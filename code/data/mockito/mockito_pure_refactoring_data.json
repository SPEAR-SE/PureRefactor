[
    {
        "type": "Extract Method",
        "description": "Extract Method\tprivate getaClass(generic Type) : Class<?> extracted from public getGenericType(field Field) : Class<?> in class org.mockito.internal.util.reflection.GenericMaster",
        "diffLocations": [
            {
                "filePath": "src/main/java/org/mockito/internal/util/reflection/GenericMaster.java",
                "startLine": 13,
                "endLine": 31,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "src/main/java/org/mockito/internal/util/reflection/GenericMaster.java",
                "startLine": 14,
                "endLine": 22,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "src/main/java/org/mockito/internal/util/reflection/GenericMaster.java",
                "startLine": 33,
                "endLine": 45,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "/**\n     * Finds the generic type (parametrized type) of the field. If the field is not generic it returns Object.class.\n     *\n     * @param field the field to inspect\n     */\n    public Class<?> getGenericType(Field field) {\n        Type generic = field.getGenericType();\n        if (generic instanceof ParameterizedType) {\n            Type actual = ((ParameterizedType) generic).getActualTypeArguments()[0];\n            if (actual instanceof Class) {\n                return (Class<?>) actual;\n            } else if (actual instanceof ParameterizedType) {\n                // in case of nested generics we don't go deep\n                return (Class<?>) ((ParameterizedType) actual).getRawType();\n            }\n        }\n\n        return Object.class;\n    }",
        "filePathBefore": "src/main/java/org/mockito/internal/util/reflection/GenericMaster.java",
        "isPureRefactoring": true,
        "commitId": "6f4eb023ac76f2d59020f59a5a8e8c602a094235",
        "packageNameBefore": "org.mockito.internal.util.reflection",
        "classNameBefore": "org.mockito.internal.util.reflection.GenericMaster",
        "methodNameBefore": "org.mockito.internal.util.reflection.GenericMaster#getGenericType",
        "invokedMethod": "methodSignature: org.mockito.internal.util.reflection.GenericMaster#getGenericType\n methodBody: public Class<?> getGenericType(Field field) {\nType generic=field.getGenericType();\nif(generic instanceof ParameterizedType){Type actual=((ParameterizedType)generic).getActualTypeArguments()[0];\nif(actual instanceof Class){return (Class<?>)actual;\n}if(actual instanceof ParameterizedType){return (Class<?>)((ParameterizedType)actual).getRawType();\n}}return Object.class;\n}",
        "classSignatureBefore": "public class GenericMaster ",
        "methodNameBeforeSet": [
            "org.mockito.internal.util.reflection.GenericMaster#getGenericType"
        ],
        "classNameBeforeSet": [
            "org.mockito.internal.util.reflection.GenericMaster"
        ],
        "classSignatureBeforeSet": [
            "public class GenericMaster "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Copyright (c) 2007 Mockito contributors\n * This program is made available under the terms of the MIT License.\n */\npackage org.mockito.internal.util.reflection;\n\nimport java.lang.reflect.Field;\nimport java.lang.reflect.ParameterizedType;\nimport java.lang.reflect.Type;\n\npublic class GenericMaster {\n\n    /**\n     * Finds the generic type (parametrized type) of the field. If the field is not generic it returns Object.class.\n     *\n     * @param field the field to inspect\n     */\n    public Class<?> getGenericType(Field field) {\n        Type generic = field.getGenericType();\n        if (generic instanceof ParameterizedType) {\n            Type actual = ((ParameterizedType) generic).getActualTypeArguments()[0];\n            if (actual instanceof Class) {\n                return (Class<?>) actual;\n            } else if (actual instanceof ParameterizedType) {\n                // in case of nested generics we don't go deep\n                return (Class<?>) ((ParameterizedType) actual).getRawType();\n            }\n        }\n\n        return Object.class;\n    }\n}\n",
        "filePathAfter": "src/main/java/org/mockito/internal/util/reflection/GenericMaster.java",
        "sourceCodeAfterForWhole": "/*\n * Copyright (c) 2007 Mockito contributors\n * This program is made available under the terms of the MIT License.\n */\npackage org.mockito.internal.util.reflection;\n\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Parameter;\nimport java.lang.reflect.ParameterizedType;\nimport java.lang.reflect.Type;\n\npublic class GenericMaster {\n\n    /**\n     * Finds the generic type (parametrized type) of the field. If the field is not generic it returns Object.class.\n     *\n     * @param field the field to inspect\n     */\n    public Class<?> getGenericType(Field field) {\n        Type generic = field.getGenericType();\n        return getaClass(generic);\n    }\n\n    /**\n     * Resolves the type (parametrized type) of the parameter. If the field is not generic it returns Object.class.\n     *\n     * @param parameter the parameter to inspect\n     */\n    public Class<?> getGenericType(Parameter parameter) {\n        return getaClass(parameter.getType());\n    }\n\n    private Class<?> getaClass(Type generic) {\n        if (generic instanceof ParameterizedType) {\n            Type actual = ((ParameterizedType) generic).getActualTypeArguments()[0];\n            if (actual instanceof Class) {\n                return (Class<?>) actual;\n            } else if (actual instanceof ParameterizedType) {\n                // in case of nested generics we don't go deep\n                return (Class<?>) ((ParameterizedType) actual).getRawType();\n            }\n        }\n\n        return Object.class;\n    }\n}\n",
        "diffSourceCodeSet": [
            "private Class<?> getaClass(Type generic) {\n        if (generic instanceof ParameterizedType) {\n            Type actual = ((ParameterizedType) generic).getActualTypeArguments()[0];\n            if (actual instanceof Class) {\n                return (Class<?>) actual;\n            } else if (actual instanceof ParameterizedType) {\n                // in case of nested generics we don't go deep\n                return (Class<?>) ((ParameterizedType) actual).getRawType();\n            }\n        }\n\n        return Object.class;\n    }"
        ],
        "invokedMethodSet": [
            "methodSignature: org.mockito.internal.util.reflection.GenericMaster#getGenericType\n methodBody: public Class<?> getGenericType(Field field) {\nType generic=field.getGenericType();\nif(generic instanceof ParameterizedType){Type actual=((ParameterizedType)generic).getActualTypeArguments()[0];\nif(actual instanceof Class){return (Class<?>)actual;\n}if(actual instanceof ParameterizedType){return (Class<?>)((ParameterizedType)actual).getRawType();\n}}return Object.class;\n}"
        ],
        "sourceCodeAfterRefactoring": "/**\n     * Finds the generic type (parametrized type) of the field. If the field is not generic it returns Object.class.\n     *\n     * @param field the field to inspect\n     */\n    public Class<?> getGenericType(Field field) {\n        Type generic = field.getGenericType();\n        return getaClass(generic);\n    }\nprivate Class<?> getaClass(Type generic) {\n        if (generic instanceof ParameterizedType) {\n            Type actual = ((ParameterizedType) generic).getActualTypeArguments()[0];\n            if (actual instanceof Class) {\n                return (Class<?>) actual;\n            } else if (actual instanceof ParameterizedType) {\n                // in case of nested generics we don't go deep\n                return (Class<?>) ((ParameterizedType) actual).getRawType();\n            }\n        }\n\n        return Object.class;\n    }",
        "diffSourceCode": "-   13:     /**\n-   14:      * Finds the generic type (parametrized type) of the field. If the field is not generic it returns Object.class.\n-   15:      *\n-   16:      * @param field the field to inspect\n-   17:      */\n-   18:     public Class<?> getGenericType(Field field) {\n-   19:         Type generic = field.getGenericType();\n-   20:         if (generic instanceof ParameterizedType) {\n-   21:             Type actual = ((ParameterizedType) generic).getActualTypeArguments()[0];\n-   22:             if (actual instanceof Class) {\n-   23:                 return (Class<?>) actual;\n-   24:             } else if (actual instanceof ParameterizedType) {\n-   25:                 // in case of nested generics we don't go deep\n-   26:                 return (Class<?>) ((ParameterizedType) actual).getRawType();\n-   27:             }\n-   28:         }\n-   29: \n-   30:         return Object.class;\n+   13: \n+   14:     /**\n+   15:      * Finds the generic type (parametrized type) of the field. If the field is not generic it returns Object.class.\n+   16:      *\n+   17:      * @param field the field to inspect\n+   18:      */\n+   19:     public Class<?> getGenericType(Field field) {\n+   20:         Type generic = field.getGenericType();\n+   21:         return getaClass(generic);\n+   22:     }\n+   23: \n+   24:     /**\n+   25:      * Resolves the type (parametrized type) of the parameter. If the field is not generic it returns Object.class.\n+   26:      *\n+   27:      * @param parameter the parameter to inspect\n+   28:      */\n+   29:     public Class<?> getGenericType(Parameter parameter) {\n+   30:         return getaClass(parameter.getType());\n    31:     }\n+   33:     private Class<?> getaClass(Type generic) {\n+   34:         if (generic instanceof ParameterizedType) {\n+   35:             Type actual = ((ParameterizedType) generic).getActualTypeArguments()[0];\n+   36:             if (actual instanceof Class) {\n+   37:                 return (Class<?>) actual;\n+   38:             } else if (actual instanceof ParameterizedType) {\n+   39:                 // in case of nested generics we don't go deep\n+   40:                 return (Class<?>) ((ParameterizedType) actual).getRawType();\n+   41:             }\n+   42:         }\n+   43: \n+   44:         return Object.class;\n+   45:     }\n",
        "uniqueId": "6f4eb023ac76f2d59020f59a5a8e8c602a094235_13_31_33_45_14_22",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 0,
                "covered": 28
            },
            "BRANCH": {
                "missed": 0,
                "covered": 6
            },
            "LINE": {
                "missed": 0,
                "covered": 8
            },
            "COMPLEXITY": {
                "missed": 0,
                "covered": 4
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 17
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tpackage returnCommonEmptyValueFor(type Class<?>) : Object extracted from package returnValueFor(type Class<?>) : Object in class org.mockito.internal.stubbing.defaultanswers.ReturnsEmptyValues",
        "diffLocations": [
            {
                "filePath": "src/main/java/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java",
                "startLine": 106,
                "endLine": 166,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "src/main/java/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java",
                "startLine": 106,
                "endLine": 158,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "src/main/java/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java",
                "startLine": 160,
                "endLine": 177,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "Object returnValueFor(Class<?> type) {\n        if (Primitives.isPrimitiveOrWrapper(type)) {\n            return Primitives.defaultValue(type);\n            // new instances are used instead of Collections.emptyList(), etc.\n            // to avoid UnsupportedOperationException if code under test modifies returned\n            // collection\n        } else if (type == Iterable.class) {\n            return new ArrayList<>(0);\n        } else if (type == Collection.class) {\n            return new LinkedList<>();\n        } else if (type == Set.class) {\n            return new HashSet<>();\n        } else if (type == HashSet.class) {\n            return new HashSet<>();\n        } else if (type == SortedSet.class) {\n            return new TreeSet<>();\n        } else if (type == TreeSet.class) {\n            return new TreeSet<>();\n        } else if (type == LinkedHashSet.class) {\n            return new LinkedHashSet<>();\n        } else if (type == List.class) {\n            return new LinkedList<>();\n        } else if (type == LinkedList.class) {\n            return new LinkedList<>();\n        } else if (type == ArrayList.class) {\n            return new ArrayList<>();\n        } else if (type == Map.class) {\n            return new HashMap<>();\n        } else if (type == HashMap.class) {\n            return new HashMap<>();\n        } else if (type == SortedMap.class) {\n            return new TreeMap<>();\n        } else if (type == TreeMap.class) {\n            return new TreeMap<>();\n        } else if (type == LinkedHashMap.class) {\n            return new LinkedHashMap<>();\n        } else if (type == Optional.class) {\n            return Optional.empty();\n        } else if (type == OptionalDouble.class) {\n            return OptionalDouble.empty();\n        } else if (type == OptionalInt.class) {\n            return OptionalInt.empty();\n        } else if (type == OptionalLong.class) {\n            return OptionalLong.empty();\n        } else if (type == Stream.class) {\n            return Stream.empty();\n        } else if (type == DoubleStream.class) {\n            return DoubleStream.empty();\n        } else if (type == IntStream.class) {\n            return IntStream.empty();\n        } else if (type == LongStream.class) {\n            return LongStream.empty();\n        } else if (type == Duration.class) {\n            return Duration.ZERO;\n        } else if (type == Period.class) {\n            return Period.ZERO;\n        }\n\n        // Let's not care about the rest of collections.\n        return null;\n    }",
        "filePathBefore": "src/main/java/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java",
        "isPureRefactoring": true,
        "commitId": "63d1cd405066886c6fb041ecc1ae502fe4b8a782",
        "packageNameBefore": "org.mockito.internal.stubbing.defaultanswers",
        "classNameBefore": "org.mockito.internal.stubbing.defaultanswers.ReturnsEmptyValues",
        "methodNameBefore": "org.mockito.internal.stubbing.defaultanswers.ReturnsEmptyValues#returnValueFor",
        "classSignatureBefore": "public class ReturnsEmptyValues implements Answer<Object>, Serializable ",
        "methodNameBeforeSet": [
            "org.mockito.internal.stubbing.defaultanswers.ReturnsEmptyValues#returnValueFor"
        ],
        "classNameBeforeSet": [
            "org.mockito.internal.stubbing.defaultanswers.ReturnsEmptyValues"
        ],
        "classSignatureBeforeSet": [
            "public class ReturnsEmptyValues implements Answer<Object>, Serializable "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Changes are within the Extract Method refactoring mechanics Severe changes",
                "description": "Return expression has been added within the Extract Method mechanics - with non-mapped leaves",
                "mappingState": 2
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Copyright (c) 2016 Mockito contributors\n * This program is made available under the terms of the MIT License.\n */\npackage org.mockito.internal.stubbing.defaultanswers;\n\nimport static org.mockito.internal.util.ObjectMethodsGuru.isCompareToMethod;\nimport static org.mockito.internal.util.ObjectMethodsGuru.isToStringMethod;\n\nimport java.io.Serializable;\nimport java.time.Duration;\nimport java.time.Period;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedHashMap;\nimport java.util.LinkedHashSet;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.OptionalDouble;\nimport java.util.OptionalInt;\nimport java.util.OptionalLong;\nimport java.util.Set;\nimport java.util.SortedMap;\nimport java.util.SortedSet;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\nimport java.util.stream.DoubleStream;\nimport java.util.stream.IntStream;\nimport java.util.stream.LongStream;\nimport java.util.stream.Stream;\n\nimport org.mockito.internal.util.MockUtil;\nimport org.mockito.internal.util.Primitives;\nimport org.mockito.invocation.InvocationOnMock;\nimport org.mockito.mock.MockName;\nimport org.mockito.stubbing.Answer;\n\n/**\n * Default answer of every Mockito mock.\n * <ul>\n * <li>\n * Returns appropriate primitive for primitive-returning methods\n * </li>\n * <li>\n * Returns consistent values for primitive wrapper classes (e.g. int-returning method returns 0 <b>and</b> Integer-returning method returns 0, too)\n * </li>\n * <li>\n * Returns empty collection for collection-returning methods (works for most commonly used collection types)\n * </li>\n * <li>\n * Returns description of mock for toString() method\n * </li>\n * <li>\n * Returns zero if references are equals otherwise non-zero for Comparable#compareTo(T other) method (see issue 184)\n * </li>\n * <li>\n * Returns an {@code java.util.Optional#empty() empty Optional} for Optional. Similarly for primitive optional variants.\n * </li>\n * <li>\n * Returns an {@code java.util.stream.Stream#empty() empty Stream} for Stream. Similarly for primitive stream variants.\n * </li>\n * <li>\n * Returns an {@code java.time.Duration.ZERO zero Duration} for empty Duration and {@code java.time.Period.ZERO zero Period} for empty Period.\n * </li>\n * <li>\n * Returns null for everything else\n * </li>\n * </ul>\n */\npublic class ReturnsEmptyValues implements Answer<Object>, Serializable {\n\n    private static final long serialVersionUID = 1998191268711234347L;\n\n    /* (non-Javadoc)\n     * @see org.mockito.stubbing.Answer#answer(org.mockito.invocation.InvocationOnMock)\n     */\n    @Override\n    public Object answer(InvocationOnMock invocation) {\n        if (isToStringMethod(invocation.getMethod())) {\n            Object mock = invocation.getMock();\n            MockName name = MockUtil.getMockName(mock);\n            if (name.isDefault()) {\n                return \"Mock for \"\n                        + MockUtil.getMockSettings(mock).getTypeToMock().getSimpleName()\n                        + \", hashCode: \"\n                        + mock.hashCode();\n            } else {\n                return name.toString();\n            }\n        } else if (isCompareToMethod(invocation.getMethod())) {\n            // see issue 184.\n            // mocks by default should return 0 if references are the same, otherwise some other\n            // value because they are not the same. Hence we return 1 (anything but 0 is good).\n            // Only for compareTo() method by the Comparable interface\n            return invocation.getMock() == invocation.getArgument(0) ? 0 : 1;\n        }\n\n        Class<?> returnType = invocation.getMethod().getReturnType();\n        return returnValueFor(returnType);\n    }\n\n    Object returnValueFor(Class<?> type) {\n        if (Primitives.isPrimitiveOrWrapper(type)) {\n            return Primitives.defaultValue(type);\n            // new instances are used instead of Collections.emptyList(), etc.\n            // to avoid UnsupportedOperationException if code under test modifies returned\n            // collection\n        } else if (type == Iterable.class) {\n            return new ArrayList<>(0);\n        } else if (type == Collection.class) {\n            return new LinkedList<>();\n        } else if (type == Set.class) {\n            return new HashSet<>();\n        } else if (type == HashSet.class) {\n            return new HashSet<>();\n        } else if (type == SortedSet.class) {\n            return new TreeSet<>();\n        } else if (type == TreeSet.class) {\n            return new TreeSet<>();\n        } else if (type == LinkedHashSet.class) {\n            return new LinkedHashSet<>();\n        } else if (type == List.class) {\n            return new LinkedList<>();\n        } else if (type == LinkedList.class) {\n            return new LinkedList<>();\n        } else if (type == ArrayList.class) {\n            return new ArrayList<>();\n        } else if (type == Map.class) {\n            return new HashMap<>();\n        } else if (type == HashMap.class) {\n            return new HashMap<>();\n        } else if (type == SortedMap.class) {\n            return new TreeMap<>();\n        } else if (type == TreeMap.class) {\n            return new TreeMap<>();\n        } else if (type == LinkedHashMap.class) {\n            return new LinkedHashMap<>();\n        } else if (type == Optional.class) {\n            return Optional.empty();\n        } else if (type == OptionalDouble.class) {\n            return OptionalDouble.empty();\n        } else if (type == OptionalInt.class) {\n            return OptionalInt.empty();\n        } else if (type == OptionalLong.class) {\n            return OptionalLong.empty();\n        } else if (type == Stream.class) {\n            return Stream.empty();\n        } else if (type == DoubleStream.class) {\n            return DoubleStream.empty();\n        } else if (type == IntStream.class) {\n            return IntStream.empty();\n        } else if (type == LongStream.class) {\n            return LongStream.empty();\n        } else if (type == Duration.class) {\n            return Duration.ZERO;\n        } else if (type == Period.class) {\n            return Period.ZERO;\n        }\n\n        // Let's not care about the rest of collections.\n        return null;\n    }\n}\n",
        "filePathAfter": "src/main/java/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java",
        "sourceCodeAfterForWhole": "/*\n * Copyright (c) 2016 Mockito contributors\n * This program is made available under the terms of the MIT License.\n */\npackage org.mockito.internal.stubbing.defaultanswers;\n\nimport static org.mockito.internal.util.ObjectMethodsGuru.isCompareToMethod;\nimport static org.mockito.internal.util.ObjectMethodsGuru.isToStringMethod;\n\nimport java.io.Serializable;\nimport java.time.Duration;\nimport java.time.Period;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedHashMap;\nimport java.util.LinkedHashSet;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.OptionalDouble;\nimport java.util.OptionalInt;\nimport java.util.OptionalLong;\nimport java.util.Set;\nimport java.util.SortedMap;\nimport java.util.SortedSet;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\nimport java.util.stream.DoubleStream;\nimport java.util.stream.IntStream;\nimport java.util.stream.LongStream;\nimport java.util.stream.Stream;\n\nimport org.mockito.internal.util.MockUtil;\nimport org.mockito.internal.util.Primitives;\nimport org.mockito.invocation.InvocationOnMock;\nimport org.mockito.mock.MockName;\nimport org.mockito.stubbing.Answer;\n\n/**\n * Default answer of every Mockito mock.\n * <ul>\n * <li>\n * Returns appropriate primitive for primitive-returning methods\n * </li>\n * <li>\n * Returns consistent values for primitive wrapper classes (e.g. int-returning method returns 0 <b>and</b> Integer-returning method returns 0, too)\n * </li>\n * <li>\n * Returns empty collection for collection-returning methods (works for most commonly used collection types)\n * </li>\n * <li>\n * Returns description of mock for toString() method\n * </li>\n * <li>\n * Returns zero if references are equals otherwise non-zero for Comparable#compareTo(T other) method (see issue 184)\n * </li>\n * <li>\n * Returns an {@code java.util.Optional#empty() empty Optional} for Optional. Similarly for primitive optional variants.\n * </li>\n * <li>\n * Returns an {@code java.util.stream.Stream#empty() empty Stream} for Stream. Similarly for primitive stream variants.\n * </li>\n * <li>\n * Returns an {@code java.time.Duration.ZERO zero Duration} for empty Duration and {@code java.time.Period.ZERO zero Period} for empty Period.\n * </li>\n * <li>\n * Returns null for everything else\n * </li>\n * </ul>\n */\npublic class ReturnsEmptyValues implements Answer<Object>, Serializable {\n\n    private static final long serialVersionUID = 1998191268711234347L;\n\n    /* (non-Javadoc)\n     * @see org.mockito.stubbing.Answer#answer(org.mockito.invocation.InvocationOnMock)\n     */\n    @Override\n    public Object answer(InvocationOnMock invocation) {\n        if (isToStringMethod(invocation.getMethod())) {\n            Object mock = invocation.getMock();\n            MockName name = MockUtil.getMockName(mock);\n            if (name.isDefault()) {\n                return \"Mock for \"\n                        + MockUtil.getMockSettings(mock).getTypeToMock().getSimpleName()\n                        + \", hashCode: \"\n                        + mock.hashCode();\n            } else {\n                return name.toString();\n            }\n        } else if (isCompareToMethod(invocation.getMethod())) {\n            // see issue 184.\n            // mocks by default should return 0 if references are the same, otherwise some other\n            // value because they are not the same. Hence we return 1 (anything but 0 is good).\n            // Only for compareTo() method by the Comparable interface\n            return invocation.getMock() == invocation.getArgument(0) ? 0 : 1;\n        }\n\n        Class<?> returnType = invocation.getMethod().getReturnType();\n        return returnValueFor(returnType);\n    }\n\n    Object returnValueFor(Class<?> type) {\n        if (Primitives.isPrimitiveOrWrapper(type)) {\n            return Primitives.defaultValue(type);\n            // new instances are used instead of Collections.emptyList(), etc.\n            // to avoid UnsupportedOperationException if code under test modifies returned\n            // collection\n        } else if (type == Iterable.class) {\n            return new ArrayList<>(0);\n        } else if (type == Collection.class) {\n            return new LinkedList<>();\n        } else if (type == Set.class) {\n            return new HashSet<>();\n        } else if (type == HashSet.class) {\n            return new HashSet<>();\n        } else if (type == SortedSet.class) {\n            return new TreeSet<>();\n        } else if (type == TreeSet.class) {\n            return new TreeSet<>();\n        } else if (type == LinkedHashSet.class) {\n            return new LinkedHashSet<>();\n        } else if (type == List.class) {\n            return new LinkedList<>();\n        } else if (type == LinkedList.class) {\n            return new LinkedList<>();\n        } else if (type == ArrayList.class) {\n            return new ArrayList<>();\n        } else if (type == Map.class) {\n            return new HashMap<>();\n        } else if (type == HashMap.class) {\n            return new HashMap<>();\n        } else if (type == SortedMap.class) {\n            return new TreeMap<>();\n        } else if (type == TreeMap.class) {\n            return new TreeMap<>();\n        } else if (type == LinkedHashMap.class) {\n            return new LinkedHashMap<>();\n        } else if (type == Stream.class) {\n            return Stream.empty();\n        } else if (type == DoubleStream.class) {\n            return DoubleStream.empty();\n        } else if (type == IntStream.class) {\n            return IntStream.empty();\n        } else if (type == LongStream.class) {\n            return LongStream.empty();\n        } else if (type == Duration.class) {\n            return Duration.ZERO;\n        } else if (type == Period.class) {\n            return Period.ZERO;\n        }\n        // Let's not care about the rest of collections.\n\n        return returnCommonEmptyValueFor(type);\n    }\n\n    /**\n     * Returns empty values for common known types, shared between {@link ReturnsEmptyValues} and {@link ReturnsDeepStubs}.\n     *\n     * @param type the type to check\n     * @return the empty value, or {@code null}\n     */\n    static Object returnCommonEmptyValueFor(Class<?> type) {\n        if (type == Optional.class) {\n            return Optional.empty();\n        } else if (type == OptionalDouble.class) {\n            return OptionalDouble.empty();\n        } else if (type == OptionalInt.class) {\n            return OptionalInt.empty();\n        } else if (type == OptionalLong.class) {\n            return OptionalLong.empty();\n        }\n        return null;\n    }\n}\n",
        "diffSourceCodeSet": [
            "/**\n     * Returns empty values for common known types, shared between {@link ReturnsEmptyValues} and {@link ReturnsDeepStubs}.\n     *\n     * @param type the type to check\n     * @return the empty value, or {@code null}\n     */\n    static Object returnCommonEmptyValueFor(Class<?> type) {\n        if (type == Optional.class) {\n            return Optional.empty();\n        } else if (type == OptionalDouble.class) {\n            return OptionalDouble.empty();\n        } else if (type == OptionalInt.class) {\n            return OptionalInt.empty();\n        } else if (type == OptionalLong.class) {\n            return OptionalLong.empty();\n        }\n        return null;\n    }"
        ],
        "invokedMethodSet": [],
        "sourceCodeAfterRefactoring": "Object returnValueFor(Class<?> type) {\n        if (Primitives.isPrimitiveOrWrapper(type)) {\n            return Primitives.defaultValue(type);\n            // new instances are used instead of Collections.emptyList(), etc.\n            // to avoid UnsupportedOperationException if code under test modifies returned\n            // collection\n        } else if (type == Iterable.class) {\n            return new ArrayList<>(0);\n        } else if (type == Collection.class) {\n            return new LinkedList<>();\n        } else if (type == Set.class) {\n            return new HashSet<>();\n        } else if (type == HashSet.class) {\n            return new HashSet<>();\n        } else if (type == SortedSet.class) {\n            return new TreeSet<>();\n        } else if (type == TreeSet.class) {\n            return new TreeSet<>();\n        } else if (type == LinkedHashSet.class) {\n            return new LinkedHashSet<>();\n        } else if (type == List.class) {\n            return new LinkedList<>();\n        } else if (type == LinkedList.class) {\n            return new LinkedList<>();\n        } else if (type == ArrayList.class) {\n            return new ArrayList<>();\n        } else if (type == Map.class) {\n            return new HashMap<>();\n        } else if (type == HashMap.class) {\n            return new HashMap<>();\n        } else if (type == SortedMap.class) {\n            return new TreeMap<>();\n        } else if (type == TreeMap.class) {\n            return new TreeMap<>();\n        } else if (type == LinkedHashMap.class) {\n            return new LinkedHashMap<>();\n        } else if (type == Stream.class) {\n            return Stream.empty();\n        } else if (type == DoubleStream.class) {\n            return DoubleStream.empty();\n        } else if (type == IntStream.class) {\n            return IntStream.empty();\n        } else if (type == LongStream.class) {\n            return LongStream.empty();\n        } else if (type == Duration.class) {\n            return Duration.ZERO;\n        } else if (type == Period.class) {\n            return Period.ZERO;\n        }\n        // Let's not care about the rest of collections.\n\n        return returnCommonEmptyValueFor(type);\n    }\n/**\n     * Returns empty values for common known types, shared between {@link ReturnsEmptyValues} and {@link ReturnsDeepStubs}.\n     *\n     * @param type the type to check\n     * @return the empty value, or {@code null}\n     */\n    static Object returnCommonEmptyValueFor(Class<?> type) {\n        if (type == Optional.class) {\n            return Optional.empty();\n        } else if (type == OptionalDouble.class) {\n            return OptionalDouble.empty();\n        } else if (type == OptionalInt.class) {\n            return OptionalInt.empty();\n        } else if (type == OptionalLong.class) {\n            return OptionalLong.empty();\n        }\n        return null;\n    }",
        "diffSourceCode": "   106:     Object returnValueFor(Class<?> type) {\n   107:         if (Primitives.isPrimitiveOrWrapper(type)) {\n   108:             return Primitives.defaultValue(type);\n   109:             // new instances are used instead of Collections.emptyList(), etc.\n   110:             // to avoid UnsupportedOperationException if code under test modifies returned\n   111:             // collection\n   112:         } else if (type == Iterable.class) {\n   113:             return new ArrayList<>(0);\n   114:         } else if (type == Collection.class) {\n   115:             return new LinkedList<>();\n   116:         } else if (type == Set.class) {\n   117:             return new HashSet<>();\n   118:         } else if (type == HashSet.class) {\n   119:             return new HashSet<>();\n   120:         } else if (type == SortedSet.class) {\n   121:             return new TreeSet<>();\n   122:         } else if (type == TreeSet.class) {\n   123:             return new TreeSet<>();\n   124:         } else if (type == LinkedHashSet.class) {\n   125:             return new LinkedHashSet<>();\n   126:         } else if (type == List.class) {\n   127:             return new LinkedList<>();\n   128:         } else if (type == LinkedList.class) {\n   129:             return new LinkedList<>();\n   130:         } else if (type == ArrayList.class) {\n   131:             return new ArrayList<>();\n   132:         } else if (type == Map.class) {\n   133:             return new HashMap<>();\n   134:         } else if (type == HashMap.class) {\n   135:             return new HashMap<>();\n   136:         } else if (type == SortedMap.class) {\n   137:             return new TreeMap<>();\n   138:         } else if (type == TreeMap.class) {\n   139:             return new TreeMap<>();\n   140:         } else if (type == LinkedHashMap.class) {\n   141:             return new LinkedHashMap<>();\n-  142:         } else if (type == Optional.class) {\n-  143:             return Optional.empty();\n-  144:         } else if (type == OptionalDouble.class) {\n-  145:             return OptionalDouble.empty();\n-  146:         } else if (type == OptionalInt.class) {\n-  147:             return OptionalInt.empty();\n-  148:         } else if (type == OptionalLong.class) {\n-  149:             return OptionalLong.empty();\n-  150:         } else if (type == Stream.class) {\n-  151:             return Stream.empty();\n-  152:         } else if (type == DoubleStream.class) {\n-  153:             return DoubleStream.empty();\n-  154:         } else if (type == IntStream.class) {\n-  155:             return IntStream.empty();\n-  156:         } else if (type == LongStream.class) {\n-  157:             return LongStream.empty();\n-  158:         } else if (type == Duration.class) {\n-  159:             return Duration.ZERO;\n-  160:         } else if (type == Period.class) {\n-  161:             return Period.ZERO;\n-  162:         }\n-  163: \n-  164:         // Let's not care about the rest of collections.\n-  165:         return null;\n-  166:     }\n-  167: }\n+  142:         } else if (type == Stream.class) {\n+  143:             return Stream.empty();\n+  144:         } else if (type == DoubleStream.class) {\n+  145:             return DoubleStream.empty();\n+  146:         } else if (type == IntStream.class) {\n+  147:             return IntStream.empty();\n+  148:         } else if (type == LongStream.class) {\n+  149:             return LongStream.empty();\n+  150:         } else if (type == Duration.class) {\n+  151:             return Duration.ZERO;\n+  152:         } else if (type == Period.class) {\n+  153:             return Period.ZERO;\n+  154:         }\n+  155:         // Let's not care about the rest of collections.\n+  156: \n+  157:         return returnCommonEmptyValueFor(type);\n+  158:     }\n+  159: \n+  160:     /**\n+  161:      * Returns empty values for common known types, shared between {@link ReturnsEmptyValues} and {@link ReturnsDeepStubs}.\n+  162:      *\n+  163:      * @param type the type to check\n+  164:      * @return the empty value, or {@code null}\n+  165:      */\n+  166:     static Object returnCommonEmptyValueFor(Class<?> type) {\n+  167:         if (type == Optional.class) {\n+  168:             return Optional.empty();\n+  169:         } else if (type == OptionalDouble.class) {\n+  170:             return OptionalDouble.empty();\n+  171:         } else if (type == OptionalInt.class) {\n+  172:             return OptionalInt.empty();\n+  173:         } else if (type == OptionalLong.class) {\n+  174:             return OptionalLong.empty();\n+  175:         }\n+  176:         return null;\n+  177:     }\n",
        "uniqueId": "63d1cd405066886c6fb041ecc1ae502fe4b8a782_106_166_160_177_106_158",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 2,
                "covered": 162
            },
            "BRANCH": {
                "missed": 1,
                "covered": 51
            },
            "LINE": {
                "missed": 1,
                "covered": 52
            },
            "COMPLEXITY": {
                "missed": 1,
                "covered": 26
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 17
    },
    {
        "type": "Extract And Move Method",
        "description": "Extract And Move Method\tpublic create(inline boolean) : Location extracted from public create(inline boolean) : Location in class org.mockito.internal.debugging.LocationFactory & moved to class org.mockito.internal.debugging.LocationFactory.DefaultLocationFactory",
        "diffLocations": [
            {
                "filePath": "src/main/java/org/mockito/internal/debugging/LocationFactory.java",
                "startLine": 16,
                "endLine": 18,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "src/main/java/org/mockito/internal/debugging/LocationFactory.java",
                "startLine": 18,
                "endLine": 20,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "src/main/java/org/mockito/internal/debugging/LocationFactory.java",
                "startLine": 46,
                "endLine": 49,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "public static Location create(boolean inline) {\n        return new LocationImpl(inline);\n    }",
        "filePathBefore": "src/main/java/org/mockito/internal/debugging/LocationFactory.java",
        "isPureRefactoring": true,
        "commitId": "50b21cf68b400a29369de58b9286d29e368212a7",
        "packageNameBefore": "org.mockito.internal.debugging",
        "classNameBefore": "org.mockito.internal.debugging.LocationFactory",
        "methodNameBefore": "org.mockito.internal.debugging.LocationFactory#create",
        "classSignatureBefore": "public final class LocationFactory ",
        "methodNameBeforeSet": [
            "org.mockito.internal.debugging.LocationFactory#create"
        ],
        "classNameBeforeSet": [
            "org.mockito.internal.debugging.LocationFactory"
        ],
        "classSignatureBeforeSet": [
            "public final class LocationFactory "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Copyright (c) 2007 Mockito contributors\n * This program is made available under the terms of the MIT License.\n */\npackage org.mockito.internal.debugging;\n\nimport org.mockito.invocation.Location;\n\npublic final class LocationFactory {\n    private LocationFactory() {}\n\n    public static Location create() {\n        return create(false);\n    }\n\n    public static Location create(boolean inline) {\n        return new LocationImpl(inline);\n    }\n}\n",
        "filePathAfter": "src/main/java/org/mockito/internal/debugging/LocationFactory.java",
        "sourceCodeAfterForWhole": "/*\n * Copyright (c) 2007 Mockito contributors\n * This program is made available under the terms of the MIT License.\n */\npackage org.mockito.internal.debugging;\n\nimport org.mockito.invocation.Location;\n\npublic final class LocationFactory {\n    private static final Factory factory = createLocationFactory();\n\n    private LocationFactory() {}\n\n    public static Location create() {\n        return create(false);\n    }\n\n    public static Location create(boolean inline) {\n        return factory.create(inline);\n    }\n\n    private interface Factory {\n        Location create(boolean inline);\n    }\n\n    private static Factory createLocationFactory() {\n        try {\n            // On some platforms, like Android, the StackWalker APIs may not be\n            // available, in this case we have to fallback to Java 8 style of stack\n            // traversing.\n            Class.forName(\"java.lang.StackWalker\");\n            return new DefaultLocationFactory();\n        } catch (ClassNotFoundException e) {\n            return new Java8LocationFactory();\n        }\n    }\n\n    private static final class Java8LocationFactory implements Factory {\n        @Override\n        public Location create(boolean inline) {\n            return new Java8LocationImpl(new Throwable(), inline);\n        }\n    }\n\n    private static final class DefaultLocationFactory implements Factory {\n        @Override\n        public Location create(boolean inline) {\n            return new LocationImpl(inline);\n        }\n    }\n}\n",
        "diffSourceCodeSet": [
            "@Override\n        public Location create(boolean inline) {\n            return new LocationImpl(inline);\n        }"
        ],
        "invokedMethodSet": [],
        "sourceCodeAfterRefactoring": "public static Location create(boolean inline) {\n        return factory.create(inline);\n    }\n@Override\n        public Location create(boolean inline) {\n            return new LocationImpl(inline);\n        }",
        "diffSourceCode": "-   16:     public static Location create(boolean inline) {\n-   17:         return new LocationImpl(inline);\n-   18:     }\n-   19: }\n+   16:     }\n+   17: \n+   18:     public static Location create(boolean inline) {\n+   19:         return factory.create(inline);\n+   20:     }\n+   46:         @Override\n+   47:         public Location create(boolean inline) {\n+   48:             return new LocationImpl(inline);\n+   49:         }\n",
        "uniqueId": "50b21cf68b400a29369de58b9286d29e368212a7_16_18_46_49_18_20",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 0,
                "covered": 5
            },
            "LINE": {
                "missed": 0,
                "covered": 1
            },
            "COMPLEXITY": {
                "missed": 0,
                "covered": 1
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 17
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprivate reportMatcher(matcher HamcrestArgumentMatcher<T>) : void extracted from private reportMatcher(matcher Matcher<T>) : void in class org.mockito.hamcrest.MockitoHamcrest",
        "diffLocations": [
            {
                "filePath": "src/main/java/org/mockito/hamcrest/MockitoHamcrest.java",
                "startLine": 177,
                "endLine": 181,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "src/main/java/org/mockito/hamcrest/MockitoHamcrest.java",
                "startLine": 215,
                "endLine": 217,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "src/main/java/org/mockito/hamcrest/MockitoHamcrest.java",
                "startLine": 223,
                "endLine": 225,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "private static <T> void reportMatcher(Matcher<T> matcher) {\n        mockingProgress()\n                .getArgumentMatcherStorage()\n                .reportMatcher(new HamcrestArgumentMatcher<T>(matcher));\n    }",
        "filePathBefore": "src/main/java/org/mockito/hamcrest/MockitoHamcrest.java",
        "isPureRefactoring": true,
        "commitId": "064fe9028993a11ccf0ae12b5975b96baffcf305",
        "packageNameBefore": "org.mockito.hamcrest",
        "classNameBefore": "org.mockito.hamcrest.MockitoHamcrest",
        "methodNameBefore": "org.mockito.hamcrest.MockitoHamcrest#reportMatcher",
        "invokedMethod": "methodSignature: org.mockito.hamcrest.MockitoHamcrest#reportMatcher\n methodBody: private static <T> void reportMatcher(Matcher<T> matcher) {\nmockingProgress().getArgumentMatcherStorage().reportMatcher(new HamcrestArgumentMatcher<T>(matcher));\n}\nmethodSignature: org.mockito.ArgumentMatchers#reportMatcher\n methodBody: private static void reportMatcher(ArgumentMatcher<?> matcher) {\nmockingProgress().getArgumentMatcherStorage().reportMatcher(matcher);\n}",
        "classSignatureBefore": "public final class MockitoHamcrest ",
        "methodNameBeforeSet": [
            "org.mockito.hamcrest.MockitoHamcrest#reportMatcher"
        ],
        "classNameBeforeSet": [
            "org.mockito.hamcrest.MockitoHamcrest"
        ],
        "classSignatureBeforeSet": [
            "public final class MockitoHamcrest "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Changes are within the Extract Method refactoring mechanics",
                "description": "All replacements have been justified - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Copyright (c) 2016 Mockito contributors\n * This program is made available under the terms of the MIT License.\n */\npackage org.mockito.hamcrest;\n\nimport static org.mockito.internal.hamcrest.MatcherGenericTypeExtractor.genericTypeOfMatcher;\nimport static org.mockito.internal.progress.ThreadSafeMockingProgress.mockingProgress;\nimport static org.mockito.internal.util.Primitives.defaultValue;\n\nimport org.hamcrest.Matcher;\nimport org.mockito.ArgumentMatcher;\nimport org.mockito.internal.hamcrest.HamcrestArgumentMatcher;\n\n/**\n * Allows matching arguments with hamcrest matchers.\n * <b>Requires</b> <a href=\"http://hamcrest.org/JavaHamcrest/\">hamcrest</a> on classpath,\n * Mockito <b>does not</b> depend on hamcrest!\n * Note the <b>NullPointerException</b> auto-unboxing caveat described below.\n * <p/>\n * Before implementing or reusing an existing hamcrest matcher please read\n * how to deal with sophisticated argument matching in {@link ArgumentMatcher}.\n * <p/>\n * Mockito 2.1.0 was decoupled from Hamcrest to avoid version incompatibilities\n * that have impacted our users in past. Mockito offers a dedicated API to match arguments\n * via {@link ArgumentMatcher}.\n * Hamcrest integration is provided so that users can take advantage of existing Hamcrest matchers.\n * <p/>\n * Example:\n * <pre>\n *     import static org.mockito.hamcrest.MockitoHamcrest.argThat;\n *\n *     //stubbing\n *     when(mock.giveMe(argThat(new MyHamcrestMatcher())));\n *\n *     //verification\n *     verify(mock).giveMe(argThat(new MyHamcrestMatcher()));\n * </pre>\n * <b>NullPointerException</b> auto-unboxing caveat.\n * In rare cases when matching primitive parameter types you <b>*must*</b> use relevant intThat(), floatThat(), etc. method.\n * This way you will avoid <code>NullPointerException</code> during auto-unboxing.\n * Due to how java works we don't really have a clean way of detecting this scenario and protecting the user from this problem.\n * Hopefully, the javadoc describes the problem and solution well.\n * If you have an idea how to fix the problem, let us know via the mailing list or the issue tracker.\n *\n * @since 2.1.0\n */\npublic final class MockitoHamcrest {\n\n    /**\n     * Allows matching arguments with hamcrest matchers.\n     * <p/>\n     * See examples in javadoc for {@link MockitoHamcrest} class\n     *\n     * @param matcher decides whether argument matches\n     * @return <code>null</code> or default value for primitive (0, false, etc.)\n     * @since 2.1.0\n     */\n    @SuppressWarnings(\"unchecked\")\n    public static <T> T argThat(Matcher<T> matcher) {\n        reportMatcher(matcher);\n        return (T) defaultValue(genericTypeOfMatcher(matcher.getClass()));\n    }\n\n    /**\n     * Enables integrating hamcrest matchers that match primitive <code>char</code> arguments.\n     * Note that {@link #argThat} will not work with primitive <code>char</code> matchers due to <code>NullPointerException</code> auto-unboxing caveat.\n     * <p/>\n     * See examples in javadoc for {@link MockitoHamcrest} class\n     *\n     * @param matcher decides whether argument matches\n     * @return <code>0</code>.\n     */\n    public static char charThat(Matcher<Character> matcher) {\n        reportMatcher(matcher);\n        return 0;\n    }\n\n    /**\n     * Enables integrating hamcrest matchers that match primitive <code>boolean</code> arguments.\n     * Note that {@link #argThat} will not work with primitive <code>boolean</code> matchers due to <code>NullPointerException</code> auto-unboxing caveat.\n     * <p/>\n     * See examples in javadoc for {@link MockitoHamcrest} class\n     *\n     * @param matcher decides whether argument matches\n     * @return <code>false</code>.\n     */\n    public static boolean booleanThat(Matcher<Boolean> matcher) {\n        reportMatcher(matcher);\n        return false;\n    }\n\n    /**\n     * Enables integrating hamcrest matchers that match primitive <code>byte</code> arguments.\n     * Note that {@link #argThat} will not work with primitive <code>byte</code> matchers due to <code>NullPointerException</code> auto-unboxing caveat.\n     * <p/>\n     * * See examples in javadoc for {@link MockitoHamcrest} class\n     *\n     * @param matcher decides whether argument matches\n     * @return <code>0</code>.\n     */\n    public static byte byteThat(Matcher<Byte> matcher) {\n        reportMatcher(matcher);\n        return 0;\n    }\n\n    /**\n     * Enables integrating hamcrest matchers that match primitive <code>short</code> arguments.\n     * Note that {@link #argThat} will not work with primitive <code>short</code> matchers due to <code>NullPointerException</code> auto-unboxing caveat.\n     * <p/>\n     * * See examples in javadoc for {@link MockitoHamcrest} class\n     *\n     * @param matcher decides whether argument matches\n     * @return <code>0</code>.\n     */\n    public static short shortThat(Matcher<Short> matcher) {\n        reportMatcher(matcher);\n        return 0;\n    }\n\n    /**\n     * Enables integrating hamcrest matchers that match primitive <code>int</code> arguments.\n     * Note that {@link #argThat} will not work with primitive <code>int</code> matchers due to <code>NullPointerException</code> auto-unboxing caveat.\n     * <p/>\n     * * See examples in javadoc for {@link MockitoHamcrest} class\n     *\n     * @param matcher decides whether argument matches\n     * @return <code>0</code>.\n     */\n    public static int intThat(Matcher<Integer> matcher) {\n        reportMatcher(matcher);\n        return 0;\n    }\n\n    /**\n     * Enables integrating hamcrest matchers that match primitive <code>long</code> arguments.\n     * Note that {@link #argThat} will not work with primitive <code>long</code> matchers due to <code>NullPointerException</code> auto-unboxing caveat.\n     * <p/>\n     * * See examples in javadoc for {@link MockitoHamcrest} class\n     *\n     * @param matcher decides whether argument matches\n     * @return <code>0</code>.\n     */\n    public static long longThat(Matcher<Long> matcher) {\n        reportMatcher(matcher);\n        return 0;\n    }\n\n    /**\n     * Enables integrating hamcrest matchers that match primitive <code>float</code> arguments.\n     * Note that {@link #argThat} will not work with primitive <code>float</code> matchers due to <code>NullPointerException</code> auto-unboxing caveat.\n     * <p/>\n     * * See examples in javadoc for {@link MockitoHamcrest} class\n     *\n     * @param matcher decides whether argument matches\n     * @return <code>0</code>.\n     */\n    public static float floatThat(Matcher<Float> matcher) {\n        reportMatcher(matcher);\n        return 0;\n    }\n\n    /**\n     * Enables integrating hamcrest matchers that match primitive <code>double</code> arguments.\n     * Note that {@link #argThat} will not work with primitive <code>double</code> matchers due to <code>NullPointerException</code> auto-unboxing caveat.\n     * <p/>\n     * * See examples in javadoc for {@link MockitoHamcrest} class\n     *\n     * @param matcher decides whether argument matches\n     * @return <code>0</code>.\n     */\n    public static double doubleThat(Matcher<Double> matcher) {\n        reportMatcher(matcher);\n        return 0;\n    }\n\n    private static <T> void reportMatcher(Matcher<T> matcher) {\n        mockingProgress()\n                .getArgumentMatcherStorage()\n                .reportMatcher(new HamcrestArgumentMatcher<T>(matcher));\n    }\n\n    private MockitoHamcrest() {}\n}\n",
        "filePathAfter": "src/main/java/org/mockito/hamcrest/MockitoHamcrest.java",
        "sourceCodeAfterForWhole": "/*\n * Copyright (c) 2016 Mockito contributors\n * This program is made available under the terms of the MIT License.\n */\npackage org.mockito.hamcrest;\n\nimport static org.mockito.internal.hamcrest.MatcherGenericTypeExtractor.genericTypeOfMatcher;\nimport static org.mockito.internal.progress.ThreadSafeMockingProgress.mockingProgress;\nimport static org.mockito.internal.util.Primitives.defaultValue;\n\nimport org.hamcrest.Matcher;\nimport org.mockito.ArgumentMatcher;\nimport org.mockito.internal.hamcrest.HamcrestArgumentMatcher;\n\n/**\n * Allows matching arguments with hamcrest matchers.\n * <b>Requires</b> <a href=\"http://hamcrest.org/JavaHamcrest/\">hamcrest</a> on classpath,\n * Mockito <b>does not</b> depend on hamcrest!\n * Note the <b>NullPointerException</b> auto-unboxing caveat described below.\n * <p/>\n * Before implementing or reusing an existing hamcrest matcher please read\n * how to deal with sophisticated argument matching in {@link ArgumentMatcher}.\n * <p/>\n * Mockito 2.1.0 was decoupled from Hamcrest to avoid version incompatibilities\n * that have impacted our users in past. Mockito offers a dedicated API to match arguments\n * via {@link ArgumentMatcher}.\n * Hamcrest integration is provided so that users can take advantage of existing Hamcrest matchers.\n * <p/>\n * Example:\n * <pre>\n *     import static org.mockito.hamcrest.MockitoHamcrest.argThat;\n *\n *     //stubbing\n *     when(mock.giveMe(argThat(new MyHamcrestMatcher())));\n *\n *     //verification\n *     verify(mock).giveMe(argThat(new MyHamcrestMatcher()));\n * </pre>\n * <b>NullPointerException</b> auto-unboxing caveat.\n * In rare cases when matching primitive parameter types you <b>*must*</b> use relevant intThat(), floatThat(), etc. method.\n * This way you will avoid <code>NullPointerException</code> during auto-unboxing.\n * Due to how java works we don't really have a clean way of detecting this scenario and protecting the user from this problem.\n * Hopefully, the javadoc describes the problem and solution well.\n * If you have an idea how to fix the problem, let us know via the mailing list or the issue tracker.\n * <p/>\n * By default, a matcher passed to a varargs parameter will match against the first element in the varargs array.\n * To match against the raw varargs array pass the type of the varargs parameter to {@link MockitoHamcrest#argThat(Matcher, Class)}\n * <p/>\n * For example, to match any number of {@code String} values:\n * <pre>\n *     import static org.hamcrest.CoreMatchers.isA;\n *     import static org.mockito.hamcrest.MockitoHamcrest.argThat;\n *\n *     // Given:\n *     void varargMethod(String... args);\n *\n *     //stubbing\n *     when(mock.varargMethod(argThat(isA(String[].class), String[].class));\n *\n *     //verification\n *     verify(mock).giveMe(argThat(isA(String[].class), String[].class));\n * </pre>\n *\n * @since 2.1.0\n */\npublic final class MockitoHamcrest {\n\n    /**\n     * Allows matching arguments with hamcrest matchers.\n     * <p/>\n     * See examples in javadoc for {@link MockitoHamcrest} class\n     *\n     * @param matcher decides whether argument matches\n     * @return <code>null</code> or default value for primitive (0, false, etc.)\n     * @since 2.1.0\n     */\n    @SuppressWarnings(\"unchecked\")\n    public static <T> T argThat(Matcher<T> matcher) {\n        reportMatcher(matcher);\n        return (T) defaultValue(genericTypeOfMatcher(matcher.getClass()));\n    }\n\n    /**\n     * Allows matching arguments with hamcrest matchers.\n     * <p/>\n     * This variant can be used to pass an explicit {@code type},\n     * which can be useful to provide a matcher that matches against all\n     * elements in a varargs parameter.\n     * <p/>\n     * See examples in javadoc for {@link MockitoHamcrest} class\n     *\n     * @param matcher decides whether argument matches\n     * @param type the type the matcher matches.\n     * @return <code>null</code> or default value for primitive (0, false, etc.)\n     * @since 5.0.0\n     */\n    @SuppressWarnings(\"unchecked\")\n    public static <T> T argThat(Matcher<T> matcher, Class<T> type) {\n        reportMatcher(matcher, type);\n        return (T) defaultValue(genericTypeOfMatcher(matcher.getClass()));\n    }\n\n    /**\n     * Enables integrating hamcrest matchers that match primitive <code>char</code> arguments.\n     * Note that {@link #argThat} will not work with primitive <code>char</code> matchers due to <code>NullPointerException</code> auto-unboxing caveat.\n     * <p/>\n     * See examples in javadoc for {@link MockitoHamcrest} class\n     *\n     * @param matcher decides whether argument matches\n     * @return <code>0</code>.\n     */\n    public static char charThat(Matcher<Character> matcher) {\n        reportMatcher(matcher);\n        return 0;\n    }\n\n    /**\n     * Enables integrating hamcrest matchers that match primitive <code>boolean</code> arguments.\n     * Note that {@link #argThat} will not work with primitive <code>boolean</code> matchers due to <code>NullPointerException</code> auto-unboxing caveat.\n     * <p/>\n     * See examples in javadoc for {@link MockitoHamcrest} class\n     *\n     * @param matcher decides whether argument matches\n     * @return <code>false</code>.\n     */\n    public static boolean booleanThat(Matcher<Boolean> matcher) {\n        reportMatcher(matcher);\n        return false;\n    }\n\n    /**\n     * Enables integrating hamcrest matchers that match primitive <code>byte</code> arguments.\n     * Note that {@link #argThat} will not work with primitive <code>byte</code> matchers due to <code>NullPointerException</code> auto-unboxing caveat.\n     * <p/>\n     * * See examples in javadoc for {@link MockitoHamcrest} class\n     *\n     * @param matcher decides whether argument matches\n     * @return <code>0</code>.\n     */\n    public static byte byteThat(Matcher<Byte> matcher) {\n        reportMatcher(matcher);\n        return 0;\n    }\n\n    /**\n     * Enables integrating hamcrest matchers that match primitive <code>short</code> arguments.\n     * Note that {@link #argThat} will not work with primitive <code>short</code> matchers due to <code>NullPointerException</code> auto-unboxing caveat.\n     * <p/>\n     * * See examples in javadoc for {@link MockitoHamcrest} class\n     *\n     * @param matcher decides whether argument matches\n     * @return <code>0</code>.\n     */\n    public static short shortThat(Matcher<Short> matcher) {\n        reportMatcher(matcher);\n        return 0;\n    }\n\n    /**\n     * Enables integrating hamcrest matchers that match primitive <code>int</code> arguments.\n     * Note that {@link #argThat} will not work with primitive <code>int</code> matchers due to <code>NullPointerException</code> auto-unboxing caveat.\n     * <p/>\n     * * See examples in javadoc for {@link MockitoHamcrest} class\n     *\n     * @param matcher decides whether argument matches\n     * @return <code>0</code>.\n     */\n    public static int intThat(Matcher<Integer> matcher) {\n        reportMatcher(matcher);\n        return 0;\n    }\n\n    /**\n     * Enables integrating hamcrest matchers that match primitive <code>long</code> arguments.\n     * Note that {@link #argThat} will not work with primitive <code>long</code> matchers due to <code>NullPointerException</code> auto-unboxing caveat.\n     * <p/>\n     * * See examples in javadoc for {@link MockitoHamcrest} class\n     *\n     * @param matcher decides whether argument matches\n     * @return <code>0</code>.\n     */\n    public static long longThat(Matcher<Long> matcher) {\n        reportMatcher(matcher);\n        return 0;\n    }\n\n    /**\n     * Enables integrating hamcrest matchers that match primitive <code>float</code> arguments.\n     * Note that {@link #argThat} will not work with primitive <code>float</code> matchers due to <code>NullPointerException</code> auto-unboxing caveat.\n     * <p/>\n     * * See examples in javadoc for {@link MockitoHamcrest} class\n     *\n     * @param matcher decides whether argument matches\n     * @return <code>0</code>.\n     */\n    public static float floatThat(Matcher<Float> matcher) {\n        reportMatcher(matcher);\n        return 0;\n    }\n\n    /**\n     * Enables integrating hamcrest matchers that match primitive <code>double</code> arguments.\n     * Note that {@link #argThat} will not work with primitive <code>double</code> matchers due to <code>NullPointerException</code> auto-unboxing caveat.\n     * <p/>\n     * * See examples in javadoc for {@link MockitoHamcrest} class\n     *\n     * @param matcher decides whether argument matches\n     * @return <code>0</code>.\n     */\n    public static double doubleThat(Matcher<Double> matcher) {\n        reportMatcher(matcher);\n        return 0;\n    }\n\n    private static <T> void reportMatcher(Matcher<T> matcher) {\n        reportMatcher(new HamcrestArgumentMatcher<T>(matcher));\n    }\n\n    private static <T> void reportMatcher(Matcher<T> matcher, Class<T> type) {\n        reportMatcher(new HamcrestArgumentMatcher<T>(matcher, type));\n    }\n\n    private static <T> void reportMatcher(final HamcrestArgumentMatcher<T> matcher) {\n        mockingProgress().getArgumentMatcherStorage().reportMatcher(matcher);\n    }\n\n    private MockitoHamcrest() {}\n}\n",
        "diffSourceCodeSet": [
            "private static <T> void reportMatcher(final HamcrestArgumentMatcher<T> matcher) {\n        mockingProgress().getArgumentMatcherStorage().reportMatcher(matcher);\n    }"
        ],
        "invokedMethodSet": [
            "methodSignature: org.mockito.hamcrest.MockitoHamcrest#reportMatcher\n methodBody: private static <T> void reportMatcher(Matcher<T> matcher) {\nmockingProgress().getArgumentMatcherStorage().reportMatcher(new HamcrestArgumentMatcher<T>(matcher));\n}",
            "methodSignature: org.mockito.ArgumentMatchers#reportMatcher\n methodBody: private static void reportMatcher(ArgumentMatcher<?> matcher) {\nmockingProgress().getArgumentMatcherStorage().reportMatcher(matcher);\n}"
        ],
        "sourceCodeAfterRefactoring": "private static <T> void reportMatcher(Matcher<T> matcher) {\n        reportMatcher(new HamcrestArgumentMatcher<T>(matcher));\n    }\nprivate static <T> void reportMatcher(final HamcrestArgumentMatcher<T> matcher) {\n        mockingProgress().getArgumentMatcherStorage().reportMatcher(matcher);\n    }",
        "diffSourceCode": "-  177:     private static <T> void reportMatcher(Matcher<T> matcher) {\n-  178:         mockingProgress()\n-  179:                 .getArgumentMatcherStorage()\n-  180:                 .reportMatcher(new HamcrestArgumentMatcher<T>(matcher));\n-  181:     }\n+  177:      * * See examples in javadoc for {@link MockitoHamcrest} class\n+  178:      *\n+  179:      * @param matcher decides whether argument matches\n+  180:      * @return <code>0</code>.\n+  181:      */\n+  215:     private static <T> void reportMatcher(Matcher<T> matcher) {\n+  216:         reportMatcher(new HamcrestArgumentMatcher<T>(matcher));\n+  217:     }\n+  223:     private static <T> void reportMatcher(final HamcrestArgumentMatcher<T> matcher) {\n+  224:         mockingProgress().getArgumentMatcherStorage().reportMatcher(matcher);\n+  225:     }\n",
        "uniqueId": "064fe9028993a11ccf0ae12b5975b96baffcf305_177_181_223_225_215_217",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 0,
                "covered": 8
            },
            "LINE": {
                "missed": 0,
                "covered": 4
            },
            "COMPLEXITY": {
                "missed": 0,
                "covered": 1
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 17
    }
]