[
    {
        "type": "Extract Method",
        "description": "Extract Method\tprivate getExplicitJavaType() : BasicJavaType<?> extracted from protected buildResolution() : Resolution<?> in class org.hibernate.mapping.BasicValue",
        "diffLocations": [
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/mapping/BasicValue.java",
                "startLine": 428,
                "endLine": 498,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/mapping/BasicValue.java",
                "startLine": 427,
                "endLine": 460,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/mapping/BasicValue.java",
                "startLine": 462,
                "endLine": 465,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "protected Resolution<?> buildResolution() {\n\t\tfinal Properties typeParameters = getTypeParameters();\n\t\tif ( typeParameters != null\n\t\t\t\t&& parseBoolean( typeParameters.getProperty(DynamicParameterizedType.IS_DYNAMIC) )\n\t\t\t\t&& typeParameters.get(DynamicParameterizedType.PARAMETER_TYPE) == null ) {\n\t\t\tcreateParameterImpl();\n\t\t}\n\n\t\tif ( explicitTypeName != null ) {\n\t\t\treturn interpretExplicitlyNamedType(\n\t\t\t\t\texplicitTypeName,\n\t\t\t\t\texplicitJavaTypeAccess,\n\t\t\t\t\texplicitJdbcTypeAccess,\n\t\t\t\t\texplicitMutabilityPlanAccess,\n\t\t\t\t\tgetAttributeConverterDescriptor(),\n\t\t\t\t\ttypeParameters,\n\t\t\t\t\tthis::setTypeParameters,\n\t\t\t\t\tthis,\n\t\t\t\t\tgetBuildingContext()\n\t\t\t);\n\t\t}\n\n\t\tif ( isVersion() ) {\n\t\t\treturn VersionResolution.from( implicitJavaTypeAccess, timeZoneStorageType, getBuildingContext() );\n\t\t}\n\n\t\t// determine JavaType if we can\n\t\tfinal BasicJavaType<?> explicitJavaType = explicitJavaTypeAccess == null\n\t\t\t\t? null\n\t\t\t\t: explicitJavaTypeAccess.apply( getTypeConfiguration() );\n\n\t\tJavaType<?> javaType = determineJavaType( explicitJavaType );\n\t\tConverterDescriptor attributeConverterDescriptor = getAttributeConverterDescriptor();\n\n\t\tif ( isSoftDelete() ) {\n\t\t\tassert attributeConverterDescriptor != null;\n\t\t\tfinal boolean conversionWasUnspecified = SoftDelete.UnspecifiedConversion.class.equals( attributeConverterDescriptor.getAttributeConverterClass() );\n\t\t\tif ( conversionWasUnspecified ) {\n\t\t\t\tfinal JdbcType jdbcType = BooleanJdbcType.INSTANCE.resolveIndicatedType( this, javaType );\n\t\t\t\tif ( jdbcType.isNumber() ) {\n\t\t\t\t\tattributeConverterDescriptor = new InstanceBasedConverterDescriptor(\n\t\t\t\t\t\t\tNumericBooleanConverter.INSTANCE,\n\t\t\t\t\t\t\tgetBuildingContext().getBootstrapContext().getClassmateContext()\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\telse if ( jdbcType.isString() ) {\n\t\t\t\t\t// here we pick 'T' / 'F' storage, though 'Y' / 'N' is equally valid - its 50/50\n\t\t\t\t\tattributeConverterDescriptor = new InstanceBasedConverterDescriptor(\n\t\t\t\t\t\t\tTrueFalseConverter.INSTANCE,\n\t\t\t\t\t\t\tgetBuildingContext().getBootstrapContext().getClassmateContext()\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// should indicate BIT or BOOLEAN == no conversion needed\n\t\t\t\t\t//\t\t- we still create the converter to properly set up JDBC type, etc\n\t\t\t\t\tattributeConverterDescriptor = new InstanceBasedConverterDescriptor(\n\t\t\t\t\t\t\tPassThruSoftDeleteConverter.INSTANCE,\n\t\t\t\t\t\t\tgetBuildingContext().getBootstrapContext().getClassmateContext()\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( getSoftDeleteStrategy() == SoftDeleteType.ACTIVE ) {\n\t\t\t\tattributeConverterDescriptor = new ReversedConverterDescriptor<>( attributeConverterDescriptor );\n\t\t\t}\n\t\t}\n\n\t\treturn attributeConverterDescriptor != null\n\t\t\t\t? converterResolution( javaType, attributeConverterDescriptor )\n\t\t\t\t: resolution( explicitJavaType, javaType );\n\t}",
        "filePathBefore": "hibernate-core/src/main/java/org/hibernate/mapping/BasicValue.java",
        "isPureRefactoring": true,
        "commitId": "6c6c92e88d4535be020b4acb3d81f96df39a65d8",
        "packageNameBefore": "org.hibernate.mapping",
        "classNameBefore": "org.hibernate.mapping.BasicValue",
        "methodNameBefore": "org.hibernate.mapping.BasicValue#buildResolution",
        "invokedMethod": "methodSignature: org.hibernate.type.spi.TypeConfiguration.ArrayCacheKey#equals\n methodBody: public boolean equals(Object o) {\nreturn Arrays.equals(components,((ArrayCacheKey)o).components);\n}\nmethodSignature: org.hibernate.mapping.BasicValue#resolution\n methodBody: private Resolution<?> resolution(BasicJavaType explicitJavaType, JavaType<?> javaType) {\nfinal JavaType<?> basicJavaType;\nfinal JdbcType jdbcType;\nif(explicitJdbcTypeAccess != null){final TypeConfiguration typeConfiguration=getTypeConfiguration();\njdbcType=explicitJdbcTypeAccess.apply(typeConfiguration);\nbasicJavaType=javaType == null && jdbcType != null ? jdbcType.getJdbcRecommendedJavaTypeMapping(null,null,typeConfiguration) : javaType;\n}{jdbcType=null;\nbasicJavaType=javaType;\n}if(basicJavaType == null){throw new MappingException(\"Unable to determine JavaType to use : \" + this);\n}if(basicJavaType instanceof BasicJavaType<?> && (!basicJavaType.getJavaTypeClass().isEnum() || enumerationStyle == null)){final TypeDefinition autoAppliedTypeDef=getBuildingContext().getTypeDefinitionRegistry().resolveAutoApplied((BasicJavaType<?>)basicJavaType);\nif(autoAppliedTypeDef != null){log.debug(\"BasicValue resolution matched auto-applied type-definition\");\nreturn autoAppliedTypeDef.resolve(getTypeParameters(),null,getBuildingContext(),this);\n}}return InferredBasicValueResolver.from(explicitJavaType,jdbcType,resolvedJavaType,this::determineReflectedJavaType,explicitMutabilityPlanAccess,this,getTable(),getColumn(),ownerName,propertyName,getBuildingContext());\n}\nmethodSignature: org.hibernate.mapping.BasicValue#isSoftDelete\n methodBody: public boolean isSoftDelete() {\nreturn isSoftDelete;\n}\nmethodSignature: org.hibernate.type.spi.TypeConfiguration.Scope#getTypeConfiguration\n methodBody: public TypeConfiguration getTypeConfiguration() {\nreturn typeConfiguration;\n}\nmethodSignature: org.hibernate.mapping.BasicValue.ReversedConverterDescriptor#getAttributeConverterClass\n methodBody: public Class<? extends AttributeConverter<Boolean,R>> getAttributeConverterClass() {\nreturn (Class<? extends AttributeConverter<Boolean,R>>)getClass();\n}\nmethodSignature: org.hibernate.mapping.BasicValue#interpretExplicitlyNamedType\n methodBody: private static Resolution<?> interpretExplicitlyNamedType(\n\t\t\tString name,\n\t\t\tFunction<TypeConfiguration, BasicJavaType> explicitJtdAccess,\n\t\t\tFunction<TypeConfiguration, JdbcType> explicitStdAccess,\n\t\t\tFunction<TypeConfiguration, MutabilityPlan> explicitMutabilityPlanAccess,\n\t\t\tConverterDescriptor converterDescriptor,\n\t\t\tMap<Object,Object> localTypeParams,\n\t\t\tConsumer<Properties> combinedParameterConsumer,\n\t\t\tJdbcTypeIndicators stdIndicators,\n\t\t\tMetadataBuildingContext context) {\nfinal StandardServiceRegistry serviceRegistry=context.getBootstrapContext().getServiceRegistry();\nfinal ManagedBeanRegistry managedBeanRegistry=serviceRegistry.requireService(ManagedBeanRegistry.class);\nfinal TypeConfiguration typeConfiguration=context.getBootstrapContext().getTypeConfiguration();\nfinal JpaAttributeConverterCreationContext converterCreationContext=new JpaAttributeConverterCreationContext(){\n  @Override public ManagedBeanRegistry getManagedBeanRegistry(){\n    return managedBeanRegistry;\n  }\n  @Override public TypeConfiguration getTypeConfiguration(){\n    return typeConfiguration;\n  }\n}\n;\nif(name.startsWith(ConverterDescriptor.TYPE_NAME_PREFIX)){return NamedConverterResolution.from(name,explicitJtdAccess,explicitStdAccess,explicitMutabilityPlanAccess,stdIndicators,converterCreationContext,context);\n}if(name.startsWith(BasicTypeImpl.EXTERNALIZED_PREFIX)){final BasicType<Object> basicType=context.getBootstrapContext().resolveAdHocBasicType(name);\nreturn new NamedBasicTypeResolution<>(basicType.getJavaTypeDescriptor(),basicType,null,explicitMutabilityPlanAccess,context);\n}final BasicType<?> basicTypeByName=typeConfiguration.getBasicTypeRegistry().getRegisteredType(name);\nif(basicTypeByName != null){final BasicValueConverter<?,?> valueConverter;\nfinal JavaType<?> domainJtd;\nif(converterDescriptor != null){valueConverter=converterDescriptor.createJpaAttributeConverter(converterCreationContext);\ndomainJtd=valueConverter.getDomainJavaType();\n}{valueConverter=basicTypeByName.getValueConverter();\ndomainJtd=basicTypeByName.getJavaTypeDescriptor();\n}return new NamedBasicTypeResolution<>(domainJtd,basicTypeByName,valueConverter,explicitMutabilityPlanAccess,context);\n}final TypeDefinition typeDefinition=context.getTypeDefinitionRegistry().resolve(name);\nif(typeDefinition != null){final Resolution<?> resolution=typeDefinition.resolve(localTypeParams,explicitMutabilityPlanAccess != null ? explicitMutabilityPlanAccess.apply(typeConfiguration) : null,context,stdIndicators);\ncombinedParameterConsumer.accept(resolution.getCombinedTypeParameters());\nreturn resolution;\n}final ClassLoaderService cls=serviceRegistry.requireService(ClassLoaderService.class);\ntryfinal Class<?> typeNamedClass=cls.classForName(name);\nif(CollectionHelper.isEmpty(localTypeParams)){final TypeDefinition implicitDefinition=new TypeDefinition(name,typeNamedClass,null,null);\ncontext.getTypeDefinitionRegistry().register(implicitDefinition);\nreturn implicitDefinition.resolve(localTypeParams,explicitMutabilityPlanAccess != null ? explicitMutabilityPlanAccess.apply(typeConfiguration) : null,context,stdIndicators);\n}return TypeDefinition.createLocalResolution(name,typeNamedClass,localTypeParams,context);\ncatch(ClassLoadingException e)log.debugf(\"Could not resolve type-name [%s] as Java type : %s\",name,e);\nthrow new MappingException(\"Could not resolve named type : \" + name);\n}\nmethodSignature: org.hibernate.mapping.BasicValue#getSoftDeleteStrategy\n methodBody: public SoftDeleteType getSoftDeleteStrategy() {\nreturn softDeleteStrategy;\n}\nmethodSignature: org.hibernate.mapping.BasicValue#determineJavaType\n methodBody: private JavaType<?> determineJavaType(JavaType<?> explicitJavaType) {\nJavaType<?> javaType=explicitJavaType;\nif(javaType == null){final JavaType<?> reflectedJtd=determineReflectedJavaType();\nif(reflectedJtd != null){javaType=reflectedJtd;\n}}return javaType;\n}\nmethodSignature: org.hibernate.mapping.BasicValue#converterResolution\n methodBody: private Resolution<?> converterResolution(JavaType<?> javaType, ConverterDescriptor attributeConverterDescriptor) {\nfinal NamedConverterResolution<?> converterResolution=NamedConverterResolution.from(attributeConverterDescriptor,explicitJavaTypeAccess,explicitJdbcTypeAccess,explicitMutabilityPlanAccess,resolvedJavaType,this,this,getBuildingContext());\nif(javaType instanceof BasicPluralJavaType<?> && !attributeConverterDescriptor.getDomainValueResolvedType().getErasedType().isAssignableFrom(javaType.getJavaTypeClass())){final BasicPluralJavaType<?> containerJtd=(BasicPluralJavaType<?>)javaType;\nfinal BasicType registeredElementType=converterResolution.getLegacyResolvedBasicType();\nfinal Selectable column=getColumn();\nfinal BasicType<?> registeredType=registeredElementType == null ? null : containerJtd.resolveType(getTypeConfiguration(),getDialect(),registeredElementType,column instanceof ColumnTypeInformation ? (ColumnTypeInformation)column : null,this);\nif(registeredType != null){getTypeConfiguration().getBasicTypeRegistry().register(registeredType);\nreturn new InferredBasicValueResolution(registeredType,registeredType.getJavaTypeDescriptor(),registeredType.getJavaTypeDescriptor(),registeredType.getJdbcType(),registeredType,null);\n}}return converterResolution;\n}",
        "classSignatureBefore": "public class BasicValue extends SimpleValue implements JdbcTypeIndicators, Resolvable, JpaAttributeConverterCreationContext ",
        "methodNameBeforeSet": [
            "org.hibernate.mapping.BasicValue#buildResolution"
        ],
        "classNameBeforeSet": [
            "org.hibernate.mapping.BasicValue"
        ],
        "classSignatureBeforeSet": [
            "public class BasicValue extends SimpleValue implements JdbcTypeIndicators, Resolvable, JpaAttributeConverterCreationContext "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later\n * See the lgpl.txt file in the root directory or http://www.gnu.org/licenses/lgpl-2.1.html\n */\npackage org.hibernate.mapping;\n\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Properties;\nimport java.util.function.Consumer;\nimport java.util.function.Function;\n\nimport org.hibernate.Incubating;\nimport org.hibernate.Internal;\nimport org.hibernate.MappingException;\nimport org.hibernate.TimeZoneStorageStrategy;\nimport org.hibernate.annotations.SoftDelete;\nimport org.hibernate.annotations.SoftDeleteType;\nimport org.hibernate.annotations.TimeZoneStorageType;\nimport org.hibernate.boot.model.TypeDefinition;\nimport org.hibernate.boot.model.convert.internal.AutoApplicableConverterDescriptorBypassedImpl;\nimport org.hibernate.boot.model.convert.internal.ClassBasedConverterDescriptor;\nimport org.hibernate.boot.model.convert.internal.InstanceBasedConverterDescriptor;\nimport org.hibernate.boot.model.convert.spi.AutoApplicableConverterDescriptor;\nimport org.hibernate.boot.model.convert.spi.ConverterDescriptor;\nimport org.hibernate.boot.model.convert.spi.JpaAttributeConverterCreationContext;\nimport org.hibernate.boot.model.process.internal.InferredBasicValueResolution;\nimport org.hibernate.boot.model.process.internal.InferredBasicValueResolver;\nimport org.hibernate.boot.model.process.internal.NamedBasicTypeResolution;\nimport org.hibernate.boot.model.process.internal.NamedConverterResolution;\nimport org.hibernate.boot.model.process.internal.UserTypeResolution;\nimport org.hibernate.boot.model.process.internal.VersionResolution;\nimport org.hibernate.boot.registry.StandardServiceRegistry;\nimport org.hibernate.boot.registry.classloading.spi.ClassLoaderService;\nimport org.hibernate.boot.registry.classloading.spi.ClassLoadingException;\nimport org.hibernate.boot.spi.MetadataBuildingContext;\nimport org.hibernate.dialect.Dialect;\nimport org.hibernate.engine.jdbc.Size;\nimport org.hibernate.internal.CoreLogging;\nimport org.hibernate.internal.CoreMessageLogger;\nimport org.hibernate.internal.util.ReflectHelper;\nimport org.hibernate.internal.util.StringHelper;\nimport org.hibernate.internal.util.collections.CollectionHelper;\nimport org.hibernate.metamodel.mapping.JdbcMapping;\nimport org.hibernate.metamodel.mapping.SelectablePath;\nimport org.hibernate.resource.beans.internal.FallbackBeanInstanceProducer;\nimport org.hibernate.resource.beans.spi.BeanInstanceProducer;\nimport org.hibernate.resource.beans.spi.ManagedBean;\nimport org.hibernate.resource.beans.spi.ManagedBeanRegistry;\nimport org.hibernate.tool.schema.extract.spi.ColumnTypeInformation;\nimport org.hibernate.type.BasicType;\nimport org.hibernate.type.CustomType;\nimport org.hibernate.type.NumericBooleanConverter;\nimport org.hibernate.type.SqlTypes;\nimport org.hibernate.type.TrueFalseConverter;\nimport org.hibernate.type.Type;\nimport org.hibernate.type.WrapperArrayHandling;\nimport org.hibernate.type.descriptor.converter.spi.BasicValueConverter;\nimport org.hibernate.type.descriptor.converter.spi.JpaAttributeConverter;\nimport org.hibernate.type.descriptor.java.BasicJavaType;\nimport org.hibernate.type.descriptor.java.BasicPluralJavaType;\nimport org.hibernate.type.descriptor.java.JavaType;\nimport org.hibernate.type.descriptor.java.MutabilityPlan;\nimport org.hibernate.type.descriptor.java.spi.JavaTypeRegistry;\nimport org.hibernate.type.descriptor.java.spi.JsonJavaType;\nimport org.hibernate.type.descriptor.java.spi.RegistryHelper;\nimport org.hibernate.type.descriptor.java.spi.XmlJavaType;\nimport org.hibernate.type.descriptor.jdbc.BooleanJdbcType;\nimport org.hibernate.type.descriptor.jdbc.JdbcType;\nimport org.hibernate.type.descriptor.jdbc.JdbcTypeIndicators;\nimport org.hibernate.type.internal.BasicTypeImpl;\nimport org.hibernate.type.spi.TypeConfiguration;\nimport org.hibernate.type.spi.TypeConfigurationAware;\nimport org.hibernate.usertype.DynamicParameterizedType;\nimport org.hibernate.usertype.UserType;\n\nimport com.fasterxml.classmate.ResolvedType;\nimport jakarta.persistence.AttributeConverter;\nimport jakarta.persistence.EnumType;\nimport jakarta.persistence.TemporalType;\n\nimport static java.lang.Boolean.parseBoolean;\nimport static org.hibernate.internal.util.collections.CollectionHelper.isNotEmpty;\nimport static org.hibernate.mapping.MappingHelper.injectParameters;\n\n/**\n * @author Steve Ebersole\n */\npublic class BasicValue extends SimpleValue implements JdbcTypeIndicators, Resolvable, JpaAttributeConverterCreationContext {\n\tprivate static final CoreMessageLogger log = CoreLogging.messageLogger( BasicValue.class );\n\n\t// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\t// incoming \"configuration\" values\n\n\tprivate String explicitTypeName;\n\tprivate Map<String,String> explicitLocalTypeParams;\n\n\tprivate Function<TypeConfiguration, BasicJavaType> explicitJavaTypeAccess;\n\tprivate Function<TypeConfiguration, JdbcType> explicitJdbcTypeAccess;\n\tprivate Function<TypeConfiguration, MutabilityPlan> explicitMutabilityPlanAccess;\n\tprivate Function<TypeConfiguration, java.lang.reflect.Type> implicitJavaTypeAccess;\n\n\tprivate EnumType enumerationStyle;\n\tprivate TemporalType temporalPrecision;\n\tprivate TimeZoneStorageType timeZoneStorageType;\n\tprivate boolean isSoftDelete;\n\tprivate SoftDeleteType softDeleteStrategy;\n\n\tprivate java.lang.reflect.Type resolvedJavaType;\n\n\tprivate String ownerName;\n\tprivate String propertyName;\n\tprivate AggregateColumn aggregateColumn;\n\n\t// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\t// Resolved state - available after `#resolve`\n\tprivate Resolution<?> resolution;\n\tprivate Integer jdbcTypeCode;\n\n\n\tpublic BasicValue(MetadataBuildingContext buildingContext) {\n\t\tthis( buildingContext, null );\n\t}\n\n\tpublic BasicValue(MetadataBuildingContext buildingContext, Table table) {\n\t\tsuper( buildingContext, table );\n\t\tbuildingContext.getMetadataCollector().registerValueMappingResolver( this::resolve );\n\t}\n\n\tpublic BasicValue(BasicValue original) {\n\t\tsuper( original );\n\t\tthis.explicitTypeName = original.explicitTypeName;\n\t\tthis.explicitLocalTypeParams = original.explicitLocalTypeParams == null\n\t\t\t\t? null\n\t\t\t\t: new HashMap<>(original.explicitLocalTypeParams);\n\t\tthis.explicitJavaTypeAccess = original.explicitJavaTypeAccess;\n\t\tthis.explicitJdbcTypeAccess = original.explicitJdbcTypeAccess;\n\t\tthis.explicitMutabilityPlanAccess = original.explicitMutabilityPlanAccess;\n\t\tthis.implicitJavaTypeAccess = original.implicitJavaTypeAccess;\n\t\tthis.enumerationStyle = original.enumerationStyle;\n\t\tthis.temporalPrecision = original.temporalPrecision;\n\t\tthis.timeZoneStorageType = original.timeZoneStorageType;\n\t\tthis.resolvedJavaType = original.resolvedJavaType;\n\t\tthis.ownerName = original.ownerName;\n\t\tthis.propertyName = original.propertyName;\n\t}\n\n\t@Override\n\tpublic BasicValue copy() {\n\t\treturn new BasicValue( this );\n\t}\n\n\tpublic boolean isSoftDelete() {\n\t\treturn isSoftDelete;\n\t}\n\n\tpublic SoftDeleteType getSoftDeleteStrategy() {\n\t\treturn softDeleteStrategy;\n\t}\n\n\tpublic void makeSoftDelete(SoftDeleteType strategy) {\n\t\tisSoftDelete = true;\n\t\tsoftDeleteStrategy = strategy;\n\t}\n\n\t// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\t// Setters - in preparation of resolution\n\n\t@Override\n\tpublic void setTypeUsingReflection(String className, String propertyName) throws MappingException {\n\t\tif ( resolution != null ) {\n\t\t\tthrow new IllegalStateException( \"BasicValue already resolved\" );\n\t\t}\n\n\t\tthis.ownerName = className;\n\t\tthis.propertyName = propertyName;\n\n\t\tsuper.setTypeUsingReflection( className, propertyName );\n\t}\n\n\tpublic void setEnumerationStyle(EnumType enumerationStyle) {\n\t\tthis.enumerationStyle = enumerationStyle;\n\t}\n\n\tpublic EnumType getEnumerationStyle() {\n\t\treturn enumerationStyle;\n\t}\n\n\tpublic TimeZoneStorageType getTimeZoneStorageType() {\n\t\treturn timeZoneStorageType;\n\t}\n\n\tpublic void setTimeZoneStorageType(TimeZoneStorageType timeZoneStorageType) {\n\t\tthis.timeZoneStorageType = timeZoneStorageType;\n\t}\n\n\tpublic void setJpaAttributeConverterDescriptor(ConverterDescriptor descriptor) {\n\t\tsetAttributeConverterDescriptor( descriptor );\n\n\t\tsuper.setJpaAttributeConverterDescriptor( descriptor );\n\t}\n\n\t@SuppressWarnings(\"rawtypes\")\n\tpublic void setExplicitJavaTypeAccess(Function<TypeConfiguration, BasicJavaType> explicitJavaTypeAccess) {\n\t\tthis.explicitJavaTypeAccess = explicitJavaTypeAccess;\n\t}\n\n\tpublic void setExplicitJdbcTypeAccess(Function<TypeConfiguration, JdbcType> jdbcTypeAccess) {\n\t\tthis.explicitJdbcTypeAccess = jdbcTypeAccess;\n\t}\n\n\tpublic void setExplicitMutabilityPlanAccess(Function<TypeConfiguration, MutabilityPlan> explicitMutabilityPlanAccess) {\n\t\tthis.explicitMutabilityPlanAccess = explicitMutabilityPlanAccess;\n\t}\n\n\tpublic void setImplicitJavaTypeAccess(Function<TypeConfiguration, java.lang.reflect.Type> implicitJavaTypeAccess) {\n\t\tthis.implicitJavaTypeAccess = implicitJavaTypeAccess;\n\t}\n\n\tpublic Selectable getColumn() {\n\t\tif ( getColumnSpan() == 0 ) {\n\t\t\treturn null;\n\t\t}\n\t\treturn getColumn( 0 );\n\t}\n\n\tpublic java.lang.reflect.Type getResolvedJavaType() {\n\t\treturn resolvedJavaType;\n\t}\n\n\t@Override\n\tpublic long getColumnLength() {\n\t\tfinal Selectable selectable = getColumn();\n\t\tif ( selectable instanceof Column ) {\n\t\t\tfinal Column column = (Column) selectable;\n\t\t\tfinal Long length = column.getLength();\n\t\t\treturn length == null ? NO_COLUMN_LENGTH : length;\n\t\t}\n\t\telse {\n\t\t\treturn NO_COLUMN_LENGTH;\n\t\t}\n\t}\n\n\t@Override\n\tpublic int getColumnPrecision() {\n\t\tfinal Selectable selectable = getColumn();\n\t\tif ( selectable instanceof Column ) {\n\t\t\tfinal Column column = (Column) selectable;\n\t\t\tif ( column.getTemporalPrecision() != null ) {\n\t\t\t\treturn column.getTemporalPrecision();\n\t\t\t}\n\t\t\tfinal Integer precision = column.getPrecision();\n\t\t\treturn precision == null ? NO_COLUMN_PRECISION : precision;\n\t\t}\n\t\telse {\n\t\t\treturn NO_COLUMN_PRECISION;\n\t\t}\n\t}\n\n\t@Override\n\tpublic int getColumnScale() {\n\t\tfinal Selectable selectable = getColumn();\n\t\tif ( selectable instanceof Column ) {\n\t\t\tfinal Column column = (Column) selectable;\n\t\t\tfinal Integer scale = column.getScale();\n\t\t\treturn scale == null ? NO_COLUMN_SCALE : scale;\n\t\t}\n\t\telse {\n\t\t\treturn NO_COLUMN_SCALE;\n\t\t}\n\t}\n\n\t@Override\n\tpublic void addColumn(Column incomingColumn) {\n\t\tsuper.addColumn( incomingColumn );\n\n\t\tcheckSelectable( incomingColumn );\n\t}\n\n\t@Override\n\tpublic void copyTypeFrom(SimpleValue sourceValue) {\n\t\tsuper.copyTypeFrom( sourceValue );\n\t\tif ( sourceValue instanceof BasicValue ) {\n\t\t\tfinal BasicValue basicValue = (BasicValue) sourceValue;\n\t\t\tthis.resolution = basicValue.resolution;\n\t\t\tthis.implicitJavaTypeAccess = (typeConfiguration) -> basicValue.implicitJavaTypeAccess.apply( typeConfiguration );\n\t\t}\n\t}\n\n\tprivate void checkSelectable(Selectable incomingColumn) {\n\t\tif ( incomingColumn == null ) {\n\t\t\tthrow new IllegalArgumentException( \"Incoming column was null\" );\n\t\t}\n\n\t\tfinal Selectable column = getColumn();\n\t\tif ( column == incomingColumn || column.getText().equals( incomingColumn.getText() ) ) {\n\t\t\tlog.debugf( \"Skipping column re-registration: %s.%s\", getTable().getName(), column.getText() );\n\t\t}\n//\t\telse {\n//\t\t\tthrow new IllegalStateException(\n//\t\t\t\t\t\"BasicValue [\" + ownerName + \".\" + propertyName +\n//\t\t\t\t\t\t\t\"] already had column associated: `\" + column.getText() +\n//\t\t\t\t\t\t\t\"` -> `\" + incomingColumn.getText() + \"`\"\n//\t\t\t);\n//\t\t}\n\t}\n\n\t@Override\n\tpublic void addColumn(Column incomingColumn, boolean isInsertable, boolean isUpdatable) {\n\t\tsuper.addColumn( incomingColumn, isInsertable, isUpdatable );\n\t\tcheckSelectable( incomingColumn );\n\t}\n\n\t@Override\n\tpublic void addFormula(Formula formula) {\n\t\tsuper.addFormula( formula );\n\n\t\tcheckSelectable( formula );\n\t}\n\n\t// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\t// Resolution\n\n\t@Override\n\tpublic Type getType() throws MappingException {\n\t\tresolve();\n\t\tassert getResolution() != null;\n\n\t\treturn getResolution().getLegacyResolvedBasicType();\n\t}\n\n\tpublic Resolution<?> getResolution() {\n\t\treturn resolution;\n\t}\n\n\t@Override\n\tpublic boolean resolve(MetadataBuildingContext buildingContext) {\n\t\tresolve();\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic Resolution<?> resolve() {\n\t\tif ( resolution != null ) {\n\t\t\treturn resolution;\n\t\t}\n\n\t\tresolution = buildResolution();\n\n\t\tif ( resolution == null ) {\n\t\t\tthrow new IllegalStateException( \"Unable to resolve BasicValue : \" + this );\n\t\t}\n\n\t\tfinal Selectable selectable = getColumn();\n\t\tfinal Size size;\n\t\tif ( selectable instanceof Column column ) {\n\t\t\tresolveColumn( column, getDialect() );\n\t\t\tsize = column.calculateColumnSize( getDialect(), getBuildingContext().getMetadataCollector() );\n\t\t}\n\t\telse {\n\t\t\tsize = Size.nil();\n\t\t}\n\n\t\tresolution.getJdbcType().addAuxiliaryDatabaseObjects(\n\t\t\t\tresolution.getRelationalJavaType(),\n\t\t\t\tresolution.getValueConverter(),\n\t\t\t\tsize,\n\t\t\t\tgetBuildingContext().getMetadataCollector().getDatabase(),\n\t\t\t\tthis\n\t\t);\n\n\t\treturn resolution;\n\t}\n\n\t@Override\n\tpublic String getExtraCreateTableInfo() {\n\t\treturn resolution.getJdbcType()\n\t\t\t\t.getExtraCreateTableInfo(\n\t\t\t\t\t\tresolution.getRelationalJavaType(),\n\t\t\t\t\t\tgetColumn().getText(),\n\t\t\t\t\t\tgetTable().getName(),\n\t\t\t\t\t\tgetBuildingContext().getMetadataCollector().getDatabase()\n\t\t\t\t);\n\t}\n\n\t@Override\n\tpublic Dialect getDialect() {\n\t\treturn getMetadata().getDatabase().getDialect();\n\t}\n\n\tprivate void resolveColumn(Column column, Dialect dialect) {\n\n\t\tif ( column.getSqlTypeCode() == null ) {\n\t\t\tcolumn.setSqlTypeCode( resolution.getJdbcType().getDdlTypeCode() );\n\t\t}\n\n//\t\tfinal String declaration = resolution.getLegacyResolvedBasicType().getSpecializedTypeDeclaration( dialect );\n//\t\tif ( declaration != null ) {\n//\t\t\tcolumn.setSpecializedTypeDeclaration( declaration );\n//\t\t}\n\n\t\tif ( dialect.supportsColumnCheck() ) {\n\t\t\tfinal String checkCondition = resolution.getLegacyResolvedBasicType()\n\t\t\t\t\t.getCheckCondition( column.getQuotedName( dialect ), dialect );\n\t\t\tif ( checkCondition != null ) {\n\t\t\t\tcolumn.addCheckConstraint( new CheckConstraint( checkCondition ) );\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic AggregateColumn getAggregateColumn() {\n\t\treturn aggregateColumn;\n\t}\n\n\tpublic void setAggregateColumn(AggregateColumn aggregateColumn) {\n\t\tthis.aggregateColumn = aggregateColumn;\n\t}\n\n\tpublic SelectablePath createSelectablePath(String selectableName) {\n\t\tif ( aggregateColumn != null ) {\n\t\t\treturn aggregateColumn.getSelectablePath().append( selectableName );\n\t\t}\n\t\treturn new SelectablePath( selectableName );\n\t}\n\n\tprotected Resolution<?> buildResolution() {\n\t\tfinal Properties typeParameters = getTypeParameters();\n\t\tif ( typeParameters != null\n\t\t\t\t&& parseBoolean( typeParameters.getProperty(DynamicParameterizedType.IS_DYNAMIC) )\n\t\t\t\t&& typeParameters.get(DynamicParameterizedType.PARAMETER_TYPE) == null ) {\n\t\t\tcreateParameterImpl();\n\t\t}\n\n\t\tif ( explicitTypeName != null ) {\n\t\t\treturn interpretExplicitlyNamedType(\n\t\t\t\t\texplicitTypeName,\n\t\t\t\t\texplicitJavaTypeAccess,\n\t\t\t\t\texplicitJdbcTypeAccess,\n\t\t\t\t\texplicitMutabilityPlanAccess,\n\t\t\t\t\tgetAttributeConverterDescriptor(),\n\t\t\t\t\ttypeParameters,\n\t\t\t\t\tthis::setTypeParameters,\n\t\t\t\t\tthis,\n\t\t\t\t\tgetBuildingContext()\n\t\t\t);\n\t\t}\n\n\t\tif ( isVersion() ) {\n\t\t\treturn VersionResolution.from( implicitJavaTypeAccess, timeZoneStorageType, getBuildingContext() );\n\t\t}\n\n\t\t// determine JavaType if we can\n\t\tfinal BasicJavaType<?> explicitJavaType = explicitJavaTypeAccess == null\n\t\t\t\t? null\n\t\t\t\t: explicitJavaTypeAccess.apply( getTypeConfiguration() );\n\n\t\tJavaType<?> javaType = determineJavaType( explicitJavaType );\n\t\tConverterDescriptor attributeConverterDescriptor = getAttributeConverterDescriptor();\n\n\t\tif ( isSoftDelete() ) {\n\t\t\tassert attributeConverterDescriptor != null;\n\t\t\tfinal boolean conversionWasUnspecified = SoftDelete.UnspecifiedConversion.class.equals( attributeConverterDescriptor.getAttributeConverterClass() );\n\t\t\tif ( conversionWasUnspecified ) {\n\t\t\t\tfinal JdbcType jdbcType = BooleanJdbcType.INSTANCE.resolveIndicatedType( this, javaType );\n\t\t\t\tif ( jdbcType.isNumber() ) {\n\t\t\t\t\tattributeConverterDescriptor = new InstanceBasedConverterDescriptor(\n\t\t\t\t\t\t\tNumericBooleanConverter.INSTANCE,\n\t\t\t\t\t\t\tgetBuildingContext().getBootstrapContext().getClassmateContext()\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\telse if ( jdbcType.isString() ) {\n\t\t\t\t\t// here we pick 'T' / 'F' storage, though 'Y' / 'N' is equally valid - its 50/50\n\t\t\t\t\tattributeConverterDescriptor = new InstanceBasedConverterDescriptor(\n\t\t\t\t\t\t\tTrueFalseConverter.INSTANCE,\n\t\t\t\t\t\t\tgetBuildingContext().getBootstrapContext().getClassmateContext()\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// should indicate BIT or BOOLEAN == no conversion needed\n\t\t\t\t\t//\t\t- we still create the converter to properly set up JDBC type, etc\n\t\t\t\t\tattributeConverterDescriptor = new InstanceBasedConverterDescriptor(\n\t\t\t\t\t\t\tPassThruSoftDeleteConverter.INSTANCE,\n\t\t\t\t\t\t\tgetBuildingContext().getBootstrapContext().getClassmateContext()\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( getSoftDeleteStrategy() == SoftDeleteType.ACTIVE ) {\n\t\t\t\tattributeConverterDescriptor = new ReversedConverterDescriptor<>( attributeConverterDescriptor );\n\t\t\t}\n\t\t}\n\n\t\treturn attributeConverterDescriptor != null\n\t\t\t\t? converterResolution( javaType, attributeConverterDescriptor )\n\t\t\t\t: resolution( explicitJavaType, javaType );\n\t}\n\n\tprivate static class ReversedConverterDescriptor<R> implements ConverterDescriptor {\n\t\tprivate final ConverterDescriptor underlyingDescriptor;\n\n\t\tpublic ReversedConverterDescriptor(ConverterDescriptor underlyingDescriptor) {\n\t\t\tthis.underlyingDescriptor = underlyingDescriptor;\n\t\t}\n\n\t\t@Override\n\t\tpublic Class<? extends AttributeConverter<Boolean,R>> getAttributeConverterClass() {\n\t\t\t//noinspection unchecked\n\t\t\treturn (Class<? extends AttributeConverter<Boolean, R>>) getClass();\n\t\t}\n\n\t\t@Override\n\t\tpublic ResolvedType getDomainValueResolvedType() {\n\t\t\treturn underlyingDescriptor.getDomainValueResolvedType();\n\t\t}\n\n\t\t@Override\n\t\tpublic ResolvedType getRelationalValueResolvedType() {\n\t\t\treturn underlyingDescriptor.getRelationalValueResolvedType();\n\t\t}\n\n\t\t@Override\n\t\tpublic AutoApplicableConverterDescriptor getAutoApplyDescriptor() {\n\t\t\treturn AutoApplicableConverterDescriptorBypassedImpl.INSTANCE;\n\t\t}\n\n\t\t@Override\n\t\tpublic JpaAttributeConverter<Boolean,R> createJpaAttributeConverter(JpaAttributeConverterCreationContext context) {\n\t\t\t//noinspection unchecked\n\t\t\treturn new ReversedJpaAttributeConverter<>(\n\t\t\t\t\t(JpaAttributeConverter<Boolean, R>) underlyingDescriptor.createJpaAttributeConverter( context ),\n\t\t\t\t\tcontext.getJavaTypeRegistry().getDescriptor( ReversedJpaAttributeConverter.class )\n\t\t\t);\n\t\t}\n\t}\n\n\tprivate static class ReversedJpaAttributeConverter<R, B extends AttributeConverter<Boolean, R>>\n\t\t\timplements JpaAttributeConverter<Boolean,R>, AttributeConverter<Boolean,R>, ManagedBean<B> {\n\t\tprivate final JpaAttributeConverter<Boolean,R> underlyingJpaConverter;\n\t\tprivate final JavaType<ReversedJpaAttributeConverter<R,B>> converterJavaType;\n\n\t\tpublic ReversedJpaAttributeConverter(\n\t\t\t\tJpaAttributeConverter<Boolean, R> underlyingJpaConverter,\n\t\t\t\tJavaType<ReversedJpaAttributeConverter<R,B>> converterJavaType) {\n\t\t\tthis.underlyingJpaConverter = underlyingJpaConverter;\n\t\t\tthis.converterJavaType = converterJavaType;\n\t\t}\n\n\t\t@Override\n\t\tpublic Boolean toDomainValue(R relationalValue) {\n\t\t\treturn !underlyingJpaConverter.toDomainValue( relationalValue );\n\t\t}\n\n\t\t@Override\n\t\tpublic R toRelationalValue(Boolean domainValue) {\n\t\t\treturn underlyingJpaConverter.toRelationalValue( domainValue != null ? !domainValue : null );\n\t\t}\n\n\t\t@Override\n\t\tpublic Boolean convertToEntityAttribute(R relationalValue) {\n\t\t\treturn toDomainValue( relationalValue );\n\t\t}\n\n\t\t@Override\n\t\tpublic R convertToDatabaseColumn(Boolean domainValue) {\n\t\t\treturn toRelationalValue( domainValue );\n\t\t}\n\n\t\t@Override\n\t\tpublic JavaType<Boolean> getDomainJavaType() {\n\t\t\treturn underlyingJpaConverter.getDomainJavaType();\n\t\t}\n\n\t\t@Override\n\t\tpublic JavaType<R> getRelationalJavaType() {\n\t\t\treturn underlyingJpaConverter.getRelationalJavaType();\n\t\t}\n\n\t\t@Override\n\t\tpublic JavaType<? extends AttributeConverter<Boolean, R>> getConverterJavaType() {\n\t\t\treturn converterJavaType;\n\t\t}\n\n\t\t@Override\n\t\tpublic ManagedBean<? extends AttributeConverter<Boolean, R>> getConverterBean() {\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\tpublic Class<B> getBeanClass() {\n\t\t\t//noinspection unchecked\n\t\t\treturn (Class<B>) getClass();\n\t\t}\n\n\t\t@Override\n\t\tpublic B getBeanInstance() {\n\t\t\t//noinspection unchecked\n\t\t\treturn (B) this;\n\t\t}\n\t}\n\n\tprivate static class PassThruSoftDeleteConverter implements AttributeConverter<Boolean,Boolean> {\n\t\tprivate static final PassThruSoftDeleteConverter INSTANCE = new PassThruSoftDeleteConverter();\n\n\t\t@Override\n\t\tpublic Boolean convertToDatabaseColumn(Boolean domainValue) {\n\t\t\treturn domainValue;\n\t\t}\n\n\t\t@Override\n\t\tpublic Boolean convertToEntityAttribute(Boolean relationalValue) {\n\t\t\treturn relationalValue;\n\t\t}\n\t}\n\n\tprivate Resolution<?> resolution(BasicJavaType explicitJavaType, JavaType<?> javaType) {\n\t\tfinal JavaType<?> basicJavaType;\n\t\tfinal JdbcType jdbcType;\n\t\tif ( explicitJdbcTypeAccess != null ) {\n\t\t\tfinal TypeConfiguration typeConfiguration = getTypeConfiguration();\n\t\t\tjdbcType = explicitJdbcTypeAccess.apply( typeConfiguration );\n\t\t\tbasicJavaType = javaType == null && jdbcType != null\n\t\t\t\t\t? jdbcType.getJdbcRecommendedJavaTypeMapping(null, null, typeConfiguration)\n\t\t\t\t\t: javaType;\n\t\t}\n\t\telse {\n\t\t\tjdbcType = null;\n\t\t\tbasicJavaType = javaType;\n\t\t}\n\t\tif ( basicJavaType == null ) {\n\t\t\tthrow new MappingException( \"Unable to determine JavaType to use : \" + this );\n\t\t}\n\n\t\tif ( basicJavaType instanceof BasicJavaType<?>\n\t\t\t\t&& ( !basicJavaType.getJavaTypeClass().isEnum() || enumerationStyle == null ) ) {\n\t\t\tfinal TypeDefinition autoAppliedTypeDef =\n\t\t\t\t\tgetBuildingContext().getTypeDefinitionRegistry()\n\t\t\t\t\t\t\t.resolveAutoApplied( (BasicJavaType<?>) basicJavaType );\n\t\t\tif ( autoAppliedTypeDef != null ) {\n\t\t\t\tlog.debug(\"BasicValue resolution matched auto-applied type-definition\");\n\t\t\t\treturn autoAppliedTypeDef.resolve( getTypeParameters(), null, getBuildingContext(), this );\n\t\t\t}\n\t\t}\n\n\t\treturn InferredBasicValueResolver.from(\n\t\t\t\texplicitJavaType,\n\t\t\t\tjdbcType,\n\t\t\t\tresolvedJavaType,\n\t\t\t\tthis::determineReflectedJavaType,\n\t\t\t\texplicitMutabilityPlanAccess,\n\t\t\t\tthis,\n\t\t\t\tgetTable(),\n\t\t\t\tgetColumn(),\n\t\t\t\townerName,\n\t\t\t\tpropertyName,\n\t\t\t\tgetBuildingContext()\n\t\t);\n\t}\n\n\t@Override\n\tpublic ManagedBeanRegistry getManagedBeanRegistry() {\n\t\treturn getServiceRegistry().requireService( ManagedBeanRegistry.class );\n\t}\n\n\tprivate Resolution<?> converterResolution(JavaType<?> javaType, ConverterDescriptor attributeConverterDescriptor) {\n\t\tfinal NamedConverterResolution<?> converterResolution = NamedConverterResolution.from(\n\t\t\t\tattributeConverterDescriptor,\n\t\t\t\texplicitJavaTypeAccess,\n\t\t\t\texplicitJdbcTypeAccess,\n\t\t\t\texplicitMutabilityPlanAccess,\n\t\t\t\tresolvedJavaType,\n\t\t\t\tthis,\n\t\t\t\tthis,\n\t\t\t\tgetBuildingContext()\n\t\t);\n\n\t\tif ( javaType instanceof BasicPluralJavaType<?>\n\t\t\t\t&& !attributeConverterDescriptor.getDomainValueResolvedType().getErasedType()\n\t\t\t\t\t\t.isAssignableFrom( javaType.getJavaTypeClass() ) ) {\n\t\t\t// In this case, the converter applies to the element of a BasicPluralJavaType\n\t\t\tfinal BasicPluralJavaType<?> containerJtd = (BasicPluralJavaType<?>) javaType;\n\t\t\tfinal BasicType registeredElementType = converterResolution.getLegacyResolvedBasicType();\n\t\t\tfinal Selectable column = getColumn();\n\t\t\tfinal BasicType<?> registeredType = registeredElementType == null ? null\n\t\t\t\t\t: containerJtd.resolveType(\n\t\t\t\t\t\t\tgetTypeConfiguration(),\n\t\t\t\t\t\t\tgetDialect(),\n\t\t\t\t\t\t\tregisteredElementType,\n\t\t\t\t\t\t\tcolumn instanceof ColumnTypeInformation ? (ColumnTypeInformation) column : null,\n\t\t\t\t\t\t\tthis\n\t\t\t);\n\t\t\tif ( registeredType != null ) {\n\t\t\t\tgetTypeConfiguration().getBasicTypeRegistry().register( registeredType );\n\t\t\t\treturn new InferredBasicValueResolution(\n\t\t\t\t\t\tregisteredType,\n\t\t\t\t\t\tregisteredType.getJavaTypeDescriptor(),\n\t\t\t\t\t\tregisteredType.getJavaTypeDescriptor(),\n\t\t\t\t\t\tregisteredType.getJdbcType(),\n\t\t\t\t\t\tregisteredType,\n\t\t\t\t\t\tnull\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\treturn converterResolution;\n\t}\n\n\tprivate JavaType<?> determineJavaType(JavaType<?> explicitJavaType) {\n\t\tJavaType<?> javaType = explicitJavaType;\n//\n//\t\tif ( javaType == null ) {\n//\t\t\tif ( implicitJavaTypeAccess != null ) {\n//\t\t\t\tfinal java.lang.reflect.Type implicitJtd = implicitJavaTypeAccess.apply( getTypeConfiguration() );\n//\t\t\t\tif ( implicitJtd != null ) {\n//\t\t\t\t\tjavaType = getTypeConfiguration().getJavaTypeRegistry().getDescriptor( implicitJtd );\n//\t\t\t\t}\n//\t\t\t}\n//\t\t}\n\n\t\tif ( javaType == null ) {\n\t\t\tfinal JavaType<?> reflectedJtd = determineReflectedJavaType();\n\t\t\tif ( reflectedJtd != null ) {\n\t\t\t\tjavaType = reflectedJtd;\n\t\t\t}\n\t\t}\n\n\t\treturn javaType;\n\t}\n\n\tprivate JavaType<?> determineReflectedJavaType() {\n\t\tfinal java.lang.reflect.Type impliedJavaType;\n\n\t\tfinal TypeConfiguration typeConfiguration = getTypeConfiguration();\n\t\tif ( resolvedJavaType != null ) {\n\t\t\timpliedJavaType = resolvedJavaType;\n\t\t}\n\t\telse if ( implicitJavaTypeAccess != null ) {\n\t\t\timpliedJavaType = implicitJavaTypeAccess.apply( typeConfiguration );\n\t\t}\n\t\telse if ( ownerName != null && propertyName != null ) {\n\t\t\timpliedJavaType = ReflectHelper.reflectedPropertyType(\n\t\t\t\t\townerName,\n\t\t\t\t\tpropertyName,\n\t\t\t\t\tgetServiceRegistry().requireService( ClassLoaderService.class )\n\t\t\t);\n\t\t}\n\t\telse {\n\t\t\treturn null;\n\t\t}\n\n\t\tresolvedJavaType = impliedJavaType;\n\n\t\tif ( impliedJavaType == null ) {\n\t\t\treturn null;\n\t\t}\n\n\t\tfinal JavaTypeRegistry javaTypeRegistry = typeConfiguration.getJavaTypeRegistry();\n\t\tfinal JavaType<Object> javaType = javaTypeRegistry.findDescriptor( impliedJavaType );\n\t\tfinal MutabilityPlan<Object> explicitMutabilityPlan = explicitMutabilityPlanAccess != null\n\t\t\t\t? explicitMutabilityPlanAccess.apply( typeConfiguration )\n\t\t\t\t: null;\n\t\tfinal MutabilityPlan<Object> determinedMutabilityPlan = explicitMutabilityPlan != null\n\t\t\t\t? explicitMutabilityPlan\n\t\t\t\t: RegistryHelper.INSTANCE.determineMutabilityPlan( impliedJavaType, typeConfiguration );\n\t\tif ( javaType == null ) {\n\t\t\tif ( jdbcTypeCode != null ) {\n\t\t\t\t// Construct special JavaType instances for JSON/XML types which can report recommended JDBC types\n\t\t\t\t// and implement toString/fromString as well as copying based on FormatMapper operations\n\t\t\t\tswitch ( jdbcTypeCode ) {\n\t\t\t\t\tcase SqlTypes.JSON:\n\t\t\t\t\t\tfinal JavaType<Object> jsonJavaType = new JsonJavaType<>(\n\t\t\t\t\t\t\t\timpliedJavaType,\n\t\t\t\t\t\t\t\tdeterminedMutabilityPlan,\n\t\t\t\t\t\t\t\ttypeConfiguration\n\t\t\t\t\t\t);\n\t\t\t\t\t\tjavaTypeRegistry.addDescriptor( jsonJavaType );\n\t\t\t\t\t\treturn jsonJavaType;\n\t\t\t\t\tcase SqlTypes.SQLXML:\n\t\t\t\t\t\tfinal JavaType<Object> xmlJavaType = new XmlJavaType<>(\n\t\t\t\t\t\t\t\timpliedJavaType,\n\t\t\t\t\t\t\t\tdeterminedMutabilityPlan,\n\t\t\t\t\t\t\t\ttypeConfiguration\n\t\t\t\t\t\t);\n\t\t\t\t\t\tjavaTypeRegistry.addDescriptor( xmlJavaType );\n\t\t\t\t\t\treturn xmlJavaType;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn javaTypeRegistry.resolveDescriptor( impliedJavaType );\n\t\t}\n\t\treturn javaType;\n\t}\n\n\tprivate static Resolution<?> interpretExplicitlyNamedType(\n\t\t\tString name,\n\t\t\tFunction<TypeConfiguration, BasicJavaType> explicitJtdAccess,\n\t\t\tFunction<TypeConfiguration, JdbcType> explicitStdAccess,\n\t\t\tFunction<TypeConfiguration, MutabilityPlan> explicitMutabilityPlanAccess,\n\t\t\tConverterDescriptor converterDescriptor,\n\t\t\tMap<Object,Object> localTypeParams,\n\t\t\tConsumer<Properties> combinedParameterConsumer,\n\t\t\tJdbcTypeIndicators stdIndicators,\n\t\t\tMetadataBuildingContext context) {\n\n\t\tfinal StandardServiceRegistry serviceRegistry = context.getBootstrapContext().getServiceRegistry();\n\t\tfinal ManagedBeanRegistry managedBeanRegistry = serviceRegistry.requireService( ManagedBeanRegistry.class );\n\t\tfinal TypeConfiguration typeConfiguration = context.getBootstrapContext().getTypeConfiguration();\n\n\t\tfinal JpaAttributeConverterCreationContext converterCreationContext = new JpaAttributeConverterCreationContext() {\n\t\t\t@Override\n\t\t\tpublic ManagedBeanRegistry getManagedBeanRegistry() {\n\t\t\t\treturn managedBeanRegistry;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic TypeConfiguration getTypeConfiguration() {\n\t\t\t\treturn typeConfiguration;\n\t\t\t}\n\t\t};\n\n\t\t// Name could refer to:\n\t\t//\t\t1) a named converter - HBM support for JPA's AttributeConverter via its `type=\"...\"` XML attribute\n\t\t//\t\t2) a \"named composed\" mapping - like (1), this is mainly to support envers since it tells\n\t\t//\t\t\tHibernate the mappings via DOM.  See `org.hibernate.type.internal.BasicTypeImpl`\n\t\t//\t\t3) basic type \"resolution key\"\n\t\t//\t\t4) UserType or BasicType class name - directly, or through a TypeDefinition\n\n\t\tif ( name.startsWith( ConverterDescriptor.TYPE_NAME_PREFIX  ) ) {\n\t\t\treturn NamedConverterResolution.from(\n\t\t\t\t\tname,\n\t\t\t\t\texplicitJtdAccess,\n\t\t\t\t\texplicitStdAccess,\n\t\t\t\t\texplicitMutabilityPlanAccess,\n\t\t\t\t\tstdIndicators,\n\t\t\t\t\tconverterCreationContext,\n\t\t\t\t\tcontext\n\t\t\t);\n\t\t}\n\n//\t\tif ( name.startsWith( EnumeratedValueResolution.PREFIX ) ) {\n//\t\t\treturn EnumeratedValueResolution.fromName( name, stdIndicators, context );\n//\t\t}\n\n\t\tif ( name.startsWith( BasicTypeImpl.EXTERNALIZED_PREFIX ) ) {\n\t\t\tfinal BasicType<Object> basicType = context.getBootstrapContext().resolveAdHocBasicType( name );\n\t\t\treturn new NamedBasicTypeResolution<>(\n\t\t\t\t\tbasicType.getJavaTypeDescriptor(),\n\t\t\t\t\tbasicType,\n\t\t\t\t\tnull,\n\t\t\t\t\texplicitMutabilityPlanAccess,\n\t\t\t\t\tcontext\n\t\t\t);\n\t\t}\n\n\t\t// see if it is a named basic type\n\t\tfinal BasicType<?> basicTypeByName = typeConfiguration.getBasicTypeRegistry().getRegisteredType( name );\n\t\tif ( basicTypeByName != null ) {\n\t\t\tfinal BasicValueConverter<?,?> valueConverter;\n\t\t\tfinal JavaType<?> domainJtd;\n\t\t\tif ( converterDescriptor != null ) {\n\t\t\t\tvalueConverter = converterDescriptor.createJpaAttributeConverter( converterCreationContext );\n\t\t\t\tdomainJtd = valueConverter.getDomainJavaType();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tvalueConverter = basicTypeByName.getValueConverter();\n\t\t\t\tdomainJtd = basicTypeByName.getJavaTypeDescriptor();\n\t\t\t}\n\n\t\t\treturn new NamedBasicTypeResolution<>(\n\t\t\t\t\tdomainJtd,\n\t\t\t\t\tbasicTypeByName,\n\t\t\t\t\tvalueConverter,\n\t\t\t\t\texplicitMutabilityPlanAccess,\n\t\t\t\t\tcontext\n\t\t\t);\n\t\t}\n\n\t\t// see if it is a named TypeDefinition\n\t\tfinal TypeDefinition typeDefinition = context.getTypeDefinitionRegistry().resolve( name );\n\t\tif ( typeDefinition != null ) {\n\t\t\tfinal Resolution<?> resolution = typeDefinition.resolve(\n\t\t\t\t\tlocalTypeParams,\n\t\t\t\t\texplicitMutabilityPlanAccess != null\n\t\t\t\t\t\t\t? explicitMutabilityPlanAccess.apply( typeConfiguration )\n\t\t\t\t\t\t\t: null,\n\t\t\t\t\tcontext,\n\t\t\t\t\tstdIndicators\n\t\t\t);\n\t\t\tcombinedParameterConsumer.accept( resolution.getCombinedTypeParameters() );\n\t\t\treturn resolution;\n\t\t}\n\n\n\t\t// see if the name is a UserType or BasicType implementor class name\n\t\tfinal ClassLoaderService cls = serviceRegistry.requireService( ClassLoaderService.class );\n\t\ttry {\n\t\t\tfinal Class<?> typeNamedClass = cls.classForName( name );\n\n\t\t\t// if there are no local config params, register an implicit TypeDefinition for this custom type .\n\t\t\t//  later uses may find it and re-use its cacheable reference...\n\t\t\tif ( CollectionHelper.isEmpty( localTypeParams ) ) {\n\t\t\t\tfinal TypeDefinition implicitDefinition = new TypeDefinition(\n\t\t\t\t\t\tname,\n\t\t\t\t\t\ttypeNamedClass,\n\t\t\t\t\t\tnull,\n\t\t\t\t\t\tnull\n\t\t\t\t);\n\t\t\t\tcontext.getTypeDefinitionRegistry().register( implicitDefinition );\n\t\t\t\treturn implicitDefinition.resolve(\n\t\t\t\t\t\tlocalTypeParams,\n\t\t\t\t\t\texplicitMutabilityPlanAccess != null\n\t\t\t\t\t\t\t\t? explicitMutabilityPlanAccess.apply( typeConfiguration )\n\t\t\t\t\t\t\t\t: null,\n\t\t\t\t\t\tcontext,\n\t\t\t\t\t\tstdIndicators\n\t\t\t\t);\n\t\t\t}\n\n\t\t\treturn TypeDefinition.createLocalResolution( name, typeNamedClass, localTypeParams, context );\n\t\t}\n\t\tcatch (ClassLoadingException e) {\n\t\t\t// allow the exception below to trigger\n\t\t\tlog.debugf( \"Could not resolve type-name [%s] as Java type : %s\", name, e );\n\t\t}\n\n\t\tthrow new MappingException( \"Could not resolve named type : \" + name );\n\t}\n\n\n\t// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\t// SqlTypeDescriptorIndicators\n\n\t@Override\n\tpublic EnumType getEnumeratedType() {\n\t\treturn getEnumerationStyle();\n\t}\n\n\n\t@Override\n\tpublic int getPreferredSqlTypeCodeForBoolean() {\n\t\treturn resolveJdbcTypeCode( getBuildingContext().getPreferredSqlTypeCodeForBoolean() );\n\t}\n\n\t@Override\n\tpublic int getPreferredSqlTypeCodeForDuration() {\n\t\treturn resolveJdbcTypeCode( getBuildingContext().getPreferredSqlTypeCodeForDuration() );\n\t}\n\n\t@Override\n\tpublic int getPreferredSqlTypeCodeForUuid() {\n\t\treturn resolveJdbcTypeCode( getBuildingContext().getPreferredSqlTypeCodeForUuid() );\n\t}\n\n\t@Override\n\tpublic int getPreferredSqlTypeCodeForInstant() {\n\t\treturn resolveJdbcTypeCode( getBuildingContext().getPreferredSqlTypeCodeForInstant() );\n\t}\n\n\t@Override\n\tpublic int getPreferredSqlTypeCodeForArray() {\n\t\treturn resolveJdbcTypeCode( getBuildingContext().getPreferredSqlTypeCodeForArray() );\n\t}\n\n\t@Override\n\tpublic int resolveJdbcTypeCode(int jdbcTypeCode) {\n\t\treturn aggregateColumn == null\n\t\t\t\t? jdbcTypeCode\n\t\t\t\t: getDialect().getAggregateSupport()\n\t\t\t\t.aggregateComponentSqlTypeCode( aggregateColumn.getSqlTypeCode( getMetadata() ), jdbcTypeCode );\n\t}\n\n\t@Override\n\tpublic TimeZoneStorageStrategy getDefaultTimeZoneStorageStrategy() {\n\t\treturn timeZoneStorageStrategy( timeZoneStorageType, getBuildingContext() );\n\t}\n\n\t@Internal\n\tpublic static TimeZoneStorageStrategy timeZoneStorageStrategy(\n\t\t\tTimeZoneStorageType timeZoneStorageType,\n\t\t\tMetadataBuildingContext buildingContext) {\n\t\tif ( timeZoneStorageType != null ) {\n\t\t\tswitch ( timeZoneStorageType ) {\n\t\t\t\tcase COLUMN:\n\t\t\t\t\treturn TimeZoneStorageStrategy.COLUMN;\n\t\t\t\tcase NATIVE:\n\t\t\t\t\treturn TimeZoneStorageStrategy.NATIVE;\n\t\t\t\tcase NORMALIZE:\n\t\t\t\t\treturn TimeZoneStorageStrategy.NORMALIZE;\n\t\t\t\tcase NORMALIZE_UTC:\n\t\t\t\t\treturn TimeZoneStorageStrategy.NORMALIZE_UTC;\n\t\t\t}\n\t\t}\n\t\treturn buildingContext.getBuildingOptions().getDefaultTimeZoneStorage();\n\t}\n\n\tpublic void setExplicitTypeParams(Map<String,String> explicitLocalTypeParams) {\n\t\tthis.explicitLocalTypeParams = explicitLocalTypeParams;\n\t}\n\n\tpublic void setExplicitTypeName(String typeName) {\n\t\tthis.explicitTypeName = typeName;\n\t}\n\n\tpublic void setTypeName(String typeName) {\n\t\tif ( StringHelper.isNotEmpty( typeName ) ) {\n\t\t\tif ( typeName.startsWith( ConverterDescriptor.TYPE_NAME_PREFIX ) ) {\n\t\t\t\tfinal String converterClassName = typeName.substring( ConverterDescriptor.TYPE_NAME_PREFIX.length() );\n\t\t\t\tfinal ClassLoaderService cls = getServiceRegistry().requireService( ClassLoaderService.class );\n\t\t\t\ttry {\n\t\t\t\t\tfinal Class<AttributeConverter<?,?>> converterClass = cls.classForName( converterClassName );\n\t\t\t\t\tsetAttributeConverterDescriptor( new ClassBasedConverterDescriptor(\n\t\t\t\t\t\t\tconverterClass,\n\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\tgetBuildingContext().getBootstrapContext().getClassmateContext()\n\t\t\t\t\t) );\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tcatch (Exception e) {\n\t\t\t\t\tlog.logBadHbmAttributeConverterType( typeName, e.getMessage() );\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsetExplicitTypeName( typeName );\n\t\t\t}\n\t\t}\n\n\t\tsuper.setTypeName( typeName );\n\t}\n\n\tprivate static int COUNTER;\n\n\tpublic void setExplicitCustomType(Class<? extends UserType<?>> explicitCustomType) {\n\t\tif ( explicitCustomType != null ) {\n\t\t\tif ( resolution != null ) {\n\t\t\t\tthrow new UnsupportedOperationException( \"Unsupported attempt to set an explicit-custom-type when value is already resolved\" );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tresolution = new UserTypeResolution<>(\n\t\t\t\t\t\tnew CustomType<>(\n\t\t\t\t\t\t\t\tgetConfiguredUserTypeBean( explicitCustomType, getCustomTypeProperties() ),\n\t\t\t\t\t\t\t\tgetTypeConfiguration()\n\t\t\t\t\t\t),\n\t\t\t\t\t\tnull,\n\t\t\t\t\t\tgetCustomTypeProperties()\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate Properties getCustomTypeProperties() {\n\t\tfinal Properties properties = new Properties();\n\t\tif ( isNotEmpty( getTypeParameters() ) ) {\n\t\t\tproperties.putAll( getTypeParameters() );\n\t\t}\n\t\tif ( isNotEmpty( explicitLocalTypeParams ) ) {\n\t\t\tproperties.putAll( explicitLocalTypeParams );\n\t\t}\n\t\treturn properties;\n\t}\n\n\tprivate UserType<?> getConfiguredUserTypeBean(Class<? extends UserType<?>> explicitCustomType, Properties properties) {\n\t\tfinal UserType<?> typeInstance =\n\t\t\t\t!getBuildingContext().getBuildingOptions().isAllowExtensionsInCdi()\n\t\t\t\t\t\t? FallbackBeanInstanceProducer.INSTANCE.produceBeanInstance( explicitCustomType )\n\t\t\t\t\t\t: getUserTypeBean( explicitCustomType, properties ).getBeanInstance();\n\n\t\tif ( typeInstance instanceof TypeConfigurationAware ) {\n\t\t\tfinal TypeConfigurationAware configurationAware = (TypeConfigurationAware) typeInstance;\n\t\t\tconfigurationAware.setTypeConfiguration( getTypeConfiguration() );\n\t\t}\n\n\t\tif ( typeInstance instanceof DynamicParameterizedType ) {\n\t\t\tif ( parseBoolean( properties.getProperty( DynamicParameterizedType.IS_DYNAMIC ) ) ) {\n\t\t\t\tif ( properties.get( DynamicParameterizedType.PARAMETER_TYPE ) == null ) {\n\t\t\t\t\tproperties.put( DynamicParameterizedType.PARAMETER_TYPE, makeParameterImpl() );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tinjectParameters( typeInstance, properties);\n\t\t// envers - grr\n\t\tsetTypeParameters( properties );\n\n\t\treturn typeInstance;\n\t}\n\n\tprivate <T> ManagedBean<T> getUserTypeBean(Class<T> explicitCustomType, Properties properties) {\n\t\tfinal BeanInstanceProducer producer = getBuildingContext().getBootstrapContext().getCustomTypeProducer();\n\t\tfinal ManagedBeanRegistry registry = getServiceRegistry().requireService( ManagedBeanRegistry.class );\n\t\tif ( isNotEmpty( properties ) ) {\n\t\t\tfinal String name = explicitCustomType.getName() + COUNTER++;\n\t\t\treturn registry.getBean( name, explicitCustomType, producer );\n\t\t}\n\t\telse {\n\t\t\treturn registry.getBean( explicitCustomType, producer );\n\t\t}\n\t}\n\n\tpublic void setTemporalPrecision(TemporalType temporalPrecision) {\n\t\tthis.temporalPrecision = temporalPrecision;\n\t}\n\n\t@Override\n\tpublic TemporalType getTemporalPrecision() {\n\t\treturn temporalPrecision;\n\t}\n\n\t@Override\n\tpublic boolean isPreferJavaTimeJdbcTypesEnabled() {\n\t\treturn getBuildingContext().isPreferJavaTimeJdbcTypesEnabled();\n\t}\n\n\t@Override\n\tpublic boolean isPreferNativeEnumTypesEnabled() {\n\t\treturn getBuildingContext().isPreferNativeEnumTypesEnabled();\n\t}\n\n\t@Override\n\tpublic Object accept(ValueVisitor visitor) {\n\t\treturn visitor.accept(this);\n\t}\n\n\t@Internal\n\tpublic boolean isDisallowedWrapperArray() {\n\t\treturn getBuildingContext().getBuildingOptions().getWrapperArrayHandling() == WrapperArrayHandling.DISALLOW\n\t\t\t&& !isLob()\n\t\t\t&& ( explicitJavaTypeAccess == null || explicitJavaTypeAccess.apply( getTypeConfiguration() ) == null )\n\t\t\t&& isWrapperByteOrCharacterArray();\n\t}\n\n\tprivate boolean isWrapperByteOrCharacterArray() {\n\t\tfinal Class<?> javaTypeClass = getResolution().getDomainJavaType().getJavaTypeClass();\n\t\treturn javaTypeClass == Byte[].class || javaTypeClass == Character[].class;\n\t}\n\n\t@Incubating\n\tpublic void setExplicitJdbcTypeCode(Integer jdbcTypeCode) {\n\t\tthis.jdbcTypeCode = jdbcTypeCode;\n\t}\n\n\t@Override\n\tpublic Integer getExplicitJdbcTypeCode() {\n\t\treturn jdbcTypeCode == null ? getPreferredSqlTypeCodeForArray() : jdbcTypeCode;\n\t}\n\n\t/**\n\t * Resolved form of {@link BasicValue} as part of interpreting the\n\t * boot-time model into the run-time model\n\t */\n\tpublic interface Resolution<J> {\n\t\t/**\n\t\t * The BasicType resolved using the pre-6.0 rules.  This is temporarily\n\t\t * needed because of the split in extracting / binding\n\t\t */\n\t\tBasicType<J> getLegacyResolvedBasicType();\n\n\t\t/**\n\t\t * Get the collection of type-parameters collected both locally as well\n\t\t * as from the applied type-def, if one\n\t\t */\n\t\tdefault Properties getCombinedTypeParameters() {\n\t\t\treturn null;\n\t\t}\n\n\t\tJdbcMapping getJdbcMapping();\n\n\t\t/**\n\t\t * The JavaType for the value as part of the domain model\n\t\t */\n\t\tJavaType<J> getDomainJavaType();\n\n\t\t/**\n\t\t * The JavaType for the relational value as part of\n\t\t * the relational model (its JDBC representation)\n\t\t */\n\t\tJavaType<?> getRelationalJavaType();\n\n\t\t/**\n\t\t * The JavaType for the relational value as part of\n\t\t * the relational model (its JDBC representation)\n\t\t */\n\t\tJdbcType getJdbcType();\n\n\t\t/**\n\t\t * Converter, if any, to convert values between the\n\t\t * domain and relational JavaType representations\n\t\t */\n\t\tBasicValueConverter<J,?> getValueConverter();\n\n\t\t/**\n\t\t * The resolved MutabilityPlan\n\t\t */\n\t\tMutabilityPlan<J> getMutabilityPlan();\n\n\t\tdefault void updateResolution(BasicType<?> type) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\t}\n}\n",
        "filePathAfter": "hibernate-core/src/main/java/org/hibernate/mapping/BasicValue.java",
        "sourceCodeAfterForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later\n * See the lgpl.txt file in the root directory or http://www.gnu.org/licenses/lgpl-2.1.html\n */\npackage org.hibernate.mapping;\n\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Properties;\nimport java.util.function.Consumer;\nimport java.util.function.Function;\n\nimport org.hibernate.Incubating;\nimport org.hibernate.Internal;\nimport org.hibernate.MappingException;\nimport org.hibernate.TimeZoneStorageStrategy;\nimport org.hibernate.annotations.SoftDelete;\nimport org.hibernate.annotations.SoftDeleteType;\nimport org.hibernate.annotations.TimeZoneStorageType;\nimport org.hibernate.boot.model.TypeDefinition;\nimport org.hibernate.boot.model.convert.internal.AutoApplicableConverterDescriptorBypassedImpl;\nimport org.hibernate.boot.model.convert.internal.ClassBasedConverterDescriptor;\nimport org.hibernate.boot.model.convert.internal.InstanceBasedConverterDescriptor;\nimport org.hibernate.boot.model.convert.spi.AutoApplicableConverterDescriptor;\nimport org.hibernate.boot.model.convert.spi.ConverterDescriptor;\nimport org.hibernate.boot.model.convert.spi.JpaAttributeConverterCreationContext;\nimport org.hibernate.boot.model.process.internal.InferredBasicValueResolution;\nimport org.hibernate.boot.model.process.internal.InferredBasicValueResolver;\nimport org.hibernate.boot.model.process.internal.NamedBasicTypeResolution;\nimport org.hibernate.boot.model.process.internal.NamedConverterResolution;\nimport org.hibernate.boot.model.process.internal.UserTypeResolution;\nimport org.hibernate.boot.model.process.internal.VersionResolution;\nimport org.hibernate.boot.registry.StandardServiceRegistry;\nimport org.hibernate.boot.registry.classloading.spi.ClassLoaderService;\nimport org.hibernate.boot.registry.classloading.spi.ClassLoadingException;\nimport org.hibernate.boot.spi.MetadataBuildingContext;\nimport org.hibernate.dialect.Dialect;\nimport org.hibernate.engine.jdbc.Size;\nimport org.hibernate.internal.CoreLogging;\nimport org.hibernate.internal.CoreMessageLogger;\nimport org.hibernate.internal.util.StringHelper;\nimport org.hibernate.internal.util.collections.CollectionHelper;\nimport org.hibernate.metamodel.mapping.JdbcMapping;\nimport org.hibernate.metamodel.mapping.SelectablePath;\nimport org.hibernate.resource.beans.internal.FallbackBeanInstanceProducer;\nimport org.hibernate.resource.beans.spi.BeanInstanceProducer;\nimport org.hibernate.resource.beans.spi.ManagedBean;\nimport org.hibernate.resource.beans.spi.ManagedBeanRegistry;\nimport org.hibernate.tool.schema.extract.spi.ColumnTypeInformation;\nimport org.hibernate.type.BasicType;\nimport org.hibernate.type.CustomType;\nimport org.hibernate.type.NumericBooleanConverter;\nimport org.hibernate.type.SqlTypes;\nimport org.hibernate.type.TrueFalseConverter;\nimport org.hibernate.type.Type;\nimport org.hibernate.type.WrapperArrayHandling;\nimport org.hibernate.type.descriptor.converter.spi.BasicValueConverter;\nimport org.hibernate.type.descriptor.converter.spi.JpaAttributeConverter;\nimport org.hibernate.type.descriptor.java.BasicJavaType;\nimport org.hibernate.type.descriptor.java.BasicPluralJavaType;\nimport org.hibernate.type.descriptor.java.JavaType;\nimport org.hibernate.type.descriptor.java.MutabilityPlan;\nimport org.hibernate.type.descriptor.java.spi.JavaTypeRegistry;\nimport org.hibernate.type.descriptor.java.spi.JsonJavaType;\nimport org.hibernate.type.descriptor.java.spi.RegistryHelper;\nimport org.hibernate.type.descriptor.java.spi.XmlJavaType;\nimport org.hibernate.type.descriptor.jdbc.BooleanJdbcType;\nimport org.hibernate.type.descriptor.jdbc.JdbcType;\nimport org.hibernate.type.descriptor.jdbc.JdbcTypeIndicators;\nimport org.hibernate.type.internal.BasicTypeImpl;\nimport org.hibernate.type.spi.TypeConfiguration;\nimport org.hibernate.type.spi.TypeConfigurationAware;\nimport org.hibernate.usertype.DynamicParameterizedType;\nimport org.hibernate.usertype.UserType;\n\nimport com.fasterxml.classmate.ResolvedType;\nimport jakarta.persistence.AttributeConverter;\nimport jakarta.persistence.EnumType;\nimport jakarta.persistence.TemporalType;\n\nimport static java.lang.Boolean.parseBoolean;\nimport static org.hibernate.internal.util.ReflectHelper.reflectedPropertyType;\nimport static org.hibernate.internal.util.collections.CollectionHelper.isNotEmpty;\nimport static org.hibernate.mapping.MappingHelper.injectParameters;\n\n/**\n * @author Steve Ebersole\n */\npublic class BasicValue extends SimpleValue implements JdbcTypeIndicators, Resolvable, JpaAttributeConverterCreationContext {\n\tprivate static final CoreMessageLogger log = CoreLogging.messageLogger( BasicValue.class );\n\n\t// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\t// incoming \"configuration\" values\n\n\tprivate String explicitTypeName;\n\tprivate Map<String,String> explicitLocalTypeParams;\n\n\tprivate Function<TypeConfiguration, BasicJavaType> explicitJavaTypeAccess;\n\tprivate Function<TypeConfiguration, JdbcType> explicitJdbcTypeAccess;\n\tprivate Function<TypeConfiguration, MutabilityPlan> explicitMutabilityPlanAccess;\n\tprivate Function<TypeConfiguration, java.lang.reflect.Type> implicitJavaTypeAccess;\n\n\tprivate EnumType enumerationStyle;\n\t@SuppressWarnings(\"deprecation\")\n\tprivate TemporalType temporalPrecision;\n\tprivate TimeZoneStorageType timeZoneStorageType;\n\tprivate boolean isSoftDelete;\n\tprivate SoftDeleteType softDeleteStrategy;\n\n\tprivate java.lang.reflect.Type resolvedJavaType;\n\n\tprivate String ownerName;\n\tprivate String propertyName;\n\tprivate AggregateColumn aggregateColumn;\n\n\t// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\t// Resolved state - available after `#resolve`\n\tprivate Resolution<?> resolution;\n\tprivate Integer jdbcTypeCode;\n\n\n\tpublic BasicValue(MetadataBuildingContext buildingContext) {\n\t\tthis( buildingContext, null );\n\t}\n\n\tpublic BasicValue(MetadataBuildingContext buildingContext, Table table) {\n\t\tsuper( buildingContext, table );\n\t\tbuildingContext.getMetadataCollector().registerValueMappingResolver( this::resolve );\n\t}\n\n\tpublic BasicValue(BasicValue original) {\n\t\tsuper( original );\n\t\tthis.explicitTypeName = original.explicitTypeName;\n\t\tthis.explicitLocalTypeParams = original.explicitLocalTypeParams == null\n\t\t\t\t? null\n\t\t\t\t: new HashMap<>(original.explicitLocalTypeParams);\n\t\tthis.explicitJavaTypeAccess = original.explicitJavaTypeAccess;\n\t\tthis.explicitJdbcTypeAccess = original.explicitJdbcTypeAccess;\n\t\tthis.explicitMutabilityPlanAccess = original.explicitMutabilityPlanAccess;\n\t\tthis.implicitJavaTypeAccess = original.implicitJavaTypeAccess;\n\t\tthis.enumerationStyle = original.enumerationStyle;\n\t\tthis.temporalPrecision = original.temporalPrecision;\n\t\tthis.timeZoneStorageType = original.timeZoneStorageType;\n\t\tthis.resolvedJavaType = original.resolvedJavaType;\n\t\tthis.ownerName = original.ownerName;\n\t\tthis.propertyName = original.propertyName;\n\t}\n\n\t@Override\n\tpublic BasicValue copy() {\n\t\treturn new BasicValue( this );\n\t}\n\n\tpublic boolean isSoftDelete() {\n\t\treturn isSoftDelete;\n\t}\n\n\tpublic SoftDeleteType getSoftDeleteStrategy() {\n\t\treturn softDeleteStrategy;\n\t}\n\n\tpublic void makeSoftDelete(SoftDeleteType strategy) {\n\t\tisSoftDelete = true;\n\t\tsoftDeleteStrategy = strategy;\n\t}\n\n\t// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\t// Setters - in preparation of resolution\n\n\t@Override\n\tpublic void setTypeUsingReflection(String className, String propertyName) throws MappingException {\n\t\tif ( resolution != null ) {\n\t\t\tthrow new IllegalStateException( \"BasicValue already resolved\" );\n\t\t}\n\n\t\tthis.ownerName = className;\n\t\tthis.propertyName = propertyName;\n\n\t\tsuper.setTypeUsingReflection( className, propertyName );\n\t}\n\n\tpublic void setEnumerationStyle(EnumType enumerationStyle) {\n\t\tthis.enumerationStyle = enumerationStyle;\n\t}\n\n\tpublic EnumType getEnumerationStyle() {\n\t\treturn enumerationStyle;\n\t}\n\n\tpublic TimeZoneStorageType getTimeZoneStorageType() {\n\t\treturn timeZoneStorageType;\n\t}\n\n\tpublic void setTimeZoneStorageType(TimeZoneStorageType timeZoneStorageType) {\n\t\tthis.timeZoneStorageType = timeZoneStorageType;\n\t}\n\n\tpublic void setJpaAttributeConverterDescriptor(ConverterDescriptor descriptor) {\n\t\tsetAttributeConverterDescriptor( descriptor );\n\n\t\tsuper.setJpaAttributeConverterDescriptor( descriptor );\n\t}\n\n\t@SuppressWarnings(\"rawtypes\")\n\tpublic void setExplicitJavaTypeAccess(Function<TypeConfiguration, BasicJavaType> explicitJavaTypeAccess) {\n\t\tthis.explicitJavaTypeAccess = explicitJavaTypeAccess;\n\t}\n\n\tpublic void setExplicitJdbcTypeAccess(Function<TypeConfiguration, JdbcType> jdbcTypeAccess) {\n\t\tthis.explicitJdbcTypeAccess = jdbcTypeAccess;\n\t}\n\n\tpublic void setExplicitMutabilityPlanAccess(Function<TypeConfiguration, MutabilityPlan> explicitMutabilityPlanAccess) {\n\t\tthis.explicitMutabilityPlanAccess = explicitMutabilityPlanAccess;\n\t}\n\n\tpublic void setImplicitJavaTypeAccess(Function<TypeConfiguration, java.lang.reflect.Type> implicitJavaTypeAccess) {\n\t\tthis.implicitJavaTypeAccess = implicitJavaTypeAccess;\n\t}\n\n\tpublic Selectable getColumn() {\n\t\tif ( getColumnSpan() == 0 ) {\n\t\t\treturn null;\n\t\t}\n\t\treturn getColumn( 0 );\n\t}\n\n\tpublic java.lang.reflect.Type getResolvedJavaType() {\n\t\treturn resolvedJavaType;\n\t}\n\n\t@Override\n\tpublic long getColumnLength() {\n\t\tfinal Selectable selectable = getColumn();\n\t\tif ( selectable instanceof Column column ) {\n\t\t\tfinal Long length = column.getLength();\n\t\t\treturn length == null ? NO_COLUMN_LENGTH : length;\n\t\t}\n\t\telse {\n\t\t\treturn NO_COLUMN_LENGTH;\n\t\t}\n\t}\n\n\t@Override\n\tpublic int getColumnPrecision() {\n\t\tfinal Selectable selectable = getColumn();\n\t\tif ( selectable instanceof Column column ) {\n\t\t\tfinal Integer temporalPrecision = column.getTemporalPrecision();\n\t\t\tif ( temporalPrecision != null ) {\n\t\t\t\treturn temporalPrecision;\n\t\t\t}\n\t\t\tfinal Integer precision = column.getPrecision();\n\t\t\treturn precision == null ? NO_COLUMN_PRECISION : precision;\n\t\t}\n\t\telse {\n\t\t\treturn NO_COLUMN_PRECISION;\n\t\t}\n\t}\n\n\t@Override\n\tpublic int getColumnScale() {\n\t\tfinal Selectable selectable = getColumn();\n\t\tif ( selectable instanceof Column column ) {\n\t\t\tfinal Integer scale = column.getScale();\n\t\t\treturn scale == null ? NO_COLUMN_SCALE : scale;\n\t\t}\n\t\telse {\n\t\t\treturn NO_COLUMN_SCALE;\n\t\t}\n\t}\n\n\t@Override\n\tpublic void addColumn(Column incomingColumn) {\n\t\tsuper.addColumn( incomingColumn );\n\n\t\tcheckSelectable( incomingColumn );\n\t}\n\n\t@Override\n\tpublic void copyTypeFrom(SimpleValue sourceValue) {\n\t\tsuper.copyTypeFrom( sourceValue );\n\t\tif ( sourceValue instanceof BasicValue basicValue ) {\n\t\t\tresolution = basicValue.resolution;\n\t\t\timplicitJavaTypeAccess =\n\t\t\t\t\ttypeConfiguration -> basicValue.implicitJavaTypeAccess.apply( typeConfiguration );\n\t\t}\n\t}\n\n\tprivate void checkSelectable(Selectable incomingColumn) {\n\t\tif ( incomingColumn == null ) {\n\t\t\tthrow new IllegalArgumentException( \"Incoming column was null\" );\n\t\t}\n\n\t\tfinal Selectable column = getColumn();\n\t\tif ( column == incomingColumn || column.getText().equals( incomingColumn.getText() ) ) {\n\t\t\tlog.debugf( \"Skipping column re-registration: %s.%s\", getTable().getName(), column.getText() );\n\t\t}\n//\t\telse {\n//\t\t\tthrow new IllegalStateException(\n//\t\t\t\t\t\"BasicValue [\" + ownerName + \".\" + propertyName +\n//\t\t\t\t\t\t\t\"] already had column associated: `\" + column.getText() +\n//\t\t\t\t\t\t\t\"` -> `\" + incomingColumn.getText() + \"`\"\n//\t\t\t);\n//\t\t}\n\t}\n\n\t@Override\n\tpublic void addColumn(Column incomingColumn, boolean isInsertable, boolean isUpdatable) {\n\t\tsuper.addColumn( incomingColumn, isInsertable, isUpdatable );\n\t\tcheckSelectable( incomingColumn );\n\t}\n\n\t@Override\n\tpublic void addFormula(Formula formula) {\n\t\tsuper.addFormula( formula );\n\n\t\tcheckSelectable( formula );\n\t}\n\n\t// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\t// Resolution\n\n\t@Override\n\tpublic Type getType() throws MappingException {\n\t\tresolve();\n\t\tassert getResolution() != null;\n\n\t\treturn getResolution().getLegacyResolvedBasicType();\n\t}\n\n\tpublic Resolution<?> getResolution() {\n\t\treturn resolution;\n\t}\n\n\t@Override\n\tpublic boolean resolve(MetadataBuildingContext buildingContext) {\n\t\tresolve();\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic Resolution<?> resolve() {\n\t\tif ( resolution != null ) {\n\t\t\treturn resolution;\n\t\t}\n\n\t\tresolution = buildResolution();\n\n\t\tif ( resolution == null ) {\n\t\t\tthrow new IllegalStateException( \"Unable to resolve BasicValue : \" + this );\n\t\t}\n\n\t\tfinal Selectable selectable = getColumn();\n\t\tfinal Size size;\n\t\tif ( selectable instanceof Column column ) {\n\t\t\tresolveColumn( column, getDialect() );\n\t\t\tsize = column.calculateColumnSize( getDialect(), getBuildingContext().getMetadataCollector() );\n\t\t}\n\t\telse {\n\t\t\tsize = Size.nil();\n\t\t}\n\n\t\tresolution.getJdbcType().addAuxiliaryDatabaseObjects(\n\t\t\t\tresolution.getRelationalJavaType(),\n\t\t\t\tresolution.getValueConverter(),\n\t\t\t\tsize,\n\t\t\t\tgetBuildingContext().getMetadataCollector().getDatabase(),\n\t\t\t\tthis\n\t\t);\n\n\t\treturn resolution;\n\t}\n\n\t@Override\n\tpublic String getExtraCreateTableInfo() {\n\t\treturn resolution.getJdbcType()\n\t\t\t\t.getExtraCreateTableInfo(\n\t\t\t\t\t\tresolution.getRelationalJavaType(),\n\t\t\t\t\t\tgetColumn().getText(),\n\t\t\t\t\t\tgetTable().getName(),\n\t\t\t\t\t\tgetBuildingContext().getMetadataCollector().getDatabase()\n\t\t\t\t);\n\t}\n\n\t@Override\n\tpublic Dialect getDialect() {\n\t\treturn getMetadata().getDatabase().getDialect();\n\t}\n\n\tprivate void resolveColumn(Column column, Dialect dialect) {\n\n\t\tif ( column.getSqlTypeCode() == null ) {\n\t\t\tcolumn.setSqlTypeCode( resolution.getJdbcType().getDdlTypeCode() );\n\t\t}\n\n//\t\tfinal String declaration = resolution.getLegacyResolvedBasicType().getSpecializedTypeDeclaration( dialect );\n//\t\tif ( declaration != null ) {\n//\t\t\tcolumn.setSpecializedTypeDeclaration( declaration );\n//\t\t}\n\n\t\tif ( dialect.supportsColumnCheck() ) {\n\t\t\tfinal String checkCondition = resolution.getLegacyResolvedBasicType()\n\t\t\t\t\t.getCheckCondition( column.getQuotedName( dialect ), dialect );\n\t\t\tif ( checkCondition != null ) {\n\t\t\t\tcolumn.addCheckConstraint( new CheckConstraint( checkCondition ) );\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic AggregateColumn getAggregateColumn() {\n\t\treturn aggregateColumn;\n\t}\n\n\tpublic void setAggregateColumn(AggregateColumn aggregateColumn) {\n\t\tthis.aggregateColumn = aggregateColumn;\n\t}\n\n\tpublic SelectablePath createSelectablePath(String selectableName) {\n\t\tif ( aggregateColumn != null ) {\n\t\t\treturn aggregateColumn.getSelectablePath().append( selectableName );\n\t\t}\n\t\treturn new SelectablePath( selectableName );\n\t}\n\n\tprotected Resolution<?> buildResolution() {\n\t\tfinal Properties typeParameters = getTypeParameters();\n\t\tif ( typeParameters != null\n\t\t\t\t&& parseBoolean( typeParameters.getProperty(DynamicParameterizedType.IS_DYNAMIC) )\n\t\t\t\t&& typeParameters.get(DynamicParameterizedType.PARAMETER_TYPE) == null ) {\n\t\t\tcreateParameterImpl();\n\t\t}\n\n\t\tif ( explicitTypeName != null ) {\n\t\t\treturn interpretExplicitlyNamedType(\n\t\t\t\t\texplicitTypeName,\n\t\t\t\t\texplicitJavaTypeAccess,\n\t\t\t\t\texplicitJdbcTypeAccess,\n\t\t\t\t\texplicitMutabilityPlanAccess,\n\t\t\t\t\tgetAttributeConverterDescriptor(),\n\t\t\t\t\ttypeParameters,\n\t\t\t\t\tthis::setTypeParameters,\n\t\t\t\t\tthis,\n\t\t\t\t\tgetBuildingContext()\n\t\t\t);\n\t\t}\n\t\telse if ( isVersion() ) {\n\t\t\treturn VersionResolution.from( implicitJavaTypeAccess, timeZoneStorageType, getBuildingContext() );\n\t\t}\n\t\telse {\n\t\t\t// determine JavaType if we can\n\t\t\tfinal BasicJavaType<?> explicitJavaType = getExplicitJavaType();\n\t\t\tfinal JavaType<?> javaType = determineJavaType( explicitJavaType );\n\t\t\tfinal ConverterDescriptor converterDescriptor = getConverterDescriptor( javaType );\n\t\t\treturn converterDescriptor != null\n\t\t\t\t\t? converterResolution( javaType, converterDescriptor )\n\t\t\t\t\t: resolution( explicitJavaType, javaType );\n\t\t}\n\t}\n\n\tprivate BasicJavaType<?> getExplicitJavaType() {\n\t\treturn explicitJavaTypeAccess == null ? null\n\t\t\t\t: explicitJavaTypeAccess.apply( getTypeConfiguration() );\n\t}\n\n\tprivate ConverterDescriptor getConverterDescriptor(JavaType<?> javaType) {\n\t\tfinal ConverterDescriptor converterDescriptor = getAttributeConverterDescriptor();\n\t\tif ( isSoftDelete() ) {\n\t\t\tassert converterDescriptor != null;\n\t\t\tfinal ConverterDescriptor softDeleteConverterDescriptor =\n\t\t\t\t\tgetSoftDeleteConverterDescriptor( converterDescriptor, javaType);\n\t\t\treturn getSoftDeleteStrategy() == SoftDeleteType.ACTIVE\n\t\t\t\t\t? new ReversedConverterDescriptor<>( softDeleteConverterDescriptor )\n\t\t\t\t\t: softDeleteConverterDescriptor;\n\t\t}\n\t\telse {\n\t\t\treturn converterDescriptor;\n\t\t}\n\t}\n\n\tprivate ConverterDescriptor getSoftDeleteConverterDescriptor(\n\t\t\tConverterDescriptor attributeConverterDescriptor, JavaType<?> javaType) {\n\t\tfinal boolean conversionWasUnspecified =\n\t\t\t\tSoftDelete.UnspecifiedConversion.class.equals( attributeConverterDescriptor.getAttributeConverterClass() );\n\t\tif ( conversionWasUnspecified ) {\n\t\t\tfinal JdbcType jdbcType = BooleanJdbcType.INSTANCE.resolveIndicatedType( this, javaType);\n\t\t\tif ( jdbcType.isNumber() ) {\n\t\t\t\treturn new InstanceBasedConverterDescriptor(\n\t\t\t\t\t\tNumericBooleanConverter.INSTANCE,\n\t\t\t\t\t\tgetBuildingContext().getBootstrapContext().getClassmateContext()\n\t\t\t\t);\n\t\t\t}\n\t\t\telse if ( jdbcType.isString() ) {\n\t\t\t\t// here we pick 'T' / 'F' storage, though 'Y' / 'N' is equally valid - its 50/50\n\t\t\t\treturn new InstanceBasedConverterDescriptor(\n\t\t\t\t\t\tTrueFalseConverter.INSTANCE,\n\t\t\t\t\t\tgetBuildingContext().getBootstrapContext().getClassmateContext()\n\t\t\t\t);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// should indicate BIT or BOOLEAN == no conversion needed\n\t\t\t\t//\t\t- we still create the converter to properly set up JDBC type, etc\n\t\t\t\treturn new InstanceBasedConverterDescriptor(\n\t\t\t\t\t\tPassThruSoftDeleteConverter.INSTANCE,\n\t\t\t\t\t\tgetBuildingContext().getBootstrapContext().getClassmateContext()\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\treturn attributeConverterDescriptor;\n\t\t}\n\t}\n\n\tprivate static class ReversedConverterDescriptor<R> implements ConverterDescriptor {\n\t\tprivate final ConverterDescriptor underlyingDescriptor;\n\n\t\tpublic ReversedConverterDescriptor(ConverterDescriptor underlyingDescriptor) {\n\t\t\tthis.underlyingDescriptor = underlyingDescriptor;\n\t\t}\n\n\t\t@Override\n\t\tpublic Class<? extends AttributeConverter<Boolean,R>> getAttributeConverterClass() {\n\t\t\t//noinspection unchecked\n\t\t\treturn (Class<? extends AttributeConverter<Boolean, R>>) getClass();\n\t\t}\n\n\t\t@Override\n\t\tpublic ResolvedType getDomainValueResolvedType() {\n\t\t\treturn underlyingDescriptor.getDomainValueResolvedType();\n\t\t}\n\n\t\t@Override\n\t\tpublic ResolvedType getRelationalValueResolvedType() {\n\t\t\treturn underlyingDescriptor.getRelationalValueResolvedType();\n\t\t}\n\n\t\t@Override\n\t\tpublic AutoApplicableConverterDescriptor getAutoApplyDescriptor() {\n\t\t\treturn AutoApplicableConverterDescriptorBypassedImpl.INSTANCE;\n\t\t}\n\n\t\t@Override\n\t\tpublic JpaAttributeConverter<Boolean,R> createJpaAttributeConverter(JpaAttributeConverterCreationContext context) {\n\t\t\t//noinspection unchecked\n\t\t\treturn new ReversedJpaAttributeConverter<>(\n\t\t\t\t\t(JpaAttributeConverter<Boolean, R>) underlyingDescriptor.createJpaAttributeConverter( context ),\n\t\t\t\t\tcontext.getJavaTypeRegistry().getDescriptor( ReversedJpaAttributeConverter.class )\n\t\t\t);\n\t\t}\n\t}\n\n\tprivate static class ReversedJpaAttributeConverter<R, B extends AttributeConverter<Boolean, R>>\n\t\t\timplements JpaAttributeConverter<Boolean,R>, AttributeConverter<Boolean,R>, ManagedBean<B> {\n\t\tprivate final JpaAttributeConverter<Boolean,R> underlyingJpaConverter;\n\t\tprivate final JavaType<ReversedJpaAttributeConverter<R,B>> converterJavaType;\n\n\t\tpublic ReversedJpaAttributeConverter(\n\t\t\t\tJpaAttributeConverter<Boolean, R> underlyingJpaConverter,\n\t\t\t\tJavaType<ReversedJpaAttributeConverter<R,B>> converterJavaType) {\n\t\t\tthis.underlyingJpaConverter = underlyingJpaConverter;\n\t\t\tthis.converterJavaType = converterJavaType;\n\t\t}\n\n\t\t@Override\n\t\tpublic Boolean toDomainValue(R relationalValue) {\n\t\t\treturn !underlyingJpaConverter.toDomainValue( relationalValue );\n\t\t}\n\n\t\t@Override\n\t\tpublic R toRelationalValue(Boolean domainValue) {\n\t\t\treturn underlyingJpaConverter.toRelationalValue( domainValue != null ? !domainValue : null );\n\t\t}\n\n\t\t@Override\n\t\tpublic Boolean convertToEntityAttribute(R relationalValue) {\n\t\t\treturn toDomainValue( relationalValue );\n\t\t}\n\n\t\t@Override\n\t\tpublic R convertToDatabaseColumn(Boolean domainValue) {\n\t\t\treturn toRelationalValue( domainValue );\n\t\t}\n\n\t\t@Override\n\t\tpublic JavaType<Boolean> getDomainJavaType() {\n\t\t\treturn underlyingJpaConverter.getDomainJavaType();\n\t\t}\n\n\t\t@Override\n\t\tpublic JavaType<R> getRelationalJavaType() {\n\t\t\treturn underlyingJpaConverter.getRelationalJavaType();\n\t\t}\n\n\t\t@Override\n\t\tpublic JavaType<? extends AttributeConverter<Boolean, R>> getConverterJavaType() {\n\t\t\treturn converterJavaType;\n\t\t}\n\n\t\t@Override\n\t\tpublic ManagedBean<? extends AttributeConverter<Boolean, R>> getConverterBean() {\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\tpublic Class<B> getBeanClass() {\n\t\t\t//noinspection unchecked\n\t\t\treturn (Class<B>) getClass();\n\t\t}\n\n\t\t@Override\n\t\tpublic B getBeanInstance() {\n\t\t\t//noinspection unchecked\n\t\t\treturn (B) this;\n\t\t}\n\t}\n\n\tprivate static class PassThruSoftDeleteConverter implements AttributeConverter<Boolean,Boolean> {\n\t\tprivate static final PassThruSoftDeleteConverter INSTANCE = new PassThruSoftDeleteConverter();\n\n\t\t@Override\n\t\tpublic Boolean convertToDatabaseColumn(Boolean domainValue) {\n\t\t\treturn domainValue;\n\t\t}\n\n\t\t@Override\n\t\tpublic Boolean convertToEntityAttribute(Boolean relationalValue) {\n\t\t\treturn relationalValue;\n\t\t}\n\t}\n\n\tprivate Resolution<?> resolution(BasicJavaType explicitJavaType, JavaType<?> javaType) {\n\t\tfinal JavaType<?> basicJavaType;\n\t\tfinal JdbcType jdbcType;\n\t\tif ( explicitJdbcTypeAccess != null ) {\n\t\t\tfinal TypeConfiguration typeConfiguration = getTypeConfiguration();\n\t\t\tjdbcType = explicitJdbcTypeAccess.apply( typeConfiguration );\n\t\t\tbasicJavaType = javaType == null && jdbcType != null\n\t\t\t\t\t? jdbcType.getJdbcRecommendedJavaTypeMapping(null, null, typeConfiguration)\n\t\t\t\t\t: javaType;\n\t\t}\n\t\telse {\n\t\t\tjdbcType = null;\n\t\t\tbasicJavaType = javaType;\n\t\t}\n\t\tif ( basicJavaType == null ) {\n\t\t\tthrow new MappingException( \"Unable to determine JavaType to use : \" + this );\n\t\t}\n\n\t\tif ( basicJavaType instanceof BasicJavaType<?>\n\t\t\t\t&& ( !basicJavaType.getJavaTypeClass().isEnum() || enumerationStyle == null ) ) {\n\t\t\tfinal TypeDefinition autoAppliedTypeDef =\n\t\t\t\t\tgetBuildingContext().getTypeDefinitionRegistry()\n\t\t\t\t\t\t\t.resolveAutoApplied( (BasicJavaType<?>) basicJavaType );\n\t\t\tif ( autoAppliedTypeDef != null ) {\n\t\t\t\tlog.debug(\"BasicValue resolution matched auto-applied type-definition\");\n\t\t\t\treturn autoAppliedTypeDef.resolve( getTypeParameters(), null, getBuildingContext(), this );\n\t\t\t}\n\t\t}\n\n\t\treturn InferredBasicValueResolver.from(\n\t\t\t\texplicitJavaType,\n\t\t\t\tjdbcType,\n\t\t\t\tresolvedJavaType,\n\t\t\t\tthis::determineReflectedJavaType,\n\t\t\t\texplicitMutabilityPlanAccess,\n\t\t\t\tthis,\n\t\t\t\tgetTable(),\n\t\t\t\tgetColumn(),\n\t\t\t\townerName,\n\t\t\t\tpropertyName,\n\t\t\t\tgetBuildingContext()\n\t\t);\n\t}\n\n\t@Override\n\tpublic ManagedBeanRegistry getManagedBeanRegistry() {\n\t\treturn getServiceRegistry().requireService( ManagedBeanRegistry.class );\n\t}\n\n\tprivate Resolution<?> converterResolution(JavaType<?> javaType, ConverterDescriptor attributeConverterDescriptor) {\n\t\tfinal NamedConverterResolution<?> converterResolution = NamedConverterResolution.from(\n\t\t\t\tattributeConverterDescriptor,\n\t\t\t\texplicitJavaTypeAccess,\n\t\t\t\texplicitJdbcTypeAccess,\n\t\t\t\texplicitMutabilityPlanAccess,\n\t\t\t\tresolvedJavaType,\n\t\t\t\tthis,\n\t\t\t\tthis,\n\t\t\t\tgetBuildingContext()\n\t\t);\n\n\t\tif ( javaType instanceof BasicPluralJavaType<?> containerJtd\n\t\t\t\t&& !attributeConverterDescriptor.getDomainValueResolvedType().getErasedType()\n\t\t\t\t\t\t.isAssignableFrom( javaType.getJavaTypeClass() ) ) {\n\t\t\t// In this case, the converter applies to the element of a BasicPluralJavaType\n\t\t\tfinal BasicType registeredElementType = converterResolution.getLegacyResolvedBasicType();\n\t\t\tfinal Selectable column = getColumn();\n\t\t\tfinal BasicType<?> registeredType = registeredElementType == null ? null\n\t\t\t\t\t: containerJtd.resolveType(\n\t\t\t\t\t\t\tgetTypeConfiguration(),\n\t\t\t\t\t\t\tgetDialect(),\n\t\t\t\t\t\t\tregisteredElementType,\n\t\t\t\t\t\t\tcolumn instanceof ColumnTypeInformation ? (ColumnTypeInformation) column : null,\n\t\t\t\t\t\t\tthis\n\t\t\t);\n\t\t\tif ( registeredType != null ) {\n\t\t\t\tgetTypeConfiguration().getBasicTypeRegistry().register( registeredType );\n\t\t\t\treturn new InferredBasicValueResolution(\n\t\t\t\t\t\tregisteredType,\n\t\t\t\t\t\tregisteredType.getJavaTypeDescriptor(),\n\t\t\t\t\t\tregisteredType.getJavaTypeDescriptor(),\n\t\t\t\t\t\tregisteredType.getJdbcType(),\n\t\t\t\t\t\tregisteredType,\n\t\t\t\t\t\tnull\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\treturn converterResolution;\n\t}\n\n\tprivate JavaType<?> determineJavaType(JavaType<?> explicitJavaType) {\n\t\tJavaType<?> javaType = explicitJavaType;\n//\n//\t\tif ( javaType == null ) {\n//\t\t\tif ( implicitJavaTypeAccess != null ) {\n//\t\t\t\tfinal java.lang.reflect.Type implicitJtd = implicitJavaTypeAccess.apply( getTypeConfiguration() );\n//\t\t\t\tif ( implicitJtd != null ) {\n//\t\t\t\t\tjavaType = getTypeConfiguration().getJavaTypeRegistry().getDescriptor( implicitJtd );\n//\t\t\t\t}\n//\t\t\t}\n//\t\t}\n\n\t\tif ( javaType == null ) {\n\t\t\tfinal JavaType<?> reflectedJtd = determineReflectedJavaType();\n\t\t\tif ( reflectedJtd != null ) {\n\t\t\t\tjavaType = reflectedJtd;\n\t\t\t}\n\t\t}\n\n\t\treturn javaType;\n\t}\n\n\tprivate JavaType<?> determineReflectedJavaType() {\n\t\tfinal TypeConfiguration typeConfiguration = getTypeConfiguration();\n\t\tfinal java.lang.reflect.Type impliedJavaType = impliedJavaType( typeConfiguration );\n\t\tif ( impliedJavaType == null ) {\n\t\t\treturn null;\n\t\t}\n\t\telse {\n\t\t\tresolvedJavaType = impliedJavaType;\n\t\t\treturn javaType( typeConfiguration, impliedJavaType );\n\t\t}\n\t}\n\n\tprivate java.lang.reflect.Type impliedJavaType(TypeConfiguration typeConfiguration) {\n\t\tif ( resolvedJavaType != null ) {\n\t\t\treturn resolvedJavaType;\n\t\t}\n\t\telse if ( implicitJavaTypeAccess != null ) {\n\t\t\treturn implicitJavaTypeAccess.apply(typeConfiguration);\n\t\t}\n\t\telse if ( ownerName != null && propertyName != null ) {\n\t\t\treturn reflectedPropertyType( ownerName, propertyName,\n\t\t\t\t\tgetServiceRegistry().requireService( ClassLoaderService.class ) );\n\t\t}\n\t\telse {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tprivate JavaType<Object> javaType(TypeConfiguration typeConfiguration, java.lang.reflect.Type impliedJavaType) {\n\t\tfinal JavaType<Object> javaType = typeConfiguration.getJavaTypeRegistry().findDescriptor( impliedJavaType );\n\t\treturn javaType == null ? specialJavaType( typeConfiguration, impliedJavaType ) : javaType;\n\t}\n\n\tprivate JavaType<Object> specialJavaType(\n\t\t\tTypeConfiguration typeConfiguration,\n\t\t\tjava.lang.reflect.Type impliedJavaType) {\n\t\tfinal JavaTypeRegistry javaTypeRegistry = typeConfiguration.getJavaTypeRegistry();\n\t\tif ( jdbcTypeCode != null ) {\n\t\t\t// Construct special JavaType instances for JSON/XML types which can report recommended JDBC types\n\t\t\t// and implement toString/fromString as well as copying based on FormatMapper operations\n\t\t\tswitch ( jdbcTypeCode ) {\n\t\t\t\tcase SqlTypes.JSON:\n\t\t\t\t\tfinal JavaType<Object> jsonJavaType =\n\t\t\t\t\t\t\tnew JsonJavaType<>( impliedJavaType,\n\t\t\t\t\t\t\t\t\tmutabilityPlan( typeConfiguration, impliedJavaType ),\n\t\t\t\t\t\t\t\t\ttypeConfiguration );\n\t\t\t\t\tjavaTypeRegistry.addDescriptor( jsonJavaType );\n\t\t\t\t\treturn jsonJavaType;\n\t\t\t\tcase SqlTypes.SQLXML:\n\t\t\t\t\tfinal JavaType<Object> xmlJavaType =\n\t\t\t\t\t\t\tnew XmlJavaType<>( impliedJavaType,\n\t\t\t\t\t\t\t\t\tmutabilityPlan( typeConfiguration, impliedJavaType ),\n\t\t\t\t\t\t\t\t\ttypeConfiguration );\n\t\t\t\t\tjavaTypeRegistry.addDescriptor( xmlJavaType );\n\t\t\t\t\treturn xmlJavaType;\n\t\t\t}\n\t\t}\n\t\treturn javaTypeRegistry.resolveDescriptor( impliedJavaType );\n\t}\n\n\tprivate MutabilityPlan<Object> mutabilityPlan(\n\t\t\tTypeConfiguration typeConfiguration, java.lang.reflect.Type impliedJavaType) {\n\t\tfinal MutabilityPlan<Object> explicitMutabilityPlan = getExplicitMutabilityPlan();\n\t\treturn explicitMutabilityPlan != null\n\t\t\t\t? explicitMutabilityPlan\n\t\t\t\t: RegistryHelper.INSTANCE.determineMutabilityPlan( impliedJavaType, typeConfiguration );\n\t}\n\n\tprivate MutabilityPlan<Object> getExplicitMutabilityPlan() {\n\t\treturn explicitMutabilityPlanAccess == null ? null\n\t\t\t\t: explicitMutabilityPlanAccess.apply( getTypeConfiguration()  );\n\t}\n\n\tprivate static Resolution<?> interpretExplicitlyNamedType(\n\t\t\tString name,\n\t\t\tFunction<TypeConfiguration, BasicJavaType> explicitJtdAccess,\n\t\t\tFunction<TypeConfiguration, JdbcType> explicitStdAccess,\n\t\t\tFunction<TypeConfiguration, MutabilityPlan> explicitMutabilityPlanAccess,\n\t\t\tConverterDescriptor converterDescriptor,\n\t\t\tMap<Object,Object> localTypeParams,\n\t\t\tConsumer<Properties> combinedParameterConsumer,\n\t\t\tJdbcTypeIndicators stdIndicators,\n\t\t\tMetadataBuildingContext context) {\n\n\t\tfinal StandardServiceRegistry serviceRegistry = context.getBootstrapContext().getServiceRegistry();\n\t\tfinal ManagedBeanRegistry managedBeanRegistry = serviceRegistry.requireService( ManagedBeanRegistry.class );\n\t\tfinal TypeConfiguration typeConfiguration = context.getBootstrapContext().getTypeConfiguration();\n\n\t\tfinal JpaAttributeConverterCreationContext converterCreationContext = new JpaAttributeConverterCreationContext() {\n\t\t\t@Override\n\t\t\tpublic ManagedBeanRegistry getManagedBeanRegistry() {\n\t\t\t\treturn managedBeanRegistry;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic TypeConfiguration getTypeConfiguration() {\n\t\t\t\treturn typeConfiguration;\n\t\t\t}\n\t\t};\n\n\t\t// Name could refer to:\n\t\t//\t\t1) a named converter - HBM support for JPA's AttributeConverter via its `type=\"...\"` XML attribute\n\t\t//\t\t2) a \"named composed\" mapping - like (1), this is mainly to support envers since it tells\n\t\t//\t\t\tHibernate the mappings via DOM.  See `org.hibernate.type.internal.BasicTypeImpl`\n\t\t//\t\t3) basic type \"resolution key\"\n\t\t//\t\t4) UserType or BasicType class name - directly, or through a TypeDefinition\n\n\t\tif ( name.startsWith( ConverterDescriptor.TYPE_NAME_PREFIX  ) ) {\n\t\t\treturn NamedConverterResolution.from(\n\t\t\t\t\tname,\n\t\t\t\t\texplicitJtdAccess,\n\t\t\t\t\texplicitStdAccess,\n\t\t\t\t\texplicitMutabilityPlanAccess,\n\t\t\t\t\tstdIndicators,\n\t\t\t\t\tconverterCreationContext,\n\t\t\t\t\tcontext\n\t\t\t);\n\t\t}\n\n//\t\tif ( name.startsWith( EnumeratedValueResolution.PREFIX ) ) {\n//\t\t\treturn EnumeratedValueResolution.fromName( name, stdIndicators, context );\n//\t\t}\n\n\t\tif ( name.startsWith( BasicTypeImpl.EXTERNALIZED_PREFIX ) ) {\n\t\t\tfinal BasicType<Object> basicType = context.getBootstrapContext().resolveAdHocBasicType( name );\n\t\t\treturn new NamedBasicTypeResolution<>(\n\t\t\t\t\tbasicType.getJavaTypeDescriptor(),\n\t\t\t\t\tbasicType,\n\t\t\t\t\tnull,\n\t\t\t\t\texplicitMutabilityPlanAccess,\n\t\t\t\t\tcontext\n\t\t\t);\n\t\t}\n\n\t\t// see if it is a named basic type\n\t\tfinal BasicType<?> basicTypeByName = typeConfiguration.getBasicTypeRegistry().getRegisteredType( name );\n\t\tif ( basicTypeByName != null ) {\n\t\t\tfinal BasicValueConverter<?,?> valueConverter;\n\t\t\tfinal JavaType<?> domainJtd;\n\t\t\tif ( converterDescriptor != null ) {\n\t\t\t\tvalueConverter = converterDescriptor.createJpaAttributeConverter( converterCreationContext );\n\t\t\t\tdomainJtd = valueConverter.getDomainJavaType();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tvalueConverter = basicTypeByName.getValueConverter();\n\t\t\t\tdomainJtd = basicTypeByName.getJavaTypeDescriptor();\n\t\t\t}\n\n\t\t\treturn new NamedBasicTypeResolution<>(\n\t\t\t\t\tdomainJtd,\n\t\t\t\t\tbasicTypeByName,\n\t\t\t\t\tvalueConverter,\n\t\t\t\t\texplicitMutabilityPlanAccess,\n\t\t\t\t\tcontext\n\t\t\t);\n\t\t}\n\n\t\t// see if it is a named TypeDefinition\n\t\tfinal TypeDefinition typeDefinition = context.getTypeDefinitionRegistry().resolve( name );\n\t\tif ( typeDefinition != null ) {\n\t\t\tfinal Resolution<?> resolution = typeDefinition.resolve(\n\t\t\t\t\tlocalTypeParams,\n\t\t\t\t\texplicitMutabilityPlanAccess != null\n\t\t\t\t\t\t\t? explicitMutabilityPlanAccess.apply( typeConfiguration )\n\t\t\t\t\t\t\t: null,\n\t\t\t\t\tcontext,\n\t\t\t\t\tstdIndicators\n\t\t\t);\n\t\t\tcombinedParameterConsumer.accept( resolution.getCombinedTypeParameters() );\n\t\t\treturn resolution;\n\t\t}\n\n\n\t\t// see if the name is a UserType or BasicType implementor class name\n\t\tfinal ClassLoaderService cls = serviceRegistry.requireService( ClassLoaderService.class );\n\t\ttry {\n\t\t\tfinal Class<?> typeNamedClass = cls.classForName( name );\n\n\t\t\t// if there are no local config params, register an implicit TypeDefinition for this custom type .\n\t\t\t//  later uses may find it and re-use its cacheable reference...\n\t\t\tif ( CollectionHelper.isEmpty( localTypeParams ) ) {\n\t\t\t\tfinal TypeDefinition implicitDefinition = new TypeDefinition(\n\t\t\t\t\t\tname,\n\t\t\t\t\t\ttypeNamedClass,\n\t\t\t\t\t\tnull,\n\t\t\t\t\t\tnull\n\t\t\t\t);\n\t\t\t\tcontext.getTypeDefinitionRegistry().register( implicitDefinition );\n\t\t\t\treturn implicitDefinition.resolve(\n\t\t\t\t\t\tlocalTypeParams,\n\t\t\t\t\t\texplicitMutabilityPlanAccess != null\n\t\t\t\t\t\t\t\t? explicitMutabilityPlanAccess.apply( typeConfiguration )\n\t\t\t\t\t\t\t\t: null,\n\t\t\t\t\t\tcontext,\n\t\t\t\t\t\tstdIndicators\n\t\t\t\t);\n\t\t\t}\n\n\t\t\treturn TypeDefinition.createLocalResolution( name, typeNamedClass, localTypeParams, context );\n\t\t}\n\t\tcatch (ClassLoadingException e) {\n\t\t\t// allow the exception below to trigger\n\t\t\tlog.debugf( \"Could not resolve type-name [%s] as Java type : %s\", name, e );\n\t\t}\n\n\t\tthrow new MappingException( \"Could not resolve named type : \" + name );\n\t}\n\n\n\t// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\t// SqlTypeDescriptorIndicators\n\n\t@Override\n\tpublic EnumType getEnumeratedType() {\n\t\treturn getEnumerationStyle();\n\t}\n\n\n\t@Override\n\tpublic int getPreferredSqlTypeCodeForBoolean() {\n\t\treturn resolveJdbcTypeCode( getBuildingContext().getPreferredSqlTypeCodeForBoolean() );\n\t}\n\n\t@Override\n\tpublic int getPreferredSqlTypeCodeForDuration() {\n\t\treturn resolveJdbcTypeCode( getBuildingContext().getPreferredSqlTypeCodeForDuration() );\n\t}\n\n\t@Override\n\tpublic int getPreferredSqlTypeCodeForUuid() {\n\t\treturn resolveJdbcTypeCode( getBuildingContext().getPreferredSqlTypeCodeForUuid() );\n\t}\n\n\t@Override\n\tpublic int getPreferredSqlTypeCodeForInstant() {\n\t\treturn resolveJdbcTypeCode( getBuildingContext().getPreferredSqlTypeCodeForInstant() );\n\t}\n\n\t@Override\n\tpublic int getPreferredSqlTypeCodeForArray() {\n\t\treturn resolveJdbcTypeCode( getBuildingContext().getPreferredSqlTypeCodeForArray() );\n\t}\n\n\t@Override\n\tpublic int resolveJdbcTypeCode(int jdbcTypeCode) {\n\t\treturn aggregateColumn == null\n\t\t\t\t? jdbcTypeCode\n\t\t\t\t: getDialect().getAggregateSupport()\n\t\t\t\t.aggregateComponentSqlTypeCode( aggregateColumn.getSqlTypeCode( getMetadata() ), jdbcTypeCode );\n\t}\n\n\t@Override\n\tpublic TimeZoneStorageStrategy getDefaultTimeZoneStorageStrategy() {\n\t\treturn timeZoneStorageStrategy( timeZoneStorageType, getBuildingContext() );\n\t}\n\n\t@Internal\n\tpublic static TimeZoneStorageStrategy timeZoneStorageStrategy(\n\t\t\tTimeZoneStorageType timeZoneStorageType,\n\t\t\tMetadataBuildingContext buildingContext) {\n\t\tif ( timeZoneStorageType != null ) {\n\t\t\tswitch ( timeZoneStorageType ) {\n\t\t\t\tcase COLUMN:\n\t\t\t\t\treturn TimeZoneStorageStrategy.COLUMN;\n\t\t\t\tcase NATIVE:\n\t\t\t\t\treturn TimeZoneStorageStrategy.NATIVE;\n\t\t\t\tcase NORMALIZE:\n\t\t\t\t\treturn TimeZoneStorageStrategy.NORMALIZE;\n\t\t\t\tcase NORMALIZE_UTC:\n\t\t\t\t\treturn TimeZoneStorageStrategy.NORMALIZE_UTC;\n\t\t\t}\n\t\t}\n\t\treturn buildingContext.getBuildingOptions().getDefaultTimeZoneStorage();\n\t}\n\n\tpublic void setExplicitTypeParams(Map<String,String> explicitLocalTypeParams) {\n\t\tthis.explicitLocalTypeParams = explicitLocalTypeParams;\n\t}\n\n\tpublic void setExplicitTypeName(String typeName) {\n\t\tthis.explicitTypeName = typeName;\n\t}\n\n\tpublic void setTypeName(String typeName) {\n\t\tif ( StringHelper.isNotEmpty( typeName ) ) {\n\t\t\tif ( typeName.startsWith( ConverterDescriptor.TYPE_NAME_PREFIX ) ) {\n\t\t\t\tfinal String converterClassName = typeName.substring( ConverterDescriptor.TYPE_NAME_PREFIX.length() );\n\t\t\t\tfinal ClassLoaderService cls = getServiceRegistry().requireService( ClassLoaderService.class );\n\t\t\t\ttry {\n\t\t\t\t\tfinal Class<AttributeConverter<?,?>> converterClass = cls.classForName( converterClassName );\n\t\t\t\t\tsetAttributeConverterDescriptor( new ClassBasedConverterDescriptor(\n\t\t\t\t\t\t\tconverterClass,\n\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\tgetBuildingContext().getBootstrapContext().getClassmateContext()\n\t\t\t\t\t) );\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tcatch (Exception e) {\n\t\t\t\t\tlog.logBadHbmAttributeConverterType( typeName, e.getMessage() );\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsetExplicitTypeName( typeName );\n\t\t\t}\n\t\t}\n\n\t\tsuper.setTypeName( typeName );\n\t}\n\n\tprivate static int COUNTER;\n\n\tpublic void setExplicitCustomType(Class<? extends UserType<?>> explicitCustomType) {\n\t\tif ( explicitCustomType != null ) {\n\t\t\tif ( resolution != null ) {\n\t\t\t\tthrow new UnsupportedOperationException( \"Unsupported attempt to set an explicit-custom-type when value is already resolved\" );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tresolution = new UserTypeResolution<>(\n\t\t\t\t\t\tnew CustomType<>(\n\t\t\t\t\t\t\t\tgetConfiguredUserTypeBean( explicitCustomType, getCustomTypeProperties() ),\n\t\t\t\t\t\t\t\tgetTypeConfiguration()\n\t\t\t\t\t\t),\n\t\t\t\t\t\tnull,\n\t\t\t\t\t\tgetCustomTypeProperties()\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate Properties getCustomTypeProperties() {\n\t\tfinal Properties properties = new Properties();\n\t\tif ( isNotEmpty( getTypeParameters() ) ) {\n\t\t\tproperties.putAll( getTypeParameters() );\n\t\t}\n\t\tif ( isNotEmpty( explicitLocalTypeParams ) ) {\n\t\t\tproperties.putAll( explicitLocalTypeParams );\n\t\t}\n\t\treturn properties;\n\t}\n\n\tprivate UserType<?> getConfiguredUserTypeBean(Class<? extends UserType<?>> explicitCustomType, Properties properties) {\n\t\tfinal UserType<?> typeInstance =\n\t\t\t\t!getBuildingContext().getBuildingOptions().isAllowExtensionsInCdi()\n\t\t\t\t\t\t? FallbackBeanInstanceProducer.INSTANCE.produceBeanInstance( explicitCustomType )\n\t\t\t\t\t\t: getUserTypeBean( explicitCustomType, properties ).getBeanInstance();\n\n\t\tif ( typeInstance instanceof TypeConfigurationAware configurationAware ) {\n\t\t\tconfigurationAware.setTypeConfiguration( getTypeConfiguration() );\n\t\t}\n\n\t\tif ( typeInstance instanceof DynamicParameterizedType ) {\n\t\t\tif ( parseBoolean( properties.getProperty( DynamicParameterizedType.IS_DYNAMIC ) ) ) {\n\t\t\t\tif ( properties.get( DynamicParameterizedType.PARAMETER_TYPE ) == null ) {\n\t\t\t\t\tproperties.put( DynamicParameterizedType.PARAMETER_TYPE, makeParameterImpl() );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tinjectParameters( typeInstance, properties);\n\t\t// envers - grr\n\t\tsetTypeParameters( properties );\n\n\t\treturn typeInstance;\n\t}\n\n\tprivate <T> ManagedBean<T> getUserTypeBean(Class<T> explicitCustomType, Properties properties) {\n\t\tfinal BeanInstanceProducer producer = getBuildingContext().getBootstrapContext().getCustomTypeProducer();\n\t\tfinal ManagedBeanRegistry registry = getServiceRegistry().requireService( ManagedBeanRegistry.class );\n\t\tif ( isNotEmpty( properties ) ) {\n\t\t\tfinal String name = explicitCustomType.getName() + COUNTER++;\n\t\t\treturn registry.getBean( name, explicitCustomType, producer );\n\t\t}\n\t\telse {\n\t\t\treturn registry.getBean( explicitCustomType, producer );\n\t\t}\n\t}\n\n\t@SuppressWarnings(\"deprecation\")\n\tpublic void setTemporalPrecision(TemporalType temporalPrecision) {\n\t\tthis.temporalPrecision = temporalPrecision;\n\t}\n\n\t@Override @SuppressWarnings(\"deprecation\")\n\tpublic TemporalType getTemporalPrecision() {\n\t\treturn temporalPrecision;\n\t}\n\n\t@Override\n\tpublic boolean isPreferJavaTimeJdbcTypesEnabled() {\n\t\treturn getBuildingContext().isPreferJavaTimeJdbcTypesEnabled();\n\t}\n\n\t@Override\n\tpublic boolean isPreferNativeEnumTypesEnabled() {\n\t\treturn getBuildingContext().isPreferNativeEnumTypesEnabled();\n\t}\n\n\t@Override\n\tpublic Object accept(ValueVisitor visitor) {\n\t\treturn visitor.accept(this);\n\t}\n\n\t@Internal\n\tpublic boolean isDisallowedWrapperArray() {\n\t\treturn getBuildingContext().getBuildingOptions().getWrapperArrayHandling() == WrapperArrayHandling.DISALLOW\n\t\t\t&& !isLob()\n\t\t\t&& ( explicitJavaTypeAccess == null || explicitJavaTypeAccess.apply( getTypeConfiguration() ) == null )\n\t\t\t&& isWrapperByteOrCharacterArray();\n\t}\n\n\tprivate boolean isWrapperByteOrCharacterArray() {\n\t\tfinal Class<?> javaTypeClass = getResolution().getDomainJavaType().getJavaTypeClass();\n\t\treturn javaTypeClass == Byte[].class || javaTypeClass == Character[].class;\n\t}\n\n\t@Incubating\n\tpublic void setExplicitJdbcTypeCode(Integer jdbcTypeCode) {\n\t\tthis.jdbcTypeCode = jdbcTypeCode;\n\t}\n\n\t@Override\n\tpublic Integer getExplicitJdbcTypeCode() {\n\t\treturn jdbcTypeCode == null ? getPreferredSqlTypeCodeForArray() : jdbcTypeCode;\n\t}\n\n\t/**\n\t * Resolved form of {@link BasicValue} as part of interpreting the\n\t * boot-time model into the run-time model\n\t */\n\tpublic interface Resolution<J> {\n\t\t/**\n\t\t * The BasicType resolved using the pre-6.0 rules.  This is temporarily\n\t\t * needed because of the split in extracting / binding\n\t\t */\n\t\tBasicType<J> getLegacyResolvedBasicType();\n\n\t\t/**\n\t\t * Get the collection of type-parameters collected both locally as well\n\t\t * as from the applied type-def, if one\n\t\t */\n\t\tdefault Properties getCombinedTypeParameters() {\n\t\t\treturn null;\n\t\t}\n\n\t\tJdbcMapping getJdbcMapping();\n\n\t\t/**\n\t\t * The JavaType for the value as part of the domain model\n\t\t */\n\t\tJavaType<J> getDomainJavaType();\n\n\t\t/**\n\t\t * The JavaType for the relational value as part of\n\t\t * the relational model (its JDBC representation)\n\t\t */\n\t\tJavaType<?> getRelationalJavaType();\n\n\t\t/**\n\t\t * The JavaType for the relational value as part of\n\t\t * the relational model (its JDBC representation)\n\t\t */\n\t\tJdbcType getJdbcType();\n\n\t\t/**\n\t\t * Converter, if any, to convert values between the\n\t\t * domain and relational JavaType representations\n\t\t */\n\t\tBasicValueConverter<J,?> getValueConverter();\n\n\t\t/**\n\t\t * The resolved MutabilityPlan\n\t\t */\n\t\tMutabilityPlan<J> getMutabilityPlan();\n\n\t\tdefault void updateResolution(BasicType<?> type) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\t}\n}\n",
        "diffSourceCodeSet": [
            "private BasicJavaType<?> getExplicitJavaType() {\n\t\treturn explicitJavaTypeAccess == null ? null\n\t\t\t\t: explicitJavaTypeAccess.apply( getTypeConfiguration() );\n\t}"
        ],
        "invokedMethodSet": [
            "methodSignature: org.hibernate.type.spi.TypeConfiguration.ArrayCacheKey#equals\n methodBody: public boolean equals(Object o) {\nreturn Arrays.equals(components,((ArrayCacheKey)o).components);\n}",
            "methodSignature: org.hibernate.mapping.BasicValue#resolution\n methodBody: private Resolution<?> resolution(BasicJavaType explicitJavaType, JavaType<?> javaType) {\nfinal JavaType<?> basicJavaType;\nfinal JdbcType jdbcType;\nif(explicitJdbcTypeAccess != null){final TypeConfiguration typeConfiguration=getTypeConfiguration();\njdbcType=explicitJdbcTypeAccess.apply(typeConfiguration);\nbasicJavaType=javaType == null && jdbcType != null ? jdbcType.getJdbcRecommendedJavaTypeMapping(null,null,typeConfiguration) : javaType;\n}{jdbcType=null;\nbasicJavaType=javaType;\n}if(basicJavaType == null){throw new MappingException(\"Unable to determine JavaType to use : \" + this);\n}if(basicJavaType instanceof BasicJavaType<?> && (!basicJavaType.getJavaTypeClass().isEnum() || enumerationStyle == null)){final TypeDefinition autoAppliedTypeDef=getBuildingContext().getTypeDefinitionRegistry().resolveAutoApplied((BasicJavaType<?>)basicJavaType);\nif(autoAppliedTypeDef != null){log.debug(\"BasicValue resolution matched auto-applied type-definition\");\nreturn autoAppliedTypeDef.resolve(getTypeParameters(),null,getBuildingContext(),this);\n}}return InferredBasicValueResolver.from(explicitJavaType,jdbcType,resolvedJavaType,this::determineReflectedJavaType,explicitMutabilityPlanAccess,this,getTable(),getColumn(),ownerName,propertyName,getBuildingContext());\n}",
            "methodSignature: org.hibernate.mapping.BasicValue#isSoftDelete\n methodBody: public boolean isSoftDelete() {\nreturn isSoftDelete;\n}",
            "methodSignature: org.hibernate.type.spi.TypeConfiguration.Scope#getTypeConfiguration\n methodBody: public TypeConfiguration getTypeConfiguration() {\nreturn typeConfiguration;\n}",
            "methodSignature: org.hibernate.mapping.BasicValue.ReversedConverterDescriptor#getAttributeConverterClass\n methodBody: public Class<? extends AttributeConverter<Boolean,R>> getAttributeConverterClass() {\nreturn (Class<? extends AttributeConverter<Boolean,R>>)getClass();\n}",
            "methodSignature: org.hibernate.mapping.BasicValue#interpretExplicitlyNamedType\n methodBody: private static Resolution<?> interpretExplicitlyNamedType(\n\t\t\tString name,\n\t\t\tFunction<TypeConfiguration, BasicJavaType> explicitJtdAccess,\n\t\t\tFunction<TypeConfiguration, JdbcType> explicitStdAccess,\n\t\t\tFunction<TypeConfiguration, MutabilityPlan> explicitMutabilityPlanAccess,\n\t\t\tConverterDescriptor converterDescriptor,\n\t\t\tMap<Object,Object> localTypeParams,\n\t\t\tConsumer<Properties> combinedParameterConsumer,\n\t\t\tJdbcTypeIndicators stdIndicators,\n\t\t\tMetadataBuildingContext context) {\nfinal StandardServiceRegistry serviceRegistry=context.getBootstrapContext().getServiceRegistry();\nfinal ManagedBeanRegistry managedBeanRegistry=serviceRegistry.requireService(ManagedBeanRegistry.class);\nfinal TypeConfiguration typeConfiguration=context.getBootstrapContext().getTypeConfiguration();\nfinal JpaAttributeConverterCreationContext converterCreationContext=new JpaAttributeConverterCreationContext(){\n  @Override public ManagedBeanRegistry getManagedBeanRegistry(){\n    return managedBeanRegistry;\n  }\n  @Override public TypeConfiguration getTypeConfiguration(){\n    return typeConfiguration;\n  }\n}\n;\nif(name.startsWith(ConverterDescriptor.TYPE_NAME_PREFIX)){return NamedConverterResolution.from(name,explicitJtdAccess,explicitStdAccess,explicitMutabilityPlanAccess,stdIndicators,converterCreationContext,context);\n}if(name.startsWith(BasicTypeImpl.EXTERNALIZED_PREFIX)){final BasicType<Object> basicType=context.getBootstrapContext().resolveAdHocBasicType(name);\nreturn new NamedBasicTypeResolution<>(basicType.getJavaTypeDescriptor(),basicType,null,explicitMutabilityPlanAccess,context);\n}final BasicType<?> basicTypeByName=typeConfiguration.getBasicTypeRegistry().getRegisteredType(name);\nif(basicTypeByName != null){final BasicValueConverter<?,?> valueConverter;\nfinal JavaType<?> domainJtd;\nif(converterDescriptor != null){valueConverter=converterDescriptor.createJpaAttributeConverter(converterCreationContext);\ndomainJtd=valueConverter.getDomainJavaType();\n}{valueConverter=basicTypeByName.getValueConverter();\ndomainJtd=basicTypeByName.getJavaTypeDescriptor();\n}return new NamedBasicTypeResolution<>(domainJtd,basicTypeByName,valueConverter,explicitMutabilityPlanAccess,context);\n}final TypeDefinition typeDefinition=context.getTypeDefinitionRegistry().resolve(name);\nif(typeDefinition != null){final Resolution<?> resolution=typeDefinition.resolve(localTypeParams,explicitMutabilityPlanAccess != null ? explicitMutabilityPlanAccess.apply(typeConfiguration) : null,context,stdIndicators);\ncombinedParameterConsumer.accept(resolution.getCombinedTypeParameters());\nreturn resolution;\n}final ClassLoaderService cls=serviceRegistry.requireService(ClassLoaderService.class);\ntryfinal Class<?> typeNamedClass=cls.classForName(name);\nif(CollectionHelper.isEmpty(localTypeParams)){final TypeDefinition implicitDefinition=new TypeDefinition(name,typeNamedClass,null,null);\ncontext.getTypeDefinitionRegistry().register(implicitDefinition);\nreturn implicitDefinition.resolve(localTypeParams,explicitMutabilityPlanAccess != null ? explicitMutabilityPlanAccess.apply(typeConfiguration) : null,context,stdIndicators);\n}return TypeDefinition.createLocalResolution(name,typeNamedClass,localTypeParams,context);\ncatch(ClassLoadingException e)log.debugf(\"Could not resolve type-name [%s] as Java type : %s\",name,e);\nthrow new MappingException(\"Could not resolve named type : \" + name);\n}",
            "methodSignature: org.hibernate.mapping.BasicValue#getSoftDeleteStrategy\n methodBody: public SoftDeleteType getSoftDeleteStrategy() {\nreturn softDeleteStrategy;\n}",
            "methodSignature: org.hibernate.mapping.BasicValue#determineJavaType\n methodBody: private JavaType<?> determineJavaType(JavaType<?> explicitJavaType) {\nJavaType<?> javaType=explicitJavaType;\nif(javaType == null){final JavaType<?> reflectedJtd=determineReflectedJavaType();\nif(reflectedJtd != null){javaType=reflectedJtd;\n}}return javaType;\n}",
            "methodSignature: org.hibernate.mapping.BasicValue#converterResolution\n methodBody: private Resolution<?> converterResolution(JavaType<?> javaType, ConverterDescriptor attributeConverterDescriptor) {\nfinal NamedConverterResolution<?> converterResolution=NamedConverterResolution.from(attributeConverterDescriptor,explicitJavaTypeAccess,explicitJdbcTypeAccess,explicitMutabilityPlanAccess,resolvedJavaType,this,this,getBuildingContext());\nif(javaType instanceof BasicPluralJavaType<?> && !attributeConverterDescriptor.getDomainValueResolvedType().getErasedType().isAssignableFrom(javaType.getJavaTypeClass())){final BasicPluralJavaType<?> containerJtd=(BasicPluralJavaType<?>)javaType;\nfinal BasicType registeredElementType=converterResolution.getLegacyResolvedBasicType();\nfinal Selectable column=getColumn();\nfinal BasicType<?> registeredType=registeredElementType == null ? null : containerJtd.resolveType(getTypeConfiguration(),getDialect(),registeredElementType,column instanceof ColumnTypeInformation ? (ColumnTypeInformation)column : null,this);\nif(registeredType != null){getTypeConfiguration().getBasicTypeRegistry().register(registeredType);\nreturn new InferredBasicValueResolution(registeredType,registeredType.getJavaTypeDescriptor(),registeredType.getJavaTypeDescriptor(),registeredType.getJdbcType(),registeredType,null);\n}}return converterResolution;\n}"
        ],
        "sourceCodeAfterRefactoring": "protected Resolution<?> buildResolution() {\n\t\tfinal Properties typeParameters = getTypeParameters();\n\t\tif ( typeParameters != null\n\t\t\t\t&& parseBoolean( typeParameters.getProperty(DynamicParameterizedType.IS_DYNAMIC) )\n\t\t\t\t&& typeParameters.get(DynamicParameterizedType.PARAMETER_TYPE) == null ) {\n\t\t\tcreateParameterImpl();\n\t\t}\n\n\t\tif ( explicitTypeName != null ) {\n\t\t\treturn interpretExplicitlyNamedType(\n\t\t\t\t\texplicitTypeName,\n\t\t\t\t\texplicitJavaTypeAccess,\n\t\t\t\t\texplicitJdbcTypeAccess,\n\t\t\t\t\texplicitMutabilityPlanAccess,\n\t\t\t\t\tgetAttributeConverterDescriptor(),\n\t\t\t\t\ttypeParameters,\n\t\t\t\t\tthis::setTypeParameters,\n\t\t\t\t\tthis,\n\t\t\t\t\tgetBuildingContext()\n\t\t\t);\n\t\t}\n\t\telse if ( isVersion() ) {\n\t\t\treturn VersionResolution.from( implicitJavaTypeAccess, timeZoneStorageType, getBuildingContext() );\n\t\t}\n\t\telse {\n\t\t\t// determine JavaType if we can\n\t\t\tfinal BasicJavaType<?> explicitJavaType = getExplicitJavaType();\n\t\t\tfinal JavaType<?> javaType = determineJavaType( explicitJavaType );\n\t\t\tfinal ConverterDescriptor converterDescriptor = getConverterDescriptor( javaType );\n\t\t\treturn converterDescriptor != null\n\t\t\t\t\t? converterResolution( javaType, converterDescriptor )\n\t\t\t\t\t: resolution( explicitJavaType, javaType );\n\t\t}\n\t}\nprivate BasicJavaType<?> getExplicitJavaType() {\n\t\treturn explicitJavaTypeAccess == null ? null\n\t\t\t\t: explicitJavaTypeAccess.apply( getTypeConfiguration() );\n\t}",
        "diffSourceCode": "-  427: \n-  428: \tprotected Resolution<?> buildResolution() {\n-  429: \t\tfinal Properties typeParameters = getTypeParameters();\n-  430: \t\tif ( typeParameters != null\n-  431: \t\t\t\t&& parseBoolean( typeParameters.getProperty(DynamicParameterizedType.IS_DYNAMIC) )\n-  432: \t\t\t\t&& typeParameters.get(DynamicParameterizedType.PARAMETER_TYPE) == null ) {\n-  433: \t\t\tcreateParameterImpl();\n-  434: \t\t}\n-  435: \n-  436: \t\tif ( explicitTypeName != null ) {\n-  437: \t\t\treturn interpretExplicitlyNamedType(\n-  438: \t\t\t\t\texplicitTypeName,\n-  439: \t\t\t\t\texplicitJavaTypeAccess,\n-  440: \t\t\t\t\texplicitJdbcTypeAccess,\n-  441: \t\t\t\t\texplicitMutabilityPlanAccess,\n-  442: \t\t\t\t\tgetAttributeConverterDescriptor(),\n-  443: \t\t\t\t\ttypeParameters,\n-  444: \t\t\t\t\tthis::setTypeParameters,\n-  445: \t\t\t\t\tthis,\n-  446: \t\t\t\t\tgetBuildingContext()\n-  447: \t\t\t);\n-  448: \t\t}\n-  449: \n-  450: \t\tif ( isVersion() ) {\n-  451: \t\t\treturn VersionResolution.from( implicitJavaTypeAccess, timeZoneStorageType, getBuildingContext() );\n-  452: \t\t}\n-  453: \n-  454: \t\t// determine JavaType if we can\n-  455: \t\tfinal BasicJavaType<?> explicitJavaType = explicitJavaTypeAccess == null\n-  456: \t\t\t\t? null\n-  457: \t\t\t\t: explicitJavaTypeAccess.apply( getTypeConfiguration() );\n-  458: \n-  459: \t\tJavaType<?> javaType = determineJavaType( explicitJavaType );\n-  460: \t\tConverterDescriptor attributeConverterDescriptor = getAttributeConverterDescriptor();\n+  427: \tprotected Resolution<?> buildResolution() {\n+  428: \t\tfinal Properties typeParameters = getTypeParameters();\n+  429: \t\tif ( typeParameters != null\n+  430: \t\t\t\t&& parseBoolean( typeParameters.getProperty(DynamicParameterizedType.IS_DYNAMIC) )\n+  431: \t\t\t\t&& typeParameters.get(DynamicParameterizedType.PARAMETER_TYPE) == null ) {\n+  432: \t\t\tcreateParameterImpl();\n+  433: \t\t}\n+  434: \n+  435: \t\tif ( explicitTypeName != null ) {\n+  436: \t\t\treturn interpretExplicitlyNamedType(\n+  437: \t\t\t\t\texplicitTypeName,\n+  438: \t\t\t\t\texplicitJavaTypeAccess,\n+  439: \t\t\t\t\texplicitJdbcTypeAccess,\n+  440: \t\t\t\t\texplicitMutabilityPlanAccess,\n+  441: \t\t\t\t\tgetAttributeConverterDescriptor(),\n+  442: \t\t\t\t\ttypeParameters,\n+  443: \t\t\t\t\tthis::setTypeParameters,\n+  444: \t\t\t\t\tthis,\n+  445: \t\t\t\t\tgetBuildingContext()\n+  446: \t\t\t);\n+  447: \t\t}\n+  448: \t\telse if ( isVersion() ) {\n+  449: \t\t\treturn VersionResolution.from( implicitJavaTypeAccess, timeZoneStorageType, getBuildingContext() );\n+  450: \t\t}\n+  451: \t\telse {\n+  452: \t\t\t// determine JavaType if we can\n+  453: \t\t\tfinal BasicJavaType<?> explicitJavaType = getExplicitJavaType();\n+  454: \t\t\tfinal JavaType<?> javaType = determineJavaType( explicitJavaType );\n+  455: \t\t\tfinal ConverterDescriptor converterDescriptor = getConverterDescriptor( javaType );\n+  456: \t\t\treturn converterDescriptor != null\n+  457: \t\t\t\t\t? converterResolution( javaType, converterDescriptor )\n+  458: \t\t\t\t\t: resolution( explicitJavaType, javaType );\n+  459: \t\t}\n+  460: \t}\n   461: \n-  462: \t\tif ( isSoftDelete() ) {\n-  463: \t\t\tassert attributeConverterDescriptor != null;\n-  464: \t\t\tfinal boolean conversionWasUnspecified = SoftDelete.UnspecifiedConversion.class.equals( attributeConverterDescriptor.getAttributeConverterClass() );\n-  465: \t\t\tif ( conversionWasUnspecified ) {\n-  466: \t\t\t\tfinal JdbcType jdbcType = BooleanJdbcType.INSTANCE.resolveIndicatedType( this, javaType );\n-  467: \t\t\t\tif ( jdbcType.isNumber() ) {\n-  468: \t\t\t\t\tattributeConverterDescriptor = new InstanceBasedConverterDescriptor(\n-  469: \t\t\t\t\t\t\tNumericBooleanConverter.INSTANCE,\n-  470: \t\t\t\t\t\t\tgetBuildingContext().getBootstrapContext().getClassmateContext()\n-  471: \t\t\t\t\t);\n-  472: \t\t\t\t}\n-  473: \t\t\t\telse if ( jdbcType.isString() ) {\n-  474: \t\t\t\t\t// here we pick 'T' / 'F' storage, though 'Y' / 'N' is equally valid - its 50/50\n-  475: \t\t\t\t\tattributeConverterDescriptor = new InstanceBasedConverterDescriptor(\n-  476: \t\t\t\t\t\t\tTrueFalseConverter.INSTANCE,\n-  477: \t\t\t\t\t\t\tgetBuildingContext().getBootstrapContext().getClassmateContext()\n-  478: \t\t\t\t\t);\n-  479: \t\t\t\t}\n-  480: \t\t\t\telse {\n-  481: \t\t\t\t\t// should indicate BIT or BOOLEAN == no conversion needed\n-  482: \t\t\t\t\t//\t\t- we still create the converter to properly set up JDBC type, etc\n-  483: \t\t\t\t\tattributeConverterDescriptor = new InstanceBasedConverterDescriptor(\n-  484: \t\t\t\t\t\t\tPassThruSoftDeleteConverter.INSTANCE,\n-  485: \t\t\t\t\t\t\tgetBuildingContext().getBootstrapContext().getClassmateContext()\n-  486: \t\t\t\t\t);\n-  487: \t\t\t\t}\n-  488: \t\t\t}\n-  489: \n-  490: \t\t\tif ( getSoftDeleteStrategy() == SoftDeleteType.ACTIVE ) {\n-  491: \t\t\t\tattributeConverterDescriptor = new ReversedConverterDescriptor<>( attributeConverterDescriptor );\n-  492: \t\t\t}\n-  493: \t\t}\n-  494: \n-  495: \t\treturn attributeConverterDescriptor != null\n-  496: \t\t\t\t? converterResolution( javaType, attributeConverterDescriptor )\n-  497: \t\t\t\t: resolution( explicitJavaType, javaType );\n-  498: \t}\n+  462: \tprivate BasicJavaType<?> getExplicitJavaType() {\n+  463: \t\treturn explicitJavaTypeAccess == null ? null\n+  464: \t\t\t\t: explicitJavaTypeAccess.apply( getTypeConfiguration() );\n+  465: \t}\n+  466: \n+  467: \tprivate ConverterDescriptor getConverterDescriptor(JavaType<?> javaType) {\n+  468: \t\tfinal ConverterDescriptor converterDescriptor = getAttributeConverterDescriptor();\n+  469: \t\tif ( isSoftDelete() ) {\n+  470: \t\t\tassert converterDescriptor != null;\n+  471: \t\t\tfinal ConverterDescriptor softDeleteConverterDescriptor =\n+  472: \t\t\t\t\tgetSoftDeleteConverterDescriptor( converterDescriptor, javaType);\n+  473: \t\t\treturn getSoftDeleteStrategy() == SoftDeleteType.ACTIVE\n+  474: \t\t\t\t\t? new ReversedConverterDescriptor<>( softDeleteConverterDescriptor )\n+  475: \t\t\t\t\t: softDeleteConverterDescriptor;\n+  476: \t\t}\n+  477: \t\telse {\n+  478: \t\t\treturn converterDescriptor;\n+  479: \t\t}\n+  480: \t}\n+  481: \n+  482: \tprivate ConverterDescriptor getSoftDeleteConverterDescriptor(\n+  483: \t\t\tConverterDescriptor attributeConverterDescriptor, JavaType<?> javaType) {\n+  484: \t\tfinal boolean conversionWasUnspecified =\n+  485: \t\t\t\tSoftDelete.UnspecifiedConversion.class.equals( attributeConverterDescriptor.getAttributeConverterClass() );\n+  486: \t\tif ( conversionWasUnspecified ) {\n+  487: \t\t\tfinal JdbcType jdbcType = BooleanJdbcType.INSTANCE.resolveIndicatedType( this, javaType);\n+  488: \t\t\tif ( jdbcType.isNumber() ) {\n+  489: \t\t\t\treturn new InstanceBasedConverterDescriptor(\n+  490: \t\t\t\t\t\tNumericBooleanConverter.INSTANCE,\n+  491: \t\t\t\t\t\tgetBuildingContext().getBootstrapContext().getClassmateContext()\n+  492: \t\t\t\t);\n+  493: \t\t\t}\n+  494: \t\t\telse if ( jdbcType.isString() ) {\n+  495: \t\t\t\t// here we pick 'T' / 'F' storage, though 'Y' / 'N' is equally valid - its 50/50\n+  496: \t\t\t\treturn new InstanceBasedConverterDescriptor(\n+  497: \t\t\t\t\t\tTrueFalseConverter.INSTANCE,\n+  498: \t\t\t\t\t\tgetBuildingContext().getBootstrapContext().getClassmateContext()\n",
        "uniqueId": "6c6c92e88d4535be020b4acb3d81f96df39a65d8_428_498_462_465_427_460",
        "moveFileExist": true,
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 21,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 0,
                "covered": 71
            },
            "BRANCH": {
                "missed": 0,
                "covered": 12
            },
            "LINE": {
                "missed": 0,
                "covered": 17
            },
            "COMPLEXITY": {
                "missed": 0,
                "covered": 7
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        }
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprivate verifyOutcome(statementDetails PreparedStatementDetails, affectedRowCount int, batchPosition int) : boolean extracted from protected doDynamicInserts(id Object, values Object[], object Object, session SharedSessionContractImplementor, forceIdentifierBinding boolean) : GeneratedValues in class org.hibernate.persister.entity.mutation.InsertCoordinatorStandard",
        "diffLocations": [
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/persister/entity/mutation/InsertCoordinatorStandard.java",
                "startLine": 296,
                "endLine": 333,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/persister/entity/mutation/InsertCoordinatorStandard.java",
                "startLine": 290,
                "endLine": 320,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/persister/entity/mutation/InsertCoordinatorStandard.java",
                "startLine": 322,
                "endLine": 331,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "protected GeneratedValues doDynamicInserts(\n\t\t\tObject id,\n\t\t\tObject[] values,\n\t\t\tObject object,\n\t\t\tSharedSessionContractImplementor session,\n\t\t\tboolean forceIdentifierBinding) {\n\t\tfinal boolean[] insertability = getPropertiesToInsert( values );\n\t\tfinal MutationOperationGroup insertGroup = generateDynamicInsertSqlGroup( insertability, object, session, forceIdentifierBinding );\n\n\t\tfinal MutationExecutor mutationExecutor = executor( session, insertGroup, true );\n\n\t\tfinal InsertValuesAnalysis insertValuesAnalysis = new InsertValuesAnalysis( entityPersister(), values );\n\n\t\tfinal TableInclusionChecker tableInclusionChecker = getTableInclusionChecker( insertValuesAnalysis );\n\n\t\tdecomposeForInsert( mutationExecutor, id, values, insertGroup, insertability, tableInclusionChecker, session );\n\n\t\ttry {\n\t\t\treturn mutationExecutor.execute(\n\t\t\t\t\tobject,\n\t\t\t\t\tinsertValuesAnalysis,\n\t\t\t\t\ttableInclusionChecker,\n\t\t\t\t\t(statementDetails, affectedRowCount, batchPosition) -> {\n\t\t\t\t\t\tstatementDetails.getExpectation().verifyOutcome(\n\t\t\t\t\t\t\t\taffectedRowCount,\n\t\t\t\t\t\t\t\tstatementDetails.getStatement(),\n\t\t\t\t\t\t\t\tbatchPosition,\n\t\t\t\t\t\t\t\tstatementDetails.getSqlString()\n\t\t\t\t\t\t);\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t},\n\t\t\t\t\tsession\n\t\t\t);\n\t\t}\n\t\tfinally {\n\t\t\tmutationExecutor.release();\n\t\t}\n\t}",
        "filePathBefore": "hibernate-core/src/main/java/org/hibernate/persister/entity/mutation/InsertCoordinatorStandard.java",
        "isPureRefactoring": true,
        "commitId": "ee00217733018075ccade7e1145f45ff9acae0c2",
        "packageNameBefore": "org.hibernate.persister.entity.mutation",
        "classNameBefore": "org.hibernate.persister.entity.mutation.InsertCoordinatorStandard",
        "methodNameBefore": "org.hibernate.persister.entity.mutation.InsertCoordinatorStandard#doDynamicInserts",
        "invokedMethod": "methodSignature: org.hibernate.persister.entity.mutation.InsertCoordinatorStandard#getPropertiesToInsert\n methodBody: public boolean[] getPropertiesToInsert(Object[] fields) {\nboolean[] notNull=new boolean[fields.length];\nboolean[] insertable=entityPersister().getPropertyInsertability();\nfor(int i=0; i < fields.length; i++){notNull[i]=insertable[i] && fields[i] != null;\n}return notNull;\n}\nmethodSignature: org.hibernate.persister.entity.mutation.InsertCoordinatorStandard#decomposeForInsert\n methodBody: protected void decomposeForInsert(\n\t\t\tMutationExecutor mutationExecutor,\n\t\t\tObject id,\n\t\t\tObject[] values,\n\t\t\tMutationOperationGroup mutationGroup,\n\t\t\tboolean[] propertyInclusions,\n\t\t\tTableInclusionChecker tableInclusionChecker,\n\t\t\tSharedSessionContractImplementor session) {\nfinal JdbcValueBindings jdbcValueBindings=mutationExecutor.getJdbcValueBindings();\nfinal AttributeMappingsList attributeMappings=entityPersister().getAttributeMappings();\nfor(int position=0; position < mutationGroup.getNumberOfOperations(); position++){final MutationOperation operation=mutationGroup.getOperation(position);\nfinal EntityTableMapping tableDetails=(EntityTableMapping)operation.getTableDetails();\nif(tableInclusionChecker.include(tableDetails)){final int[] attributeIndexes=tableDetails.getAttributeIndexes();\nfor(int i=0; i < attributeIndexes.length; i++){final int attributeIndex=attributeIndexes[i];\nif(propertyInclusions[attributeIndex]){final AttributeMapping mapping=attributeMappings.get(attributeIndex);\ndecomposeAttribute(values[attributeIndex],session,jdbcValueBindings,mapping);\n}}}}if(id == null){assert entityPersister().getInsertDelegate() != null;\n}{for(int position=0; position < mutationGroup.getNumberOfOperations(); position++){final MutationOperation jdbcOperation=mutationGroup.getOperation(position);\nfinal EntityTableMapping tableDetails=(EntityTableMapping)jdbcOperation.getTableDetails();\nbreakDownJdbcValue(id,session,jdbcValueBindings,tableDetails);\n}}}\nmethodSignature: org.hibernate.engine.jdbc.mutation.internal.MutationExecutorStandard#release\n methodBody: public void release() {\nnonBatchedStatementGroup.release();\n}\nmethodSignature: org.hibernate.persister.entity.mutation.InsertCoordinatorStandard#getTableInclusionChecker\n methodBody: protected static TableInclusionChecker getTableInclusionChecker(InsertValuesAnalysis insertValuesAnalysis) {\nreturn tableMapping -> !tableMapping.isOptional() || insertValuesAnalysis.hasNonNullBindings(tableMapping);\n}\nmethodSignature: org.hibernate.engine.jdbc.mutation.internal.AbstractMutationExecutor#execute\n methodBody: public final GeneratedValues execute(\n\t\t\tObject modelReference,\n\t\t\tValuesAnalysis valuesAnalysis,\n\t\t\tTableInclusionChecker inclusionChecker,\n\t\t\tOperationResultChecker resultChecker,\n\t\t\tSharedSessionContractImplementor session) {\nfinal GeneratedValues generatedValues=performNonBatchedOperations(modelReference,valuesAnalysis,inclusionChecker,resultChecker,session);\nperformSelfExecutingOperations(valuesAnalysis,inclusionChecker,session);\nperformBatchedOperations(valuesAnalysis,inclusionChecker);\nreturn generatedValues;\n}\nmethodSignature: org.hibernate.orm.test.jpa.transaction.batch.AbstractBatchingTest.BatchWrapper#execute\n methodBody: public void execute() {\nwrapped.execute();\n}\nmethodSignature: org.hibernate.engine.jdbc.batch.spi.Batch#execute\n methodBody: void execute();\nmethodSignature: org.hibernate.orm.test.jpa.transaction.batch.AbstractBatchingTest.BatchWrapper#release\n methodBody: public void release() {\nwasReleaseCalled=true;\nwrapped.release();\nnumberOfStatementsAfterRelease=wrapped.getStatementGroup().getNumberOfActiveStatements();\n}\nmethodSignature: org.hibernate.persister.entity.mutation.AbstractDeleteCoordinator#executor\n methodBody: private MutationExecutor executor(SharedSessionContractImplementor session, MutationOperationGroup group) {\nreturn mutationExecutorService.createExecutor(resolveBatchKeyAccess(false,session),group,session);\n}\nmethodSignature: org.hibernate.engine.jdbc.batch.internal.BatchImpl#execute\n methodBody: public void execute() {\nnotifyObserversExplicitExecution();\nif(getStatementGroup().getNumberOfStatements() == 0){return;\n}tryif(batchPosition == 0){if(!batchExecuted){if(BATCH_LOGGER.isDebugEnabled()){BATCH_LOGGER.debugf(\"No batched statements to execute - %s\",getKey().toLoggableString());\n}}}{performExecution();\n}finallyreleaseStatements();\n}\nmethodSignature: org.hibernate.engine.jdbc.batch.spi.Batch#release\n methodBody: void release();\nmethodSignature: org.hibernate.persister.entity.mutation.InsertCoordinatorStandard#generateDynamicInsertSqlGroup\n methodBody: protected MutationOperationGroup generateDynamicInsertSqlGroup(\n\t\t\tboolean[] insertable,\n\t\t\tObject object,\n\t\t\tSharedSessionContractImplementor session,\n\t\t\tboolean forceIdentifierBinding) {\nfinal MutationGroupBuilder insertGroupBuilder=new MutationGroupBuilder(MutationType.INSERT,entityPersister());\nentityPersister().forEachMutableTable((tableMapping) -> insertGroupBuilder.addTableDetailsBuilder(createTableInsertBuilder(tableMapping,forceIdentifierBinding)));\napplyTableInsertDetails(insertGroupBuilder,insertable,object,session,forceIdentifierBinding);\nreturn createOperationGroup(null,insertGroupBuilder.buildMutationGroup());\n}\nmethodSignature: org.hibernate.engine.jdbc.mutation.internal.MutationExecutorSingleBatched#release\n methodBody: public void release() {\n}\nmethodSignature: org.hibernate.engine.jdbc.mutation.MutationExecutor#release\n methodBody: void release();\nmethodSignature: org.hibernate.persister.entity.mutation.UpdateCoordinatorStandard#executor\n methodBody: private MutationExecutor executor(SharedSessionContractImplementor session, MutationOperationGroup group, boolean dynamicUpdate) {\nreturn mutationExecutorService.createExecutor(resolveBatchKeyAccess(dynamicUpdate,session),group,session);\n}\nmethodSignature: org.hibernate.engine.jdbc.batch.internal.BatchImpl#release\n methodBody: public void release() {\nif(BATCH_MESSAGE_LOGGER.isInfoEnabled()){final PreparedStatementGroup statementGroup=getStatementGroup();\nif(statementGroup.getNumberOfStatements() != 0){if(statementGroup.hasMatching((statementDetails) -> statementDetails.getStatement() != null)){BATCH_MESSAGE_LOGGER.batchContainedStatementsOnRelease();\n}}}releaseStatements();\nobservers.clear();\n}\nmethodSignature: org.hibernate.persister.entity.mutation.AbstractMutationCoordinator#entityPersister\n methodBody: protected EntityPersister entityPersister() {\nreturn entityPersister;\n}\nmethodSignature: org.hibernate.engine.jdbc.mutation.MutationExecutor#execute\n methodBody: GeneratedValues execute(\n\t\t\tObject modelReference,\n\t\t\tValuesAnalysis valuesAnalysis,\n\t\t\tTableInclusionChecker inclusionChecker,\n\t\t\tOperationResultChecker resultChecker,\n\t\t\tSharedSessionContractImplementor session);\nmethodSignature: org.hibernate.persister.entity.mutation.InsertCoordinatorStandard#executor\n methodBody: private MutationExecutor executor(SharedSessionContractImplementor session, MutationOperationGroup group, boolean dynamicUpdate) {\nreturn mutationExecutorService.createExecutor(resolveBatchKeyAccess(dynamicUpdate,session),group,session);\n}",
        "classSignatureBefore": "public class InsertCoordinatorStandard extends AbstractMutationCoordinator implements InsertCoordinator ",
        "methodNameBeforeSet": [
            "org.hibernate.persister.entity.mutation.InsertCoordinatorStandard#doDynamicInserts"
        ],
        "classNameBeforeSet": [
            "org.hibernate.persister.entity.mutation.InsertCoordinatorStandard"
        ],
        "classSignatureBeforeSet": [
            "public class InsertCoordinatorStandard extends AbstractMutationCoordinator implements InsertCoordinator "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n * See the lgpl.txt file in the root directory or http://www.gnu.org/licenses/lgpl-2.1.html.\n */\npackage org.hibernate.persister.entity.mutation;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.hibernate.Internal;\nimport org.hibernate.dialect.Dialect;\nimport org.hibernate.engine.jdbc.batch.internal.BasicBatchKey;\nimport org.hibernate.engine.jdbc.batch.spi.BatchKey;\nimport org.hibernate.engine.jdbc.mutation.JdbcValueBindings;\nimport org.hibernate.engine.jdbc.mutation.MutationExecutor;\nimport org.hibernate.engine.jdbc.mutation.ParameterUsage;\nimport org.hibernate.engine.jdbc.mutation.TableInclusionChecker;\nimport org.hibernate.engine.spi.SessionFactoryImplementor;\nimport org.hibernate.engine.spi.SharedSessionContractImplementor;\nimport org.hibernate.generator.BeforeExecutionGenerator;\nimport org.hibernate.generator.Generator;\nimport org.hibernate.generator.OnExecutionGenerator;\nimport org.hibernate.generator.values.GeneratedValues;\nimport org.hibernate.generator.values.GeneratedValuesMutationDelegate;\nimport org.hibernate.metamodel.mapping.AttributeMapping;\nimport org.hibernate.metamodel.mapping.AttributeMappingsList;\nimport org.hibernate.metamodel.mapping.BasicEntityIdentifierMapping;\nimport org.hibernate.metamodel.mapping.PluralAttributeMapping;\nimport org.hibernate.persister.entity.EntityPersister;\nimport org.hibernate.sql.model.MutationOperation;\nimport org.hibernate.sql.model.MutationOperationGroup;\nimport org.hibernate.sql.model.MutationType;\nimport org.hibernate.sql.model.TableMapping;\nimport org.hibernate.sql.model.ValuesAnalysis;\nimport org.hibernate.sql.model.ast.builder.MutationGroupBuilder;\nimport org.hibernate.sql.model.ast.builder.TableInsertBuilder;\nimport org.hibernate.sql.model.ast.builder.TableInsertBuilderStandard;\nimport org.hibernate.sql.model.ast.builder.TableMutationBuilder;\nimport org.hibernate.tuple.entity.EntityMetamodel;\n\nimport org.checkerframework.checker.nullness.qual.Nullable;\n\nimport static org.hibernate.generator.EventType.INSERT;\n\n/**\n * Coordinates the insertion of an entity.\n *\n * @see #coordinateInsert\n *\n * @author Steve Ebersole\n */\n@Internal\npublic class InsertCoordinatorStandard extends AbstractMutationCoordinator implements InsertCoordinator {\n\tprivate final MutationOperationGroup staticInsertGroup;\n\tprivate final BasicBatchKey batchKey;\n\n\tpublic InsertCoordinatorStandard(EntityPersister entityPersister, SessionFactoryImplementor factory) {\n\t\tsuper( entityPersister, factory );\n\n\t\tif ( entityPersister.isIdentifierAssignedByInsert() || entityPersister.hasInsertGeneratedProperties() ) {\n\t\t\t// disable batching in case of insert generated identifier or properties\n\t\t\tbatchKey = null;\n\t\t}\n\t\telse {\n\t\t\tbatchKey = new BasicBatchKey( entityPersister.getEntityName() + \"#INSERT\" );\n\t\t}\n\n\t\tif ( entityPersister.getEntityMetamodel().isDynamicInsert() ) {\n\t\t\t// the entity specified dynamic-insert - skip generating the\n\t\t\t// static inserts as we will create them every time\n\t\t\tstaticInsertGroup = null;\n\t\t}\n\t\telse {\n\t\t\tstaticInsertGroup = generateStaticOperationGroup();\n\t\t}\n\t}\n\n\t@Override\n\tpublic MutationOperationGroup getStaticMutationOperationGroup() {\n\t\treturn staticInsertGroup;\n\t}\n\n\t@Override\n\tprotected BatchKey getBatchKey() {\n\t\treturn batchKey;\n\t}\n\n\t@Override\n\tpublic @Nullable GeneratedValues insert(Object entity, Object[] values, SharedSessionContractImplementor session) {\n\t\treturn coordinateInsert( null, values, entity, session );\n\t}\n\n\t@Override\n\tpublic @Nullable GeneratedValues insert(\n\t\t\tObject entity,\n\t\t\tObject id,\n\t\t\tObject[] values,\n\t\t\tSharedSessionContractImplementor session) {\n\t\treturn coordinateInsert( id, values, entity, session );\n\t}\n\n\t/**\n\t * Perform the insert(s).\n\t *\n\t * @param id This is the id as known in memory. For post-insert id generation (IDENTITY, etc)\n\t * this will be null.\n\t * @param values The extracted attribute values\n\t * @param entity The entity instance being persisted\n\t * @param session The originating context\n\t *\n\t * @return The {@linkplain GeneratedValues generated values} if any, {@code null} otherwise.\n\t */\n\tpublic GeneratedValues coordinateInsert(\n\t\t\tObject id,\n\t\t\tObject[] values,\n\t\t\tObject entity,\n\t\t\tSharedSessionContractImplementor session) {\n\t\t// apply any pre-insert in-memory value generation\n\t\tfinal boolean needsDynamicInsert = preInsertInMemoryValueGeneration( values, entity, session );\n\n\t\tfinal EntityMetamodel entityMetamodel = entityPersister().getEntityMetamodel();\n\t\tfinal boolean forceIdentifierBinding = entityPersister().getGenerator().generatedOnExecution() && id != null;\n\t\tif ( entityMetamodel.isDynamicInsert() || needsDynamicInsert || forceIdentifierBinding ) {\n\t\t\treturn doDynamicInserts( id, values, entity, session, forceIdentifierBinding );\n\t\t}\n\t\telse {\n\t\t\treturn doStaticInserts( id, values, entity, session );\n\t\t}\n\t}\n\n\tprotected boolean preInsertInMemoryValueGeneration(Object[] values, Object entity, SharedSessionContractImplementor session) {\n\t\tfinal EntityPersister persister = entityPersister();\n\t\tfinal EntityMetamodel entityMetamodel = persister.getEntityMetamodel();\n\t\tboolean foundStateDependentGenerator = false;\n\t\tif ( entityMetamodel.hasPreInsertGeneratedValues() ) {\n\t\t\tfinal Generator[] generators = entityMetamodel.getGenerators();\n\t\t\tfor ( int i = 0; i < generators.length; i++ ) {\n\t\t\t\tfinal Generator generator = generators[i];\n\t\t\t\tif ( generator != null\n\t\t\t\t\t\t&& generator.generatesOnInsert()\n\t\t\t\t\t\t&& !generator.generatedOnExecution( entity, session ) ) {\n\t\t\t\t\tvalues[i] = ( (BeforeExecutionGenerator) generator ).generate( session, entity, values[i], INSERT );\n\t\t\t\t\tpersister.setPropertyValue( entity, i, values[i] );\n\t\t\t\t\tfoundStateDependentGenerator = foundStateDependentGenerator || generator.generatedOnExecution();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn foundStateDependentGenerator;\n\t}\n\n\tpublic static class InsertValuesAnalysis implements ValuesAnalysis {\n\t\tprivate final List<TableMapping> tablesWithNonNullValues = new ArrayList<>();\n\n\t\tpublic InsertValuesAnalysis(EntityMutationTarget mutationTarget, Object[] values) {\n\t\t\tmutationTarget.forEachMutableTable( (tableMapping) -> {\n\t\t\t\tfinal int[] tableAttributeIndexes = tableMapping.getAttributeIndexes();\n\t\t\t\tfor ( int i = 0; i < tableAttributeIndexes.length; i++ ) {\n\t\t\t\t\tif ( values[tableAttributeIndexes[i]] != null ) {\n\t\t\t\t\t\ttablesWithNonNullValues.add( tableMapping );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} );\n\t\t}\n\n\t\tpublic boolean hasNonNullBindings(TableMapping tableMapping) {\n\t\t\treturn tablesWithNonNullValues.contains( tableMapping );\n\t\t}\n\t}\n\n\tprotected GeneratedValues doStaticInserts(Object id, Object[] values, Object object, SharedSessionContractImplementor session) {\n\t\tfinal InsertValuesAnalysis insertValuesAnalysis = new InsertValuesAnalysis( entityPersister(), values );\n\n\t\tfinal TableInclusionChecker tableInclusionChecker = getTableInclusionChecker( insertValuesAnalysis );\n\n\t\tfinal MutationExecutor mutationExecutor = executor( session, staticInsertGroup, false );\n\n\t\tdecomposeForInsert(\n\t\t\t\tmutationExecutor,\n\t\t\t\tid,\n\t\t\t\tvalues,\n\t\t\t\tstaticInsertGroup,\n\t\t\t\tentityPersister().getPropertyInsertability(),\n\t\t\t\ttableInclusionChecker,\n\t\t\t\tsession\n\t\t);\n\n\t\ttry {\n\t\t\treturn mutationExecutor.execute(\n\t\t\t\t\tobject,\n\t\t\t\t\tinsertValuesAnalysis,\n\t\t\t\t\ttableInclusionChecker,\n\t\t\t\t\t(statementDetails, affectedRowCount, batchPosition) -> {\n\t\t\t\t\t\tstatementDetails.getExpectation().verifyOutcome(\n\t\t\t\t\t\t\t\taffectedRowCount,\n\t\t\t\t\t\t\t\tstatementDetails.getStatement(),\n\t\t\t\t\t\t\t\tbatchPosition,\n\t\t\t\t\t\t\t\tstatementDetails.getSqlString()\n\t\t\t\t\t\t);\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t},\n\t\t\t\t\tsession\n\t\t\t);\n\t\t}\n\t\tfinally {\n\t\t\tmutationExecutor.release();\n\t\t}\n\t}\n\n\tprotected void decomposeForInsert(\n\t\t\tMutationExecutor mutationExecutor,\n\t\t\tObject id,\n\t\t\tObject[] values,\n\t\t\tMutationOperationGroup mutationGroup,\n\t\t\tboolean[] propertyInclusions,\n\t\t\tTableInclusionChecker tableInclusionChecker,\n\t\t\tSharedSessionContractImplementor session) {\n\t\tfinal JdbcValueBindings jdbcValueBindings = mutationExecutor.getJdbcValueBindings();\n\t\tfinal AttributeMappingsList attributeMappings = entityPersister().getAttributeMappings();\n\n\t\tfor ( int position = 0; position < mutationGroup.getNumberOfOperations(); position++ ) {\n\t\t\tfinal MutationOperation operation = mutationGroup.getOperation( position );\n\t\t\tfinal EntityTableMapping tableDetails = (EntityTableMapping) operation.getTableDetails();\n\t\t\tif ( tableInclusionChecker.include( tableDetails ) ) {\n\t\t\t\tfinal int[] attributeIndexes = tableDetails.getAttributeIndexes();\n\t\t\t\tfor ( int i = 0; i < attributeIndexes.length; i++ ) {\n\t\t\t\t\tfinal int attributeIndex = attributeIndexes[ i ];\n\t\t\t\t\tif ( propertyInclusions[attributeIndex] ) {\n\t\t\t\t\t\tfinal AttributeMapping mapping = attributeMappings.get( attributeIndex );\n\t\t\t\t\t\tdecomposeAttribute( values[attributeIndex], session, jdbcValueBindings, mapping );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ( id == null ) {\n\t\t\tassert entityPersister().getInsertDelegate() != null;\n\t\t}\n\t\telse {\n\t\t\tfor ( int position = 0; position < mutationGroup.getNumberOfOperations(); position++ ) {\n\t\t\t\tfinal MutationOperation jdbcOperation = mutationGroup.getOperation( position );\n\t\t\t\tfinal EntityTableMapping tableDetails = (EntityTableMapping) jdbcOperation.getTableDetails();\n\t\t\t\tbreakDownJdbcValue( id, session, jdbcValueBindings, tableDetails );\n\t\t\t}\n\t\t}\n\t}\n\n\tprotected void breakDownJdbcValue(\n\t\t\tObject id,\n\t\t\tSharedSessionContractImplementor session,\n\t\t\tJdbcValueBindings jdbcValueBindings,\n\t\t\tEntityTableMapping tableDetails) {\n\t\tfinal String tableName = tableDetails.getTableName();\n\t\ttableDetails.getKeyMapping().breakDownKeyJdbcValues(\n\t\t\t\tid,\n\t\t\t\t(jdbcValue, columnMapping) -> {\n\t\t\t\t\tjdbcValueBindings.bindValue(\n\t\t\t\t\t\t\tjdbcValue,\n\t\t\t\t\t\t\ttableName,\n\t\t\t\t\t\t\tcolumnMapping.getColumnName(),\n\t\t\t\t\t\t\tParameterUsage.SET\n\t\t\t\t\t);\n\t\t\t\t},\n\t\t\t\tsession\n\t\t);\n\t}\n\n\tprotected void decomposeAttribute(\n\t\t\tObject value,\n\t\t\tSharedSessionContractImplementor session,\n\t\t\tJdbcValueBindings jdbcValueBindings,\n\t\t\tAttributeMapping mapping) {\n\t\tif ( !(mapping instanceof PluralAttributeMapping) ) {\n\t\t\tmapping.decompose(\n\t\t\t\t\tvalue,\n\t\t\t\t\t0,\n\t\t\t\t\tjdbcValueBindings,\n\t\t\t\t\tnull,\n\t\t\t\t\t(valueIndex, bindings, noop, jdbcValue, selectableMapping) -> {\n\t\t\t\t\t\tif ( selectableMapping.isInsertable() ) {\n\t\t\t\t\t\t\tbindings.bindValue(\n\t\t\t\t\t\t\t\t\tjdbcValue,\n\t\t\t\t\t\t\t\t\tentityPersister().physicalTableNameForMutation( selectableMapping ),\n\t\t\t\t\t\t\t\t\tselectableMapping.getSelectionExpression(),\n\t\t\t\t\t\t\t\t\tParameterUsage.SET\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tsession\n\t\t\t);\n\t\t}\n\t}\n\n\tprotected GeneratedValues doDynamicInserts(\n\t\t\tObject id,\n\t\t\tObject[] values,\n\t\t\tObject object,\n\t\t\tSharedSessionContractImplementor session,\n\t\t\tboolean forceIdentifierBinding) {\n\t\tfinal boolean[] insertability = getPropertiesToInsert( values );\n\t\tfinal MutationOperationGroup insertGroup = generateDynamicInsertSqlGroup( insertability, object, session, forceIdentifierBinding );\n\n\t\tfinal MutationExecutor mutationExecutor = executor( session, insertGroup, true );\n\n\t\tfinal InsertValuesAnalysis insertValuesAnalysis = new InsertValuesAnalysis( entityPersister(), values );\n\n\t\tfinal TableInclusionChecker tableInclusionChecker = getTableInclusionChecker( insertValuesAnalysis );\n\n\t\tdecomposeForInsert( mutationExecutor, id, values, insertGroup, insertability, tableInclusionChecker, session );\n\n\t\ttry {\n\t\t\treturn mutationExecutor.execute(\n\t\t\t\t\tobject,\n\t\t\t\t\tinsertValuesAnalysis,\n\t\t\t\t\ttableInclusionChecker,\n\t\t\t\t\t(statementDetails, affectedRowCount, batchPosition) -> {\n\t\t\t\t\t\tstatementDetails.getExpectation().verifyOutcome(\n\t\t\t\t\t\t\t\taffectedRowCount,\n\t\t\t\t\t\t\t\tstatementDetails.getStatement(),\n\t\t\t\t\t\t\t\tbatchPosition,\n\t\t\t\t\t\t\t\tstatementDetails.getSqlString()\n\t\t\t\t\t\t);\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t},\n\t\t\t\t\tsession\n\t\t\t);\n\t\t}\n\t\tfinally {\n\t\t\tmutationExecutor.release();\n\t\t}\n\t}\n\n\tprivate MutationExecutor executor(SharedSessionContractImplementor session, MutationOperationGroup group, boolean dynamicUpdate) {\n\t\treturn mutationExecutorService\n\t\t\t\t.createExecutor( resolveBatchKeyAccess( dynamicUpdate, session ), group, session );\n\t}\n\n\tprotected static TableInclusionChecker getTableInclusionChecker(InsertValuesAnalysis insertValuesAnalysis) {\n\t\treturn tableMapping -> !tableMapping.isOptional() || insertValuesAnalysis.hasNonNullBindings( tableMapping );\n\t}\n\n\n\t/**\n\t * Transform the array of property indexes to an array of booleans,\n\t * true when the property is insertable and non-null\n\t */\n\tpublic boolean[] getPropertiesToInsert(Object[] fields) {\n\t\tboolean[] notNull = new boolean[fields.length];\n\t\tboolean[] insertable = entityPersister().getPropertyInsertability();\n\t\tfor ( int i = 0; i < fields.length; i++ ) {\n\t\t\tnotNull[i] = insertable[i] && fields[i] != null;\n\t\t}\n\t\treturn notNull;\n\t}\n\n\tprotected MutationOperationGroup generateDynamicInsertSqlGroup(\n\t\t\tboolean[] insertable,\n\t\t\tObject object,\n\t\t\tSharedSessionContractImplementor session,\n\t\t\tboolean forceIdentifierBinding) {\n\t\tfinal MutationGroupBuilder insertGroupBuilder = new MutationGroupBuilder( MutationType.INSERT, entityPersister() );\n\t\tentityPersister().forEachMutableTable(\n\t\t\t\t(tableMapping) -> insertGroupBuilder.addTableDetailsBuilder( createTableInsertBuilder( tableMapping, forceIdentifierBinding ) )\n\t\t);\n\t\tapplyTableInsertDetails( insertGroupBuilder, insertable, object, session, forceIdentifierBinding );\n\t\treturn createOperationGroup( null, insertGroupBuilder.buildMutationGroup() );\n\t}\n\n\tpublic MutationOperationGroup generateStaticOperationGroup() {\n\t\tfinal MutationGroupBuilder insertGroupBuilder = new MutationGroupBuilder( MutationType.INSERT, entityPersister() );\n\t\tentityPersister().forEachMutableTable(\n\t\t\t\t(tableMapping) -> insertGroupBuilder.addTableDetailsBuilder( createTableInsertBuilder( tableMapping, false ) )\n\t\t);\n\t\tapplyTableInsertDetails( insertGroupBuilder, entityPersister().getPropertyInsertability(), null, null, false );\n\t\treturn createOperationGroup( null, insertGroupBuilder.buildMutationGroup() );\n\t}\n\n\tprivate TableMutationBuilder<?> createTableInsertBuilder(EntityTableMapping tableMapping, boolean forceIdentifierBinding) {\n\t\tfinal GeneratedValuesMutationDelegate delegate = entityPersister().getInsertDelegate();\n\t\tif ( tableMapping.isIdentifierTable() && delegate != null && !forceIdentifierBinding ) {\n\t\t\treturn delegate.createTableMutationBuilder( tableMapping.getInsertExpectation(), factory() );\n\t\t}\n\t\telse {\n\t\t\treturn new TableInsertBuilderStandard( entityPersister(), tableMapping, factory() );\n\t\t}\n\t}\n\n\tprivate void applyTableInsertDetails(\n\t\t\tMutationGroupBuilder insertGroupBuilder,\n\t\t\tboolean[] attributeInclusions,\n\t\t\tObject object,\n\t\t\tSharedSessionContractImplementor session,\n\t\t\tboolean forceIdentifierBinding) {\n\t\tfinal AttributeMappingsList attributeMappings = entityPersister().getAttributeMappings();\n\n\t\tinsertGroupBuilder.forEachTableMutationBuilder( (builder) -> {\n\t\t\tfinal EntityTableMapping tableMapping = (EntityTableMapping) builder.getMutatingTable().getTableMapping();\n\t\t\tassert !tableMapping.isInverse();\n\n\t\t\t// `attributeIndexes` represents the indexes (relative to `attributeMappings`) of\n\t\t\t// the attributes mapped to the table\n\t\t\tfinal int[] attributeIndexes = tableMapping.getAttributeIndexes();\n\t\t\tfor ( int i = 0; i < attributeIndexes.length; i++ ) {\n\t\t\t\tfinal int attributeIndex = attributeIndexes[ i ];\n\t\t\t\tfinal AttributeMapping attributeMapping = attributeMappings.get( attributeIndex );\n\t\t\t\tif ( attributeInclusions[attributeIndex] ) {\n\t\t\t\t\tattributeMapping.forEachInsertable( insertGroupBuilder );\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tfinal Generator generator = attributeMapping.getGenerator();\n\t\t\t\t\tif ( isValueGenerated( generator ) ) {\n\t\t\t\t\t\tif ( session != null && !generator.generatedOnExecution( object, session ) ) {\n\t\t\t\t\t\t\tattributeInclusions[attributeIndex] = true;\n\t\t\t\t\t\t\tattributeMapping.forEachInsertable( insertGroupBuilder );\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if ( isValueGenerationInSql( generator, factory().getJdbcServices().getDialect() ) ) {\n\t\t\t\t\t\t\thandleValueGeneration( attributeMapping, insertGroupBuilder, (OnExecutionGenerator) generator );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\n\t\t// add the discriminator\n\t\tentityPersister().addDiscriminatorToInsertGroup( insertGroupBuilder );\n\t\tentityPersister().addSoftDeleteToInsertGroup( insertGroupBuilder );\n\n\t\t// add the keys\n\t\tinsertGroupBuilder.forEachTableMutationBuilder( (tableMutationBuilder) -> {\n\t\t\tfinal TableInsertBuilder tableInsertBuilder = (TableInsertBuilder) tableMutationBuilder;\n\t\t\tfinal EntityTableMapping tableMapping = (EntityTableMapping) tableInsertBuilder.getMutatingTable().getTableMapping();\n\t\t\tif ( tableMapping.isIdentifierTable() && entityPersister().isIdentifierAssignedByInsert() && !forceIdentifierBinding ) {\n\t\t\t\tassert entityPersister().getInsertDelegate() != null;\n\t\t\t\tfinal OnExecutionGenerator generator = (OnExecutionGenerator) entityPersister().getGenerator();\n\t\t\t\tif ( generator.referenceColumnsInSql( dialect() ) ) {\n\t\t\t\t\tfinal BasicEntityIdentifierMapping identifierMapping = (BasicEntityIdentifierMapping) entityPersister().getIdentifierMapping();\n\t\t\t\t\tfinal String[] columnValues = generator.getReferencedColumnValues( dialect );\n\t\t\t\t\ttableMapping.getKeyMapping().forEachKeyColumn( (i, column) -> tableInsertBuilder.addKeyColumn(\n\t\t\t\t\t\t\tcolumn.getColumnName(),\n\t\t\t\t\t\t\tcolumnValues[i],\n\t\t\t\t\t\t\tidentifierMapping.getJdbcMapping()\n\t\t\t\t\t) );\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttableMapping.getKeyMapping().forEachKeyColumn( tableInsertBuilder::addKeyColumn );\n\t\t\t}\n\t\t} );\n\t}\n\n\tprivate static boolean isValueGenerated(Generator generator) {\n\t\treturn generator != null\n\t\t\t\t&& generator.generatesOnInsert()\n\t\t\t\t&& generator.generatedOnExecution();\n\t}\n\n\tprivate static boolean isValueGenerationInSql(Generator generator, Dialect dialect) {\n\t\tassert isValueGenerated( generator );\n\t\treturn ( (OnExecutionGenerator) generator ).referenceColumnsInSql(dialect);\n\t}\n\n\t/**\n\t * @deprecated Use {@link #getBatchKey()}\n\t */\n\t@Deprecated\n\tpublic BasicBatchKey getInsertBatchKey() {\n\t\treturn batchKey;\n\t}\n}\n",
        "filePathAfter": "hibernate-core/src/main/java/org/hibernate/persister/entity/mutation/InsertCoordinatorStandard.java",
        "sourceCodeAfterForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n * See the lgpl.txt file in the root directory or http://www.gnu.org/licenses/lgpl-2.1.html.\n */\npackage org.hibernate.persister.entity.mutation;\n\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.hibernate.Internal;\nimport org.hibernate.dialect.Dialect;\nimport org.hibernate.engine.jdbc.batch.internal.BasicBatchKey;\nimport org.hibernate.engine.jdbc.batch.spi.BatchKey;\nimport org.hibernate.engine.jdbc.mutation.JdbcValueBindings;\nimport org.hibernate.engine.jdbc.mutation.MutationExecutor;\nimport org.hibernate.engine.jdbc.mutation.ParameterUsage;\nimport org.hibernate.engine.jdbc.mutation.TableInclusionChecker;\nimport org.hibernate.engine.jdbc.mutation.group.PreparedStatementDetails;\nimport org.hibernate.engine.spi.SessionFactoryImplementor;\nimport org.hibernate.engine.spi.SharedSessionContractImplementor;\nimport org.hibernate.generator.BeforeExecutionGenerator;\nimport org.hibernate.generator.Generator;\nimport org.hibernate.generator.OnExecutionGenerator;\nimport org.hibernate.generator.values.GeneratedValues;\nimport org.hibernate.generator.values.GeneratedValuesMutationDelegate;\nimport org.hibernate.metamodel.mapping.AttributeMapping;\nimport org.hibernate.metamodel.mapping.AttributeMappingsList;\nimport org.hibernate.metamodel.mapping.BasicEntityIdentifierMapping;\nimport org.hibernate.metamodel.mapping.PluralAttributeMapping;\nimport org.hibernate.persister.entity.EntityPersister;\nimport org.hibernate.sql.model.MutationOperation;\nimport org.hibernate.sql.model.MutationOperationGroup;\nimport org.hibernate.sql.model.MutationType;\nimport org.hibernate.sql.model.TableMapping;\nimport org.hibernate.sql.model.ValuesAnalysis;\nimport org.hibernate.sql.model.ast.builder.MutationGroupBuilder;\nimport org.hibernate.sql.model.ast.builder.TableInsertBuilder;\nimport org.hibernate.sql.model.ast.builder.TableInsertBuilderStandard;\nimport org.hibernate.sql.model.ast.builder.TableMutationBuilder;\nimport org.hibernate.tuple.entity.EntityMetamodel;\n\nimport org.checkerframework.checker.nullness.qual.Nullable;\n\nimport static org.hibernate.generator.EventType.INSERT;\n\n/**\n * Coordinates the insertion of an entity.\n *\n * @see #coordinateInsert\n *\n * @author Steve Ebersole\n */\n@Internal\npublic class InsertCoordinatorStandard extends AbstractMutationCoordinator implements InsertCoordinator {\n\tprivate final MutationOperationGroup staticInsertGroup;\n\tprivate final BasicBatchKey batchKey;\n\n\tpublic InsertCoordinatorStandard(EntityPersister entityPersister, SessionFactoryImplementor factory) {\n\t\tsuper( entityPersister, factory );\n\n\t\tif ( entityPersister.isIdentifierAssignedByInsert() || entityPersister.hasInsertGeneratedProperties() ) {\n\t\t\t// disable batching in case of insert generated identifier or properties\n\t\t\tbatchKey = null;\n\t\t}\n\t\telse {\n\t\t\tbatchKey = new BasicBatchKey( entityPersister.getEntityName() + \"#INSERT\" );\n\t\t}\n\n\t\tif ( entityPersister.getEntityMetamodel().isDynamicInsert() ) {\n\t\t\t// the entity specified dynamic-insert - skip generating the\n\t\t\t// static inserts as we will create them every time\n\t\t\tstaticInsertGroup = null;\n\t\t}\n\t\telse {\n\t\t\tstaticInsertGroup = generateStaticOperationGroup();\n\t\t}\n\t}\n\n\t@Override\n\tpublic MutationOperationGroup getStaticMutationOperationGroup() {\n\t\treturn staticInsertGroup;\n\t}\n\n\t@Override\n\tprotected BatchKey getBatchKey() {\n\t\treturn batchKey;\n\t}\n\n\t@Override\n\tpublic @Nullable GeneratedValues insert(Object entity, Object[] values, SharedSessionContractImplementor session) {\n\t\treturn coordinateInsert( null, values, entity, session );\n\t}\n\n\t@Override\n\tpublic @Nullable GeneratedValues insert(\n\t\t\tObject entity,\n\t\t\tObject id,\n\t\t\tObject[] values,\n\t\t\tSharedSessionContractImplementor session) {\n\t\treturn coordinateInsert( id, values, entity, session );\n\t}\n\n\t/**\n\t * Perform the insert(s).\n\t *\n\t * @param id This is the id as known in memory. For post-insert id generation (IDENTITY, etc)\n\t * this will be null.\n\t * @param values The extracted attribute values\n\t * @param entity The entity instance being persisted\n\t * @param session The originating context\n\t *\n\t * @return The {@linkplain GeneratedValues generated values} if any, {@code null} otherwise.\n\t */\n\tpublic GeneratedValues coordinateInsert(\n\t\t\tObject id,\n\t\t\tObject[] values,\n\t\t\tObject entity,\n\t\t\tSharedSessionContractImplementor session) {\n\t\t// apply any pre-insert in-memory value generation\n\t\tfinal boolean needsDynamicInsert = preInsertInMemoryValueGeneration( values, entity, session );\n\n\t\tfinal EntityMetamodel entityMetamodel = entityPersister().getEntityMetamodel();\n\t\tfinal boolean forceIdentifierBinding = entityPersister().getGenerator().generatedOnExecution() && id != null;\n\t\tif ( entityMetamodel.isDynamicInsert() || needsDynamicInsert || forceIdentifierBinding ) {\n\t\t\treturn doDynamicInserts( id, values, entity, session, forceIdentifierBinding );\n\t\t}\n\t\telse {\n\t\t\treturn doStaticInserts( id, values, entity, session );\n\t\t}\n\t}\n\n\tprotected boolean preInsertInMemoryValueGeneration(Object[] values, Object entity, SharedSessionContractImplementor session) {\n\t\tfinal EntityPersister persister = entityPersister();\n\t\tfinal EntityMetamodel entityMetamodel = persister.getEntityMetamodel();\n\t\tboolean foundStateDependentGenerator = false;\n\t\tif ( entityMetamodel.hasPreInsertGeneratedValues() ) {\n\t\t\tfinal Generator[] generators = entityMetamodel.getGenerators();\n\t\t\tfor ( int i = 0; i < generators.length; i++ ) {\n\t\t\t\tfinal Generator generator = generators[i];\n\t\t\t\tif ( generator != null\n\t\t\t\t\t\t&& generator.generatesOnInsert()\n\t\t\t\t\t\t&& !generator.generatedOnExecution( entity, session ) ) {\n\t\t\t\t\tvalues[i] = ( (BeforeExecutionGenerator) generator ).generate( session, entity, values[i], INSERT );\n\t\t\t\t\tpersister.setPropertyValue( entity, i, values[i] );\n\t\t\t\t\tfoundStateDependentGenerator = foundStateDependentGenerator || generator.generatedOnExecution();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn foundStateDependentGenerator;\n\t}\n\n\tpublic static class InsertValuesAnalysis implements ValuesAnalysis {\n\t\tprivate final List<TableMapping> tablesWithNonNullValues = new ArrayList<>();\n\n\t\tpublic InsertValuesAnalysis(EntityMutationTarget mutationTarget, Object[] values) {\n\t\t\tmutationTarget.forEachMutableTable( (tableMapping) -> {\n\t\t\t\tfinal int[] tableAttributeIndexes = tableMapping.getAttributeIndexes();\n\t\t\t\tfor ( int i = 0; i < tableAttributeIndexes.length; i++ ) {\n\t\t\t\t\tif ( values[tableAttributeIndexes[i]] != null ) {\n\t\t\t\t\t\ttablesWithNonNullValues.add( tableMapping );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} );\n\t\t}\n\n\t\tpublic boolean hasNonNullBindings(TableMapping tableMapping) {\n\t\t\treturn tablesWithNonNullValues.contains( tableMapping );\n\t\t}\n\t}\n\n\tprotected GeneratedValues doStaticInserts(Object id, Object[] values, Object object, SharedSessionContractImplementor session) {\n\t\tfinal InsertValuesAnalysis insertValuesAnalysis = new InsertValuesAnalysis( entityPersister(), values );\n\n\t\tfinal TableInclusionChecker tableInclusionChecker = getTableInclusionChecker( insertValuesAnalysis );\n\n\t\tfinal MutationExecutor mutationExecutor = executor( session, staticInsertGroup, false );\n\n\t\tdecomposeForInsert(\n\t\t\t\tmutationExecutor,\n\t\t\t\tid,\n\t\t\t\tvalues,\n\t\t\t\tstaticInsertGroup,\n\t\t\t\tentityPersister().getPropertyInsertability(),\n\t\t\t\ttableInclusionChecker,\n\t\t\t\tsession\n\t\t);\n\n\t\ttry {\n\t\t\treturn mutationExecutor.execute(\n\t\t\t\t\tobject,\n\t\t\t\t\tinsertValuesAnalysis,\n\t\t\t\t\ttableInclusionChecker,\n\t\t\t\t\tInsertCoordinatorStandard::verifyOutcome,\n\t\t\t\t\tsession\n\t\t\t);\n\t\t}\n\t\tfinally {\n\t\t\tmutationExecutor.release();\n\t\t}\n\t}\n\n\tprotected void decomposeForInsert(\n\t\t\tMutationExecutor mutationExecutor,\n\t\t\tObject id,\n\t\t\tObject[] values,\n\t\t\tMutationOperationGroup mutationGroup,\n\t\t\tboolean[] propertyInclusions,\n\t\t\tTableInclusionChecker tableInclusionChecker,\n\t\t\tSharedSessionContractImplementor session) {\n\t\tfinal JdbcValueBindings jdbcValueBindings = mutationExecutor.getJdbcValueBindings();\n\t\tfinal AttributeMappingsList attributeMappings = entityPersister().getAttributeMappings();\n\n\t\tfor ( int position = 0; position < mutationGroup.getNumberOfOperations(); position++ ) {\n\t\t\tfinal MutationOperation operation = mutationGroup.getOperation( position );\n\t\t\tfinal EntityTableMapping tableDetails = (EntityTableMapping) operation.getTableDetails();\n\t\t\tif ( tableInclusionChecker.include( tableDetails ) ) {\n\t\t\t\tfinal int[] attributeIndexes = tableDetails.getAttributeIndexes();\n\t\t\t\tfor ( int i = 0; i < attributeIndexes.length; i++ ) {\n\t\t\t\t\tfinal int attributeIndex = attributeIndexes[ i ];\n\t\t\t\t\tif ( propertyInclusions[attributeIndex] ) {\n\t\t\t\t\t\tfinal AttributeMapping mapping = attributeMappings.get( attributeIndex );\n\t\t\t\t\t\tdecomposeAttribute( values[attributeIndex], session, jdbcValueBindings, mapping );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ( id == null ) {\n\t\t\tassert entityPersister().getInsertDelegate() != null;\n\t\t}\n\t\telse {\n\t\t\tfor ( int position = 0; position < mutationGroup.getNumberOfOperations(); position++ ) {\n\t\t\t\tfinal MutationOperation jdbcOperation = mutationGroup.getOperation( position );\n\t\t\t\tfinal EntityTableMapping tableDetails = (EntityTableMapping) jdbcOperation.getTableDetails();\n\t\t\t\tbreakDownJdbcValue( id, session, jdbcValueBindings, tableDetails );\n\t\t\t}\n\t\t}\n\t}\n\n\tprotected void breakDownJdbcValue(\n\t\t\tObject id,\n\t\t\tSharedSessionContractImplementor session,\n\t\t\tJdbcValueBindings jdbcValueBindings,\n\t\t\tEntityTableMapping tableDetails) {\n\t\tfinal String tableName = tableDetails.getTableName();\n\t\ttableDetails.getKeyMapping().breakDownKeyJdbcValues(\n\t\t\t\tid,\n\t\t\t\t(jdbcValue, columnMapping) -> {\n\t\t\t\t\tjdbcValueBindings.bindValue(\n\t\t\t\t\t\t\tjdbcValue,\n\t\t\t\t\t\t\ttableName,\n\t\t\t\t\t\t\tcolumnMapping.getColumnName(),\n\t\t\t\t\t\t\tParameterUsage.SET\n\t\t\t\t\t);\n\t\t\t\t},\n\t\t\t\tsession\n\t\t);\n\t}\n\n\tprotected void decomposeAttribute(\n\t\t\tObject value,\n\t\t\tSharedSessionContractImplementor session,\n\t\t\tJdbcValueBindings jdbcValueBindings,\n\t\t\tAttributeMapping mapping) {\n\t\tif ( !(mapping instanceof PluralAttributeMapping) ) {\n\t\t\tmapping.decompose(\n\t\t\t\t\tvalue,\n\t\t\t\t\t0,\n\t\t\t\t\tjdbcValueBindings,\n\t\t\t\t\tnull,\n\t\t\t\t\t(valueIndex, bindings, noop, jdbcValue, selectableMapping) -> {\n\t\t\t\t\t\tif ( selectableMapping.isInsertable() ) {\n\t\t\t\t\t\t\tbindings.bindValue(\n\t\t\t\t\t\t\t\t\tjdbcValue,\n\t\t\t\t\t\t\t\t\tentityPersister().physicalTableNameForMutation( selectableMapping ),\n\t\t\t\t\t\t\t\t\tselectableMapping.getSelectionExpression(),\n\t\t\t\t\t\t\t\t\tParameterUsage.SET\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tsession\n\t\t\t);\n\t\t}\n\t}\n\n\tprotected GeneratedValues doDynamicInserts(\n\t\t\tObject id,\n\t\t\tObject[] values,\n\t\t\tObject object,\n\t\t\tSharedSessionContractImplementor session,\n\t\t\tboolean forceIdentifierBinding) {\n\t\tfinal boolean[] insertability = getPropertiesToInsert( values );\n\t\tfinal MutationOperationGroup insertGroup =\n\t\t\t\tgenerateDynamicInsertSqlGroup( insertability, object, session, forceIdentifierBinding );\n\n\t\tfinal MutationExecutor mutationExecutor = executor( session, insertGroup, true );\n\n\t\tfinal InsertValuesAnalysis insertValuesAnalysis = new InsertValuesAnalysis( entityPersister(), values );\n\n\t\tfinal TableInclusionChecker tableInclusionChecker = getTableInclusionChecker( insertValuesAnalysis );\n\n\t\tdecomposeForInsert( mutationExecutor, id, values, insertGroup, insertability, tableInclusionChecker, session );\n\n\t\ttry {\n\t\t\treturn mutationExecutor.execute(\n\t\t\t\t\tobject,\n\t\t\t\t\tinsertValuesAnalysis,\n\t\t\t\t\ttableInclusionChecker,\n\t\t\t\t\tInsertCoordinatorStandard::verifyOutcome,\n\t\t\t\t\tsession\n\t\t\t);\n\t\t}\n\t\tfinally {\n\t\t\tmutationExecutor.release();\n\t\t}\n\t}\n\n\tprivate static boolean verifyOutcome(PreparedStatementDetails statementDetails, int affectedRowCount, int batchPosition)\n\t\t\tthrows SQLException {\n\t\tstatementDetails.getExpectation().verifyOutcome(\n\t\t\t\taffectedRowCount,\n\t\t\t\tstatementDetails.getStatement(),\n\t\t\t\tbatchPosition,\n\t\t\t\tstatementDetails.getSqlString()\n\t\t);\n\t\treturn true;\n\t}\n\n\tprivate MutationExecutor executor(SharedSessionContractImplementor session, MutationOperationGroup group, boolean dynamicUpdate) {\n\t\treturn mutationExecutorService\n\t\t\t\t.createExecutor( resolveBatchKeyAccess( dynamicUpdate, session ), group, session );\n\t}\n\n\tprotected static TableInclusionChecker getTableInclusionChecker(InsertValuesAnalysis insertValuesAnalysis) {\n\t\treturn tableMapping -> !tableMapping.isOptional() || insertValuesAnalysis.hasNonNullBindings( tableMapping );\n\t}\n\n\n\t/**\n\t * Transform the array of property indexes to an array of booleans,\n\t * true when the property is insertable and non-null\n\t */\n\tpublic boolean[] getPropertiesToInsert(Object[] fields) {\n\t\tboolean[] notNull = new boolean[fields.length];\n\t\tboolean[] insertable = entityPersister().getPropertyInsertability();\n\t\tfor ( int i = 0; i < fields.length; i++ ) {\n\t\t\tnotNull[i] = insertable[i] && fields[i] != null;\n\t\t}\n\t\treturn notNull;\n\t}\n\n\tprotected MutationOperationGroup generateDynamicInsertSqlGroup(\n\t\t\tboolean[] insertable,\n\t\t\tObject object,\n\t\t\tSharedSessionContractImplementor session,\n\t\t\tboolean forceIdentifierBinding) {\n\t\tfinal MutationGroupBuilder insertGroupBuilder = new MutationGroupBuilder( MutationType.INSERT, entityPersister() );\n\t\tentityPersister().forEachMutableTable(\n\t\t\t\t(tableMapping) -> insertGroupBuilder.addTableDetailsBuilder( createTableInsertBuilder( tableMapping, forceIdentifierBinding ) )\n\t\t);\n\t\tapplyTableInsertDetails( insertGroupBuilder, insertable, object, session, forceIdentifierBinding );\n\t\treturn createOperationGroup( null, insertGroupBuilder.buildMutationGroup() );\n\t}\n\n\tpublic MutationOperationGroup generateStaticOperationGroup() {\n\t\tfinal MutationGroupBuilder insertGroupBuilder = new MutationGroupBuilder( MutationType.INSERT, entityPersister() );\n\t\tentityPersister().forEachMutableTable(\n\t\t\t\t(tableMapping) -> insertGroupBuilder.addTableDetailsBuilder( createTableInsertBuilder( tableMapping, false ) )\n\t\t);\n\t\tapplyTableInsertDetails( insertGroupBuilder, entityPersister().getPropertyInsertability(), null, null, false );\n\t\treturn createOperationGroup( null, insertGroupBuilder.buildMutationGroup() );\n\t}\n\n\tprivate TableMutationBuilder<?> createTableInsertBuilder(EntityTableMapping tableMapping, boolean forceIdentifierBinding) {\n\t\tfinal GeneratedValuesMutationDelegate delegate = entityPersister().getInsertDelegate();\n\t\tif ( tableMapping.isIdentifierTable() && delegate != null && !forceIdentifierBinding ) {\n\t\t\treturn delegate.createTableMutationBuilder( tableMapping.getInsertExpectation(), factory() );\n\t\t}\n\t\telse {\n\t\t\treturn new TableInsertBuilderStandard( entityPersister(), tableMapping, factory() );\n\t\t}\n\t}\n\n\tprivate void applyTableInsertDetails(\n\t\t\tMutationGroupBuilder insertGroupBuilder,\n\t\t\tboolean[] attributeInclusions,\n\t\t\tObject object,\n\t\t\tSharedSessionContractImplementor session,\n\t\t\tboolean forceIdentifierBinding) {\n\t\tfinal AttributeMappingsList attributeMappings = entityPersister().getAttributeMappings();\n\n\t\tinsertGroupBuilder.forEachTableMutationBuilder( (builder) -> {\n\t\t\tfinal EntityTableMapping tableMapping = (EntityTableMapping) builder.getMutatingTable().getTableMapping();\n\t\t\tassert !tableMapping.isInverse();\n\n\t\t\t// `attributeIndexes` represents the indexes (relative to `attributeMappings`) of\n\t\t\t// the attributes mapped to the table\n\t\t\tfinal int[] attributeIndexes = tableMapping.getAttributeIndexes();\n\t\t\tfor ( int i = 0; i < attributeIndexes.length; i++ ) {\n\t\t\t\tfinal int attributeIndex = attributeIndexes[ i ];\n\t\t\t\tfinal AttributeMapping attributeMapping = attributeMappings.get( attributeIndex );\n\t\t\t\tif ( attributeInclusions[attributeIndex] ) {\n\t\t\t\t\tattributeMapping.forEachInsertable( insertGroupBuilder );\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tfinal Generator generator = attributeMapping.getGenerator();\n\t\t\t\t\tif ( isValueGenerated( generator ) ) {\n\t\t\t\t\t\tif ( session != null && !generator.generatedOnExecution( object, session ) ) {\n\t\t\t\t\t\t\tattributeInclusions[attributeIndex] = true;\n\t\t\t\t\t\t\tattributeMapping.forEachInsertable( insertGroupBuilder );\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if ( isValueGenerationInSql( generator, factory.getJdbcServices().getDialect() ) ) {\n\t\t\t\t\t\t\thandleValueGeneration( attributeMapping, insertGroupBuilder, (OnExecutionGenerator) generator );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\n\t\t// add the discriminator\n\t\tentityPersister().addDiscriminatorToInsertGroup( insertGroupBuilder );\n\t\tentityPersister().addSoftDeleteToInsertGroup( insertGroupBuilder );\n\n\t\t// add the keys\n\t\tinsertGroupBuilder.forEachTableMutationBuilder( (tableMutationBuilder) -> {\n\t\t\tfinal TableInsertBuilder tableInsertBuilder = (TableInsertBuilder) tableMutationBuilder;\n\t\t\tfinal EntityTableMapping tableMapping = (EntityTableMapping) tableInsertBuilder.getMutatingTable().getTableMapping();\n\t\t\tif ( tableMapping.isIdentifierTable() && entityPersister().isIdentifierAssignedByInsert() && !forceIdentifierBinding ) {\n\t\t\t\tassert entityPersister().getInsertDelegate() != null;\n\t\t\t\tfinal OnExecutionGenerator generator = (OnExecutionGenerator) entityPersister().getGenerator();\n\t\t\t\tif ( generator.referenceColumnsInSql( dialect() ) ) {\n\t\t\t\t\tfinal BasicEntityIdentifierMapping identifierMapping = (BasicEntityIdentifierMapping) entityPersister().getIdentifierMapping();\n\t\t\t\t\tfinal String[] columnValues = generator.getReferencedColumnValues( dialect );\n\t\t\t\t\ttableMapping.getKeyMapping().forEachKeyColumn( (i, column) -> tableInsertBuilder.addKeyColumn(\n\t\t\t\t\t\t\tcolumn.getColumnName(),\n\t\t\t\t\t\t\tcolumnValues[i],\n\t\t\t\t\t\t\tidentifierMapping.getJdbcMapping()\n\t\t\t\t\t) );\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttableMapping.getKeyMapping().forEachKeyColumn( tableInsertBuilder::addKeyColumn );\n\t\t\t}\n\t\t} );\n\t}\n\n\tprivate static boolean isValueGenerated(Generator generator) {\n\t\treturn generator != null\n\t\t\t\t&& generator.generatesOnInsert()\n\t\t\t\t&& generator.generatedOnExecution();\n\t}\n\n\tprivate static boolean isValueGenerationInSql(Generator generator, Dialect dialect) {\n\t\tassert isValueGenerated( generator );\n\t\treturn ( (OnExecutionGenerator) generator ).referenceColumnsInSql(dialect);\n\t}\n\n\t/**\n\t * @deprecated Use {@link #getBatchKey()}\n\t */\n\t@Deprecated\n\tpublic BasicBatchKey getInsertBatchKey() {\n\t\treturn batchKey;\n\t}\n}\n",
        "diffSourceCodeSet": [
            "private static boolean verifyOutcome(PreparedStatementDetails statementDetails, int affectedRowCount, int batchPosition)\n\t\t\tthrows SQLException {\n\t\tstatementDetails.getExpectation().verifyOutcome(\n\t\t\t\taffectedRowCount,\n\t\t\t\tstatementDetails.getStatement(),\n\t\t\t\tbatchPosition,\n\t\t\t\tstatementDetails.getSqlString()\n\t\t);\n\t\treturn true;\n\t}"
        ],
        "invokedMethodSet": [
            "methodSignature: org.hibernate.persister.entity.mutation.InsertCoordinatorStandard#getPropertiesToInsert\n methodBody: public boolean[] getPropertiesToInsert(Object[] fields) {\nboolean[] notNull=new boolean[fields.length];\nboolean[] insertable=entityPersister().getPropertyInsertability();\nfor(int i=0; i < fields.length; i++){notNull[i]=insertable[i] && fields[i] != null;\n}return notNull;\n}",
            "methodSignature: org.hibernate.persister.entity.mutation.InsertCoordinatorStandard#decomposeForInsert\n methodBody: protected void decomposeForInsert(\n\t\t\tMutationExecutor mutationExecutor,\n\t\t\tObject id,\n\t\t\tObject[] values,\n\t\t\tMutationOperationGroup mutationGroup,\n\t\t\tboolean[] propertyInclusions,\n\t\t\tTableInclusionChecker tableInclusionChecker,\n\t\t\tSharedSessionContractImplementor session) {\nfinal JdbcValueBindings jdbcValueBindings=mutationExecutor.getJdbcValueBindings();\nfinal AttributeMappingsList attributeMappings=entityPersister().getAttributeMappings();\nfor(int position=0; position < mutationGroup.getNumberOfOperations(); position++){final MutationOperation operation=mutationGroup.getOperation(position);\nfinal EntityTableMapping tableDetails=(EntityTableMapping)operation.getTableDetails();\nif(tableInclusionChecker.include(tableDetails)){final int[] attributeIndexes=tableDetails.getAttributeIndexes();\nfor(int i=0; i < attributeIndexes.length; i++){final int attributeIndex=attributeIndexes[i];\nif(propertyInclusions[attributeIndex]){final AttributeMapping mapping=attributeMappings.get(attributeIndex);\ndecomposeAttribute(values[attributeIndex],session,jdbcValueBindings,mapping);\n}}}}if(id == null){assert entityPersister().getInsertDelegate() != null;\n}{for(int position=0; position < mutationGroup.getNumberOfOperations(); position++){final MutationOperation jdbcOperation=mutationGroup.getOperation(position);\nfinal EntityTableMapping tableDetails=(EntityTableMapping)jdbcOperation.getTableDetails();\nbreakDownJdbcValue(id,session,jdbcValueBindings,tableDetails);\n}}}",
            "methodSignature: org.hibernate.engine.jdbc.mutation.internal.MutationExecutorStandard#release\n methodBody: public void release() {\nnonBatchedStatementGroup.release();\n}",
            "methodSignature: org.hibernate.persister.entity.mutation.InsertCoordinatorStandard#getTableInclusionChecker\n methodBody: protected static TableInclusionChecker getTableInclusionChecker(InsertValuesAnalysis insertValuesAnalysis) {\nreturn tableMapping -> !tableMapping.isOptional() || insertValuesAnalysis.hasNonNullBindings(tableMapping);\n}",
            "methodSignature: org.hibernate.engine.jdbc.mutation.internal.AbstractMutationExecutor#execute\n methodBody: public final GeneratedValues execute(\n\t\t\tObject modelReference,\n\t\t\tValuesAnalysis valuesAnalysis,\n\t\t\tTableInclusionChecker inclusionChecker,\n\t\t\tOperationResultChecker resultChecker,\n\t\t\tSharedSessionContractImplementor session) {\nfinal GeneratedValues generatedValues=performNonBatchedOperations(modelReference,valuesAnalysis,inclusionChecker,resultChecker,session);\nperformSelfExecutingOperations(valuesAnalysis,inclusionChecker,session);\nperformBatchedOperations(valuesAnalysis,inclusionChecker);\nreturn generatedValues;\n}",
            "methodSignature: org.hibernate.orm.test.jpa.transaction.batch.AbstractBatchingTest.BatchWrapper#execute\n methodBody: public void execute() {\nwrapped.execute();\n}",
            "methodSignature: org.hibernate.engine.jdbc.batch.spi.Batch#execute\n methodBody: void execute();",
            "methodSignature: org.hibernate.orm.test.jpa.transaction.batch.AbstractBatchingTest.BatchWrapper#release\n methodBody: public void release() {\nwasReleaseCalled=true;\nwrapped.release();\nnumberOfStatementsAfterRelease=wrapped.getStatementGroup().getNumberOfActiveStatements();\n}",
            "methodSignature: org.hibernate.persister.entity.mutation.AbstractDeleteCoordinator#executor\n methodBody: private MutationExecutor executor(SharedSessionContractImplementor session, MutationOperationGroup group) {\nreturn mutationExecutorService.createExecutor(resolveBatchKeyAccess(false,session),group,session);\n}",
            "methodSignature: org.hibernate.engine.jdbc.batch.internal.BatchImpl#execute\n methodBody: public void execute() {\nnotifyObserversExplicitExecution();\nif(getStatementGroup().getNumberOfStatements() == 0){return;\n}tryif(batchPosition == 0){if(!batchExecuted){if(BATCH_LOGGER.isDebugEnabled()){BATCH_LOGGER.debugf(\"No batched statements to execute - %s\",getKey().toLoggableString());\n}}}{performExecution();\n}finallyreleaseStatements();\n}",
            "methodSignature: org.hibernate.engine.jdbc.batch.spi.Batch#release\n methodBody: void release();",
            "methodSignature: org.hibernate.persister.entity.mutation.InsertCoordinatorStandard#generateDynamicInsertSqlGroup\n methodBody: protected MutationOperationGroup generateDynamicInsertSqlGroup(\n\t\t\tboolean[] insertable,\n\t\t\tObject object,\n\t\t\tSharedSessionContractImplementor session,\n\t\t\tboolean forceIdentifierBinding) {\nfinal MutationGroupBuilder insertGroupBuilder=new MutationGroupBuilder(MutationType.INSERT,entityPersister());\nentityPersister().forEachMutableTable((tableMapping) -> insertGroupBuilder.addTableDetailsBuilder(createTableInsertBuilder(tableMapping,forceIdentifierBinding)));\napplyTableInsertDetails(insertGroupBuilder,insertable,object,session,forceIdentifierBinding);\nreturn createOperationGroup(null,insertGroupBuilder.buildMutationGroup());\n}",
            "methodSignature: org.hibernate.engine.jdbc.mutation.internal.MutationExecutorSingleBatched#release\n methodBody: public void release() {\n}",
            "methodSignature: org.hibernate.engine.jdbc.mutation.MutationExecutor#release\n methodBody: void release();",
            "methodSignature: org.hibernate.persister.entity.mutation.UpdateCoordinatorStandard#executor\n methodBody: private MutationExecutor executor(SharedSessionContractImplementor session, MutationOperationGroup group, boolean dynamicUpdate) {\nreturn mutationExecutorService.createExecutor(resolveBatchKeyAccess(dynamicUpdate,session),group,session);\n}",
            "methodSignature: org.hibernate.engine.jdbc.batch.internal.BatchImpl#release\n methodBody: public void release() {\nif(BATCH_MESSAGE_LOGGER.isInfoEnabled()){final PreparedStatementGroup statementGroup=getStatementGroup();\nif(statementGroup.getNumberOfStatements() != 0){if(statementGroup.hasMatching((statementDetails) -> statementDetails.getStatement() != null)){BATCH_MESSAGE_LOGGER.batchContainedStatementsOnRelease();\n}}}releaseStatements();\nobservers.clear();\n}",
            "methodSignature: org.hibernate.persister.entity.mutation.AbstractMutationCoordinator#entityPersister\n methodBody: protected EntityPersister entityPersister() {\nreturn entityPersister;\n}",
            "methodSignature: org.hibernate.engine.jdbc.mutation.MutationExecutor#execute\n methodBody: GeneratedValues execute(\n\t\t\tObject modelReference,\n\t\t\tValuesAnalysis valuesAnalysis,\n\t\t\tTableInclusionChecker inclusionChecker,\n\t\t\tOperationResultChecker resultChecker,\n\t\t\tSharedSessionContractImplementor session);",
            "methodSignature: org.hibernate.persister.entity.mutation.InsertCoordinatorStandard#executor\n methodBody: private MutationExecutor executor(SharedSessionContractImplementor session, MutationOperationGroup group, boolean dynamicUpdate) {\nreturn mutationExecutorService.createExecutor(resolveBatchKeyAccess(dynamicUpdate,session),group,session);\n}"
        ],
        "sourceCodeAfterRefactoring": "protected GeneratedValues doDynamicInserts(\n\t\t\tObject id,\n\t\t\tObject[] values,\n\t\t\tObject object,\n\t\t\tSharedSessionContractImplementor session,\n\t\t\tboolean forceIdentifierBinding) {\n\t\tfinal boolean[] insertability = getPropertiesToInsert( values );\n\t\tfinal MutationOperationGroup insertGroup =\n\t\t\t\tgenerateDynamicInsertSqlGroup( insertability, object, session, forceIdentifierBinding );\n\n\t\tfinal MutationExecutor mutationExecutor = executor( session, insertGroup, true );\n\n\t\tfinal InsertValuesAnalysis insertValuesAnalysis = new InsertValuesAnalysis( entityPersister(), values );\n\n\t\tfinal TableInclusionChecker tableInclusionChecker = getTableInclusionChecker( insertValuesAnalysis );\n\n\t\tdecomposeForInsert( mutationExecutor, id, values, insertGroup, insertability, tableInclusionChecker, session );\n\n\t\ttry {\n\t\t\treturn mutationExecutor.execute(\n\t\t\t\t\tobject,\n\t\t\t\t\tinsertValuesAnalysis,\n\t\t\t\t\ttableInclusionChecker,\n\t\t\t\t\tInsertCoordinatorStandard::verifyOutcome,\n\t\t\t\t\tsession\n\t\t\t);\n\t\t}\n\t\tfinally {\n\t\t\tmutationExecutor.release();\n\t\t}\n\t}\nprivate static boolean verifyOutcome(PreparedStatementDetails statementDetails, int affectedRowCount, int batchPosition)\n\t\t\tthrows SQLException {\n\t\tstatementDetails.getExpectation().verifyOutcome(\n\t\t\t\taffectedRowCount,\n\t\t\t\tstatementDetails.getStatement(),\n\t\t\t\tbatchPosition,\n\t\t\t\tstatementDetails.getSqlString()\n\t\t);\n\t\treturn true;\n\t}",
        "diffSourceCode": "-  290: \t\t\t\t\t},\n-  291: \t\t\t\t\tsession\n-  292: \t\t\t);\n-  293: \t\t}\n-  294: \t}\n-  295: \n-  296: \tprotected GeneratedValues doDynamicInserts(\n-  297: \t\t\tObject id,\n-  298: \t\t\tObject[] values,\n-  299: \t\t\tObject object,\n-  300: \t\t\tSharedSessionContractImplementor session,\n-  301: \t\t\tboolean forceIdentifierBinding) {\n-  302: \t\tfinal boolean[] insertability = getPropertiesToInsert( values );\n-  303: \t\tfinal MutationOperationGroup insertGroup = generateDynamicInsertSqlGroup( insertability, object, session, forceIdentifierBinding );\n-  304: \n-  305: \t\tfinal MutationExecutor mutationExecutor = executor( session, insertGroup, true );\n-  306: \n-  307: \t\tfinal InsertValuesAnalysis insertValuesAnalysis = new InsertValuesAnalysis( entityPersister(), values );\n-  308: \n-  309: \t\tfinal TableInclusionChecker tableInclusionChecker = getTableInclusionChecker( insertValuesAnalysis );\n-  310: \n-  311: \t\tdecomposeForInsert( mutationExecutor, id, values, insertGroup, insertability, tableInclusionChecker, session );\n-  312: \n-  313: \t\ttry {\n-  314: \t\t\treturn mutationExecutor.execute(\n-  315: \t\t\t\t\tobject,\n-  316: \t\t\t\t\tinsertValuesAnalysis,\n-  317: \t\t\t\t\ttableInclusionChecker,\n-  318: \t\t\t\t\t(statementDetails, affectedRowCount, batchPosition) -> {\n-  319: \t\t\t\t\t\tstatementDetails.getExpectation().verifyOutcome(\n-  320: \t\t\t\t\t\t\t\taffectedRowCount,\n-  321: \t\t\t\t\t\t\t\tstatementDetails.getStatement(),\n-  322: \t\t\t\t\t\t\t\tbatchPosition,\n-  323: \t\t\t\t\t\t\t\tstatementDetails.getSqlString()\n-  324: \t\t\t\t\t\t);\n-  325: \t\t\t\t\t\treturn true;\n-  326: \t\t\t\t\t},\n-  327: \t\t\t\t\tsession\n-  328: \t\t\t);\n-  329: \t\t}\n-  330: \t\tfinally {\n-  331: \t\t\tmutationExecutor.release();\n-  332: \t\t}\n-  333: \t}\n+  290: \tprotected GeneratedValues doDynamicInserts(\n+  291: \t\t\tObject id,\n+  292: \t\t\tObject[] values,\n+  293: \t\t\tObject object,\n+  294: \t\t\tSharedSessionContractImplementor session,\n+  295: \t\t\tboolean forceIdentifierBinding) {\n+  296: \t\tfinal boolean[] insertability = getPropertiesToInsert( values );\n+  297: \t\tfinal MutationOperationGroup insertGroup =\n+  298: \t\t\t\tgenerateDynamicInsertSqlGroup( insertability, object, session, forceIdentifierBinding );\n+  299: \n+  300: \t\tfinal MutationExecutor mutationExecutor = executor( session, insertGroup, true );\n+  301: \n+  302: \t\tfinal InsertValuesAnalysis insertValuesAnalysis = new InsertValuesAnalysis( entityPersister(), values );\n+  303: \n+  304: \t\tfinal TableInclusionChecker tableInclusionChecker = getTableInclusionChecker( insertValuesAnalysis );\n+  305: \n+  306: \t\tdecomposeForInsert( mutationExecutor, id, values, insertGroup, insertability, tableInclusionChecker, session );\n+  307: \n+  308: \t\ttry {\n+  309: \t\t\treturn mutationExecutor.execute(\n+  310: \t\t\t\t\tobject,\n+  311: \t\t\t\t\tinsertValuesAnalysis,\n+  312: \t\t\t\t\ttableInclusionChecker,\n+  313: \t\t\t\t\tInsertCoordinatorStandard::verifyOutcome,\n+  314: \t\t\t\t\tsession\n+  315: \t\t\t);\n+  316: \t\t}\n+  317: \t\tfinally {\n+  318: \t\t\tmutationExecutor.release();\n+  319: \t\t}\n+  320: \t}\n+  321: \n+  322: \tprivate static boolean verifyOutcome(PreparedStatementDetails statementDetails, int affectedRowCount, int batchPosition)\n+  323: \t\t\tthrows SQLException {\n+  324: \t\tstatementDetails.getExpectation().verifyOutcome(\n+  325: \t\t\t\taffectedRowCount,\n+  326: \t\t\t\tstatementDetails.getStatement(),\n+  327: \t\t\t\tbatchPosition,\n+  328: \t\t\t\tstatementDetails.getSqlString()\n+  329: \t\t);\n+  330: \t\treturn true;\n+  331: \t}\n+  332: \n+  333: \tprivate MutationExecutor executor(SharedSessionContractImplementor session, MutationOperationGroup group, boolean dynamicUpdate) {\n",
        "uniqueId": "ee00217733018075ccade7e1145f45ff9acae0c2_296_333_322_331_290_320",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 0,
                "covered": 48
            },
            "LINE": {
                "missed": 0,
                "covered": 8
            },
            "COMPLEXITY": {
                "missed": 0,
                "covered": 1
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 21
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprivate verifyOutcome(statementDetails PreparedStatementDetails, affectedRowCount int, batchPosition int) : boolean extracted from protected doStaticInserts(id Object, values Object[], object Object, session SharedSessionContractImplementor) : GeneratedValues in class org.hibernate.persister.entity.mutation.InsertCoordinatorStandard",
        "diffLocations": [
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/persister/entity/mutation/InsertCoordinatorStandard.java",
                "startLine": 173,
                "endLine": 210,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/persister/entity/mutation/InsertCoordinatorStandard.java",
                "startLine": 175,
                "endLine": 204,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/persister/entity/mutation/InsertCoordinatorStandard.java",
                "startLine": 322,
                "endLine": 331,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "protected GeneratedValues doStaticInserts(Object id, Object[] values, Object object, SharedSessionContractImplementor session) {\n\t\tfinal InsertValuesAnalysis insertValuesAnalysis = new InsertValuesAnalysis( entityPersister(), values );\n\n\t\tfinal TableInclusionChecker tableInclusionChecker = getTableInclusionChecker( insertValuesAnalysis );\n\n\t\tfinal MutationExecutor mutationExecutor = executor( session, staticInsertGroup, false );\n\n\t\tdecomposeForInsert(\n\t\t\t\tmutationExecutor,\n\t\t\t\tid,\n\t\t\t\tvalues,\n\t\t\t\tstaticInsertGroup,\n\t\t\t\tentityPersister().getPropertyInsertability(),\n\t\t\t\ttableInclusionChecker,\n\t\t\t\tsession\n\t\t);\n\n\t\ttry {\n\t\t\treturn mutationExecutor.execute(\n\t\t\t\t\tobject,\n\t\t\t\t\tinsertValuesAnalysis,\n\t\t\t\t\ttableInclusionChecker,\n\t\t\t\t\t(statementDetails, affectedRowCount, batchPosition) -> {\n\t\t\t\t\t\tstatementDetails.getExpectation().verifyOutcome(\n\t\t\t\t\t\t\t\taffectedRowCount,\n\t\t\t\t\t\t\t\tstatementDetails.getStatement(),\n\t\t\t\t\t\t\t\tbatchPosition,\n\t\t\t\t\t\t\t\tstatementDetails.getSqlString()\n\t\t\t\t\t\t);\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t},\n\t\t\t\t\tsession\n\t\t\t);\n\t\t}\n\t\tfinally {\n\t\t\tmutationExecutor.release();\n\t\t}\n\t}",
        "filePathBefore": "hibernate-core/src/main/java/org/hibernate/persister/entity/mutation/InsertCoordinatorStandard.java",
        "isPureRefactoring": true,
        "commitId": "ee00217733018075ccade7e1145f45ff9acae0c2",
        "packageNameBefore": "org.hibernate.persister.entity.mutation",
        "classNameBefore": "org.hibernate.persister.entity.mutation.InsertCoordinatorStandard",
        "methodNameBefore": "org.hibernate.persister.entity.mutation.InsertCoordinatorStandard#doStaticInserts",
        "invokedMethod": "methodSignature: org.hibernate.persister.entity.mutation.InsertCoordinatorStandard#decomposeForInsert\n methodBody: protected void decomposeForInsert(\n\t\t\tMutationExecutor mutationExecutor,\n\t\t\tObject id,\n\t\t\tObject[] values,\n\t\t\tMutationOperationGroup mutationGroup,\n\t\t\tboolean[] propertyInclusions,\n\t\t\tTableInclusionChecker tableInclusionChecker,\n\t\t\tSharedSessionContractImplementor session) {\nfinal JdbcValueBindings jdbcValueBindings=mutationExecutor.getJdbcValueBindings();\nfinal AttributeMappingsList attributeMappings=entityPersister().getAttributeMappings();\nfor(int position=0; position < mutationGroup.getNumberOfOperations(); position++){final MutationOperation operation=mutationGroup.getOperation(position);\nfinal EntityTableMapping tableDetails=(EntityTableMapping)operation.getTableDetails();\nif(tableInclusionChecker.include(tableDetails)){final int[] attributeIndexes=tableDetails.getAttributeIndexes();\nfor(int i=0; i < attributeIndexes.length; i++){final int attributeIndex=attributeIndexes[i];\nif(propertyInclusions[attributeIndex]){final AttributeMapping mapping=attributeMappings.get(attributeIndex);\ndecomposeAttribute(values[attributeIndex],session,jdbcValueBindings,mapping);\n}}}}if(id == null){assert entityPersister().getInsertDelegate() != null;\n}{for(int position=0; position < mutationGroup.getNumberOfOperations(); position++){final MutationOperation jdbcOperation=mutationGroup.getOperation(position);\nfinal EntityTableMapping tableDetails=(EntityTableMapping)jdbcOperation.getTableDetails();\nbreakDownJdbcValue(id,session,jdbcValueBindings,tableDetails);\n}}}\nmethodSignature: org.hibernate.engine.jdbc.mutation.internal.MutationExecutorStandard#release\n methodBody: public void release() {\nnonBatchedStatementGroup.release();\n}\nmethodSignature: org.hibernate.persister.entity.mutation.InsertCoordinatorStandard#getTableInclusionChecker\n methodBody: protected static TableInclusionChecker getTableInclusionChecker(InsertValuesAnalysis insertValuesAnalysis) {\nreturn tableMapping -> !tableMapping.isOptional() || insertValuesAnalysis.hasNonNullBindings(tableMapping);\n}\nmethodSignature: org.hibernate.engine.jdbc.mutation.internal.AbstractMutationExecutor#execute\n methodBody: public final GeneratedValues execute(\n\t\t\tObject modelReference,\n\t\t\tValuesAnalysis valuesAnalysis,\n\t\t\tTableInclusionChecker inclusionChecker,\n\t\t\tOperationResultChecker resultChecker,\n\t\t\tSharedSessionContractImplementor session) {\nfinal GeneratedValues generatedValues=performNonBatchedOperations(modelReference,valuesAnalysis,inclusionChecker,resultChecker,session);\nperformSelfExecutingOperations(valuesAnalysis,inclusionChecker,session);\nperformBatchedOperations(valuesAnalysis,inclusionChecker);\nreturn generatedValues;\n}\nmethodSignature: org.hibernate.orm.test.jpa.transaction.batch.AbstractBatchingTest.BatchWrapper#execute\n methodBody: public void execute() {\nwrapped.execute();\n}\nmethodSignature: org.hibernate.engine.jdbc.batch.spi.Batch#execute\n methodBody: void execute();\nmethodSignature: org.hibernate.orm.test.jpa.transaction.batch.AbstractBatchingTest.BatchWrapper#release\n methodBody: public void release() {\nwasReleaseCalled=true;\nwrapped.release();\nnumberOfStatementsAfterRelease=wrapped.getStatementGroup().getNumberOfActiveStatements();\n}\nmethodSignature: org.hibernate.persister.entity.mutation.AbstractDeleteCoordinator#executor\n methodBody: private MutationExecutor executor(SharedSessionContractImplementor session, MutationOperationGroup group) {\nreturn mutationExecutorService.createExecutor(resolveBatchKeyAccess(false,session),group,session);\n}\nmethodSignature: org.hibernate.engine.jdbc.batch.internal.BatchImpl#execute\n methodBody: public void execute() {\nnotifyObserversExplicitExecution();\nif(getStatementGroup().getNumberOfStatements() == 0){return;\n}tryif(batchPosition == 0){if(!batchExecuted){if(BATCH_LOGGER.isDebugEnabled()){BATCH_LOGGER.debugf(\"No batched statements to execute - %s\",getKey().toLoggableString());\n}}}{performExecution();\n}finallyreleaseStatements();\n}\nmethodSignature: org.hibernate.persister.entity.AbstractEntityPersister#getPropertyInsertability\n methodBody: public boolean[] getPropertyInsertability() {\nreturn entityMetamodel.getPropertyInsertability();\n}\nmethodSignature: org.hibernate.engine.jdbc.batch.spi.Batch#release\n methodBody: void release();\nmethodSignature: org.hibernate.engine.jdbc.mutation.internal.MutationExecutorSingleBatched#release\n methodBody: public void release() {\n}\nmethodSignature: org.hibernate.engine.jdbc.mutation.MutationExecutor#release\n methodBody: void release();\nmethodSignature: org.hibernate.persister.entity.mutation.UpdateCoordinatorStandard#executor\n methodBody: private MutationExecutor executor(SharedSessionContractImplementor session, MutationOperationGroup group, boolean dynamicUpdate) {\nreturn mutationExecutorService.createExecutor(resolveBatchKeyAccess(dynamicUpdate,session),group,session);\n}\nmethodSignature: org.hibernate.engine.jdbc.batch.internal.BatchImpl#release\n methodBody: public void release() {\nif(BATCH_MESSAGE_LOGGER.isInfoEnabled()){final PreparedStatementGroup statementGroup=getStatementGroup();\nif(statementGroup.getNumberOfStatements() != 0){if(statementGroup.hasMatching((statementDetails) -> statementDetails.getStatement() != null)){BATCH_MESSAGE_LOGGER.batchContainedStatementsOnRelease();\n}}}releaseStatements();\nobservers.clear();\n}\nmethodSignature: org.hibernate.persister.entity.mutation.AbstractMutationCoordinator#entityPersister\n methodBody: protected EntityPersister entityPersister() {\nreturn entityPersister;\n}\nmethodSignature: org.hibernate.engine.jdbc.mutation.MutationExecutor#execute\n methodBody: GeneratedValues execute(\n\t\t\tObject modelReference,\n\t\t\tValuesAnalysis valuesAnalysis,\n\t\t\tTableInclusionChecker inclusionChecker,\n\t\t\tOperationResultChecker resultChecker,\n\t\t\tSharedSessionContractImplementor session);\nmethodSignature: org.hibernate.persister.entity.mutation.InsertCoordinatorStandard#executor\n methodBody: private MutationExecutor executor(SharedSessionContractImplementor session, MutationOperationGroup group, boolean dynamicUpdate) {\nreturn mutationExecutorService.createExecutor(resolveBatchKeyAccess(dynamicUpdate,session),group,session);\n}",
        "classSignatureBefore": "public class InsertCoordinatorStandard extends AbstractMutationCoordinator implements InsertCoordinator ",
        "methodNameBeforeSet": [
            "org.hibernate.persister.entity.mutation.InsertCoordinatorStandard#doStaticInserts"
        ],
        "classNameBeforeSet": [
            "org.hibernate.persister.entity.mutation.InsertCoordinatorStandard"
        ],
        "classSignatureBeforeSet": [
            "public class InsertCoordinatorStandard extends AbstractMutationCoordinator implements InsertCoordinator "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n * See the lgpl.txt file in the root directory or http://www.gnu.org/licenses/lgpl-2.1.html.\n */\npackage org.hibernate.persister.entity.mutation;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.hibernate.Internal;\nimport org.hibernate.dialect.Dialect;\nimport org.hibernate.engine.jdbc.batch.internal.BasicBatchKey;\nimport org.hibernate.engine.jdbc.batch.spi.BatchKey;\nimport org.hibernate.engine.jdbc.mutation.JdbcValueBindings;\nimport org.hibernate.engine.jdbc.mutation.MutationExecutor;\nimport org.hibernate.engine.jdbc.mutation.ParameterUsage;\nimport org.hibernate.engine.jdbc.mutation.TableInclusionChecker;\nimport org.hibernate.engine.spi.SessionFactoryImplementor;\nimport org.hibernate.engine.spi.SharedSessionContractImplementor;\nimport org.hibernate.generator.BeforeExecutionGenerator;\nimport org.hibernate.generator.Generator;\nimport org.hibernate.generator.OnExecutionGenerator;\nimport org.hibernate.generator.values.GeneratedValues;\nimport org.hibernate.generator.values.GeneratedValuesMutationDelegate;\nimport org.hibernate.metamodel.mapping.AttributeMapping;\nimport org.hibernate.metamodel.mapping.AttributeMappingsList;\nimport org.hibernate.metamodel.mapping.BasicEntityIdentifierMapping;\nimport org.hibernate.metamodel.mapping.PluralAttributeMapping;\nimport org.hibernate.persister.entity.EntityPersister;\nimport org.hibernate.sql.model.MutationOperation;\nimport org.hibernate.sql.model.MutationOperationGroup;\nimport org.hibernate.sql.model.MutationType;\nimport org.hibernate.sql.model.TableMapping;\nimport org.hibernate.sql.model.ValuesAnalysis;\nimport org.hibernate.sql.model.ast.builder.MutationGroupBuilder;\nimport org.hibernate.sql.model.ast.builder.TableInsertBuilder;\nimport org.hibernate.sql.model.ast.builder.TableInsertBuilderStandard;\nimport org.hibernate.sql.model.ast.builder.TableMutationBuilder;\nimport org.hibernate.tuple.entity.EntityMetamodel;\n\nimport org.checkerframework.checker.nullness.qual.Nullable;\n\nimport static org.hibernate.generator.EventType.INSERT;\n\n/**\n * Coordinates the insertion of an entity.\n *\n * @see #coordinateInsert\n *\n * @author Steve Ebersole\n */\n@Internal\npublic class InsertCoordinatorStandard extends AbstractMutationCoordinator implements InsertCoordinator {\n\tprivate final MutationOperationGroup staticInsertGroup;\n\tprivate final BasicBatchKey batchKey;\n\n\tpublic InsertCoordinatorStandard(EntityPersister entityPersister, SessionFactoryImplementor factory) {\n\t\tsuper( entityPersister, factory );\n\n\t\tif ( entityPersister.isIdentifierAssignedByInsert() || entityPersister.hasInsertGeneratedProperties() ) {\n\t\t\t// disable batching in case of insert generated identifier or properties\n\t\t\tbatchKey = null;\n\t\t}\n\t\telse {\n\t\t\tbatchKey = new BasicBatchKey( entityPersister.getEntityName() + \"#INSERT\" );\n\t\t}\n\n\t\tif ( entityPersister.getEntityMetamodel().isDynamicInsert() ) {\n\t\t\t// the entity specified dynamic-insert - skip generating the\n\t\t\t// static inserts as we will create them every time\n\t\t\tstaticInsertGroup = null;\n\t\t}\n\t\telse {\n\t\t\tstaticInsertGroup = generateStaticOperationGroup();\n\t\t}\n\t}\n\n\t@Override\n\tpublic MutationOperationGroup getStaticMutationOperationGroup() {\n\t\treturn staticInsertGroup;\n\t}\n\n\t@Override\n\tprotected BatchKey getBatchKey() {\n\t\treturn batchKey;\n\t}\n\n\t@Override\n\tpublic @Nullable GeneratedValues insert(Object entity, Object[] values, SharedSessionContractImplementor session) {\n\t\treturn coordinateInsert( null, values, entity, session );\n\t}\n\n\t@Override\n\tpublic @Nullable GeneratedValues insert(\n\t\t\tObject entity,\n\t\t\tObject id,\n\t\t\tObject[] values,\n\t\t\tSharedSessionContractImplementor session) {\n\t\treturn coordinateInsert( id, values, entity, session );\n\t}\n\n\t/**\n\t * Perform the insert(s).\n\t *\n\t * @param id This is the id as known in memory. For post-insert id generation (IDENTITY, etc)\n\t * this will be null.\n\t * @param values The extracted attribute values\n\t * @param entity The entity instance being persisted\n\t * @param session The originating context\n\t *\n\t * @return The {@linkplain GeneratedValues generated values} if any, {@code null} otherwise.\n\t */\n\tpublic GeneratedValues coordinateInsert(\n\t\t\tObject id,\n\t\t\tObject[] values,\n\t\t\tObject entity,\n\t\t\tSharedSessionContractImplementor session) {\n\t\t// apply any pre-insert in-memory value generation\n\t\tfinal boolean needsDynamicInsert = preInsertInMemoryValueGeneration( values, entity, session );\n\n\t\tfinal EntityMetamodel entityMetamodel = entityPersister().getEntityMetamodel();\n\t\tfinal boolean forceIdentifierBinding = entityPersister().getGenerator().generatedOnExecution() && id != null;\n\t\tif ( entityMetamodel.isDynamicInsert() || needsDynamicInsert || forceIdentifierBinding ) {\n\t\t\treturn doDynamicInserts( id, values, entity, session, forceIdentifierBinding );\n\t\t}\n\t\telse {\n\t\t\treturn doStaticInserts( id, values, entity, session );\n\t\t}\n\t}\n\n\tprotected boolean preInsertInMemoryValueGeneration(Object[] values, Object entity, SharedSessionContractImplementor session) {\n\t\tfinal EntityPersister persister = entityPersister();\n\t\tfinal EntityMetamodel entityMetamodel = persister.getEntityMetamodel();\n\t\tboolean foundStateDependentGenerator = false;\n\t\tif ( entityMetamodel.hasPreInsertGeneratedValues() ) {\n\t\t\tfinal Generator[] generators = entityMetamodel.getGenerators();\n\t\t\tfor ( int i = 0; i < generators.length; i++ ) {\n\t\t\t\tfinal Generator generator = generators[i];\n\t\t\t\tif ( generator != null\n\t\t\t\t\t\t&& generator.generatesOnInsert()\n\t\t\t\t\t\t&& !generator.generatedOnExecution( entity, session ) ) {\n\t\t\t\t\tvalues[i] = ( (BeforeExecutionGenerator) generator ).generate( session, entity, values[i], INSERT );\n\t\t\t\t\tpersister.setPropertyValue( entity, i, values[i] );\n\t\t\t\t\tfoundStateDependentGenerator = foundStateDependentGenerator || generator.generatedOnExecution();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn foundStateDependentGenerator;\n\t}\n\n\tpublic static class InsertValuesAnalysis implements ValuesAnalysis {\n\t\tprivate final List<TableMapping> tablesWithNonNullValues = new ArrayList<>();\n\n\t\tpublic InsertValuesAnalysis(EntityMutationTarget mutationTarget, Object[] values) {\n\t\t\tmutationTarget.forEachMutableTable( (tableMapping) -> {\n\t\t\t\tfinal int[] tableAttributeIndexes = tableMapping.getAttributeIndexes();\n\t\t\t\tfor ( int i = 0; i < tableAttributeIndexes.length; i++ ) {\n\t\t\t\t\tif ( values[tableAttributeIndexes[i]] != null ) {\n\t\t\t\t\t\ttablesWithNonNullValues.add( tableMapping );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} );\n\t\t}\n\n\t\tpublic boolean hasNonNullBindings(TableMapping tableMapping) {\n\t\t\treturn tablesWithNonNullValues.contains( tableMapping );\n\t\t}\n\t}\n\n\tprotected GeneratedValues doStaticInserts(Object id, Object[] values, Object object, SharedSessionContractImplementor session) {\n\t\tfinal InsertValuesAnalysis insertValuesAnalysis = new InsertValuesAnalysis( entityPersister(), values );\n\n\t\tfinal TableInclusionChecker tableInclusionChecker = getTableInclusionChecker( insertValuesAnalysis );\n\n\t\tfinal MutationExecutor mutationExecutor = executor( session, staticInsertGroup, false );\n\n\t\tdecomposeForInsert(\n\t\t\t\tmutationExecutor,\n\t\t\t\tid,\n\t\t\t\tvalues,\n\t\t\t\tstaticInsertGroup,\n\t\t\t\tentityPersister().getPropertyInsertability(),\n\t\t\t\ttableInclusionChecker,\n\t\t\t\tsession\n\t\t);\n\n\t\ttry {\n\t\t\treturn mutationExecutor.execute(\n\t\t\t\t\tobject,\n\t\t\t\t\tinsertValuesAnalysis,\n\t\t\t\t\ttableInclusionChecker,\n\t\t\t\t\t(statementDetails, affectedRowCount, batchPosition) -> {\n\t\t\t\t\t\tstatementDetails.getExpectation().verifyOutcome(\n\t\t\t\t\t\t\t\taffectedRowCount,\n\t\t\t\t\t\t\t\tstatementDetails.getStatement(),\n\t\t\t\t\t\t\t\tbatchPosition,\n\t\t\t\t\t\t\t\tstatementDetails.getSqlString()\n\t\t\t\t\t\t);\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t},\n\t\t\t\t\tsession\n\t\t\t);\n\t\t}\n\t\tfinally {\n\t\t\tmutationExecutor.release();\n\t\t}\n\t}\n\n\tprotected void decomposeForInsert(\n\t\t\tMutationExecutor mutationExecutor,\n\t\t\tObject id,\n\t\t\tObject[] values,\n\t\t\tMutationOperationGroup mutationGroup,\n\t\t\tboolean[] propertyInclusions,\n\t\t\tTableInclusionChecker tableInclusionChecker,\n\t\t\tSharedSessionContractImplementor session) {\n\t\tfinal JdbcValueBindings jdbcValueBindings = mutationExecutor.getJdbcValueBindings();\n\t\tfinal AttributeMappingsList attributeMappings = entityPersister().getAttributeMappings();\n\n\t\tfor ( int position = 0; position < mutationGroup.getNumberOfOperations(); position++ ) {\n\t\t\tfinal MutationOperation operation = mutationGroup.getOperation( position );\n\t\t\tfinal EntityTableMapping tableDetails = (EntityTableMapping) operation.getTableDetails();\n\t\t\tif ( tableInclusionChecker.include( tableDetails ) ) {\n\t\t\t\tfinal int[] attributeIndexes = tableDetails.getAttributeIndexes();\n\t\t\t\tfor ( int i = 0; i < attributeIndexes.length; i++ ) {\n\t\t\t\t\tfinal int attributeIndex = attributeIndexes[ i ];\n\t\t\t\t\tif ( propertyInclusions[attributeIndex] ) {\n\t\t\t\t\t\tfinal AttributeMapping mapping = attributeMappings.get( attributeIndex );\n\t\t\t\t\t\tdecomposeAttribute( values[attributeIndex], session, jdbcValueBindings, mapping );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ( id == null ) {\n\t\t\tassert entityPersister().getInsertDelegate() != null;\n\t\t}\n\t\telse {\n\t\t\tfor ( int position = 0; position < mutationGroup.getNumberOfOperations(); position++ ) {\n\t\t\t\tfinal MutationOperation jdbcOperation = mutationGroup.getOperation( position );\n\t\t\t\tfinal EntityTableMapping tableDetails = (EntityTableMapping) jdbcOperation.getTableDetails();\n\t\t\t\tbreakDownJdbcValue( id, session, jdbcValueBindings, tableDetails );\n\t\t\t}\n\t\t}\n\t}\n\n\tprotected void breakDownJdbcValue(\n\t\t\tObject id,\n\t\t\tSharedSessionContractImplementor session,\n\t\t\tJdbcValueBindings jdbcValueBindings,\n\t\t\tEntityTableMapping tableDetails) {\n\t\tfinal String tableName = tableDetails.getTableName();\n\t\ttableDetails.getKeyMapping().breakDownKeyJdbcValues(\n\t\t\t\tid,\n\t\t\t\t(jdbcValue, columnMapping) -> {\n\t\t\t\t\tjdbcValueBindings.bindValue(\n\t\t\t\t\t\t\tjdbcValue,\n\t\t\t\t\t\t\ttableName,\n\t\t\t\t\t\t\tcolumnMapping.getColumnName(),\n\t\t\t\t\t\t\tParameterUsage.SET\n\t\t\t\t\t);\n\t\t\t\t},\n\t\t\t\tsession\n\t\t);\n\t}\n\n\tprotected void decomposeAttribute(\n\t\t\tObject value,\n\t\t\tSharedSessionContractImplementor session,\n\t\t\tJdbcValueBindings jdbcValueBindings,\n\t\t\tAttributeMapping mapping) {\n\t\tif ( !(mapping instanceof PluralAttributeMapping) ) {\n\t\t\tmapping.decompose(\n\t\t\t\t\tvalue,\n\t\t\t\t\t0,\n\t\t\t\t\tjdbcValueBindings,\n\t\t\t\t\tnull,\n\t\t\t\t\t(valueIndex, bindings, noop, jdbcValue, selectableMapping) -> {\n\t\t\t\t\t\tif ( selectableMapping.isInsertable() ) {\n\t\t\t\t\t\t\tbindings.bindValue(\n\t\t\t\t\t\t\t\t\tjdbcValue,\n\t\t\t\t\t\t\t\t\tentityPersister().physicalTableNameForMutation( selectableMapping ),\n\t\t\t\t\t\t\t\t\tselectableMapping.getSelectionExpression(),\n\t\t\t\t\t\t\t\t\tParameterUsage.SET\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tsession\n\t\t\t);\n\t\t}\n\t}\n\n\tprotected GeneratedValues doDynamicInserts(\n\t\t\tObject id,\n\t\t\tObject[] values,\n\t\t\tObject object,\n\t\t\tSharedSessionContractImplementor session,\n\t\t\tboolean forceIdentifierBinding) {\n\t\tfinal boolean[] insertability = getPropertiesToInsert( values );\n\t\tfinal MutationOperationGroup insertGroup = generateDynamicInsertSqlGroup( insertability, object, session, forceIdentifierBinding );\n\n\t\tfinal MutationExecutor mutationExecutor = executor( session, insertGroup, true );\n\n\t\tfinal InsertValuesAnalysis insertValuesAnalysis = new InsertValuesAnalysis( entityPersister(), values );\n\n\t\tfinal TableInclusionChecker tableInclusionChecker = getTableInclusionChecker( insertValuesAnalysis );\n\n\t\tdecomposeForInsert( mutationExecutor, id, values, insertGroup, insertability, tableInclusionChecker, session );\n\n\t\ttry {\n\t\t\treturn mutationExecutor.execute(\n\t\t\t\t\tobject,\n\t\t\t\t\tinsertValuesAnalysis,\n\t\t\t\t\ttableInclusionChecker,\n\t\t\t\t\t(statementDetails, affectedRowCount, batchPosition) -> {\n\t\t\t\t\t\tstatementDetails.getExpectation().verifyOutcome(\n\t\t\t\t\t\t\t\taffectedRowCount,\n\t\t\t\t\t\t\t\tstatementDetails.getStatement(),\n\t\t\t\t\t\t\t\tbatchPosition,\n\t\t\t\t\t\t\t\tstatementDetails.getSqlString()\n\t\t\t\t\t\t);\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t},\n\t\t\t\t\tsession\n\t\t\t);\n\t\t}\n\t\tfinally {\n\t\t\tmutationExecutor.release();\n\t\t}\n\t}\n\n\tprivate MutationExecutor executor(SharedSessionContractImplementor session, MutationOperationGroup group, boolean dynamicUpdate) {\n\t\treturn mutationExecutorService\n\t\t\t\t.createExecutor( resolveBatchKeyAccess( dynamicUpdate, session ), group, session );\n\t}\n\n\tprotected static TableInclusionChecker getTableInclusionChecker(InsertValuesAnalysis insertValuesAnalysis) {\n\t\treturn tableMapping -> !tableMapping.isOptional() || insertValuesAnalysis.hasNonNullBindings( tableMapping );\n\t}\n\n\n\t/**\n\t * Transform the array of property indexes to an array of booleans,\n\t * true when the property is insertable and non-null\n\t */\n\tpublic boolean[] getPropertiesToInsert(Object[] fields) {\n\t\tboolean[] notNull = new boolean[fields.length];\n\t\tboolean[] insertable = entityPersister().getPropertyInsertability();\n\t\tfor ( int i = 0; i < fields.length; i++ ) {\n\t\t\tnotNull[i] = insertable[i] && fields[i] != null;\n\t\t}\n\t\treturn notNull;\n\t}\n\n\tprotected MutationOperationGroup generateDynamicInsertSqlGroup(\n\t\t\tboolean[] insertable,\n\t\t\tObject object,\n\t\t\tSharedSessionContractImplementor session,\n\t\t\tboolean forceIdentifierBinding) {\n\t\tfinal MutationGroupBuilder insertGroupBuilder = new MutationGroupBuilder( MutationType.INSERT, entityPersister() );\n\t\tentityPersister().forEachMutableTable(\n\t\t\t\t(tableMapping) -> insertGroupBuilder.addTableDetailsBuilder( createTableInsertBuilder( tableMapping, forceIdentifierBinding ) )\n\t\t);\n\t\tapplyTableInsertDetails( insertGroupBuilder, insertable, object, session, forceIdentifierBinding );\n\t\treturn createOperationGroup( null, insertGroupBuilder.buildMutationGroup() );\n\t}\n\n\tpublic MutationOperationGroup generateStaticOperationGroup() {\n\t\tfinal MutationGroupBuilder insertGroupBuilder = new MutationGroupBuilder( MutationType.INSERT, entityPersister() );\n\t\tentityPersister().forEachMutableTable(\n\t\t\t\t(tableMapping) -> insertGroupBuilder.addTableDetailsBuilder( createTableInsertBuilder( tableMapping, false ) )\n\t\t);\n\t\tapplyTableInsertDetails( insertGroupBuilder, entityPersister().getPropertyInsertability(), null, null, false );\n\t\treturn createOperationGroup( null, insertGroupBuilder.buildMutationGroup() );\n\t}\n\n\tprivate TableMutationBuilder<?> createTableInsertBuilder(EntityTableMapping tableMapping, boolean forceIdentifierBinding) {\n\t\tfinal GeneratedValuesMutationDelegate delegate = entityPersister().getInsertDelegate();\n\t\tif ( tableMapping.isIdentifierTable() && delegate != null && !forceIdentifierBinding ) {\n\t\t\treturn delegate.createTableMutationBuilder( tableMapping.getInsertExpectation(), factory() );\n\t\t}\n\t\telse {\n\t\t\treturn new TableInsertBuilderStandard( entityPersister(), tableMapping, factory() );\n\t\t}\n\t}\n\n\tprivate void applyTableInsertDetails(\n\t\t\tMutationGroupBuilder insertGroupBuilder,\n\t\t\tboolean[] attributeInclusions,\n\t\t\tObject object,\n\t\t\tSharedSessionContractImplementor session,\n\t\t\tboolean forceIdentifierBinding) {\n\t\tfinal AttributeMappingsList attributeMappings = entityPersister().getAttributeMappings();\n\n\t\tinsertGroupBuilder.forEachTableMutationBuilder( (builder) -> {\n\t\t\tfinal EntityTableMapping tableMapping = (EntityTableMapping) builder.getMutatingTable().getTableMapping();\n\t\t\tassert !tableMapping.isInverse();\n\n\t\t\t// `attributeIndexes` represents the indexes (relative to `attributeMappings`) of\n\t\t\t// the attributes mapped to the table\n\t\t\tfinal int[] attributeIndexes = tableMapping.getAttributeIndexes();\n\t\t\tfor ( int i = 0; i < attributeIndexes.length; i++ ) {\n\t\t\t\tfinal int attributeIndex = attributeIndexes[ i ];\n\t\t\t\tfinal AttributeMapping attributeMapping = attributeMappings.get( attributeIndex );\n\t\t\t\tif ( attributeInclusions[attributeIndex] ) {\n\t\t\t\t\tattributeMapping.forEachInsertable( insertGroupBuilder );\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tfinal Generator generator = attributeMapping.getGenerator();\n\t\t\t\t\tif ( isValueGenerated( generator ) ) {\n\t\t\t\t\t\tif ( session != null && !generator.generatedOnExecution( object, session ) ) {\n\t\t\t\t\t\t\tattributeInclusions[attributeIndex] = true;\n\t\t\t\t\t\t\tattributeMapping.forEachInsertable( insertGroupBuilder );\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if ( isValueGenerationInSql( generator, factory().getJdbcServices().getDialect() ) ) {\n\t\t\t\t\t\t\thandleValueGeneration( attributeMapping, insertGroupBuilder, (OnExecutionGenerator) generator );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\n\t\t// add the discriminator\n\t\tentityPersister().addDiscriminatorToInsertGroup( insertGroupBuilder );\n\t\tentityPersister().addSoftDeleteToInsertGroup( insertGroupBuilder );\n\n\t\t// add the keys\n\t\tinsertGroupBuilder.forEachTableMutationBuilder( (tableMutationBuilder) -> {\n\t\t\tfinal TableInsertBuilder tableInsertBuilder = (TableInsertBuilder) tableMutationBuilder;\n\t\t\tfinal EntityTableMapping tableMapping = (EntityTableMapping) tableInsertBuilder.getMutatingTable().getTableMapping();\n\t\t\tif ( tableMapping.isIdentifierTable() && entityPersister().isIdentifierAssignedByInsert() && !forceIdentifierBinding ) {\n\t\t\t\tassert entityPersister().getInsertDelegate() != null;\n\t\t\t\tfinal OnExecutionGenerator generator = (OnExecutionGenerator) entityPersister().getGenerator();\n\t\t\t\tif ( generator.referenceColumnsInSql( dialect() ) ) {\n\t\t\t\t\tfinal BasicEntityIdentifierMapping identifierMapping = (BasicEntityIdentifierMapping) entityPersister().getIdentifierMapping();\n\t\t\t\t\tfinal String[] columnValues = generator.getReferencedColumnValues( dialect );\n\t\t\t\t\ttableMapping.getKeyMapping().forEachKeyColumn( (i, column) -> tableInsertBuilder.addKeyColumn(\n\t\t\t\t\t\t\tcolumn.getColumnName(),\n\t\t\t\t\t\t\tcolumnValues[i],\n\t\t\t\t\t\t\tidentifierMapping.getJdbcMapping()\n\t\t\t\t\t) );\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttableMapping.getKeyMapping().forEachKeyColumn( tableInsertBuilder::addKeyColumn );\n\t\t\t}\n\t\t} );\n\t}\n\n\tprivate static boolean isValueGenerated(Generator generator) {\n\t\treturn generator != null\n\t\t\t\t&& generator.generatesOnInsert()\n\t\t\t\t&& generator.generatedOnExecution();\n\t}\n\n\tprivate static boolean isValueGenerationInSql(Generator generator, Dialect dialect) {\n\t\tassert isValueGenerated( generator );\n\t\treturn ( (OnExecutionGenerator) generator ).referenceColumnsInSql(dialect);\n\t}\n\n\t/**\n\t * @deprecated Use {@link #getBatchKey()}\n\t */\n\t@Deprecated\n\tpublic BasicBatchKey getInsertBatchKey() {\n\t\treturn batchKey;\n\t}\n}\n",
        "filePathAfter": "hibernate-core/src/main/java/org/hibernate/persister/entity/mutation/InsertCoordinatorStandard.java",
        "sourceCodeAfterForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n * See the lgpl.txt file in the root directory or http://www.gnu.org/licenses/lgpl-2.1.html.\n */\npackage org.hibernate.persister.entity.mutation;\n\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.hibernate.Internal;\nimport org.hibernate.dialect.Dialect;\nimport org.hibernate.engine.jdbc.batch.internal.BasicBatchKey;\nimport org.hibernate.engine.jdbc.batch.spi.BatchKey;\nimport org.hibernate.engine.jdbc.mutation.JdbcValueBindings;\nimport org.hibernate.engine.jdbc.mutation.MutationExecutor;\nimport org.hibernate.engine.jdbc.mutation.ParameterUsage;\nimport org.hibernate.engine.jdbc.mutation.TableInclusionChecker;\nimport org.hibernate.engine.jdbc.mutation.group.PreparedStatementDetails;\nimport org.hibernate.engine.spi.SessionFactoryImplementor;\nimport org.hibernate.engine.spi.SharedSessionContractImplementor;\nimport org.hibernate.generator.BeforeExecutionGenerator;\nimport org.hibernate.generator.Generator;\nimport org.hibernate.generator.OnExecutionGenerator;\nimport org.hibernate.generator.values.GeneratedValues;\nimport org.hibernate.generator.values.GeneratedValuesMutationDelegate;\nimport org.hibernate.metamodel.mapping.AttributeMapping;\nimport org.hibernate.metamodel.mapping.AttributeMappingsList;\nimport org.hibernate.metamodel.mapping.BasicEntityIdentifierMapping;\nimport org.hibernate.metamodel.mapping.PluralAttributeMapping;\nimport org.hibernate.persister.entity.EntityPersister;\nimport org.hibernate.sql.model.MutationOperation;\nimport org.hibernate.sql.model.MutationOperationGroup;\nimport org.hibernate.sql.model.MutationType;\nimport org.hibernate.sql.model.TableMapping;\nimport org.hibernate.sql.model.ValuesAnalysis;\nimport org.hibernate.sql.model.ast.builder.MutationGroupBuilder;\nimport org.hibernate.sql.model.ast.builder.TableInsertBuilder;\nimport org.hibernate.sql.model.ast.builder.TableInsertBuilderStandard;\nimport org.hibernate.sql.model.ast.builder.TableMutationBuilder;\nimport org.hibernate.tuple.entity.EntityMetamodel;\n\nimport org.checkerframework.checker.nullness.qual.Nullable;\n\nimport static org.hibernate.generator.EventType.INSERT;\n\n/**\n * Coordinates the insertion of an entity.\n *\n * @see #coordinateInsert\n *\n * @author Steve Ebersole\n */\n@Internal\npublic class InsertCoordinatorStandard extends AbstractMutationCoordinator implements InsertCoordinator {\n\tprivate final MutationOperationGroup staticInsertGroup;\n\tprivate final BasicBatchKey batchKey;\n\n\tpublic InsertCoordinatorStandard(EntityPersister entityPersister, SessionFactoryImplementor factory) {\n\t\tsuper( entityPersister, factory );\n\n\t\tif ( entityPersister.isIdentifierAssignedByInsert() || entityPersister.hasInsertGeneratedProperties() ) {\n\t\t\t// disable batching in case of insert generated identifier or properties\n\t\t\tbatchKey = null;\n\t\t}\n\t\telse {\n\t\t\tbatchKey = new BasicBatchKey( entityPersister.getEntityName() + \"#INSERT\" );\n\t\t}\n\n\t\tif ( entityPersister.getEntityMetamodel().isDynamicInsert() ) {\n\t\t\t// the entity specified dynamic-insert - skip generating the\n\t\t\t// static inserts as we will create them every time\n\t\t\tstaticInsertGroup = null;\n\t\t}\n\t\telse {\n\t\t\tstaticInsertGroup = generateStaticOperationGroup();\n\t\t}\n\t}\n\n\t@Override\n\tpublic MutationOperationGroup getStaticMutationOperationGroup() {\n\t\treturn staticInsertGroup;\n\t}\n\n\t@Override\n\tprotected BatchKey getBatchKey() {\n\t\treturn batchKey;\n\t}\n\n\t@Override\n\tpublic @Nullable GeneratedValues insert(Object entity, Object[] values, SharedSessionContractImplementor session) {\n\t\treturn coordinateInsert( null, values, entity, session );\n\t}\n\n\t@Override\n\tpublic @Nullable GeneratedValues insert(\n\t\t\tObject entity,\n\t\t\tObject id,\n\t\t\tObject[] values,\n\t\t\tSharedSessionContractImplementor session) {\n\t\treturn coordinateInsert( id, values, entity, session );\n\t}\n\n\t/**\n\t * Perform the insert(s).\n\t *\n\t * @param id This is the id as known in memory. For post-insert id generation (IDENTITY, etc)\n\t * this will be null.\n\t * @param values The extracted attribute values\n\t * @param entity The entity instance being persisted\n\t * @param session The originating context\n\t *\n\t * @return The {@linkplain GeneratedValues generated values} if any, {@code null} otherwise.\n\t */\n\tpublic GeneratedValues coordinateInsert(\n\t\t\tObject id,\n\t\t\tObject[] values,\n\t\t\tObject entity,\n\t\t\tSharedSessionContractImplementor session) {\n\t\t// apply any pre-insert in-memory value generation\n\t\tfinal boolean needsDynamicInsert = preInsertInMemoryValueGeneration( values, entity, session );\n\n\t\tfinal EntityMetamodel entityMetamodel = entityPersister().getEntityMetamodel();\n\t\tfinal boolean forceIdentifierBinding = entityPersister().getGenerator().generatedOnExecution() && id != null;\n\t\tif ( entityMetamodel.isDynamicInsert() || needsDynamicInsert || forceIdentifierBinding ) {\n\t\t\treturn doDynamicInserts( id, values, entity, session, forceIdentifierBinding );\n\t\t}\n\t\telse {\n\t\t\treturn doStaticInserts( id, values, entity, session );\n\t\t}\n\t}\n\n\tprotected boolean preInsertInMemoryValueGeneration(Object[] values, Object entity, SharedSessionContractImplementor session) {\n\t\tfinal EntityPersister persister = entityPersister();\n\t\tfinal EntityMetamodel entityMetamodel = persister.getEntityMetamodel();\n\t\tboolean foundStateDependentGenerator = false;\n\t\tif ( entityMetamodel.hasPreInsertGeneratedValues() ) {\n\t\t\tfinal Generator[] generators = entityMetamodel.getGenerators();\n\t\t\tfor ( int i = 0; i < generators.length; i++ ) {\n\t\t\t\tfinal Generator generator = generators[i];\n\t\t\t\tif ( generator != null\n\t\t\t\t\t\t&& generator.generatesOnInsert()\n\t\t\t\t\t\t&& !generator.generatedOnExecution( entity, session ) ) {\n\t\t\t\t\tvalues[i] = ( (BeforeExecutionGenerator) generator ).generate( session, entity, values[i], INSERT );\n\t\t\t\t\tpersister.setPropertyValue( entity, i, values[i] );\n\t\t\t\t\tfoundStateDependentGenerator = foundStateDependentGenerator || generator.generatedOnExecution();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn foundStateDependentGenerator;\n\t}\n\n\tpublic static class InsertValuesAnalysis implements ValuesAnalysis {\n\t\tprivate final List<TableMapping> tablesWithNonNullValues = new ArrayList<>();\n\n\t\tpublic InsertValuesAnalysis(EntityMutationTarget mutationTarget, Object[] values) {\n\t\t\tmutationTarget.forEachMutableTable( (tableMapping) -> {\n\t\t\t\tfinal int[] tableAttributeIndexes = tableMapping.getAttributeIndexes();\n\t\t\t\tfor ( int i = 0; i < tableAttributeIndexes.length; i++ ) {\n\t\t\t\t\tif ( values[tableAttributeIndexes[i]] != null ) {\n\t\t\t\t\t\ttablesWithNonNullValues.add( tableMapping );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} );\n\t\t}\n\n\t\tpublic boolean hasNonNullBindings(TableMapping tableMapping) {\n\t\t\treturn tablesWithNonNullValues.contains( tableMapping );\n\t\t}\n\t}\n\n\tprotected GeneratedValues doStaticInserts(Object id, Object[] values, Object object, SharedSessionContractImplementor session) {\n\t\tfinal InsertValuesAnalysis insertValuesAnalysis = new InsertValuesAnalysis( entityPersister(), values );\n\n\t\tfinal TableInclusionChecker tableInclusionChecker = getTableInclusionChecker( insertValuesAnalysis );\n\n\t\tfinal MutationExecutor mutationExecutor = executor( session, staticInsertGroup, false );\n\n\t\tdecomposeForInsert(\n\t\t\t\tmutationExecutor,\n\t\t\t\tid,\n\t\t\t\tvalues,\n\t\t\t\tstaticInsertGroup,\n\t\t\t\tentityPersister().getPropertyInsertability(),\n\t\t\t\ttableInclusionChecker,\n\t\t\t\tsession\n\t\t);\n\n\t\ttry {\n\t\t\treturn mutationExecutor.execute(\n\t\t\t\t\tobject,\n\t\t\t\t\tinsertValuesAnalysis,\n\t\t\t\t\ttableInclusionChecker,\n\t\t\t\t\tInsertCoordinatorStandard::verifyOutcome,\n\t\t\t\t\tsession\n\t\t\t);\n\t\t}\n\t\tfinally {\n\t\t\tmutationExecutor.release();\n\t\t}\n\t}\n\n\tprotected void decomposeForInsert(\n\t\t\tMutationExecutor mutationExecutor,\n\t\t\tObject id,\n\t\t\tObject[] values,\n\t\t\tMutationOperationGroup mutationGroup,\n\t\t\tboolean[] propertyInclusions,\n\t\t\tTableInclusionChecker tableInclusionChecker,\n\t\t\tSharedSessionContractImplementor session) {\n\t\tfinal JdbcValueBindings jdbcValueBindings = mutationExecutor.getJdbcValueBindings();\n\t\tfinal AttributeMappingsList attributeMappings = entityPersister().getAttributeMappings();\n\n\t\tfor ( int position = 0; position < mutationGroup.getNumberOfOperations(); position++ ) {\n\t\t\tfinal MutationOperation operation = mutationGroup.getOperation( position );\n\t\t\tfinal EntityTableMapping tableDetails = (EntityTableMapping) operation.getTableDetails();\n\t\t\tif ( tableInclusionChecker.include( tableDetails ) ) {\n\t\t\t\tfinal int[] attributeIndexes = tableDetails.getAttributeIndexes();\n\t\t\t\tfor ( int i = 0; i < attributeIndexes.length; i++ ) {\n\t\t\t\t\tfinal int attributeIndex = attributeIndexes[ i ];\n\t\t\t\t\tif ( propertyInclusions[attributeIndex] ) {\n\t\t\t\t\t\tfinal AttributeMapping mapping = attributeMappings.get( attributeIndex );\n\t\t\t\t\t\tdecomposeAttribute( values[attributeIndex], session, jdbcValueBindings, mapping );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ( id == null ) {\n\t\t\tassert entityPersister().getInsertDelegate() != null;\n\t\t}\n\t\telse {\n\t\t\tfor ( int position = 0; position < mutationGroup.getNumberOfOperations(); position++ ) {\n\t\t\t\tfinal MutationOperation jdbcOperation = mutationGroup.getOperation( position );\n\t\t\t\tfinal EntityTableMapping tableDetails = (EntityTableMapping) jdbcOperation.getTableDetails();\n\t\t\t\tbreakDownJdbcValue( id, session, jdbcValueBindings, tableDetails );\n\t\t\t}\n\t\t}\n\t}\n\n\tprotected void breakDownJdbcValue(\n\t\t\tObject id,\n\t\t\tSharedSessionContractImplementor session,\n\t\t\tJdbcValueBindings jdbcValueBindings,\n\t\t\tEntityTableMapping tableDetails) {\n\t\tfinal String tableName = tableDetails.getTableName();\n\t\ttableDetails.getKeyMapping().breakDownKeyJdbcValues(\n\t\t\t\tid,\n\t\t\t\t(jdbcValue, columnMapping) -> {\n\t\t\t\t\tjdbcValueBindings.bindValue(\n\t\t\t\t\t\t\tjdbcValue,\n\t\t\t\t\t\t\ttableName,\n\t\t\t\t\t\t\tcolumnMapping.getColumnName(),\n\t\t\t\t\t\t\tParameterUsage.SET\n\t\t\t\t\t);\n\t\t\t\t},\n\t\t\t\tsession\n\t\t);\n\t}\n\n\tprotected void decomposeAttribute(\n\t\t\tObject value,\n\t\t\tSharedSessionContractImplementor session,\n\t\t\tJdbcValueBindings jdbcValueBindings,\n\t\t\tAttributeMapping mapping) {\n\t\tif ( !(mapping instanceof PluralAttributeMapping) ) {\n\t\t\tmapping.decompose(\n\t\t\t\t\tvalue,\n\t\t\t\t\t0,\n\t\t\t\t\tjdbcValueBindings,\n\t\t\t\t\tnull,\n\t\t\t\t\t(valueIndex, bindings, noop, jdbcValue, selectableMapping) -> {\n\t\t\t\t\t\tif ( selectableMapping.isInsertable() ) {\n\t\t\t\t\t\t\tbindings.bindValue(\n\t\t\t\t\t\t\t\t\tjdbcValue,\n\t\t\t\t\t\t\t\t\tentityPersister().physicalTableNameForMutation( selectableMapping ),\n\t\t\t\t\t\t\t\t\tselectableMapping.getSelectionExpression(),\n\t\t\t\t\t\t\t\t\tParameterUsage.SET\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tsession\n\t\t\t);\n\t\t}\n\t}\n\n\tprotected GeneratedValues doDynamicInserts(\n\t\t\tObject id,\n\t\t\tObject[] values,\n\t\t\tObject object,\n\t\t\tSharedSessionContractImplementor session,\n\t\t\tboolean forceIdentifierBinding) {\n\t\tfinal boolean[] insertability = getPropertiesToInsert( values );\n\t\tfinal MutationOperationGroup insertGroup =\n\t\t\t\tgenerateDynamicInsertSqlGroup( insertability, object, session, forceIdentifierBinding );\n\n\t\tfinal MutationExecutor mutationExecutor = executor( session, insertGroup, true );\n\n\t\tfinal InsertValuesAnalysis insertValuesAnalysis = new InsertValuesAnalysis( entityPersister(), values );\n\n\t\tfinal TableInclusionChecker tableInclusionChecker = getTableInclusionChecker( insertValuesAnalysis );\n\n\t\tdecomposeForInsert( mutationExecutor, id, values, insertGroup, insertability, tableInclusionChecker, session );\n\n\t\ttry {\n\t\t\treturn mutationExecutor.execute(\n\t\t\t\t\tobject,\n\t\t\t\t\tinsertValuesAnalysis,\n\t\t\t\t\ttableInclusionChecker,\n\t\t\t\t\tInsertCoordinatorStandard::verifyOutcome,\n\t\t\t\t\tsession\n\t\t\t);\n\t\t}\n\t\tfinally {\n\t\t\tmutationExecutor.release();\n\t\t}\n\t}\n\n\tprivate static boolean verifyOutcome(PreparedStatementDetails statementDetails, int affectedRowCount, int batchPosition)\n\t\t\tthrows SQLException {\n\t\tstatementDetails.getExpectation().verifyOutcome(\n\t\t\t\taffectedRowCount,\n\t\t\t\tstatementDetails.getStatement(),\n\t\t\t\tbatchPosition,\n\t\t\t\tstatementDetails.getSqlString()\n\t\t);\n\t\treturn true;\n\t}\n\n\tprivate MutationExecutor executor(SharedSessionContractImplementor session, MutationOperationGroup group, boolean dynamicUpdate) {\n\t\treturn mutationExecutorService\n\t\t\t\t.createExecutor( resolveBatchKeyAccess( dynamicUpdate, session ), group, session );\n\t}\n\n\tprotected static TableInclusionChecker getTableInclusionChecker(InsertValuesAnalysis insertValuesAnalysis) {\n\t\treturn tableMapping -> !tableMapping.isOptional() || insertValuesAnalysis.hasNonNullBindings( tableMapping );\n\t}\n\n\n\t/**\n\t * Transform the array of property indexes to an array of booleans,\n\t * true when the property is insertable and non-null\n\t */\n\tpublic boolean[] getPropertiesToInsert(Object[] fields) {\n\t\tboolean[] notNull = new boolean[fields.length];\n\t\tboolean[] insertable = entityPersister().getPropertyInsertability();\n\t\tfor ( int i = 0; i < fields.length; i++ ) {\n\t\t\tnotNull[i] = insertable[i] && fields[i] != null;\n\t\t}\n\t\treturn notNull;\n\t}\n\n\tprotected MutationOperationGroup generateDynamicInsertSqlGroup(\n\t\t\tboolean[] insertable,\n\t\t\tObject object,\n\t\t\tSharedSessionContractImplementor session,\n\t\t\tboolean forceIdentifierBinding) {\n\t\tfinal MutationGroupBuilder insertGroupBuilder = new MutationGroupBuilder( MutationType.INSERT, entityPersister() );\n\t\tentityPersister().forEachMutableTable(\n\t\t\t\t(tableMapping) -> insertGroupBuilder.addTableDetailsBuilder( createTableInsertBuilder( tableMapping, forceIdentifierBinding ) )\n\t\t);\n\t\tapplyTableInsertDetails( insertGroupBuilder, insertable, object, session, forceIdentifierBinding );\n\t\treturn createOperationGroup( null, insertGroupBuilder.buildMutationGroup() );\n\t}\n\n\tpublic MutationOperationGroup generateStaticOperationGroup() {\n\t\tfinal MutationGroupBuilder insertGroupBuilder = new MutationGroupBuilder( MutationType.INSERT, entityPersister() );\n\t\tentityPersister().forEachMutableTable(\n\t\t\t\t(tableMapping) -> insertGroupBuilder.addTableDetailsBuilder( createTableInsertBuilder( tableMapping, false ) )\n\t\t);\n\t\tapplyTableInsertDetails( insertGroupBuilder, entityPersister().getPropertyInsertability(), null, null, false );\n\t\treturn createOperationGroup( null, insertGroupBuilder.buildMutationGroup() );\n\t}\n\n\tprivate TableMutationBuilder<?> createTableInsertBuilder(EntityTableMapping tableMapping, boolean forceIdentifierBinding) {\n\t\tfinal GeneratedValuesMutationDelegate delegate = entityPersister().getInsertDelegate();\n\t\tif ( tableMapping.isIdentifierTable() && delegate != null && !forceIdentifierBinding ) {\n\t\t\treturn delegate.createTableMutationBuilder( tableMapping.getInsertExpectation(), factory() );\n\t\t}\n\t\telse {\n\t\t\treturn new TableInsertBuilderStandard( entityPersister(), tableMapping, factory() );\n\t\t}\n\t}\n\n\tprivate void applyTableInsertDetails(\n\t\t\tMutationGroupBuilder insertGroupBuilder,\n\t\t\tboolean[] attributeInclusions,\n\t\t\tObject object,\n\t\t\tSharedSessionContractImplementor session,\n\t\t\tboolean forceIdentifierBinding) {\n\t\tfinal AttributeMappingsList attributeMappings = entityPersister().getAttributeMappings();\n\n\t\tinsertGroupBuilder.forEachTableMutationBuilder( (builder) -> {\n\t\t\tfinal EntityTableMapping tableMapping = (EntityTableMapping) builder.getMutatingTable().getTableMapping();\n\t\t\tassert !tableMapping.isInverse();\n\n\t\t\t// `attributeIndexes` represents the indexes (relative to `attributeMappings`) of\n\t\t\t// the attributes mapped to the table\n\t\t\tfinal int[] attributeIndexes = tableMapping.getAttributeIndexes();\n\t\t\tfor ( int i = 0; i < attributeIndexes.length; i++ ) {\n\t\t\t\tfinal int attributeIndex = attributeIndexes[ i ];\n\t\t\t\tfinal AttributeMapping attributeMapping = attributeMappings.get( attributeIndex );\n\t\t\t\tif ( attributeInclusions[attributeIndex] ) {\n\t\t\t\t\tattributeMapping.forEachInsertable( insertGroupBuilder );\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tfinal Generator generator = attributeMapping.getGenerator();\n\t\t\t\t\tif ( isValueGenerated( generator ) ) {\n\t\t\t\t\t\tif ( session != null && !generator.generatedOnExecution( object, session ) ) {\n\t\t\t\t\t\t\tattributeInclusions[attributeIndex] = true;\n\t\t\t\t\t\t\tattributeMapping.forEachInsertable( insertGroupBuilder );\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if ( isValueGenerationInSql( generator, factory.getJdbcServices().getDialect() ) ) {\n\t\t\t\t\t\t\thandleValueGeneration( attributeMapping, insertGroupBuilder, (OnExecutionGenerator) generator );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\n\t\t// add the discriminator\n\t\tentityPersister().addDiscriminatorToInsertGroup( insertGroupBuilder );\n\t\tentityPersister().addSoftDeleteToInsertGroup( insertGroupBuilder );\n\n\t\t// add the keys\n\t\tinsertGroupBuilder.forEachTableMutationBuilder( (tableMutationBuilder) -> {\n\t\t\tfinal TableInsertBuilder tableInsertBuilder = (TableInsertBuilder) tableMutationBuilder;\n\t\t\tfinal EntityTableMapping tableMapping = (EntityTableMapping) tableInsertBuilder.getMutatingTable().getTableMapping();\n\t\t\tif ( tableMapping.isIdentifierTable() && entityPersister().isIdentifierAssignedByInsert() && !forceIdentifierBinding ) {\n\t\t\t\tassert entityPersister().getInsertDelegate() != null;\n\t\t\t\tfinal OnExecutionGenerator generator = (OnExecutionGenerator) entityPersister().getGenerator();\n\t\t\t\tif ( generator.referenceColumnsInSql( dialect() ) ) {\n\t\t\t\t\tfinal BasicEntityIdentifierMapping identifierMapping = (BasicEntityIdentifierMapping) entityPersister().getIdentifierMapping();\n\t\t\t\t\tfinal String[] columnValues = generator.getReferencedColumnValues( dialect );\n\t\t\t\t\ttableMapping.getKeyMapping().forEachKeyColumn( (i, column) -> tableInsertBuilder.addKeyColumn(\n\t\t\t\t\t\t\tcolumn.getColumnName(),\n\t\t\t\t\t\t\tcolumnValues[i],\n\t\t\t\t\t\t\tidentifierMapping.getJdbcMapping()\n\t\t\t\t\t) );\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttableMapping.getKeyMapping().forEachKeyColumn( tableInsertBuilder::addKeyColumn );\n\t\t\t}\n\t\t} );\n\t}\n\n\tprivate static boolean isValueGenerated(Generator generator) {\n\t\treturn generator != null\n\t\t\t\t&& generator.generatesOnInsert()\n\t\t\t\t&& generator.generatedOnExecution();\n\t}\n\n\tprivate static boolean isValueGenerationInSql(Generator generator, Dialect dialect) {\n\t\tassert isValueGenerated( generator );\n\t\treturn ( (OnExecutionGenerator) generator ).referenceColumnsInSql(dialect);\n\t}\n\n\t/**\n\t * @deprecated Use {@link #getBatchKey()}\n\t */\n\t@Deprecated\n\tpublic BasicBatchKey getInsertBatchKey() {\n\t\treturn batchKey;\n\t}\n}\n",
        "diffSourceCodeSet": [
            "private static boolean verifyOutcome(PreparedStatementDetails statementDetails, int affectedRowCount, int batchPosition)\n\t\t\tthrows SQLException {\n\t\tstatementDetails.getExpectation().verifyOutcome(\n\t\t\t\taffectedRowCount,\n\t\t\t\tstatementDetails.getStatement(),\n\t\t\t\tbatchPosition,\n\t\t\t\tstatementDetails.getSqlString()\n\t\t);\n\t\treturn true;\n\t}"
        ],
        "invokedMethodSet": [
            "methodSignature: org.hibernate.persister.entity.mutation.InsertCoordinatorStandard#decomposeForInsert\n methodBody: protected void decomposeForInsert(\n\t\t\tMutationExecutor mutationExecutor,\n\t\t\tObject id,\n\t\t\tObject[] values,\n\t\t\tMutationOperationGroup mutationGroup,\n\t\t\tboolean[] propertyInclusions,\n\t\t\tTableInclusionChecker tableInclusionChecker,\n\t\t\tSharedSessionContractImplementor session) {\nfinal JdbcValueBindings jdbcValueBindings=mutationExecutor.getJdbcValueBindings();\nfinal AttributeMappingsList attributeMappings=entityPersister().getAttributeMappings();\nfor(int position=0; position < mutationGroup.getNumberOfOperations(); position++){final MutationOperation operation=mutationGroup.getOperation(position);\nfinal EntityTableMapping tableDetails=(EntityTableMapping)operation.getTableDetails();\nif(tableInclusionChecker.include(tableDetails)){final int[] attributeIndexes=tableDetails.getAttributeIndexes();\nfor(int i=0; i < attributeIndexes.length; i++){final int attributeIndex=attributeIndexes[i];\nif(propertyInclusions[attributeIndex]){final AttributeMapping mapping=attributeMappings.get(attributeIndex);\ndecomposeAttribute(values[attributeIndex],session,jdbcValueBindings,mapping);\n}}}}if(id == null){assert entityPersister().getInsertDelegate() != null;\n}{for(int position=0; position < mutationGroup.getNumberOfOperations(); position++){final MutationOperation jdbcOperation=mutationGroup.getOperation(position);\nfinal EntityTableMapping tableDetails=(EntityTableMapping)jdbcOperation.getTableDetails();\nbreakDownJdbcValue(id,session,jdbcValueBindings,tableDetails);\n}}}",
            "methodSignature: org.hibernate.engine.jdbc.mutation.internal.MutationExecutorStandard#release\n methodBody: public void release() {\nnonBatchedStatementGroup.release();\n}",
            "methodSignature: org.hibernate.persister.entity.mutation.InsertCoordinatorStandard#getTableInclusionChecker\n methodBody: protected static TableInclusionChecker getTableInclusionChecker(InsertValuesAnalysis insertValuesAnalysis) {\nreturn tableMapping -> !tableMapping.isOptional() || insertValuesAnalysis.hasNonNullBindings(tableMapping);\n}",
            "methodSignature: org.hibernate.engine.jdbc.mutation.internal.AbstractMutationExecutor#execute\n methodBody: public final GeneratedValues execute(\n\t\t\tObject modelReference,\n\t\t\tValuesAnalysis valuesAnalysis,\n\t\t\tTableInclusionChecker inclusionChecker,\n\t\t\tOperationResultChecker resultChecker,\n\t\t\tSharedSessionContractImplementor session) {\nfinal GeneratedValues generatedValues=performNonBatchedOperations(modelReference,valuesAnalysis,inclusionChecker,resultChecker,session);\nperformSelfExecutingOperations(valuesAnalysis,inclusionChecker,session);\nperformBatchedOperations(valuesAnalysis,inclusionChecker);\nreturn generatedValues;\n}",
            "methodSignature: org.hibernate.orm.test.jpa.transaction.batch.AbstractBatchingTest.BatchWrapper#execute\n methodBody: public void execute() {\nwrapped.execute();\n}",
            "methodSignature: org.hibernate.engine.jdbc.batch.spi.Batch#execute\n methodBody: void execute();",
            "methodSignature: org.hibernate.orm.test.jpa.transaction.batch.AbstractBatchingTest.BatchWrapper#release\n methodBody: public void release() {\nwasReleaseCalled=true;\nwrapped.release();\nnumberOfStatementsAfterRelease=wrapped.getStatementGroup().getNumberOfActiveStatements();\n}",
            "methodSignature: org.hibernate.persister.entity.mutation.AbstractDeleteCoordinator#executor\n methodBody: private MutationExecutor executor(SharedSessionContractImplementor session, MutationOperationGroup group) {\nreturn mutationExecutorService.createExecutor(resolveBatchKeyAccess(false,session),group,session);\n}",
            "methodSignature: org.hibernate.engine.jdbc.batch.internal.BatchImpl#execute\n methodBody: public void execute() {\nnotifyObserversExplicitExecution();\nif(getStatementGroup().getNumberOfStatements() == 0){return;\n}tryif(batchPosition == 0){if(!batchExecuted){if(BATCH_LOGGER.isDebugEnabled()){BATCH_LOGGER.debugf(\"No batched statements to execute - %s\",getKey().toLoggableString());\n}}}{performExecution();\n}finallyreleaseStatements();\n}",
            "methodSignature: org.hibernate.persister.entity.AbstractEntityPersister#getPropertyInsertability\n methodBody: public boolean[] getPropertyInsertability() {\nreturn entityMetamodel.getPropertyInsertability();\n}",
            "methodSignature: org.hibernate.engine.jdbc.batch.spi.Batch#release\n methodBody: void release();",
            "methodSignature: org.hibernate.engine.jdbc.mutation.internal.MutationExecutorSingleBatched#release\n methodBody: public void release() {\n}",
            "methodSignature: org.hibernate.engine.jdbc.mutation.MutationExecutor#release\n methodBody: void release();",
            "methodSignature: org.hibernate.persister.entity.mutation.UpdateCoordinatorStandard#executor\n methodBody: private MutationExecutor executor(SharedSessionContractImplementor session, MutationOperationGroup group, boolean dynamicUpdate) {\nreturn mutationExecutorService.createExecutor(resolveBatchKeyAccess(dynamicUpdate,session),group,session);\n}",
            "methodSignature: org.hibernate.engine.jdbc.batch.internal.BatchImpl#release\n methodBody: public void release() {\nif(BATCH_MESSAGE_LOGGER.isInfoEnabled()){final PreparedStatementGroup statementGroup=getStatementGroup();\nif(statementGroup.getNumberOfStatements() != 0){if(statementGroup.hasMatching((statementDetails) -> statementDetails.getStatement() != null)){BATCH_MESSAGE_LOGGER.batchContainedStatementsOnRelease();\n}}}releaseStatements();\nobservers.clear();\n}",
            "methodSignature: org.hibernate.persister.entity.mutation.AbstractMutationCoordinator#entityPersister\n methodBody: protected EntityPersister entityPersister() {\nreturn entityPersister;\n}",
            "methodSignature: org.hibernate.engine.jdbc.mutation.MutationExecutor#execute\n methodBody: GeneratedValues execute(\n\t\t\tObject modelReference,\n\t\t\tValuesAnalysis valuesAnalysis,\n\t\t\tTableInclusionChecker inclusionChecker,\n\t\t\tOperationResultChecker resultChecker,\n\t\t\tSharedSessionContractImplementor session);",
            "methodSignature: org.hibernate.persister.entity.mutation.InsertCoordinatorStandard#executor\n methodBody: private MutationExecutor executor(SharedSessionContractImplementor session, MutationOperationGroup group, boolean dynamicUpdate) {\nreturn mutationExecutorService.createExecutor(resolveBatchKeyAccess(dynamicUpdate,session),group,session);\n}"
        ],
        "sourceCodeAfterRefactoring": "protected GeneratedValues doStaticInserts(Object id, Object[] values, Object object, SharedSessionContractImplementor session) {\n\t\tfinal InsertValuesAnalysis insertValuesAnalysis = new InsertValuesAnalysis( entityPersister(), values );\n\n\t\tfinal TableInclusionChecker tableInclusionChecker = getTableInclusionChecker( insertValuesAnalysis );\n\n\t\tfinal MutationExecutor mutationExecutor = executor( session, staticInsertGroup, false );\n\n\t\tdecomposeForInsert(\n\t\t\t\tmutationExecutor,\n\t\t\t\tid,\n\t\t\t\tvalues,\n\t\t\t\tstaticInsertGroup,\n\t\t\t\tentityPersister().getPropertyInsertability(),\n\t\t\t\ttableInclusionChecker,\n\t\t\t\tsession\n\t\t);\n\n\t\ttry {\n\t\t\treturn mutationExecutor.execute(\n\t\t\t\t\tobject,\n\t\t\t\t\tinsertValuesAnalysis,\n\t\t\t\t\ttableInclusionChecker,\n\t\t\t\t\tInsertCoordinatorStandard::verifyOutcome,\n\t\t\t\t\tsession\n\t\t\t);\n\t\t}\n\t\tfinally {\n\t\t\tmutationExecutor.release();\n\t\t}\n\t}\nprivate static boolean verifyOutcome(PreparedStatementDetails statementDetails, int affectedRowCount, int batchPosition)\n\t\t\tthrows SQLException {\n\t\tstatementDetails.getExpectation().verifyOutcome(\n\t\t\t\taffectedRowCount,\n\t\t\t\tstatementDetails.getStatement(),\n\t\t\t\tbatchPosition,\n\t\t\t\tstatementDetails.getSqlString()\n\t\t);\n\t\treturn true;\n\t}",
        "diffSourceCode": "-  173: \tprotected GeneratedValues doStaticInserts(Object id, Object[] values, Object object, SharedSessionContractImplementor session) {\n-  174: \t\tfinal InsertValuesAnalysis insertValuesAnalysis = new InsertValuesAnalysis( entityPersister(), values );\n-  175: \n-  176: \t\tfinal TableInclusionChecker tableInclusionChecker = getTableInclusionChecker( insertValuesAnalysis );\n+  173: \t}\n+  174: \n+  175: \tprotected GeneratedValues doStaticInserts(Object id, Object[] values, Object object, SharedSessionContractImplementor session) {\n+  176: \t\tfinal InsertValuesAnalysis insertValuesAnalysis = new InsertValuesAnalysis( entityPersister(), values );\n   177: \n-  178: \t\tfinal MutationExecutor mutationExecutor = executor( session, staticInsertGroup, false );\n+  178: \t\tfinal TableInclusionChecker tableInclusionChecker = getTableInclusionChecker( insertValuesAnalysis );\n   179: \n-  180: \t\tdecomposeForInsert(\n-  181: \t\t\t\tmutationExecutor,\n-  182: \t\t\t\tid,\n-  183: \t\t\t\tvalues,\n-  184: \t\t\t\tstaticInsertGroup,\n-  185: \t\t\t\tentityPersister().getPropertyInsertability(),\n-  186: \t\t\t\ttableInclusionChecker,\n-  187: \t\t\t\tsession\n-  188: \t\t);\n-  189: \n-  190: \t\ttry {\n-  191: \t\t\treturn mutationExecutor.execute(\n-  192: \t\t\t\t\tobject,\n-  193: \t\t\t\t\tinsertValuesAnalysis,\n-  194: \t\t\t\t\ttableInclusionChecker,\n-  195: \t\t\t\t\t(statementDetails, affectedRowCount, batchPosition) -> {\n-  196: \t\t\t\t\t\tstatementDetails.getExpectation().verifyOutcome(\n-  197: \t\t\t\t\t\t\t\taffectedRowCount,\n-  198: \t\t\t\t\t\t\t\tstatementDetails.getStatement(),\n-  199: \t\t\t\t\t\t\t\tbatchPosition,\n-  200: \t\t\t\t\t\t\t\tstatementDetails.getSqlString()\n-  201: \t\t\t\t\t\t);\n-  202: \t\t\t\t\t\treturn true;\n-  203: \t\t\t\t\t},\n-  204: \t\t\t\t\tsession\n-  205: \t\t\t);\n-  206: \t\t}\n-  207: \t\tfinally {\n-  208: \t\t\tmutationExecutor.release();\n-  209: \t\t}\n-  210: \t}\n-  322: \t\t\t\t\t\t\t\tbatchPosition,\n-  323: \t\t\t\t\t\t\t\tstatementDetails.getSqlString()\n-  324: \t\t\t\t\t\t);\n-  325: \t\t\t\t\t\treturn true;\n-  326: \t\t\t\t\t},\n-  327: \t\t\t\t\tsession\n-  328: \t\t\t);\n-  329: \t\t}\n-  330: \t\tfinally {\n-  331: \t\t\tmutationExecutor.release();\n+  180: \t\tfinal MutationExecutor mutationExecutor = executor( session, staticInsertGroup, false );\n+  181: \n+  182: \t\tdecomposeForInsert(\n+  183: \t\t\t\tmutationExecutor,\n+  184: \t\t\t\tid,\n+  185: \t\t\t\tvalues,\n+  186: \t\t\t\tstaticInsertGroup,\n+  187: \t\t\t\tentityPersister().getPropertyInsertability(),\n+  188: \t\t\t\ttableInclusionChecker,\n+  189: \t\t\t\tsession\n+  190: \t\t);\n+  191: \n+  192: \t\ttry {\n+  193: \t\t\treturn mutationExecutor.execute(\n+  194: \t\t\t\t\tobject,\n+  195: \t\t\t\t\tinsertValuesAnalysis,\n+  196: \t\t\t\t\ttableInclusionChecker,\n+  197: \t\t\t\t\tInsertCoordinatorStandard::verifyOutcome,\n+  198: \t\t\t\t\tsession\n+  199: \t\t\t);\n+  200: \t\t}\n+  201: \t\tfinally {\n+  202: \t\t\tmutationExecutor.release();\n+  203: \t\t}\n+  204: \t}\n+  205: \n+  206: \tprotected void decomposeForInsert(\n+  207: \t\t\tMutationExecutor mutationExecutor,\n+  208: \t\t\tObject id,\n+  209: \t\t\tObject[] values,\n+  210: \t\t\tMutationOperationGroup mutationGroup,\n+  322: \tprivate static boolean verifyOutcome(PreparedStatementDetails statementDetails, int affectedRowCount, int batchPosition)\n+  323: \t\t\tthrows SQLException {\n+  324: \t\tstatementDetails.getExpectation().verifyOutcome(\n+  325: \t\t\t\taffectedRowCount,\n+  326: \t\t\t\tstatementDetails.getStatement(),\n+  327: \t\t\t\tbatchPosition,\n+  328: \t\t\t\tstatementDetails.getSqlString()\n+  329: \t\t);\n+  330: \t\treturn true;\n+  331: \t}\n",
        "uniqueId": "ee00217733018075ccade7e1145f45ff9acae0c2_173_210_322_331_175_204",
        "moveFileExist": true,
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 21,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 0,
                "covered": 41
            },
            "LINE": {
                "missed": 0,
                "covered": 7
            },
            "COMPLEXITY": {
                "missed": 0,
                "covered": 1
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        }
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tpublic execute(modelReference Object, valuesAnalysis ValuesAnalysis, inclusionChecker TableInclusionChecker, resultChecker OperationResultChecker, session SharedSessionContractImplementor, staleStateMapper Batch.StaleStateMapper) : GeneratedValues extracted from public execute(modelReference Object, valuesAnalysis ValuesAnalysis, inclusionChecker TableInclusionChecker, resultChecker OperationResultChecker, session SharedSessionContractImplementor) : GeneratedValues in class org.hibernate.engine.jdbc.mutation.internal.AbstractMutationExecutor",
        "diffLocations": [
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/engine/jdbc/mutation/internal/AbstractMutationExecutor.java",
                "startLine": 41,
                "endLine": 65,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/engine/jdbc/mutation/internal/AbstractMutationExecutor.java",
                "startLine": 43,
                "endLine": 58,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/engine/jdbc/mutation/internal/AbstractMutationExecutor.java",
                "startLine": 60,
                "endLine": 78,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "/**\n\t * Templated implementation of execution as <ol>\n\t *     <li>{@link #performNonBatchedOperations}</li>\n\t *     <li>{@link #performSelfExecutingOperations}</li>\n\t *     <li>{@link #performBatchedOperations}</li>\n\t * </ol>\n\t */\n\t@Override\n\tpublic final GeneratedValues execute(\n\t\t\tObject modelReference,\n\t\t\tValuesAnalysis valuesAnalysis,\n\t\t\tTableInclusionChecker inclusionChecker,\n\t\t\tOperationResultChecker resultChecker,\n\t\t\tSharedSessionContractImplementor session) {\n\t\tfinal GeneratedValues generatedValues = performNonBatchedOperations(\n\t\t\t\tmodelReference,\n\t\t\t\tvaluesAnalysis,\n\t\t\t\tinclusionChecker,\n\t\t\t\tresultChecker,\n\t\t\t\tsession\n\t\t);\n\t\tperformSelfExecutingOperations( valuesAnalysis, inclusionChecker, session );\n\t\tperformBatchedOperations( valuesAnalysis, inclusionChecker );\n\t\treturn generatedValues;\n\t}",
        "filePathBefore": "hibernate-core/src/main/java/org/hibernate/engine/jdbc/mutation/internal/AbstractMutationExecutor.java",
        "isPureRefactoring": true,
        "commitId": "ee00217733018075ccade7e1145f45ff9acae0c2",
        "packageNameBefore": "org.hibernate.engine.jdbc.mutation.internal",
        "classNameBefore": "org.hibernate.engine.jdbc.mutation.internal.AbstractMutationExecutor",
        "methodNameBefore": "org.hibernate.engine.jdbc.mutation.internal.AbstractMutationExecutor#execute",
        "invokedMethod": "methodSignature: org.hibernate.engine.jdbc.mutation.internal.AbstractMutationExecutor#performNonBatchedOperations\n methodBody: protected GeneratedValues performNonBatchedOperations(\n\t\t\tObject modelReference,\n\t\t\tValuesAnalysis valuesAnalysis,\n\t\t\tTableInclusionChecker inclusionChecker,\n\t\t\tOperationResultChecker resultChecker,\n\t\t\tSharedSessionContractImplementor session) {\nreturn null;\n}\nmethodSignature: org.hibernate.engine.jdbc.mutation.internal.MutationExecutorStandard#performNonBatchedOperations\n methodBody: protected GeneratedValues performNonBatchedOperations(\n\t\t\tObject modelReference,\n\t\t\tValuesAnalysis valuesAnalysis,\n\t\t\tTableInclusionChecker inclusionChecker,\n\t\t\tOperationResultChecker resultChecker,\n\t\t\tSharedSessionContractImplementor session) {\nif(nonBatchedStatementGroup == null || nonBatchedStatementGroup.getNumberOfStatements() <= 0){return null;\n}final GeneratedValues generatedValues;\nif(generatedValuesDelegate != null){final EntityMutationOperationGroup entityGroup=mutationOperationGroup.asEntityMutationOperationGroup();\nfinal EntityMutationTarget entityTarget=entityGroup.getMutationTarget();\nfinal PreparedStatementDetails details=nonBatchedStatementGroup.getPreparedStatementDetails(entityTarget.getIdentifierTableName());\ngeneratedValues=generatedValuesDelegate.performMutation(details,valueBindings,modelReference,session);\nfinal Object id=entityGroup.getMutationType() == MutationType.INSERT && details.getMutatingTableDetails().isIdentifierTable() ? generatedValues.getGeneratedValue(entityTarget.getTargetPart().getIdentifierMapping()) : null;\nnonBatchedStatementGroup.forEachStatement((tableName,statementDetails) -> {\n  if (!statementDetails.getMutatingTableDetails().isIdentifierTable()) {\n    performNonBatchedMutation(statementDetails,id,valueBindings,inclusionChecker,resultChecker,session);\n  }\n}\n);\n}{generatedValues=null;\nnonBatchedStatementGroup.forEachStatement((tableName,statementDetails) -> performNonBatchedMutation(statementDetails,null,valueBindings,inclusionChecker,resultChecker,session));\n}return generatedValues;\n}\nmethodSignature: org.hibernate.engine.jdbc.mutation.internal.MutationExecutorStandard#performSelfExecutingOperations\n methodBody: protected void performSelfExecutingOperations(ValuesAnalysis valuesAnalysis, TableInclusionChecker inclusionChecker, SharedSessionContractImplementor session) {\nif(selfExecutingMutations == null || selfExecutingMutations.isEmpty()){return;\n}for(int i=0; i < selfExecutingMutations.size(); i++){final SelfExecutingUpdateOperation operation=selfExecutingMutations.get(i);\nif(inclusionChecker.include(operation.getTableDetails())){operation.performMutation(valueBindings,valuesAnalysis,session);\n}}}\nmethodSignature: org.hibernate.engine.jdbc.mutation.internal.MutationExecutorStandard#performBatchedOperations\n methodBody: protected void performBatchedOperations(\n\t\t\tValuesAnalysis valuesAnalysis,\n\t\t\tTableInclusionChecker inclusionChecker) {\nif(batch == null){return;\n}batch.addToBatch(valueBindings,inclusionChecker);\n}\nmethodSignature: org.hibernate.engine.jdbc.mutation.internal.MutationExecutorSingleBatched#performBatchedOperations\n methodBody: protected void performBatchedOperations(ValuesAnalysis valuesAnalysis, TableInclusionChecker inclusionChecker) {\nresolveBatch().addToBatch(getJdbcValueBindings(),inclusionChecker);\n}\nmethodSignature: org.hibernate.engine.jdbc.mutation.internal.AbstractMutationExecutor#performSelfExecutingOperations\n methodBody: protected void performSelfExecutingOperations(\n\t\t\tValuesAnalysis valuesAnalysis,\n\t\t\tTableInclusionChecker inclusionChecker,\n\t\t\tSharedSessionContractImplementor session) {\n}\nmethodSignature: org.hibernate.engine.jdbc.mutation.internal.AbstractMutationExecutor#performBatchedOperations\n methodBody: protected void performBatchedOperations(\n\t\t\tValuesAnalysis valuesAnalysis,\n\t\t\tTableInclusionChecker inclusionChecker) {\n}",
        "classSignatureBefore": "public abstract class AbstractMutationExecutor implements MutationExecutor ",
        "methodNameBeforeSet": [
            "org.hibernate.engine.jdbc.mutation.internal.AbstractMutationExecutor#execute"
        ],
        "classNameBeforeSet": [
            "org.hibernate.engine.jdbc.mutation.internal.AbstractMutationExecutor"
        ],
        "classSignatureBeforeSet": [
            "public abstract class AbstractMutationExecutor implements MutationExecutor "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Overlapped refactoring - can be identical by undoing the overlapped refactoring\n- Add Parameter-",
                "description": "Parametrization or Add Parameter on top of the extract method - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n * See the lgpl.txt file in the root directory or http://www.gnu.org/licenses/lgpl-2.1.html.\n */\npackage org.hibernate.engine.jdbc.mutation.internal;\n\nimport java.sql.SQLException;\n\nimport org.hibernate.engine.jdbc.batch.spi.BatchKey;\nimport org.hibernate.engine.jdbc.mutation.JdbcValueBindings;\nimport org.hibernate.engine.jdbc.mutation.MutationExecutor;\nimport org.hibernate.engine.jdbc.mutation.OperationResultChecker;\nimport org.hibernate.engine.jdbc.mutation.ParameterUsage;\nimport org.hibernate.engine.jdbc.mutation.TableInclusionChecker;\nimport org.hibernate.engine.jdbc.mutation.group.PreparedStatementDetails;\nimport org.hibernate.engine.spi.SharedSessionContractImplementor;\nimport org.hibernate.generator.values.GeneratedValues;\nimport org.hibernate.persister.entity.mutation.EntityTableMapping;\nimport org.hibernate.sql.model.TableMapping;\nimport org.hibernate.sql.model.ValuesAnalysis;\n\nimport static org.hibernate.sql.model.ModelMutationLogging.MODEL_MUTATION_LOGGER;\n\n/**\n * Base support for MutationExecutor implementations\n *\n * @author Steve Ebersole\n */\npublic abstract class AbstractMutationExecutor implements MutationExecutor {\n\t/**\n\t * Executors with non-batched operations should call this to clean up any \"previous\" batch\n\t * before starting their work\n\t */\n\tprotected void prepareForNonBatchedWork(BatchKey batchKey, SharedSessionContractImplementor session) {\n\t\t// if there is a current batch, make sure to execute it first\n\t\tsession.getJdbcCoordinator().conditionallyExecuteBatch( batchKey );\n\t}\n\n\t/**\n\t * Templated implementation of execution as <ol>\n\t *     <li>{@link #performNonBatchedOperations}</li>\n\t *     <li>{@link #performSelfExecutingOperations}</li>\n\t *     <li>{@link #performBatchedOperations}</li>\n\t * </ol>\n\t */\n\t@Override\n\tpublic final GeneratedValues execute(\n\t\t\tObject modelReference,\n\t\t\tValuesAnalysis valuesAnalysis,\n\t\t\tTableInclusionChecker inclusionChecker,\n\t\t\tOperationResultChecker resultChecker,\n\t\t\tSharedSessionContractImplementor session) {\n\t\tfinal GeneratedValues generatedValues = performNonBatchedOperations(\n\t\t\t\tmodelReference,\n\t\t\t\tvaluesAnalysis,\n\t\t\t\tinclusionChecker,\n\t\t\t\tresultChecker,\n\t\t\t\tsession\n\t\t);\n\t\tperformSelfExecutingOperations( valuesAnalysis, inclusionChecker, session );\n\t\tperformBatchedOperations( valuesAnalysis, inclusionChecker );\n\t\treturn generatedValues;\n\t}\n\n\tprotected GeneratedValues performNonBatchedOperations(\n\t\t\tObject modelReference,\n\t\t\tValuesAnalysis valuesAnalysis,\n\t\t\tTableInclusionChecker inclusionChecker,\n\t\t\tOperationResultChecker resultChecker,\n\t\t\tSharedSessionContractImplementor session) {\n\t\treturn null;\n\t}\n\n\tprotected void performSelfExecutingOperations(\n\t\t\tValuesAnalysis valuesAnalysis,\n\t\t\tTableInclusionChecker inclusionChecker,\n\t\t\tSharedSessionContractImplementor session) {\n\t}\n\n\tprotected void performBatchedOperations(\n\t\t\tValuesAnalysis valuesAnalysis,\n\t\t\tTableInclusionChecker inclusionChecker) {\n\t}\n\n\t/**\n\t * Perform a non-batched mutation\n\t */\n\tprotected void performNonBatchedMutation(\n\t\t\tPreparedStatementDetails statementDetails,\n\t\t\tObject id,\n\t\t\tJdbcValueBindings valueBindings,\n\t\t\tTableInclusionChecker inclusionChecker,\n\t\t\tOperationResultChecker resultChecker,\n\t\t\tSharedSessionContractImplementor session) {\n\t\tif ( statementDetails == null ) {\n\t\t\treturn;\n\t\t}\n\n\t\tfinal TableMapping tableDetails = statementDetails.getMutatingTableDetails();\n\t\tif ( inclusionChecker != null && !inclusionChecker.include( tableDetails ) ) {\n\t\t\tif ( MODEL_MUTATION_LOGGER.isTraceEnabled() ) {\n\t\t\t\tMODEL_MUTATION_LOGGER.tracef(\n\t\t\t\t\t\t\"Skipping execution of secondary insert : %s\",\n\t\t\t\t\t\ttableDetails.getTableName()\n\t\t\t\t);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tif ( id != null ) {\n\t\t\tassert !tableDetails.isIdentifierTable() : \"Unsupported identifier table with generated id\";\n\t\t\t( (EntityTableMapping) tableDetails ).getKeyMapping().breakDownKeyJdbcValues(\n\t\t\t\t\tid,\n\t\t\t\t\t(jdbcValue, columnMapping) -> valueBindings.bindValue(\n\t\t\t\t\t\t\tjdbcValue,\n\t\t\t\t\t\t\ttableDetails.getTableName(),\n\t\t\t\t\t\t\tcolumnMapping.getColumnName(),\n\t\t\t\t\t\t\tParameterUsage.SET\n\t\t\t\t\t),\n\t\t\t\t\tsession\n\t\t\t);\n\t\t}\n\n\t\t// If we get here the statement is needed - make sure it is resolved\n\t\tsession.getJdbcServices().getSqlStatementLogger().logStatement( statementDetails.getSqlString() );\n\n\t\ttry {\n\t\t\tvalueBindings.beforeStatement( statementDetails );\n\n\t\t\tfinal int affectedRowCount = session.getJdbcCoordinator()\n\t\t\t\t\t.getResultSetReturn()\n\t\t\t\t\t.executeUpdate( statementDetails.getStatement(), statementDetails.getSqlString() );\n\n\t\t\tif ( affectedRowCount == 0 && tableDetails.isOptional() ) {\n\t\t\t\t// the optional table did not have a row\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tModelMutationHelper.checkResults( resultChecker, statementDetails, affectedRowCount, -1 );\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow session.getJdbcServices().getSqlExceptionHelper().convert(\n\t\t\t\t\te,\n\t\t\t\t\tString.format(\n\t\t\t\t\t\t\t\"Unable to execute mutation PreparedStatement against table `%s`\",\n\t\t\t\t\t\t\ttableDetails.getTableName()\n\t\t\t\t\t),\n\t\t\t\t\tstatementDetails.getSqlString()\n\t\t\t);\n\t\t}\n\t\tfinally {\n\t\t\tif ( statementDetails.getStatement() != null ) {\n\t\t\t\tstatementDetails.releaseStatement( session );\n\t\t\t}\n\t\t\tvalueBindings.afterStatement( tableDetails );\n\t\t}\n\t}\n}\n",
        "filePathAfter": "hibernate-core/src/main/java/org/hibernate/engine/jdbc/mutation/internal/AbstractMutationExecutor.java",
        "sourceCodeAfterForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n * See the lgpl.txt file in the root directory or http://www.gnu.org/licenses/lgpl-2.1.html.\n */\npackage org.hibernate.engine.jdbc.mutation.internal;\n\nimport java.sql.SQLException;\n\nimport org.hibernate.engine.jdbc.batch.spi.Batch;\nimport org.hibernate.engine.jdbc.batch.spi.BatchKey;\nimport org.hibernate.engine.jdbc.mutation.JdbcValueBindings;\nimport org.hibernate.engine.jdbc.mutation.MutationExecutor;\nimport org.hibernate.engine.jdbc.mutation.OperationResultChecker;\nimport org.hibernate.engine.jdbc.mutation.ParameterUsage;\nimport org.hibernate.engine.jdbc.mutation.TableInclusionChecker;\nimport org.hibernate.engine.jdbc.mutation.group.PreparedStatementDetails;\nimport org.hibernate.engine.spi.SharedSessionContractImplementor;\nimport org.hibernate.generator.values.GeneratedValues;\nimport org.hibernate.persister.entity.mutation.EntityTableMapping;\nimport org.hibernate.sql.model.TableMapping;\nimport org.hibernate.sql.model.ValuesAnalysis;\n\nimport static org.hibernate.engine.jdbc.mutation.internal.ModelMutationHelper.checkResults;\nimport static org.hibernate.sql.model.ModelMutationLogging.MODEL_MUTATION_LOGGER;\n\n/**\n * Base support for MutationExecutor implementations\n *\n * @author Steve Ebersole\n */\npublic abstract class AbstractMutationExecutor implements MutationExecutor {\n\t/**\n\t * Executors with non-batched operations should call this to clean up any \"previous\" batch\n\t * before starting their work\n\t */\n\tprotected void prepareForNonBatchedWork(BatchKey batchKey, SharedSessionContractImplementor session) {\n\t\t// if there is a current batch, make sure to execute it first\n\t\tsession.getJdbcCoordinator().conditionallyExecuteBatch( batchKey );\n\t}\n\n\t/**\n\t * Templated implementation of execution as <ol>\n\t *     <li>{@link #performNonBatchedOperations}</li>\n\t *     <li>{@link #performSelfExecutingOperations}</li>\n\t *     <li>{@link #performBatchedOperations}</li>\n\t * </ol>\n\t */\n\t@Override\n\tpublic final GeneratedValues execute(\n\t\t\tObject modelReference,\n\t\t\tValuesAnalysis valuesAnalysis,\n\t\t\tTableInclusionChecker inclusionChecker,\n\t\t\tOperationResultChecker resultChecker,\n\t\t\tSharedSessionContractImplementor session) {\n\t\treturn execute( modelReference, valuesAnalysis, inclusionChecker, resultChecker, session, null );\n\t}\n\n\t@Override\n\tpublic final GeneratedValues execute(\n\t\t\tObject modelReference,\n\t\t\tValuesAnalysis valuesAnalysis,\n\t\t\tTableInclusionChecker inclusionChecker,\n\t\t\tOperationResultChecker resultChecker,\n\t\t\tSharedSessionContractImplementor session,\n\t\t\tBatch.StaleStateMapper staleStateMapper) {\n\t\tfinal GeneratedValues generatedValues = performNonBatchedOperations(\n\t\t\t\tmodelReference,\n\t\t\t\tvaluesAnalysis,\n\t\t\t\tinclusionChecker,\n\t\t\t\tresultChecker,\n\t\t\t\tsession\n\t\t);\n\t\tperformSelfExecutingOperations( valuesAnalysis, inclusionChecker, session );\n\t\tperformBatchedOperations( valuesAnalysis, inclusionChecker, staleStateMapper );\n\t\treturn generatedValues;\n\t}\n\n\n\n\tprotected GeneratedValues performNonBatchedOperations(\n\t\t\tObject modelReference,\n\t\t\tValuesAnalysis valuesAnalysis,\n\t\t\tTableInclusionChecker inclusionChecker,\n\t\t\tOperationResultChecker resultChecker,\n\t\t\tSharedSessionContractImplementor session) {\n\t\treturn null;\n\t}\n\n\tprotected void performSelfExecutingOperations(\n\t\t\tValuesAnalysis valuesAnalysis,\n\t\t\tTableInclusionChecker inclusionChecker,\n\t\t\tSharedSessionContractImplementor session) {\n\t}\n\n\tprotected void performBatchedOperations(\n\t\t\tValuesAnalysis valuesAnalysis,\n\t\t\tTableInclusionChecker inclusionChecker,\n\t\t\tBatch.StaleStateMapper staleStateMapper) {\n\t}\n\n\t/**\n\t * Perform a non-batched mutation\n\t */\n\tprotected void performNonBatchedMutation(\n\t\t\tPreparedStatementDetails statementDetails,\n\t\t\tObject id,\n\t\t\tJdbcValueBindings valueBindings,\n\t\t\tTableInclusionChecker inclusionChecker,\n\t\t\tOperationResultChecker resultChecker,\n\t\t\tSharedSessionContractImplementor session) {\n\t\tif ( statementDetails == null ) {\n\t\t\treturn;\n\t\t}\n\n\t\tfinal TableMapping tableDetails = statementDetails.getMutatingTableDetails();\n\t\tif ( inclusionChecker != null && !inclusionChecker.include( tableDetails ) ) {\n\t\t\tif ( MODEL_MUTATION_LOGGER.isTraceEnabled() ) {\n\t\t\t\tMODEL_MUTATION_LOGGER.tracef(\n\t\t\t\t\t\t\"Skipping execution of secondary insert : %s\",\n\t\t\t\t\t\ttableDetails.getTableName()\n\t\t\t\t);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tif ( id != null ) {\n\t\t\tassert !tableDetails.isIdentifierTable() : \"Unsupported identifier table with generated id\";\n\t\t\t( (EntityTableMapping) tableDetails ).getKeyMapping().breakDownKeyJdbcValues(\n\t\t\t\t\tid,\n\t\t\t\t\t(jdbcValue, columnMapping) -> valueBindings.bindValue(\n\t\t\t\t\t\t\tjdbcValue,\n\t\t\t\t\t\t\ttableDetails.getTableName(),\n\t\t\t\t\t\t\tcolumnMapping.getColumnName(),\n\t\t\t\t\t\t\tParameterUsage.SET\n\t\t\t\t\t),\n\t\t\t\t\tsession\n\t\t\t);\n\t\t}\n\n\t\t// If we get here the statement is needed - make sure it is resolved\n\t\tsession.getJdbcServices().getSqlStatementLogger().logStatement( statementDetails.getSqlString() );\n\n\t\ttry {\n\t\t\tvalueBindings.beforeStatement( statementDetails );\n\n\t\t\tfinal int affectedRowCount = session.getJdbcCoordinator()\n\t\t\t\t\t.getResultSetReturn()\n\t\t\t\t\t.executeUpdate( statementDetails.getStatement(), statementDetails.getSqlString() );\n\n\t\t\tif ( affectedRowCount == 0 && tableDetails.isOptional() ) {\n\t\t\t\t// the optional table did not have a row\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tcheckResults( resultChecker, statementDetails, affectedRowCount, -1 );\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow session.getJdbcServices().getSqlExceptionHelper().convert(\n\t\t\t\t\te,\n\t\t\t\t\tString.format(\n\t\t\t\t\t\t\t\"Unable to execute mutation PreparedStatement against table `%s`\",\n\t\t\t\t\t\t\ttableDetails.getTableName()\n\t\t\t\t\t),\n\t\t\t\t\tstatementDetails.getSqlString()\n\t\t\t);\n\t\t}\n\t\tfinally {\n\t\t\tif ( statementDetails.getStatement() != null ) {\n\t\t\t\tstatementDetails.releaseStatement( session );\n\t\t\t}\n\t\t\tvalueBindings.afterStatement( tableDetails );\n\t\t}\n\t}\n}\n",
        "diffSourceCodeSet": [
            "@Override\n\tpublic final GeneratedValues execute(\n\t\t\tObject modelReference,\n\t\t\tValuesAnalysis valuesAnalysis,\n\t\t\tTableInclusionChecker inclusionChecker,\n\t\t\tOperationResultChecker resultChecker,\n\t\t\tSharedSessionContractImplementor session,\n\t\t\tBatch.StaleStateMapper staleStateMapper) {\n\t\tfinal GeneratedValues generatedValues = performNonBatchedOperations(\n\t\t\t\tmodelReference,\n\t\t\t\tvaluesAnalysis,\n\t\t\t\tinclusionChecker,\n\t\t\t\tresultChecker,\n\t\t\t\tsession\n\t\t);\n\t\tperformSelfExecutingOperations( valuesAnalysis, inclusionChecker, session );\n\t\tperformBatchedOperations( valuesAnalysis, inclusionChecker, staleStateMapper );\n\t\treturn generatedValues;\n\t}"
        ],
        "invokedMethodSet": [
            "methodSignature: org.hibernate.engine.jdbc.mutation.internal.AbstractMutationExecutor#performNonBatchedOperations\n methodBody: protected GeneratedValues performNonBatchedOperations(\n\t\t\tObject modelReference,\n\t\t\tValuesAnalysis valuesAnalysis,\n\t\t\tTableInclusionChecker inclusionChecker,\n\t\t\tOperationResultChecker resultChecker,\n\t\t\tSharedSessionContractImplementor session) {\nreturn null;\n}",
            "methodSignature: org.hibernate.engine.jdbc.mutation.internal.MutationExecutorStandard#performNonBatchedOperations\n methodBody: protected GeneratedValues performNonBatchedOperations(\n\t\t\tObject modelReference,\n\t\t\tValuesAnalysis valuesAnalysis,\n\t\t\tTableInclusionChecker inclusionChecker,\n\t\t\tOperationResultChecker resultChecker,\n\t\t\tSharedSessionContractImplementor session) {\nif(nonBatchedStatementGroup == null || nonBatchedStatementGroup.getNumberOfStatements() <= 0){return null;\n}final GeneratedValues generatedValues;\nif(generatedValuesDelegate != null){final EntityMutationOperationGroup entityGroup=mutationOperationGroup.asEntityMutationOperationGroup();\nfinal EntityMutationTarget entityTarget=entityGroup.getMutationTarget();\nfinal PreparedStatementDetails details=nonBatchedStatementGroup.getPreparedStatementDetails(entityTarget.getIdentifierTableName());\ngeneratedValues=generatedValuesDelegate.performMutation(details,valueBindings,modelReference,session);\nfinal Object id=entityGroup.getMutationType() == MutationType.INSERT && details.getMutatingTableDetails().isIdentifierTable() ? generatedValues.getGeneratedValue(entityTarget.getTargetPart().getIdentifierMapping()) : null;\nnonBatchedStatementGroup.forEachStatement((tableName,statementDetails) -> {\n  if (!statementDetails.getMutatingTableDetails().isIdentifierTable()) {\n    performNonBatchedMutation(statementDetails,id,valueBindings,inclusionChecker,resultChecker,session);\n  }\n}\n);\n}{generatedValues=null;\nnonBatchedStatementGroup.forEachStatement((tableName,statementDetails) -> performNonBatchedMutation(statementDetails,null,valueBindings,inclusionChecker,resultChecker,session));\n}return generatedValues;\n}",
            "methodSignature: org.hibernate.engine.jdbc.mutation.internal.MutationExecutorStandard#performSelfExecutingOperations\n methodBody: protected void performSelfExecutingOperations(ValuesAnalysis valuesAnalysis, TableInclusionChecker inclusionChecker, SharedSessionContractImplementor session) {\nif(selfExecutingMutations == null || selfExecutingMutations.isEmpty()){return;\n}for(int i=0; i < selfExecutingMutations.size(); i++){final SelfExecutingUpdateOperation operation=selfExecutingMutations.get(i);\nif(inclusionChecker.include(operation.getTableDetails())){operation.performMutation(valueBindings,valuesAnalysis,session);\n}}}",
            "methodSignature: org.hibernate.engine.jdbc.mutation.internal.MutationExecutorStandard#performBatchedOperations\n methodBody: protected void performBatchedOperations(\n\t\t\tValuesAnalysis valuesAnalysis,\n\t\t\tTableInclusionChecker inclusionChecker) {\nif(batch == null){return;\n}batch.addToBatch(valueBindings,inclusionChecker);\n}",
            "methodSignature: org.hibernate.engine.jdbc.mutation.internal.MutationExecutorSingleBatched#performBatchedOperations\n methodBody: protected void performBatchedOperations(ValuesAnalysis valuesAnalysis, TableInclusionChecker inclusionChecker) {\nresolveBatch().addToBatch(getJdbcValueBindings(),inclusionChecker);\n}",
            "methodSignature: org.hibernate.engine.jdbc.mutation.internal.AbstractMutationExecutor#performSelfExecutingOperations\n methodBody: protected void performSelfExecutingOperations(\n\t\t\tValuesAnalysis valuesAnalysis,\n\t\t\tTableInclusionChecker inclusionChecker,\n\t\t\tSharedSessionContractImplementor session) {\n}",
            "methodSignature: org.hibernate.engine.jdbc.mutation.internal.AbstractMutationExecutor#performBatchedOperations\n methodBody: protected void performBatchedOperations(\n\t\t\tValuesAnalysis valuesAnalysis,\n\t\t\tTableInclusionChecker inclusionChecker) {\n}"
        ],
        "sourceCodeAfterRefactoring": "/**\n\t * Templated implementation of execution as <ol>\n\t *     <li>{@link #performNonBatchedOperations}</li>\n\t *     <li>{@link #performSelfExecutingOperations}</li>\n\t *     <li>{@link #performBatchedOperations}</li>\n\t * </ol>\n\t */\n\t@Override\n\tpublic final GeneratedValues execute(\n\t\t\tObject modelReference,\n\t\t\tValuesAnalysis valuesAnalysis,\n\t\t\tTableInclusionChecker inclusionChecker,\n\t\t\tOperationResultChecker resultChecker,\n\t\t\tSharedSessionContractImplementor session) {\n\t\treturn execute( modelReference, valuesAnalysis, inclusionChecker, resultChecker, session, null );\n\t}\n@Override\n\tpublic final GeneratedValues execute(\n\t\t\tObject modelReference,\n\t\t\tValuesAnalysis valuesAnalysis,\n\t\t\tTableInclusionChecker inclusionChecker,\n\t\t\tOperationResultChecker resultChecker,\n\t\t\tSharedSessionContractImplementor session,\n\t\t\tBatch.StaleStateMapper staleStateMapper) {\n\t\tfinal GeneratedValues generatedValues = performNonBatchedOperations(\n\t\t\t\tmodelReference,\n\t\t\t\tvaluesAnalysis,\n\t\t\t\tinclusionChecker,\n\t\t\t\tresultChecker,\n\t\t\t\tsession\n\t\t);\n\t\tperformSelfExecutingOperations( valuesAnalysis, inclusionChecker, session );\n\t\tperformBatchedOperations( valuesAnalysis, inclusionChecker, staleStateMapper );\n\t\treturn generatedValues;\n\t}",
        "diffSourceCode": "-   41: \t/**\n-   42: \t * Templated implementation of execution as <ol>\n-   43: \t *     <li>{@link #performNonBatchedOperations}</li>\n-   44: \t *     <li>{@link #performSelfExecutingOperations}</li>\n-   45: \t *     <li>{@link #performBatchedOperations}</li>\n-   46: \t * </ol>\n-   47: \t */\n-   48: \t@Override\n-   49: \tpublic final GeneratedValues execute(\n-   50: \t\t\tObject modelReference,\n-   51: \t\t\tValuesAnalysis valuesAnalysis,\n-   52: \t\t\tTableInclusionChecker inclusionChecker,\n-   53: \t\t\tOperationResultChecker resultChecker,\n-   54: \t\t\tSharedSessionContractImplementor session) {\n-   55: \t\tfinal GeneratedValues generatedValues = performNonBatchedOperations(\n-   56: \t\t\t\tmodelReference,\n-   57: \t\t\t\tvaluesAnalysis,\n-   58: \t\t\t\tinclusionChecker,\n-   59: \t\t\t\tresultChecker,\n-   60: \t\t\t\tsession\n-   61: \t\t);\n-   62: \t\tperformSelfExecutingOperations( valuesAnalysis, inclusionChecker, session );\n-   63: \t\tperformBatchedOperations( valuesAnalysis, inclusionChecker );\n-   64: \t\treturn generatedValues;\n-   65: \t}\n-   66: \n-   67: \tprotected GeneratedValues performNonBatchedOperations(\n-   68: \t\t\tObject modelReference,\n-   69: \t\t\tValuesAnalysis valuesAnalysis,\n-   70: \t\t\tTableInclusionChecker inclusionChecker,\n-   71: \t\t\tOperationResultChecker resultChecker,\n-   72: \t\t\tSharedSessionContractImplementor session) {\n-   73: \t\treturn null;\n-   74: \t}\n-   75: \n-   76: \tprotected void performSelfExecutingOperations(\n-   77: \t\t\tValuesAnalysis valuesAnalysis,\n-   78: \t\t\tTableInclusionChecker inclusionChecker,\n+   41: \t}\n+   42: \n+   43: \t/**\n+   44: \t * Templated implementation of execution as <ol>\n+   45: \t *     <li>{@link #performNonBatchedOperations}</li>\n+   46: \t *     <li>{@link #performSelfExecutingOperations}</li>\n+   47: \t *     <li>{@link #performBatchedOperations}</li>\n+   48: \t * </ol>\n+   49: \t */\n+   50: \t@Override\n+   51: \tpublic final GeneratedValues execute(\n+   52: \t\t\tObject modelReference,\n+   53: \t\t\tValuesAnalysis valuesAnalysis,\n+   54: \t\t\tTableInclusionChecker inclusionChecker,\n+   55: \t\t\tOperationResultChecker resultChecker,\n+   56: \t\t\tSharedSessionContractImplementor session) {\n+   57: \t\treturn execute( modelReference, valuesAnalysis, inclusionChecker, resultChecker, session, null );\n+   58: \t}\n+   59: \n+   60: \t@Override\n+   61: \tpublic final GeneratedValues execute(\n+   62: \t\t\tObject modelReference,\n+   63: \t\t\tValuesAnalysis valuesAnalysis,\n+   64: \t\t\tTableInclusionChecker inclusionChecker,\n+   65: \t\t\tOperationResultChecker resultChecker,\n+   66: \t\t\tSharedSessionContractImplementor session,\n+   67: \t\t\tBatch.StaleStateMapper staleStateMapper) {\n+   68: \t\tfinal GeneratedValues generatedValues = performNonBatchedOperations(\n+   69: \t\t\t\tmodelReference,\n+   70: \t\t\t\tvaluesAnalysis,\n+   71: \t\t\t\tinclusionChecker,\n+   72: \t\t\t\tresultChecker,\n+   73: \t\t\t\tsession\n+   74: \t\t);\n+   75: \t\tperformSelfExecutingOperations( valuesAnalysis, inclusionChecker, session );\n+   76: \t\tperformBatchedOperations( valuesAnalysis, inclusionChecker, staleStateMapper );\n+   77: \t\treturn generatedValues;\n+   78: \t}\n",
        "uniqueId": "ee00217733018075ccade7e1145f45ff9acae0c2_41_65_60_78_43_58",
        "moveFileExist": true,
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 21,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 0,
                "covered": 20
            },
            "LINE": {
                "missed": 0,
                "covered": 4
            },
            "COMPLEXITY": {
                "missed": 0,
                "covered": 1
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        }
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprivate registerEntityNameUsage(tableGroup TableGroup, creationState SqlAstCreationState, tableName String) : void extracted from private render(aliasGenerator FilterAliasGenerator, filterIndex int, tableGroup TableGroup, creationState SqlAstCreationState) : String in class org.hibernate.internal.FilterHelper",
        "diffLocations": [
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/internal/FilterHelper.java",
                "startLine": 226,
                "endLine": 295,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/internal/FilterHelper.java",
                "startLine": 279,
                "endLine": 288,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/internal/FilterHelper.java",
                "startLine": 290,
                "endLine": 293,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "private String render(\n\t\t\tFilterAliasGenerator aliasGenerator,\n\t\t\tint filterIndex,\n\t\t\tTableGroup tableGroup,\n\t\t\tSqlAstCreationState creationState) {\n\t\tMap<String, String> aliasTableMap = filterAliasTableMaps[filterIndex];\n\t\tString condition = filterConditions[filterIndex];\n\t\tif ( aliasGenerator == null ) {\n\t\t\treturn StringHelper.replace( condition, FilterImpl.MARKER + \".\", \"\");\n\t\t}\n\t\tif ( filterAutoAliasFlags[filterIndex] ) {\n\t\t\tfinal String tableName = aliasTableMap.get( null );\n\t\t\tfinal String newCondition = StringHelper.replace(\n\t\t\t\t\tcondition,\n\t\t\t\t\tFilterImpl.MARKER,\n\t\t\t\t\taliasGenerator.getAlias( tableName )\n\t\t\t);\n\t\t\tif ( creationState != null && tableToEntityName != null && !newCondition.equals( condition ) ) {\n\t\t\t\tcreationState.registerEntityNameUsage(\n\t\t\t\t\t\ttableGroup,\n\t\t\t\t\t\tEntityNameUse.EXPRESSION,\n\t\t\t\t\t\ttableToEntityName.get(\n\t\t\t\t\t\t\t\ttableName == null\n\t\t\t\t\t\t\t\t\t\t? tableGroup.getPrimaryTableReference().getTableId()\n\t\t\t\t\t\t\t\t\t\t: tableName\n\t\t\t\t\t\t)\n\t\t\t\t);\n\t\t\t}\n\t\t\treturn newCondition;\n\t\t}\n\t\telse if ( isTableFromPersistentClass( aliasTableMap ) ) {\n\t\t\tfinal String tableName = aliasTableMap.get( null );\n\t\t\tfinal String newCondition = StringHelper.replace(\n\t\t\t\t\tcondition,\n\t\t\t\t\t\"{alias}\",\n\t\t\t\t\taliasGenerator.getAlias( tableName )\n\t\t\t);\n\t\t\tif ( creationState != null && !newCondition.equals( condition ) ) {\n\t\t\t\tcreationState.registerEntityNameUsage(\n\t\t\t\t\t\ttableGroup,\n\t\t\t\t\t\tEntityNameUse.EXPRESSION,\n\t\t\t\t\t\ttableToEntityName.get(\n\t\t\t\t\t\t\t\ttableName == null\n\t\t\t\t\t\t\t\t\t\t? tableGroup.getPrimaryTableReference().getTableId()\n\t\t\t\t\t\t\t\t\t\t: tableName\n\t\t\t\t\t\t)\n\t\t\t\t);\n\t\t\t}\n\t\t\treturn newCondition;\n\t\t}\n\t\telse {\n\t\t\tfor ( Map.Entry<String, String> entry : aliasTableMap.entrySet() ) {\n\t\t\t\tfinal String tableName = entry.getValue();\n\t\t\t\tfinal String newCondition = StringHelper.replace(\n\t\t\t\t\t\tcondition,\n\t\t\t\t\t\t\"{\" + entry.getKey() + \"}\",\n\t\t\t\t\t\taliasGenerator.getAlias( tableName )\n\t\t\t\t);\n\t\t\t\tif ( creationState != null && !newCondition.equals( condition ) ) {\n\t\t\t\t\tcreationState.registerEntityNameUsage(\n\t\t\t\t\t\t\ttableGroup,\n\t\t\t\t\t\t\tEntityNameUse.EXPRESSION,\n\t\t\t\t\t\t\ttableToEntityName.get( tableName )\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tcondition = newCondition;\n\t\t\t}\n\t\t\treturn condition;\n\t\t}\n\t}",
        "filePathBefore": "hibernate-core/src/main/java/org/hibernate/internal/FilterHelper.java",
        "isPureRefactoring": true,
        "commitId": "57cfbb616164b6cb93fd6bb1b3f8a4a5d4f7d59f",
        "packageNameBefore": "org.hibernate.internal",
        "classNameBefore": "org.hibernate.internal.FilterHelper",
        "methodNameBefore": "org.hibernate.internal.FilterHelper#render",
        "invokedMethod": "methodSignature: org.hibernate.sql.ast.tree.predicate.FilterPredicate.FilterFragmentParameter#getValue\n methodBody: public Object getValue() {\nreturn value;\n}\nmethodSignature: org.hibernate.internal.FilterHelper#isTableFromPersistentClass\n methodBody: private static boolean isTableFromPersistentClass(Map<String, String> aliasTableMap) {\nreturn aliasTableMap.size() == 1 && aliasTableMap.containsKey(null);\n}\nmethodSignature: org.hibernate.internal.util.StringHelper#replace\n methodBody: public static String replace(\n\t\t\tString beforePlaceholder,\n\t\t\tString afterPlaceholder,\n\t\t\tString placeholder,\n\t\t\tString replacement,\n\t\t\tboolean wholeWords,\n\t\t\tboolean encloseInParensIfNecessary) {\nfinal boolean actuallyReplace=!wholeWords || afterPlaceholder.length() == 0 || !Character.isJavaIdentifierPart(afterPlaceholder.charAt(0));\nboolean encloseInParens=actuallyReplace && encloseInParensIfNecessary && !(getLastNonWhitespaceCharacter(beforePlaceholder) == '(') && !(getLastNonWhitespaceCharacter(beforePlaceholder) == ',' && getFirstNonWhitespaceCharacter(afterPlaceholder) == ')');\nStringBuilder buf=new StringBuilder(beforePlaceholder);\nif(encloseInParens){buf.append('(');\n}buf.append(actuallyReplace ? replacement : placeholder);\nif(encloseInParens){buf.append(')');\n}buf.append(replace(afterPlaceholder,placeholder,replacement,wholeWords,encloseInParensIfNecessary));\nreturn buf.toString();\n}\nmethodSignature: org.hibernate.mapping.Selectable#getAlias\n methodBody: String getAlias(Dialect dialect, Table table);",
        "classSignatureBefore": "public class FilterHelper ",
        "methodNameBeforeSet": [
            "org.hibernate.internal.FilterHelper#render"
        ],
        "classNameBeforeSet": [
            "org.hibernate.internal.FilterHelper"
        ],
        "classSignatureBeforeSet": [
            "public class FilterHelper "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.\n */\npackage org.hibernate.internal;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.function.Consumer;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport org.hibernate.Filter;\nimport org.hibernate.engine.spi.LoadQueryInfluencers;\nimport org.hibernate.engine.spi.SessionFactoryImplementor;\nimport org.hibernate.internal.util.StringHelper;\nimport org.hibernate.internal.util.collections.CollectionHelper;\nimport org.hibernate.metamodel.mapping.Restrictable;\nimport org.hibernate.persister.entity.EntityNameUse;\nimport org.hibernate.sql.Template;\nimport org.hibernate.sql.ast.spi.SqlAstCreationState;\nimport org.hibernate.sql.ast.tree.from.TableGroup;\nimport org.hibernate.sql.ast.tree.predicate.FilterPredicate;\nimport org.hibernate.sql.ast.tree.predicate.Predicate;\n\nimport static org.hibernate.internal.util.StringHelper.safeInterning;\n\n/**\n * Implementation of FilterHelper.\n *\n * @author Steve Ebersole\n * @author Rob Worsnop\n * @author Nathan Xu\n */\npublic class FilterHelper {\n\tprivate static final Pattern FILTER_PARAMETER_PATTERN = Pattern.compile( \":(\\\\S+)(\\\\w+)\" );\n\n\tprivate final String[] filterNames;\n\tprivate final String[] filterConditions;\n\tprivate final boolean[] filterAutoAliasFlags;\n\tprivate final Map<String, String>[] filterAliasTableMaps;\n\tprivate final List<String>[] parameterNames;\n\tprivate final Map<String, String> tableToEntityName;\n\n\tpublic FilterHelper(List<FilterConfiguration> filters, SessionFactoryImplementor factory) {\n\t\tthis( filters, null, factory );\n\t}\n\n\t/**\n\t * The map of defined filters.  This is expected to be in format\n\t * where the filter names are the map keys, and the defined\n\t * conditions are the values.\n\t *\n\t * @param filters The map of defined filters.\n\t * @param factory The session factory\n\t */\n\tpublic FilterHelper(List<FilterConfiguration> filters, Map<String, String> tableToEntityName, SessionFactoryImplementor factory) {\n\t\tint filterCount = filters.size();\n\n\t\tfilterNames = new String[filterCount];\n\t\tfilterConditions = new String[filterCount];\n\t\tfilterAutoAliasFlags = new boolean[filterCount];\n\t\tfilterAliasTableMaps = new Map[filterCount];\n\t\tparameterNames = new List[filterCount];\n\t\tthis.tableToEntityName = tableToEntityName;\n\n\t\tfilterCount = 0;\n\t\tfor ( final FilterConfiguration filter : filters ) {\n\t\t\tfinal String filterName = safeInterning( filter.getName() );\n\t\t\tfilterNames[filterCount] = filterName;\n\t\t\tfilterConditions[filterCount] = safeInterning( filter.getCondition() );\n\n\t\t\tfilterAliasTableMaps[filterCount] = filter.getAliasTableMap( factory );\n\t\t\tfilterAutoAliasFlags[filterCount] = false;\n\n\t\t\tif ( ( filterAliasTableMaps[filterCount].isEmpty()\n\t\t\t\t\t|| isTableFromPersistentClass( filterAliasTableMaps[filterCount] ) )\n\t\t\t\t\t&& filter.useAutoAliasInjection() ) {\n\t\t\t\tfinal String autoAliasedCondition = Template.renderWhereStringTemplate(\n\t\t\t\t\t\tfilter.getCondition(),\n\t\t\t\t\t\tFilterImpl.MARKER,\n\t\t\t\t\t\tfactory.getJdbcServices().getDialect(),\n\t\t\t\t\t\tfactory.getTypeConfiguration()\n\t\t\t\t);\n\t\t\t\tfilterConditions[filterCount] = safeInterning( autoAliasedCondition );\n\t\t\t\tfilterAutoAliasFlags[filterCount] = true;\n\t\t\t}\n\n\t\t\t// look for parameters in the condition.  for each parameter, we:\n\t\t\t//\t\t1) keep track of the name for later\n\t\t\t//\t\t2) // we replace `:{param-name} ` with `:{filter-name}.{param-name} ` in the condition\n\t\t\tfinal Matcher matcher = FILTER_PARAMETER_PATTERN.matcher( filterConditions[filterCount] );\n\n\t\t\tString copy = filterConditions[filterCount];\n\t\t\tfinal List<String> filterParamNames = new ArrayList<>();\n\t\t\tparameterNames[filterCount] = filterParamNames;\n\t\t\tboolean foundAny = false;\n\n\t\t\t// handle any subsequent matched parameters\n\t\t\twhile( matcher.find() ) {\n\t\t\t\tfinal String parameterLabel = filterConditions[filterCount].substring( matcher.start() + 1, matcher.end() );\n\t\t\t\tfilterParamNames.add( parameterLabel );\n\t\t\t\tcopy = copy.replace(\n\t\t\t\t\t\t\":\" + parameterLabel,\n\t\t\t\t\t\t\":\" + filterName + \".\" + parameterLabel\n\t\t\t\t);\n\t\t\t\tfoundAny = true;\n\t\t\t}\n\n\t\t\tif ( foundAny ) {\n\t\t\t\tfilterConditions[filterCount] = safeInterning( copy );\n\t\t\t}\n\n\t\t\tfilterCount++;\n\t\t}\n\t}\n\n\tprivate static boolean isTableFromPersistentClass(Map<String, String> aliasTableMap) {\n\t\treturn aliasTableMap.size() == 1 && aliasTableMap.containsKey( null );\n\t}\n\n\tpublic String[] getFilterNames() {\n\t\treturn filterNames;\n\t}\n\n\tpublic boolean isAffectedBy(Map<String, Filter> enabledFilters) {\n\t\treturn isAffectedBy( enabledFilters, false );\n\t}\n\n\tpublic boolean isAffectedBy(Map<String, Filter> enabledFilters, boolean onlyApplyForLoadByKey) {\n\t\tfor ( String filterName : filterNames ) {\n\t\t\tFilter filter = enabledFilters.get( filterName );\n\t\t\tif ( filter != null && ( !onlyApplyForLoadByKey || filter.isAppliedToLoadByKey() ) ) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic static void applyBaseRestrictions(\n\t\t\tConsumer<Predicate> predicateConsumer,\n\t\t\tRestrictable restrictable,\n\t\t\tTableGroup rootTableGroup,\n\t\t\tboolean useIdentificationVariable,\n\t\t\tLoadQueryInfluencers loadQueryInfluencers,\n\t\t\tSqlAstCreationState astCreationState) {\n\t\trestrictable.applyBaseRestrictions(\n\t\t\t\tpredicateConsumer,\n\t\t\t\trootTableGroup,\n\t\t\t\tuseIdentificationVariable,\n\t\t\t\tloadQueryInfluencers.getEnabledFilters(),\n\t\t\t\tastCreationState.applyOnlyLoadByKeyFilters(),\n\t\t\t\tnull,\n\t\t\t\tastCreationState\n\t\t);\n\t}\n\n\tpublic void applyEnabledFilters(\n\t\t\tConsumer<Predicate> predicateConsumer,\n\t\t\tFilterAliasGenerator aliasGenerator,\n\t\t\tMap<String, Filter> enabledFilters,\n\t\t\tboolean onlyApplyLoadByKeyFilters,\n\t\t\tTableGroup tableGroup,\n\t\t\tSqlAstCreationState creationState) {\n\t\tfinal FilterPredicate predicate = generateFilterPredicate(\n\t\t\t\taliasGenerator,\n\t\t\t\tenabledFilters,\n\t\t\t\tonlyApplyLoadByKeyFilters,\n\t\t\t\ttableGroup,\n\t\t\t\tcreationState\n\t\t);\n\t\tif ( predicate != null ) {\n\t\t\tpredicateConsumer.accept( predicate );\n\t\t}\n\t}\n\n\tprivate FilterPredicate generateFilterPredicate(\n\t\t\tFilterAliasGenerator aliasGenerator,\n\t\t\tMap<String, Filter> enabledFilters,\n\t\t\tboolean onlyApplyLoadByKeyFilters,\n\t\t\tTableGroup tableGroup,\n\t\t\tSqlAstCreationState creationState) {\n\t\tfinal FilterPredicate filterPredicate = new FilterPredicate();\n\n\t\tfor ( int i = 0, max = filterNames.length; i < max; i++ ) {\n\t\t\tfinal String filterName = filterNames[i];\n\t\t\tfinal FilterImpl enabledFilter = (FilterImpl) enabledFilters.get( filterName );\n\t\t\tif ( enabledFilter != null && ( !onlyApplyLoadByKeyFilters || enabledFilter.isAppliedToLoadByKey() ) ) {\n\t\t\t\tfilterPredicate.applyFragment( render( aliasGenerator, i, tableGroup, creationState ), enabledFilter, parameterNames[i] );\n\t\t\t}\n\t\t}\n\n\t\tif ( filterPredicate.isEmpty() ) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn filterPredicate;\n\t}\n\n\tpublic String render(FilterAliasGenerator aliasGenerator, Map<String, Filter> enabledFilters) {\n\t\tStringBuilder buffer = new StringBuilder();\n\t\trender( buffer, aliasGenerator, enabledFilters );\n\t\treturn buffer.toString();\n\t}\n\n\tpublic void render(StringBuilder buffer, FilterAliasGenerator aliasGenerator, Map<String, Filter> enabledFilters) {\n\t\tif ( CollectionHelper.isEmpty( filterNames ) ) {\n\t\t\treturn;\n\t\t}\n\t\tfor ( int i = 0, max = filterNames.length; i < max; i++ ) {\n\t\t\tif ( enabledFilters.containsKey( filterNames[i] ) ) {\n\t\t\t\tfinal String condition = filterConditions[i];\n\t\t\t\tif ( StringHelper.isNotEmpty( condition ) ) {\n\t\t\t\t\tif ( buffer.length() > 0 ) {\n\t\t\t\t\t\tbuffer.append( \" and \" );\n\t\t\t\t\t}\n\t\t\t\t\tbuffer.append( render( aliasGenerator, i, null, null ) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate String render(\n\t\t\tFilterAliasGenerator aliasGenerator,\n\t\t\tint filterIndex,\n\t\t\tTableGroup tableGroup,\n\t\t\tSqlAstCreationState creationState) {\n\t\tMap<String, String> aliasTableMap = filterAliasTableMaps[filterIndex];\n\t\tString condition = filterConditions[filterIndex];\n\t\tif ( aliasGenerator == null ) {\n\t\t\treturn StringHelper.replace( condition, FilterImpl.MARKER + \".\", \"\");\n\t\t}\n\t\tif ( filterAutoAliasFlags[filterIndex] ) {\n\t\t\tfinal String tableName = aliasTableMap.get( null );\n\t\t\tfinal String newCondition = StringHelper.replace(\n\t\t\t\t\tcondition,\n\t\t\t\t\tFilterImpl.MARKER,\n\t\t\t\t\taliasGenerator.getAlias( tableName )\n\t\t\t);\n\t\t\tif ( creationState != null && tableToEntityName != null && !newCondition.equals( condition ) ) {\n\t\t\t\tcreationState.registerEntityNameUsage(\n\t\t\t\t\t\ttableGroup,\n\t\t\t\t\t\tEntityNameUse.EXPRESSION,\n\t\t\t\t\t\ttableToEntityName.get(\n\t\t\t\t\t\t\t\ttableName == null\n\t\t\t\t\t\t\t\t\t\t? tableGroup.getPrimaryTableReference().getTableId()\n\t\t\t\t\t\t\t\t\t\t: tableName\n\t\t\t\t\t\t)\n\t\t\t\t);\n\t\t\t}\n\t\t\treturn newCondition;\n\t\t}\n\t\telse if ( isTableFromPersistentClass( aliasTableMap ) ) {\n\t\t\tfinal String tableName = aliasTableMap.get( null );\n\t\t\tfinal String newCondition = StringHelper.replace(\n\t\t\t\t\tcondition,\n\t\t\t\t\t\"{alias}\",\n\t\t\t\t\taliasGenerator.getAlias( tableName )\n\t\t\t);\n\t\t\tif ( creationState != null && !newCondition.equals( condition ) ) {\n\t\t\t\tcreationState.registerEntityNameUsage(\n\t\t\t\t\t\ttableGroup,\n\t\t\t\t\t\tEntityNameUse.EXPRESSION,\n\t\t\t\t\t\ttableToEntityName.get(\n\t\t\t\t\t\t\t\ttableName == null\n\t\t\t\t\t\t\t\t\t\t? tableGroup.getPrimaryTableReference().getTableId()\n\t\t\t\t\t\t\t\t\t\t: tableName\n\t\t\t\t\t\t)\n\t\t\t\t);\n\t\t\t}\n\t\t\treturn newCondition;\n\t\t}\n\t\telse {\n\t\t\tfor ( Map.Entry<String, String> entry : aliasTableMap.entrySet() ) {\n\t\t\t\tfinal String tableName = entry.getValue();\n\t\t\t\tfinal String newCondition = StringHelper.replace(\n\t\t\t\t\t\tcondition,\n\t\t\t\t\t\t\"{\" + entry.getKey() + \"}\",\n\t\t\t\t\t\taliasGenerator.getAlias( tableName )\n\t\t\t\t);\n\t\t\t\tif ( creationState != null && !newCondition.equals( condition ) ) {\n\t\t\t\t\tcreationState.registerEntityNameUsage(\n\t\t\t\t\t\t\ttableGroup,\n\t\t\t\t\t\t\tEntityNameUse.EXPRESSION,\n\t\t\t\t\t\t\ttableToEntityName.get( tableName )\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tcondition = newCondition;\n\t\t\t}\n\t\t\treturn condition;\n\t\t}\n\t}\n\n}\n",
        "filePathAfter": "hibernate-core/src/main/java/org/hibernate/internal/FilterHelper.java",
        "sourceCodeAfterForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.\n */\npackage org.hibernate.internal;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.function.Consumer;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport org.hibernate.Filter;\nimport org.hibernate.engine.spi.LoadQueryInfluencers;\nimport org.hibernate.engine.spi.SessionFactoryImplementor;\nimport org.hibernate.metamodel.mapping.Restrictable;\nimport org.hibernate.persister.entity.EntityNameUse;\nimport org.hibernate.sql.Template;\nimport org.hibernate.sql.ast.spi.SqlAstCreationState;\nimport org.hibernate.sql.ast.tree.from.TableGroup;\nimport org.hibernate.sql.ast.tree.predicate.FilterPredicate;\nimport org.hibernate.sql.ast.tree.predicate.Predicate;\n\nimport static org.hibernate.internal.FilterImpl.MARKER;\nimport static org.hibernate.internal.util.StringHelper.isNotEmpty;\nimport static org.hibernate.internal.util.StringHelper.replace;\nimport static org.hibernate.internal.util.StringHelper.safeInterning;\nimport static org.hibernate.internal.util.collections.CollectionHelper.isNotEmpty;\n\n/**\n * Utility methods for dealing with {@linkplain FilterConfiguration filters}.\n *\n * @author Steve Ebersole\n * @author Rob Worsnop\n * @author Nathan Xu\n */\npublic class FilterHelper {\n\tprivate static final Pattern FILTER_PARAMETER_PATTERN = Pattern.compile( \":((\\\\S+)(\\\\w+))\" );\n\n\tprivate final String[] filterNames;\n\tprivate final String[] filterConditions;\n\tprivate final boolean[] filterAutoAliasFlags;\n\tprivate final Map<String, String>[] filterAliasTableMaps;\n\tprivate final List<String>[] parameterNames;\n\tprivate final Map<String, String> tableToEntityName;\n\n\tpublic FilterHelper(List<FilterConfiguration> filters, SessionFactoryImplementor factory) {\n\t\tthis( filters, null, factory );\n\t}\n\n\t/**\n\t * The map of defined filters.  This is expected to be in format\n\t * where the filter names are the map keys, and the defined\n\t * conditions are the values.\n\t *\n\t * @param filters The map of defined filters.\n\t * @param factory The session factory\n\t */\n\tpublic FilterHelper(List<FilterConfiguration> filters, Map<String, String> tableToEntityName, SessionFactoryImplementor factory) {\n\t\tint filterCount = filters.size();\n\n\t\tfilterNames = new String[filterCount];\n\t\tfilterConditions = new String[filterCount];\n\t\tfilterAutoAliasFlags = new boolean[filterCount];\n\t\tfilterAliasTableMaps = new Map[filterCount];\n\t\tparameterNames = new List[filterCount];\n\t\tthis.tableToEntityName = tableToEntityName;\n\n\t\tfilterCount = 0;\n\t\tfor ( final FilterConfiguration filter : filters ) {\n\t\t\tfinal String filterName = safeInterning( filter.getName() );\n\t\t\tfilterNames[filterCount] = filterName;\n\t\t\tfilterConditions[filterCount] = safeInterning( filter.getCondition() );\n\n\t\t\tfilterAliasTableMaps[filterCount] = filter.getAliasTableMap( factory );\n\t\t\tfilterAutoAliasFlags[filterCount] = false;\n\n\t\t\tinjectAliases( factory, filter, filterCount );\n\t\t\tqualifyParameterNames( filterCount, filterName );\n\n\t\t\tfilterCount++;\n\t\t}\n\t}\n\n\tprivate void injectAliases(SessionFactoryImplementor factory, FilterConfiguration filter, int filterCount) {\n\t\tif ( ( filterAliasTableMaps[filterCount].isEmpty()\n\t\t\t\t|| isTableFromPersistentClass( filterAliasTableMaps[filterCount] ) )\n\t\t\t\t&& filter.useAutoAliasInjection() ) {\n\t\t\tfinal String autoAliasedCondition = Template.renderWhereStringTemplate(\n\t\t\t\t\tfilter.getCondition(),\n\t\t\t\t\tMARKER,\n\t\t\t\t\tfactory.getJdbcServices().getDialect(),\n\t\t\t\t\tfactory.getTypeConfiguration()\n\t\t\t);\n\t\t\tfilterConditions[filterCount] = safeInterning( autoAliasedCondition );\n\t\t\tfilterAutoAliasFlags[filterCount] = true;\n\t\t}\n\t}\n\n\t/**\n\t * Look for parameters in the given condition. For each parameter, we:\n\t * <ol>\n\t *     <li>keep track of the name for later</li>\n\t *     <li>replace {@code :{param-name}} with {@code :{filter-name}.{param-name}}\n\t *     in the condition</li>\n\t * </ol>\n\t */\n\tprivate void qualifyParameterNames(int filterCount, String filterName) {\n\t\tfinal List<String> parameterNames = new ArrayList<>();\n\t\tboolean foundAny = false;\n\t\tfinal Matcher matcher = FILTER_PARAMETER_PATTERN.matcher( filterConditions[filterCount] );\n\t\twhile ( matcher.find() ) {\n\t\t\tparameterNames.add( matcher.group(1) );\n\t\t\tfoundAny = true;\n\t\t}\n\t\tif ( foundAny ) {\n\t\t\tfilterConditions[filterCount] =\n\t\t\t\t\tsafeInterning( matcher.replaceAll(\":\" + filterName +  \".$1\") );\n\t\t}\n\t\tthis.parameterNames[filterCount] = parameterNames;\n\t}\n\n\tprivate static boolean isTableFromPersistentClass(Map<String, String> aliasTableMap) {\n\t\treturn aliasTableMap.size() == 1 && aliasTableMap.containsKey( null );\n\t}\n\n\tpublic String[] getFilterNames() {\n\t\treturn filterNames;\n\t}\n\n\tpublic boolean isAffectedBy(Map<String, Filter> enabledFilters) {\n\t\treturn isAffectedBy( enabledFilters, false );\n\t}\n\n\tpublic boolean isAffectedBy(Map<String, Filter> enabledFilters, boolean onlyApplyForLoadByKey) {\n\t\tfor ( String filterName : filterNames ) {\n\t\t\tFilter filter = enabledFilters.get( filterName );\n\t\t\tif ( filter != null && ( !onlyApplyForLoadByKey || filter.isAppliedToLoadByKey() ) ) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic static void applyBaseRestrictions(\n\t\t\tConsumer<Predicate> predicateConsumer,\n\t\t\tRestrictable restrictable,\n\t\t\tTableGroup rootTableGroup,\n\t\t\tboolean useIdentificationVariable,\n\t\t\tLoadQueryInfluencers loadQueryInfluencers,\n\t\t\tSqlAstCreationState astCreationState) {\n\t\trestrictable.applyBaseRestrictions(\n\t\t\t\tpredicateConsumer,\n\t\t\t\trootTableGroup,\n\t\t\t\tuseIdentificationVariable,\n\t\t\t\tloadQueryInfluencers.getEnabledFilters(),\n\t\t\t\tastCreationState.applyOnlyLoadByKeyFilters(),\n\t\t\t\tnull,\n\t\t\t\tastCreationState\n\t\t);\n\t}\n\n\tpublic void applyEnabledFilters(\n\t\t\tConsumer<Predicate> predicateConsumer,\n\t\t\tFilterAliasGenerator aliasGenerator,\n\t\t\tMap<String, Filter> enabledFilters,\n\t\t\tboolean onlyApplyLoadByKeyFilters,\n\t\t\tTableGroup tableGroup,\n\t\t\tSqlAstCreationState creationState) {\n\t\tfinal FilterPredicate predicate = generateFilterPredicate(\n\t\t\t\taliasGenerator,\n\t\t\t\tenabledFilters,\n\t\t\t\tonlyApplyLoadByKeyFilters,\n\t\t\t\ttableGroup,\n\t\t\t\tcreationState\n\t\t);\n\t\tif ( predicate != null ) {\n\t\t\tpredicateConsumer.accept( predicate );\n\t\t}\n\t}\n\n\tprivate FilterPredicate generateFilterPredicate(\n\t\t\tFilterAliasGenerator aliasGenerator,\n\t\t\tMap<String, Filter> enabledFilters,\n\t\t\tboolean onlyApplyLoadByKeyFilters,\n\t\t\tTableGroup tableGroup,\n\t\t\tSqlAstCreationState creationState) {\n\t\tfinal FilterPredicate filterPredicate = new FilterPredicate();\n\n\t\tfor ( int i = 0, max = filterNames.length; i < max; i++ ) {\n\t\t\tfinal Filter enabledFilter = enabledFilters.get( filterNames[i] );\n\t\t\tif ( enabledFilter != null && ( !onlyApplyLoadByKeyFilters || enabledFilter.isAppliedToLoadByKey() ) ) {\n\t\t\t\tfilterPredicate.applyFragment( render( aliasGenerator, i, tableGroup, creationState ), enabledFilter, parameterNames[i] );\n\t\t\t}\n\t\t}\n\n\t\tif ( filterPredicate.isEmpty() ) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn filterPredicate;\n\t}\n\n\tpublic String render(FilterAliasGenerator aliasGenerator, Map<String, Filter> enabledFilters) {\n\t\tfinal StringBuilder buffer = new StringBuilder();\n\t\trender( buffer, aliasGenerator, enabledFilters );\n\t\treturn buffer.toString();\n\t}\n\n\tpublic void render(StringBuilder buffer, FilterAliasGenerator aliasGenerator, Map<String, Filter> enabledFilters) {\n\t\tif ( isNotEmpty( filterNames ) ) {\n\t\t\tfor ( int i = 0, max = filterNames.length; i < max; i++ ) {\n\t\t\t\tif ( enabledFilters.containsKey( filterNames[i] ) ) {\n\t\t\t\t\tif ( isNotEmpty( filterConditions[i] ) ) {\n\t\t\t\t\t\tif ( !buffer.isEmpty() ) {\n\t\t\t\t\t\t\tbuffer.append( \" and \" );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbuffer.append( render( aliasGenerator, i, null, null ) );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate String render(\n\t\t\tFilterAliasGenerator aliasGenerator,\n\t\t\tint filterIndex,\n\t\t\tTableGroup tableGroup,\n\t\t\tSqlAstCreationState creationState) {\n\t\tfinal String condition = filterConditions[filterIndex];\n\t\tif ( aliasGenerator == null ) {\n\t\t\treturn replace( condition, MARKER + \".\", \"\");\n\t\t}\n\t\telse {\n\t\t\tfinal Map<String, String> aliasTableMap = filterAliasTableMaps[filterIndex];\n\t\t\tif ( filterAutoAliasFlags[filterIndex] ) {\n\t\t\t\tfinal String tableName = aliasTableMap.get( null );\n\t\t\t\treturn replaceMarker( tableGroup, creationState, condition,\n\t\t\t\t\t\taliasGenerator.getAlias( tableName ),\n\t\t\t\t\t\ttableName( tableGroup, tableName ) );\n\t\t\t}\n\t\t\telse if ( isTableFromPersistentClass( aliasTableMap ) ) {\n\t\t\t\tfinal String tableName = aliasTableMap.get( null );\n\t\t\t\treturn replaceAlias( tableGroup, creationState, condition,\n\t\t\t\t\t\t\"{alias}\",\n\t\t\t\t\t\taliasGenerator.getAlias( tableName ),\n\t\t\t\t\t\ttableName( tableGroup, tableName ) );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tString newCondition = condition;\n\t\t\t\tfor ( Map.Entry<String, String> entry : aliasTableMap.entrySet() ) {\n\t\t\t\t\tfinal String tableName = entry.getValue();\n\t\t\t\t\tnewCondition =\n\t\t\t\t\t\t\treplaceAlias( tableGroup, creationState, newCondition,\n\t\t\t\t\t\t\t\t\t\"{\" + entry.getKey() + \"}\",\n\t\t\t\t\t\t\t\t\taliasGenerator.getAlias( tableName ),\n\t\t\t\t\t\t\t\t\ttableName );\n\t\t\t\t}\n\t\t\t\treturn newCondition;\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate String replaceMarker(\n\t\t\tTableGroup tableGroup, SqlAstCreationState creationState,\n\t\t\tString condition, String alias, String tableName) {\n\t\tfinal String newCondition = replace( condition, MARKER, alias );\n\t\tif ( creationState != null\n\t\t\t\t&& tableToEntityName != null\n\t\t\t\t&& !newCondition.equals(condition) ) {\n\t\t\tregisterEntityNameUsage( tableGroup, creationState, tableName );\n\t\t}\n\t\treturn newCondition;\n\t}\n\n\tprivate String replaceAlias(\n\t\t\tTableGroup tableGroup, SqlAstCreationState creationState,\n\t\t\tString condition, String placeholder, String alias, String tableName) {\n\t\tfinal String newCondition = replace( condition, placeholder, alias );\n\t\tif ( creationState != null\n\t\t\t\t&& !newCondition.equals(condition) ) {\n\t\t\tregisterEntityNameUsage( tableGroup, creationState, tableName );\n\t\t}\n\t\treturn newCondition;\n\t}\n\n\tprivate void registerEntityNameUsage(TableGroup tableGroup, SqlAstCreationState creationState, String tableName) {\n\t\tcreationState.registerEntityNameUsage( tableGroup, EntityNameUse.EXPRESSION,\n\t\t\t\ttableToEntityName.get( tableName ) );\n\t}\n\n\tprivate static String tableName(TableGroup tableGroup, String tableName) {\n\t\treturn tableName == null\n\t\t\t\t? tableGroup.getPrimaryTableReference().getTableId()\n\t\t\t\t: tableName;\n\t}\n}\n",
        "diffSourceCodeSet": [
            "private void registerEntityNameUsage(TableGroup tableGroup, SqlAstCreationState creationState, String tableName) {\n\t\tcreationState.registerEntityNameUsage( tableGroup, EntityNameUse.EXPRESSION,\n\t\t\t\ttableToEntityName.get( tableName ) );\n\t}"
        ],
        "invokedMethodSet": [
            "methodSignature: org.hibernate.sql.ast.tree.predicate.FilterPredicate.FilterFragmentParameter#getValue\n methodBody: public Object getValue() {\nreturn value;\n}",
            "methodSignature: org.hibernate.internal.FilterHelper#isTableFromPersistentClass\n methodBody: private static boolean isTableFromPersistentClass(Map<String, String> aliasTableMap) {\nreturn aliasTableMap.size() == 1 && aliasTableMap.containsKey(null);\n}",
            "methodSignature: org.hibernate.internal.util.StringHelper#replace\n methodBody: public static String replace(\n\t\t\tString beforePlaceholder,\n\t\t\tString afterPlaceholder,\n\t\t\tString placeholder,\n\t\t\tString replacement,\n\t\t\tboolean wholeWords,\n\t\t\tboolean encloseInParensIfNecessary) {\nfinal boolean actuallyReplace=!wholeWords || afterPlaceholder.length() == 0 || !Character.isJavaIdentifierPart(afterPlaceholder.charAt(0));\nboolean encloseInParens=actuallyReplace && encloseInParensIfNecessary && !(getLastNonWhitespaceCharacter(beforePlaceholder) == '(') && !(getLastNonWhitespaceCharacter(beforePlaceholder) == ',' && getFirstNonWhitespaceCharacter(afterPlaceholder) == ')');\nStringBuilder buf=new StringBuilder(beforePlaceholder);\nif(encloseInParens){buf.append('(');\n}buf.append(actuallyReplace ? replacement : placeholder);\nif(encloseInParens){buf.append(')');\n}buf.append(replace(afterPlaceholder,placeholder,replacement,wholeWords,encloseInParensIfNecessary));\nreturn buf.toString();\n}",
            "methodSignature: org.hibernate.mapping.Selectable#getAlias\n methodBody: String getAlias(Dialect dialect, Table table);"
        ],
        "sourceCodeAfterRefactoring": "private String replaceAlias(\n\t\t\tTableGroup tableGroup, SqlAstCreationState creationState,\n\t\t\tString condition, String placeholder, String alias, String tableName) {\n\t\tfinal String newCondition = replace( condition, placeholder, alias );\n\t\tif ( creationState != null\n\t\t\t\t&& !newCondition.equals(condition) ) {\n\t\t\tregisterEntityNameUsage( tableGroup, creationState, tableName );\n\t\t}\n\t\treturn newCondition;\n\t}\nprivate void registerEntityNameUsage(TableGroup tableGroup, SqlAstCreationState creationState, String tableName) {\n\t\tcreationState.registerEntityNameUsage( tableGroup, EntityNameUse.EXPRESSION,\n\t\t\t\ttableToEntityName.get( tableName ) );\n\t}",
        "diffSourceCode": "-  226: \tprivate String render(\n-  227: \t\t\tFilterAliasGenerator aliasGenerator,\n-  228: \t\t\tint filterIndex,\n-  229: \t\t\tTableGroup tableGroup,\n-  230: \t\t\tSqlAstCreationState creationState) {\n-  231: \t\tMap<String, String> aliasTableMap = filterAliasTableMaps[filterIndex];\n-  232: \t\tString condition = filterConditions[filterIndex];\n-  233: \t\tif ( aliasGenerator == null ) {\n-  234: \t\t\treturn StringHelper.replace( condition, FilterImpl.MARKER + \".\", \"\");\n-  235: \t\t}\n-  236: \t\tif ( filterAutoAliasFlags[filterIndex] ) {\n-  237: \t\t\tfinal String tableName = aliasTableMap.get( null );\n-  238: \t\t\tfinal String newCondition = StringHelper.replace(\n-  239: \t\t\t\t\tcondition,\n-  240: \t\t\t\t\tFilterImpl.MARKER,\n-  241: \t\t\t\t\taliasGenerator.getAlias( tableName )\n-  242: \t\t\t);\n-  243: \t\t\tif ( creationState != null && tableToEntityName != null && !newCondition.equals( condition ) ) {\n-  244: \t\t\t\tcreationState.registerEntityNameUsage(\n-  245: \t\t\t\t\t\ttableGroup,\n-  246: \t\t\t\t\t\tEntityNameUse.EXPRESSION,\n-  247: \t\t\t\t\t\ttableToEntityName.get(\n-  248: \t\t\t\t\t\t\t\ttableName == null\n-  249: \t\t\t\t\t\t\t\t\t\t? tableGroup.getPrimaryTableReference().getTableId()\n-  250: \t\t\t\t\t\t\t\t\t\t: tableName\n-  251: \t\t\t\t\t\t)\n-  252: \t\t\t\t);\n-  253: \t\t\t}\n-  254: \t\t\treturn newCondition;\n-  255: \t\t}\n-  256: \t\telse if ( isTableFromPersistentClass( aliasTableMap ) ) {\n-  257: \t\t\tfinal String tableName = aliasTableMap.get( null );\n-  258: \t\t\tfinal String newCondition = StringHelper.replace(\n-  259: \t\t\t\t\tcondition,\n-  260: \t\t\t\t\t\"{alias}\",\n-  261: \t\t\t\t\taliasGenerator.getAlias( tableName )\n-  262: \t\t\t);\n-  263: \t\t\tif ( creationState != null && !newCondition.equals( condition ) ) {\n-  264: \t\t\t\tcreationState.registerEntityNameUsage(\n-  265: \t\t\t\t\t\ttableGroup,\n-  266: \t\t\t\t\t\tEntityNameUse.EXPRESSION,\n-  267: \t\t\t\t\t\ttableToEntityName.get(\n-  268: \t\t\t\t\t\t\t\ttableName == null\n-  269: \t\t\t\t\t\t\t\t\t\t? tableGroup.getPrimaryTableReference().getTableId()\n-  270: \t\t\t\t\t\t\t\t\t\t: tableName\n-  271: \t\t\t\t\t\t)\n-  272: \t\t\t\t);\n-  273: \t\t\t}\n-  274: \t\t\treturn newCondition;\n+  226: \t}\n+  227: \n+  228: \tprivate String render(\n+  229: \t\t\tFilterAliasGenerator aliasGenerator,\n+  230: \t\t\tint filterIndex,\n+  231: \t\t\tTableGroup tableGroup,\n+  232: \t\t\tSqlAstCreationState creationState) {\n+  233: \t\tfinal String condition = filterConditions[filterIndex];\n+  234: \t\tif ( aliasGenerator == null ) {\n+  235: \t\t\treturn replace( condition, MARKER + \".\", \"\");\n+  236: \t\t}\n+  237: \t\telse {\n+  238: \t\t\tfinal Map<String, String> aliasTableMap = filterAliasTableMaps[filterIndex];\n+  239: \t\t\tif ( filterAutoAliasFlags[filterIndex] ) {\n+  240: \t\t\t\tfinal String tableName = aliasTableMap.get( null );\n+  241: \t\t\t\treturn replaceMarker( tableGroup, creationState, condition,\n+  242: \t\t\t\t\t\taliasGenerator.getAlias( tableName ),\n+  243: \t\t\t\t\t\ttableName( tableGroup, tableName ) );\n+  244: \t\t\t}\n+  245: \t\t\telse if ( isTableFromPersistentClass( aliasTableMap ) ) {\n+  246: \t\t\t\tfinal String tableName = aliasTableMap.get( null );\n+  247: \t\t\t\treturn replaceAlias( tableGroup, creationState, condition,\n+  248: \t\t\t\t\t\t\"{alias}\",\n+  249: \t\t\t\t\t\taliasGenerator.getAlias( tableName ),\n+  250: \t\t\t\t\t\ttableName( tableGroup, tableName ) );\n+  251: \t\t\t}\n+  252: \t\t\telse {\n+  253: \t\t\t\tString newCondition = condition;\n+  254: \t\t\t\tfor ( Map.Entry<String, String> entry : aliasTableMap.entrySet() ) {\n+  255: \t\t\t\t\tfinal String tableName = entry.getValue();\n+  256: \t\t\t\t\tnewCondition =\n+  257: \t\t\t\t\t\t\treplaceAlias( tableGroup, creationState, newCondition,\n+  258: \t\t\t\t\t\t\t\t\t\"{\" + entry.getKey() + \"}\",\n+  259: \t\t\t\t\t\t\t\t\taliasGenerator.getAlias( tableName ),\n+  260: \t\t\t\t\t\t\t\t\ttableName );\n+  261: \t\t\t\t}\n+  262: \t\t\t\treturn newCondition;\n+  263: \t\t\t}\n+  264: \t\t}\n+  265: \t}\n+  266: \n+  267: \tprivate String replaceMarker(\n+  268: \t\t\tTableGroup tableGroup, SqlAstCreationState creationState,\n+  269: \t\t\tString condition, String alias, String tableName) {\n+  270: \t\tfinal String newCondition = replace( condition, MARKER, alias );\n+  271: \t\tif ( creationState != null\n+  272: \t\t\t\t&& tableToEntityName != null\n+  273: \t\t\t\t&& !newCondition.equals(condition) ) {\n+  274: \t\t\tregisterEntityNameUsage( tableGroup, creationState, tableName );\n   275: \t\t}\n-  276: \t\telse {\n-  277: \t\t\tfor ( Map.Entry<String, String> entry : aliasTableMap.entrySet() ) {\n-  278: \t\t\t\tfinal String tableName = entry.getValue();\n-  279: \t\t\t\tfinal String newCondition = StringHelper.replace(\n-  280: \t\t\t\t\t\tcondition,\n-  281: \t\t\t\t\t\t\"{\" + entry.getKey() + \"}\",\n-  282: \t\t\t\t\t\taliasGenerator.getAlias( tableName )\n-  283: \t\t\t\t);\n-  284: \t\t\t\tif ( creationState != null && !newCondition.equals( condition ) ) {\n-  285: \t\t\t\t\tcreationState.registerEntityNameUsage(\n-  286: \t\t\t\t\t\t\ttableGroup,\n-  287: \t\t\t\t\t\t\tEntityNameUse.EXPRESSION,\n-  288: \t\t\t\t\t\t\ttableToEntityName.get( tableName )\n-  289: \t\t\t\t\t);\n-  290: \t\t\t\t}\n-  291: \t\t\t\tcondition = newCondition;\n-  292: \t\t\t}\n-  293: \t\t\treturn condition;\n-  294: \t\t}\n-  295: \t}\n+  276: \t\treturn newCondition;\n+  277: \t}\n+  278: \n+  279: \tprivate String replaceAlias(\n+  280: \t\t\tTableGroup tableGroup, SqlAstCreationState creationState,\n+  281: \t\t\tString condition, String placeholder, String alias, String tableName) {\n+  282: \t\tfinal String newCondition = replace( condition, placeholder, alias );\n+  283: \t\tif ( creationState != null\n+  284: \t\t\t\t&& !newCondition.equals(condition) ) {\n+  285: \t\t\tregisterEntityNameUsage( tableGroup, creationState, tableName );\n+  286: \t\t}\n+  287: \t\treturn newCondition;\n+  288: \t}\n+  289: \n+  290: \tprivate void registerEntityNameUsage(TableGroup tableGroup, SqlAstCreationState creationState, String tableName) {\n+  291: \t\tcreationState.registerEntityNameUsage( tableGroup, EntityNameUse.EXPRESSION,\n+  292: \t\t\t\ttableToEntityName.get( tableName ) );\n+  293: \t}\n+  294: \n+  295: \tprivate static String tableName(TableGroup tableGroup, String tableName) {\n",
        "uniqueId": "57cfbb616164b6cb93fd6bb1b3f8a4a5d4f7d59f_226_295_290_293_279_288",
        "moveFileExist": true,
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 21,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 5,
                "covered": 89
            },
            "BRANCH": {
                "missed": 1,
                "covered": 7
            },
            "LINE": {
                "missed": 1,
                "covered": 22
            },
            "COMPLEXITY": {
                "missed": 1,
                "covered": 4
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        }
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprivate lookahead(sql String, symbols String, tokens StringTokenizer, skip int) : StringTokenizer extracted from private isLiteral(lcToken String, next String, sqlWhereString String, symbols String, tokens StringTokenizer) : boolean in class org.hibernate.sql.Template",
        "diffLocations": [
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/sql/Template.java",
                "startLine": 270,
                "endLine": 308,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/sql/Template.java",
                "startLine": 300,
                "endLine": 316,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/sql/Template.java",
                "startLine": 318,
                "endLine": 335,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "private static boolean isLiteral(\n\t\t\tString lcToken, String next,\n\t\t\tString sqlWhereString, String symbols, StringTokenizer tokens) {\n\t\tif ( LITERAL_PREFIXES.contains( lcToken ) && next != null ) {\n\t\t\t// easy cases first\n\t\t\tif ( \"'\".equals(next) ) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse if ( !next.isBlank() ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// we need to look ahead in the token stream\n\t\t\t\t// to find the first non-blank token\n\t\t\t\tfinal StringTokenizer lookahead =\n\t\t\t\t\t\tnew StringTokenizer( sqlWhereString, symbols, true );\n\t\t\t\twhile ( lookahead.countTokens() > tokens.countTokens()+1 ) {\n\t\t\t\t\tlookahead.nextToken();\n\t\t\t\t}\n\t\t\t\tif ( lookahead.hasMoreTokens() ) {\n\t\t\t\t\tString nextToken;\n\t\t\t\t\tdo {\n\t\t\t\t\t\tnextToken = lookahead.nextToken().toLowerCase(Locale.ROOT);\n\t\t\t\t\t}\n\t\t\t\t\twhile ( nextToken.isBlank() && lookahead.hasMoreTokens() );\n\t\t\t\t\treturn \"'\".equals( nextToken )\n\t\t\t\t\t\t|| lcToken.equals( \"time\" ) && \"with\".equals( nextToken )\n\t\t\t\t\t\t|| lcToken.equals( \"timestamp\" ) && \"with\".equals( nextToken )\n\t\t\t\t\t\t|| lcToken.equals( \"time\" ) && \"zone\".equals( nextToken );\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\treturn false;\n\t\t}\n\t}",
        "filePathBefore": "hibernate-core/src/main/java/org/hibernate/sql/Template.java",
        "isPureRefactoring": true,
        "commitId": "a20fb5663dc6e389aa1d9787dfbaf9750b693943",
        "packageNameBefore": "org.hibernate.sql",
        "classNameBefore": "org.hibernate.sql.Template",
        "methodNameBefore": "org.hibernate.sql.Template#isLiteral",
        "invokedMethod": "methodSignature: org.hibernate.mapping.Formula#equals\n methodBody: public boolean equals(Object obj) {\nreturn obj instanceof Formula && ((Formula)obj).formula.equals(formula);\n}\nmethodSignature: org.hibernate.mapping.PersistentClass#contains\n methodBody: public boolean contains(Property property) {\nreturn properties.contains(property);\n}",
        "classSignatureBefore": "public final class Template ",
        "methodNameBeforeSet": [
            "org.hibernate.sql.Template#isLiteral"
        ],
        "classNameBeforeSet": [
            "org.hibernate.sql.Template"
        ],
        "classSignatureBeforeSet": [
            "public final class Template "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Changes are within the Extract Method refactoring mechanics \n Severe changes",
                "description": "Return expression has been added within the Extract Method mechanics - with non-mapped leaves",
                "mappingState": 2
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.\n */\npackage org.hibernate.sql;\n\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Set;\nimport java.util.StringTokenizer;\n\nimport org.hibernate.HibernateException;\nimport org.hibernate.dialect.Dialect;\nimport org.hibernate.query.sqm.function.SqmFunctionDescriptor;\nimport org.hibernate.query.sqm.function.SqmFunctionRegistry;\nimport org.hibernate.type.spi.TypeConfiguration;\n\nimport static java.lang.Boolean.parseBoolean;\nimport static java.lang.Character.isLetter;\nimport static org.hibernate.internal.util.StringHelper.WHITESPACE;\n\n/**\n * Parses SQL fragments specified in mapping documents.\n *\n * @author Gavin King\n */\npublic final class Template {\n\n\tprivate static final Set<String> KEYWORDS = new HashSet<>();\n\tprivate static final Set<String> BEFORE_TABLE_KEYWORDS = new HashSet<>();\n\tprivate static final Set<String> FUNCTION_KEYWORDS = new HashSet<>();\n\tprivate static final Set<String> LITERAL_PREFIXES = new HashSet<>();\n\tpublic static final String PUNCTUATION = \"=><!+-*/()',|&`\";\n\n\tstatic {\n\t\tKEYWORDS.add(\"and\");\n\t\tKEYWORDS.add(\"or\");\n\t\tKEYWORDS.add(\"not\");\n\t\tKEYWORDS.add(\"like\");\n\t\tKEYWORDS.add(\"escape\");\n\t\tKEYWORDS.add(\"is\");\n\t\tKEYWORDS.add(\"in\");\n\t\tKEYWORDS.add(\"between\");\n\t\tKEYWORDS.add(\"null\");\n\t\tKEYWORDS.add(\"select\");\n\t\tKEYWORDS.add(\"distinct\");\n\t\tKEYWORDS.add(\"from\");\n\t\tKEYWORDS.add(\"join\");\n\t\tKEYWORDS.add(\"inner\");\n\t\tKEYWORDS.add(\"outer\");\n\t\tKEYWORDS.add(\"left\");\n\t\tKEYWORDS.add(\"right\");\n\t\tKEYWORDS.add(\"on\");\n\t\tKEYWORDS.add(\"where\");\n\t\tKEYWORDS.add(\"having\");\n\t\tKEYWORDS.add(\"group\");\n\t\tKEYWORDS.add(\"order\");\n\t\tKEYWORDS.add(\"by\");\n\t\tKEYWORDS.add(\"desc\");\n\t\tKEYWORDS.add(\"asc\");\n\t\tKEYWORDS.add(\"limit\");\n\t\tKEYWORDS.add(\"any\");\n\t\tKEYWORDS.add(\"some\");\n\t\tKEYWORDS.add(\"exists\");\n\t\tKEYWORDS.add(\"all\");\n\t\tKEYWORDS.add(\"union\");\n\t\tKEYWORDS.add(\"minus\");\n\t\tKEYWORDS.add(\"except\");\n\t\tKEYWORDS.add(\"intersect\");\n\t\tKEYWORDS.add(\"partition\");\n\n\t\tBEFORE_TABLE_KEYWORDS.add(\"from\");\n\t\tBEFORE_TABLE_KEYWORDS.add(\"join\");\n\n\t\tFUNCTION_KEYWORDS.add(\"as\");\n\t\tFUNCTION_KEYWORDS.add(\"leading\");\n\t\tFUNCTION_KEYWORDS.add(\"trailing\");\n\t\tFUNCTION_KEYWORDS.add(\"from\");\n\t\tFUNCTION_KEYWORDS.add(\"case\");\n\t\tFUNCTION_KEYWORDS.add(\"when\");\n\t\tFUNCTION_KEYWORDS.add(\"then\");\n\t\tFUNCTION_KEYWORDS.add(\"else\");\n\t\tFUNCTION_KEYWORDS.add(\"end\");\n\n\t\tLITERAL_PREFIXES.add(\"n\");\n\t\tLITERAL_PREFIXES.add(\"x\");\n\t\tLITERAL_PREFIXES.add(\"varbyte\");\n\t\tLITERAL_PREFIXES.add(\"bx\");\n\t\tLITERAL_PREFIXES.add(\"bytea\");\n\t\tLITERAL_PREFIXES.add(\"date\");\n\t\tLITERAL_PREFIXES.add(\"time\");\n\t\tLITERAL_PREFIXES.add(\"timestamp\");\n\t\tLITERAL_PREFIXES.add(\"zone\");\n\t}\n\n\tpublic static final String TEMPLATE = \"$PlaceHolder$\";\n\n\tprivate Template() {}\n\n\tpublic static String renderTransformerReadFragment(\n\t\t\tString fragment,\n\t\t\tString... columnNames) {\n\t\t// NOTE : would need access to SessionFactoryImplementor to make this configurable\n\t\tfor ( String columnName : columnNames ) {\n\t\t\tfragment = fragment.replace( columnName, TEMPLATE + '.' + columnName );\n\t\t}\n\t\treturn fragment;\n\t}\n\n\tpublic static String renderWhereStringTemplate(\n\t\t\tString sqlWhereString,\n\t\t\tDialect dialect,\n\t\t\tTypeConfiguration typeConfiguration,\n\t\t\tSqmFunctionRegistry functionRegistry) {\n\t\treturn renderWhereStringTemplate( sqlWhereString, TEMPLATE, dialect, typeConfiguration, functionRegistry );\n\t}\n\n\t/**\n\t * Takes the where condition provided in the mapping attribute and interpolates the alias.\n\t * Handles sub-selects, quoted identifiers, quoted strings, expressions, SQL functions,\n\t * named parameters.\n\t *\n\t * @param sqlWhereString The string into which to interpolate the placeholder value\n\t * @param placeholder The value to be interpolated into the sqlWhereString\n\t * @param dialect The dialect to apply\n\t * @param functionRegistry The registry of all sql functions\n\t * @return The rendered sql fragment\n\t */\n\tpublic static String renderWhereStringTemplate(\n\t\t\tString sqlWhereString,\n\t\t\tString placeholder,\n\t\t\tDialect dialect,\n\t\t\tTypeConfiguration typeConfiguration,\n\t\t\tSqmFunctionRegistry functionRegistry) {\n\n\t\t// IMPL NOTE : The basic process here is to tokenize the incoming string and to iterate over each token\n\t\t//\t\tin turn.  As we process each token, we set a series of flags used to indicate the type of context in\n\t\t// \t\twhich the tokens occur.  Depending on the state of those flags we decide whether we need to qualify\n\t\t//\t\tidentifier references.\n\n\t\tfinal String symbols = PUNCTUATION + WHITESPACE + dialect.openQuote() + dialect.closeQuote();\n\t\tfinal StringTokenizer tokens = new StringTokenizer( sqlWhereString, symbols, true );\n\t\tfinal StringBuilder result = new StringBuilder();\n\n\t\tboolean quoted = false;\n\t\tboolean quotedIdentifier = false;\n\t\tboolean beforeTable = false;\n\t\tboolean inFromClause = false;\n\t\tboolean afterFromTable = false;\n\n\t\tboolean hasMore = tokens.hasMoreTokens();\n\t\tString nextToken = hasMore ? tokens.nextToken() : null;\n\t\twhile ( hasMore ) {\n\t\t\tString token = nextToken;\n\t\t\tString lcToken = token.toLowerCase(Locale.ROOT);\n\t\t\thasMore = tokens.hasMoreTokens();\n\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n\n\t\t\tboolean isQuoteCharacter = false;\n\n\t\t\tif ( !quotedIdentifier && \"'\".equals(token) ) {\n\t\t\t\tquoted = !quoted;\n\t\t\t\tisQuoteCharacter = true;\n\t\t\t}\n\n\t\t\tif ( !quoted ) {\n\t\t\t\tfinal boolean isOpenQuote;\n\t\t\t\tif ( \"`\".equals(token) ) {\n\t\t\t\t\tisOpenQuote = !quotedIdentifier;\n\t\t\t\t\ttoken = lcToken = isOpenQuote\n\t\t\t\t\t\t\t? Character.toString( dialect.openQuote() )\n\t\t\t\t\t\t\t: Character.toString( dialect.closeQuote() );\n\t\t\t\t\tquotedIdentifier = isOpenQuote;\n\t\t\t\t\tisQuoteCharacter = true;\n\t\t\t\t}\n\t\t\t\telse if ( !quotedIdentifier && dialect.openQuote()==token.charAt(0) ) {\n\t\t\t\t\tisOpenQuote = true;\n\t\t\t\t\tquotedIdentifier = true;\n\t\t\t\t\tisQuoteCharacter = true;\n\t\t\t\t}\n\t\t\t\telse if ( quotedIdentifier && dialect.closeQuote()==token.charAt(0) ) {\n\t\t\t\t\tquotedIdentifier = false;\n\t\t\t\t\tisQuoteCharacter = true;\n\t\t\t\t\tisOpenQuote = false;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tisOpenQuote = false;\n\t\t\t\t}\n\t\t\t\tif ( isOpenQuote ) {\n\t\t\t\t\tresult.append( placeholder ).append( '.' );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfinal boolean quotedOrWhitespace =\n\t\t\t\t\tquoted || quotedIdentifier || isQuoteCharacter\n\t\t\t\t\t\t\t|| token.isBlank();\n\t\t\tif ( quotedOrWhitespace ) {\n\t\t\t\tresult.append( token );\n\t\t\t}\n\t\t\telse if ( beforeTable ) {\n\t\t\t\tresult.append( token );\n\t\t\t\tbeforeTable = false;\n\t\t\t\tafterFromTable = true;\n\t\t\t}\n\t\t\telse if ( afterFromTable ) {\n\t\t\t\tif ( !\"as\".equals(lcToken) ) {\n\t\t\t\t\tafterFromTable = false;\n\t\t\t\t}\n\t\t\t\tresult.append(token);\n\t\t\t}\n\t\t\telse if ( isNamedParameter(token) ) {\n\t\t\t\tresult.append(token);\n\t\t\t}\n\t\t\telse if ( isExtractFunction( lcToken, nextToken ) ) {\n\t\t\t\t// Special processing for ANSI SQL EXTRACT function\n\t\t\t\thandleExtractFunction( placeholder, dialect, typeConfiguration, functionRegistry, tokens, result );\n\t\t\t\thasMore = tokens.hasMoreTokens();\n\t\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n\t\t\t}\n\t\t\telse if ( isTrimFunction( lcToken, nextToken ) ) {\n\t\t\t\t// Special processing for ANSI SQL TRIM function\n\t\t\t\thandleTrimFunction( placeholder, dialect, typeConfiguration, functionRegistry, tokens, result );\n\t\t\t\thasMore = tokens.hasMoreTokens();\n\t\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n\t\t\t}\n\t\t\telse if ( isIdentifier(token)\n\t\t\t\t\t&& !isFunctionOrKeyword( lcToken, nextToken, dialect, typeConfiguration, functionRegistry )\n\t\t\t\t\t&& !isLiteral( lcToken, nextToken, sqlWhereString, symbols, tokens ) ) {\n\t\t\t\tresult.append(placeholder)\n\t\t\t\t\t\t.append('.')\n\t\t\t\t\t\t.append( dialect.quote(token) );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif ( BEFORE_TABLE_KEYWORDS.contains(lcToken) ) {\n\t\t\t\t\tbeforeTable = true;\n\t\t\t\t\tinFromClause = true;\n\t\t\t\t}\n\t\t\t\telse if ( inFromClause && \",\".equals(lcToken) ) {\n\t\t\t\t\tbeforeTable = true;\n\t\t\t\t}\n\t\t\t\tif ( isBoolean( token ) ) {\n\t\t\t\t\ttoken = dialect.toBooleanValueString( parseBoolean( token ) );\n\t\t\t\t}\n\t\t\t\tresult.append(token);\n\t\t\t}\n\n\t\t\t//Yuck:\n\t\t\tif ( inFromClause\n\t\t\t\t\t&& KEYWORDS.contains( lcToken ) //\"as\" is not in KEYWORDS\n\t\t\t\t\t&& !BEFORE_TABLE_KEYWORDS.contains( lcToken ) ) {\n\t\t\t\tinFromClause = false;\n\t\t\t}\n\t\t}\n\n\t\treturn result.toString();\n\t}\n\n\tprivate static boolean isTrimFunction(String lcToken, String nextToken) {\n\t\treturn \"trim\".equals(lcToken) && \"(\".equals(nextToken);\n\t}\n\n\tprivate static boolean isExtractFunction(String lcToken, String nextToken) {\n\t\treturn \"extract\".equals(lcToken) && \"(\".equals(nextToken);\n\t}\n\n\tprivate static boolean isLiteral(\n\t\t\tString lcToken, String next,\n\t\t\tString sqlWhereString, String symbols, StringTokenizer tokens) {\n\t\tif ( LITERAL_PREFIXES.contains( lcToken ) && next != null ) {\n\t\t\t// easy cases first\n\t\t\tif ( \"'\".equals(next) ) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse if ( !next.isBlank() ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// we need to look ahead in the token stream\n\t\t\t\t// to find the first non-blank token\n\t\t\t\tfinal StringTokenizer lookahead =\n\t\t\t\t\t\tnew StringTokenizer( sqlWhereString, symbols, true );\n\t\t\t\twhile ( lookahead.countTokens() > tokens.countTokens()+1 ) {\n\t\t\t\t\tlookahead.nextToken();\n\t\t\t\t}\n\t\t\t\tif ( lookahead.hasMoreTokens() ) {\n\t\t\t\t\tString nextToken;\n\t\t\t\t\tdo {\n\t\t\t\t\t\tnextToken = lookahead.nextToken().toLowerCase(Locale.ROOT);\n\t\t\t\t\t}\n\t\t\t\t\twhile ( nextToken.isBlank() && lookahead.hasMoreTokens() );\n\t\t\t\t\treturn \"'\".equals( nextToken )\n\t\t\t\t\t\t|| lcToken.equals( \"time\" ) && \"with\".equals( nextToken )\n\t\t\t\t\t\t|| lcToken.equals( \"timestamp\" ) && \"with\".equals( nextToken )\n\t\t\t\t\t\t|| lcToken.equals( \"time\" ) && \"zone\".equals( nextToken );\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tprivate static void handleTrimFunction(\n\t\t\tString placeholder, Dialect dialect,\n\t\t\tTypeConfiguration typeConfiguration,\n\t\t\tSqmFunctionRegistry functionRegistry,\n\t\t\tStringTokenizer tokens,\n\t\t\tStringBuilder result) {\n\t\tfinal List<String> operands = new ArrayList<>();\n\t\tfinal StringBuilder builder = new StringBuilder();\n\n\t\tboolean hasMoreOperands = true;\n\t\tString operandToken = tokens.nextToken();\n\t\tswitch ( operandToken.toLowerCase( Locale.ROOT ) ) {\n\t\t\tcase \"leading\":\n\t\t\tcase \"trailing\":\n\t\t\tcase \"both\":\n\t\t\t\toperands.add( operandToken );\n\t\t\t\tif ( hasMoreOperands = tokens.hasMoreTokens() ) {\n\t\t\t\t\toperandToken = tokens.nextToken();\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t\tboolean quotedOperand = false;\n\t\tint parenthesis = 0;\n\t\twhile ( hasMoreOperands ) {\n\t\t\tfinal boolean isQuote = \"'\".equals( operandToken );\n\t\t\tif ( isQuote ) {\n\t\t\t\tquotedOperand = !quotedOperand;\n\t\t\t\tif ( !quotedOperand ) {\n\t\t\t\t\toperands.add( builder.append( '\\'' ).toString() );\n\t\t\t\t\tbuilder.setLength( 0 );\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tbuilder.append( '\\'' );\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if ( quotedOperand ) {\n\t\t\t\tbuilder.append( operandToken );\n\t\t\t}\n\t\t\telse if ( parenthesis != 0 ) {\n\t\t\t\tbuilder.append( operandToken );\n\t\t\t\tswitch ( operandToken ) {\n\t\t\t\t\tcase \"(\":\n\t\t\t\t\t\tparenthesis++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \")\":\n\t\t\t\t\t\tparenthesis--;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbuilder.append( operandToken );\n\t\t\t\tswitch ( operandToken.toLowerCase( Locale.ROOT ) ) {\n\t\t\t\t\tcase \"(\":\n\t\t\t\t\t\tparenthesis++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \")\":\n\t\t\t\t\t\tparenthesis--;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"from\":\n\t\t\t\t\t\tif ( !builder.isEmpty() ) {\n\t\t\t\t\t\t\toperands.add( builder.substring( 0, builder.length() - 4 ) );\n\t\t\t\t\t\t\tbuilder.setLength( 0 );\n\t\t\t\t\t\t\toperands.add( operandToken );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\toperandToken = tokens.nextToken();\n\t\t\thasMoreOperands = tokens.hasMoreTokens()\n\t\t\t\t\t&& ( parenthesis != 0 || ! \")\".equals( operandToken ) );\n\t\t}\n\t\tif ( !builder.isEmpty() ) {\n\t\t\toperands.add( builder.toString() );\n\t\t}\n\n\t\tfinal TrimOperands trimOperands = new TrimOperands( operands );\n\t\tresult.append( \"trim(\" );\n\t\tif ( trimOperands.trimSpec != null ) {\n\t\t\tresult.append( trimOperands.trimSpec ).append( ' ' );\n\t\t}\n\t\tif ( trimOperands.trimChar != null ) {\n\t\t\tif ( trimOperands.trimChar.startsWith( \"'\" ) && trimOperands.trimChar.endsWith( \"'\" ) ) {\n\t\t\t\tresult.append( trimOperands.trimChar );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tresult.append(\n\t\t\t\t\t\trenderWhereStringTemplate( trimOperands.trimSpec, placeholder, dialect, typeConfiguration, functionRegistry )\n\t\t\t\t);\n\t\t\t}\n\t\t\tresult.append( ' ' );\n\t\t}\n\t\tif ( trimOperands.from != null ) {\n\t\t\tresult.append( trimOperands.from ).append( ' ' );\n\t\t}\n\t\telse if ( trimOperands.trimSpec != null || trimOperands.trimChar != null ) {\n\t\t\t// I think ANSI SQL says that the 'from' is not optional if either trim-spec or trim-char is specified\n\t\t\tresult.append( \"from \" );\n\t\t}\n\n\t\tresult.append( renderWhereStringTemplate( trimOperands.trimSource, placeholder, dialect, typeConfiguration, functionRegistry ) )\n\t\t\t\t.append( ')' );\n\t}\n\n\tprivate static void handleExtractFunction(\n\t\t\tString placeholder,\n\t\t\tDialect dialect,\n\t\t\tTypeConfiguration typeConfiguration,\n\t\t\tSqmFunctionRegistry functionRegistry,\n\t\t\tStringTokenizer tokens,\n\t\t\tStringBuilder result) {\n\t\tfinal String field = extractUntil( tokens, \"from\" );\n\t\tfinal String source = renderWhereStringTemplate(\n\t\t\t\textractUntil( tokens, \")\" ),\n\t\t\t\tplaceholder,\n\t\t\t\tdialect,\n\t\t\t\ttypeConfiguration,\n\t\t\t\tfunctionRegistry\n\t\t);\n\t\tresult.append( \"extract(\" ).append( field ).append( \" from \" ).append( source ).append( ')' );\n\t}\n\n\tpublic static List<String> collectColumnNames(\n\t\t\tString sql,\n\t\t\tDialect dialect,\n\t\t\tTypeConfiguration typeConfiguration,\n\t\t\tSqmFunctionRegistry functionRegistry) {\n\t\treturn collectColumnNames( renderWhereStringTemplate( sql, dialect, typeConfiguration, functionRegistry ) );\n\t}\n\n\tpublic static List<String> collectColumnNames(String template) {\n\t\tfinal List<String> names = new ArrayList<>();\n\t\tint begin = 0;\n\t\tint match;\n\t\twhile ( ( match = template.indexOf(TEMPLATE, begin) ) >= 0 ) {\n\t\t\tint start = match + TEMPLATE.length() + 1;\n\t\t\tfor ( int loc = start;; loc++ ) {\n\t\t\t\tif ( loc == template.length() - 1 ) {\n\t\t\t\t\tnames.add( template.substring( start ) );\n\t\t\t\t\tbegin = template.length();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tchar ch = template.charAt( loc );\n\t\t\t\t\tif ( PUNCTUATION.indexOf(ch) >= 0 || WHITESPACE.indexOf(ch) >= 0 ) {\n\t\t\t\t\t\tnames.add( template.substring( start, loc ) );\n\t\t\t\t\t\tbegin = loc;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn names;\n\t}\n\n//\t/**\n//\t * Takes the where condition provided in the mapping attribute and interpolates the alias.\n//\t * Handles sub-selects, quoted identifiers, quoted strings, expressions, SQL functions,\n//\t * named parameters.\n//\t *\n//\t * @param sqlWhereString The string into which to interpolate the placeholder value\n//\t * @param placeholder The value to be interpolated into the sqlWhereString\n//\t * @param dialect The dialect to apply\n//\t * @param functionRegistry The registry of all sql functions\n//\t *\n//\t * @return The rendered sql fragment\n//\t */\n//\tpublic static String renderWhereStringTemplate(\n//\t\t\tString sqlWhereString,\n//\t\t\tString placeholder,\n//\t\t\tDialect dialect,\n//\t\t\tSQLFunctionRegistry functionRegistry) {\n//\n//\t\t// IMPL NOTE : The basic process here is to tokenize the incoming string and to iterate over each token\n//\t\t//\t\tin turn.  As we process each token, we set a series of flags used to indicate the type of context in\n//\t\t// \t\twhich the tokens occur.  Depending on the state of those flags we decide whether we need to qualify\n//\t\t//\t\tidentifier references.\n//\n//\t\tfinal String dialectOpenQuote = Character.toString( dialect.openQuote() );\n//\t\tfinal String dialectCloseQuote = Character.toString( dialect.closeQuote() );\n//\n//\t\tString symbols = new StringBuilder()\n//\t\t\t\t.append( \"=><!+-*/()',|&`\" )\n//\t\t\t\t.append( StringHelper.WHITESPACE )\n//\t\t\t\t.append( dialect.openQuote() )\n//\t\t\t\t.append( dialect.closeQuote() )\n//\t\t\t\t.toString();\n//\t\tStringTokenizer tokens = new StringTokenizer( sqlWhereString, symbols, true );\n//\t\tProcessingState state = new ProcessingState();\n//\n//\t\tStringBuilder quotedBuffer = new StringBuilder();\n//\t\tStringBuilder result = new StringBuilder();\n//\n//\t\tboolean hasMore = tokens.hasMoreTokens();\n//\t\tString nextToken = hasMore ? tokens.nextToken() : null;\n//\t\twhile ( hasMore ) {\n//\t\t\tString token = nextToken;\n//\t\t\tString lcToken = token.toLowerCase(Locale.ROOT);\n//\t\t\thasMore = tokens.hasMoreTokens();\n//\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n//\n//\t\t\t// First, determine quoting which might be based on either:\n//\t\t\t// \t\t1) back-tick\n//\t\t\t// \t\t2) single quote (ANSI SQL standard)\n//\t\t\t// \t\t3) or dialect defined quote character(s)\n//\t\t\tQuotingCharacterDisposition quotingCharacterDisposition = QuotingCharacterDisposition.NONE;\n//\t\t\tif ( \"`\".equals( token ) ) {\n//\t\t\t\tstate.quoted = !state.quoted;\n//\t\t\t\tquotingCharacterDisposition = state.quoted\n//\t\t\t\t\t\t? QuotingCharacterDisposition.OPEN\n//\t\t\t\t\t\t: QuotingCharacterDisposition.CLOSE;\n//\t\t\t\t// replace token with the appropriate dialect quoting char\n//\t\t\t\ttoken = lcToken = ( quotingCharacterDisposition == QuotingCharacterDisposition.OPEN )\n//\t\t\t\t\t\t? dialectOpenQuote\n//\t\t\t\t\t\t: dialectCloseQuote;\n//\t\t\t}\n//\t\t\telse if ( \"'\".equals( token ) ) {\n//\t\t\t\tstate.quoted = !state.quoted;\n//\t\t\t\tquotingCharacterDisposition = state.quoted\n//\t\t\t\t\t\t? QuotingCharacterDisposition.OPEN\n//\t\t\t\t\t\t: QuotingCharacterDisposition.CLOSE;\n//\t\t\t}\n//\t\t\telse if ( !state.quoted && dialectOpenQuote.equals( token ) ) {\n//\t\t\t\tstate.quoted = true;\n//\t\t\t\tquotingCharacterDisposition = QuotingCharacterDisposition.OPEN;\n//\t\t\t}\n//\t\t\telse if ( state.quoted && dialectCloseQuote.equals( token ) ) {\n//\t\t\t\tstate.quoted = false;\n//\t\t\t\tquotingCharacterDisposition = QuotingCharacterDisposition.CLOSE;\n//\t\t\t}\n//\n//\t\t\tif ( state.quoted ) {\n//\t\t\t\tquotedBuffer.append( token );\n//\t\t\t\tcontinue;\n//\t\t\t}\n//\n//\t\t\t// if we were previously processing quoted state and just encountered the close quote, then handle that\n//\t\t\t// quoted text\n//\t\t\tif ( quotingCharacterDisposition == QuotingCharacterDisposition.CLOSE ) {\n//\t\t\t\ttoken = quotedBuffer.toString();\n//\t\t\t\tquotedBuffer.setLength( 0 );\n//\t\t\t\tresult.append( placeholder ).append( '.' )\n//\t\t\t\t\t\t.append( dialectOpenQuote ).append( token ).append( dialectCloseQuote );\n//\t\t\t\tcontinue;\n//\t\t\t}\n//\n//\t\t\t// Special processing for ANSI SQL EXTRACT function\n//\t\t\tif ( \"extract\".equals( lcToken ) && \"(\".equals( nextToken ) ) {\n//\t\t\t\tfinal String field = extractUntil( tokens, \"from\" );\n//\t\t\t\tfinal String source = renderWhereStringTemplate(\n//\t\t\t\t\t\textractUntil( tokens, \")\" ),\n//\t\t\t\t\t\tplaceholder,\n//\t\t\t\t\t\tdialect,\n//\t\t\t\t\t\tfunctionRegistry\n//\t\t\t\t);\n//\t\t\t\tresult.append( \"extract(\" ).append( field ).append( \" from \" ).append( source ).append( ')' );\n//\n//\t\t\t\thasMore = tokens.hasMoreTokens();\n//\t\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n//\n//\t\t\t\tcontinue;\n//\t\t\t}\n//\n//\t\t\t// Special processing for ANSI SQL TRIM function\n//\t\t\tif ( \"trim\".equals( lcToken ) && \"(\".equals( nextToken ) ) {\n//\t\t\t\tList<String> operands = new ArrayList<String>();\n//\t\t\t\tStringBuilder builder = new StringBuilder();\n//\n//\t\t\t\tboolean hasMoreOperands = true;\n//\t\t\t\tString operandToken = tokens.nextToken();\n//\t\t\t\tboolean quoted = false;\n//\t\t\t\twhile ( hasMoreOperands ) {\n//\t\t\t\t\tfinal boolean isQuote = \"'\".equals( operandToken );\n//\t\t\t\t\tif ( isQuote ) {\n//\t\t\t\t\t\tquoted = !quoted;\n//\t\t\t\t\t\tif ( !quoted ) {\n//\t\t\t\t\t\t\toperands.add( builder.append( '\\'' ).toString() );\n//\t\t\t\t\t\t\tbuilder.setLength( 0 );\n//\t\t\t\t\t\t}\n//\t\t\t\t\t\telse {\n//\t\t\t\t\t\t\tbuilder.append( '\\'' );\n//\t\t\t\t\t\t}\n//\t\t\t\t\t}\n//\t\t\t\t\telse if ( quoted ) {\n//\t\t\t\t\t\tbuilder.append( operandToken );\n//\t\t\t\t\t}\n//\t\t\t\t\telse if ( operandToken.length() == 1 && Character.isWhitespace( operandToken.charAt( 0 ) ) ) {\n//\t\t\t\t\t\t// do nothing\n//\t\t\t\t\t}\n//\t\t\t\t\telse {\n//\t\t\t\t\t\toperands.add( operandToken );\n//\t\t\t\t\t}\n//\t\t\t\t\toperandToken = tokens.nextToken();\n//\t\t\t\t\thasMoreOperands = tokens.hasMoreTokens() && ! \")\".equals( operandToken );\n//\t\t\t\t}\n//\n//\t\t\t\tTrimOperands trimOperands = new TrimOperands( operands );\n//\t\t\t\tresult.append( \"trim(\" );\n//\t\t\t\tif ( trimOperands.trimSpec != null ) {\n//\t\t\t\t\tresult.append( trimOperands.trimSpec ).append( ' ' );\n//\t\t\t\t}\n//\t\t\t\tif ( trimOperands.trimChar != null ) {\n//\t\t\t\t\tif ( trimOperands.trimChar.startsWith( \"'\" ) && trimOperands.trimChar.endsWith( \"'\" ) ) {\n//\t\t\t\t\t\tresult.append( trimOperands.trimChar );\n//\t\t\t\t\t}\n//\t\t\t\t\telse {\n//\t\t\t\t\t\tresult.append(\n//\t\t\t\t\t\t\t\trenderWhereStringTemplate( trimOperands.trimSpec, placeholder, dialect, functionRegistry )\n//\t\t\t\t\t\t);\n//\t\t\t\t\t}\n//\t\t\t\t\tresult.append( ' ' );\n//\t\t\t\t}\n//\t\t\t\tif ( trimOperands.from != null ) {\n//\t\t\t\t\tresult.append( trimOperands.from ).append( ' ' );\n//\t\t\t\t}\n//\t\t\t\telse if ( trimOperands.trimSpec != null || trimOperands.trimChar != null ) {\n//\t\t\t\t\t// I think ANSI SQL says that the 'from' is not optional if either trim-spec or trim-char are specified\n//\t\t\t\t\tresult.append( \"from \" );\n//\t\t\t\t}\n//\n//\t\t\t\tresult.append( renderWhereStringTemplate( trimOperands.trimSource, placeholder, dialect, functionRegistry ) )\n//\t\t\t\t\t\t.append( ')' );\n//\n//\t\t\t\thasMore = tokens.hasMoreTokens();\n//\t\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n//\n//\t\t\t\tcontinue;\n//\t\t\t}\n//\n//\n//\t\t\t// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n//\n//\t\t\tif ( Character.isWhitespace( token.charAt( 0 ) ) ) {\n//\t\t\t\tresult.append( token );\n//\t\t\t}\n//\t\t\telse if ( state.beforeTable ) {\n//\t\t\t\tresult.append( token );\n//\t\t\t\tstate.beforeTable = false;\n//\t\t\t\tstate.afterFromTable = true;\n//\t\t\t}\n//\t\t\telse if ( state.afterFromTable ) {\n//\t\t\t\tif ( !\"as\".equals(lcToken) ) {\n//\t\t\t\t\tstate.afterFromTable = false;\n//\t\t\t\t}\n//\t\t\t\tresult.append(token);\n//\t\t\t}\n//\t\t\telse if ( isNamedParameter(token) ) {\n//\t\t\t\tresult.append(token);\n//\t\t\t}\n//\t\t\telse if ( isIdentifier(token, dialect)\n//\t\t\t\t\t&& !isFunctionOrKeyword(lcToken, nextToken, dialect , functionRegistry) ) {\n//\t\t\t\tresult.append(placeholder)\n//\t\t\t\t\t\t.append('.')\n//\t\t\t\t\t\t.append( dialect.quote(token) );\n//\t\t\t}\n//\t\t\telse {\n//\t\t\t\tif ( BEFORE_TABLE_KEYWORDS.contains(lcToken) ) {\n//\t\t\t\t\tstate.beforeTable = true;\n//\t\t\t\t\tstate.inFromClause = true;\n//\t\t\t\t}\n//\t\t\t\telse if ( state.inFromClause && \",\".equals(lcToken) ) {\n//\t\t\t\t\tstate.beforeTable = true;\n//\t\t\t\t}\n//\t\t\t\tresult.append(token);\n//\t\t\t}\n//\n//\t\t\t//Yuck:\n//\t\t\tif ( state.inFromClause\n//\t\t\t\t\t&& KEYWORDS.contains( lcToken ) //\"as\" is not in KEYWORDS\n//\t\t\t\t\t&& !BEFORE_TABLE_KEYWORDS.contains( lcToken ) ) {\n//\t\t\t\tstate.inFromClause = false;\n//\t\t\t}\n//\t\t}\n//\n//\t\treturn result.toString();\n//\t}\n//\n//\tprivate static class ProcessingState {\n//\t\tboolean quoted = false;\n//\t\tboolean quotedIdentifier = false;\n//\t\tboolean beforeTable = false;\n//\t\tboolean inFromClause = false;\n//\t\tboolean afterFromTable = false;\n//\t}\n//\n//\tprivate static enum QuotingCharacterDisposition { NONE, OPEN, CLOSE }\n\n\tprivate static class TrimOperands {\n\t\tprivate final String trimSpec;\n\t\tprivate final String trimChar;\n\t\tprivate final String from;\n\t\tprivate final String trimSource;\n\n\t\tprivate TrimOperands(List<String> operands) {\n\t\t\tfinal int size = operands.size();\n\t\t\tif ( size == 1 ) {\n\t\t\t\ttrimSpec = null;\n\t\t\t\ttrimChar = null;\n\t\t\t\tfrom = null;\n\t\t\t\ttrimSource = operands.get(0);\n\t\t\t}\n\t\t\telse if ( size == 4 ) {\n\t\t\t\ttrimSpec = operands.get(0);\n\t\t\t\ttrimChar = operands.get(1);\n\t\t\t\tfrom = operands.get(2);\n\t\t\t\ttrimSource = operands.get(3);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif ( size < 1 || size > 4 ) {\n\t\t\t\t\tthrow new HibernateException( \"Unexpected number of trim function operands : \" + size );\n\t\t\t\t}\n\n\t\t\t\t// trim-source will always be the last operand\n\t\t\t\ttrimSource = operands.get( size - 1 );\n\n\t\t\t\t// ANSI SQL says that more than one operand means that the FROM is required\n\t\t\t\tif ( ! \"from\".equals( operands.get( size - 2 ) ) ) {\n\t\t\t\t\tthrow new HibernateException( \"Expecting FROM, found : \" + operands.get( size - 2 ) );\n\t\t\t\t}\n\t\t\t\tfrom = operands.get( size - 2 );\n\n\t\t\t\t// trim-spec, if there is one will always be the first operand\n\t\t\t\tif ( \"leading\".equalsIgnoreCase( operands.get(0) )\n\t\t\t\t\t\t|| \"trailing\".equalsIgnoreCase( operands.get(0) )\n\t\t\t\t\t\t|| \"both\".equalsIgnoreCase( operands.get(0) ) ) {\n\t\t\t\t\ttrimSpec = operands.get(0);\n\t\t\t\t\ttrimChar = null;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ttrimSpec = null;\n\t\t\t\t\tif ( size - 2 == 0 ) {\n\t\t\t\t\t\ttrimChar = null;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\ttrimChar = operands.get( 0 );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate static String extractUntil(StringTokenizer tokens, String delimiter) {\n\t\tfinal StringBuilder valueBuilder = new StringBuilder();\n\t\tString token = tokens.nextToken();\n\t\twhile ( ! delimiter.equalsIgnoreCase( token ) ) {\n\t\t\tvalueBuilder.append( token );\n\t\t\ttoken = tokens.nextToken();\n\t\t}\n\t\treturn valueBuilder.toString().trim();\n\t}\n\n\tprivate static boolean isNamedParameter(String token) {\n\t\treturn token.startsWith( \":\" );\n\t}\n\n\tprivate static boolean isFunctionOrKeyword(\n\t\t\tString lcToken,\n\t\t\tString nextToken,\n\t\t\tDialect dialect,\n\t\t\tTypeConfiguration typeConfiguration,\n\t\t\tSqmFunctionRegistry functionRegistry) {\n\t\tif ( \"(\".equals( nextToken ) ) {\n\t\t\treturn true;\n\t\t}\n\t\telse if ( \"date\".equals( lcToken ) || \"time\".equals( lcToken ) ) {\n\t\t\t// these can be column names on some databases\n\t\t\t// TODO: treat 'current date' as a function\n\t\t\treturn false;\n\t\t}\n\t\telse {\n\t\t\treturn KEYWORDS.contains( lcToken )\n\t\t\t\t|| isType( lcToken, typeConfiguration )\n\t\t\t\t|| isFunction( lcToken, nextToken, functionRegistry )\n\t\t\t\t|| dialect.getKeywords().contains( lcToken )\n\t\t\t\t|| FUNCTION_KEYWORDS.contains( lcToken );\n\t\t}\n\t}\n\n\tprivate static boolean isType(String lcToken, TypeConfiguration typeConfiguration) {\n\t\treturn typeConfiguration.getDdlTypeRegistry().isTypeNameRegistered( lcToken );\n\t}\n\n\tprivate static boolean isFunction(String lcToken, String nextToken, SqmFunctionRegistry functionRegistry) {\n\t\t// checking for \"(\" is currently redundant because it is checked before getting here;\n\t\t// doing the check anyhow, in case that earlier check goes away;\n\t\tif ( \"(\".equals( nextToken ) ) {\n\t\t\treturn true;\n\t\t}\n\n\t\tfinal SqmFunctionDescriptor function = functionRegistry.findFunctionDescriptor( lcToken );\n\t\treturn function != null;\n\t}\n\n\tprivate static boolean isIdentifier(String token) {\n\t\tif ( isBoolean( token ) ) {\n\t\t\treturn false;\n\t\t}\n\t\treturn token.charAt( 0 ) == '`'\n\t\t\t|| ( //allow any identifier quoted with backtick\n\t\t\t\tisLetter( token.charAt( 0 ) ) && //only recognizes identifiers beginning with a letter\n\t\t\t\t\t\ttoken.indexOf( '.' ) < 0\n\t\t\t);\n\t}\n\n\tprivate static boolean isBoolean(String token) {\n\t\treturn \"true\".equals( token ) || \"false\".equals( token );\n\t}\n}\n",
        "filePathAfter": "hibernate-core/src/main/java/org/hibernate/sql/Template.java",
        "sourceCodeAfterForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.\n */\npackage org.hibernate.sql;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Set;\nimport java.util.StringTokenizer;\nimport java.util.function.Function;\n\nimport org.hibernate.dialect.Dialect;\nimport org.hibernate.type.spi.TypeConfiguration;\n\nimport static java.lang.Boolean.parseBoolean;\nimport static java.lang.Character.isLetter;\nimport static org.hibernate.internal.util.StringHelper.WHITESPACE;\n\n/**\n * Parses SQL fragments specified in mapping documents. The SQL fragment\n * should be written in the native SQL dialect of the target database,\n * with the following special exceptions:\n * <ul>\n *     <li>any backtick-quoted identifiers, for example {@code `hello`},\n *     is interpreted as a quoted identifier and re-quoted using the\n *     {@linkplain Dialect#quote native quoted identifier syntax} of\n *     the database, and</li>\n *     <li>the literal identifiers {@code true} and {@code false} are\n *     interpreted are literal boolean values, and replaced with\n *     {@linkplain Dialect#toBooleanValueString dialect-specific\n *     literal values}.\n *     </li>\n * </ul>\n *\n * @implNote This is based on a simple scanner-based state machine.\n *           It is NOT in any way, shape, nor form, a parser, since\n *           we simply cannot recognize the syntax of every dialect\n *           of SQL we support.\n *\n * @author Gavin King\n */\npublic final class Template {\n\n\tprivate static final Set<String> KEYWORDS = Set.of(\n\t\t\t\"and\",\n\t\t\t\"or\",\n\t\t\t\"not\",\n\t\t\t\"like\",\n\t\t\t\"escape\",\n\t\t\t\"is\",\n\t\t\t\"in\",\n\t\t\t\"between\",\n\t\t\t\"null\",\n\t\t\t\"select\",\n\t\t\t\"distinct\",\n\t\t\t\"from\",\n\t\t\t\"join\",\n\t\t\t\"inner\",\n\t\t\t\"outer\",\n\t\t\t\"left\",\n\t\t\t\"right\",\n\t\t\t\"on\",\n\t\t\t\"where\",\n\t\t\t\"having\",\n\t\t\t\"group\",\n\t\t\t\"order\",\n\t\t\t\"by\",\n\t\t\t\"desc\",\n\t\t\t\"asc\",\n\t\t\t\"limit\",\n\t\t\t\"any\",\n\t\t\t\"some\",\n\t\t\t\"exists\",\n\t\t\t\"all\",\n\t\t\t\"union\",\n\t\t\t\"minus\",\n\t\t\t\"except\",\n\t\t\t\"intersect\",\n\t\t\t\"partition\");\n\tprivate static final Set<String> BEFORE_TABLE_KEYWORDS\n\t\t\t= Set.of(\"from\", \"join\");\n\tprivate static final Set<String> FUNCTION_KEYWORDS\n\t\t\t= Set.of(\"as\", \"leading\", \"trailing\", \"from\", \"case\", \"when\", \"then\", \"else\", \"end\");\n\tprivate static final Set<String> FUNCTION_WITH_FROM_KEYWORDS\n\t\t\t= Set.of(\"extract\", \"trim\");\n\tprivate static final Set<String> SOFT_KEYWORDS\n\t\t\t= Set.of(\"date\", \"time\");\n\tprivate static final Set<String> LITERAL_PREFIXES\n\t\t\t= Set.of(\"n\", \"x\", \"varbyte\", \"bx\", \"bytea\", \"date\", \"time\", \"timestamp\", \"zone\");\n\n\tprivate static final String PUNCTUATION = \"=><!+-*/()',|&`\";\n\n\tpublic static final String TEMPLATE = \"{@}\";\n\n\tprivate Template() {}\n\n\tpublic static String renderTransformerReadFragment(\n\t\t\tString fragment,\n\t\t\tString... columnNames) {\n\t\t// NOTE : would need access to SessionFactoryImplementor to make this configurable\n\t\tfor ( String columnName : columnNames ) {\n\t\t\tfragment = fragment.replace( columnName, TEMPLATE + '.' + columnName );\n\t\t}\n\t\treturn fragment;\n\t}\n\n\t/**\n\t * Takes the SQL fragment provided in the mapping attribute and interpolates the default\n\t * {@linkplain #TEMPLATE placeholder value}, which is {@value #TEMPLATE}, using it to\n\t * qualify every unqualified column name.\n\t * <p>\n\t * Handles subselects, quoted identifiers, quoted strings, expressions, SQL functions,\n\t * named parameters, literals.\n\t *\n\t * @param sql The SQL string into which to interpolate the placeholder value\n\t * @param dialect The dialect to apply\n\t * @return The rendered SQL fragment\n\t */\n\tpublic static String renderWhereStringTemplate(\n\t\t\tString sql,\n\t\t\tDialect dialect,\n\t\t\tTypeConfiguration typeConfiguration) {\n\t\treturn renderWhereStringTemplate( sql, TEMPLATE, dialect, typeConfiguration );\n\t}\n\n\t/**\n\t * Takes the SQL fragment provided in the mapping attribute and interpolates the given\n\t * alias, using it to qualify every unqualified column name.\n\t * <p>\n\t * Handles subselects, quoted identifiers, quoted strings, expressions, SQL functions,\n\t * named parameters, literals.\n\t *\n\t * @param sql The SQL string into which to interpolate the alias value\n\t * @param alias The alias to be interpolated into the SQL\n\t * @param dialect The dialect to apply\n\t * @return The rendered SQL fragment\n\t */\n\tpublic static String renderWhereStringTemplate(\n\t\t\tString sql,\n\t\t\tString alias,\n\t\t\tDialect dialect,\n\t\t\tTypeConfiguration typeConfiguration) {\n\n\t\t// IMPL NOTE: The basic process here is to tokenize the incoming string and to iterate over each token\n\t\t//\t\tin turn. As we process each token, we set a series of flags used to indicate the type of context in\n\t\t// \t\twhich the tokens occur. Depending on the state of those flags we decide whether we need to qualify\n\t\t//\t\tidentifier references.\n\n\t\t// WARNING TO MAINTAINERS: This is a simple scanner-based state machine. Please don't attempt to turn it into\n\t\t//      a parser for SQL, no matter how \"special\" your case is. What I mean by this is: don't write code which\n\t\t//      attempts to recognize the grammar of SQL, not even little bits of SQL. Previous \"enhancements\" to this\n\t\t//      function did not respect this concept, and resulted in code which was fragile and unmaintainable. If\n\t\t//      lookahead is truly necessary, use the lookahead() function provided below.\n\n\t\tfinal String symbols = PUNCTUATION + WHITESPACE + dialect.openQuote() + dialect.closeQuote();\n\t\tfinal StringTokenizer tokens = new StringTokenizer( sql, symbols, true );\n\t\tfinal StringBuilder result = new StringBuilder();\n\n\t\tboolean quoted = false;\n\t\tboolean quotedIdentifier = false;\n\t\tboolean beforeTable = false;\n\t\tboolean inFromClause = false;\n\t\tboolean afterFromTable = false;\n\t\tboolean inExtractOrTrim = false;\n\n\t\tboolean hasMore = tokens.hasMoreTokens();\n\t\tString nextToken = hasMore ? tokens.nextToken() : null;\n\t\twhile ( hasMore ) {\n\t\t\tString token = nextToken;\n\t\t\tString lcToken = token.toLowerCase(Locale.ROOT);\n\t\t\thasMore = tokens.hasMoreTokens();\n\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n\n\t\t\tboolean isQuoteCharacter = false;\n\n\t\t\tif ( !quotedIdentifier && \"'\".equals(token) ) {\n\t\t\t\tquoted = !quoted;\n\t\t\t\tisQuoteCharacter = true;\n\t\t\t}\n\n\t\t\tif ( !quoted ) {\n\t\t\t\tfinal boolean isOpenQuote;\n\t\t\t\tif ( \"`\".equals(token) ) {\n\t\t\t\t\tisOpenQuote = !quotedIdentifier;\n\t\t\t\t\ttoken = lcToken = isOpenQuote\n\t\t\t\t\t\t\t? Character.toString( dialect.openQuote() )\n\t\t\t\t\t\t\t: Character.toString( dialect.closeQuote() );\n\t\t\t\t\tquotedIdentifier = isOpenQuote;\n\t\t\t\t\tisQuoteCharacter = true;\n\t\t\t\t}\n\t\t\t\telse if ( !quotedIdentifier && dialect.openQuote()==token.charAt(0) ) {\n\t\t\t\t\tisOpenQuote = true;\n\t\t\t\t\tquotedIdentifier = true;\n\t\t\t\t\tisQuoteCharacter = true;\n\t\t\t\t}\n\t\t\t\telse if ( quotedIdentifier && dialect.closeQuote()==token.charAt(0) ) {\n\t\t\t\t\tquotedIdentifier = false;\n\t\t\t\t\tisQuoteCharacter = true;\n\t\t\t\t\tisOpenQuote = false;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tisOpenQuote = false;\n\t\t\t\t}\n\t\t\t\tif ( isOpenQuote ) {\n\t\t\t\t\tresult.append( alias ).append( '.' );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfinal boolean quotedOrWhitespace =\n\t\t\t\t\tquoted || quotedIdentifier || isQuoteCharacter\n\t\t\t\t\t\t\t|| token.isBlank();\n\t\t\tif ( quotedOrWhitespace ) {\n\t\t\t\tresult.append( token );\n\t\t\t}\n\t\t\telse if ( beforeTable ) {\n\t\t\t\tresult.append( token );\n\t\t\t\tbeforeTable = false;\n\t\t\t\tafterFromTable = true;\n\t\t\t}\n\t\t\telse if ( afterFromTable ) {\n\t\t\t\tif ( !\"as\".equals(lcToken) ) {\n\t\t\t\t\tafterFromTable = false;\n\t\t\t\t}\n\t\t\t\tresult.append(token);\n\t\t\t}\n\t\t\telse if ( isNamedParameter(token) ) {\n\t\t\t\tresult.append(token);\n\t\t\t}\n\t\t\telse if ( FUNCTION_WITH_FROM_KEYWORDS.contains(lcToken) && \"(\".equals( nextToken ) ) {\n\t\t\t\tresult.append(token);\n\t\t\t\tinExtractOrTrim = true;\n\t\t\t}\n\t\t\telse if ( isIdentifier(token)\n\t\t\t\t\t&& !isFunctionOrKeyword( lcToken, nextToken, dialect, typeConfiguration )\n\t\t\t\t\t&& !isLiteral( lcToken, nextToken, sql, symbols, tokens ) ) {\n\t\t\t\tresult.append(alias)\n\t\t\t\t\t\t.append('.')\n\t\t\t\t\t\t.append( dialect.quote(token) );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif ( \")\".equals( lcToken) ) {\n\t\t\t\t\tinExtractOrTrim = false;\n\t\t\t\t}\n\t\t\t\telse if ( !inExtractOrTrim\n\t\t\t\t\t\t&& BEFORE_TABLE_KEYWORDS.contains(lcToken) ) {\n\t\t\t\t\tbeforeTable = true;\n\t\t\t\t\tinFromClause = true;\n\t\t\t\t}\n\t\t\t\telse if ( inFromClause && \",\".equals(lcToken) ) {\n\t\t\t\t\tbeforeTable = true;\n\t\t\t\t}\n\t\t\t\tif ( isBoolean( token ) ) {\n\t\t\t\t\ttoken = dialect.toBooleanValueString( parseBoolean( token ) );\n\t\t\t\t}\n\t\t\t\tresult.append(token);\n\t\t\t}\n\n\t\t\t//Yuck:\n\t\t\tif ( inFromClause\n\t\t\t\t\t&& KEYWORDS.contains( lcToken ) //\"as\" is not in KEYWORDS\n\t\t\t\t\t&& !BEFORE_TABLE_KEYWORDS.contains( lcToken ) ) {\n\t\t\t\tinFromClause = false;\n\t\t\t}\n\t\t}\n\n\t\treturn result.toString();\n\t}\n\n\tprivate static boolean isLiteral(\n\t\t\tString lcToken, String next,\n\t\t\tString sqlWhereString, String symbols, StringTokenizer tokens) {\n\t\tif ( LITERAL_PREFIXES.contains( lcToken ) && next != null ) {\n\t\t\t// easy cases first\n\t\t\tif ( \"'\".equals(next) ) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse if ( !next.isBlank() ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// we need to look ahead in the token stream\n\t\t\t\t// to find the first non-blank token\n\t\t\t\treturn lookPastBlankTokens( sqlWhereString, symbols, tokens, 1,\n\t\t\t\t\t\t(String nextToken)\n\t\t\t\t\t\t\t\t-> \"'\".equals(nextToken)\n\t\t\t\t\t\t\t\t|| lcToken.equals(\"time\") && \"with\".equals(nextToken)\n\t\t\t\t\t\t\t\t|| lcToken.equals(\"timestamp\") && \"with\".equals(nextToken)\n\t\t\t\t\t\t\t\t|| lcToken.equals(\"time\") && \"zone\".equals(nextToken) );\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tprivate static boolean lookPastBlankTokens(\n\t\t\tString sqlWhereString, String symbols, StringTokenizer tokens,\n\t\t\t@SuppressWarnings(\"SameParameterValue\") int skip,\n\t\t\tFunction<String, Boolean> check) {\n\t\tfinal StringTokenizer lookahead = lookahead( sqlWhereString, symbols, tokens, skip );\n\t\tif ( lookahead.hasMoreTokens() ) {\n\t\t\tString nextToken;\n\t\t\tdo {\n\t\t\t\tnextToken = lookahead.nextToken().toLowerCase(Locale.ROOT);\n\t\t\t}\n\t\t\twhile ( nextToken.isBlank() && lookahead.hasMoreTokens() );\n\t\t\treturn check.apply( nextToken );\n\t\t}\n\t\telse {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * Clone the given token stream, returning a token stream which begins\n\t * from the next token.\n\t *\n\t * @param sql the full SQL we are scanning\n\t * @param symbols the delimiter symbols\n\t * @param tokens the current token stream\n\t * @param skip the number of tokens to skip\n\t * @return a cloned token stream\n\t */\n\tprivate static StringTokenizer lookahead(String sql, String symbols, StringTokenizer tokens, int skip) {\n\t\tfinal StringTokenizer lookahead =\n\t\t\t\tnew StringTokenizer( sql, symbols, true );\n\t\twhile ( lookahead.countTokens() > tokens.countTokens() + skip ) {\n\t\t\tlookahead.nextToken();\n\t\t}\n\t\treturn lookahead;\n\t}\n\n\tpublic static List<String> collectColumnNames(String sql, Dialect dialect, TypeConfiguration typeConfiguration) {\n\t\treturn collectColumnNames( renderWhereStringTemplate( sql, dialect, typeConfiguration ) );\n\t}\n\n\tpublic static List<String> collectColumnNames(String template) {\n\t\tfinal List<String> names = new ArrayList<>();\n\t\tint begin = 0;\n\t\tint match;\n\t\twhile ( ( match = template.indexOf(TEMPLATE, begin) ) >= 0 ) {\n\t\t\tint start = match + TEMPLATE.length() + 1;\n\t\t\tfor ( int loc = start;; loc++ ) {\n\t\t\t\tif ( loc == template.length() - 1 ) {\n\t\t\t\t\tnames.add( template.substring( start ) );\n\t\t\t\t\tbegin = template.length();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tchar ch = template.charAt( loc );\n\t\t\t\t\tif ( PUNCTUATION.indexOf(ch) >= 0 || WHITESPACE.indexOf(ch) >= 0 ) {\n\t\t\t\t\t\tnames.add( template.substring( start, loc ) );\n\t\t\t\t\t\tbegin = loc;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn names;\n\t}\n\n\tprivate static boolean isNamedParameter(String token) {\n\t\treturn token.startsWith( \":\" );\n\t}\n\n\tprivate static boolean isFunctionOrKeyword(\n\t\t\tString lcToken,\n\t\t\tString nextToken,\n\t\t\tDialect dialect,\n\t\t\tTypeConfiguration typeConfiguration) {\n\t\tif ( \"(\".equals( nextToken ) ) {\n\t\t\treturn true;\n\t\t}\n\t\telse if ( SOFT_KEYWORDS.contains( lcToken ) ) {\n\t\t\t// these can be column names on some databases\n\t\t\t// TODO: treat 'current date' as a function\n\t\t\treturn false;\n\t\t}\n\t\telse {\n\t\t\treturn KEYWORDS.contains( lcToken )\n\t\t\t\t|| isType( lcToken, typeConfiguration )\n\t\t\t\t|| dialect.getKeywords().contains( lcToken )\n\t\t\t\t|| FUNCTION_KEYWORDS.contains( lcToken );\n\t\t}\n\t}\n\n\tprivate static boolean isType(String lcToken, TypeConfiguration typeConfiguration) {\n\t\treturn typeConfiguration.getDdlTypeRegistry().isTypeNameRegistered( lcToken );\n\t}\n\n\tprivate static boolean isIdentifier(String token) {\n\t\tif ( isBoolean( token ) ) {\n\t\t\treturn false;\n\t\t}\n\t\treturn token.charAt( 0 ) == '`'\n\t\t\t|| ( //allow any identifier quoted with backtick\n\t\t\t\tisLetter( token.charAt( 0 ) ) && //only recognizes identifiers beginning with a letter\n\t\t\t\t\t\ttoken.indexOf( '.' ) < 0\n\t\t\t);\n\t}\n\n\tprivate static boolean isBoolean(String token) {\n\t\treturn \"true\".equals( token ) || \"false\".equals( token );\n\t}\n}\n",
        "diffSourceCodeSet": [
            "/**\n\t * Clone the given token stream, returning a token stream which begins\n\t * from the next token.\n\t *\n\t * @param sql the full SQL we are scanning\n\t * @param symbols the delimiter symbols\n\t * @param tokens the current token stream\n\t * @param skip the number of tokens to skip\n\t * @return a cloned token stream\n\t */\n\tprivate static StringTokenizer lookahead(String sql, String symbols, StringTokenizer tokens, int skip) {\n\t\tfinal StringTokenizer lookahead =\n\t\t\t\tnew StringTokenizer( sql, symbols, true );\n\t\twhile ( lookahead.countTokens() > tokens.countTokens() + skip ) {\n\t\t\tlookahead.nextToken();\n\t\t}\n\t\treturn lookahead;\n\t}"
        ],
        "invokedMethodSet": [
            "methodSignature: org.hibernate.mapping.Formula#equals\n methodBody: public boolean equals(Object obj) {\nreturn obj instanceof Formula && ((Formula)obj).formula.equals(formula);\n}",
            "methodSignature: org.hibernate.mapping.PersistentClass#contains\n methodBody: public boolean contains(Property property) {\nreturn properties.contains(property);\n}"
        ],
        "sourceCodeAfterRefactoring": "private static boolean lookPastBlankTokens(\n\t\t\tString sqlWhereString, String symbols, StringTokenizer tokens,\n\t\t\t@SuppressWarnings(\"SameParameterValue\") int skip,\n\t\t\tFunction<String, Boolean> check) {\n\t\tfinal StringTokenizer lookahead = lookahead( sqlWhereString, symbols, tokens, skip );\n\t\tif ( lookahead.hasMoreTokens() ) {\n\t\t\tString nextToken;\n\t\t\tdo {\n\t\t\t\tnextToken = lookahead.nextToken().toLowerCase(Locale.ROOT);\n\t\t\t}\n\t\t\twhile ( nextToken.isBlank() && lookahead.hasMoreTokens() );\n\t\t\treturn check.apply( nextToken );\n\t\t}\n\t\telse {\n\t\t\treturn false;\n\t\t}\n\t}\n/**\n\t * Clone the given token stream, returning a token stream which begins\n\t * from the next token.\n\t *\n\t * @param sql the full SQL we are scanning\n\t * @param symbols the delimiter symbols\n\t * @param tokens the current token stream\n\t * @param skip the number of tokens to skip\n\t * @return a cloned token stream\n\t */\n\tprivate static StringTokenizer lookahead(String sql, String symbols, StringTokenizer tokens, int skip) {\n\t\tfinal StringTokenizer lookahead =\n\t\t\t\tnew StringTokenizer( sql, symbols, true );\n\t\twhile ( lookahead.countTokens() > tokens.countTokens() + skip ) {\n\t\t\tlookahead.nextToken();\n\t\t}\n\t\treturn lookahead;\n\t}",
        "diffSourceCode": "-  270: \tprivate static boolean isLiteral(\n-  271: \t\t\tString lcToken, String next,\n-  272: \t\t\tString sqlWhereString, String symbols, StringTokenizer tokens) {\n-  273: \t\tif ( LITERAL_PREFIXES.contains( lcToken ) && next != null ) {\n-  274: \t\t\t// easy cases first\n-  275: \t\t\tif ( \"'\".equals(next) ) {\n-  276: \t\t\t\treturn true;\n-  277: \t\t\t}\n-  278: \t\t\telse if ( !next.isBlank() ) {\n-  279: \t\t\t\treturn false;\n+  270: \t\treturn result.toString();\n+  271: \t}\n+  272: \n+  273: \tprivate static boolean isLiteral(\n+  274: \t\t\tString lcToken, String next,\n+  275: \t\t\tString sqlWhereString, String symbols, StringTokenizer tokens) {\n+  276: \t\tif ( LITERAL_PREFIXES.contains( lcToken ) && next != null ) {\n+  277: \t\t\t// easy cases first\n+  278: \t\t\tif ( \"'\".equals(next) ) {\n+  279: \t\t\t\treturn true;\n   280: \t\t\t}\n-  281: \t\t\telse {\n-  282: \t\t\t\t// we need to look ahead in the token stream\n-  283: \t\t\t\t// to find the first non-blank token\n-  284: \t\t\t\tfinal StringTokenizer lookahead =\n-  285: \t\t\t\t\t\tnew StringTokenizer( sqlWhereString, symbols, true );\n-  286: \t\t\t\twhile ( lookahead.countTokens() > tokens.countTokens()+1 ) {\n-  287: \t\t\t\t\tlookahead.nextToken();\n-  288: \t\t\t\t}\n-  289: \t\t\t\tif ( lookahead.hasMoreTokens() ) {\n-  290: \t\t\t\t\tString nextToken;\n-  291: \t\t\t\t\tdo {\n-  292: \t\t\t\t\t\tnextToken = lookahead.nextToken().toLowerCase(Locale.ROOT);\n-  293: \t\t\t\t\t}\n-  294: \t\t\t\t\twhile ( nextToken.isBlank() && lookahead.hasMoreTokens() );\n-  295: \t\t\t\t\treturn \"'\".equals( nextToken )\n-  296: \t\t\t\t\t\t|| lcToken.equals( \"time\" ) && \"with\".equals( nextToken )\n-  297: \t\t\t\t\t\t|| lcToken.equals( \"timestamp\" ) && \"with\".equals( nextToken )\n-  298: \t\t\t\t\t\t|| lcToken.equals( \"time\" ) && \"zone\".equals( nextToken );\n-  299: \t\t\t\t}\n-  300: \t\t\t\telse {\n-  301: \t\t\t\t\treturn false;\n-  302: \t\t\t\t}\n-  303: \t\t\t}\n-  304: \t\t}\n-  305: \t\telse {\n-  306: \t\t\treturn false;\n-  307: \t\t}\n-  308: \t}\n-  309: \n-  310: \tprivate static void handleTrimFunction(\n-  311: \t\t\tString placeholder, Dialect dialect,\n-  312: \t\t\tTypeConfiguration typeConfiguration,\n-  313: \t\t\tSqmFunctionRegistry functionRegistry,\n-  314: \t\t\tStringTokenizer tokens,\n-  315: \t\t\tStringBuilder result) {\n-  316: \t\tfinal List<String> operands = new ArrayList<>();\n-  318: \n-  319: \t\tboolean hasMoreOperands = true;\n-  320: \t\tString operandToken = tokens.nextToken();\n-  321: \t\tswitch ( operandToken.toLowerCase( Locale.ROOT ) ) {\n-  322: \t\t\tcase \"leading\":\n-  323: \t\t\tcase \"trailing\":\n-  324: \t\t\tcase \"both\":\n-  325: \t\t\t\toperands.add( operandToken );\n-  326: \t\t\t\tif ( hasMoreOperands = tokens.hasMoreTokens() ) {\n-  327: \t\t\t\t\toperandToken = tokens.nextToken();\n-  328: \t\t\t\t}\n-  329: \t\t\t\tbreak;\n-  330: \t\t}\n-  331: \t\tboolean quotedOperand = false;\n-  332: \t\tint parenthesis = 0;\n-  333: \t\twhile ( hasMoreOperands ) {\n-  334: \t\t\tfinal boolean isQuote = \"'\".equals( operandToken );\n-  335: \t\t\tif ( isQuote ) {\n+  281: \t\t\telse if ( !next.isBlank() ) {\n+  282: \t\t\t\treturn false;\n+  283: \t\t\t}\n+  284: \t\t\telse {\n+  285: \t\t\t\t// we need to look ahead in the token stream\n+  286: \t\t\t\t// to find the first non-blank token\n+  287: \t\t\t\treturn lookPastBlankTokens( sqlWhereString, symbols, tokens, 1,\n+  288: \t\t\t\t\t\t(String nextToken)\n+  289: \t\t\t\t\t\t\t\t-> \"'\".equals(nextToken)\n+  290: \t\t\t\t\t\t\t\t|| lcToken.equals(\"time\") && \"with\".equals(nextToken)\n+  291: \t\t\t\t\t\t\t\t|| lcToken.equals(\"timestamp\") && \"with\".equals(nextToken)\n+  292: \t\t\t\t\t\t\t\t|| lcToken.equals(\"time\") && \"zone\".equals(nextToken) );\n+  293: \t\t\t}\n+  294: \t\t}\n+  295: \t\telse {\n+  296: \t\t\treturn false;\n+  297: \t\t}\n+  298: \t}\n+  299: \n+  300: \tprivate static boolean lookPastBlankTokens(\n+  301: \t\t\tString sqlWhereString, String symbols, StringTokenizer tokens,\n+  302: \t\t\t@SuppressWarnings(\"SameParameterValue\") int skip,\n+  303: \t\t\tFunction<String, Boolean> check) {\n+  304: \t\tfinal StringTokenizer lookahead = lookahead( sqlWhereString, symbols, tokens, skip );\n+  305: \t\tif ( lookahead.hasMoreTokens() ) {\n+  306: \t\t\tString nextToken;\n+  307: \t\t\tdo {\n+  308: \t\t\t\tnextToken = lookahead.nextToken().toLowerCase(Locale.ROOT);\n+  309: \t\t\t}\n+  310: \t\t\twhile ( nextToken.isBlank() && lookahead.hasMoreTokens() );\n+  311: \t\t\treturn check.apply( nextToken );\n+  312: \t\t}\n+  313: \t\telse {\n+  314: \t\t\treturn false;\n+  315: \t\t}\n+  316: \t}\n+  318: \t/**\n+  319: \t * Clone the given token stream, returning a token stream which begins\n+  320: \t * from the next token.\n+  321: \t *\n+  322: \t * @param sql the full SQL we are scanning\n+  323: \t * @param symbols the delimiter symbols\n+  324: \t * @param tokens the current token stream\n+  325: \t * @param skip the number of tokens to skip\n+  326: \t * @return a cloned token stream\n+  327: \t */\n+  328: \tprivate static StringTokenizer lookahead(String sql, String symbols, StringTokenizer tokens, int skip) {\n+  329: \t\tfinal StringTokenizer lookahead =\n+  330: \t\t\t\tnew StringTokenizer( sql, symbols, true );\n+  331: \t\twhile ( lookahead.countTokens() > tokens.countTokens() + skip ) {\n+  332: \t\t\tlookahead.nextToken();\n+  333: \t\t}\n+  334: \t\treturn lookahead;\n+  335: \t}\n",
        "uniqueId": "a20fb5663dc6e389aa1d9787dfbaf9750b693943_270_308_318_335_300_316",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 8,
                "covered": 77
            },
            "BRANCH": {
                "missed": 7,
                "covered": 23
            },
            "LINE": {
                "missed": 2,
                "covered": 15
            },
            "COMPLEXITY": {
                "missed": 6,
                "covered": 10
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 21
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprivate handleExtractFunction(placeholder String, dialect Dialect, typeConfiguration TypeConfiguration, functionRegistry SqmFunctionRegistry, tokens StringTokenizer, result StringBuilder) : void extracted from public renderWhereStringTemplate(sqlWhereString String, placeholder String, dialect Dialect, typeConfiguration TypeConfiguration, functionRegistry SqmFunctionRegistry) : String in class org.hibernate.sql.Template",
        "diffLocations": [
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/sql/Template.java",
                "startLine": 119,
                "endLine": 402,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/sql/Template.java",
                "startLine": 122,
                "endLine": 260,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/sql/Template.java",
                "startLine": 413,
                "endLine": 429,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "/**\n\t * Takes the where condition provided in the mapping attribute and interpolates the alias.\n\t * Handles sub-selects, quoted identifiers, quoted strings, expressions, SQL functions,\n\t * named parameters.\n\t *\n\t * @param sqlWhereString The string into which to interpolate the placeholder value\n\t * @param placeholder The value to be interpolated into the sqlWhereString\n\t * @param dialect The dialect to apply\n\t * @param functionRegistry The registry of all sql functions\n\t * @return The rendered sql fragment\n\t */\n\tpublic static String renderWhereStringTemplate(\n\t\t\tString sqlWhereString,\n\t\t\tString placeholder,\n\t\t\tDialect dialect,\n\t\t\tTypeConfiguration typeConfiguration,\n\t\t\tSqmFunctionRegistry functionRegistry) {\n\n\t\t// IMPL NOTE : The basic process here is to tokenize the incoming string and to iterate over each token\n\t\t//\t\tin turn.  As we process each token, we set a series of flags used to indicate the type of context in\n\t\t// \t\twhich the tokens occur.  Depending on the state of those flags we decide whether we need to qualify\n\t\t//\t\tidentifier references.\n\n\t\tString symbols = PUNCTUATION +\n\t\t\t\tWHITESPACE +\n\t\t\t\tdialect.openQuote() +\n\t\t\t\tdialect.closeQuote();\n\t\tStringTokenizer tokens = new StringTokenizer( sqlWhereString, symbols, true );\n\t\tStringBuilder result = new StringBuilder();\n\n\t\tboolean quoted = false;\n\t\tboolean quotedIdentifier = false;\n\t\tboolean beforeTable = false;\n\t\tboolean inFromClause = false;\n\t\tboolean afterFromTable = false;\n\n\t\tboolean hasMore = tokens.hasMoreTokens();\n\t\tString nextToken = hasMore ? tokens.nextToken() : null;\n\t\twhile ( hasMore ) {\n\t\t\tString token = nextToken;\n\t\t\tString lcToken = token.toLowerCase(Locale.ROOT);\n\t\t\thasMore = tokens.hasMoreTokens();\n\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n\n\t\t\tboolean isQuoteCharacter = false;\n\n\t\t\tif ( !quotedIdentifier && \"'\".equals(token) ) {\n\t\t\t\tquoted = !quoted;\n\t\t\t\tisQuoteCharacter = true;\n\t\t\t}\n\n\t\t\tif ( !quoted ) {\n\t\t\t\tboolean isOpenQuote;\n\t\t\t\tif ( \"`\".equals(token) ) {\n\t\t\t\t\tisOpenQuote = !quotedIdentifier;\n\t\t\t\t\ttoken = lcToken = isOpenQuote\n\t\t\t\t\t\t\t? Character.toString( dialect.openQuote() )\n\t\t\t\t\t\t\t: Character.toString( dialect.closeQuote() );\n\t\t\t\t\tquotedIdentifier = isOpenQuote;\n\t\t\t\t\tisQuoteCharacter = true;\n\t\t\t\t}\n\t\t\t\telse if ( !quotedIdentifier && ( dialect.openQuote()==token.charAt(0) ) ) {\n\t\t\t\t\tisOpenQuote = true;\n\t\t\t\t\tquotedIdentifier = true;\n\t\t\t\t\tisQuoteCharacter = true;\n\t\t\t\t}\n\t\t\t\telse if ( quotedIdentifier && ( dialect.closeQuote()==token.charAt(0) ) ) {\n\t\t\t\t\tquotedIdentifier = false;\n\t\t\t\t\tisQuoteCharacter = true;\n\t\t\t\t\tisOpenQuote = false;\n\t\t\t\t}\n\t\t\t\telse if ( LITERAL_PREFIXES.contains( lcToken ) ) {\n\t\t\t\t\tif ( \"'\".equals( nextToken ) ) {\n\t\t\t\t\t\t// Don't prefix a literal\n\t\t\t\t\t\tresult.append( token );\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\telse if ( nextToken != null && Character.isWhitespace( nextToken.charAt( 0 ) ) ) {\n\t\t\t\t\t\tfinal StringBuilder additionalTokens = new StringBuilder();\n\t\t\t\t\t\tTimeZoneTokens possibleNextToken = null;\n\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\tpossibleNextToken = possibleNextToken == null\n\t\t\t\t\t\t\t\t\t? TimeZoneTokens.getPossibleNextTokens( lcToken )\n\t\t\t\t\t\t\t\t\t: possibleNextToken.nextToken();\n\t\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\t\tadditionalTokens.append( nextToken );\n\t\t\t\t\t\t\t\thasMore = tokens.hasMoreTokens();\n\t\t\t\t\t\t\t\tnextToken = tokens.nextToken();\n\t\t\t\t\t\t\t} while ( nextToken != null && Character.isWhitespace( nextToken.charAt( 0 ) ) );\n\t\t\t\t\t\t} while ( nextToken != null && possibleNextToken.isToken( nextToken ) );\n\t\t\t\t\t\tif ( \"'\".equals( nextToken ) ) {\n\t\t\t\t\t\t\t// Don't prefix a literal\n\t\t\t\t\t\t\tresult.append( token );\n\t\t\t\t\t\t\tresult.append( additionalTokens );\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tisOpenQuote = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tisOpenQuote = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tisOpenQuote = false;\n\t\t\t\t}\n\n\t\t\t\tif ( isOpenQuote ) {\n\t\t\t\t\tresult.append( placeholder ).append( '.' );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Special processing for ANSI SQL EXTRACT function\n\t\t\tif ( \"extract\".equals( lcToken ) && \"(\".equals( nextToken ) ) {\n\t\t\t\tfinal String field = extractUntil( tokens, \"from\" );\n\t\t\t\tfinal String source = renderWhereStringTemplate(\n\t\t\t\t\t\textractUntil( tokens, \")\" ),\n\t\t\t\t\t\tplaceholder,\n\t\t\t\t\t\tdialect,\n\t\t\t\t\t\ttypeConfiguration,\n\t\t\t\t\t\tfunctionRegistry\n\t\t\t\t);\n\t\t\t\tresult.append( \"extract(\" ).append( field ).append( \" from \" ).append( source ).append( ')' );\n\n\t\t\t\thasMore = tokens.hasMoreTokens();\n\t\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Special processing for ANSI SQL TRIM function\n\t\t\tif ( \"trim\".equals( lcToken ) && \"(\".equals( nextToken ) ) {\n\t\t\t\tList<String> operands = new ArrayList<>();\n\t\t\t\tStringBuilder builder = new StringBuilder();\n\n\t\t\t\tboolean hasMoreOperands = true;\n\t\t\t\tString operandToken = tokens.nextToken();\n\t\t\t\tswitch ( operandToken.toLowerCase( Locale.ROOT ) ) {\n\t\t\t\t\tcase \"leading\":\n\t\t\t\t\tcase \"trailing\":\n\t\t\t\t\tcase \"both\":\n\t\t\t\t\t\toperands.add( operandToken );\n\t\t\t\t\t\tif ( hasMoreOperands = tokens.hasMoreTokens() ) {\n\t\t\t\t\t\t\toperandToken = tokens.nextToken();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tboolean quotedOperand = false;\n\t\t\t\tint parenthesis = 0;\n\t\t\t\twhile ( hasMoreOperands ) {\n\t\t\t\t\tfinal boolean isQuote = \"'\".equals( operandToken );\n\t\t\t\t\tif ( isQuote ) {\n\t\t\t\t\t\tquotedOperand = !quotedOperand;\n\t\t\t\t\t\tif ( !quotedOperand ) {\n\t\t\t\t\t\t\toperands.add( builder.append( '\\'' ).toString() );\n\t\t\t\t\t\t\tbuilder.setLength( 0 );\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tbuilder.append( '\\'' );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if ( quotedOperand ) {\n\t\t\t\t\t\tbuilder.append( operandToken );\n\t\t\t\t\t}\n\t\t\t\t\telse if ( parenthesis != 0 ) {\n\t\t\t\t\t\tbuilder.append( operandToken );\n\t\t\t\t\t\tswitch ( operandToken ) {\n\t\t\t\t\t\t\tcase \"(\":\n\t\t\t\t\t\t\t\tparenthesis++;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase \")\":\n\t\t\t\t\t\t\t\tparenthesis--;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tbuilder.append( operandToken );\n\t\t\t\t\t\tswitch ( operandToken.toLowerCase( Locale.ROOT ) ) {\n\t\t\t\t\t\t\tcase \"(\":\n\t\t\t\t\t\t\t\tparenthesis++;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase \")\":\n\t\t\t\t\t\t\t\tparenthesis--;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase \"from\":\n\t\t\t\t\t\t\t\tif ( builder.length() != 0 ) {\n\t\t\t\t\t\t\t\t\toperands.add( builder.substring( 0, builder.length() - 4 ) );\n\t\t\t\t\t\t\t\t\tbuilder.setLength( 0 );\n\t\t\t\t\t\t\t\t\toperands.add( operandToken );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\toperandToken = tokens.nextToken();\n\t\t\t\t\thasMoreOperands = tokens.hasMoreTokens() && ( parenthesis != 0 || ! \")\".equals( operandToken ) );\n\t\t\t\t}\n\t\t\t\tif ( builder.length() != 0 ) {\n\t\t\t\t\toperands.add( builder.toString() );\n\t\t\t\t}\n\n\t\t\t\tTrimOperands trimOperands = new TrimOperands( operands );\n\t\t\t\tresult.append( \"trim(\" );\n\t\t\t\tif ( trimOperands.trimSpec != null ) {\n\t\t\t\t\tresult.append( trimOperands.trimSpec ).append( ' ' );\n\t\t\t\t}\n\t\t\t\tif ( trimOperands.trimChar != null ) {\n\t\t\t\t\tif ( trimOperands.trimChar.startsWith( \"'\" ) && trimOperands.trimChar.endsWith( \"'\" ) ) {\n\t\t\t\t\t\tresult.append( trimOperands.trimChar );\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tresult.append(\n\t\t\t\t\t\t\t\trenderWhereStringTemplate( trimOperands.trimSpec, placeholder, dialect, typeConfiguration, functionRegistry )\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\tresult.append( ' ' );\n\t\t\t\t}\n\t\t\t\tif ( trimOperands.from != null ) {\n\t\t\t\t\tresult.append( trimOperands.from ).append( ' ' );\n\t\t\t\t}\n\t\t\t\telse if ( trimOperands.trimSpec != null || trimOperands.trimChar != null ) {\n\t\t\t\t\t// I think ANSI SQL says that the 'from' is not optional if either trim-spec or trim-char is specified\n\t\t\t\t\tresult.append( \"from \" );\n\t\t\t\t}\n\n\t\t\t\tresult.append( renderWhereStringTemplate( trimOperands.trimSource, placeholder, dialect, typeConfiguration, functionRegistry ) )\n\t\t\t\t\t\t.append( ')' );\n\n\t\t\t\thasMore = tokens.hasMoreTokens();\n\t\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tboolean quotedOrWhitespace = quoted || quotedIdentifier || isQuoteCharacter\n\t\t\t\t\t|| Character.isWhitespace( token.charAt(0) );\n\n\t\t\tif ( quotedOrWhitespace ) {\n\t\t\t\tresult.append( token );\n\t\t\t}\n\t\t\telse if ( beforeTable ) {\n\t\t\t\tresult.append( token );\n\t\t\t\tbeforeTable = false;\n\t\t\t\tafterFromTable = true;\n\t\t\t}\n\t\t\telse if ( afterFromTable ) {\n\t\t\t\tif ( !\"as\".equals(lcToken) ) {\n\t\t\t\t\tafterFromTable = false;\n\t\t\t\t}\n\t\t\t\tresult.append(token);\n\t\t\t}\n\t\t\telse if ( isNamedParameter(token) ) {\n\t\t\t\tresult.append(token);\n\t\t\t}\n\t\t\telse if ( isIdentifier(token)\n\t\t\t\t\t&& !isFunctionOrKeyword(lcToken, nextToken, dialect, typeConfiguration, functionRegistry) ) {\n\t\t\t\tresult.append(placeholder)\n\t\t\t\t\t\t.append('.')\n\t\t\t\t\t\t.append( dialect.quote(token) );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif ( BEFORE_TABLE_KEYWORDS.contains(lcToken) ) {\n\t\t\t\t\tbeforeTable = true;\n\t\t\t\t\tinFromClause = true;\n\t\t\t\t}\n\t\t\t\telse if ( inFromClause && \",\".equals(lcToken) ) {\n\t\t\t\t\tbeforeTable = true;\n\t\t\t\t}\n\t\t\t\tif ( isBoolean( token ) ) {\n\t\t\t\t\ttoken = dialect.toBooleanValueString( Boolean.parseBoolean( token ) );\n\t\t\t\t}\n\t\t\t\tresult.append(token);\n\t\t\t}\n\n\t\t\t//Yuck:\n\t\t\tif ( inFromClause\n\t\t\t\t\t&& KEYWORDS.contains( lcToken ) //\"as\" is not in KEYWORDS\n\t\t\t\t\t&& !BEFORE_TABLE_KEYWORDS.contains( lcToken ) ) {\n\t\t\t\tinFromClause = false;\n\t\t\t}\n\t\t}\n\n\t\treturn result.toString();\n\t}",
        "filePathBefore": "hibernate-core/src/main/java/org/hibernate/sql/Template.java",
        "isPureRefactoring": true,
        "commitId": "35f96d6e901dbd071b375d809521ef6f1c979868",
        "packageNameBefore": "org.hibernate.sql",
        "classNameBefore": "org.hibernate.sql.Template",
        "methodNameBefore": "org.hibernate.sql.Template#renderWhereStringTemplate",
        "invokedMethod": "methodSignature: org.hibernate.sql.Template#extractUntil\n methodBody: private static String extractUntil(StringTokenizer tokens, String delimiter) {\nStringBuilder valueBuilder=new StringBuilder();\nString token=tokens.nextToken();\nwhile(!delimiter.equalsIgnoreCase(token)){valueBuilder.append(token);\ntoken=tokens.nextToken();\n}return valueBuilder.toString().trim();\n}\nmethodSignature: org.hibernate.sql.Template#renderWhereStringTemplate\n methodBody: public static String renderWhereStringTemplate(\n\t\t\tString sqlWhereString,\n\t\t\tString placeholder,\n\t\t\tDialect dialect,\n\t\t\tTypeConfiguration typeConfiguration,\n\t\t\tSqmFunctionRegistry functionRegistry) {\nString symbols=PUNCTUATION + WHITESPACE + dialect.openQuote() + dialect.closeQuote();\nStringTokenizer tokens=new StringTokenizer(sqlWhereString,symbols,true);\nStringBuilder result=new StringBuilder();\nboolean quoted=false;\nboolean quotedIdentifier=false;\nboolean beforeTable=false;\nboolean inFromClause=false;\nboolean afterFromTable=false;\nboolean hasMore=tokens.hasMoreTokens();\nString nextToken=hasMore ? tokens.nextToken() : null;\nwhile(hasMore){String token=nextToken;\nString lcToken=token.toLowerCase(Locale.ROOT);\nhasMore=tokens.hasMoreTokens();\nnextToken=hasMore ? tokens.nextToken() : null;\nboolean isQuoteCharacter=false;\nif(!quotedIdentifier && \"'\".equals(token)){quoted=!quoted;\nisQuoteCharacter=true;\n}if(!quoted){boolean isOpenQuote;\nif(\"`\".equals(token)){isOpenQuote=!quotedIdentifier;\ntoken=lcToken=isOpenQuote ? Character.toString(dialect.openQuote()) : Character.toString(dialect.closeQuote());\nquotedIdentifier=isOpenQuote;\nisQuoteCharacter=true;\n}if(!quotedIdentifier && (dialect.openQuote() == token.charAt(0))){isOpenQuote=true;\nquotedIdentifier=true;\nisQuoteCharacter=true;\n}if(quotedIdentifier && (dialect.closeQuote() == token.charAt(0))){quotedIdentifier=false;\nisQuoteCharacter=true;\nisOpenQuote=false;\n}if(LITERAL_PREFIXES.contains(lcToken)){if(\"'\".equals(nextToken)){result.append(token);\ncontinue;\n}if(nextToken != null && Character.isWhitespace(nextToken.charAt(0))){final StringBuilder additionalTokens=new StringBuilder();\nTimeZoneTokens possibleNextToken=null;\ndo(nextToken != null && possibleNextToken.isToken(nextToken)){possibleNextToken=possibleNextToken == null ? TimeZoneTokens.getPossibleNextTokens(lcToken) : possibleNextToken.nextToken();\ndo(nextToken != null && Character.isWhitespace(nextToken.charAt(0))){additionalTokens.append(nextToken);\nhasMore=tokens.hasMoreTokens();\nnextToken=tokens.nextToken();\n}}if(\"'\".equals(nextToken)){result.append(token);\nresult.append(additionalTokens);\ncontinue;\n}{isOpenQuote=false;\n}}{isOpenQuote=false;\n}}{isOpenQuote=false;\n}if(isOpenQuote){result.append(placeholder).append('.');\n}}if(\"extract\".equals(lcToken) && \"(\".equals(nextToken)){final String field=extractUntil(tokens,\"from\");\nfinal String source=renderWhereStringTemplate(extractUntil(tokens,\")\"),placeholder,dialect,typeConfiguration,functionRegistry);\nresult.append(\"extract(\").append(field).append(\" from \").append(source).append(')');\nhasMore=tokens.hasMoreTokens();\nnextToken=hasMore ? tokens.nextToken() : null;\ncontinue;\n}if(\"trim\".equals(lcToken) && \"(\".equals(nextToken)){List<String> operands=new ArrayList<>();\nStringBuilder builder=new StringBuilder();\nboolean hasMoreOperands=true;\nString operandToken=tokens.nextToken();\nswitch(operandToken.toLowerCase(Locale.ROOT))case \"leading\":case \"trailing\":case \"both\":operands.add(operandToken);\nif(hasMoreOperands=tokens.hasMoreTokens()){operandToken=tokens.nextToken();\n}break;\nboolean quotedOperand=false;\nint parenthesis=0;\nwhile(hasMoreOperands){final boolean isQuote=\"'\".equals(operandToken);\nif(isQuote){quotedOperand=!quotedOperand;\nif(!quotedOperand){operands.add(builder.append('\\'').toString());\nbuilder.setLength(0);\n}{builder.append('\\'');\n}}if(quotedOperand){builder.append(operandToken);\n}if(parenthesis != 0){builder.append(operandToken);\nswitch(operandToken)case \"(\":parenthesis++;\nbreak;\ncase \")\":parenthesis--;\nbreak;\n}{builder.append(operandToken);\nswitch(operandToken.toLowerCase(Locale.ROOT))case \"(\":parenthesis++;\nbreak;\ncase \")\":parenthesis--;\nbreak;\ncase \"from\":if(builder.length() != 0){operands.add(builder.substring(0,builder.length() - 4));\nbuilder.setLength(0);\noperands.add(operandToken);\n}break;\n}operandToken=tokens.nextToken();\nhasMoreOperands=tokens.hasMoreTokens() && (parenthesis != 0 || !\")\".equals(operandToken));\n}if(builder.length() != 0){operands.add(builder.toString());\n}TrimOperands trimOperands=new TrimOperands(operands);\nresult.append(\"trim(\");\nif(trimOperands.trimSpec != null){result.append(trimOperands.trimSpec).append(' ');\n}if(trimOperands.trimChar != null){if(trimOperands.trimChar.startsWith(\"'\") && trimOperands.trimChar.endsWith(\"'\")){result.append(trimOperands.trimChar);\n}{result.append(renderWhereStringTemplate(trimOperands.trimSpec,placeholder,dialect,typeConfiguration,functionRegistry));\n}result.append(' ');\n}if(trimOperands.from != null){result.append(trimOperands.from).append(' ');\n}if(trimOperands.trimSpec != null || trimOperands.trimChar != null){result.append(\"from \");\n}result.append(renderWhereStringTemplate(trimOperands.trimSource,placeholder,dialect,typeConfiguration,functionRegistry)).append(')');\nhasMore=tokens.hasMoreTokens();\nnextToken=hasMore ? tokens.nextToken() : null;\ncontinue;\n}boolean quotedOrWhitespace=quoted || quotedIdentifier || isQuoteCharacter || Character.isWhitespace(token.charAt(0));\nif(quotedOrWhitespace){result.append(token);\n}if(beforeTable){result.append(token);\nbeforeTable=false;\nafterFromTable=true;\n}if(afterFromTable){if(!\"as\".equals(lcToken)){afterFromTable=false;\n}result.append(token);\n}if(isNamedParameter(token)){result.append(token);\n}if(isIdentifier(token) && !isFunctionOrKeyword(lcToken,nextToken,dialect,typeConfiguration,functionRegistry)){result.append(placeholder).append('.').append(dialect.quote(token));\n}{if(BEFORE_TABLE_KEYWORDS.contains(lcToken)){beforeTable=true;\ninFromClause=true;\n}if(inFromClause && \",\".equals(lcToken)){beforeTable=true;\n}if(isBoolean(token)){token=dialect.toBooleanValueString(Boolean.parseBoolean(token));\n}result.append(token);\n}if(inFromClause && KEYWORDS.contains(lcToken) && !BEFORE_TABLE_KEYWORDS.contains(lcToken)){inFromClause=false;\n}}return result.toString();\n}\nmethodSignature: org.hibernate.sql.Template.TimeZoneTokens#isToken\n methodBody: public boolean isToken(String token) {\nreturn this != NONE && name().equalsIgnoreCase(token);\n}\nmethodSignature: org.hibernate.sql.Template#isBoolean\n methodBody: private static boolean isBoolean(String token) {\nreturn \"true\".equals(token) || \"false\".equals(token);\n}\nmethodSignature: org.hibernate.sql.Template.TimeZoneTokens#nextToken\n methodBody: public TimeZoneTokens nextToken() {\nif(this == WITH){return TIME;\n}if(this == TIME){return ZONE;\n}{return NONE;\n}}\nmethodSignature: org.hibernate.sql.Template.TimeZoneTokens#getPossibleNextTokens\n methodBody: static TimeZoneTokens getPossibleNextTokens(String lctoken) {\nswitch(lctoken)case \"time\":case \"timestamp\":return WITH;\ndefault:return NONE;\n}\nmethodSignature: org.hibernate.sql.Template#isIdentifier\n methodBody: private static boolean isIdentifier(String token) {\nif(isBoolean(token)){return false;\n}return token.charAt(0) == '`' || (Character.isLetter(token.charAt(0)) && token.indexOf('.') < 0);\n}\nmethodSignature: org.hibernate.sql.Template#isNamedParameter\n methodBody: private static boolean isNamedParameter(String token) {\nreturn token.startsWith(\":\");\n}\nmethodSignature: org.hibernate.sql.Template#isFunctionOrKeyword\n methodBody: private static boolean isFunctionOrKeyword(\n\t\t\tString lcToken,\n\t\t\tString nextToken,\n\t\t\tDialect dialect,\n\t\t\tTypeConfiguration typeConfiguration,\n\t\t\tSqmFunctionRegistry functionRegistry) {\nreturn \"(\".equals(nextToken) || KEYWORDS.contains(lcToken) || isType(lcToken,typeConfiguration) || isFunction(lcToken,nextToken,functionRegistry) || dialect.getKeywords().contains(lcToken) || FUNCTION_KEYWORDS.contains(lcToken);\n}",
        "classSignatureBefore": "public final class Template ",
        "methodNameBeforeSet": [
            "org.hibernate.sql.Template#renderWhereStringTemplate"
        ],
        "classNameBeforeSet": [
            "org.hibernate.sql.Template"
        ],
        "classSignatureBeforeSet": [
            "public final class Template "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.\n */\npackage org.hibernate.sql;\n\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Set;\nimport java.util.StringTokenizer;\n\nimport org.hibernate.HibernateException;\nimport org.hibernate.dialect.Dialect;\nimport org.hibernate.query.sqm.function.SqmFunctionDescriptor;\nimport org.hibernate.query.sqm.function.SqmFunctionRegistry;\nimport org.hibernate.type.spi.TypeConfiguration;\n\nimport static org.hibernate.internal.util.StringHelper.WHITESPACE;\n\n/**\n * Parses SQL fragments specified in mapping documents.\n *\n * @author Gavin King\n */\npublic final class Template {\n\n\tprivate static final Set<String> KEYWORDS = new HashSet<>();\n\tprivate static final Set<String> BEFORE_TABLE_KEYWORDS = new HashSet<>();\n\tprivate static final Set<String> FUNCTION_KEYWORDS = new HashSet<>();\n\tprivate static final Set<String> LITERAL_PREFIXES = new HashSet<>();\n\tpublic static final String PUNCTUATION = \"=><!+-*/()',|&`\";\n\n\tstatic {\n\t\tKEYWORDS.add(\"and\");\n\t\tKEYWORDS.add(\"or\");\n\t\tKEYWORDS.add(\"not\");\n\t\tKEYWORDS.add(\"like\");\n\t\tKEYWORDS.add(\"escape\");\n\t\tKEYWORDS.add(\"is\");\n\t\tKEYWORDS.add(\"in\");\n\t\tKEYWORDS.add(\"between\");\n\t\tKEYWORDS.add(\"null\");\n\t\tKEYWORDS.add(\"select\");\n\t\tKEYWORDS.add(\"distinct\");\n\t\tKEYWORDS.add(\"from\");\n\t\tKEYWORDS.add(\"join\");\n\t\tKEYWORDS.add(\"inner\");\n\t\tKEYWORDS.add(\"outer\");\n\t\tKEYWORDS.add(\"left\");\n\t\tKEYWORDS.add(\"right\");\n\t\tKEYWORDS.add(\"on\");\n\t\tKEYWORDS.add(\"where\");\n\t\tKEYWORDS.add(\"having\");\n\t\tKEYWORDS.add(\"group\");\n\t\tKEYWORDS.add(\"order\");\n\t\tKEYWORDS.add(\"by\");\n\t\tKEYWORDS.add(\"desc\");\n\t\tKEYWORDS.add(\"asc\");\n\t\tKEYWORDS.add(\"limit\");\n\t\tKEYWORDS.add(\"any\");\n\t\tKEYWORDS.add(\"some\");\n\t\tKEYWORDS.add(\"exists\");\n\t\tKEYWORDS.add(\"all\");\n\t\tKEYWORDS.add(\"union\");\n\t\tKEYWORDS.add(\"minus\");\n\t\tKEYWORDS.add(\"except\");\n\t\tKEYWORDS.add(\"intersect\");\n\t\tKEYWORDS.add(\"partition\");\n\n\t\tBEFORE_TABLE_KEYWORDS.add(\"from\");\n\t\tBEFORE_TABLE_KEYWORDS.add(\"join\");\n\n\t\tFUNCTION_KEYWORDS.add(\"as\");\n\t\tFUNCTION_KEYWORDS.add(\"leading\");\n\t\tFUNCTION_KEYWORDS.add(\"trailing\");\n\t\tFUNCTION_KEYWORDS.add(\"from\");\n\t\tFUNCTION_KEYWORDS.add(\"case\");\n\t\tFUNCTION_KEYWORDS.add(\"when\");\n\t\tFUNCTION_KEYWORDS.add(\"then\");\n\t\tFUNCTION_KEYWORDS.add(\"else\");\n\t\tFUNCTION_KEYWORDS.add(\"end\");\n\n\t\tLITERAL_PREFIXES.add(\"n\");\n\t\tLITERAL_PREFIXES.add(\"x\");\n\t\tLITERAL_PREFIXES.add(\"varbyte\");\n\t\tLITERAL_PREFIXES.add(\"bx\");\n\t\tLITERAL_PREFIXES.add(\"bytea\");\n\t\tLITERAL_PREFIXES.add(\"date\");\n\t\tLITERAL_PREFIXES.add(\"time\");\n\t\tLITERAL_PREFIXES.add(\"timestamp\");\n\t}\n\n\tpublic static final String TEMPLATE = \"$PlaceHolder$\";\n\n\tprivate Template() {}\n\n\tpublic static String renderTransformerReadFragment(\n\t\t\tString fragment,\n\t\t\tString... columnNames) {\n\t\t// NOTE : would need access to SessionFactoryImplementor to make this configurable\n\t\tfor ( String columnName : columnNames ) {\n\t\t\tfragment = fragment.replace( columnName, TEMPLATE + '.' + columnName );\n\t\t}\n\t\treturn fragment;\n\t}\n\n\tpublic static String renderWhereStringTemplate(\n\t\t\tString sqlWhereString,\n\t\t\tDialect dialect,\n\t\t\tTypeConfiguration typeConfiguration,\n\t\t\tSqmFunctionRegistry functionRegistry) {\n\t\treturn renderWhereStringTemplate( sqlWhereString, TEMPLATE, dialect, typeConfiguration, functionRegistry );\n\t}\n\n\t/**\n\t * Takes the where condition provided in the mapping attribute and interpolates the alias.\n\t * Handles sub-selects, quoted identifiers, quoted strings, expressions, SQL functions,\n\t * named parameters.\n\t *\n\t * @param sqlWhereString The string into which to interpolate the placeholder value\n\t * @param placeholder The value to be interpolated into the sqlWhereString\n\t * @param dialect The dialect to apply\n\t * @param functionRegistry The registry of all sql functions\n\t * @return The rendered sql fragment\n\t */\n\tpublic static String renderWhereStringTemplate(\n\t\t\tString sqlWhereString,\n\t\t\tString placeholder,\n\t\t\tDialect dialect,\n\t\t\tTypeConfiguration typeConfiguration,\n\t\t\tSqmFunctionRegistry functionRegistry) {\n\n\t\t// IMPL NOTE : The basic process here is to tokenize the incoming string and to iterate over each token\n\t\t//\t\tin turn.  As we process each token, we set a series of flags used to indicate the type of context in\n\t\t// \t\twhich the tokens occur.  Depending on the state of those flags we decide whether we need to qualify\n\t\t//\t\tidentifier references.\n\n\t\tString symbols = PUNCTUATION +\n\t\t\t\tWHITESPACE +\n\t\t\t\tdialect.openQuote() +\n\t\t\t\tdialect.closeQuote();\n\t\tStringTokenizer tokens = new StringTokenizer( sqlWhereString, symbols, true );\n\t\tStringBuilder result = new StringBuilder();\n\n\t\tboolean quoted = false;\n\t\tboolean quotedIdentifier = false;\n\t\tboolean beforeTable = false;\n\t\tboolean inFromClause = false;\n\t\tboolean afterFromTable = false;\n\n\t\tboolean hasMore = tokens.hasMoreTokens();\n\t\tString nextToken = hasMore ? tokens.nextToken() : null;\n\t\twhile ( hasMore ) {\n\t\t\tString token = nextToken;\n\t\t\tString lcToken = token.toLowerCase(Locale.ROOT);\n\t\t\thasMore = tokens.hasMoreTokens();\n\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n\n\t\t\tboolean isQuoteCharacter = false;\n\n\t\t\tif ( !quotedIdentifier && \"'\".equals(token) ) {\n\t\t\t\tquoted = !quoted;\n\t\t\t\tisQuoteCharacter = true;\n\t\t\t}\n\n\t\t\tif ( !quoted ) {\n\t\t\t\tboolean isOpenQuote;\n\t\t\t\tif ( \"`\".equals(token) ) {\n\t\t\t\t\tisOpenQuote = !quotedIdentifier;\n\t\t\t\t\ttoken = lcToken = isOpenQuote\n\t\t\t\t\t\t\t? Character.toString( dialect.openQuote() )\n\t\t\t\t\t\t\t: Character.toString( dialect.closeQuote() );\n\t\t\t\t\tquotedIdentifier = isOpenQuote;\n\t\t\t\t\tisQuoteCharacter = true;\n\t\t\t\t}\n\t\t\t\telse if ( !quotedIdentifier && ( dialect.openQuote()==token.charAt(0) ) ) {\n\t\t\t\t\tisOpenQuote = true;\n\t\t\t\t\tquotedIdentifier = true;\n\t\t\t\t\tisQuoteCharacter = true;\n\t\t\t\t}\n\t\t\t\telse if ( quotedIdentifier && ( dialect.closeQuote()==token.charAt(0) ) ) {\n\t\t\t\t\tquotedIdentifier = false;\n\t\t\t\t\tisQuoteCharacter = true;\n\t\t\t\t\tisOpenQuote = false;\n\t\t\t\t}\n\t\t\t\telse if ( LITERAL_PREFIXES.contains( lcToken ) ) {\n\t\t\t\t\tif ( \"'\".equals( nextToken ) ) {\n\t\t\t\t\t\t// Don't prefix a literal\n\t\t\t\t\t\tresult.append( token );\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\telse if ( nextToken != null && Character.isWhitespace( nextToken.charAt( 0 ) ) ) {\n\t\t\t\t\t\tfinal StringBuilder additionalTokens = new StringBuilder();\n\t\t\t\t\t\tTimeZoneTokens possibleNextToken = null;\n\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\tpossibleNextToken = possibleNextToken == null\n\t\t\t\t\t\t\t\t\t? TimeZoneTokens.getPossibleNextTokens( lcToken )\n\t\t\t\t\t\t\t\t\t: possibleNextToken.nextToken();\n\t\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\t\tadditionalTokens.append( nextToken );\n\t\t\t\t\t\t\t\thasMore = tokens.hasMoreTokens();\n\t\t\t\t\t\t\t\tnextToken = tokens.nextToken();\n\t\t\t\t\t\t\t} while ( nextToken != null && Character.isWhitespace( nextToken.charAt( 0 ) ) );\n\t\t\t\t\t\t} while ( nextToken != null && possibleNextToken.isToken( nextToken ) );\n\t\t\t\t\t\tif ( \"'\".equals( nextToken ) ) {\n\t\t\t\t\t\t\t// Don't prefix a literal\n\t\t\t\t\t\t\tresult.append( token );\n\t\t\t\t\t\t\tresult.append( additionalTokens );\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tisOpenQuote = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tisOpenQuote = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tisOpenQuote = false;\n\t\t\t\t}\n\n\t\t\t\tif ( isOpenQuote ) {\n\t\t\t\t\tresult.append( placeholder ).append( '.' );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Special processing for ANSI SQL EXTRACT function\n\t\t\tif ( \"extract\".equals( lcToken ) && \"(\".equals( nextToken ) ) {\n\t\t\t\tfinal String field = extractUntil( tokens, \"from\" );\n\t\t\t\tfinal String source = renderWhereStringTemplate(\n\t\t\t\t\t\textractUntil( tokens, \")\" ),\n\t\t\t\t\t\tplaceholder,\n\t\t\t\t\t\tdialect,\n\t\t\t\t\t\ttypeConfiguration,\n\t\t\t\t\t\tfunctionRegistry\n\t\t\t\t);\n\t\t\t\tresult.append( \"extract(\" ).append( field ).append( \" from \" ).append( source ).append( ')' );\n\n\t\t\t\thasMore = tokens.hasMoreTokens();\n\t\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Special processing for ANSI SQL TRIM function\n\t\t\tif ( \"trim\".equals( lcToken ) && \"(\".equals( nextToken ) ) {\n\t\t\t\tList<String> operands = new ArrayList<>();\n\t\t\t\tStringBuilder builder = new StringBuilder();\n\n\t\t\t\tboolean hasMoreOperands = true;\n\t\t\t\tString operandToken = tokens.nextToken();\n\t\t\t\tswitch ( operandToken.toLowerCase( Locale.ROOT ) ) {\n\t\t\t\t\tcase \"leading\":\n\t\t\t\t\tcase \"trailing\":\n\t\t\t\t\tcase \"both\":\n\t\t\t\t\t\toperands.add( operandToken );\n\t\t\t\t\t\tif ( hasMoreOperands = tokens.hasMoreTokens() ) {\n\t\t\t\t\t\t\toperandToken = tokens.nextToken();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tboolean quotedOperand = false;\n\t\t\t\tint parenthesis = 0;\n\t\t\t\twhile ( hasMoreOperands ) {\n\t\t\t\t\tfinal boolean isQuote = \"'\".equals( operandToken );\n\t\t\t\t\tif ( isQuote ) {\n\t\t\t\t\t\tquotedOperand = !quotedOperand;\n\t\t\t\t\t\tif ( !quotedOperand ) {\n\t\t\t\t\t\t\toperands.add( builder.append( '\\'' ).toString() );\n\t\t\t\t\t\t\tbuilder.setLength( 0 );\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tbuilder.append( '\\'' );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if ( quotedOperand ) {\n\t\t\t\t\t\tbuilder.append( operandToken );\n\t\t\t\t\t}\n\t\t\t\t\telse if ( parenthesis != 0 ) {\n\t\t\t\t\t\tbuilder.append( operandToken );\n\t\t\t\t\t\tswitch ( operandToken ) {\n\t\t\t\t\t\t\tcase \"(\":\n\t\t\t\t\t\t\t\tparenthesis++;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase \")\":\n\t\t\t\t\t\t\t\tparenthesis--;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tbuilder.append( operandToken );\n\t\t\t\t\t\tswitch ( operandToken.toLowerCase( Locale.ROOT ) ) {\n\t\t\t\t\t\t\tcase \"(\":\n\t\t\t\t\t\t\t\tparenthesis++;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase \")\":\n\t\t\t\t\t\t\t\tparenthesis--;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase \"from\":\n\t\t\t\t\t\t\t\tif ( builder.length() != 0 ) {\n\t\t\t\t\t\t\t\t\toperands.add( builder.substring( 0, builder.length() - 4 ) );\n\t\t\t\t\t\t\t\t\tbuilder.setLength( 0 );\n\t\t\t\t\t\t\t\t\toperands.add( operandToken );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\toperandToken = tokens.nextToken();\n\t\t\t\t\thasMoreOperands = tokens.hasMoreTokens() && ( parenthesis != 0 || ! \")\".equals( operandToken ) );\n\t\t\t\t}\n\t\t\t\tif ( builder.length() != 0 ) {\n\t\t\t\t\toperands.add( builder.toString() );\n\t\t\t\t}\n\n\t\t\t\tTrimOperands trimOperands = new TrimOperands( operands );\n\t\t\t\tresult.append( \"trim(\" );\n\t\t\t\tif ( trimOperands.trimSpec != null ) {\n\t\t\t\t\tresult.append( trimOperands.trimSpec ).append( ' ' );\n\t\t\t\t}\n\t\t\t\tif ( trimOperands.trimChar != null ) {\n\t\t\t\t\tif ( trimOperands.trimChar.startsWith( \"'\" ) && trimOperands.trimChar.endsWith( \"'\" ) ) {\n\t\t\t\t\t\tresult.append( trimOperands.trimChar );\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tresult.append(\n\t\t\t\t\t\t\t\trenderWhereStringTemplate( trimOperands.trimSpec, placeholder, dialect, typeConfiguration, functionRegistry )\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\tresult.append( ' ' );\n\t\t\t\t}\n\t\t\t\tif ( trimOperands.from != null ) {\n\t\t\t\t\tresult.append( trimOperands.from ).append( ' ' );\n\t\t\t\t}\n\t\t\t\telse if ( trimOperands.trimSpec != null || trimOperands.trimChar != null ) {\n\t\t\t\t\t// I think ANSI SQL says that the 'from' is not optional if either trim-spec or trim-char is specified\n\t\t\t\t\tresult.append( \"from \" );\n\t\t\t\t}\n\n\t\t\t\tresult.append( renderWhereStringTemplate( trimOperands.trimSource, placeholder, dialect, typeConfiguration, functionRegistry ) )\n\t\t\t\t\t\t.append( ')' );\n\n\t\t\t\thasMore = tokens.hasMoreTokens();\n\t\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tboolean quotedOrWhitespace = quoted || quotedIdentifier || isQuoteCharacter\n\t\t\t\t\t|| Character.isWhitespace( token.charAt(0) );\n\n\t\t\tif ( quotedOrWhitespace ) {\n\t\t\t\tresult.append( token );\n\t\t\t}\n\t\t\telse if ( beforeTable ) {\n\t\t\t\tresult.append( token );\n\t\t\t\tbeforeTable = false;\n\t\t\t\tafterFromTable = true;\n\t\t\t}\n\t\t\telse if ( afterFromTable ) {\n\t\t\t\tif ( !\"as\".equals(lcToken) ) {\n\t\t\t\t\tafterFromTable = false;\n\t\t\t\t}\n\t\t\t\tresult.append(token);\n\t\t\t}\n\t\t\telse if ( isNamedParameter(token) ) {\n\t\t\t\tresult.append(token);\n\t\t\t}\n\t\t\telse if ( isIdentifier(token)\n\t\t\t\t\t&& !isFunctionOrKeyword(lcToken, nextToken, dialect, typeConfiguration, functionRegistry) ) {\n\t\t\t\tresult.append(placeholder)\n\t\t\t\t\t\t.append('.')\n\t\t\t\t\t\t.append( dialect.quote(token) );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif ( BEFORE_TABLE_KEYWORDS.contains(lcToken) ) {\n\t\t\t\t\tbeforeTable = true;\n\t\t\t\t\tinFromClause = true;\n\t\t\t\t}\n\t\t\t\telse if ( inFromClause && \",\".equals(lcToken) ) {\n\t\t\t\t\tbeforeTable = true;\n\t\t\t\t}\n\t\t\t\tif ( isBoolean( token ) ) {\n\t\t\t\t\ttoken = dialect.toBooleanValueString( Boolean.parseBoolean( token ) );\n\t\t\t\t}\n\t\t\t\tresult.append(token);\n\t\t\t}\n\n\t\t\t//Yuck:\n\t\t\tif ( inFromClause\n\t\t\t\t\t&& KEYWORDS.contains( lcToken ) //\"as\" is not in KEYWORDS\n\t\t\t\t\t&& !BEFORE_TABLE_KEYWORDS.contains( lcToken ) ) {\n\t\t\t\tinFromClause = false;\n\t\t\t}\n\t\t}\n\n\t\treturn result.toString();\n\t}\n\n\tprivate enum TimeZoneTokens {\n\t\tNONE,\n\t\tWITH,\n\t\tTIME,\n\t\tZONE;\n\n\t\tstatic TimeZoneTokens getPossibleNextTokens(String lctoken) {\n\t\t\tswitch ( lctoken ) {\n\t\t\t\tcase \"time\":\n\t\t\t\tcase \"timestamp\":\n\t\t\t\t\treturn WITH;\n\t\t\t\tdefault:\n\t\t\t\t\treturn NONE;\n\t\t\t}\n\t\t}\n\n\t\tpublic TimeZoneTokens nextToken() {\n\t\t\tif ( this == WITH ) {\n\t\t\t\treturn TIME;\n\t\t\t}\n\t\t\telse if ( this == TIME ) {\n\t\t\t\treturn ZONE;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn NONE;\n\t\t\t}\n\t\t}\n\n\t\tpublic boolean isToken(String token) {\n\t\t\treturn this != NONE && name().equalsIgnoreCase( token );\n\t\t}\n\t}\n\n\tpublic static List<String> collectColumnNames(\n\t\t\tString sql,\n\t\t\tDialect dialect,\n\t\t\tTypeConfiguration typeConfiguration,\n\t\t\tSqmFunctionRegistry functionRegistry) {\n\t\treturn collectColumnNames( renderWhereStringTemplate( sql, dialect, typeConfiguration, functionRegistry ) );\n\t}\n\n\tpublic static List<String> collectColumnNames(String template) {\n\t\tfinal List<String> names = new ArrayList<>();\n\t\tint begin = 0;\n\t\tint match;\n\t\twhile ( ( match = template.indexOf(TEMPLATE, begin) ) >= 0 ) {\n\t\t\tint start = match + TEMPLATE.length() + 1;\n\t\t\tfor ( int loc = start;; loc++ ) {\n\t\t\t\tif ( loc == template.length() - 1 ) {\n\t\t\t\t\tnames.add( template.substring( start ) );\n\t\t\t\t\tbegin = template.length();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tchar ch = template.charAt( loc );\n\t\t\t\t\tif ( PUNCTUATION.indexOf(ch) >= 0 || WHITESPACE.indexOf(ch) >= 0 ) {\n\t\t\t\t\t\tnames.add( template.substring( start, loc ) );\n\t\t\t\t\t\tbegin = loc;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn names;\n\t}\n\n//\t/**\n//\t * Takes the where condition provided in the mapping attribute and interpolates the alias.\n//\t * Handles sub-selects, quoted identifiers, quoted strings, expressions, SQL functions,\n//\t * named parameters.\n//\t *\n//\t * @param sqlWhereString The string into which to interpolate the placeholder value\n//\t * @param placeholder The value to be interpolated into the sqlWhereString\n//\t * @param dialect The dialect to apply\n//\t * @param functionRegistry The registry of all sql functions\n//\t *\n//\t * @return The rendered sql fragment\n//\t */\n//\tpublic static String renderWhereStringTemplate(\n//\t\t\tString sqlWhereString,\n//\t\t\tString placeholder,\n//\t\t\tDialect dialect,\n//\t\t\tSQLFunctionRegistry functionRegistry) {\n//\n//\t\t// IMPL NOTE : The basic process here is to tokenize the incoming string and to iterate over each token\n//\t\t//\t\tin turn.  As we process each token, we set a series of flags used to indicate the type of context in\n//\t\t// \t\twhich the tokens occur.  Depending on the state of those flags we decide whether we need to qualify\n//\t\t//\t\tidentifier references.\n//\n//\t\tfinal String dialectOpenQuote = Character.toString( dialect.openQuote() );\n//\t\tfinal String dialectCloseQuote = Character.toString( dialect.closeQuote() );\n//\n//\t\tString symbols = new StringBuilder()\n//\t\t\t\t.append( \"=><!+-*/()',|&`\" )\n//\t\t\t\t.append( StringHelper.WHITESPACE )\n//\t\t\t\t.append( dialect.openQuote() )\n//\t\t\t\t.append( dialect.closeQuote() )\n//\t\t\t\t.toString();\n//\t\tStringTokenizer tokens = new StringTokenizer( sqlWhereString, symbols, true );\n//\t\tProcessingState state = new ProcessingState();\n//\n//\t\tStringBuilder quotedBuffer = new StringBuilder();\n//\t\tStringBuilder result = new StringBuilder();\n//\n//\t\tboolean hasMore = tokens.hasMoreTokens();\n//\t\tString nextToken = hasMore ? tokens.nextToken() : null;\n//\t\twhile ( hasMore ) {\n//\t\t\tString token = nextToken;\n//\t\t\tString lcToken = token.toLowerCase(Locale.ROOT);\n//\t\t\thasMore = tokens.hasMoreTokens();\n//\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n//\n//\t\t\t// First, determine quoting which might be based on either:\n//\t\t\t// \t\t1) back-tick\n//\t\t\t// \t\t2) single quote (ANSI SQL standard)\n//\t\t\t// \t\t3) or dialect defined quote character(s)\n//\t\t\tQuotingCharacterDisposition quotingCharacterDisposition = QuotingCharacterDisposition.NONE;\n//\t\t\tif ( \"`\".equals( token ) ) {\n//\t\t\t\tstate.quoted = !state.quoted;\n//\t\t\t\tquotingCharacterDisposition = state.quoted\n//\t\t\t\t\t\t? QuotingCharacterDisposition.OPEN\n//\t\t\t\t\t\t: QuotingCharacterDisposition.CLOSE;\n//\t\t\t\t// replace token with the appropriate dialect quoting char\n//\t\t\t\ttoken = lcToken = ( quotingCharacterDisposition == QuotingCharacterDisposition.OPEN )\n//\t\t\t\t\t\t? dialectOpenQuote\n//\t\t\t\t\t\t: dialectCloseQuote;\n//\t\t\t}\n//\t\t\telse if ( \"'\".equals( token ) ) {\n//\t\t\t\tstate.quoted = !state.quoted;\n//\t\t\t\tquotingCharacterDisposition = state.quoted\n//\t\t\t\t\t\t? QuotingCharacterDisposition.OPEN\n//\t\t\t\t\t\t: QuotingCharacterDisposition.CLOSE;\n//\t\t\t}\n//\t\t\telse if ( !state.quoted && dialectOpenQuote.equals( token ) ) {\n//\t\t\t\tstate.quoted = true;\n//\t\t\t\tquotingCharacterDisposition = QuotingCharacterDisposition.OPEN;\n//\t\t\t}\n//\t\t\telse if ( state.quoted && dialectCloseQuote.equals( token ) ) {\n//\t\t\t\tstate.quoted = false;\n//\t\t\t\tquotingCharacterDisposition = QuotingCharacterDisposition.CLOSE;\n//\t\t\t}\n//\n//\t\t\tif ( state.quoted ) {\n//\t\t\t\tquotedBuffer.append( token );\n//\t\t\t\tcontinue;\n//\t\t\t}\n//\n//\t\t\t// if we were previously processing quoted state and just encountered the close quote, then handle that\n//\t\t\t// quoted text\n//\t\t\tif ( quotingCharacterDisposition == QuotingCharacterDisposition.CLOSE ) {\n//\t\t\t\ttoken = quotedBuffer.toString();\n//\t\t\t\tquotedBuffer.setLength( 0 );\n//\t\t\t\tresult.append( placeholder ).append( '.' )\n//\t\t\t\t\t\t.append( dialectOpenQuote ).append( token ).append( dialectCloseQuote );\n//\t\t\t\tcontinue;\n//\t\t\t}\n//\n//\t\t\t// Special processing for ANSI SQL EXTRACT function\n//\t\t\tif ( \"extract\".equals( lcToken ) && \"(\".equals( nextToken ) ) {\n//\t\t\t\tfinal String field = extractUntil( tokens, \"from\" );\n//\t\t\t\tfinal String source = renderWhereStringTemplate(\n//\t\t\t\t\t\textractUntil( tokens, \")\" ),\n//\t\t\t\t\t\tplaceholder,\n//\t\t\t\t\t\tdialect,\n//\t\t\t\t\t\tfunctionRegistry\n//\t\t\t\t);\n//\t\t\t\tresult.append( \"extract(\" ).append( field ).append( \" from \" ).append( source ).append( ')' );\n//\n//\t\t\t\thasMore = tokens.hasMoreTokens();\n//\t\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n//\n//\t\t\t\tcontinue;\n//\t\t\t}\n//\n//\t\t\t// Special processing for ANSI SQL TRIM function\n//\t\t\tif ( \"trim\".equals( lcToken ) && \"(\".equals( nextToken ) ) {\n//\t\t\t\tList<String> operands = new ArrayList<String>();\n//\t\t\t\tStringBuilder builder = new StringBuilder();\n//\n//\t\t\t\tboolean hasMoreOperands = true;\n//\t\t\t\tString operandToken = tokens.nextToken();\n//\t\t\t\tboolean quoted = false;\n//\t\t\t\twhile ( hasMoreOperands ) {\n//\t\t\t\t\tfinal boolean isQuote = \"'\".equals( operandToken );\n//\t\t\t\t\tif ( isQuote ) {\n//\t\t\t\t\t\tquoted = !quoted;\n//\t\t\t\t\t\tif ( !quoted ) {\n//\t\t\t\t\t\t\toperands.add( builder.append( '\\'' ).toString() );\n//\t\t\t\t\t\t\tbuilder.setLength( 0 );\n//\t\t\t\t\t\t}\n//\t\t\t\t\t\telse {\n//\t\t\t\t\t\t\tbuilder.append( '\\'' );\n//\t\t\t\t\t\t}\n//\t\t\t\t\t}\n//\t\t\t\t\telse if ( quoted ) {\n//\t\t\t\t\t\tbuilder.append( operandToken );\n//\t\t\t\t\t}\n//\t\t\t\t\telse if ( operandToken.length() == 1 && Character.isWhitespace( operandToken.charAt( 0 ) ) ) {\n//\t\t\t\t\t\t// do nothing\n//\t\t\t\t\t}\n//\t\t\t\t\telse {\n//\t\t\t\t\t\toperands.add( operandToken );\n//\t\t\t\t\t}\n//\t\t\t\t\toperandToken = tokens.nextToken();\n//\t\t\t\t\thasMoreOperands = tokens.hasMoreTokens() && ! \")\".equals( operandToken );\n//\t\t\t\t}\n//\n//\t\t\t\tTrimOperands trimOperands = new TrimOperands( operands );\n//\t\t\t\tresult.append( \"trim(\" );\n//\t\t\t\tif ( trimOperands.trimSpec != null ) {\n//\t\t\t\t\tresult.append( trimOperands.trimSpec ).append( ' ' );\n//\t\t\t\t}\n//\t\t\t\tif ( trimOperands.trimChar != null ) {\n//\t\t\t\t\tif ( trimOperands.trimChar.startsWith( \"'\" ) && trimOperands.trimChar.endsWith( \"'\" ) ) {\n//\t\t\t\t\t\tresult.append( trimOperands.trimChar );\n//\t\t\t\t\t}\n//\t\t\t\t\telse {\n//\t\t\t\t\t\tresult.append(\n//\t\t\t\t\t\t\t\trenderWhereStringTemplate( trimOperands.trimSpec, placeholder, dialect, functionRegistry )\n//\t\t\t\t\t\t);\n//\t\t\t\t\t}\n//\t\t\t\t\tresult.append( ' ' );\n//\t\t\t\t}\n//\t\t\t\tif ( trimOperands.from != null ) {\n//\t\t\t\t\tresult.append( trimOperands.from ).append( ' ' );\n//\t\t\t\t}\n//\t\t\t\telse if ( trimOperands.trimSpec != null || trimOperands.trimChar != null ) {\n//\t\t\t\t\t// I think ANSI SQL says that the 'from' is not optional if either trim-spec or trim-char are specified\n//\t\t\t\t\tresult.append( \"from \" );\n//\t\t\t\t}\n//\n//\t\t\t\tresult.append( renderWhereStringTemplate( trimOperands.trimSource, placeholder, dialect, functionRegistry ) )\n//\t\t\t\t\t\t.append( ')' );\n//\n//\t\t\t\thasMore = tokens.hasMoreTokens();\n//\t\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n//\n//\t\t\t\tcontinue;\n//\t\t\t}\n//\n//\n//\t\t\t// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n//\n//\t\t\tif ( Character.isWhitespace( token.charAt( 0 ) ) ) {\n//\t\t\t\tresult.append( token );\n//\t\t\t}\n//\t\t\telse if ( state.beforeTable ) {\n//\t\t\t\tresult.append( token );\n//\t\t\t\tstate.beforeTable = false;\n//\t\t\t\tstate.afterFromTable = true;\n//\t\t\t}\n//\t\t\telse if ( state.afterFromTable ) {\n//\t\t\t\tif ( !\"as\".equals(lcToken) ) {\n//\t\t\t\t\tstate.afterFromTable = false;\n//\t\t\t\t}\n//\t\t\t\tresult.append(token);\n//\t\t\t}\n//\t\t\telse if ( isNamedParameter(token) ) {\n//\t\t\t\tresult.append(token);\n//\t\t\t}\n//\t\t\telse if ( isIdentifier(token, dialect)\n//\t\t\t\t\t&& !isFunctionOrKeyword(lcToken, nextToken, dialect , functionRegistry) ) {\n//\t\t\t\tresult.append(placeholder)\n//\t\t\t\t\t\t.append('.')\n//\t\t\t\t\t\t.append( dialect.quote(token) );\n//\t\t\t}\n//\t\t\telse {\n//\t\t\t\tif ( BEFORE_TABLE_KEYWORDS.contains(lcToken) ) {\n//\t\t\t\t\tstate.beforeTable = true;\n//\t\t\t\t\tstate.inFromClause = true;\n//\t\t\t\t}\n//\t\t\t\telse if ( state.inFromClause && \",\".equals(lcToken) ) {\n//\t\t\t\t\tstate.beforeTable = true;\n//\t\t\t\t}\n//\t\t\t\tresult.append(token);\n//\t\t\t}\n//\n//\t\t\t//Yuck:\n//\t\t\tif ( state.inFromClause\n//\t\t\t\t\t&& KEYWORDS.contains( lcToken ) //\"as\" is not in KEYWORDS\n//\t\t\t\t\t&& !BEFORE_TABLE_KEYWORDS.contains( lcToken ) ) {\n//\t\t\t\tstate.inFromClause = false;\n//\t\t\t}\n//\t\t}\n//\n//\t\treturn result.toString();\n//\t}\n//\n//\tprivate static class ProcessingState {\n//\t\tboolean quoted = false;\n//\t\tboolean quotedIdentifier = false;\n//\t\tboolean beforeTable = false;\n//\t\tboolean inFromClause = false;\n//\t\tboolean afterFromTable = false;\n//\t}\n//\n//\tprivate static enum QuotingCharacterDisposition { NONE, OPEN, CLOSE }\n\n\tprivate static class TrimOperands {\n\t\tprivate final String trimSpec;\n\t\tprivate final String trimChar;\n\t\tprivate final String from;\n\t\tprivate final String trimSource;\n\n\t\tprivate TrimOperands(List<String> operands) {\n\t\t\tfinal int size = operands.size();\n\t\t\tif ( size == 1 ) {\n\t\t\t\ttrimSpec = null;\n\t\t\t\ttrimChar = null;\n\t\t\t\tfrom = null;\n\t\t\t\ttrimSource = operands.get(0);\n\t\t\t}\n\t\t\telse if ( size == 4 ) {\n\t\t\t\ttrimSpec = operands.get(0);\n\t\t\t\ttrimChar = operands.get(1);\n\t\t\t\tfrom = operands.get(2);\n\t\t\t\ttrimSource = operands.get(3);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif ( size < 1 || size > 4 ) {\n\t\t\t\t\tthrow new HibernateException( \"Unexpected number of trim function operands : \" + size );\n\t\t\t\t}\n\n\t\t\t\t// trim-source will always be the last operand\n\t\t\t\ttrimSource = operands.get( size - 1 );\n\n\t\t\t\t// ANSI SQL says that more than one operand means that the FROM is required\n\t\t\t\tif ( ! \"from\".equals( operands.get( size - 2 ) ) ) {\n\t\t\t\t\tthrow new HibernateException( \"Expecting FROM, found : \" + operands.get( size - 2 ) );\n\t\t\t\t}\n\t\t\t\tfrom = operands.get( size - 2 );\n\n\t\t\t\t// trim-spec, if there is one will always be the first operand\n\t\t\t\tif ( \"leading\".equalsIgnoreCase( operands.get(0) )\n\t\t\t\t\t\t|| \"trailing\".equalsIgnoreCase( operands.get(0) )\n\t\t\t\t\t\t|| \"both\".equalsIgnoreCase( operands.get(0) ) ) {\n\t\t\t\t\ttrimSpec = operands.get(0);\n\t\t\t\t\ttrimChar = null;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ttrimSpec = null;\n\t\t\t\t\tif ( size - 2 == 0 ) {\n\t\t\t\t\t\ttrimChar = null;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\ttrimChar = operands.get( 0 );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate static String extractUntil(StringTokenizer tokens, String delimiter) {\n\t\tStringBuilder valueBuilder = new StringBuilder();\n\t\tString token = tokens.nextToken();\n\t\twhile ( ! delimiter.equalsIgnoreCase( token ) ) {\n\t\t\tvalueBuilder.append( token );\n\t\t\ttoken = tokens.nextToken();\n\t\t}\n\t\treturn valueBuilder.toString().trim();\n\t}\n\n\tprivate static boolean isNamedParameter(String token) {\n\t\treturn token.startsWith( \":\" );\n\t}\n\n\tprivate static boolean isFunctionOrKeyword(\n\t\t\tString lcToken,\n\t\t\tString nextToken,\n\t\t\tDialect dialect,\n\t\t\tTypeConfiguration typeConfiguration,\n\t\t\tSqmFunctionRegistry functionRegistry) {\n\t\treturn \"(\".equals( nextToken ) ||\n\t\t\t\tKEYWORDS.contains( lcToken ) ||\n\t\t\t\tisType( lcToken, typeConfiguration ) ||\n\t\t\t\tisFunction( lcToken, nextToken, functionRegistry ) ||\n\t\t\t\tdialect.getKeywords().contains( lcToken ) ||\n\t\t\t\tFUNCTION_KEYWORDS.contains( lcToken );\n\t}\n\n\tprivate static boolean isType(String lcToken, TypeConfiguration typeConfiguration) {\n\t\treturn typeConfiguration.getDdlTypeRegistry().isTypeNameRegistered( lcToken );\n\t}\n\n\tprivate static boolean isFunction(String lcToken, String nextToken, SqmFunctionRegistry functionRegistry) {\n\t\t// checking for \"(\" is currently redundant because it is checked before getting here;\n\t\t// doing the check anyhow, in case that earlier check goes away;\n\t\tif ( \"(\".equals( nextToken ) ) {\n\t\t\treturn true;\n\t\t}\n\n\t\tfinal SqmFunctionDescriptor function = functionRegistry.findFunctionDescriptor( lcToken );\n\t\treturn function != null;\n\t}\n\n\tprivate static boolean isIdentifier(String token) {\n\t\tif ( isBoolean( token ) ) {\n\t\t\treturn false;\n\t\t}\n\t\treturn token.charAt( 0 ) == '`' || ( //allow any identifier quoted with backtick\n\t\t\t\tCharacter.isLetter( token.charAt( 0 ) ) && //only recognizes identifiers beginning with a letter\n\t\t\t\t\t\ttoken.indexOf( '.' ) < 0\n\t\t);\n\t}\n\n\tprivate static boolean isBoolean(String token) {\n\t\treturn \"true\".equals( token ) || \"false\".equals( token );\n\t}\n}\n",
        "filePathAfter": "hibernate-core/src/main/java/org/hibernate/sql/Template.java",
        "sourceCodeAfterForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.\n */\npackage org.hibernate.sql;\n\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Set;\nimport java.util.StringTokenizer;\n\nimport org.hibernate.HibernateException;\nimport org.hibernate.dialect.Dialect;\nimport org.hibernate.query.sqm.function.SqmFunctionDescriptor;\nimport org.hibernate.query.sqm.function.SqmFunctionRegistry;\nimport org.hibernate.type.spi.TypeConfiguration;\n\nimport static java.lang.Boolean.parseBoolean;\nimport static java.lang.Character.isLetter;\nimport static org.hibernate.internal.util.StringHelper.WHITESPACE;\n\n/**\n * Parses SQL fragments specified in mapping documents.\n *\n * @author Gavin King\n */\npublic final class Template {\n\n\tprivate static final Set<String> KEYWORDS = new HashSet<>();\n\tprivate static final Set<String> BEFORE_TABLE_KEYWORDS = new HashSet<>();\n\tprivate static final Set<String> FUNCTION_KEYWORDS = new HashSet<>();\n\tprivate static final Set<String> LITERAL_PREFIXES = new HashSet<>();\n\tpublic static final String PUNCTUATION = \"=><!+-*/()',|&`\";\n\n\tstatic {\n\t\tKEYWORDS.add(\"and\");\n\t\tKEYWORDS.add(\"or\");\n\t\tKEYWORDS.add(\"not\");\n\t\tKEYWORDS.add(\"like\");\n\t\tKEYWORDS.add(\"escape\");\n\t\tKEYWORDS.add(\"is\");\n\t\tKEYWORDS.add(\"in\");\n\t\tKEYWORDS.add(\"between\");\n\t\tKEYWORDS.add(\"null\");\n\t\tKEYWORDS.add(\"select\");\n\t\tKEYWORDS.add(\"distinct\");\n\t\tKEYWORDS.add(\"from\");\n\t\tKEYWORDS.add(\"join\");\n\t\tKEYWORDS.add(\"inner\");\n\t\tKEYWORDS.add(\"outer\");\n\t\tKEYWORDS.add(\"left\");\n\t\tKEYWORDS.add(\"right\");\n\t\tKEYWORDS.add(\"on\");\n\t\tKEYWORDS.add(\"where\");\n\t\tKEYWORDS.add(\"having\");\n\t\tKEYWORDS.add(\"group\");\n\t\tKEYWORDS.add(\"order\");\n\t\tKEYWORDS.add(\"by\");\n\t\tKEYWORDS.add(\"desc\");\n\t\tKEYWORDS.add(\"asc\");\n\t\tKEYWORDS.add(\"limit\");\n\t\tKEYWORDS.add(\"any\");\n\t\tKEYWORDS.add(\"some\");\n\t\tKEYWORDS.add(\"exists\");\n\t\tKEYWORDS.add(\"all\");\n\t\tKEYWORDS.add(\"union\");\n\t\tKEYWORDS.add(\"minus\");\n\t\tKEYWORDS.add(\"except\");\n\t\tKEYWORDS.add(\"intersect\");\n\t\tKEYWORDS.add(\"partition\");\n\n\t\tBEFORE_TABLE_KEYWORDS.add(\"from\");\n\t\tBEFORE_TABLE_KEYWORDS.add(\"join\");\n\n\t\tFUNCTION_KEYWORDS.add(\"as\");\n\t\tFUNCTION_KEYWORDS.add(\"leading\");\n\t\tFUNCTION_KEYWORDS.add(\"trailing\");\n\t\tFUNCTION_KEYWORDS.add(\"from\");\n\t\tFUNCTION_KEYWORDS.add(\"case\");\n\t\tFUNCTION_KEYWORDS.add(\"when\");\n\t\tFUNCTION_KEYWORDS.add(\"then\");\n\t\tFUNCTION_KEYWORDS.add(\"else\");\n\t\tFUNCTION_KEYWORDS.add(\"end\");\n\n\t\tLITERAL_PREFIXES.add(\"n\");\n\t\tLITERAL_PREFIXES.add(\"x\");\n\t\tLITERAL_PREFIXES.add(\"varbyte\");\n\t\tLITERAL_PREFIXES.add(\"bx\");\n\t\tLITERAL_PREFIXES.add(\"bytea\");\n\t\tLITERAL_PREFIXES.add(\"date\");\n\t\tLITERAL_PREFIXES.add(\"time\");\n\t\tLITERAL_PREFIXES.add(\"timestamp\");\n\t\tLITERAL_PREFIXES.add(\"zone\");\n\t}\n\n\tpublic static final String TEMPLATE = \"$PlaceHolder$\";\n\n\tprivate Template() {}\n\n\tpublic static String renderTransformerReadFragment(\n\t\t\tString fragment,\n\t\t\tString... columnNames) {\n\t\t// NOTE : would need access to SessionFactoryImplementor to make this configurable\n\t\tfor ( String columnName : columnNames ) {\n\t\t\tfragment = fragment.replace( columnName, TEMPLATE + '.' + columnName );\n\t\t}\n\t\treturn fragment;\n\t}\n\n\tpublic static String renderWhereStringTemplate(\n\t\t\tString sqlWhereString,\n\t\t\tDialect dialect,\n\t\t\tTypeConfiguration typeConfiguration,\n\t\t\tSqmFunctionRegistry functionRegistry) {\n\t\treturn renderWhereStringTemplate( sqlWhereString, TEMPLATE, dialect, typeConfiguration, functionRegistry );\n\t}\n\n\t/**\n\t * Takes the where condition provided in the mapping attribute and interpolates the alias.\n\t * Handles sub-selects, quoted identifiers, quoted strings, expressions, SQL functions,\n\t * named parameters.\n\t *\n\t * @param sqlWhereString The string into which to interpolate the placeholder value\n\t * @param placeholder The value to be interpolated into the sqlWhereString\n\t * @param dialect The dialect to apply\n\t * @param functionRegistry The registry of all sql functions\n\t * @return The rendered sql fragment\n\t */\n\tpublic static String renderWhereStringTemplate(\n\t\t\tString sqlWhereString,\n\t\t\tString placeholder,\n\t\t\tDialect dialect,\n\t\t\tTypeConfiguration typeConfiguration,\n\t\t\tSqmFunctionRegistry functionRegistry) {\n\n\t\t// IMPL NOTE : The basic process here is to tokenize the incoming string and to iterate over each token\n\t\t//\t\tin turn.  As we process each token, we set a series of flags used to indicate the type of context in\n\t\t// \t\twhich the tokens occur.  Depending on the state of those flags we decide whether we need to qualify\n\t\t//\t\tidentifier references.\n\n\t\tfinal String symbols = PUNCTUATION + WHITESPACE + dialect.openQuote() + dialect.closeQuote();\n\t\tfinal StringTokenizer tokens = new StringTokenizer( sqlWhereString, symbols, true );\n\t\tfinal StringBuilder result = new StringBuilder();\n\n\t\tboolean quoted = false;\n\t\tboolean quotedIdentifier = false;\n\t\tboolean beforeTable = false;\n\t\tboolean inFromClause = false;\n\t\tboolean afterFromTable = false;\n\n\t\tboolean hasMore = tokens.hasMoreTokens();\n\t\tString nextToken = hasMore ? tokens.nextToken() : null;\n\t\twhile ( hasMore ) {\n\t\t\tString token = nextToken;\n\t\t\tString lcToken = token.toLowerCase(Locale.ROOT);\n\t\t\thasMore = tokens.hasMoreTokens();\n\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n\n\t\t\tboolean isQuoteCharacter = false;\n\n\t\t\tif ( !quotedIdentifier && \"'\".equals(token) ) {\n\t\t\t\tquoted = !quoted;\n\t\t\t\tisQuoteCharacter = true;\n\t\t\t}\n\n\t\t\tif ( !quoted ) {\n\t\t\t\tfinal boolean isOpenQuote;\n\t\t\t\tif ( \"`\".equals(token) ) {\n\t\t\t\t\tisOpenQuote = !quotedIdentifier;\n\t\t\t\t\ttoken = lcToken = isOpenQuote\n\t\t\t\t\t\t\t? Character.toString( dialect.openQuote() )\n\t\t\t\t\t\t\t: Character.toString( dialect.closeQuote() );\n\t\t\t\t\tquotedIdentifier = isOpenQuote;\n\t\t\t\t\tisQuoteCharacter = true;\n\t\t\t\t}\n\t\t\t\telse if ( !quotedIdentifier && dialect.openQuote()==token.charAt(0) ) {\n\t\t\t\t\tisOpenQuote = true;\n\t\t\t\t\tquotedIdentifier = true;\n\t\t\t\t\tisQuoteCharacter = true;\n\t\t\t\t}\n\t\t\t\telse if ( quotedIdentifier && dialect.closeQuote()==token.charAt(0) ) {\n\t\t\t\t\tquotedIdentifier = false;\n\t\t\t\t\tisQuoteCharacter = true;\n\t\t\t\t\tisOpenQuote = false;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tisOpenQuote = false;\n\t\t\t\t}\n\t\t\t\tif ( isOpenQuote ) {\n\t\t\t\t\tresult.append( placeholder ).append( '.' );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfinal boolean quotedOrWhitespace =\n\t\t\t\t\tquoted || quotedIdentifier || isQuoteCharacter\n\t\t\t\t\t\t\t|| token.isBlank();\n\t\t\tif ( quotedOrWhitespace ) {\n\t\t\t\tresult.append( token );\n\t\t\t}\n\t\t\telse if ( beforeTable ) {\n\t\t\t\tresult.append( token );\n\t\t\t\tbeforeTable = false;\n\t\t\t\tafterFromTable = true;\n\t\t\t}\n\t\t\telse if ( afterFromTable ) {\n\t\t\t\tif ( !\"as\".equals(lcToken) ) {\n\t\t\t\t\tafterFromTable = false;\n\t\t\t\t}\n\t\t\t\tresult.append(token);\n\t\t\t}\n\t\t\telse if ( isNamedParameter(token) ) {\n\t\t\t\tresult.append(token);\n\t\t\t}\n\t\t\telse if ( isExtractFunction( lcToken, nextToken ) ) {\n\t\t\t\t// Special processing for ANSI SQL EXTRACT function\n\t\t\t\thandleExtractFunction( placeholder, dialect, typeConfiguration, functionRegistry, tokens, result );\n\t\t\t\thasMore = tokens.hasMoreTokens();\n\t\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n\t\t\t}\n\t\t\telse if ( isTrimFunction( lcToken, nextToken ) ) {\n\t\t\t\t// Special processing for ANSI SQL TRIM function\n\t\t\t\thandleTrimFunction( placeholder, dialect, typeConfiguration, functionRegistry, tokens, result );\n\t\t\t\thasMore = tokens.hasMoreTokens();\n\t\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n\t\t\t}\n\t\t\telse if ( isIdentifier(token)\n\t\t\t\t\t&& !isFunctionOrKeyword( lcToken, nextToken, dialect, typeConfiguration, functionRegistry )\n\t\t\t\t\t&& !isLiteral( lcToken, nextToken, sqlWhereString, symbols, tokens ) ) {\n\t\t\t\tresult.append(placeholder)\n\t\t\t\t\t\t.append('.')\n\t\t\t\t\t\t.append( dialect.quote(token) );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif ( BEFORE_TABLE_KEYWORDS.contains(lcToken) ) {\n\t\t\t\t\tbeforeTable = true;\n\t\t\t\t\tinFromClause = true;\n\t\t\t\t}\n\t\t\t\telse if ( inFromClause && \",\".equals(lcToken) ) {\n\t\t\t\t\tbeforeTable = true;\n\t\t\t\t}\n\t\t\t\tif ( isBoolean( token ) ) {\n\t\t\t\t\ttoken = dialect.toBooleanValueString( parseBoolean( token ) );\n\t\t\t\t}\n\t\t\t\tresult.append(token);\n\t\t\t}\n\n\t\t\t//Yuck:\n\t\t\tif ( inFromClause\n\t\t\t\t\t&& KEYWORDS.contains( lcToken ) //\"as\" is not in KEYWORDS\n\t\t\t\t\t&& !BEFORE_TABLE_KEYWORDS.contains( lcToken ) ) {\n\t\t\t\tinFromClause = false;\n\t\t\t}\n\t\t}\n\n\t\treturn result.toString();\n\t}\n\n\tprivate static boolean isTrimFunction(String lcToken, String nextToken) {\n\t\treturn \"trim\".equals(lcToken) && \"(\".equals(nextToken);\n\t}\n\n\tprivate static boolean isExtractFunction(String lcToken, String nextToken) {\n\t\treturn \"extract\".equals(lcToken) && \"(\".equals(nextToken);\n\t}\n\n\tprivate static boolean isLiteral(\n\t\t\tString lcToken, String next,\n\t\t\tString sqlWhereString, String symbols, StringTokenizer tokens) {\n\t\tif ( LITERAL_PREFIXES.contains( lcToken ) && next != null ) {\n\t\t\t// easy cases first\n\t\t\tif ( \"'\".equals(next) ) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse if ( !next.isBlank() ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// we need to look ahead in the token stream\n\t\t\t\t// to find the first non-blank token\n\t\t\t\tfinal StringTokenizer lookahead =\n\t\t\t\t\t\tnew StringTokenizer( sqlWhereString, symbols, true );\n\t\t\t\twhile ( lookahead.countTokens() > tokens.countTokens()+1 ) {\n\t\t\t\t\tlookahead.nextToken();\n\t\t\t\t}\n\t\t\t\tif ( lookahead.hasMoreTokens() ) {\n\t\t\t\t\tString nextToken;\n\t\t\t\t\tdo {\n\t\t\t\t\t\tnextToken = lookahead.nextToken().toLowerCase(Locale.ROOT);\n\t\t\t\t\t}\n\t\t\t\t\twhile ( nextToken.isBlank() && lookahead.hasMoreTokens() );\n\t\t\t\t\treturn \"'\".equals( nextToken )\n\t\t\t\t\t\t|| lcToken.equals( \"time\" ) && \"with\".equals( nextToken )\n\t\t\t\t\t\t|| lcToken.equals( \"timestamp\" ) && \"with\".equals( nextToken )\n\t\t\t\t\t\t|| lcToken.equals( \"time\" ) && \"zone\".equals( nextToken );\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tprivate static void handleTrimFunction(\n\t\t\tString placeholder, Dialect dialect,\n\t\t\tTypeConfiguration typeConfiguration,\n\t\t\tSqmFunctionRegistry functionRegistry,\n\t\t\tStringTokenizer tokens,\n\t\t\tStringBuilder result) {\n\t\tfinal List<String> operands = new ArrayList<>();\n\t\tfinal StringBuilder builder = new StringBuilder();\n\n\t\tboolean hasMoreOperands = true;\n\t\tString operandToken = tokens.nextToken();\n\t\tswitch ( operandToken.toLowerCase( Locale.ROOT ) ) {\n\t\t\tcase \"leading\":\n\t\t\tcase \"trailing\":\n\t\t\tcase \"both\":\n\t\t\t\toperands.add( operandToken );\n\t\t\t\tif ( hasMoreOperands = tokens.hasMoreTokens() ) {\n\t\t\t\t\toperandToken = tokens.nextToken();\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t\tboolean quotedOperand = false;\n\t\tint parenthesis = 0;\n\t\twhile ( hasMoreOperands ) {\n\t\t\tfinal boolean isQuote = \"'\".equals( operandToken );\n\t\t\tif ( isQuote ) {\n\t\t\t\tquotedOperand = !quotedOperand;\n\t\t\t\tif ( !quotedOperand ) {\n\t\t\t\t\toperands.add( builder.append( '\\'' ).toString() );\n\t\t\t\t\tbuilder.setLength( 0 );\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tbuilder.append( '\\'' );\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if ( quotedOperand ) {\n\t\t\t\tbuilder.append( operandToken );\n\t\t\t}\n\t\t\telse if ( parenthesis != 0 ) {\n\t\t\t\tbuilder.append( operandToken );\n\t\t\t\tswitch ( operandToken ) {\n\t\t\t\t\tcase \"(\":\n\t\t\t\t\t\tparenthesis++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \")\":\n\t\t\t\t\t\tparenthesis--;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbuilder.append( operandToken );\n\t\t\t\tswitch ( operandToken.toLowerCase( Locale.ROOT ) ) {\n\t\t\t\t\tcase \"(\":\n\t\t\t\t\t\tparenthesis++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \")\":\n\t\t\t\t\t\tparenthesis--;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"from\":\n\t\t\t\t\t\tif ( !builder.isEmpty() ) {\n\t\t\t\t\t\t\toperands.add( builder.substring( 0, builder.length() - 4 ) );\n\t\t\t\t\t\t\tbuilder.setLength( 0 );\n\t\t\t\t\t\t\toperands.add( operandToken );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\toperandToken = tokens.nextToken();\n\t\t\thasMoreOperands = tokens.hasMoreTokens()\n\t\t\t\t\t&& ( parenthesis != 0 || ! \")\".equals( operandToken ) );\n\t\t}\n\t\tif ( !builder.isEmpty() ) {\n\t\t\toperands.add( builder.toString() );\n\t\t}\n\n\t\tfinal TrimOperands trimOperands = new TrimOperands( operands );\n\t\tresult.append( \"trim(\" );\n\t\tif ( trimOperands.trimSpec != null ) {\n\t\t\tresult.append( trimOperands.trimSpec ).append( ' ' );\n\t\t}\n\t\tif ( trimOperands.trimChar != null ) {\n\t\t\tif ( trimOperands.trimChar.startsWith( \"'\" ) && trimOperands.trimChar.endsWith( \"'\" ) ) {\n\t\t\t\tresult.append( trimOperands.trimChar );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tresult.append(\n\t\t\t\t\t\trenderWhereStringTemplate( trimOperands.trimSpec, placeholder, dialect, typeConfiguration, functionRegistry )\n\t\t\t\t);\n\t\t\t}\n\t\t\tresult.append( ' ' );\n\t\t}\n\t\tif ( trimOperands.from != null ) {\n\t\t\tresult.append( trimOperands.from ).append( ' ' );\n\t\t}\n\t\telse if ( trimOperands.trimSpec != null || trimOperands.trimChar != null ) {\n\t\t\t// I think ANSI SQL says that the 'from' is not optional if either trim-spec or trim-char is specified\n\t\t\tresult.append( \"from \" );\n\t\t}\n\n\t\tresult.append( renderWhereStringTemplate( trimOperands.trimSource, placeholder, dialect, typeConfiguration, functionRegistry ) )\n\t\t\t\t.append( ')' );\n\t}\n\n\tprivate static void handleExtractFunction(\n\t\t\tString placeholder,\n\t\t\tDialect dialect,\n\t\t\tTypeConfiguration typeConfiguration,\n\t\t\tSqmFunctionRegistry functionRegistry,\n\t\t\tStringTokenizer tokens,\n\t\t\tStringBuilder result) {\n\t\tfinal String field = extractUntil( tokens, \"from\" );\n\t\tfinal String source = renderWhereStringTemplate(\n\t\t\t\textractUntil( tokens, \")\" ),\n\t\t\t\tplaceholder,\n\t\t\t\tdialect,\n\t\t\t\ttypeConfiguration,\n\t\t\t\tfunctionRegistry\n\t\t);\n\t\tresult.append( \"extract(\" ).append( field ).append( \" from \" ).append( source ).append( ')' );\n\t}\n\n\tpublic static List<String> collectColumnNames(\n\t\t\tString sql,\n\t\t\tDialect dialect,\n\t\t\tTypeConfiguration typeConfiguration,\n\t\t\tSqmFunctionRegistry functionRegistry) {\n\t\treturn collectColumnNames( renderWhereStringTemplate( sql, dialect, typeConfiguration, functionRegistry ) );\n\t}\n\n\tpublic static List<String> collectColumnNames(String template) {\n\t\tfinal List<String> names = new ArrayList<>();\n\t\tint begin = 0;\n\t\tint match;\n\t\twhile ( ( match = template.indexOf(TEMPLATE, begin) ) >= 0 ) {\n\t\t\tint start = match + TEMPLATE.length() + 1;\n\t\t\tfor ( int loc = start;; loc++ ) {\n\t\t\t\tif ( loc == template.length() - 1 ) {\n\t\t\t\t\tnames.add( template.substring( start ) );\n\t\t\t\t\tbegin = template.length();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tchar ch = template.charAt( loc );\n\t\t\t\t\tif ( PUNCTUATION.indexOf(ch) >= 0 || WHITESPACE.indexOf(ch) >= 0 ) {\n\t\t\t\t\t\tnames.add( template.substring( start, loc ) );\n\t\t\t\t\t\tbegin = loc;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn names;\n\t}\n\n//\t/**\n//\t * Takes the where condition provided in the mapping attribute and interpolates the alias.\n//\t * Handles sub-selects, quoted identifiers, quoted strings, expressions, SQL functions,\n//\t * named parameters.\n//\t *\n//\t * @param sqlWhereString The string into which to interpolate the placeholder value\n//\t * @param placeholder The value to be interpolated into the sqlWhereString\n//\t * @param dialect The dialect to apply\n//\t * @param functionRegistry The registry of all sql functions\n//\t *\n//\t * @return The rendered sql fragment\n//\t */\n//\tpublic static String renderWhereStringTemplate(\n//\t\t\tString sqlWhereString,\n//\t\t\tString placeholder,\n//\t\t\tDialect dialect,\n//\t\t\tSQLFunctionRegistry functionRegistry) {\n//\n//\t\t// IMPL NOTE : The basic process here is to tokenize the incoming string and to iterate over each token\n//\t\t//\t\tin turn.  As we process each token, we set a series of flags used to indicate the type of context in\n//\t\t// \t\twhich the tokens occur.  Depending on the state of those flags we decide whether we need to qualify\n//\t\t//\t\tidentifier references.\n//\n//\t\tfinal String dialectOpenQuote = Character.toString( dialect.openQuote() );\n//\t\tfinal String dialectCloseQuote = Character.toString( dialect.closeQuote() );\n//\n//\t\tString symbols = new StringBuilder()\n//\t\t\t\t.append( \"=><!+-*/()',|&`\" )\n//\t\t\t\t.append( StringHelper.WHITESPACE )\n//\t\t\t\t.append( dialect.openQuote() )\n//\t\t\t\t.append( dialect.closeQuote() )\n//\t\t\t\t.toString();\n//\t\tStringTokenizer tokens = new StringTokenizer( sqlWhereString, symbols, true );\n//\t\tProcessingState state = new ProcessingState();\n//\n//\t\tStringBuilder quotedBuffer = new StringBuilder();\n//\t\tStringBuilder result = new StringBuilder();\n//\n//\t\tboolean hasMore = tokens.hasMoreTokens();\n//\t\tString nextToken = hasMore ? tokens.nextToken() : null;\n//\t\twhile ( hasMore ) {\n//\t\t\tString token = nextToken;\n//\t\t\tString lcToken = token.toLowerCase(Locale.ROOT);\n//\t\t\thasMore = tokens.hasMoreTokens();\n//\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n//\n//\t\t\t// First, determine quoting which might be based on either:\n//\t\t\t// \t\t1) back-tick\n//\t\t\t// \t\t2) single quote (ANSI SQL standard)\n//\t\t\t// \t\t3) or dialect defined quote character(s)\n//\t\t\tQuotingCharacterDisposition quotingCharacterDisposition = QuotingCharacterDisposition.NONE;\n//\t\t\tif ( \"`\".equals( token ) ) {\n//\t\t\t\tstate.quoted = !state.quoted;\n//\t\t\t\tquotingCharacterDisposition = state.quoted\n//\t\t\t\t\t\t? QuotingCharacterDisposition.OPEN\n//\t\t\t\t\t\t: QuotingCharacterDisposition.CLOSE;\n//\t\t\t\t// replace token with the appropriate dialect quoting char\n//\t\t\t\ttoken = lcToken = ( quotingCharacterDisposition == QuotingCharacterDisposition.OPEN )\n//\t\t\t\t\t\t? dialectOpenQuote\n//\t\t\t\t\t\t: dialectCloseQuote;\n//\t\t\t}\n//\t\t\telse if ( \"'\".equals( token ) ) {\n//\t\t\t\tstate.quoted = !state.quoted;\n//\t\t\t\tquotingCharacterDisposition = state.quoted\n//\t\t\t\t\t\t? QuotingCharacterDisposition.OPEN\n//\t\t\t\t\t\t: QuotingCharacterDisposition.CLOSE;\n//\t\t\t}\n//\t\t\telse if ( !state.quoted && dialectOpenQuote.equals( token ) ) {\n//\t\t\t\tstate.quoted = true;\n//\t\t\t\tquotingCharacterDisposition = QuotingCharacterDisposition.OPEN;\n//\t\t\t}\n//\t\t\telse if ( state.quoted && dialectCloseQuote.equals( token ) ) {\n//\t\t\t\tstate.quoted = false;\n//\t\t\t\tquotingCharacterDisposition = QuotingCharacterDisposition.CLOSE;\n//\t\t\t}\n//\n//\t\t\tif ( state.quoted ) {\n//\t\t\t\tquotedBuffer.append( token );\n//\t\t\t\tcontinue;\n//\t\t\t}\n//\n//\t\t\t// if we were previously processing quoted state and just encountered the close quote, then handle that\n//\t\t\t// quoted text\n//\t\t\tif ( quotingCharacterDisposition == QuotingCharacterDisposition.CLOSE ) {\n//\t\t\t\ttoken = quotedBuffer.toString();\n//\t\t\t\tquotedBuffer.setLength( 0 );\n//\t\t\t\tresult.append( placeholder ).append( '.' )\n//\t\t\t\t\t\t.append( dialectOpenQuote ).append( token ).append( dialectCloseQuote );\n//\t\t\t\tcontinue;\n//\t\t\t}\n//\n//\t\t\t// Special processing for ANSI SQL EXTRACT function\n//\t\t\tif ( \"extract\".equals( lcToken ) && \"(\".equals( nextToken ) ) {\n//\t\t\t\tfinal String field = extractUntil( tokens, \"from\" );\n//\t\t\t\tfinal String source = renderWhereStringTemplate(\n//\t\t\t\t\t\textractUntil( tokens, \")\" ),\n//\t\t\t\t\t\tplaceholder,\n//\t\t\t\t\t\tdialect,\n//\t\t\t\t\t\tfunctionRegistry\n//\t\t\t\t);\n//\t\t\t\tresult.append( \"extract(\" ).append( field ).append( \" from \" ).append( source ).append( ')' );\n//\n//\t\t\t\thasMore = tokens.hasMoreTokens();\n//\t\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n//\n//\t\t\t\tcontinue;\n//\t\t\t}\n//\n//\t\t\t// Special processing for ANSI SQL TRIM function\n//\t\t\tif ( \"trim\".equals( lcToken ) && \"(\".equals( nextToken ) ) {\n//\t\t\t\tList<String> operands = new ArrayList<String>();\n//\t\t\t\tStringBuilder builder = new StringBuilder();\n//\n//\t\t\t\tboolean hasMoreOperands = true;\n//\t\t\t\tString operandToken = tokens.nextToken();\n//\t\t\t\tboolean quoted = false;\n//\t\t\t\twhile ( hasMoreOperands ) {\n//\t\t\t\t\tfinal boolean isQuote = \"'\".equals( operandToken );\n//\t\t\t\t\tif ( isQuote ) {\n//\t\t\t\t\t\tquoted = !quoted;\n//\t\t\t\t\t\tif ( !quoted ) {\n//\t\t\t\t\t\t\toperands.add( builder.append( '\\'' ).toString() );\n//\t\t\t\t\t\t\tbuilder.setLength( 0 );\n//\t\t\t\t\t\t}\n//\t\t\t\t\t\telse {\n//\t\t\t\t\t\t\tbuilder.append( '\\'' );\n//\t\t\t\t\t\t}\n//\t\t\t\t\t}\n//\t\t\t\t\telse if ( quoted ) {\n//\t\t\t\t\t\tbuilder.append( operandToken );\n//\t\t\t\t\t}\n//\t\t\t\t\telse if ( operandToken.length() == 1 && Character.isWhitespace( operandToken.charAt( 0 ) ) ) {\n//\t\t\t\t\t\t// do nothing\n//\t\t\t\t\t}\n//\t\t\t\t\telse {\n//\t\t\t\t\t\toperands.add( operandToken );\n//\t\t\t\t\t}\n//\t\t\t\t\toperandToken = tokens.nextToken();\n//\t\t\t\t\thasMoreOperands = tokens.hasMoreTokens() && ! \")\".equals( operandToken );\n//\t\t\t\t}\n//\n//\t\t\t\tTrimOperands trimOperands = new TrimOperands( operands );\n//\t\t\t\tresult.append( \"trim(\" );\n//\t\t\t\tif ( trimOperands.trimSpec != null ) {\n//\t\t\t\t\tresult.append( trimOperands.trimSpec ).append( ' ' );\n//\t\t\t\t}\n//\t\t\t\tif ( trimOperands.trimChar != null ) {\n//\t\t\t\t\tif ( trimOperands.trimChar.startsWith( \"'\" ) && trimOperands.trimChar.endsWith( \"'\" ) ) {\n//\t\t\t\t\t\tresult.append( trimOperands.trimChar );\n//\t\t\t\t\t}\n//\t\t\t\t\telse {\n//\t\t\t\t\t\tresult.append(\n//\t\t\t\t\t\t\t\trenderWhereStringTemplate( trimOperands.trimSpec, placeholder, dialect, functionRegistry )\n//\t\t\t\t\t\t);\n//\t\t\t\t\t}\n//\t\t\t\t\tresult.append( ' ' );\n//\t\t\t\t}\n//\t\t\t\tif ( trimOperands.from != null ) {\n//\t\t\t\t\tresult.append( trimOperands.from ).append( ' ' );\n//\t\t\t\t}\n//\t\t\t\telse if ( trimOperands.trimSpec != null || trimOperands.trimChar != null ) {\n//\t\t\t\t\t// I think ANSI SQL says that the 'from' is not optional if either trim-spec or trim-char are specified\n//\t\t\t\t\tresult.append( \"from \" );\n//\t\t\t\t}\n//\n//\t\t\t\tresult.append( renderWhereStringTemplate( trimOperands.trimSource, placeholder, dialect, functionRegistry ) )\n//\t\t\t\t\t\t.append( ')' );\n//\n//\t\t\t\thasMore = tokens.hasMoreTokens();\n//\t\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n//\n//\t\t\t\tcontinue;\n//\t\t\t}\n//\n//\n//\t\t\t// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n//\n//\t\t\tif ( Character.isWhitespace( token.charAt( 0 ) ) ) {\n//\t\t\t\tresult.append( token );\n//\t\t\t}\n//\t\t\telse if ( state.beforeTable ) {\n//\t\t\t\tresult.append( token );\n//\t\t\t\tstate.beforeTable = false;\n//\t\t\t\tstate.afterFromTable = true;\n//\t\t\t}\n//\t\t\telse if ( state.afterFromTable ) {\n//\t\t\t\tif ( !\"as\".equals(lcToken) ) {\n//\t\t\t\t\tstate.afterFromTable = false;\n//\t\t\t\t}\n//\t\t\t\tresult.append(token);\n//\t\t\t}\n//\t\t\telse if ( isNamedParameter(token) ) {\n//\t\t\t\tresult.append(token);\n//\t\t\t}\n//\t\t\telse if ( isIdentifier(token, dialect)\n//\t\t\t\t\t&& !isFunctionOrKeyword(lcToken, nextToken, dialect , functionRegistry) ) {\n//\t\t\t\tresult.append(placeholder)\n//\t\t\t\t\t\t.append('.')\n//\t\t\t\t\t\t.append( dialect.quote(token) );\n//\t\t\t}\n//\t\t\telse {\n//\t\t\t\tif ( BEFORE_TABLE_KEYWORDS.contains(lcToken) ) {\n//\t\t\t\t\tstate.beforeTable = true;\n//\t\t\t\t\tstate.inFromClause = true;\n//\t\t\t\t}\n//\t\t\t\telse if ( state.inFromClause && \",\".equals(lcToken) ) {\n//\t\t\t\t\tstate.beforeTable = true;\n//\t\t\t\t}\n//\t\t\t\tresult.append(token);\n//\t\t\t}\n//\n//\t\t\t//Yuck:\n//\t\t\tif ( state.inFromClause\n//\t\t\t\t\t&& KEYWORDS.contains( lcToken ) //\"as\" is not in KEYWORDS\n//\t\t\t\t\t&& !BEFORE_TABLE_KEYWORDS.contains( lcToken ) ) {\n//\t\t\t\tstate.inFromClause = false;\n//\t\t\t}\n//\t\t}\n//\n//\t\treturn result.toString();\n//\t}\n//\n//\tprivate static class ProcessingState {\n//\t\tboolean quoted = false;\n//\t\tboolean quotedIdentifier = false;\n//\t\tboolean beforeTable = false;\n//\t\tboolean inFromClause = false;\n//\t\tboolean afterFromTable = false;\n//\t}\n//\n//\tprivate static enum QuotingCharacterDisposition { NONE, OPEN, CLOSE }\n\n\tprivate static class TrimOperands {\n\t\tprivate final String trimSpec;\n\t\tprivate final String trimChar;\n\t\tprivate final String from;\n\t\tprivate final String trimSource;\n\n\t\tprivate TrimOperands(List<String> operands) {\n\t\t\tfinal int size = operands.size();\n\t\t\tif ( size == 1 ) {\n\t\t\t\ttrimSpec = null;\n\t\t\t\ttrimChar = null;\n\t\t\t\tfrom = null;\n\t\t\t\ttrimSource = operands.get(0);\n\t\t\t}\n\t\t\telse if ( size == 4 ) {\n\t\t\t\ttrimSpec = operands.get(0);\n\t\t\t\ttrimChar = operands.get(1);\n\t\t\t\tfrom = operands.get(2);\n\t\t\t\ttrimSource = operands.get(3);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif ( size < 1 || size > 4 ) {\n\t\t\t\t\tthrow new HibernateException( \"Unexpected number of trim function operands : \" + size );\n\t\t\t\t}\n\n\t\t\t\t// trim-source will always be the last operand\n\t\t\t\ttrimSource = operands.get( size - 1 );\n\n\t\t\t\t// ANSI SQL says that more than one operand means that the FROM is required\n\t\t\t\tif ( ! \"from\".equals( operands.get( size - 2 ) ) ) {\n\t\t\t\t\tthrow new HibernateException( \"Expecting FROM, found : \" + operands.get( size - 2 ) );\n\t\t\t\t}\n\t\t\t\tfrom = operands.get( size - 2 );\n\n\t\t\t\t// trim-spec, if there is one will always be the first operand\n\t\t\t\tif ( \"leading\".equalsIgnoreCase( operands.get(0) )\n\t\t\t\t\t\t|| \"trailing\".equalsIgnoreCase( operands.get(0) )\n\t\t\t\t\t\t|| \"both\".equalsIgnoreCase( operands.get(0) ) ) {\n\t\t\t\t\ttrimSpec = operands.get(0);\n\t\t\t\t\ttrimChar = null;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ttrimSpec = null;\n\t\t\t\t\tif ( size - 2 == 0 ) {\n\t\t\t\t\t\ttrimChar = null;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\ttrimChar = operands.get( 0 );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate static String extractUntil(StringTokenizer tokens, String delimiter) {\n\t\tfinal StringBuilder valueBuilder = new StringBuilder();\n\t\tString token = tokens.nextToken();\n\t\twhile ( ! delimiter.equalsIgnoreCase( token ) ) {\n\t\t\tvalueBuilder.append( token );\n\t\t\ttoken = tokens.nextToken();\n\t\t}\n\t\treturn valueBuilder.toString().trim();\n\t}\n\n\tprivate static boolean isNamedParameter(String token) {\n\t\treturn token.startsWith( \":\" );\n\t}\n\n\tprivate static boolean isFunctionOrKeyword(\n\t\t\tString lcToken,\n\t\t\tString nextToken,\n\t\t\tDialect dialect,\n\t\t\tTypeConfiguration typeConfiguration,\n\t\t\tSqmFunctionRegistry functionRegistry) {\n\t\tif ( \"(\".equals( nextToken ) ) {\n\t\t\treturn true;\n\t\t}\n\t\telse if ( \"date\".equals( lcToken ) || \"time\".equals( lcToken ) ) {\n\t\t\t// these can be column names on some databases\n\t\t\t// TODO: treat 'current date' as a function\n\t\t\treturn false;\n\t\t}\n\t\telse {\n\t\t\treturn KEYWORDS.contains( lcToken )\n\t\t\t\t|| isType( lcToken, typeConfiguration )\n\t\t\t\t|| isFunction( lcToken, nextToken, functionRegistry )\n\t\t\t\t|| dialect.getKeywords().contains( lcToken )\n\t\t\t\t|| FUNCTION_KEYWORDS.contains( lcToken );\n\t\t}\n\t}\n\n\tprivate static boolean isType(String lcToken, TypeConfiguration typeConfiguration) {\n\t\treturn typeConfiguration.getDdlTypeRegistry().isTypeNameRegistered( lcToken );\n\t}\n\n\tprivate static boolean isFunction(String lcToken, String nextToken, SqmFunctionRegistry functionRegistry) {\n\t\t// checking for \"(\" is currently redundant because it is checked before getting here;\n\t\t// doing the check anyhow, in case that earlier check goes away;\n\t\tif ( \"(\".equals( nextToken ) ) {\n\t\t\treturn true;\n\t\t}\n\n\t\tfinal SqmFunctionDescriptor function = functionRegistry.findFunctionDescriptor( lcToken );\n\t\treturn function != null;\n\t}\n\n\tprivate static boolean isIdentifier(String token) {\n\t\tif ( isBoolean( token ) ) {\n\t\t\treturn false;\n\t\t}\n\t\treturn token.charAt( 0 ) == '`'\n\t\t\t|| ( //allow any identifier quoted with backtick\n\t\t\t\tisLetter( token.charAt( 0 ) ) && //only recognizes identifiers beginning with a letter\n\t\t\t\t\t\ttoken.indexOf( '.' ) < 0\n\t\t\t);\n\t}\n\n\tprivate static boolean isBoolean(String token) {\n\t\treturn \"true\".equals( token ) || \"false\".equals( token );\n\t}\n}\n",
        "diffSourceCodeSet": [
            "private static void handleExtractFunction(\n\t\t\tString placeholder,\n\t\t\tDialect dialect,\n\t\t\tTypeConfiguration typeConfiguration,\n\t\t\tSqmFunctionRegistry functionRegistry,\n\t\t\tStringTokenizer tokens,\n\t\t\tStringBuilder result) {\n\t\tfinal String field = extractUntil( tokens, \"from\" );\n\t\tfinal String source = renderWhereStringTemplate(\n\t\t\t\textractUntil( tokens, \")\" ),\n\t\t\t\tplaceholder,\n\t\t\t\tdialect,\n\t\t\t\ttypeConfiguration,\n\t\t\t\tfunctionRegistry\n\t\t);\n\t\tresult.append( \"extract(\" ).append( field ).append( \" from \" ).append( source ).append( ')' );\n\t}"
        ],
        "invokedMethodSet": [
            "methodSignature: org.hibernate.sql.Template#extractUntil\n methodBody: private static String extractUntil(StringTokenizer tokens, String delimiter) {\nStringBuilder valueBuilder=new StringBuilder();\nString token=tokens.nextToken();\nwhile(!delimiter.equalsIgnoreCase(token)){valueBuilder.append(token);\ntoken=tokens.nextToken();\n}return valueBuilder.toString().trim();\n}",
            "methodSignature: org.hibernate.sql.Template#renderWhereStringTemplate\n methodBody: public static String renderWhereStringTemplate(\n\t\t\tString sqlWhereString,\n\t\t\tString placeholder,\n\t\t\tDialect dialect,\n\t\t\tTypeConfiguration typeConfiguration,\n\t\t\tSqmFunctionRegistry functionRegistry) {\nString symbols=PUNCTUATION + WHITESPACE + dialect.openQuote() + dialect.closeQuote();\nStringTokenizer tokens=new StringTokenizer(sqlWhereString,symbols,true);\nStringBuilder result=new StringBuilder();\nboolean quoted=false;\nboolean quotedIdentifier=false;\nboolean beforeTable=false;\nboolean inFromClause=false;\nboolean afterFromTable=false;\nboolean hasMore=tokens.hasMoreTokens();\nString nextToken=hasMore ? tokens.nextToken() : null;\nwhile(hasMore){String token=nextToken;\nString lcToken=token.toLowerCase(Locale.ROOT);\nhasMore=tokens.hasMoreTokens();\nnextToken=hasMore ? tokens.nextToken() : null;\nboolean isQuoteCharacter=false;\nif(!quotedIdentifier && \"'\".equals(token)){quoted=!quoted;\nisQuoteCharacter=true;\n}if(!quoted){boolean isOpenQuote;\nif(\"`\".equals(token)){isOpenQuote=!quotedIdentifier;\ntoken=lcToken=isOpenQuote ? Character.toString(dialect.openQuote()) : Character.toString(dialect.closeQuote());\nquotedIdentifier=isOpenQuote;\nisQuoteCharacter=true;\n}if(!quotedIdentifier && (dialect.openQuote() == token.charAt(0))){isOpenQuote=true;\nquotedIdentifier=true;\nisQuoteCharacter=true;\n}if(quotedIdentifier && (dialect.closeQuote() == token.charAt(0))){quotedIdentifier=false;\nisQuoteCharacter=true;\nisOpenQuote=false;\n}if(LITERAL_PREFIXES.contains(lcToken)){if(\"'\".equals(nextToken)){result.append(token);\ncontinue;\n}if(nextToken != null && Character.isWhitespace(nextToken.charAt(0))){final StringBuilder additionalTokens=new StringBuilder();\nTimeZoneTokens possibleNextToken=null;\ndo(nextToken != null && possibleNextToken.isToken(nextToken)){possibleNextToken=possibleNextToken == null ? TimeZoneTokens.getPossibleNextTokens(lcToken) : possibleNextToken.nextToken();\ndo(nextToken != null && Character.isWhitespace(nextToken.charAt(0))){additionalTokens.append(nextToken);\nhasMore=tokens.hasMoreTokens();\nnextToken=tokens.nextToken();\n}}if(\"'\".equals(nextToken)){result.append(token);\nresult.append(additionalTokens);\ncontinue;\n}{isOpenQuote=false;\n}}{isOpenQuote=false;\n}}{isOpenQuote=false;\n}if(isOpenQuote){result.append(placeholder).append('.');\n}}if(\"extract\".equals(lcToken) && \"(\".equals(nextToken)){final String field=extractUntil(tokens,\"from\");\nfinal String source=renderWhereStringTemplate(extractUntil(tokens,\")\"),placeholder,dialect,typeConfiguration,functionRegistry);\nresult.append(\"extract(\").append(field).append(\" from \").append(source).append(')');\nhasMore=tokens.hasMoreTokens();\nnextToken=hasMore ? tokens.nextToken() : null;\ncontinue;\n}if(\"trim\".equals(lcToken) && \"(\".equals(nextToken)){List<String> operands=new ArrayList<>();\nStringBuilder builder=new StringBuilder();\nboolean hasMoreOperands=true;\nString operandToken=tokens.nextToken();\nswitch(operandToken.toLowerCase(Locale.ROOT))case \"leading\":case \"trailing\":case \"both\":operands.add(operandToken);\nif(hasMoreOperands=tokens.hasMoreTokens()){operandToken=tokens.nextToken();\n}break;\nboolean quotedOperand=false;\nint parenthesis=0;\nwhile(hasMoreOperands){final boolean isQuote=\"'\".equals(operandToken);\nif(isQuote){quotedOperand=!quotedOperand;\nif(!quotedOperand){operands.add(builder.append('\\'').toString());\nbuilder.setLength(0);\n}{builder.append('\\'');\n}}if(quotedOperand){builder.append(operandToken);\n}if(parenthesis != 0){builder.append(operandToken);\nswitch(operandToken)case \"(\":parenthesis++;\nbreak;\ncase \")\":parenthesis--;\nbreak;\n}{builder.append(operandToken);\nswitch(operandToken.toLowerCase(Locale.ROOT))case \"(\":parenthesis++;\nbreak;\ncase \")\":parenthesis--;\nbreak;\ncase \"from\":if(builder.length() != 0){operands.add(builder.substring(0,builder.length() - 4));\nbuilder.setLength(0);\noperands.add(operandToken);\n}break;\n}operandToken=tokens.nextToken();\nhasMoreOperands=tokens.hasMoreTokens() && (parenthesis != 0 || !\")\".equals(operandToken));\n}if(builder.length() != 0){operands.add(builder.toString());\n}TrimOperands trimOperands=new TrimOperands(operands);\nresult.append(\"trim(\");\nif(trimOperands.trimSpec != null){result.append(trimOperands.trimSpec).append(' ');\n}if(trimOperands.trimChar != null){if(trimOperands.trimChar.startsWith(\"'\") && trimOperands.trimChar.endsWith(\"'\")){result.append(trimOperands.trimChar);\n}{result.append(renderWhereStringTemplate(trimOperands.trimSpec,placeholder,dialect,typeConfiguration,functionRegistry));\n}result.append(' ');\n}if(trimOperands.from != null){result.append(trimOperands.from).append(' ');\n}if(trimOperands.trimSpec != null || trimOperands.trimChar != null){result.append(\"from \");\n}result.append(renderWhereStringTemplate(trimOperands.trimSource,placeholder,dialect,typeConfiguration,functionRegistry)).append(')');\nhasMore=tokens.hasMoreTokens();\nnextToken=hasMore ? tokens.nextToken() : null;\ncontinue;\n}boolean quotedOrWhitespace=quoted || quotedIdentifier || isQuoteCharacter || Character.isWhitespace(token.charAt(0));\nif(quotedOrWhitespace){result.append(token);\n}if(beforeTable){result.append(token);\nbeforeTable=false;\nafterFromTable=true;\n}if(afterFromTable){if(!\"as\".equals(lcToken)){afterFromTable=false;\n}result.append(token);\n}if(isNamedParameter(token)){result.append(token);\n}if(isIdentifier(token) && !isFunctionOrKeyword(lcToken,nextToken,dialect,typeConfiguration,functionRegistry)){result.append(placeholder).append('.').append(dialect.quote(token));\n}{if(BEFORE_TABLE_KEYWORDS.contains(lcToken)){beforeTable=true;\ninFromClause=true;\n}if(inFromClause && \",\".equals(lcToken)){beforeTable=true;\n}if(isBoolean(token)){token=dialect.toBooleanValueString(Boolean.parseBoolean(token));\n}result.append(token);\n}if(inFromClause && KEYWORDS.contains(lcToken) && !BEFORE_TABLE_KEYWORDS.contains(lcToken)){inFromClause=false;\n}}return result.toString();\n}",
            "methodSignature: org.hibernate.sql.Template.TimeZoneTokens#isToken\n methodBody: public boolean isToken(String token) {\nreturn this != NONE && name().equalsIgnoreCase(token);\n}",
            "methodSignature: org.hibernate.sql.Template#isBoolean\n methodBody: private static boolean isBoolean(String token) {\nreturn \"true\".equals(token) || \"false\".equals(token);\n}",
            "methodSignature: org.hibernate.sql.Template.TimeZoneTokens#nextToken\n methodBody: public TimeZoneTokens nextToken() {\nif(this == WITH){return TIME;\n}if(this == TIME){return ZONE;\n}{return NONE;\n}}",
            "methodSignature: org.hibernate.sql.Template.TimeZoneTokens#getPossibleNextTokens\n methodBody: static TimeZoneTokens getPossibleNextTokens(String lctoken) {\nswitch(lctoken)case \"time\":case \"timestamp\":return WITH;\ndefault:return NONE;\n}",
            "methodSignature: org.hibernate.sql.Template#isIdentifier\n methodBody: private static boolean isIdentifier(String token) {\nif(isBoolean(token)){return false;\n}return token.charAt(0) == '`' || (Character.isLetter(token.charAt(0)) && token.indexOf('.') < 0);\n}",
            "methodSignature: org.hibernate.sql.Template#isNamedParameter\n methodBody: private static boolean isNamedParameter(String token) {\nreturn token.startsWith(\":\");\n}",
            "methodSignature: org.hibernate.sql.Template#isFunctionOrKeyword\n methodBody: private static boolean isFunctionOrKeyword(\n\t\t\tString lcToken,\n\t\t\tString nextToken,\n\t\t\tDialect dialect,\n\t\t\tTypeConfiguration typeConfiguration,\n\t\t\tSqmFunctionRegistry functionRegistry) {\nreturn \"(\".equals(nextToken) || KEYWORDS.contains(lcToken) || isType(lcToken,typeConfiguration) || isFunction(lcToken,nextToken,functionRegistry) || dialect.getKeywords().contains(lcToken) || FUNCTION_KEYWORDS.contains(lcToken);\n}"
        ],
        "sourceCodeAfterRefactoring": "/**\n\t * Takes the where condition provided in the mapping attribute and interpolates the alias.\n\t * Handles sub-selects, quoted identifiers, quoted strings, expressions, SQL functions,\n\t * named parameters.\n\t *\n\t * @param sqlWhereString The string into which to interpolate the placeholder value\n\t * @param placeholder The value to be interpolated into the sqlWhereString\n\t * @param dialect The dialect to apply\n\t * @param functionRegistry The registry of all sql functions\n\t * @return The rendered sql fragment\n\t */\n\tpublic static String renderWhereStringTemplate(\n\t\t\tString sqlWhereString,\n\t\t\tString placeholder,\n\t\t\tDialect dialect,\n\t\t\tTypeConfiguration typeConfiguration,\n\t\t\tSqmFunctionRegistry functionRegistry) {\n\n\t\t// IMPL NOTE : The basic process here is to tokenize the incoming string and to iterate over each token\n\t\t//\t\tin turn.  As we process each token, we set a series of flags used to indicate the type of context in\n\t\t// \t\twhich the tokens occur.  Depending on the state of those flags we decide whether we need to qualify\n\t\t//\t\tidentifier references.\n\n\t\tfinal String symbols = PUNCTUATION + WHITESPACE + dialect.openQuote() + dialect.closeQuote();\n\t\tfinal StringTokenizer tokens = new StringTokenizer( sqlWhereString, symbols, true );\n\t\tfinal StringBuilder result = new StringBuilder();\n\n\t\tboolean quoted = false;\n\t\tboolean quotedIdentifier = false;\n\t\tboolean beforeTable = false;\n\t\tboolean inFromClause = false;\n\t\tboolean afterFromTable = false;\n\n\t\tboolean hasMore = tokens.hasMoreTokens();\n\t\tString nextToken = hasMore ? tokens.nextToken() : null;\n\t\twhile ( hasMore ) {\n\t\t\tString token = nextToken;\n\t\t\tString lcToken = token.toLowerCase(Locale.ROOT);\n\t\t\thasMore = tokens.hasMoreTokens();\n\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n\n\t\t\tboolean isQuoteCharacter = false;\n\n\t\t\tif ( !quotedIdentifier && \"'\".equals(token) ) {\n\t\t\t\tquoted = !quoted;\n\t\t\t\tisQuoteCharacter = true;\n\t\t\t}\n\n\t\t\tif ( !quoted ) {\n\t\t\t\tfinal boolean isOpenQuote;\n\t\t\t\tif ( \"`\".equals(token) ) {\n\t\t\t\t\tisOpenQuote = !quotedIdentifier;\n\t\t\t\t\ttoken = lcToken = isOpenQuote\n\t\t\t\t\t\t\t? Character.toString( dialect.openQuote() )\n\t\t\t\t\t\t\t: Character.toString( dialect.closeQuote() );\n\t\t\t\t\tquotedIdentifier = isOpenQuote;\n\t\t\t\t\tisQuoteCharacter = true;\n\t\t\t\t}\n\t\t\t\telse if ( !quotedIdentifier && dialect.openQuote()==token.charAt(0) ) {\n\t\t\t\t\tisOpenQuote = true;\n\t\t\t\t\tquotedIdentifier = true;\n\t\t\t\t\tisQuoteCharacter = true;\n\t\t\t\t}\n\t\t\t\telse if ( quotedIdentifier && dialect.closeQuote()==token.charAt(0) ) {\n\t\t\t\t\tquotedIdentifier = false;\n\t\t\t\t\tisQuoteCharacter = true;\n\t\t\t\t\tisOpenQuote = false;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tisOpenQuote = false;\n\t\t\t\t}\n\t\t\t\tif ( isOpenQuote ) {\n\t\t\t\t\tresult.append( placeholder ).append( '.' );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfinal boolean quotedOrWhitespace =\n\t\t\t\t\tquoted || quotedIdentifier || isQuoteCharacter\n\t\t\t\t\t\t\t|| token.isBlank();\n\t\t\tif ( quotedOrWhitespace ) {\n\t\t\t\tresult.append( token );\n\t\t\t}\n\t\t\telse if ( beforeTable ) {\n\t\t\t\tresult.append( token );\n\t\t\t\tbeforeTable = false;\n\t\t\t\tafterFromTable = true;\n\t\t\t}\n\t\t\telse if ( afterFromTable ) {\n\t\t\t\tif ( !\"as\".equals(lcToken) ) {\n\t\t\t\t\tafterFromTable = false;\n\t\t\t\t}\n\t\t\t\tresult.append(token);\n\t\t\t}\n\t\t\telse if ( isNamedParameter(token) ) {\n\t\t\t\tresult.append(token);\n\t\t\t}\n\t\t\telse if ( isExtractFunction( lcToken, nextToken ) ) {\n\t\t\t\t// Special processing for ANSI SQL EXTRACT function\n\t\t\t\thandleExtractFunction( placeholder, dialect, typeConfiguration, functionRegistry, tokens, result );\n\t\t\t\thasMore = tokens.hasMoreTokens();\n\t\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n\t\t\t}\n\t\t\telse if ( isTrimFunction( lcToken, nextToken ) ) {\n\t\t\t\t// Special processing for ANSI SQL TRIM function\n\t\t\t\thandleTrimFunction( placeholder, dialect, typeConfiguration, functionRegistry, tokens, result );\n\t\t\t\thasMore = tokens.hasMoreTokens();\n\t\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n\t\t\t}\n\t\t\telse if ( isIdentifier(token)\n\t\t\t\t\t&& !isFunctionOrKeyword( lcToken, nextToken, dialect, typeConfiguration, functionRegistry )\n\t\t\t\t\t&& !isLiteral( lcToken, nextToken, sqlWhereString, symbols, tokens ) ) {\n\t\t\t\tresult.append(placeholder)\n\t\t\t\t\t\t.append('.')\n\t\t\t\t\t\t.append( dialect.quote(token) );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif ( BEFORE_TABLE_KEYWORDS.contains(lcToken) ) {\n\t\t\t\t\tbeforeTable = true;\n\t\t\t\t\tinFromClause = true;\n\t\t\t\t}\n\t\t\t\telse if ( inFromClause && \",\".equals(lcToken) ) {\n\t\t\t\t\tbeforeTable = true;\n\t\t\t\t}\n\t\t\t\tif ( isBoolean( token ) ) {\n\t\t\t\t\ttoken = dialect.toBooleanValueString( parseBoolean( token ) );\n\t\t\t\t}\n\t\t\t\tresult.append(token);\n\t\t\t}\n\n\t\t\t//Yuck:\n\t\t\tif ( inFromClause\n\t\t\t\t\t&& KEYWORDS.contains( lcToken ) //\"as\" is not in KEYWORDS\n\t\t\t\t\t&& !BEFORE_TABLE_KEYWORDS.contains( lcToken ) ) {\n\t\t\t\tinFromClause = false;\n\t\t\t}\n\t\t}\n\n\t\treturn result.toString();\n\t}\nprivate static void handleExtractFunction(\n\t\t\tString placeholder,\n\t\t\tDialect dialect,\n\t\t\tTypeConfiguration typeConfiguration,\n\t\t\tSqmFunctionRegistry functionRegistry,\n\t\t\tStringTokenizer tokens,\n\t\t\tStringBuilder result) {\n\t\tfinal String field = extractUntil( tokens, \"from\" );\n\t\tfinal String source = renderWhereStringTemplate(\n\t\t\t\textractUntil( tokens, \")\" ),\n\t\t\t\tplaceholder,\n\t\t\t\tdialect,\n\t\t\t\ttypeConfiguration,\n\t\t\t\tfunctionRegistry\n\t\t);\n\t\tresult.append( \"extract(\" ).append( field ).append( \" from \" ).append( source ).append( ')' );\n\t}",
        "diffSourceCode": "-  119: \t/**\n-  120: \t * Takes the where condition provided in the mapping attribute and interpolates the alias.\n-  121: \t * Handles sub-selects, quoted identifiers, quoted strings, expressions, SQL functions,\n-  122: \t * named parameters.\n-  123: \t *\n-  124: \t * @param sqlWhereString The string into which to interpolate the placeholder value\n-  125: \t * @param placeholder The value to be interpolated into the sqlWhereString\n-  126: \t * @param dialect The dialect to apply\n-  127: \t * @param functionRegistry The registry of all sql functions\n-  128: \t * @return The rendered sql fragment\n-  129: \t */\n-  130: \tpublic static String renderWhereStringTemplate(\n-  131: \t\t\tString sqlWhereString,\n-  132: \t\t\tString placeholder,\n-  133: \t\t\tDialect dialect,\n-  134: \t\t\tTypeConfiguration typeConfiguration,\n-  135: \t\t\tSqmFunctionRegistry functionRegistry) {\n-  136: \n-  137: \t\t// IMPL NOTE : The basic process here is to tokenize the incoming string and to iterate over each token\n-  138: \t\t//\t\tin turn.  As we process each token, we set a series of flags used to indicate the type of context in\n-  139: \t\t// \t\twhich the tokens occur.  Depending on the state of those flags we decide whether we need to qualify\n-  140: \t\t//\t\tidentifier references.\n-  141: \n-  142: \t\tString symbols = PUNCTUATION +\n-  143: \t\t\t\tWHITESPACE +\n-  144: \t\t\t\tdialect.openQuote() +\n-  145: \t\t\t\tdialect.closeQuote();\n-  146: \t\tStringTokenizer tokens = new StringTokenizer( sqlWhereString, symbols, true );\n-  147: \t\tStringBuilder result = new StringBuilder();\n+  119: \t\treturn renderWhereStringTemplate( sqlWhereString, TEMPLATE, dialect, typeConfiguration, functionRegistry );\n+  120: \t}\n+  121: \n+  122: \t/**\n+  123: \t * Takes the where condition provided in the mapping attribute and interpolates the alias.\n+  124: \t * Handles sub-selects, quoted identifiers, quoted strings, expressions, SQL functions,\n+  125: \t * named parameters.\n+  126: \t *\n+  127: \t * @param sqlWhereString The string into which to interpolate the placeholder value\n+  128: \t * @param placeholder The value to be interpolated into the sqlWhereString\n+  129: \t * @param dialect The dialect to apply\n+  130: \t * @param functionRegistry The registry of all sql functions\n+  131: \t * @return The rendered sql fragment\n+  132: \t */\n+  133: \tpublic static String renderWhereStringTemplate(\n+  134: \t\t\tString sqlWhereString,\n+  135: \t\t\tString placeholder,\n+  136: \t\t\tDialect dialect,\n+  137: \t\t\tTypeConfiguration typeConfiguration,\n+  138: \t\t\tSqmFunctionRegistry functionRegistry) {\n+  139: \n+  140: \t\t// IMPL NOTE : The basic process here is to tokenize the incoming string and to iterate over each token\n+  141: \t\t//\t\tin turn.  As we process each token, we set a series of flags used to indicate the type of context in\n+  142: \t\t// \t\twhich the tokens occur.  Depending on the state of those flags we decide whether we need to qualify\n+  143: \t\t//\t\tidentifier references.\n+  144: \n+  145: \t\tfinal String symbols = PUNCTUATION + WHITESPACE + dialect.openQuote() + dialect.closeQuote();\n+  146: \t\tfinal StringTokenizer tokens = new StringTokenizer( sqlWhereString, symbols, true );\n+  147: \t\tfinal StringBuilder result = new StringBuilder();\n   148: \n   149: \t\tboolean quoted = false;\n   150: \t\tboolean quotedIdentifier = false;\n   151: \t\tboolean beforeTable = false;\n   152: \t\tboolean inFromClause = false;\n   153: \t\tboolean afterFromTable = false;\n   154: \n   155: \t\tboolean hasMore = tokens.hasMoreTokens();\n   156: \t\tString nextToken = hasMore ? tokens.nextToken() : null;\n   157: \t\twhile ( hasMore ) {\n   158: \t\t\tString token = nextToken;\n   159: \t\t\tString lcToken = token.toLowerCase(Locale.ROOT);\n   160: \t\t\thasMore = tokens.hasMoreTokens();\n   161: \t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n   162: \n   163: \t\t\tboolean isQuoteCharacter = false;\n   164: \n   165: \t\t\tif ( !quotedIdentifier && \"'\".equals(token) ) {\n   166: \t\t\t\tquoted = !quoted;\n   167: \t\t\t\tisQuoteCharacter = true;\n   168: \t\t\t}\n   169: \n   170: \t\t\tif ( !quoted ) {\n-  171: \t\t\t\tboolean isOpenQuote;\n+  171: \t\t\t\tfinal boolean isOpenQuote;\n   172: \t\t\t\tif ( \"`\".equals(token) ) {\n   173: \t\t\t\t\tisOpenQuote = !quotedIdentifier;\n   174: \t\t\t\t\ttoken = lcToken = isOpenQuote\n   175: \t\t\t\t\t\t\t? Character.toString( dialect.openQuote() )\n   176: \t\t\t\t\t\t\t: Character.toString( dialect.closeQuote() );\n   177: \t\t\t\t\tquotedIdentifier = isOpenQuote;\n   178: \t\t\t\t\tisQuoteCharacter = true;\n   179: \t\t\t\t}\n-  180: \t\t\t\telse if ( !quotedIdentifier && ( dialect.openQuote()==token.charAt(0) ) ) {\n+  180: \t\t\t\telse if ( !quotedIdentifier && dialect.openQuote()==token.charAt(0) ) {\n   181: \t\t\t\t\tisOpenQuote = true;\n   182: \t\t\t\t\tquotedIdentifier = true;\n   183: \t\t\t\t\tisQuoteCharacter = true;\n   184: \t\t\t\t}\n-  185: \t\t\t\telse if ( quotedIdentifier && ( dialect.closeQuote()==token.charAt(0) ) ) {\n+  185: \t\t\t\telse if ( quotedIdentifier && dialect.closeQuote()==token.charAt(0) ) {\n   186: \t\t\t\t\tquotedIdentifier = false;\n   187: \t\t\t\t\tisQuoteCharacter = true;\n   188: \t\t\t\t\tisOpenQuote = false;\n   189: \t\t\t\t}\n-  190: \t\t\t\telse if ( LITERAL_PREFIXES.contains( lcToken ) ) {\n-  191: \t\t\t\t\tif ( \"'\".equals( nextToken ) ) {\n-  192: \t\t\t\t\t\t// Don't prefix a literal\n-  193: \t\t\t\t\t\tresult.append( token );\n-  194: \t\t\t\t\t\tcontinue;\n-  195: \t\t\t\t\t}\n-  196: \t\t\t\t\telse if ( nextToken != null && Character.isWhitespace( nextToken.charAt( 0 ) ) ) {\n-  197: \t\t\t\t\t\tfinal StringBuilder additionalTokens = new StringBuilder();\n-  198: \t\t\t\t\t\tTimeZoneTokens possibleNextToken = null;\n-  199: \t\t\t\t\t\tdo {\n-  200: \t\t\t\t\t\t\tpossibleNextToken = possibleNextToken == null\n-  201: \t\t\t\t\t\t\t\t\t? TimeZoneTokens.getPossibleNextTokens( lcToken )\n-  202: \t\t\t\t\t\t\t\t\t: possibleNextToken.nextToken();\n-  203: \t\t\t\t\t\t\tdo {\n-  204: \t\t\t\t\t\t\t\tadditionalTokens.append( nextToken );\n-  205: \t\t\t\t\t\t\t\thasMore = tokens.hasMoreTokens();\n-  206: \t\t\t\t\t\t\t\tnextToken = tokens.nextToken();\n-  207: \t\t\t\t\t\t\t} while ( nextToken != null && Character.isWhitespace( nextToken.charAt( 0 ) ) );\n-  208: \t\t\t\t\t\t} while ( nextToken != null && possibleNextToken.isToken( nextToken ) );\n-  209: \t\t\t\t\t\tif ( \"'\".equals( nextToken ) ) {\n-  210: \t\t\t\t\t\t\t// Don't prefix a literal\n-  211: \t\t\t\t\t\t\tresult.append( token );\n-  212: \t\t\t\t\t\t\tresult.append( additionalTokens );\n-  213: \t\t\t\t\t\t\tcontinue;\n-  214: \t\t\t\t\t\t}\n-  215: \t\t\t\t\t\telse {\n-  216: \t\t\t\t\t\t\tisOpenQuote = false;\n-  217: \t\t\t\t\t\t}\n-  218: \t\t\t\t\t}\n-  219: \t\t\t\t\telse {\n-  220: \t\t\t\t\t\tisOpenQuote = false;\n-  221: \t\t\t\t\t}\n-  222: \t\t\t\t}\n-  223: \t\t\t\telse {\n-  224: \t\t\t\t\tisOpenQuote = false;\n-  225: \t\t\t\t}\n-  226: \n-  227: \t\t\t\tif ( isOpenQuote ) {\n-  228: \t\t\t\t\tresult.append( placeholder ).append( '.' );\n-  229: \t\t\t\t}\n-  230: \t\t\t}\n-  231: \n-  232: \t\t\t// Special processing for ANSI SQL EXTRACT function\n-  233: \t\t\tif ( \"extract\".equals( lcToken ) && \"(\".equals( nextToken ) ) {\n-  234: \t\t\t\tfinal String field = extractUntil( tokens, \"from\" );\n-  235: \t\t\t\tfinal String source = renderWhereStringTemplate(\n-  236: \t\t\t\t\t\textractUntil( tokens, \")\" ),\n-  237: \t\t\t\t\t\tplaceholder,\n-  238: \t\t\t\t\t\tdialect,\n-  239: \t\t\t\t\t\ttypeConfiguration,\n-  240: \t\t\t\t\t\tfunctionRegistry\n-  241: \t\t\t\t);\n-  242: \t\t\t\tresult.append( \"extract(\" ).append( field ).append( \" from \" ).append( source ).append( ')' );\n-  243: \n-  244: \t\t\t\thasMore = tokens.hasMoreTokens();\n-  245: \t\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n-  246: \n-  247: \t\t\t\tcontinue;\n-  248: \t\t\t}\n-  249: \n-  250: \t\t\t// Special processing for ANSI SQL TRIM function\n-  251: \t\t\tif ( \"trim\".equals( lcToken ) && \"(\".equals( nextToken ) ) {\n-  252: \t\t\t\tList<String> operands = new ArrayList<>();\n-  253: \t\t\t\tStringBuilder builder = new StringBuilder();\n-  254: \n-  255: \t\t\t\tboolean hasMoreOperands = true;\n-  256: \t\t\t\tString operandToken = tokens.nextToken();\n-  257: \t\t\t\tswitch ( operandToken.toLowerCase( Locale.ROOT ) ) {\n-  258: \t\t\t\t\tcase \"leading\":\n-  259: \t\t\t\t\tcase \"trailing\":\n-  260: \t\t\t\t\tcase \"both\":\n-  261: \t\t\t\t\t\toperands.add( operandToken );\n-  262: \t\t\t\t\t\tif ( hasMoreOperands = tokens.hasMoreTokens() ) {\n-  263: \t\t\t\t\t\t\toperandToken = tokens.nextToken();\n-  264: \t\t\t\t\t\t}\n-  265: \t\t\t\t\t\tbreak;\n-  266: \t\t\t\t}\n-  267: \t\t\t\tboolean quotedOperand = false;\n-  268: \t\t\t\tint parenthesis = 0;\n-  269: \t\t\t\twhile ( hasMoreOperands ) {\n-  270: \t\t\t\t\tfinal boolean isQuote = \"'\".equals( operandToken );\n-  271: \t\t\t\t\tif ( isQuote ) {\n-  272: \t\t\t\t\t\tquotedOperand = !quotedOperand;\n-  273: \t\t\t\t\t\tif ( !quotedOperand ) {\n-  274: \t\t\t\t\t\t\toperands.add( builder.append( '\\'' ).toString() );\n-  275: \t\t\t\t\t\t\tbuilder.setLength( 0 );\n-  276: \t\t\t\t\t\t}\n-  277: \t\t\t\t\t\telse {\n-  278: \t\t\t\t\t\t\tbuilder.append( '\\'' );\n-  279: \t\t\t\t\t\t}\n-  280: \t\t\t\t\t}\n-  281: \t\t\t\t\telse if ( quotedOperand ) {\n-  282: \t\t\t\t\t\tbuilder.append( operandToken );\n-  283: \t\t\t\t\t}\n-  284: \t\t\t\t\telse if ( parenthesis != 0 ) {\n-  285: \t\t\t\t\t\tbuilder.append( operandToken );\n-  286: \t\t\t\t\t\tswitch ( operandToken ) {\n-  287: \t\t\t\t\t\t\tcase \"(\":\n-  288: \t\t\t\t\t\t\t\tparenthesis++;\n-  289: \t\t\t\t\t\t\t\tbreak;\n-  290: \t\t\t\t\t\t\tcase \")\":\n-  291: \t\t\t\t\t\t\t\tparenthesis--;\n-  292: \t\t\t\t\t\t\t\tbreak;\n-  293: \t\t\t\t\t\t}\n-  294: \t\t\t\t\t}\n-  295: \t\t\t\t\telse {\n-  296: \t\t\t\t\t\tbuilder.append( operandToken );\n-  297: \t\t\t\t\t\tswitch ( operandToken.toLowerCase( Locale.ROOT ) ) {\n-  298: \t\t\t\t\t\t\tcase \"(\":\n-  299: \t\t\t\t\t\t\t\tparenthesis++;\n-  300: \t\t\t\t\t\t\t\tbreak;\n-  301: \t\t\t\t\t\t\tcase \")\":\n-  302: \t\t\t\t\t\t\t\tparenthesis--;\n-  303: \t\t\t\t\t\t\t\tbreak;\n-  304: \t\t\t\t\t\t\tcase \"from\":\n-  305: \t\t\t\t\t\t\t\tif ( builder.length() != 0 ) {\n-  306: \t\t\t\t\t\t\t\t\toperands.add( builder.substring( 0, builder.length() - 4 ) );\n-  307: \t\t\t\t\t\t\t\t\tbuilder.setLength( 0 );\n-  308: \t\t\t\t\t\t\t\t\toperands.add( operandToken );\n-  309: \t\t\t\t\t\t\t\t}\n-  310: \t\t\t\t\t\t\t\tbreak;\n-  311: \t\t\t\t\t\t}\n-  312: \t\t\t\t\t}\n-  313: \t\t\t\t\toperandToken = tokens.nextToken();\n-  314: \t\t\t\t\thasMoreOperands = tokens.hasMoreTokens() && ( parenthesis != 0 || ! \")\".equals( operandToken ) );\n-  315: \t\t\t\t}\n-  316: \t\t\t\tif ( builder.length() != 0 ) {\n-  317: \t\t\t\t\toperands.add( builder.toString() );\n-  318: \t\t\t\t}\n-  319: \n-  320: \t\t\t\tTrimOperands trimOperands = new TrimOperands( operands );\n-  321: \t\t\t\tresult.append( \"trim(\" );\n-  322: \t\t\t\tif ( trimOperands.trimSpec != null ) {\n-  323: \t\t\t\t\tresult.append( trimOperands.trimSpec ).append( ' ' );\n-  324: \t\t\t\t}\n-  325: \t\t\t\tif ( trimOperands.trimChar != null ) {\n-  326: \t\t\t\t\tif ( trimOperands.trimChar.startsWith( \"'\" ) && trimOperands.trimChar.endsWith( \"'\" ) ) {\n-  327: \t\t\t\t\t\tresult.append( trimOperands.trimChar );\n-  328: \t\t\t\t\t}\n-  329: \t\t\t\t\telse {\n-  330: \t\t\t\t\t\tresult.append(\n-  331: \t\t\t\t\t\t\t\trenderWhereStringTemplate( trimOperands.trimSpec, placeholder, dialect, typeConfiguration, functionRegistry )\n-  332: \t\t\t\t\t\t);\n-  333: \t\t\t\t\t}\n-  334: \t\t\t\t\tresult.append( ' ' );\n-  335: \t\t\t\t}\n-  336: \t\t\t\tif ( trimOperands.from != null ) {\n-  337: \t\t\t\t\tresult.append( trimOperands.from ).append( ' ' );\n-  338: \t\t\t\t}\n-  339: \t\t\t\telse if ( trimOperands.trimSpec != null || trimOperands.trimChar != null ) {\n-  340: \t\t\t\t\t// I think ANSI SQL says that the 'from' is not optional if either trim-spec or trim-char is specified\n-  341: \t\t\t\t\tresult.append( \"from \" );\n-  342: \t\t\t\t}\n-  343: \n-  344: \t\t\t\tresult.append( renderWhereStringTemplate( trimOperands.trimSource, placeholder, dialect, typeConfiguration, functionRegistry ) )\n-  345: \t\t\t\t\t\t.append( ')' );\n-  346: \n-  347: \t\t\t\thasMore = tokens.hasMoreTokens();\n-  348: \t\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n-  349: \n-  350: \t\t\t\tcontinue;\n-  351: \t\t\t}\n-  352: \n-  353: \t\t\tboolean quotedOrWhitespace = quoted || quotedIdentifier || isQuoteCharacter\n-  354: \t\t\t\t\t|| Character.isWhitespace( token.charAt(0) );\n-  355: \n-  356: \t\t\tif ( quotedOrWhitespace ) {\n-  357: \t\t\t\tresult.append( token );\n+  190: \t\t\t\telse {\n+  191: \t\t\t\t\tisOpenQuote = false;\n+  192: \t\t\t\t}\n+  193: \t\t\t\tif ( isOpenQuote ) {\n+  194: \t\t\t\t\tresult.append( placeholder ).append( '.' );\n+  195: \t\t\t\t}\n+  196: \t\t\t}\n+  197: \n+  198: \t\t\tfinal boolean quotedOrWhitespace =\n+  199: \t\t\t\t\tquoted || quotedIdentifier || isQuoteCharacter\n+  200: \t\t\t\t\t\t\t|| token.isBlank();\n+  201: \t\t\tif ( quotedOrWhitespace ) {\n+  202: \t\t\t\tresult.append( token );\n+  203: \t\t\t}\n+  204: \t\t\telse if ( beforeTable ) {\n+  205: \t\t\t\tresult.append( token );\n+  206: \t\t\t\tbeforeTable = false;\n+  207: \t\t\t\tafterFromTable = true;\n+  208: \t\t\t}\n+  209: \t\t\telse if ( afterFromTable ) {\n+  210: \t\t\t\tif ( !\"as\".equals(lcToken) ) {\n+  211: \t\t\t\t\tafterFromTable = false;\n+  212: \t\t\t\t}\n+  213: \t\t\t\tresult.append(token);\n+  214: \t\t\t}\n+  215: \t\t\telse if ( isNamedParameter(token) ) {\n+  216: \t\t\t\tresult.append(token);\n+  217: \t\t\t}\n+  218: \t\t\telse if ( isExtractFunction( lcToken, nextToken ) ) {\n+  219: \t\t\t\t// Special processing for ANSI SQL EXTRACT function\n+  220: \t\t\t\thandleExtractFunction( placeholder, dialect, typeConfiguration, functionRegistry, tokens, result );\n+  221: \t\t\t\thasMore = tokens.hasMoreTokens();\n+  222: \t\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n+  223: \t\t\t}\n+  224: \t\t\telse if ( isTrimFunction( lcToken, nextToken ) ) {\n+  225: \t\t\t\t// Special processing for ANSI SQL TRIM function\n+  226: \t\t\t\thandleTrimFunction( placeholder, dialect, typeConfiguration, functionRegistry, tokens, result );\n+  227: \t\t\t\thasMore = tokens.hasMoreTokens();\n+  228: \t\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n+  229: \t\t\t}\n+  230: \t\t\telse if ( isIdentifier(token)\n+  231: \t\t\t\t\t&& !isFunctionOrKeyword( lcToken, nextToken, dialect, typeConfiguration, functionRegistry )\n+  232: \t\t\t\t\t&& !isLiteral( lcToken, nextToken, sqlWhereString, symbols, tokens ) ) {\n+  233: \t\t\t\tresult.append(placeholder)\n+  234: \t\t\t\t\t\t.append('.')\n+  235: \t\t\t\t\t\t.append( dialect.quote(token) );\n+  236: \t\t\t}\n+  237: \t\t\telse {\n+  238: \t\t\t\tif ( BEFORE_TABLE_KEYWORDS.contains(lcToken) ) {\n+  239: \t\t\t\t\tbeforeTable = true;\n+  240: \t\t\t\t\tinFromClause = true;\n+  241: \t\t\t\t}\n+  242: \t\t\t\telse if ( inFromClause && \",\".equals(lcToken) ) {\n+  243: \t\t\t\t\tbeforeTable = true;\n+  244: \t\t\t\t}\n+  245: \t\t\t\tif ( isBoolean( token ) ) {\n+  246: \t\t\t\t\ttoken = dialect.toBooleanValueString( parseBoolean( token ) );\n+  247: \t\t\t\t}\n+  248: \t\t\t\tresult.append(token);\n+  249: \t\t\t}\n+  250: \n+  251: \t\t\t//Yuck:\n+  252: \t\t\tif ( inFromClause\n+  253: \t\t\t\t\t&& KEYWORDS.contains( lcToken ) //\"as\" is not in KEYWORDS\n+  254: \t\t\t\t\t&& !BEFORE_TABLE_KEYWORDS.contains( lcToken ) ) {\n+  255: \t\t\t\tinFromClause = false;\n+  256: \t\t\t}\n+  257: \t\t}\n+  258: \n+  259: \t\treturn result.toString();\n+  260: \t}\n+  261: \n+  262: \tprivate static boolean isTrimFunction(String lcToken, String nextToken) {\n+  263: \t\treturn \"trim\".equals(lcToken) && \"(\".equals(nextToken);\n+  264: \t}\n+  265: \n+  266: \tprivate static boolean isExtractFunction(String lcToken, String nextToken) {\n+  267: \t\treturn \"extract\".equals(lcToken) && \"(\".equals(nextToken);\n+  268: \t}\n+  269: \n+  270: \tprivate static boolean isLiteral(\n+  271: \t\t\tString lcToken, String next,\n+  272: \t\t\tString sqlWhereString, String symbols, StringTokenizer tokens) {\n+  273: \t\tif ( LITERAL_PREFIXES.contains( lcToken ) && next != null ) {\n+  274: \t\t\t// easy cases first\n+  275: \t\t\tif ( \"'\".equals(next) ) {\n+  276: \t\t\t\treturn true;\n+  277: \t\t\t}\n+  278: \t\t\telse if ( !next.isBlank() ) {\n+  279: \t\t\t\treturn false;\n+  280: \t\t\t}\n+  281: \t\t\telse {\n+  282: \t\t\t\t// we need to look ahead in the token stream\n+  283: \t\t\t\t// to find the first non-blank token\n+  284: \t\t\t\tfinal StringTokenizer lookahead =\n+  285: \t\t\t\t\t\tnew StringTokenizer( sqlWhereString, symbols, true );\n+  286: \t\t\t\twhile ( lookahead.countTokens() > tokens.countTokens()+1 ) {\n+  287: \t\t\t\t\tlookahead.nextToken();\n+  288: \t\t\t\t}\n+  289: \t\t\t\tif ( lookahead.hasMoreTokens() ) {\n+  290: \t\t\t\t\tString nextToken;\n+  291: \t\t\t\t\tdo {\n+  292: \t\t\t\t\t\tnextToken = lookahead.nextToken().toLowerCase(Locale.ROOT);\n+  293: \t\t\t\t\t}\n+  294: \t\t\t\t\twhile ( nextToken.isBlank() && lookahead.hasMoreTokens() );\n+  295: \t\t\t\t\treturn \"'\".equals( nextToken )\n+  296: \t\t\t\t\t\t|| lcToken.equals( \"time\" ) && \"with\".equals( nextToken )\n+  297: \t\t\t\t\t\t|| lcToken.equals( \"timestamp\" ) && \"with\".equals( nextToken )\n+  298: \t\t\t\t\t\t|| lcToken.equals( \"time\" ) && \"zone\".equals( nextToken );\n+  299: \t\t\t\t}\n+  300: \t\t\t\telse {\n+  301: \t\t\t\t\treturn false;\n+  302: \t\t\t\t}\n+  303: \t\t\t}\n+  304: \t\t}\n+  305: \t\telse {\n+  306: \t\t\treturn false;\n+  307: \t\t}\n+  308: \t}\n+  309: \n+  310: \tprivate static void handleTrimFunction(\n+  311: \t\t\tString placeholder, Dialect dialect,\n+  312: \t\t\tTypeConfiguration typeConfiguration,\n+  313: \t\t\tSqmFunctionRegistry functionRegistry,\n+  314: \t\t\tStringTokenizer tokens,\n+  315: \t\t\tStringBuilder result) {\n+  316: \t\tfinal List<String> operands = new ArrayList<>();\n+  317: \t\tfinal StringBuilder builder = new StringBuilder();\n+  318: \n+  319: \t\tboolean hasMoreOperands = true;\n+  320: \t\tString operandToken = tokens.nextToken();\n+  321: \t\tswitch ( operandToken.toLowerCase( Locale.ROOT ) ) {\n+  322: \t\t\tcase \"leading\":\n+  323: \t\t\tcase \"trailing\":\n+  324: \t\t\tcase \"both\":\n+  325: \t\t\t\toperands.add( operandToken );\n+  326: \t\t\t\tif ( hasMoreOperands = tokens.hasMoreTokens() ) {\n+  327: \t\t\t\t\toperandToken = tokens.nextToken();\n+  328: \t\t\t\t}\n+  329: \t\t\t\tbreak;\n+  330: \t\t}\n+  331: \t\tboolean quotedOperand = false;\n+  332: \t\tint parenthesis = 0;\n+  333: \t\twhile ( hasMoreOperands ) {\n+  334: \t\t\tfinal boolean isQuote = \"'\".equals( operandToken );\n+  335: \t\t\tif ( isQuote ) {\n+  336: \t\t\t\tquotedOperand = !quotedOperand;\n+  337: \t\t\t\tif ( !quotedOperand ) {\n+  338: \t\t\t\t\toperands.add( builder.append( '\\'' ).toString() );\n+  339: \t\t\t\t\tbuilder.setLength( 0 );\n+  340: \t\t\t\t}\n+  341: \t\t\t\telse {\n+  342: \t\t\t\t\tbuilder.append( '\\'' );\n+  343: \t\t\t\t}\n+  344: \t\t\t}\n+  345: \t\t\telse if ( quotedOperand ) {\n+  346: \t\t\t\tbuilder.append( operandToken );\n+  347: \t\t\t}\n+  348: \t\t\telse if ( parenthesis != 0 ) {\n+  349: \t\t\t\tbuilder.append( operandToken );\n+  350: \t\t\t\tswitch ( operandToken ) {\n+  351: \t\t\t\t\tcase \"(\":\n+  352: \t\t\t\t\t\tparenthesis++;\n+  353: \t\t\t\t\t\tbreak;\n+  354: \t\t\t\t\tcase \")\":\n+  355: \t\t\t\t\t\tparenthesis--;\n+  356: \t\t\t\t\t\tbreak;\n+  357: \t\t\t\t}\n   358: \t\t\t}\n-  359: \t\t\telse if ( beforeTable ) {\n-  360: \t\t\t\tresult.append( token );\n-  361: \t\t\t\tbeforeTable = false;\n-  362: \t\t\t\tafterFromTable = true;\n-  363: \t\t\t}\n-  364: \t\t\telse if ( afterFromTable ) {\n-  365: \t\t\t\tif ( !\"as\".equals(lcToken) ) {\n-  366: \t\t\t\t\tafterFromTable = false;\n-  367: \t\t\t\t}\n-  368: \t\t\t\tresult.append(token);\n-  369: \t\t\t}\n-  370: \t\t\telse if ( isNamedParameter(token) ) {\n-  371: \t\t\t\tresult.append(token);\n-  372: \t\t\t}\n-  373: \t\t\telse if ( isIdentifier(token)\n-  374: \t\t\t\t\t&& !isFunctionOrKeyword(lcToken, nextToken, dialect, typeConfiguration, functionRegistry) ) {\n-  375: \t\t\t\tresult.append(placeholder)\n-  376: \t\t\t\t\t\t.append('.')\n-  377: \t\t\t\t\t\t.append( dialect.quote(token) );\n-  378: \t\t\t}\n-  379: \t\t\telse {\n-  380: \t\t\t\tif ( BEFORE_TABLE_KEYWORDS.contains(lcToken) ) {\n-  381: \t\t\t\t\tbeforeTable = true;\n-  382: \t\t\t\t\tinFromClause = true;\n-  383: \t\t\t\t}\n-  384: \t\t\t\telse if ( inFromClause && \",\".equals(lcToken) ) {\n-  385: \t\t\t\t\tbeforeTable = true;\n-  386: \t\t\t\t}\n-  387: \t\t\t\tif ( isBoolean( token ) ) {\n-  388: \t\t\t\t\ttoken = dialect.toBooleanValueString( Boolean.parseBoolean( token ) );\n-  389: \t\t\t\t}\n-  390: \t\t\t\tresult.append(token);\n-  391: \t\t\t}\n-  392: \n-  393: \t\t\t//Yuck:\n-  394: \t\t\tif ( inFromClause\n-  395: \t\t\t\t\t&& KEYWORDS.contains( lcToken ) //\"as\" is not in KEYWORDS\n-  396: \t\t\t\t\t&& !BEFORE_TABLE_KEYWORDS.contains( lcToken ) ) {\n-  397: \t\t\t\tinFromClause = false;\n+  359: \t\t\telse {\n+  360: \t\t\t\tbuilder.append( operandToken );\n+  361: \t\t\t\tswitch ( operandToken.toLowerCase( Locale.ROOT ) ) {\n+  362: \t\t\t\t\tcase \"(\":\n+  363: \t\t\t\t\t\tparenthesis++;\n+  364: \t\t\t\t\t\tbreak;\n+  365: \t\t\t\t\tcase \")\":\n+  366: \t\t\t\t\t\tparenthesis--;\n+  367: \t\t\t\t\t\tbreak;\n+  368: \t\t\t\t\tcase \"from\":\n+  369: \t\t\t\t\t\tif ( !builder.isEmpty() ) {\n+  370: \t\t\t\t\t\t\toperands.add( builder.substring( 0, builder.length() - 4 ) );\n+  371: \t\t\t\t\t\t\tbuilder.setLength( 0 );\n+  372: \t\t\t\t\t\t\toperands.add( operandToken );\n+  373: \t\t\t\t\t\t}\n+  374: \t\t\t\t\t\tbreak;\n+  375: \t\t\t\t}\n+  376: \t\t\t}\n+  377: \t\t\toperandToken = tokens.nextToken();\n+  378: \t\t\thasMoreOperands = tokens.hasMoreTokens()\n+  379: \t\t\t\t\t&& ( parenthesis != 0 || ! \")\".equals( operandToken ) );\n+  380: \t\t}\n+  381: \t\tif ( !builder.isEmpty() ) {\n+  382: \t\t\toperands.add( builder.toString() );\n+  383: \t\t}\n+  384: \n+  385: \t\tfinal TrimOperands trimOperands = new TrimOperands( operands );\n+  386: \t\tresult.append( \"trim(\" );\n+  387: \t\tif ( trimOperands.trimSpec != null ) {\n+  388: \t\t\tresult.append( trimOperands.trimSpec ).append( ' ' );\n+  389: \t\t}\n+  390: \t\tif ( trimOperands.trimChar != null ) {\n+  391: \t\t\tif ( trimOperands.trimChar.startsWith( \"'\" ) && trimOperands.trimChar.endsWith( \"'\" ) ) {\n+  392: \t\t\t\tresult.append( trimOperands.trimChar );\n+  393: \t\t\t}\n+  394: \t\t\telse {\n+  395: \t\t\t\tresult.append(\n+  396: \t\t\t\t\t\trenderWhereStringTemplate( trimOperands.trimSpec, placeholder, dialect, typeConfiguration, functionRegistry )\n+  397: \t\t\t\t);\n   398: \t\t\t}\n-  399: \t\t}\n-  400: \n-  401: \t\treturn result.toString();\n-  402: \t}\n-  413: \t\t\t\tcase \"timestamp\":\n-  414: \t\t\t\t\treturn WITH;\n-  415: \t\t\t\tdefault:\n-  416: \t\t\t\t\treturn NONE;\n-  417: \t\t\t}\n-  418: \t\t}\n-  419: \n-  420: \t\tpublic TimeZoneTokens nextToken() {\n-  421: \t\t\tif ( this == WITH ) {\n-  422: \t\t\t\treturn TIME;\n-  423: \t\t\t}\n-  424: \t\t\telse if ( this == TIME ) {\n-  425: \t\t\t\treturn ZONE;\n-  426: \t\t\t}\n-  427: \t\t\telse {\n-  428: \t\t\t\treturn NONE;\n-  429: \t\t\t}\n+  399: \t\t\tresult.append( ' ' );\n+  400: \t\t}\n+  401: \t\tif ( trimOperands.from != null ) {\n+  402: \t\t\tresult.append( trimOperands.from ).append( ' ' );\n+  413: \tprivate static void handleExtractFunction(\n+  414: \t\t\tString placeholder,\n+  415: \t\t\tDialect dialect,\n+  416: \t\t\tTypeConfiguration typeConfiguration,\n+  417: \t\t\tSqmFunctionRegistry functionRegistry,\n+  418: \t\t\tStringTokenizer tokens,\n+  419: \t\t\tStringBuilder result) {\n+  420: \t\tfinal String field = extractUntil( tokens, \"from\" );\n+  421: \t\tfinal String source = renderWhereStringTemplate(\n+  422: \t\t\t\textractUntil( tokens, \")\" ),\n+  423: \t\t\t\tplaceholder,\n+  424: \t\t\t\tdialect,\n+  425: \t\t\t\ttypeConfiguration,\n+  426: \t\t\t\tfunctionRegistry\n+  427: \t\t);\n+  428: \t\tresult.append( \"extract(\" ).append( field ).append( \" from \" ).append( source ).append( ')' );\n+  429: \t}\n",
        "uniqueId": "35f96d6e901dbd071b375d809521ef6f1c979868_119_402_413_429_122_260",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 137,
                "covered": 506
            },
            "BRANCH": {
                "missed": 37,
                "covered": 108
            },
            "LINE": {
                "missed": 32,
                "covered": 133
            },
            "COMPLEXITY": {
                "missed": 31,
                "covered": 44
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 21
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprivate isExtractFunction(lcToken String, nextToken String) : boolean extracted from public renderWhereStringTemplate(sqlWhereString String, placeholder String, dialect Dialect, typeConfiguration TypeConfiguration, functionRegistry SqmFunctionRegistry) : String in class org.hibernate.sql.Template",
        "diffLocations": [
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/sql/Template.java",
                "startLine": 119,
                "endLine": 402,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/sql/Template.java",
                "startLine": 122,
                "endLine": 260,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/sql/Template.java",
                "startLine": 266,
                "endLine": 268,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "/**\n\t * Takes the where condition provided in the mapping attribute and interpolates the alias.\n\t * Handles sub-selects, quoted identifiers, quoted strings, expressions, SQL functions,\n\t * named parameters.\n\t *\n\t * @param sqlWhereString The string into which to interpolate the placeholder value\n\t * @param placeholder The value to be interpolated into the sqlWhereString\n\t * @param dialect The dialect to apply\n\t * @param functionRegistry The registry of all sql functions\n\t * @return The rendered sql fragment\n\t */\n\tpublic static String renderWhereStringTemplate(\n\t\t\tString sqlWhereString,\n\t\t\tString placeholder,\n\t\t\tDialect dialect,\n\t\t\tTypeConfiguration typeConfiguration,\n\t\t\tSqmFunctionRegistry functionRegistry) {\n\n\t\t// IMPL NOTE : The basic process here is to tokenize the incoming string and to iterate over each token\n\t\t//\t\tin turn.  As we process each token, we set a series of flags used to indicate the type of context in\n\t\t// \t\twhich the tokens occur.  Depending on the state of those flags we decide whether we need to qualify\n\t\t//\t\tidentifier references.\n\n\t\tString symbols = PUNCTUATION +\n\t\t\t\tWHITESPACE +\n\t\t\t\tdialect.openQuote() +\n\t\t\t\tdialect.closeQuote();\n\t\tStringTokenizer tokens = new StringTokenizer( sqlWhereString, symbols, true );\n\t\tStringBuilder result = new StringBuilder();\n\n\t\tboolean quoted = false;\n\t\tboolean quotedIdentifier = false;\n\t\tboolean beforeTable = false;\n\t\tboolean inFromClause = false;\n\t\tboolean afterFromTable = false;\n\n\t\tboolean hasMore = tokens.hasMoreTokens();\n\t\tString nextToken = hasMore ? tokens.nextToken() : null;\n\t\twhile ( hasMore ) {\n\t\t\tString token = nextToken;\n\t\t\tString lcToken = token.toLowerCase(Locale.ROOT);\n\t\t\thasMore = tokens.hasMoreTokens();\n\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n\n\t\t\tboolean isQuoteCharacter = false;\n\n\t\t\tif ( !quotedIdentifier && \"'\".equals(token) ) {\n\t\t\t\tquoted = !quoted;\n\t\t\t\tisQuoteCharacter = true;\n\t\t\t}\n\n\t\t\tif ( !quoted ) {\n\t\t\t\tboolean isOpenQuote;\n\t\t\t\tif ( \"`\".equals(token) ) {\n\t\t\t\t\tisOpenQuote = !quotedIdentifier;\n\t\t\t\t\ttoken = lcToken = isOpenQuote\n\t\t\t\t\t\t\t? Character.toString( dialect.openQuote() )\n\t\t\t\t\t\t\t: Character.toString( dialect.closeQuote() );\n\t\t\t\t\tquotedIdentifier = isOpenQuote;\n\t\t\t\t\tisQuoteCharacter = true;\n\t\t\t\t}\n\t\t\t\telse if ( !quotedIdentifier && ( dialect.openQuote()==token.charAt(0) ) ) {\n\t\t\t\t\tisOpenQuote = true;\n\t\t\t\t\tquotedIdentifier = true;\n\t\t\t\t\tisQuoteCharacter = true;\n\t\t\t\t}\n\t\t\t\telse if ( quotedIdentifier && ( dialect.closeQuote()==token.charAt(0) ) ) {\n\t\t\t\t\tquotedIdentifier = false;\n\t\t\t\t\tisQuoteCharacter = true;\n\t\t\t\t\tisOpenQuote = false;\n\t\t\t\t}\n\t\t\t\telse if ( LITERAL_PREFIXES.contains( lcToken ) ) {\n\t\t\t\t\tif ( \"'\".equals( nextToken ) ) {\n\t\t\t\t\t\t// Don't prefix a literal\n\t\t\t\t\t\tresult.append( token );\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\telse if ( nextToken != null && Character.isWhitespace( nextToken.charAt( 0 ) ) ) {\n\t\t\t\t\t\tfinal StringBuilder additionalTokens = new StringBuilder();\n\t\t\t\t\t\tTimeZoneTokens possibleNextToken = null;\n\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\tpossibleNextToken = possibleNextToken == null\n\t\t\t\t\t\t\t\t\t? TimeZoneTokens.getPossibleNextTokens( lcToken )\n\t\t\t\t\t\t\t\t\t: possibleNextToken.nextToken();\n\t\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\t\tadditionalTokens.append( nextToken );\n\t\t\t\t\t\t\t\thasMore = tokens.hasMoreTokens();\n\t\t\t\t\t\t\t\tnextToken = tokens.nextToken();\n\t\t\t\t\t\t\t} while ( nextToken != null && Character.isWhitespace( nextToken.charAt( 0 ) ) );\n\t\t\t\t\t\t} while ( nextToken != null && possibleNextToken.isToken( nextToken ) );\n\t\t\t\t\t\tif ( \"'\".equals( nextToken ) ) {\n\t\t\t\t\t\t\t// Don't prefix a literal\n\t\t\t\t\t\t\tresult.append( token );\n\t\t\t\t\t\t\tresult.append( additionalTokens );\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tisOpenQuote = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tisOpenQuote = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tisOpenQuote = false;\n\t\t\t\t}\n\n\t\t\t\tif ( isOpenQuote ) {\n\t\t\t\t\tresult.append( placeholder ).append( '.' );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Special processing for ANSI SQL EXTRACT function\n\t\t\tif ( \"extract\".equals( lcToken ) && \"(\".equals( nextToken ) ) {\n\t\t\t\tfinal String field = extractUntil( tokens, \"from\" );\n\t\t\t\tfinal String source = renderWhereStringTemplate(\n\t\t\t\t\t\textractUntil( tokens, \")\" ),\n\t\t\t\t\t\tplaceholder,\n\t\t\t\t\t\tdialect,\n\t\t\t\t\t\ttypeConfiguration,\n\t\t\t\t\t\tfunctionRegistry\n\t\t\t\t);\n\t\t\t\tresult.append( \"extract(\" ).append( field ).append( \" from \" ).append( source ).append( ')' );\n\n\t\t\t\thasMore = tokens.hasMoreTokens();\n\t\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Special processing for ANSI SQL TRIM function\n\t\t\tif ( \"trim\".equals( lcToken ) && \"(\".equals( nextToken ) ) {\n\t\t\t\tList<String> operands = new ArrayList<>();\n\t\t\t\tStringBuilder builder = new StringBuilder();\n\n\t\t\t\tboolean hasMoreOperands = true;\n\t\t\t\tString operandToken = tokens.nextToken();\n\t\t\t\tswitch ( operandToken.toLowerCase( Locale.ROOT ) ) {\n\t\t\t\t\tcase \"leading\":\n\t\t\t\t\tcase \"trailing\":\n\t\t\t\t\tcase \"both\":\n\t\t\t\t\t\toperands.add( operandToken );\n\t\t\t\t\t\tif ( hasMoreOperands = tokens.hasMoreTokens() ) {\n\t\t\t\t\t\t\toperandToken = tokens.nextToken();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tboolean quotedOperand = false;\n\t\t\t\tint parenthesis = 0;\n\t\t\t\twhile ( hasMoreOperands ) {\n\t\t\t\t\tfinal boolean isQuote = \"'\".equals( operandToken );\n\t\t\t\t\tif ( isQuote ) {\n\t\t\t\t\t\tquotedOperand = !quotedOperand;\n\t\t\t\t\t\tif ( !quotedOperand ) {\n\t\t\t\t\t\t\toperands.add( builder.append( '\\'' ).toString() );\n\t\t\t\t\t\t\tbuilder.setLength( 0 );\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tbuilder.append( '\\'' );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if ( quotedOperand ) {\n\t\t\t\t\t\tbuilder.append( operandToken );\n\t\t\t\t\t}\n\t\t\t\t\telse if ( parenthesis != 0 ) {\n\t\t\t\t\t\tbuilder.append( operandToken );\n\t\t\t\t\t\tswitch ( operandToken ) {\n\t\t\t\t\t\t\tcase \"(\":\n\t\t\t\t\t\t\t\tparenthesis++;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase \")\":\n\t\t\t\t\t\t\t\tparenthesis--;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tbuilder.append( operandToken );\n\t\t\t\t\t\tswitch ( operandToken.toLowerCase( Locale.ROOT ) ) {\n\t\t\t\t\t\t\tcase \"(\":\n\t\t\t\t\t\t\t\tparenthesis++;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase \")\":\n\t\t\t\t\t\t\t\tparenthesis--;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase \"from\":\n\t\t\t\t\t\t\t\tif ( builder.length() != 0 ) {\n\t\t\t\t\t\t\t\t\toperands.add( builder.substring( 0, builder.length() - 4 ) );\n\t\t\t\t\t\t\t\t\tbuilder.setLength( 0 );\n\t\t\t\t\t\t\t\t\toperands.add( operandToken );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\toperandToken = tokens.nextToken();\n\t\t\t\t\thasMoreOperands = tokens.hasMoreTokens() && ( parenthesis != 0 || ! \")\".equals( operandToken ) );\n\t\t\t\t}\n\t\t\t\tif ( builder.length() != 0 ) {\n\t\t\t\t\toperands.add( builder.toString() );\n\t\t\t\t}\n\n\t\t\t\tTrimOperands trimOperands = new TrimOperands( operands );\n\t\t\t\tresult.append( \"trim(\" );\n\t\t\t\tif ( trimOperands.trimSpec != null ) {\n\t\t\t\t\tresult.append( trimOperands.trimSpec ).append( ' ' );\n\t\t\t\t}\n\t\t\t\tif ( trimOperands.trimChar != null ) {\n\t\t\t\t\tif ( trimOperands.trimChar.startsWith( \"'\" ) && trimOperands.trimChar.endsWith( \"'\" ) ) {\n\t\t\t\t\t\tresult.append( trimOperands.trimChar );\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tresult.append(\n\t\t\t\t\t\t\t\trenderWhereStringTemplate( trimOperands.trimSpec, placeholder, dialect, typeConfiguration, functionRegistry )\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\tresult.append( ' ' );\n\t\t\t\t}\n\t\t\t\tif ( trimOperands.from != null ) {\n\t\t\t\t\tresult.append( trimOperands.from ).append( ' ' );\n\t\t\t\t}\n\t\t\t\telse if ( trimOperands.trimSpec != null || trimOperands.trimChar != null ) {\n\t\t\t\t\t// I think ANSI SQL says that the 'from' is not optional if either trim-spec or trim-char is specified\n\t\t\t\t\tresult.append( \"from \" );\n\t\t\t\t}\n\n\t\t\t\tresult.append( renderWhereStringTemplate( trimOperands.trimSource, placeholder, dialect, typeConfiguration, functionRegistry ) )\n\t\t\t\t\t\t.append( ')' );\n\n\t\t\t\thasMore = tokens.hasMoreTokens();\n\t\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tboolean quotedOrWhitespace = quoted || quotedIdentifier || isQuoteCharacter\n\t\t\t\t\t|| Character.isWhitespace( token.charAt(0) );\n\n\t\t\tif ( quotedOrWhitespace ) {\n\t\t\t\tresult.append( token );\n\t\t\t}\n\t\t\telse if ( beforeTable ) {\n\t\t\t\tresult.append( token );\n\t\t\t\tbeforeTable = false;\n\t\t\t\tafterFromTable = true;\n\t\t\t}\n\t\t\telse if ( afterFromTable ) {\n\t\t\t\tif ( !\"as\".equals(lcToken) ) {\n\t\t\t\t\tafterFromTable = false;\n\t\t\t\t}\n\t\t\t\tresult.append(token);\n\t\t\t}\n\t\t\telse if ( isNamedParameter(token) ) {\n\t\t\t\tresult.append(token);\n\t\t\t}\n\t\t\telse if ( isIdentifier(token)\n\t\t\t\t\t&& !isFunctionOrKeyword(lcToken, nextToken, dialect, typeConfiguration, functionRegistry) ) {\n\t\t\t\tresult.append(placeholder)\n\t\t\t\t\t\t.append('.')\n\t\t\t\t\t\t.append( dialect.quote(token) );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif ( BEFORE_TABLE_KEYWORDS.contains(lcToken) ) {\n\t\t\t\t\tbeforeTable = true;\n\t\t\t\t\tinFromClause = true;\n\t\t\t\t}\n\t\t\t\telse if ( inFromClause && \",\".equals(lcToken) ) {\n\t\t\t\t\tbeforeTable = true;\n\t\t\t\t}\n\t\t\t\tif ( isBoolean( token ) ) {\n\t\t\t\t\ttoken = dialect.toBooleanValueString( Boolean.parseBoolean( token ) );\n\t\t\t\t}\n\t\t\t\tresult.append(token);\n\t\t\t}\n\n\t\t\t//Yuck:\n\t\t\tif ( inFromClause\n\t\t\t\t\t&& KEYWORDS.contains( lcToken ) //\"as\" is not in KEYWORDS\n\t\t\t\t\t&& !BEFORE_TABLE_KEYWORDS.contains( lcToken ) ) {\n\t\t\t\tinFromClause = false;\n\t\t\t}\n\t\t}\n\n\t\treturn result.toString();\n\t}",
        "filePathBefore": "hibernate-core/src/main/java/org/hibernate/sql/Template.java",
        "isPureRefactoring": true,
        "commitId": "35f96d6e901dbd071b375d809521ef6f1c979868",
        "packageNameBefore": "org.hibernate.sql",
        "classNameBefore": "org.hibernate.sql.Template",
        "methodNameBefore": "org.hibernate.sql.Template#renderWhereStringTemplate",
        "invokedMethod": "methodSignature: org.hibernate.sql.Template#extractUntil\n methodBody: private static String extractUntil(StringTokenizer tokens, String delimiter) {\nStringBuilder valueBuilder=new StringBuilder();\nString token=tokens.nextToken();\nwhile(!delimiter.equalsIgnoreCase(token)){valueBuilder.append(token);\ntoken=tokens.nextToken();\n}return valueBuilder.toString().trim();\n}\nmethodSignature: org.hibernate.sql.Template#renderWhereStringTemplate\n methodBody: public static String renderWhereStringTemplate(\n\t\t\tString sqlWhereString,\n\t\t\tString placeholder,\n\t\t\tDialect dialect,\n\t\t\tTypeConfiguration typeConfiguration,\n\t\t\tSqmFunctionRegistry functionRegistry) {\nString symbols=PUNCTUATION + WHITESPACE + dialect.openQuote() + dialect.closeQuote();\nStringTokenizer tokens=new StringTokenizer(sqlWhereString,symbols,true);\nStringBuilder result=new StringBuilder();\nboolean quoted=false;\nboolean quotedIdentifier=false;\nboolean beforeTable=false;\nboolean inFromClause=false;\nboolean afterFromTable=false;\nboolean hasMore=tokens.hasMoreTokens();\nString nextToken=hasMore ? tokens.nextToken() : null;\nwhile(hasMore){String token=nextToken;\nString lcToken=token.toLowerCase(Locale.ROOT);\nhasMore=tokens.hasMoreTokens();\nnextToken=hasMore ? tokens.nextToken() : null;\nboolean isQuoteCharacter=false;\nif(!quotedIdentifier && \"'\".equals(token)){quoted=!quoted;\nisQuoteCharacter=true;\n}if(!quoted){boolean isOpenQuote;\nif(\"`\".equals(token)){isOpenQuote=!quotedIdentifier;\ntoken=lcToken=isOpenQuote ? Character.toString(dialect.openQuote()) : Character.toString(dialect.closeQuote());\nquotedIdentifier=isOpenQuote;\nisQuoteCharacter=true;\n}if(!quotedIdentifier && (dialect.openQuote() == token.charAt(0))){isOpenQuote=true;\nquotedIdentifier=true;\nisQuoteCharacter=true;\n}if(quotedIdentifier && (dialect.closeQuote() == token.charAt(0))){quotedIdentifier=false;\nisQuoteCharacter=true;\nisOpenQuote=false;\n}if(LITERAL_PREFIXES.contains(lcToken)){if(\"'\".equals(nextToken)){result.append(token);\ncontinue;\n}if(nextToken != null && Character.isWhitespace(nextToken.charAt(0))){final StringBuilder additionalTokens=new StringBuilder();\nTimeZoneTokens possibleNextToken=null;\ndo(nextToken != null && possibleNextToken.isToken(nextToken)){possibleNextToken=possibleNextToken == null ? TimeZoneTokens.getPossibleNextTokens(lcToken) : possibleNextToken.nextToken();\ndo(nextToken != null && Character.isWhitespace(nextToken.charAt(0))){additionalTokens.append(nextToken);\nhasMore=tokens.hasMoreTokens();\nnextToken=tokens.nextToken();\n}}if(\"'\".equals(nextToken)){result.append(token);\nresult.append(additionalTokens);\ncontinue;\n}{isOpenQuote=false;\n}}{isOpenQuote=false;\n}}{isOpenQuote=false;\n}if(isOpenQuote){result.append(placeholder).append('.');\n}}if(\"extract\".equals(lcToken) && \"(\".equals(nextToken)){final String field=extractUntil(tokens,\"from\");\nfinal String source=renderWhereStringTemplate(extractUntil(tokens,\")\"),placeholder,dialect,typeConfiguration,functionRegistry);\nresult.append(\"extract(\").append(field).append(\" from \").append(source).append(')');\nhasMore=tokens.hasMoreTokens();\nnextToken=hasMore ? tokens.nextToken() : null;\ncontinue;\n}if(\"trim\".equals(lcToken) && \"(\".equals(nextToken)){List<String> operands=new ArrayList<>();\nStringBuilder builder=new StringBuilder();\nboolean hasMoreOperands=true;\nString operandToken=tokens.nextToken();\nswitch(operandToken.toLowerCase(Locale.ROOT))case \"leading\":case \"trailing\":case \"both\":operands.add(operandToken);\nif(hasMoreOperands=tokens.hasMoreTokens()){operandToken=tokens.nextToken();\n}break;\nboolean quotedOperand=false;\nint parenthesis=0;\nwhile(hasMoreOperands){final boolean isQuote=\"'\".equals(operandToken);\nif(isQuote){quotedOperand=!quotedOperand;\nif(!quotedOperand){operands.add(builder.append('\\'').toString());\nbuilder.setLength(0);\n}{builder.append('\\'');\n}}if(quotedOperand){builder.append(operandToken);\n}if(parenthesis != 0){builder.append(operandToken);\nswitch(operandToken)case \"(\":parenthesis++;\nbreak;\ncase \")\":parenthesis--;\nbreak;\n}{builder.append(operandToken);\nswitch(operandToken.toLowerCase(Locale.ROOT))case \"(\":parenthesis++;\nbreak;\ncase \")\":parenthesis--;\nbreak;\ncase \"from\":if(builder.length() != 0){operands.add(builder.substring(0,builder.length() - 4));\nbuilder.setLength(0);\noperands.add(operandToken);\n}break;\n}operandToken=tokens.nextToken();\nhasMoreOperands=tokens.hasMoreTokens() && (parenthesis != 0 || !\")\".equals(operandToken));\n}if(builder.length() != 0){operands.add(builder.toString());\n}TrimOperands trimOperands=new TrimOperands(operands);\nresult.append(\"trim(\");\nif(trimOperands.trimSpec != null){result.append(trimOperands.trimSpec).append(' ');\n}if(trimOperands.trimChar != null){if(trimOperands.trimChar.startsWith(\"'\") && trimOperands.trimChar.endsWith(\"'\")){result.append(trimOperands.trimChar);\n}{result.append(renderWhereStringTemplate(trimOperands.trimSpec,placeholder,dialect,typeConfiguration,functionRegistry));\n}result.append(' ');\n}if(trimOperands.from != null){result.append(trimOperands.from).append(' ');\n}if(trimOperands.trimSpec != null || trimOperands.trimChar != null){result.append(\"from \");\n}result.append(renderWhereStringTemplate(trimOperands.trimSource,placeholder,dialect,typeConfiguration,functionRegistry)).append(')');\nhasMore=tokens.hasMoreTokens();\nnextToken=hasMore ? tokens.nextToken() : null;\ncontinue;\n}boolean quotedOrWhitespace=quoted || quotedIdentifier || isQuoteCharacter || Character.isWhitespace(token.charAt(0));\nif(quotedOrWhitespace){result.append(token);\n}if(beforeTable){result.append(token);\nbeforeTable=false;\nafterFromTable=true;\n}if(afterFromTable){if(!\"as\".equals(lcToken)){afterFromTable=false;\n}result.append(token);\n}if(isNamedParameter(token)){result.append(token);\n}if(isIdentifier(token) && !isFunctionOrKeyword(lcToken,nextToken,dialect,typeConfiguration,functionRegistry)){result.append(placeholder).append('.').append(dialect.quote(token));\n}{if(BEFORE_TABLE_KEYWORDS.contains(lcToken)){beforeTable=true;\ninFromClause=true;\n}if(inFromClause && \",\".equals(lcToken)){beforeTable=true;\n}if(isBoolean(token)){token=dialect.toBooleanValueString(Boolean.parseBoolean(token));\n}result.append(token);\n}if(inFromClause && KEYWORDS.contains(lcToken) && !BEFORE_TABLE_KEYWORDS.contains(lcToken)){inFromClause=false;\n}}return result.toString();\n}\nmethodSignature: org.hibernate.sql.Template.TimeZoneTokens#isToken\n methodBody: public boolean isToken(String token) {\nreturn this != NONE && name().equalsIgnoreCase(token);\n}\nmethodSignature: org.hibernate.sql.Template#isBoolean\n methodBody: private static boolean isBoolean(String token) {\nreturn \"true\".equals(token) || \"false\".equals(token);\n}\nmethodSignature: org.hibernate.sql.Template.TimeZoneTokens#nextToken\n methodBody: public TimeZoneTokens nextToken() {\nif(this == WITH){return TIME;\n}if(this == TIME){return ZONE;\n}{return NONE;\n}}\nmethodSignature: org.hibernate.sql.Template.TimeZoneTokens#getPossibleNextTokens\n methodBody: static TimeZoneTokens getPossibleNextTokens(String lctoken) {\nswitch(lctoken)case \"time\":case \"timestamp\":return WITH;\ndefault:return NONE;\n}\nmethodSignature: org.hibernate.sql.Template#isIdentifier\n methodBody: private static boolean isIdentifier(String token) {\nif(isBoolean(token)){return false;\n}return token.charAt(0) == '`' || (Character.isLetter(token.charAt(0)) && token.indexOf('.') < 0);\n}\nmethodSignature: org.hibernate.sql.Template#isNamedParameter\n methodBody: private static boolean isNamedParameter(String token) {\nreturn token.startsWith(\":\");\n}\nmethodSignature: org.hibernate.sql.Template#isFunctionOrKeyword\n methodBody: private static boolean isFunctionOrKeyword(\n\t\t\tString lcToken,\n\t\t\tString nextToken,\n\t\t\tDialect dialect,\n\t\t\tTypeConfiguration typeConfiguration,\n\t\t\tSqmFunctionRegistry functionRegistry) {\nreturn \"(\".equals(nextToken) || KEYWORDS.contains(lcToken) || isType(lcToken,typeConfiguration) || isFunction(lcToken,nextToken,functionRegistry) || dialect.getKeywords().contains(lcToken) || FUNCTION_KEYWORDS.contains(lcToken);\n}",
        "classSignatureBefore": "public final class Template ",
        "methodNameBeforeSet": [
            "org.hibernate.sql.Template#renderWhereStringTemplate"
        ],
        "classNameBeforeSet": [
            "org.hibernate.sql.Template"
        ],
        "classSignatureBeforeSet": [
            "public final class Template "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.\n */\npackage org.hibernate.sql;\n\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Set;\nimport java.util.StringTokenizer;\n\nimport org.hibernate.HibernateException;\nimport org.hibernate.dialect.Dialect;\nimport org.hibernate.query.sqm.function.SqmFunctionDescriptor;\nimport org.hibernate.query.sqm.function.SqmFunctionRegistry;\nimport org.hibernate.type.spi.TypeConfiguration;\n\nimport static org.hibernate.internal.util.StringHelper.WHITESPACE;\n\n/**\n * Parses SQL fragments specified in mapping documents.\n *\n * @author Gavin King\n */\npublic final class Template {\n\n\tprivate static final Set<String> KEYWORDS = new HashSet<>();\n\tprivate static final Set<String> BEFORE_TABLE_KEYWORDS = new HashSet<>();\n\tprivate static final Set<String> FUNCTION_KEYWORDS = new HashSet<>();\n\tprivate static final Set<String> LITERAL_PREFIXES = new HashSet<>();\n\tpublic static final String PUNCTUATION = \"=><!+-*/()',|&`\";\n\n\tstatic {\n\t\tKEYWORDS.add(\"and\");\n\t\tKEYWORDS.add(\"or\");\n\t\tKEYWORDS.add(\"not\");\n\t\tKEYWORDS.add(\"like\");\n\t\tKEYWORDS.add(\"escape\");\n\t\tKEYWORDS.add(\"is\");\n\t\tKEYWORDS.add(\"in\");\n\t\tKEYWORDS.add(\"between\");\n\t\tKEYWORDS.add(\"null\");\n\t\tKEYWORDS.add(\"select\");\n\t\tKEYWORDS.add(\"distinct\");\n\t\tKEYWORDS.add(\"from\");\n\t\tKEYWORDS.add(\"join\");\n\t\tKEYWORDS.add(\"inner\");\n\t\tKEYWORDS.add(\"outer\");\n\t\tKEYWORDS.add(\"left\");\n\t\tKEYWORDS.add(\"right\");\n\t\tKEYWORDS.add(\"on\");\n\t\tKEYWORDS.add(\"where\");\n\t\tKEYWORDS.add(\"having\");\n\t\tKEYWORDS.add(\"group\");\n\t\tKEYWORDS.add(\"order\");\n\t\tKEYWORDS.add(\"by\");\n\t\tKEYWORDS.add(\"desc\");\n\t\tKEYWORDS.add(\"asc\");\n\t\tKEYWORDS.add(\"limit\");\n\t\tKEYWORDS.add(\"any\");\n\t\tKEYWORDS.add(\"some\");\n\t\tKEYWORDS.add(\"exists\");\n\t\tKEYWORDS.add(\"all\");\n\t\tKEYWORDS.add(\"union\");\n\t\tKEYWORDS.add(\"minus\");\n\t\tKEYWORDS.add(\"except\");\n\t\tKEYWORDS.add(\"intersect\");\n\t\tKEYWORDS.add(\"partition\");\n\n\t\tBEFORE_TABLE_KEYWORDS.add(\"from\");\n\t\tBEFORE_TABLE_KEYWORDS.add(\"join\");\n\n\t\tFUNCTION_KEYWORDS.add(\"as\");\n\t\tFUNCTION_KEYWORDS.add(\"leading\");\n\t\tFUNCTION_KEYWORDS.add(\"trailing\");\n\t\tFUNCTION_KEYWORDS.add(\"from\");\n\t\tFUNCTION_KEYWORDS.add(\"case\");\n\t\tFUNCTION_KEYWORDS.add(\"when\");\n\t\tFUNCTION_KEYWORDS.add(\"then\");\n\t\tFUNCTION_KEYWORDS.add(\"else\");\n\t\tFUNCTION_KEYWORDS.add(\"end\");\n\n\t\tLITERAL_PREFIXES.add(\"n\");\n\t\tLITERAL_PREFIXES.add(\"x\");\n\t\tLITERAL_PREFIXES.add(\"varbyte\");\n\t\tLITERAL_PREFIXES.add(\"bx\");\n\t\tLITERAL_PREFIXES.add(\"bytea\");\n\t\tLITERAL_PREFIXES.add(\"date\");\n\t\tLITERAL_PREFIXES.add(\"time\");\n\t\tLITERAL_PREFIXES.add(\"timestamp\");\n\t}\n\n\tpublic static final String TEMPLATE = \"$PlaceHolder$\";\n\n\tprivate Template() {}\n\n\tpublic static String renderTransformerReadFragment(\n\t\t\tString fragment,\n\t\t\tString... columnNames) {\n\t\t// NOTE : would need access to SessionFactoryImplementor to make this configurable\n\t\tfor ( String columnName : columnNames ) {\n\t\t\tfragment = fragment.replace( columnName, TEMPLATE + '.' + columnName );\n\t\t}\n\t\treturn fragment;\n\t}\n\n\tpublic static String renderWhereStringTemplate(\n\t\t\tString sqlWhereString,\n\t\t\tDialect dialect,\n\t\t\tTypeConfiguration typeConfiguration,\n\t\t\tSqmFunctionRegistry functionRegistry) {\n\t\treturn renderWhereStringTemplate( sqlWhereString, TEMPLATE, dialect, typeConfiguration, functionRegistry );\n\t}\n\n\t/**\n\t * Takes the where condition provided in the mapping attribute and interpolates the alias.\n\t * Handles sub-selects, quoted identifiers, quoted strings, expressions, SQL functions,\n\t * named parameters.\n\t *\n\t * @param sqlWhereString The string into which to interpolate the placeholder value\n\t * @param placeholder The value to be interpolated into the sqlWhereString\n\t * @param dialect The dialect to apply\n\t * @param functionRegistry The registry of all sql functions\n\t * @return The rendered sql fragment\n\t */\n\tpublic static String renderWhereStringTemplate(\n\t\t\tString sqlWhereString,\n\t\t\tString placeholder,\n\t\t\tDialect dialect,\n\t\t\tTypeConfiguration typeConfiguration,\n\t\t\tSqmFunctionRegistry functionRegistry) {\n\n\t\t// IMPL NOTE : The basic process here is to tokenize the incoming string and to iterate over each token\n\t\t//\t\tin turn.  As we process each token, we set a series of flags used to indicate the type of context in\n\t\t// \t\twhich the tokens occur.  Depending on the state of those flags we decide whether we need to qualify\n\t\t//\t\tidentifier references.\n\n\t\tString symbols = PUNCTUATION +\n\t\t\t\tWHITESPACE +\n\t\t\t\tdialect.openQuote() +\n\t\t\t\tdialect.closeQuote();\n\t\tStringTokenizer tokens = new StringTokenizer( sqlWhereString, symbols, true );\n\t\tStringBuilder result = new StringBuilder();\n\n\t\tboolean quoted = false;\n\t\tboolean quotedIdentifier = false;\n\t\tboolean beforeTable = false;\n\t\tboolean inFromClause = false;\n\t\tboolean afterFromTable = false;\n\n\t\tboolean hasMore = tokens.hasMoreTokens();\n\t\tString nextToken = hasMore ? tokens.nextToken() : null;\n\t\twhile ( hasMore ) {\n\t\t\tString token = nextToken;\n\t\t\tString lcToken = token.toLowerCase(Locale.ROOT);\n\t\t\thasMore = tokens.hasMoreTokens();\n\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n\n\t\t\tboolean isQuoteCharacter = false;\n\n\t\t\tif ( !quotedIdentifier && \"'\".equals(token) ) {\n\t\t\t\tquoted = !quoted;\n\t\t\t\tisQuoteCharacter = true;\n\t\t\t}\n\n\t\t\tif ( !quoted ) {\n\t\t\t\tboolean isOpenQuote;\n\t\t\t\tif ( \"`\".equals(token) ) {\n\t\t\t\t\tisOpenQuote = !quotedIdentifier;\n\t\t\t\t\ttoken = lcToken = isOpenQuote\n\t\t\t\t\t\t\t? Character.toString( dialect.openQuote() )\n\t\t\t\t\t\t\t: Character.toString( dialect.closeQuote() );\n\t\t\t\t\tquotedIdentifier = isOpenQuote;\n\t\t\t\t\tisQuoteCharacter = true;\n\t\t\t\t}\n\t\t\t\telse if ( !quotedIdentifier && ( dialect.openQuote()==token.charAt(0) ) ) {\n\t\t\t\t\tisOpenQuote = true;\n\t\t\t\t\tquotedIdentifier = true;\n\t\t\t\t\tisQuoteCharacter = true;\n\t\t\t\t}\n\t\t\t\telse if ( quotedIdentifier && ( dialect.closeQuote()==token.charAt(0) ) ) {\n\t\t\t\t\tquotedIdentifier = false;\n\t\t\t\t\tisQuoteCharacter = true;\n\t\t\t\t\tisOpenQuote = false;\n\t\t\t\t}\n\t\t\t\telse if ( LITERAL_PREFIXES.contains( lcToken ) ) {\n\t\t\t\t\tif ( \"'\".equals( nextToken ) ) {\n\t\t\t\t\t\t// Don't prefix a literal\n\t\t\t\t\t\tresult.append( token );\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\telse if ( nextToken != null && Character.isWhitespace( nextToken.charAt( 0 ) ) ) {\n\t\t\t\t\t\tfinal StringBuilder additionalTokens = new StringBuilder();\n\t\t\t\t\t\tTimeZoneTokens possibleNextToken = null;\n\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\tpossibleNextToken = possibleNextToken == null\n\t\t\t\t\t\t\t\t\t? TimeZoneTokens.getPossibleNextTokens( lcToken )\n\t\t\t\t\t\t\t\t\t: possibleNextToken.nextToken();\n\t\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\t\tadditionalTokens.append( nextToken );\n\t\t\t\t\t\t\t\thasMore = tokens.hasMoreTokens();\n\t\t\t\t\t\t\t\tnextToken = tokens.nextToken();\n\t\t\t\t\t\t\t} while ( nextToken != null && Character.isWhitespace( nextToken.charAt( 0 ) ) );\n\t\t\t\t\t\t} while ( nextToken != null && possibleNextToken.isToken( nextToken ) );\n\t\t\t\t\t\tif ( \"'\".equals( nextToken ) ) {\n\t\t\t\t\t\t\t// Don't prefix a literal\n\t\t\t\t\t\t\tresult.append( token );\n\t\t\t\t\t\t\tresult.append( additionalTokens );\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tisOpenQuote = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tisOpenQuote = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tisOpenQuote = false;\n\t\t\t\t}\n\n\t\t\t\tif ( isOpenQuote ) {\n\t\t\t\t\tresult.append( placeholder ).append( '.' );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Special processing for ANSI SQL EXTRACT function\n\t\t\tif ( \"extract\".equals( lcToken ) && \"(\".equals( nextToken ) ) {\n\t\t\t\tfinal String field = extractUntil( tokens, \"from\" );\n\t\t\t\tfinal String source = renderWhereStringTemplate(\n\t\t\t\t\t\textractUntil( tokens, \")\" ),\n\t\t\t\t\t\tplaceholder,\n\t\t\t\t\t\tdialect,\n\t\t\t\t\t\ttypeConfiguration,\n\t\t\t\t\t\tfunctionRegistry\n\t\t\t\t);\n\t\t\t\tresult.append( \"extract(\" ).append( field ).append( \" from \" ).append( source ).append( ')' );\n\n\t\t\t\thasMore = tokens.hasMoreTokens();\n\t\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Special processing for ANSI SQL TRIM function\n\t\t\tif ( \"trim\".equals( lcToken ) && \"(\".equals( nextToken ) ) {\n\t\t\t\tList<String> operands = new ArrayList<>();\n\t\t\t\tStringBuilder builder = new StringBuilder();\n\n\t\t\t\tboolean hasMoreOperands = true;\n\t\t\t\tString operandToken = tokens.nextToken();\n\t\t\t\tswitch ( operandToken.toLowerCase( Locale.ROOT ) ) {\n\t\t\t\t\tcase \"leading\":\n\t\t\t\t\tcase \"trailing\":\n\t\t\t\t\tcase \"both\":\n\t\t\t\t\t\toperands.add( operandToken );\n\t\t\t\t\t\tif ( hasMoreOperands = tokens.hasMoreTokens() ) {\n\t\t\t\t\t\t\toperandToken = tokens.nextToken();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tboolean quotedOperand = false;\n\t\t\t\tint parenthesis = 0;\n\t\t\t\twhile ( hasMoreOperands ) {\n\t\t\t\t\tfinal boolean isQuote = \"'\".equals( operandToken );\n\t\t\t\t\tif ( isQuote ) {\n\t\t\t\t\t\tquotedOperand = !quotedOperand;\n\t\t\t\t\t\tif ( !quotedOperand ) {\n\t\t\t\t\t\t\toperands.add( builder.append( '\\'' ).toString() );\n\t\t\t\t\t\t\tbuilder.setLength( 0 );\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tbuilder.append( '\\'' );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if ( quotedOperand ) {\n\t\t\t\t\t\tbuilder.append( operandToken );\n\t\t\t\t\t}\n\t\t\t\t\telse if ( parenthesis != 0 ) {\n\t\t\t\t\t\tbuilder.append( operandToken );\n\t\t\t\t\t\tswitch ( operandToken ) {\n\t\t\t\t\t\t\tcase \"(\":\n\t\t\t\t\t\t\t\tparenthesis++;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase \")\":\n\t\t\t\t\t\t\t\tparenthesis--;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tbuilder.append( operandToken );\n\t\t\t\t\t\tswitch ( operandToken.toLowerCase( Locale.ROOT ) ) {\n\t\t\t\t\t\t\tcase \"(\":\n\t\t\t\t\t\t\t\tparenthesis++;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase \")\":\n\t\t\t\t\t\t\t\tparenthesis--;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase \"from\":\n\t\t\t\t\t\t\t\tif ( builder.length() != 0 ) {\n\t\t\t\t\t\t\t\t\toperands.add( builder.substring( 0, builder.length() - 4 ) );\n\t\t\t\t\t\t\t\t\tbuilder.setLength( 0 );\n\t\t\t\t\t\t\t\t\toperands.add( operandToken );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\toperandToken = tokens.nextToken();\n\t\t\t\t\thasMoreOperands = tokens.hasMoreTokens() && ( parenthesis != 0 || ! \")\".equals( operandToken ) );\n\t\t\t\t}\n\t\t\t\tif ( builder.length() != 0 ) {\n\t\t\t\t\toperands.add( builder.toString() );\n\t\t\t\t}\n\n\t\t\t\tTrimOperands trimOperands = new TrimOperands( operands );\n\t\t\t\tresult.append( \"trim(\" );\n\t\t\t\tif ( trimOperands.trimSpec != null ) {\n\t\t\t\t\tresult.append( trimOperands.trimSpec ).append( ' ' );\n\t\t\t\t}\n\t\t\t\tif ( trimOperands.trimChar != null ) {\n\t\t\t\t\tif ( trimOperands.trimChar.startsWith( \"'\" ) && trimOperands.trimChar.endsWith( \"'\" ) ) {\n\t\t\t\t\t\tresult.append( trimOperands.trimChar );\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tresult.append(\n\t\t\t\t\t\t\t\trenderWhereStringTemplate( trimOperands.trimSpec, placeholder, dialect, typeConfiguration, functionRegistry )\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\tresult.append( ' ' );\n\t\t\t\t}\n\t\t\t\tif ( trimOperands.from != null ) {\n\t\t\t\t\tresult.append( trimOperands.from ).append( ' ' );\n\t\t\t\t}\n\t\t\t\telse if ( trimOperands.trimSpec != null || trimOperands.trimChar != null ) {\n\t\t\t\t\t// I think ANSI SQL says that the 'from' is not optional if either trim-spec or trim-char is specified\n\t\t\t\t\tresult.append( \"from \" );\n\t\t\t\t}\n\n\t\t\t\tresult.append( renderWhereStringTemplate( trimOperands.trimSource, placeholder, dialect, typeConfiguration, functionRegistry ) )\n\t\t\t\t\t\t.append( ')' );\n\n\t\t\t\thasMore = tokens.hasMoreTokens();\n\t\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tboolean quotedOrWhitespace = quoted || quotedIdentifier || isQuoteCharacter\n\t\t\t\t\t|| Character.isWhitespace( token.charAt(0) );\n\n\t\t\tif ( quotedOrWhitespace ) {\n\t\t\t\tresult.append( token );\n\t\t\t}\n\t\t\telse if ( beforeTable ) {\n\t\t\t\tresult.append( token );\n\t\t\t\tbeforeTable = false;\n\t\t\t\tafterFromTable = true;\n\t\t\t}\n\t\t\telse if ( afterFromTable ) {\n\t\t\t\tif ( !\"as\".equals(lcToken) ) {\n\t\t\t\t\tafterFromTable = false;\n\t\t\t\t}\n\t\t\t\tresult.append(token);\n\t\t\t}\n\t\t\telse if ( isNamedParameter(token) ) {\n\t\t\t\tresult.append(token);\n\t\t\t}\n\t\t\telse if ( isIdentifier(token)\n\t\t\t\t\t&& !isFunctionOrKeyword(lcToken, nextToken, dialect, typeConfiguration, functionRegistry) ) {\n\t\t\t\tresult.append(placeholder)\n\t\t\t\t\t\t.append('.')\n\t\t\t\t\t\t.append( dialect.quote(token) );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif ( BEFORE_TABLE_KEYWORDS.contains(lcToken) ) {\n\t\t\t\t\tbeforeTable = true;\n\t\t\t\t\tinFromClause = true;\n\t\t\t\t}\n\t\t\t\telse if ( inFromClause && \",\".equals(lcToken) ) {\n\t\t\t\t\tbeforeTable = true;\n\t\t\t\t}\n\t\t\t\tif ( isBoolean( token ) ) {\n\t\t\t\t\ttoken = dialect.toBooleanValueString( Boolean.parseBoolean( token ) );\n\t\t\t\t}\n\t\t\t\tresult.append(token);\n\t\t\t}\n\n\t\t\t//Yuck:\n\t\t\tif ( inFromClause\n\t\t\t\t\t&& KEYWORDS.contains( lcToken ) //\"as\" is not in KEYWORDS\n\t\t\t\t\t&& !BEFORE_TABLE_KEYWORDS.contains( lcToken ) ) {\n\t\t\t\tinFromClause = false;\n\t\t\t}\n\t\t}\n\n\t\treturn result.toString();\n\t}\n\n\tprivate enum TimeZoneTokens {\n\t\tNONE,\n\t\tWITH,\n\t\tTIME,\n\t\tZONE;\n\n\t\tstatic TimeZoneTokens getPossibleNextTokens(String lctoken) {\n\t\t\tswitch ( lctoken ) {\n\t\t\t\tcase \"time\":\n\t\t\t\tcase \"timestamp\":\n\t\t\t\t\treturn WITH;\n\t\t\t\tdefault:\n\t\t\t\t\treturn NONE;\n\t\t\t}\n\t\t}\n\n\t\tpublic TimeZoneTokens nextToken() {\n\t\t\tif ( this == WITH ) {\n\t\t\t\treturn TIME;\n\t\t\t}\n\t\t\telse if ( this == TIME ) {\n\t\t\t\treturn ZONE;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn NONE;\n\t\t\t}\n\t\t}\n\n\t\tpublic boolean isToken(String token) {\n\t\t\treturn this != NONE && name().equalsIgnoreCase( token );\n\t\t}\n\t}\n\n\tpublic static List<String> collectColumnNames(\n\t\t\tString sql,\n\t\t\tDialect dialect,\n\t\t\tTypeConfiguration typeConfiguration,\n\t\t\tSqmFunctionRegistry functionRegistry) {\n\t\treturn collectColumnNames( renderWhereStringTemplate( sql, dialect, typeConfiguration, functionRegistry ) );\n\t}\n\n\tpublic static List<String> collectColumnNames(String template) {\n\t\tfinal List<String> names = new ArrayList<>();\n\t\tint begin = 0;\n\t\tint match;\n\t\twhile ( ( match = template.indexOf(TEMPLATE, begin) ) >= 0 ) {\n\t\t\tint start = match + TEMPLATE.length() + 1;\n\t\t\tfor ( int loc = start;; loc++ ) {\n\t\t\t\tif ( loc == template.length() - 1 ) {\n\t\t\t\t\tnames.add( template.substring( start ) );\n\t\t\t\t\tbegin = template.length();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tchar ch = template.charAt( loc );\n\t\t\t\t\tif ( PUNCTUATION.indexOf(ch) >= 0 || WHITESPACE.indexOf(ch) >= 0 ) {\n\t\t\t\t\t\tnames.add( template.substring( start, loc ) );\n\t\t\t\t\t\tbegin = loc;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn names;\n\t}\n\n//\t/**\n//\t * Takes the where condition provided in the mapping attribute and interpolates the alias.\n//\t * Handles sub-selects, quoted identifiers, quoted strings, expressions, SQL functions,\n//\t * named parameters.\n//\t *\n//\t * @param sqlWhereString The string into which to interpolate the placeholder value\n//\t * @param placeholder The value to be interpolated into the sqlWhereString\n//\t * @param dialect The dialect to apply\n//\t * @param functionRegistry The registry of all sql functions\n//\t *\n//\t * @return The rendered sql fragment\n//\t */\n//\tpublic static String renderWhereStringTemplate(\n//\t\t\tString sqlWhereString,\n//\t\t\tString placeholder,\n//\t\t\tDialect dialect,\n//\t\t\tSQLFunctionRegistry functionRegistry) {\n//\n//\t\t// IMPL NOTE : The basic process here is to tokenize the incoming string and to iterate over each token\n//\t\t//\t\tin turn.  As we process each token, we set a series of flags used to indicate the type of context in\n//\t\t// \t\twhich the tokens occur.  Depending on the state of those flags we decide whether we need to qualify\n//\t\t//\t\tidentifier references.\n//\n//\t\tfinal String dialectOpenQuote = Character.toString( dialect.openQuote() );\n//\t\tfinal String dialectCloseQuote = Character.toString( dialect.closeQuote() );\n//\n//\t\tString symbols = new StringBuilder()\n//\t\t\t\t.append( \"=><!+-*/()',|&`\" )\n//\t\t\t\t.append( StringHelper.WHITESPACE )\n//\t\t\t\t.append( dialect.openQuote() )\n//\t\t\t\t.append( dialect.closeQuote() )\n//\t\t\t\t.toString();\n//\t\tStringTokenizer tokens = new StringTokenizer( sqlWhereString, symbols, true );\n//\t\tProcessingState state = new ProcessingState();\n//\n//\t\tStringBuilder quotedBuffer = new StringBuilder();\n//\t\tStringBuilder result = new StringBuilder();\n//\n//\t\tboolean hasMore = tokens.hasMoreTokens();\n//\t\tString nextToken = hasMore ? tokens.nextToken() : null;\n//\t\twhile ( hasMore ) {\n//\t\t\tString token = nextToken;\n//\t\t\tString lcToken = token.toLowerCase(Locale.ROOT);\n//\t\t\thasMore = tokens.hasMoreTokens();\n//\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n//\n//\t\t\t// First, determine quoting which might be based on either:\n//\t\t\t// \t\t1) back-tick\n//\t\t\t// \t\t2) single quote (ANSI SQL standard)\n//\t\t\t// \t\t3) or dialect defined quote character(s)\n//\t\t\tQuotingCharacterDisposition quotingCharacterDisposition = QuotingCharacterDisposition.NONE;\n//\t\t\tif ( \"`\".equals( token ) ) {\n//\t\t\t\tstate.quoted = !state.quoted;\n//\t\t\t\tquotingCharacterDisposition = state.quoted\n//\t\t\t\t\t\t? QuotingCharacterDisposition.OPEN\n//\t\t\t\t\t\t: QuotingCharacterDisposition.CLOSE;\n//\t\t\t\t// replace token with the appropriate dialect quoting char\n//\t\t\t\ttoken = lcToken = ( quotingCharacterDisposition == QuotingCharacterDisposition.OPEN )\n//\t\t\t\t\t\t? dialectOpenQuote\n//\t\t\t\t\t\t: dialectCloseQuote;\n//\t\t\t}\n//\t\t\telse if ( \"'\".equals( token ) ) {\n//\t\t\t\tstate.quoted = !state.quoted;\n//\t\t\t\tquotingCharacterDisposition = state.quoted\n//\t\t\t\t\t\t? QuotingCharacterDisposition.OPEN\n//\t\t\t\t\t\t: QuotingCharacterDisposition.CLOSE;\n//\t\t\t}\n//\t\t\telse if ( !state.quoted && dialectOpenQuote.equals( token ) ) {\n//\t\t\t\tstate.quoted = true;\n//\t\t\t\tquotingCharacterDisposition = QuotingCharacterDisposition.OPEN;\n//\t\t\t}\n//\t\t\telse if ( state.quoted && dialectCloseQuote.equals( token ) ) {\n//\t\t\t\tstate.quoted = false;\n//\t\t\t\tquotingCharacterDisposition = QuotingCharacterDisposition.CLOSE;\n//\t\t\t}\n//\n//\t\t\tif ( state.quoted ) {\n//\t\t\t\tquotedBuffer.append( token );\n//\t\t\t\tcontinue;\n//\t\t\t}\n//\n//\t\t\t// if we were previously processing quoted state and just encountered the close quote, then handle that\n//\t\t\t// quoted text\n//\t\t\tif ( quotingCharacterDisposition == QuotingCharacterDisposition.CLOSE ) {\n//\t\t\t\ttoken = quotedBuffer.toString();\n//\t\t\t\tquotedBuffer.setLength( 0 );\n//\t\t\t\tresult.append( placeholder ).append( '.' )\n//\t\t\t\t\t\t.append( dialectOpenQuote ).append( token ).append( dialectCloseQuote );\n//\t\t\t\tcontinue;\n//\t\t\t}\n//\n//\t\t\t// Special processing for ANSI SQL EXTRACT function\n//\t\t\tif ( \"extract\".equals( lcToken ) && \"(\".equals( nextToken ) ) {\n//\t\t\t\tfinal String field = extractUntil( tokens, \"from\" );\n//\t\t\t\tfinal String source = renderWhereStringTemplate(\n//\t\t\t\t\t\textractUntil( tokens, \")\" ),\n//\t\t\t\t\t\tplaceholder,\n//\t\t\t\t\t\tdialect,\n//\t\t\t\t\t\tfunctionRegistry\n//\t\t\t\t);\n//\t\t\t\tresult.append( \"extract(\" ).append( field ).append( \" from \" ).append( source ).append( ')' );\n//\n//\t\t\t\thasMore = tokens.hasMoreTokens();\n//\t\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n//\n//\t\t\t\tcontinue;\n//\t\t\t}\n//\n//\t\t\t// Special processing for ANSI SQL TRIM function\n//\t\t\tif ( \"trim\".equals( lcToken ) && \"(\".equals( nextToken ) ) {\n//\t\t\t\tList<String> operands = new ArrayList<String>();\n//\t\t\t\tStringBuilder builder = new StringBuilder();\n//\n//\t\t\t\tboolean hasMoreOperands = true;\n//\t\t\t\tString operandToken = tokens.nextToken();\n//\t\t\t\tboolean quoted = false;\n//\t\t\t\twhile ( hasMoreOperands ) {\n//\t\t\t\t\tfinal boolean isQuote = \"'\".equals( operandToken );\n//\t\t\t\t\tif ( isQuote ) {\n//\t\t\t\t\t\tquoted = !quoted;\n//\t\t\t\t\t\tif ( !quoted ) {\n//\t\t\t\t\t\t\toperands.add( builder.append( '\\'' ).toString() );\n//\t\t\t\t\t\t\tbuilder.setLength( 0 );\n//\t\t\t\t\t\t}\n//\t\t\t\t\t\telse {\n//\t\t\t\t\t\t\tbuilder.append( '\\'' );\n//\t\t\t\t\t\t}\n//\t\t\t\t\t}\n//\t\t\t\t\telse if ( quoted ) {\n//\t\t\t\t\t\tbuilder.append( operandToken );\n//\t\t\t\t\t}\n//\t\t\t\t\telse if ( operandToken.length() == 1 && Character.isWhitespace( operandToken.charAt( 0 ) ) ) {\n//\t\t\t\t\t\t// do nothing\n//\t\t\t\t\t}\n//\t\t\t\t\telse {\n//\t\t\t\t\t\toperands.add( operandToken );\n//\t\t\t\t\t}\n//\t\t\t\t\toperandToken = tokens.nextToken();\n//\t\t\t\t\thasMoreOperands = tokens.hasMoreTokens() && ! \")\".equals( operandToken );\n//\t\t\t\t}\n//\n//\t\t\t\tTrimOperands trimOperands = new TrimOperands( operands );\n//\t\t\t\tresult.append( \"trim(\" );\n//\t\t\t\tif ( trimOperands.trimSpec != null ) {\n//\t\t\t\t\tresult.append( trimOperands.trimSpec ).append( ' ' );\n//\t\t\t\t}\n//\t\t\t\tif ( trimOperands.trimChar != null ) {\n//\t\t\t\t\tif ( trimOperands.trimChar.startsWith( \"'\" ) && trimOperands.trimChar.endsWith( \"'\" ) ) {\n//\t\t\t\t\t\tresult.append( trimOperands.trimChar );\n//\t\t\t\t\t}\n//\t\t\t\t\telse {\n//\t\t\t\t\t\tresult.append(\n//\t\t\t\t\t\t\t\trenderWhereStringTemplate( trimOperands.trimSpec, placeholder, dialect, functionRegistry )\n//\t\t\t\t\t\t);\n//\t\t\t\t\t}\n//\t\t\t\t\tresult.append( ' ' );\n//\t\t\t\t}\n//\t\t\t\tif ( trimOperands.from != null ) {\n//\t\t\t\t\tresult.append( trimOperands.from ).append( ' ' );\n//\t\t\t\t}\n//\t\t\t\telse if ( trimOperands.trimSpec != null || trimOperands.trimChar != null ) {\n//\t\t\t\t\t// I think ANSI SQL says that the 'from' is not optional if either trim-spec or trim-char are specified\n//\t\t\t\t\tresult.append( \"from \" );\n//\t\t\t\t}\n//\n//\t\t\t\tresult.append( renderWhereStringTemplate( trimOperands.trimSource, placeholder, dialect, functionRegistry ) )\n//\t\t\t\t\t\t.append( ')' );\n//\n//\t\t\t\thasMore = tokens.hasMoreTokens();\n//\t\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n//\n//\t\t\t\tcontinue;\n//\t\t\t}\n//\n//\n//\t\t\t// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n//\n//\t\t\tif ( Character.isWhitespace( token.charAt( 0 ) ) ) {\n//\t\t\t\tresult.append( token );\n//\t\t\t}\n//\t\t\telse if ( state.beforeTable ) {\n//\t\t\t\tresult.append( token );\n//\t\t\t\tstate.beforeTable = false;\n//\t\t\t\tstate.afterFromTable = true;\n//\t\t\t}\n//\t\t\telse if ( state.afterFromTable ) {\n//\t\t\t\tif ( !\"as\".equals(lcToken) ) {\n//\t\t\t\t\tstate.afterFromTable = false;\n//\t\t\t\t}\n//\t\t\t\tresult.append(token);\n//\t\t\t}\n//\t\t\telse if ( isNamedParameter(token) ) {\n//\t\t\t\tresult.append(token);\n//\t\t\t}\n//\t\t\telse if ( isIdentifier(token, dialect)\n//\t\t\t\t\t&& !isFunctionOrKeyword(lcToken, nextToken, dialect , functionRegistry) ) {\n//\t\t\t\tresult.append(placeholder)\n//\t\t\t\t\t\t.append('.')\n//\t\t\t\t\t\t.append( dialect.quote(token) );\n//\t\t\t}\n//\t\t\telse {\n//\t\t\t\tif ( BEFORE_TABLE_KEYWORDS.contains(lcToken) ) {\n//\t\t\t\t\tstate.beforeTable = true;\n//\t\t\t\t\tstate.inFromClause = true;\n//\t\t\t\t}\n//\t\t\t\telse if ( state.inFromClause && \",\".equals(lcToken) ) {\n//\t\t\t\t\tstate.beforeTable = true;\n//\t\t\t\t}\n//\t\t\t\tresult.append(token);\n//\t\t\t}\n//\n//\t\t\t//Yuck:\n//\t\t\tif ( state.inFromClause\n//\t\t\t\t\t&& KEYWORDS.contains( lcToken ) //\"as\" is not in KEYWORDS\n//\t\t\t\t\t&& !BEFORE_TABLE_KEYWORDS.contains( lcToken ) ) {\n//\t\t\t\tstate.inFromClause = false;\n//\t\t\t}\n//\t\t}\n//\n//\t\treturn result.toString();\n//\t}\n//\n//\tprivate static class ProcessingState {\n//\t\tboolean quoted = false;\n//\t\tboolean quotedIdentifier = false;\n//\t\tboolean beforeTable = false;\n//\t\tboolean inFromClause = false;\n//\t\tboolean afterFromTable = false;\n//\t}\n//\n//\tprivate static enum QuotingCharacterDisposition { NONE, OPEN, CLOSE }\n\n\tprivate static class TrimOperands {\n\t\tprivate final String trimSpec;\n\t\tprivate final String trimChar;\n\t\tprivate final String from;\n\t\tprivate final String trimSource;\n\n\t\tprivate TrimOperands(List<String> operands) {\n\t\t\tfinal int size = operands.size();\n\t\t\tif ( size == 1 ) {\n\t\t\t\ttrimSpec = null;\n\t\t\t\ttrimChar = null;\n\t\t\t\tfrom = null;\n\t\t\t\ttrimSource = operands.get(0);\n\t\t\t}\n\t\t\telse if ( size == 4 ) {\n\t\t\t\ttrimSpec = operands.get(0);\n\t\t\t\ttrimChar = operands.get(1);\n\t\t\t\tfrom = operands.get(2);\n\t\t\t\ttrimSource = operands.get(3);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif ( size < 1 || size > 4 ) {\n\t\t\t\t\tthrow new HibernateException( \"Unexpected number of trim function operands : \" + size );\n\t\t\t\t}\n\n\t\t\t\t// trim-source will always be the last operand\n\t\t\t\ttrimSource = operands.get( size - 1 );\n\n\t\t\t\t// ANSI SQL says that more than one operand means that the FROM is required\n\t\t\t\tif ( ! \"from\".equals( operands.get( size - 2 ) ) ) {\n\t\t\t\t\tthrow new HibernateException( \"Expecting FROM, found : \" + operands.get( size - 2 ) );\n\t\t\t\t}\n\t\t\t\tfrom = operands.get( size - 2 );\n\n\t\t\t\t// trim-spec, if there is one will always be the first operand\n\t\t\t\tif ( \"leading\".equalsIgnoreCase( operands.get(0) )\n\t\t\t\t\t\t|| \"trailing\".equalsIgnoreCase( operands.get(0) )\n\t\t\t\t\t\t|| \"both\".equalsIgnoreCase( operands.get(0) ) ) {\n\t\t\t\t\ttrimSpec = operands.get(0);\n\t\t\t\t\ttrimChar = null;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ttrimSpec = null;\n\t\t\t\t\tif ( size - 2 == 0 ) {\n\t\t\t\t\t\ttrimChar = null;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\ttrimChar = operands.get( 0 );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate static String extractUntil(StringTokenizer tokens, String delimiter) {\n\t\tStringBuilder valueBuilder = new StringBuilder();\n\t\tString token = tokens.nextToken();\n\t\twhile ( ! delimiter.equalsIgnoreCase( token ) ) {\n\t\t\tvalueBuilder.append( token );\n\t\t\ttoken = tokens.nextToken();\n\t\t}\n\t\treturn valueBuilder.toString().trim();\n\t}\n\n\tprivate static boolean isNamedParameter(String token) {\n\t\treturn token.startsWith( \":\" );\n\t}\n\n\tprivate static boolean isFunctionOrKeyword(\n\t\t\tString lcToken,\n\t\t\tString nextToken,\n\t\t\tDialect dialect,\n\t\t\tTypeConfiguration typeConfiguration,\n\t\t\tSqmFunctionRegistry functionRegistry) {\n\t\treturn \"(\".equals( nextToken ) ||\n\t\t\t\tKEYWORDS.contains( lcToken ) ||\n\t\t\t\tisType( lcToken, typeConfiguration ) ||\n\t\t\t\tisFunction( lcToken, nextToken, functionRegistry ) ||\n\t\t\t\tdialect.getKeywords().contains( lcToken ) ||\n\t\t\t\tFUNCTION_KEYWORDS.contains( lcToken );\n\t}\n\n\tprivate static boolean isType(String lcToken, TypeConfiguration typeConfiguration) {\n\t\treturn typeConfiguration.getDdlTypeRegistry().isTypeNameRegistered( lcToken );\n\t}\n\n\tprivate static boolean isFunction(String lcToken, String nextToken, SqmFunctionRegistry functionRegistry) {\n\t\t// checking for \"(\" is currently redundant because it is checked before getting here;\n\t\t// doing the check anyhow, in case that earlier check goes away;\n\t\tif ( \"(\".equals( nextToken ) ) {\n\t\t\treturn true;\n\t\t}\n\n\t\tfinal SqmFunctionDescriptor function = functionRegistry.findFunctionDescriptor( lcToken );\n\t\treturn function != null;\n\t}\n\n\tprivate static boolean isIdentifier(String token) {\n\t\tif ( isBoolean( token ) ) {\n\t\t\treturn false;\n\t\t}\n\t\treturn token.charAt( 0 ) == '`' || ( //allow any identifier quoted with backtick\n\t\t\t\tCharacter.isLetter( token.charAt( 0 ) ) && //only recognizes identifiers beginning with a letter\n\t\t\t\t\t\ttoken.indexOf( '.' ) < 0\n\t\t);\n\t}\n\n\tprivate static boolean isBoolean(String token) {\n\t\treturn \"true\".equals( token ) || \"false\".equals( token );\n\t}\n}\n",
        "filePathAfter": "hibernate-core/src/main/java/org/hibernate/sql/Template.java",
        "sourceCodeAfterForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.\n */\npackage org.hibernate.sql;\n\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Set;\nimport java.util.StringTokenizer;\n\nimport org.hibernate.HibernateException;\nimport org.hibernate.dialect.Dialect;\nimport org.hibernate.query.sqm.function.SqmFunctionDescriptor;\nimport org.hibernate.query.sqm.function.SqmFunctionRegistry;\nimport org.hibernate.type.spi.TypeConfiguration;\n\nimport static java.lang.Boolean.parseBoolean;\nimport static java.lang.Character.isLetter;\nimport static org.hibernate.internal.util.StringHelper.WHITESPACE;\n\n/**\n * Parses SQL fragments specified in mapping documents.\n *\n * @author Gavin King\n */\npublic final class Template {\n\n\tprivate static final Set<String> KEYWORDS = new HashSet<>();\n\tprivate static final Set<String> BEFORE_TABLE_KEYWORDS = new HashSet<>();\n\tprivate static final Set<String> FUNCTION_KEYWORDS = new HashSet<>();\n\tprivate static final Set<String> LITERAL_PREFIXES = new HashSet<>();\n\tpublic static final String PUNCTUATION = \"=><!+-*/()',|&`\";\n\n\tstatic {\n\t\tKEYWORDS.add(\"and\");\n\t\tKEYWORDS.add(\"or\");\n\t\tKEYWORDS.add(\"not\");\n\t\tKEYWORDS.add(\"like\");\n\t\tKEYWORDS.add(\"escape\");\n\t\tKEYWORDS.add(\"is\");\n\t\tKEYWORDS.add(\"in\");\n\t\tKEYWORDS.add(\"between\");\n\t\tKEYWORDS.add(\"null\");\n\t\tKEYWORDS.add(\"select\");\n\t\tKEYWORDS.add(\"distinct\");\n\t\tKEYWORDS.add(\"from\");\n\t\tKEYWORDS.add(\"join\");\n\t\tKEYWORDS.add(\"inner\");\n\t\tKEYWORDS.add(\"outer\");\n\t\tKEYWORDS.add(\"left\");\n\t\tKEYWORDS.add(\"right\");\n\t\tKEYWORDS.add(\"on\");\n\t\tKEYWORDS.add(\"where\");\n\t\tKEYWORDS.add(\"having\");\n\t\tKEYWORDS.add(\"group\");\n\t\tKEYWORDS.add(\"order\");\n\t\tKEYWORDS.add(\"by\");\n\t\tKEYWORDS.add(\"desc\");\n\t\tKEYWORDS.add(\"asc\");\n\t\tKEYWORDS.add(\"limit\");\n\t\tKEYWORDS.add(\"any\");\n\t\tKEYWORDS.add(\"some\");\n\t\tKEYWORDS.add(\"exists\");\n\t\tKEYWORDS.add(\"all\");\n\t\tKEYWORDS.add(\"union\");\n\t\tKEYWORDS.add(\"minus\");\n\t\tKEYWORDS.add(\"except\");\n\t\tKEYWORDS.add(\"intersect\");\n\t\tKEYWORDS.add(\"partition\");\n\n\t\tBEFORE_TABLE_KEYWORDS.add(\"from\");\n\t\tBEFORE_TABLE_KEYWORDS.add(\"join\");\n\n\t\tFUNCTION_KEYWORDS.add(\"as\");\n\t\tFUNCTION_KEYWORDS.add(\"leading\");\n\t\tFUNCTION_KEYWORDS.add(\"trailing\");\n\t\tFUNCTION_KEYWORDS.add(\"from\");\n\t\tFUNCTION_KEYWORDS.add(\"case\");\n\t\tFUNCTION_KEYWORDS.add(\"when\");\n\t\tFUNCTION_KEYWORDS.add(\"then\");\n\t\tFUNCTION_KEYWORDS.add(\"else\");\n\t\tFUNCTION_KEYWORDS.add(\"end\");\n\n\t\tLITERAL_PREFIXES.add(\"n\");\n\t\tLITERAL_PREFIXES.add(\"x\");\n\t\tLITERAL_PREFIXES.add(\"varbyte\");\n\t\tLITERAL_PREFIXES.add(\"bx\");\n\t\tLITERAL_PREFIXES.add(\"bytea\");\n\t\tLITERAL_PREFIXES.add(\"date\");\n\t\tLITERAL_PREFIXES.add(\"time\");\n\t\tLITERAL_PREFIXES.add(\"timestamp\");\n\t\tLITERAL_PREFIXES.add(\"zone\");\n\t}\n\n\tpublic static final String TEMPLATE = \"$PlaceHolder$\";\n\n\tprivate Template() {}\n\n\tpublic static String renderTransformerReadFragment(\n\t\t\tString fragment,\n\t\t\tString... columnNames) {\n\t\t// NOTE : would need access to SessionFactoryImplementor to make this configurable\n\t\tfor ( String columnName : columnNames ) {\n\t\t\tfragment = fragment.replace( columnName, TEMPLATE + '.' + columnName );\n\t\t}\n\t\treturn fragment;\n\t}\n\n\tpublic static String renderWhereStringTemplate(\n\t\t\tString sqlWhereString,\n\t\t\tDialect dialect,\n\t\t\tTypeConfiguration typeConfiguration,\n\t\t\tSqmFunctionRegistry functionRegistry) {\n\t\treturn renderWhereStringTemplate( sqlWhereString, TEMPLATE, dialect, typeConfiguration, functionRegistry );\n\t}\n\n\t/**\n\t * Takes the where condition provided in the mapping attribute and interpolates the alias.\n\t * Handles sub-selects, quoted identifiers, quoted strings, expressions, SQL functions,\n\t * named parameters.\n\t *\n\t * @param sqlWhereString The string into which to interpolate the placeholder value\n\t * @param placeholder The value to be interpolated into the sqlWhereString\n\t * @param dialect The dialect to apply\n\t * @param functionRegistry The registry of all sql functions\n\t * @return The rendered sql fragment\n\t */\n\tpublic static String renderWhereStringTemplate(\n\t\t\tString sqlWhereString,\n\t\t\tString placeholder,\n\t\t\tDialect dialect,\n\t\t\tTypeConfiguration typeConfiguration,\n\t\t\tSqmFunctionRegistry functionRegistry) {\n\n\t\t// IMPL NOTE : The basic process here is to tokenize the incoming string and to iterate over each token\n\t\t//\t\tin turn.  As we process each token, we set a series of flags used to indicate the type of context in\n\t\t// \t\twhich the tokens occur.  Depending on the state of those flags we decide whether we need to qualify\n\t\t//\t\tidentifier references.\n\n\t\tfinal String symbols = PUNCTUATION + WHITESPACE + dialect.openQuote() + dialect.closeQuote();\n\t\tfinal StringTokenizer tokens = new StringTokenizer( sqlWhereString, symbols, true );\n\t\tfinal StringBuilder result = new StringBuilder();\n\n\t\tboolean quoted = false;\n\t\tboolean quotedIdentifier = false;\n\t\tboolean beforeTable = false;\n\t\tboolean inFromClause = false;\n\t\tboolean afterFromTable = false;\n\n\t\tboolean hasMore = tokens.hasMoreTokens();\n\t\tString nextToken = hasMore ? tokens.nextToken() : null;\n\t\twhile ( hasMore ) {\n\t\t\tString token = nextToken;\n\t\t\tString lcToken = token.toLowerCase(Locale.ROOT);\n\t\t\thasMore = tokens.hasMoreTokens();\n\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n\n\t\t\tboolean isQuoteCharacter = false;\n\n\t\t\tif ( !quotedIdentifier && \"'\".equals(token) ) {\n\t\t\t\tquoted = !quoted;\n\t\t\t\tisQuoteCharacter = true;\n\t\t\t}\n\n\t\t\tif ( !quoted ) {\n\t\t\t\tfinal boolean isOpenQuote;\n\t\t\t\tif ( \"`\".equals(token) ) {\n\t\t\t\t\tisOpenQuote = !quotedIdentifier;\n\t\t\t\t\ttoken = lcToken = isOpenQuote\n\t\t\t\t\t\t\t? Character.toString( dialect.openQuote() )\n\t\t\t\t\t\t\t: Character.toString( dialect.closeQuote() );\n\t\t\t\t\tquotedIdentifier = isOpenQuote;\n\t\t\t\t\tisQuoteCharacter = true;\n\t\t\t\t}\n\t\t\t\telse if ( !quotedIdentifier && dialect.openQuote()==token.charAt(0) ) {\n\t\t\t\t\tisOpenQuote = true;\n\t\t\t\t\tquotedIdentifier = true;\n\t\t\t\t\tisQuoteCharacter = true;\n\t\t\t\t}\n\t\t\t\telse if ( quotedIdentifier && dialect.closeQuote()==token.charAt(0) ) {\n\t\t\t\t\tquotedIdentifier = false;\n\t\t\t\t\tisQuoteCharacter = true;\n\t\t\t\t\tisOpenQuote = false;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tisOpenQuote = false;\n\t\t\t\t}\n\t\t\t\tif ( isOpenQuote ) {\n\t\t\t\t\tresult.append( placeholder ).append( '.' );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfinal boolean quotedOrWhitespace =\n\t\t\t\t\tquoted || quotedIdentifier || isQuoteCharacter\n\t\t\t\t\t\t\t|| token.isBlank();\n\t\t\tif ( quotedOrWhitespace ) {\n\t\t\t\tresult.append( token );\n\t\t\t}\n\t\t\telse if ( beforeTable ) {\n\t\t\t\tresult.append( token );\n\t\t\t\tbeforeTable = false;\n\t\t\t\tafterFromTable = true;\n\t\t\t}\n\t\t\telse if ( afterFromTable ) {\n\t\t\t\tif ( !\"as\".equals(lcToken) ) {\n\t\t\t\t\tafterFromTable = false;\n\t\t\t\t}\n\t\t\t\tresult.append(token);\n\t\t\t}\n\t\t\telse if ( isNamedParameter(token) ) {\n\t\t\t\tresult.append(token);\n\t\t\t}\n\t\t\telse if ( isExtractFunction( lcToken, nextToken ) ) {\n\t\t\t\t// Special processing for ANSI SQL EXTRACT function\n\t\t\t\thandleExtractFunction( placeholder, dialect, typeConfiguration, functionRegistry, tokens, result );\n\t\t\t\thasMore = tokens.hasMoreTokens();\n\t\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n\t\t\t}\n\t\t\telse if ( isTrimFunction( lcToken, nextToken ) ) {\n\t\t\t\t// Special processing for ANSI SQL TRIM function\n\t\t\t\thandleTrimFunction( placeholder, dialect, typeConfiguration, functionRegistry, tokens, result );\n\t\t\t\thasMore = tokens.hasMoreTokens();\n\t\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n\t\t\t}\n\t\t\telse if ( isIdentifier(token)\n\t\t\t\t\t&& !isFunctionOrKeyword( lcToken, nextToken, dialect, typeConfiguration, functionRegistry )\n\t\t\t\t\t&& !isLiteral( lcToken, nextToken, sqlWhereString, symbols, tokens ) ) {\n\t\t\t\tresult.append(placeholder)\n\t\t\t\t\t\t.append('.')\n\t\t\t\t\t\t.append( dialect.quote(token) );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif ( BEFORE_TABLE_KEYWORDS.contains(lcToken) ) {\n\t\t\t\t\tbeforeTable = true;\n\t\t\t\t\tinFromClause = true;\n\t\t\t\t}\n\t\t\t\telse if ( inFromClause && \",\".equals(lcToken) ) {\n\t\t\t\t\tbeforeTable = true;\n\t\t\t\t}\n\t\t\t\tif ( isBoolean( token ) ) {\n\t\t\t\t\ttoken = dialect.toBooleanValueString( parseBoolean( token ) );\n\t\t\t\t}\n\t\t\t\tresult.append(token);\n\t\t\t}\n\n\t\t\t//Yuck:\n\t\t\tif ( inFromClause\n\t\t\t\t\t&& KEYWORDS.contains( lcToken ) //\"as\" is not in KEYWORDS\n\t\t\t\t\t&& !BEFORE_TABLE_KEYWORDS.contains( lcToken ) ) {\n\t\t\t\tinFromClause = false;\n\t\t\t}\n\t\t}\n\n\t\treturn result.toString();\n\t}\n\n\tprivate static boolean isTrimFunction(String lcToken, String nextToken) {\n\t\treturn \"trim\".equals(lcToken) && \"(\".equals(nextToken);\n\t}\n\n\tprivate static boolean isExtractFunction(String lcToken, String nextToken) {\n\t\treturn \"extract\".equals(lcToken) && \"(\".equals(nextToken);\n\t}\n\n\tprivate static boolean isLiteral(\n\t\t\tString lcToken, String next,\n\t\t\tString sqlWhereString, String symbols, StringTokenizer tokens) {\n\t\tif ( LITERAL_PREFIXES.contains( lcToken ) && next != null ) {\n\t\t\t// easy cases first\n\t\t\tif ( \"'\".equals(next) ) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse if ( !next.isBlank() ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// we need to look ahead in the token stream\n\t\t\t\t// to find the first non-blank token\n\t\t\t\tfinal StringTokenizer lookahead =\n\t\t\t\t\t\tnew StringTokenizer( sqlWhereString, symbols, true );\n\t\t\t\twhile ( lookahead.countTokens() > tokens.countTokens()+1 ) {\n\t\t\t\t\tlookahead.nextToken();\n\t\t\t\t}\n\t\t\t\tif ( lookahead.hasMoreTokens() ) {\n\t\t\t\t\tString nextToken;\n\t\t\t\t\tdo {\n\t\t\t\t\t\tnextToken = lookahead.nextToken().toLowerCase(Locale.ROOT);\n\t\t\t\t\t}\n\t\t\t\t\twhile ( nextToken.isBlank() && lookahead.hasMoreTokens() );\n\t\t\t\t\treturn \"'\".equals( nextToken )\n\t\t\t\t\t\t|| lcToken.equals( \"time\" ) && \"with\".equals( nextToken )\n\t\t\t\t\t\t|| lcToken.equals( \"timestamp\" ) && \"with\".equals( nextToken )\n\t\t\t\t\t\t|| lcToken.equals( \"time\" ) && \"zone\".equals( nextToken );\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tprivate static void handleTrimFunction(\n\t\t\tString placeholder, Dialect dialect,\n\t\t\tTypeConfiguration typeConfiguration,\n\t\t\tSqmFunctionRegistry functionRegistry,\n\t\t\tStringTokenizer tokens,\n\t\t\tStringBuilder result) {\n\t\tfinal List<String> operands = new ArrayList<>();\n\t\tfinal StringBuilder builder = new StringBuilder();\n\n\t\tboolean hasMoreOperands = true;\n\t\tString operandToken = tokens.nextToken();\n\t\tswitch ( operandToken.toLowerCase( Locale.ROOT ) ) {\n\t\t\tcase \"leading\":\n\t\t\tcase \"trailing\":\n\t\t\tcase \"both\":\n\t\t\t\toperands.add( operandToken );\n\t\t\t\tif ( hasMoreOperands = tokens.hasMoreTokens() ) {\n\t\t\t\t\toperandToken = tokens.nextToken();\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t\tboolean quotedOperand = false;\n\t\tint parenthesis = 0;\n\t\twhile ( hasMoreOperands ) {\n\t\t\tfinal boolean isQuote = \"'\".equals( operandToken );\n\t\t\tif ( isQuote ) {\n\t\t\t\tquotedOperand = !quotedOperand;\n\t\t\t\tif ( !quotedOperand ) {\n\t\t\t\t\toperands.add( builder.append( '\\'' ).toString() );\n\t\t\t\t\tbuilder.setLength( 0 );\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tbuilder.append( '\\'' );\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if ( quotedOperand ) {\n\t\t\t\tbuilder.append( operandToken );\n\t\t\t}\n\t\t\telse if ( parenthesis != 0 ) {\n\t\t\t\tbuilder.append( operandToken );\n\t\t\t\tswitch ( operandToken ) {\n\t\t\t\t\tcase \"(\":\n\t\t\t\t\t\tparenthesis++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \")\":\n\t\t\t\t\t\tparenthesis--;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbuilder.append( operandToken );\n\t\t\t\tswitch ( operandToken.toLowerCase( Locale.ROOT ) ) {\n\t\t\t\t\tcase \"(\":\n\t\t\t\t\t\tparenthesis++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \")\":\n\t\t\t\t\t\tparenthesis--;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"from\":\n\t\t\t\t\t\tif ( !builder.isEmpty() ) {\n\t\t\t\t\t\t\toperands.add( builder.substring( 0, builder.length() - 4 ) );\n\t\t\t\t\t\t\tbuilder.setLength( 0 );\n\t\t\t\t\t\t\toperands.add( operandToken );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\toperandToken = tokens.nextToken();\n\t\t\thasMoreOperands = tokens.hasMoreTokens()\n\t\t\t\t\t&& ( parenthesis != 0 || ! \")\".equals( operandToken ) );\n\t\t}\n\t\tif ( !builder.isEmpty() ) {\n\t\t\toperands.add( builder.toString() );\n\t\t}\n\n\t\tfinal TrimOperands trimOperands = new TrimOperands( operands );\n\t\tresult.append( \"trim(\" );\n\t\tif ( trimOperands.trimSpec != null ) {\n\t\t\tresult.append( trimOperands.trimSpec ).append( ' ' );\n\t\t}\n\t\tif ( trimOperands.trimChar != null ) {\n\t\t\tif ( trimOperands.trimChar.startsWith( \"'\" ) && trimOperands.trimChar.endsWith( \"'\" ) ) {\n\t\t\t\tresult.append( trimOperands.trimChar );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tresult.append(\n\t\t\t\t\t\trenderWhereStringTemplate( trimOperands.trimSpec, placeholder, dialect, typeConfiguration, functionRegistry )\n\t\t\t\t);\n\t\t\t}\n\t\t\tresult.append( ' ' );\n\t\t}\n\t\tif ( trimOperands.from != null ) {\n\t\t\tresult.append( trimOperands.from ).append( ' ' );\n\t\t}\n\t\telse if ( trimOperands.trimSpec != null || trimOperands.trimChar != null ) {\n\t\t\t// I think ANSI SQL says that the 'from' is not optional if either trim-spec or trim-char is specified\n\t\t\tresult.append( \"from \" );\n\t\t}\n\n\t\tresult.append( renderWhereStringTemplate( trimOperands.trimSource, placeholder, dialect, typeConfiguration, functionRegistry ) )\n\t\t\t\t.append( ')' );\n\t}\n\n\tprivate static void handleExtractFunction(\n\t\t\tString placeholder,\n\t\t\tDialect dialect,\n\t\t\tTypeConfiguration typeConfiguration,\n\t\t\tSqmFunctionRegistry functionRegistry,\n\t\t\tStringTokenizer tokens,\n\t\t\tStringBuilder result) {\n\t\tfinal String field = extractUntil( tokens, \"from\" );\n\t\tfinal String source = renderWhereStringTemplate(\n\t\t\t\textractUntil( tokens, \")\" ),\n\t\t\t\tplaceholder,\n\t\t\t\tdialect,\n\t\t\t\ttypeConfiguration,\n\t\t\t\tfunctionRegistry\n\t\t);\n\t\tresult.append( \"extract(\" ).append( field ).append( \" from \" ).append( source ).append( ')' );\n\t}\n\n\tpublic static List<String> collectColumnNames(\n\t\t\tString sql,\n\t\t\tDialect dialect,\n\t\t\tTypeConfiguration typeConfiguration,\n\t\t\tSqmFunctionRegistry functionRegistry) {\n\t\treturn collectColumnNames( renderWhereStringTemplate( sql, dialect, typeConfiguration, functionRegistry ) );\n\t}\n\n\tpublic static List<String> collectColumnNames(String template) {\n\t\tfinal List<String> names = new ArrayList<>();\n\t\tint begin = 0;\n\t\tint match;\n\t\twhile ( ( match = template.indexOf(TEMPLATE, begin) ) >= 0 ) {\n\t\t\tint start = match + TEMPLATE.length() + 1;\n\t\t\tfor ( int loc = start;; loc++ ) {\n\t\t\t\tif ( loc == template.length() - 1 ) {\n\t\t\t\t\tnames.add( template.substring( start ) );\n\t\t\t\t\tbegin = template.length();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tchar ch = template.charAt( loc );\n\t\t\t\t\tif ( PUNCTUATION.indexOf(ch) >= 0 || WHITESPACE.indexOf(ch) >= 0 ) {\n\t\t\t\t\t\tnames.add( template.substring( start, loc ) );\n\t\t\t\t\t\tbegin = loc;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn names;\n\t}\n\n//\t/**\n//\t * Takes the where condition provided in the mapping attribute and interpolates the alias.\n//\t * Handles sub-selects, quoted identifiers, quoted strings, expressions, SQL functions,\n//\t * named parameters.\n//\t *\n//\t * @param sqlWhereString The string into which to interpolate the placeholder value\n//\t * @param placeholder The value to be interpolated into the sqlWhereString\n//\t * @param dialect The dialect to apply\n//\t * @param functionRegistry The registry of all sql functions\n//\t *\n//\t * @return The rendered sql fragment\n//\t */\n//\tpublic static String renderWhereStringTemplate(\n//\t\t\tString sqlWhereString,\n//\t\t\tString placeholder,\n//\t\t\tDialect dialect,\n//\t\t\tSQLFunctionRegistry functionRegistry) {\n//\n//\t\t// IMPL NOTE : The basic process here is to tokenize the incoming string and to iterate over each token\n//\t\t//\t\tin turn.  As we process each token, we set a series of flags used to indicate the type of context in\n//\t\t// \t\twhich the tokens occur.  Depending on the state of those flags we decide whether we need to qualify\n//\t\t//\t\tidentifier references.\n//\n//\t\tfinal String dialectOpenQuote = Character.toString( dialect.openQuote() );\n//\t\tfinal String dialectCloseQuote = Character.toString( dialect.closeQuote() );\n//\n//\t\tString symbols = new StringBuilder()\n//\t\t\t\t.append( \"=><!+-*/()',|&`\" )\n//\t\t\t\t.append( StringHelper.WHITESPACE )\n//\t\t\t\t.append( dialect.openQuote() )\n//\t\t\t\t.append( dialect.closeQuote() )\n//\t\t\t\t.toString();\n//\t\tStringTokenizer tokens = new StringTokenizer( sqlWhereString, symbols, true );\n//\t\tProcessingState state = new ProcessingState();\n//\n//\t\tStringBuilder quotedBuffer = new StringBuilder();\n//\t\tStringBuilder result = new StringBuilder();\n//\n//\t\tboolean hasMore = tokens.hasMoreTokens();\n//\t\tString nextToken = hasMore ? tokens.nextToken() : null;\n//\t\twhile ( hasMore ) {\n//\t\t\tString token = nextToken;\n//\t\t\tString lcToken = token.toLowerCase(Locale.ROOT);\n//\t\t\thasMore = tokens.hasMoreTokens();\n//\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n//\n//\t\t\t// First, determine quoting which might be based on either:\n//\t\t\t// \t\t1) back-tick\n//\t\t\t// \t\t2) single quote (ANSI SQL standard)\n//\t\t\t// \t\t3) or dialect defined quote character(s)\n//\t\t\tQuotingCharacterDisposition quotingCharacterDisposition = QuotingCharacterDisposition.NONE;\n//\t\t\tif ( \"`\".equals( token ) ) {\n//\t\t\t\tstate.quoted = !state.quoted;\n//\t\t\t\tquotingCharacterDisposition = state.quoted\n//\t\t\t\t\t\t? QuotingCharacterDisposition.OPEN\n//\t\t\t\t\t\t: QuotingCharacterDisposition.CLOSE;\n//\t\t\t\t// replace token with the appropriate dialect quoting char\n//\t\t\t\ttoken = lcToken = ( quotingCharacterDisposition == QuotingCharacterDisposition.OPEN )\n//\t\t\t\t\t\t? dialectOpenQuote\n//\t\t\t\t\t\t: dialectCloseQuote;\n//\t\t\t}\n//\t\t\telse if ( \"'\".equals( token ) ) {\n//\t\t\t\tstate.quoted = !state.quoted;\n//\t\t\t\tquotingCharacterDisposition = state.quoted\n//\t\t\t\t\t\t? QuotingCharacterDisposition.OPEN\n//\t\t\t\t\t\t: QuotingCharacterDisposition.CLOSE;\n//\t\t\t}\n//\t\t\telse if ( !state.quoted && dialectOpenQuote.equals( token ) ) {\n//\t\t\t\tstate.quoted = true;\n//\t\t\t\tquotingCharacterDisposition = QuotingCharacterDisposition.OPEN;\n//\t\t\t}\n//\t\t\telse if ( state.quoted && dialectCloseQuote.equals( token ) ) {\n//\t\t\t\tstate.quoted = false;\n//\t\t\t\tquotingCharacterDisposition = QuotingCharacterDisposition.CLOSE;\n//\t\t\t}\n//\n//\t\t\tif ( state.quoted ) {\n//\t\t\t\tquotedBuffer.append( token );\n//\t\t\t\tcontinue;\n//\t\t\t}\n//\n//\t\t\t// if we were previously processing quoted state and just encountered the close quote, then handle that\n//\t\t\t// quoted text\n//\t\t\tif ( quotingCharacterDisposition == QuotingCharacterDisposition.CLOSE ) {\n//\t\t\t\ttoken = quotedBuffer.toString();\n//\t\t\t\tquotedBuffer.setLength( 0 );\n//\t\t\t\tresult.append( placeholder ).append( '.' )\n//\t\t\t\t\t\t.append( dialectOpenQuote ).append( token ).append( dialectCloseQuote );\n//\t\t\t\tcontinue;\n//\t\t\t}\n//\n//\t\t\t// Special processing for ANSI SQL EXTRACT function\n//\t\t\tif ( \"extract\".equals( lcToken ) && \"(\".equals( nextToken ) ) {\n//\t\t\t\tfinal String field = extractUntil( tokens, \"from\" );\n//\t\t\t\tfinal String source = renderWhereStringTemplate(\n//\t\t\t\t\t\textractUntil( tokens, \")\" ),\n//\t\t\t\t\t\tplaceholder,\n//\t\t\t\t\t\tdialect,\n//\t\t\t\t\t\tfunctionRegistry\n//\t\t\t\t);\n//\t\t\t\tresult.append( \"extract(\" ).append( field ).append( \" from \" ).append( source ).append( ')' );\n//\n//\t\t\t\thasMore = tokens.hasMoreTokens();\n//\t\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n//\n//\t\t\t\tcontinue;\n//\t\t\t}\n//\n//\t\t\t// Special processing for ANSI SQL TRIM function\n//\t\t\tif ( \"trim\".equals( lcToken ) && \"(\".equals( nextToken ) ) {\n//\t\t\t\tList<String> operands = new ArrayList<String>();\n//\t\t\t\tStringBuilder builder = new StringBuilder();\n//\n//\t\t\t\tboolean hasMoreOperands = true;\n//\t\t\t\tString operandToken = tokens.nextToken();\n//\t\t\t\tboolean quoted = false;\n//\t\t\t\twhile ( hasMoreOperands ) {\n//\t\t\t\t\tfinal boolean isQuote = \"'\".equals( operandToken );\n//\t\t\t\t\tif ( isQuote ) {\n//\t\t\t\t\t\tquoted = !quoted;\n//\t\t\t\t\t\tif ( !quoted ) {\n//\t\t\t\t\t\t\toperands.add( builder.append( '\\'' ).toString() );\n//\t\t\t\t\t\t\tbuilder.setLength( 0 );\n//\t\t\t\t\t\t}\n//\t\t\t\t\t\telse {\n//\t\t\t\t\t\t\tbuilder.append( '\\'' );\n//\t\t\t\t\t\t}\n//\t\t\t\t\t}\n//\t\t\t\t\telse if ( quoted ) {\n//\t\t\t\t\t\tbuilder.append( operandToken );\n//\t\t\t\t\t}\n//\t\t\t\t\telse if ( operandToken.length() == 1 && Character.isWhitespace( operandToken.charAt( 0 ) ) ) {\n//\t\t\t\t\t\t// do nothing\n//\t\t\t\t\t}\n//\t\t\t\t\telse {\n//\t\t\t\t\t\toperands.add( operandToken );\n//\t\t\t\t\t}\n//\t\t\t\t\toperandToken = tokens.nextToken();\n//\t\t\t\t\thasMoreOperands = tokens.hasMoreTokens() && ! \")\".equals( operandToken );\n//\t\t\t\t}\n//\n//\t\t\t\tTrimOperands trimOperands = new TrimOperands( operands );\n//\t\t\t\tresult.append( \"trim(\" );\n//\t\t\t\tif ( trimOperands.trimSpec != null ) {\n//\t\t\t\t\tresult.append( trimOperands.trimSpec ).append( ' ' );\n//\t\t\t\t}\n//\t\t\t\tif ( trimOperands.trimChar != null ) {\n//\t\t\t\t\tif ( trimOperands.trimChar.startsWith( \"'\" ) && trimOperands.trimChar.endsWith( \"'\" ) ) {\n//\t\t\t\t\t\tresult.append( trimOperands.trimChar );\n//\t\t\t\t\t}\n//\t\t\t\t\telse {\n//\t\t\t\t\t\tresult.append(\n//\t\t\t\t\t\t\t\trenderWhereStringTemplate( trimOperands.trimSpec, placeholder, dialect, functionRegistry )\n//\t\t\t\t\t\t);\n//\t\t\t\t\t}\n//\t\t\t\t\tresult.append( ' ' );\n//\t\t\t\t}\n//\t\t\t\tif ( trimOperands.from != null ) {\n//\t\t\t\t\tresult.append( trimOperands.from ).append( ' ' );\n//\t\t\t\t}\n//\t\t\t\telse if ( trimOperands.trimSpec != null || trimOperands.trimChar != null ) {\n//\t\t\t\t\t// I think ANSI SQL says that the 'from' is not optional if either trim-spec or trim-char are specified\n//\t\t\t\t\tresult.append( \"from \" );\n//\t\t\t\t}\n//\n//\t\t\t\tresult.append( renderWhereStringTemplate( trimOperands.trimSource, placeholder, dialect, functionRegistry ) )\n//\t\t\t\t\t\t.append( ')' );\n//\n//\t\t\t\thasMore = tokens.hasMoreTokens();\n//\t\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n//\n//\t\t\t\tcontinue;\n//\t\t\t}\n//\n//\n//\t\t\t// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n//\n//\t\t\tif ( Character.isWhitespace( token.charAt( 0 ) ) ) {\n//\t\t\t\tresult.append( token );\n//\t\t\t}\n//\t\t\telse if ( state.beforeTable ) {\n//\t\t\t\tresult.append( token );\n//\t\t\t\tstate.beforeTable = false;\n//\t\t\t\tstate.afterFromTable = true;\n//\t\t\t}\n//\t\t\telse if ( state.afterFromTable ) {\n//\t\t\t\tif ( !\"as\".equals(lcToken) ) {\n//\t\t\t\t\tstate.afterFromTable = false;\n//\t\t\t\t}\n//\t\t\t\tresult.append(token);\n//\t\t\t}\n//\t\t\telse if ( isNamedParameter(token) ) {\n//\t\t\t\tresult.append(token);\n//\t\t\t}\n//\t\t\telse if ( isIdentifier(token, dialect)\n//\t\t\t\t\t&& !isFunctionOrKeyword(lcToken, nextToken, dialect , functionRegistry) ) {\n//\t\t\t\tresult.append(placeholder)\n//\t\t\t\t\t\t.append('.')\n//\t\t\t\t\t\t.append( dialect.quote(token) );\n//\t\t\t}\n//\t\t\telse {\n//\t\t\t\tif ( BEFORE_TABLE_KEYWORDS.contains(lcToken) ) {\n//\t\t\t\t\tstate.beforeTable = true;\n//\t\t\t\t\tstate.inFromClause = true;\n//\t\t\t\t}\n//\t\t\t\telse if ( state.inFromClause && \",\".equals(lcToken) ) {\n//\t\t\t\t\tstate.beforeTable = true;\n//\t\t\t\t}\n//\t\t\t\tresult.append(token);\n//\t\t\t}\n//\n//\t\t\t//Yuck:\n//\t\t\tif ( state.inFromClause\n//\t\t\t\t\t&& KEYWORDS.contains( lcToken ) //\"as\" is not in KEYWORDS\n//\t\t\t\t\t&& !BEFORE_TABLE_KEYWORDS.contains( lcToken ) ) {\n//\t\t\t\tstate.inFromClause = false;\n//\t\t\t}\n//\t\t}\n//\n//\t\treturn result.toString();\n//\t}\n//\n//\tprivate static class ProcessingState {\n//\t\tboolean quoted = false;\n//\t\tboolean quotedIdentifier = false;\n//\t\tboolean beforeTable = false;\n//\t\tboolean inFromClause = false;\n//\t\tboolean afterFromTable = false;\n//\t}\n//\n//\tprivate static enum QuotingCharacterDisposition { NONE, OPEN, CLOSE }\n\n\tprivate static class TrimOperands {\n\t\tprivate final String trimSpec;\n\t\tprivate final String trimChar;\n\t\tprivate final String from;\n\t\tprivate final String trimSource;\n\n\t\tprivate TrimOperands(List<String> operands) {\n\t\t\tfinal int size = operands.size();\n\t\t\tif ( size == 1 ) {\n\t\t\t\ttrimSpec = null;\n\t\t\t\ttrimChar = null;\n\t\t\t\tfrom = null;\n\t\t\t\ttrimSource = operands.get(0);\n\t\t\t}\n\t\t\telse if ( size == 4 ) {\n\t\t\t\ttrimSpec = operands.get(0);\n\t\t\t\ttrimChar = operands.get(1);\n\t\t\t\tfrom = operands.get(2);\n\t\t\t\ttrimSource = operands.get(3);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif ( size < 1 || size > 4 ) {\n\t\t\t\t\tthrow new HibernateException( \"Unexpected number of trim function operands : \" + size );\n\t\t\t\t}\n\n\t\t\t\t// trim-source will always be the last operand\n\t\t\t\ttrimSource = operands.get( size - 1 );\n\n\t\t\t\t// ANSI SQL says that more than one operand means that the FROM is required\n\t\t\t\tif ( ! \"from\".equals( operands.get( size - 2 ) ) ) {\n\t\t\t\t\tthrow new HibernateException( \"Expecting FROM, found : \" + operands.get( size - 2 ) );\n\t\t\t\t}\n\t\t\t\tfrom = operands.get( size - 2 );\n\n\t\t\t\t// trim-spec, if there is one will always be the first operand\n\t\t\t\tif ( \"leading\".equalsIgnoreCase( operands.get(0) )\n\t\t\t\t\t\t|| \"trailing\".equalsIgnoreCase( operands.get(0) )\n\t\t\t\t\t\t|| \"both\".equalsIgnoreCase( operands.get(0) ) ) {\n\t\t\t\t\ttrimSpec = operands.get(0);\n\t\t\t\t\ttrimChar = null;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ttrimSpec = null;\n\t\t\t\t\tif ( size - 2 == 0 ) {\n\t\t\t\t\t\ttrimChar = null;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\ttrimChar = operands.get( 0 );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate static String extractUntil(StringTokenizer tokens, String delimiter) {\n\t\tfinal StringBuilder valueBuilder = new StringBuilder();\n\t\tString token = tokens.nextToken();\n\t\twhile ( ! delimiter.equalsIgnoreCase( token ) ) {\n\t\t\tvalueBuilder.append( token );\n\t\t\ttoken = tokens.nextToken();\n\t\t}\n\t\treturn valueBuilder.toString().trim();\n\t}\n\n\tprivate static boolean isNamedParameter(String token) {\n\t\treturn token.startsWith( \":\" );\n\t}\n\n\tprivate static boolean isFunctionOrKeyword(\n\t\t\tString lcToken,\n\t\t\tString nextToken,\n\t\t\tDialect dialect,\n\t\t\tTypeConfiguration typeConfiguration,\n\t\t\tSqmFunctionRegistry functionRegistry) {\n\t\tif ( \"(\".equals( nextToken ) ) {\n\t\t\treturn true;\n\t\t}\n\t\telse if ( \"date\".equals( lcToken ) || \"time\".equals( lcToken ) ) {\n\t\t\t// these can be column names on some databases\n\t\t\t// TODO: treat 'current date' as a function\n\t\t\treturn false;\n\t\t}\n\t\telse {\n\t\t\treturn KEYWORDS.contains( lcToken )\n\t\t\t\t|| isType( lcToken, typeConfiguration )\n\t\t\t\t|| isFunction( lcToken, nextToken, functionRegistry )\n\t\t\t\t|| dialect.getKeywords().contains( lcToken )\n\t\t\t\t|| FUNCTION_KEYWORDS.contains( lcToken );\n\t\t}\n\t}\n\n\tprivate static boolean isType(String lcToken, TypeConfiguration typeConfiguration) {\n\t\treturn typeConfiguration.getDdlTypeRegistry().isTypeNameRegistered( lcToken );\n\t}\n\n\tprivate static boolean isFunction(String lcToken, String nextToken, SqmFunctionRegistry functionRegistry) {\n\t\t// checking for \"(\" is currently redundant because it is checked before getting here;\n\t\t// doing the check anyhow, in case that earlier check goes away;\n\t\tif ( \"(\".equals( nextToken ) ) {\n\t\t\treturn true;\n\t\t}\n\n\t\tfinal SqmFunctionDescriptor function = functionRegistry.findFunctionDescriptor( lcToken );\n\t\treturn function != null;\n\t}\n\n\tprivate static boolean isIdentifier(String token) {\n\t\tif ( isBoolean( token ) ) {\n\t\t\treturn false;\n\t\t}\n\t\treturn token.charAt( 0 ) == '`'\n\t\t\t|| ( //allow any identifier quoted with backtick\n\t\t\t\tisLetter( token.charAt( 0 ) ) && //only recognizes identifiers beginning with a letter\n\t\t\t\t\t\ttoken.indexOf( '.' ) < 0\n\t\t\t);\n\t}\n\n\tprivate static boolean isBoolean(String token) {\n\t\treturn \"true\".equals( token ) || \"false\".equals( token );\n\t}\n}\n",
        "diffSourceCodeSet": [
            "private static boolean isExtractFunction(String lcToken, String nextToken) {\n\t\treturn \"extract\".equals(lcToken) && \"(\".equals(nextToken);\n\t}"
        ],
        "invokedMethodSet": [
            "methodSignature: org.hibernate.sql.Template#extractUntil\n methodBody: private static String extractUntil(StringTokenizer tokens, String delimiter) {\nStringBuilder valueBuilder=new StringBuilder();\nString token=tokens.nextToken();\nwhile(!delimiter.equalsIgnoreCase(token)){valueBuilder.append(token);\ntoken=tokens.nextToken();\n}return valueBuilder.toString().trim();\n}",
            "methodSignature: org.hibernate.sql.Template#renderWhereStringTemplate\n methodBody: public static String renderWhereStringTemplate(\n\t\t\tString sqlWhereString,\n\t\t\tString placeholder,\n\t\t\tDialect dialect,\n\t\t\tTypeConfiguration typeConfiguration,\n\t\t\tSqmFunctionRegistry functionRegistry) {\nString symbols=PUNCTUATION + WHITESPACE + dialect.openQuote() + dialect.closeQuote();\nStringTokenizer tokens=new StringTokenizer(sqlWhereString,symbols,true);\nStringBuilder result=new StringBuilder();\nboolean quoted=false;\nboolean quotedIdentifier=false;\nboolean beforeTable=false;\nboolean inFromClause=false;\nboolean afterFromTable=false;\nboolean hasMore=tokens.hasMoreTokens();\nString nextToken=hasMore ? tokens.nextToken() : null;\nwhile(hasMore){String token=nextToken;\nString lcToken=token.toLowerCase(Locale.ROOT);\nhasMore=tokens.hasMoreTokens();\nnextToken=hasMore ? tokens.nextToken() : null;\nboolean isQuoteCharacter=false;\nif(!quotedIdentifier && \"'\".equals(token)){quoted=!quoted;\nisQuoteCharacter=true;\n}if(!quoted){boolean isOpenQuote;\nif(\"`\".equals(token)){isOpenQuote=!quotedIdentifier;\ntoken=lcToken=isOpenQuote ? Character.toString(dialect.openQuote()) : Character.toString(dialect.closeQuote());\nquotedIdentifier=isOpenQuote;\nisQuoteCharacter=true;\n}if(!quotedIdentifier && (dialect.openQuote() == token.charAt(0))){isOpenQuote=true;\nquotedIdentifier=true;\nisQuoteCharacter=true;\n}if(quotedIdentifier && (dialect.closeQuote() == token.charAt(0))){quotedIdentifier=false;\nisQuoteCharacter=true;\nisOpenQuote=false;\n}if(LITERAL_PREFIXES.contains(lcToken)){if(\"'\".equals(nextToken)){result.append(token);\ncontinue;\n}if(nextToken != null && Character.isWhitespace(nextToken.charAt(0))){final StringBuilder additionalTokens=new StringBuilder();\nTimeZoneTokens possibleNextToken=null;\ndo(nextToken != null && possibleNextToken.isToken(nextToken)){possibleNextToken=possibleNextToken == null ? TimeZoneTokens.getPossibleNextTokens(lcToken) : possibleNextToken.nextToken();\ndo(nextToken != null && Character.isWhitespace(nextToken.charAt(0))){additionalTokens.append(nextToken);\nhasMore=tokens.hasMoreTokens();\nnextToken=tokens.nextToken();\n}}if(\"'\".equals(nextToken)){result.append(token);\nresult.append(additionalTokens);\ncontinue;\n}{isOpenQuote=false;\n}}{isOpenQuote=false;\n}}{isOpenQuote=false;\n}if(isOpenQuote){result.append(placeholder).append('.');\n}}if(\"extract\".equals(lcToken) && \"(\".equals(nextToken)){final String field=extractUntil(tokens,\"from\");\nfinal String source=renderWhereStringTemplate(extractUntil(tokens,\")\"),placeholder,dialect,typeConfiguration,functionRegistry);\nresult.append(\"extract(\").append(field).append(\" from \").append(source).append(')');\nhasMore=tokens.hasMoreTokens();\nnextToken=hasMore ? tokens.nextToken() : null;\ncontinue;\n}if(\"trim\".equals(lcToken) && \"(\".equals(nextToken)){List<String> operands=new ArrayList<>();\nStringBuilder builder=new StringBuilder();\nboolean hasMoreOperands=true;\nString operandToken=tokens.nextToken();\nswitch(operandToken.toLowerCase(Locale.ROOT))case \"leading\":case \"trailing\":case \"both\":operands.add(operandToken);\nif(hasMoreOperands=tokens.hasMoreTokens()){operandToken=tokens.nextToken();\n}break;\nboolean quotedOperand=false;\nint parenthesis=0;\nwhile(hasMoreOperands){final boolean isQuote=\"'\".equals(operandToken);\nif(isQuote){quotedOperand=!quotedOperand;\nif(!quotedOperand){operands.add(builder.append('\\'').toString());\nbuilder.setLength(0);\n}{builder.append('\\'');\n}}if(quotedOperand){builder.append(operandToken);\n}if(parenthesis != 0){builder.append(operandToken);\nswitch(operandToken)case \"(\":parenthesis++;\nbreak;\ncase \")\":parenthesis--;\nbreak;\n}{builder.append(operandToken);\nswitch(operandToken.toLowerCase(Locale.ROOT))case \"(\":parenthesis++;\nbreak;\ncase \")\":parenthesis--;\nbreak;\ncase \"from\":if(builder.length() != 0){operands.add(builder.substring(0,builder.length() - 4));\nbuilder.setLength(0);\noperands.add(operandToken);\n}break;\n}operandToken=tokens.nextToken();\nhasMoreOperands=tokens.hasMoreTokens() && (parenthesis != 0 || !\")\".equals(operandToken));\n}if(builder.length() != 0){operands.add(builder.toString());\n}TrimOperands trimOperands=new TrimOperands(operands);\nresult.append(\"trim(\");\nif(trimOperands.trimSpec != null){result.append(trimOperands.trimSpec).append(' ');\n}if(trimOperands.trimChar != null){if(trimOperands.trimChar.startsWith(\"'\") && trimOperands.trimChar.endsWith(\"'\")){result.append(trimOperands.trimChar);\n}{result.append(renderWhereStringTemplate(trimOperands.trimSpec,placeholder,dialect,typeConfiguration,functionRegistry));\n}result.append(' ');\n}if(trimOperands.from != null){result.append(trimOperands.from).append(' ');\n}if(trimOperands.trimSpec != null || trimOperands.trimChar != null){result.append(\"from \");\n}result.append(renderWhereStringTemplate(trimOperands.trimSource,placeholder,dialect,typeConfiguration,functionRegistry)).append(')');\nhasMore=tokens.hasMoreTokens();\nnextToken=hasMore ? tokens.nextToken() : null;\ncontinue;\n}boolean quotedOrWhitespace=quoted || quotedIdentifier || isQuoteCharacter || Character.isWhitespace(token.charAt(0));\nif(quotedOrWhitespace){result.append(token);\n}if(beforeTable){result.append(token);\nbeforeTable=false;\nafterFromTable=true;\n}if(afterFromTable){if(!\"as\".equals(lcToken)){afterFromTable=false;\n}result.append(token);\n}if(isNamedParameter(token)){result.append(token);\n}if(isIdentifier(token) && !isFunctionOrKeyword(lcToken,nextToken,dialect,typeConfiguration,functionRegistry)){result.append(placeholder).append('.').append(dialect.quote(token));\n}{if(BEFORE_TABLE_KEYWORDS.contains(lcToken)){beforeTable=true;\ninFromClause=true;\n}if(inFromClause && \",\".equals(lcToken)){beforeTable=true;\n}if(isBoolean(token)){token=dialect.toBooleanValueString(Boolean.parseBoolean(token));\n}result.append(token);\n}if(inFromClause && KEYWORDS.contains(lcToken) && !BEFORE_TABLE_KEYWORDS.contains(lcToken)){inFromClause=false;\n}}return result.toString();\n}",
            "methodSignature: org.hibernate.sql.Template.TimeZoneTokens#isToken\n methodBody: public boolean isToken(String token) {\nreturn this != NONE && name().equalsIgnoreCase(token);\n}",
            "methodSignature: org.hibernate.sql.Template#isBoolean\n methodBody: private static boolean isBoolean(String token) {\nreturn \"true\".equals(token) || \"false\".equals(token);\n}",
            "methodSignature: org.hibernate.sql.Template.TimeZoneTokens#nextToken\n methodBody: public TimeZoneTokens nextToken() {\nif(this == WITH){return TIME;\n}if(this == TIME){return ZONE;\n}{return NONE;\n}}",
            "methodSignature: org.hibernate.sql.Template.TimeZoneTokens#getPossibleNextTokens\n methodBody: static TimeZoneTokens getPossibleNextTokens(String lctoken) {\nswitch(lctoken)case \"time\":case \"timestamp\":return WITH;\ndefault:return NONE;\n}",
            "methodSignature: org.hibernate.sql.Template#isIdentifier\n methodBody: private static boolean isIdentifier(String token) {\nif(isBoolean(token)){return false;\n}return token.charAt(0) == '`' || (Character.isLetter(token.charAt(0)) && token.indexOf('.') < 0);\n}",
            "methodSignature: org.hibernate.sql.Template#isNamedParameter\n methodBody: private static boolean isNamedParameter(String token) {\nreturn token.startsWith(\":\");\n}",
            "methodSignature: org.hibernate.sql.Template#isFunctionOrKeyword\n methodBody: private static boolean isFunctionOrKeyword(\n\t\t\tString lcToken,\n\t\t\tString nextToken,\n\t\t\tDialect dialect,\n\t\t\tTypeConfiguration typeConfiguration,\n\t\t\tSqmFunctionRegistry functionRegistry) {\nreturn \"(\".equals(nextToken) || KEYWORDS.contains(lcToken) || isType(lcToken,typeConfiguration) || isFunction(lcToken,nextToken,functionRegistry) || dialect.getKeywords().contains(lcToken) || FUNCTION_KEYWORDS.contains(lcToken);\n}"
        ],
        "sourceCodeAfterRefactoring": "/**\n\t * Takes the where condition provided in the mapping attribute and interpolates the alias.\n\t * Handles sub-selects, quoted identifiers, quoted strings, expressions, SQL functions,\n\t * named parameters.\n\t *\n\t * @param sqlWhereString The string into which to interpolate the placeholder value\n\t * @param placeholder The value to be interpolated into the sqlWhereString\n\t * @param dialect The dialect to apply\n\t * @param functionRegistry The registry of all sql functions\n\t * @return The rendered sql fragment\n\t */\n\tpublic static String renderWhereStringTemplate(\n\t\t\tString sqlWhereString,\n\t\t\tString placeholder,\n\t\t\tDialect dialect,\n\t\t\tTypeConfiguration typeConfiguration,\n\t\t\tSqmFunctionRegistry functionRegistry) {\n\n\t\t// IMPL NOTE : The basic process here is to tokenize the incoming string and to iterate over each token\n\t\t//\t\tin turn.  As we process each token, we set a series of flags used to indicate the type of context in\n\t\t// \t\twhich the tokens occur.  Depending on the state of those flags we decide whether we need to qualify\n\t\t//\t\tidentifier references.\n\n\t\tfinal String symbols = PUNCTUATION + WHITESPACE + dialect.openQuote() + dialect.closeQuote();\n\t\tfinal StringTokenizer tokens = new StringTokenizer( sqlWhereString, symbols, true );\n\t\tfinal StringBuilder result = new StringBuilder();\n\n\t\tboolean quoted = false;\n\t\tboolean quotedIdentifier = false;\n\t\tboolean beforeTable = false;\n\t\tboolean inFromClause = false;\n\t\tboolean afterFromTable = false;\n\n\t\tboolean hasMore = tokens.hasMoreTokens();\n\t\tString nextToken = hasMore ? tokens.nextToken() : null;\n\t\twhile ( hasMore ) {\n\t\t\tString token = nextToken;\n\t\t\tString lcToken = token.toLowerCase(Locale.ROOT);\n\t\t\thasMore = tokens.hasMoreTokens();\n\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n\n\t\t\tboolean isQuoteCharacter = false;\n\n\t\t\tif ( !quotedIdentifier && \"'\".equals(token) ) {\n\t\t\t\tquoted = !quoted;\n\t\t\t\tisQuoteCharacter = true;\n\t\t\t}\n\n\t\t\tif ( !quoted ) {\n\t\t\t\tfinal boolean isOpenQuote;\n\t\t\t\tif ( \"`\".equals(token) ) {\n\t\t\t\t\tisOpenQuote = !quotedIdentifier;\n\t\t\t\t\ttoken = lcToken = isOpenQuote\n\t\t\t\t\t\t\t? Character.toString( dialect.openQuote() )\n\t\t\t\t\t\t\t: Character.toString( dialect.closeQuote() );\n\t\t\t\t\tquotedIdentifier = isOpenQuote;\n\t\t\t\t\tisQuoteCharacter = true;\n\t\t\t\t}\n\t\t\t\telse if ( !quotedIdentifier && dialect.openQuote()==token.charAt(0) ) {\n\t\t\t\t\tisOpenQuote = true;\n\t\t\t\t\tquotedIdentifier = true;\n\t\t\t\t\tisQuoteCharacter = true;\n\t\t\t\t}\n\t\t\t\telse if ( quotedIdentifier && dialect.closeQuote()==token.charAt(0) ) {\n\t\t\t\t\tquotedIdentifier = false;\n\t\t\t\t\tisQuoteCharacter = true;\n\t\t\t\t\tisOpenQuote = false;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tisOpenQuote = false;\n\t\t\t\t}\n\t\t\t\tif ( isOpenQuote ) {\n\t\t\t\t\tresult.append( placeholder ).append( '.' );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfinal boolean quotedOrWhitespace =\n\t\t\t\t\tquoted || quotedIdentifier || isQuoteCharacter\n\t\t\t\t\t\t\t|| token.isBlank();\n\t\t\tif ( quotedOrWhitespace ) {\n\t\t\t\tresult.append( token );\n\t\t\t}\n\t\t\telse if ( beforeTable ) {\n\t\t\t\tresult.append( token );\n\t\t\t\tbeforeTable = false;\n\t\t\t\tafterFromTable = true;\n\t\t\t}\n\t\t\telse if ( afterFromTable ) {\n\t\t\t\tif ( !\"as\".equals(lcToken) ) {\n\t\t\t\t\tafterFromTable = false;\n\t\t\t\t}\n\t\t\t\tresult.append(token);\n\t\t\t}\n\t\t\telse if ( isNamedParameter(token) ) {\n\t\t\t\tresult.append(token);\n\t\t\t}\n\t\t\telse if ( isExtractFunction( lcToken, nextToken ) ) {\n\t\t\t\t// Special processing for ANSI SQL EXTRACT function\n\t\t\t\thandleExtractFunction( placeholder, dialect, typeConfiguration, functionRegistry, tokens, result );\n\t\t\t\thasMore = tokens.hasMoreTokens();\n\t\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n\t\t\t}\n\t\t\telse if ( isTrimFunction( lcToken, nextToken ) ) {\n\t\t\t\t// Special processing for ANSI SQL TRIM function\n\t\t\t\thandleTrimFunction( placeholder, dialect, typeConfiguration, functionRegistry, tokens, result );\n\t\t\t\thasMore = tokens.hasMoreTokens();\n\t\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n\t\t\t}\n\t\t\telse if ( isIdentifier(token)\n\t\t\t\t\t&& !isFunctionOrKeyword( lcToken, nextToken, dialect, typeConfiguration, functionRegistry )\n\t\t\t\t\t&& !isLiteral( lcToken, nextToken, sqlWhereString, symbols, tokens ) ) {\n\t\t\t\tresult.append(placeholder)\n\t\t\t\t\t\t.append('.')\n\t\t\t\t\t\t.append( dialect.quote(token) );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif ( BEFORE_TABLE_KEYWORDS.contains(lcToken) ) {\n\t\t\t\t\tbeforeTable = true;\n\t\t\t\t\tinFromClause = true;\n\t\t\t\t}\n\t\t\t\telse if ( inFromClause && \",\".equals(lcToken) ) {\n\t\t\t\t\tbeforeTable = true;\n\t\t\t\t}\n\t\t\t\tif ( isBoolean( token ) ) {\n\t\t\t\t\ttoken = dialect.toBooleanValueString( parseBoolean( token ) );\n\t\t\t\t}\n\t\t\t\tresult.append(token);\n\t\t\t}\n\n\t\t\t//Yuck:\n\t\t\tif ( inFromClause\n\t\t\t\t\t&& KEYWORDS.contains( lcToken ) //\"as\" is not in KEYWORDS\n\t\t\t\t\t&& !BEFORE_TABLE_KEYWORDS.contains( lcToken ) ) {\n\t\t\t\tinFromClause = false;\n\t\t\t}\n\t\t}\n\n\t\treturn result.toString();\n\t}\nprivate static boolean isExtractFunction(String lcToken, String nextToken) {\n\t\treturn \"extract\".equals(lcToken) && \"(\".equals(nextToken);\n\t}",
        "diffSourceCode": "-  119: \t/**\n-  120: \t * Takes the where condition provided in the mapping attribute and interpolates the alias.\n-  121: \t * Handles sub-selects, quoted identifiers, quoted strings, expressions, SQL functions,\n-  122: \t * named parameters.\n-  123: \t *\n-  124: \t * @param sqlWhereString The string into which to interpolate the placeholder value\n-  125: \t * @param placeholder The value to be interpolated into the sqlWhereString\n-  126: \t * @param dialect The dialect to apply\n-  127: \t * @param functionRegistry The registry of all sql functions\n-  128: \t * @return The rendered sql fragment\n-  129: \t */\n-  130: \tpublic static String renderWhereStringTemplate(\n-  131: \t\t\tString sqlWhereString,\n-  132: \t\t\tString placeholder,\n-  133: \t\t\tDialect dialect,\n-  134: \t\t\tTypeConfiguration typeConfiguration,\n-  135: \t\t\tSqmFunctionRegistry functionRegistry) {\n-  136: \n-  137: \t\t// IMPL NOTE : The basic process here is to tokenize the incoming string and to iterate over each token\n-  138: \t\t//\t\tin turn.  As we process each token, we set a series of flags used to indicate the type of context in\n-  139: \t\t// \t\twhich the tokens occur.  Depending on the state of those flags we decide whether we need to qualify\n-  140: \t\t//\t\tidentifier references.\n-  141: \n-  142: \t\tString symbols = PUNCTUATION +\n-  143: \t\t\t\tWHITESPACE +\n-  144: \t\t\t\tdialect.openQuote() +\n-  145: \t\t\t\tdialect.closeQuote();\n-  146: \t\tStringTokenizer tokens = new StringTokenizer( sqlWhereString, symbols, true );\n-  147: \t\tStringBuilder result = new StringBuilder();\n+  119: \t\treturn renderWhereStringTemplate( sqlWhereString, TEMPLATE, dialect, typeConfiguration, functionRegistry );\n+  120: \t}\n+  121: \n+  122: \t/**\n+  123: \t * Takes the where condition provided in the mapping attribute and interpolates the alias.\n+  124: \t * Handles sub-selects, quoted identifiers, quoted strings, expressions, SQL functions,\n+  125: \t * named parameters.\n+  126: \t *\n+  127: \t * @param sqlWhereString The string into which to interpolate the placeholder value\n+  128: \t * @param placeholder The value to be interpolated into the sqlWhereString\n+  129: \t * @param dialect The dialect to apply\n+  130: \t * @param functionRegistry The registry of all sql functions\n+  131: \t * @return The rendered sql fragment\n+  132: \t */\n+  133: \tpublic static String renderWhereStringTemplate(\n+  134: \t\t\tString sqlWhereString,\n+  135: \t\t\tString placeholder,\n+  136: \t\t\tDialect dialect,\n+  137: \t\t\tTypeConfiguration typeConfiguration,\n+  138: \t\t\tSqmFunctionRegistry functionRegistry) {\n+  139: \n+  140: \t\t// IMPL NOTE : The basic process here is to tokenize the incoming string and to iterate over each token\n+  141: \t\t//\t\tin turn.  As we process each token, we set a series of flags used to indicate the type of context in\n+  142: \t\t// \t\twhich the tokens occur.  Depending on the state of those flags we decide whether we need to qualify\n+  143: \t\t//\t\tidentifier references.\n+  144: \n+  145: \t\tfinal String symbols = PUNCTUATION + WHITESPACE + dialect.openQuote() + dialect.closeQuote();\n+  146: \t\tfinal StringTokenizer tokens = new StringTokenizer( sqlWhereString, symbols, true );\n+  147: \t\tfinal StringBuilder result = new StringBuilder();\n   148: \n   149: \t\tboolean quoted = false;\n   150: \t\tboolean quotedIdentifier = false;\n   151: \t\tboolean beforeTable = false;\n   152: \t\tboolean inFromClause = false;\n   153: \t\tboolean afterFromTable = false;\n   154: \n   155: \t\tboolean hasMore = tokens.hasMoreTokens();\n   156: \t\tString nextToken = hasMore ? tokens.nextToken() : null;\n   157: \t\twhile ( hasMore ) {\n   158: \t\t\tString token = nextToken;\n   159: \t\t\tString lcToken = token.toLowerCase(Locale.ROOT);\n   160: \t\t\thasMore = tokens.hasMoreTokens();\n   161: \t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n   162: \n   163: \t\t\tboolean isQuoteCharacter = false;\n   164: \n   165: \t\t\tif ( !quotedIdentifier && \"'\".equals(token) ) {\n   166: \t\t\t\tquoted = !quoted;\n   167: \t\t\t\tisQuoteCharacter = true;\n   168: \t\t\t}\n   169: \n   170: \t\t\tif ( !quoted ) {\n-  171: \t\t\t\tboolean isOpenQuote;\n+  171: \t\t\t\tfinal boolean isOpenQuote;\n   172: \t\t\t\tif ( \"`\".equals(token) ) {\n   173: \t\t\t\t\tisOpenQuote = !quotedIdentifier;\n   174: \t\t\t\t\ttoken = lcToken = isOpenQuote\n   175: \t\t\t\t\t\t\t? Character.toString( dialect.openQuote() )\n   176: \t\t\t\t\t\t\t: Character.toString( dialect.closeQuote() );\n   177: \t\t\t\t\tquotedIdentifier = isOpenQuote;\n   178: \t\t\t\t\tisQuoteCharacter = true;\n   179: \t\t\t\t}\n-  180: \t\t\t\telse if ( !quotedIdentifier && ( dialect.openQuote()==token.charAt(0) ) ) {\n+  180: \t\t\t\telse if ( !quotedIdentifier && dialect.openQuote()==token.charAt(0) ) {\n   181: \t\t\t\t\tisOpenQuote = true;\n   182: \t\t\t\t\tquotedIdentifier = true;\n   183: \t\t\t\t\tisQuoteCharacter = true;\n   184: \t\t\t\t}\n-  185: \t\t\t\telse if ( quotedIdentifier && ( dialect.closeQuote()==token.charAt(0) ) ) {\n+  185: \t\t\t\telse if ( quotedIdentifier && dialect.closeQuote()==token.charAt(0) ) {\n   186: \t\t\t\t\tquotedIdentifier = false;\n   187: \t\t\t\t\tisQuoteCharacter = true;\n   188: \t\t\t\t\tisOpenQuote = false;\n   189: \t\t\t\t}\n-  190: \t\t\t\telse if ( LITERAL_PREFIXES.contains( lcToken ) ) {\n-  191: \t\t\t\t\tif ( \"'\".equals( nextToken ) ) {\n-  192: \t\t\t\t\t\t// Don't prefix a literal\n-  193: \t\t\t\t\t\tresult.append( token );\n-  194: \t\t\t\t\t\tcontinue;\n-  195: \t\t\t\t\t}\n-  196: \t\t\t\t\telse if ( nextToken != null && Character.isWhitespace( nextToken.charAt( 0 ) ) ) {\n-  197: \t\t\t\t\t\tfinal StringBuilder additionalTokens = new StringBuilder();\n-  198: \t\t\t\t\t\tTimeZoneTokens possibleNextToken = null;\n-  199: \t\t\t\t\t\tdo {\n-  200: \t\t\t\t\t\t\tpossibleNextToken = possibleNextToken == null\n-  201: \t\t\t\t\t\t\t\t\t? TimeZoneTokens.getPossibleNextTokens( lcToken )\n-  202: \t\t\t\t\t\t\t\t\t: possibleNextToken.nextToken();\n-  203: \t\t\t\t\t\t\tdo {\n-  204: \t\t\t\t\t\t\t\tadditionalTokens.append( nextToken );\n-  205: \t\t\t\t\t\t\t\thasMore = tokens.hasMoreTokens();\n-  206: \t\t\t\t\t\t\t\tnextToken = tokens.nextToken();\n-  207: \t\t\t\t\t\t\t} while ( nextToken != null && Character.isWhitespace( nextToken.charAt( 0 ) ) );\n-  208: \t\t\t\t\t\t} while ( nextToken != null && possibleNextToken.isToken( nextToken ) );\n-  209: \t\t\t\t\t\tif ( \"'\".equals( nextToken ) ) {\n-  210: \t\t\t\t\t\t\t// Don't prefix a literal\n-  211: \t\t\t\t\t\t\tresult.append( token );\n-  212: \t\t\t\t\t\t\tresult.append( additionalTokens );\n-  213: \t\t\t\t\t\t\tcontinue;\n-  214: \t\t\t\t\t\t}\n-  215: \t\t\t\t\t\telse {\n-  216: \t\t\t\t\t\t\tisOpenQuote = false;\n-  217: \t\t\t\t\t\t}\n-  218: \t\t\t\t\t}\n-  219: \t\t\t\t\telse {\n-  220: \t\t\t\t\t\tisOpenQuote = false;\n-  221: \t\t\t\t\t}\n-  222: \t\t\t\t}\n-  223: \t\t\t\telse {\n-  224: \t\t\t\t\tisOpenQuote = false;\n-  225: \t\t\t\t}\n-  226: \n-  227: \t\t\t\tif ( isOpenQuote ) {\n-  228: \t\t\t\t\tresult.append( placeholder ).append( '.' );\n-  229: \t\t\t\t}\n-  230: \t\t\t}\n-  231: \n-  232: \t\t\t// Special processing for ANSI SQL EXTRACT function\n-  233: \t\t\tif ( \"extract\".equals( lcToken ) && \"(\".equals( nextToken ) ) {\n-  234: \t\t\t\tfinal String field = extractUntil( tokens, \"from\" );\n-  235: \t\t\t\tfinal String source = renderWhereStringTemplate(\n-  236: \t\t\t\t\t\textractUntil( tokens, \")\" ),\n-  237: \t\t\t\t\t\tplaceholder,\n-  238: \t\t\t\t\t\tdialect,\n-  239: \t\t\t\t\t\ttypeConfiguration,\n-  240: \t\t\t\t\t\tfunctionRegistry\n-  241: \t\t\t\t);\n-  242: \t\t\t\tresult.append( \"extract(\" ).append( field ).append( \" from \" ).append( source ).append( ')' );\n-  243: \n-  244: \t\t\t\thasMore = tokens.hasMoreTokens();\n-  245: \t\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n-  246: \n-  247: \t\t\t\tcontinue;\n-  248: \t\t\t}\n-  249: \n-  250: \t\t\t// Special processing for ANSI SQL TRIM function\n-  251: \t\t\tif ( \"trim\".equals( lcToken ) && \"(\".equals( nextToken ) ) {\n-  252: \t\t\t\tList<String> operands = new ArrayList<>();\n-  253: \t\t\t\tStringBuilder builder = new StringBuilder();\n-  254: \n-  255: \t\t\t\tboolean hasMoreOperands = true;\n-  256: \t\t\t\tString operandToken = tokens.nextToken();\n-  257: \t\t\t\tswitch ( operandToken.toLowerCase( Locale.ROOT ) ) {\n-  258: \t\t\t\t\tcase \"leading\":\n-  259: \t\t\t\t\tcase \"trailing\":\n-  260: \t\t\t\t\tcase \"both\":\n-  261: \t\t\t\t\t\toperands.add( operandToken );\n-  262: \t\t\t\t\t\tif ( hasMoreOperands = tokens.hasMoreTokens() ) {\n-  263: \t\t\t\t\t\t\toperandToken = tokens.nextToken();\n-  264: \t\t\t\t\t\t}\n-  265: \t\t\t\t\t\tbreak;\n-  266: \t\t\t\t}\n-  267: \t\t\t\tboolean quotedOperand = false;\n-  268: \t\t\t\tint parenthesis = 0;\n-  269: \t\t\t\twhile ( hasMoreOperands ) {\n-  270: \t\t\t\t\tfinal boolean isQuote = \"'\".equals( operandToken );\n-  271: \t\t\t\t\tif ( isQuote ) {\n-  272: \t\t\t\t\t\tquotedOperand = !quotedOperand;\n-  273: \t\t\t\t\t\tif ( !quotedOperand ) {\n-  274: \t\t\t\t\t\t\toperands.add( builder.append( '\\'' ).toString() );\n-  275: \t\t\t\t\t\t\tbuilder.setLength( 0 );\n-  276: \t\t\t\t\t\t}\n-  277: \t\t\t\t\t\telse {\n-  278: \t\t\t\t\t\t\tbuilder.append( '\\'' );\n-  279: \t\t\t\t\t\t}\n-  280: \t\t\t\t\t}\n-  281: \t\t\t\t\telse if ( quotedOperand ) {\n-  282: \t\t\t\t\t\tbuilder.append( operandToken );\n-  283: \t\t\t\t\t}\n-  284: \t\t\t\t\telse if ( parenthesis != 0 ) {\n-  285: \t\t\t\t\t\tbuilder.append( operandToken );\n-  286: \t\t\t\t\t\tswitch ( operandToken ) {\n-  287: \t\t\t\t\t\t\tcase \"(\":\n-  288: \t\t\t\t\t\t\t\tparenthesis++;\n-  289: \t\t\t\t\t\t\t\tbreak;\n-  290: \t\t\t\t\t\t\tcase \")\":\n-  291: \t\t\t\t\t\t\t\tparenthesis--;\n-  292: \t\t\t\t\t\t\t\tbreak;\n-  293: \t\t\t\t\t\t}\n-  294: \t\t\t\t\t}\n-  295: \t\t\t\t\telse {\n-  296: \t\t\t\t\t\tbuilder.append( operandToken );\n-  297: \t\t\t\t\t\tswitch ( operandToken.toLowerCase( Locale.ROOT ) ) {\n-  298: \t\t\t\t\t\t\tcase \"(\":\n-  299: \t\t\t\t\t\t\t\tparenthesis++;\n-  300: \t\t\t\t\t\t\t\tbreak;\n-  301: \t\t\t\t\t\t\tcase \")\":\n-  302: \t\t\t\t\t\t\t\tparenthesis--;\n-  303: \t\t\t\t\t\t\t\tbreak;\n-  304: \t\t\t\t\t\t\tcase \"from\":\n-  305: \t\t\t\t\t\t\t\tif ( builder.length() != 0 ) {\n-  306: \t\t\t\t\t\t\t\t\toperands.add( builder.substring( 0, builder.length() - 4 ) );\n-  307: \t\t\t\t\t\t\t\t\tbuilder.setLength( 0 );\n-  308: \t\t\t\t\t\t\t\t\toperands.add( operandToken );\n-  309: \t\t\t\t\t\t\t\t}\n-  310: \t\t\t\t\t\t\t\tbreak;\n-  311: \t\t\t\t\t\t}\n-  312: \t\t\t\t\t}\n-  313: \t\t\t\t\toperandToken = tokens.nextToken();\n-  314: \t\t\t\t\thasMoreOperands = tokens.hasMoreTokens() && ( parenthesis != 0 || ! \")\".equals( operandToken ) );\n-  315: \t\t\t\t}\n-  316: \t\t\t\tif ( builder.length() != 0 ) {\n-  317: \t\t\t\t\toperands.add( builder.toString() );\n-  318: \t\t\t\t}\n-  319: \n-  320: \t\t\t\tTrimOperands trimOperands = new TrimOperands( operands );\n-  321: \t\t\t\tresult.append( \"trim(\" );\n-  322: \t\t\t\tif ( trimOperands.trimSpec != null ) {\n-  323: \t\t\t\t\tresult.append( trimOperands.trimSpec ).append( ' ' );\n-  324: \t\t\t\t}\n-  325: \t\t\t\tif ( trimOperands.trimChar != null ) {\n-  326: \t\t\t\t\tif ( trimOperands.trimChar.startsWith( \"'\" ) && trimOperands.trimChar.endsWith( \"'\" ) ) {\n-  327: \t\t\t\t\t\tresult.append( trimOperands.trimChar );\n-  328: \t\t\t\t\t}\n-  329: \t\t\t\t\telse {\n-  330: \t\t\t\t\t\tresult.append(\n-  331: \t\t\t\t\t\t\t\trenderWhereStringTemplate( trimOperands.trimSpec, placeholder, dialect, typeConfiguration, functionRegistry )\n-  332: \t\t\t\t\t\t);\n-  333: \t\t\t\t\t}\n-  334: \t\t\t\t\tresult.append( ' ' );\n-  335: \t\t\t\t}\n-  336: \t\t\t\tif ( trimOperands.from != null ) {\n-  337: \t\t\t\t\tresult.append( trimOperands.from ).append( ' ' );\n-  338: \t\t\t\t}\n-  339: \t\t\t\telse if ( trimOperands.trimSpec != null || trimOperands.trimChar != null ) {\n-  340: \t\t\t\t\t// I think ANSI SQL says that the 'from' is not optional if either trim-spec or trim-char is specified\n-  341: \t\t\t\t\tresult.append( \"from \" );\n-  342: \t\t\t\t}\n-  343: \n-  344: \t\t\t\tresult.append( renderWhereStringTemplate( trimOperands.trimSource, placeholder, dialect, typeConfiguration, functionRegistry ) )\n-  345: \t\t\t\t\t\t.append( ')' );\n-  346: \n-  347: \t\t\t\thasMore = tokens.hasMoreTokens();\n-  348: \t\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n-  349: \n-  350: \t\t\t\tcontinue;\n-  351: \t\t\t}\n-  352: \n-  353: \t\t\tboolean quotedOrWhitespace = quoted || quotedIdentifier || isQuoteCharacter\n-  354: \t\t\t\t\t|| Character.isWhitespace( token.charAt(0) );\n-  355: \n-  356: \t\t\tif ( quotedOrWhitespace ) {\n-  357: \t\t\t\tresult.append( token );\n+  190: \t\t\t\telse {\n+  191: \t\t\t\t\tisOpenQuote = false;\n+  192: \t\t\t\t}\n+  193: \t\t\t\tif ( isOpenQuote ) {\n+  194: \t\t\t\t\tresult.append( placeholder ).append( '.' );\n+  195: \t\t\t\t}\n+  196: \t\t\t}\n+  197: \n+  198: \t\t\tfinal boolean quotedOrWhitespace =\n+  199: \t\t\t\t\tquoted || quotedIdentifier || isQuoteCharacter\n+  200: \t\t\t\t\t\t\t|| token.isBlank();\n+  201: \t\t\tif ( quotedOrWhitespace ) {\n+  202: \t\t\t\tresult.append( token );\n+  203: \t\t\t}\n+  204: \t\t\telse if ( beforeTable ) {\n+  205: \t\t\t\tresult.append( token );\n+  206: \t\t\t\tbeforeTable = false;\n+  207: \t\t\t\tafterFromTable = true;\n+  208: \t\t\t}\n+  209: \t\t\telse if ( afterFromTable ) {\n+  210: \t\t\t\tif ( !\"as\".equals(lcToken) ) {\n+  211: \t\t\t\t\tafterFromTable = false;\n+  212: \t\t\t\t}\n+  213: \t\t\t\tresult.append(token);\n+  214: \t\t\t}\n+  215: \t\t\telse if ( isNamedParameter(token) ) {\n+  216: \t\t\t\tresult.append(token);\n+  217: \t\t\t}\n+  218: \t\t\telse if ( isExtractFunction( lcToken, nextToken ) ) {\n+  219: \t\t\t\t// Special processing for ANSI SQL EXTRACT function\n+  220: \t\t\t\thandleExtractFunction( placeholder, dialect, typeConfiguration, functionRegistry, tokens, result );\n+  221: \t\t\t\thasMore = tokens.hasMoreTokens();\n+  222: \t\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n+  223: \t\t\t}\n+  224: \t\t\telse if ( isTrimFunction( lcToken, nextToken ) ) {\n+  225: \t\t\t\t// Special processing for ANSI SQL TRIM function\n+  226: \t\t\t\thandleTrimFunction( placeholder, dialect, typeConfiguration, functionRegistry, tokens, result );\n+  227: \t\t\t\thasMore = tokens.hasMoreTokens();\n+  228: \t\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n+  229: \t\t\t}\n+  230: \t\t\telse if ( isIdentifier(token)\n+  231: \t\t\t\t\t&& !isFunctionOrKeyword( lcToken, nextToken, dialect, typeConfiguration, functionRegistry )\n+  232: \t\t\t\t\t&& !isLiteral( lcToken, nextToken, sqlWhereString, symbols, tokens ) ) {\n+  233: \t\t\t\tresult.append(placeholder)\n+  234: \t\t\t\t\t\t.append('.')\n+  235: \t\t\t\t\t\t.append( dialect.quote(token) );\n+  236: \t\t\t}\n+  237: \t\t\telse {\n+  238: \t\t\t\tif ( BEFORE_TABLE_KEYWORDS.contains(lcToken) ) {\n+  239: \t\t\t\t\tbeforeTable = true;\n+  240: \t\t\t\t\tinFromClause = true;\n+  241: \t\t\t\t}\n+  242: \t\t\t\telse if ( inFromClause && \",\".equals(lcToken) ) {\n+  243: \t\t\t\t\tbeforeTable = true;\n+  244: \t\t\t\t}\n+  245: \t\t\t\tif ( isBoolean( token ) ) {\n+  246: \t\t\t\t\ttoken = dialect.toBooleanValueString( parseBoolean( token ) );\n+  247: \t\t\t\t}\n+  248: \t\t\t\tresult.append(token);\n+  249: \t\t\t}\n+  250: \n+  251: \t\t\t//Yuck:\n+  252: \t\t\tif ( inFromClause\n+  253: \t\t\t\t\t&& KEYWORDS.contains( lcToken ) //\"as\" is not in KEYWORDS\n+  254: \t\t\t\t\t&& !BEFORE_TABLE_KEYWORDS.contains( lcToken ) ) {\n+  255: \t\t\t\tinFromClause = false;\n+  256: \t\t\t}\n+  257: \t\t}\n+  258: \n+  259: \t\treturn result.toString();\n+  260: \t}\n+  261: \n+  262: \tprivate static boolean isTrimFunction(String lcToken, String nextToken) {\n+  263: \t\treturn \"trim\".equals(lcToken) && \"(\".equals(nextToken);\n+  264: \t}\n+  265: \n+  266: \tprivate static boolean isExtractFunction(String lcToken, String nextToken) {\n+  267: \t\treturn \"extract\".equals(lcToken) && \"(\".equals(nextToken);\n+  268: \t}\n+  269: \n+  270: \tprivate static boolean isLiteral(\n+  271: \t\t\tString lcToken, String next,\n+  272: \t\t\tString sqlWhereString, String symbols, StringTokenizer tokens) {\n+  273: \t\tif ( LITERAL_PREFIXES.contains( lcToken ) && next != null ) {\n+  274: \t\t\t// easy cases first\n+  275: \t\t\tif ( \"'\".equals(next) ) {\n+  276: \t\t\t\treturn true;\n+  277: \t\t\t}\n+  278: \t\t\telse if ( !next.isBlank() ) {\n+  279: \t\t\t\treturn false;\n+  280: \t\t\t}\n+  281: \t\t\telse {\n+  282: \t\t\t\t// we need to look ahead in the token stream\n+  283: \t\t\t\t// to find the first non-blank token\n+  284: \t\t\t\tfinal StringTokenizer lookahead =\n+  285: \t\t\t\t\t\tnew StringTokenizer( sqlWhereString, symbols, true );\n+  286: \t\t\t\twhile ( lookahead.countTokens() > tokens.countTokens()+1 ) {\n+  287: \t\t\t\t\tlookahead.nextToken();\n+  288: \t\t\t\t}\n+  289: \t\t\t\tif ( lookahead.hasMoreTokens() ) {\n+  290: \t\t\t\t\tString nextToken;\n+  291: \t\t\t\t\tdo {\n+  292: \t\t\t\t\t\tnextToken = lookahead.nextToken().toLowerCase(Locale.ROOT);\n+  293: \t\t\t\t\t}\n+  294: \t\t\t\t\twhile ( nextToken.isBlank() && lookahead.hasMoreTokens() );\n+  295: \t\t\t\t\treturn \"'\".equals( nextToken )\n+  296: \t\t\t\t\t\t|| lcToken.equals( \"time\" ) && \"with\".equals( nextToken )\n+  297: \t\t\t\t\t\t|| lcToken.equals( \"timestamp\" ) && \"with\".equals( nextToken )\n+  298: \t\t\t\t\t\t|| lcToken.equals( \"time\" ) && \"zone\".equals( nextToken );\n+  299: \t\t\t\t}\n+  300: \t\t\t\telse {\n+  301: \t\t\t\t\treturn false;\n+  302: \t\t\t\t}\n+  303: \t\t\t}\n+  304: \t\t}\n+  305: \t\telse {\n+  306: \t\t\treturn false;\n+  307: \t\t}\n+  308: \t}\n+  309: \n+  310: \tprivate static void handleTrimFunction(\n+  311: \t\t\tString placeholder, Dialect dialect,\n+  312: \t\t\tTypeConfiguration typeConfiguration,\n+  313: \t\t\tSqmFunctionRegistry functionRegistry,\n+  314: \t\t\tStringTokenizer tokens,\n+  315: \t\t\tStringBuilder result) {\n+  316: \t\tfinal List<String> operands = new ArrayList<>();\n+  317: \t\tfinal StringBuilder builder = new StringBuilder();\n+  318: \n+  319: \t\tboolean hasMoreOperands = true;\n+  320: \t\tString operandToken = tokens.nextToken();\n+  321: \t\tswitch ( operandToken.toLowerCase( Locale.ROOT ) ) {\n+  322: \t\t\tcase \"leading\":\n+  323: \t\t\tcase \"trailing\":\n+  324: \t\t\tcase \"both\":\n+  325: \t\t\t\toperands.add( operandToken );\n+  326: \t\t\t\tif ( hasMoreOperands = tokens.hasMoreTokens() ) {\n+  327: \t\t\t\t\toperandToken = tokens.nextToken();\n+  328: \t\t\t\t}\n+  329: \t\t\t\tbreak;\n+  330: \t\t}\n+  331: \t\tboolean quotedOperand = false;\n+  332: \t\tint parenthesis = 0;\n+  333: \t\twhile ( hasMoreOperands ) {\n+  334: \t\t\tfinal boolean isQuote = \"'\".equals( operandToken );\n+  335: \t\t\tif ( isQuote ) {\n+  336: \t\t\t\tquotedOperand = !quotedOperand;\n+  337: \t\t\t\tif ( !quotedOperand ) {\n+  338: \t\t\t\t\toperands.add( builder.append( '\\'' ).toString() );\n+  339: \t\t\t\t\tbuilder.setLength( 0 );\n+  340: \t\t\t\t}\n+  341: \t\t\t\telse {\n+  342: \t\t\t\t\tbuilder.append( '\\'' );\n+  343: \t\t\t\t}\n+  344: \t\t\t}\n+  345: \t\t\telse if ( quotedOperand ) {\n+  346: \t\t\t\tbuilder.append( operandToken );\n+  347: \t\t\t}\n+  348: \t\t\telse if ( parenthesis != 0 ) {\n+  349: \t\t\t\tbuilder.append( operandToken );\n+  350: \t\t\t\tswitch ( operandToken ) {\n+  351: \t\t\t\t\tcase \"(\":\n+  352: \t\t\t\t\t\tparenthesis++;\n+  353: \t\t\t\t\t\tbreak;\n+  354: \t\t\t\t\tcase \")\":\n+  355: \t\t\t\t\t\tparenthesis--;\n+  356: \t\t\t\t\t\tbreak;\n+  357: \t\t\t\t}\n   358: \t\t\t}\n-  359: \t\t\telse if ( beforeTable ) {\n-  360: \t\t\t\tresult.append( token );\n-  361: \t\t\t\tbeforeTable = false;\n-  362: \t\t\t\tafterFromTable = true;\n-  363: \t\t\t}\n-  364: \t\t\telse if ( afterFromTable ) {\n-  365: \t\t\t\tif ( !\"as\".equals(lcToken) ) {\n-  366: \t\t\t\t\tafterFromTable = false;\n-  367: \t\t\t\t}\n-  368: \t\t\t\tresult.append(token);\n-  369: \t\t\t}\n-  370: \t\t\telse if ( isNamedParameter(token) ) {\n-  371: \t\t\t\tresult.append(token);\n-  372: \t\t\t}\n-  373: \t\t\telse if ( isIdentifier(token)\n-  374: \t\t\t\t\t&& !isFunctionOrKeyword(lcToken, nextToken, dialect, typeConfiguration, functionRegistry) ) {\n-  375: \t\t\t\tresult.append(placeholder)\n-  376: \t\t\t\t\t\t.append('.')\n-  377: \t\t\t\t\t\t.append( dialect.quote(token) );\n-  378: \t\t\t}\n-  379: \t\t\telse {\n-  380: \t\t\t\tif ( BEFORE_TABLE_KEYWORDS.contains(lcToken) ) {\n-  381: \t\t\t\t\tbeforeTable = true;\n-  382: \t\t\t\t\tinFromClause = true;\n-  383: \t\t\t\t}\n-  384: \t\t\t\telse if ( inFromClause && \",\".equals(lcToken) ) {\n-  385: \t\t\t\t\tbeforeTable = true;\n-  386: \t\t\t\t}\n-  387: \t\t\t\tif ( isBoolean( token ) ) {\n-  388: \t\t\t\t\ttoken = dialect.toBooleanValueString( Boolean.parseBoolean( token ) );\n-  389: \t\t\t\t}\n-  390: \t\t\t\tresult.append(token);\n-  391: \t\t\t}\n-  392: \n-  393: \t\t\t//Yuck:\n-  394: \t\t\tif ( inFromClause\n-  395: \t\t\t\t\t&& KEYWORDS.contains( lcToken ) //\"as\" is not in KEYWORDS\n-  396: \t\t\t\t\t&& !BEFORE_TABLE_KEYWORDS.contains( lcToken ) ) {\n-  397: \t\t\t\tinFromClause = false;\n+  359: \t\t\telse {\n+  360: \t\t\t\tbuilder.append( operandToken );\n+  361: \t\t\t\tswitch ( operandToken.toLowerCase( Locale.ROOT ) ) {\n+  362: \t\t\t\t\tcase \"(\":\n+  363: \t\t\t\t\t\tparenthesis++;\n+  364: \t\t\t\t\t\tbreak;\n+  365: \t\t\t\t\tcase \")\":\n+  366: \t\t\t\t\t\tparenthesis--;\n+  367: \t\t\t\t\t\tbreak;\n+  368: \t\t\t\t\tcase \"from\":\n+  369: \t\t\t\t\t\tif ( !builder.isEmpty() ) {\n+  370: \t\t\t\t\t\t\toperands.add( builder.substring( 0, builder.length() - 4 ) );\n+  371: \t\t\t\t\t\t\tbuilder.setLength( 0 );\n+  372: \t\t\t\t\t\t\toperands.add( operandToken );\n+  373: \t\t\t\t\t\t}\n+  374: \t\t\t\t\t\tbreak;\n+  375: \t\t\t\t}\n+  376: \t\t\t}\n+  377: \t\t\toperandToken = tokens.nextToken();\n+  378: \t\t\thasMoreOperands = tokens.hasMoreTokens()\n+  379: \t\t\t\t\t&& ( parenthesis != 0 || ! \")\".equals( operandToken ) );\n+  380: \t\t}\n+  381: \t\tif ( !builder.isEmpty() ) {\n+  382: \t\t\toperands.add( builder.toString() );\n+  383: \t\t}\n+  384: \n+  385: \t\tfinal TrimOperands trimOperands = new TrimOperands( operands );\n+  386: \t\tresult.append( \"trim(\" );\n+  387: \t\tif ( trimOperands.trimSpec != null ) {\n+  388: \t\t\tresult.append( trimOperands.trimSpec ).append( ' ' );\n+  389: \t\t}\n+  390: \t\tif ( trimOperands.trimChar != null ) {\n+  391: \t\t\tif ( trimOperands.trimChar.startsWith( \"'\" ) && trimOperands.trimChar.endsWith( \"'\" ) ) {\n+  392: \t\t\t\tresult.append( trimOperands.trimChar );\n+  393: \t\t\t}\n+  394: \t\t\telse {\n+  395: \t\t\t\tresult.append(\n+  396: \t\t\t\t\t\trenderWhereStringTemplate( trimOperands.trimSpec, placeholder, dialect, typeConfiguration, functionRegistry )\n+  397: \t\t\t\t);\n   398: \t\t\t}\n-  399: \t\t}\n-  400: \n-  401: \t\treturn result.toString();\n-  402: \t}\n+  399: \t\t\tresult.append( ' ' );\n+  400: \t\t}\n+  401: \t\tif ( trimOperands.from != null ) {\n+  402: \t\t\tresult.append( trimOperands.from ).append( ' ' );\n",
        "uniqueId": "35f96d6e901dbd071b375d809521ef6f1c979868_119_402_266_268_122_260",
        "moveFileExist": true,
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 21,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 1,
                "covered": 289
            },
            "BRANCH": {
                "missed": 2,
                "covered": 74
            },
            "LINE": {
                "missed": 0,
                "covered": 79
            },
            "COMPLEXITY": {
                "missed": 2,
                "covered": 37
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        }
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprivate isTrimFunction(lcToken String, nextToken String) : boolean extracted from public renderWhereStringTemplate(sqlWhereString String, placeholder String, dialect Dialect, typeConfiguration TypeConfiguration, functionRegistry SqmFunctionRegistry) : String in class org.hibernate.sql.Template",
        "diffLocations": [
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/sql/Template.java",
                "startLine": 119,
                "endLine": 402,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/sql/Template.java",
                "startLine": 122,
                "endLine": 260,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/sql/Template.java",
                "startLine": 262,
                "endLine": 264,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "/**\n\t * Takes the where condition provided in the mapping attribute and interpolates the alias.\n\t * Handles sub-selects, quoted identifiers, quoted strings, expressions, SQL functions,\n\t * named parameters.\n\t *\n\t * @param sqlWhereString The string into which to interpolate the placeholder value\n\t * @param placeholder The value to be interpolated into the sqlWhereString\n\t * @param dialect The dialect to apply\n\t * @param functionRegistry The registry of all sql functions\n\t * @return The rendered sql fragment\n\t */\n\tpublic static String renderWhereStringTemplate(\n\t\t\tString sqlWhereString,\n\t\t\tString placeholder,\n\t\t\tDialect dialect,\n\t\t\tTypeConfiguration typeConfiguration,\n\t\t\tSqmFunctionRegistry functionRegistry) {\n\n\t\t// IMPL NOTE : The basic process here is to tokenize the incoming string and to iterate over each token\n\t\t//\t\tin turn.  As we process each token, we set a series of flags used to indicate the type of context in\n\t\t// \t\twhich the tokens occur.  Depending on the state of those flags we decide whether we need to qualify\n\t\t//\t\tidentifier references.\n\n\t\tString symbols = PUNCTUATION +\n\t\t\t\tWHITESPACE +\n\t\t\t\tdialect.openQuote() +\n\t\t\t\tdialect.closeQuote();\n\t\tStringTokenizer tokens = new StringTokenizer( sqlWhereString, symbols, true );\n\t\tStringBuilder result = new StringBuilder();\n\n\t\tboolean quoted = false;\n\t\tboolean quotedIdentifier = false;\n\t\tboolean beforeTable = false;\n\t\tboolean inFromClause = false;\n\t\tboolean afterFromTable = false;\n\n\t\tboolean hasMore = tokens.hasMoreTokens();\n\t\tString nextToken = hasMore ? tokens.nextToken() : null;\n\t\twhile ( hasMore ) {\n\t\t\tString token = nextToken;\n\t\t\tString lcToken = token.toLowerCase(Locale.ROOT);\n\t\t\thasMore = tokens.hasMoreTokens();\n\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n\n\t\t\tboolean isQuoteCharacter = false;\n\n\t\t\tif ( !quotedIdentifier && \"'\".equals(token) ) {\n\t\t\t\tquoted = !quoted;\n\t\t\t\tisQuoteCharacter = true;\n\t\t\t}\n\n\t\t\tif ( !quoted ) {\n\t\t\t\tboolean isOpenQuote;\n\t\t\t\tif ( \"`\".equals(token) ) {\n\t\t\t\t\tisOpenQuote = !quotedIdentifier;\n\t\t\t\t\ttoken = lcToken = isOpenQuote\n\t\t\t\t\t\t\t? Character.toString( dialect.openQuote() )\n\t\t\t\t\t\t\t: Character.toString( dialect.closeQuote() );\n\t\t\t\t\tquotedIdentifier = isOpenQuote;\n\t\t\t\t\tisQuoteCharacter = true;\n\t\t\t\t}\n\t\t\t\telse if ( !quotedIdentifier && ( dialect.openQuote()==token.charAt(0) ) ) {\n\t\t\t\t\tisOpenQuote = true;\n\t\t\t\t\tquotedIdentifier = true;\n\t\t\t\t\tisQuoteCharacter = true;\n\t\t\t\t}\n\t\t\t\telse if ( quotedIdentifier && ( dialect.closeQuote()==token.charAt(0) ) ) {\n\t\t\t\t\tquotedIdentifier = false;\n\t\t\t\t\tisQuoteCharacter = true;\n\t\t\t\t\tisOpenQuote = false;\n\t\t\t\t}\n\t\t\t\telse if ( LITERAL_PREFIXES.contains( lcToken ) ) {\n\t\t\t\t\tif ( \"'\".equals( nextToken ) ) {\n\t\t\t\t\t\t// Don't prefix a literal\n\t\t\t\t\t\tresult.append( token );\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\telse if ( nextToken != null && Character.isWhitespace( nextToken.charAt( 0 ) ) ) {\n\t\t\t\t\t\tfinal StringBuilder additionalTokens = new StringBuilder();\n\t\t\t\t\t\tTimeZoneTokens possibleNextToken = null;\n\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\tpossibleNextToken = possibleNextToken == null\n\t\t\t\t\t\t\t\t\t? TimeZoneTokens.getPossibleNextTokens( lcToken )\n\t\t\t\t\t\t\t\t\t: possibleNextToken.nextToken();\n\t\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\t\tadditionalTokens.append( nextToken );\n\t\t\t\t\t\t\t\thasMore = tokens.hasMoreTokens();\n\t\t\t\t\t\t\t\tnextToken = tokens.nextToken();\n\t\t\t\t\t\t\t} while ( nextToken != null && Character.isWhitespace( nextToken.charAt( 0 ) ) );\n\t\t\t\t\t\t} while ( nextToken != null && possibleNextToken.isToken( nextToken ) );\n\t\t\t\t\t\tif ( \"'\".equals( nextToken ) ) {\n\t\t\t\t\t\t\t// Don't prefix a literal\n\t\t\t\t\t\t\tresult.append( token );\n\t\t\t\t\t\t\tresult.append( additionalTokens );\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tisOpenQuote = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tisOpenQuote = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tisOpenQuote = false;\n\t\t\t\t}\n\n\t\t\t\tif ( isOpenQuote ) {\n\t\t\t\t\tresult.append( placeholder ).append( '.' );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Special processing for ANSI SQL EXTRACT function\n\t\t\tif ( \"extract\".equals( lcToken ) && \"(\".equals( nextToken ) ) {\n\t\t\t\tfinal String field = extractUntil( tokens, \"from\" );\n\t\t\t\tfinal String source = renderWhereStringTemplate(\n\t\t\t\t\t\textractUntil( tokens, \")\" ),\n\t\t\t\t\t\tplaceholder,\n\t\t\t\t\t\tdialect,\n\t\t\t\t\t\ttypeConfiguration,\n\t\t\t\t\t\tfunctionRegistry\n\t\t\t\t);\n\t\t\t\tresult.append( \"extract(\" ).append( field ).append( \" from \" ).append( source ).append( ')' );\n\n\t\t\t\thasMore = tokens.hasMoreTokens();\n\t\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Special processing for ANSI SQL TRIM function\n\t\t\tif ( \"trim\".equals( lcToken ) && \"(\".equals( nextToken ) ) {\n\t\t\t\tList<String> operands = new ArrayList<>();\n\t\t\t\tStringBuilder builder = new StringBuilder();\n\n\t\t\t\tboolean hasMoreOperands = true;\n\t\t\t\tString operandToken = tokens.nextToken();\n\t\t\t\tswitch ( operandToken.toLowerCase( Locale.ROOT ) ) {\n\t\t\t\t\tcase \"leading\":\n\t\t\t\t\tcase \"trailing\":\n\t\t\t\t\tcase \"both\":\n\t\t\t\t\t\toperands.add( operandToken );\n\t\t\t\t\t\tif ( hasMoreOperands = tokens.hasMoreTokens() ) {\n\t\t\t\t\t\t\toperandToken = tokens.nextToken();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tboolean quotedOperand = false;\n\t\t\t\tint parenthesis = 0;\n\t\t\t\twhile ( hasMoreOperands ) {\n\t\t\t\t\tfinal boolean isQuote = \"'\".equals( operandToken );\n\t\t\t\t\tif ( isQuote ) {\n\t\t\t\t\t\tquotedOperand = !quotedOperand;\n\t\t\t\t\t\tif ( !quotedOperand ) {\n\t\t\t\t\t\t\toperands.add( builder.append( '\\'' ).toString() );\n\t\t\t\t\t\t\tbuilder.setLength( 0 );\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tbuilder.append( '\\'' );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if ( quotedOperand ) {\n\t\t\t\t\t\tbuilder.append( operandToken );\n\t\t\t\t\t}\n\t\t\t\t\telse if ( parenthesis != 0 ) {\n\t\t\t\t\t\tbuilder.append( operandToken );\n\t\t\t\t\t\tswitch ( operandToken ) {\n\t\t\t\t\t\t\tcase \"(\":\n\t\t\t\t\t\t\t\tparenthesis++;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase \")\":\n\t\t\t\t\t\t\t\tparenthesis--;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tbuilder.append( operandToken );\n\t\t\t\t\t\tswitch ( operandToken.toLowerCase( Locale.ROOT ) ) {\n\t\t\t\t\t\t\tcase \"(\":\n\t\t\t\t\t\t\t\tparenthesis++;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase \")\":\n\t\t\t\t\t\t\t\tparenthesis--;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase \"from\":\n\t\t\t\t\t\t\t\tif ( builder.length() != 0 ) {\n\t\t\t\t\t\t\t\t\toperands.add( builder.substring( 0, builder.length() - 4 ) );\n\t\t\t\t\t\t\t\t\tbuilder.setLength( 0 );\n\t\t\t\t\t\t\t\t\toperands.add( operandToken );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\toperandToken = tokens.nextToken();\n\t\t\t\t\thasMoreOperands = tokens.hasMoreTokens() && ( parenthesis != 0 || ! \")\".equals( operandToken ) );\n\t\t\t\t}\n\t\t\t\tif ( builder.length() != 0 ) {\n\t\t\t\t\toperands.add( builder.toString() );\n\t\t\t\t}\n\n\t\t\t\tTrimOperands trimOperands = new TrimOperands( operands );\n\t\t\t\tresult.append( \"trim(\" );\n\t\t\t\tif ( trimOperands.trimSpec != null ) {\n\t\t\t\t\tresult.append( trimOperands.trimSpec ).append( ' ' );\n\t\t\t\t}\n\t\t\t\tif ( trimOperands.trimChar != null ) {\n\t\t\t\t\tif ( trimOperands.trimChar.startsWith( \"'\" ) && trimOperands.trimChar.endsWith( \"'\" ) ) {\n\t\t\t\t\t\tresult.append( trimOperands.trimChar );\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tresult.append(\n\t\t\t\t\t\t\t\trenderWhereStringTemplate( trimOperands.trimSpec, placeholder, dialect, typeConfiguration, functionRegistry )\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\tresult.append( ' ' );\n\t\t\t\t}\n\t\t\t\tif ( trimOperands.from != null ) {\n\t\t\t\t\tresult.append( trimOperands.from ).append( ' ' );\n\t\t\t\t}\n\t\t\t\telse if ( trimOperands.trimSpec != null || trimOperands.trimChar != null ) {\n\t\t\t\t\t// I think ANSI SQL says that the 'from' is not optional if either trim-spec or trim-char is specified\n\t\t\t\t\tresult.append( \"from \" );\n\t\t\t\t}\n\n\t\t\t\tresult.append( renderWhereStringTemplate( trimOperands.trimSource, placeholder, dialect, typeConfiguration, functionRegistry ) )\n\t\t\t\t\t\t.append( ')' );\n\n\t\t\t\thasMore = tokens.hasMoreTokens();\n\t\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tboolean quotedOrWhitespace = quoted || quotedIdentifier || isQuoteCharacter\n\t\t\t\t\t|| Character.isWhitespace( token.charAt(0) );\n\n\t\t\tif ( quotedOrWhitespace ) {\n\t\t\t\tresult.append( token );\n\t\t\t}\n\t\t\telse if ( beforeTable ) {\n\t\t\t\tresult.append( token );\n\t\t\t\tbeforeTable = false;\n\t\t\t\tafterFromTable = true;\n\t\t\t}\n\t\t\telse if ( afterFromTable ) {\n\t\t\t\tif ( !\"as\".equals(lcToken) ) {\n\t\t\t\t\tafterFromTable = false;\n\t\t\t\t}\n\t\t\t\tresult.append(token);\n\t\t\t}\n\t\t\telse if ( isNamedParameter(token) ) {\n\t\t\t\tresult.append(token);\n\t\t\t}\n\t\t\telse if ( isIdentifier(token)\n\t\t\t\t\t&& !isFunctionOrKeyword(lcToken, nextToken, dialect, typeConfiguration, functionRegistry) ) {\n\t\t\t\tresult.append(placeholder)\n\t\t\t\t\t\t.append('.')\n\t\t\t\t\t\t.append( dialect.quote(token) );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif ( BEFORE_TABLE_KEYWORDS.contains(lcToken) ) {\n\t\t\t\t\tbeforeTable = true;\n\t\t\t\t\tinFromClause = true;\n\t\t\t\t}\n\t\t\t\telse if ( inFromClause && \",\".equals(lcToken) ) {\n\t\t\t\t\tbeforeTable = true;\n\t\t\t\t}\n\t\t\t\tif ( isBoolean( token ) ) {\n\t\t\t\t\ttoken = dialect.toBooleanValueString( Boolean.parseBoolean( token ) );\n\t\t\t\t}\n\t\t\t\tresult.append(token);\n\t\t\t}\n\n\t\t\t//Yuck:\n\t\t\tif ( inFromClause\n\t\t\t\t\t&& KEYWORDS.contains( lcToken ) //\"as\" is not in KEYWORDS\n\t\t\t\t\t&& !BEFORE_TABLE_KEYWORDS.contains( lcToken ) ) {\n\t\t\t\tinFromClause = false;\n\t\t\t}\n\t\t}\n\n\t\treturn result.toString();\n\t}",
        "filePathBefore": "hibernate-core/src/main/java/org/hibernate/sql/Template.java",
        "isPureRefactoring": true,
        "commitId": "35f96d6e901dbd071b375d809521ef6f1c979868",
        "packageNameBefore": "org.hibernate.sql",
        "classNameBefore": "org.hibernate.sql.Template",
        "methodNameBefore": "org.hibernate.sql.Template#renderWhereStringTemplate",
        "invokedMethod": "methodSignature: org.hibernate.sql.Template#extractUntil\n methodBody: private static String extractUntil(StringTokenizer tokens, String delimiter) {\nStringBuilder valueBuilder=new StringBuilder();\nString token=tokens.nextToken();\nwhile(!delimiter.equalsIgnoreCase(token)){valueBuilder.append(token);\ntoken=tokens.nextToken();\n}return valueBuilder.toString().trim();\n}\nmethodSignature: org.hibernate.sql.Template#renderWhereStringTemplate\n methodBody: public static String renderWhereStringTemplate(\n\t\t\tString sqlWhereString,\n\t\t\tString placeholder,\n\t\t\tDialect dialect,\n\t\t\tTypeConfiguration typeConfiguration,\n\t\t\tSqmFunctionRegistry functionRegistry) {\nString symbols=PUNCTUATION + WHITESPACE + dialect.openQuote() + dialect.closeQuote();\nStringTokenizer tokens=new StringTokenizer(sqlWhereString,symbols,true);\nStringBuilder result=new StringBuilder();\nboolean quoted=false;\nboolean quotedIdentifier=false;\nboolean beforeTable=false;\nboolean inFromClause=false;\nboolean afterFromTable=false;\nboolean hasMore=tokens.hasMoreTokens();\nString nextToken=hasMore ? tokens.nextToken() : null;\nwhile(hasMore){String token=nextToken;\nString lcToken=token.toLowerCase(Locale.ROOT);\nhasMore=tokens.hasMoreTokens();\nnextToken=hasMore ? tokens.nextToken() : null;\nboolean isQuoteCharacter=false;\nif(!quotedIdentifier && \"'\".equals(token)){quoted=!quoted;\nisQuoteCharacter=true;\n}if(!quoted){boolean isOpenQuote;\nif(\"`\".equals(token)){isOpenQuote=!quotedIdentifier;\ntoken=lcToken=isOpenQuote ? Character.toString(dialect.openQuote()) : Character.toString(dialect.closeQuote());\nquotedIdentifier=isOpenQuote;\nisQuoteCharacter=true;\n}if(!quotedIdentifier && (dialect.openQuote() == token.charAt(0))){isOpenQuote=true;\nquotedIdentifier=true;\nisQuoteCharacter=true;\n}if(quotedIdentifier && (dialect.closeQuote() == token.charAt(0))){quotedIdentifier=false;\nisQuoteCharacter=true;\nisOpenQuote=false;\n}if(LITERAL_PREFIXES.contains(lcToken)){if(\"'\".equals(nextToken)){result.append(token);\ncontinue;\n}if(nextToken != null && Character.isWhitespace(nextToken.charAt(0))){final StringBuilder additionalTokens=new StringBuilder();\nTimeZoneTokens possibleNextToken=null;\ndo(nextToken != null && possibleNextToken.isToken(nextToken)){possibleNextToken=possibleNextToken == null ? TimeZoneTokens.getPossibleNextTokens(lcToken) : possibleNextToken.nextToken();\ndo(nextToken != null && Character.isWhitespace(nextToken.charAt(0))){additionalTokens.append(nextToken);\nhasMore=tokens.hasMoreTokens();\nnextToken=tokens.nextToken();\n}}if(\"'\".equals(nextToken)){result.append(token);\nresult.append(additionalTokens);\ncontinue;\n}{isOpenQuote=false;\n}}{isOpenQuote=false;\n}}{isOpenQuote=false;\n}if(isOpenQuote){result.append(placeholder).append('.');\n}}if(\"extract\".equals(lcToken) && \"(\".equals(nextToken)){final String field=extractUntil(tokens,\"from\");\nfinal String source=renderWhereStringTemplate(extractUntil(tokens,\")\"),placeholder,dialect,typeConfiguration,functionRegistry);\nresult.append(\"extract(\").append(field).append(\" from \").append(source).append(')');\nhasMore=tokens.hasMoreTokens();\nnextToken=hasMore ? tokens.nextToken() : null;\ncontinue;\n}if(\"trim\".equals(lcToken) && \"(\".equals(nextToken)){List<String> operands=new ArrayList<>();\nStringBuilder builder=new StringBuilder();\nboolean hasMoreOperands=true;\nString operandToken=tokens.nextToken();\nswitch(operandToken.toLowerCase(Locale.ROOT))case \"leading\":case \"trailing\":case \"both\":operands.add(operandToken);\nif(hasMoreOperands=tokens.hasMoreTokens()){operandToken=tokens.nextToken();\n}break;\nboolean quotedOperand=false;\nint parenthesis=0;\nwhile(hasMoreOperands){final boolean isQuote=\"'\".equals(operandToken);\nif(isQuote){quotedOperand=!quotedOperand;\nif(!quotedOperand){operands.add(builder.append('\\'').toString());\nbuilder.setLength(0);\n}{builder.append('\\'');\n}}if(quotedOperand){builder.append(operandToken);\n}if(parenthesis != 0){builder.append(operandToken);\nswitch(operandToken)case \"(\":parenthesis++;\nbreak;\ncase \")\":parenthesis--;\nbreak;\n}{builder.append(operandToken);\nswitch(operandToken.toLowerCase(Locale.ROOT))case \"(\":parenthesis++;\nbreak;\ncase \")\":parenthesis--;\nbreak;\ncase \"from\":if(builder.length() != 0){operands.add(builder.substring(0,builder.length() - 4));\nbuilder.setLength(0);\noperands.add(operandToken);\n}break;\n}operandToken=tokens.nextToken();\nhasMoreOperands=tokens.hasMoreTokens() && (parenthesis != 0 || !\")\".equals(operandToken));\n}if(builder.length() != 0){operands.add(builder.toString());\n}TrimOperands trimOperands=new TrimOperands(operands);\nresult.append(\"trim(\");\nif(trimOperands.trimSpec != null){result.append(trimOperands.trimSpec).append(' ');\n}if(trimOperands.trimChar != null){if(trimOperands.trimChar.startsWith(\"'\") && trimOperands.trimChar.endsWith(\"'\")){result.append(trimOperands.trimChar);\n}{result.append(renderWhereStringTemplate(trimOperands.trimSpec,placeholder,dialect,typeConfiguration,functionRegistry));\n}result.append(' ');\n}if(trimOperands.from != null){result.append(trimOperands.from).append(' ');\n}if(trimOperands.trimSpec != null || trimOperands.trimChar != null){result.append(\"from \");\n}result.append(renderWhereStringTemplate(trimOperands.trimSource,placeholder,dialect,typeConfiguration,functionRegistry)).append(')');\nhasMore=tokens.hasMoreTokens();\nnextToken=hasMore ? tokens.nextToken() : null;\ncontinue;\n}boolean quotedOrWhitespace=quoted || quotedIdentifier || isQuoteCharacter || Character.isWhitespace(token.charAt(0));\nif(quotedOrWhitespace){result.append(token);\n}if(beforeTable){result.append(token);\nbeforeTable=false;\nafterFromTable=true;\n}if(afterFromTable){if(!\"as\".equals(lcToken)){afterFromTable=false;\n}result.append(token);\n}if(isNamedParameter(token)){result.append(token);\n}if(isIdentifier(token) && !isFunctionOrKeyword(lcToken,nextToken,dialect,typeConfiguration,functionRegistry)){result.append(placeholder).append('.').append(dialect.quote(token));\n}{if(BEFORE_TABLE_KEYWORDS.contains(lcToken)){beforeTable=true;\ninFromClause=true;\n}if(inFromClause && \",\".equals(lcToken)){beforeTable=true;\n}if(isBoolean(token)){token=dialect.toBooleanValueString(Boolean.parseBoolean(token));\n}result.append(token);\n}if(inFromClause && KEYWORDS.contains(lcToken) && !BEFORE_TABLE_KEYWORDS.contains(lcToken)){inFromClause=false;\n}}return result.toString();\n}\nmethodSignature: org.hibernate.sql.Template.TimeZoneTokens#isToken\n methodBody: public boolean isToken(String token) {\nreturn this != NONE && name().equalsIgnoreCase(token);\n}\nmethodSignature: org.hibernate.sql.Template#isBoolean\n methodBody: private static boolean isBoolean(String token) {\nreturn \"true\".equals(token) || \"false\".equals(token);\n}\nmethodSignature: org.hibernate.sql.Template.TimeZoneTokens#nextToken\n methodBody: public TimeZoneTokens nextToken() {\nif(this == WITH){return TIME;\n}if(this == TIME){return ZONE;\n}{return NONE;\n}}\nmethodSignature: org.hibernate.sql.Template.TimeZoneTokens#getPossibleNextTokens\n methodBody: static TimeZoneTokens getPossibleNextTokens(String lctoken) {\nswitch(lctoken)case \"time\":case \"timestamp\":return WITH;\ndefault:return NONE;\n}\nmethodSignature: org.hibernate.sql.Template#isIdentifier\n methodBody: private static boolean isIdentifier(String token) {\nif(isBoolean(token)){return false;\n}return token.charAt(0) == '`' || (Character.isLetter(token.charAt(0)) && token.indexOf('.') < 0);\n}\nmethodSignature: org.hibernate.sql.Template#isNamedParameter\n methodBody: private static boolean isNamedParameter(String token) {\nreturn token.startsWith(\":\");\n}\nmethodSignature: org.hibernate.sql.Template#isFunctionOrKeyword\n methodBody: private static boolean isFunctionOrKeyword(\n\t\t\tString lcToken,\n\t\t\tString nextToken,\n\t\t\tDialect dialect,\n\t\t\tTypeConfiguration typeConfiguration,\n\t\t\tSqmFunctionRegistry functionRegistry) {\nreturn \"(\".equals(nextToken) || KEYWORDS.contains(lcToken) || isType(lcToken,typeConfiguration) || isFunction(lcToken,nextToken,functionRegistry) || dialect.getKeywords().contains(lcToken) || FUNCTION_KEYWORDS.contains(lcToken);\n}",
        "classSignatureBefore": "public final class Template ",
        "methodNameBeforeSet": [
            "org.hibernate.sql.Template#renderWhereStringTemplate"
        ],
        "classNameBeforeSet": [
            "org.hibernate.sql.Template"
        ],
        "classSignatureBeforeSet": [
            "public final class Template "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.\n */\npackage org.hibernate.sql;\n\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Set;\nimport java.util.StringTokenizer;\n\nimport org.hibernate.HibernateException;\nimport org.hibernate.dialect.Dialect;\nimport org.hibernate.query.sqm.function.SqmFunctionDescriptor;\nimport org.hibernate.query.sqm.function.SqmFunctionRegistry;\nimport org.hibernate.type.spi.TypeConfiguration;\n\nimport static org.hibernate.internal.util.StringHelper.WHITESPACE;\n\n/**\n * Parses SQL fragments specified in mapping documents.\n *\n * @author Gavin King\n */\npublic final class Template {\n\n\tprivate static final Set<String> KEYWORDS = new HashSet<>();\n\tprivate static final Set<String> BEFORE_TABLE_KEYWORDS = new HashSet<>();\n\tprivate static final Set<String> FUNCTION_KEYWORDS = new HashSet<>();\n\tprivate static final Set<String> LITERAL_PREFIXES = new HashSet<>();\n\tpublic static final String PUNCTUATION = \"=><!+-*/()',|&`\";\n\n\tstatic {\n\t\tKEYWORDS.add(\"and\");\n\t\tKEYWORDS.add(\"or\");\n\t\tKEYWORDS.add(\"not\");\n\t\tKEYWORDS.add(\"like\");\n\t\tKEYWORDS.add(\"escape\");\n\t\tKEYWORDS.add(\"is\");\n\t\tKEYWORDS.add(\"in\");\n\t\tKEYWORDS.add(\"between\");\n\t\tKEYWORDS.add(\"null\");\n\t\tKEYWORDS.add(\"select\");\n\t\tKEYWORDS.add(\"distinct\");\n\t\tKEYWORDS.add(\"from\");\n\t\tKEYWORDS.add(\"join\");\n\t\tKEYWORDS.add(\"inner\");\n\t\tKEYWORDS.add(\"outer\");\n\t\tKEYWORDS.add(\"left\");\n\t\tKEYWORDS.add(\"right\");\n\t\tKEYWORDS.add(\"on\");\n\t\tKEYWORDS.add(\"where\");\n\t\tKEYWORDS.add(\"having\");\n\t\tKEYWORDS.add(\"group\");\n\t\tKEYWORDS.add(\"order\");\n\t\tKEYWORDS.add(\"by\");\n\t\tKEYWORDS.add(\"desc\");\n\t\tKEYWORDS.add(\"asc\");\n\t\tKEYWORDS.add(\"limit\");\n\t\tKEYWORDS.add(\"any\");\n\t\tKEYWORDS.add(\"some\");\n\t\tKEYWORDS.add(\"exists\");\n\t\tKEYWORDS.add(\"all\");\n\t\tKEYWORDS.add(\"union\");\n\t\tKEYWORDS.add(\"minus\");\n\t\tKEYWORDS.add(\"except\");\n\t\tKEYWORDS.add(\"intersect\");\n\t\tKEYWORDS.add(\"partition\");\n\n\t\tBEFORE_TABLE_KEYWORDS.add(\"from\");\n\t\tBEFORE_TABLE_KEYWORDS.add(\"join\");\n\n\t\tFUNCTION_KEYWORDS.add(\"as\");\n\t\tFUNCTION_KEYWORDS.add(\"leading\");\n\t\tFUNCTION_KEYWORDS.add(\"trailing\");\n\t\tFUNCTION_KEYWORDS.add(\"from\");\n\t\tFUNCTION_KEYWORDS.add(\"case\");\n\t\tFUNCTION_KEYWORDS.add(\"when\");\n\t\tFUNCTION_KEYWORDS.add(\"then\");\n\t\tFUNCTION_KEYWORDS.add(\"else\");\n\t\tFUNCTION_KEYWORDS.add(\"end\");\n\n\t\tLITERAL_PREFIXES.add(\"n\");\n\t\tLITERAL_PREFIXES.add(\"x\");\n\t\tLITERAL_PREFIXES.add(\"varbyte\");\n\t\tLITERAL_PREFIXES.add(\"bx\");\n\t\tLITERAL_PREFIXES.add(\"bytea\");\n\t\tLITERAL_PREFIXES.add(\"date\");\n\t\tLITERAL_PREFIXES.add(\"time\");\n\t\tLITERAL_PREFIXES.add(\"timestamp\");\n\t}\n\n\tpublic static final String TEMPLATE = \"$PlaceHolder$\";\n\n\tprivate Template() {}\n\n\tpublic static String renderTransformerReadFragment(\n\t\t\tString fragment,\n\t\t\tString... columnNames) {\n\t\t// NOTE : would need access to SessionFactoryImplementor to make this configurable\n\t\tfor ( String columnName : columnNames ) {\n\t\t\tfragment = fragment.replace( columnName, TEMPLATE + '.' + columnName );\n\t\t}\n\t\treturn fragment;\n\t}\n\n\tpublic static String renderWhereStringTemplate(\n\t\t\tString sqlWhereString,\n\t\t\tDialect dialect,\n\t\t\tTypeConfiguration typeConfiguration,\n\t\t\tSqmFunctionRegistry functionRegistry) {\n\t\treturn renderWhereStringTemplate( sqlWhereString, TEMPLATE, dialect, typeConfiguration, functionRegistry );\n\t}\n\n\t/**\n\t * Takes the where condition provided in the mapping attribute and interpolates the alias.\n\t * Handles sub-selects, quoted identifiers, quoted strings, expressions, SQL functions,\n\t * named parameters.\n\t *\n\t * @param sqlWhereString The string into which to interpolate the placeholder value\n\t * @param placeholder The value to be interpolated into the sqlWhereString\n\t * @param dialect The dialect to apply\n\t * @param functionRegistry The registry of all sql functions\n\t * @return The rendered sql fragment\n\t */\n\tpublic static String renderWhereStringTemplate(\n\t\t\tString sqlWhereString,\n\t\t\tString placeholder,\n\t\t\tDialect dialect,\n\t\t\tTypeConfiguration typeConfiguration,\n\t\t\tSqmFunctionRegistry functionRegistry) {\n\n\t\t// IMPL NOTE : The basic process here is to tokenize the incoming string and to iterate over each token\n\t\t//\t\tin turn.  As we process each token, we set a series of flags used to indicate the type of context in\n\t\t// \t\twhich the tokens occur.  Depending on the state of those flags we decide whether we need to qualify\n\t\t//\t\tidentifier references.\n\n\t\tString symbols = PUNCTUATION +\n\t\t\t\tWHITESPACE +\n\t\t\t\tdialect.openQuote() +\n\t\t\t\tdialect.closeQuote();\n\t\tStringTokenizer tokens = new StringTokenizer( sqlWhereString, symbols, true );\n\t\tStringBuilder result = new StringBuilder();\n\n\t\tboolean quoted = false;\n\t\tboolean quotedIdentifier = false;\n\t\tboolean beforeTable = false;\n\t\tboolean inFromClause = false;\n\t\tboolean afterFromTable = false;\n\n\t\tboolean hasMore = tokens.hasMoreTokens();\n\t\tString nextToken = hasMore ? tokens.nextToken() : null;\n\t\twhile ( hasMore ) {\n\t\t\tString token = nextToken;\n\t\t\tString lcToken = token.toLowerCase(Locale.ROOT);\n\t\t\thasMore = tokens.hasMoreTokens();\n\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n\n\t\t\tboolean isQuoteCharacter = false;\n\n\t\t\tif ( !quotedIdentifier && \"'\".equals(token) ) {\n\t\t\t\tquoted = !quoted;\n\t\t\t\tisQuoteCharacter = true;\n\t\t\t}\n\n\t\t\tif ( !quoted ) {\n\t\t\t\tboolean isOpenQuote;\n\t\t\t\tif ( \"`\".equals(token) ) {\n\t\t\t\t\tisOpenQuote = !quotedIdentifier;\n\t\t\t\t\ttoken = lcToken = isOpenQuote\n\t\t\t\t\t\t\t? Character.toString( dialect.openQuote() )\n\t\t\t\t\t\t\t: Character.toString( dialect.closeQuote() );\n\t\t\t\t\tquotedIdentifier = isOpenQuote;\n\t\t\t\t\tisQuoteCharacter = true;\n\t\t\t\t}\n\t\t\t\telse if ( !quotedIdentifier && ( dialect.openQuote()==token.charAt(0) ) ) {\n\t\t\t\t\tisOpenQuote = true;\n\t\t\t\t\tquotedIdentifier = true;\n\t\t\t\t\tisQuoteCharacter = true;\n\t\t\t\t}\n\t\t\t\telse if ( quotedIdentifier && ( dialect.closeQuote()==token.charAt(0) ) ) {\n\t\t\t\t\tquotedIdentifier = false;\n\t\t\t\t\tisQuoteCharacter = true;\n\t\t\t\t\tisOpenQuote = false;\n\t\t\t\t}\n\t\t\t\telse if ( LITERAL_PREFIXES.contains( lcToken ) ) {\n\t\t\t\t\tif ( \"'\".equals( nextToken ) ) {\n\t\t\t\t\t\t// Don't prefix a literal\n\t\t\t\t\t\tresult.append( token );\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\telse if ( nextToken != null && Character.isWhitespace( nextToken.charAt( 0 ) ) ) {\n\t\t\t\t\t\tfinal StringBuilder additionalTokens = new StringBuilder();\n\t\t\t\t\t\tTimeZoneTokens possibleNextToken = null;\n\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\tpossibleNextToken = possibleNextToken == null\n\t\t\t\t\t\t\t\t\t? TimeZoneTokens.getPossibleNextTokens( lcToken )\n\t\t\t\t\t\t\t\t\t: possibleNextToken.nextToken();\n\t\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\t\tadditionalTokens.append( nextToken );\n\t\t\t\t\t\t\t\thasMore = tokens.hasMoreTokens();\n\t\t\t\t\t\t\t\tnextToken = tokens.nextToken();\n\t\t\t\t\t\t\t} while ( nextToken != null && Character.isWhitespace( nextToken.charAt( 0 ) ) );\n\t\t\t\t\t\t} while ( nextToken != null && possibleNextToken.isToken( nextToken ) );\n\t\t\t\t\t\tif ( \"'\".equals( nextToken ) ) {\n\t\t\t\t\t\t\t// Don't prefix a literal\n\t\t\t\t\t\t\tresult.append( token );\n\t\t\t\t\t\t\tresult.append( additionalTokens );\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tisOpenQuote = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tisOpenQuote = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tisOpenQuote = false;\n\t\t\t\t}\n\n\t\t\t\tif ( isOpenQuote ) {\n\t\t\t\t\tresult.append( placeholder ).append( '.' );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Special processing for ANSI SQL EXTRACT function\n\t\t\tif ( \"extract\".equals( lcToken ) && \"(\".equals( nextToken ) ) {\n\t\t\t\tfinal String field = extractUntil( tokens, \"from\" );\n\t\t\t\tfinal String source = renderWhereStringTemplate(\n\t\t\t\t\t\textractUntil( tokens, \")\" ),\n\t\t\t\t\t\tplaceholder,\n\t\t\t\t\t\tdialect,\n\t\t\t\t\t\ttypeConfiguration,\n\t\t\t\t\t\tfunctionRegistry\n\t\t\t\t);\n\t\t\t\tresult.append( \"extract(\" ).append( field ).append( \" from \" ).append( source ).append( ')' );\n\n\t\t\t\thasMore = tokens.hasMoreTokens();\n\t\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Special processing for ANSI SQL TRIM function\n\t\t\tif ( \"trim\".equals( lcToken ) && \"(\".equals( nextToken ) ) {\n\t\t\t\tList<String> operands = new ArrayList<>();\n\t\t\t\tStringBuilder builder = new StringBuilder();\n\n\t\t\t\tboolean hasMoreOperands = true;\n\t\t\t\tString operandToken = tokens.nextToken();\n\t\t\t\tswitch ( operandToken.toLowerCase( Locale.ROOT ) ) {\n\t\t\t\t\tcase \"leading\":\n\t\t\t\t\tcase \"trailing\":\n\t\t\t\t\tcase \"both\":\n\t\t\t\t\t\toperands.add( operandToken );\n\t\t\t\t\t\tif ( hasMoreOperands = tokens.hasMoreTokens() ) {\n\t\t\t\t\t\t\toperandToken = tokens.nextToken();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tboolean quotedOperand = false;\n\t\t\t\tint parenthesis = 0;\n\t\t\t\twhile ( hasMoreOperands ) {\n\t\t\t\t\tfinal boolean isQuote = \"'\".equals( operandToken );\n\t\t\t\t\tif ( isQuote ) {\n\t\t\t\t\t\tquotedOperand = !quotedOperand;\n\t\t\t\t\t\tif ( !quotedOperand ) {\n\t\t\t\t\t\t\toperands.add( builder.append( '\\'' ).toString() );\n\t\t\t\t\t\t\tbuilder.setLength( 0 );\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tbuilder.append( '\\'' );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if ( quotedOperand ) {\n\t\t\t\t\t\tbuilder.append( operandToken );\n\t\t\t\t\t}\n\t\t\t\t\telse if ( parenthesis != 0 ) {\n\t\t\t\t\t\tbuilder.append( operandToken );\n\t\t\t\t\t\tswitch ( operandToken ) {\n\t\t\t\t\t\t\tcase \"(\":\n\t\t\t\t\t\t\t\tparenthesis++;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase \")\":\n\t\t\t\t\t\t\t\tparenthesis--;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tbuilder.append( operandToken );\n\t\t\t\t\t\tswitch ( operandToken.toLowerCase( Locale.ROOT ) ) {\n\t\t\t\t\t\t\tcase \"(\":\n\t\t\t\t\t\t\t\tparenthesis++;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase \")\":\n\t\t\t\t\t\t\t\tparenthesis--;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase \"from\":\n\t\t\t\t\t\t\t\tif ( builder.length() != 0 ) {\n\t\t\t\t\t\t\t\t\toperands.add( builder.substring( 0, builder.length() - 4 ) );\n\t\t\t\t\t\t\t\t\tbuilder.setLength( 0 );\n\t\t\t\t\t\t\t\t\toperands.add( operandToken );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\toperandToken = tokens.nextToken();\n\t\t\t\t\thasMoreOperands = tokens.hasMoreTokens() && ( parenthesis != 0 || ! \")\".equals( operandToken ) );\n\t\t\t\t}\n\t\t\t\tif ( builder.length() != 0 ) {\n\t\t\t\t\toperands.add( builder.toString() );\n\t\t\t\t}\n\n\t\t\t\tTrimOperands trimOperands = new TrimOperands( operands );\n\t\t\t\tresult.append( \"trim(\" );\n\t\t\t\tif ( trimOperands.trimSpec != null ) {\n\t\t\t\t\tresult.append( trimOperands.trimSpec ).append( ' ' );\n\t\t\t\t}\n\t\t\t\tif ( trimOperands.trimChar != null ) {\n\t\t\t\t\tif ( trimOperands.trimChar.startsWith( \"'\" ) && trimOperands.trimChar.endsWith( \"'\" ) ) {\n\t\t\t\t\t\tresult.append( trimOperands.trimChar );\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tresult.append(\n\t\t\t\t\t\t\t\trenderWhereStringTemplate( trimOperands.trimSpec, placeholder, dialect, typeConfiguration, functionRegistry )\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\tresult.append( ' ' );\n\t\t\t\t}\n\t\t\t\tif ( trimOperands.from != null ) {\n\t\t\t\t\tresult.append( trimOperands.from ).append( ' ' );\n\t\t\t\t}\n\t\t\t\telse if ( trimOperands.trimSpec != null || trimOperands.trimChar != null ) {\n\t\t\t\t\t// I think ANSI SQL says that the 'from' is not optional if either trim-spec or trim-char is specified\n\t\t\t\t\tresult.append( \"from \" );\n\t\t\t\t}\n\n\t\t\t\tresult.append( renderWhereStringTemplate( trimOperands.trimSource, placeholder, dialect, typeConfiguration, functionRegistry ) )\n\t\t\t\t\t\t.append( ')' );\n\n\t\t\t\thasMore = tokens.hasMoreTokens();\n\t\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tboolean quotedOrWhitespace = quoted || quotedIdentifier || isQuoteCharacter\n\t\t\t\t\t|| Character.isWhitespace( token.charAt(0) );\n\n\t\t\tif ( quotedOrWhitespace ) {\n\t\t\t\tresult.append( token );\n\t\t\t}\n\t\t\telse if ( beforeTable ) {\n\t\t\t\tresult.append( token );\n\t\t\t\tbeforeTable = false;\n\t\t\t\tafterFromTable = true;\n\t\t\t}\n\t\t\telse if ( afterFromTable ) {\n\t\t\t\tif ( !\"as\".equals(lcToken) ) {\n\t\t\t\t\tafterFromTable = false;\n\t\t\t\t}\n\t\t\t\tresult.append(token);\n\t\t\t}\n\t\t\telse if ( isNamedParameter(token) ) {\n\t\t\t\tresult.append(token);\n\t\t\t}\n\t\t\telse if ( isIdentifier(token)\n\t\t\t\t\t&& !isFunctionOrKeyword(lcToken, nextToken, dialect, typeConfiguration, functionRegistry) ) {\n\t\t\t\tresult.append(placeholder)\n\t\t\t\t\t\t.append('.')\n\t\t\t\t\t\t.append( dialect.quote(token) );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif ( BEFORE_TABLE_KEYWORDS.contains(lcToken) ) {\n\t\t\t\t\tbeforeTable = true;\n\t\t\t\t\tinFromClause = true;\n\t\t\t\t}\n\t\t\t\telse if ( inFromClause && \",\".equals(lcToken) ) {\n\t\t\t\t\tbeforeTable = true;\n\t\t\t\t}\n\t\t\t\tif ( isBoolean( token ) ) {\n\t\t\t\t\ttoken = dialect.toBooleanValueString( Boolean.parseBoolean( token ) );\n\t\t\t\t}\n\t\t\t\tresult.append(token);\n\t\t\t}\n\n\t\t\t//Yuck:\n\t\t\tif ( inFromClause\n\t\t\t\t\t&& KEYWORDS.contains( lcToken ) //\"as\" is not in KEYWORDS\n\t\t\t\t\t&& !BEFORE_TABLE_KEYWORDS.contains( lcToken ) ) {\n\t\t\t\tinFromClause = false;\n\t\t\t}\n\t\t}\n\n\t\treturn result.toString();\n\t}\n\n\tprivate enum TimeZoneTokens {\n\t\tNONE,\n\t\tWITH,\n\t\tTIME,\n\t\tZONE;\n\n\t\tstatic TimeZoneTokens getPossibleNextTokens(String lctoken) {\n\t\t\tswitch ( lctoken ) {\n\t\t\t\tcase \"time\":\n\t\t\t\tcase \"timestamp\":\n\t\t\t\t\treturn WITH;\n\t\t\t\tdefault:\n\t\t\t\t\treturn NONE;\n\t\t\t}\n\t\t}\n\n\t\tpublic TimeZoneTokens nextToken() {\n\t\t\tif ( this == WITH ) {\n\t\t\t\treturn TIME;\n\t\t\t}\n\t\t\telse if ( this == TIME ) {\n\t\t\t\treturn ZONE;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn NONE;\n\t\t\t}\n\t\t}\n\n\t\tpublic boolean isToken(String token) {\n\t\t\treturn this != NONE && name().equalsIgnoreCase( token );\n\t\t}\n\t}\n\n\tpublic static List<String> collectColumnNames(\n\t\t\tString sql,\n\t\t\tDialect dialect,\n\t\t\tTypeConfiguration typeConfiguration,\n\t\t\tSqmFunctionRegistry functionRegistry) {\n\t\treturn collectColumnNames( renderWhereStringTemplate( sql, dialect, typeConfiguration, functionRegistry ) );\n\t}\n\n\tpublic static List<String> collectColumnNames(String template) {\n\t\tfinal List<String> names = new ArrayList<>();\n\t\tint begin = 0;\n\t\tint match;\n\t\twhile ( ( match = template.indexOf(TEMPLATE, begin) ) >= 0 ) {\n\t\t\tint start = match + TEMPLATE.length() + 1;\n\t\t\tfor ( int loc = start;; loc++ ) {\n\t\t\t\tif ( loc == template.length() - 1 ) {\n\t\t\t\t\tnames.add( template.substring( start ) );\n\t\t\t\t\tbegin = template.length();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tchar ch = template.charAt( loc );\n\t\t\t\t\tif ( PUNCTUATION.indexOf(ch) >= 0 || WHITESPACE.indexOf(ch) >= 0 ) {\n\t\t\t\t\t\tnames.add( template.substring( start, loc ) );\n\t\t\t\t\t\tbegin = loc;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn names;\n\t}\n\n//\t/**\n//\t * Takes the where condition provided in the mapping attribute and interpolates the alias.\n//\t * Handles sub-selects, quoted identifiers, quoted strings, expressions, SQL functions,\n//\t * named parameters.\n//\t *\n//\t * @param sqlWhereString The string into which to interpolate the placeholder value\n//\t * @param placeholder The value to be interpolated into the sqlWhereString\n//\t * @param dialect The dialect to apply\n//\t * @param functionRegistry The registry of all sql functions\n//\t *\n//\t * @return The rendered sql fragment\n//\t */\n//\tpublic static String renderWhereStringTemplate(\n//\t\t\tString sqlWhereString,\n//\t\t\tString placeholder,\n//\t\t\tDialect dialect,\n//\t\t\tSQLFunctionRegistry functionRegistry) {\n//\n//\t\t// IMPL NOTE : The basic process here is to tokenize the incoming string and to iterate over each token\n//\t\t//\t\tin turn.  As we process each token, we set a series of flags used to indicate the type of context in\n//\t\t// \t\twhich the tokens occur.  Depending on the state of those flags we decide whether we need to qualify\n//\t\t//\t\tidentifier references.\n//\n//\t\tfinal String dialectOpenQuote = Character.toString( dialect.openQuote() );\n//\t\tfinal String dialectCloseQuote = Character.toString( dialect.closeQuote() );\n//\n//\t\tString symbols = new StringBuilder()\n//\t\t\t\t.append( \"=><!+-*/()',|&`\" )\n//\t\t\t\t.append( StringHelper.WHITESPACE )\n//\t\t\t\t.append( dialect.openQuote() )\n//\t\t\t\t.append( dialect.closeQuote() )\n//\t\t\t\t.toString();\n//\t\tStringTokenizer tokens = new StringTokenizer( sqlWhereString, symbols, true );\n//\t\tProcessingState state = new ProcessingState();\n//\n//\t\tStringBuilder quotedBuffer = new StringBuilder();\n//\t\tStringBuilder result = new StringBuilder();\n//\n//\t\tboolean hasMore = tokens.hasMoreTokens();\n//\t\tString nextToken = hasMore ? tokens.nextToken() : null;\n//\t\twhile ( hasMore ) {\n//\t\t\tString token = nextToken;\n//\t\t\tString lcToken = token.toLowerCase(Locale.ROOT);\n//\t\t\thasMore = tokens.hasMoreTokens();\n//\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n//\n//\t\t\t// First, determine quoting which might be based on either:\n//\t\t\t// \t\t1) back-tick\n//\t\t\t// \t\t2) single quote (ANSI SQL standard)\n//\t\t\t// \t\t3) or dialect defined quote character(s)\n//\t\t\tQuotingCharacterDisposition quotingCharacterDisposition = QuotingCharacterDisposition.NONE;\n//\t\t\tif ( \"`\".equals( token ) ) {\n//\t\t\t\tstate.quoted = !state.quoted;\n//\t\t\t\tquotingCharacterDisposition = state.quoted\n//\t\t\t\t\t\t? QuotingCharacterDisposition.OPEN\n//\t\t\t\t\t\t: QuotingCharacterDisposition.CLOSE;\n//\t\t\t\t// replace token with the appropriate dialect quoting char\n//\t\t\t\ttoken = lcToken = ( quotingCharacterDisposition == QuotingCharacterDisposition.OPEN )\n//\t\t\t\t\t\t? dialectOpenQuote\n//\t\t\t\t\t\t: dialectCloseQuote;\n//\t\t\t}\n//\t\t\telse if ( \"'\".equals( token ) ) {\n//\t\t\t\tstate.quoted = !state.quoted;\n//\t\t\t\tquotingCharacterDisposition = state.quoted\n//\t\t\t\t\t\t? QuotingCharacterDisposition.OPEN\n//\t\t\t\t\t\t: QuotingCharacterDisposition.CLOSE;\n//\t\t\t}\n//\t\t\telse if ( !state.quoted && dialectOpenQuote.equals( token ) ) {\n//\t\t\t\tstate.quoted = true;\n//\t\t\t\tquotingCharacterDisposition = QuotingCharacterDisposition.OPEN;\n//\t\t\t}\n//\t\t\telse if ( state.quoted && dialectCloseQuote.equals( token ) ) {\n//\t\t\t\tstate.quoted = false;\n//\t\t\t\tquotingCharacterDisposition = QuotingCharacterDisposition.CLOSE;\n//\t\t\t}\n//\n//\t\t\tif ( state.quoted ) {\n//\t\t\t\tquotedBuffer.append( token );\n//\t\t\t\tcontinue;\n//\t\t\t}\n//\n//\t\t\t// if we were previously processing quoted state and just encountered the close quote, then handle that\n//\t\t\t// quoted text\n//\t\t\tif ( quotingCharacterDisposition == QuotingCharacterDisposition.CLOSE ) {\n//\t\t\t\ttoken = quotedBuffer.toString();\n//\t\t\t\tquotedBuffer.setLength( 0 );\n//\t\t\t\tresult.append( placeholder ).append( '.' )\n//\t\t\t\t\t\t.append( dialectOpenQuote ).append( token ).append( dialectCloseQuote );\n//\t\t\t\tcontinue;\n//\t\t\t}\n//\n//\t\t\t// Special processing for ANSI SQL EXTRACT function\n//\t\t\tif ( \"extract\".equals( lcToken ) && \"(\".equals( nextToken ) ) {\n//\t\t\t\tfinal String field = extractUntil( tokens, \"from\" );\n//\t\t\t\tfinal String source = renderWhereStringTemplate(\n//\t\t\t\t\t\textractUntil( tokens, \")\" ),\n//\t\t\t\t\t\tplaceholder,\n//\t\t\t\t\t\tdialect,\n//\t\t\t\t\t\tfunctionRegistry\n//\t\t\t\t);\n//\t\t\t\tresult.append( \"extract(\" ).append( field ).append( \" from \" ).append( source ).append( ')' );\n//\n//\t\t\t\thasMore = tokens.hasMoreTokens();\n//\t\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n//\n//\t\t\t\tcontinue;\n//\t\t\t}\n//\n//\t\t\t// Special processing for ANSI SQL TRIM function\n//\t\t\tif ( \"trim\".equals( lcToken ) && \"(\".equals( nextToken ) ) {\n//\t\t\t\tList<String> operands = new ArrayList<String>();\n//\t\t\t\tStringBuilder builder = new StringBuilder();\n//\n//\t\t\t\tboolean hasMoreOperands = true;\n//\t\t\t\tString operandToken = tokens.nextToken();\n//\t\t\t\tboolean quoted = false;\n//\t\t\t\twhile ( hasMoreOperands ) {\n//\t\t\t\t\tfinal boolean isQuote = \"'\".equals( operandToken );\n//\t\t\t\t\tif ( isQuote ) {\n//\t\t\t\t\t\tquoted = !quoted;\n//\t\t\t\t\t\tif ( !quoted ) {\n//\t\t\t\t\t\t\toperands.add( builder.append( '\\'' ).toString() );\n//\t\t\t\t\t\t\tbuilder.setLength( 0 );\n//\t\t\t\t\t\t}\n//\t\t\t\t\t\telse {\n//\t\t\t\t\t\t\tbuilder.append( '\\'' );\n//\t\t\t\t\t\t}\n//\t\t\t\t\t}\n//\t\t\t\t\telse if ( quoted ) {\n//\t\t\t\t\t\tbuilder.append( operandToken );\n//\t\t\t\t\t}\n//\t\t\t\t\telse if ( operandToken.length() == 1 && Character.isWhitespace( operandToken.charAt( 0 ) ) ) {\n//\t\t\t\t\t\t// do nothing\n//\t\t\t\t\t}\n//\t\t\t\t\telse {\n//\t\t\t\t\t\toperands.add( operandToken );\n//\t\t\t\t\t}\n//\t\t\t\t\toperandToken = tokens.nextToken();\n//\t\t\t\t\thasMoreOperands = tokens.hasMoreTokens() && ! \")\".equals( operandToken );\n//\t\t\t\t}\n//\n//\t\t\t\tTrimOperands trimOperands = new TrimOperands( operands );\n//\t\t\t\tresult.append( \"trim(\" );\n//\t\t\t\tif ( trimOperands.trimSpec != null ) {\n//\t\t\t\t\tresult.append( trimOperands.trimSpec ).append( ' ' );\n//\t\t\t\t}\n//\t\t\t\tif ( trimOperands.trimChar != null ) {\n//\t\t\t\t\tif ( trimOperands.trimChar.startsWith( \"'\" ) && trimOperands.trimChar.endsWith( \"'\" ) ) {\n//\t\t\t\t\t\tresult.append( trimOperands.trimChar );\n//\t\t\t\t\t}\n//\t\t\t\t\telse {\n//\t\t\t\t\t\tresult.append(\n//\t\t\t\t\t\t\t\trenderWhereStringTemplate( trimOperands.trimSpec, placeholder, dialect, functionRegistry )\n//\t\t\t\t\t\t);\n//\t\t\t\t\t}\n//\t\t\t\t\tresult.append( ' ' );\n//\t\t\t\t}\n//\t\t\t\tif ( trimOperands.from != null ) {\n//\t\t\t\t\tresult.append( trimOperands.from ).append( ' ' );\n//\t\t\t\t}\n//\t\t\t\telse if ( trimOperands.trimSpec != null || trimOperands.trimChar != null ) {\n//\t\t\t\t\t// I think ANSI SQL says that the 'from' is not optional if either trim-spec or trim-char are specified\n//\t\t\t\t\tresult.append( \"from \" );\n//\t\t\t\t}\n//\n//\t\t\t\tresult.append( renderWhereStringTemplate( trimOperands.trimSource, placeholder, dialect, functionRegistry ) )\n//\t\t\t\t\t\t.append( ')' );\n//\n//\t\t\t\thasMore = tokens.hasMoreTokens();\n//\t\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n//\n//\t\t\t\tcontinue;\n//\t\t\t}\n//\n//\n//\t\t\t// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n//\n//\t\t\tif ( Character.isWhitespace( token.charAt( 0 ) ) ) {\n//\t\t\t\tresult.append( token );\n//\t\t\t}\n//\t\t\telse if ( state.beforeTable ) {\n//\t\t\t\tresult.append( token );\n//\t\t\t\tstate.beforeTable = false;\n//\t\t\t\tstate.afterFromTable = true;\n//\t\t\t}\n//\t\t\telse if ( state.afterFromTable ) {\n//\t\t\t\tif ( !\"as\".equals(lcToken) ) {\n//\t\t\t\t\tstate.afterFromTable = false;\n//\t\t\t\t}\n//\t\t\t\tresult.append(token);\n//\t\t\t}\n//\t\t\telse if ( isNamedParameter(token) ) {\n//\t\t\t\tresult.append(token);\n//\t\t\t}\n//\t\t\telse if ( isIdentifier(token, dialect)\n//\t\t\t\t\t&& !isFunctionOrKeyword(lcToken, nextToken, dialect , functionRegistry) ) {\n//\t\t\t\tresult.append(placeholder)\n//\t\t\t\t\t\t.append('.')\n//\t\t\t\t\t\t.append( dialect.quote(token) );\n//\t\t\t}\n//\t\t\telse {\n//\t\t\t\tif ( BEFORE_TABLE_KEYWORDS.contains(lcToken) ) {\n//\t\t\t\t\tstate.beforeTable = true;\n//\t\t\t\t\tstate.inFromClause = true;\n//\t\t\t\t}\n//\t\t\t\telse if ( state.inFromClause && \",\".equals(lcToken) ) {\n//\t\t\t\t\tstate.beforeTable = true;\n//\t\t\t\t}\n//\t\t\t\tresult.append(token);\n//\t\t\t}\n//\n//\t\t\t//Yuck:\n//\t\t\tif ( state.inFromClause\n//\t\t\t\t\t&& KEYWORDS.contains( lcToken ) //\"as\" is not in KEYWORDS\n//\t\t\t\t\t&& !BEFORE_TABLE_KEYWORDS.contains( lcToken ) ) {\n//\t\t\t\tstate.inFromClause = false;\n//\t\t\t}\n//\t\t}\n//\n//\t\treturn result.toString();\n//\t}\n//\n//\tprivate static class ProcessingState {\n//\t\tboolean quoted = false;\n//\t\tboolean quotedIdentifier = false;\n//\t\tboolean beforeTable = false;\n//\t\tboolean inFromClause = false;\n//\t\tboolean afterFromTable = false;\n//\t}\n//\n//\tprivate static enum QuotingCharacterDisposition { NONE, OPEN, CLOSE }\n\n\tprivate static class TrimOperands {\n\t\tprivate final String trimSpec;\n\t\tprivate final String trimChar;\n\t\tprivate final String from;\n\t\tprivate final String trimSource;\n\n\t\tprivate TrimOperands(List<String> operands) {\n\t\t\tfinal int size = operands.size();\n\t\t\tif ( size == 1 ) {\n\t\t\t\ttrimSpec = null;\n\t\t\t\ttrimChar = null;\n\t\t\t\tfrom = null;\n\t\t\t\ttrimSource = operands.get(0);\n\t\t\t}\n\t\t\telse if ( size == 4 ) {\n\t\t\t\ttrimSpec = operands.get(0);\n\t\t\t\ttrimChar = operands.get(1);\n\t\t\t\tfrom = operands.get(2);\n\t\t\t\ttrimSource = operands.get(3);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif ( size < 1 || size > 4 ) {\n\t\t\t\t\tthrow new HibernateException( \"Unexpected number of trim function operands : \" + size );\n\t\t\t\t}\n\n\t\t\t\t// trim-source will always be the last operand\n\t\t\t\ttrimSource = operands.get( size - 1 );\n\n\t\t\t\t// ANSI SQL says that more than one operand means that the FROM is required\n\t\t\t\tif ( ! \"from\".equals( operands.get( size - 2 ) ) ) {\n\t\t\t\t\tthrow new HibernateException( \"Expecting FROM, found : \" + operands.get( size - 2 ) );\n\t\t\t\t}\n\t\t\t\tfrom = operands.get( size - 2 );\n\n\t\t\t\t// trim-spec, if there is one will always be the first operand\n\t\t\t\tif ( \"leading\".equalsIgnoreCase( operands.get(0) )\n\t\t\t\t\t\t|| \"trailing\".equalsIgnoreCase( operands.get(0) )\n\t\t\t\t\t\t|| \"both\".equalsIgnoreCase( operands.get(0) ) ) {\n\t\t\t\t\ttrimSpec = operands.get(0);\n\t\t\t\t\ttrimChar = null;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ttrimSpec = null;\n\t\t\t\t\tif ( size - 2 == 0 ) {\n\t\t\t\t\t\ttrimChar = null;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\ttrimChar = operands.get( 0 );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate static String extractUntil(StringTokenizer tokens, String delimiter) {\n\t\tStringBuilder valueBuilder = new StringBuilder();\n\t\tString token = tokens.nextToken();\n\t\twhile ( ! delimiter.equalsIgnoreCase( token ) ) {\n\t\t\tvalueBuilder.append( token );\n\t\t\ttoken = tokens.nextToken();\n\t\t}\n\t\treturn valueBuilder.toString().trim();\n\t}\n\n\tprivate static boolean isNamedParameter(String token) {\n\t\treturn token.startsWith( \":\" );\n\t}\n\n\tprivate static boolean isFunctionOrKeyword(\n\t\t\tString lcToken,\n\t\t\tString nextToken,\n\t\t\tDialect dialect,\n\t\t\tTypeConfiguration typeConfiguration,\n\t\t\tSqmFunctionRegistry functionRegistry) {\n\t\treturn \"(\".equals( nextToken ) ||\n\t\t\t\tKEYWORDS.contains( lcToken ) ||\n\t\t\t\tisType( lcToken, typeConfiguration ) ||\n\t\t\t\tisFunction( lcToken, nextToken, functionRegistry ) ||\n\t\t\t\tdialect.getKeywords().contains( lcToken ) ||\n\t\t\t\tFUNCTION_KEYWORDS.contains( lcToken );\n\t}\n\n\tprivate static boolean isType(String lcToken, TypeConfiguration typeConfiguration) {\n\t\treturn typeConfiguration.getDdlTypeRegistry().isTypeNameRegistered( lcToken );\n\t}\n\n\tprivate static boolean isFunction(String lcToken, String nextToken, SqmFunctionRegistry functionRegistry) {\n\t\t// checking for \"(\" is currently redundant because it is checked before getting here;\n\t\t// doing the check anyhow, in case that earlier check goes away;\n\t\tif ( \"(\".equals( nextToken ) ) {\n\t\t\treturn true;\n\t\t}\n\n\t\tfinal SqmFunctionDescriptor function = functionRegistry.findFunctionDescriptor( lcToken );\n\t\treturn function != null;\n\t}\n\n\tprivate static boolean isIdentifier(String token) {\n\t\tif ( isBoolean( token ) ) {\n\t\t\treturn false;\n\t\t}\n\t\treturn token.charAt( 0 ) == '`' || ( //allow any identifier quoted with backtick\n\t\t\t\tCharacter.isLetter( token.charAt( 0 ) ) && //only recognizes identifiers beginning with a letter\n\t\t\t\t\t\ttoken.indexOf( '.' ) < 0\n\t\t);\n\t}\n\n\tprivate static boolean isBoolean(String token) {\n\t\treturn \"true\".equals( token ) || \"false\".equals( token );\n\t}\n}\n",
        "filePathAfter": "hibernate-core/src/main/java/org/hibernate/sql/Template.java",
        "sourceCodeAfterForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.\n */\npackage org.hibernate.sql;\n\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Set;\nimport java.util.StringTokenizer;\n\nimport org.hibernate.HibernateException;\nimport org.hibernate.dialect.Dialect;\nimport org.hibernate.query.sqm.function.SqmFunctionDescriptor;\nimport org.hibernate.query.sqm.function.SqmFunctionRegistry;\nimport org.hibernate.type.spi.TypeConfiguration;\n\nimport static java.lang.Boolean.parseBoolean;\nimport static java.lang.Character.isLetter;\nimport static org.hibernate.internal.util.StringHelper.WHITESPACE;\n\n/**\n * Parses SQL fragments specified in mapping documents.\n *\n * @author Gavin King\n */\npublic final class Template {\n\n\tprivate static final Set<String> KEYWORDS = new HashSet<>();\n\tprivate static final Set<String> BEFORE_TABLE_KEYWORDS = new HashSet<>();\n\tprivate static final Set<String> FUNCTION_KEYWORDS = new HashSet<>();\n\tprivate static final Set<String> LITERAL_PREFIXES = new HashSet<>();\n\tpublic static final String PUNCTUATION = \"=><!+-*/()',|&`\";\n\n\tstatic {\n\t\tKEYWORDS.add(\"and\");\n\t\tKEYWORDS.add(\"or\");\n\t\tKEYWORDS.add(\"not\");\n\t\tKEYWORDS.add(\"like\");\n\t\tKEYWORDS.add(\"escape\");\n\t\tKEYWORDS.add(\"is\");\n\t\tKEYWORDS.add(\"in\");\n\t\tKEYWORDS.add(\"between\");\n\t\tKEYWORDS.add(\"null\");\n\t\tKEYWORDS.add(\"select\");\n\t\tKEYWORDS.add(\"distinct\");\n\t\tKEYWORDS.add(\"from\");\n\t\tKEYWORDS.add(\"join\");\n\t\tKEYWORDS.add(\"inner\");\n\t\tKEYWORDS.add(\"outer\");\n\t\tKEYWORDS.add(\"left\");\n\t\tKEYWORDS.add(\"right\");\n\t\tKEYWORDS.add(\"on\");\n\t\tKEYWORDS.add(\"where\");\n\t\tKEYWORDS.add(\"having\");\n\t\tKEYWORDS.add(\"group\");\n\t\tKEYWORDS.add(\"order\");\n\t\tKEYWORDS.add(\"by\");\n\t\tKEYWORDS.add(\"desc\");\n\t\tKEYWORDS.add(\"asc\");\n\t\tKEYWORDS.add(\"limit\");\n\t\tKEYWORDS.add(\"any\");\n\t\tKEYWORDS.add(\"some\");\n\t\tKEYWORDS.add(\"exists\");\n\t\tKEYWORDS.add(\"all\");\n\t\tKEYWORDS.add(\"union\");\n\t\tKEYWORDS.add(\"minus\");\n\t\tKEYWORDS.add(\"except\");\n\t\tKEYWORDS.add(\"intersect\");\n\t\tKEYWORDS.add(\"partition\");\n\n\t\tBEFORE_TABLE_KEYWORDS.add(\"from\");\n\t\tBEFORE_TABLE_KEYWORDS.add(\"join\");\n\n\t\tFUNCTION_KEYWORDS.add(\"as\");\n\t\tFUNCTION_KEYWORDS.add(\"leading\");\n\t\tFUNCTION_KEYWORDS.add(\"trailing\");\n\t\tFUNCTION_KEYWORDS.add(\"from\");\n\t\tFUNCTION_KEYWORDS.add(\"case\");\n\t\tFUNCTION_KEYWORDS.add(\"when\");\n\t\tFUNCTION_KEYWORDS.add(\"then\");\n\t\tFUNCTION_KEYWORDS.add(\"else\");\n\t\tFUNCTION_KEYWORDS.add(\"end\");\n\n\t\tLITERAL_PREFIXES.add(\"n\");\n\t\tLITERAL_PREFIXES.add(\"x\");\n\t\tLITERAL_PREFIXES.add(\"varbyte\");\n\t\tLITERAL_PREFIXES.add(\"bx\");\n\t\tLITERAL_PREFIXES.add(\"bytea\");\n\t\tLITERAL_PREFIXES.add(\"date\");\n\t\tLITERAL_PREFIXES.add(\"time\");\n\t\tLITERAL_PREFIXES.add(\"timestamp\");\n\t\tLITERAL_PREFIXES.add(\"zone\");\n\t}\n\n\tpublic static final String TEMPLATE = \"$PlaceHolder$\";\n\n\tprivate Template() {}\n\n\tpublic static String renderTransformerReadFragment(\n\t\t\tString fragment,\n\t\t\tString... columnNames) {\n\t\t// NOTE : would need access to SessionFactoryImplementor to make this configurable\n\t\tfor ( String columnName : columnNames ) {\n\t\t\tfragment = fragment.replace( columnName, TEMPLATE + '.' + columnName );\n\t\t}\n\t\treturn fragment;\n\t}\n\n\tpublic static String renderWhereStringTemplate(\n\t\t\tString sqlWhereString,\n\t\t\tDialect dialect,\n\t\t\tTypeConfiguration typeConfiguration,\n\t\t\tSqmFunctionRegistry functionRegistry) {\n\t\treturn renderWhereStringTemplate( sqlWhereString, TEMPLATE, dialect, typeConfiguration, functionRegistry );\n\t}\n\n\t/**\n\t * Takes the where condition provided in the mapping attribute and interpolates the alias.\n\t * Handles sub-selects, quoted identifiers, quoted strings, expressions, SQL functions,\n\t * named parameters.\n\t *\n\t * @param sqlWhereString The string into which to interpolate the placeholder value\n\t * @param placeholder The value to be interpolated into the sqlWhereString\n\t * @param dialect The dialect to apply\n\t * @param functionRegistry The registry of all sql functions\n\t * @return The rendered sql fragment\n\t */\n\tpublic static String renderWhereStringTemplate(\n\t\t\tString sqlWhereString,\n\t\t\tString placeholder,\n\t\t\tDialect dialect,\n\t\t\tTypeConfiguration typeConfiguration,\n\t\t\tSqmFunctionRegistry functionRegistry) {\n\n\t\t// IMPL NOTE : The basic process here is to tokenize the incoming string and to iterate over each token\n\t\t//\t\tin turn.  As we process each token, we set a series of flags used to indicate the type of context in\n\t\t// \t\twhich the tokens occur.  Depending on the state of those flags we decide whether we need to qualify\n\t\t//\t\tidentifier references.\n\n\t\tfinal String symbols = PUNCTUATION + WHITESPACE + dialect.openQuote() + dialect.closeQuote();\n\t\tfinal StringTokenizer tokens = new StringTokenizer( sqlWhereString, symbols, true );\n\t\tfinal StringBuilder result = new StringBuilder();\n\n\t\tboolean quoted = false;\n\t\tboolean quotedIdentifier = false;\n\t\tboolean beforeTable = false;\n\t\tboolean inFromClause = false;\n\t\tboolean afterFromTable = false;\n\n\t\tboolean hasMore = tokens.hasMoreTokens();\n\t\tString nextToken = hasMore ? tokens.nextToken() : null;\n\t\twhile ( hasMore ) {\n\t\t\tString token = nextToken;\n\t\t\tString lcToken = token.toLowerCase(Locale.ROOT);\n\t\t\thasMore = tokens.hasMoreTokens();\n\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n\n\t\t\tboolean isQuoteCharacter = false;\n\n\t\t\tif ( !quotedIdentifier && \"'\".equals(token) ) {\n\t\t\t\tquoted = !quoted;\n\t\t\t\tisQuoteCharacter = true;\n\t\t\t}\n\n\t\t\tif ( !quoted ) {\n\t\t\t\tfinal boolean isOpenQuote;\n\t\t\t\tif ( \"`\".equals(token) ) {\n\t\t\t\t\tisOpenQuote = !quotedIdentifier;\n\t\t\t\t\ttoken = lcToken = isOpenQuote\n\t\t\t\t\t\t\t? Character.toString( dialect.openQuote() )\n\t\t\t\t\t\t\t: Character.toString( dialect.closeQuote() );\n\t\t\t\t\tquotedIdentifier = isOpenQuote;\n\t\t\t\t\tisQuoteCharacter = true;\n\t\t\t\t}\n\t\t\t\telse if ( !quotedIdentifier && dialect.openQuote()==token.charAt(0) ) {\n\t\t\t\t\tisOpenQuote = true;\n\t\t\t\t\tquotedIdentifier = true;\n\t\t\t\t\tisQuoteCharacter = true;\n\t\t\t\t}\n\t\t\t\telse if ( quotedIdentifier && dialect.closeQuote()==token.charAt(0) ) {\n\t\t\t\t\tquotedIdentifier = false;\n\t\t\t\t\tisQuoteCharacter = true;\n\t\t\t\t\tisOpenQuote = false;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tisOpenQuote = false;\n\t\t\t\t}\n\t\t\t\tif ( isOpenQuote ) {\n\t\t\t\t\tresult.append( placeholder ).append( '.' );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfinal boolean quotedOrWhitespace =\n\t\t\t\t\tquoted || quotedIdentifier || isQuoteCharacter\n\t\t\t\t\t\t\t|| token.isBlank();\n\t\t\tif ( quotedOrWhitespace ) {\n\t\t\t\tresult.append( token );\n\t\t\t}\n\t\t\telse if ( beforeTable ) {\n\t\t\t\tresult.append( token );\n\t\t\t\tbeforeTable = false;\n\t\t\t\tafterFromTable = true;\n\t\t\t}\n\t\t\telse if ( afterFromTable ) {\n\t\t\t\tif ( !\"as\".equals(lcToken) ) {\n\t\t\t\t\tafterFromTable = false;\n\t\t\t\t}\n\t\t\t\tresult.append(token);\n\t\t\t}\n\t\t\telse if ( isNamedParameter(token) ) {\n\t\t\t\tresult.append(token);\n\t\t\t}\n\t\t\telse if ( isExtractFunction( lcToken, nextToken ) ) {\n\t\t\t\t// Special processing for ANSI SQL EXTRACT function\n\t\t\t\thandleExtractFunction( placeholder, dialect, typeConfiguration, functionRegistry, tokens, result );\n\t\t\t\thasMore = tokens.hasMoreTokens();\n\t\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n\t\t\t}\n\t\t\telse if ( isTrimFunction( lcToken, nextToken ) ) {\n\t\t\t\t// Special processing for ANSI SQL TRIM function\n\t\t\t\thandleTrimFunction( placeholder, dialect, typeConfiguration, functionRegistry, tokens, result );\n\t\t\t\thasMore = tokens.hasMoreTokens();\n\t\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n\t\t\t}\n\t\t\telse if ( isIdentifier(token)\n\t\t\t\t\t&& !isFunctionOrKeyword( lcToken, nextToken, dialect, typeConfiguration, functionRegistry )\n\t\t\t\t\t&& !isLiteral( lcToken, nextToken, sqlWhereString, symbols, tokens ) ) {\n\t\t\t\tresult.append(placeholder)\n\t\t\t\t\t\t.append('.')\n\t\t\t\t\t\t.append( dialect.quote(token) );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif ( BEFORE_TABLE_KEYWORDS.contains(lcToken) ) {\n\t\t\t\t\tbeforeTable = true;\n\t\t\t\t\tinFromClause = true;\n\t\t\t\t}\n\t\t\t\telse if ( inFromClause && \",\".equals(lcToken) ) {\n\t\t\t\t\tbeforeTable = true;\n\t\t\t\t}\n\t\t\t\tif ( isBoolean( token ) ) {\n\t\t\t\t\ttoken = dialect.toBooleanValueString( parseBoolean( token ) );\n\t\t\t\t}\n\t\t\t\tresult.append(token);\n\t\t\t}\n\n\t\t\t//Yuck:\n\t\t\tif ( inFromClause\n\t\t\t\t\t&& KEYWORDS.contains( lcToken ) //\"as\" is not in KEYWORDS\n\t\t\t\t\t&& !BEFORE_TABLE_KEYWORDS.contains( lcToken ) ) {\n\t\t\t\tinFromClause = false;\n\t\t\t}\n\t\t}\n\n\t\treturn result.toString();\n\t}\n\n\tprivate static boolean isTrimFunction(String lcToken, String nextToken) {\n\t\treturn \"trim\".equals(lcToken) && \"(\".equals(nextToken);\n\t}\n\n\tprivate static boolean isExtractFunction(String lcToken, String nextToken) {\n\t\treturn \"extract\".equals(lcToken) && \"(\".equals(nextToken);\n\t}\n\n\tprivate static boolean isLiteral(\n\t\t\tString lcToken, String next,\n\t\t\tString sqlWhereString, String symbols, StringTokenizer tokens) {\n\t\tif ( LITERAL_PREFIXES.contains( lcToken ) && next != null ) {\n\t\t\t// easy cases first\n\t\t\tif ( \"'\".equals(next) ) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse if ( !next.isBlank() ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// we need to look ahead in the token stream\n\t\t\t\t// to find the first non-blank token\n\t\t\t\tfinal StringTokenizer lookahead =\n\t\t\t\t\t\tnew StringTokenizer( sqlWhereString, symbols, true );\n\t\t\t\twhile ( lookahead.countTokens() > tokens.countTokens()+1 ) {\n\t\t\t\t\tlookahead.nextToken();\n\t\t\t\t}\n\t\t\t\tif ( lookahead.hasMoreTokens() ) {\n\t\t\t\t\tString nextToken;\n\t\t\t\t\tdo {\n\t\t\t\t\t\tnextToken = lookahead.nextToken().toLowerCase(Locale.ROOT);\n\t\t\t\t\t}\n\t\t\t\t\twhile ( nextToken.isBlank() && lookahead.hasMoreTokens() );\n\t\t\t\t\treturn \"'\".equals( nextToken )\n\t\t\t\t\t\t|| lcToken.equals( \"time\" ) && \"with\".equals( nextToken )\n\t\t\t\t\t\t|| lcToken.equals( \"timestamp\" ) && \"with\".equals( nextToken )\n\t\t\t\t\t\t|| lcToken.equals( \"time\" ) && \"zone\".equals( nextToken );\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tprivate static void handleTrimFunction(\n\t\t\tString placeholder, Dialect dialect,\n\t\t\tTypeConfiguration typeConfiguration,\n\t\t\tSqmFunctionRegistry functionRegistry,\n\t\t\tStringTokenizer tokens,\n\t\t\tStringBuilder result) {\n\t\tfinal List<String> operands = new ArrayList<>();\n\t\tfinal StringBuilder builder = new StringBuilder();\n\n\t\tboolean hasMoreOperands = true;\n\t\tString operandToken = tokens.nextToken();\n\t\tswitch ( operandToken.toLowerCase( Locale.ROOT ) ) {\n\t\t\tcase \"leading\":\n\t\t\tcase \"trailing\":\n\t\t\tcase \"both\":\n\t\t\t\toperands.add( operandToken );\n\t\t\t\tif ( hasMoreOperands = tokens.hasMoreTokens() ) {\n\t\t\t\t\toperandToken = tokens.nextToken();\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t\tboolean quotedOperand = false;\n\t\tint parenthesis = 0;\n\t\twhile ( hasMoreOperands ) {\n\t\t\tfinal boolean isQuote = \"'\".equals( operandToken );\n\t\t\tif ( isQuote ) {\n\t\t\t\tquotedOperand = !quotedOperand;\n\t\t\t\tif ( !quotedOperand ) {\n\t\t\t\t\toperands.add( builder.append( '\\'' ).toString() );\n\t\t\t\t\tbuilder.setLength( 0 );\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tbuilder.append( '\\'' );\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if ( quotedOperand ) {\n\t\t\t\tbuilder.append( operandToken );\n\t\t\t}\n\t\t\telse if ( parenthesis != 0 ) {\n\t\t\t\tbuilder.append( operandToken );\n\t\t\t\tswitch ( operandToken ) {\n\t\t\t\t\tcase \"(\":\n\t\t\t\t\t\tparenthesis++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \")\":\n\t\t\t\t\t\tparenthesis--;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbuilder.append( operandToken );\n\t\t\t\tswitch ( operandToken.toLowerCase( Locale.ROOT ) ) {\n\t\t\t\t\tcase \"(\":\n\t\t\t\t\t\tparenthesis++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \")\":\n\t\t\t\t\t\tparenthesis--;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"from\":\n\t\t\t\t\t\tif ( !builder.isEmpty() ) {\n\t\t\t\t\t\t\toperands.add( builder.substring( 0, builder.length() - 4 ) );\n\t\t\t\t\t\t\tbuilder.setLength( 0 );\n\t\t\t\t\t\t\toperands.add( operandToken );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\toperandToken = tokens.nextToken();\n\t\t\thasMoreOperands = tokens.hasMoreTokens()\n\t\t\t\t\t&& ( parenthesis != 0 || ! \")\".equals( operandToken ) );\n\t\t}\n\t\tif ( !builder.isEmpty() ) {\n\t\t\toperands.add( builder.toString() );\n\t\t}\n\n\t\tfinal TrimOperands trimOperands = new TrimOperands( operands );\n\t\tresult.append( \"trim(\" );\n\t\tif ( trimOperands.trimSpec != null ) {\n\t\t\tresult.append( trimOperands.trimSpec ).append( ' ' );\n\t\t}\n\t\tif ( trimOperands.trimChar != null ) {\n\t\t\tif ( trimOperands.trimChar.startsWith( \"'\" ) && trimOperands.trimChar.endsWith( \"'\" ) ) {\n\t\t\t\tresult.append( trimOperands.trimChar );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tresult.append(\n\t\t\t\t\t\trenderWhereStringTemplate( trimOperands.trimSpec, placeholder, dialect, typeConfiguration, functionRegistry )\n\t\t\t\t);\n\t\t\t}\n\t\t\tresult.append( ' ' );\n\t\t}\n\t\tif ( trimOperands.from != null ) {\n\t\t\tresult.append( trimOperands.from ).append( ' ' );\n\t\t}\n\t\telse if ( trimOperands.trimSpec != null || trimOperands.trimChar != null ) {\n\t\t\t// I think ANSI SQL says that the 'from' is not optional if either trim-spec or trim-char is specified\n\t\t\tresult.append( \"from \" );\n\t\t}\n\n\t\tresult.append( renderWhereStringTemplate( trimOperands.trimSource, placeholder, dialect, typeConfiguration, functionRegistry ) )\n\t\t\t\t.append( ')' );\n\t}\n\n\tprivate static void handleExtractFunction(\n\t\t\tString placeholder,\n\t\t\tDialect dialect,\n\t\t\tTypeConfiguration typeConfiguration,\n\t\t\tSqmFunctionRegistry functionRegistry,\n\t\t\tStringTokenizer tokens,\n\t\t\tStringBuilder result) {\n\t\tfinal String field = extractUntil( tokens, \"from\" );\n\t\tfinal String source = renderWhereStringTemplate(\n\t\t\t\textractUntil( tokens, \")\" ),\n\t\t\t\tplaceholder,\n\t\t\t\tdialect,\n\t\t\t\ttypeConfiguration,\n\t\t\t\tfunctionRegistry\n\t\t);\n\t\tresult.append( \"extract(\" ).append( field ).append( \" from \" ).append( source ).append( ')' );\n\t}\n\n\tpublic static List<String> collectColumnNames(\n\t\t\tString sql,\n\t\t\tDialect dialect,\n\t\t\tTypeConfiguration typeConfiguration,\n\t\t\tSqmFunctionRegistry functionRegistry) {\n\t\treturn collectColumnNames( renderWhereStringTemplate( sql, dialect, typeConfiguration, functionRegistry ) );\n\t}\n\n\tpublic static List<String> collectColumnNames(String template) {\n\t\tfinal List<String> names = new ArrayList<>();\n\t\tint begin = 0;\n\t\tint match;\n\t\twhile ( ( match = template.indexOf(TEMPLATE, begin) ) >= 0 ) {\n\t\t\tint start = match + TEMPLATE.length() + 1;\n\t\t\tfor ( int loc = start;; loc++ ) {\n\t\t\t\tif ( loc == template.length() - 1 ) {\n\t\t\t\t\tnames.add( template.substring( start ) );\n\t\t\t\t\tbegin = template.length();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tchar ch = template.charAt( loc );\n\t\t\t\t\tif ( PUNCTUATION.indexOf(ch) >= 0 || WHITESPACE.indexOf(ch) >= 0 ) {\n\t\t\t\t\t\tnames.add( template.substring( start, loc ) );\n\t\t\t\t\t\tbegin = loc;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn names;\n\t}\n\n//\t/**\n//\t * Takes the where condition provided in the mapping attribute and interpolates the alias.\n//\t * Handles sub-selects, quoted identifiers, quoted strings, expressions, SQL functions,\n//\t * named parameters.\n//\t *\n//\t * @param sqlWhereString The string into which to interpolate the placeholder value\n//\t * @param placeholder The value to be interpolated into the sqlWhereString\n//\t * @param dialect The dialect to apply\n//\t * @param functionRegistry The registry of all sql functions\n//\t *\n//\t * @return The rendered sql fragment\n//\t */\n//\tpublic static String renderWhereStringTemplate(\n//\t\t\tString sqlWhereString,\n//\t\t\tString placeholder,\n//\t\t\tDialect dialect,\n//\t\t\tSQLFunctionRegistry functionRegistry) {\n//\n//\t\t// IMPL NOTE : The basic process here is to tokenize the incoming string and to iterate over each token\n//\t\t//\t\tin turn.  As we process each token, we set a series of flags used to indicate the type of context in\n//\t\t// \t\twhich the tokens occur.  Depending on the state of those flags we decide whether we need to qualify\n//\t\t//\t\tidentifier references.\n//\n//\t\tfinal String dialectOpenQuote = Character.toString( dialect.openQuote() );\n//\t\tfinal String dialectCloseQuote = Character.toString( dialect.closeQuote() );\n//\n//\t\tString symbols = new StringBuilder()\n//\t\t\t\t.append( \"=><!+-*/()',|&`\" )\n//\t\t\t\t.append( StringHelper.WHITESPACE )\n//\t\t\t\t.append( dialect.openQuote() )\n//\t\t\t\t.append( dialect.closeQuote() )\n//\t\t\t\t.toString();\n//\t\tStringTokenizer tokens = new StringTokenizer( sqlWhereString, symbols, true );\n//\t\tProcessingState state = new ProcessingState();\n//\n//\t\tStringBuilder quotedBuffer = new StringBuilder();\n//\t\tStringBuilder result = new StringBuilder();\n//\n//\t\tboolean hasMore = tokens.hasMoreTokens();\n//\t\tString nextToken = hasMore ? tokens.nextToken() : null;\n//\t\twhile ( hasMore ) {\n//\t\t\tString token = nextToken;\n//\t\t\tString lcToken = token.toLowerCase(Locale.ROOT);\n//\t\t\thasMore = tokens.hasMoreTokens();\n//\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n//\n//\t\t\t// First, determine quoting which might be based on either:\n//\t\t\t// \t\t1) back-tick\n//\t\t\t// \t\t2) single quote (ANSI SQL standard)\n//\t\t\t// \t\t3) or dialect defined quote character(s)\n//\t\t\tQuotingCharacterDisposition quotingCharacterDisposition = QuotingCharacterDisposition.NONE;\n//\t\t\tif ( \"`\".equals( token ) ) {\n//\t\t\t\tstate.quoted = !state.quoted;\n//\t\t\t\tquotingCharacterDisposition = state.quoted\n//\t\t\t\t\t\t? QuotingCharacterDisposition.OPEN\n//\t\t\t\t\t\t: QuotingCharacterDisposition.CLOSE;\n//\t\t\t\t// replace token with the appropriate dialect quoting char\n//\t\t\t\ttoken = lcToken = ( quotingCharacterDisposition == QuotingCharacterDisposition.OPEN )\n//\t\t\t\t\t\t? dialectOpenQuote\n//\t\t\t\t\t\t: dialectCloseQuote;\n//\t\t\t}\n//\t\t\telse if ( \"'\".equals( token ) ) {\n//\t\t\t\tstate.quoted = !state.quoted;\n//\t\t\t\tquotingCharacterDisposition = state.quoted\n//\t\t\t\t\t\t? QuotingCharacterDisposition.OPEN\n//\t\t\t\t\t\t: QuotingCharacterDisposition.CLOSE;\n//\t\t\t}\n//\t\t\telse if ( !state.quoted && dialectOpenQuote.equals( token ) ) {\n//\t\t\t\tstate.quoted = true;\n//\t\t\t\tquotingCharacterDisposition = QuotingCharacterDisposition.OPEN;\n//\t\t\t}\n//\t\t\telse if ( state.quoted && dialectCloseQuote.equals( token ) ) {\n//\t\t\t\tstate.quoted = false;\n//\t\t\t\tquotingCharacterDisposition = QuotingCharacterDisposition.CLOSE;\n//\t\t\t}\n//\n//\t\t\tif ( state.quoted ) {\n//\t\t\t\tquotedBuffer.append( token );\n//\t\t\t\tcontinue;\n//\t\t\t}\n//\n//\t\t\t// if we were previously processing quoted state and just encountered the close quote, then handle that\n//\t\t\t// quoted text\n//\t\t\tif ( quotingCharacterDisposition == QuotingCharacterDisposition.CLOSE ) {\n//\t\t\t\ttoken = quotedBuffer.toString();\n//\t\t\t\tquotedBuffer.setLength( 0 );\n//\t\t\t\tresult.append( placeholder ).append( '.' )\n//\t\t\t\t\t\t.append( dialectOpenQuote ).append( token ).append( dialectCloseQuote );\n//\t\t\t\tcontinue;\n//\t\t\t}\n//\n//\t\t\t// Special processing for ANSI SQL EXTRACT function\n//\t\t\tif ( \"extract\".equals( lcToken ) && \"(\".equals( nextToken ) ) {\n//\t\t\t\tfinal String field = extractUntil( tokens, \"from\" );\n//\t\t\t\tfinal String source = renderWhereStringTemplate(\n//\t\t\t\t\t\textractUntil( tokens, \")\" ),\n//\t\t\t\t\t\tplaceholder,\n//\t\t\t\t\t\tdialect,\n//\t\t\t\t\t\tfunctionRegistry\n//\t\t\t\t);\n//\t\t\t\tresult.append( \"extract(\" ).append( field ).append( \" from \" ).append( source ).append( ')' );\n//\n//\t\t\t\thasMore = tokens.hasMoreTokens();\n//\t\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n//\n//\t\t\t\tcontinue;\n//\t\t\t}\n//\n//\t\t\t// Special processing for ANSI SQL TRIM function\n//\t\t\tif ( \"trim\".equals( lcToken ) && \"(\".equals( nextToken ) ) {\n//\t\t\t\tList<String> operands = new ArrayList<String>();\n//\t\t\t\tStringBuilder builder = new StringBuilder();\n//\n//\t\t\t\tboolean hasMoreOperands = true;\n//\t\t\t\tString operandToken = tokens.nextToken();\n//\t\t\t\tboolean quoted = false;\n//\t\t\t\twhile ( hasMoreOperands ) {\n//\t\t\t\t\tfinal boolean isQuote = \"'\".equals( operandToken );\n//\t\t\t\t\tif ( isQuote ) {\n//\t\t\t\t\t\tquoted = !quoted;\n//\t\t\t\t\t\tif ( !quoted ) {\n//\t\t\t\t\t\t\toperands.add( builder.append( '\\'' ).toString() );\n//\t\t\t\t\t\t\tbuilder.setLength( 0 );\n//\t\t\t\t\t\t}\n//\t\t\t\t\t\telse {\n//\t\t\t\t\t\t\tbuilder.append( '\\'' );\n//\t\t\t\t\t\t}\n//\t\t\t\t\t}\n//\t\t\t\t\telse if ( quoted ) {\n//\t\t\t\t\t\tbuilder.append( operandToken );\n//\t\t\t\t\t}\n//\t\t\t\t\telse if ( operandToken.length() == 1 && Character.isWhitespace( operandToken.charAt( 0 ) ) ) {\n//\t\t\t\t\t\t// do nothing\n//\t\t\t\t\t}\n//\t\t\t\t\telse {\n//\t\t\t\t\t\toperands.add( operandToken );\n//\t\t\t\t\t}\n//\t\t\t\t\toperandToken = tokens.nextToken();\n//\t\t\t\t\thasMoreOperands = tokens.hasMoreTokens() && ! \")\".equals( operandToken );\n//\t\t\t\t}\n//\n//\t\t\t\tTrimOperands trimOperands = new TrimOperands( operands );\n//\t\t\t\tresult.append( \"trim(\" );\n//\t\t\t\tif ( trimOperands.trimSpec != null ) {\n//\t\t\t\t\tresult.append( trimOperands.trimSpec ).append( ' ' );\n//\t\t\t\t}\n//\t\t\t\tif ( trimOperands.trimChar != null ) {\n//\t\t\t\t\tif ( trimOperands.trimChar.startsWith( \"'\" ) && trimOperands.trimChar.endsWith( \"'\" ) ) {\n//\t\t\t\t\t\tresult.append( trimOperands.trimChar );\n//\t\t\t\t\t}\n//\t\t\t\t\telse {\n//\t\t\t\t\t\tresult.append(\n//\t\t\t\t\t\t\t\trenderWhereStringTemplate( trimOperands.trimSpec, placeholder, dialect, functionRegistry )\n//\t\t\t\t\t\t);\n//\t\t\t\t\t}\n//\t\t\t\t\tresult.append( ' ' );\n//\t\t\t\t}\n//\t\t\t\tif ( trimOperands.from != null ) {\n//\t\t\t\t\tresult.append( trimOperands.from ).append( ' ' );\n//\t\t\t\t}\n//\t\t\t\telse if ( trimOperands.trimSpec != null || trimOperands.trimChar != null ) {\n//\t\t\t\t\t// I think ANSI SQL says that the 'from' is not optional if either trim-spec or trim-char are specified\n//\t\t\t\t\tresult.append( \"from \" );\n//\t\t\t\t}\n//\n//\t\t\t\tresult.append( renderWhereStringTemplate( trimOperands.trimSource, placeholder, dialect, functionRegistry ) )\n//\t\t\t\t\t\t.append( ')' );\n//\n//\t\t\t\thasMore = tokens.hasMoreTokens();\n//\t\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n//\n//\t\t\t\tcontinue;\n//\t\t\t}\n//\n//\n//\t\t\t// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n//\n//\t\t\tif ( Character.isWhitespace( token.charAt( 0 ) ) ) {\n//\t\t\t\tresult.append( token );\n//\t\t\t}\n//\t\t\telse if ( state.beforeTable ) {\n//\t\t\t\tresult.append( token );\n//\t\t\t\tstate.beforeTable = false;\n//\t\t\t\tstate.afterFromTable = true;\n//\t\t\t}\n//\t\t\telse if ( state.afterFromTable ) {\n//\t\t\t\tif ( !\"as\".equals(lcToken) ) {\n//\t\t\t\t\tstate.afterFromTable = false;\n//\t\t\t\t}\n//\t\t\t\tresult.append(token);\n//\t\t\t}\n//\t\t\telse if ( isNamedParameter(token) ) {\n//\t\t\t\tresult.append(token);\n//\t\t\t}\n//\t\t\telse if ( isIdentifier(token, dialect)\n//\t\t\t\t\t&& !isFunctionOrKeyword(lcToken, nextToken, dialect , functionRegistry) ) {\n//\t\t\t\tresult.append(placeholder)\n//\t\t\t\t\t\t.append('.')\n//\t\t\t\t\t\t.append( dialect.quote(token) );\n//\t\t\t}\n//\t\t\telse {\n//\t\t\t\tif ( BEFORE_TABLE_KEYWORDS.contains(lcToken) ) {\n//\t\t\t\t\tstate.beforeTable = true;\n//\t\t\t\t\tstate.inFromClause = true;\n//\t\t\t\t}\n//\t\t\t\telse if ( state.inFromClause && \",\".equals(lcToken) ) {\n//\t\t\t\t\tstate.beforeTable = true;\n//\t\t\t\t}\n//\t\t\t\tresult.append(token);\n//\t\t\t}\n//\n//\t\t\t//Yuck:\n//\t\t\tif ( state.inFromClause\n//\t\t\t\t\t&& KEYWORDS.contains( lcToken ) //\"as\" is not in KEYWORDS\n//\t\t\t\t\t&& !BEFORE_TABLE_KEYWORDS.contains( lcToken ) ) {\n//\t\t\t\tstate.inFromClause = false;\n//\t\t\t}\n//\t\t}\n//\n//\t\treturn result.toString();\n//\t}\n//\n//\tprivate static class ProcessingState {\n//\t\tboolean quoted = false;\n//\t\tboolean quotedIdentifier = false;\n//\t\tboolean beforeTable = false;\n//\t\tboolean inFromClause = false;\n//\t\tboolean afterFromTable = false;\n//\t}\n//\n//\tprivate static enum QuotingCharacterDisposition { NONE, OPEN, CLOSE }\n\n\tprivate static class TrimOperands {\n\t\tprivate final String trimSpec;\n\t\tprivate final String trimChar;\n\t\tprivate final String from;\n\t\tprivate final String trimSource;\n\n\t\tprivate TrimOperands(List<String> operands) {\n\t\t\tfinal int size = operands.size();\n\t\t\tif ( size == 1 ) {\n\t\t\t\ttrimSpec = null;\n\t\t\t\ttrimChar = null;\n\t\t\t\tfrom = null;\n\t\t\t\ttrimSource = operands.get(0);\n\t\t\t}\n\t\t\telse if ( size == 4 ) {\n\t\t\t\ttrimSpec = operands.get(0);\n\t\t\t\ttrimChar = operands.get(1);\n\t\t\t\tfrom = operands.get(2);\n\t\t\t\ttrimSource = operands.get(3);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif ( size < 1 || size > 4 ) {\n\t\t\t\t\tthrow new HibernateException( \"Unexpected number of trim function operands : \" + size );\n\t\t\t\t}\n\n\t\t\t\t// trim-source will always be the last operand\n\t\t\t\ttrimSource = operands.get( size - 1 );\n\n\t\t\t\t// ANSI SQL says that more than one operand means that the FROM is required\n\t\t\t\tif ( ! \"from\".equals( operands.get( size - 2 ) ) ) {\n\t\t\t\t\tthrow new HibernateException( \"Expecting FROM, found : \" + operands.get( size - 2 ) );\n\t\t\t\t}\n\t\t\t\tfrom = operands.get( size - 2 );\n\n\t\t\t\t// trim-spec, if there is one will always be the first operand\n\t\t\t\tif ( \"leading\".equalsIgnoreCase( operands.get(0) )\n\t\t\t\t\t\t|| \"trailing\".equalsIgnoreCase( operands.get(0) )\n\t\t\t\t\t\t|| \"both\".equalsIgnoreCase( operands.get(0) ) ) {\n\t\t\t\t\ttrimSpec = operands.get(0);\n\t\t\t\t\ttrimChar = null;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ttrimSpec = null;\n\t\t\t\t\tif ( size - 2 == 0 ) {\n\t\t\t\t\t\ttrimChar = null;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\ttrimChar = operands.get( 0 );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate static String extractUntil(StringTokenizer tokens, String delimiter) {\n\t\tfinal StringBuilder valueBuilder = new StringBuilder();\n\t\tString token = tokens.nextToken();\n\t\twhile ( ! delimiter.equalsIgnoreCase( token ) ) {\n\t\t\tvalueBuilder.append( token );\n\t\t\ttoken = tokens.nextToken();\n\t\t}\n\t\treturn valueBuilder.toString().trim();\n\t}\n\n\tprivate static boolean isNamedParameter(String token) {\n\t\treturn token.startsWith( \":\" );\n\t}\n\n\tprivate static boolean isFunctionOrKeyword(\n\t\t\tString lcToken,\n\t\t\tString nextToken,\n\t\t\tDialect dialect,\n\t\t\tTypeConfiguration typeConfiguration,\n\t\t\tSqmFunctionRegistry functionRegistry) {\n\t\tif ( \"(\".equals( nextToken ) ) {\n\t\t\treturn true;\n\t\t}\n\t\telse if ( \"date\".equals( lcToken ) || \"time\".equals( lcToken ) ) {\n\t\t\t// these can be column names on some databases\n\t\t\t// TODO: treat 'current date' as a function\n\t\t\treturn false;\n\t\t}\n\t\telse {\n\t\t\treturn KEYWORDS.contains( lcToken )\n\t\t\t\t|| isType( lcToken, typeConfiguration )\n\t\t\t\t|| isFunction( lcToken, nextToken, functionRegistry )\n\t\t\t\t|| dialect.getKeywords().contains( lcToken )\n\t\t\t\t|| FUNCTION_KEYWORDS.contains( lcToken );\n\t\t}\n\t}\n\n\tprivate static boolean isType(String lcToken, TypeConfiguration typeConfiguration) {\n\t\treturn typeConfiguration.getDdlTypeRegistry().isTypeNameRegistered( lcToken );\n\t}\n\n\tprivate static boolean isFunction(String lcToken, String nextToken, SqmFunctionRegistry functionRegistry) {\n\t\t// checking for \"(\" is currently redundant because it is checked before getting here;\n\t\t// doing the check anyhow, in case that earlier check goes away;\n\t\tif ( \"(\".equals( nextToken ) ) {\n\t\t\treturn true;\n\t\t}\n\n\t\tfinal SqmFunctionDescriptor function = functionRegistry.findFunctionDescriptor( lcToken );\n\t\treturn function != null;\n\t}\n\n\tprivate static boolean isIdentifier(String token) {\n\t\tif ( isBoolean( token ) ) {\n\t\t\treturn false;\n\t\t}\n\t\treturn token.charAt( 0 ) == '`'\n\t\t\t|| ( //allow any identifier quoted with backtick\n\t\t\t\tisLetter( token.charAt( 0 ) ) && //only recognizes identifiers beginning with a letter\n\t\t\t\t\t\ttoken.indexOf( '.' ) < 0\n\t\t\t);\n\t}\n\n\tprivate static boolean isBoolean(String token) {\n\t\treturn \"true\".equals( token ) || \"false\".equals( token );\n\t}\n}\n",
        "diffSourceCodeSet": [
            "private static boolean isTrimFunction(String lcToken, String nextToken) {\n\t\treturn \"trim\".equals(lcToken) && \"(\".equals(nextToken);\n\t}"
        ],
        "invokedMethodSet": [
            "methodSignature: org.hibernate.sql.Template#extractUntil\n methodBody: private static String extractUntil(StringTokenizer tokens, String delimiter) {\nStringBuilder valueBuilder=new StringBuilder();\nString token=tokens.nextToken();\nwhile(!delimiter.equalsIgnoreCase(token)){valueBuilder.append(token);\ntoken=tokens.nextToken();\n}return valueBuilder.toString().trim();\n}",
            "methodSignature: org.hibernate.sql.Template#renderWhereStringTemplate\n methodBody: public static String renderWhereStringTemplate(\n\t\t\tString sqlWhereString,\n\t\t\tString placeholder,\n\t\t\tDialect dialect,\n\t\t\tTypeConfiguration typeConfiguration,\n\t\t\tSqmFunctionRegistry functionRegistry) {\nString symbols=PUNCTUATION + WHITESPACE + dialect.openQuote() + dialect.closeQuote();\nStringTokenizer tokens=new StringTokenizer(sqlWhereString,symbols,true);\nStringBuilder result=new StringBuilder();\nboolean quoted=false;\nboolean quotedIdentifier=false;\nboolean beforeTable=false;\nboolean inFromClause=false;\nboolean afterFromTable=false;\nboolean hasMore=tokens.hasMoreTokens();\nString nextToken=hasMore ? tokens.nextToken() : null;\nwhile(hasMore){String token=nextToken;\nString lcToken=token.toLowerCase(Locale.ROOT);\nhasMore=tokens.hasMoreTokens();\nnextToken=hasMore ? tokens.nextToken() : null;\nboolean isQuoteCharacter=false;\nif(!quotedIdentifier && \"'\".equals(token)){quoted=!quoted;\nisQuoteCharacter=true;\n}if(!quoted){boolean isOpenQuote;\nif(\"`\".equals(token)){isOpenQuote=!quotedIdentifier;\ntoken=lcToken=isOpenQuote ? Character.toString(dialect.openQuote()) : Character.toString(dialect.closeQuote());\nquotedIdentifier=isOpenQuote;\nisQuoteCharacter=true;\n}if(!quotedIdentifier && (dialect.openQuote() == token.charAt(0))){isOpenQuote=true;\nquotedIdentifier=true;\nisQuoteCharacter=true;\n}if(quotedIdentifier && (dialect.closeQuote() == token.charAt(0))){quotedIdentifier=false;\nisQuoteCharacter=true;\nisOpenQuote=false;\n}if(LITERAL_PREFIXES.contains(lcToken)){if(\"'\".equals(nextToken)){result.append(token);\ncontinue;\n}if(nextToken != null && Character.isWhitespace(nextToken.charAt(0))){final StringBuilder additionalTokens=new StringBuilder();\nTimeZoneTokens possibleNextToken=null;\ndo(nextToken != null && possibleNextToken.isToken(nextToken)){possibleNextToken=possibleNextToken == null ? TimeZoneTokens.getPossibleNextTokens(lcToken) : possibleNextToken.nextToken();\ndo(nextToken != null && Character.isWhitespace(nextToken.charAt(0))){additionalTokens.append(nextToken);\nhasMore=tokens.hasMoreTokens();\nnextToken=tokens.nextToken();\n}}if(\"'\".equals(nextToken)){result.append(token);\nresult.append(additionalTokens);\ncontinue;\n}{isOpenQuote=false;\n}}{isOpenQuote=false;\n}}{isOpenQuote=false;\n}if(isOpenQuote){result.append(placeholder).append('.');\n}}if(\"extract\".equals(lcToken) && \"(\".equals(nextToken)){final String field=extractUntil(tokens,\"from\");\nfinal String source=renderWhereStringTemplate(extractUntil(tokens,\")\"),placeholder,dialect,typeConfiguration,functionRegistry);\nresult.append(\"extract(\").append(field).append(\" from \").append(source).append(')');\nhasMore=tokens.hasMoreTokens();\nnextToken=hasMore ? tokens.nextToken() : null;\ncontinue;\n}if(\"trim\".equals(lcToken) && \"(\".equals(nextToken)){List<String> operands=new ArrayList<>();\nStringBuilder builder=new StringBuilder();\nboolean hasMoreOperands=true;\nString operandToken=tokens.nextToken();\nswitch(operandToken.toLowerCase(Locale.ROOT))case \"leading\":case \"trailing\":case \"both\":operands.add(operandToken);\nif(hasMoreOperands=tokens.hasMoreTokens()){operandToken=tokens.nextToken();\n}break;\nboolean quotedOperand=false;\nint parenthesis=0;\nwhile(hasMoreOperands){final boolean isQuote=\"'\".equals(operandToken);\nif(isQuote){quotedOperand=!quotedOperand;\nif(!quotedOperand){operands.add(builder.append('\\'').toString());\nbuilder.setLength(0);\n}{builder.append('\\'');\n}}if(quotedOperand){builder.append(operandToken);\n}if(parenthesis != 0){builder.append(operandToken);\nswitch(operandToken)case \"(\":parenthesis++;\nbreak;\ncase \")\":parenthesis--;\nbreak;\n}{builder.append(operandToken);\nswitch(operandToken.toLowerCase(Locale.ROOT))case \"(\":parenthesis++;\nbreak;\ncase \")\":parenthesis--;\nbreak;\ncase \"from\":if(builder.length() != 0){operands.add(builder.substring(0,builder.length() - 4));\nbuilder.setLength(0);\noperands.add(operandToken);\n}break;\n}operandToken=tokens.nextToken();\nhasMoreOperands=tokens.hasMoreTokens() && (parenthesis != 0 || !\")\".equals(operandToken));\n}if(builder.length() != 0){operands.add(builder.toString());\n}TrimOperands trimOperands=new TrimOperands(operands);\nresult.append(\"trim(\");\nif(trimOperands.trimSpec != null){result.append(trimOperands.trimSpec).append(' ');\n}if(trimOperands.trimChar != null){if(trimOperands.trimChar.startsWith(\"'\") && trimOperands.trimChar.endsWith(\"'\")){result.append(trimOperands.trimChar);\n}{result.append(renderWhereStringTemplate(trimOperands.trimSpec,placeholder,dialect,typeConfiguration,functionRegistry));\n}result.append(' ');\n}if(trimOperands.from != null){result.append(trimOperands.from).append(' ');\n}if(trimOperands.trimSpec != null || trimOperands.trimChar != null){result.append(\"from \");\n}result.append(renderWhereStringTemplate(trimOperands.trimSource,placeholder,dialect,typeConfiguration,functionRegistry)).append(')');\nhasMore=tokens.hasMoreTokens();\nnextToken=hasMore ? tokens.nextToken() : null;\ncontinue;\n}boolean quotedOrWhitespace=quoted || quotedIdentifier || isQuoteCharacter || Character.isWhitespace(token.charAt(0));\nif(quotedOrWhitespace){result.append(token);\n}if(beforeTable){result.append(token);\nbeforeTable=false;\nafterFromTable=true;\n}if(afterFromTable){if(!\"as\".equals(lcToken)){afterFromTable=false;\n}result.append(token);\n}if(isNamedParameter(token)){result.append(token);\n}if(isIdentifier(token) && !isFunctionOrKeyword(lcToken,nextToken,dialect,typeConfiguration,functionRegistry)){result.append(placeholder).append('.').append(dialect.quote(token));\n}{if(BEFORE_TABLE_KEYWORDS.contains(lcToken)){beforeTable=true;\ninFromClause=true;\n}if(inFromClause && \",\".equals(lcToken)){beforeTable=true;\n}if(isBoolean(token)){token=dialect.toBooleanValueString(Boolean.parseBoolean(token));\n}result.append(token);\n}if(inFromClause && KEYWORDS.contains(lcToken) && !BEFORE_TABLE_KEYWORDS.contains(lcToken)){inFromClause=false;\n}}return result.toString();\n}",
            "methodSignature: org.hibernate.sql.Template.TimeZoneTokens#isToken\n methodBody: public boolean isToken(String token) {\nreturn this != NONE && name().equalsIgnoreCase(token);\n}",
            "methodSignature: org.hibernate.sql.Template#isBoolean\n methodBody: private static boolean isBoolean(String token) {\nreturn \"true\".equals(token) || \"false\".equals(token);\n}",
            "methodSignature: org.hibernate.sql.Template.TimeZoneTokens#nextToken\n methodBody: public TimeZoneTokens nextToken() {\nif(this == WITH){return TIME;\n}if(this == TIME){return ZONE;\n}{return NONE;\n}}",
            "methodSignature: org.hibernate.sql.Template.TimeZoneTokens#getPossibleNextTokens\n methodBody: static TimeZoneTokens getPossibleNextTokens(String lctoken) {\nswitch(lctoken)case \"time\":case \"timestamp\":return WITH;\ndefault:return NONE;\n}",
            "methodSignature: org.hibernate.sql.Template#isIdentifier\n methodBody: private static boolean isIdentifier(String token) {\nif(isBoolean(token)){return false;\n}return token.charAt(0) == '`' || (Character.isLetter(token.charAt(0)) && token.indexOf('.') < 0);\n}",
            "methodSignature: org.hibernate.sql.Template#isNamedParameter\n methodBody: private static boolean isNamedParameter(String token) {\nreturn token.startsWith(\":\");\n}",
            "methodSignature: org.hibernate.sql.Template#isFunctionOrKeyword\n methodBody: private static boolean isFunctionOrKeyword(\n\t\t\tString lcToken,\n\t\t\tString nextToken,\n\t\t\tDialect dialect,\n\t\t\tTypeConfiguration typeConfiguration,\n\t\t\tSqmFunctionRegistry functionRegistry) {\nreturn \"(\".equals(nextToken) || KEYWORDS.contains(lcToken) || isType(lcToken,typeConfiguration) || isFunction(lcToken,nextToken,functionRegistry) || dialect.getKeywords().contains(lcToken) || FUNCTION_KEYWORDS.contains(lcToken);\n}"
        ],
        "sourceCodeAfterRefactoring": "/**\n\t * Takes the where condition provided in the mapping attribute and interpolates the alias.\n\t * Handles sub-selects, quoted identifiers, quoted strings, expressions, SQL functions,\n\t * named parameters.\n\t *\n\t * @param sqlWhereString The string into which to interpolate the placeholder value\n\t * @param placeholder The value to be interpolated into the sqlWhereString\n\t * @param dialect The dialect to apply\n\t * @param functionRegistry The registry of all sql functions\n\t * @return The rendered sql fragment\n\t */\n\tpublic static String renderWhereStringTemplate(\n\t\t\tString sqlWhereString,\n\t\t\tString placeholder,\n\t\t\tDialect dialect,\n\t\t\tTypeConfiguration typeConfiguration,\n\t\t\tSqmFunctionRegistry functionRegistry) {\n\n\t\t// IMPL NOTE : The basic process here is to tokenize the incoming string and to iterate over each token\n\t\t//\t\tin turn.  As we process each token, we set a series of flags used to indicate the type of context in\n\t\t// \t\twhich the tokens occur.  Depending on the state of those flags we decide whether we need to qualify\n\t\t//\t\tidentifier references.\n\n\t\tfinal String symbols = PUNCTUATION + WHITESPACE + dialect.openQuote() + dialect.closeQuote();\n\t\tfinal StringTokenizer tokens = new StringTokenizer( sqlWhereString, symbols, true );\n\t\tfinal StringBuilder result = new StringBuilder();\n\n\t\tboolean quoted = false;\n\t\tboolean quotedIdentifier = false;\n\t\tboolean beforeTable = false;\n\t\tboolean inFromClause = false;\n\t\tboolean afterFromTable = false;\n\n\t\tboolean hasMore = tokens.hasMoreTokens();\n\t\tString nextToken = hasMore ? tokens.nextToken() : null;\n\t\twhile ( hasMore ) {\n\t\t\tString token = nextToken;\n\t\t\tString lcToken = token.toLowerCase(Locale.ROOT);\n\t\t\thasMore = tokens.hasMoreTokens();\n\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n\n\t\t\tboolean isQuoteCharacter = false;\n\n\t\t\tif ( !quotedIdentifier && \"'\".equals(token) ) {\n\t\t\t\tquoted = !quoted;\n\t\t\t\tisQuoteCharacter = true;\n\t\t\t}\n\n\t\t\tif ( !quoted ) {\n\t\t\t\tfinal boolean isOpenQuote;\n\t\t\t\tif ( \"`\".equals(token) ) {\n\t\t\t\t\tisOpenQuote = !quotedIdentifier;\n\t\t\t\t\ttoken = lcToken = isOpenQuote\n\t\t\t\t\t\t\t? Character.toString( dialect.openQuote() )\n\t\t\t\t\t\t\t: Character.toString( dialect.closeQuote() );\n\t\t\t\t\tquotedIdentifier = isOpenQuote;\n\t\t\t\t\tisQuoteCharacter = true;\n\t\t\t\t}\n\t\t\t\telse if ( !quotedIdentifier && dialect.openQuote()==token.charAt(0) ) {\n\t\t\t\t\tisOpenQuote = true;\n\t\t\t\t\tquotedIdentifier = true;\n\t\t\t\t\tisQuoteCharacter = true;\n\t\t\t\t}\n\t\t\t\telse if ( quotedIdentifier && dialect.closeQuote()==token.charAt(0) ) {\n\t\t\t\t\tquotedIdentifier = false;\n\t\t\t\t\tisQuoteCharacter = true;\n\t\t\t\t\tisOpenQuote = false;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tisOpenQuote = false;\n\t\t\t\t}\n\t\t\t\tif ( isOpenQuote ) {\n\t\t\t\t\tresult.append( placeholder ).append( '.' );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfinal boolean quotedOrWhitespace =\n\t\t\t\t\tquoted || quotedIdentifier || isQuoteCharacter\n\t\t\t\t\t\t\t|| token.isBlank();\n\t\t\tif ( quotedOrWhitespace ) {\n\t\t\t\tresult.append( token );\n\t\t\t}\n\t\t\telse if ( beforeTable ) {\n\t\t\t\tresult.append( token );\n\t\t\t\tbeforeTable = false;\n\t\t\t\tafterFromTable = true;\n\t\t\t}\n\t\t\telse if ( afterFromTable ) {\n\t\t\t\tif ( !\"as\".equals(lcToken) ) {\n\t\t\t\t\tafterFromTable = false;\n\t\t\t\t}\n\t\t\t\tresult.append(token);\n\t\t\t}\n\t\t\telse if ( isNamedParameter(token) ) {\n\t\t\t\tresult.append(token);\n\t\t\t}\n\t\t\telse if ( isExtractFunction( lcToken, nextToken ) ) {\n\t\t\t\t// Special processing for ANSI SQL EXTRACT function\n\t\t\t\thandleExtractFunction( placeholder, dialect, typeConfiguration, functionRegistry, tokens, result );\n\t\t\t\thasMore = tokens.hasMoreTokens();\n\t\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n\t\t\t}\n\t\t\telse if ( isTrimFunction( lcToken, nextToken ) ) {\n\t\t\t\t// Special processing for ANSI SQL TRIM function\n\t\t\t\thandleTrimFunction( placeholder, dialect, typeConfiguration, functionRegistry, tokens, result );\n\t\t\t\thasMore = tokens.hasMoreTokens();\n\t\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n\t\t\t}\n\t\t\telse if ( isIdentifier(token)\n\t\t\t\t\t&& !isFunctionOrKeyword( lcToken, nextToken, dialect, typeConfiguration, functionRegistry )\n\t\t\t\t\t&& !isLiteral( lcToken, nextToken, sqlWhereString, symbols, tokens ) ) {\n\t\t\t\tresult.append(placeholder)\n\t\t\t\t\t\t.append('.')\n\t\t\t\t\t\t.append( dialect.quote(token) );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif ( BEFORE_TABLE_KEYWORDS.contains(lcToken) ) {\n\t\t\t\t\tbeforeTable = true;\n\t\t\t\t\tinFromClause = true;\n\t\t\t\t}\n\t\t\t\telse if ( inFromClause && \",\".equals(lcToken) ) {\n\t\t\t\t\tbeforeTable = true;\n\t\t\t\t}\n\t\t\t\tif ( isBoolean( token ) ) {\n\t\t\t\t\ttoken = dialect.toBooleanValueString( parseBoolean( token ) );\n\t\t\t\t}\n\t\t\t\tresult.append(token);\n\t\t\t}\n\n\t\t\t//Yuck:\n\t\t\tif ( inFromClause\n\t\t\t\t\t&& KEYWORDS.contains( lcToken ) //\"as\" is not in KEYWORDS\n\t\t\t\t\t&& !BEFORE_TABLE_KEYWORDS.contains( lcToken ) ) {\n\t\t\t\tinFromClause = false;\n\t\t\t}\n\t\t}\n\n\t\treturn result.toString();\n\t}\nprivate static boolean isTrimFunction(String lcToken, String nextToken) {\n\t\treturn \"trim\".equals(lcToken) && \"(\".equals(nextToken);\n\t}",
        "diffSourceCode": "-  119: \t/**\n-  120: \t * Takes the where condition provided in the mapping attribute and interpolates the alias.\n-  121: \t * Handles sub-selects, quoted identifiers, quoted strings, expressions, SQL functions,\n-  122: \t * named parameters.\n-  123: \t *\n-  124: \t * @param sqlWhereString The string into which to interpolate the placeholder value\n-  125: \t * @param placeholder The value to be interpolated into the sqlWhereString\n-  126: \t * @param dialect The dialect to apply\n-  127: \t * @param functionRegistry The registry of all sql functions\n-  128: \t * @return The rendered sql fragment\n-  129: \t */\n-  130: \tpublic static String renderWhereStringTemplate(\n-  131: \t\t\tString sqlWhereString,\n-  132: \t\t\tString placeholder,\n-  133: \t\t\tDialect dialect,\n-  134: \t\t\tTypeConfiguration typeConfiguration,\n-  135: \t\t\tSqmFunctionRegistry functionRegistry) {\n-  136: \n-  137: \t\t// IMPL NOTE : The basic process here is to tokenize the incoming string and to iterate over each token\n-  138: \t\t//\t\tin turn.  As we process each token, we set a series of flags used to indicate the type of context in\n-  139: \t\t// \t\twhich the tokens occur.  Depending on the state of those flags we decide whether we need to qualify\n-  140: \t\t//\t\tidentifier references.\n-  141: \n-  142: \t\tString symbols = PUNCTUATION +\n-  143: \t\t\t\tWHITESPACE +\n-  144: \t\t\t\tdialect.openQuote() +\n-  145: \t\t\t\tdialect.closeQuote();\n-  146: \t\tStringTokenizer tokens = new StringTokenizer( sqlWhereString, symbols, true );\n-  147: \t\tStringBuilder result = new StringBuilder();\n+  119: \t\treturn renderWhereStringTemplate( sqlWhereString, TEMPLATE, dialect, typeConfiguration, functionRegistry );\n+  120: \t}\n+  121: \n+  122: \t/**\n+  123: \t * Takes the where condition provided in the mapping attribute and interpolates the alias.\n+  124: \t * Handles sub-selects, quoted identifiers, quoted strings, expressions, SQL functions,\n+  125: \t * named parameters.\n+  126: \t *\n+  127: \t * @param sqlWhereString The string into which to interpolate the placeholder value\n+  128: \t * @param placeholder The value to be interpolated into the sqlWhereString\n+  129: \t * @param dialect The dialect to apply\n+  130: \t * @param functionRegistry The registry of all sql functions\n+  131: \t * @return The rendered sql fragment\n+  132: \t */\n+  133: \tpublic static String renderWhereStringTemplate(\n+  134: \t\t\tString sqlWhereString,\n+  135: \t\t\tString placeholder,\n+  136: \t\t\tDialect dialect,\n+  137: \t\t\tTypeConfiguration typeConfiguration,\n+  138: \t\t\tSqmFunctionRegistry functionRegistry) {\n+  139: \n+  140: \t\t// IMPL NOTE : The basic process here is to tokenize the incoming string and to iterate over each token\n+  141: \t\t//\t\tin turn.  As we process each token, we set a series of flags used to indicate the type of context in\n+  142: \t\t// \t\twhich the tokens occur.  Depending on the state of those flags we decide whether we need to qualify\n+  143: \t\t//\t\tidentifier references.\n+  144: \n+  145: \t\tfinal String symbols = PUNCTUATION + WHITESPACE + dialect.openQuote() + dialect.closeQuote();\n+  146: \t\tfinal StringTokenizer tokens = new StringTokenizer( sqlWhereString, symbols, true );\n+  147: \t\tfinal StringBuilder result = new StringBuilder();\n   148: \n   149: \t\tboolean quoted = false;\n   150: \t\tboolean quotedIdentifier = false;\n   151: \t\tboolean beforeTable = false;\n   152: \t\tboolean inFromClause = false;\n   153: \t\tboolean afterFromTable = false;\n   154: \n   155: \t\tboolean hasMore = tokens.hasMoreTokens();\n   156: \t\tString nextToken = hasMore ? tokens.nextToken() : null;\n   157: \t\twhile ( hasMore ) {\n   158: \t\t\tString token = nextToken;\n   159: \t\t\tString lcToken = token.toLowerCase(Locale.ROOT);\n   160: \t\t\thasMore = tokens.hasMoreTokens();\n   161: \t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n   162: \n   163: \t\t\tboolean isQuoteCharacter = false;\n   164: \n   165: \t\t\tif ( !quotedIdentifier && \"'\".equals(token) ) {\n   166: \t\t\t\tquoted = !quoted;\n   167: \t\t\t\tisQuoteCharacter = true;\n   168: \t\t\t}\n   169: \n   170: \t\t\tif ( !quoted ) {\n-  171: \t\t\t\tboolean isOpenQuote;\n+  171: \t\t\t\tfinal boolean isOpenQuote;\n   172: \t\t\t\tif ( \"`\".equals(token) ) {\n   173: \t\t\t\t\tisOpenQuote = !quotedIdentifier;\n   174: \t\t\t\t\ttoken = lcToken = isOpenQuote\n   175: \t\t\t\t\t\t\t? Character.toString( dialect.openQuote() )\n   176: \t\t\t\t\t\t\t: Character.toString( dialect.closeQuote() );\n   177: \t\t\t\t\tquotedIdentifier = isOpenQuote;\n   178: \t\t\t\t\tisQuoteCharacter = true;\n   179: \t\t\t\t}\n-  180: \t\t\t\telse if ( !quotedIdentifier && ( dialect.openQuote()==token.charAt(0) ) ) {\n+  180: \t\t\t\telse if ( !quotedIdentifier && dialect.openQuote()==token.charAt(0) ) {\n   181: \t\t\t\t\tisOpenQuote = true;\n   182: \t\t\t\t\tquotedIdentifier = true;\n   183: \t\t\t\t\tisQuoteCharacter = true;\n   184: \t\t\t\t}\n-  185: \t\t\t\telse if ( quotedIdentifier && ( dialect.closeQuote()==token.charAt(0) ) ) {\n+  185: \t\t\t\telse if ( quotedIdentifier && dialect.closeQuote()==token.charAt(0) ) {\n   186: \t\t\t\t\tquotedIdentifier = false;\n   187: \t\t\t\t\tisQuoteCharacter = true;\n   188: \t\t\t\t\tisOpenQuote = false;\n   189: \t\t\t\t}\n-  190: \t\t\t\telse if ( LITERAL_PREFIXES.contains( lcToken ) ) {\n-  191: \t\t\t\t\tif ( \"'\".equals( nextToken ) ) {\n-  192: \t\t\t\t\t\t// Don't prefix a literal\n-  193: \t\t\t\t\t\tresult.append( token );\n-  194: \t\t\t\t\t\tcontinue;\n-  195: \t\t\t\t\t}\n-  196: \t\t\t\t\telse if ( nextToken != null && Character.isWhitespace( nextToken.charAt( 0 ) ) ) {\n-  197: \t\t\t\t\t\tfinal StringBuilder additionalTokens = new StringBuilder();\n-  198: \t\t\t\t\t\tTimeZoneTokens possibleNextToken = null;\n-  199: \t\t\t\t\t\tdo {\n-  200: \t\t\t\t\t\t\tpossibleNextToken = possibleNextToken == null\n-  201: \t\t\t\t\t\t\t\t\t? TimeZoneTokens.getPossibleNextTokens( lcToken )\n-  202: \t\t\t\t\t\t\t\t\t: possibleNextToken.nextToken();\n-  203: \t\t\t\t\t\t\tdo {\n-  204: \t\t\t\t\t\t\t\tadditionalTokens.append( nextToken );\n-  205: \t\t\t\t\t\t\t\thasMore = tokens.hasMoreTokens();\n-  206: \t\t\t\t\t\t\t\tnextToken = tokens.nextToken();\n-  207: \t\t\t\t\t\t\t} while ( nextToken != null && Character.isWhitespace( nextToken.charAt( 0 ) ) );\n-  208: \t\t\t\t\t\t} while ( nextToken != null && possibleNextToken.isToken( nextToken ) );\n-  209: \t\t\t\t\t\tif ( \"'\".equals( nextToken ) ) {\n-  210: \t\t\t\t\t\t\t// Don't prefix a literal\n-  211: \t\t\t\t\t\t\tresult.append( token );\n-  212: \t\t\t\t\t\t\tresult.append( additionalTokens );\n-  213: \t\t\t\t\t\t\tcontinue;\n-  214: \t\t\t\t\t\t}\n-  215: \t\t\t\t\t\telse {\n-  216: \t\t\t\t\t\t\tisOpenQuote = false;\n-  217: \t\t\t\t\t\t}\n-  218: \t\t\t\t\t}\n-  219: \t\t\t\t\telse {\n-  220: \t\t\t\t\t\tisOpenQuote = false;\n-  221: \t\t\t\t\t}\n-  222: \t\t\t\t}\n-  223: \t\t\t\telse {\n-  224: \t\t\t\t\tisOpenQuote = false;\n-  225: \t\t\t\t}\n-  226: \n-  227: \t\t\t\tif ( isOpenQuote ) {\n-  228: \t\t\t\t\tresult.append( placeholder ).append( '.' );\n-  229: \t\t\t\t}\n-  230: \t\t\t}\n-  231: \n-  232: \t\t\t// Special processing for ANSI SQL EXTRACT function\n-  233: \t\t\tif ( \"extract\".equals( lcToken ) && \"(\".equals( nextToken ) ) {\n-  234: \t\t\t\tfinal String field = extractUntil( tokens, \"from\" );\n-  235: \t\t\t\tfinal String source = renderWhereStringTemplate(\n-  236: \t\t\t\t\t\textractUntil( tokens, \")\" ),\n-  237: \t\t\t\t\t\tplaceholder,\n-  238: \t\t\t\t\t\tdialect,\n-  239: \t\t\t\t\t\ttypeConfiguration,\n-  240: \t\t\t\t\t\tfunctionRegistry\n-  241: \t\t\t\t);\n-  242: \t\t\t\tresult.append( \"extract(\" ).append( field ).append( \" from \" ).append( source ).append( ')' );\n-  243: \n-  244: \t\t\t\thasMore = tokens.hasMoreTokens();\n-  245: \t\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n-  246: \n-  247: \t\t\t\tcontinue;\n-  248: \t\t\t}\n-  249: \n-  250: \t\t\t// Special processing for ANSI SQL TRIM function\n-  251: \t\t\tif ( \"trim\".equals( lcToken ) && \"(\".equals( nextToken ) ) {\n-  252: \t\t\t\tList<String> operands = new ArrayList<>();\n-  253: \t\t\t\tStringBuilder builder = new StringBuilder();\n-  254: \n-  255: \t\t\t\tboolean hasMoreOperands = true;\n-  256: \t\t\t\tString operandToken = tokens.nextToken();\n-  257: \t\t\t\tswitch ( operandToken.toLowerCase( Locale.ROOT ) ) {\n-  258: \t\t\t\t\tcase \"leading\":\n-  259: \t\t\t\t\tcase \"trailing\":\n-  260: \t\t\t\t\tcase \"both\":\n-  261: \t\t\t\t\t\toperands.add( operandToken );\n-  262: \t\t\t\t\t\tif ( hasMoreOperands = tokens.hasMoreTokens() ) {\n-  263: \t\t\t\t\t\t\toperandToken = tokens.nextToken();\n-  264: \t\t\t\t\t\t}\n-  265: \t\t\t\t\t\tbreak;\n-  266: \t\t\t\t}\n-  267: \t\t\t\tboolean quotedOperand = false;\n-  268: \t\t\t\tint parenthesis = 0;\n-  269: \t\t\t\twhile ( hasMoreOperands ) {\n-  270: \t\t\t\t\tfinal boolean isQuote = \"'\".equals( operandToken );\n-  271: \t\t\t\t\tif ( isQuote ) {\n-  272: \t\t\t\t\t\tquotedOperand = !quotedOperand;\n-  273: \t\t\t\t\t\tif ( !quotedOperand ) {\n-  274: \t\t\t\t\t\t\toperands.add( builder.append( '\\'' ).toString() );\n-  275: \t\t\t\t\t\t\tbuilder.setLength( 0 );\n-  276: \t\t\t\t\t\t}\n-  277: \t\t\t\t\t\telse {\n-  278: \t\t\t\t\t\t\tbuilder.append( '\\'' );\n-  279: \t\t\t\t\t\t}\n-  280: \t\t\t\t\t}\n-  281: \t\t\t\t\telse if ( quotedOperand ) {\n-  282: \t\t\t\t\t\tbuilder.append( operandToken );\n-  283: \t\t\t\t\t}\n-  284: \t\t\t\t\telse if ( parenthesis != 0 ) {\n-  285: \t\t\t\t\t\tbuilder.append( operandToken );\n-  286: \t\t\t\t\t\tswitch ( operandToken ) {\n-  287: \t\t\t\t\t\t\tcase \"(\":\n-  288: \t\t\t\t\t\t\t\tparenthesis++;\n-  289: \t\t\t\t\t\t\t\tbreak;\n-  290: \t\t\t\t\t\t\tcase \")\":\n-  291: \t\t\t\t\t\t\t\tparenthesis--;\n-  292: \t\t\t\t\t\t\t\tbreak;\n-  293: \t\t\t\t\t\t}\n-  294: \t\t\t\t\t}\n-  295: \t\t\t\t\telse {\n-  296: \t\t\t\t\t\tbuilder.append( operandToken );\n-  297: \t\t\t\t\t\tswitch ( operandToken.toLowerCase( Locale.ROOT ) ) {\n-  298: \t\t\t\t\t\t\tcase \"(\":\n-  299: \t\t\t\t\t\t\t\tparenthesis++;\n-  300: \t\t\t\t\t\t\t\tbreak;\n-  301: \t\t\t\t\t\t\tcase \")\":\n-  302: \t\t\t\t\t\t\t\tparenthesis--;\n-  303: \t\t\t\t\t\t\t\tbreak;\n-  304: \t\t\t\t\t\t\tcase \"from\":\n-  305: \t\t\t\t\t\t\t\tif ( builder.length() != 0 ) {\n-  306: \t\t\t\t\t\t\t\t\toperands.add( builder.substring( 0, builder.length() - 4 ) );\n-  307: \t\t\t\t\t\t\t\t\tbuilder.setLength( 0 );\n-  308: \t\t\t\t\t\t\t\t\toperands.add( operandToken );\n-  309: \t\t\t\t\t\t\t\t}\n-  310: \t\t\t\t\t\t\t\tbreak;\n-  311: \t\t\t\t\t\t}\n-  312: \t\t\t\t\t}\n-  313: \t\t\t\t\toperandToken = tokens.nextToken();\n-  314: \t\t\t\t\thasMoreOperands = tokens.hasMoreTokens() && ( parenthesis != 0 || ! \")\".equals( operandToken ) );\n-  315: \t\t\t\t}\n-  316: \t\t\t\tif ( builder.length() != 0 ) {\n-  317: \t\t\t\t\toperands.add( builder.toString() );\n-  318: \t\t\t\t}\n-  319: \n-  320: \t\t\t\tTrimOperands trimOperands = new TrimOperands( operands );\n-  321: \t\t\t\tresult.append( \"trim(\" );\n-  322: \t\t\t\tif ( trimOperands.trimSpec != null ) {\n-  323: \t\t\t\t\tresult.append( trimOperands.trimSpec ).append( ' ' );\n-  324: \t\t\t\t}\n-  325: \t\t\t\tif ( trimOperands.trimChar != null ) {\n-  326: \t\t\t\t\tif ( trimOperands.trimChar.startsWith( \"'\" ) && trimOperands.trimChar.endsWith( \"'\" ) ) {\n-  327: \t\t\t\t\t\tresult.append( trimOperands.trimChar );\n-  328: \t\t\t\t\t}\n-  329: \t\t\t\t\telse {\n-  330: \t\t\t\t\t\tresult.append(\n-  331: \t\t\t\t\t\t\t\trenderWhereStringTemplate( trimOperands.trimSpec, placeholder, dialect, typeConfiguration, functionRegistry )\n-  332: \t\t\t\t\t\t);\n-  333: \t\t\t\t\t}\n-  334: \t\t\t\t\tresult.append( ' ' );\n-  335: \t\t\t\t}\n-  336: \t\t\t\tif ( trimOperands.from != null ) {\n-  337: \t\t\t\t\tresult.append( trimOperands.from ).append( ' ' );\n-  338: \t\t\t\t}\n-  339: \t\t\t\telse if ( trimOperands.trimSpec != null || trimOperands.trimChar != null ) {\n-  340: \t\t\t\t\t// I think ANSI SQL says that the 'from' is not optional if either trim-spec or trim-char is specified\n-  341: \t\t\t\t\tresult.append( \"from \" );\n-  342: \t\t\t\t}\n-  343: \n-  344: \t\t\t\tresult.append( renderWhereStringTemplate( trimOperands.trimSource, placeholder, dialect, typeConfiguration, functionRegistry ) )\n-  345: \t\t\t\t\t\t.append( ')' );\n-  346: \n-  347: \t\t\t\thasMore = tokens.hasMoreTokens();\n-  348: \t\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n-  349: \n-  350: \t\t\t\tcontinue;\n-  351: \t\t\t}\n-  352: \n-  353: \t\t\tboolean quotedOrWhitespace = quoted || quotedIdentifier || isQuoteCharacter\n-  354: \t\t\t\t\t|| Character.isWhitespace( token.charAt(0) );\n-  355: \n-  356: \t\t\tif ( quotedOrWhitespace ) {\n-  357: \t\t\t\tresult.append( token );\n+  190: \t\t\t\telse {\n+  191: \t\t\t\t\tisOpenQuote = false;\n+  192: \t\t\t\t}\n+  193: \t\t\t\tif ( isOpenQuote ) {\n+  194: \t\t\t\t\tresult.append( placeholder ).append( '.' );\n+  195: \t\t\t\t}\n+  196: \t\t\t}\n+  197: \n+  198: \t\t\tfinal boolean quotedOrWhitespace =\n+  199: \t\t\t\t\tquoted || quotedIdentifier || isQuoteCharacter\n+  200: \t\t\t\t\t\t\t|| token.isBlank();\n+  201: \t\t\tif ( quotedOrWhitespace ) {\n+  202: \t\t\t\tresult.append( token );\n+  203: \t\t\t}\n+  204: \t\t\telse if ( beforeTable ) {\n+  205: \t\t\t\tresult.append( token );\n+  206: \t\t\t\tbeforeTable = false;\n+  207: \t\t\t\tafterFromTable = true;\n+  208: \t\t\t}\n+  209: \t\t\telse if ( afterFromTable ) {\n+  210: \t\t\t\tif ( !\"as\".equals(lcToken) ) {\n+  211: \t\t\t\t\tafterFromTable = false;\n+  212: \t\t\t\t}\n+  213: \t\t\t\tresult.append(token);\n+  214: \t\t\t}\n+  215: \t\t\telse if ( isNamedParameter(token) ) {\n+  216: \t\t\t\tresult.append(token);\n+  217: \t\t\t}\n+  218: \t\t\telse if ( isExtractFunction( lcToken, nextToken ) ) {\n+  219: \t\t\t\t// Special processing for ANSI SQL EXTRACT function\n+  220: \t\t\t\thandleExtractFunction( placeholder, dialect, typeConfiguration, functionRegistry, tokens, result );\n+  221: \t\t\t\thasMore = tokens.hasMoreTokens();\n+  222: \t\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n+  223: \t\t\t}\n+  224: \t\t\telse if ( isTrimFunction( lcToken, nextToken ) ) {\n+  225: \t\t\t\t// Special processing for ANSI SQL TRIM function\n+  226: \t\t\t\thandleTrimFunction( placeholder, dialect, typeConfiguration, functionRegistry, tokens, result );\n+  227: \t\t\t\thasMore = tokens.hasMoreTokens();\n+  228: \t\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n+  229: \t\t\t}\n+  230: \t\t\telse if ( isIdentifier(token)\n+  231: \t\t\t\t\t&& !isFunctionOrKeyword( lcToken, nextToken, dialect, typeConfiguration, functionRegistry )\n+  232: \t\t\t\t\t&& !isLiteral( lcToken, nextToken, sqlWhereString, symbols, tokens ) ) {\n+  233: \t\t\t\tresult.append(placeholder)\n+  234: \t\t\t\t\t\t.append('.')\n+  235: \t\t\t\t\t\t.append( dialect.quote(token) );\n+  236: \t\t\t}\n+  237: \t\t\telse {\n+  238: \t\t\t\tif ( BEFORE_TABLE_KEYWORDS.contains(lcToken) ) {\n+  239: \t\t\t\t\tbeforeTable = true;\n+  240: \t\t\t\t\tinFromClause = true;\n+  241: \t\t\t\t}\n+  242: \t\t\t\telse if ( inFromClause && \",\".equals(lcToken) ) {\n+  243: \t\t\t\t\tbeforeTable = true;\n+  244: \t\t\t\t}\n+  245: \t\t\t\tif ( isBoolean( token ) ) {\n+  246: \t\t\t\t\ttoken = dialect.toBooleanValueString( parseBoolean( token ) );\n+  247: \t\t\t\t}\n+  248: \t\t\t\tresult.append(token);\n+  249: \t\t\t}\n+  250: \n+  251: \t\t\t//Yuck:\n+  252: \t\t\tif ( inFromClause\n+  253: \t\t\t\t\t&& KEYWORDS.contains( lcToken ) //\"as\" is not in KEYWORDS\n+  254: \t\t\t\t\t&& !BEFORE_TABLE_KEYWORDS.contains( lcToken ) ) {\n+  255: \t\t\t\tinFromClause = false;\n+  256: \t\t\t}\n+  257: \t\t}\n+  258: \n+  259: \t\treturn result.toString();\n+  260: \t}\n+  261: \n+  262: \tprivate static boolean isTrimFunction(String lcToken, String nextToken) {\n+  263: \t\treturn \"trim\".equals(lcToken) && \"(\".equals(nextToken);\n+  264: \t}\n+  265: \n+  266: \tprivate static boolean isExtractFunction(String lcToken, String nextToken) {\n+  267: \t\treturn \"extract\".equals(lcToken) && \"(\".equals(nextToken);\n+  268: \t}\n+  269: \n+  270: \tprivate static boolean isLiteral(\n+  271: \t\t\tString lcToken, String next,\n+  272: \t\t\tString sqlWhereString, String symbols, StringTokenizer tokens) {\n+  273: \t\tif ( LITERAL_PREFIXES.contains( lcToken ) && next != null ) {\n+  274: \t\t\t// easy cases first\n+  275: \t\t\tif ( \"'\".equals(next) ) {\n+  276: \t\t\t\treturn true;\n+  277: \t\t\t}\n+  278: \t\t\telse if ( !next.isBlank() ) {\n+  279: \t\t\t\treturn false;\n+  280: \t\t\t}\n+  281: \t\t\telse {\n+  282: \t\t\t\t// we need to look ahead in the token stream\n+  283: \t\t\t\t// to find the first non-blank token\n+  284: \t\t\t\tfinal StringTokenizer lookahead =\n+  285: \t\t\t\t\t\tnew StringTokenizer( sqlWhereString, symbols, true );\n+  286: \t\t\t\twhile ( lookahead.countTokens() > tokens.countTokens()+1 ) {\n+  287: \t\t\t\t\tlookahead.nextToken();\n+  288: \t\t\t\t}\n+  289: \t\t\t\tif ( lookahead.hasMoreTokens() ) {\n+  290: \t\t\t\t\tString nextToken;\n+  291: \t\t\t\t\tdo {\n+  292: \t\t\t\t\t\tnextToken = lookahead.nextToken().toLowerCase(Locale.ROOT);\n+  293: \t\t\t\t\t}\n+  294: \t\t\t\t\twhile ( nextToken.isBlank() && lookahead.hasMoreTokens() );\n+  295: \t\t\t\t\treturn \"'\".equals( nextToken )\n+  296: \t\t\t\t\t\t|| lcToken.equals( \"time\" ) && \"with\".equals( nextToken )\n+  297: \t\t\t\t\t\t|| lcToken.equals( \"timestamp\" ) && \"with\".equals( nextToken )\n+  298: \t\t\t\t\t\t|| lcToken.equals( \"time\" ) && \"zone\".equals( nextToken );\n+  299: \t\t\t\t}\n+  300: \t\t\t\telse {\n+  301: \t\t\t\t\treturn false;\n+  302: \t\t\t\t}\n+  303: \t\t\t}\n+  304: \t\t}\n+  305: \t\telse {\n+  306: \t\t\treturn false;\n+  307: \t\t}\n+  308: \t}\n+  309: \n+  310: \tprivate static void handleTrimFunction(\n+  311: \t\t\tString placeholder, Dialect dialect,\n+  312: \t\t\tTypeConfiguration typeConfiguration,\n+  313: \t\t\tSqmFunctionRegistry functionRegistry,\n+  314: \t\t\tStringTokenizer tokens,\n+  315: \t\t\tStringBuilder result) {\n+  316: \t\tfinal List<String> operands = new ArrayList<>();\n+  317: \t\tfinal StringBuilder builder = new StringBuilder();\n+  318: \n+  319: \t\tboolean hasMoreOperands = true;\n+  320: \t\tString operandToken = tokens.nextToken();\n+  321: \t\tswitch ( operandToken.toLowerCase( Locale.ROOT ) ) {\n+  322: \t\t\tcase \"leading\":\n+  323: \t\t\tcase \"trailing\":\n+  324: \t\t\tcase \"both\":\n+  325: \t\t\t\toperands.add( operandToken );\n+  326: \t\t\t\tif ( hasMoreOperands = tokens.hasMoreTokens() ) {\n+  327: \t\t\t\t\toperandToken = tokens.nextToken();\n+  328: \t\t\t\t}\n+  329: \t\t\t\tbreak;\n+  330: \t\t}\n+  331: \t\tboolean quotedOperand = false;\n+  332: \t\tint parenthesis = 0;\n+  333: \t\twhile ( hasMoreOperands ) {\n+  334: \t\t\tfinal boolean isQuote = \"'\".equals( operandToken );\n+  335: \t\t\tif ( isQuote ) {\n+  336: \t\t\t\tquotedOperand = !quotedOperand;\n+  337: \t\t\t\tif ( !quotedOperand ) {\n+  338: \t\t\t\t\toperands.add( builder.append( '\\'' ).toString() );\n+  339: \t\t\t\t\tbuilder.setLength( 0 );\n+  340: \t\t\t\t}\n+  341: \t\t\t\telse {\n+  342: \t\t\t\t\tbuilder.append( '\\'' );\n+  343: \t\t\t\t}\n+  344: \t\t\t}\n+  345: \t\t\telse if ( quotedOperand ) {\n+  346: \t\t\t\tbuilder.append( operandToken );\n+  347: \t\t\t}\n+  348: \t\t\telse if ( parenthesis != 0 ) {\n+  349: \t\t\t\tbuilder.append( operandToken );\n+  350: \t\t\t\tswitch ( operandToken ) {\n+  351: \t\t\t\t\tcase \"(\":\n+  352: \t\t\t\t\t\tparenthesis++;\n+  353: \t\t\t\t\t\tbreak;\n+  354: \t\t\t\t\tcase \")\":\n+  355: \t\t\t\t\t\tparenthesis--;\n+  356: \t\t\t\t\t\tbreak;\n+  357: \t\t\t\t}\n   358: \t\t\t}\n-  359: \t\t\telse if ( beforeTable ) {\n-  360: \t\t\t\tresult.append( token );\n-  361: \t\t\t\tbeforeTable = false;\n-  362: \t\t\t\tafterFromTable = true;\n-  363: \t\t\t}\n-  364: \t\t\telse if ( afterFromTable ) {\n-  365: \t\t\t\tif ( !\"as\".equals(lcToken) ) {\n-  366: \t\t\t\t\tafterFromTable = false;\n-  367: \t\t\t\t}\n-  368: \t\t\t\tresult.append(token);\n-  369: \t\t\t}\n-  370: \t\t\telse if ( isNamedParameter(token) ) {\n-  371: \t\t\t\tresult.append(token);\n-  372: \t\t\t}\n-  373: \t\t\telse if ( isIdentifier(token)\n-  374: \t\t\t\t\t&& !isFunctionOrKeyword(lcToken, nextToken, dialect, typeConfiguration, functionRegistry) ) {\n-  375: \t\t\t\tresult.append(placeholder)\n-  376: \t\t\t\t\t\t.append('.')\n-  377: \t\t\t\t\t\t.append( dialect.quote(token) );\n-  378: \t\t\t}\n-  379: \t\t\telse {\n-  380: \t\t\t\tif ( BEFORE_TABLE_KEYWORDS.contains(lcToken) ) {\n-  381: \t\t\t\t\tbeforeTable = true;\n-  382: \t\t\t\t\tinFromClause = true;\n-  383: \t\t\t\t}\n-  384: \t\t\t\telse if ( inFromClause && \",\".equals(lcToken) ) {\n-  385: \t\t\t\t\tbeforeTable = true;\n-  386: \t\t\t\t}\n-  387: \t\t\t\tif ( isBoolean( token ) ) {\n-  388: \t\t\t\t\ttoken = dialect.toBooleanValueString( Boolean.parseBoolean( token ) );\n-  389: \t\t\t\t}\n-  390: \t\t\t\tresult.append(token);\n-  391: \t\t\t}\n-  392: \n-  393: \t\t\t//Yuck:\n-  394: \t\t\tif ( inFromClause\n-  395: \t\t\t\t\t&& KEYWORDS.contains( lcToken ) //\"as\" is not in KEYWORDS\n-  396: \t\t\t\t\t&& !BEFORE_TABLE_KEYWORDS.contains( lcToken ) ) {\n-  397: \t\t\t\tinFromClause = false;\n+  359: \t\t\telse {\n+  360: \t\t\t\tbuilder.append( operandToken );\n+  361: \t\t\t\tswitch ( operandToken.toLowerCase( Locale.ROOT ) ) {\n+  362: \t\t\t\t\tcase \"(\":\n+  363: \t\t\t\t\t\tparenthesis++;\n+  364: \t\t\t\t\t\tbreak;\n+  365: \t\t\t\t\tcase \")\":\n+  366: \t\t\t\t\t\tparenthesis--;\n+  367: \t\t\t\t\t\tbreak;\n+  368: \t\t\t\t\tcase \"from\":\n+  369: \t\t\t\t\t\tif ( !builder.isEmpty() ) {\n+  370: \t\t\t\t\t\t\toperands.add( builder.substring( 0, builder.length() - 4 ) );\n+  371: \t\t\t\t\t\t\tbuilder.setLength( 0 );\n+  372: \t\t\t\t\t\t\toperands.add( operandToken );\n+  373: \t\t\t\t\t\t}\n+  374: \t\t\t\t\t\tbreak;\n+  375: \t\t\t\t}\n+  376: \t\t\t}\n+  377: \t\t\toperandToken = tokens.nextToken();\n+  378: \t\t\thasMoreOperands = tokens.hasMoreTokens()\n+  379: \t\t\t\t\t&& ( parenthesis != 0 || ! \")\".equals( operandToken ) );\n+  380: \t\t}\n+  381: \t\tif ( !builder.isEmpty() ) {\n+  382: \t\t\toperands.add( builder.toString() );\n+  383: \t\t}\n+  384: \n+  385: \t\tfinal TrimOperands trimOperands = new TrimOperands( operands );\n+  386: \t\tresult.append( \"trim(\" );\n+  387: \t\tif ( trimOperands.trimSpec != null ) {\n+  388: \t\t\tresult.append( trimOperands.trimSpec ).append( ' ' );\n+  389: \t\t}\n+  390: \t\tif ( trimOperands.trimChar != null ) {\n+  391: \t\t\tif ( trimOperands.trimChar.startsWith( \"'\" ) && trimOperands.trimChar.endsWith( \"'\" ) ) {\n+  392: \t\t\t\tresult.append( trimOperands.trimChar );\n+  393: \t\t\t}\n+  394: \t\t\telse {\n+  395: \t\t\t\tresult.append(\n+  396: \t\t\t\t\t\trenderWhereStringTemplate( trimOperands.trimSpec, placeholder, dialect, typeConfiguration, functionRegistry )\n+  397: \t\t\t\t);\n   398: \t\t\t}\n-  399: \t\t}\n-  400: \n-  401: \t\treturn result.toString();\n-  402: \t}\n+  399: \t\t\tresult.append( ' ' );\n+  400: \t\t}\n+  401: \t\tif ( trimOperands.from != null ) {\n+  402: \t\t\tresult.append( trimOperands.from ).append( ' ' );\n",
        "uniqueId": "35f96d6e901dbd071b375d809521ef6f1c979868_119_402_262_264_122_260",
        "moveFileExist": true,
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 21,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 1,
                "covered": 289
            },
            "BRANCH": {
                "missed": 2,
                "covered": 74
            },
            "LINE": {
                "missed": 0,
                "covered": 79
            },
            "COMPLEXITY": {
                "missed": 2,
                "covered": 37
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        }
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprivate setupStatementInspector(jpa Jpa, integrationSettings Map<String,Object>) : void extracted from public findEntityManagerFactoryScope(testScope Object, emfAnnWrapper Optional<Jpa>, context ExtensionContext) : EntityManagerFactoryScope in class org.hibernate.testing.orm.junit.EntityManagerFactoryExtension",
        "diffLocations": [
            {
                "filePath": "hibernate-testing/src/main/java/org/hibernate/testing/orm/junit/EntityManagerFactoryExtension.java",
                "startLine": 66,
                "endLine": 203,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-testing/src/main/java/org/hibernate/testing/orm/junit/EntityManagerFactoryExtension.java",
                "startLine": 61,
                "endLine": 91,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-testing/src/main/java/org/hibernate/testing/orm/junit/EntityManagerFactoryExtension.java",
                "startLine": 181,
                "endLine": 189,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "public static EntityManagerFactoryScope findEntityManagerFactoryScope(\n\t\t\tObject testScope,\n\t\t\tOptional<Jpa> emfAnnWrapper,\n\t\t\tExtensionContext context) {\n\n\t\tif ( emfAnnWrapper.isEmpty() ) {\n\t\t\t// No annotation on the test class, should be on the test methods\n\t\t\treturn null;\n\t\t}\n\n\t\tfinal ExtensionContext.Store store = locateExtensionStore( testScope, context );\n\t\tfinal EntityManagerFactoryScope existing = (EntityManagerFactoryScope) store.get( EMF_KEY );\n\t\tif ( existing != null ) {\n\t\t\treturn existing;\n\t\t}\n\n\t\tif ( !context.getElement().isPresent() ) {\n\t\t\tthrow new RuntimeException( \"Unable to determine how to handle given ExtensionContext : \" + context.getDisplayName() );\n\t\t}\n\t\tfinal Jpa emfAnn = emfAnnWrapper.get();\n\n\t\tfinal PersistenceUnitInfoImpl pui = new PersistenceUnitInfoImpl( emfAnn.persistenceUnitName() );\n\t\t( (Map<Object, Object>) Environment.getProperties() ).forEach(\n\t\t\t\t(key, value) ->\n\t\t\t\t\t\tpui.getProperties().put( key, value )\n\t\t);\n\n\t\tpui.setTransactionType( emfAnn.transactionType() );\n\t\tpui.setCacheMode( emfAnn.sharedCacheMode() );\n\t\tpui.setValidationMode( emfAnn.validationMode() );\n\t\tpui.setExcludeUnlistedClasses( emfAnn.excludeUnlistedClasses() );\n\n\t\t// JpaCompliance\n\t\tpui.getProperties().put( AvailableSettings.JPA_COMPLIANCE, emfAnn.jpaComplianceEnabled() );\n\t\tpui.getProperties().put( AvailableSettings.JPA_QUERY_COMPLIANCE, emfAnn.queryComplianceEnabled() );\n\t\tpui.getProperties().put( AvailableSettings.JPA_TRANSACTION_COMPLIANCE, emfAnn.transactionComplianceEnabled() );\n\t\tpui.getProperties().put( AvailableSettings.JPA_CLOSED_COMPLIANCE, emfAnn.closedComplianceEnabled() );\n\t\tpui.getProperties().put( AvailableSettings.JPA_PROXY_COMPLIANCE, emfAnn.proxyComplianceEnabled() );\n\t\tpui.getProperties().put( AvailableSettings.JPA_CACHING_COMPLIANCE, emfAnn.cacheComplianceEnabled() );\n\t\tpui.getProperties().put( AvailableSettings.JPA_ID_GENERATOR_GLOBAL_SCOPE_COMPLIANCE, emfAnn.generatorScopeComplianceEnabled() );\n\t\tpui.getProperties().put( AvailableSettings.JPA_ORDER_BY_MAPPING_COMPLIANCE, emfAnn.orderByMappingComplianceEnabled() );\n\t\tpui.getProperties().put( AvailableSettings.JPA_LOAD_BY_ID_COMPLIANCE, emfAnn.loadByIdComplianceEnabled() );\n\n\t\tfinal Setting[] properties = emfAnn.properties();\n\t\tfor ( int i = 0; i < properties.length; i++ ) {\n\t\t\tfinal Setting property = properties[i];\n\t\t\tpui.getProperties().setProperty( property.name(), property.value() );\n\t\t}\n\n\t\tpui.getProperties().setProperty(\n\t\t\t\tAvailableSettings.GENERATE_STATISTICS,\n\t\t\t\tBoolean.toString( emfAnn.generateStatistics() )\n\t\t);\n\n\t\tif ( emfAnn.exportSchema() ) {\n\t\t\tpui.getProperties().setProperty(\n\t\t\t\t\tAvailableSettings.JAKARTA_HBM2DDL_DATABASE_ACTION,\n\t\t\t\t\tAction.CREATE_DROP.getExternalHbm2ddlName()\n\t\t\t);\n\t\t}\n\n\t\tif ( emfAnn.annotatedPackageNames().length > 0 ) {\n\t\t\tpui.applyManagedClassNames( emfAnn.annotatedPackageNames() );\n\t\t}\n\n\t\tif ( emfAnn.annotatedClassNames().length > 0 ) {\n\t\t\tpui.applyManagedClassNames( emfAnn.annotatedClassNames() );\n\t\t}\n\n\t\tif ( emfAnn.annotatedClasses().length > 0 ) {\n\t\t\tfor ( int i = 0; i < emfAnn.annotatedClasses().length; i++ ) {\n\t\t\t\tpui.applyManagedClassNames( emfAnn.annotatedClasses()[i].getName() );\n\t\t\t}\n\t\t}\n\n\t\tif ( emfAnn.xmlMappings().length > 0 ) {\n\t\t\tpui.applyMappingFiles( emfAnn.xmlMappings() );\n\t\t}\n\n\t\tif ( emfAnn.standardModels().length > 0 ) {\n\t\t\tfor ( int i = 0; i < emfAnn.standardModels().length; i++ ) {\n\t\t\t\tfinal StandardDomainModel standardDomainModel = emfAnn.standardModels()[i];\n\t\t\t\tfor ( int i1 = 0; i1 < standardDomainModel.getDescriptor().getAnnotatedClasses().length; i1++ ) {\n\t\t\t\t\tfinal Class<?> annotatedClass = standardDomainModel.getDescriptor().getAnnotatedClasses()[i1];\n\t\t\t\t\tpui.applyManagedClassNames( annotatedClass.getName() );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ( emfAnn.modelDescriptorClasses().length > 0 ) {\n\t\t\tfor ( int i = 0; i < emfAnn.modelDescriptorClasses().length; i++ ) {\n\t\t\t\tfinal Class<? extends DomainModelDescriptor> modelDescriptorClass = emfAnn.modelDescriptorClasses()[i];\n\t\t\t\tfinal DomainModelDescriptor domainModelDescriptor = instantiateDomainModelDescriptor(\n\t\t\t\t\t\tmodelDescriptorClass );\n\t\t\t\tfor ( int i1 = 0; i1 < domainModelDescriptor.getAnnotatedClasses().length; i1++ ) {\n\t\t\t\t\tfinal Class<?> annotatedClass = domainModelDescriptor.getAnnotatedClasses()[i1];\n\t\t\t\t\tpui.applyManagedClassNames( annotatedClass.getName() );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfinal Map<String, Object> integrationSettings = new HashMap<>();\n\n\t\tintegrationSettings.put( PersistentTableStrategy.DROP_ID_TABLES, \"true\" );\n\t\tintegrationSettings.put( GlobalTemporaryTableMutationStrategy.DROP_ID_TABLES, \"true\" );\n\t\tintegrationSettings.put( LocalTemporaryTableMutationStrategy.DROP_ID_TABLES, \"true\" );\n\t\tfor ( int i = 0; i < emfAnn.integrationSettings().length; i++ ) {\n\t\t\tfinal Setting setting = emfAnn.integrationSettings()[i];\n\t\t\tintegrationSettings.put( setting.name(), setting.value() );\n\t\t}\n\n\t\tfor ( SettingProvider providerAnn : emfAnn.settingProviders() ) {\n\t\t\tfinal Class<? extends SettingProvider.Provider<?>> providerImpl = providerAnn.provider();\n\t\t\ttry {\n\t\t\t\tfinal SettingProvider.Provider<?> provider = providerImpl.getConstructor().newInstance();\n\t\t\t\tintegrationSettings.put( providerAnn.settingName(), provider.getSetting() );\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tlog.error( \"Error obtaining setting provider for \" + providerImpl.getName(), e );\n\t\t\t}\n\t\t}\n\n\t\t// statement inspector\n\t\tif ( emfAnn.useCollectingStatementInspector() ) {\n\t\t\tString inspectorSetting = (String) integrationSettings.get( AvailableSettings.STATEMENT_INSPECTOR );\n\t\t\tif ( !(inspectorSetting == null || inspectorSetting.isBlank()) ) {\n\t\t\t\tlog.warn( String.format( \"Overriding the explicit \\\"%1s\\\" statement inspector setting\", inspectorSetting ) );\n\t\t\t}\n\t\t\tintegrationSettings.put( AvailableSettings.STATEMENT_INSPECTOR, new SQLStatementInspector() );\n\t\t}\n\n\t\tServiceRegistryUtil.applySettings( integrationSettings );\n\t\tfinal EntityManagerFactoryScopeImpl scope = new EntityManagerFactoryScopeImpl( pui, integrationSettings );\n\n\t\tstore.put( EMF_KEY, scope );\n\n\t\treturn scope;\n\t}",
        "filePathBefore": "hibernate-testing/src/main/java/org/hibernate/testing/orm/junit/EntityManagerFactoryExtension.java",
        "isPureRefactoring": true,
        "commitId": "4781c09d0df0eb4ce05b2fa0d2a12747023ae024",
        "packageNameBefore": "org.hibernate.testing.orm.junit",
        "classNameBefore": "org.hibernate.testing.orm.junit.EntityManagerFactoryExtension",
        "methodNameBefore": "org.hibernate.testing.orm.junit.EntityManagerFactoryExtension#findEntityManagerFactoryScope",
        "invokedMethod": "methodSignature: org.hibernate.jpa.boot.internal.ParsedPersistenceXmlDescriptor#setValidationMode\n methodBody: public void setValidationMode(String validationMode) {\nsetValidationMode(ValidationMode.valueOf(validationMode));\n}\nmethodSignature: org.hibernate.testing.junit4.BaseNonConfigCoreFunctionalTestCase#getAnnotatedClasses\n methodBody: protected Class[] getAnnotatedClasses() {\nreturn NO_CLASSES;\n}\nmethodSignature: org.hibernate.jpa.boot.internal.PersistenceUnitInfoDescriptor#getName\n methodBody: public String getName() {\nreturn persistenceUnitInfo.getPersistenceUnitName();\n}\nmethodSignature: org.hibernate.testing.orm.jpa.PersistenceUnitInfoImpl#setTransactionType\n methodBody: public void setTransactionType(PersistenceUnitTransactionType transactionType) {\nthis.transactionType=transactionType;\n}\nmethodSignature: org.hibernate.testing.orm.junit.EntityManagerFactoryBasedFunctionalTest#applySettings\n methodBody: protected void applySettings(Map<Object, Object> settings) {\nString[] mappings=getMappings();\nif(mappings != null){settings.put(AvailableSettings.HBM_XML_FILES,String.join(\",\",mappings));\n}}\nmethodSignature: org.hibernate.testing.orm.jpa.PersistenceUnitInfoImpl#setValidationMode\n methodBody: public void setValidationMode(ValidationMode validationMode) {\nthis.validationMode=validationMode;\n}\nmethodSignature: org.hibernate.collection.spi.AbstractPersistentCollection.SetProxy#isEmpty\n methodBody: public boolean isEmpty() {\nreturn set.isEmpty();\n}\nmethodSignature: org.hibernate.testing.orm.jpa.PersistenceUnitInfoImpl#applyMappingFiles\n methodBody: public void applyMappingFiles(String... mappingFiles) {\nif(this.mappingFiles == null){this.mappingFiles=new ArrayList<>();\n}Collections.addAll(this.mappingFiles,mappingFiles);\n}\nmethodSignature: org.hibernate.testing.util.jpa.DelegatingPersistenceUnitInfo#getProperties\n methodBody: public Properties getProperties() {\nreturn delegate.getProperties();\n}\nmethodSignature: org.hibernate.orm.test.exceptionhandling.BaseJpaOrNativeBootstrapFunctionalTestCase.TestingPersistenceUnitDescriptorImpl#getName\n methodBody: public String getName() {\nreturn name;\n}\nmethodSignature: org.hibernate.collection.spi.PersistentList#get\n methodBody: public E get(int index) {\nif(index < 0){throw new ArrayIndexOutOfBoundsException(\"negative index\");\n}final Object result=readElementByIndex(index);\nreturn result == UNKNOWN ? list.get(index) : (E)result;\n}\nmethodSignature: org.hibernate.orm.test.bootstrap.BootstrapTest.PersistenceUnitInfoImpl#getProperties\n methodBody: public Properties getProperties() {\nreturn properties;\n}\nmethodSignature: org.hibernate.testing.orm.junit.EntityManagerFactoryBasedFunctionalTest.TestingPersistenceUnitDescriptorImpl#getName\n methodBody: public String getName() {\nreturn name;\n}\nmethodSignature: org.hibernate.jpa.boot.spi.PersistenceConfigurationDescriptor#getName\n methodBody: public String getName() {\nreturn persistenceConfiguration.name();\n}\nmethodSignature: org.hibernate.jpa.boot.internal.PersistenceUnitInfoDescriptor#getProperties\n methodBody: public Properties getProperties() {\nreturn persistenceUnitInfo.getProperties();\n}\nmethodSignature: org.hibernate.jpa.boot.spi.PersistenceUnitDescriptor#getProperties\n methodBody: Properties getProperties();\nmethodSignature: org.hibernate.testing.orm.junit.BaseSessionFactoryFunctionalTest#getAnnotatedClasses\n methodBody: protected Class[] getAnnotatedClasses() {\nreturn NO_CLASSES;\n}\nmethodSignature: org.hibernate.testing.orm.junit.BaseSessionFactoryFunctionalTest#applySettings\n methodBody: protected void applySettings(StandardServiceRegistryBuilder builder) {\n}\nmethodSignature: org.hibernate.testing.orm.jpa.PersistenceUnitInfoAdapter#getProperties\n methodBody: public Properties getProperties() {\nif(properties == null){properties=new Properties();\n}return properties;\n}\nmethodSignature: org.hibernate.testing.util.jpa.DelegatingPersistenceUnitInfo#excludeUnlistedClasses\n methodBody: public boolean excludeUnlistedClasses() {\nreturn delegate.excludeUnlistedClasses();\n}\nmethodSignature: org.hibernate.testing.util.jpa.PersistenceUnitInfoAdapter#getProperties\n methodBody: public Properties getProperties() {\nreturn properties;\n}\nmethodSignature: org.hibernate.testing.orm.jpa.PersistenceUnitInfoImpl#setCacheMode\n methodBody: public void setCacheMode(SharedCacheMode cacheMode) {\nthis.cacheMode=cacheMode;\n}\nmethodSignature: org.hibernate.jpa.boot.internal.ParsedPersistenceXmlDescriptor#getName\n methodBody: public String getName() {\nreturn name;\n}\nmethodSignature: org.hibernate.orm.test.jpa.BaseEntityManagerFunctionalTestCase.TestingPersistenceUnitDescriptorImpl#getName\n methodBody: public String getName() {\nreturn name;\n}\nmethodSignature: org.hibernate.testing.orm.jpa.PersistenceUnitInfoImpl#excludeUnlistedClasses\n methodBody: public boolean excludeUnlistedClasses() {\nreturn excludeUnlistedClasses;\n}\nmethodSignature: org.hibernate.testing.orm.junit.EntityManagerFactoryBasedFunctionalTest#getAnnotatedClasses\n methodBody: protected Class<?>[] getAnnotatedClasses() {\nreturn NO_CLASSES;\n}\nmethodSignature: org.hibernate.collection.spi.AbstractPersistentCollection.ListProxy#get\n methodBody: public E get(int i) {\nreturn list.get(i);\n}\nmethodSignature: org.hibernate.testing.util.jpa.PersistenceUnitInfoAdapter#excludeUnlistedClasses\n methodBody: public boolean excludeUnlistedClasses() {\nreturn false;\n}\nmethodSignature: org.hibernate.orm.test.exceptionhandling.BaseJpaOrNativeBootstrapFunctionalTestCase#getAnnotatedClasses\n methodBody: protected Class<?>[] getAnnotatedClasses() {\nreturn NO_CLASSES;\n}\nmethodSignature: org.hibernate.orm.test.bootstrap.BootstrapTest.PersistenceUnitInfoImpl#excludeUnlistedClasses\n methodBody: public boolean excludeUnlistedClasses() {\nreturn false;\n}\nmethodSignature: org.hibernate.jpa.boot.spi.PersistenceConfigurationDescriptor#getProperties\n methodBody: public Properties getProperties() {\nreturn properties;\n}\nmethodSignature: org.hibernate.testing.orm.jpa.PersistenceUnitDescriptorAdapter#getProperties\n methodBody: public Properties getProperties() {\nif(properties == null){properties=new Properties();\n}return properties;\n}\nmethodSignature: org.hibernate.collection.spi.PersistentBag#get\n methodBody: public E get(int i) {\nread();\nreturn bag.get(i);\n}\nmethodSignature: org.hibernate.testing.orm.jpa.PersistenceUnitInfoAdapter#excludeUnlistedClasses\n methodBody: public boolean excludeUnlistedClasses() {\nreturn false;\n}\nmethodSignature: org.hibernate.testing.orm.jpa.PersistenceUnitInfoImpl#setExcludeUnlistedClasses\n methodBody: public void setExcludeUnlistedClasses(boolean excludeUnlistedClasses) {\nthis.excludeUnlistedClasses=excludeUnlistedClasses;\n}\nmethodSignature: org.hibernate.collection.spi.PersistentList#toString\n methodBody: public String toString() {\nread();\nreturn list.toString();\n}\nmethodSignature: org.hibernate.testing.junit4.BaseCoreFunctionalTestCase#getAnnotatedClasses\n methodBody: protected Class<?>[] getAnnotatedClasses() {\nreturn NO_CLASSES;\n}\nmethodSignature: org.hibernate.collection.spi.PersistentBag#getElement\n methodBody: public Object getElement(Object entry) {\nreturn entry;\n}\nmethodSignature: org.hibernate.collection.spi.PersistentBag#isEmpty\n methodBody: public boolean isEmpty() {\nreturn readSize() ? getCachedSize() == 0 : bag.isEmpty();\n}\nmethodSignature: org.hibernate.orm.test.jpa.xml.versions.JpaXsdVersionsTest.PersistenceUnitInfoImpl#getProperties\n methodBody: public Properties getProperties() {\nreturn properties;\n}\nmethodSignature: org.hibernate.jpa.boot.internal.ParsedPersistenceXmlDescriptor#setTransactionType\n methodBody: public void setTransactionType(PersistenceUnitTransactionType transactionType) {\nthis.transactionType=transactionType;\n}\nmethodSignature: org.hibernate.orm.test.jpa.EntityManagerTest#getAnnotatedClasses\n methodBody: public Class[] getAnnotatedClasses() {\nreturn new Class[]{Item.class,Distributor.class,Wallet.class};\n}\nmethodSignature: org.hibernate.orm.test.jpa.BaseEntityManagerFunctionalTestCase#getAnnotatedClasses\n methodBody: protected Class<?>[] getAnnotatedClasses() {\nreturn NO_CLASSES;\n}\nmethodSignature: org.hibernate.testing.orm.junit.EntityManagerFactoryBasedFunctionalTest#exportSchema\n methodBody: protected boolean exportSchema() {\nreturn true;\n}\nmethodSignature: org.hibernate.jpa.boot.internal.ParsedPersistenceXmlDescriptor#getProperties\n methodBody: public Properties getProperties() {\nreturn properties;\n}\nmethodSignature: org.hibernate.internal.SessionFactoryImpl#getProperties\n methodBody: public Map<String, Object> getProperties() {\nvalidateNotClosed();\nreturn settings;\n}\nmethodSignature: org.hibernate.testing.util.jpa.PersistenceUnitInfoPropertiesWrapper#excludeUnlistedClasses\n methodBody: public boolean excludeUnlistedClasses() {\nreturn false;\n}\nmethodSignature: org.hibernate.orm.test.jpa.xml.versions.JpaXsdVersionsTest.PersistenceUnitInfoImpl#excludeUnlistedClasses\n methodBody: public boolean excludeUnlistedClasses() {\nreturn false;\n}\nmethodSignature: org.hibernate.jpa.boot.spi.PersistenceUnitDescriptor#getName\n methodBody: String getName();\nmethodSignature: org.hibernate.orm.test.exceptionhandling.BaseJpaOrNativeBootstrapFunctionalTestCase.TestingPersistenceUnitDescriptorImpl#getProperties\n methodBody: public Properties getProperties() {\nreturn null;\n}\nmethodSignature: org.hibernate.testing.orm.jpa.PersistenceUnitDescriptorAdapter#getName\n methodBody: public String getName() {\nreturn name;\n}\nmethodSignature: org.hibernate.testing.orm.junit.EntityManagerFactoryExtension#locateExtensionStore\n methodBody: private static ExtensionContext.Store locateExtensionStore(Object testScope, ExtensionContext context) {\nreturn JUnitHelper.locateExtensionStore(EntityManagerFactoryExtension.class,context,testScope);\n}\nmethodSignature: org.hibernate.jpa.boot.internal.ParsedPersistenceXmlDescriptor#setExcludeUnlistedClasses\n methodBody: public void setExcludeUnlistedClasses(boolean excludeUnlistedClasses) {\nthis.excludeUnlistedClasses=excludeUnlistedClasses;\n}\nmethodSignature: org.hibernate.testing.orm.jpa.PersistenceUnitInfoImpl#applyManagedClassNames\n methodBody: public void applyManagedClassNames(String... managedClassNames) {\nif(this.managedClassNames == null){this.managedClassNames=new ArrayList<>();\n}Collections.addAll(this.managedClassNames,managedClassNames);\n}\nmethodSignature: org.hibernate.testing.util.jpa.PersistenceUnitInfoPropertiesWrapper#getProperties\n methodBody: public Properties getProperties() {\nif(properties == null){properties=new Properties();\n}return properties;\n}\nmethodSignature: org.hibernate.collection.spi.PersistentList#getElement\n methodBody: public Object getElement(Object entry) {\nreturn entry;\n}\nmethodSignature: org.hibernate.orm.test.jpa.BaseEntityManagerFunctionalTestCase.TestingPersistenceUnitDescriptorImpl#getProperties\n methodBody: public Properties getProperties() {\nreturn null;\n}\nmethodSignature: org.hibernate.internal.SessionFactoryImpl#getName\n methodBody: public String getName() {\nreturn name;\n}\nmethodSignature: org.hibernate.testing.orm.junit.EntityManagerFactoryBasedFunctionalTest.TestingPersistenceUnitDescriptorImpl#getProperties\n methodBody: public Properties getProperties() {\nreturn null;\n}\nmethodSignature: org.hibernate.collection.spi.PersistentList#isEmpty\n methodBody: public boolean isEmpty() {\nreturn readSize() ? getCachedSize() == 0 : list.isEmpty();\n}\nmethodSignature: org.hibernate.testing.orm.jpa.PersistenceUnitInfoImpl#getProperties\n methodBody: public Properties getProperties() {\nreturn properties;\n}\nmethodSignature: org.hibernate.testing.orm.junit.EntityManagerFactoryExtension#instantiateDomainModelDescriptor\n methodBody: private static DomainModelDescriptor instantiateDomainModelDescriptor(Class<? extends DomainModelDescriptor> modelDescriptorClass) {\ntryfinal Field[] declaredFields=modelDescriptorClass.getDeclaredFields();\nfor(int i=0; i < declaredFields.length; i++){final Field field=declaredFields[i];\nif(ReflectHelper.isStaticField(field)){final Object value=field.get(null);\nif(value instanceof DomainModelDescriptor){return (DomainModelDescriptor)value;\n}}}catch(IllegalAccessException e)throw new RuntimeException(\"Problem accessing DomainModelDescriptor fields : \" + modelDescriptorClass.getName(),e);\ntryreturn modelDescriptorClass.getConstructor(null).newInstance(null);\ncatch(InstantiationException|IllegalAccessException|InvocationTargetException|NoSuchMethodException e)throw new RuntimeException(\"Problem instantiation DomainModelDescriptor : \" + modelDescriptorClass.getName(),e);\n}\nmethodSignature: org.hibernate.testing.orm.junit.BaseSessionFactoryFunctionalTest#exportSchema\n methodBody: protected boolean exportSchema() {\nreturn true;\n}\nmethodSignature: org.hibernate.collection.spi.AbstractPersistentCollection.ListProxy#isEmpty\n methodBody: public boolean isEmpty() {\nreturn list.isEmpty();\n}\nmethodSignature: org.hibernate.collection.spi.PersistentBag#toString\n methodBody: public String toString() {\nread();\nreturn bag.toString();\n}",
        "classSignatureBefore": "public class EntityManagerFactoryExtension\n\t\timplements TestInstancePostProcessor, BeforeEachCallback, TestExecutionExceptionHandler ",
        "methodNameBeforeSet": [
            "org.hibernate.testing.orm.junit.EntityManagerFactoryExtension#findEntityManagerFactoryScope"
        ],
        "classNameBeforeSet": [
            "org.hibernate.testing.orm.junit.EntityManagerFactoryExtension"
        ],
        "classSignatureBeforeSet": [
            "public class EntityManagerFactoryExtension\n\t\timplements TestInstancePostProcessor, BeforeEachCallback, TestExecutionExceptionHandler "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Overlapped refactoring - can be identical by undoing the overlapped refactoring\n- Rename Variable-",
                "description": "Rename Variable on top of the extract method - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later\n * See the lgpl.txt file in the root directory or http://www.gnu.org/licenses/lgpl-2.1.html\n */\npackage org.hibernate.testing.orm.junit;\n\nimport java.lang.reflect.Field;\nimport java.lang.reflect.InvocationTargetException;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.Set;\nimport jakarta.persistence.spi.PersistenceUnitInfo;\n\nimport org.hibernate.SessionFactoryObserver;\nimport org.hibernate.boot.registry.StandardServiceRegistry;\nimport org.hibernate.boot.spi.MetadataImplementor;\nimport org.hibernate.cfg.AvailableSettings;\nimport org.hibernate.cfg.Environment;\nimport org.hibernate.engine.spi.SessionFactoryImplementor;\nimport org.hibernate.internal.util.ReflectHelper;\nimport org.hibernate.jpa.boot.internal.PersistenceUnitInfoDescriptor;\nimport org.hibernate.jpa.boot.spi.Bootstrap;\nimport org.hibernate.jpa.boot.spi.EntityManagerFactoryBuilder;\nimport org.hibernate.query.sqm.mutation.internal.temptable.GlobalTemporaryTableMutationStrategy;\nimport org.hibernate.query.sqm.mutation.internal.temptable.LocalTemporaryTableMutationStrategy;\nimport org.hibernate.query.sqm.mutation.internal.temptable.PersistentTableStrategy;\nimport org.hibernate.tool.schema.Action;\nimport org.hibernate.tool.schema.spi.SchemaManagementToolCoordinator;\nimport org.hibernate.tool.schema.spi.SchemaManagementToolCoordinator.ActionGrouping;\n\nimport org.hibernate.testing.jdbc.SQLStatementInspector;\nimport org.hibernate.testing.orm.domain.DomainModelDescriptor;\nimport org.hibernate.testing.orm.domain.StandardDomainModel;\nimport org.hibernate.testing.orm.jpa.PersistenceUnitInfoImpl;\nimport org.hibernate.testing.util.ServiceRegistryUtil;\nimport org.junit.jupiter.api.extension.BeforeEachCallback;\nimport org.junit.jupiter.api.extension.ExtensionContext;\nimport org.junit.jupiter.api.extension.TestExecutionExceptionHandler;\nimport org.junit.jupiter.api.extension.TestInstancePostProcessor;\nimport org.junit.platform.commons.support.AnnotationSupport;\n\nimport org.jboss.logging.Logger;\n\n/**\n * hibernate-testing implementation of a few JUnit5 contracts to support SessionFactory-based testing,\n * including argument injection (or see {@link SessionFactoryScopeAware})\n *\n * @author Steve Ebersole\n *\n * @see DomainModelExtension\n * @see SessionFactoryExtension\n */\npublic class EntityManagerFactoryExtension\n\t\timplements TestInstancePostProcessor, BeforeEachCallback, TestExecutionExceptionHandler {\n\n\tprivate static final Logger log = Logger.getLogger( EntityManagerFactoryExtension.class );\n\tprivate static final String EMF_KEY = EntityManagerFactoryScope.class.getName();\n\n\tprivate static ExtensionContext.Store locateExtensionStore(Object testScope, ExtensionContext context) {\n\t\treturn JUnitHelper.locateExtensionStore( EntityManagerFactoryExtension.class, context, testScope );\n\t}\n\n\tpublic static EntityManagerFactoryScope findEntityManagerFactoryScope(\n\t\t\tObject testScope,\n\t\t\tOptional<Jpa> emfAnnWrapper,\n\t\t\tExtensionContext context) {\n\n\t\tif ( emfAnnWrapper.isEmpty() ) {\n\t\t\t// No annotation on the test class, should be on the test methods\n\t\t\treturn null;\n\t\t}\n\n\t\tfinal ExtensionContext.Store store = locateExtensionStore( testScope, context );\n\t\tfinal EntityManagerFactoryScope existing = (EntityManagerFactoryScope) store.get( EMF_KEY );\n\t\tif ( existing != null ) {\n\t\t\treturn existing;\n\t\t}\n\n\t\tif ( !context.getElement().isPresent() ) {\n\t\t\tthrow new RuntimeException( \"Unable to determine how to handle given ExtensionContext : \" + context.getDisplayName() );\n\t\t}\n\t\tfinal Jpa emfAnn = emfAnnWrapper.get();\n\n\t\tfinal PersistenceUnitInfoImpl pui = new PersistenceUnitInfoImpl( emfAnn.persistenceUnitName() );\n\t\t( (Map<Object, Object>) Environment.getProperties() ).forEach(\n\t\t\t\t(key, value) ->\n\t\t\t\t\t\tpui.getProperties().put( key, value )\n\t\t);\n\n\t\tpui.setTransactionType( emfAnn.transactionType() );\n\t\tpui.setCacheMode( emfAnn.sharedCacheMode() );\n\t\tpui.setValidationMode( emfAnn.validationMode() );\n\t\tpui.setExcludeUnlistedClasses( emfAnn.excludeUnlistedClasses() );\n\n\t\t// JpaCompliance\n\t\tpui.getProperties().put( AvailableSettings.JPA_COMPLIANCE, emfAnn.jpaComplianceEnabled() );\n\t\tpui.getProperties().put( AvailableSettings.JPA_QUERY_COMPLIANCE, emfAnn.queryComplianceEnabled() );\n\t\tpui.getProperties().put( AvailableSettings.JPA_TRANSACTION_COMPLIANCE, emfAnn.transactionComplianceEnabled() );\n\t\tpui.getProperties().put( AvailableSettings.JPA_CLOSED_COMPLIANCE, emfAnn.closedComplianceEnabled() );\n\t\tpui.getProperties().put( AvailableSettings.JPA_PROXY_COMPLIANCE, emfAnn.proxyComplianceEnabled() );\n\t\tpui.getProperties().put( AvailableSettings.JPA_CACHING_COMPLIANCE, emfAnn.cacheComplianceEnabled() );\n\t\tpui.getProperties().put( AvailableSettings.JPA_ID_GENERATOR_GLOBAL_SCOPE_COMPLIANCE, emfAnn.generatorScopeComplianceEnabled() );\n\t\tpui.getProperties().put( AvailableSettings.JPA_ORDER_BY_MAPPING_COMPLIANCE, emfAnn.orderByMappingComplianceEnabled() );\n\t\tpui.getProperties().put( AvailableSettings.JPA_LOAD_BY_ID_COMPLIANCE, emfAnn.loadByIdComplianceEnabled() );\n\n\t\tfinal Setting[] properties = emfAnn.properties();\n\t\tfor ( int i = 0; i < properties.length; i++ ) {\n\t\t\tfinal Setting property = properties[i];\n\t\t\tpui.getProperties().setProperty( property.name(), property.value() );\n\t\t}\n\n\t\tpui.getProperties().setProperty(\n\t\t\t\tAvailableSettings.GENERATE_STATISTICS,\n\t\t\t\tBoolean.toString( emfAnn.generateStatistics() )\n\t\t);\n\n\t\tif ( emfAnn.exportSchema() ) {\n\t\t\tpui.getProperties().setProperty(\n\t\t\t\t\tAvailableSettings.JAKARTA_HBM2DDL_DATABASE_ACTION,\n\t\t\t\t\tAction.CREATE_DROP.getExternalHbm2ddlName()\n\t\t\t);\n\t\t}\n\n\t\tif ( emfAnn.annotatedPackageNames().length > 0 ) {\n\t\t\tpui.applyManagedClassNames( emfAnn.annotatedPackageNames() );\n\t\t}\n\n\t\tif ( emfAnn.annotatedClassNames().length > 0 ) {\n\t\t\tpui.applyManagedClassNames( emfAnn.annotatedClassNames() );\n\t\t}\n\n\t\tif ( emfAnn.annotatedClasses().length > 0 ) {\n\t\t\tfor ( int i = 0; i < emfAnn.annotatedClasses().length; i++ ) {\n\t\t\t\tpui.applyManagedClassNames( emfAnn.annotatedClasses()[i].getName() );\n\t\t\t}\n\t\t}\n\n\t\tif ( emfAnn.xmlMappings().length > 0 ) {\n\t\t\tpui.applyMappingFiles( emfAnn.xmlMappings() );\n\t\t}\n\n\t\tif ( emfAnn.standardModels().length > 0 ) {\n\t\t\tfor ( int i = 0; i < emfAnn.standardModels().length; i++ ) {\n\t\t\t\tfinal StandardDomainModel standardDomainModel = emfAnn.standardModels()[i];\n\t\t\t\tfor ( int i1 = 0; i1 < standardDomainModel.getDescriptor().getAnnotatedClasses().length; i1++ ) {\n\t\t\t\t\tfinal Class<?> annotatedClass = standardDomainModel.getDescriptor().getAnnotatedClasses()[i1];\n\t\t\t\t\tpui.applyManagedClassNames( annotatedClass.getName() );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ( emfAnn.modelDescriptorClasses().length > 0 ) {\n\t\t\tfor ( int i = 0; i < emfAnn.modelDescriptorClasses().length; i++ ) {\n\t\t\t\tfinal Class<? extends DomainModelDescriptor> modelDescriptorClass = emfAnn.modelDescriptorClasses()[i];\n\t\t\t\tfinal DomainModelDescriptor domainModelDescriptor = instantiateDomainModelDescriptor(\n\t\t\t\t\t\tmodelDescriptorClass );\n\t\t\t\tfor ( int i1 = 0; i1 < domainModelDescriptor.getAnnotatedClasses().length; i1++ ) {\n\t\t\t\t\tfinal Class<?> annotatedClass = domainModelDescriptor.getAnnotatedClasses()[i1];\n\t\t\t\t\tpui.applyManagedClassNames( annotatedClass.getName() );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfinal Map<String, Object> integrationSettings = new HashMap<>();\n\n\t\tintegrationSettings.put( PersistentTableStrategy.DROP_ID_TABLES, \"true\" );\n\t\tintegrationSettings.put( GlobalTemporaryTableMutationStrategy.DROP_ID_TABLES, \"true\" );\n\t\tintegrationSettings.put( LocalTemporaryTableMutationStrategy.DROP_ID_TABLES, \"true\" );\n\t\tfor ( int i = 0; i < emfAnn.integrationSettings().length; i++ ) {\n\t\t\tfinal Setting setting = emfAnn.integrationSettings()[i];\n\t\t\tintegrationSettings.put( setting.name(), setting.value() );\n\t\t}\n\n\t\tfor ( SettingProvider providerAnn : emfAnn.settingProviders() ) {\n\t\t\tfinal Class<? extends SettingProvider.Provider<?>> providerImpl = providerAnn.provider();\n\t\t\ttry {\n\t\t\t\tfinal SettingProvider.Provider<?> provider = providerImpl.getConstructor().newInstance();\n\t\t\t\tintegrationSettings.put( providerAnn.settingName(), provider.getSetting() );\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tlog.error( \"Error obtaining setting provider for \" + providerImpl.getName(), e );\n\t\t\t}\n\t\t}\n\n\t\t// statement inspector\n\t\tif ( emfAnn.useCollectingStatementInspector() ) {\n\t\t\tString inspectorSetting = (String) integrationSettings.get( AvailableSettings.STATEMENT_INSPECTOR );\n\t\t\tif ( !(inspectorSetting == null || inspectorSetting.isBlank()) ) {\n\t\t\t\tlog.warn( String.format( \"Overriding the explicit \\\"%1s\\\" statement inspector setting\", inspectorSetting ) );\n\t\t\t}\n\t\t\tintegrationSettings.put( AvailableSettings.STATEMENT_INSPECTOR, new SQLStatementInspector() );\n\t\t}\n\n\t\tServiceRegistryUtil.applySettings( integrationSettings );\n\t\tfinal EntityManagerFactoryScopeImpl scope = new EntityManagerFactoryScopeImpl( pui, integrationSettings );\n\n\t\tstore.put( EMF_KEY, scope );\n\n\t\treturn scope;\n\t}\n\n\tprivate static DomainModelDescriptor instantiateDomainModelDescriptor(Class<? extends DomainModelDescriptor> modelDescriptorClass) {\n\t\t// first, see if it has a static singleton reference and use that if so\n\t\ttry {\n\t\t\tfinal Field[] declaredFields = modelDescriptorClass.getDeclaredFields();\n\t\t\tfor ( int i = 0; i < declaredFields.length; i++ ) {\n\t\t\t\tfinal Field field = declaredFields[i];\n\t\t\t\tif ( ReflectHelper.isStaticField( field ) ) {\n\t\t\t\t\tfinal Object value = field.get( null );\n\t\t\t\t\tif ( value instanceof DomainModelDescriptor ) {\n\t\t\t\t\t\treturn (DomainModelDescriptor) value;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (IllegalAccessException e) {\n\t\t\tthrow new RuntimeException(\n\t\t\t\t\t\"Problem accessing DomainModelDescriptor fields : \" + modelDescriptorClass.getName(),\n\t\t\t\t\te\n\t\t\t);\n\t\t}\n\n\t\t// no singleton field, try to instantiate it via reflection\n\t\ttry {\n\t\t\treturn modelDescriptorClass.getConstructor( null ).newInstance( null );\n\t\t}\n\t\tcatch (InstantiationException | IllegalAccessException | InvocationTargetException | NoSuchMethodException e) {\n\t\t\tthrow new RuntimeException(\n\t\t\t\t\t\"Problem instantiation DomainModelDescriptor : \" + modelDescriptorClass.getName(),\n\t\t\t\t\te\n\t\t\t);\n\t\t}\n\t}\n\n\tprivate static void prepareSchemaExport(\n\t\t\tSessionFactoryImplementor sessionFactory,\n\t\t\tMetadataImplementor model) {\n\t\tfinal Map<String, Object> baseProperties = sessionFactory.getProperties();\n\n\t\tfinal Set<ActionGrouping> groupings = ActionGrouping.interpret( model, baseProperties );\n\t\tif ( !groupings.isEmpty() ) {\n\t\t\t// the properties contained explicit settings for auto schema tooling - skip the annotation\n\t\t\treturn;\n\t\t}\n\n\t\tfinal HashMap<String,Object> settings = new HashMap<>( baseProperties );\n\t\tsettings.put( AvailableSettings.JAKARTA_HBM2DDL_DATABASE_ACTION, Action.CREATE_DROP );\n\n\t\tfinal StandardServiceRegistry serviceRegistry = model.getMetadataBuildingOptions().getServiceRegistry();\n\n\n\t\tSchemaManagementToolCoordinator.process(\n\t\t\t\tmodel,\n\t\t\t\tserviceRegistry,\n\t\t\t\tsettings,\n\t\t\t\taction -> sessionFactory.addObserver(\n\t\t\t\t\t\tnew SessionFactoryObserver() {\n\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\tpublic void sessionFactoryClosing(org.hibernate.SessionFactory factory) {\n\t\t\t\t\t\t\t\taction.perform( serviceRegistry );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t)\n\t\t);\n\t}\n\n\t@Override\n\tpublic void beforeEach(ExtensionContext context) {\n\t\tlog.tracef( \"#beforeEach(%s)\", context.getDisplayName() );\n\t\tfinal Optional<Jpa> emfAnnWrapper = AnnotationSupport.findAnnotation(\n\t\t\t\tcontext.getRequiredTestMethod(),\n\t\t\t\tJpa.class\n\t\t);\n\n\t\tif ( emfAnnWrapper.isEmpty() ) {\n\t\t\t// assume the annotation is defined on the class-level...\n\t\t\treturn;\n\t\t}\n\n\t\tfindEntityManagerFactoryScope( context.getRequiredTestMethod(), emfAnnWrapper, context );\n\t}\n\n\t@Override\n\tpublic void postProcessTestInstance(Object testInstance, ExtensionContext context) {\n\t\tlog.tracef( \"#postProcessTestInstance(%s, %s)\", testInstance, context.getDisplayName() );\n\n\t\tfinal Optional<Jpa> emfAnnWrapper = AnnotationSupport.findAnnotation(\n\t\t\t\tcontext.getRequiredTestClass(),\n\t\t\t\tJpa.class\n\t\t);\n\n\t\tfindEntityManagerFactoryScope( testInstance, emfAnnWrapper, context );\n\t}\n\n\t@Override\n\tpublic void handleTestExecutionException(ExtensionContext context, Throwable throwable) throws Throwable {\n\t\tlog.tracef( \"#handleTestExecutionException(%s, %s)\", context.getDisplayName(), throwable );\n\n\t\ttry {\n\t\t\tfinal Object testInstance = context.getRequiredTestInstance();\n\t\t\tfinal ExtensionContext.Store store = locateExtensionStore( testInstance, context );\n\t\t\tfinal EntityManagerFactoryScopeImpl scope = (EntityManagerFactoryScopeImpl) store.get( EMF_KEY );\n\t\t\tscope.releaseEntityManagerFactory();\n\t\t}\n\t\tcatch (Exception ignore) {\n\t\t}\n\n\t\tthrow throwable;\n\t}\n\n\tprivate static class EntityManagerFactoryScopeImpl extends AbstractEntityManagerFactoryScope {\n\t\tprivate final PersistenceUnitInfo persistenceUnitInfo;\n\t\tprivate final Map<String, Object> integrationSettings;\n\n\t\tprivate EntityManagerFactoryScopeImpl(\n\t\t\t\tPersistenceUnitInfo persistenceUnitInfo,\n\t\t\t\tMap<String, Object> integrationSettings) {\n\t\t\tthis.persistenceUnitInfo = persistenceUnitInfo;\n\t\t\tthis.integrationSettings = integrationSettings;\n\t\t}\n\n\t\tprotected jakarta.persistence.EntityManagerFactory createEntityManagerFactory() {\n\t\t\tfinal EntityManagerFactoryBuilder emfBuilder = Bootstrap.getEntityManagerFactoryBuilder(\n\t\t\t\t\tnew PersistenceUnitInfoDescriptor( persistenceUnitInfo ),\n\t\t\t\t\tintegrationSettings\n\t\t\t);\n\n\t\t\treturn emfBuilder.build();\n\t\t}\n\t}\n}\n",
        "filePathAfter": "hibernate-testing/src/main/java/org/hibernate/testing/orm/junit/EntityManagerFactoryExtension.java",
        "sourceCodeAfterForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later\n * See the lgpl.txt file in the root directory or http://www.gnu.org/licenses/lgpl-2.1.html\n */\npackage org.hibernate.testing.orm.junit;\n\nimport java.lang.reflect.Field;\nimport java.lang.reflect.InvocationTargetException;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.Properties;\n\nimport jakarta.persistence.spi.PersistenceUnitInfo;\n\nimport org.hibernate.cfg.AvailableSettings;\nimport org.hibernate.cfg.Environment;\nimport org.hibernate.internal.util.ReflectHelper;\nimport org.hibernate.jpa.boot.internal.PersistenceUnitInfoDescriptor;\nimport org.hibernate.query.sqm.mutation.internal.temptable.GlobalTemporaryTableMutationStrategy;\nimport org.hibernate.query.sqm.mutation.internal.temptable.LocalTemporaryTableMutationStrategy;\nimport org.hibernate.query.sqm.mutation.internal.temptable.PersistentTableStrategy;\nimport org.hibernate.tool.schema.Action;\n\nimport org.hibernate.testing.jdbc.SQLStatementInspector;\nimport org.hibernate.testing.orm.domain.DomainModelDescriptor;\nimport org.hibernate.testing.orm.domain.StandardDomainModel;\nimport org.hibernate.testing.orm.jpa.PersistenceUnitInfoImpl;\nimport org.hibernate.testing.util.ServiceRegistryUtil;\nimport org.junit.jupiter.api.extension.BeforeEachCallback;\nimport org.junit.jupiter.api.extension.ExtensionContext;\nimport org.junit.jupiter.api.extension.TestExecutionExceptionHandler;\nimport org.junit.jupiter.api.extension.TestInstancePostProcessor;\n\nimport org.jboss.logging.Logger;\n\nimport static org.hibernate.jpa.boot.spi.Bootstrap.getEntityManagerFactoryBuilder;\nimport static org.junit.platform.commons.support.AnnotationSupport.findAnnotation;\n\n/**\n * hibernate-testing implementation of a few JUnit5 contracts to support SessionFactory-based testing,\n * including argument injection (or see {@link SessionFactoryScopeAware})\n *\n * @author Steve Ebersole\n *\n * @see DomainModelExtension\n * @see SessionFactoryExtension\n */\npublic class EntityManagerFactoryExtension\n\t\timplements TestInstancePostProcessor, BeforeEachCallback, TestExecutionExceptionHandler {\n\n\tprivate static final Logger log = Logger.getLogger( EntityManagerFactoryExtension.class );\n\tprivate static final String EMF_KEY = EntityManagerFactoryScope.class.getName();\n\n\tprivate static ExtensionContext.Store locateExtensionStore(Object testScope, ExtensionContext context) {\n\t\treturn JUnitHelper.locateExtensionStore( EntityManagerFactoryExtension.class, context, testScope );\n\t}\n\n\tpublic static EntityManagerFactoryScope findEntityManagerFactoryScope(\n\t\t\tObject testScope, Optional<Jpa> optionalJpa, ExtensionContext context) {\n\n\t\tif ( optionalJpa.isEmpty() ) {\n\t\t\t// No annotation on the test class, should be on the test methods\n\t\t\treturn null;\n\t\t}\n\n\t\tfinal ExtensionContext.Store store = locateExtensionStore( testScope, context );\n\t\tfinal EntityManagerFactoryScope existing = (EntityManagerFactoryScope) store.get( EMF_KEY );\n\t\tif ( existing != null ) {\n\t\t\treturn existing;\n\t\t}\n\t\tif ( context.getElement().isEmpty() ) {\n\t\t\tthrow new RuntimeException( \"Unable to determine how to handle given ExtensionContext : \"\n\t\t\t\t\t+ context.getDisplayName() );\n\t\t}\n\n\t\tfinal Jpa jpa = optionalJpa.get();\n\t\tfinal PersistenceUnitInfoImpl pui = createPersistenceUnitInfo( jpa );\n\t\tcollectProperties( pui, jpa );\n\t\tmanagedClassesAndMappings( jpa, pui );\n\t\tfinal Map<String, Object> integrationSettings = collectIntegrationSettings( jpa );\n\t\t// statement inspector\n\t\tsetupStatementInspector( jpa, integrationSettings );\n\t\tServiceRegistryUtil.applySettings( integrationSettings );\n\t\tfinal EntityManagerFactoryScopeImpl scope =\n\t\t\t\tnew EntityManagerFactoryScopeImpl( pui, integrationSettings );\n\t\tstore.put( EMF_KEY, scope );\n\t\treturn scope;\n\t}\n\n\tprivate static void collectProperties(PersistenceUnitInfoImpl pui, Jpa jpa) {\n\t\tfinal Properties properties = pui.getProperties();\n\t\tproperties.putAll( Environment.getProperties() );\n\t\t// JpaCompliance\n\t\tsetJpaComplianceProperties( properties, jpa );\n\t\tfor ( Setting property : jpa.properties() ) {\n\t\t\tproperties.setProperty( property.name(), property.value() );\n\t\t}\n\t\tproperties.setProperty(\n\t\t\t\tAvailableSettings.GENERATE_STATISTICS,\n\t\t\t\tBoolean.toString( jpa.generateStatistics() )\n\t\t);\n\t\tif ( jpa.exportSchema() ) {\n\t\t\tproperties.setProperty(\n\t\t\t\t\tAvailableSettings.JAKARTA_HBM2DDL_DATABASE_ACTION,\n\t\t\t\t\tAction.CREATE_DROP.getExternalHbm2ddlName()\n\t\t\t);\n\t\t}\n\t}\n\n\tprivate static PersistenceUnitInfoImpl createPersistenceUnitInfo(Jpa jpa) {\n\t\tfinal PersistenceUnitInfoImpl pui =\n\t\t\t\tnew PersistenceUnitInfoImpl( jpa.persistenceUnitName() );\n\t\tpui.setTransactionType( jpa.transactionType() );\n\t\tpui.setCacheMode( jpa.sharedCacheMode() );\n\t\tpui.setValidationMode( jpa.validationMode() );\n\t\tpui.setExcludeUnlistedClasses( jpa.excludeUnlistedClasses() );\n\t\treturn pui;\n\t}\n\n\tprivate static void managedClassesAndMappings(Jpa jpa, PersistenceUnitInfoImpl pui) {\n\t\tif ( jpa.annotatedPackageNames().length > 0 ) {\n\t\t\tpui.applyManagedClassNames( jpa.annotatedPackageNames() );\n\t\t}\n\n\t\tif ( jpa.annotatedClassNames().length > 0 ) {\n\t\t\tpui.applyManagedClassNames( jpa.annotatedClassNames() );\n\t\t}\n\n\t\tif ( jpa.annotatedClasses().length > 0 ) {\n\t\t\tfor (int i = 0; i < jpa.annotatedClasses().length; i++ ) {\n\t\t\t\tpui.applyManagedClassNames( jpa.annotatedClasses()[i].getName() );\n\t\t\t}\n\t\t}\n\n\t\tif ( jpa.xmlMappings().length > 0 ) {\n\t\t\tpui.applyMappingFiles( jpa.xmlMappings() );\n\t\t}\n\n\t\tfor ( StandardDomainModel standardDomainModel : jpa.standardModels() ) {\n\t\t\tfor ( Class<?> annotatedClass : standardDomainModel.getDescriptor().getAnnotatedClasses() ) {\n\t\t\t\tpui.applyManagedClassNames( annotatedClass.getName() );\n\t\t\t}\n\t\t}\n\n\t\tfor ( Class<? extends DomainModelDescriptor> modelDescriptorClass :\n\t\t\t\tjpa.modelDescriptorClasses() ) {\n\t\t\tfinal DomainModelDescriptor domainModelDescriptor =\n\t\t\t\t\tinstantiateDomainModelDescriptor( modelDescriptorClass );\n\t\t\tfinal Class<?>[] annotatedClasses = domainModelDescriptor.getAnnotatedClasses();\n\t\t\tfor ( Class<?> annotatedClass : annotatedClasses ) {\n\t\t\t\tpui.applyManagedClassNames( annotatedClass.getName() );\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate static Map<String, Object> collectIntegrationSettings(Jpa jpa) {\n\t\tfinal Map<String, Object> integrationSettings = new HashMap<>();\n\t\tintegrationSettings.put( PersistentTableStrategy.DROP_ID_TABLES, \"true\" );\n\t\tintegrationSettings.put( GlobalTemporaryTableMutationStrategy.DROP_ID_TABLES, \"true\" );\n\t\tintegrationSettings.put( LocalTemporaryTableMutationStrategy.DROP_ID_TABLES, \"true\" );\n\t\tfinal Setting[] settings = jpa.integrationSettings();\n\t\tfor ( Setting setting : settings ) {\n\t\t\tintegrationSettings.put( setting.name(), setting.value() );\n\t\t}\n\t\tfor ( SettingProvider providerAnn : jpa.settingProviders() ) {\n\t\t\tfinal Class<? extends SettingProvider.Provider<?>> providerImpl = providerAnn.provider();\n\t\t\ttry {\n\t\t\t\tintegrationSettings.put( providerAnn.settingName(),\n\t\t\t\t\t\tproviderImpl.getConstructor().newInstance().getSetting() );\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tlog.error( \"Error obtaining setting provider for \" + providerImpl.getName(), e );\n\t\t\t}\n\t\t}\n\t\treturn integrationSettings;\n\t}\n\n\tprivate static void setupStatementInspector(Jpa jpa, Map<String, Object> integrationSettings) {\n\t\tif ( jpa.useCollectingStatementInspector() ) {\n\t\t\tfinal String inspectorSetting = (String) integrationSettings.get( AvailableSettings.STATEMENT_INSPECTOR );\n\t\t\tif ( inspectorSetting != null && !inspectorSetting.isBlank() ) {\n\t\t\t\tlog.warn( String.format( \"Overriding the explicit \\\"%1s\\\" statement inspector setting\", inspectorSetting ) );\n\t\t\t}\n\t\t\tintegrationSettings.put( AvailableSettings.STATEMENT_INSPECTOR, new SQLStatementInspector() );\n\t\t}\n\t}\n\n\tprivate static void setJpaComplianceProperties(Properties properties, Jpa jpa) {\n\t\tproperties.put( AvailableSettings.JPA_COMPLIANCE, jpa.jpaComplianceEnabled() );\n\t\tproperties.put( AvailableSettings.JPA_QUERY_COMPLIANCE, jpa.queryComplianceEnabled() );\n\t\tproperties.put( AvailableSettings.JPA_TRANSACTION_COMPLIANCE, jpa.transactionComplianceEnabled() );\n\t\tproperties.put( AvailableSettings.JPA_CLOSED_COMPLIANCE, jpa.closedComplianceEnabled() );\n\t\tproperties.put( AvailableSettings.JPA_PROXY_COMPLIANCE, jpa.proxyComplianceEnabled() );\n\t\tproperties.put( AvailableSettings.JPA_CACHING_COMPLIANCE, jpa.cacheComplianceEnabled() );\n\t\tproperties.put( AvailableSettings.JPA_ID_GENERATOR_GLOBAL_SCOPE_COMPLIANCE, jpa.generatorScopeComplianceEnabled() );\n\t\tproperties.put( AvailableSettings.JPA_ORDER_BY_MAPPING_COMPLIANCE, jpa.orderByMappingComplianceEnabled() );\n\t\tproperties.put( AvailableSettings.JPA_LOAD_BY_ID_COMPLIANCE, jpa.loadByIdComplianceEnabled() );\n\t}\n\n\tprivate static DomainModelDescriptor instantiateDomainModelDescriptor(\n\t\t\tClass<? extends DomainModelDescriptor> modelDescriptorClass) {\n\t\t// first, see if it has a static singleton reference and use that if so\n\t\ttry {\n\t\t\tfor ( Field field : modelDescriptorClass.getDeclaredFields() ) {\n\t\t\t\tif ( ReflectHelper.isStaticField(field) ) {\n\t\t\t\t\tfinal Object value = field.get( null );\n\t\t\t\t\tif ( value instanceof DomainModelDescriptor descriptor ) {\n\t\t\t\t\t\treturn descriptor;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (IllegalAccessException e) {\n\t\t\tthrow new RuntimeException( \"Problem accessing DomainModelDescriptor fields : \"\n\t\t\t\t\t+ modelDescriptorClass.getName(), e );\n\t\t}\n\n\t\t// no singleton field, try to instantiate it via reflection\n\t\ttry {\n\t\t\treturn modelDescriptorClass.getConstructor( null ).newInstance( null );\n\t\t}\n\t\tcatch (InstantiationException | IllegalAccessException | InvocationTargetException | NoSuchMethodException e) {\n\t\t\tthrow new RuntimeException( \"Problem instantiation DomainModelDescriptor : \"\n\t\t\t\t\t+ modelDescriptorClass.getName(), e );\n\t\t}\n\t}\n\n\t@Override\n\tpublic void beforeEach(ExtensionContext context) {\n\t\tlog.tracef( \"#beforeEach(%s)\", context.getDisplayName() );\n\t\tfinal Optional<Jpa> optionalJpa = findAnnotation( context.getRequiredTestMethod(), Jpa.class );\n\t\tif ( optionalJpa.isPresent() ) {\n\t\t\tfindEntityManagerFactoryScope( context.getRequiredTestMethod(), optionalJpa, context );\n\t\t}\n\t\t// else assume the annotation is defined on the class-level...\n\t}\n\n\t@Override\n\tpublic void postProcessTestInstance(Object testInstance, ExtensionContext context) {\n\t\tlog.tracef( \"#postProcessTestInstance(%s, %s)\", testInstance, context.getDisplayName() );\n\t\tfinal Optional<Jpa> optionalJpa = findAnnotation( context.getRequiredTestClass(), Jpa.class );\n\t\tfindEntityManagerFactoryScope( testInstance, optionalJpa, context );\n\t}\n\n\t@Override\n\tpublic void handleTestExecutionException(ExtensionContext context, Throwable throwable) throws Throwable {\n\t\tlog.tracef( \"#handleTestExecutionException(%s, %s)\", context.getDisplayName(), throwable );\n\t\ttry {\n\t\t\tfinal ExtensionContext.Store store = locateExtensionStore( context.getRequiredTestInstance(), context );\n\t\t\tfinal EntityManagerFactoryScopeImpl scope = (EntityManagerFactoryScopeImpl) store.get( EMF_KEY );\n\t\t\tscope.releaseEntityManagerFactory();\n\t\t}\n\t\tcatch (Exception ignore) {\n\t\t}\n\t\tthrow throwable;\n\t}\n\n\tprivate static class EntityManagerFactoryScopeImpl extends AbstractEntityManagerFactoryScope {\n\t\tprivate final PersistenceUnitInfo persistenceUnitInfo;\n\t\tprivate final Map<String, Object> integrationSettings;\n\n\t\tprivate EntityManagerFactoryScopeImpl(\n\t\t\t\tPersistenceUnitInfo persistenceUnitInfo,\n\t\t\t\tMap<String, Object> integrationSettings) {\n\t\t\tthis.persistenceUnitInfo = persistenceUnitInfo;\n\t\t\tthis.integrationSettings = integrationSettings;\n\t\t}\n\n\t\tprotected jakarta.persistence.EntityManagerFactory createEntityManagerFactory() {\n\t\t\tfinal PersistenceUnitInfoDescriptor descriptor = new PersistenceUnitInfoDescriptor( persistenceUnitInfo );\n\t\t\treturn getEntityManagerFactoryBuilder( descriptor, integrationSettings ).build();\n\t\t}\n\t}\n}\n",
        "diffSourceCodeSet": [
            "private static void setupStatementInspector(Jpa jpa, Map<String, Object> integrationSettings) {\n\t\tif ( jpa.useCollectingStatementInspector() ) {\n\t\t\tfinal String inspectorSetting = (String) integrationSettings.get( AvailableSettings.STATEMENT_INSPECTOR );\n\t\t\tif ( inspectorSetting != null && !inspectorSetting.isBlank() ) {\n\t\t\t\tlog.warn( String.format( \"Overriding the explicit \\\"%1s\\\" statement inspector setting\", inspectorSetting ) );\n\t\t\t}\n\t\t\tintegrationSettings.put( AvailableSettings.STATEMENT_INSPECTOR, new SQLStatementInspector() );\n\t\t}\n\t}"
        ],
        "invokedMethodSet": [
            "methodSignature: org.hibernate.jpa.boot.internal.ParsedPersistenceXmlDescriptor#setValidationMode\n methodBody: public void setValidationMode(String validationMode) {\nsetValidationMode(ValidationMode.valueOf(validationMode));\n}",
            "methodSignature: org.hibernate.testing.junit4.BaseNonConfigCoreFunctionalTestCase#getAnnotatedClasses\n methodBody: protected Class[] getAnnotatedClasses() {\nreturn NO_CLASSES;\n}",
            "methodSignature: org.hibernate.jpa.boot.internal.PersistenceUnitInfoDescriptor#getName\n methodBody: public String getName() {\nreturn persistenceUnitInfo.getPersistenceUnitName();\n}",
            "methodSignature: org.hibernate.testing.orm.jpa.PersistenceUnitInfoImpl#setTransactionType\n methodBody: public void setTransactionType(PersistenceUnitTransactionType transactionType) {\nthis.transactionType=transactionType;\n}",
            "methodSignature: org.hibernate.testing.orm.junit.EntityManagerFactoryBasedFunctionalTest#applySettings\n methodBody: protected void applySettings(Map<Object, Object> settings) {\nString[] mappings=getMappings();\nif(mappings != null){settings.put(AvailableSettings.HBM_XML_FILES,String.join(\",\",mappings));\n}}",
            "methodSignature: org.hibernate.testing.orm.jpa.PersistenceUnitInfoImpl#setValidationMode\n methodBody: public void setValidationMode(ValidationMode validationMode) {\nthis.validationMode=validationMode;\n}",
            "methodSignature: org.hibernate.collection.spi.AbstractPersistentCollection.SetProxy#isEmpty\n methodBody: public boolean isEmpty() {\nreturn set.isEmpty();\n}",
            "methodSignature: org.hibernate.testing.orm.jpa.PersistenceUnitInfoImpl#applyMappingFiles\n methodBody: public void applyMappingFiles(String... mappingFiles) {\nif(this.mappingFiles == null){this.mappingFiles=new ArrayList<>();\n}Collections.addAll(this.mappingFiles,mappingFiles);\n}",
            "methodSignature: org.hibernate.testing.util.jpa.DelegatingPersistenceUnitInfo#getProperties\n methodBody: public Properties getProperties() {\nreturn delegate.getProperties();\n}",
            "methodSignature: org.hibernate.orm.test.exceptionhandling.BaseJpaOrNativeBootstrapFunctionalTestCase.TestingPersistenceUnitDescriptorImpl#getName\n methodBody: public String getName() {\nreturn name;\n}",
            "methodSignature: org.hibernate.collection.spi.PersistentList#get\n methodBody: public E get(int index) {\nif(index < 0){throw new ArrayIndexOutOfBoundsException(\"negative index\");\n}final Object result=readElementByIndex(index);\nreturn result == UNKNOWN ? list.get(index) : (E)result;\n}",
            "methodSignature: org.hibernate.orm.test.bootstrap.BootstrapTest.PersistenceUnitInfoImpl#getProperties\n methodBody: public Properties getProperties() {\nreturn properties;\n}",
            "methodSignature: org.hibernate.testing.orm.junit.EntityManagerFactoryBasedFunctionalTest.TestingPersistenceUnitDescriptorImpl#getName\n methodBody: public String getName() {\nreturn name;\n}",
            "methodSignature: org.hibernate.jpa.boot.spi.PersistenceConfigurationDescriptor#getName\n methodBody: public String getName() {\nreturn persistenceConfiguration.name();\n}",
            "methodSignature: org.hibernate.jpa.boot.internal.PersistenceUnitInfoDescriptor#getProperties\n methodBody: public Properties getProperties() {\nreturn persistenceUnitInfo.getProperties();\n}",
            "methodSignature: org.hibernate.jpa.boot.spi.PersistenceUnitDescriptor#getProperties\n methodBody: Properties getProperties();",
            "methodSignature: org.hibernate.testing.orm.junit.BaseSessionFactoryFunctionalTest#getAnnotatedClasses\n methodBody: protected Class[] getAnnotatedClasses() {\nreturn NO_CLASSES;\n}",
            "methodSignature: org.hibernate.testing.orm.junit.BaseSessionFactoryFunctionalTest#applySettings\n methodBody: protected void applySettings(StandardServiceRegistryBuilder builder) {\n}",
            "methodSignature: org.hibernate.testing.orm.jpa.PersistenceUnitInfoAdapter#getProperties\n methodBody: public Properties getProperties() {\nif(properties == null){properties=new Properties();\n}return properties;\n}",
            "methodSignature: org.hibernate.testing.util.jpa.DelegatingPersistenceUnitInfo#excludeUnlistedClasses\n methodBody: public boolean excludeUnlistedClasses() {\nreturn delegate.excludeUnlistedClasses();\n}",
            "methodSignature: org.hibernate.testing.util.jpa.PersistenceUnitInfoAdapter#getProperties\n methodBody: public Properties getProperties() {\nreturn properties;\n}",
            "methodSignature: org.hibernate.testing.orm.jpa.PersistenceUnitInfoImpl#setCacheMode\n methodBody: public void setCacheMode(SharedCacheMode cacheMode) {\nthis.cacheMode=cacheMode;\n}",
            "methodSignature: org.hibernate.jpa.boot.internal.ParsedPersistenceXmlDescriptor#getName\n methodBody: public String getName() {\nreturn name;\n}",
            "methodSignature: org.hibernate.orm.test.jpa.BaseEntityManagerFunctionalTestCase.TestingPersistenceUnitDescriptorImpl#getName\n methodBody: public String getName() {\nreturn name;\n}",
            "methodSignature: org.hibernate.testing.orm.jpa.PersistenceUnitInfoImpl#excludeUnlistedClasses\n methodBody: public boolean excludeUnlistedClasses() {\nreturn excludeUnlistedClasses;\n}",
            "methodSignature: org.hibernate.testing.orm.junit.EntityManagerFactoryBasedFunctionalTest#getAnnotatedClasses\n methodBody: protected Class<?>[] getAnnotatedClasses() {\nreturn NO_CLASSES;\n}",
            "methodSignature: org.hibernate.collection.spi.AbstractPersistentCollection.ListProxy#get\n methodBody: public E get(int i) {\nreturn list.get(i);\n}",
            "methodSignature: org.hibernate.testing.util.jpa.PersistenceUnitInfoAdapter#excludeUnlistedClasses\n methodBody: public boolean excludeUnlistedClasses() {\nreturn false;\n}",
            "methodSignature: org.hibernate.orm.test.exceptionhandling.BaseJpaOrNativeBootstrapFunctionalTestCase#getAnnotatedClasses\n methodBody: protected Class<?>[] getAnnotatedClasses() {\nreturn NO_CLASSES;\n}",
            "methodSignature: org.hibernate.orm.test.bootstrap.BootstrapTest.PersistenceUnitInfoImpl#excludeUnlistedClasses\n methodBody: public boolean excludeUnlistedClasses() {\nreturn false;\n}",
            "methodSignature: org.hibernate.jpa.boot.spi.PersistenceConfigurationDescriptor#getProperties\n methodBody: public Properties getProperties() {\nreturn properties;\n}",
            "methodSignature: org.hibernate.testing.orm.jpa.PersistenceUnitDescriptorAdapter#getProperties\n methodBody: public Properties getProperties() {\nif(properties == null){properties=new Properties();\n}return properties;\n}",
            "methodSignature: org.hibernate.collection.spi.PersistentBag#get\n methodBody: public E get(int i) {\nread();\nreturn bag.get(i);\n}",
            "methodSignature: org.hibernate.testing.orm.jpa.PersistenceUnitInfoAdapter#excludeUnlistedClasses\n methodBody: public boolean excludeUnlistedClasses() {\nreturn false;\n}",
            "methodSignature: org.hibernate.testing.orm.jpa.PersistenceUnitInfoImpl#setExcludeUnlistedClasses\n methodBody: public void setExcludeUnlistedClasses(boolean excludeUnlistedClasses) {\nthis.excludeUnlistedClasses=excludeUnlistedClasses;\n}",
            "methodSignature: org.hibernate.collection.spi.PersistentList#toString\n methodBody: public String toString() {\nread();\nreturn list.toString();\n}",
            "methodSignature: org.hibernate.testing.junit4.BaseCoreFunctionalTestCase#getAnnotatedClasses\n methodBody: protected Class<?>[] getAnnotatedClasses() {\nreturn NO_CLASSES;\n}",
            "methodSignature: org.hibernate.collection.spi.PersistentBag#getElement\n methodBody: public Object getElement(Object entry) {\nreturn entry;\n}",
            "methodSignature: org.hibernate.collection.spi.PersistentBag#isEmpty\n methodBody: public boolean isEmpty() {\nreturn readSize() ? getCachedSize() == 0 : bag.isEmpty();\n}",
            "methodSignature: org.hibernate.orm.test.jpa.xml.versions.JpaXsdVersionsTest.PersistenceUnitInfoImpl#getProperties\n methodBody: public Properties getProperties() {\nreturn properties;\n}",
            "methodSignature: org.hibernate.jpa.boot.internal.ParsedPersistenceXmlDescriptor#setTransactionType\n methodBody: public void setTransactionType(PersistenceUnitTransactionType transactionType) {\nthis.transactionType=transactionType;\n}",
            "methodSignature: org.hibernate.orm.test.jpa.EntityManagerTest#getAnnotatedClasses\n methodBody: public Class[] getAnnotatedClasses() {\nreturn new Class[]{Item.class,Distributor.class,Wallet.class};\n}",
            "methodSignature: org.hibernate.orm.test.jpa.BaseEntityManagerFunctionalTestCase#getAnnotatedClasses\n methodBody: protected Class<?>[] getAnnotatedClasses() {\nreturn NO_CLASSES;\n}",
            "methodSignature: org.hibernate.testing.orm.junit.EntityManagerFactoryBasedFunctionalTest#exportSchema\n methodBody: protected boolean exportSchema() {\nreturn true;\n}",
            "methodSignature: org.hibernate.jpa.boot.internal.ParsedPersistenceXmlDescriptor#getProperties\n methodBody: public Properties getProperties() {\nreturn properties;\n}",
            "methodSignature: org.hibernate.internal.SessionFactoryImpl#getProperties\n methodBody: public Map<String, Object> getProperties() {\nvalidateNotClosed();\nreturn settings;\n}",
            "methodSignature: org.hibernate.testing.util.jpa.PersistenceUnitInfoPropertiesWrapper#excludeUnlistedClasses\n methodBody: public boolean excludeUnlistedClasses() {\nreturn false;\n}",
            "methodSignature: org.hibernate.orm.test.jpa.xml.versions.JpaXsdVersionsTest.PersistenceUnitInfoImpl#excludeUnlistedClasses\n methodBody: public boolean excludeUnlistedClasses() {\nreturn false;\n}",
            "methodSignature: org.hibernate.jpa.boot.spi.PersistenceUnitDescriptor#getName\n methodBody: String getName();",
            "methodSignature: org.hibernate.orm.test.exceptionhandling.BaseJpaOrNativeBootstrapFunctionalTestCase.TestingPersistenceUnitDescriptorImpl#getProperties\n methodBody: public Properties getProperties() {\nreturn null;\n}",
            "methodSignature: org.hibernate.testing.orm.jpa.PersistenceUnitDescriptorAdapter#getName\n methodBody: public String getName() {\nreturn name;\n}",
            "methodSignature: org.hibernate.testing.orm.junit.EntityManagerFactoryExtension#locateExtensionStore\n methodBody: private static ExtensionContext.Store locateExtensionStore(Object testScope, ExtensionContext context) {\nreturn JUnitHelper.locateExtensionStore(EntityManagerFactoryExtension.class,context,testScope);\n}",
            "methodSignature: org.hibernate.jpa.boot.internal.ParsedPersistenceXmlDescriptor#setExcludeUnlistedClasses\n methodBody: public void setExcludeUnlistedClasses(boolean excludeUnlistedClasses) {\nthis.excludeUnlistedClasses=excludeUnlistedClasses;\n}",
            "methodSignature: org.hibernate.testing.orm.jpa.PersistenceUnitInfoImpl#applyManagedClassNames\n methodBody: public void applyManagedClassNames(String... managedClassNames) {\nif(this.managedClassNames == null){this.managedClassNames=new ArrayList<>();\n}Collections.addAll(this.managedClassNames,managedClassNames);\n}",
            "methodSignature: org.hibernate.testing.util.jpa.PersistenceUnitInfoPropertiesWrapper#getProperties\n methodBody: public Properties getProperties() {\nif(properties == null){properties=new Properties();\n}return properties;\n}",
            "methodSignature: org.hibernate.collection.spi.PersistentList#getElement\n methodBody: public Object getElement(Object entry) {\nreturn entry;\n}",
            "methodSignature: org.hibernate.orm.test.jpa.BaseEntityManagerFunctionalTestCase.TestingPersistenceUnitDescriptorImpl#getProperties\n methodBody: public Properties getProperties() {\nreturn null;\n}",
            "methodSignature: org.hibernate.internal.SessionFactoryImpl#getName\n methodBody: public String getName() {\nreturn name;\n}",
            "methodSignature: org.hibernate.testing.orm.junit.EntityManagerFactoryBasedFunctionalTest.TestingPersistenceUnitDescriptorImpl#getProperties\n methodBody: public Properties getProperties() {\nreturn null;\n}",
            "methodSignature: org.hibernate.collection.spi.PersistentList#isEmpty\n methodBody: public boolean isEmpty() {\nreturn readSize() ? getCachedSize() == 0 : list.isEmpty();\n}",
            "methodSignature: org.hibernate.testing.orm.jpa.PersistenceUnitInfoImpl#getProperties\n methodBody: public Properties getProperties() {\nreturn properties;\n}",
            "methodSignature: org.hibernate.testing.orm.junit.EntityManagerFactoryExtension#instantiateDomainModelDescriptor\n methodBody: private static DomainModelDescriptor instantiateDomainModelDescriptor(Class<? extends DomainModelDescriptor> modelDescriptorClass) {\ntryfinal Field[] declaredFields=modelDescriptorClass.getDeclaredFields();\nfor(int i=0; i < declaredFields.length; i++){final Field field=declaredFields[i];\nif(ReflectHelper.isStaticField(field)){final Object value=field.get(null);\nif(value instanceof DomainModelDescriptor){return (DomainModelDescriptor)value;\n}}}catch(IllegalAccessException e)throw new RuntimeException(\"Problem accessing DomainModelDescriptor fields : \" + modelDescriptorClass.getName(),e);\ntryreturn modelDescriptorClass.getConstructor(null).newInstance(null);\ncatch(InstantiationException|IllegalAccessException|InvocationTargetException|NoSuchMethodException e)throw new RuntimeException(\"Problem instantiation DomainModelDescriptor : \" + modelDescriptorClass.getName(),e);\n}",
            "methodSignature: org.hibernate.testing.orm.junit.BaseSessionFactoryFunctionalTest#exportSchema\n methodBody: protected boolean exportSchema() {\nreturn true;\n}",
            "methodSignature: org.hibernate.collection.spi.AbstractPersistentCollection.ListProxy#isEmpty\n methodBody: public boolean isEmpty() {\nreturn list.isEmpty();\n}",
            "methodSignature: org.hibernate.collection.spi.PersistentBag#toString\n methodBody: public String toString() {\nread();\nreturn bag.toString();\n}"
        ],
        "sourceCodeAfterRefactoring": "public static EntityManagerFactoryScope findEntityManagerFactoryScope(\n\t\t\tObject testScope, Optional<Jpa> optionalJpa, ExtensionContext context) {\n\n\t\tif ( optionalJpa.isEmpty() ) {\n\t\t\t// No annotation on the test class, should be on the test methods\n\t\t\treturn null;\n\t\t}\n\n\t\tfinal ExtensionContext.Store store = locateExtensionStore( testScope, context );\n\t\tfinal EntityManagerFactoryScope existing = (EntityManagerFactoryScope) store.get( EMF_KEY );\n\t\tif ( existing != null ) {\n\t\t\treturn existing;\n\t\t}\n\t\tif ( context.getElement().isEmpty() ) {\n\t\t\tthrow new RuntimeException( \"Unable to determine how to handle given ExtensionContext : \"\n\t\t\t\t\t+ context.getDisplayName() );\n\t\t}\n\n\t\tfinal Jpa jpa = optionalJpa.get();\n\t\tfinal PersistenceUnitInfoImpl pui = createPersistenceUnitInfo( jpa );\n\t\tcollectProperties( pui, jpa );\n\t\tmanagedClassesAndMappings( jpa, pui );\n\t\tfinal Map<String, Object> integrationSettings = collectIntegrationSettings( jpa );\n\t\t// statement inspector\n\t\tsetupStatementInspector( jpa, integrationSettings );\n\t\tServiceRegistryUtil.applySettings( integrationSettings );\n\t\tfinal EntityManagerFactoryScopeImpl scope =\n\t\t\t\tnew EntityManagerFactoryScopeImpl( pui, integrationSettings );\n\t\tstore.put( EMF_KEY, scope );\n\t\treturn scope;\n\t}\nprivate static void setupStatementInspector(Jpa jpa, Map<String, Object> integrationSettings) {\n\t\tif ( jpa.useCollectingStatementInspector() ) {\n\t\t\tfinal String inspectorSetting = (String) integrationSettings.get( AvailableSettings.STATEMENT_INSPECTOR );\n\t\t\tif ( inspectorSetting != null && !inspectorSetting.isBlank() ) {\n\t\t\t\tlog.warn( String.format( \"Overriding the explicit \\\"%1s\\\" statement inspector setting\", inspectorSetting ) );\n\t\t\t}\n\t\t\tintegrationSettings.put( AvailableSettings.STATEMENT_INSPECTOR, new SQLStatementInspector() );\n\t\t}\n\t}",
        "diffSourceCode": "-   61: \n-   62: \tprivate static ExtensionContext.Store locateExtensionStore(Object testScope, ExtensionContext context) {\n-   63: \t\treturn JUnitHelper.locateExtensionStore( EntityManagerFactoryExtension.class, context, testScope );\n-   64: \t}\n-   65: \n-   66: \tpublic static EntityManagerFactoryScope findEntityManagerFactoryScope(\n-   67: \t\t\tObject testScope,\n-   68: \t\t\tOptional<Jpa> emfAnnWrapper,\n-   69: \t\t\tExtensionContext context) {\n-   70: \n-   71: \t\tif ( emfAnnWrapper.isEmpty() ) {\n-   72: \t\t\t// No annotation on the test class, should be on the test methods\n-   73: \t\t\treturn null;\n-   74: \t\t}\n-   75: \n-   76: \t\tfinal ExtensionContext.Store store = locateExtensionStore( testScope, context );\n-   77: \t\tfinal EntityManagerFactoryScope existing = (EntityManagerFactoryScope) store.get( EMF_KEY );\n-   78: \t\tif ( existing != null ) {\n-   79: \t\t\treturn existing;\n-   80: \t\t}\n-   81: \n-   82: \t\tif ( !context.getElement().isPresent() ) {\n-   83: \t\t\tthrow new RuntimeException( \"Unable to determine how to handle given ExtensionContext : \" + context.getDisplayName() );\n-   84: \t\t}\n-   85: \t\tfinal Jpa emfAnn = emfAnnWrapper.get();\n-   86: \n-   87: \t\tfinal PersistenceUnitInfoImpl pui = new PersistenceUnitInfoImpl( emfAnn.persistenceUnitName() );\n-   88: \t\t( (Map<Object, Object>) Environment.getProperties() ).forEach(\n-   89: \t\t\t\t(key, value) ->\n-   90: \t\t\t\t\t\tpui.getProperties().put( key, value )\n-   91: \t\t);\n+   61: \tpublic static EntityManagerFactoryScope findEntityManagerFactoryScope(\n+   62: \t\t\tObject testScope, Optional<Jpa> optionalJpa, ExtensionContext context) {\n+   63: \n+   64: \t\tif ( optionalJpa.isEmpty() ) {\n+   65: \t\t\t// No annotation on the test class, should be on the test methods\n+   66: \t\t\treturn null;\n+   67: \t\t}\n+   68: \n+   69: \t\tfinal ExtensionContext.Store store = locateExtensionStore( testScope, context );\n+   70: \t\tfinal EntityManagerFactoryScope existing = (EntityManagerFactoryScope) store.get( EMF_KEY );\n+   71: \t\tif ( existing != null ) {\n+   72: \t\t\treturn existing;\n+   73: \t\t}\n+   74: \t\tif ( context.getElement().isEmpty() ) {\n+   75: \t\t\tthrow new RuntimeException( \"Unable to determine how to handle given ExtensionContext : \"\n+   76: \t\t\t\t\t+ context.getDisplayName() );\n+   77: \t\t}\n+   78: \n+   79: \t\tfinal Jpa jpa = optionalJpa.get();\n+   80: \t\tfinal PersistenceUnitInfoImpl pui = createPersistenceUnitInfo( jpa );\n+   81: \t\tcollectProperties( pui, jpa );\n+   82: \t\tmanagedClassesAndMappings( jpa, pui );\n+   83: \t\tfinal Map<String, Object> integrationSettings = collectIntegrationSettings( jpa );\n+   84: \t\t// statement inspector\n+   85: \t\tsetupStatementInspector( jpa, integrationSettings );\n+   86: \t\tServiceRegistryUtil.applySettings( integrationSettings );\n+   87: \t\tfinal EntityManagerFactoryScopeImpl scope =\n+   88: \t\t\t\tnew EntityManagerFactoryScopeImpl( pui, integrationSettings );\n+   89: \t\tstore.put( EMF_KEY, scope );\n+   90: \t\treturn scope;\n+   91: \t}\n    92: \n-   93: \t\tpui.setTransactionType( emfAnn.transactionType() );\n-   94: \t\tpui.setCacheMode( emfAnn.sharedCacheMode() );\n-   95: \t\tpui.setValidationMode( emfAnn.validationMode() );\n-   96: \t\tpui.setExcludeUnlistedClasses( emfAnn.excludeUnlistedClasses() );\n-   97: \n-   98: \t\t// JpaCompliance\n-   99: \t\tpui.getProperties().put( AvailableSettings.JPA_COMPLIANCE, emfAnn.jpaComplianceEnabled() );\n-  100: \t\tpui.getProperties().put( AvailableSettings.JPA_QUERY_COMPLIANCE, emfAnn.queryComplianceEnabled() );\n-  101: \t\tpui.getProperties().put( AvailableSettings.JPA_TRANSACTION_COMPLIANCE, emfAnn.transactionComplianceEnabled() );\n-  102: \t\tpui.getProperties().put( AvailableSettings.JPA_CLOSED_COMPLIANCE, emfAnn.closedComplianceEnabled() );\n-  103: \t\tpui.getProperties().put( AvailableSettings.JPA_PROXY_COMPLIANCE, emfAnn.proxyComplianceEnabled() );\n-  104: \t\tpui.getProperties().put( AvailableSettings.JPA_CACHING_COMPLIANCE, emfAnn.cacheComplianceEnabled() );\n-  105: \t\tpui.getProperties().put( AvailableSettings.JPA_ID_GENERATOR_GLOBAL_SCOPE_COMPLIANCE, emfAnn.generatorScopeComplianceEnabled() );\n-  106: \t\tpui.getProperties().put( AvailableSettings.JPA_ORDER_BY_MAPPING_COMPLIANCE, emfAnn.orderByMappingComplianceEnabled() );\n-  107: \t\tpui.getProperties().put( AvailableSettings.JPA_LOAD_BY_ID_COMPLIANCE, emfAnn.loadByIdComplianceEnabled() );\n-  108: \n-  109: \t\tfinal Setting[] properties = emfAnn.properties();\n-  110: \t\tfor ( int i = 0; i < properties.length; i++ ) {\n-  111: \t\t\tfinal Setting property = properties[i];\n-  112: \t\t\tpui.getProperties().setProperty( property.name(), property.value() );\n-  113: \t\t}\n-  114: \n-  115: \t\tpui.getProperties().setProperty(\n-  116: \t\t\t\tAvailableSettings.GENERATE_STATISTICS,\n-  117: \t\t\t\tBoolean.toString( emfAnn.generateStatistics() )\n-  118: \t\t);\n-  119: \n-  120: \t\tif ( emfAnn.exportSchema() ) {\n-  121: \t\t\tpui.getProperties().setProperty(\n-  122: \t\t\t\t\tAvailableSettings.JAKARTA_HBM2DDL_DATABASE_ACTION,\n-  123: \t\t\t\t\tAction.CREATE_DROP.getExternalHbm2ddlName()\n-  124: \t\t\t);\n-  125: \t\t}\n-  126: \n-  127: \t\tif ( emfAnn.annotatedPackageNames().length > 0 ) {\n-  128: \t\t\tpui.applyManagedClassNames( emfAnn.annotatedPackageNames() );\n-  129: \t\t}\n-  130: \n-  131: \t\tif ( emfAnn.annotatedClassNames().length > 0 ) {\n-  132: \t\t\tpui.applyManagedClassNames( emfAnn.annotatedClassNames() );\n-  133: \t\t}\n-  134: \n-  135: \t\tif ( emfAnn.annotatedClasses().length > 0 ) {\n-  136: \t\t\tfor ( int i = 0; i < emfAnn.annotatedClasses().length; i++ ) {\n-  137: \t\t\t\tpui.applyManagedClassNames( emfAnn.annotatedClasses()[i].getName() );\n-  138: \t\t\t}\n-  139: \t\t}\n-  140: \n-  141: \t\tif ( emfAnn.xmlMappings().length > 0 ) {\n-  142: \t\t\tpui.applyMappingFiles( emfAnn.xmlMappings() );\n-  143: \t\t}\n-  144: \n-  145: \t\tif ( emfAnn.standardModels().length > 0 ) {\n-  146: \t\t\tfor ( int i = 0; i < emfAnn.standardModels().length; i++ ) {\n-  147: \t\t\t\tfinal StandardDomainModel standardDomainModel = emfAnn.standardModels()[i];\n-  148: \t\t\t\tfor ( int i1 = 0; i1 < standardDomainModel.getDescriptor().getAnnotatedClasses().length; i1++ ) {\n-  149: \t\t\t\t\tfinal Class<?> annotatedClass = standardDomainModel.getDescriptor().getAnnotatedClasses()[i1];\n-  150: \t\t\t\t\tpui.applyManagedClassNames( annotatedClass.getName() );\n-  151: \t\t\t\t}\n-  152: \t\t\t}\n-  153: \t\t}\n-  154: \n-  155: \t\tif ( emfAnn.modelDescriptorClasses().length > 0 ) {\n-  156: \t\t\tfor ( int i = 0; i < emfAnn.modelDescriptorClasses().length; i++ ) {\n-  157: \t\t\t\tfinal Class<? extends DomainModelDescriptor> modelDescriptorClass = emfAnn.modelDescriptorClasses()[i];\n-  158: \t\t\t\tfinal DomainModelDescriptor domainModelDescriptor = instantiateDomainModelDescriptor(\n-  159: \t\t\t\t\t\tmodelDescriptorClass );\n-  160: \t\t\t\tfor ( int i1 = 0; i1 < domainModelDescriptor.getAnnotatedClasses().length; i1++ ) {\n-  161: \t\t\t\t\tfinal Class<?> annotatedClass = domainModelDescriptor.getAnnotatedClasses()[i1];\n-  162: \t\t\t\t\tpui.applyManagedClassNames( annotatedClass.getName() );\n-  163: \t\t\t\t}\n-  164: \t\t\t}\n-  165: \t\t}\n-  166: \n-  167: \t\tfinal Map<String, Object> integrationSettings = new HashMap<>();\n-  168: \n-  169: \t\tintegrationSettings.put( PersistentTableStrategy.DROP_ID_TABLES, \"true\" );\n-  170: \t\tintegrationSettings.put( GlobalTemporaryTableMutationStrategy.DROP_ID_TABLES, \"true\" );\n-  171: \t\tintegrationSettings.put( LocalTemporaryTableMutationStrategy.DROP_ID_TABLES, \"true\" );\n-  172: \t\tfor ( int i = 0; i < emfAnn.integrationSettings().length; i++ ) {\n-  173: \t\t\tfinal Setting setting = emfAnn.integrationSettings()[i];\n-  174: \t\t\tintegrationSettings.put( setting.name(), setting.value() );\n-  175: \t\t}\n-  176: \n-  177: \t\tfor ( SettingProvider providerAnn : emfAnn.settingProviders() ) {\n-  178: \t\t\tfinal Class<? extends SettingProvider.Provider<?>> providerImpl = providerAnn.provider();\n-  179: \t\t\ttry {\n-  180: \t\t\t\tfinal SettingProvider.Provider<?> provider = providerImpl.getConstructor().newInstance();\n-  181: \t\t\t\tintegrationSettings.put( providerAnn.settingName(), provider.getSetting() );\n-  182: \t\t\t}\n-  183: \t\t\tcatch (Exception e) {\n-  184: \t\t\t\tlog.error( \"Error obtaining setting provider for \" + providerImpl.getName(), e );\n-  185: \t\t\t}\n-  186: \t\t}\n-  187: \n-  188: \t\t// statement inspector\n-  189: \t\tif ( emfAnn.useCollectingStatementInspector() ) {\n-  190: \t\t\tString inspectorSetting = (String) integrationSettings.get( AvailableSettings.STATEMENT_INSPECTOR );\n-  191: \t\t\tif ( !(inspectorSetting == null || inspectorSetting.isBlank()) ) {\n-  192: \t\t\t\tlog.warn( String.format( \"Overriding the explicit \\\"%1s\\\" statement inspector setting\", inspectorSetting ) );\n-  193: \t\t\t}\n-  194: \t\t\tintegrationSettings.put( AvailableSettings.STATEMENT_INSPECTOR, new SQLStatementInspector() );\n-  195: \t\t}\n-  196: \n-  197: \t\tServiceRegistryUtil.applySettings( integrationSettings );\n-  198: \t\tfinal EntityManagerFactoryScopeImpl scope = new EntityManagerFactoryScopeImpl( pui, integrationSettings );\n-  199: \n-  200: \t\tstore.put( EMF_KEY, scope );\n-  201: \n-  202: \t\treturn scope;\n-  203: \t}\n+   93: \tprivate static void collectProperties(PersistenceUnitInfoImpl pui, Jpa jpa) {\n+   94: \t\tfinal Properties properties = pui.getProperties();\n+   95: \t\tproperties.putAll( Environment.getProperties() );\n+   96: \t\t// JpaCompliance\n+   97: \t\tsetJpaComplianceProperties( properties, jpa );\n+   98: \t\tfor ( Setting property : jpa.properties() ) {\n+   99: \t\t\tproperties.setProperty( property.name(), property.value() );\n+  100: \t\t}\n+  101: \t\tproperties.setProperty(\n+  102: \t\t\t\tAvailableSettings.GENERATE_STATISTICS,\n+  103: \t\t\t\tBoolean.toString( jpa.generateStatistics() )\n+  104: \t\t);\n+  105: \t\tif ( jpa.exportSchema() ) {\n+  106: \t\t\tproperties.setProperty(\n+  107: \t\t\t\t\tAvailableSettings.JAKARTA_HBM2DDL_DATABASE_ACTION,\n+  108: \t\t\t\t\tAction.CREATE_DROP.getExternalHbm2ddlName()\n+  109: \t\t\t);\n+  110: \t\t}\n+  111: \t}\n+  112: \n+  113: \tprivate static PersistenceUnitInfoImpl createPersistenceUnitInfo(Jpa jpa) {\n+  114: \t\tfinal PersistenceUnitInfoImpl pui =\n+  115: \t\t\t\tnew PersistenceUnitInfoImpl( jpa.persistenceUnitName() );\n+  116: \t\tpui.setTransactionType( jpa.transactionType() );\n+  117: \t\tpui.setCacheMode( jpa.sharedCacheMode() );\n+  118: \t\tpui.setValidationMode( jpa.validationMode() );\n+  119: \t\tpui.setExcludeUnlistedClasses( jpa.excludeUnlistedClasses() );\n+  120: \t\treturn pui;\n+  121: \t}\n+  122: \n+  123: \tprivate static void managedClassesAndMappings(Jpa jpa, PersistenceUnitInfoImpl pui) {\n+  124: \t\tif ( jpa.annotatedPackageNames().length > 0 ) {\n+  125: \t\t\tpui.applyManagedClassNames( jpa.annotatedPackageNames() );\n+  126: \t\t}\n+  127: \n+  128: \t\tif ( jpa.annotatedClassNames().length > 0 ) {\n+  129: \t\t\tpui.applyManagedClassNames( jpa.annotatedClassNames() );\n+  130: \t\t}\n+  131: \n+  132: \t\tif ( jpa.annotatedClasses().length > 0 ) {\n+  133: \t\t\tfor (int i = 0; i < jpa.annotatedClasses().length; i++ ) {\n+  134: \t\t\t\tpui.applyManagedClassNames( jpa.annotatedClasses()[i].getName() );\n+  135: \t\t\t}\n+  136: \t\t}\n+  137: \n+  138: \t\tif ( jpa.xmlMappings().length > 0 ) {\n+  139: \t\t\tpui.applyMappingFiles( jpa.xmlMappings() );\n+  140: \t\t}\n+  141: \n+  142: \t\tfor ( StandardDomainModel standardDomainModel : jpa.standardModels() ) {\n+  143: \t\t\tfor ( Class<?> annotatedClass : standardDomainModel.getDescriptor().getAnnotatedClasses() ) {\n+  144: \t\t\t\tpui.applyManagedClassNames( annotatedClass.getName() );\n+  145: \t\t\t}\n+  146: \t\t}\n+  147: \n+  148: \t\tfor ( Class<? extends DomainModelDescriptor> modelDescriptorClass :\n+  149: \t\t\t\tjpa.modelDescriptorClasses() ) {\n+  150: \t\t\tfinal DomainModelDescriptor domainModelDescriptor =\n+  151: \t\t\t\t\tinstantiateDomainModelDescriptor( modelDescriptorClass );\n+  152: \t\t\tfinal Class<?>[] annotatedClasses = domainModelDescriptor.getAnnotatedClasses();\n+  153: \t\t\tfor ( Class<?> annotatedClass : annotatedClasses ) {\n+  154: \t\t\t\tpui.applyManagedClassNames( annotatedClass.getName() );\n+  155: \t\t\t}\n+  156: \t\t}\n+  157: \t}\n+  158: \n+  159: \tprivate static Map<String, Object> collectIntegrationSettings(Jpa jpa) {\n+  160: \t\tfinal Map<String, Object> integrationSettings = new HashMap<>();\n+  161: \t\tintegrationSettings.put( PersistentTableStrategy.DROP_ID_TABLES, \"true\" );\n+  162: \t\tintegrationSettings.put( GlobalTemporaryTableMutationStrategy.DROP_ID_TABLES, \"true\" );\n+  163: \t\tintegrationSettings.put( LocalTemporaryTableMutationStrategy.DROP_ID_TABLES, \"true\" );\n+  164: \t\tfinal Setting[] settings = jpa.integrationSettings();\n+  165: \t\tfor ( Setting setting : settings ) {\n+  166: \t\t\tintegrationSettings.put( setting.name(), setting.value() );\n+  167: \t\t}\n+  168: \t\tfor ( SettingProvider providerAnn : jpa.settingProviders() ) {\n+  169: \t\t\tfinal Class<? extends SettingProvider.Provider<?>> providerImpl = providerAnn.provider();\n+  170: \t\t\ttry {\n+  171: \t\t\t\tintegrationSettings.put( providerAnn.settingName(),\n+  172: \t\t\t\t\t\tproviderImpl.getConstructor().newInstance().getSetting() );\n+  173: \t\t\t}\n+  174: \t\t\tcatch (Exception e) {\n+  175: \t\t\t\tlog.error( \"Error obtaining setting provider for \" + providerImpl.getName(), e );\n+  176: \t\t\t}\n+  177: \t\t}\n+  178: \t\treturn integrationSettings;\n+  179: \t}\n+  180: \n+  181: \tprivate static void setupStatementInspector(Jpa jpa, Map<String, Object> integrationSettings) {\n+  182: \t\tif ( jpa.useCollectingStatementInspector() ) {\n+  183: \t\t\tfinal String inspectorSetting = (String) integrationSettings.get( AvailableSettings.STATEMENT_INSPECTOR );\n+  184: \t\t\tif ( inspectorSetting != null && !inspectorSetting.isBlank() ) {\n+  185: \t\t\t\tlog.warn( String.format( \"Overriding the explicit \\\"%1s\\\" statement inspector setting\", inspectorSetting ) );\n+  186: \t\t\t}\n+  187: \t\t\tintegrationSettings.put( AvailableSettings.STATEMENT_INSPECTOR, new SQLStatementInspector() );\n+  188: \t\t}\n+  189: \t}\n+  190: \n+  191: \tprivate static void setJpaComplianceProperties(Properties properties, Jpa jpa) {\n+  192: \t\tproperties.put( AvailableSettings.JPA_COMPLIANCE, jpa.jpaComplianceEnabled() );\n+  193: \t\tproperties.put( AvailableSettings.JPA_QUERY_COMPLIANCE, jpa.queryComplianceEnabled() );\n+  194: \t\tproperties.put( AvailableSettings.JPA_TRANSACTION_COMPLIANCE, jpa.transactionComplianceEnabled() );\n+  195: \t\tproperties.put( AvailableSettings.JPA_CLOSED_COMPLIANCE, jpa.closedComplianceEnabled() );\n+  196: \t\tproperties.put( AvailableSettings.JPA_PROXY_COMPLIANCE, jpa.proxyComplianceEnabled() );\n+  197: \t\tproperties.put( AvailableSettings.JPA_CACHING_COMPLIANCE, jpa.cacheComplianceEnabled() );\n+  198: \t\tproperties.put( AvailableSettings.JPA_ID_GENERATOR_GLOBAL_SCOPE_COMPLIANCE, jpa.generatorScopeComplianceEnabled() );\n+  199: \t\tproperties.put( AvailableSettings.JPA_ORDER_BY_MAPPING_COMPLIANCE, jpa.orderByMappingComplianceEnabled() );\n+  200: \t\tproperties.put( AvailableSettings.JPA_LOAD_BY_ID_COMPLIANCE, jpa.loadByIdComplianceEnabled() );\n+  201: \t}\n+  202: \n+  203: \tprivate static DomainModelDescriptor instantiateDomainModelDescriptor(\n",
        "uniqueId": "4781c09d0df0eb4ce05b2fa0d2a12747023ae024_66_203_181_189_61_91",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 186,
                "covered": 250
            },
            "BRANCH": {
                "missed": 24,
                "covered": 18
            },
            "LINE": {
                "missed": 29,
                "covered": 49
            },
            "COMPLEXITY": {
                "missed": 18,
                "covered": 4
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 21
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprivate isLegalFirstChar(first char) : boolean extracted from public toIdentifier(text String, quote boolean, quoteOnNonIdentifierChar boolean) : Identifier in class org.hibernate.boot.model.naming.Identifier",
        "diffLocations": [
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/boot/model/naming/Identifier.java",
                "startLine": 67,
                "endLine": 123,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/boot/model/naming/Identifier.java",
                "startLine": 112,
                "endLine": 126,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/boot/model/naming/Identifier.java",
                "startLine": 136,
                "endLine": 140,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "/**\n\t * Means to generate an {@link Identifier} instance from its simple text form.\n\t * <p>\n\t * If passed text is {@code null}, {@code null} is returned.\n\t * <p>\n\t * If passed text is surrounded in quote markers, the generated Identifier\n\t * is considered quoted.  Quote markers include back-ticks (`),\n\t * double-quotes (\") and brackets ([ and ]).\n\t *\n\t * @param text The text form\n\t * @param quote Whether to quote unquoted text forms\n\t * @param quoteOnNonIdentifierChar Controls whether to treat the result as quoted if text contains characters that are invalid for identifiers\n\t *\n\t * @return The identifier form, or {@code null} if text was {@code null}\n\t */\n\tpublic static Identifier toIdentifier(String text, boolean quote, boolean quoteOnNonIdentifierChar) {\n\t\tif ( isBlank( text ) ) {\n\t\t\treturn null;\n\t\t}\n\t\tint start = 0;\n\t\tint end = text.length();\n\t\twhile ( start < end ) {\n\t\t\tif ( !isWhitespace( text.charAt( start ) ) ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tstart++;\n\t\t}\n\t\twhile ( start < end ) {\n\t\t\tif ( !isWhitespace( text.charAt( end - 1 ) ) ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tend--;\n\t\t}\n\t\tif ( isQuoted( text, start, end ) ) {\n\t\t\tstart++;\n\t\t\tend--;\n\t\t\tquote = true;\n\t\t}\n\t\telse if ( quoteOnNonIdentifierChar && !quote ) {\n\t\t\t// Check the letters to determine if we must quote the text\n\t\t\tchar c = text.charAt( start );\n\t\t\tif ( !isLetter( c ) && c != '_' ) {\n\t\t\t\t// SQL identifiers must begin with a letter or underscore\n\t\t\t\tquote = true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor ( int i = start + 1; i < end; i++ ) {\n\t\t\t\t\tc = text.charAt( i );\n\t\t\t\t\tif ( !isLetterOrDigit( c ) && c != '_' ) {\n\t\t\t\t\t\tquote = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn new Identifier( text.substring( start, end ), quote );\n\t}",
        "filePathBefore": "hibernate-core/src/main/java/org/hibernate/boot/model/naming/Identifier.java",
        "isPureRefactoring": true,
        "commitId": "e14ead0c0f0916cc8fdb8895e2cc481754a75583",
        "packageNameBefore": "org.hibernate.boot.model.naming",
        "classNameBefore": "org.hibernate.boot.model.naming.Identifier",
        "methodNameBefore": "org.hibernate.boot.model.naming.Identifier#toIdentifier",
        "invokedMethod": "methodSignature: org.hibernate.boot.model.naming.Identifier#isQuoted\n methodBody: public boolean isQuoted() {\nreturn isQuoted;\n}",
        "classSignatureBefore": "public class Identifier implements Comparable<Identifier> ",
        "methodNameBeforeSet": [
            "org.hibernate.boot.model.naming.Identifier#toIdentifier"
        ],
        "classNameBeforeSet": [
            "org.hibernate.boot.model.naming.Identifier"
        ],
        "classSignatureBeforeSet": [
            "public class Identifier implements Comparable<Identifier> "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Overlapped refactoring - can be identical by undoing the overlapped refactoring\n- Inline Variable-",
                "description": "Inline Variable on top of the extracted method - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * SPDX-License-Identifier: LGPL-2.1-or-later\n * Copyright Red Hat Inc. and Hibernate Authors\n */\npackage org.hibernate.boot.model.naming;\n\nimport java.util.Locale;\n\nimport org.hibernate.dialect.Dialect;\n\nimport static java.lang.Character.isLetter;\nimport static java.lang.Character.isLetterOrDigit;\nimport static java.lang.Character.isWhitespace;\nimport static org.hibernate.internal.util.StringHelper.isBlank;\nimport static org.hibernate.internal.util.StringHelper.isEmpty;\n\n/**\n * Models an identifier (name), which may or may not be quoted.\n *\n * @author Steve Ebersole\n */\npublic class Identifier implements Comparable<Identifier> {\n\tprivate final String text;\n\tprivate final boolean isQuoted;\n\n\t/**\n\t * Means to generate an {@link Identifier} instance from its simple text form.\n\t * <p>\n\t * If passed text is {@code null}, {@code null} is returned.\n\t * <p>\n\t * If passed text is surrounded in quote markers, the generated Identifier\n\t * is considered quoted.  Quote markers include back-ticks (`),\n\t * double-quotes (\") and brackets ([ and ]).\n\t *\n\t * If the text, after trimming, contains a character that is not a valid identifier character,\n\t * the identifier is treated as quoted.\n\t *\n\t * @param text The text form\n\t *\n\t * @return The identifier form, or {@code null} if text was {@code null}\n\t */\n\tpublic static Identifier toIdentifier(String text) {\n\t\treturn toIdentifier( text, false );\n\t}\n\n\t/**\n\t * Means to generate an {@link Identifier} instance from its simple text form.\n\t * <p>\n\t * If passed text is {@code null}, {@code null} is returned.\n\t * <p>\n\t * If passed text is surrounded in quote markers, the generated Identifier\n\t * is considered quoted.  Quote markers include back-ticks (`),\n\t * double-quotes (\") and brackets ([ and ]).\n\t *\n\t * If the text, after trimming, contains a character that is not a valid identifier character,\n\t * the identifier is treated as quoted.\n\t *\n\t * @param text The text form\n\t * @param quote Whether to quote unquoted text forms\n\t *\n\t * @return The identifier form, or {@code null} if text was {@code null}\n\t */\n\tpublic static Identifier toIdentifier(String text, boolean quote) {\n\t\treturn toIdentifier( text, quote, true );\n\t}\n\n\t/**\n\t * Means to generate an {@link Identifier} instance from its simple text form.\n\t * <p>\n\t * If passed text is {@code null}, {@code null} is returned.\n\t * <p>\n\t * If passed text is surrounded in quote markers, the generated Identifier\n\t * is considered quoted.  Quote markers include back-ticks (`),\n\t * double-quotes (\") and brackets ([ and ]).\n\t *\n\t * @param text The text form\n\t * @param quote Whether to quote unquoted text forms\n\t * @param quoteOnNonIdentifierChar Controls whether to treat the result as quoted if text contains characters that are invalid for identifiers\n\t *\n\t * @return The identifier form, or {@code null} if text was {@code null}\n\t */\n\tpublic static Identifier toIdentifier(String text, boolean quote, boolean quoteOnNonIdentifierChar) {\n\t\tif ( isBlank( text ) ) {\n\t\t\treturn null;\n\t\t}\n\t\tint start = 0;\n\t\tint end = text.length();\n\t\twhile ( start < end ) {\n\t\t\tif ( !isWhitespace( text.charAt( start ) ) ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tstart++;\n\t\t}\n\t\twhile ( start < end ) {\n\t\t\tif ( !isWhitespace( text.charAt( end - 1 ) ) ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tend--;\n\t\t}\n\t\tif ( isQuoted( text, start, end ) ) {\n\t\t\tstart++;\n\t\t\tend--;\n\t\t\tquote = true;\n\t\t}\n\t\telse if ( quoteOnNonIdentifierChar && !quote ) {\n\t\t\t// Check the letters to determine if we must quote the text\n\t\t\tchar c = text.charAt( start );\n\t\t\tif ( !isLetter( c ) && c != '_' ) {\n\t\t\t\t// SQL identifiers must begin with a letter or underscore\n\t\t\t\tquote = true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor ( int i = start + 1; i < end; i++ ) {\n\t\t\t\t\tc = text.charAt( i );\n\t\t\t\t\tif ( !isLetterOrDigit( c ) && c != '_' ) {\n\t\t\t\t\t\tquote = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn new Identifier( text.substring( start, end ), quote );\n\t}\n\n\t/**\n\t * Is the given identifier text considered quoted.  The following patterns are\n\t * recognized as quoted:<ul>\n\t *     <li>{@code `name`}</li>\n\t *     <li>{@code [name]}</li>\n\t *     <li>{@code \"name\"}</li>\n\t * </ul>\n\t * <p>\n\t * That final form using double-quote (\") is the JPA-defined quoting pattern.  Although\n\t * it is the standard, it makes for ugly declarations.\n\t *\n\t * @return {@code true} if the given identifier text is considered quoted; {@code false} otherwise.\n\t */\n\tpublic static boolean isQuoted(String name) {\n\t\treturn isQuoted( name, 0, name.length() );\n\t}\n\n\tpublic static boolean isQuoted(String name, int start, int end) {\n\t\tif ( start + 2 < end ) {\n\t\t\tswitch ( name.charAt( start ) ) {\n\t\t\t\tcase '`':\n\t\t\t\t\treturn name.charAt( end - 1 ) == '`';\n\t\t\t\tcase '[':\n\t\t\t\t\treturn name.charAt( end - 1 ) == ']';\n\t\t\t\tcase '\"':\n\t\t\t\t\treturn name.charAt( end - 1 ) == '\"';\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic static String unQuote(String name) {\n\t\tassert isQuoted( name );\n\n\t\treturn name.substring( 1, name.length() - 1 );\n\t}\n\n\t/**\n\t * Constructs an identifier instance.\n\t *\n\t * @param text The identifier text.\n\t * @param quoted Is this a quoted identifier?\n\t */\n\tpublic Identifier(String text, boolean quoted) {\n\t\tif ( isEmpty( text ) ) {\n\t\t\tthrow new IllegalIdentifierException( \"Identifier text cannot be null\" );\n\t\t}\n\t\tif ( isQuoted( text ) ) {\n\t\t\tthrow new IllegalIdentifierException( \"Identifier text should not contain quote markers (` or \\\")\" );\n\t\t}\n\t\tthis.text = text;\n\t\tthis.isQuoted = quoted;\n\t}\n\n\t/**\n\t * Constructs an unquoted identifier instance.\n\t *\n\t * @param text The identifier text.\n\t */\n\tprotected Identifier(String text) {\n\t\tthis.text = text;\n\t\tthis.isQuoted = false;\n\t}\n\n\t/**\n\t * Get the identifiers name (text)\n\t *\n\t * @return The name\n\t */\n\tpublic String getText() {\n\t\treturn text;\n\t}\n\n\t/**\n\t * Is this a quoted identifier?\n\t *\n\t * @return True if this is a quote identifier; false otherwise.\n\t */\n\tpublic boolean isQuoted() {\n\t\treturn isQuoted;\n\t}\n\n\t/**\n\t * If this is a quoted identifier, then return the identifier name\n\t * enclosed in dialect-specific open- and end-quotes; otherwise,\n\t * simply return the unquoted identifier.\n\t *\n\t * @param dialect The dialect whose dialect-specific quoting should be used.\n\t *\n\t * @return if quoted, identifier name enclosed in dialect-specific open- and\n\t * end-quotes; otherwise, the unquoted identifier.\n\t */\n\tpublic String render(Dialect dialect) {\n\t\treturn isQuoted\n\t\t\t\t? dialect.toQuotedIdentifier( getText() )\n\t\t\t\t: getText();\n\t}\n\n\tpublic String render() {\n\t\treturn isQuoted\n\t\t\t\t? '`' + getText() + '`'\n\t\t\t\t: getText();\n\t}\n\n\tpublic String getCanonicalName() {\n\t\treturn isQuoted ? text : text.toLowerCase( Locale.ENGLISH );\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn render();\n\t}\n\n\t@Override\n\tpublic boolean equals(Object o) {\n\t\tif ( !(o instanceof Identifier that) ) {\n\t\t\treturn false;\n\t\t}\n\t\treturn getCanonicalName().equals( that.getCanonicalName() );\n\t}\n\n\tpublic boolean matches(String name) {\n\t\treturn isQuoted()\n\t\t\t\t? text.equals( name )\n\t\t\t\t: text.equalsIgnoreCase( name );\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\treturn isQuoted ? text.hashCode() : text.toLowerCase( Locale.ENGLISH ).hashCode();\n\t}\n\n\tpublic static boolean areEqual(Identifier id1, Identifier id2) {\n\t\tif ( id1 == null ) {\n\t\t\treturn id2 == null;\n\t\t}\n\t\telse {\n\t\t\treturn id1.equals( id2 );\n\t\t}\n\t}\n\n\tpublic static Identifier quote(Identifier identifier) {\n\t\treturn identifier.isQuoted()\n\t\t\t\t? identifier\n\t\t\t\t: Identifier.toIdentifier( identifier.getText(), true );\n\t}\n\n\t@Override\n\tpublic int compareTo(Identifier o) {\n\t\treturn getCanonicalName().compareTo( o.getCanonicalName() );\n\t}\n}\n",
        "filePathAfter": "hibernate-core/src/main/java/org/hibernate/boot/model/naming/Identifier.java",
        "sourceCodeAfterForWhole": "/*\n * SPDX-License-Identifier: LGPL-2.1-or-later\n * Copyright Red Hat Inc. and Hibernate Authors\n */\npackage org.hibernate.boot.model.naming;\n\nimport java.util.Locale;\nimport java.util.Objects;\n\nimport org.hibernate.dialect.Dialect;\n\nimport static java.lang.Character.isLetter;\nimport static java.lang.Character.isLetterOrDigit;\nimport static java.lang.Character.isWhitespace;\nimport static org.hibernate.internal.util.StringHelper.isBlank;\nimport static org.hibernate.internal.util.StringHelper.isEmpty;\n\n/**\n * Models an identifier (name), which may or may not be quoted.\n *\n * @author Steve Ebersole\n */\npublic class Identifier implements Comparable<Identifier> {\n\tprivate final String text;\n\tprivate final boolean isQuoted;\n\n\t/**\n\t * Means to generate an {@link Identifier} instance from its simple text form.\n\t * <p>\n\t * If passed text is {@code null}, {@code null} is returned.\n\t * <p>\n\t * If passed text is surrounded in quote markers, the generated Identifier\n\t * is considered quoted.  Quote markers include back-ticks (`),\n\t * double-quotes (\") and brackets ([ and ]).\n\t *\n\t * If the text, after trimming, contains a character that is not a valid identifier character,\n\t * the identifier is treated as quoted.\n\t *\n\t * @param text The text form\n\t *\n\t * @return The identifier form, or {@code null} if text was {@code null}\n\t */\n\tpublic static Identifier toIdentifier(String text) {\n\t\treturn toIdentifier( text, false );\n\t}\n\n\t/**\n\t * Means to generate an {@link Identifier} instance from its simple text form.\n\t * <p>\n\t * If passed text is {@code null}, {@code null} is returned.\n\t * <p>\n\t * If passed text is surrounded in quote markers, the generated Identifier\n\t * is considered quoted.  Quote markers include back-ticks (`),\n\t * double-quotes (\") and brackets ([ and ]).\n\t *\n\t * If the text, after trimming, contains a character that is not a valid identifier character,\n\t * the identifier is treated as quoted.\n\t *\n\t * @param text The text form\n\t * @param quote Whether to quote unquoted text forms\n\t *\n\t * @return The identifier form, or {@code null} if text was {@code null}\n\t */\n\tpublic static Identifier toIdentifier(String text, boolean quote) {\n\t\treturn toIdentifier( text, quote, true );\n\t}\n\n\t/**\n\t * Means to generate an {@link Identifier} instance from its simple text form.\n\t * <p>\n\t * If passed {@code text} is {@code null}, {@code null} is returned.\n\t * <p>\n\t * If passed {@code text} is surrounded in quote markers, the returned Identifier\n\t * is considered quoted. Quote markers include back-ticks (`), double-quotes (\"),\n\t * and brackets ([ and ]).\n\t *\n\t * @param text The text form\n\t * @param quote Whether to quote unquoted text forms\n\t * @param autoquote Whether to quote the result if it contains special characters\n\t *\n\t * @return The identifier form, or {@code null} if text was {@code null}\n\t */\n\tpublic static Identifier toIdentifier(String text, boolean quote, boolean autoquote) {\n\t\tif ( isBlank( text ) ) {\n\t\t\treturn null;\n\t\t}\n\t\tint start = 0;\n\t\tint end = text.length();\n\t\twhile ( start < end ) {\n\t\t\tif ( !isWhitespace( text.charAt( start ) ) ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tstart++;\n\t\t}\n\t\twhile ( start < end ) {\n\t\t\tif ( !isWhitespace( text.charAt( end - 1 ) ) ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tend--;\n\t\t}\n\t\tif ( isQuoted( text, start, end ) ) {\n\t\t\tstart++;\n\t\t\tend--;\n\t\t\tquote = true;\n\t\t}\n\t\telse if ( autoquote && !quote ) {\n\t\t\tquote = autoquote( text, start, end );\n\t\t}\n\t\treturn new Identifier( text.substring( start, end ), quote );\n\t}\n\n\tprivate static boolean autoquote(String text, int start, int end) {\n\t\t// Check the letters to determine if we must quote the text\n\t\tif ( !isLegalFirstChar( text.charAt( start ) ) ) {\n\t\t\t// SQL identifiers must begin with a letter or underscore\n\t\t\treturn true;\n\t\t}\n\t\telse {\n\t\t\tfor ( int i = start + 1; i < end; i++ ) {\n\t\t\t\tif ( !isLegalChar( text.charAt( i ) ) ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tprivate static boolean isLegalChar(char current) {\n\t\treturn isLetterOrDigit( current )\n\t\t\t// every database also allows _ here\n\t\t\t|| current == '_'\n\t\t\t// every database except HSQLDB also allows $ here\n\t\t\t|| current == '$';\n\t}\n\n\tprivate static boolean isLegalFirstChar(char first) {\n\t\treturn isLetter( first )\n\t\t\t// many databases also allow _ here\n\t\t\t|| first == '_';\n\t}\n\n\t/**\n\t * Is the given identifier text considered quoted.  The following patterns are\n\t * recognized as quoted:<ul>\n\t *     <li>{@code `name`}</li>\n\t *     <li>{@code [name]}</li>\n\t *     <li>{@code \"name\"}</li>\n\t * </ul>\n\t * <p>\n\t * That final form using double-quote (\") is the JPA-defined quoting pattern.  Although\n\t * it is the standard, it makes for ugly declarations.\n\t *\n\t * @return {@code true} if the given identifier text is considered quoted; {@code false} otherwise.\n\t */\n\tpublic static boolean isQuoted(String name) {\n\t\treturn isQuoted( name, 0, name.length() );\n\t}\n\n\tpublic static boolean isQuoted(String name, int start, int end) {\n\t\tif ( start + 2 < end ) {\n\t\t\tfinal char first = name.charAt( start );\n\t\t\tfinal char last = name.charAt( end - 1 );\n\t\t\treturn switch ( first ) {\n\t\t\t\tcase '`' -> last == '`';\n\t\t\t\tcase '[' -> last == ']';\n\t\t\t\tcase '\"' -> last == '\"';\n\t\t\t\tdefault -> false;\n\t\t\t};\n\t\t}\n\t\telse {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tpublic static String unQuote(String name) {\n\t\tassert isQuoted( name );\n\t\treturn name.substring( 1, name.length() - 1 );\n\t}\n\n\t/**\n\t * Constructs an identifier instance.\n\t *\n\t * @param text The identifier text.\n\t * @param quoted Is this a quoted identifier?\n\t */\n\tpublic Identifier(String text, boolean quoted) {\n\t\tif ( isEmpty( text ) ) {\n\t\t\tthrow new IllegalIdentifierException( \"Identifier text cannot be null\" );\n\t\t}\n\t\tif ( isQuoted( text ) ) {\n\t\t\tthrow new IllegalIdentifierException( \"Identifier text should not contain quote markers (` or \\\")\" );\n\t\t}\n\t\tthis.text = text;\n\t\tthis.isQuoted = quoted;\n\t}\n\n\t/**\n\t * Constructs an unquoted identifier instance.\n\t *\n\t * @param text The identifier text.\n\t */\n\tprotected Identifier(String text) {\n\t\tthis.text = text;\n\t\tthis.isQuoted = false;\n\t}\n\n\t/**\n\t * Get the identifiers name (text)\n\t *\n\t * @return The name\n\t */\n\tpublic String getText() {\n\t\treturn text;\n\t}\n\n\t/**\n\t * Is this a quoted identifier?\n\t *\n\t * @return True if this is a quote identifier; false otherwise.\n\t */\n\tpublic boolean isQuoted() {\n\t\treturn isQuoted;\n\t}\n\n\t/**\n\t * If this is a quoted identifier, then return the identifier name\n\t * enclosed in dialect-specific open- and end-quotes; otherwise,\n\t * simply return the unquoted identifier.\n\t *\n\t * @param dialect The dialect whose dialect-specific quoting should be used.\n\t *\n\t * @return if quoted, identifier name enclosed in dialect-specific open- and\n\t * end-quotes; otherwise, the unquoted identifier.\n\t */\n\tpublic String render(Dialect dialect) {\n\t\treturn isQuoted\n\t\t\t\t? dialect.toQuotedIdentifier( getText() )\n\t\t\t\t: getText();\n\t}\n\n\tpublic String render() {\n\t\treturn isQuoted\n\t\t\t\t? '`' + getText() + '`'\n\t\t\t\t: getText();\n\t}\n\n\tpublic String getCanonicalName() {\n\t\treturn isQuoted ? text : text.toLowerCase( Locale.ENGLISH );\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn render();\n\t}\n\n\t@Override\n\tpublic boolean equals(Object object) {\n\t\treturn object instanceof Identifier that\n\t\t\t&& getCanonicalName().equals( that.getCanonicalName() );\n\t}\n\n\tpublic boolean matches(String name) {\n\t\treturn isQuoted()\n\t\t\t\t? text.equals( name )\n\t\t\t\t: text.equalsIgnoreCase( name );\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\treturn isQuoted\n\t\t\t\t? text.hashCode()\n\t\t\t\t: text.toLowerCase( Locale.ENGLISH ).hashCode();\n\t}\n\n\tpublic static boolean areEqual(Identifier id1, Identifier id2) {\n\t\treturn Objects.equals( id1, id2 );\n\t}\n\n\tpublic static Identifier quote(Identifier identifier) {\n\t\treturn identifier.isQuoted()\n\t\t\t\t? identifier\n\t\t\t\t: Identifier.toIdentifier( identifier.getText(), true );\n\t}\n\n\t@Override\n\tpublic int compareTo(Identifier identifier) {\n\t\treturn getCanonicalName().compareTo( identifier.getCanonicalName() );\n\t}\n}\n",
        "diffSourceCodeSet": [
            "private static boolean isLegalFirstChar(char first) {\n\t\treturn isLetter( first )\n\t\t\t// many databases also allow _ here\n\t\t\t|| first == '_';\n\t}"
        ],
        "invokedMethodSet": [
            "methodSignature: org.hibernate.boot.model.naming.Identifier#isQuoted\n methodBody: public boolean isQuoted() {\nreturn isQuoted;\n}"
        ],
        "sourceCodeAfterRefactoring": "private static boolean autoquote(String text, int start, int end) {\n\t\t// Check the letters to determine if we must quote the text\n\t\tif ( !isLegalFirstChar( text.charAt( start ) ) ) {\n\t\t\t// SQL identifiers must begin with a letter or underscore\n\t\t\treturn true;\n\t\t}\n\t\telse {\n\t\t\tfor ( int i = start + 1; i < end; i++ ) {\n\t\t\t\tif ( !isLegalChar( text.charAt( i ) ) ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\nprivate static boolean isLegalFirstChar(char first) {\n\t\treturn isLetter( first )\n\t\t\t// many databases also allow _ here\n\t\t\t|| first == '_';\n\t}",
        "diffSourceCode": "-   67: \t/**\n-   68: \t * Means to generate an {@link Identifier} instance from its simple text form.\n-   69: \t * <p>\n-   70: \t * If passed text is {@code null}, {@code null} is returned.\n-   71: \t * <p>\n-   72: \t * If passed text is surrounded in quote markers, the generated Identifier\n-   73: \t * is considered quoted.  Quote markers include back-ticks (`),\n-   74: \t * double-quotes (\") and brackets ([ and ]).\n-   75: \t *\n-   76: \t * @param text The text form\n-   77: \t * @param quote Whether to quote unquoted text forms\n-   78: \t * @param quoteOnNonIdentifierChar Controls whether to treat the result as quoted if text contains characters that are invalid for identifiers\n-   79: \t *\n-   80: \t * @return The identifier form, or {@code null} if text was {@code null}\n-   81: \t */\n-   82: \tpublic static Identifier toIdentifier(String text, boolean quote, boolean quoteOnNonIdentifierChar) {\n-   83: \t\tif ( isBlank( text ) ) {\n-   84: \t\t\treturn null;\n-   85: \t\t}\n-   86: \t\tint start = 0;\n-   87: \t\tint end = text.length();\n-   88: \t\twhile ( start < end ) {\n-   89: \t\t\tif ( !isWhitespace( text.charAt( start ) ) ) {\n-   90: \t\t\t\tbreak;\n-   91: \t\t\t}\n-   92: \t\t\tstart++;\n-   93: \t\t}\n-   94: \t\twhile ( start < end ) {\n-   95: \t\t\tif ( !isWhitespace( text.charAt( end - 1 ) ) ) {\n-   96: \t\t\t\tbreak;\n-   97: \t\t\t}\n-   98: \t\t\tend--;\n-   99: \t\t}\n-  100: \t\tif ( isQuoted( text, start, end ) ) {\n-  101: \t\t\tstart++;\n-  102: \t\t\tend--;\n-  103: \t\t\tquote = true;\n-  104: \t\t}\n-  105: \t\telse if ( quoteOnNonIdentifierChar && !quote ) {\n-  106: \t\t\t// Check the letters to determine if we must quote the text\n-  107: \t\t\tchar c = text.charAt( start );\n-  108: \t\t\tif ( !isLetter( c ) && c != '_' ) {\n-  109: \t\t\t\t// SQL identifiers must begin with a letter or underscore\n-  110: \t\t\t\tquote = true;\n-  111: \t\t\t}\n-  112: \t\t\telse {\n-  113: \t\t\t\tfor ( int i = start + 1; i < end; i++ ) {\n-  114: \t\t\t\t\tc = text.charAt( i );\n-  115: \t\t\t\t\tif ( !isLetterOrDigit( c ) && c != '_' ) {\n-  116: \t\t\t\t\t\tquote = true;\n-  117: \t\t\t\t\t\tbreak;\n-  118: \t\t\t\t\t}\n-  119: \t\t\t\t}\n-  120: \t\t\t}\n-  121: \t\t}\n-  122: \t\treturn new Identifier( text.substring( start, end ), quote );\n-  123: \t}\n-  124: \n-  125: \t/**\n-  126: \t * Is the given identifier text considered quoted.  The following patterns are\n-  136: \t * @return {@code true} if the given identifier text is considered quoted; {@code false} otherwise.\n-  137: \t */\n-  138: \tpublic static boolean isQuoted(String name) {\n-  139: \t\treturn isQuoted( name, 0, name.length() );\n+   67: \n+   68: \t/**\n+   69: \t * Means to generate an {@link Identifier} instance from its simple text form.\n+   70: \t * <p>\n+   71: \t * If passed {@code text} is {@code null}, {@code null} is returned.\n+   72: \t * <p>\n+   73: \t * If passed {@code text} is surrounded in quote markers, the returned Identifier\n+   74: \t * is considered quoted. Quote markers include back-ticks (`), double-quotes (\"),\n+   75: \t * and brackets ([ and ]).\n+   76: \t *\n+   77: \t * @param text The text form\n+   78: \t * @param quote Whether to quote unquoted text forms\n+   79: \t * @param autoquote Whether to quote the result if it contains special characters\n+   80: \t *\n+   81: \t * @return The identifier form, or {@code null} if text was {@code null}\n+   82: \t */\n+   83: \tpublic static Identifier toIdentifier(String text, boolean quote, boolean autoquote) {\n+   84: \t\tif ( isBlank( text ) ) {\n+   85: \t\t\treturn null;\n+   86: \t\t}\n+   87: \t\tint start = 0;\n+   88: \t\tint end = text.length();\n+   89: \t\twhile ( start < end ) {\n+   90: \t\t\tif ( !isWhitespace( text.charAt( start ) ) ) {\n+   91: \t\t\t\tbreak;\n+   92: \t\t\t}\n+   93: \t\t\tstart++;\n+   94: \t\t}\n+   95: \t\twhile ( start < end ) {\n+   96: \t\t\tif ( !isWhitespace( text.charAt( end - 1 ) ) ) {\n+   97: \t\t\t\tbreak;\n+   98: \t\t\t}\n+   99: \t\t\tend--;\n+  100: \t\t}\n+  101: \t\tif ( isQuoted( text, start, end ) ) {\n+  102: \t\t\tstart++;\n+  103: \t\t\tend--;\n+  104: \t\t\tquote = true;\n+  105: \t\t}\n+  106: \t\telse if ( autoquote && !quote ) {\n+  107: \t\t\tquote = autoquote( text, start, end );\n+  108: \t\t}\n+  109: \t\treturn new Identifier( text.substring( start, end ), quote );\n+  110: \t}\n+  111: \n+  112: \tprivate static boolean autoquote(String text, int start, int end) {\n+  113: \t\t// Check the letters to determine if we must quote the text\n+  114: \t\tif ( !isLegalFirstChar( text.charAt( start ) ) ) {\n+  115: \t\t\t// SQL identifiers must begin with a letter or underscore\n+  116: \t\t\treturn true;\n+  117: \t\t}\n+  118: \t\telse {\n+  119: \t\t\tfor ( int i = start + 1; i < end; i++ ) {\n+  120: \t\t\t\tif ( !isLegalChar( text.charAt( i ) ) ) {\n+  121: \t\t\t\t\treturn true;\n+  122: \t\t\t\t}\n+  123: \t\t\t}\n+  124: \t\t}\n+  125: \t\treturn false;\n+  126: \t}\n+  136: \tprivate static boolean isLegalFirstChar(char first) {\n+  137: \t\treturn isLetter( first )\n+  138: \t\t\t// many databases also allow _ here\n+  139: \t\t\t|| first == '_';\n   140: \t}\n",
        "uniqueId": "e14ead0c0f0916cc8fdb8895e2cc481754a75583_67_123_136_140_112_126",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 0,
                "covered": 92
            },
            "BRANCH": {
                "missed": 2,
                "covered": 24
            },
            "LINE": {
                "missed": 0,
                "covered": 26
            },
            "COMPLEXITY": {
                "missed": 2,
                "covered": 12
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 21
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprotected buildEntityAssembler(entityInitializer EntityInitializer<?>) : EntityAssembler<?> extracted from public createAssembler(parent InitializerParent<?>, creationState AssemblerCreationState) : DomainResultAssembler<?> in class org.hibernate.sql.results.graph.entity.internal.EntityFetchJoinedImpl",
        "diffLocations": [
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/sql/results/graph/entity/internal/EntityFetchJoinedImpl.java",
                "startLine": 128,
                "endLine": 135,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/sql/results/graph/entity/internal/EntityFetchJoinedImpl.java",
                "startLine": 128,
                "endLine": 133,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/sql/results/graph/entity/internal/EntityFetchJoinedImpl.java",
                "startLine": 135,
                "endLine": 140,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "@Override\n\tpublic DomainResultAssembler<?> createAssembler(\n\t\t\tInitializerParent<?> parent,\n\t\t\tAssemblerCreationState creationState) {\n\t\treturn new EntityAssembler<>( getFetchedMapping().getJavaType(),\n\t\t\t\tcreationState.resolveInitializer( this, parent, this )\n\t\t\t\t\t\t.asEntityInitializer() );\n\t}",
        "filePathBefore": "hibernate-core/src/main/java/org/hibernate/sql/results/graph/entity/internal/EntityFetchJoinedImpl.java",
        "isPureRefactoring": true,
        "commitId": "1fe23ae2edc8ae660d4a9923efb610b383fd0c3d",
        "packageNameBefore": "org.hibernate.sql.results.graph.entity.internal",
        "classNameBefore": "org.hibernate.sql.results.graph.entity.internal.EntityFetchJoinedImpl",
        "methodNameBefore": "org.hibernate.sql.results.graph.entity.internal.EntityFetchJoinedImpl#createAssembler",
        "invokedMethod": "methodSignature: org.hibernate.sql.results.graph.entity.internal.AbstractNonJoinedEntityFetch#getFetchedMapping\n methodBody: public ToOneAttributeMapping getFetchedMapping() {\nreturn fetchedModelPart;\n}\nmethodSignature: org.hibernate.sql.results.graph.entity.internal.EntityFetchJoinedImpl#getFetchedMapping\n methodBody: public EntityValuedFetchable getFetchedMapping() {\nreturn getEntityValuedModelPart();\n}",
        "classSignatureBefore": "public class EntityFetchJoinedImpl implements EntityFetch, FetchParent, InitializerProducer<EntityFetchJoinedImpl> ",
        "methodNameBeforeSet": [
            "org.hibernate.sql.results.graph.entity.internal.EntityFetchJoinedImpl#createAssembler"
        ],
        "classNameBeforeSet": [
            "org.hibernate.sql.results.graph.entity.internal.EntityFetchJoinedImpl"
        ],
        "classSignatureBeforeSet": [
            "public class EntityFetchJoinedImpl implements EntityFetch, FetchParent, InitializerProducer<EntityFetchJoinedImpl> "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Changes are within the Extract Method refactoring mechanics",
                "description": "All the mappings are matched! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * SPDX-License-Identifier: LGPL-2.1-or-later\n * Copyright Red Hat Inc. and Hibernate Authors\n */\npackage org.hibernate.sql.results.graph.entity.internal;\n\nimport java.util.BitSet;\n\nimport org.hibernate.annotations.NotFoundAction;\nimport org.hibernate.engine.FetchTiming;\nimport org.hibernate.metamodel.mapping.internal.EntityCollectionPart;\nimport org.hibernate.metamodel.mapping.internal.ToOneAttributeMapping;\nimport org.hibernate.spi.NavigablePath;\nimport org.hibernate.sql.ast.tree.from.TableGroup;\nimport org.hibernate.sql.results.graph.AssemblerCreationState;\nimport org.hibernate.sql.results.graph.DomainResult;\nimport org.hibernate.sql.results.graph.DomainResultAssembler;\nimport org.hibernate.sql.results.graph.DomainResultCreationState;\nimport org.hibernate.sql.results.graph.Fetch;\nimport org.hibernate.sql.results.graph.FetchParent;\nimport org.hibernate.sql.results.graph.Fetchable;\nimport org.hibernate.sql.results.graph.Initializer;\nimport org.hibernate.sql.results.graph.InitializerParent;\nimport org.hibernate.sql.results.graph.InitializerProducer;\nimport org.hibernate.sql.results.graph.entity.EntityFetch;\nimport org.hibernate.sql.results.graph.entity.EntityInitializer;\nimport org.hibernate.sql.results.graph.entity.EntityValuedFetchable;\nimport org.hibernate.sql.results.graph.internal.ImmutableFetchList;\n\n/**\n * @author Andrea Boriero\n * @author Steve Ebersole\n */\npublic class EntityFetchJoinedImpl implements EntityFetch, FetchParent, InitializerProducer<EntityFetchJoinedImpl> {\n\tprivate final FetchParent fetchParent;\n\tprivate final EntityValuedFetchable fetchContainer;\n\tprivate final EntityResultImpl entityResult;\n\tprivate final DomainResult<?> keyResult;\n\tprivate final NotFoundAction notFoundAction;\n\tprivate final boolean isAffectedByFilter;\n\n\tprivate final String sourceAlias;\n\n\tpublic EntityFetchJoinedImpl(\n\t\t\tFetchParent fetchParent,\n\t\t\tToOneAttributeMapping toOneMapping,\n\t\t\tTableGroup tableGroup,\n\t\t\tDomainResult<?> keyResult,\n\t\t\tboolean isAffectedByFilter,\n\t\t\tNavigablePath navigablePath,\n\t\t\tDomainResultCreationState creationState) {\n\t\tthis.fetchContainer = toOneMapping;\n\t\tthis.fetchParent = fetchParent;\n\t\tthis.keyResult = keyResult;\n\t\tthis.notFoundAction = toOneMapping.getNotFoundAction();\n\t\tthis.sourceAlias = tableGroup.getSourceAlias();\n\t\tthis.isAffectedByFilter = isAffectedByFilter;\n\t\tthis.entityResult = new EntityResultImpl(\n\t\t\t\tnavigablePath,\n\t\t\t\ttoOneMapping,\n\t\t\t\ttableGroup,\n\t\t\t\tnull\n\t\t);\n\n\t\tthis.entityResult.afterInitialize( this, creationState );\n\t}\n\n\tpublic EntityFetchJoinedImpl(\n\t\t\tFetchParent fetchParent,\n\t\t\tEntityCollectionPart collectionPart,\n\t\t\tTableGroup tableGroup,\n\t\t\tNavigablePath navigablePath,\n\t\t\tDomainResultCreationState creationState) {\n\t\tthis.fetchContainer = collectionPart;\n\t\tthis.fetchParent = fetchParent;\n\t\tthis.notFoundAction = collectionPart.getNotFoundAction();\n\t\tthis.keyResult = null;\n\t\tthis.sourceAlias = tableGroup.getSourceAlias();\n\t\tthis.isAffectedByFilter = false;\n\t\tthis.entityResult = new EntityResultImpl(\n\t\t\t\tnavigablePath,\n\t\t\t\tcollectionPart,\n\t\t\t\ttableGroup,\n\t\t\t\tnull\n\t\t);\n\n\t\tthis.entityResult.afterInitialize( this, creationState );\n\t}\n\n\t/**\n\t * For Hibernate Reactive\n\t */\n\tprotected EntityFetchJoinedImpl(EntityFetchJoinedImpl original) {\n\t\tthis.fetchContainer = original.fetchContainer;\n\t\tthis.fetchParent = original.fetchParent;\n\t\tthis.entityResult = original.entityResult;\n\t\tthis.keyResult = original.keyResult;\n\t\tthis.notFoundAction = original.notFoundAction;\n\t\tthis.isAffectedByFilter = original.isAffectedByFilter;\n\t\tthis.sourceAlias = original.sourceAlias;\n\t}\n\n\t@Override\n\tpublic EntityValuedFetchable getEntityValuedModelPart() {\n\t\treturn fetchContainer;\n\t}\n\n\t@Override\n\tpublic EntityValuedFetchable getReferencedModePart() {\n\t\treturn getEntityValuedModelPart();\n\t}\n\n\t@Override\n\tpublic EntityValuedFetchable getReferencedMappingType() {\n\t\treturn getEntityValuedModelPart();\n\t}\n\n\t@Override\n\tpublic EntityValuedFetchable getFetchedMapping() {\n\t\treturn getEntityValuedModelPart();\n\t}\n\n\t@Override\n\tpublic FetchParent getFetchParent() {\n\t\treturn fetchParent;\n\t}\n\n\t@Override\n\tpublic DomainResultAssembler<?> createAssembler(\n\t\t\tInitializerParent<?> parent,\n\t\t\tAssemblerCreationState creationState) {\n\t\treturn new EntityAssembler<>( getFetchedMapping().getJavaType(),\n\t\t\t\tcreationState.resolveInitializer( this, parent, this )\n\t\t\t\t\t\t.asEntityInitializer() );\n\t}\n\n\t@Override\n\tpublic Initializer<?> createInitializer(\n\t\t\tEntityFetchJoinedImpl resultGraphNode,\n\t\t\tInitializerParent<?> parent,\n\t\t\tAssemblerCreationState creationState) {\n\t\treturn resultGraphNode.createInitializer( parent, creationState );\n\t}\n\n\t@Override\n\tpublic EntityInitializer<?> createInitializer(InitializerParent<?> parent, AssemblerCreationState creationState) {\n\t\treturn new EntityInitializerImpl(\n\t\t\t\tthis,\n\t\t\t\tsourceAlias,\n\t\t\t\tentityResult.getIdentifierFetch(),\n\t\t\t\tentityResult.getDiscriminatorFetch(),\n\t\t\t\tkeyResult,\n\t\t\t\tentityResult.getRowIdResult(),\n\t\t\t\tnotFoundAction,\n\t\t\t\tisAffectedByFilter,\n\t\t\t\tparent,\n\t\t\t\tfalse,\n\t\t\t\tcreationState\n\t\t);\n\t}\n\n\t@Override\n\tpublic FetchTiming getTiming() {\n\t\treturn FetchTiming.IMMEDIATE;\n\t}\n\n\t@Override\n\tpublic boolean hasTableGroup() {\n\t\treturn true;\n\t}\n\n\tpublic EntityResultImpl getEntityResult() {\n\t\treturn entityResult;\n\t}\n\n\t@Override\n\tpublic NavigablePath getNavigablePath() {\n\t\treturn entityResult.getNavigablePath();\n\t}\n\n\t@Override\n\tpublic ImmutableFetchList getFetches() {\n\t\treturn entityResult.getFetches();\n\t}\n\n\t@Override\n\tpublic Fetch findFetch(Fetchable fetchable) {\n\t\treturn entityResult.findFetch( fetchable );\n\t}\n\n\t@Override\n\tpublic boolean hasJoinFetches() {\n\t\treturn entityResult.hasJoinFetches();\n\t}\n\n\t@Override\n\tpublic boolean containsCollectionFetches() {\n\t\treturn entityResult.containsCollectionFetches();\n\t}\n\n\t@Override\n\tpublic void collectValueIndexesToCache(BitSet valueIndexes) {\n\t\tentityResult.collectValueIndexesToCache( valueIndexes );\n\t}\n\n\t/*\n\t * BEGIN: For Hibernate Reactive\n\t */\n\tprotected DomainResult<?> getKeyResult() {\n\t\treturn keyResult;\n\t}\n\n\tprotected NotFoundAction getNotFoundAction() {\n\t\treturn notFoundAction;\n\t}\n\n\tprotected boolean isAffectedByFilter() {\n\t\treturn isAffectedByFilter;\n\t}\n\n\tprotected String getSourceAlias() {\n\t\treturn sourceAlias;\n\t}\n\t/*\n\t * END: Hibernate Reactive: make sure values are accessible from subclass\n\t */\n}\n",
        "filePathAfter": "hibernate-core/src/main/java/org/hibernate/sql/results/graph/entity/internal/EntityFetchJoinedImpl.java",
        "sourceCodeAfterForWhole": "/*\n * SPDX-License-Identifier: LGPL-2.1-or-later\n * Copyright Red Hat Inc. and Hibernate Authors\n */\npackage org.hibernate.sql.results.graph.entity.internal;\n\nimport java.util.BitSet;\n\nimport org.hibernate.annotations.NotFoundAction;\nimport org.hibernate.engine.FetchTiming;\nimport org.hibernate.metamodel.mapping.internal.EntityCollectionPart;\nimport org.hibernate.metamodel.mapping.internal.ToOneAttributeMapping;\nimport org.hibernate.spi.NavigablePath;\nimport org.hibernate.sql.ast.tree.from.TableGroup;\nimport org.hibernate.sql.results.graph.AssemblerCreationState;\nimport org.hibernate.sql.results.graph.DomainResult;\nimport org.hibernate.sql.results.graph.DomainResultAssembler;\nimport org.hibernate.sql.results.graph.DomainResultCreationState;\nimport org.hibernate.sql.results.graph.Fetch;\nimport org.hibernate.sql.results.graph.FetchParent;\nimport org.hibernate.sql.results.graph.Fetchable;\nimport org.hibernate.sql.results.graph.Initializer;\nimport org.hibernate.sql.results.graph.InitializerParent;\nimport org.hibernate.sql.results.graph.InitializerProducer;\nimport org.hibernate.sql.results.graph.entity.EntityFetch;\nimport org.hibernate.sql.results.graph.entity.EntityInitializer;\nimport org.hibernate.sql.results.graph.entity.EntityValuedFetchable;\nimport org.hibernate.sql.results.graph.internal.ImmutableFetchList;\n\n/**\n * @author Andrea Boriero\n * @author Steve Ebersole\n */\npublic class EntityFetchJoinedImpl implements EntityFetch, FetchParent, InitializerProducer<EntityFetchJoinedImpl> {\n\tprivate final FetchParent fetchParent;\n\tprivate final EntityValuedFetchable fetchContainer;\n\tprivate final EntityResultImpl entityResult;\n\tprivate final DomainResult<?> keyResult;\n\tprivate final NotFoundAction notFoundAction;\n\tprivate final boolean isAffectedByFilter;\n\n\tprivate final String sourceAlias;\n\n\tpublic EntityFetchJoinedImpl(\n\t\t\tFetchParent fetchParent,\n\t\t\tToOneAttributeMapping toOneMapping,\n\t\t\tTableGroup tableGroup,\n\t\t\tDomainResult<?> keyResult,\n\t\t\tboolean isAffectedByFilter,\n\t\t\tNavigablePath navigablePath,\n\t\t\tDomainResultCreationState creationState) {\n\t\tthis.fetchContainer = toOneMapping;\n\t\tthis.fetchParent = fetchParent;\n\t\tthis.keyResult = keyResult;\n\t\tthis.notFoundAction = toOneMapping.getNotFoundAction();\n\t\tthis.sourceAlias = tableGroup.getSourceAlias();\n\t\tthis.isAffectedByFilter = isAffectedByFilter;\n\t\tthis.entityResult = new EntityResultImpl(\n\t\t\t\tnavigablePath,\n\t\t\t\ttoOneMapping,\n\t\t\t\ttableGroup,\n\t\t\t\tnull\n\t\t);\n\n\t\tthis.entityResult.afterInitialize( this, creationState );\n\t}\n\n\tpublic EntityFetchJoinedImpl(\n\t\t\tFetchParent fetchParent,\n\t\t\tEntityCollectionPart collectionPart,\n\t\t\tTableGroup tableGroup,\n\t\t\tNavigablePath navigablePath,\n\t\t\tDomainResultCreationState creationState) {\n\t\tthis.fetchContainer = collectionPart;\n\t\tthis.fetchParent = fetchParent;\n\t\tthis.notFoundAction = collectionPart.getNotFoundAction();\n\t\tthis.keyResult = null;\n\t\tthis.sourceAlias = tableGroup.getSourceAlias();\n\t\tthis.isAffectedByFilter = false;\n\t\tthis.entityResult = new EntityResultImpl(\n\t\t\t\tnavigablePath,\n\t\t\t\tcollectionPart,\n\t\t\t\ttableGroup,\n\t\t\t\tnull\n\t\t);\n\n\t\tthis.entityResult.afterInitialize( this, creationState );\n\t}\n\n\t/**\n\t * For Hibernate Reactive\n\t */\n\tprotected EntityFetchJoinedImpl(EntityFetchJoinedImpl original) {\n\t\tthis.fetchContainer = original.fetchContainer;\n\t\tthis.fetchParent = original.fetchParent;\n\t\tthis.entityResult = original.entityResult;\n\t\tthis.keyResult = original.keyResult;\n\t\tthis.notFoundAction = original.notFoundAction;\n\t\tthis.isAffectedByFilter = original.isAffectedByFilter;\n\t\tthis.sourceAlias = original.sourceAlias;\n\t}\n\n\t@Override\n\tpublic EntityValuedFetchable getEntityValuedModelPart() {\n\t\treturn fetchContainer;\n\t}\n\n\t@Override\n\tpublic EntityValuedFetchable getReferencedModePart() {\n\t\treturn getEntityValuedModelPart();\n\t}\n\n\t@Override\n\tpublic EntityValuedFetchable getReferencedMappingType() {\n\t\treturn getEntityValuedModelPart();\n\t}\n\n\t@Override\n\tpublic EntityValuedFetchable getFetchedMapping() {\n\t\treturn getEntityValuedModelPart();\n\t}\n\n\t@Override\n\tpublic FetchParent getFetchParent() {\n\t\treturn fetchParent;\n\t}\n\n\t@Override\n\tpublic DomainResultAssembler<?> createAssembler(\n\t\t\tInitializerParent<?> parent,\n\t\t\tAssemblerCreationState creationState) {\n\t\treturn buildEntityAssembler( creationState.resolveInitializer( this, parent, this ).asEntityInitializer() );\n\t}\n\n\t/**\n\t * Used by Hibernate Reactive\n\t */\n\tprotected EntityAssembler<?> buildEntityAssembler(EntityInitializer<?> entityInitializer) {\n\t\treturn new EntityAssembler<>( getFetchedMapping().getJavaType(), entityInitializer );\n\t}\n\n\t@Override\n\tpublic Initializer<?> createInitializer(\n\t\t\tEntityFetchJoinedImpl resultGraphNode,\n\t\t\tInitializerParent<?> parent,\n\t\t\tAssemblerCreationState creationState) {\n\t\treturn resultGraphNode.createInitializer( parent, creationState );\n\t}\n\n\t@Override\n\tpublic EntityInitializer<?> createInitializer(InitializerParent<?> parent, AssemblerCreationState creationState) {\n\t\treturn new EntityInitializerImpl(\n\t\t\t\tthis,\n\t\t\t\tsourceAlias,\n\t\t\t\tentityResult.getIdentifierFetch(),\n\t\t\t\tentityResult.getDiscriminatorFetch(),\n\t\t\t\tkeyResult,\n\t\t\t\tentityResult.getRowIdResult(),\n\t\t\t\tnotFoundAction,\n\t\t\t\tisAffectedByFilter,\n\t\t\t\tparent,\n\t\t\t\tfalse,\n\t\t\t\tcreationState\n\t\t);\n\t}\n\n\t@Override\n\tpublic FetchTiming getTiming() {\n\t\treturn FetchTiming.IMMEDIATE;\n\t}\n\n\t@Override\n\tpublic boolean hasTableGroup() {\n\t\treturn true;\n\t}\n\n\tpublic EntityResultImpl getEntityResult() {\n\t\treturn entityResult;\n\t}\n\n\t@Override\n\tpublic NavigablePath getNavigablePath() {\n\t\treturn entityResult.getNavigablePath();\n\t}\n\n\t@Override\n\tpublic ImmutableFetchList getFetches() {\n\t\treturn entityResult.getFetches();\n\t}\n\n\t@Override\n\tpublic Fetch findFetch(Fetchable fetchable) {\n\t\treturn entityResult.findFetch( fetchable );\n\t}\n\n\t@Override\n\tpublic boolean hasJoinFetches() {\n\t\treturn entityResult.hasJoinFetches();\n\t}\n\n\t@Override\n\tpublic boolean containsCollectionFetches() {\n\t\treturn entityResult.containsCollectionFetches();\n\t}\n\n\t@Override\n\tpublic void collectValueIndexesToCache(BitSet valueIndexes) {\n\t\tentityResult.collectValueIndexesToCache( valueIndexes );\n\t}\n\n\t/*\n\t * BEGIN: For Hibernate Reactive\n\t */\n\tprotected DomainResult<?> getKeyResult() {\n\t\treturn keyResult;\n\t}\n\n\tprotected NotFoundAction getNotFoundAction() {\n\t\treturn notFoundAction;\n\t}\n\n\tprotected boolean isAffectedByFilter() {\n\t\treturn isAffectedByFilter;\n\t}\n\n\tprotected String getSourceAlias() {\n\t\treturn sourceAlias;\n\t}\n\t/*\n\t * END: Hibernate Reactive: make sure values are accessible from subclass\n\t */\n}\n",
        "diffSourceCodeSet": [
            "/**\n\t * Used by Hibernate Reactive\n\t */\n\tprotected EntityAssembler<?> buildEntityAssembler(EntityInitializer<?> entityInitializer) {\n\t\treturn new EntityAssembler<>( getFetchedMapping().getJavaType(), entityInitializer );\n\t}"
        ],
        "invokedMethodSet": [
            "methodSignature: org.hibernate.sql.results.graph.entity.internal.AbstractNonJoinedEntityFetch#getFetchedMapping\n methodBody: public ToOneAttributeMapping getFetchedMapping() {\nreturn fetchedModelPart;\n}",
            "methodSignature: org.hibernate.sql.results.graph.entity.internal.EntityFetchJoinedImpl#getFetchedMapping\n methodBody: public EntityValuedFetchable getFetchedMapping() {\nreturn getEntityValuedModelPart();\n}"
        ],
        "sourceCodeAfterRefactoring": "@Override\n\tpublic DomainResultAssembler<?> createAssembler(\n\t\t\tInitializerParent<?> parent,\n\t\t\tAssemblerCreationState creationState) {\n\t\treturn buildEntityAssembler( creationState.resolveInitializer( this, parent, this ).asEntityInitializer() );\n\t}\n/**\n\t * Used by Hibernate Reactive\n\t */\n\tprotected EntityAssembler<?> buildEntityAssembler(EntityInitializer<?> entityInitializer) {\n\t\treturn new EntityAssembler<>( getFetchedMapping().getJavaType(), entityInitializer );\n\t}",
        "diffSourceCode": "   128: \t@Override\n   129: \tpublic DomainResultAssembler<?> createAssembler(\n   130: \t\t\tInitializerParent<?> parent,\n   131: \t\t\tAssemblerCreationState creationState) {\n-  132: \t\treturn new EntityAssembler<>( getFetchedMapping().getJavaType(),\n-  133: \t\t\t\tcreationState.resolveInitializer( this, parent, this )\n-  134: \t\t\t\t\t\t.asEntityInitializer() );\n-  135: \t}\n-  136: \n-  137: \t@Override\n-  138: \tpublic Initializer<?> createInitializer(\n-  139: \t\t\tEntityFetchJoinedImpl resultGraphNode,\n-  140: \t\t\tInitializerParent<?> parent,\n+  132: \t\treturn buildEntityAssembler( creationState.resolveInitializer( this, parent, this ).asEntityInitializer() );\n+  133: \t}\n+  134: \n+  135: \t/**\n+  136: \t * Used by Hibernate Reactive\n+  137: \t */\n+  138: \tprotected EntityAssembler<?> buildEntityAssembler(EntityInitializer<?> entityInitializer) {\n+  139: \t\treturn new EntityAssembler<>( getFetchedMapping().getJavaType(), entityInitializer );\n+  140: \t}\n",
        "uniqueId": "1fe23ae2edc8ae660d4a9923efb610b383fd0c3d_128_135_135_140_128_133",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 0,
                "covered": 13
            },
            "LINE": {
                "missed": 0,
                "covered": 3
            },
            "COMPLEXITY": {
                "missed": 0,
                "covered": 1
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 21
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprivate registerAllCallbacks(persistentClass PersistentClass, registryBuilder CallbackRegistryImpl.Builder, entityClass Class<?>, beanRegistry ManagedBeanRegistry) : void extracted from public buildCallbackRegistry(options SessionFactoryOptions, serviceRegistry ServiceRegistry, entityBindings Collection<PersistentClass>) : CallbackRegistry in class org.hibernate.jpa.event.internal.CallbacksFactory",
        "diffLocations": [
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/jpa/event/internal/CallbacksFactory.java",
                "startLine": 32,
                "endLine": 73,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/jpa/event/internal/CallbacksFactory.java",
                "startLine": 32,
                "endLine": 65,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/jpa/event/internal/CallbacksFactory.java",
                "startLine": 67,
                "endLine": 79,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "public static CallbackRegistry buildCallbackRegistry(SessionFactoryOptions options, ServiceRegistry serviceRegistry, Collection<PersistentClass> entityBindings) {\n\t\tif ( !jpaCallBacksEnabled( options ) ) {\n\t\t\treturn new EmptyCallbackRegistryImpl();\n\t\t}\n\t\tManagedBeanRegistry beanRegistry = serviceRegistry.getService( ManagedBeanRegistry.class );\n\t\tCallbackRegistryImpl.Builder registryBuilder = new CallbackRegistryImpl.Builder();\n\t\tSet<Class<?>> entityClasses = new HashSet<>();\n\n\t\tfor ( PersistentClass persistentClass : entityBindings ) {\n\t\t\tif ( persistentClass.getClassName() == null ) {\n\t\t\t\t// we can have dynamic (non-java class) mapping\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tClass<?> entityClass = persistentClass.getMappedClass();\n\n\t\t\tif ( !entityClasses.add( entityClass ) ) {\n\t\t\t\t// this most likely means we have a class mapped multiple times using the hbm.xml\n\t\t\t\t// \"entity name\" feature\n\t\t\t\tif ( log.isDebugEnabled() ) {\n\t\t\t\t\tlog.debugf(\n\t\t\t\t\t\t\t\"Class [%s] already has callbacks registered; \" +\n\t\t\t\t\t\t\t\t\t\"assuming this means the class was mapped twice \" +\n\t\t\t\t\t\t\t\t\t\"(using hbm.xml entity-name support) - skipping subsequent registrations\" +\n\t\t\t\t\t\t\t\t\t\"to avoid duplicates\",\n\t\t\t\t\t\t\tentityClass.getName()\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tregistryBuilder.registerCallbacks( persistentClass.getMappedClass(),\n\t\t\t\t\tbuildCallbacks( persistentClass.getCallbackDefinitions(), beanRegistry ) );\n\n\t\t\tfor ( Property property : persistentClass.getDeclaredProperties() ) {\n\t\t\t\tregistryBuilder.registerCallbacks( persistentClass.getMappedClass(),\n\t\t\t\t\t\tbuildCallbacks( property.getCallbackDefinitions(), beanRegistry ) );\n\t\t\t}\n\t\t}\n\n\t\treturn registryBuilder.build();\n\t}",
        "filePathBefore": "hibernate-core/src/main/java/org/hibernate/jpa/event/internal/CallbacksFactory.java",
        "isPureRefactoring": true,
        "commitId": "ddeaffc917fb82e84461691605baab7d12962cd2",
        "packageNameBefore": "org.hibernate.jpa.event.internal",
        "classNameBefore": "org.hibernate.jpa.event.internal.CallbacksFactory",
        "methodNameBefore": "org.hibernate.jpa.event.internal.CallbacksFactory#buildCallbackRegistry",
        "invokedMethod": "methodSignature: org.hibernate.jpa.event.internal.CallbacksFactory#buildCallbacks\n methodBody: private static Callback[] buildCallbacks(List<CallbackDefinition> callbackDefinitions,\n\t\t\tManagedBeanRegistry beanRegistry) {\nif(callbackDefinitions == null || callbackDefinitions.isEmpty()){return null;\n}List<Callback> callbacks=new ArrayList<>();\nfor(CallbackDefinition definition: callbackDefinitions){callbacks.add(definition.createCallback(beanRegistry));\n}return callbacks.toArray(new Callback[0]);\n}\nmethodSignature: org.hibernate.jpa.event.internal.CallbacksFactory#jpaCallBacksEnabled\n methodBody: private static boolean jpaCallBacksEnabled(SessionFactoryOptions options) {\nreturn options.areJPACallbacksEnabled();\n}",
        "classSignatureBefore": "public final class CallbacksFactory ",
        "methodNameBeforeSet": [
            "org.hibernate.jpa.event.internal.CallbacksFactory#buildCallbackRegistry"
        ],
        "classNameBeforeSet": [
            "org.hibernate.jpa.event.internal.CallbacksFactory"
        ],
        "classSignatureBeforeSet": [
            "public final class CallbacksFactory "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Changes are within the Extract Method refactoring mechanics",
                "description": "All replacements have been justified - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * SPDX-License-Identifier: LGPL-2.1-or-later\n * Copyright Red Hat Inc. and Hibernate Authors\n */\npackage org.hibernate.jpa.event.internal;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\n\nimport org.hibernate.boot.spi.SessionFactoryOptions;\nimport org.hibernate.jpa.event.spi.Callback;\nimport org.hibernate.jpa.event.spi.CallbackDefinition;\nimport org.hibernate.jpa.event.spi.CallbackRegistry;\nimport org.hibernate.mapping.PersistentClass;\nimport org.hibernate.mapping.Property;\nimport org.hibernate.resource.beans.spi.ManagedBeanRegistry;\nimport org.hibernate.service.ServiceRegistry;\n\nimport org.jboss.logging.Logger;\n\n/**\n * The intent of this class is to use a lighter implementation\n * when JPA callbacks are disabled via\n * {@link SessionFactoryOptions#areJPACallbacksEnabled()}\n */\npublic final class CallbacksFactory {\n\tprivate static final Logger log = Logger.getLogger( CallbacksFactory.class );\n\n\tpublic static CallbackRegistry buildCallbackRegistry(SessionFactoryOptions options, ServiceRegistry serviceRegistry, Collection<PersistentClass> entityBindings) {\n\t\tif ( !jpaCallBacksEnabled( options ) ) {\n\t\t\treturn new EmptyCallbackRegistryImpl();\n\t\t}\n\t\tManagedBeanRegistry beanRegistry = serviceRegistry.getService( ManagedBeanRegistry.class );\n\t\tCallbackRegistryImpl.Builder registryBuilder = new CallbackRegistryImpl.Builder();\n\t\tSet<Class<?>> entityClasses = new HashSet<>();\n\n\t\tfor ( PersistentClass persistentClass : entityBindings ) {\n\t\t\tif ( persistentClass.getClassName() == null ) {\n\t\t\t\t// we can have dynamic (non-java class) mapping\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tClass<?> entityClass = persistentClass.getMappedClass();\n\n\t\t\tif ( !entityClasses.add( entityClass ) ) {\n\t\t\t\t// this most likely means we have a class mapped multiple times using the hbm.xml\n\t\t\t\t// \"entity name\" feature\n\t\t\t\tif ( log.isDebugEnabled() ) {\n\t\t\t\t\tlog.debugf(\n\t\t\t\t\t\t\t\"Class [%s] already has callbacks registered; \" +\n\t\t\t\t\t\t\t\t\t\"assuming this means the class was mapped twice \" +\n\t\t\t\t\t\t\t\t\t\"(using hbm.xml entity-name support) - skipping subsequent registrations\" +\n\t\t\t\t\t\t\t\t\t\"to avoid duplicates\",\n\t\t\t\t\t\t\tentityClass.getName()\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tregistryBuilder.registerCallbacks( persistentClass.getMappedClass(),\n\t\t\t\t\tbuildCallbacks( persistentClass.getCallbackDefinitions(), beanRegistry ) );\n\n\t\t\tfor ( Property property : persistentClass.getDeclaredProperties() ) {\n\t\t\t\tregistryBuilder.registerCallbacks( persistentClass.getMappedClass(),\n\t\t\t\t\t\tbuildCallbacks( property.getCallbackDefinitions(), beanRegistry ) );\n\t\t\t}\n\t\t}\n\n\t\treturn registryBuilder.build();\n\t}\n\n\tprivate static Callback[] buildCallbacks(List<CallbackDefinition> callbackDefinitions,\n\t\t\tManagedBeanRegistry beanRegistry) {\n\t\tif ( callbackDefinitions == null || callbackDefinitions.isEmpty() ) {\n\t\t\treturn null;\n\t\t}\n\t\tList<Callback> callbacks = new ArrayList<>();\n\t\tfor ( CallbackDefinition definition : callbackDefinitions ) {\n\t\t\tcallbacks.add( definition.createCallback( beanRegistry ) );\n\t\t}\n\t\treturn callbacks.toArray( new Callback[0] );\n\t}\n\n\tprivate static boolean jpaCallBacksEnabled(SessionFactoryOptions options) {\n\t\treturn options.areJPACallbacksEnabled();\n\t}\n\n}\n",
        "filePathAfter": "hibernate-core/src/main/java/org/hibernate/jpa/event/internal/CallbacksFactory.java",
        "sourceCodeAfterForWhole": "/*\n * SPDX-License-Identifier: LGPL-2.1-or-later\n * Copyright Red Hat Inc. and Hibernate Authors\n */\npackage org.hibernate.jpa.event.internal;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\n\nimport org.hibernate.boot.spi.SessionFactoryOptions;\nimport org.hibernate.jpa.event.spi.Callback;\nimport org.hibernate.jpa.event.spi.CallbackDefinition;\nimport org.hibernate.jpa.event.spi.CallbackRegistry;\nimport org.hibernate.mapping.PersistentClass;\nimport org.hibernate.mapping.Property;\nimport org.hibernate.resource.beans.spi.ManagedBeanRegistry;\nimport org.hibernate.service.ServiceRegistry;\n\nimport org.jboss.logging.Logger;\n\n/**\n * The intent of this class is to use a lighter implementation\n * when JPA callbacks are disabled via\n * {@link SessionFactoryOptions#areJPACallbacksEnabled()}\n */\npublic final class CallbacksFactory {\n\tprivate static final Logger log = Logger.getLogger( CallbacksFactory.class );\n\n\tpublic static CallbackRegistry buildCallbackRegistry(\n\t\t\tSessionFactoryOptions options, ServiceRegistry serviceRegistry, Collection<PersistentClass> entityBindings) {\n\t\tif ( !options.areJPACallbacksEnabled() ) {\n\t\t\treturn new EmptyCallbackRegistryImpl();\n\t\t}\n\t\tfinal ManagedBeanRegistry beanRegistry = serviceRegistry.getService( ManagedBeanRegistry.class );\n\t\tfinal CallbackRegistryImpl.Builder registryBuilder = new CallbackRegistryImpl.Builder();\n\t\tfinal Set<Class<?>> entityClasses = new HashSet<>();\n\n\t\tfor ( PersistentClass persistentClass : entityBindings ) {\n\t\t\tif ( persistentClass.getClassName() != null ) {\n\t\t\t\tfinal Class<?> entityClass = persistentClass.getMappedClass();\n\t\t\t\tif ( !entityClasses.add( entityClass ) ) {\n\t\t\t\t\t// this most likely means we have a class mapped multiple\n\t\t\t\t\t// times using the hbm.xml \"entity name\" feature\n\t\t\t\t\tif ( log.isDebugEnabled() ) {\n\t\t\t\t\t\tlog.debugf(\n\t\t\t\t\t\t\t\t\"Class [%s] already has callbacks registered; \" +\n\t\t\t\t\t\t\t\t\"assuming this means the class was mapped twice \" +\n\t\t\t\t\t\t\t\t\"(using hbm.xml entity-name support) - skipping subsequent registrations\" +\n\t\t\t\t\t\t\t\t\"to avoid duplicates\",\n\t\t\t\t\t\t\t\tentityClass.getName()\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tregisterAllCallbacks( persistentClass, registryBuilder, entityClass, beanRegistry );\n\t\t\t\t}\n\t\t\t}\n\t\t\t// else we can have dynamic (non-java class) mapping\n\t\t}\n\n\t\treturn registryBuilder.build();\n\t}\n\n\tprivate static void registerAllCallbacks(\n\t\t\tPersistentClass persistentClass,\n\t\t\tCallbackRegistryImpl.Builder registryBuilder,\n\t\t\tClass<?> entityClass,\n\t\t\tManagedBeanRegistry beanRegistry) {\n\t\tregistryBuilder.registerCallbacks( entityClass,\n\t\t\t\tbuildCallbacks( persistentClass.getCallbackDefinitions(), beanRegistry ) );\n\n\t\tfor ( Property property : persistentClass.getDeclaredProperties() ) {\n\t\t\tregistryBuilder.registerCallbacks( entityClass,\n\t\t\t\t\tbuildCallbacks( property.getCallbackDefinitions(), beanRegistry ) );\n\t\t}\n\t}\n\n\tprivate static Callback[] buildCallbacks(List<CallbackDefinition> callbackDefinitions,\n\t\t\tManagedBeanRegistry beanRegistry) {\n\t\tif ( callbackDefinitions == null || callbackDefinitions.isEmpty() ) {\n\t\t\treturn null;\n\t\t}\n\t\telse {\n\t\t\tfinal List<Callback> callbacks = new ArrayList<>();\n\t\t\tfor ( CallbackDefinition definition : callbackDefinitions ) {\n\t\t\t\tcallbacks.add( definition.createCallback( beanRegistry ) );\n\t\t\t}\n\t\t\treturn callbacks.toArray( new Callback[0] );\n\t\t}\n\t}\n\n}\n",
        "diffSourceCodeSet": [
            "private static void registerAllCallbacks(\n\t\t\tPersistentClass persistentClass,\n\t\t\tCallbackRegistryImpl.Builder registryBuilder,\n\t\t\tClass<?> entityClass,\n\t\t\tManagedBeanRegistry beanRegistry) {\n\t\tregistryBuilder.registerCallbacks( entityClass,\n\t\t\t\tbuildCallbacks( persistentClass.getCallbackDefinitions(), beanRegistry ) );\n\n\t\tfor ( Property property : persistentClass.getDeclaredProperties() ) {\n\t\t\tregistryBuilder.registerCallbacks( entityClass,\n\t\t\t\t\tbuildCallbacks( property.getCallbackDefinitions(), beanRegistry ) );\n\t\t}\n\t}"
        ],
        "invokedMethodSet": [
            "methodSignature: org.hibernate.jpa.event.internal.CallbacksFactory#buildCallbacks\n methodBody: private static Callback[] buildCallbacks(List<CallbackDefinition> callbackDefinitions,\n\t\t\tManagedBeanRegistry beanRegistry) {\nif(callbackDefinitions == null || callbackDefinitions.isEmpty()){return null;\n}List<Callback> callbacks=new ArrayList<>();\nfor(CallbackDefinition definition: callbackDefinitions){callbacks.add(definition.createCallback(beanRegistry));\n}return callbacks.toArray(new Callback[0]);\n}",
            "methodSignature: org.hibernate.jpa.event.internal.CallbacksFactory#jpaCallBacksEnabled\n methodBody: private static boolean jpaCallBacksEnabled(SessionFactoryOptions options) {\nreturn options.areJPACallbacksEnabled();\n}"
        ],
        "sourceCodeAfterRefactoring": "public static CallbackRegistry buildCallbackRegistry(\n\t\t\tSessionFactoryOptions options, ServiceRegistry serviceRegistry, Collection<PersistentClass> entityBindings) {\n\t\tif ( !options.areJPACallbacksEnabled() ) {\n\t\t\treturn new EmptyCallbackRegistryImpl();\n\t\t}\n\t\tfinal ManagedBeanRegistry beanRegistry = serviceRegistry.getService( ManagedBeanRegistry.class );\n\t\tfinal CallbackRegistryImpl.Builder registryBuilder = new CallbackRegistryImpl.Builder();\n\t\tfinal Set<Class<?>> entityClasses = new HashSet<>();\n\n\t\tfor ( PersistentClass persistentClass : entityBindings ) {\n\t\t\tif ( persistentClass.getClassName() != null ) {\n\t\t\t\tfinal Class<?> entityClass = persistentClass.getMappedClass();\n\t\t\t\tif ( !entityClasses.add( entityClass ) ) {\n\t\t\t\t\t// this most likely means we have a class mapped multiple\n\t\t\t\t\t// times using the hbm.xml \"entity name\" feature\n\t\t\t\t\tif ( log.isDebugEnabled() ) {\n\t\t\t\t\t\tlog.debugf(\n\t\t\t\t\t\t\t\t\"Class [%s] already has callbacks registered; \" +\n\t\t\t\t\t\t\t\t\"assuming this means the class was mapped twice \" +\n\t\t\t\t\t\t\t\t\"(using hbm.xml entity-name support) - skipping subsequent registrations\" +\n\t\t\t\t\t\t\t\t\"to avoid duplicates\",\n\t\t\t\t\t\t\t\tentityClass.getName()\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tregisterAllCallbacks( persistentClass, registryBuilder, entityClass, beanRegistry );\n\t\t\t\t}\n\t\t\t}\n\t\t\t// else we can have dynamic (non-java class) mapping\n\t\t}\n\n\t\treturn registryBuilder.build();\n\t}\nprivate static void registerAllCallbacks(\n\t\t\tPersistentClass persistentClass,\n\t\t\tCallbackRegistryImpl.Builder registryBuilder,\n\t\t\tClass<?> entityClass,\n\t\t\tManagedBeanRegistry beanRegistry) {\n\t\tregistryBuilder.registerCallbacks( entityClass,\n\t\t\t\tbuildCallbacks( persistentClass.getCallbackDefinitions(), beanRegistry ) );\n\n\t\tfor ( Property property : persistentClass.getDeclaredProperties() ) {\n\t\t\tregistryBuilder.registerCallbacks( entityClass,\n\t\t\t\t\tbuildCallbacks( property.getCallbackDefinitions(), beanRegistry ) );\n\t\t}\n\t}",
        "diffSourceCode": "-   32: \tpublic static CallbackRegistry buildCallbackRegistry(SessionFactoryOptions options, ServiceRegistry serviceRegistry, Collection<PersistentClass> entityBindings) {\n-   33: \t\tif ( !jpaCallBacksEnabled( options ) ) {\n-   34: \t\t\treturn new EmptyCallbackRegistryImpl();\n-   35: \t\t}\n-   36: \t\tManagedBeanRegistry beanRegistry = serviceRegistry.getService( ManagedBeanRegistry.class );\n-   37: \t\tCallbackRegistryImpl.Builder registryBuilder = new CallbackRegistryImpl.Builder();\n-   38: \t\tSet<Class<?>> entityClasses = new HashSet<>();\n-   39: \n-   40: \t\tfor ( PersistentClass persistentClass : entityBindings ) {\n-   41: \t\t\tif ( persistentClass.getClassName() == null ) {\n-   42: \t\t\t\t// we can have dynamic (non-java class) mapping\n-   43: \t\t\t\tcontinue;\n-   44: \t\t\t}\n-   45: \n-   46: \t\t\tClass<?> entityClass = persistentClass.getMappedClass();\n-   47: \n-   48: \t\t\tif ( !entityClasses.add( entityClass ) ) {\n-   49: \t\t\t\t// this most likely means we have a class mapped multiple times using the hbm.xml\n-   50: \t\t\t\t// \"entity name\" feature\n-   51: \t\t\t\tif ( log.isDebugEnabled() ) {\n-   52: \t\t\t\t\tlog.debugf(\n-   53: \t\t\t\t\t\t\t\"Class [%s] already has callbacks registered; \" +\n-   54: \t\t\t\t\t\t\t\t\t\"assuming this means the class was mapped twice \" +\n-   55: \t\t\t\t\t\t\t\t\t\"(using hbm.xml entity-name support) - skipping subsequent registrations\" +\n-   56: \t\t\t\t\t\t\t\t\t\"to avoid duplicates\",\n-   57: \t\t\t\t\t\t\tentityClass.getName()\n-   58: \t\t\t\t\t);\n+   32: \tpublic static CallbackRegistry buildCallbackRegistry(\n+   33: \t\t\tSessionFactoryOptions options, ServiceRegistry serviceRegistry, Collection<PersistentClass> entityBindings) {\n+   34: \t\tif ( !options.areJPACallbacksEnabled() ) {\n+   35: \t\t\treturn new EmptyCallbackRegistryImpl();\n+   36: \t\t}\n+   37: \t\tfinal ManagedBeanRegistry beanRegistry = serviceRegistry.getService( ManagedBeanRegistry.class );\n+   38: \t\tfinal CallbackRegistryImpl.Builder registryBuilder = new CallbackRegistryImpl.Builder();\n+   39: \t\tfinal Set<Class<?>> entityClasses = new HashSet<>();\n+   40: \n+   41: \t\tfor ( PersistentClass persistentClass : entityBindings ) {\n+   42: \t\t\tif ( persistentClass.getClassName() != null ) {\n+   43: \t\t\t\tfinal Class<?> entityClass = persistentClass.getMappedClass();\n+   44: \t\t\t\tif ( !entityClasses.add( entityClass ) ) {\n+   45: \t\t\t\t\t// this most likely means we have a class mapped multiple\n+   46: \t\t\t\t\t// times using the hbm.xml \"entity name\" feature\n+   47: \t\t\t\t\tif ( log.isDebugEnabled() ) {\n+   48: \t\t\t\t\t\tlog.debugf(\n+   49: \t\t\t\t\t\t\t\t\"Class [%s] already has callbacks registered; \" +\n+   50: \t\t\t\t\t\t\t\t\"assuming this means the class was mapped twice \" +\n+   51: \t\t\t\t\t\t\t\t\"(using hbm.xml entity-name support) - skipping subsequent registrations\" +\n+   52: \t\t\t\t\t\t\t\t\"to avoid duplicates\",\n+   53: \t\t\t\t\t\t\t\tentityClass.getName()\n+   54: \t\t\t\t\t\t);\n+   55: \t\t\t\t\t}\n+   56: \t\t\t\t}\n+   57: \t\t\t\telse {\n+   58: \t\t\t\t\tregisterAllCallbacks( persistentClass, registryBuilder, entityClass, beanRegistry );\n    59: \t\t\t\t}\n-   60: \t\t\t\tcontinue;\n-   61: \t\t\t}\n-   62: \n-   63: \t\t\tregistryBuilder.registerCallbacks( persistentClass.getMappedClass(),\n-   64: \t\t\t\t\tbuildCallbacks( persistentClass.getCallbackDefinitions(), beanRegistry ) );\n-   65: \n-   66: \t\t\tfor ( Property property : persistentClass.getDeclaredProperties() ) {\n-   67: \t\t\t\tregistryBuilder.registerCallbacks( persistentClass.getMappedClass(),\n-   68: \t\t\t\t\t\tbuildCallbacks( property.getCallbackDefinitions(), beanRegistry ) );\n-   69: \t\t\t}\n-   70: \t\t}\n-   71: \n-   72: \t\treturn registryBuilder.build();\n-   73: \t}\n+   60: \t\t\t}\n+   61: \t\t\t// else we can have dynamic (non-java class) mapping\n+   62: \t\t}\n+   63: \n+   64: \t\treturn registryBuilder.build();\n+   65: \t}\n+   66: \n+   67: \tprivate static void registerAllCallbacks(\n+   68: \t\t\tPersistentClass persistentClass,\n+   69: \t\t\tCallbackRegistryImpl.Builder registryBuilder,\n+   70: \t\t\tClass<?> entityClass,\n+   71: \t\t\tManagedBeanRegistry beanRegistry) {\n+   72: \t\tregistryBuilder.registerCallbacks( entityClass,\n+   73: \t\t\t\tbuildCallbacks( persistentClass.getCallbackDefinitions(), beanRegistry ) );\n    74: \n-   75: \tprivate static Callback[] buildCallbacks(List<CallbackDefinition> callbackDefinitions,\n-   76: \t\t\tManagedBeanRegistry beanRegistry) {\n-   77: \t\tif ( callbackDefinitions == null || callbackDefinitions.isEmpty() ) {\n-   78: \t\t\treturn null;\n-   79: \t\t}\n+   75: \t\tfor ( Property property : persistentClass.getDeclaredProperties() ) {\n+   76: \t\t\tregistryBuilder.registerCallbacks( entityClass,\n+   77: \t\t\t\t\tbuildCallbacks( property.getCallbackDefinitions(), beanRegistry ) );\n+   78: \t\t}\n+   79: \t}\n",
        "uniqueId": "ddeaffc917fb82e84461691605baab7d12962cd2_32_73_67_79_32_65",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 6,
                "covered": 76
            },
            "BRANCH": {
                "missed": 1,
                "covered": 11
            },
            "LINE": {
                "missed": 2,
                "covered": 19
            },
            "COMPLEXITY": {
                "missed": 1,
                "covered": 6
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 21
    },
    {
        "type": "Extract And Move Method",
        "description": "Extract And Move Method\tpackage prefix(creationState DomainResultCreationStateImpl, elementPrefix String, indexPrefix String) : String extracted from public buildFetch(parent FetchParent, fetchPath NavigablePath, jdbcResultsMetadata JdbcValuesMetadata, domainResultCreationState DomainResultCreationState) : Fetch in class org.hibernate.query.results.internal.dynamic.DynamicFetchBuilderLegacy & moved to class org.hibernate.query.results.internal.dynamic.DynamicResultBuilderEntityStandard",
        "diffLocations": [
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/query/results/internal/dynamic/DynamicFetchBuilderLegacy.java",
                "startLine": 123,
                "endLine": 224,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/query/results/internal/dynamic/DynamicFetchBuilderLegacy.java",
                "startLine": 128,
                "endLine": 191,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/query/results/internal/dynamic/DynamicFetchBuilderLegacy.java",
                "startLine": 87,
                "endLine": 97,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "@Override\n\tpublic Fetch buildFetch(\n\t\t\tFetchParent parent,\n\t\t\tNavigablePath fetchPath,\n\t\t\tJdbcValuesMetadata jdbcResultsMetadata,\n\t\t\tDomainResultCreationState domainResultCreationState) {\n\t\tfinal DomainResultCreationStateImpl creationState = impl( domainResultCreationState );\n\t\tfinal TableGroup ownerTableGroup = creationState.getFromClauseAccess().findByAlias( ownerTableAlias );\n\t\tfinal AttributeMapping attributeMapping = parent.getReferencedMappingContainer()\n\t\t\t\t.findContainingEntityMapping()\n\t\t\t\t.findDeclaredAttributeMapping( fetchableName );\n\t\tfinal TableGroup tableGroup;\n\t\tif ( attributeMapping instanceof TableGroupJoinProducer ) {\n\t\t\tfinal SqlAliasBase sqlAliasBase = new SqlAliasBaseConstant( tableAlias );\n\t\t\tfinal TableGroupJoin tableGroupJoin = ( (TableGroupJoinProducer) attributeMapping ).createTableGroupJoin(\n\t\t\t\t\tfetchPath,\n\t\t\t\t\townerTableGroup,\n\t\t\t\t\ttableAlias,\n\t\t\t\t\tsqlAliasBase,\n\t\t\t\t\tSqlAstJoinType.INNER,\n\t\t\t\t\ttrue,\n\t\t\t\t\tfalse,\n\t\t\t\t\tcreationState\n\t\t\t);\n\t\t\townerTableGroup.addTableGroupJoin( tableGroupJoin );\n\t\t\tcreationState.getFromClauseAccess().registerTableGroup( fetchPath, tableGroup = tableGroupJoin.getJoinedGroup() );\n\t\t}\n\t\telse {\n\t\t\ttableGroup = ownerTableGroup;\n\t\t}\n\n\t\tif ( columnNames != null ) {\n\t\t\tfinal ForeignKeyDescriptor keyDescriptor;\n\t\t\tif ( attributeMapping instanceof PluralAttributeMapping pluralAttributeMapping ) {\n\t\t\t\tkeyDescriptor = pluralAttributeMapping.getKeyDescriptor();\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Not sure if this fetch builder can also be used with other attribute mappings\n\t\t\t\tassert attributeMapping instanceof ToOneAttributeMapping;\n\n\t\t\t\tfinal ToOneAttributeMapping toOneAttributeMapping = (ToOneAttributeMapping) attributeMapping;\n\t\t\t\tkeyDescriptor = toOneAttributeMapping.getForeignKeyDescriptor();\n\t\t\t}\n\n\t\t\tif ( !columnNames.isEmpty() ) {\n\t\t\t\tkeyDescriptor.forEachSelectable( (selectionIndex, selectableMapping) -> {\n\t\t\t\t\tresolveSqlSelection(\n\t\t\t\t\t\t\tcolumnNames.get( selectionIndex ),\n\t\t\t\t\t\t\ttableGroup.resolveTableReference(\n\t\t\t\t\t\t\t\t\tfetchPath,\n\t\t\t\t\t\t\t\t\tkeyDescriptor.getKeyPart(),\n\t\t\t\t\t\t\t\t\tselectableMapping.getContainingTableExpression()\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\tselectableMapping,\n\t\t\t\t\t\t\tjdbcResultsMetadata,\n\t\t\t\t\t\t\tdomainResultCreationState\n\t\t\t\t\t); }\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// We process the fetch builder such that it contains a resultBuilderEntity before calling this method in ResultSetMappingProcessor\n\t\t\tif ( resultBuilderEntity != null ) {\n\t\t\t\treturn resultBuilderEntity.buildFetch(\n\t\t\t\t\t\tparent,\n\t\t\t\t\t\tattributeMapping,\n\t\t\t\t\t\tjdbcResultsMetadata,\n\t\t\t\t\t\tcreationState\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\ttry {\n\t\t\tfinal Map.Entry<String, NavigablePath> currentRelativePath = creationState.getCurrentRelativePath();\n\t\t\tfinal String prefix;\n\t\t\tif ( currentRelativePath == null ) {\n\t\t\t\tprefix = \"\";\n\t\t\t}\n\t\t\telse {\n\t\t\t\tprefix = currentRelativePath.getKey()\n\t\t\t\t\t\t.replace( ELEMENT_PREFIX, \"\" )\n\t\t\t\t\t\t.replace( INDEX_PREFIX, \"\" ) + \".\";\n\t\t\t}\n\t\t\tcreationState.pushExplicitFetchMementoResolver(\n\t\t\t\t\trelativePath -> {\n\t\t\t\t\t\tif ( relativePath.startsWith( prefix ) ) {\n\t\t\t\t\t\t\treturn findFetchBuilder( relativePath.substring( prefix.length() ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t);\n\t\t\treturn parent.generateFetchableFetch(\n\t\t\t\t\tattributeMapping,\n\t\t\t\t\tparent.resolveNavigablePath( attributeMapping ),\n\t\t\t\t\tFetchTiming.IMMEDIATE,\n\t\t\t\t\ttrue,\n\t\t\t\t\tnull,\n\t\t\t\t\tdomainResultCreationState\n\t\t\t);\n\t\t}\n\t\tfinally {\n\t\t\tcreationState.popExplicitFetchMementoResolver();\n\t\t}\n\t}",
        "filePathBefore": "hibernate-core/src/main/java/org/hibernate/query/results/internal/dynamic/DynamicFetchBuilderLegacy.java",
        "isPureRefactoring": true,
        "commitId": "96cba56591e3e8c6dabaf35d954bd5911b1471ae",
        "packageNameBefore": "org.hibernate.query.results.internal.dynamic",
        "classNameBefore": "org.hibernate.query.results.internal.dynamic.DynamicFetchBuilderLegacy",
        "methodNameBefore": "org.hibernate.query.results.internal.dynamic.DynamicFetchBuilderLegacy#buildFetch",
        "invokedMethod": "methodSignature: org.hibernate.sql.results.graph.entity.internal.EntityResultImpl#resolveNavigablePath\n methodBody: public NavigablePath resolveNavigablePath(Fetchable fetchable) {\nif(fetchable instanceof TableGroupProducer){for(TableGroupJoin tableGroupJoin: tableGroup.getTableGroupJoins()){final NavigablePath navigablePath=tableGroupJoin.getNavigablePath();\nif(tableGroupJoin.getJoinedGroup().isFetched() && fetchable.getFetchableName().equals(navigablePath.getLocalName()) && tableGroupJoin.getJoinedGroup().getModelPart() == fetchable && castNonNull(navigablePath.getParent()).equals(getNavigablePath())){return navigablePath;\n}}}return super.resolveNavigablePath(fetchable);\n}\nmethodSignature: org.hibernate.query.results.internal.complete.CompleteFetchBuilderEntityValuedModelPart#buildFetch\n methodBody: public Fetch buildFetch(\n\t\t\tFetchParent parent,\n\t\t\tNavigablePath fetchPath,\n\t\t\tJdbcValuesMetadata jdbcResultsMetadata,\n\t\t\tDomainResultCreationState domainResultCreationState) {\nassert fetchPath.equals(navigablePath);\nfinal DomainResultCreationStateImpl creationStateImpl=impl(domainResultCreationState);\nfinal TableGroup tableGroup=creationStateImpl.getFromClauseAccess().getTableGroup(navigablePath.getParent());\nmodelPart.forEachSelectable((selectionIndex,selectableMapping) -> {\n  final TableReference tableReference=tableGroup.resolveTableReference(navigablePath,(ValuedModelPart)modelPart,selectableMapping.getContainingTableExpression());\n  final String columnAlias=columnAliases.get(selectionIndex);\n  creationStateImpl.resolveSqlSelection(ResultsHelper.resolveSqlExpression(creationStateImpl,jdbcResultsMetadata,tableReference,selectableMapping,columnAlias),selectableMapping.getJdbcMapping().getJdbcJavaType(),null,creationStateImpl.getSessionFactory().getTypeConfiguration());\n}\n);\nreturn parent.generateFetchableFetch(modelPart,fetchPath,FetchTiming.DELAYED,true,null,domainResultCreationState);\n}\nmethodSignature: org.hibernate.query.results.internal.complete.CompleteFetchBuilderEmbeddableValuedModelPart#buildFetch\n methodBody: public Fetch buildFetch(\n\t\t\tFetchParent parent,\n\t\t\tNavigablePath fetchPath,\n\t\t\tJdbcValuesMetadata jdbcResultsMetadata,\n\t\t\tDomainResultCreationState domainResultCreationState) {\nassert fetchPath.equals(navigablePath);\nfinal DomainResultCreationStateImpl creationStateImpl=impl(domainResultCreationState);\nfinal TableGroup tableGroup=creationStateImpl.getFromClauseAccess().getTableGroup(navigablePath.getParent());\nmodelPart.forEachSelectable((selectionIndex,selectableMapping) -> {\n  final TableReference tableReference=tableGroup.resolveTableReference(navigablePath,modelPart,selectableMapping.getContainingTableExpression());\n  final String columnAlias=columnAliases.get(selectionIndex);\n  creationStateImpl.resolveSqlSelection(ResultsHelper.resolveSqlExpression(creationStateImpl,jdbcResultsMetadata,tableReference,selectableMapping,columnAlias),selectableMapping.getJdbcMapping().getJdbcJavaType(),null,creationStateImpl.getSessionFactory().getTypeConfiguration());\n}\n);\nreturn parent.generateFetchableFetch(modelPart,fetchPath,FetchTiming.IMMEDIATE,true,null,domainResultCreationState);\n}\nmethodSignature: org.hibernate.query.results.internal.dynamic.AbstractFetchBuilderContainer#findFetchBuilder\n methodBody: public FetchBuilder findFetchBuilder(String fetchableName) {\nreturn fetchBuilderMap == null ? null : fetchBuilderMap.get(fetchableName);\n}\nmethodSignature: org.hibernate.query.results.internal.implicit.ImplicitFetchBuilderPlural#buildFetch\n methodBody: public Fetch buildFetch(\n\t\t\tFetchParent parent,\n\t\t\tNavigablePath fetchPath,\n\t\t\tJdbcValuesMetadata jdbcResultsMetadata,\n\t\t\tDomainResultCreationState creationState) {\nfinal Fetch fetch=parent.generateFetchableFetch(fetchable,fetchPath,fetchable.getMappedFetchOptions().getTiming(),false,null,creationState);\nreturn fetch;\n}\nmethodSignature: org.hibernate.query.results.internal.dynamic.DynamicFetchBuilderLegacy#findFetchBuilder\n methodBody: public FetchBuilder findFetchBuilder(String fetchableName) {\nreturn fetchBuilderMap.get(fetchableName);\n}\nmethodSignature: org.hibernate.query.results.internal.complete.CompleteFetchBuilderBasicPart#buildFetch\n methodBody: public BasicFetch<?> buildFetch(\n\t\t\tFetchParent parent,\n\t\t\tNavigablePath fetchPath,\n\t\t\tJdbcValuesMetadata jdbcResultsMetadata,\n\t\t\tDomainResultCreationState domainResultCreationState) {\nfinal DomainResultCreationStateImpl creationStateImpl=impl(domainResultCreationState);\nfinal String mappedTable=referencedModelPart.getContainingTableExpression();\nfinal TableGroup tableGroup=creationStateImpl.getFromClauseAccess().getTableGroup(parent.getNavigablePath());\nfinal TableReference tableReference=tableGroup.resolveTableReference(navigablePath,referencedModelPart,mappedTable);\nfinal String selectedAlias;\nfinal int jdbcPosition;\nif(selectionAlias != null){tryjdbcPosition=jdbcResultsMetadata.resolveColumnPosition(selectionAlias);\ncatch(Exception e)throw new MissingSqlSelectionException(\"ResultSet mapping specified selected-alias `\" + selectionAlias + \"` which was not part of the ResultSet\",e);\nselectedAlias=selectionAlias;\n}{if(!creationStateImpl.arePositionalSelectionsAllowed()){throw new AssertionFailure(\"Positional SQL selection resolution not allowed\");\n}jdbcPosition=creationStateImpl.getNumberOfProcessedSelections() + 1;\nselectedAlias=jdbcResultsMetadata.resolveColumnName(jdbcPosition);\n}final int valuesArrayPosition=jdbcPositionToValuesArrayPosition(jdbcPosition);\nfinal JdbcMapping jdbcMapping;\nif(referencedModelPart instanceof DiscriminatorMapping){jdbcMapping=((DiscriminatorMapping)referencedModelPart).getUnderlyingJdbcMapping();\n}{jdbcMapping=referencedModelPart.getJdbcMapping();\n}creationStateImpl.resolveSqlExpression(createColumnReferenceKey(tableReference,referencedModelPart.getSelectablePath(),jdbcMapping),processingState -> new ResultSetMappingSqlSelection(valuesArrayPosition,referencedModelPart));\nreturn (BasicFetch<?>)parent.generateFetchableFetch(referencedModelPart,fetchPath,FetchTiming.IMMEDIATE,true,selectedAlias,domainResultCreationState);\n}\nmethodSignature: org.hibernate.query.results.internal.dynamic.DynamicResultBuilderEntityStandard#buildFetch\n methodBody: public Fetch buildFetch(\n\t\t\tFetchParent parent,\n\t\t\tFetchable fetchable,\n\t\t\tJdbcValuesMetadata jdbcResultsMetadata,\n\t\t\tDomainResultCreationState domainResultCreationState) {\nreturn buildResultOrFetch((tableGroup) -> parent.generateFetchableFetch(fetchable,parent.resolveNavigablePath(fetchable),FetchTiming.IMMEDIATE,true,null,domainResultCreationState),fetchable,jdbcResultsMetadata,domainResultCreationState);\n}\nmethodSignature: org.hibernate.query.results.internal.implicit.ImplicitFetchBuilderEmbeddable#buildFetch\n methodBody: public Fetch buildFetch(\n\t\t\tFetchParent parent,\n\t\t\tNavigablePath fetchPath,\n\t\t\tJdbcValuesMetadata jdbcResultsMetadata,\n\t\t\tDomainResultCreationState creationState) {\nfinal DomainResultCreationStateImpl creationStateImpl=impl(creationState);\ncreationStateImpl.getFromClauseAccess().resolveTableGroup(fetchPath,navigablePath -> {\n  final TableGroup parentTableGroup=creationStateImpl.getFromClauseAccess().getTableGroup(parent.getNavigablePath());\n  final TableGroupJoin tableGroupJoin=fetchable.createTableGroupJoin(fetchPath,parentTableGroup,null,null,SqlAstJoinType.INNER,true,false,creationStateImpl);\n  parentTableGroup.addTableGroupJoin(tableGroupJoin);\n  return tableGroupJoin.getJoinedGroup();\n}\n);\nreturn parent.generateFetchableFetch(fetchable,fetchPath,FetchTiming.IMMEDIATE,true,null,creationState);\n}\nmethodSignature: org.hibernate.query.results.internal.ResultsHelper#impl\n methodBody: public static DomainResultCreationStateImpl impl(DomainResultCreationState creationState) {\nreturn unwrap(creationState);\n}\nmethodSignature: org.hibernate.query.results.internal.implicit.ImplicitAttributeFetchBuilder#buildFetch\n methodBody: public Fetch buildFetch(\n\t\t\tFetchParent parent,\n\t\t\tNavigablePath fetchPath,\n\t\t\tJdbcValuesMetadata jdbcResultsMetadata,\n\t\t\tDomainResultCreationState domainResultCreationState) {\nassert fetchPath.equals(navigablePath);\nreturn parent.generateFetchableFetch(attributeMapping,fetchPath,FetchTiming.IMMEDIATE,true,null,domainResultCreationState);\n}\nmethodSignature: org.hibernate.query.results.internal.dynamic.DynamicFetchBuilderLegacy#resolveSqlSelection\n methodBody: private void resolveSqlSelection(\n\t\t\tString columnAlias,\n\t\t\tTableReference tableReference,\n\t\t\tSelectableMapping selectableMapping,\n\t\t\tJdbcValuesMetadata jdbcResultsMetadata,\n\t\t\tDomainResultCreationState domainResultCreationState) {\nfinal DomainResultCreationStateImpl creationStateImpl=impl(domainResultCreationState);\ncreationStateImpl.resolveSqlSelection(ResultsHelper.resolveSqlExpression(creationStateImpl,jdbcResultsMetadata,tableReference,selectableMapping,columnAlias),selectableMapping.getJdbcMapping().getJdbcJavaType(),null,domainResultCreationState.getSqlAstCreationState().getCreationContext().getSessionFactory().getTypeConfiguration());\n}\nmethodSignature: org.hibernate.query.results.internal.dynamic.DynamicFetchBuilderLegacy#buildFetch\n methodBody: public Fetch buildFetch(\n\t\t\tFetchParent parent,\n\t\t\tNavigablePath fetchPath,\n\t\t\tJdbcValuesMetadata jdbcResultsMetadata,\n\t\t\tDomainResultCreationState domainResultCreationState) {\nfinal DomainResultCreationStateImpl creationState=impl(domainResultCreationState);\nfinal TableGroup ownerTableGroup=creationState.getFromClauseAccess().findByAlias(ownerTableAlias);\nfinal AttributeMapping attributeMapping=parent.getReferencedMappingContainer().findContainingEntityMapping().findDeclaredAttributeMapping(fetchableName);\nfinal TableGroup tableGroup;\nif(attributeMapping instanceof TableGroupJoinProducer){final SqlAliasBase sqlAliasBase=new SqlAliasBaseConstant(tableAlias);\nfinal TableGroupJoin tableGroupJoin=((TableGroupJoinProducer)attributeMapping).createTableGroupJoin(fetchPath,ownerTableGroup,tableAlias,sqlAliasBase,SqlAstJoinType.INNER,true,false,creationState);\nownerTableGroup.addTableGroupJoin(tableGroupJoin);\ncreationState.getFromClauseAccess().registerTableGroup(fetchPath,tableGroup=tableGroupJoin.getJoinedGroup());\n}{tableGroup=ownerTableGroup;\n}if(columnNames != null){final ForeignKeyDescriptor keyDescriptor;\nif(attributeMapping instanceof PluralAttributeMapping pluralAttributeMapping){keyDescriptor=pluralAttributeMapping.getKeyDescriptor();\n}{assert attributeMapping instanceof ToOneAttributeMapping;\nfinal ToOneAttributeMapping toOneAttributeMapping=(ToOneAttributeMapping)attributeMapping;\nkeyDescriptor=toOneAttributeMapping.getForeignKeyDescriptor();\n}if(!columnNames.isEmpty()){keyDescriptor.forEachSelectable((selectionIndex,selectableMapping) -> {\n  resolveSqlSelection(columnNames.get(selectionIndex),tableGroup.resolveTableReference(fetchPath,keyDescriptor.getKeyPart(),selectableMapping.getContainingTableExpression()),selectableMapping,jdbcResultsMetadata,domainResultCreationState);\n}\n);\n}if(resultBuilderEntity != null){return resultBuilderEntity.buildFetch(parent,attributeMapping,jdbcResultsMetadata,creationState);\n}}tryfinal Map.Entry<String,NavigablePath> currentRelativePath=creationState.getCurrentRelativePath();\nfinal String prefix;\nif(currentRelativePath == null){prefix=\"\";\n}{prefix=currentRelativePath.getKey().replace(ELEMENT_PREFIX,\"\").replace(INDEX_PREFIX,\"\") + \".\";\n}creationState.pushExplicitFetchMementoResolver(relativePath -> {\n  if (relativePath.startsWith(prefix)) {\n    return findFetchBuilder(relativePath.substring(prefix.length()));\n  }\n  return null;\n}\n);\nreturn parent.generateFetchableFetch(attributeMapping,parent.resolveNavigablePath(attributeMapping),FetchTiming.IMMEDIATE,true,null,domainResultCreationState);\nfinallycreationState.popExplicitFetchMementoResolver();\n}\nmethodSignature: org.hibernate.query.results.internal.implicit.ImplicitFetchBuilderEntity#buildFetch\n methodBody: public Fetch buildFetch(\n\t\t\tFetchParent parent,\n\t\t\tNavigablePath fetchPath,\n\t\t\tJdbcValuesMetadata jdbcResultsMetadata,\n\t\t\tDomainResultCreationState creationState) {\nreturn parent.generateFetchableFetch(fetchable,fetchPath,fetchable.getMappedFetchOptions().getTiming(),false,null,creationState);\n}\nmethodSignature: org.hibernate.query.results.internal.complete.DelayedFetchBuilderBasicPart#buildFetch\n methodBody: public BasicFetch<?> buildFetch(\n\t\t\tFetchParent parent,\n\t\t\tNavigablePath fetchPath,\n\t\t\tJdbcValuesMetadata jdbcResultsMetadata,\n\t\t\tDomainResultCreationState domainResultCreationState) {\nreturn new BasicFetch<>(-1,parent,fetchPath,referencedModelPart,null,FetchTiming.DELAYED,isEnhancedForLazyLoading,domainResultCreationState,false,false);\n}\nmethodSignature: org.hibernate.query.results.internal.implicit.ImplicitFetchBuilderBasic#buildFetch\n methodBody: public BasicFetch<?> buildFetch(\n\t\t\tFetchParent parent,\n\t\t\tNavigablePath fetchPath,\n\t\t\tJdbcValuesMetadata jdbcResultsMetadata,\n\t\t\tDomainResultCreationState domainResultCreationState) {\nif(fetchBuilder != null){return (BasicFetch<?>)fetchBuilder.buildFetch(parent,fetchPath,jdbcResultsMetadata,domainResultCreationState);\n}final DomainResultCreationStateImpl creationStateImpl=ResultsHelper.impl(domainResultCreationState);\nfinal TableGroup parentTableGroup=creationStateImpl.getFromClauseAccess().getTableGroup(parent.getNavigablePath());\nfinal String table=fetchable.getContainingTableExpression();\nfinal String column;\nif(fetchable.isFormula()){column=fetchable.getFetchableName();\n}{column=fetchable.getSelectionExpression();\n}final Expression expression=ResultsHelper.resolveSqlExpression(creationStateImpl,jdbcResultsMetadata,parentTableGroup.resolveTableReference(fetchPath,fetchable,table),fetchable,column);\nfinal SqlSelection sqlSelection=creationStateImpl.resolveSqlSelection(expression,fetchable.getJdbcMapping().getJdbcJavaType(),parent,domainResultCreationState.getSqlAstCreationState().getCreationContext().getSessionFactory().getTypeConfiguration());\nreturn new BasicFetch<>(sqlSelection.getValuesArrayPosition(),parent,fetchPath,fetchable,FetchTiming.IMMEDIATE,domainResultCreationState,!sqlSelection.isVirtual());\n}\nmethodSignature: org.hibernate.query.results.internal.dynamic.DynamicResultBuilderEntityStandard#resolveSqlSelection\n methodBody: private void resolveSqlSelection(\n\t\t\tString columnAlias,\n\t\t\tTableReference tableReference,\n\t\t\tSelectableMapping selectableMapping,\n\t\t\tJdbcValuesMetadata jdbcResultsMetadata,\n\t\t\tDomainResultCreationState domainResultCreationState) {\nfinal DomainResultCreationStateImpl creationStateImpl=impl(domainResultCreationState);\ncreationStateImpl.resolveSqlSelection(ResultsHelper.resolveSqlExpression(creationStateImpl,jdbcResultsMetadata,tableReference,selectableMapping,columnAlias),selectableMapping.getJdbcMapping().getJdbcJavaType(),null,domainResultCreationState.getSqlAstCreationState().getCreationContext().getSessionFactory().getTypeConfiguration());\n}\nmethodSignature: org.hibernate.query.results.internal.dynamic.DynamicFetchBuilderStandard#buildFetch\n methodBody: public Fetch buildFetch(\n\t\t\tFetchParent parent,\n\t\t\tNavigablePath fetchPath,\n\t\t\tJdbcValuesMetadata jdbcResultsMetadata,\n\t\t\tDomainResultCreationState domainResultCreationState) {\nfinal DomainResultCreationStateImpl creationStateImpl=ResultsHelper.impl(domainResultCreationState);\nfinal TableGroup ownerTableGroup=creationStateImpl.getFromClauseAccess().getTableGroup(parent.getNavigablePath());\nfinal Fetchable attributeMapping=(Fetchable)parent.getReferencedMappingContainer().findSubPart(fetchableName,null);\nfinal SqlExpressionResolver sqlExpressionResolver=domainResultCreationState.getSqlAstCreationState().getSqlExpressionResolver();\nfinal BasicValuedModelPart basicPart=attributeMapping.asBasicValuedModelPart();\nif(basicPart != null){attributeMapping.forEachSelectable(getSelectableConsumer(fetchPath,jdbcResultsMetadata,domainResultCreationState,creationStateImpl,ownerTableGroup,sqlExpressionResolver,basicPart));\nreturn parent.generateFetchableFetch(attributeMapping,fetchPath,FetchTiming.IMMEDIATE,true,null,creationStateImpl);\n}if(attributeMapping instanceof EmbeddableValuedFetchable){attributeMapping.forEachSelectable(getSelectableConsumer(fetchPath,jdbcResultsMetadata,domainResultCreationState,creationStateImpl,ownerTableGroup,sqlExpressionResolver,(EmbeddableValuedFetchable)attributeMapping));\nreturn parent.generateFetchableFetch(attributeMapping,fetchPath,FetchTiming.IMMEDIATE,false,null,creationStateImpl);\n}if(attributeMapping instanceof ToOneAttributeMapping toOneAttributeMapping){toOneAttributeMapping.getForeignKeyDescriptor().getPart(toOneAttributeMapping.getSideNature()).forEachSelectable(getSelectableConsumer(fetchPath,jdbcResultsMetadata,domainResultCreationState,creationStateImpl,ownerTableGroup,sqlExpressionResolver,toOneAttributeMapping.getForeignKeyDescriptor()));\nreturn parent.generateFetchableFetch(attributeMapping,fetchPath,attributeMapping.getMappedFetchOptions().getTiming(),false,null,creationStateImpl);\n}{assert attributeMapping instanceof PluralAttributeMapping;\nfinal PluralAttributeMapping pluralAttributeMapping=(PluralAttributeMapping)attributeMapping;\npluralAttributeMapping.getKeyDescriptor().visitTargetSelectables(getSelectableConsumer(fetchPath,jdbcResultsMetadata,domainResultCreationState,creationStateImpl,ownerTableGroup,sqlExpressionResolver,pluralAttributeMapping.getKeyDescriptor()));\nreturn parent.generateFetchableFetch(attributeMapping,fetchPath,attributeMapping.getMappedFetchOptions().getTiming(),false,null,creationStateImpl);\n}}\nmethodSignature: org.hibernate.query.results.internal.implicit.ImplicitFetchBuilderDiscriminatedAssociation#buildFetch\n methodBody: public Fetch buildFetch(\n\t\t\tFetchParent parent,\n\t\t\tNavigablePath fetchPath,\n\t\t\tJdbcValuesMetadata jdbcResultsMetadata,\n\t\t\tDomainResultCreationState creationState) {\nfinal DomainResultCreationStateImpl creationStateImpl=impl(creationState);\ncreationStateImpl.getFromClauseAccess().resolveTableGroup(fetchPath,navigablePath -> {\n  final TableGroup parentTableGroup=creationStateImpl.getFromClauseAccess().getTableGroup(parent.getNavigablePath());\n  final TableGroupJoin tableGroupJoin=fetchable.createTableGroupJoin(fetchPath,parentTableGroup,null,null,SqlAstJoinType.INNER,true,false,creationStateImpl);\n  parentTableGroup.addTableGroupJoin(tableGroupJoin);\n  return tableGroupJoin.getJoinedGroup();\n}\n);\nreturn parent.generateFetchableFetch(fetchable,fetchPath,fetchable.getTiming(),false,null,creationState);\n}\nmethodSignature: org.hibernate.query.results.internal.implicit.ImplicitFetchBuilderEntityPart#buildFetch\n methodBody: public Fetch buildFetch(\n\t\t\tFetchParent parent,\n\t\t\tNavigablePath fetchPath,\n\t\t\tJdbcValuesMetadata jdbcResultsMetadata,\n\t\t\tDomainResultCreationState creationState) {\nreturn parent.generateFetchableFetch(fetchable,fetchPath,FetchTiming.IMMEDIATE,true,null,creationState);\n}",
        "classSignatureBefore": "public class DynamicFetchBuilderLegacy\n\t\timplements LegacyFetchBuilder, DynamicFetchBuilder, NativeQuery.FetchReturn, NativeQuery.ReturnableResultNode, DynamicFetchBuilderContainer ",
        "methodNameBeforeSet": [
            "org.hibernate.query.results.internal.dynamic.DynamicFetchBuilderLegacy#buildFetch"
        ],
        "classNameBeforeSet": [
            "org.hibernate.query.results.internal.dynamic.DynamicFetchBuilderLegacy"
        ],
        "classSignatureBeforeSet": [
            "public class DynamicFetchBuilderLegacy\n\t\timplements LegacyFetchBuilder, DynamicFetchBuilder, NativeQuery.FetchReturn, NativeQuery.ReturnableResultNode, DynamicFetchBuilderContainer "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Changes are within the Extract Method refactoring mechanics",
                "description": "All replacements have been justified - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * SPDX-License-Identifier: LGPL-2.1-or-later\n * Copyright Red Hat Inc. and Hibernate Authors\n */\npackage org.hibernate.query.results.internal.dynamic;\n\nimport org.hibernate.LockMode;\nimport org.hibernate.engine.FetchTiming;\nimport org.hibernate.metamodel.mapping.AttributeMapping;\nimport org.hibernate.metamodel.mapping.CollectionPart;\nimport org.hibernate.metamodel.mapping.ForeignKeyDescriptor;\nimport org.hibernate.metamodel.mapping.PluralAttributeMapping;\nimport org.hibernate.metamodel.mapping.SelectableMapping;\nimport org.hibernate.metamodel.mapping.internal.ToOneAttributeMapping;\nimport org.hibernate.query.NativeQuery;\nimport org.hibernate.query.results.FetchBuilder;\nimport org.hibernate.query.results.LegacyFetchBuilder;\nimport org.hibernate.query.results.internal.DomainResultCreationStateImpl;\nimport org.hibernate.query.results.internal.ResultsHelper;\nimport org.hibernate.spi.NavigablePath;\nimport org.hibernate.sql.ast.SqlAstJoinType;\nimport org.hibernate.sql.ast.spi.SqlAliasBase;\nimport org.hibernate.sql.ast.spi.SqlAliasBaseConstant;\nimport org.hibernate.sql.ast.tree.from.TableGroup;\nimport org.hibernate.sql.ast.tree.from.TableGroupJoin;\nimport org.hibernate.sql.ast.tree.from.TableGroupJoinProducer;\nimport org.hibernate.sql.ast.tree.from.TableReference;\nimport org.hibernate.sql.results.graph.DomainResultCreationState;\nimport org.hibernate.sql.results.graph.Fetch;\nimport org.hibernate.sql.results.graph.FetchParent;\nimport org.hibernate.sql.results.jdbc.spi.JdbcValuesMetadata;\n\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.function.BiConsumer;\n\nimport static org.hibernate.query.results.internal.ResultsHelper.impl;\n\n/**\n * @author Steve Ebersole\n * @author Christian Beikov\n */\npublic class DynamicFetchBuilderLegacy\n\t\timplements LegacyFetchBuilder, DynamicFetchBuilder, NativeQuery.FetchReturn, NativeQuery.ReturnableResultNode, DynamicFetchBuilderContainer {\n\n\tprivate static final String ELEMENT_PREFIX = CollectionPart.Nature.ELEMENT.getName() + \".\";\n\tprivate static final String INDEX_PREFIX = CollectionPart.Nature.INDEX.getName() + \".\";\n\n\tprivate final String tableAlias;\n\n\tprivate final String ownerTableAlias;\n\tprivate final String fetchableName;\n\n\tprivate final List<String> columnNames;\n\tprivate final Map<String, FetchBuilder> fetchBuilderMap;\n\tprivate final DynamicResultBuilderEntityStandard resultBuilderEntity;\n\n\tprivate LockMode lockMode;\n\n\tpublic DynamicFetchBuilderLegacy(\n\t\t\tString tableAlias,\n\t\t\tString ownerTableAlias,\n\t\t\tString fetchableName,\n\t\t\tList<String> columnNames,\n\t\t\tMap<String, FetchBuilder> fetchBuilderMap) {\n\t\tthis( tableAlias, ownerTableAlias, fetchableName, columnNames, fetchBuilderMap, null );\n\t}\n\n\tpublic DynamicFetchBuilderLegacy(\n\t\t\tString tableAlias,\n\t\t\tString ownerTableAlias,\n\t\t\tString fetchableName,\n\t\t\tList<String> columnNames,\n\t\t\tMap<String, FetchBuilder> fetchBuilderMap,\n\t\t\tDynamicResultBuilderEntityStandard resultBuilderEntity) {\n\t\tthis.tableAlias = tableAlias;\n\t\tthis.ownerTableAlias = ownerTableAlias;\n\t\tthis.fetchableName = fetchableName;\n\t\tthis.columnNames = columnNames;\n\t\tthis.fetchBuilderMap = fetchBuilderMap;\n\t\tthis.resultBuilderEntity = resultBuilderEntity;\n\t}\n\n\t@Override\n\tpublic String getTableAlias() {\n\t\treturn tableAlias;\n\t}\n\n\t@Override\n\tpublic String getOwnerAlias() {\n\t\treturn ownerTableAlias;\n\t}\n\n\t@Override\n\tpublic String getFetchableName() {\n\t\treturn fetchableName;\n\t}\n\n\t@Override\n\tpublic DynamicFetchBuilderLegacy cacheKeyInstance() {\n\t\tfinal Map<String, FetchBuilder> fetchBuilderMap;\n\t\tif ( this.fetchBuilderMap == null ) {\n\t\t\tfetchBuilderMap = null;\n\t\t}\n\t\telse {\n\t\t\tfetchBuilderMap = new HashMap<>( this.fetchBuilderMap.size() );\n\t\t\tfor ( Map.Entry<String, FetchBuilder> entry : this.fetchBuilderMap.entrySet() ) {\n\t\t\t\tfetchBuilderMap.put( entry.getKey(), entry.getValue().cacheKeyInstance() );\n\t\t\t}\n\t\t}\n\t\treturn new DynamicFetchBuilderLegacy(\n\t\t\t\ttableAlias,\n\t\t\t\townerTableAlias,\n\t\t\t\tfetchableName,\n\t\t\t\tcolumnNames == null ? null : List.copyOf( columnNames ),\n\t\t\t\tfetchBuilderMap,\n\t\t\t\tresultBuilderEntity == null ? null : resultBuilderEntity.cacheKeyInstance()\n\t\t);\n\t}\n\n\t@Override\n\tpublic Fetch buildFetch(\n\t\t\tFetchParent parent,\n\t\t\tNavigablePath fetchPath,\n\t\t\tJdbcValuesMetadata jdbcResultsMetadata,\n\t\t\tDomainResultCreationState domainResultCreationState) {\n\t\tfinal DomainResultCreationStateImpl creationState = impl( domainResultCreationState );\n\t\tfinal TableGroup ownerTableGroup = creationState.getFromClauseAccess().findByAlias( ownerTableAlias );\n\t\tfinal AttributeMapping attributeMapping = parent.getReferencedMappingContainer()\n\t\t\t\t.findContainingEntityMapping()\n\t\t\t\t.findDeclaredAttributeMapping( fetchableName );\n\t\tfinal TableGroup tableGroup;\n\t\tif ( attributeMapping instanceof TableGroupJoinProducer ) {\n\t\t\tfinal SqlAliasBase sqlAliasBase = new SqlAliasBaseConstant( tableAlias );\n\t\t\tfinal TableGroupJoin tableGroupJoin = ( (TableGroupJoinProducer) attributeMapping ).createTableGroupJoin(\n\t\t\t\t\tfetchPath,\n\t\t\t\t\townerTableGroup,\n\t\t\t\t\ttableAlias,\n\t\t\t\t\tsqlAliasBase,\n\t\t\t\t\tSqlAstJoinType.INNER,\n\t\t\t\t\ttrue,\n\t\t\t\t\tfalse,\n\t\t\t\t\tcreationState\n\t\t\t);\n\t\t\townerTableGroup.addTableGroupJoin( tableGroupJoin );\n\t\t\tcreationState.getFromClauseAccess().registerTableGroup( fetchPath, tableGroup = tableGroupJoin.getJoinedGroup() );\n\t\t}\n\t\telse {\n\t\t\ttableGroup = ownerTableGroup;\n\t\t}\n\n\t\tif ( columnNames != null ) {\n\t\t\tfinal ForeignKeyDescriptor keyDescriptor;\n\t\t\tif ( attributeMapping instanceof PluralAttributeMapping pluralAttributeMapping ) {\n\t\t\t\tkeyDescriptor = pluralAttributeMapping.getKeyDescriptor();\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Not sure if this fetch builder can also be used with other attribute mappings\n\t\t\t\tassert attributeMapping instanceof ToOneAttributeMapping;\n\n\t\t\t\tfinal ToOneAttributeMapping toOneAttributeMapping = (ToOneAttributeMapping) attributeMapping;\n\t\t\t\tkeyDescriptor = toOneAttributeMapping.getForeignKeyDescriptor();\n\t\t\t}\n\n\t\t\tif ( !columnNames.isEmpty() ) {\n\t\t\t\tkeyDescriptor.forEachSelectable( (selectionIndex, selectableMapping) -> {\n\t\t\t\t\tresolveSqlSelection(\n\t\t\t\t\t\t\tcolumnNames.get( selectionIndex ),\n\t\t\t\t\t\t\ttableGroup.resolveTableReference(\n\t\t\t\t\t\t\t\t\tfetchPath,\n\t\t\t\t\t\t\t\t\tkeyDescriptor.getKeyPart(),\n\t\t\t\t\t\t\t\t\tselectableMapping.getContainingTableExpression()\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\tselectableMapping,\n\t\t\t\t\t\t\tjdbcResultsMetadata,\n\t\t\t\t\t\t\tdomainResultCreationState\n\t\t\t\t\t); }\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// We process the fetch builder such that it contains a resultBuilderEntity before calling this method in ResultSetMappingProcessor\n\t\t\tif ( resultBuilderEntity != null ) {\n\t\t\t\treturn resultBuilderEntity.buildFetch(\n\t\t\t\t\t\tparent,\n\t\t\t\t\t\tattributeMapping,\n\t\t\t\t\t\tjdbcResultsMetadata,\n\t\t\t\t\t\tcreationState\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\ttry {\n\t\t\tfinal Map.Entry<String, NavigablePath> currentRelativePath = creationState.getCurrentRelativePath();\n\t\t\tfinal String prefix;\n\t\t\tif ( currentRelativePath == null ) {\n\t\t\t\tprefix = \"\";\n\t\t\t}\n\t\t\telse {\n\t\t\t\tprefix = currentRelativePath.getKey()\n\t\t\t\t\t\t.replace( ELEMENT_PREFIX, \"\" )\n\t\t\t\t\t\t.replace( INDEX_PREFIX, \"\" ) + \".\";\n\t\t\t}\n\t\t\tcreationState.pushExplicitFetchMementoResolver(\n\t\t\t\t\trelativePath -> {\n\t\t\t\t\t\tif ( relativePath.startsWith( prefix ) ) {\n\t\t\t\t\t\t\treturn findFetchBuilder( relativePath.substring( prefix.length() ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t);\n\t\t\treturn parent.generateFetchableFetch(\n\t\t\t\t\tattributeMapping,\n\t\t\t\t\tparent.resolveNavigablePath( attributeMapping ),\n\t\t\t\t\tFetchTiming.IMMEDIATE,\n\t\t\t\t\ttrue,\n\t\t\t\t\tnull,\n\t\t\t\t\tdomainResultCreationState\n\t\t\t);\n\t\t}\n\t\tfinally {\n\t\t\tcreationState.popExplicitFetchMementoResolver();\n\t\t}\n\t}\n\n\tprivate void resolveSqlSelection(\n\t\t\tString columnAlias,\n\t\t\tTableReference tableReference,\n\t\t\tSelectableMapping selectableMapping,\n\t\t\tJdbcValuesMetadata jdbcResultsMetadata,\n\t\t\tDomainResultCreationState domainResultCreationState) {\n\t\tfinal DomainResultCreationStateImpl creationStateImpl = impl( domainResultCreationState );\n\t\tcreationStateImpl.resolveSqlSelection(\n\t\t\t\tResultsHelper.resolveSqlExpression(\n\t\t\t\t\t\tcreationStateImpl,\n\t\t\t\t\t\tjdbcResultsMetadata,\n\t\t\t\t\t\ttableReference,\n\t\t\t\t\t\tselectableMapping,\n\t\t\t\t\t\tcolumnAlias\n\t\t\t\t),\n\t\t\t\tselectableMapping.getJdbcMapping().getJdbcJavaType(),\n\t\t\t\tnull,\n\t\t\t\tdomainResultCreationState.getSqlAstCreationState()\n\t\t\t\t\t\t.getCreationContext()\n\t\t\t\t\t\t.getSessionFactory()\n\t\t\t\t\t\t.getTypeConfiguration()\n\t\t);\n\t}\n\n\t@Override\n\tpublic NativeQuery.ReturnProperty addColumnAlias(String columnAlias) {\n\t\tcolumnNames.add( columnAlias );\n\t\treturn this;\n\t}\n\n\t@Override\n\tpublic List<String> getColumnAliases() {\n\t\treturn columnNames;\n\t}\n\n\t@Override\n\tpublic NativeQuery.FetchReturn setLockMode(LockMode lockMode) {\n\t\tthis.lockMode = lockMode;\n\t\treturn this;\n\t}\n\n\t@Override\n\tpublic DynamicFetchBuilderLegacy addProperty(String propertyName, String columnAlias) {\n\t\taddProperty( propertyName ).addColumnAlias( columnAlias );\n\t\treturn this;\n\t}\n\n\t@Override\n\tpublic DynamicFetchBuilder addProperty(String propertyName) {\n\t\tDynamicFetchBuilderStandard fetchBuilder = new DynamicFetchBuilderStandard( propertyName );\n\t\tfetchBuilderMap.put( propertyName, fetchBuilder );\n\t\treturn fetchBuilder;\n\t}\n\n\t@Override\n\tpublic FetchBuilder findFetchBuilder(String fetchableName) {\n\t\treturn fetchBuilderMap.get( fetchableName );\n\t}\n\n\t@Override\n\tpublic DynamicFetchBuilderContainer addProperty(String propertyName, String... columnAliases) {\n\t\tfinal DynamicFetchBuilder fetchBuilder = addProperty( propertyName );\n\t\tfor ( String columnAlias : columnAliases ) {\n\t\t\tfetchBuilder.addColumnAlias( columnAlias );\n\t\t}\n\t\treturn this;\n\t}\n\n\t@Override\n\tpublic void addFetchBuilder(String propertyName, FetchBuilder fetchBuilder) {\n\t\tfetchBuilderMap.put( propertyName, fetchBuilder );\n\t}\n\n\t@Override\n\tpublic void visitFetchBuilders(BiConsumer<String, FetchBuilder> consumer) {\n\t\tfetchBuilderMap.forEach( consumer );\n\t}\n\n\t@Override\n\tpublic boolean equals(Object o) {\n\t\tif ( this == o ) {\n\t\t\treturn true;\n\t\t}\n\t\tif ( o == null || getClass() != o.getClass() ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tfinal DynamicFetchBuilderLegacy that = (DynamicFetchBuilderLegacy) o;\n\t\treturn tableAlias.equals( that.tableAlias )\n\t\t\t\t&& ownerTableAlias.equals( that.ownerTableAlias )\n\t\t\t\t&& fetchableName.equals( that.fetchableName )\n\t\t\t\t&& Objects.equals( columnNames, that.columnNames )\n\t\t\t\t&& Objects.equals( fetchBuilderMap, that.fetchBuilderMap )\n\t\t\t\t&& Objects.equals( resultBuilderEntity, that.resultBuilderEntity );\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\tint result = tableAlias.hashCode();\n\t\tresult = 31 * result + ownerTableAlias.hashCode();\n\t\tresult = 31 * result + fetchableName.hashCode();\n\t\tresult = 31 * result + ( columnNames != null ? columnNames.hashCode() : 0 );\n\t\tresult = 31 * result + ( fetchBuilderMap != null ? fetchBuilderMap.hashCode() : 0 );\n\t\tresult = 31 * result + ( resultBuilderEntity != null ? resultBuilderEntity.hashCode() : 0 );\n\t\treturn result;\n\t}\n}\n",
        "filePathAfter": "hibernate-core/src/main/java/org/hibernate/query/results/internal/dynamic/DynamicFetchBuilderLegacy.java",
        "sourceCodeAfterForWhole": "/*\n * SPDX-License-Identifier: LGPL-2.1-or-later\n * Copyright Red Hat Inc. and Hibernate Authors\n */\npackage org.hibernate.query.results.internal.dynamic;\n\nimport org.hibernate.AssertionFailure;\nimport org.hibernate.LockMode;\nimport org.hibernate.engine.FetchTiming;\nimport org.hibernate.metamodel.mapping.AttributeMapping;\nimport org.hibernate.metamodel.mapping.CollectionPart;\nimport org.hibernate.metamodel.mapping.ForeignKeyDescriptor;\nimport org.hibernate.metamodel.mapping.PluralAttributeMapping;\nimport org.hibernate.metamodel.mapping.SelectableMapping;\nimport org.hibernate.metamodel.mapping.internal.ToOneAttributeMapping;\nimport org.hibernate.query.NativeQuery;\nimport org.hibernate.query.results.FetchBuilder;\nimport org.hibernate.query.results.LegacyFetchBuilder;\nimport org.hibernate.query.results.internal.DomainResultCreationStateImpl;\nimport org.hibernate.query.results.internal.ResultsHelper;\nimport org.hibernate.spi.NavigablePath;\nimport org.hibernate.sql.ast.SqlAstJoinType;\nimport org.hibernate.sql.ast.spi.SqlAliasBase;\nimport org.hibernate.sql.ast.spi.SqlAliasBaseConstant;\nimport org.hibernate.sql.ast.tree.from.TableGroup;\nimport org.hibernate.sql.ast.tree.from.TableGroupJoin;\nimport org.hibernate.sql.ast.tree.from.TableGroupJoinProducer;\nimport org.hibernate.sql.ast.tree.from.TableReference;\nimport org.hibernate.sql.results.graph.DomainResultCreationState;\nimport org.hibernate.sql.results.graph.Fetch;\nimport org.hibernate.sql.results.graph.FetchParent;\nimport org.hibernate.sql.results.jdbc.spi.JdbcValuesMetadata;\n\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.function.BiConsumer;\n\nimport static org.hibernate.query.results.internal.ResultsHelper.impl;\n\n/**\n * @author Steve Ebersole\n * @author Christian Beikov\n */\npublic class DynamicFetchBuilderLegacy\n\t\timplements LegacyFetchBuilder, DynamicFetchBuilder,\n\t\t\t\tNativeQuery.FetchReturn, NativeQuery.ReturnableResultNode, DynamicFetchBuilderContainer {\n\n\tprivate static final String ELEMENT_PREFIX = CollectionPart.Nature.ELEMENT.getName() + \".\";\n\tprivate static final String INDEX_PREFIX = CollectionPart.Nature.INDEX.getName() + \".\";\n\n\tprivate final String tableAlias;\n\n\tprivate final String ownerTableAlias;\n\tprivate final String fetchableName;\n\n\tprivate final List<String> columnNames;\n\tprivate final Map<String, FetchBuilder> fetchBuilderMap;\n\tprivate final DynamicResultBuilderEntityStandard resultBuilderEntity;\n\n\tprivate LockMode lockMode;\n\n\tpublic DynamicFetchBuilderLegacy(\n\t\t\tString tableAlias,\n\t\t\tString ownerTableAlias,\n\t\t\tString fetchableName,\n\t\t\tList<String> columnNames,\n\t\t\tMap<String, FetchBuilder> fetchBuilderMap) {\n\t\tthis( tableAlias, ownerTableAlias, fetchableName, columnNames, fetchBuilderMap, null );\n\t}\n\n\tpublic DynamicFetchBuilderLegacy(\n\t\t\tString tableAlias,\n\t\t\tString ownerTableAlias,\n\t\t\tString fetchableName,\n\t\t\tList<String> columnNames,\n\t\t\tMap<String, FetchBuilder> fetchBuilderMap,\n\t\t\tDynamicResultBuilderEntityStandard resultBuilderEntity) {\n\t\tthis.tableAlias = tableAlias;\n\t\tthis.ownerTableAlias = ownerTableAlias;\n\t\tthis.fetchableName = fetchableName;\n\t\tthis.columnNames = columnNames;\n\t\tthis.fetchBuilderMap = fetchBuilderMap;\n\t\tthis.resultBuilderEntity = resultBuilderEntity;\n\t}\n\n\t@Override\n\tpublic String getTableAlias() {\n\t\treturn tableAlias;\n\t}\n\n\t@Override\n\tpublic String getOwnerAlias() {\n\t\treturn ownerTableAlias;\n\t}\n\n\t@Override\n\tpublic String getFetchableName() {\n\t\treturn fetchableName;\n\t}\n\n\t@Override\n\tpublic DynamicFetchBuilderLegacy cacheKeyInstance() {\n\t\treturn new DynamicFetchBuilderLegacy(\n\t\t\t\ttableAlias,\n\t\t\t\townerTableAlias,\n\t\t\t\tfetchableName,\n\t\t\t\tcolumnNames == null ? null : List.copyOf( columnNames ),\n\t\t\t\tfetchBuilderMap(),\n\t\t\t\tresultBuilderEntity == null ? null : resultBuilderEntity.cacheKeyInstance()\n\t\t);\n\t}\n\n\tprivate Map<String, FetchBuilder> fetchBuilderMap() {\n\t\tif ( this.fetchBuilderMap == null ) {\n\t\t\treturn null;\n\t\t}\n\t\telse {\n\t\t\tfinal Map<String, FetchBuilder> fetchBuilderMap = new HashMap<>( this.fetchBuilderMap.size() );\n\t\t\tfor ( Map.Entry<String, FetchBuilder> entry : this.fetchBuilderMap.entrySet() ) {\n\t\t\t\tfetchBuilderMap.put( entry.getKey(), entry.getValue().cacheKeyInstance() );\n\t\t\t}\n\t\t\treturn fetchBuilderMap;\n\t\t}\n\t}\n\n\t@Override\n\tpublic Fetch buildFetch(\n\t\t\tFetchParent parent,\n\t\t\tNavigablePath fetchPath,\n\t\t\tJdbcValuesMetadata jdbcResultsMetadata,\n\t\t\tDomainResultCreationState domainResultCreationState) {\n\t\tfinal DomainResultCreationStateImpl creationState = impl( domainResultCreationState );\n\t\tfinal TableGroup ownerTableGroup = creationState.getFromClauseAccess().findByAlias( ownerTableAlias );\n\t\tfinal AttributeMapping attributeMapping =\n\t\t\t\tparent.getReferencedMappingContainer().findContainingEntityMapping()\n\t\t\t\t\t\t.findDeclaredAttributeMapping( fetchableName );\n\t\tfinal TableGroup tableGroup = tableGroup( fetchPath, attributeMapping, ownerTableGroup, creationState );\n\n\t\tif ( columnNames != null ) {\n\t\t\tfinal ForeignKeyDescriptor keyDescriptor = getForeignKeyDescriptor( attributeMapping );\n\t\t\tif ( !columnNames.isEmpty() ) {\n\t\t\t\tkeyDescriptor.forEachSelectable( (selectionIndex, selectableMapping) -> {\n\t\t\t\t\tresolveSqlSelection(\n\t\t\t\t\t\t\tcolumnNames.get( selectionIndex ),\n\t\t\t\t\t\t\ttableGroup.resolveTableReference(\n\t\t\t\t\t\t\t\t\tfetchPath,\n\t\t\t\t\t\t\t\t\tkeyDescriptor.getKeyPart(),\n\t\t\t\t\t\t\t\t\tselectableMapping.getContainingTableExpression()\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\tselectableMapping,\n\t\t\t\t\t\t\tjdbcResultsMetadata,\n\t\t\t\t\t\t\tdomainResultCreationState\n\t\t\t\t\t); }\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// We process the fetch builder such that it contains a resultBuilderEntity before calling this method in ResultSetMappingProcessor\n\t\t\tif ( resultBuilderEntity != null ) {\n\t\t\t\treturn resultBuilderEntity.buildFetch(\n\t\t\t\t\t\tparent,\n\t\t\t\t\t\tattributeMapping,\n\t\t\t\t\t\tjdbcResultsMetadata,\n\t\t\t\t\t\tcreationState\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\ttry {\n\t\t\tfinal String prefix = DynamicResultBuilderEntityStandard.prefix( creationState, ELEMENT_PREFIX, INDEX_PREFIX );\n\t\t\tcreationState.pushExplicitFetchMementoResolver(\n\t\t\t\t\trelativePath -> {\n\t\t\t\t\t\tif ( relativePath.startsWith( prefix ) ) {\n\t\t\t\t\t\t\treturn findFetchBuilder( relativePath.substring( prefix.length() ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t);\n\t\t\treturn parent.generateFetchableFetch(\n\t\t\t\t\tattributeMapping,\n\t\t\t\t\tparent.resolveNavigablePath( attributeMapping ),\n\t\t\t\t\tFetchTiming.IMMEDIATE,\n\t\t\t\t\ttrue,\n\t\t\t\t\tnull,\n\t\t\t\t\tdomainResultCreationState\n\t\t\t);\n\t\t}\n\t\tfinally {\n\t\t\tcreationState.popExplicitFetchMementoResolver();\n\t\t}\n\t}\n\n\tprivate TableGroup tableGroup(\n\t\t\tNavigablePath fetchPath,\n\t\t\tAttributeMapping attributeMapping,\n\t\t\tTableGroup ownerTableGroup,\n\t\t\tDomainResultCreationStateImpl creationState) {\n\t\tif ( attributeMapping instanceof TableGroupJoinProducer tableGroupJoinProducer ) {\n\t\t\tfinal TableGroupJoin tableGroupJoin = tableGroupJoinProducer.createTableGroupJoin(\n\t\t\t\t\tfetchPath,\n\t\t\t\t\townerTableGroup,\n\t\t\t\t\ttableAlias,\n\t\t\t\t\tnew SqlAliasBaseConstant( tableAlias ),\n\t\t\t\t\tSqlAstJoinType.INNER,\n\t\t\t\t\ttrue,\n\t\t\t\t\tfalse,\n\t\t\t\t\tcreationState\n\t\t\t);\n\t\t\townerTableGroup.addTableGroupJoin( tableGroupJoin );\n\t\t\tfinal TableGroup tableGroup = tableGroupJoin.getJoinedGroup();\n\t\t\tcreationState.getFromClauseAccess().registerTableGroup( fetchPath, tableGroup );\n\t\t\treturn tableGroup;\n\t\t}\n\t\telse {\n\t\t\treturn ownerTableGroup;\n\t\t}\n\t}\n\n\tprivate static ForeignKeyDescriptor getForeignKeyDescriptor(AttributeMapping attributeMapping) {\n\t\tif ( attributeMapping instanceof PluralAttributeMapping pluralAttributeMapping ) {\n\t\t\treturn pluralAttributeMapping.getKeyDescriptor();\n\t\t}\n\t\telse if ( attributeMapping instanceof ToOneAttributeMapping toOneAttributeMapping ) {\n\t\t\treturn toOneAttributeMapping.getForeignKeyDescriptor();\n\t\t}\n\t\telse {\n\t\t\t// Not sure if this fetch builder can also be used with other attribute mappings\n\t\t\tthrow new AssertionFailure( \"Unrecognized AttributeMapping\" );\n\t\t}\n\t}\n\n\tprivate void resolveSqlSelection(\n\t\t\tString columnAlias,\n\t\t\tTableReference tableReference,\n\t\t\tSelectableMapping selectableMapping,\n\t\t\tJdbcValuesMetadata jdbcResultsMetadata,\n\t\t\tDomainResultCreationState domainResultCreationState) {\n\t\tfinal DomainResultCreationStateImpl creationStateImpl = impl( domainResultCreationState );\n\t\tcreationStateImpl.resolveSqlSelection(\n\t\t\t\tResultsHelper.resolveSqlExpression(\n\t\t\t\t\t\tcreationStateImpl,\n\t\t\t\t\t\tjdbcResultsMetadata,\n\t\t\t\t\t\ttableReference,\n\t\t\t\t\t\tselectableMapping,\n\t\t\t\t\t\tcolumnAlias\n\t\t\t\t),\n\t\t\t\tselectableMapping.getJdbcMapping().getJdbcJavaType(),\n\t\t\t\tnull,\n\t\t\t\tdomainResultCreationState.getSqlAstCreationState().getCreationContext()\n\t\t\t\t\t\t.getSessionFactory().getTypeConfiguration()\n\t\t);\n\t}\n\n\t@Override\n\tpublic NativeQuery.ReturnProperty addColumnAlias(String columnAlias) {\n\t\tcolumnNames.add( columnAlias );\n\t\treturn this;\n\t}\n\n\t@Override\n\tpublic List<String> getColumnAliases() {\n\t\treturn columnNames;\n\t}\n\n\t@Override\n\tpublic NativeQuery.FetchReturn setLockMode(LockMode lockMode) {\n\t\tthis.lockMode = lockMode;\n\t\treturn this;\n\t}\n\n\t@Override\n\tpublic DynamicFetchBuilderLegacy addProperty(String propertyName, String columnAlias) {\n\t\taddProperty( propertyName ).addColumnAlias( columnAlias );\n\t\treturn this;\n\t}\n\n\t@Override\n\tpublic DynamicFetchBuilder addProperty(String propertyName) {\n\t\tDynamicFetchBuilderStandard fetchBuilder = new DynamicFetchBuilderStandard( propertyName );\n\t\tfetchBuilderMap.put( propertyName, fetchBuilder );\n\t\treturn fetchBuilder;\n\t}\n\n\t@Override\n\tpublic FetchBuilder findFetchBuilder(String fetchableName) {\n\t\treturn fetchBuilderMap.get( fetchableName );\n\t}\n\n\t@Override\n\tpublic DynamicFetchBuilderContainer addProperty(String propertyName, String... columnAliases) {\n\t\tfinal DynamicFetchBuilder fetchBuilder = addProperty( propertyName );\n\t\tfor ( String columnAlias : columnAliases ) {\n\t\t\tfetchBuilder.addColumnAlias( columnAlias );\n\t\t}\n\t\treturn this;\n\t}\n\n\t@Override\n\tpublic void addFetchBuilder(String propertyName, FetchBuilder fetchBuilder) {\n\t\tfetchBuilderMap.put( propertyName, fetchBuilder );\n\t}\n\n\t@Override\n\tpublic void visitFetchBuilders(BiConsumer<String, FetchBuilder> consumer) {\n\t\tfetchBuilderMap.forEach( consumer );\n\t}\n\n\t@Override\n\tpublic boolean equals(Object o) {\n\t\tif ( this == o ) {\n\t\t\treturn true;\n\t\t}\n\t\tif ( o == null || getClass() != o.getClass() ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tfinal DynamicFetchBuilderLegacy that = (DynamicFetchBuilderLegacy) o;\n\t\treturn tableAlias.equals( that.tableAlias )\n\t\t\t&& ownerTableAlias.equals( that.ownerTableAlias )\n\t\t\t&& fetchableName.equals( that.fetchableName )\n\t\t\t&& Objects.equals( columnNames, that.columnNames )\n\t\t\t&& Objects.equals( fetchBuilderMap, that.fetchBuilderMap )\n\t\t\t&& Objects.equals( resultBuilderEntity, that.resultBuilderEntity );\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\tint result = tableAlias.hashCode();\n\t\tresult = 31 * result + ownerTableAlias.hashCode();\n\t\tresult = 31 * result + fetchableName.hashCode();\n\t\tresult = 31 * result + ( columnNames != null ? columnNames.hashCode() : 0 );\n\t\tresult = 31 * result + ( fetchBuilderMap != null ? fetchBuilderMap.hashCode() : 0 );\n\t\tresult = 31 * result + ( resultBuilderEntity != null ? resultBuilderEntity.hashCode() : 0 );\n\t\treturn result;\n\t}\n}\n",
        "diffSourceCodeSet": [
            "@Override\n\tpublic String getTableAlias() {\n\t\treturn tableAlias;\n\t}\n\n\t@Override\n\tpublic String getOwnerAlias() {\n\t\treturn ownerTableAlias;\n\t}"
        ],
        "invokedMethodSet": [
            "methodSignature: org.hibernate.sql.results.graph.entity.internal.EntityResultImpl#resolveNavigablePath\n methodBody: public NavigablePath resolveNavigablePath(Fetchable fetchable) {\nif(fetchable instanceof TableGroupProducer){for(TableGroupJoin tableGroupJoin: tableGroup.getTableGroupJoins()){final NavigablePath navigablePath=tableGroupJoin.getNavigablePath();\nif(tableGroupJoin.getJoinedGroup().isFetched() && fetchable.getFetchableName().equals(navigablePath.getLocalName()) && tableGroupJoin.getJoinedGroup().getModelPart() == fetchable && castNonNull(navigablePath.getParent()).equals(getNavigablePath())){return navigablePath;\n}}}return super.resolveNavigablePath(fetchable);\n}",
            "methodSignature: org.hibernate.query.results.internal.complete.CompleteFetchBuilderEntityValuedModelPart#buildFetch\n methodBody: public Fetch buildFetch(\n\t\t\tFetchParent parent,\n\t\t\tNavigablePath fetchPath,\n\t\t\tJdbcValuesMetadata jdbcResultsMetadata,\n\t\t\tDomainResultCreationState domainResultCreationState) {\nassert fetchPath.equals(navigablePath);\nfinal DomainResultCreationStateImpl creationStateImpl=impl(domainResultCreationState);\nfinal TableGroup tableGroup=creationStateImpl.getFromClauseAccess().getTableGroup(navigablePath.getParent());\nmodelPart.forEachSelectable((selectionIndex,selectableMapping) -> {\n  final TableReference tableReference=tableGroup.resolveTableReference(navigablePath,(ValuedModelPart)modelPart,selectableMapping.getContainingTableExpression());\n  final String columnAlias=columnAliases.get(selectionIndex);\n  creationStateImpl.resolveSqlSelection(ResultsHelper.resolveSqlExpression(creationStateImpl,jdbcResultsMetadata,tableReference,selectableMapping,columnAlias),selectableMapping.getJdbcMapping().getJdbcJavaType(),null,creationStateImpl.getSessionFactory().getTypeConfiguration());\n}\n);\nreturn parent.generateFetchableFetch(modelPart,fetchPath,FetchTiming.DELAYED,true,null,domainResultCreationState);\n}",
            "methodSignature: org.hibernate.query.results.internal.complete.CompleteFetchBuilderEmbeddableValuedModelPart#buildFetch\n methodBody: public Fetch buildFetch(\n\t\t\tFetchParent parent,\n\t\t\tNavigablePath fetchPath,\n\t\t\tJdbcValuesMetadata jdbcResultsMetadata,\n\t\t\tDomainResultCreationState domainResultCreationState) {\nassert fetchPath.equals(navigablePath);\nfinal DomainResultCreationStateImpl creationStateImpl=impl(domainResultCreationState);\nfinal TableGroup tableGroup=creationStateImpl.getFromClauseAccess().getTableGroup(navigablePath.getParent());\nmodelPart.forEachSelectable((selectionIndex,selectableMapping) -> {\n  final TableReference tableReference=tableGroup.resolveTableReference(navigablePath,modelPart,selectableMapping.getContainingTableExpression());\n  final String columnAlias=columnAliases.get(selectionIndex);\n  creationStateImpl.resolveSqlSelection(ResultsHelper.resolveSqlExpression(creationStateImpl,jdbcResultsMetadata,tableReference,selectableMapping,columnAlias),selectableMapping.getJdbcMapping().getJdbcJavaType(),null,creationStateImpl.getSessionFactory().getTypeConfiguration());\n}\n);\nreturn parent.generateFetchableFetch(modelPart,fetchPath,FetchTiming.IMMEDIATE,true,null,domainResultCreationState);\n}",
            "methodSignature: org.hibernate.query.results.internal.dynamic.AbstractFetchBuilderContainer#findFetchBuilder\n methodBody: public FetchBuilder findFetchBuilder(String fetchableName) {\nreturn fetchBuilderMap == null ? null : fetchBuilderMap.get(fetchableName);\n}",
            "methodSignature: org.hibernate.query.results.internal.implicit.ImplicitFetchBuilderPlural#buildFetch\n methodBody: public Fetch buildFetch(\n\t\t\tFetchParent parent,\n\t\t\tNavigablePath fetchPath,\n\t\t\tJdbcValuesMetadata jdbcResultsMetadata,\n\t\t\tDomainResultCreationState creationState) {\nfinal Fetch fetch=parent.generateFetchableFetch(fetchable,fetchPath,fetchable.getMappedFetchOptions().getTiming(),false,null,creationState);\nreturn fetch;\n}",
            "methodSignature: org.hibernate.query.results.internal.dynamic.DynamicFetchBuilderLegacy#findFetchBuilder\n methodBody: public FetchBuilder findFetchBuilder(String fetchableName) {\nreturn fetchBuilderMap.get(fetchableName);\n}",
            "methodSignature: org.hibernate.query.results.internal.complete.CompleteFetchBuilderBasicPart#buildFetch\n methodBody: public BasicFetch<?> buildFetch(\n\t\t\tFetchParent parent,\n\t\t\tNavigablePath fetchPath,\n\t\t\tJdbcValuesMetadata jdbcResultsMetadata,\n\t\t\tDomainResultCreationState domainResultCreationState) {\nfinal DomainResultCreationStateImpl creationStateImpl=impl(domainResultCreationState);\nfinal String mappedTable=referencedModelPart.getContainingTableExpression();\nfinal TableGroup tableGroup=creationStateImpl.getFromClauseAccess().getTableGroup(parent.getNavigablePath());\nfinal TableReference tableReference=tableGroup.resolveTableReference(navigablePath,referencedModelPart,mappedTable);\nfinal String selectedAlias;\nfinal int jdbcPosition;\nif(selectionAlias != null){tryjdbcPosition=jdbcResultsMetadata.resolveColumnPosition(selectionAlias);\ncatch(Exception e)throw new MissingSqlSelectionException(\"ResultSet mapping specified selected-alias `\" + selectionAlias + \"` which was not part of the ResultSet\",e);\nselectedAlias=selectionAlias;\n}{if(!creationStateImpl.arePositionalSelectionsAllowed()){throw new AssertionFailure(\"Positional SQL selection resolution not allowed\");\n}jdbcPosition=creationStateImpl.getNumberOfProcessedSelections() + 1;\nselectedAlias=jdbcResultsMetadata.resolveColumnName(jdbcPosition);\n}final int valuesArrayPosition=jdbcPositionToValuesArrayPosition(jdbcPosition);\nfinal JdbcMapping jdbcMapping;\nif(referencedModelPart instanceof DiscriminatorMapping){jdbcMapping=((DiscriminatorMapping)referencedModelPart).getUnderlyingJdbcMapping();\n}{jdbcMapping=referencedModelPart.getJdbcMapping();\n}creationStateImpl.resolveSqlExpression(createColumnReferenceKey(tableReference,referencedModelPart.getSelectablePath(),jdbcMapping),processingState -> new ResultSetMappingSqlSelection(valuesArrayPosition,referencedModelPart));\nreturn (BasicFetch<?>)parent.generateFetchableFetch(referencedModelPart,fetchPath,FetchTiming.IMMEDIATE,true,selectedAlias,domainResultCreationState);\n}",
            "methodSignature: org.hibernate.query.results.internal.dynamic.DynamicResultBuilderEntityStandard#buildFetch\n methodBody: public Fetch buildFetch(\n\t\t\tFetchParent parent,\n\t\t\tFetchable fetchable,\n\t\t\tJdbcValuesMetadata jdbcResultsMetadata,\n\t\t\tDomainResultCreationState domainResultCreationState) {\nreturn buildResultOrFetch((tableGroup) -> parent.generateFetchableFetch(fetchable,parent.resolveNavigablePath(fetchable),FetchTiming.IMMEDIATE,true,null,domainResultCreationState),fetchable,jdbcResultsMetadata,domainResultCreationState);\n}",
            "methodSignature: org.hibernate.query.results.internal.implicit.ImplicitFetchBuilderEmbeddable#buildFetch\n methodBody: public Fetch buildFetch(\n\t\t\tFetchParent parent,\n\t\t\tNavigablePath fetchPath,\n\t\t\tJdbcValuesMetadata jdbcResultsMetadata,\n\t\t\tDomainResultCreationState creationState) {\nfinal DomainResultCreationStateImpl creationStateImpl=impl(creationState);\ncreationStateImpl.getFromClauseAccess().resolveTableGroup(fetchPath,navigablePath -> {\n  final TableGroup parentTableGroup=creationStateImpl.getFromClauseAccess().getTableGroup(parent.getNavigablePath());\n  final TableGroupJoin tableGroupJoin=fetchable.createTableGroupJoin(fetchPath,parentTableGroup,null,null,SqlAstJoinType.INNER,true,false,creationStateImpl);\n  parentTableGroup.addTableGroupJoin(tableGroupJoin);\n  return tableGroupJoin.getJoinedGroup();\n}\n);\nreturn parent.generateFetchableFetch(fetchable,fetchPath,FetchTiming.IMMEDIATE,true,null,creationState);\n}",
            "methodSignature: org.hibernate.query.results.internal.ResultsHelper#impl\n methodBody: public static DomainResultCreationStateImpl impl(DomainResultCreationState creationState) {\nreturn unwrap(creationState);\n}",
            "methodSignature: org.hibernate.query.results.internal.implicit.ImplicitAttributeFetchBuilder#buildFetch\n methodBody: public Fetch buildFetch(\n\t\t\tFetchParent parent,\n\t\t\tNavigablePath fetchPath,\n\t\t\tJdbcValuesMetadata jdbcResultsMetadata,\n\t\t\tDomainResultCreationState domainResultCreationState) {\nassert fetchPath.equals(navigablePath);\nreturn parent.generateFetchableFetch(attributeMapping,fetchPath,FetchTiming.IMMEDIATE,true,null,domainResultCreationState);\n}",
            "methodSignature: org.hibernate.query.results.internal.dynamic.DynamicFetchBuilderLegacy#resolveSqlSelection\n methodBody: private void resolveSqlSelection(\n\t\t\tString columnAlias,\n\t\t\tTableReference tableReference,\n\t\t\tSelectableMapping selectableMapping,\n\t\t\tJdbcValuesMetadata jdbcResultsMetadata,\n\t\t\tDomainResultCreationState domainResultCreationState) {\nfinal DomainResultCreationStateImpl creationStateImpl=impl(domainResultCreationState);\ncreationStateImpl.resolveSqlSelection(ResultsHelper.resolveSqlExpression(creationStateImpl,jdbcResultsMetadata,tableReference,selectableMapping,columnAlias),selectableMapping.getJdbcMapping().getJdbcJavaType(),null,domainResultCreationState.getSqlAstCreationState().getCreationContext().getSessionFactory().getTypeConfiguration());\n}",
            "methodSignature: org.hibernate.query.results.internal.dynamic.DynamicFetchBuilderLegacy#buildFetch\n methodBody: public Fetch buildFetch(\n\t\t\tFetchParent parent,\n\t\t\tNavigablePath fetchPath,\n\t\t\tJdbcValuesMetadata jdbcResultsMetadata,\n\t\t\tDomainResultCreationState domainResultCreationState) {\nfinal DomainResultCreationStateImpl creationState=impl(domainResultCreationState);\nfinal TableGroup ownerTableGroup=creationState.getFromClauseAccess().findByAlias(ownerTableAlias);\nfinal AttributeMapping attributeMapping=parent.getReferencedMappingContainer().findContainingEntityMapping().findDeclaredAttributeMapping(fetchableName);\nfinal TableGroup tableGroup;\nif(attributeMapping instanceof TableGroupJoinProducer){final SqlAliasBase sqlAliasBase=new SqlAliasBaseConstant(tableAlias);\nfinal TableGroupJoin tableGroupJoin=((TableGroupJoinProducer)attributeMapping).createTableGroupJoin(fetchPath,ownerTableGroup,tableAlias,sqlAliasBase,SqlAstJoinType.INNER,true,false,creationState);\nownerTableGroup.addTableGroupJoin(tableGroupJoin);\ncreationState.getFromClauseAccess().registerTableGroup(fetchPath,tableGroup=tableGroupJoin.getJoinedGroup());\n}{tableGroup=ownerTableGroup;\n}if(columnNames != null){final ForeignKeyDescriptor keyDescriptor;\nif(attributeMapping instanceof PluralAttributeMapping pluralAttributeMapping){keyDescriptor=pluralAttributeMapping.getKeyDescriptor();\n}{assert attributeMapping instanceof ToOneAttributeMapping;\nfinal ToOneAttributeMapping toOneAttributeMapping=(ToOneAttributeMapping)attributeMapping;\nkeyDescriptor=toOneAttributeMapping.getForeignKeyDescriptor();\n}if(!columnNames.isEmpty()){keyDescriptor.forEachSelectable((selectionIndex,selectableMapping) -> {\n  resolveSqlSelection(columnNames.get(selectionIndex),tableGroup.resolveTableReference(fetchPath,keyDescriptor.getKeyPart(),selectableMapping.getContainingTableExpression()),selectableMapping,jdbcResultsMetadata,domainResultCreationState);\n}\n);\n}if(resultBuilderEntity != null){return resultBuilderEntity.buildFetch(parent,attributeMapping,jdbcResultsMetadata,creationState);\n}}tryfinal Map.Entry<String,NavigablePath> currentRelativePath=creationState.getCurrentRelativePath();\nfinal String prefix;\nif(currentRelativePath == null){prefix=\"\";\n}{prefix=currentRelativePath.getKey().replace(ELEMENT_PREFIX,\"\").replace(INDEX_PREFIX,\"\") + \".\";\n}creationState.pushExplicitFetchMementoResolver(relativePath -> {\n  if (relativePath.startsWith(prefix)) {\n    return findFetchBuilder(relativePath.substring(prefix.length()));\n  }\n  return null;\n}\n);\nreturn parent.generateFetchableFetch(attributeMapping,parent.resolveNavigablePath(attributeMapping),FetchTiming.IMMEDIATE,true,null,domainResultCreationState);\nfinallycreationState.popExplicitFetchMementoResolver();\n}",
            "methodSignature: org.hibernate.query.results.internal.implicit.ImplicitFetchBuilderEntity#buildFetch\n methodBody: public Fetch buildFetch(\n\t\t\tFetchParent parent,\n\t\t\tNavigablePath fetchPath,\n\t\t\tJdbcValuesMetadata jdbcResultsMetadata,\n\t\t\tDomainResultCreationState creationState) {\nreturn parent.generateFetchableFetch(fetchable,fetchPath,fetchable.getMappedFetchOptions().getTiming(),false,null,creationState);\n}",
            "methodSignature: org.hibernate.query.results.internal.complete.DelayedFetchBuilderBasicPart#buildFetch\n methodBody: public BasicFetch<?> buildFetch(\n\t\t\tFetchParent parent,\n\t\t\tNavigablePath fetchPath,\n\t\t\tJdbcValuesMetadata jdbcResultsMetadata,\n\t\t\tDomainResultCreationState domainResultCreationState) {\nreturn new BasicFetch<>(-1,parent,fetchPath,referencedModelPart,null,FetchTiming.DELAYED,isEnhancedForLazyLoading,domainResultCreationState,false,false);\n}",
            "methodSignature: org.hibernate.query.results.internal.implicit.ImplicitFetchBuilderBasic#buildFetch\n methodBody: public BasicFetch<?> buildFetch(\n\t\t\tFetchParent parent,\n\t\t\tNavigablePath fetchPath,\n\t\t\tJdbcValuesMetadata jdbcResultsMetadata,\n\t\t\tDomainResultCreationState domainResultCreationState) {\nif(fetchBuilder != null){return (BasicFetch<?>)fetchBuilder.buildFetch(parent,fetchPath,jdbcResultsMetadata,domainResultCreationState);\n}final DomainResultCreationStateImpl creationStateImpl=ResultsHelper.impl(domainResultCreationState);\nfinal TableGroup parentTableGroup=creationStateImpl.getFromClauseAccess().getTableGroup(parent.getNavigablePath());\nfinal String table=fetchable.getContainingTableExpression();\nfinal String column;\nif(fetchable.isFormula()){column=fetchable.getFetchableName();\n}{column=fetchable.getSelectionExpression();\n}final Expression expression=ResultsHelper.resolveSqlExpression(creationStateImpl,jdbcResultsMetadata,parentTableGroup.resolveTableReference(fetchPath,fetchable,table),fetchable,column);\nfinal SqlSelection sqlSelection=creationStateImpl.resolveSqlSelection(expression,fetchable.getJdbcMapping().getJdbcJavaType(),parent,domainResultCreationState.getSqlAstCreationState().getCreationContext().getSessionFactory().getTypeConfiguration());\nreturn new BasicFetch<>(sqlSelection.getValuesArrayPosition(),parent,fetchPath,fetchable,FetchTiming.IMMEDIATE,domainResultCreationState,!sqlSelection.isVirtual());\n}",
            "methodSignature: org.hibernate.query.results.internal.dynamic.DynamicResultBuilderEntityStandard#resolveSqlSelection\n methodBody: private void resolveSqlSelection(\n\t\t\tString columnAlias,\n\t\t\tTableReference tableReference,\n\t\t\tSelectableMapping selectableMapping,\n\t\t\tJdbcValuesMetadata jdbcResultsMetadata,\n\t\t\tDomainResultCreationState domainResultCreationState) {\nfinal DomainResultCreationStateImpl creationStateImpl=impl(domainResultCreationState);\ncreationStateImpl.resolveSqlSelection(ResultsHelper.resolveSqlExpression(creationStateImpl,jdbcResultsMetadata,tableReference,selectableMapping,columnAlias),selectableMapping.getJdbcMapping().getJdbcJavaType(),null,domainResultCreationState.getSqlAstCreationState().getCreationContext().getSessionFactory().getTypeConfiguration());\n}",
            "methodSignature: org.hibernate.query.results.internal.dynamic.DynamicFetchBuilderStandard#buildFetch\n methodBody: public Fetch buildFetch(\n\t\t\tFetchParent parent,\n\t\t\tNavigablePath fetchPath,\n\t\t\tJdbcValuesMetadata jdbcResultsMetadata,\n\t\t\tDomainResultCreationState domainResultCreationState) {\nfinal DomainResultCreationStateImpl creationStateImpl=ResultsHelper.impl(domainResultCreationState);\nfinal TableGroup ownerTableGroup=creationStateImpl.getFromClauseAccess().getTableGroup(parent.getNavigablePath());\nfinal Fetchable attributeMapping=(Fetchable)parent.getReferencedMappingContainer().findSubPart(fetchableName,null);\nfinal SqlExpressionResolver sqlExpressionResolver=domainResultCreationState.getSqlAstCreationState().getSqlExpressionResolver();\nfinal BasicValuedModelPart basicPart=attributeMapping.asBasicValuedModelPart();\nif(basicPart != null){attributeMapping.forEachSelectable(getSelectableConsumer(fetchPath,jdbcResultsMetadata,domainResultCreationState,creationStateImpl,ownerTableGroup,sqlExpressionResolver,basicPart));\nreturn parent.generateFetchableFetch(attributeMapping,fetchPath,FetchTiming.IMMEDIATE,true,null,creationStateImpl);\n}if(attributeMapping instanceof EmbeddableValuedFetchable){attributeMapping.forEachSelectable(getSelectableConsumer(fetchPath,jdbcResultsMetadata,domainResultCreationState,creationStateImpl,ownerTableGroup,sqlExpressionResolver,(EmbeddableValuedFetchable)attributeMapping));\nreturn parent.generateFetchableFetch(attributeMapping,fetchPath,FetchTiming.IMMEDIATE,false,null,creationStateImpl);\n}if(attributeMapping instanceof ToOneAttributeMapping toOneAttributeMapping){toOneAttributeMapping.getForeignKeyDescriptor().getPart(toOneAttributeMapping.getSideNature()).forEachSelectable(getSelectableConsumer(fetchPath,jdbcResultsMetadata,domainResultCreationState,creationStateImpl,ownerTableGroup,sqlExpressionResolver,toOneAttributeMapping.getForeignKeyDescriptor()));\nreturn parent.generateFetchableFetch(attributeMapping,fetchPath,attributeMapping.getMappedFetchOptions().getTiming(),false,null,creationStateImpl);\n}{assert attributeMapping instanceof PluralAttributeMapping;\nfinal PluralAttributeMapping pluralAttributeMapping=(PluralAttributeMapping)attributeMapping;\npluralAttributeMapping.getKeyDescriptor().visitTargetSelectables(getSelectableConsumer(fetchPath,jdbcResultsMetadata,domainResultCreationState,creationStateImpl,ownerTableGroup,sqlExpressionResolver,pluralAttributeMapping.getKeyDescriptor()));\nreturn parent.generateFetchableFetch(attributeMapping,fetchPath,attributeMapping.getMappedFetchOptions().getTiming(),false,null,creationStateImpl);\n}}",
            "methodSignature: org.hibernate.query.results.internal.implicit.ImplicitFetchBuilderDiscriminatedAssociation#buildFetch\n methodBody: public Fetch buildFetch(\n\t\t\tFetchParent parent,\n\t\t\tNavigablePath fetchPath,\n\t\t\tJdbcValuesMetadata jdbcResultsMetadata,\n\t\t\tDomainResultCreationState creationState) {\nfinal DomainResultCreationStateImpl creationStateImpl=impl(creationState);\ncreationStateImpl.getFromClauseAccess().resolveTableGroup(fetchPath,navigablePath -> {\n  final TableGroup parentTableGroup=creationStateImpl.getFromClauseAccess().getTableGroup(parent.getNavigablePath());\n  final TableGroupJoin tableGroupJoin=fetchable.createTableGroupJoin(fetchPath,parentTableGroup,null,null,SqlAstJoinType.INNER,true,false,creationStateImpl);\n  parentTableGroup.addTableGroupJoin(tableGroupJoin);\n  return tableGroupJoin.getJoinedGroup();\n}\n);\nreturn parent.generateFetchableFetch(fetchable,fetchPath,fetchable.getTiming(),false,null,creationState);\n}",
            "methodSignature: org.hibernate.query.results.internal.implicit.ImplicitFetchBuilderEntityPart#buildFetch\n methodBody: public Fetch buildFetch(\n\t\t\tFetchParent parent,\n\t\t\tNavigablePath fetchPath,\n\t\t\tJdbcValuesMetadata jdbcResultsMetadata,\n\t\t\tDomainResultCreationState creationState) {\nreturn parent.generateFetchableFetch(fetchable,fetchPath,FetchTiming.IMMEDIATE,true,null,creationState);\n}"
        ],
        "sourceCodeAfterRefactoring": "@Override\n\tpublic Fetch buildFetch(\n\t\t\tFetchParent parent,\n\t\t\tNavigablePath fetchPath,\n\t\t\tJdbcValuesMetadata jdbcResultsMetadata,\n\t\t\tDomainResultCreationState domainResultCreationState) {\n\t\tfinal DomainResultCreationStateImpl creationState = impl( domainResultCreationState );\n\t\tfinal TableGroup ownerTableGroup = creationState.getFromClauseAccess().findByAlias( ownerTableAlias );\n\t\tfinal AttributeMapping attributeMapping =\n\t\t\t\tparent.getReferencedMappingContainer().findContainingEntityMapping()\n\t\t\t\t\t\t.findDeclaredAttributeMapping( fetchableName );\n\t\tfinal TableGroup tableGroup = tableGroup( fetchPath, attributeMapping, ownerTableGroup, creationState );\n\n\t\tif ( columnNames != null ) {\n\t\t\tfinal ForeignKeyDescriptor keyDescriptor = getForeignKeyDescriptor( attributeMapping );\n\t\t\tif ( !columnNames.isEmpty() ) {\n\t\t\t\tkeyDescriptor.forEachSelectable( (selectionIndex, selectableMapping) -> {\n\t\t\t\t\tresolveSqlSelection(\n\t\t\t\t\t\t\tcolumnNames.get( selectionIndex ),\n\t\t\t\t\t\t\ttableGroup.resolveTableReference(\n\t\t\t\t\t\t\t\t\tfetchPath,\n\t\t\t\t\t\t\t\t\tkeyDescriptor.getKeyPart(),\n\t\t\t\t\t\t\t\t\tselectableMapping.getContainingTableExpression()\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\tselectableMapping,\n\t\t\t\t\t\t\tjdbcResultsMetadata,\n\t\t\t\t\t\t\tdomainResultCreationState\n\t\t\t\t\t); }\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// We process the fetch builder such that it contains a resultBuilderEntity before calling this method in ResultSetMappingProcessor\n\t\t\tif ( resultBuilderEntity != null ) {\n\t\t\t\treturn resultBuilderEntity.buildFetch(\n\t\t\t\t\t\tparent,\n\t\t\t\t\t\tattributeMapping,\n\t\t\t\t\t\tjdbcResultsMetadata,\n\t\t\t\t\t\tcreationState\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\ttry {\n\t\t\tfinal String prefix = DynamicResultBuilderEntityStandard.prefix( creationState, ELEMENT_PREFIX, INDEX_PREFIX );\n\t\t\tcreationState.pushExplicitFetchMementoResolver(\n\t\t\t\t\trelativePath -> {\n\t\t\t\t\t\tif ( relativePath.startsWith( prefix ) ) {\n\t\t\t\t\t\t\treturn findFetchBuilder( relativePath.substring( prefix.length() ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t);\n\t\t\treturn parent.generateFetchableFetch(\n\t\t\t\t\tattributeMapping,\n\t\t\t\t\tparent.resolveNavigablePath( attributeMapping ),\n\t\t\t\t\tFetchTiming.IMMEDIATE,\n\t\t\t\t\ttrue,\n\t\t\t\t\tnull,\n\t\t\t\t\tdomainResultCreationState\n\t\t\t);\n\t\t}\n\t\tfinally {\n\t\t\tcreationState.popExplicitFetchMementoResolver();\n\t\t}\n\t}\n@Override\n\tpublic String getTableAlias() {\n\t\treturn tableAlias;\n\t}\n\n\t@Override\n\tpublic String getOwnerAlias() {\n\t\treturn ownerTableAlias;\n\t}",
        "diffSourceCode": "-   87: \tpublic String getTableAlias() {\n-   88: \t\treturn tableAlias;\n-   89: \t}\n-   90: \n-   91: \t@Override\n-   92: \tpublic String getOwnerAlias() {\n-   93: \t\treturn ownerTableAlias;\n-   94: \t}\n-   95: \n-   96: \t@Override\n-   97: \tpublic String getFetchableName() {\n-  123: \t@Override\n-  124: \tpublic Fetch buildFetch(\n-  125: \t\t\tFetchParent parent,\n-  126: \t\t\tNavigablePath fetchPath,\n-  127: \t\t\tJdbcValuesMetadata jdbcResultsMetadata,\n-  128: \t\t\tDomainResultCreationState domainResultCreationState) {\n-  129: \t\tfinal DomainResultCreationStateImpl creationState = impl( domainResultCreationState );\n-  130: \t\tfinal TableGroup ownerTableGroup = creationState.getFromClauseAccess().findByAlias( ownerTableAlias );\n-  131: \t\tfinal AttributeMapping attributeMapping = parent.getReferencedMappingContainer()\n-  132: \t\t\t\t.findContainingEntityMapping()\n-  133: \t\t\t\t.findDeclaredAttributeMapping( fetchableName );\n-  134: \t\tfinal TableGroup tableGroup;\n-  135: \t\tif ( attributeMapping instanceof TableGroupJoinProducer ) {\n-  136: \t\t\tfinal SqlAliasBase sqlAliasBase = new SqlAliasBaseConstant( tableAlias );\n-  137: \t\t\tfinal TableGroupJoin tableGroupJoin = ( (TableGroupJoinProducer) attributeMapping ).createTableGroupJoin(\n-  138: \t\t\t\t\tfetchPath,\n-  139: \t\t\t\t\townerTableGroup,\n-  140: \t\t\t\t\ttableAlias,\n-  141: \t\t\t\t\tsqlAliasBase,\n-  142: \t\t\t\t\tSqlAstJoinType.INNER,\n-  143: \t\t\t\t\ttrue,\n-  144: \t\t\t\t\tfalse,\n-  145: \t\t\t\t\tcreationState\n-  146: \t\t\t);\n-  147: \t\t\townerTableGroup.addTableGroupJoin( tableGroupJoin );\n-  148: \t\t\tcreationState.getFromClauseAccess().registerTableGroup( fetchPath, tableGroup = tableGroupJoin.getJoinedGroup() );\n-  149: \t\t}\n-  150: \t\telse {\n-  151: \t\t\ttableGroup = ownerTableGroup;\n-  152: \t\t}\n-  153: \n-  154: \t\tif ( columnNames != null ) {\n-  155: \t\t\tfinal ForeignKeyDescriptor keyDescriptor;\n-  156: \t\t\tif ( attributeMapping instanceof PluralAttributeMapping pluralAttributeMapping ) {\n-  157: \t\t\t\tkeyDescriptor = pluralAttributeMapping.getKeyDescriptor();\n-  158: \t\t\t}\n-  159: \t\t\telse {\n-  160: \t\t\t\t// Not sure if this fetch builder can also be used with other attribute mappings\n-  161: \t\t\t\tassert attributeMapping instanceof ToOneAttributeMapping;\n-  162: \n-  163: \t\t\t\tfinal ToOneAttributeMapping toOneAttributeMapping = (ToOneAttributeMapping) attributeMapping;\n-  164: \t\t\t\tkeyDescriptor = toOneAttributeMapping.getForeignKeyDescriptor();\n-  165: \t\t\t}\n-  166: \n-  167: \t\t\tif ( !columnNames.isEmpty() ) {\n-  168: \t\t\t\tkeyDescriptor.forEachSelectable( (selectionIndex, selectableMapping) -> {\n-  169: \t\t\t\t\tresolveSqlSelection(\n-  170: \t\t\t\t\t\t\tcolumnNames.get( selectionIndex ),\n-  171: \t\t\t\t\t\t\ttableGroup.resolveTableReference(\n-  172: \t\t\t\t\t\t\t\t\tfetchPath,\n-  173: \t\t\t\t\t\t\t\t\tkeyDescriptor.getKeyPart(),\n-  174: \t\t\t\t\t\t\t\t\tselectableMapping.getContainingTableExpression()\n-  175: \t\t\t\t\t\t\t),\n-  176: \t\t\t\t\t\t\tselectableMapping,\n-  177: \t\t\t\t\t\t\tjdbcResultsMetadata,\n-  178: \t\t\t\t\t\t\tdomainResultCreationState\n-  179: \t\t\t\t\t); }\n-  180: \t\t\t\t);\n-  181: \t\t\t}\n-  182: \n-  183: \t\t\t// We process the fetch builder such that it contains a resultBuilderEntity before calling this method in ResultSetMappingProcessor\n-  184: \t\t\tif ( resultBuilderEntity != null ) {\n-  185: \t\t\t\treturn resultBuilderEntity.buildFetch(\n-  186: \t\t\t\t\t\tparent,\n-  187: \t\t\t\t\t\tattributeMapping,\n-  188: \t\t\t\t\t\tjdbcResultsMetadata,\n-  189: \t\t\t\t\t\tcreationState\n-  190: \t\t\t\t);\n-  191: \t\t\t}\n-  192: \t\t}\n-  193: \t\ttry {\n-  194: \t\t\tfinal Map.Entry<String, NavigablePath> currentRelativePath = creationState.getCurrentRelativePath();\n-  195: \t\t\tfinal String prefix;\n-  196: \t\t\tif ( currentRelativePath == null ) {\n-  197: \t\t\t\tprefix = \"\";\n-  198: \t\t\t}\n-  199: \t\t\telse {\n-  200: \t\t\t\tprefix = currentRelativePath.getKey()\n-  201: \t\t\t\t\t\t.replace( ELEMENT_PREFIX, \"\" )\n-  202: \t\t\t\t\t\t.replace( INDEX_PREFIX, \"\" ) + \".\";\n-  203: \t\t\t}\n-  204: \t\t\tcreationState.pushExplicitFetchMementoResolver(\n-  205: \t\t\t\t\trelativePath -> {\n-  206: \t\t\t\t\t\tif ( relativePath.startsWith( prefix ) ) {\n-  207: \t\t\t\t\t\t\treturn findFetchBuilder( relativePath.substring( prefix.length() ) );\n-  208: \t\t\t\t\t\t}\n-  209: \t\t\t\t\t\treturn null;\n-  210: \t\t\t\t\t}\n-  211: \t\t\t);\n-  212: \t\t\treturn parent.generateFetchableFetch(\n-  213: \t\t\t\t\tattributeMapping,\n-  214: \t\t\t\t\tparent.resolveNavigablePath( attributeMapping ),\n-  215: \t\t\t\t\tFetchTiming.IMMEDIATE,\n-  216: \t\t\t\t\ttrue,\n-  217: \t\t\t\t\tnull,\n-  218: \t\t\t\t\tdomainResultCreationState\n-  219: \t\t\t);\n-  220: \t\t}\n-  221: \t\tfinally {\n-  222: \t\t\tcreationState.popExplicitFetchMementoResolver();\n-  223: \t\t}\n-  224: \t}\n+   87: \n+   88: \t@Override\n+   89: \tpublic String getTableAlias() {\n+   90: \t\treturn tableAlias;\n+   91: \t}\n+   92: \n+   93: \t@Override\n+   94: \tpublic String getOwnerAlias() {\n+   95: \t\treturn ownerTableAlias;\n+   96: \t}\n+   97: \n+  123: \t\t\t}\n+  124: \t\t\treturn fetchBuilderMap;\n+  125: \t\t}\n+  126: \t}\n+  127: \n+  128: \t@Override\n+  129: \tpublic Fetch buildFetch(\n+  130: \t\t\tFetchParent parent,\n+  131: \t\t\tNavigablePath fetchPath,\n+  132: \t\t\tJdbcValuesMetadata jdbcResultsMetadata,\n+  133: \t\t\tDomainResultCreationState domainResultCreationState) {\n+  134: \t\tfinal DomainResultCreationStateImpl creationState = impl( domainResultCreationState );\n+  135: \t\tfinal TableGroup ownerTableGroup = creationState.getFromClauseAccess().findByAlias( ownerTableAlias );\n+  136: \t\tfinal AttributeMapping attributeMapping =\n+  137: \t\t\t\tparent.getReferencedMappingContainer().findContainingEntityMapping()\n+  138: \t\t\t\t\t\t.findDeclaredAttributeMapping( fetchableName );\n+  139: \t\tfinal TableGroup tableGroup = tableGroup( fetchPath, attributeMapping, ownerTableGroup, creationState );\n+  140: \n+  141: \t\tif ( columnNames != null ) {\n+  142: \t\t\tfinal ForeignKeyDescriptor keyDescriptor = getForeignKeyDescriptor( attributeMapping );\n+  143: \t\t\tif ( !columnNames.isEmpty() ) {\n+  144: \t\t\t\tkeyDescriptor.forEachSelectable( (selectionIndex, selectableMapping) -> {\n+  145: \t\t\t\t\tresolveSqlSelection(\n+  146: \t\t\t\t\t\t\tcolumnNames.get( selectionIndex ),\n+  147: \t\t\t\t\t\t\ttableGroup.resolveTableReference(\n+  148: \t\t\t\t\t\t\t\t\tfetchPath,\n+  149: \t\t\t\t\t\t\t\t\tkeyDescriptor.getKeyPart(),\n+  150: \t\t\t\t\t\t\t\t\tselectableMapping.getContainingTableExpression()\n+  151: \t\t\t\t\t\t\t),\n+  152: \t\t\t\t\t\t\tselectableMapping,\n+  153: \t\t\t\t\t\t\tjdbcResultsMetadata,\n+  154: \t\t\t\t\t\t\tdomainResultCreationState\n+  155: \t\t\t\t\t); }\n+  156: \t\t\t\t);\n+  157: \t\t\t}\n+  158: \n+  159: \t\t\t// We process the fetch builder such that it contains a resultBuilderEntity before calling this method in ResultSetMappingProcessor\n+  160: \t\t\tif ( resultBuilderEntity != null ) {\n+  161: \t\t\t\treturn resultBuilderEntity.buildFetch(\n+  162: \t\t\t\t\t\tparent,\n+  163: \t\t\t\t\t\tattributeMapping,\n+  164: \t\t\t\t\t\tjdbcResultsMetadata,\n+  165: \t\t\t\t\t\tcreationState\n+  166: \t\t\t\t);\n+  167: \t\t\t}\n+  168: \t\t}\n+  169: \t\ttry {\n+  170: \t\t\tfinal String prefix = DynamicResultBuilderEntityStandard.prefix( creationState, ELEMENT_PREFIX, INDEX_PREFIX );\n+  171: \t\t\tcreationState.pushExplicitFetchMementoResolver(\n+  172: \t\t\t\t\trelativePath -> {\n+  173: \t\t\t\t\t\tif ( relativePath.startsWith( prefix ) ) {\n+  174: \t\t\t\t\t\t\treturn findFetchBuilder( relativePath.substring( prefix.length() ) );\n+  175: \t\t\t\t\t\t}\n+  176: \t\t\t\t\t\treturn null;\n+  177: \t\t\t\t\t}\n+  178: \t\t\t);\n+  179: \t\t\treturn parent.generateFetchableFetch(\n+  180: \t\t\t\t\tattributeMapping,\n+  181: \t\t\t\t\tparent.resolveNavigablePath( attributeMapping ),\n+  182: \t\t\t\t\tFetchTiming.IMMEDIATE,\n+  183: \t\t\t\t\ttrue,\n+  184: \t\t\t\t\tnull,\n+  185: \t\t\t\t\tdomainResultCreationState\n+  186: \t\t\t);\n+  187: \t\t}\n+  188: \t\tfinally {\n+  189: \t\t\tcreationState.popExplicitFetchMementoResolver();\n+  190: \t\t}\n+  191: \t}\n+  192: \n+  193: \tprivate TableGroup tableGroup(\n+  194: \t\t\tNavigablePath fetchPath,\n+  195: \t\t\tAttributeMapping attributeMapping,\n+  196: \t\t\tTableGroup ownerTableGroup,\n+  197: \t\t\tDomainResultCreationStateImpl creationState) {\n+  198: \t\tif ( attributeMapping instanceof TableGroupJoinProducer tableGroupJoinProducer ) {\n+  199: \t\t\tfinal TableGroupJoin tableGroupJoin = tableGroupJoinProducer.createTableGroupJoin(\n+  200: \t\t\t\t\tfetchPath,\n+  201: \t\t\t\t\townerTableGroup,\n+  202: \t\t\t\t\ttableAlias,\n+  203: \t\t\t\t\tnew SqlAliasBaseConstant( tableAlias ),\n+  204: \t\t\t\t\tSqlAstJoinType.INNER,\n+  205: \t\t\t\t\ttrue,\n+  206: \t\t\t\t\tfalse,\n+  207: \t\t\t\t\tcreationState\n+  208: \t\t\t);\n+  209: \t\t\townerTableGroup.addTableGroupJoin( tableGroupJoin );\n+  210: \t\t\tfinal TableGroup tableGroup = tableGroupJoin.getJoinedGroup();\n+  211: \t\t\tcreationState.getFromClauseAccess().registerTableGroup( fetchPath, tableGroup );\n+  212: \t\t\treturn tableGroup;\n+  213: \t\t}\n+  214: \t\telse {\n+  215: \t\t\treturn ownerTableGroup;\n+  216: \t\t}\n+  217: \t}\n+  218: \n+  219: \tprivate static ForeignKeyDescriptor getForeignKeyDescriptor(AttributeMapping attributeMapping) {\n+  220: \t\tif ( attributeMapping instanceof PluralAttributeMapping pluralAttributeMapping ) {\n+  221: \t\t\treturn pluralAttributeMapping.getKeyDescriptor();\n+  222: \t\t}\n+  223: \t\telse if ( attributeMapping instanceof ToOneAttributeMapping toOneAttributeMapping ) {\n+  224: \t\t\treturn toOneAttributeMapping.getForeignKeyDescriptor();\n",
        "uniqueId": "96cba56591e3e8c6dabaf35d954bd5911b1471ae_123_224_87_97_128_191",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 9,
                "covered": 135
            },
            "BRANCH": {
                "missed": 3,
                "covered": 11
            },
            "LINE": {
                "missed": 2,
                "covered": 30
            },
            "COMPLEXITY": {
                "missed": 3,
                "covered": 5
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 21
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprivate instantiateGeneratorBean(identifierValue SimpleValue, generatorStrategy String, configuration Map<String,Object>, context MetadataBuildingContext) : void extracted from private setGeneratorCreator(identifierValue SimpleValue, configuration Map<String,Object>, generatorStrategy String, context MetadataBuildingContext) : void in class org.hibernate.boot.model.internal.GeneratorBinder",
        "diffLocations": [
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/boot/model/internal/GeneratorBinder.java",
                "startLine": 791,
                "endLine": 816,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/boot/model/internal/GeneratorBinder.java",
                "startLine": 749,
                "endLine": 765,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/boot/model/internal/GeneratorBinder.java",
                "startLine": 767,
                "endLine": 782,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "/**\n\t * Set up the {@link GeneratorCreator} for a case where there is no\n\t * generator annotation.\n\t */\n\tprivate static void setGeneratorCreator(\n\t\t\tSimpleValue identifierValue,\n\t\t\tMap<String, Object> configuration,\n\t\t\tString generatorStrategy,\n\t\t\tMetadataBuildingContext context) {\n\t\tif ( ASSIGNED_GENERATOR_NAME.equals( generatorStrategy )\n\t\t\t\t|| org.hibernate.id.Assigned.class.getName().equals( generatorStrategy ) ) {\n\t\t\tidentifierValue.setCustomIdGeneratorCreator( ASSIGNED_IDENTIFIER_GENERATOR_CREATOR );\n\t\t}\n\t\telse {\n\t\t\tfinal BeanContainer beanContainer = beanContainer( context );\n\t\t\tidentifierValue.setCustomIdGeneratorCreator( creationContext -> {\n\t\t\t\tfinal Generator identifierGenerator =\n\t\t\t\t\t\tinstantiateGenerator( beanContainer, generatorClass( generatorStrategy, identifierValue ) );\n\t\t\t\tcallConfigure( creationContext, identifierGenerator, configuration, identifierValue );\n\t\t\t\tif ( identifierGenerator instanceof IdentityGenerator) {\n\t\t\t\t\tidentifierValue.setColumnToIdentity();\n\t\t\t\t}\n\t\t\t\treturn identifierGenerator;\n\t\t\t} );\n\t\t}\n\t}",
        "filePathBefore": "hibernate-core/src/main/java/org/hibernate/boot/model/internal/GeneratorBinder.java",
        "isPureRefactoring": true,
        "commitId": "800a3f0738db7294c9684de8bfe4edce99321acb",
        "packageNameBefore": "org.hibernate.boot.model.internal",
        "classNameBefore": "org.hibernate.boot.model.internal.GeneratorBinder",
        "methodNameBefore": "org.hibernate.boot.model.internal.GeneratorBinder#setGeneratorCreator",
        "invokedMethod": "methodSignature: org.hibernate.boot.model.internal.GeneratorBinder#callConfigure\n methodBody: public static void callConfigure(\n\t\t\tGeneratorCreationContext creationContext,\n\t\t\tGenerator generator,\n\t\t\tMap<String, Object> configuration,\n\t\t\tSimpleValue identifierValue) {\nif(generator instanceof Configurable configurable){final Properties parameters=collectParameters(identifierValue,creationContext.getDatabase().getDialect(),creationContext.getRootClass(),configuration);\nconfigurable.configure(creationContext,parameters);\n}if(generator instanceof ExportableProducer exportableProducer){exportableProducer.registerExportables(creationContext.getDatabase());\n}if(generator instanceof Configurable configurable){configurable.initialize(creationContext.getSqlStringGenerationContext());\n}}\nmethodSignature: org.hibernate.boot.model.internal.GeneratorBinder#beanContainer\n methodBody: public static BeanContainer beanContainer(MetadataBuildingContext buildingContext) {\nreturn Helper.getBeanContainer(buildingContext.getBootstrapContext().getServiceRegistry());\n}\nmethodSignature: org.hibernate.boot.model.internal.GeneratorBinder#instantiateGenerator\n methodBody: public static <T extends Generator> T instantiateGenerator(\n\t\t\tBeanContainer beanContainer,\n\t\t\tClass<T> generatorClass) {\nif(beanContainer != null){return instantiateGeneratorAsBean(beanContainer,generatorClass);\n}{return instantiateGeneratorViaDefaultConstructor(generatorClass);\n}}",
        "classSignatureBefore": "public class GeneratorBinder ",
        "methodNameBeforeSet": [
            "org.hibernate.boot.model.internal.GeneratorBinder#setGeneratorCreator"
        ],
        "classNameBeforeSet": [
            "org.hibernate.boot.model.internal.GeneratorBinder"
        ],
        "classSignatureBeforeSet": [
            "public class GeneratorBinder "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * SPDX-License-Identifier: LGPL-2.1-or-later\n * Copyright Red Hat Inc. and Hibernate Authors\n */\npackage org.hibernate.boot.model.internal;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Member;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Properties;\nimport java.util.function.BiConsumer;\nimport java.util.function.Consumer;\n\nimport org.hibernate.AnnotationException;\nimport org.hibernate.AssertionFailure;\nimport org.hibernate.MappingException;\nimport org.hibernate.annotations.GenericGenerator;\nimport org.hibernate.annotations.IdGeneratorType;\nimport org.hibernate.annotations.ValueGenerationType;\nimport org.hibernate.boot.model.IdentifierGeneratorDefinition;\nimport org.hibernate.boot.model.relational.ExportableProducer;\nimport org.hibernate.boot.model.source.internal.hbm.MappingDocument;\nimport org.hibernate.boot.models.spi.GlobalRegistrar;\nimport org.hibernate.boot.spi.InFlightMetadataCollector;\nimport org.hibernate.boot.spi.MetadataBuildingContext;\nimport org.hibernate.boot.spi.PropertyData;\nimport org.hibernate.generator.AnnotationBasedGenerator;\nimport org.hibernate.generator.Assigned;\nimport org.hibernate.generator.BeforeExecutionGenerator;\nimport org.hibernate.generator.Generator;\nimport org.hibernate.generator.GeneratorCreationContext;\nimport org.hibernate.generator.OnExecutionGenerator;\nimport org.hibernate.id.Configurable;\nimport org.hibernate.id.IdentifierGenerator;\nimport org.hibernate.id.IdentityGenerator;\nimport org.hibernate.id.PersistentIdentifierGenerator;\nimport org.hibernate.id.enhanced.SequenceStyleGenerator;\nimport org.hibernate.id.uuid.UuidValueGenerator;\nimport org.hibernate.internal.CoreLogging;\nimport org.hibernate.internal.CoreMessageLogger;\nimport org.hibernate.internal.util.StringHelper;\nimport org.hibernate.mapping.GeneratorCreator;\nimport org.hibernate.mapping.KeyValue;\nimport org.hibernate.mapping.PersistentClass;\nimport org.hibernate.mapping.SimpleValue;\nimport org.hibernate.models.spi.AnnotationTarget;\nimport org.hibernate.models.spi.MemberDetails;\nimport org.hibernate.models.spi.SourceModelBuildingContext;\nimport org.hibernate.resource.beans.container.spi.BeanContainer;\nimport org.hibernate.resource.beans.internal.Helper;\n\nimport jakarta.persistence.GeneratedValue;\nimport jakarta.persistence.GenerationType;\nimport jakarta.persistence.SequenceGenerator;\nimport jakarta.persistence.TableGenerator;\nimport jakarta.persistence.Version;\n\nimport static jakarta.persistence.GenerationType.AUTO;\nimport static java.util.Collections.emptyMap;\nimport static org.hibernate.boot.model.internal.AnnotationHelper.extractParameterMap;\nimport static org.hibernate.boot.model.internal.BinderHelper.getPath;\nimport static org.hibernate.boot.model.internal.BinderHelper.isGlobalGeneratorNameGlobal;\nimport static org.hibernate.boot.model.internal.GeneratorParameters.collectParameters;\nimport static org.hibernate.boot.model.internal.GeneratorParameters.interpretSequenceGenerator;\nimport static org.hibernate.boot.model.internal.GeneratorParameters.interpretTableGenerator;\nimport static org.hibernate.boot.model.internal.GeneratorStrategies.generatorClass;\nimport static org.hibernate.id.IdentifierGenerator.GENERATOR_NAME;\nimport static org.hibernate.internal.util.NullnessUtil.castNonNull;\nimport static org.hibernate.internal.util.StringHelper.qualify;\nimport static org.hibernate.internal.util.collections.CollectionHelper.combineUntyped;\nimport static org.hibernate.resource.beans.internal.Helper.allowExtensionsInCdi;\n\n/**\n * Responsible for configuring and instantiating {@link Generator}s.\n *\n * @author Gavin King\n */\npublic class GeneratorBinder {\n\n\tprivate static final CoreMessageLogger LOG = CoreLogging.messageLogger( GeneratorBinder.class );\n\n\tpublic static final String ASSIGNED_GENERATOR_NAME = \"assigned\";\n\tpublic static final GeneratorCreator ASSIGNED_IDENTIFIER_GENERATOR_CREATOR =\n\t\t\tnew GeneratorCreator() {\n\t\t\t\t@Override\n\t\t\t\tpublic Generator createGenerator(GeneratorCreationContext context) {\n\t\t\t\t\treturn new Assigned();\n\t\t\t\t}\n\t\t\t\t@Override\n\t\t\t\tpublic boolean isAssigned() {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t};\n\n\t/**\n\t * Create a generator, based on a {@link GeneratedValue} annotation.\n\t */\n\tpublic static void makeIdGenerator(\n\t\t\tSimpleValue identifierValue,\n\t\t\tMemberDetails idAttributeMember,\n\t\t\tString generatorType,\n\t\t\tString generatorName,\n\t\t\tMetadataBuildingContext context,\n\t\t\tMap<String, ? extends IdentifierGeneratorDefinition> localGenerators) {\n\n\t\t//generator settings\n\t\tfinal Map<String,Object> configuration = new HashMap<>();\n\t\tconfiguration.put( GENERATOR_NAME, generatorName );\n\t\tconfiguration.put( PersistentIdentifierGenerator.TABLE, identifierValue.getTable().getName() );\n\t\tif ( identifierValue.getColumnSpan() == 1 ) {\n\t\t\tconfiguration.put( PersistentIdentifierGenerator.PK, identifierValue.getColumns().get(0).getName() );\n\t\t}\n\n\t\tif ( generatorName.isEmpty() ) {\n\t\t\tfinal GeneratedValue generatedValue = idAttributeMember.getDirectAnnotationUsage( GeneratedValue.class );\n\t\t\tif ( generatedValue != null ) {\n\t\t\t\t// The mapping used @GeneratedValue but specified no name.  This is a special case added in JPA 3.2.\n\t\t\t\t// Look for a matching \"implied generator\" based on the GenerationType\n\n\t\t\t\tfinal GenerationType strategy = generatedValue.strategy();\n\t\t\t\tfinal String strategyGeneratorClassName = correspondingGeneratorName( strategy );\n\n\t\t\t\tfinal IdentifierGeneratorDefinition impliedGenerator = determineImpliedGenerator(\n\t\t\t\t\t\tstrategy,\n\t\t\t\t\t\tstrategyGeneratorClassName,\n\t\t\t\t\t\tlocalGenerators\n\t\t\t\t);\n\n\t\t\t\tif ( impliedGenerator != null ) {\n\t\t\t\t\tconfiguration.putAll( impliedGenerator.getParameters() );\n\n\t\t\t\t\tfinal BeanContainer beanContainer = beanContainer( context );\n\t\t\t\t\tidentifierValue.setCustomIdGeneratorCreator( creationContext -> {\n\t\t\t\t\t\tfinal Generator identifierGenerator = instantiateGenerator(\n\t\t\t\t\t\t\t\tbeanContainer,\n\t\t\t\t\t\t\t\tgeneratorClass( strategyGeneratorClassName, identifierValue )\n\t\t\t\t\t\t);\n\t\t\t\t\t\tcallConfigure( creationContext, identifierGenerator, configuration, identifierValue );\n\t\t\t\t\t\tif ( identifierGenerator instanceof IdentityGenerator) {\n\t\t\t\t\t\t\tidentifierValue.setColumnToIdentity();\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn identifierGenerator;\n\t\t\t\t\t} );\n\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfinal String generatorStrategy = determineStrategy(\n\t\t\t\tidAttributeMember,\n\t\t\t\tgeneratorType,\n\t\t\t\tgeneratorName,\n\t\t\t\tcontext,\n\t\t\t\tlocalGenerators,\n\t\t\t\tconfiguration\n\t\t);\n\t\tsetGeneratorCreator( identifierValue, configuration, generatorStrategy, context );\n\t}\n\n\tprivate static IdentifierGeneratorDefinition determineImpliedGenerator(\n\t\t\tGenerationType strategy,\n\t\t\tString strategyGeneratorClassName,\n\t\t\tMap<String, ? extends IdentifierGeneratorDefinition> localGenerators) {\n\t\tif ( localGenerators == null ) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif ( localGenerators.size() == 1 ) {\n\t\t\tfinal IdentifierGeneratorDefinition generatorDefinition = localGenerators.entrySet().iterator().next().getValue();\n\t\t\t// NOTE : a little bit of a special rule here for the case of just one -\n\t\t\t// \t\twe consider it a match, based on strategy, if the strategy is AUTO or matches...\n\t\t\tif ( strategy == AUTO\n\t\t\t\t\t|| isImpliedGenerator( strategy, strategyGeneratorClassName, generatorDefinition ) ) {\n\t\t\t\treturn generatorDefinition;\n\t\t\t}\n\t\t}\n\n\t\tIdentifierGeneratorDefinition matching = null;\n\t\tfor ( Map.Entry<String, ? extends IdentifierGeneratorDefinition> localGeneratorEntry : localGenerators.entrySet() ) {\n\t\t\tif ( isImpliedGenerator( strategy, strategyGeneratorClassName, localGeneratorEntry.getValue() ) ) {\n\t\t\t\tif ( matching != null ) {\n\t\t\t\t\t// we found multiple matching generators\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tmatching = localGeneratorEntry.getValue();\n\t\t\t}\n\t\t}\n\t\treturn matching;\n\t}\n\n\tprivate static boolean isImpliedGenerator(\n\t\t\tGenerationType strategy,\n\t\t\tString strategyGeneratorClassName,\n\t\t\tIdentifierGeneratorDefinition generatorDefinition) {\n\t\treturn generatorDefinition.getStrategy().equals( strategyGeneratorClassName );\n\t}\n\n\tprivate static String correspondingGeneratorName(GenerationType strategy) {\n\t\treturn switch ( strategy ) {\n//\t\t\tcase UUID -> org.hibernate.id.uuid.UuidGenerator.class.getName();\n\t\t\tcase UUID -> UuidValueGenerator.class.getName();\n\t\t\tcase TABLE -> org.hibernate.id.enhanced.TableGenerator.class.getName();\n\t\t\tcase IDENTITY -> null;\n\t\t\tdefault -> SequenceStyleGenerator.class.getName();\n\t\t};\n\t}\n\n\tprivate static String determineStrategy(\n\t\t\tMemberDetails idAttributeMember,\n\t\t\tString generatorType,\n\t\t\tString generatorName,\n\t\t\tMetadataBuildingContext context,\n\t\t\tMap<String, ? extends IdentifierGeneratorDefinition> localGenerators,\n\t\t\tMap<String, Object> configuration) {\n\t\tif ( !generatorName.isEmpty() ) {\n\t\t\t//we have a named generator\n\t\t\tfinal IdentifierGeneratorDefinition definition =\n\t\t\t\t\tmakeIdentifierGeneratorDefinition( generatorName, idAttributeMember, localGenerators, context );\n\t\t\tif ( definition == null ) {\n\t\t\t\tthrow new AnnotationException( \"No id generator was declared with the name '\" + generatorName\n\t\t\t\t\t\t+ \"' specified by '@GeneratedValue'\"\n\t\t\t\t\t\t+ \" (define a named generator using '@SequenceGenerator', '@TableGenerator', or '@GenericGenerator')\" );\n\t\t\t}\n\t\t\t//This is quite vague in the spec but a generator could override the generator choice\n\t\t\tfinal String generatorStrategy =\n\t\t\t\t\tgeneratorType == null\n\t\t\t\t\t\t//yuk! this is a hack not to override 'AUTO' even if generator is set\n\t\t\t\t\t\t|| !definition.getStrategy().equals( \"identity\" )\n\t\t\t\t\t\t\t? definition.getStrategy()\n\t\t\t\t\t\t\t: generatorType;\n\t\t\t//checkIfMatchingGenerator(definition, generatorType, generatorName);\n\t\t\tconfiguration.putAll( definition.getParameters() );\n\t\t\treturn generatorStrategy;\n\t\t}\n\t\telse {\n\t\t\treturn generatorType;\n\t\t}\n\t}\n\n\tprivate static IdentifierGeneratorDefinition makeIdentifierGeneratorDefinition(\n\t\t\tString name,\n\t\t\tMemberDetails idAttributeMember,\n\t\t\tMap<String, ? extends IdentifierGeneratorDefinition> localGenerators,\n\t\t\tMetadataBuildingContext buildingContext) {\n\t\tif ( localGenerators != null ) {\n\t\t\tfinal IdentifierGeneratorDefinition result = localGenerators.get( name );\n\t\t\tif ( result != null ) {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\n\t\tfinal IdentifierGeneratorDefinition globalDefinition =\n\t\t\t\tbuildingContext.getMetadataCollector().getIdentifierGenerator( name );\n\t\tif ( globalDefinition != null ) {\n\t\t\treturn globalDefinition;\n\t\t}\n\n\t\tLOG.debugf( \"Could not resolve explicit IdentifierGeneratorDefinition - using implicit interpretation (%s)\", name );\n\n\t\tfinal GeneratedValue generatedValue = idAttributeMember.getDirectAnnotationUsage( GeneratedValue.class );\n\t\tif ( generatedValue == null ) {\n\t\t\tthrow new AssertionFailure( \"No @GeneratedValue annotation\" );\n\t\t}\n\n\t\treturn IdentifierGeneratorDefinition.createImplicit(\n\t\t\t\tname,\n\t\t\t\tidAttributeMember.getType(),\n\t\t\t\tgeneratedValue.generator(),\n\t\t\t\tinterpretGenerationType( generatedValue )\n\t\t);\n\t}\n\n\tprivate static GenerationType interpretGenerationType(GeneratedValue generatedValueAnn) {\n\t\t// todo (jpa32) : when can this ever be null?\n\t\tfinal GenerationType strategy = generatedValueAnn.strategy();\n\t\treturn strategy == null ? AUTO : strategy;\n\t}\n\n\tpublic static void visitIdGeneratorDefinitions(\n\t\t\tAnnotationTarget annotatedElement,\n\t\t\tConsumer<IdentifierGeneratorDefinition> consumer,\n\t\t\tMetadataBuildingContext context) {\n\t\tfinal InFlightMetadataCollector metadataCollector = context.getMetadataCollector();\n\t\tfinal SourceModelBuildingContext sourceModelContext = metadataCollector.getSourceModelBuildingContext();\n\n\t\tannotatedElement.forEachAnnotationUsage( TableGenerator.class, sourceModelContext, (usage) -> {\n\t\t\tfinal IdentifierGeneratorDefinition idGenerator = buildTableIdGenerator( usage );\n\t\t\tconsumer.accept( idGenerator );\n\t\t} );\n\n\t\tannotatedElement.forEachAnnotationUsage( SequenceGenerator.class, sourceModelContext, (usage) -> {\n\t\t\tfinal IdentifierGeneratorDefinition idGenerator = buildSequenceIdGenerator( usage );\n\t\t\tconsumer.accept( idGenerator );\n\t\t} );\n\n\t\tannotatedElement.forEachAnnotationUsage( GenericGenerator.class, sourceModelContext, (usage) -> {\n\t\t\tfinal IdentifierGeneratorDefinition idGenerator = buildIdGenerator( usage );\n\t\t\tconsumer.accept( idGenerator );\n\t\t} );\n\n\t}\n\n\tpublic static void registerGlobalGenerators(\n\t\t\tAnnotationTarget annotatedElement,\n\t\t\tMetadataBuildingContext context) {\n\t\tif ( !context.getBootstrapContext().getJpaCompliance().isGlobalGeneratorScopeEnabled() ) {\n\t\t\treturn;\n\t\t}\n\n\t\tfinal InFlightMetadataCollector metadataCollector = context.getMetadataCollector();\n\t\tvisitIdGeneratorDefinitions(\n\t\t\t\tannotatedElement,\n\t\t\t\t(definition) -> {\n\t\t\t\t\tif ( !definition.getName().isEmpty() ) {\n\t\t\t\t\t\tmetadataCollector.addIdentifierGenerator( definition );\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tcontext\n\t\t);\n\t}\n\n\tprivate static IdentifierGeneratorDefinition buildIdGenerator(GenericGenerator generatorAnnotation) {\n\t\tfinal IdentifierGeneratorDefinition.Builder definitionBuilder =\n\t\t\t\tnew IdentifierGeneratorDefinition.Builder();\n\t\tdefinitionBuilder.setName( generatorAnnotation.name() );\n\t\tfinal Class<? extends Generator> generatorClass = generatorAnnotation.type();\n\t\tfinal String strategy =\n\t\t\t\tgeneratorClass.equals( Generator.class )\n\t\t\t\t\t\t? generatorAnnotation.strategy()\n\t\t\t\t\t\t: generatorClass.getName();\n\t\tdefinitionBuilder.setStrategy( strategy );\n\t\tdefinitionBuilder.addParams( extractParameterMap( generatorAnnotation.parameters() ) );\n\n\t\tif ( LOG.isTraceEnabled() ) {\n\t\t\tLOG.tracev( \"Added generator with name: {0}, strategy: {0}\",\n\t\t\t\t\tdefinitionBuilder.getName(), definitionBuilder.getStrategy() );\n\t\t}\n\n\t\treturn definitionBuilder.build();\n\t}\n\n\tprivate static IdentifierGeneratorDefinition buildSequenceIdGenerator(SequenceGenerator generatorAnnotation) {\n\t\tfinal IdentifierGeneratorDefinition.Builder definitionBuilder = new IdentifierGeneratorDefinition.Builder();\n\t\tinterpretSequenceGenerator( generatorAnnotation, definitionBuilder );\n\t\tif ( LOG.isTraceEnabled() ) {\n\t\t\tLOG.tracev( \"Add sequence generator with name: {0}\", definitionBuilder.getName() );\n\t\t}\n\t\treturn definitionBuilder.build();\n\t}\n\n\tprivate static IdentifierGeneratorDefinition buildTableIdGenerator(TableGenerator generatorAnnotation) {\n\t\tfinal IdentifierGeneratorDefinition.Builder definitionBuilder = new IdentifierGeneratorDefinition.Builder();\n\t\tinterpretTableGenerator( generatorAnnotation, definitionBuilder );\n\t\tif ( LOG.isTraceEnabled() ) {\n\t\t\tLOG.tracev( \"Add sequence generator with name: {0}\", definitionBuilder.getName() );\n\t\t}\n\t\treturn definitionBuilder.build();\n\t}\n\n\tprivate static void checkGeneratorClass(Class<? extends Generator> generatorClass) {\n\t\tif ( !BeforeExecutionGenerator.class.isAssignableFrom( generatorClass )\n\t\t\t\t&& !OnExecutionGenerator.class.isAssignableFrom( generatorClass ) ) {\n\t\t\tthrow new MappingException(\"Generator class '\" + generatorClass.getName()\n\t\t\t\t\t+ \"' must implement either 'BeforeExecutionGenerator' or 'OnExecutionGenerator'\");\n\t\t}\n\t}\n\n\tprivate static void checkGeneratorInterfaces(Class<? extends Generator> generatorClass) {\n\t\t// we don't yet support the additional \"fancy\" operations of\n\t\t// IdentifierGenerator with regular generators, though this\n\t\t// would be extremely easy to add if anyone asks for it\n\t\tif ( IdentifierGenerator.class.isAssignableFrom( generatorClass ) ) {\n\t\t\tthrow new AnnotationException(\"Generator class '\" + generatorClass.getName()\n\t\t\t\t\t+ \"' implements 'IdentifierGenerator' and may not be used with '@ValueGenerationType'\");\n\t\t}\n\t\tif ( ExportableProducer.class.isAssignableFrom( generatorClass ) ) {\n\t\t\tthrow new AnnotationException(\"Generator class '\" + generatorClass.getName()\n\t\t\t\t\t+ \"' implements 'ExportableProducer' and may not be used with '@ValueGenerationType'\");\n\t\t}\n\t}\n\n\t/**\n\t * Return a {@link GeneratorCreator} for an attribute annotated\n\t * with a {@linkplain ValueGenerationType generator annotation}.\n\t */\n\tprivate static GeneratorCreator generatorCreator(\n\t\t\tMemberDetails memberDetails,\n\t\t\tAnnotation annotation,\n\t\t\tBeanContainer beanContainer) {\n\t\tfinal Class<? extends Annotation> annotationType = annotation.annotationType();\n\t\tfinal ValueGenerationType generatorAnnotation = annotationType.getAnnotation( ValueGenerationType.class );\n\t\tassert generatorAnnotation != null;\n\t\tfinal Class<? extends Generator> generatorClass = generatorAnnotation.generatedBy();\n\t\tcheckGeneratorClass( generatorClass );\n\t\tcheckGeneratorInterfaces( generatorClass );\n\t\treturn creationContext -> {\n\t\t\tfinal Generator generator = instantiateGenerator(\n\t\t\t\t\tannotation,\n\t\t\t\t\tbeanContainer,\n\t\t\t\t\tcreationContext,\n\t\t\t\t\tgeneratorClass,\n\t\t\t\t\tmemberDetails,\n\t\t\t\t\tannotationType\n\t\t\t);\n\t\t\tcallInitialize( annotation, memberDetails, creationContext, generator );\n\t\t\t//TODO: callConfigure( creationContext, generator, emptyMap(), identifierValue );\n\t\t\tcheckVersionGenerationAlways( memberDetails, generator );\n\t\t\treturn generator;\n\t\t};\n\t}\n\n\t/**\n\t * Return a {@link GeneratorCreator} for an id attribute annotated\n\t * with an {@linkplain IdGeneratorType id generator annotation}.\n\t */\n\tprivate static GeneratorCreator identifierGeneratorCreator(\n\t\t\tMemberDetails idAttributeMember,\n\t\t\tAnnotation annotation,\n\t\t\tSimpleValue identifierValue,\n\t\t\tBeanContainer beanContainer) {\n\t\tfinal Class<? extends Annotation> annotationType = annotation.annotationType();\n\t\tfinal IdGeneratorType idGeneratorAnnotation = annotationType.getAnnotation( IdGeneratorType.class );\n\t\tassert idGeneratorAnnotation != null;\n\t\tfinal Class<? extends Generator> generatorClass = idGeneratorAnnotation.value();\n\t\tcheckGeneratorClass( generatorClass );\n\t\treturn creationContext -> {\n\t\t\tfinal Generator generator =\n\t\t\t\t\tinstantiateGenerator(\n\t\t\t\t\t\t\tannotation,\n\t\t\t\t\t\t\tbeanContainer,\n\t\t\t\t\t\t\tcreationContext,\n\t\t\t\t\t\t\tgeneratorClass,\n\t\t\t\t\t\t\tidAttributeMember,\n\t\t\t\t\t\t\tannotationType\n\t\t\t\t\t);\n\t\t\tcallInitialize( annotation, idAttributeMember, creationContext, generator );\n\t\t\tcallConfigure( creationContext, generator, emptyMap(), identifierValue );\n\t\t\tcheckIdGeneratorTiming( annotationType, generator );\n\t\t\treturn generator;\n\t\t};\n\t}\n\n\t/**\n\t * Instantiate a {@link Generator}, using the given {@link BeanContainer} if any,\n\t * for the case where the generator was specified using a generator annotation.\n\t *\n\t * @param annotation the generator annotation\n\t * @param beanContainer an optional {@code BeanContainer}\n\t * @param generatorClass a class which implements {@code Generator}\n\t */\n\tprivate static Generator instantiateGenerator(\n\t\t\tAnnotation annotation,\n\t\t\tBeanContainer beanContainer,\n\t\t\tGeneratorCreationContext creationContext,\n\t\t\tClass<? extends Generator> generatorClass,\n\t\t\tMemberDetails memberDetails,\n\t\t\tClass<? extends Annotation> annotationType) {\n\t\tif ( beanContainer != null ) {\n\t\t\treturn instantiateGeneratorAsBean(\n\t\t\t\t\tannotation,\n\t\t\t\t\tbeanContainer,\n\t\t\t\t\tcreationContext,\n\t\t\t\t\tgeneratorClass,\n\t\t\t\t\tmemberDetails,\n\t\t\t\t\tannotationType\n\t\t\t);\n\t\t}\n\t\telse {\n\t\t\treturn instantiateGenerator(\n\t\t\t\t\tannotation,\n\t\t\t\t\tmemberDetails,\n\t\t\t\t\tannotationType,\n\t\t\t\t\tcreationContext,\n\t\t\t\t\tgeneratorClass\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * Instantiate a {@link Generator}, using the given {@link BeanContainer},\n\t * for the case where the generator was specified using a generator annotation.\n\t *\n\t * @param annotation the generator annotation\n\t * @param beanContainer an optional {@code BeanContainer}\n\t * @param generatorClass a class which implements {@code Generator}\n\t */\n\tprivate static Generator instantiateGeneratorAsBean(\n\t\t\tAnnotation annotation,\n\t\t\tBeanContainer beanContainer,\n\t\t\tGeneratorCreationContext creationContext,\n\t\t\tClass<? extends Generator> generatorClass,\n\t\t\tMemberDetails memberDetails,\n\t\t\tClass<? extends Annotation> annotationType) {\n\t\treturn Helper.getBean(\n\t\t\tbeanContainer,\n\t\t\tgeneratorClass,\n\t\t\tfalse,\n\t\t\ttrue,\n\t\t\t() -> instantiateGenerator(\n\t\t\t\tannotation,\n\t\t\t\tmemberDetails,\n\t\t\t\tannotationType,\n\t\t\t\tcreationContext,\n\t\t\t\tgeneratorClass\n\t\t\t)\n\t\t);\n\t}\n\n\t/**\n\t * Instantiate a {@link Generator}, using the given {@link BeanContainer},\n\t * for the case where no generator annotation is available.\n\t *\n\t * @param beanContainer an optional {@code BeanContainer}\n\t * @param generatorClass a class which implements {@code Generator}\n\t */\n\tprivate static <T extends Generator> T instantiateGeneratorAsBean(\n\t\t\tBeanContainer beanContainer,\n\t\t\tClass<T> generatorClass) {\n\t\treturn Helper.getBean(\n\t\t\tbeanContainer,\n\t\t\tgeneratorClass,\n\t\t\tfalse,\n\t\t\ttrue,\n\t\t\t() -> instantiateGeneratorViaDefaultConstructor( generatorClass )\n\t\t);\n\t}\n\n\t/**\n\t * Instantiate a {@link Generator} by calling an appropriate constructor,\n\t * for the case where the generator was specified using a generator annotation.\n\t * We look for three possible signatures:\n\t * <ol>\n\t *     <li>{@code (Annotation, Member, GeneratorCreationContext)}</li>\n\t *     <li>{@code (Annotation)}</li>\n\t *     <li>{@code ()}</li>\n\t * </ol>\n\t * where {@code Annotation} is the generator annotation type.\n\t *\n\t * @param annotation the generator annotation\n\t * @param generatorClass a class which implements {@code Generator}\n\t */\n\tprivate static <G extends Generator> G instantiateGenerator(\n\t\t\tAnnotation annotation,\n\t\t\tMemberDetails memberDetails,\n\t\t\tClass<? extends Annotation> annotationType,\n\t\t\tGeneratorCreationContext creationContext,\n\t\t\tClass<? extends G> generatorClass) {\n\t\ttry {\n\t\t\ttry {\n\t\t\t\treturn generatorClass.getConstructor( annotationType, Member.class, GeneratorCreationContext.class )\n\t\t\t\t\t\t.newInstance( annotation, memberDetails.toJavaMember(), creationContext);\n\t\t\t}\n\t\t\tcatch (NoSuchMethodException ignore) {\n\t\t\t\ttry {\n\t\t\t\t\treturn generatorClass.getConstructor( annotationType )\n\t\t\t\t\t\t\t.newInstance( annotation );\n\t\t\t\t}\n\t\t\t\tcatch (NoSuchMethodException i) {\n\t\t\t\t\treturn instantiateGeneratorViaDefaultConstructor( generatorClass );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (InvocationTargetException | InstantiationException | IllegalAccessException | IllegalArgumentException e) {\n\t\t\tthrow new org.hibernate.InstantiationException( \"Could not instantiate id generator\", generatorClass, e );\n\t\t}\n\t}\n\n\t/**\n\t * Instantiate a {@link Generator}, using the given {@link BeanContainer} if any,\n\t * or by calling the default constructor otherwise.\n\t *\n\t * @param beanContainer an optional {@code BeanContainer}\n\t * @param generatorClass a class which implements {@code Generator}\n\t */\n\tpublic static <T extends Generator> T instantiateGenerator(\n\t\t\tBeanContainer beanContainer,\n\t\t\tClass<T> generatorClass) {\n\t\tif ( beanContainer != null ) {\n\t\t\treturn instantiateGeneratorAsBean( beanContainer, generatorClass );\n\t\t}\n\t\telse {\n\t\t\treturn instantiateGeneratorViaDefaultConstructor( generatorClass );\n\t\t}\n\t}\n\n\t/**\n\t * Instantiate a {@link Generator} by calling the default constructor.\n\t */\n\tprivate static <G extends Generator> G instantiateGeneratorViaDefaultConstructor(Class<? extends G> generatorClass) {\n\t\ttry {\n\t\t\treturn generatorClass.getDeclaredConstructor().newInstance();\n\t\t}\n\t\tcatch (NoSuchMethodException e) {\n\t\t\tthrow new org.hibernate.InstantiationException( \"No appropriate constructor for id generator class\", generatorClass);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new org.hibernate.InstantiationException( \"Could not instantiate id generator\", generatorClass, e );\n\t\t}\n\t}\n\n\tpublic static <A extends Annotation> void callInitialize(\n\t\t\tA annotation,\n\t\t\tMemberDetails memberDetails,\n\t\t\tGeneratorCreationContext creationContext,\n\t\t\tGenerator generator) {\n\t\tif ( generator instanceof AnnotationBasedGenerator ) {\n\t\t\t// This will cause a CCE in case the generation type doesn't match the annotation type; As this would be\n\t\t\t// a programming error of the generation type developer and thus should show up during testing, we don't\n\t\t\t// check this explicitly; If required, this could be done e.g. using ClassMate\n\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\tfinal AnnotationBasedGenerator<A> generation = (AnnotationBasedGenerator<A>) generator;\n\t\t\tgeneration.initialize( annotation, memberDetails.toJavaMember(), creationContext );\n\t\t}\n\t}\n\n\tprivate static void checkVersionGenerationAlways(MemberDetails property, Generator generator) {\n\t\tif ( property.hasDirectAnnotationUsage( Version.class ) ) {\n\t\t\tif ( !generator.generatesOnInsert() ) {\n\t\t\t\tthrow new AnnotationException(\"Property '\" + property.getName()\n\t\t\t\t\t\t+ \"' is annotated '@Version' but has a 'Generator' which does not generate on inserts\"\n\t\t\t\t);\n\t\t\t}\n\t\t\tif ( !generator.generatesOnUpdate() ) {\n\t\t\t\tthrow new AnnotationException(\"Property '\" + property.getName()\n\t\t\t\t\t\t+ \"' is annotated '@Version' but has a 'Generator' which does not generate on updates\"\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * If the given {@link Generator} also implements {@link Configurable},\n\t * call its {@link Configurable#configure(GeneratorCreationContext, Properties)\n\t * configure()} method.\n\t */\n\tpublic static void callConfigure(\n\t\t\tGeneratorCreationContext creationContext,\n\t\t\tGenerator generator,\n\t\t\tMap<String, Object> configuration,\n\t\t\tSimpleValue identifierValue) {\n\t\tif ( generator instanceof Configurable configurable ) {\n\t\t\tfinal Properties parameters = collectParameters(\n\t\t\t\t\tidentifierValue,\n\t\t\t\t\tcreationContext.getDatabase().getDialect(),\n\t\t\t\t\tcreationContext.getRootClass(),\n\t\t\t\t\tconfiguration\n\t\t\t);\n\t\t\tconfigurable.configure( creationContext, parameters );\n\t\t}\n\t\tif ( generator instanceof ExportableProducer exportableProducer ) {\n\t\t\texportableProducer.registerExportables( creationContext.getDatabase() );\n\t\t}\n\t\tif ( generator instanceof Configurable configurable ) {\n\t\t\tconfigurable.initialize( creationContext.getSqlStringGenerationContext() );\n\t\t}\n\t}\n\n\tprivate static void checkIdGeneratorTiming(Class<? extends Annotation> annotationType, Generator generator) {\n\t\tif ( !generator.generatesOnInsert() ) {\n\t\t\tthrow new MappingException( \"Annotation '\" + annotationType\n\t\t\t\t\t+ \"' is annotated 'IdGeneratorType' but the given 'Generator' does not generate on inserts\");\n\t\t}\n\t\tif ( generator.generatesOnUpdate() ) {\n\t\t\tthrow new MappingException( \"Annotation '\" + annotationType\n\t\t\t\t\t+ \"' is annotated 'IdGeneratorType' but the given 'Generator' generates on updates (it must generate only on inserts)\");\n\t\t}\n\t}\n\n\t/**\n\t * Create a generator, based on a {@link GeneratedValue} annotation.\n\t */\n\tprivate static void createIdGenerator(\n\t\t\tMemberDetails idMember,\n\t\t\tSimpleValue idValue,\n\t\t\tPersistentClass persistentClass,\n\t\t\tMetadataBuildingContext context) {\n\t\t// NOTE: `generatedValue` is never null here\n\t\tfinal GeneratedValue generatedValue = castNonNull( idMember.getDirectAnnotationUsage( GeneratedValue.class ) );\n\n\t\tfinal InFlightMetadataCollector metadataCollector = context.getMetadataCollector();\n\t\tif ( isGlobalGeneratorNameGlobal( context ) ) {\n\t\t\t// process and register any generators defined on the member.\n\t\t\t// according to JPA these are also global.\n\t\t\tmetadataCollector.getGlobalRegistrations().as( GlobalRegistrar.class ).collectIdGenerators( idMember );\n\t\t\tmetadataCollector.addSecondPass( new StrictIdGeneratorResolverSecondPass(\n\t\t\t\t\tpersistentClass,\n\t\t\t\t\tidValue,\n\t\t\t\t\tidMember,\n\t\t\t\t\tgeneratedValue,\n\t\t\t\t\tcontext\n\t\t\t) );\n\t\t}\n\t\telse {\n\t\t\tmetadataCollector.addSecondPass( new IdGeneratorResolverSecondPass(\n\t\t\t\t\tpersistentClass,\n\t\t\t\t\tidValue,\n\t\t\t\t\tidMember,\n\t\t\t\t\tgeneratedValue,\n\t\t\t\t\tcontext\n\t\t\t) );\n\t\t}\n\t}\n\n\tpublic static void createGeneratorFrom(\n\t\t\tIdentifierGeneratorDefinition defaultedGenerator,\n\t\t\tSimpleValue idValue,\n\t\t\tMap<String, Object> configuration,\n\t\t\tMetadataBuildingContext context) {\n\t\tconfiguration.putAll( defaultedGenerator.getParameters() );\n\n\t\tfinal BeanContainer beanContainer = beanContainer( context );\n\t\tidValue.setCustomIdGeneratorCreator( creationContext -> {\n\t\t\tfinal Generator identifierGenerator = instantiateGenerator(\n\t\t\t\t\tbeanContainer,\n\t\t\t\t\tgeneratorClass( defaultedGenerator.getStrategy(), idValue )\n\t\t\t);\n\t\t\tcallConfigure( creationContext, identifierGenerator, configuration, idValue );\n\t\t\tif ( identifierGenerator instanceof IdentityGenerator) {\n\t\t\t\tidValue.setColumnToIdentity();\n\t\t\t}\n\t\t\treturn identifierGenerator;\n\t\t} );\n\t}\n\n\n\tpublic static void createGeneratorFrom(\n\t\t\tIdentifierGeneratorDefinition defaultedGenerator,\n\t\t\tSimpleValue idValue,\n\t\t\tMetadataBuildingContext context) {\n\t\tcreateGeneratorFrom(\n\t\t\t\tdefaultedGenerator,\n\t\t\t\tidValue,\n\t\t\t\tbuildConfigurationMap( idValue ),\n\t\t\t\tcontext\n\t\t);\n\t}\n\n\tprivate static Map<String, Object> buildConfigurationMap(KeyValue idValue) {\n\t\tfinal Map<String,Object> configuration = new HashMap<>();\n\t\tconfiguration.put( PersistentIdentifierGenerator.TABLE, idValue.getTable().getName() );\n\t\tif ( idValue.getColumnSpan() == 1 ) {\n\t\t\tconfiguration.put( PersistentIdentifierGenerator.PK, idValue.getColumns().get(0).getName() );\n\t\t}\n\t\treturn configuration;\n\t}\n\n\t/**\n\t * Set up the identifier generator for an id defined in a {@code hbm.xml} mapping.\n\t *\n\t * @see org.hibernate.boot.model.source.internal.hbm.ModelBinder\n\t */\n\tpublic static void makeIdGenerator(\n\t\t\tfinal MappingDocument sourceDocument,\n\t\t\tIdentifierGeneratorDefinition definition,\n\t\t\tSimpleValue identifierValue,\n\t\t\tMetadataBuildingContext context) {\n\n\t\tif ( definition != null ) {\n\t\t\t// see if the specified generator name matches a registered <identifier-generator/>\n\t\t\tfinal IdentifierGeneratorDefinition generatorDef =\n\t\t\t\t\tsourceDocument.getMetadataCollector()\n\t\t\t\t\t\t\t.getIdentifierGenerator( definition.getName() );\n\t\t\tfinal Map<String,Object> configuration = new HashMap<>();\n\t\t\tfinal String generatorStrategy;\n\t\t\tif ( generatorDef != null ) {\n\t\t\t\tgeneratorStrategy = generatorDef.getStrategy();\n\t\t\t\tconfiguration.putAll( generatorDef.getParameters() );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tgeneratorStrategy = definition.getStrategy();\n\t\t\t}\n\n\t\t\tconfiguration.putAll( definition.getParameters() );\n\n\t\t\tsetGeneratorCreator( identifierValue, configuration, generatorStrategy, context );\n\t\t}\n\t}\n\n\t/**\n\t * Obtain a {@link BeanContainer} to be used for instantiating generators.\n\t */\n\tpublic static BeanContainer beanContainer(MetadataBuildingContext buildingContext) {\n\t\treturn Helper.getBeanContainer( buildingContext.getBootstrapContext().getServiceRegistry() );\n\t}\n\n\t/**\n\t * Set up the {@link GeneratorCreator} for a case where there is no\n\t * generator annotation.\n\t */\n\tprivate static void setGeneratorCreator(\n\t\t\tSimpleValue identifierValue,\n\t\t\tMap<String, Object> configuration,\n\t\t\tString generatorStrategy,\n\t\t\tMetadataBuildingContext context) {\n\t\tif ( ASSIGNED_GENERATOR_NAME.equals( generatorStrategy )\n\t\t\t\t|| org.hibernate.id.Assigned.class.getName().equals( generatorStrategy ) ) {\n\t\t\tidentifierValue.setCustomIdGeneratorCreator( ASSIGNED_IDENTIFIER_GENERATOR_CREATOR );\n\t\t}\n\t\telse {\n\t\t\tfinal BeanContainer beanContainer = beanContainer( context );\n\t\t\tidentifierValue.setCustomIdGeneratorCreator( creationContext -> {\n\t\t\t\tfinal Generator identifierGenerator =\n\t\t\t\t\t\tinstantiateGenerator( beanContainer, generatorClass( generatorStrategy, identifierValue ) );\n\t\t\t\tcallConfigure( creationContext, identifierGenerator, configuration, identifierValue );\n\t\t\t\tif ( identifierGenerator instanceof IdentityGenerator) {\n\t\t\t\t\tidentifierValue.setColumnToIdentity();\n\t\t\t\t}\n\t\t\t\treturn identifierGenerator;\n\t\t\t} );\n\t\t}\n\t}\n\n\t/**\n\t * Set up the id generator by considering all annotations of the identifier\n\t * field, including {@linkplain IdGeneratorType id generator annotations},\n\t * and {@link GeneratedValue}.\n\t */\n\tstatic void createIdGeneratorsFromGeneratorAnnotations(\n\t\t\tPropertyHolder propertyHolder,\n\t\t\tPropertyData inferredData,\n\t\t\tSimpleValue idValue,\n\t\t\tMetadataBuildingContext context) {\n\n\t\tfinal SourceModelBuildingContext sourceModelContext =\n\t\t\t\tcontext.getMetadataCollector().getSourceModelBuildingContext();\n\t\tfinal MemberDetails idAttributeMember = inferredData.getAttributeMember();\n\t\tfinal List<? extends Annotation> idGeneratorAnnotations =\n\t\t\t\tidAttributeMember.getMetaAnnotated( IdGeneratorType.class, sourceModelContext );\n\t\tfinal List<? extends Annotation> generatorAnnotations =\n\t\t\t\tidAttributeMember.getMetaAnnotated( ValueGenerationType.class, sourceModelContext );\n\t\t// Since these collections may contain Proxies created by common-annotations module we cannot reliably use simple remove/removeAll\n\t\t// collection methods as those proxies do not implement hashcode/equals and even a simple `a.equals(a)` will return `false`.\n\t\t// Instead, we will check the annotation types, since generator annotations should not be \"repeatable\" we should have only\n\t\t// at most one annotation for a generator:\n\t\tfor ( Annotation id : idGeneratorAnnotations ) {\n\t\t\tgeneratorAnnotations.removeIf( gen -> gen.annotationType().equals( id.annotationType() ) );\n\t\t}\n\n\t\tif ( idGeneratorAnnotations.size() + generatorAnnotations.size() > 1 ) {\n\t\t\tthrow new AnnotationException( String.format(\n\t\t\t\t\tLocale.ROOT,\n\t\t\t\t\t\"Identifier attribute '%s' has too many generator annotations: %s\",\n\t\t\t\t\tgetPath( propertyHolder, inferredData ),\n\t\t\t\t\tcombineUntyped( idGeneratorAnnotations, generatorAnnotations )\n\t\t\t) );\n\t\t}\n\t\tif ( !idGeneratorAnnotations.isEmpty() ) {\n\t\t\tidValue.setCustomIdGeneratorCreator( identifierGeneratorCreator(\n\t\t\t\t\tidAttributeMember,\n\t\t\t\t\tidGeneratorAnnotations.get(0),\n\t\t\t\t\tidValue,\n\t\t\t\t\tbeanContainer( context )\n\t\t\t) );\n\t\t}\n\t\telse if ( !generatorAnnotations.isEmpty() ) {\n//\t\t\tidValue.setCustomGeneratorCreator( generatorCreator( idAttributeMember, generatorAnnotation ) );\n\t\t\tthrow new AnnotationException( String.format(\n\t\t\t\t\tLocale.ROOT,\n\t\t\t\t\t\"Identifier attribute '%s' is annotated '%s' which is not an '@IdGeneratorType'\",\n\t\t\t\t\tgetPath( propertyHolder, inferredData ),\n\t\t\t\t\tgeneratorAnnotations.get(0).annotationType()\n\t\t\t) );\n\t\t}\n\t\telse if ( idAttributeMember.hasDirectAnnotationUsage( GeneratedValue.class ) ) {\n\t\t\tcreateIdGenerator( idAttributeMember, idValue, propertyHolder.getPersistentClass(), context );\n\t\t}\n\t}\n\n\t/**\n\t * Returns the value generation strategy for the given property, if any, by\n\t * considering {@linkplain ValueGenerationType generator type annotations}.\n\t */\n\tstatic GeneratorCreator createValueGeneratorFromAnnotations(\n\t\t\tPropertyHolder holder, String propertyName,\n\t\t\tMemberDetails property, MetadataBuildingContext context) {\n\t\tfinal List<? extends Annotation> generatorAnnotations =\n\t\t\t\tproperty.getMetaAnnotated( ValueGenerationType.class,\n\t\t\t\t\t\tcontext.getMetadataCollector().getSourceModelBuildingContext() );\n\t\treturn switch ( generatorAnnotations.size() ) {\n\t\t\tcase 0 -> null;\n\t\t\tcase 1 -> generatorCreator( property, generatorAnnotations.get(0), beanContainer( context ) );\n\t\t\tdefault -> throw new AnnotationException( \"Property '\" + qualify( holder.getPath(), propertyName )\n\t\t\t\t\t+ \"' has too many generator annotations: \" + generatorAnnotations );\n\t\t};\n\t}\n\n\tpublic static void applyIfNotEmpty(String name, String value, BiConsumer<String,String> consumer) {\n\t\tif ( StringHelper.isNotEmpty( value ) ) {\n\t\t\tconsumer.accept( name, value );\n\t\t}\n\t}\n}\n",
        "filePathAfter": "hibernate-core/src/main/java/org/hibernate/boot/model/internal/GeneratorBinder.java",
        "sourceCodeAfterForWhole": "/*\n * SPDX-License-Identifier: LGPL-2.1-or-later\n * Copyright Red Hat Inc. and Hibernate Authors\n */\npackage org.hibernate.boot.model.internal;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Member;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Properties;\nimport java.util.function.BiConsumer;\nimport java.util.function.Consumer;\n\nimport org.hibernate.AnnotationException;\nimport org.hibernate.AssertionFailure;\nimport org.hibernate.MappingException;\nimport org.hibernate.annotations.GenericGenerator;\nimport org.hibernate.annotations.IdGeneratorType;\nimport org.hibernate.annotations.ValueGenerationType;\nimport org.hibernate.boot.model.IdentifierGeneratorDefinition;\nimport org.hibernate.boot.model.relational.ExportableProducer;\nimport org.hibernate.boot.model.source.internal.hbm.MappingDocument;\nimport org.hibernate.boot.models.spi.GlobalRegistrar;\nimport org.hibernate.boot.spi.InFlightMetadataCollector;\nimport org.hibernate.boot.spi.MetadataBuildingContext;\nimport org.hibernate.boot.spi.PropertyData;\nimport org.hibernate.generator.AnnotationBasedGenerator;\nimport org.hibernate.generator.Assigned;\nimport org.hibernate.generator.BeforeExecutionGenerator;\nimport org.hibernate.generator.Generator;\nimport org.hibernate.generator.GeneratorCreationContext;\nimport org.hibernate.generator.OnExecutionGenerator;\nimport org.hibernate.id.Configurable;\nimport org.hibernate.id.IdentifierGenerator;\nimport org.hibernate.id.IdentityGenerator;\nimport org.hibernate.id.PersistentIdentifierGenerator;\nimport org.hibernate.id.enhanced.SequenceStyleGenerator;\nimport org.hibernate.id.uuid.UuidValueGenerator;\nimport org.hibernate.internal.CoreLogging;\nimport org.hibernate.internal.CoreMessageLogger;\nimport org.hibernate.mapping.GeneratorCreator;\nimport org.hibernate.mapping.KeyValue;\nimport org.hibernate.mapping.PersistentClass;\nimport org.hibernate.mapping.SimpleValue;\nimport org.hibernate.models.spi.AnnotationTarget;\nimport org.hibernate.models.spi.MemberDetails;\nimport org.hibernate.models.spi.SourceModelBuildingContext;\nimport org.hibernate.resource.beans.container.spi.BeanContainer;\nimport org.hibernate.resource.beans.internal.Helper;\n\nimport jakarta.persistence.GeneratedValue;\nimport jakarta.persistence.GenerationType;\nimport jakarta.persistence.SequenceGenerator;\nimport jakarta.persistence.TableGenerator;\nimport jakarta.persistence.Version;\n\nimport static jakarta.persistence.GenerationType.AUTO;\nimport static java.util.Collections.emptyMap;\nimport static org.hibernate.boot.model.internal.AnnotationHelper.extractParameterMap;\nimport static org.hibernate.boot.model.internal.BinderHelper.getPath;\nimport static org.hibernate.boot.model.internal.BinderHelper.isGlobalGeneratorNameGlobal;\nimport static org.hibernate.boot.model.internal.GeneratorParameters.collectParameters;\nimport static org.hibernate.boot.model.internal.GeneratorParameters.interpretSequenceGenerator;\nimport static org.hibernate.boot.model.internal.GeneratorParameters.interpretTableGenerator;\nimport static org.hibernate.boot.model.internal.GeneratorStrategies.generatorClass;\nimport static org.hibernate.id.IdentifierGenerator.GENERATOR_NAME;\nimport static org.hibernate.internal.util.NullnessUtil.castNonNull;\nimport static org.hibernate.internal.util.StringHelper.isNotEmpty;\nimport static org.hibernate.internal.util.StringHelper.qualify;\nimport static org.hibernate.internal.util.collections.CollectionHelper.combineUntyped;\n\n/**\n * Responsible for configuring and instantiating {@link Generator}s.\n *\n * @author Gavin King\n */\npublic class GeneratorBinder {\n\n\tprivate static final CoreMessageLogger LOG = CoreLogging.messageLogger( GeneratorBinder.class );\n\n\tpublic static final String ASSIGNED_GENERATOR_NAME = \"assigned\";\n\tpublic static final GeneratorCreator ASSIGNED_IDENTIFIER_GENERATOR_CREATOR =\n\t\t\tnew GeneratorCreator() {\n\t\t\t\t@Override\n\t\t\t\tpublic Generator createGenerator(GeneratorCreationContext context) {\n\t\t\t\t\treturn new Assigned();\n\t\t\t\t}\n\t\t\t\t@Override\n\t\t\t\tpublic boolean isAssigned() {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t};\n\n\t/**\n\t * Create a generator, based on a {@link GeneratedValue} annotation.\n\t */\n\tpublic static void makeIdGenerator(\n\t\t\tSimpleValue identifierValue,\n\t\t\tMemberDetails idAttributeMember,\n\t\t\tString generatorType,\n\t\t\tString generatorName,\n\t\t\tMetadataBuildingContext context,\n\t\t\tMap<String, ? extends IdentifierGeneratorDefinition> localGenerators) {\n\n\t\t//generator settings\n\t\tfinal Map<String,Object> configuration = new HashMap<>();\n\t\tconfiguration.put( GENERATOR_NAME, generatorName );\n\t\tconfiguration.put( PersistentIdentifierGenerator.TABLE, identifierValue.getTable().getName() );\n\t\tif ( identifierValue.getColumnSpan() == 1 ) {\n\t\t\tconfiguration.put( PersistentIdentifierGenerator.PK, identifierValue.getColumns().get(0).getName() );\n\t\t}\n\n\t\tif ( generatorName.isEmpty() ) {\n\t\t\tfinal GeneratedValue generatedValue = idAttributeMember.getDirectAnnotationUsage( GeneratedValue.class );\n\t\t\tif ( generatedValue != null ) {\n\t\t\t\t// The mapping used @GeneratedValue but specified no name.  This is a special case added in JPA 3.2.\n\t\t\t\t// Look for a matching \"implied generator\" based on the GenerationType\n\t\t\t\tfinal GenerationType strategy = generatedValue.strategy();\n\t\t\t\tfinal String strategyGeneratorClassName = correspondingGeneratorName( strategy );\n\t\t\t\tfinal IdentifierGeneratorDefinition impliedGenerator =\n\t\t\t\t\t\tdetermineImpliedGenerator( strategy, strategyGeneratorClassName, localGenerators );\n\t\t\t\tif ( impliedGenerator != null ) {\n\t\t\t\t\tconfiguration.putAll( impliedGenerator.getParameters() );\n\t\t\t\t\tinstantiateGeneratorBean( identifierValue, strategyGeneratorClassName, configuration, context );\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfinal String generatorStrategy = determineStrategy(\n\t\t\t\tidAttributeMember,\n\t\t\t\tgeneratorType,\n\t\t\t\tgeneratorName,\n\t\t\t\tcontext,\n\t\t\t\tlocalGenerators,\n\t\t\t\tconfiguration\n\t\t);\n\t\tsetGeneratorCreator( identifierValue, configuration, generatorStrategy, context );\n\t}\n\n\tprivate static IdentifierGeneratorDefinition determineImpliedGenerator(\n\t\t\tGenerationType strategy,\n\t\t\tString strategyGeneratorClassName,\n\t\t\tMap<String, ? extends IdentifierGeneratorDefinition> localGenerators) {\n\t\tif ( localGenerators == null ) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif ( localGenerators.size() == 1 ) {\n\t\t\tfinal IdentifierGeneratorDefinition generatorDefinition =\n\t\t\t\t\tlocalGenerators.values().iterator().next();\n\t\t\t// NOTE : a little bit of a special rule here for the case of just one -\n\t\t\t// \t\twe consider it a match, based on strategy, if the strategy is AUTO or matches...\n\t\t\tif ( strategy == AUTO\n\t\t\t\t\t|| isImpliedGenerator( strategy, strategyGeneratorClassName, generatorDefinition ) ) {\n\t\t\t\treturn generatorDefinition;\n\t\t\t}\n\t\t}\n\n\t\tIdentifierGeneratorDefinition matching = null;\n\t\tfor ( IdentifierGeneratorDefinition localGenerator : localGenerators.values() ) {\n\t\t\tif ( isImpliedGenerator( strategy, strategyGeneratorClassName, localGenerator ) ) {\n\t\t\t\tif ( matching != null ) {\n\t\t\t\t\t// we found multiple matching generators\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tmatching = localGenerator;\n\t\t\t}\n\t\t}\n\t\treturn matching;\n\t}\n\n\tprivate static boolean isImpliedGenerator(\n\t\t\tGenerationType strategy,\n\t\t\tString strategyGeneratorClassName,\n\t\t\tIdentifierGeneratorDefinition generatorDefinition) {\n\t\treturn generatorDefinition.getStrategy().equals( strategyGeneratorClassName );\n\t}\n\n\tprivate static String correspondingGeneratorName(GenerationType strategy) {\n\t\treturn switch ( strategy ) {\n//\t\t\tcase UUID -> org.hibernate.id.uuid.UuidGenerator.class.getName();\n\t\t\tcase UUID -> UuidValueGenerator.class.getName();\n\t\t\tcase TABLE -> org.hibernate.id.enhanced.TableGenerator.class.getName();\n\t\t\tcase IDENTITY -> null;\n\t\t\tdefault -> SequenceStyleGenerator.class.getName();\n\t\t};\n\t}\n\n\tprivate static String determineStrategy(\n\t\t\tMemberDetails idAttributeMember,\n\t\t\tString generatorType,\n\t\t\tString generatorName,\n\t\t\tMetadataBuildingContext context,\n\t\t\tMap<String, ? extends IdentifierGeneratorDefinition> localGenerators,\n\t\t\tMap<String, Object> configuration) {\n\t\tif ( !generatorName.isEmpty() ) {\n\t\t\t//we have a named generator\n\t\t\tfinal IdentifierGeneratorDefinition definition =\n\t\t\t\t\tmakeIdentifierGeneratorDefinition( generatorName, idAttributeMember, localGenerators, context );\n\t\t\tif ( definition == null ) {\n\t\t\t\tthrow new AnnotationException( \"No id generator was declared with the name '\" + generatorName\n\t\t\t\t\t\t+ \"' specified by '@GeneratedValue'\"\n\t\t\t\t\t\t+ \" (define a named generator using '@SequenceGenerator', '@TableGenerator', or '@GenericGenerator')\" );\n\t\t\t}\n\t\t\t//This is quite vague in the spec but a generator could override the generator choice\n\t\t\tfinal String generatorStrategy =\n\t\t\t\t\tgeneratorType == null\n\t\t\t\t\t\t//yuk! this is a hack not to override 'AUTO' even if generator is set\n\t\t\t\t\t\t|| !definition.getStrategy().equals( \"identity\" )\n\t\t\t\t\t\t\t? definition.getStrategy()\n\t\t\t\t\t\t\t: generatorType;\n\t\t\t//checkIfMatchingGenerator(definition, generatorType, generatorName);\n\t\t\tconfiguration.putAll( definition.getParameters() );\n\t\t\treturn generatorStrategy;\n\t\t}\n\t\telse {\n\t\t\treturn generatorType;\n\t\t}\n\t}\n\n\tprivate static IdentifierGeneratorDefinition makeIdentifierGeneratorDefinition(\n\t\t\tString name,\n\t\t\tMemberDetails idAttributeMember,\n\t\t\tMap<String, ? extends IdentifierGeneratorDefinition> localGenerators,\n\t\t\tMetadataBuildingContext buildingContext) {\n\t\tif ( localGenerators != null ) {\n\t\t\tfinal IdentifierGeneratorDefinition result = localGenerators.get( name );\n\t\t\tif ( result != null ) {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\n\t\tfinal IdentifierGeneratorDefinition globalDefinition =\n\t\t\t\tbuildingContext.getMetadataCollector().getIdentifierGenerator( name );\n\t\tif ( globalDefinition != null ) {\n\t\t\treturn globalDefinition;\n\t\t}\n\t\telse {\n\t\t\tLOG.debugf( \"Could not resolve explicit IdentifierGeneratorDefinition - using implicit interpretation (%s)\",\n\t\t\t\t\tname );\n\t\t\tfinal GeneratedValue generatedValue = idAttributeMember.getDirectAnnotationUsage( GeneratedValue.class );\n\t\t\tif ( generatedValue == null ) {\n\t\t\t\tthrow new AssertionFailure( \"No @GeneratedValue annotation\" );\n\t\t\t}\n\t\t\treturn IdentifierGeneratorDefinition.createImplicit(\n\t\t\t\t\tname,\n\t\t\t\t\tidAttributeMember.getType(),\n\t\t\t\t\tgeneratedValue.generator(),\n\t\t\t\t\tinterpretGenerationType( generatedValue )\n\t\t\t);\n\t\t}\n\t}\n\n\tprivate static GenerationType interpretGenerationType(GeneratedValue generatedValueAnn) {\n\t\t// todo (jpa32) : when can this ever be null?\n\t\tfinal GenerationType strategy = generatedValueAnn.strategy();\n\t\treturn strategy == null ? AUTO : strategy;\n\t}\n\n\tpublic static void visitIdGeneratorDefinitions(\n\t\t\tAnnotationTarget annotatedElement,\n\t\t\tConsumer<IdentifierGeneratorDefinition> consumer,\n\t\t\tMetadataBuildingContext context) {\n\t\tfinal SourceModelBuildingContext sourceModelContext =\n\t\t\t\tcontext.getMetadataCollector().getSourceModelBuildingContext();\n\n\t\tannotatedElement.forEachAnnotationUsage( TableGenerator.class, sourceModelContext,\n\t\t\t\tusage -> consumer.accept( buildTableIdGenerator( usage ) ) );\n\n\t\tannotatedElement.forEachAnnotationUsage( SequenceGenerator.class, sourceModelContext,\n\t\t\t\tusage -> consumer.accept( buildSequenceIdGenerator( usage ) ) );\n\n\t\tannotatedElement.forEachAnnotationUsage( GenericGenerator.class, sourceModelContext,\n\t\t\t\tusage -> consumer.accept( buildIdGenerator( usage ) ) );\n\n\t}\n\n\tpublic static void registerGlobalGenerators(\n\t\t\tAnnotationTarget annotatedElement,\n\t\t\tMetadataBuildingContext context) {\n\t\tif ( context.getBootstrapContext().getJpaCompliance().isGlobalGeneratorScopeEnabled() ) {\n\t\t\tfinal InFlightMetadataCollector metadataCollector = context.getMetadataCollector();\n\t\t\tvisitIdGeneratorDefinitions(\n\t\t\t\t\tannotatedElement,\n\t\t\t\t\tdefinition -> {\n\t\t\t\t\t\tif ( !definition.getName().isEmpty() ) {\n\t\t\t\t\t\t\tmetadataCollector.addIdentifierGenerator( definition );\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tcontext\n\t\t\t);\n\t\t}\n\t}\n\n\tprivate static IdentifierGeneratorDefinition buildIdGenerator(GenericGenerator generatorAnnotation) {\n\t\tfinal IdentifierGeneratorDefinition.Builder definitionBuilder =\n\t\t\t\tnew IdentifierGeneratorDefinition.Builder();\n\t\tdefinitionBuilder.setName( generatorAnnotation.name() );\n\t\tfinal Class<? extends Generator> generatorClass = generatorAnnotation.type();\n\t\tfinal String strategy =\n\t\t\t\tgeneratorClass.equals( Generator.class )\n\t\t\t\t\t\t? generatorAnnotation.strategy()\n\t\t\t\t\t\t: generatorClass.getName();\n\t\tdefinitionBuilder.setStrategy( strategy );\n\t\tdefinitionBuilder.addParams( extractParameterMap( generatorAnnotation.parameters() ) );\n\n\t\tif ( LOG.isTraceEnabled() ) {\n\t\t\tLOG.tracev( \"Added generator with name: {0}, strategy: {0}\",\n\t\t\t\t\tdefinitionBuilder.getName(), definitionBuilder.getStrategy() );\n\t\t}\n\n\t\treturn definitionBuilder.build();\n\t}\n\n\tprivate static IdentifierGeneratorDefinition buildSequenceIdGenerator(SequenceGenerator generatorAnnotation) {\n\t\tfinal IdentifierGeneratorDefinition.Builder definitionBuilder = new IdentifierGeneratorDefinition.Builder();\n\t\tinterpretSequenceGenerator( generatorAnnotation, definitionBuilder );\n\t\tif ( LOG.isTraceEnabled() ) {\n\t\t\tLOG.tracev( \"Add sequence generator with name: {0}\", definitionBuilder.getName() );\n\t\t}\n\t\treturn definitionBuilder.build();\n\t}\n\n\tprivate static IdentifierGeneratorDefinition buildTableIdGenerator(TableGenerator generatorAnnotation) {\n\t\tfinal IdentifierGeneratorDefinition.Builder definitionBuilder = new IdentifierGeneratorDefinition.Builder();\n\t\tinterpretTableGenerator( generatorAnnotation, definitionBuilder );\n\t\tif ( LOG.isTraceEnabled() ) {\n\t\t\tLOG.tracev( \"Add sequence generator with name: {0}\", definitionBuilder.getName() );\n\t\t}\n\t\treturn definitionBuilder.build();\n\t}\n\n\tprivate static void checkGeneratorClass(Class<? extends Generator> generatorClass) {\n\t\tif ( !BeforeExecutionGenerator.class.isAssignableFrom( generatorClass )\n\t\t\t\t&& !OnExecutionGenerator.class.isAssignableFrom( generatorClass ) ) {\n\t\t\tthrow new MappingException(\"Generator class '\" + generatorClass.getName()\n\t\t\t\t\t+ \"' must implement either 'BeforeExecutionGenerator' or 'OnExecutionGenerator'\");\n\t\t}\n\t}\n\n\tprivate static void checkGeneratorInterfaces(Class<? extends Generator> generatorClass) {\n\t\t// we don't yet support the additional \"fancy\" operations of\n\t\t// IdentifierGenerator with regular generators, though this\n\t\t// would be extremely easy to add if anyone asks for it\n\t\tif ( IdentifierGenerator.class.isAssignableFrom( generatorClass ) ) {\n\t\t\tthrow new AnnotationException(\"Generator class '\" + generatorClass.getName()\n\t\t\t\t\t+ \"' implements 'IdentifierGenerator' and may not be used with '@ValueGenerationType'\");\n\t\t}\n\t\tif ( ExportableProducer.class.isAssignableFrom( generatorClass ) ) {\n\t\t\tthrow new AnnotationException(\"Generator class '\" + generatorClass.getName()\n\t\t\t\t\t+ \"' implements 'ExportableProducer' and may not be used with '@ValueGenerationType'\");\n\t\t}\n\t}\n\n\t/**\n\t * Return a {@link GeneratorCreator} for an attribute annotated\n\t * with a {@linkplain ValueGenerationType generator annotation}.\n\t */\n\tprivate static GeneratorCreator generatorCreator(\n\t\t\tMemberDetails memberDetails,\n\t\t\tAnnotation annotation,\n\t\t\tBeanContainer beanContainer) {\n\t\tfinal Class<? extends Annotation> annotationType = annotation.annotationType();\n\t\tfinal ValueGenerationType generatorAnnotation = annotationType.getAnnotation( ValueGenerationType.class );\n\t\tassert generatorAnnotation != null;\n\t\tfinal Class<? extends Generator> generatorClass = generatorAnnotation.generatedBy();\n\t\tcheckGeneratorClass( generatorClass );\n\t\tcheckGeneratorInterfaces( generatorClass );\n\t\treturn creationContext -> {\n\t\t\tfinal Generator generator = instantiateGenerator(\n\t\t\t\t\tannotation,\n\t\t\t\t\tbeanContainer,\n\t\t\t\t\tcreationContext,\n\t\t\t\t\tgeneratorClass,\n\t\t\t\t\tmemberDetails,\n\t\t\t\t\tannotationType\n\t\t\t);\n\t\t\tcallInitialize( annotation, memberDetails, creationContext, generator );\n\t\t\t//TODO: callConfigure( creationContext, generator, emptyMap(), identifierValue );\n\t\t\tcheckVersionGenerationAlways( memberDetails, generator );\n\t\t\treturn generator;\n\t\t};\n\t}\n\n\t/**\n\t * Return a {@link GeneratorCreator} for an id attribute annotated\n\t * with an {@linkplain IdGeneratorType id generator annotation}.\n\t */\n\tprivate static GeneratorCreator identifierGeneratorCreator(\n\t\t\tMemberDetails idAttributeMember,\n\t\t\tAnnotation annotation,\n\t\t\tSimpleValue identifierValue,\n\t\t\tBeanContainer beanContainer) {\n\t\tfinal Class<? extends Annotation> annotationType = annotation.annotationType();\n\t\tfinal IdGeneratorType idGeneratorAnnotation = annotationType.getAnnotation( IdGeneratorType.class );\n\t\tassert idGeneratorAnnotation != null;\n\t\tfinal Class<? extends Generator> generatorClass = idGeneratorAnnotation.value();\n\t\tcheckGeneratorClass( generatorClass );\n\t\treturn creationContext -> {\n\t\t\tfinal Generator generator =\n\t\t\t\t\tinstantiateGenerator(\n\t\t\t\t\t\t\tannotation,\n\t\t\t\t\t\t\tbeanContainer,\n\t\t\t\t\t\t\tcreationContext,\n\t\t\t\t\t\t\tgeneratorClass,\n\t\t\t\t\t\t\tidAttributeMember,\n\t\t\t\t\t\t\tannotationType\n\t\t\t\t\t);\n\t\t\tcallInitialize( annotation, idAttributeMember, creationContext, generator );\n\t\t\tcallConfigure( creationContext, generator, emptyMap(), identifierValue );\n\t\t\tcheckIdGeneratorTiming( annotationType, generator );\n\t\t\treturn generator;\n\t\t};\n\t}\n\n\t/**\n\t * Instantiate a {@link Generator}, using the given {@link BeanContainer} if any,\n\t * for the case where the generator was specified using a generator annotation.\n\t *\n\t * @param annotation the generator annotation\n\t * @param beanContainer an optional {@code BeanContainer}\n\t * @param generatorClass a class which implements {@code Generator}\n\t */\n\tprivate static Generator instantiateGenerator(\n\t\t\tAnnotation annotation,\n\t\t\tBeanContainer beanContainer,\n\t\t\tGeneratorCreationContext creationContext,\n\t\t\tClass<? extends Generator> generatorClass,\n\t\t\tMemberDetails memberDetails,\n\t\t\tClass<? extends Annotation> annotationType) {\n\t\tif ( beanContainer != null ) {\n\t\t\treturn instantiateGeneratorAsBean(\n\t\t\t\t\tannotation,\n\t\t\t\t\tbeanContainer,\n\t\t\t\t\tcreationContext,\n\t\t\t\t\tgeneratorClass,\n\t\t\t\t\tmemberDetails,\n\t\t\t\t\tannotationType\n\t\t\t);\n\t\t}\n\t\telse {\n\t\t\treturn instantiateGenerator(\n\t\t\t\t\tannotation,\n\t\t\t\t\tmemberDetails,\n\t\t\t\t\tannotationType,\n\t\t\t\t\tcreationContext,\n\t\t\t\t\tgeneratorClass\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * Instantiate a {@link Generator}, using the given {@link BeanContainer},\n\t * for the case where the generator was specified using a generator annotation.\n\t *\n\t * @param annotation the generator annotation\n\t * @param beanContainer an optional {@code BeanContainer}\n\t * @param generatorClass a class which implements {@code Generator}\n\t */\n\tprivate static Generator instantiateGeneratorAsBean(\n\t\t\tAnnotation annotation,\n\t\t\tBeanContainer beanContainer,\n\t\t\tGeneratorCreationContext creationContext,\n\t\t\tClass<? extends Generator> generatorClass,\n\t\t\tMemberDetails memberDetails,\n\t\t\tClass<? extends Annotation> annotationType) {\n\t\treturn Helper.getBean(\n\t\t\tbeanContainer,\n\t\t\tgeneratorClass,\n\t\t\tfalse,\n\t\t\ttrue,\n\t\t\t() -> instantiateGenerator(\n\t\t\t\tannotation,\n\t\t\t\tmemberDetails,\n\t\t\t\tannotationType,\n\t\t\t\tcreationContext,\n\t\t\t\tgeneratorClass\n\t\t\t)\n\t\t);\n\t}\n\n\t/**\n\t * Instantiate a {@link Generator}, using the given {@link BeanContainer},\n\t * for the case where no generator annotation is available.\n\t *\n\t * @param beanContainer an optional {@code BeanContainer}\n\t * @param generatorClass a class which implements {@code Generator}\n\t */\n\tprivate static <T extends Generator> T instantiateGeneratorAsBean(\n\t\t\tBeanContainer beanContainer,\n\t\t\tClass<T> generatorClass) {\n\t\treturn Helper.getBean(\n\t\t\tbeanContainer,\n\t\t\tgeneratorClass,\n\t\t\tfalse,\n\t\t\ttrue,\n\t\t\t() -> instantiateGeneratorViaDefaultConstructor( generatorClass )\n\t\t);\n\t}\n\n\t/**\n\t * Instantiate a {@link Generator} by calling an appropriate constructor,\n\t * for the case where the generator was specified using a generator annotation.\n\t * We look for three possible signatures:\n\t * <ol>\n\t *     <li>{@code (Annotation, Member, GeneratorCreationContext)}</li>\n\t *     <li>{@code (Annotation)}</li>\n\t *     <li>{@code ()}</li>\n\t * </ol>\n\t * where {@code Annotation} is the generator annotation type.\n\t *\n\t * @param annotation the generator annotation\n\t * @param generatorClass a class which implements {@code Generator}\n\t */\n\tprivate static <G extends Generator> G instantiateGenerator(\n\t\t\tAnnotation annotation,\n\t\t\tMemberDetails memberDetails,\n\t\t\tClass<? extends Annotation> annotationType,\n\t\t\tGeneratorCreationContext creationContext,\n\t\t\tClass<? extends G> generatorClass) {\n\t\ttry {\n\t\t\ttry {\n\t\t\t\treturn generatorClass.getConstructor( annotationType, Member.class, GeneratorCreationContext.class )\n\t\t\t\t\t\t.newInstance( annotation, memberDetails.toJavaMember(), creationContext);\n\t\t\t}\n\t\t\tcatch (NoSuchMethodException ignore) {\n\t\t\t\ttry {\n\t\t\t\t\treturn generatorClass.getConstructor( annotationType )\n\t\t\t\t\t\t\t.newInstance( annotation );\n\t\t\t\t}\n\t\t\t\tcatch (NoSuchMethodException i) {\n\t\t\t\t\treturn instantiateGeneratorViaDefaultConstructor( generatorClass );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (InvocationTargetException | InstantiationException | IllegalAccessException | IllegalArgumentException e) {\n\t\t\tthrow new org.hibernate.InstantiationException( \"Could not instantiate id generator\", generatorClass, e );\n\t\t}\n\t}\n\n\t/**\n\t * Instantiate a {@link Generator}, using the given {@link BeanContainer} if any,\n\t * or by calling the default constructor otherwise.\n\t *\n\t * @param beanContainer an optional {@code BeanContainer}\n\t * @param generatorClass a class which implements {@code Generator}\n\t */\n\tpublic static <T extends Generator> T instantiateGenerator(\n\t\t\tBeanContainer beanContainer,\n\t\t\tClass<T> generatorClass) {\n\t\treturn beanContainer != null\n\t\t\t\t? instantiateGeneratorAsBean( beanContainer, generatorClass )\n\t\t\t\t: instantiateGeneratorViaDefaultConstructor( generatorClass );\n\t}\n\n\t/**\n\t * Instantiate a {@link Generator} by calling the default constructor.\n\t */\n\tprivate static <G extends Generator> G instantiateGeneratorViaDefaultConstructor(Class<? extends G> generatorClass) {\n\t\ttry {\n\t\t\treturn generatorClass.getDeclaredConstructor().newInstance();\n\t\t}\n\t\tcatch (NoSuchMethodException e) {\n\t\t\tthrow new org.hibernate.InstantiationException( \"No appropriate constructor for id generator class\", generatorClass);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new org.hibernate.InstantiationException( \"Could not instantiate id generator\", generatorClass, e );\n\t\t}\n\t}\n\n\tpublic static <A extends Annotation> void callInitialize(\n\t\t\tA annotation,\n\t\t\tMemberDetails memberDetails,\n\t\t\tGeneratorCreationContext creationContext,\n\t\t\tGenerator generator) {\n\t\tif ( generator instanceof AnnotationBasedGenerator ) {\n\t\t\t// This will cause a CCE in case the generation type doesn't match the annotation type; As this would be\n\t\t\t// a programming error of the generation type developer and thus should show up during testing, we don't\n\t\t\t// check this explicitly; If required, this could be done e.g. using ClassMate\n\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\tfinal AnnotationBasedGenerator<A> generation = (AnnotationBasedGenerator<A>) generator;\n\t\t\tgeneration.initialize( annotation, memberDetails.toJavaMember(), creationContext );\n\t\t}\n\t}\n\n\tprivate static void checkVersionGenerationAlways(MemberDetails property, Generator generator) {\n\t\tif ( property.hasDirectAnnotationUsage( Version.class ) ) {\n\t\t\tif ( !generator.generatesOnInsert() ) {\n\t\t\t\tthrow new AnnotationException(\"Property '\" + property.getName()\n\t\t\t\t\t\t+ \"' is annotated '@Version' but has a 'Generator' which does not generate on inserts\"\n\t\t\t\t);\n\t\t\t}\n\t\t\tif ( !generator.generatesOnUpdate() ) {\n\t\t\t\tthrow new AnnotationException(\"Property '\" + property.getName()\n\t\t\t\t\t\t+ \"' is annotated '@Version' but has a 'Generator' which does not generate on updates\"\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * If the given {@link Generator} also implements {@link Configurable},\n\t * call its {@link Configurable#configure(GeneratorCreationContext, Properties)\n\t * configure()} method.\n\t */\n\tpublic static void callConfigure(\n\t\t\tGeneratorCreationContext creationContext,\n\t\t\tGenerator generator,\n\t\t\tMap<String, Object> configuration,\n\t\t\tSimpleValue identifierValue) {\n\t\tif ( generator instanceof Configurable configurable ) {\n\t\t\tfinal Properties parameters = collectParameters(\n\t\t\t\t\tidentifierValue,\n\t\t\t\t\tcreationContext.getDatabase().getDialect(),\n\t\t\t\t\tcreationContext.getRootClass(),\n\t\t\t\t\tconfiguration\n\t\t\t);\n\t\t\tconfigurable.configure( creationContext, parameters );\n\t\t}\n\t\tif ( generator instanceof ExportableProducer exportableProducer ) {\n\t\t\texportableProducer.registerExportables( creationContext.getDatabase() );\n\t\t}\n\t\tif ( generator instanceof Configurable configurable ) {\n\t\t\tconfigurable.initialize( creationContext.getSqlStringGenerationContext() );\n\t\t}\n\t}\n\n\tprivate static void checkIdGeneratorTiming(Class<? extends Annotation> annotationType, Generator generator) {\n\t\tif ( !generator.generatesOnInsert() ) {\n\t\t\tthrow new MappingException( \"Annotation '\" + annotationType\n\t\t\t\t\t+ \"' is annotated 'IdGeneratorType' but the given 'Generator' does not generate on inserts\");\n\t\t}\n\t\tif ( generator.generatesOnUpdate() ) {\n\t\t\tthrow new MappingException( \"Annotation '\" + annotationType\n\t\t\t\t\t+ \"' is annotated 'IdGeneratorType' but the given 'Generator' generates on updates (it must generate only on inserts)\");\n\t\t}\n\t}\n\n\t/**\n\t * Create a generator, based on a {@link GeneratedValue} annotation.\n\t */\n\tprivate static void createIdGenerator(\n\t\t\tMemberDetails idMember,\n\t\t\tSimpleValue idValue,\n\t\t\tPersistentClass persistentClass,\n\t\t\tMetadataBuildingContext context) {\n\t\t// NOTE: `generatedValue` is never null here\n\t\tfinal GeneratedValue generatedValue = castNonNull( idMember.getDirectAnnotationUsage( GeneratedValue.class ) );\n\n\t\tfinal InFlightMetadataCollector metadataCollector = context.getMetadataCollector();\n\t\tif ( isGlobalGeneratorNameGlobal( context ) ) {\n\t\t\t// process and register any generators defined on the member.\n\t\t\t// according to JPA these are also global.\n\t\t\tmetadataCollector.getGlobalRegistrations().as( GlobalRegistrar.class ).collectIdGenerators( idMember );\n\t\t\tmetadataCollector.addSecondPass( new StrictIdGeneratorResolverSecondPass(\n\t\t\t\t\tpersistentClass,\n\t\t\t\t\tidValue,\n\t\t\t\t\tidMember,\n\t\t\t\t\tgeneratedValue,\n\t\t\t\t\tcontext\n\t\t\t) );\n\t\t}\n\t\telse {\n\t\t\tmetadataCollector.addSecondPass( new IdGeneratorResolverSecondPass(\n\t\t\t\t\tpersistentClass,\n\t\t\t\t\tidValue,\n\t\t\t\t\tidMember,\n\t\t\t\t\tgeneratedValue,\n\t\t\t\t\tcontext\n\t\t\t) );\n\t\t}\n\t}\n\n\tpublic static void createGeneratorFrom(\n\t\t\tIdentifierGeneratorDefinition defaultedGenerator,\n\t\t\tSimpleValue idValue,\n\t\t\tMap<String, Object> configuration,\n\t\t\tMetadataBuildingContext context) {\n\t\tconfiguration.putAll( defaultedGenerator.getParameters() );\n\t\tinstantiateGeneratorBean( idValue, defaultedGenerator.getStrategy(), configuration, context );\n\t}\n\n\n\tpublic static void createGeneratorFrom(\n\t\t\tIdentifierGeneratorDefinition defaultedGenerator,\n\t\t\tSimpleValue idValue,\n\t\t\tMetadataBuildingContext context) {\n\t\tcreateGeneratorFrom(\n\t\t\t\tdefaultedGenerator,\n\t\t\t\tidValue,\n\t\t\t\tbuildConfigurationMap( idValue ),\n\t\t\t\tcontext\n\t\t);\n\t}\n\n\tprivate static Map<String, Object> buildConfigurationMap(KeyValue idValue) {\n\t\tfinal Map<String,Object> configuration = new HashMap<>();\n\t\tconfiguration.put( PersistentIdentifierGenerator.TABLE, idValue.getTable().getName() );\n\t\tif ( idValue.getColumnSpan() == 1 ) {\n\t\t\tconfiguration.put( PersistentIdentifierGenerator.PK, idValue.getColumns().get(0).getName() );\n\t\t}\n\t\treturn configuration;\n\t}\n\n\t/**\n\t * Set up the identifier generator for an id defined in a {@code hbm.xml} mapping.\n\t *\n\t * @see org.hibernate.boot.model.source.internal.hbm.ModelBinder\n\t */\n\tpublic static void makeIdGenerator(\n\t\t\tfinal MappingDocument sourceDocument,\n\t\t\tIdentifierGeneratorDefinition definition,\n\t\t\tSimpleValue identifierValue,\n\t\t\tMetadataBuildingContext context) {\n\n\t\tif ( definition != null ) {\n\t\t\t// see if the specified generator name matches a registered <identifier-generator/>\n\t\t\tfinal IdentifierGeneratorDefinition generatorDef =\n\t\t\t\t\tsourceDocument.getMetadataCollector()\n\t\t\t\t\t\t\t.getIdentifierGenerator( definition.getName() );\n\t\t\tfinal Map<String,Object> configuration = new HashMap<>();\n\t\t\tfinal String generatorStrategy;\n\t\t\tif ( generatorDef != null ) {\n\t\t\t\tgeneratorStrategy = generatorDef.getStrategy();\n\t\t\t\tconfiguration.putAll( generatorDef.getParameters() );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tgeneratorStrategy = definition.getStrategy();\n\t\t\t}\n\n\t\t\tconfiguration.putAll( definition.getParameters() );\n\n\t\t\tsetGeneratorCreator( identifierValue, configuration, generatorStrategy, context );\n\t\t}\n\t}\n\n\t/**\n\t * Obtain a {@link BeanContainer} to be used for instantiating generators.\n\t */\n\tpublic static BeanContainer beanContainer(MetadataBuildingContext buildingContext) {\n\t\treturn Helper.getBeanContainer( buildingContext.getBootstrapContext().getServiceRegistry() );\n\t}\n\n\t/**\n\t * Set up the {@link GeneratorCreator} for a case where there is no\n\t * generator annotation.\n\t */\n\tprivate static void setGeneratorCreator(\n\t\t\tSimpleValue identifierValue,\n\t\t\tMap<String, Object> configuration,\n\t\t\tString generatorStrategy,\n\t\t\tMetadataBuildingContext context) {\n\t\tif ( ASSIGNED_GENERATOR_NAME.equals( generatorStrategy )\n\t\t\t\t|| org.hibernate.id.Assigned.class.getName().equals( generatorStrategy ) ) {\n\t\t\tidentifierValue.setCustomIdGeneratorCreator( ASSIGNED_IDENTIFIER_GENERATOR_CREATOR );\n\t\t}\n\t\telse {\n\t\t\tinstantiateGeneratorBean( identifierValue, generatorStrategy, configuration, context );\n\t\t}\n\t}\n\n\tprivate static void instantiateGeneratorBean(\n\t\t\tSimpleValue identifierValue,\n\t\t\tString generatorStrategy,\n\t\t\tMap<String, Object> configuration,\n\t\t\tMetadataBuildingContext context) {\n\t\tfinal BeanContainer beanContainer = beanContainer( context );\n\t\tidentifierValue.setCustomIdGeneratorCreator( creationContext -> {\n\t\t\tfinal Generator identifierGenerator =\n\t\t\t\t\tinstantiateGenerator( beanContainer, generatorClass( generatorStrategy, identifierValue ) );\n\t\t\tcallConfigure( creationContext, identifierGenerator, configuration, identifierValue );\n\t\t\tif ( identifierGenerator instanceof IdentityGenerator) {\n\t\t\t\tidentifierValue.setColumnToIdentity();\n\t\t\t}\n\t\t\treturn identifierGenerator;\n\t\t} );\n\t}\n\n\t/**\n\t * Set up the id generator by considering all annotations of the identifier\n\t * field, including {@linkplain IdGeneratorType id generator annotations},\n\t * and {@link GeneratedValue}.\n\t */\n\tstatic void createIdGeneratorsFromGeneratorAnnotations(\n\t\t\tPropertyHolder propertyHolder,\n\t\t\tPropertyData inferredData,\n\t\t\tSimpleValue idValue,\n\t\t\tMetadataBuildingContext context) {\n\n\t\tfinal SourceModelBuildingContext sourceModelContext =\n\t\t\t\tcontext.getMetadataCollector().getSourceModelBuildingContext();\n\t\tfinal MemberDetails idAttributeMember = inferredData.getAttributeMember();\n\t\tfinal List<? extends Annotation> idGeneratorAnnotations =\n\t\t\t\tidAttributeMember.getMetaAnnotated( IdGeneratorType.class, sourceModelContext );\n\t\tfinal List<? extends Annotation> generatorAnnotations =\n\t\t\t\tidAttributeMember.getMetaAnnotated( ValueGenerationType.class, sourceModelContext );\n\t\t// Since these collections may contain Proxies created by common-annotations module we cannot reliably use simple remove/removeAll\n\t\t// collection methods as those proxies do not implement hashcode/equals and even a simple `a.equals(a)` will return `false`.\n\t\t// Instead, we will check the annotation types, since generator annotations should not be \"repeatable\" we should have only\n\t\t// at most one annotation for a generator:\n\t\tfor ( Annotation id : idGeneratorAnnotations ) {\n\t\t\tgeneratorAnnotations.removeIf( gen -> gen.annotationType().equals( id.annotationType() ) );\n\t\t}\n\n\t\tif ( idGeneratorAnnotations.size() + generatorAnnotations.size() > 1 ) {\n\t\t\tthrow new AnnotationException( String.format(\n\t\t\t\t\tLocale.ROOT,\n\t\t\t\t\t\"Identifier attribute '%s' has too many generator annotations: %s\",\n\t\t\t\t\tgetPath( propertyHolder, inferredData ),\n\t\t\t\t\tcombineUntyped( idGeneratorAnnotations, generatorAnnotations )\n\t\t\t) );\n\t\t}\n\t\tif ( !idGeneratorAnnotations.isEmpty() ) {\n\t\t\tidValue.setCustomIdGeneratorCreator( identifierGeneratorCreator(\n\t\t\t\t\tidAttributeMember,\n\t\t\t\t\tidGeneratorAnnotations.get(0),\n\t\t\t\t\tidValue,\n\t\t\t\t\tbeanContainer( context )\n\t\t\t) );\n\t\t}\n\t\telse if ( !generatorAnnotations.isEmpty() ) {\n//\t\t\tidValue.setCustomGeneratorCreator( generatorCreator( idAttributeMember, generatorAnnotation ) );\n\t\t\tthrow new AnnotationException( String.format(\n\t\t\t\t\tLocale.ROOT,\n\t\t\t\t\t\"Identifier attribute '%s' is annotated '%s' which is not an '@IdGeneratorType'\",\n\t\t\t\t\tgetPath( propertyHolder, inferredData ),\n\t\t\t\t\tgeneratorAnnotations.get(0).annotationType()\n\t\t\t) );\n\t\t}\n\t\telse if ( idAttributeMember.hasDirectAnnotationUsage( GeneratedValue.class ) ) {\n\t\t\tcreateIdGenerator( idAttributeMember, idValue, propertyHolder.getPersistentClass(), context );\n\t\t}\n\t}\n\n\t/**\n\t * Returns the value generation strategy for the given property, if any, by\n\t * considering {@linkplain ValueGenerationType generator type annotations}.\n\t */\n\tstatic GeneratorCreator createValueGeneratorFromAnnotations(\n\t\t\tPropertyHolder holder, String propertyName,\n\t\t\tMemberDetails property, MetadataBuildingContext context) {\n\t\tfinal List<? extends Annotation> generatorAnnotations =\n\t\t\t\tproperty.getMetaAnnotated( ValueGenerationType.class,\n\t\t\t\t\t\tcontext.getMetadataCollector().getSourceModelBuildingContext() );\n\t\treturn switch ( generatorAnnotations.size() ) {\n\t\t\tcase 0 -> null;\n\t\t\tcase 1 -> generatorCreator( property, generatorAnnotations.get(0), beanContainer( context ) );\n\t\t\tdefault -> throw new AnnotationException( \"Property '\" + qualify( holder.getPath(), propertyName )\n\t\t\t\t\t+ \"' has too many generator annotations: \" + generatorAnnotations );\n\t\t};\n\t}\n\n\tpublic static void applyIfNotEmpty(String name, String value, BiConsumer<String,String> consumer) {\n\t\tif ( isNotEmpty( value ) ) {\n\t\t\tconsumer.accept( name, value );\n\t\t}\n\t}\n}\n",
        "diffSourceCodeSet": [
            "private static void instantiateGeneratorBean(\n\t\t\tSimpleValue identifierValue,\n\t\t\tString generatorStrategy,\n\t\t\tMap<String, Object> configuration,\n\t\t\tMetadataBuildingContext context) {\n\t\tfinal BeanContainer beanContainer = beanContainer( context );\n\t\tidentifierValue.setCustomIdGeneratorCreator( creationContext -> {\n\t\t\tfinal Generator identifierGenerator =\n\t\t\t\t\tinstantiateGenerator( beanContainer, generatorClass( generatorStrategy, identifierValue ) );\n\t\t\tcallConfigure( creationContext, identifierGenerator, configuration, identifierValue );\n\t\t\tif ( identifierGenerator instanceof IdentityGenerator) {\n\t\t\t\tidentifierValue.setColumnToIdentity();\n\t\t\t}\n\t\t\treturn identifierGenerator;\n\t\t} );\n\t}"
        ],
        "invokedMethodSet": [
            "methodSignature: org.hibernate.boot.model.internal.GeneratorBinder#callConfigure\n methodBody: public static void callConfigure(\n\t\t\tGeneratorCreationContext creationContext,\n\t\t\tGenerator generator,\n\t\t\tMap<String, Object> configuration,\n\t\t\tSimpleValue identifierValue) {\nif(generator instanceof Configurable configurable){final Properties parameters=collectParameters(identifierValue,creationContext.getDatabase().getDialect(),creationContext.getRootClass(),configuration);\nconfigurable.configure(creationContext,parameters);\n}if(generator instanceof ExportableProducer exportableProducer){exportableProducer.registerExportables(creationContext.getDatabase());\n}if(generator instanceof Configurable configurable){configurable.initialize(creationContext.getSqlStringGenerationContext());\n}}",
            "methodSignature: org.hibernate.boot.model.internal.GeneratorBinder#beanContainer\n methodBody: public static BeanContainer beanContainer(MetadataBuildingContext buildingContext) {\nreturn Helper.getBeanContainer(buildingContext.getBootstrapContext().getServiceRegistry());\n}",
            "methodSignature: org.hibernate.boot.model.internal.GeneratorBinder#instantiateGenerator\n methodBody: public static <T extends Generator> T instantiateGenerator(\n\t\t\tBeanContainer beanContainer,\n\t\t\tClass<T> generatorClass) {\nif(beanContainer != null){return instantiateGeneratorAsBean(beanContainer,generatorClass);\n}{return instantiateGeneratorViaDefaultConstructor(generatorClass);\n}}"
        ],
        "sourceCodeAfterRefactoring": "/**\n\t * Set up the {@link GeneratorCreator} for a case where there is no\n\t * generator annotation.\n\t */\n\tprivate static void setGeneratorCreator(\n\t\t\tSimpleValue identifierValue,\n\t\t\tMap<String, Object> configuration,\n\t\t\tString generatorStrategy,\n\t\t\tMetadataBuildingContext context) {\n\t\tif ( ASSIGNED_GENERATOR_NAME.equals( generatorStrategy )\n\t\t\t\t|| org.hibernate.id.Assigned.class.getName().equals( generatorStrategy ) ) {\n\t\t\tidentifierValue.setCustomIdGeneratorCreator( ASSIGNED_IDENTIFIER_GENERATOR_CREATOR );\n\t\t}\n\t\telse {\n\t\t\tinstantiateGeneratorBean( identifierValue, generatorStrategy, configuration, context );\n\t\t}\n\t}\nprivate static void instantiateGeneratorBean(\n\t\t\tSimpleValue identifierValue,\n\t\t\tString generatorStrategy,\n\t\t\tMap<String, Object> configuration,\n\t\t\tMetadataBuildingContext context) {\n\t\tfinal BeanContainer beanContainer = beanContainer( context );\n\t\tidentifierValue.setCustomIdGeneratorCreator( creationContext -> {\n\t\t\tfinal Generator identifierGenerator =\n\t\t\t\t\tinstantiateGenerator( beanContainer, generatorClass( generatorStrategy, identifierValue ) );\n\t\t\tcallConfigure( creationContext, identifierGenerator, configuration, identifierValue );\n\t\t\tif ( identifierGenerator instanceof IdentityGenerator) {\n\t\t\t\tidentifierValue.setColumnToIdentity();\n\t\t\t}\n\t\t\treturn identifierGenerator;\n\t\t} );\n\t}",
        "diffSourceCode": "-  749: \t\treturn configuration;\n-  750: \t}\n-  751: \n-  752: \t/**\n-  753: \t * Set up the identifier generator for an id defined in a {@code hbm.xml} mapping.\n-  754: \t *\n-  755: \t * @see org.hibernate.boot.model.source.internal.hbm.ModelBinder\n-  756: \t */\n-  757: \tpublic static void makeIdGenerator(\n-  758: \t\t\tfinal MappingDocument sourceDocument,\n-  759: \t\t\tIdentifierGeneratorDefinition definition,\n-  760: \t\t\tSimpleValue identifierValue,\n-  761: \t\t\tMetadataBuildingContext context) {\n-  762: \n-  763: \t\tif ( definition != null ) {\n-  764: \t\t\t// see if the specified generator name matches a registered <identifier-generator/>\n-  765: \t\t\tfinal IdentifierGeneratorDefinition generatorDef =\n-  767: \t\t\t\t\t\t\t.getIdentifierGenerator( definition.getName() );\n-  768: \t\t\tfinal Map<String,Object> configuration = new HashMap<>();\n-  769: \t\t\tfinal String generatorStrategy;\n-  770: \t\t\tif ( generatorDef != null ) {\n-  771: \t\t\t\tgeneratorStrategy = generatorDef.getStrategy();\n-  772: \t\t\t\tconfiguration.putAll( generatorDef.getParameters() );\n-  773: \t\t\t}\n-  774: \t\t\telse {\n-  775: \t\t\t\tgeneratorStrategy = definition.getStrategy();\n-  776: \t\t\t}\n-  777: \n-  778: \t\t\tconfiguration.putAll( definition.getParameters() );\n-  779: \n-  780: \t\t\tsetGeneratorCreator( identifierValue, configuration, generatorStrategy, context );\n-  781: \t\t}\n+  749: \t/**\n+  750: \t * Set up the {@link GeneratorCreator} for a case where there is no\n+  751: \t * generator annotation.\n+  752: \t */\n+  753: \tprivate static void setGeneratorCreator(\n+  754: \t\t\tSimpleValue identifierValue,\n+  755: \t\t\tMap<String, Object> configuration,\n+  756: \t\t\tString generatorStrategy,\n+  757: \t\t\tMetadataBuildingContext context) {\n+  758: \t\tif ( ASSIGNED_GENERATOR_NAME.equals( generatorStrategy )\n+  759: \t\t\t\t|| org.hibernate.id.Assigned.class.getName().equals( generatorStrategy ) ) {\n+  760: \t\t\tidentifierValue.setCustomIdGeneratorCreator( ASSIGNED_IDENTIFIER_GENERATOR_CREATOR );\n+  761: \t\t}\n+  762: \t\telse {\n+  763: \t\t\tinstantiateGeneratorBean( identifierValue, generatorStrategy, configuration, context );\n+  764: \t\t}\n+  765: \t}\n+  767: \tprivate static void instantiateGeneratorBean(\n+  768: \t\t\tSimpleValue identifierValue,\n+  769: \t\t\tString generatorStrategy,\n+  770: \t\t\tMap<String, Object> configuration,\n+  771: \t\t\tMetadataBuildingContext context) {\n+  772: \t\tfinal BeanContainer beanContainer = beanContainer( context );\n+  773: \t\tidentifierValue.setCustomIdGeneratorCreator( creationContext -> {\n+  774: \t\t\tfinal Generator identifierGenerator =\n+  775: \t\t\t\t\tinstantiateGenerator( beanContainer, generatorClass( generatorStrategy, identifierValue ) );\n+  776: \t\t\tcallConfigure( creationContext, identifierGenerator, configuration, identifierValue );\n+  777: \t\t\tif ( identifierGenerator instanceof IdentityGenerator) {\n+  778: \t\t\t\tidentifierValue.setColumnToIdentity();\n+  779: \t\t\t}\n+  780: \t\t\treturn identifierGenerator;\n+  781: \t\t} );\n   782: \t}\n-  791: \t/**\n-  792: \t * Set up the {@link GeneratorCreator} for a case where there is no\n-  793: \t * generator annotation.\n-  794: \t */\n-  795: \tprivate static void setGeneratorCreator(\n-  796: \t\t\tSimpleValue identifierValue,\n-  797: \t\t\tMap<String, Object> configuration,\n-  798: \t\t\tString generatorStrategy,\n-  799: \t\t\tMetadataBuildingContext context) {\n-  800: \t\tif ( ASSIGNED_GENERATOR_NAME.equals( generatorStrategy )\n-  801: \t\t\t\t|| org.hibernate.id.Assigned.class.getName().equals( generatorStrategy ) ) {\n-  802: \t\t\tidentifierValue.setCustomIdGeneratorCreator( ASSIGNED_IDENTIFIER_GENERATOR_CREATOR );\n-  803: \t\t}\n-  804: \t\telse {\n-  805: \t\t\tfinal BeanContainer beanContainer = beanContainer( context );\n-  806: \t\t\tidentifierValue.setCustomIdGeneratorCreator( creationContext -> {\n-  807: \t\t\t\tfinal Generator identifierGenerator =\n-  808: \t\t\t\t\t\tinstantiateGenerator( beanContainer, generatorClass( generatorStrategy, identifierValue ) );\n-  809: \t\t\t\tcallConfigure( creationContext, identifierGenerator, configuration, identifierValue );\n-  810: \t\t\t\tif ( identifierGenerator instanceof IdentityGenerator) {\n-  811: \t\t\t\t\tidentifierValue.setColumnToIdentity();\n-  812: \t\t\t\t}\n-  813: \t\t\t\treturn identifierGenerator;\n-  814: \t\t\t} );\n-  815: \t\t}\n-  816: \t}\n+  791: \t\t\tPropertyData inferredData,\n+  792: \t\t\tSimpleValue idValue,\n+  793: \t\t\tMetadataBuildingContext context) {\n+  794: \n+  795: \t\tfinal SourceModelBuildingContext sourceModelContext =\n+  796: \t\t\t\tcontext.getMetadataCollector().getSourceModelBuildingContext();\n+  797: \t\tfinal MemberDetails idAttributeMember = inferredData.getAttributeMember();\n+  798: \t\tfinal List<? extends Annotation> idGeneratorAnnotations =\n+  799: \t\t\t\tidAttributeMember.getMetaAnnotated( IdGeneratorType.class, sourceModelContext );\n+  800: \t\tfinal List<? extends Annotation> generatorAnnotations =\n+  801: \t\t\t\tidAttributeMember.getMetaAnnotated( ValueGenerationType.class, sourceModelContext );\n+  802: \t\t// Since these collections may contain Proxies created by common-annotations module we cannot reliably use simple remove/removeAll\n+  803: \t\t// collection methods as those proxies do not implement hashcode/equals and even a simple `a.equals(a)` will return `false`.\n+  804: \t\t// Instead, we will check the annotation types, since generator annotations should not be \"repeatable\" we should have only\n+  805: \t\t// at most one annotation for a generator:\n+  806: \t\tfor ( Annotation id : idGeneratorAnnotations ) {\n+  807: \t\t\tgeneratorAnnotations.removeIf( gen -> gen.annotationType().equals( id.annotationType() ) );\n+  808: \t\t}\n+  809: \n+  810: \t\tif ( idGeneratorAnnotations.size() + generatorAnnotations.size() > 1 ) {\n+  811: \t\t\tthrow new AnnotationException( String.format(\n+  812: \t\t\t\t\tLocale.ROOT,\n+  813: \t\t\t\t\t\"Identifier attribute '%s' has too many generator annotations: %s\",\n+  814: \t\t\t\t\tgetPath( propertyHolder, inferredData ),\n+  815: \t\t\t\t\tcombineUntyped( idGeneratorAnnotations, generatorAnnotations )\n+  816: \t\t\t) );\n",
        "uniqueId": "800a3f0738db7294c9684de8bfe4edce99321acb_791_816_767_782_749_765",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 0,
                "covered": 24
            },
            "BRANCH": {
                "missed": 0,
                "covered": 4
            },
            "LINE": {
                "missed": 0,
                "covered": 6
            },
            "COMPLEXITY": {
                "missed": 0,
                "covered": 3
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 21
    },
    {
        "type": "Extract And Move Method",
        "description": "Extract And Move Method\tpublic getBeanContainer(serviceRegistry ServiceRegistry) : BeanContainer extracted from public initiateService(configurationValues Map<String,Object>, registry ServiceRegistryImplementor) : MultiTenantConnectionProvider<?> in class org.hibernate.engine.jdbc.connections.internal.MultiTenantConnectionProviderInitiator & moved to class org.hibernate.resource.beans.internal.Helper",
        "diffLocations": [
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/engine/jdbc/connections/internal/MultiTenantConnectionProviderInitiator.java",
                "startLine": 43,
                "endLine": 121,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/engine/jdbc/connections/internal/MultiTenantConnectionProviderInitiator.java",
                "startLine": 40,
                "endLine": 94,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/engine/jdbc/connections/internal/MultiTenantConnectionProviderInitiator.java",
                "startLine": 50,
                "endLine": 53,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "@Override\n\tpublic MultiTenantConnectionProvider<?> initiateService(Map<String, Object> configurationValues, ServiceRegistryImplementor registry) {\n\t\tif ( !configurationValues.containsKey( AvailableSettings.MULTI_TENANT_CONNECTION_PROVIDER ) ) {\n\t\t\tfinal BeanContainer beanContainer = Helper.allowExtensionsInCdi( registry ) ? registry.requireService( ManagedBeanRegistry.class ).getBeanContainer() : null;\n\t\t\tif (beanContainer != null) {\n\t\t\t\treturn beanContainer.getBean(\n\t\t\t\t\t\tMultiTenantConnectionProvider.class,\n\t\t\t\t\t\tnew BeanContainer.LifecycleOptions() {\n\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\tpublic boolean canUseCachedReferences() {\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\tpublic boolean useJpaCompliantCreation() {\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\tnew BeanInstanceProducer() {\n\n\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\tpublic <B> B produceBeanInstance(Class<B> beanType) {\n\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\tpublic <B> B produceBeanInstance(String name, Class<B> beanType) {\n\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\t\t\t\t).getBeanInstance();\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\n\t\tfinal Object configValue = configurationValues.get( AvailableSettings.MULTI_TENANT_CONNECTION_PROVIDER );\n\t\tif ( configValue == null ) {\n\t\t\t// if they also specified the data source *name*, then lets assume they want\n\t\t\t// DataSourceBasedMultiTenantConnectionProviderImpl\n\t\t\tfinal Object dataSourceConfigValue = configurationValues.get( AvailableSettings.DATASOURCE );\n\t\t\tif ( dataSourceConfigValue instanceof String ) {\n\t\t\t\treturn new DataSourceBasedMultiTenantConnectionProviderImpl<>();\n\t\t\t}\n\n\t\t\treturn null;\n\t\t}\n\n\t\tif ( configValue instanceof MultiTenantConnectionProvider<?> ) {\n\t\t\treturn (MultiTenantConnectionProvider<?>) configValue;\n\t\t}\n\t\telse {\n\t\t\tfinal Class<MultiTenantConnectionProvider<?>> implClass;\n\t\t\tif ( configValue instanceof Class ) {\n\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\tClass<MultiTenantConnectionProvider<?>> clazz = (Class<MultiTenantConnectionProvider<?>>) configValue;\n\t\t\t\timplClass = clazz;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfinal String className = configValue.toString();\n\t\t\t\tfinal ClassLoaderService classLoaderService = registry.requireService( ClassLoaderService.class );\n\t\t\t\ttry {\n\t\t\t\t\timplClass = classLoaderService.classForName( className );\n\t\t\t\t}\n\t\t\t\tcatch (ClassLoadingException cle) {\n\t\t\t\t\tlog.warn( \"Unable to locate specified class [\" + className + \"]\", cle );\n\t\t\t\t\tthrow new ServiceException( \"Unable to locate specified multi-tenant connection provider [\" + className + \"]\" );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\treturn implClass.newInstance();\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tlog.warn( \"Unable to instantiate specified class [\" + implClass.getName() + \"]\", e );\n\t\t\t\tthrow new ServiceException( \"Unable to instantiate specified multi-tenant connection provider [\" + implClass.getName() + \"]\" );\n\t\t\t}\n\t\t}\n\t}",
        "filePathBefore": "hibernate-core/src/main/java/org/hibernate/engine/jdbc/connections/internal/MultiTenantConnectionProviderInitiator.java",
        "isPureRefactoring": true,
        "commitId": "2f7052c0ce5114e492c7dc4e4b8abd5283b2fe13",
        "packageNameBefore": "org.hibernate.engine.jdbc.connections.internal",
        "classNameBefore": "org.hibernate.engine.jdbc.connections.internal.MultiTenantConnectionProviderInitiator",
        "methodNameBefore": "org.hibernate.engine.jdbc.connections.internal.MultiTenantConnectionProviderInitiator#initiateService",
        "invokedMethod": "methodSignature: org.hibernate.resource.beans.internal.Helper#allowExtensionsInCdi\n methodBody: public static boolean allowExtensionsInCdi(ServiceRegistry serviceRegistry) {\nreturn serviceRegistry.requireService(ConfigurationService.class).getSetting(ALLOW_EXTENSIONS_IN_CDI,BOOLEAN,false);\n}",
        "classSignatureBefore": "public class MultiTenantConnectionProviderInitiator implements StandardServiceInitiator<MultiTenantConnectionProvider<?>> ",
        "methodNameBeforeSet": [
            "org.hibernate.engine.jdbc.connections.internal.MultiTenantConnectionProviderInitiator#initiateService"
        ],
        "classNameBeforeSet": [
            "org.hibernate.engine.jdbc.connections.internal.MultiTenantConnectionProviderInitiator"
        ],
        "classSignatureBeforeSet": [
            "public class MultiTenantConnectionProviderInitiator implements StandardServiceInitiator<MultiTenantConnectionProvider<?>> "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Changes are within the Extract Method refactoring mechanics",
                "description": "All replacements have been justified - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * SPDX-License-Identifier: LGPL-2.1-or-later\n * Copyright Red Hat Inc. and Hibernate Authors\n */\npackage org.hibernate.engine.jdbc.connections.internal;\n\nimport java.util.Map;\n\nimport org.hibernate.boot.registry.StandardServiceInitiator;\nimport org.hibernate.boot.registry.classloading.spi.ClassLoaderService;\nimport org.hibernate.boot.registry.classloading.spi.ClassLoadingException;\nimport org.hibernate.cfg.AvailableSettings;\nimport org.hibernate.engine.jdbc.connections.spi.DataSourceBasedMultiTenantConnectionProviderImpl;\nimport org.hibernate.engine.jdbc.connections.spi.MultiTenantConnectionProvider;\nimport org.hibernate.resource.beans.container.spi.BeanContainer;\nimport org.hibernate.resource.beans.internal.Helper;\nimport org.hibernate.resource.beans.spi.BeanInstanceProducer;\nimport org.hibernate.resource.beans.spi.ManagedBeanRegistry;\nimport org.hibernate.service.spi.ServiceException;\nimport org.hibernate.service.spi.ServiceRegistryImplementor;\n\nimport org.jboss.logging.Logger;\n\n/**\n * A service initiator for the {@link MultiTenantConnectionProvider} service.\n *\n * @author Steve Ebersole\n */\npublic class MultiTenantConnectionProviderInitiator implements StandardServiceInitiator<MultiTenantConnectionProvider<?>> {\n\tprivate static final Logger log = Logger.getLogger( MultiTenantConnectionProviderInitiator.class );\n\n\t/**\n\t * Singleton access\n\t */\n\tpublic static final MultiTenantConnectionProviderInitiator INSTANCE = new MultiTenantConnectionProviderInitiator();\n\n\t@Override\n\tpublic Class<MultiTenantConnectionProvider<?>> getServiceInitiated() {\n\t\t//noinspection unchecked\n\t\treturn (Class<MultiTenantConnectionProvider<?>>) (Class<?>) MultiTenantConnectionProvider.class;\n\t}\n\n\t@Override\n\tpublic MultiTenantConnectionProvider<?> initiateService(Map<String, Object> configurationValues, ServiceRegistryImplementor registry) {\n\t\tif ( !configurationValues.containsKey( AvailableSettings.MULTI_TENANT_CONNECTION_PROVIDER ) ) {\n\t\t\tfinal BeanContainer beanContainer = Helper.allowExtensionsInCdi( registry ) ? registry.requireService( ManagedBeanRegistry.class ).getBeanContainer() : null;\n\t\t\tif (beanContainer != null) {\n\t\t\t\treturn beanContainer.getBean(\n\t\t\t\t\t\tMultiTenantConnectionProvider.class,\n\t\t\t\t\t\tnew BeanContainer.LifecycleOptions() {\n\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\tpublic boolean canUseCachedReferences() {\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\tpublic boolean useJpaCompliantCreation() {\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\tnew BeanInstanceProducer() {\n\n\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\tpublic <B> B produceBeanInstance(Class<B> beanType) {\n\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\tpublic <B> B produceBeanInstance(String name, Class<B> beanType) {\n\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\t\t\t\t).getBeanInstance();\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\n\t\tfinal Object configValue = configurationValues.get( AvailableSettings.MULTI_TENANT_CONNECTION_PROVIDER );\n\t\tif ( configValue == null ) {\n\t\t\t// if they also specified the data source *name*, then lets assume they want\n\t\t\t// DataSourceBasedMultiTenantConnectionProviderImpl\n\t\t\tfinal Object dataSourceConfigValue = configurationValues.get( AvailableSettings.DATASOURCE );\n\t\t\tif ( dataSourceConfigValue instanceof String ) {\n\t\t\t\treturn new DataSourceBasedMultiTenantConnectionProviderImpl<>();\n\t\t\t}\n\n\t\t\treturn null;\n\t\t}\n\n\t\tif ( configValue instanceof MultiTenantConnectionProvider<?> ) {\n\t\t\treturn (MultiTenantConnectionProvider<?>) configValue;\n\t\t}\n\t\telse {\n\t\t\tfinal Class<MultiTenantConnectionProvider<?>> implClass;\n\t\t\tif ( configValue instanceof Class ) {\n\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\tClass<MultiTenantConnectionProvider<?>> clazz = (Class<MultiTenantConnectionProvider<?>>) configValue;\n\t\t\t\timplClass = clazz;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfinal String className = configValue.toString();\n\t\t\t\tfinal ClassLoaderService classLoaderService = registry.requireService( ClassLoaderService.class );\n\t\t\t\ttry {\n\t\t\t\t\timplClass = classLoaderService.classForName( className );\n\t\t\t\t}\n\t\t\t\tcatch (ClassLoadingException cle) {\n\t\t\t\t\tlog.warn( \"Unable to locate specified class [\" + className + \"]\", cle );\n\t\t\t\t\tthrow new ServiceException( \"Unable to locate specified multi-tenant connection provider [\" + className + \"]\" );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\treturn implClass.newInstance();\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tlog.warn( \"Unable to instantiate specified class [\" + implClass.getName() + \"]\", e );\n\t\t\t\tthrow new ServiceException( \"Unable to instantiate specified multi-tenant connection provider [\" + implClass.getName() + \"]\" );\n\t\t\t}\n\t\t}\n\t}\n}\n",
        "filePathAfter": "hibernate-core/src/main/java/org/hibernate/engine/jdbc/connections/internal/MultiTenantConnectionProviderInitiator.java",
        "sourceCodeAfterForWhole": "/*\n * SPDX-License-Identifier: LGPL-2.1-or-later\n * Copyright Red Hat Inc. and Hibernate Authors\n */\npackage org.hibernate.engine.jdbc.connections.internal;\n\nimport java.util.Map;\n\nimport org.hibernate.boot.registry.StandardServiceInitiator;\nimport org.hibernate.boot.registry.classloading.spi.ClassLoaderService;\nimport org.hibernate.boot.registry.classloading.spi.ClassLoadingException;\nimport org.hibernate.cfg.AvailableSettings;\nimport org.hibernate.engine.jdbc.connections.spi.DataSourceBasedMultiTenantConnectionProviderImpl;\nimport org.hibernate.engine.jdbc.connections.spi.MultiTenantConnectionProvider;\nimport org.hibernate.resource.beans.internal.Helper;\nimport org.hibernate.service.spi.ServiceException;\nimport org.hibernate.service.spi.ServiceRegistryImplementor;\n\nimport org.jboss.logging.Logger;\n\n/**\n * A service initiator for the {@link MultiTenantConnectionProvider} service.\n *\n * @author Steve Ebersole\n */\npublic class MultiTenantConnectionProviderInitiator implements StandardServiceInitiator<MultiTenantConnectionProvider<?>> {\n\tprivate static final Logger log = Logger.getLogger( MultiTenantConnectionProviderInitiator.class );\n\n\t/**\n\t * Singleton access\n\t */\n\tpublic static final MultiTenantConnectionProviderInitiator INSTANCE = new MultiTenantConnectionProviderInitiator();\n\n\t@Override\n\tpublic Class<MultiTenantConnectionProvider<?>> getServiceInitiated() {\n\t\t//noinspection unchecked\n\t\treturn (Class<MultiTenantConnectionProvider<?>>) (Class<?>) MultiTenantConnectionProvider.class;\n\t}\n\n\t@Override\n\tpublic MultiTenantConnectionProvider<?> initiateService(Map<String, Object> configurationValues, ServiceRegistryImplementor registry) {\n\t\tif ( !configurationValues.containsKey( AvailableSettings.MULTI_TENANT_CONNECTION_PROVIDER ) ) {\n\t\t\treturn Helper.getBean(\n\t\t\t\tHelper.getBeanContainer( registry ),\n\t\t\t\tMultiTenantConnectionProvider.class,\n\t\t\t\ttrue,\n\t\t\t\ttrue,\n\t\t\t\tnull\n\t\t\t);\n\t\t}\n\n\t\tfinal Object configValue = configurationValues.get( AvailableSettings.MULTI_TENANT_CONNECTION_PROVIDER );\n\t\tif ( configValue == null ) {\n\t\t\t// if they also specified the data source *name*, then lets assume they want\n\t\t\t// DataSourceBasedMultiTenantConnectionProviderImpl\n\t\t\tfinal Object dataSourceConfigValue = configurationValues.get( AvailableSettings.DATASOURCE );\n\t\t\tif ( dataSourceConfigValue instanceof String ) {\n\t\t\t\treturn new DataSourceBasedMultiTenantConnectionProviderImpl<>();\n\t\t\t}\n\n\t\t\treturn null;\n\t\t}\n\n\t\tif ( configValue instanceof MultiTenantConnectionProvider<?> ) {\n\t\t\treturn (MultiTenantConnectionProvider<?>) configValue;\n\t\t}\n\t\telse {\n\t\t\tfinal Class<MultiTenantConnectionProvider<?>> implClass;\n\t\t\tif ( configValue instanceof Class ) {\n\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\tClass<MultiTenantConnectionProvider<?>> clazz = (Class<MultiTenantConnectionProvider<?>>) configValue;\n\t\t\t\timplClass = clazz;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfinal String className = configValue.toString();\n\t\t\t\tfinal ClassLoaderService classLoaderService = registry.requireService( ClassLoaderService.class );\n\t\t\t\ttry {\n\t\t\t\t\timplClass = classLoaderService.classForName( className );\n\t\t\t\t}\n\t\t\t\tcatch (ClassLoadingException cle) {\n\t\t\t\t\tlog.warn( \"Unable to locate specified class [\" + className + \"]\", cle );\n\t\t\t\t\tthrow new ServiceException( \"Unable to locate specified multi-tenant connection provider [\" + className + \"]\" );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\treturn implClass.newInstance();\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tlog.warn( \"Unable to instantiate specified class [\" + implClass.getName() + \"]\", e );\n\t\t\t\tthrow new ServiceException( \"Unable to instantiate specified multi-tenant connection provider [\" + implClass.getName() + \"]\" );\n\t\t\t}\n\t\t}\n\t}\n}\n",
        "diffSourceCodeSet": [
            "}\n\n\t\tfinal Object configValue = configurationValues.get( AvailableSettings.MULTI_TENANT_CONNECTION_PROVIDER );\n\t\tif ( configValue == null ) {"
        ],
        "invokedMethodSet": [
            "methodSignature: org.hibernate.resource.beans.internal.Helper#allowExtensionsInCdi\n methodBody: public static boolean allowExtensionsInCdi(ServiceRegistry serviceRegistry) {\nreturn serviceRegistry.requireService(ConfigurationService.class).getSetting(ALLOW_EXTENSIONS_IN_CDI,BOOLEAN,false);\n}"
        ],
        "sourceCodeAfterRefactoring": "@Override\n\tpublic MultiTenantConnectionProvider<?> initiateService(Map<String, Object> configurationValues, ServiceRegistryImplementor registry) {\n\t\tif ( !configurationValues.containsKey( AvailableSettings.MULTI_TENANT_CONNECTION_PROVIDER ) ) {\n\t\t\treturn Helper.getBean(\n\t\t\t\tHelper.getBeanContainer( registry ),\n\t\t\t\tMultiTenantConnectionProvider.class,\n\t\t\t\ttrue,\n\t\t\t\ttrue,\n\t\t\t\tnull\n\t\t\t);\n\t\t}\n\n\t\tfinal Object configValue = configurationValues.get( AvailableSettings.MULTI_TENANT_CONNECTION_PROVIDER );\n\t\tif ( configValue == null ) {\n\t\t\t// if they also specified the data source *name*, then lets assume they want\n\t\t\t// DataSourceBasedMultiTenantConnectionProviderImpl\n\t\t\tfinal Object dataSourceConfigValue = configurationValues.get( AvailableSettings.DATASOURCE );\n\t\t\tif ( dataSourceConfigValue instanceof String ) {\n\t\t\t\treturn new DataSourceBasedMultiTenantConnectionProviderImpl<>();\n\t\t\t}\n\n\t\t\treturn null;\n\t\t}\n\n\t\tif ( configValue instanceof MultiTenantConnectionProvider<?> ) {\n\t\t\treturn (MultiTenantConnectionProvider<?>) configValue;\n\t\t}\n\t\telse {\n\t\t\tfinal Class<MultiTenantConnectionProvider<?>> implClass;\n\t\t\tif ( configValue instanceof Class ) {\n\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\tClass<MultiTenantConnectionProvider<?>> clazz = (Class<MultiTenantConnectionProvider<?>>) configValue;\n\t\t\t\timplClass = clazz;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfinal String className = configValue.toString();\n\t\t\t\tfinal ClassLoaderService classLoaderService = registry.requireService( ClassLoaderService.class );\n\t\t\t\ttry {\n\t\t\t\t\timplClass = classLoaderService.classForName( className );\n\t\t\t\t}\n\t\t\t\tcatch (ClassLoadingException cle) {\n\t\t\t\t\tlog.warn( \"Unable to locate specified class [\" + className + \"]\", cle );\n\t\t\t\t\tthrow new ServiceException( \"Unable to locate specified multi-tenant connection provider [\" + className + \"]\" );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\treturn implClass.newInstance();\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tlog.warn( \"Unable to instantiate specified class [\" + implClass.getName() + \"]\", e );\n\t\t\t\tthrow new ServiceException( \"Unable to instantiate specified multi-tenant connection provider [\" + implClass.getName() + \"]\" );\n\t\t\t}\n\t\t}\n\t}\n}\n\n\t\tfinal Object configValue = configurationValues.get( AvailableSettings.MULTI_TENANT_CONNECTION_PROVIDER );\n\t\tif ( configValue == null ) {",
        "diffSourceCode": "-   40: \t\treturn (Class<MultiTenantConnectionProvider<?>>) (Class<?>) MultiTenantConnectionProvider.class;\n-   41: \t}\n-   42: \n-   43: \t@Override\n-   44: \tpublic MultiTenantConnectionProvider<?> initiateService(Map<String, Object> configurationValues, ServiceRegistryImplementor registry) {\n-   45: \t\tif ( !configurationValues.containsKey( AvailableSettings.MULTI_TENANT_CONNECTION_PROVIDER ) ) {\n-   46: \t\t\tfinal BeanContainer beanContainer = Helper.allowExtensionsInCdi( registry ) ? registry.requireService( ManagedBeanRegistry.class ).getBeanContainer() : null;\n-   47: \t\t\tif (beanContainer != null) {\n-   48: \t\t\t\treturn beanContainer.getBean(\n-   49: \t\t\t\t\t\tMultiTenantConnectionProvider.class,\n-   50: \t\t\t\t\t\tnew BeanContainer.LifecycleOptions() {\n-   51: \t\t\t\t\t\t\t@Override\n-   52: \t\t\t\t\t\t\tpublic boolean canUseCachedReferences() {\n-   53: \t\t\t\t\t\t\t\treturn true;\n-   54: \t\t\t\t\t\t\t}\n-   55: \n-   56: \t\t\t\t\t\t\t@Override\n-   57: \t\t\t\t\t\t\tpublic boolean useJpaCompliantCreation() {\n-   58: \t\t\t\t\t\t\t\treturn true;\n-   59: \t\t\t\t\t\t\t}\n-   60: \t\t\t\t\t\t},\n-   61: \t\t\t\t\t\tnew BeanInstanceProducer() {\n-   62: \n-   63: \t\t\t\t\t\t\t@Override\n-   64: \t\t\t\t\t\t\tpublic <B> B produceBeanInstance(Class<B> beanType) {\n-   65: \t\t\t\t\t\t\t\treturn null;\n-   66: \t\t\t\t\t\t\t}\n-   67: \n-   68: \t\t\t\t\t\t\t@Override\n-   69: \t\t\t\t\t\t\tpublic <B> B produceBeanInstance(String name, Class<B> beanType) {\n-   70: \t\t\t\t\t\t\t\treturn null;\n-   71: \t\t\t\t\t\t\t}\n-   72: \n-   73: \t\t\t\t\t\t}\n-   74: \t\t\t\t).getBeanInstance();\n-   75: \t\t\t}\n-   76: \t\t\treturn null;\n-   77: \t\t}\n-   78: \n-   79: \t\tfinal Object configValue = configurationValues.get( AvailableSettings.MULTI_TENANT_CONNECTION_PROVIDER );\n-   80: \t\tif ( configValue == null ) {\n-   81: \t\t\t// if they also specified the data source *name*, then lets assume they want\n-   82: \t\t\t// DataSourceBasedMultiTenantConnectionProviderImpl\n-   83: \t\t\tfinal Object dataSourceConfigValue = configurationValues.get( AvailableSettings.DATASOURCE );\n-   84: \t\t\tif ( dataSourceConfigValue instanceof String ) {\n-   85: \t\t\t\treturn new DataSourceBasedMultiTenantConnectionProviderImpl<>();\n-   86: \t\t\t}\n-   87: \n-   88: \t\t\treturn null;\n-   89: \t\t}\n-   90: \n-   91: \t\tif ( configValue instanceof MultiTenantConnectionProvider<?> ) {\n-   92: \t\t\treturn (MultiTenantConnectionProvider<?>) configValue;\n+   40: \t@Override\n+   41: \tpublic MultiTenantConnectionProvider<?> initiateService(Map<String, Object> configurationValues, ServiceRegistryImplementor registry) {\n+   42: \t\tif ( !configurationValues.containsKey( AvailableSettings.MULTI_TENANT_CONNECTION_PROVIDER ) ) {\n+   43: \t\t\treturn Helper.getBean(\n+   44: \t\t\t\tHelper.getBeanContainer( registry ),\n+   45: \t\t\t\tMultiTenantConnectionProvider.class,\n+   46: \t\t\t\ttrue,\n+   47: \t\t\t\ttrue,\n+   48: \t\t\t\tnull\n+   49: \t\t\t);\n+   50: \t\t}\n+   51: \n+   52: \t\tfinal Object configValue = configurationValues.get( AvailableSettings.MULTI_TENANT_CONNECTION_PROVIDER );\n+   53: \t\tif ( configValue == null ) {\n+   54: \t\t\t// if they also specified the data source *name*, then lets assume they want\n+   55: \t\t\t// DataSourceBasedMultiTenantConnectionProviderImpl\n+   56: \t\t\tfinal Object dataSourceConfigValue = configurationValues.get( AvailableSettings.DATASOURCE );\n+   57: \t\t\tif ( dataSourceConfigValue instanceof String ) {\n+   58: \t\t\t\treturn new DataSourceBasedMultiTenantConnectionProviderImpl<>();\n+   59: \t\t\t}\n+   60: \n+   61: \t\t\treturn null;\n+   62: \t\t}\n+   63: \n+   64: \t\tif ( configValue instanceof MultiTenantConnectionProvider<?> ) {\n+   65: \t\t\treturn (MultiTenantConnectionProvider<?>) configValue;\n+   66: \t\t}\n+   67: \t\telse {\n+   68: \t\t\tfinal Class<MultiTenantConnectionProvider<?>> implClass;\n+   69: \t\t\tif ( configValue instanceof Class ) {\n+   70: \t\t\t\t@SuppressWarnings(\"unchecked\")\n+   71: \t\t\t\tClass<MultiTenantConnectionProvider<?>> clazz = (Class<MultiTenantConnectionProvider<?>>) configValue;\n+   72: \t\t\t\timplClass = clazz;\n+   73: \t\t\t}\n+   74: \t\t\telse {\n+   75: \t\t\t\tfinal String className = configValue.toString();\n+   76: \t\t\t\tfinal ClassLoaderService classLoaderService = registry.requireService( ClassLoaderService.class );\n+   77: \t\t\t\ttry {\n+   78: \t\t\t\t\timplClass = classLoaderService.classForName( className );\n+   79: \t\t\t\t}\n+   80: \t\t\t\tcatch (ClassLoadingException cle) {\n+   81: \t\t\t\t\tlog.warn( \"Unable to locate specified class [\" + className + \"]\", cle );\n+   82: \t\t\t\t\tthrow new ServiceException( \"Unable to locate specified multi-tenant connection provider [\" + className + \"]\" );\n+   83: \t\t\t\t}\n+   84: \t\t\t}\n+   85: \n+   86: \t\t\ttry {\n+   87: \t\t\t\treturn implClass.newInstance();\n+   88: \t\t\t}\n+   89: \t\t\tcatch (Exception e) {\n+   90: \t\t\t\tlog.warn( \"Unable to instantiate specified class [\" + implClass.getName() + \"]\", e );\n+   91: \t\t\t\tthrow new ServiceException( \"Unable to instantiate specified multi-tenant connection provider [\" + implClass.getName() + \"]\" );\n+   92: \t\t\t}\n    93: \t\t}\n-   94: \t\telse {\n-   95: \t\t\tfinal Class<MultiTenantConnectionProvider<?>> implClass;\n-   96: \t\t\tif ( configValue instanceof Class ) {\n-   97: \t\t\t\t@SuppressWarnings(\"unchecked\")\n-   98: \t\t\t\tClass<MultiTenantConnectionProvider<?>> clazz = (Class<MultiTenantConnectionProvider<?>>) configValue;\n-   99: \t\t\t\timplClass = clazz;\n-  100: \t\t\t}\n-  101: \t\t\telse {\n-  102: \t\t\t\tfinal String className = configValue.toString();\n-  103: \t\t\t\tfinal ClassLoaderService classLoaderService = registry.requireService( ClassLoaderService.class );\n-  104: \t\t\t\ttry {\n-  105: \t\t\t\t\timplClass = classLoaderService.classForName( className );\n-  106: \t\t\t\t}\n-  107: \t\t\t\tcatch (ClassLoadingException cle) {\n-  108: \t\t\t\t\tlog.warn( \"Unable to locate specified class [\" + className + \"]\", cle );\n-  109: \t\t\t\t\tthrow new ServiceException( \"Unable to locate specified multi-tenant connection provider [\" + className + \"]\" );\n-  110: \t\t\t\t}\n-  111: \t\t\t}\n-  112: \n-  113: \t\t\ttry {\n-  114: \t\t\t\treturn implClass.newInstance();\n-  115: \t\t\t}\n-  116: \t\t\tcatch (Exception e) {\n-  117: \t\t\t\tlog.warn( \"Unable to instantiate specified class [\" + implClass.getName() + \"]\", e );\n-  118: \t\t\t\tthrow new ServiceException( \"Unable to instantiate specified multi-tenant connection provider [\" + implClass.getName() + \"]\" );\n-  119: \t\t\t}\n-  120: \t\t}\n-  121: \t}\n+   94: \t}\n+   95: }\n",
        "uniqueId": "2f7052c0ce5114e492c7dc4e4b8abd5283b2fe13_43_121_50_53_40_94",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 42,
                "covered": 68
            },
            "BRANCH": {
                "missed": 4,
                "covered": 10
            },
            "LINE": {
                "missed": 13,
                "covered": 16
            },
            "COMPLEXITY": {
                "missed": 3,
                "covered": 5
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 21
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprivate getTransactionAdapterPreferringTransactionManager() : JtaTransactionAdapter extracted from private makePhysicalTransactionDelegate() : TransactionDriverControlImpl in class org.hibernate.resource.transaction.backend.jta.internal.JtaTransactionCoordinatorImpl",
        "diffLocations": [
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/resource/transaction/backend/jta/internal/JtaTransactionCoordinatorImpl.java",
                "startLine": 223,
                "endLine": 250,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/resource/transaction/backend/jta/internal/JtaTransactionCoordinatorImpl.java",
                "startLine": 214,
                "endLine": 227,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/resource/transaction/backend/jta/internal/JtaTransactionCoordinatorImpl.java",
                "startLine": 229,
                "endLine": 236,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "private TransactionDriverControlImpl makePhysicalTransactionDelegate() {\n\t\tJtaTransactionAdapter adapter;\n\n\t\tif ( preferUserTransactions ) {\n\t\t\tadapter = makeUserTransactionAdapter();\n\n\t\t\tif ( adapter == null ) {\n\t\t\t\tlog.debug( \"Unable to access UserTransaction, attempting to use TransactionManager instead\" );\n\t\t\t\tadapter = makeTransactionManagerAdapter();\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tadapter = makeTransactionManagerAdapter();\n\n\t\t\tif ( adapter == null ) {\n\t\t\t\tlog.debug( \"Unable to access TransactionManager, attempting to use UserTransaction instead\" );\n\t\t\t\tadapter = makeUserTransactionAdapter();\n\t\t\t}\n\t\t}\n\n\t\tif ( adapter == null ) {\n\t\t\tthrow new JtaPlatformInaccessibleException(\n\t\t\t\t\t\"Unable to access TransactionManager or UserTransaction to make physical transaction delegate\"\n\t\t\t);\n\t\t}\n\n\t\treturn new TransactionDriverControlImpl( adapter );\n\t}",
        "filePathBefore": "hibernate-core/src/main/java/org/hibernate/resource/transaction/backend/jta/internal/JtaTransactionCoordinatorImpl.java",
        "isPureRefactoring": true,
        "commitId": "453f0ff0749136eac008f9c16fb7742de7ccbadb",
        "packageNameBefore": "org.hibernate.resource.transaction.backend.jta.internal",
        "classNameBefore": "org.hibernate.resource.transaction.backend.jta.internal.JtaTransactionCoordinatorImpl",
        "methodNameBefore": "org.hibernate.resource.transaction.backend.jta.internal.JtaTransactionCoordinatorImpl#makePhysicalTransactionDelegate",
        "invokedMethod": "methodSignature: org.hibernate.resource.transaction.backend.jta.internal.JtaTransactionCoordinatorImpl#makeTransactionManagerAdapter\n methodBody: private JtaTransactionAdapter makeTransactionManagerAdapter() {\ntryfinal TransactionManager transactionManager=jtaPlatform.retrieveTransactionManager();\nif(transactionManager == null){log.debug(\"JtaPlatform#retrieveTransactionManager returned null\");\n}{return new JtaTransactionAdapterTransactionManagerImpl(transactionManager);\n}catch(Exception exception)log.debugf(\"JtaPlatform#retrieveTransactionManager threw an exception [%s]\",exception.getMessage());\nreturn null;\n}\nmethodSignature: org.hibernate.resource.transaction.backend.jta.internal.JtaTransactionCoordinatorImpl#makeUserTransactionAdapter\n methodBody: private JtaTransactionAdapter makeUserTransactionAdapter() {\ntryfinal UserTransaction userTransaction=jtaPlatform.retrieveUserTransaction();\nif(userTransaction == null){log.debug(\"JtaPlatform#retrieveUserTransaction returned null\");\n}{return new JtaTransactionAdapterUserTransactionImpl(userTransaction);\n}catch(Exception exception)log.debugf(\"JtaPlatform#retrieveUserTransaction threw an exception [%s]\",exception.getMessage());\nreturn null;\n}",
        "classSignatureBefore": "public class JtaTransactionCoordinatorImpl implements TransactionCoordinator, SynchronizationCallbackTarget ",
        "methodNameBeforeSet": [
            "org.hibernate.resource.transaction.backend.jta.internal.JtaTransactionCoordinatorImpl#makePhysicalTransactionDelegate"
        ],
        "classNameBeforeSet": [
            "org.hibernate.resource.transaction.backend.jta.internal.JtaTransactionCoordinatorImpl"
        ],
        "classSignatureBeforeSet": [
            "public class JtaTransactionCoordinatorImpl implements TransactionCoordinator, SynchronizationCallbackTarget "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": " Severe changes",
                "description": "Return expression has been added within the Extract Method mechanics - with non-mapped leaves",
                "mappingState": 2
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * SPDX-License-Identifier: LGPL-2.1-or-later\n * Copyright Red Hat Inc. and Hibernate Authors\n */\npackage org.hibernate.resource.transaction.backend.jta.internal;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport jakarta.transaction.Status;\nimport jakarta.transaction.TransactionManager;\nimport jakarta.transaction.UserTransaction;\n\nimport org.hibernate.engine.transaction.jta.platform.spi.JtaPlatform;\nimport org.hibernate.resource.transaction.spi.IsolationDelegate;\nimport org.hibernate.jpa.spi.JpaCompliance;\nimport org.hibernate.resource.jdbc.spi.JdbcSessionContext;\nimport org.hibernate.resource.transaction.TransactionRequiredForJoinException;\nimport org.hibernate.resource.transaction.backend.jta.internal.synchronization.RegisteredSynchronization;\nimport org.hibernate.resource.transaction.backend.jta.internal.synchronization.SynchronizationCallbackCoordinator;\nimport org.hibernate.resource.transaction.backend.jta.internal.synchronization.SynchronizationCallbackCoordinatorNonTrackingImpl;\nimport org.hibernate.resource.transaction.backend.jta.internal.synchronization.SynchronizationCallbackCoordinatorTrackingImpl;\nimport org.hibernate.resource.transaction.backend.jta.internal.synchronization.SynchronizationCallbackTarget;\nimport org.hibernate.resource.transaction.internal.SynchronizationRegistryStandardImpl;\nimport org.hibernate.resource.transaction.spi.SynchronizationRegistry;\nimport org.hibernate.resource.transaction.spi.TransactionCoordinator;\nimport org.hibernate.resource.transaction.spi.TransactionCoordinatorBuilder;\nimport org.hibernate.resource.transaction.spi.TransactionCoordinatorOwner;\nimport org.hibernate.resource.transaction.spi.TransactionObserver;\nimport org.hibernate.resource.transaction.spi.TransactionStatus;\n\nimport org.jboss.logging.Logger;\n\nimport static java.util.Collections.addAll;\nimport static java.util.Collections.emptyList;\nimport static org.hibernate.internal.CoreLogging.logger;\nimport static org.hibernate.resource.transaction.spi.TransactionStatus.ACTIVE;\nimport static org.hibernate.resource.transaction.spi.TransactionStatus.NOT_ACTIVE;\n\n/**\n * An implementation of TransactionCoordinator based on managing a transaction through the JTA API (either TM or UT)\n *\n * @author Steve Ebersole\n */\npublic class JtaTransactionCoordinatorImpl implements TransactionCoordinator, SynchronizationCallbackTarget {\n\tprivate static final Logger log = logger( JtaTransactionCoordinatorImpl.class );\n\n\tprivate final TransactionCoordinatorBuilder transactionCoordinatorBuilder;\n\tprivate final TransactionCoordinatorOwner transactionCoordinatorOwner;\n\tprivate final JtaPlatform jtaPlatform;\n\tprivate final boolean autoJoinTransactions;\n\tprivate final boolean preferUserTransactions;\n\tprivate final boolean performJtaThreadTracking;\n\n\tprivate boolean synchronizationRegistered;\n\tprivate SynchronizationCallbackCoordinator callbackCoordinator;\n\tprivate TransactionDriverControlImpl physicalTransactionDelegate;\n\n\tprivate final SynchronizationRegistryStandardImpl synchronizationRegistry = new SynchronizationRegistryStandardImpl();\n\n\tprivate int timeOut = -1;\n\n\tprivate transient List<TransactionObserver> observers = null;\n\n\t/**\n\t * Construct a JtaTransactionCoordinatorImpl instance.  package-protected to ensure access goes through\n\t * builder.\n\t *\n\t * @param owner The transactionCoordinatorOwner\n\t * @param autoJoinTransactions Should JTA transactions be auto-joined?  Or should we wait for explicit join calls?\n\t */\n\tJtaTransactionCoordinatorImpl(\n\t\t\tTransactionCoordinatorBuilder transactionCoordinatorBuilder,\n\t\t\tTransactionCoordinatorOwner owner,\n\t\t\tboolean autoJoinTransactions,\n\t\t\tJtaPlatform jtaPlatform) {\n\t\tthis.transactionCoordinatorBuilder = transactionCoordinatorBuilder;\n\t\tthis.transactionCoordinatorOwner = owner;\n\t\tthis.autoJoinTransactions = autoJoinTransactions;\n\n\t\tfinal JdbcSessionContext jdbcSessionContext = owner.getJdbcSessionOwner().getJdbcSessionContext();\n\n\t\tthis.jtaPlatform = jtaPlatform;\n\n\t\tthis.preferUserTransactions = jdbcSessionContext.isPreferUserTransaction();\n\t\tthis.performJtaThreadTracking = jdbcSessionContext.isJtaTrackByThread();\n\n\t\tsynchronizationRegistered = false;\n\n\t\tpulse();\n\t}\n\n\tpublic JtaTransactionCoordinatorImpl(\n\t\t\tTransactionCoordinatorBuilder transactionCoordinatorBuilder,\n\t\t\tTransactionCoordinatorOwner owner,\n\t\t\tboolean autoJoinTransactions,\n\t\t\tJtaPlatform jtaPlatform,\n\t\t\tboolean preferUserTransactions,\n\t\t\tboolean performJtaThreadTracking,\n\t\t\tTransactionObserver... observers) {\n\t\tthis.transactionCoordinatorBuilder = transactionCoordinatorBuilder;\n\t\tthis.transactionCoordinatorOwner = owner;\n\t\tthis.autoJoinTransactions = autoJoinTransactions;\n\t\tthis.jtaPlatform = jtaPlatform;\n\t\tthis.preferUserTransactions = preferUserTransactions;\n\t\tthis.performJtaThreadTracking = performJtaThreadTracking;\n\n\t\tif ( observers != null ) {\n\t\t\tthis.observers = new ArrayList<>( observers.length );\n\t\t\taddAll( this.observers, observers );\n\t\t}\n\n\t\tsynchronizationRegistered = false;\n\n\t\tpulse();\n\t}\n\n\t/**\n\t * Needed because while iterating the observers list and executing the before/update callbacks,\n\t * some observers might get removed from the list.\n\t * Yet try to not allocate anything for when the list is empty, as this is a common case.\n\t *\n\t * @return TransactionObserver\n\t */\n\tprivate Iterable<TransactionObserver> observers() {\n\t\treturn observers == null ? emptyList() : new ArrayList<>( observers );\n\t}\n\n\tpublic SynchronizationCallbackCoordinator getSynchronizationCallbackCoordinator() {\n\t\tif ( callbackCoordinator == null ) {\n\t\t\tcallbackCoordinator = performJtaThreadTracking\n\t\t\t\t\t? new SynchronizationCallbackCoordinatorTrackingImpl( this )\n\t\t\t\t\t: new SynchronizationCallbackCoordinatorNonTrackingImpl( this );\n\t\t}\n\t\treturn callbackCoordinator;\n\t}\n\n\t@Override\n\tpublic void pulse() {\n\t\tif ( !autoJoinTransactions ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( synchronizationRegistered ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Can we register a synchronization according to the JtaPlatform?\n\t\tif ( !jtaPlatform.canRegisterSynchronization() ) {\n\t\t\tlog.trace( \"JTA platform says we cannot currently register synchronization; skipping\" );\n\t\t\treturn;\n\t\t}\n\n\t\tjoinJtaTransaction();\n\t}\n\n\t/**\n\t * Join to the JTA transaction.  Note that the underlying meaning of joining in JTA environments is to register the\n\t * RegisteredSynchronization with the JTA system\n\t */\n\tprivate void joinJtaTransaction() {\n\t\tif ( synchronizationRegistered ) {\n\t\t\treturn;\n\t\t}\n\n\t\tjtaPlatform.registerSynchronization( new RegisteredSynchronization( getSynchronizationCallbackCoordinator() ) );\n\t\tgetSynchronizationCallbackCoordinator().synchronizationRegistered();\n\t\tsynchronizationRegistered = true;\n\t\tlog.debug( \"Hibernate RegisteredSynchronization successfully registered with JTA platform\" );\n\n\t\t// report entering into a \"transactional context\"\n\t\tgetTransactionCoordinatorOwner().startTransactionBoundary();\n\t}\n\n\t@Override\n\tpublic void explicitJoin() {\n\t\tif ( synchronizationRegistered ) {\n\t\t\tlog.debug( \"JTA transaction was already joined (RegisteredSynchronization already registered)\" );\n\t\t\treturn;\n\t\t}\n\n\t\tif ( getTransactionDriverControl().getStatus() != ACTIVE ) {\n\t\t\tthrow new TransactionRequiredForJoinException(\n\t\t\t\t\t\"Explicitly joining a JTA transaction requires a JTA transaction be currently active\"\n\t\t\t);\n\t\t}\n\n\t\tjoinJtaTransaction();\n\t}\n\n\t@Override\n\tpublic boolean isJoined() {\n\t\treturn synchronizationRegistered;\n\t}\n\n\t/**\n\t * Is the RegisteredSynchronization used by Hibernate for unified JTA Synchronization callbacks registered for this\n\t * coordinator?\n\t *\n\t * @return {@code true} indicates that a RegisteredSynchronization is currently registered for this coordinator;\n\t * {@code false} indicates it is not (yet) registered.\n\t */\n\tpublic boolean isSynchronizationRegistered() {\n\t\treturn synchronizationRegistered;\n\t}\n\n\tpublic TransactionCoordinatorOwner getTransactionCoordinatorOwner(){\n\t\treturn this.transactionCoordinatorOwner;\n\t}\n\n\t@Override\n\tpublic JpaCompliance getJpaCompliance() {\n\t\treturn transactionCoordinatorOwner.getJdbcSessionOwner().getJdbcSessionContext().getJpaCompliance();\n\t}\n\n\t@Override\n\tpublic TransactionDriver getTransactionDriverControl() {\n\t\tif ( physicalTransactionDelegate == null ) {\n\t\t\tphysicalTransactionDelegate = makePhysicalTransactionDelegate();\n\t\t}\n\t\treturn physicalTransactionDelegate;\n\t}\n\n\tprivate TransactionDriverControlImpl makePhysicalTransactionDelegate() {\n\t\tJtaTransactionAdapter adapter;\n\n\t\tif ( preferUserTransactions ) {\n\t\t\tadapter = makeUserTransactionAdapter();\n\n\t\t\tif ( adapter == null ) {\n\t\t\t\tlog.debug( \"Unable to access UserTransaction, attempting to use TransactionManager instead\" );\n\t\t\t\tadapter = makeTransactionManagerAdapter();\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tadapter = makeTransactionManagerAdapter();\n\n\t\t\tif ( adapter == null ) {\n\t\t\t\tlog.debug( \"Unable to access TransactionManager, attempting to use UserTransaction instead\" );\n\t\t\t\tadapter = makeUserTransactionAdapter();\n\t\t\t}\n\t\t}\n\n\t\tif ( adapter == null ) {\n\t\t\tthrow new JtaPlatformInaccessibleException(\n\t\t\t\t\t\"Unable to access TransactionManager or UserTransaction to make physical transaction delegate\"\n\t\t\t);\n\t\t}\n\n\t\treturn new TransactionDriverControlImpl( adapter );\n\t}\n\n\tprivate JtaTransactionAdapter makeUserTransactionAdapter() {\n\t\ttry {\n\t\t\tfinal UserTransaction userTransaction = jtaPlatform.retrieveUserTransaction();\n\t\t\tif ( userTransaction == null ) {\n\t\t\t\tlog.debug( \"JtaPlatform#retrieveUserTransaction returned null\" );\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn new JtaTransactionAdapterUserTransactionImpl( userTransaction );\n\t\t\t}\n\t\t}\n\t\tcatch ( Exception exception ) {\n\t\t\tlog.debugf( \"JtaPlatform#retrieveUserTransaction threw an exception [%s]\", exception.getMessage() );\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tprivate JtaTransactionAdapter makeTransactionManagerAdapter() {\n\t\ttry {\n\t\t\tfinal TransactionManager transactionManager = jtaPlatform.retrieveTransactionManager();\n\t\t\tif ( transactionManager == null ) {\n\t\t\t\tlog.debug( \"JtaPlatform#retrieveTransactionManager returned null\" );\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn new JtaTransactionAdapterTransactionManagerImpl( transactionManager );\n\t\t\t}\n\t\t}\n\t\tcatch ( Exception exception ) {\n\t\t\tlog.debugf( \"JtaPlatform#retrieveTransactionManager threw an exception [%s]\", exception.getMessage() );\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic SynchronizationRegistry getLocalSynchronizations() {\n\t\treturn synchronizationRegistry;\n\t}\n\n\t@Override\n\tpublic boolean isActive() {\n\t\treturn transactionCoordinatorOwner.isActive();\n\t}\n\n\tpublic boolean isJtaTransactionCurrentlyActive() {\n\t\treturn getTransactionDriverControl().getStatus() == ACTIVE;\n\t}\n\n\t@Override\n\tpublic IsolationDelegate createIsolationDelegate() {\n\t\treturn new JtaIsolationDelegate( transactionCoordinatorOwner, jtaPlatform.retrieveTransactionManager() );\n\t}\n\n\t@Override\n\tpublic TransactionCoordinatorBuilder getTransactionCoordinatorBuilder() {\n\t\treturn transactionCoordinatorBuilder;\n\t}\n\n\t@Override\n\tpublic void setTimeOut(int seconds) {\n\t\tthis.timeOut = seconds;\n\t\tphysicalTransactionDelegate.jtaTransactionAdapter.setTimeOut( seconds );\n\t}\n\n\t@Override\n\tpublic int getTimeOut() {\n\t\treturn timeOut;\n\t}\n\n\t@Override\n\tpublic void invalidate() {\n\t\tif ( physicalTransactionDelegate != null ) {\n\t\t\tphysicalTransactionDelegate.invalidate();\n\t\t}\n\t\tphysicalTransactionDelegate = null;\n\t}\n\n\t// SynchronizationCallbackTarget ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n\t@Override\n\tpublic void beforeCompletion() {\n\t\ttry {\n\t\t\ttransactionCoordinatorOwner.beforeTransactionCompletion();\n\t\t}\n\t\tcatch ( Exception e ) {\n\t\t\tphysicalTransactionDelegate.markRollbackOnly();\n\t\t\tthrow e;\n\t\t}\n\t\tfinally {\n\t\t\tsynchronizationRegistry.notifySynchronizationsBeforeTransactionCompletion();\n\t\t\tfor ( TransactionObserver observer : observers() ) {\n\t\t\t\tobserver.beforeCompletion();\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic void afterCompletion(boolean successful, boolean delayed) {\n\t\tif ( !transactionCoordinatorOwner.isActive() ) {\n\t\t\treturn;\n\t\t}\n\n\t\tfinal int statusToSend =  successful ? Status.STATUS_COMMITTED : Status.STATUS_UNKNOWN;\n\t\tsynchronizationRegistry.notifySynchronizationsAfterTransactionCompletion( statusToSend );\n\n//\t\tafterCompletionAction.doAction( this, statusToSend );\n\n\t\ttransactionCoordinatorOwner.afterTransactionCompletion( successful, delayed );\n\n\t\tfor ( TransactionObserver observer : observers() ) {\n\t\t\tobserver.afterCompletion( successful, delayed );\n\t\t}\n\n\t\tsynchronizationRegistered = false;\n\t}\n\n\tpublic void addObserver(TransactionObserver observer) {\n\t\tif ( observers == null ) {\n\t\t\tobservers = new ArrayList<>( 3 ); //These lists are typically very small.\n\t\t}\n\t\tobservers.add( observer );\n\t}\n\n\t@Override\n\tpublic void removeObserver(TransactionObserver observer) {\n\t\tif ( observers != null ) {\n\t\t\tobservers.remove( observer );\n\t\t}\n\t}\n\n\t/**\n\t * Implementation of the LocalInflow for this TransactionCoordinator.  Allows the\n\t * local transaction ({@link org.hibernate.Transaction} to callback into this\n\t * TransactionCoordinator for the purpose of driving the underlying JTA transaction.\n\t */\n\tpublic class TransactionDriverControlImpl implements TransactionDriver {\n\t\tprivate final JtaTransactionAdapter jtaTransactionAdapter;\n\t\tprivate boolean invalid;\n\n\t\tpublic TransactionDriverControlImpl(JtaTransactionAdapter jtaTransactionAdapter) {\n\t\t\tthis.jtaTransactionAdapter = jtaTransactionAdapter;\n\t\t}\n\n\t\tprotected void invalidate() {\n\t\t\tinvalid = true;\n\t\t}\n\n\t\t@Override\n\t\tpublic void begin() {\n\t\t\terrorIfInvalid();\n\n\t\t\tjtaTransactionAdapter.begin();\n\t\t\tJtaTransactionCoordinatorImpl.this.joinJtaTransaction();\n\t\t}\n\n\t\tprotected void errorIfInvalid() {\n\t\t\tif ( invalid ) {\n\t\t\t\tthrow new IllegalStateException( \"Physical-transaction delegate is no longer valid\" );\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic void commit() {\n\t\t\terrorIfInvalid();\n\t\t\tgetTransactionCoordinatorOwner().flushBeforeTransactionCompletion();\n\n\t\t\t// we don't have to perform any before/after completion processing here.  We leave that for\n\t\t\t// the Synchronization callbacks\n\t\t\tjtaTransactionAdapter.commit();\n\t\t}\n\n\t\t@Override\n\t\tpublic void rollback() {\n\t\t\terrorIfInvalid();\n\n\t\t\t// we don't have to perform any after completion processing here.  We leave that for\n\t\t\t// the Synchronization callbacks\n\t\t\tjtaTransactionAdapter.rollback();\n\t\t}\n\n\t\t@Override\n\t\tpublic TransactionStatus getStatus() {\n\t\t\treturn jtaTransactionAdapter.getStatus();\n\t\t}\n\n\t\t@Override\n\t\tpublic void markRollbackOnly() {\n\t\t\tif ( jtaTransactionAdapter.getStatus() != NOT_ACTIVE  ) {\n\t\t\t\tjtaTransactionAdapter.markRollbackOnly();\n\t\t\t}\n\t\t}\n\t}\n\n}\n",
        "filePathAfter": "hibernate-core/src/main/java/org/hibernate/resource/transaction/backend/jta/internal/JtaTransactionCoordinatorImpl.java",
        "sourceCodeAfterForWhole": "/*\n * SPDX-License-Identifier: LGPL-2.1-or-later\n * Copyright Red Hat Inc. and Hibernate Authors\n */\npackage org.hibernate.resource.transaction.backend.jta.internal;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport jakarta.transaction.Status;\nimport jakarta.transaction.TransactionManager;\nimport jakarta.transaction.UserTransaction;\n\nimport org.hibernate.engine.transaction.jta.platform.spi.JtaPlatform;\nimport org.hibernate.resource.transaction.spi.IsolationDelegate;\nimport org.hibernate.jpa.spi.JpaCompliance;\nimport org.hibernate.resource.jdbc.spi.JdbcSessionContext;\nimport org.hibernate.resource.transaction.TransactionRequiredForJoinException;\nimport org.hibernate.resource.transaction.backend.jta.internal.synchronization.RegisteredSynchronization;\nimport org.hibernate.resource.transaction.backend.jta.internal.synchronization.SynchronizationCallbackCoordinator;\nimport org.hibernate.resource.transaction.backend.jta.internal.synchronization.SynchronizationCallbackCoordinatorNonTrackingImpl;\nimport org.hibernate.resource.transaction.backend.jta.internal.synchronization.SynchronizationCallbackCoordinatorTrackingImpl;\nimport org.hibernate.resource.transaction.backend.jta.internal.synchronization.SynchronizationCallbackTarget;\nimport org.hibernate.resource.transaction.internal.SynchronizationRegistryStandardImpl;\nimport org.hibernate.resource.transaction.spi.SynchronizationRegistry;\nimport org.hibernate.resource.transaction.spi.TransactionCoordinator;\nimport org.hibernate.resource.transaction.spi.TransactionCoordinatorBuilder;\nimport org.hibernate.resource.transaction.spi.TransactionCoordinatorOwner;\nimport org.hibernate.resource.transaction.spi.TransactionObserver;\nimport org.hibernate.resource.transaction.spi.TransactionStatus;\n\nimport org.jboss.logging.Logger;\n\nimport static java.util.Collections.addAll;\nimport static java.util.Collections.emptyList;\nimport static org.hibernate.internal.CoreLogging.logger;\nimport static org.hibernate.resource.transaction.spi.TransactionStatus.ACTIVE;\nimport static org.hibernate.resource.transaction.spi.TransactionStatus.NOT_ACTIVE;\n\n/**\n * An implementation of TransactionCoordinator based on managing a transaction through the JTA API (either TM or UT)\n *\n * @author Steve Ebersole\n */\npublic class JtaTransactionCoordinatorImpl implements TransactionCoordinator, SynchronizationCallbackTarget {\n\tprivate static final Logger log = logger( JtaTransactionCoordinatorImpl.class );\n\n\tprivate final TransactionCoordinatorBuilder transactionCoordinatorBuilder;\n\tprivate final TransactionCoordinatorOwner transactionCoordinatorOwner;\n\tprivate final JtaPlatform jtaPlatform;\n\tprivate final boolean autoJoinTransactions;\n\tprivate final boolean preferUserTransactions;\n\tprivate final boolean performJtaThreadTracking;\n\n\tprivate boolean synchronizationRegistered;\n\tprivate SynchronizationCallbackCoordinator callbackCoordinator;\n\tprivate TransactionDriverControlImpl physicalTransactionDelegate;\n\n\tprivate final SynchronizationRegistryStandardImpl synchronizationRegistry = new SynchronizationRegistryStandardImpl();\n\n\tprivate int timeOut = -1;\n\n\tprivate transient List<TransactionObserver> observers = null;\n\n\t/**\n\t * Construct a JtaTransactionCoordinatorImpl instance.  package-protected to ensure access goes through\n\t * builder.\n\t *\n\t * @param owner The transactionCoordinatorOwner\n\t * @param autoJoinTransactions Should JTA transactions be auto-joined?  Or should we wait for explicit join calls?\n\t */\n\tJtaTransactionCoordinatorImpl(\n\t\t\tTransactionCoordinatorBuilder transactionCoordinatorBuilder,\n\t\t\tTransactionCoordinatorOwner owner,\n\t\t\tboolean autoJoinTransactions,\n\t\t\tJtaPlatform jtaPlatform) {\n\t\tthis.transactionCoordinatorBuilder = transactionCoordinatorBuilder;\n\t\tthis.transactionCoordinatorOwner = owner;\n\t\tthis.autoJoinTransactions = autoJoinTransactions;\n\n\t\tfinal JdbcSessionContext jdbcSessionContext = owner.getJdbcSessionOwner().getJdbcSessionContext();\n\n\t\tthis.jtaPlatform = jtaPlatform;\n\n\t\tthis.preferUserTransactions = jdbcSessionContext.isPreferUserTransaction();\n\t\tthis.performJtaThreadTracking = jdbcSessionContext.isJtaTrackByThread();\n\n\t\tsynchronizationRegistered = false;\n\n\t\tpulse();\n\t}\n\n\tpublic JtaTransactionCoordinatorImpl(\n\t\t\tTransactionCoordinatorBuilder transactionCoordinatorBuilder,\n\t\t\tTransactionCoordinatorOwner owner,\n\t\t\tboolean autoJoinTransactions,\n\t\t\tJtaPlatform jtaPlatform,\n\t\t\tboolean preferUserTransactions,\n\t\t\tboolean performJtaThreadTracking,\n\t\t\tTransactionObserver... observers) {\n\t\tthis.transactionCoordinatorBuilder = transactionCoordinatorBuilder;\n\t\tthis.transactionCoordinatorOwner = owner;\n\t\tthis.autoJoinTransactions = autoJoinTransactions;\n\t\tthis.jtaPlatform = jtaPlatform;\n\t\tthis.preferUserTransactions = preferUserTransactions;\n\t\tthis.performJtaThreadTracking = performJtaThreadTracking;\n\n\t\tif ( observers != null ) {\n\t\t\tthis.observers = new ArrayList<>( observers.length );\n\t\t\taddAll( this.observers, observers );\n\t\t}\n\n\t\tsynchronizationRegistered = false;\n\n\t\tpulse();\n\t}\n\n\t/**\n\t * Needed because while iterating the observers list and executing the before/update callbacks,\n\t * some observers might get removed from the list.\n\t * Yet try to not allocate anything for when the list is empty, as this is a common case.\n\t *\n\t * @return TransactionObserver\n\t */\n\tprivate Iterable<TransactionObserver> observers() {\n\t\treturn observers == null ? emptyList() : new ArrayList<>( observers );\n\t}\n\n\tpublic SynchronizationCallbackCoordinator getSynchronizationCallbackCoordinator() {\n\t\tif ( callbackCoordinator == null ) {\n\t\t\tcallbackCoordinator = performJtaThreadTracking\n\t\t\t\t\t? new SynchronizationCallbackCoordinatorTrackingImpl( this )\n\t\t\t\t\t: new SynchronizationCallbackCoordinatorNonTrackingImpl( this );\n\t\t}\n\t\treturn callbackCoordinator;\n\t}\n\n\t@Override\n\tpublic void pulse() {\n\t\tif ( autoJoinTransactions && !synchronizationRegistered ) {\n\t\t\t// Can we register a synchronization according to the JtaPlatform?\n\t\t\tif ( !jtaPlatform.canRegisterSynchronization() ) {\n\t\t\t\tlog.trace( \"JTA platform says we cannot currently register synchronization; skipping\" );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tjoinJtaTransaction();\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Join to the JTA transaction.  Note that the underlying meaning of joining in JTA environments is to register the\n\t * RegisteredSynchronization with the JTA system\n\t */\n\tprivate void joinJtaTransaction() {\n\t\tif ( !synchronizationRegistered ) {\n\t\t\tjtaPlatform.registerSynchronization(\n\t\t\t\t\tnew RegisteredSynchronization( getSynchronizationCallbackCoordinator() ) );\n\t\t\tgetSynchronizationCallbackCoordinator().synchronizationRegistered();\n\t\t\tsynchronizationRegistered = true;\n\t\t\tlog.debug( \"Hibernate RegisteredSynchronization successfully registered with JTA platform\" );\n\t\t\t// report entering into a \"transactional context\"\n\t\t\tgetTransactionCoordinatorOwner().startTransactionBoundary();\n\t\t}\n\t}\n\n\t@Override\n\tpublic void explicitJoin() {\n\t\tif ( synchronizationRegistered ) {\n\t\t\tlog.debug( \"JTA transaction was already joined (RegisteredSynchronization already registered)\" );\n\t\t}\n\t\telse {\n\t\t\tif ( getTransactionDriverControl().getStatus() != ACTIVE ) {\n\t\t\t\tthrow new TransactionRequiredForJoinException(\n\t\t\t\t\t\t\"Explicitly joining a JTA transaction requires a JTA transaction be currently active\"\n\t\t\t\t);\n\t\t\t}\n\t\t\tjoinJtaTransaction();\n\t\t}\n\t}\n\n\t@Override\n\tpublic boolean isJoined() {\n\t\treturn synchronizationRegistered;\n\t}\n\n\t/**\n\t * Is the RegisteredSynchronization used by Hibernate for unified JTA Synchronization callbacks registered for this\n\t * coordinator?\n\t *\n\t * @return {@code true} indicates that a RegisteredSynchronization is currently registered for this coordinator;\n\t * {@code false} indicates it is not (yet) registered.\n\t */\n\tpublic boolean isSynchronizationRegistered() {\n\t\treturn synchronizationRegistered;\n\t}\n\n\tpublic TransactionCoordinatorOwner getTransactionCoordinatorOwner(){\n\t\treturn transactionCoordinatorOwner;\n\t}\n\n\t@Override\n\tpublic JpaCompliance getJpaCompliance() {\n\t\treturn transactionCoordinatorOwner.getJdbcSessionOwner().getJdbcSessionContext().getJpaCompliance();\n\t}\n\n\t@Override\n\tpublic TransactionDriver getTransactionDriverControl() {\n\t\tif ( physicalTransactionDelegate == null ) {\n\t\t\tphysicalTransactionDelegate = makePhysicalTransactionDelegate();\n\t\t}\n\t\treturn physicalTransactionDelegate;\n\t}\n\n\tprivate TransactionDriverControlImpl makePhysicalTransactionDelegate() {\n\t\tfinal JtaTransactionAdapter adapter =\n\t\t\t\tpreferUserTransactions\n\t\t\t\t\t\t? getTransactionAdapterPreferringUserTransaction()\n\t\t\t\t\t\t: getTransactionAdapterPreferringTransactionManager();\n\t\tif ( adapter == null ) {\n\t\t\tthrow new JtaPlatformInaccessibleException(\n\t\t\t\t\t\"Unable to access TransactionManager or UserTransaction to make physical transaction delegate\"\n\t\t\t);\n\t\t}\n\t\telse {\n\t\t\treturn new TransactionDriverControlImpl( adapter );\n\t\t}\n\t}\n\n\tprivate JtaTransactionAdapter getTransactionAdapterPreferringTransactionManager() {\n\t\tfinal JtaTransactionAdapter adapter = makeTransactionManagerAdapter();\n\t\tif ( adapter == null ) {\n\t\t\tlog.debug( \"Unable to access TransactionManager, attempting to use UserTransaction instead\" );\n\t\t\treturn makeUserTransactionAdapter();\n\t\t}\n\t\treturn adapter;\n\t}\n\n\tprivate JtaTransactionAdapter getTransactionAdapterPreferringUserTransaction() {\n\t\tfinal JtaTransactionAdapter adapter = makeUserTransactionAdapter();\n\t\tif ( adapter == null ) {\n\t\t\tlog.debug( \"Unable to access UserTransaction, attempting to use TransactionManager instead\" );\n\t\t\treturn makeTransactionManagerAdapter();\n\t\t}\n\t\treturn adapter;\n\t}\n\n\tprivate JtaTransactionAdapter makeUserTransactionAdapter() {\n\t\ttry {\n\t\t\tfinal UserTransaction userTransaction = jtaPlatform.retrieveUserTransaction();\n\t\t\tif ( userTransaction == null ) {\n\t\t\t\tlog.debug( \"JtaPlatform#retrieveUserTransaction returned null\" );\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn new JtaTransactionAdapterUserTransactionImpl( userTransaction );\n\t\t\t}\n\t\t}\n\t\tcatch ( Exception exception ) {\n\t\t\tlog.debugf( \"JtaPlatform#retrieveUserTransaction threw an exception [%s]\", exception.getMessage() );\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tprivate JtaTransactionAdapter makeTransactionManagerAdapter() {\n\t\ttry {\n\t\t\tfinal TransactionManager transactionManager = jtaPlatform.retrieveTransactionManager();\n\t\t\tif ( transactionManager == null ) {\n\t\t\t\tlog.debug( \"JtaPlatform#retrieveTransactionManager returned null\" );\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn new JtaTransactionAdapterTransactionManagerImpl( transactionManager );\n\t\t\t}\n\t\t}\n\t\tcatch ( Exception exception ) {\n\t\t\tlog.debugf( \"JtaPlatform#retrieveTransactionManager threw an exception [%s]\", exception.getMessage() );\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t@Override\n\tpublic SynchronizationRegistry getLocalSynchronizations() {\n\t\treturn synchronizationRegistry;\n\t}\n\n\t@Override\n\tpublic boolean isActive() {\n\t\treturn transactionCoordinatorOwner.isActive();\n\t}\n\n\tpublic boolean isJtaTransactionCurrentlyActive() {\n\t\treturn getTransactionDriverControl().getStatus() == ACTIVE;\n\t}\n\n\t@Override\n\tpublic IsolationDelegate createIsolationDelegate() {\n\t\treturn new JtaIsolationDelegate( transactionCoordinatorOwner, jtaPlatform.retrieveTransactionManager() );\n\t}\n\n\t@Override\n\tpublic TransactionCoordinatorBuilder getTransactionCoordinatorBuilder() {\n\t\treturn transactionCoordinatorBuilder;\n\t}\n\n\t@Override\n\tpublic void setTimeOut(int seconds) {\n\t\tthis.timeOut = seconds;\n\t\tphysicalTransactionDelegate.jtaTransactionAdapter.setTimeOut( seconds );\n\t}\n\n\t@Override\n\tpublic int getTimeOut() {\n\t\treturn timeOut;\n\t}\n\n\t@Override\n\tpublic void invalidate() {\n\t\tif ( physicalTransactionDelegate != null ) {\n\t\t\tphysicalTransactionDelegate.invalidate();\n\t\t}\n\t\tphysicalTransactionDelegate = null;\n\t}\n\n\t// SynchronizationCallbackTarget ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n\t@Override\n\tpublic void beforeCompletion() {\n\t\ttry {\n\t\t\ttransactionCoordinatorOwner.beforeTransactionCompletion();\n\t\t}\n\t\tcatch ( Exception e ) {\n\t\t\tphysicalTransactionDelegate.markRollbackOnly();\n\t\t\tthrow e;\n\t\t}\n\t\tfinally {\n\t\t\tsynchronizationRegistry.notifySynchronizationsBeforeTransactionCompletion();\n\t\t\tfor ( TransactionObserver observer : observers() ) {\n\t\t\t\tobserver.beforeCompletion();\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic void afterCompletion(boolean successful, boolean delayed) {\n\t\tif ( !transactionCoordinatorOwner.isActive() ) {\n\t\t\treturn;\n\t\t}\n\n\t\tfinal int statusToSend =  successful ? Status.STATUS_COMMITTED : Status.STATUS_UNKNOWN;\n\t\tsynchronizationRegistry.notifySynchronizationsAfterTransactionCompletion( statusToSend );\n\n//\t\tafterCompletionAction.doAction( this, statusToSend );\n\n\t\ttransactionCoordinatorOwner.afterTransactionCompletion( successful, delayed );\n\n\t\tfor ( TransactionObserver observer : observers() ) {\n\t\t\tobserver.afterCompletion( successful, delayed );\n\t\t}\n\n\t\tsynchronizationRegistered = false;\n\t}\n\n\tpublic void addObserver(TransactionObserver observer) {\n\t\tif ( observers == null ) {\n\t\t\tobservers = new ArrayList<>( 3 ); //These lists are typically very small.\n\t\t}\n\t\tobservers.add( observer );\n\t}\n\n\t@Override\n\tpublic void removeObserver(TransactionObserver observer) {\n\t\tif ( observers != null ) {\n\t\t\tobservers.remove( observer );\n\t\t}\n\t}\n\n\t/**\n\t * Implementation of the LocalInflow for this TransactionCoordinator.  Allows the\n\t * local transaction ({@link org.hibernate.Transaction} to callback into this\n\t * TransactionCoordinator for the purpose of driving the underlying JTA transaction.\n\t */\n\tpublic class TransactionDriverControlImpl implements TransactionDriver {\n\t\tprivate final JtaTransactionAdapter jtaTransactionAdapter;\n\t\tprivate boolean invalid;\n\n\t\tpublic TransactionDriverControlImpl(JtaTransactionAdapter jtaTransactionAdapter) {\n\t\t\tthis.jtaTransactionAdapter = jtaTransactionAdapter;\n\t\t}\n\n\t\tprotected void invalidate() {\n\t\t\tinvalid = true;\n\t\t}\n\n\t\t@Override\n\t\tpublic void begin() {\n\t\t\terrorIfInvalid();\n\t\t\tjtaTransactionAdapter.begin();\n\t\t\tJtaTransactionCoordinatorImpl.this.joinJtaTransaction();\n\t\t}\n\n\t\tprotected void errorIfInvalid() {\n\t\t\tif ( invalid ) {\n\t\t\t\tthrow new IllegalStateException( \"Physical-transaction delegate is no longer valid\" );\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic void commit() {\n\t\t\terrorIfInvalid();\n\t\t\tgetTransactionCoordinatorOwner().flushBeforeTransactionCompletion();\n\t\t\t// we don't have to perform any before/after completion processing here.  We leave that for\n\t\t\t// the Synchronization callbacks\n\t\t\tjtaTransactionAdapter.commit();\n\t\t}\n\n\t\t@Override\n\t\tpublic void rollback() {\n\t\t\terrorIfInvalid();\n\t\t\t// we don't have to perform any after completion processing here.  We leave that for\n\t\t\t// the Synchronization callbacks\n\t\t\tjtaTransactionAdapter.rollback();\n\t\t}\n\n\t\t@Override\n\t\tpublic TransactionStatus getStatus() {\n\t\t\treturn jtaTransactionAdapter.getStatus();\n\t\t}\n\n\t\t@Override\n\t\tpublic void markRollbackOnly() {\n\t\t\tif ( jtaTransactionAdapter.getStatus() != NOT_ACTIVE  ) {\n\t\t\t\tjtaTransactionAdapter.markRollbackOnly();\n\t\t\t}\n\t\t}\n\t}\n\n}\n",
        "diffSourceCodeSet": [
            "private JtaTransactionAdapter getTransactionAdapterPreferringTransactionManager() {\n\t\tfinal JtaTransactionAdapter adapter = makeTransactionManagerAdapter();\n\t\tif ( adapter == null ) {\n\t\t\tlog.debug( \"Unable to access TransactionManager, attempting to use UserTransaction instead\" );\n\t\t\treturn makeUserTransactionAdapter();\n\t\t}\n\t\treturn adapter;\n\t}"
        ],
        "invokedMethodSet": [
            "methodSignature: org.hibernate.resource.transaction.backend.jta.internal.JtaTransactionCoordinatorImpl#makeTransactionManagerAdapter\n methodBody: private JtaTransactionAdapter makeTransactionManagerAdapter() {\ntryfinal TransactionManager transactionManager=jtaPlatform.retrieveTransactionManager();\nif(transactionManager == null){log.debug(\"JtaPlatform#retrieveTransactionManager returned null\");\n}{return new JtaTransactionAdapterTransactionManagerImpl(transactionManager);\n}catch(Exception exception)log.debugf(\"JtaPlatform#retrieveTransactionManager threw an exception [%s]\",exception.getMessage());\nreturn null;\n}",
            "methodSignature: org.hibernate.resource.transaction.backend.jta.internal.JtaTransactionCoordinatorImpl#makeUserTransactionAdapter\n methodBody: private JtaTransactionAdapter makeUserTransactionAdapter() {\ntryfinal UserTransaction userTransaction=jtaPlatform.retrieveUserTransaction();\nif(userTransaction == null){log.debug(\"JtaPlatform#retrieveUserTransaction returned null\");\n}{return new JtaTransactionAdapterUserTransactionImpl(userTransaction);\n}catch(Exception exception)log.debugf(\"JtaPlatform#retrieveUserTransaction threw an exception [%s]\",exception.getMessage());\nreturn null;\n}"
        ],
        "sourceCodeAfterRefactoring": "private TransactionDriverControlImpl makePhysicalTransactionDelegate() {\n\t\tfinal JtaTransactionAdapter adapter =\n\t\t\t\tpreferUserTransactions\n\t\t\t\t\t\t? getTransactionAdapterPreferringUserTransaction()\n\t\t\t\t\t\t: getTransactionAdapterPreferringTransactionManager();\n\t\tif ( adapter == null ) {\n\t\t\tthrow new JtaPlatformInaccessibleException(\n\t\t\t\t\t\"Unable to access TransactionManager or UserTransaction to make physical transaction delegate\"\n\t\t\t);\n\t\t}\n\t\telse {\n\t\t\treturn new TransactionDriverControlImpl( adapter );\n\t\t}\n\t}\nprivate JtaTransactionAdapter getTransactionAdapterPreferringTransactionManager() {\n\t\tfinal JtaTransactionAdapter adapter = makeTransactionManagerAdapter();\n\t\tif ( adapter == null ) {\n\t\t\tlog.debug( \"Unable to access TransactionManager, attempting to use UserTransaction instead\" );\n\t\t\treturn makeUserTransactionAdapter();\n\t\t}\n\t\treturn adapter;\n\t}",
        "diffSourceCode": "-  214: \n-  215: \t@Override\n-  216: \tpublic TransactionDriver getTransactionDriverControl() {\n-  217: \t\tif ( physicalTransactionDelegate == null ) {\n-  218: \t\t\tphysicalTransactionDelegate = makePhysicalTransactionDelegate();\n-  219: \t\t}\n-  220: \t\treturn physicalTransactionDelegate;\n-  221: \t}\n-  222: \n-  223: \tprivate TransactionDriverControlImpl makePhysicalTransactionDelegate() {\n-  224: \t\tJtaTransactionAdapter adapter;\n-  225: \n-  226: \t\tif ( preferUserTransactions ) {\n-  227: \t\t\tadapter = makeUserTransactionAdapter();\n+  214: \tprivate TransactionDriverControlImpl makePhysicalTransactionDelegate() {\n+  215: \t\tfinal JtaTransactionAdapter adapter =\n+  216: \t\t\t\tpreferUserTransactions\n+  217: \t\t\t\t\t\t? getTransactionAdapterPreferringUserTransaction()\n+  218: \t\t\t\t\t\t: getTransactionAdapterPreferringTransactionManager();\n+  219: \t\tif ( adapter == null ) {\n+  220: \t\t\tthrow new JtaPlatformInaccessibleException(\n+  221: \t\t\t\t\t\"Unable to access TransactionManager or UserTransaction to make physical transaction delegate\"\n+  222: \t\t\t);\n+  223: \t\t}\n+  224: \t\telse {\n+  225: \t\t\treturn new TransactionDriverControlImpl( adapter );\n+  226: \t\t}\n+  227: \t}\n   228: \n-  229: \t\t\tif ( adapter == null ) {\n-  230: \t\t\t\tlog.debug( \"Unable to access UserTransaction, attempting to use TransactionManager instead\" );\n-  231: \t\t\t\tadapter = makeTransactionManagerAdapter();\n-  232: \t\t\t}\n-  233: \t\t}\n-  234: \t\telse {\n-  235: \t\t\tadapter = makeTransactionManagerAdapter();\n-  236: \n-  237: \t\t\tif ( adapter == null ) {\n-  238: \t\t\t\tlog.debug( \"Unable to access TransactionManager, attempting to use UserTransaction instead\" );\n-  239: \t\t\t\tadapter = makeUserTransactionAdapter();\n-  240: \t\t\t}\n-  241: \t\t}\n-  242: \n-  243: \t\tif ( adapter == null ) {\n-  244: \t\t\tthrow new JtaPlatformInaccessibleException(\n-  245: \t\t\t\t\t\"Unable to access TransactionManager or UserTransaction to make physical transaction delegate\"\n-  246: \t\t\t);\n-  247: \t\t}\n-  248: \n-  249: \t\treturn new TransactionDriverControlImpl( adapter );\n-  250: \t}\n+  229: \tprivate JtaTransactionAdapter getTransactionAdapterPreferringTransactionManager() {\n+  230: \t\tfinal JtaTransactionAdapter adapter = makeTransactionManagerAdapter();\n+  231: \t\tif ( adapter == null ) {\n+  232: \t\t\tlog.debug( \"Unable to access TransactionManager, attempting to use UserTransaction instead\" );\n+  233: \t\t\treturn makeUserTransactionAdapter();\n+  234: \t\t}\n+  235: \t\treturn adapter;\n+  236: \t}\n+  237: \n+  238: \tprivate JtaTransactionAdapter getTransactionAdapterPreferringUserTransaction() {\n+  239: \t\tfinal JtaTransactionAdapter adapter = makeUserTransactionAdapter();\n+  240: \t\tif ( adapter == null ) {\n+  241: \t\t\tlog.debug( \"Unable to access UserTransaction, attempting to use TransactionManager instead\" );\n+  242: \t\t\treturn makeTransactionManagerAdapter();\n+  243: \t\t}\n+  244: \t\treturn adapter;\n+  245: \t}\n+  246: \n+  247: \tprivate JtaTransactionAdapter makeUserTransactionAdapter() {\n+  248: \t\ttry {\n+  249: \t\t\tfinal UserTransaction userTransaction = jtaPlatform.retrieveUserTransaction();\n+  250: \t\t\tif ( userTransaction == null ) {\n",
        "uniqueId": "453f0ff0749136eac008f9c16fb7742de7ccbadb_223_250_229_236_214_227",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 7,
                "covered": 32
            },
            "BRANCH": {
                "missed": 1,
                "covered": 7
            },
            "LINE": {
                "missed": 2,
                "covered": 10
            },
            "COMPLEXITY": {
                "missed": 1,
                "covered": 4
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 21
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tpublic generatedBeforeExecution(entity Object, session SharedSessionContractImplementor) : boolean extracted from public generatedOnExecution(owner Object, session SharedSessionContractImplementor) : boolean in class org.hibernate.orm.test.idgen.userdefined.MixedTimingGeneratorsTest.IdentityOrRandomGenerator",
        "diffLocations": [
            {
                "filePath": "hibernate-core/src/test/java/org/hibernate/orm/test/idgen/userdefined/MixedTimingGeneratorsTest.java",
                "startLine": 308,
                "endLine": 311,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/test/java/org/hibernate/orm/test/idgen/userdefined/MixedTimingGeneratorsTest.java",
                "startLine": 308,
                "endLine": 311,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/test/java/org/hibernate/orm/test/idgen/userdefined/MixedTimingGeneratorsTest.java",
                "startLine": 313,
                "endLine": 316,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "@Override\n\t\tpublic boolean generatedOnExecution(Object owner, SharedSessionContractImplementor session) {\n\t\t\treturn !( (RandomEntity) owner ).getName().contains( \"random\" );\n\t\t}",
        "filePathBefore": "hibernate-core/src/test/java/org/hibernate/orm/test/idgen/userdefined/MixedTimingGeneratorsTest.java",
        "isPureRefactoring": true,
        "commitId": "cf0ab77cf2b26ca65db7b538233cab2ba1cbe4d7",
        "packageNameBefore": "org.hibernate.orm.test.idgen.userdefined.MixedTimingGeneratorsTest",
        "classNameBefore": "org.hibernate.orm.test.idgen.userdefined.MixedTimingGeneratorsTest.IdentityOrRandomGenerator",
        "methodNameBefore": "org.hibernate.orm.test.idgen.userdefined.MixedTimingGeneratorsTest.IdentityOrRandomGenerator#generatedOnExecution",
        "invokedMethod": "methodSignature: org.hibernate.orm.test.idgen.userdefined.MixedTimingGeneratorsTest.RandomEntity#getName\n methodBody: public String getName() {\nreturn name;\n}\nmethodSignature: org.hibernate.orm.test.idgen.userdefined.MixedTimingGeneratorsTest.StringGeneratedEntity#getName\n methodBody: public String getName() {\nreturn name;\n}",
        "classSignatureBefore": "public static class IdentityOrRandomGenerator extends IdentityGenerator implements BeforeExecutionGenerator ",
        "methodNameBeforeSet": [
            "org.hibernate.orm.test.idgen.userdefined.MixedTimingGeneratorsTest.IdentityOrRandomGenerator#generatedOnExecution"
        ],
        "classNameBeforeSet": [
            "org.hibernate.orm.test.idgen.userdefined.MixedTimingGeneratorsTest.IdentityOrRandomGenerator"
        ],
        "classSignatureBeforeSet": [
            "public static class IdentityOrRandomGenerator extends IdentityGenerator implements BeforeExecutionGenerator "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Tolerable changes in the body\n",
                "description": "All replacements have been justified - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * SPDX-License-Identifier: LGPL-2.1-or-later\n * Copyright Red Hat Inc. and Hibernate Authors\n */\npackage org.hibernate.orm.test.idgen.userdefined;\n\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.Target;\nimport java.util.EnumSet;\nimport java.util.Properties;\nimport java.util.concurrent.ThreadLocalRandom;\n\nimport org.hibernate.annotations.GenericGenerator;\nimport org.hibernate.annotations.SourceType;\nimport org.hibernate.annotations.ValueGenerationType;\nimport org.hibernate.dialect.Dialect;\nimport org.hibernate.dialect.OracleDialect;\nimport org.hibernate.dialect.SQLServerDialect;\nimport org.hibernate.dialect.SybaseASEDialect;\nimport org.hibernate.engine.spi.SharedSessionContractImplementor;\nimport org.hibernate.generator.BeforeExecutionGenerator;\nimport org.hibernate.generator.EventType;\nimport org.hibernate.generator.EventTypeSets;\nimport org.hibernate.generator.OnExecutionGenerator;\nimport org.hibernate.id.IdentifierGenerator;\nimport org.hibernate.id.IdentityGenerator;\nimport org.hibernate.persister.entity.EntityPersister;\nimport org.hibernate.service.ServiceRegistry;\nimport org.hibernate.type.Type;\n\nimport org.hibernate.testing.orm.junit.DialectFeatureChecks;\nimport org.hibernate.testing.orm.junit.DomainModel;\nimport org.hibernate.testing.orm.junit.Jira;\nimport org.hibernate.testing.orm.junit.RequiresDialectFeature;\nimport org.hibernate.testing.orm.junit.SessionFactory;\nimport org.hibernate.testing.orm.junit.SessionFactoryScope;\nimport org.hibernate.testing.orm.junit.SkipForDialect;\nimport org.junit.jupiter.api.Test;\n\nimport jakarta.persistence.Entity;\nimport jakarta.persistence.GeneratedValue;\nimport jakarta.persistence.Id;\n\nimport static java.lang.annotation.ElementType.FIELD;\nimport static java.lang.annotation.ElementType.METHOD;\nimport static java.lang.annotation.RetentionPolicy.RUNTIME;\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.hibernate.generator.EventTypeSets.INSERT_ONLY;\n\n/**\n * @author Marco Belladelli\n */\n@DomainModel( annotatedClasses = {\n\t\tMixedTimingGeneratorsTest.AssignedEntity.class,\n\t\tMixedTimingGeneratorsTest.RandomEntity.class,\n\t\tMixedTimingGeneratorsTest.StringGeneratedEntity.class,\n} )\n@SessionFactory\n@RequiresDialectFeature( feature = DialectFeatureChecks.SupportsIdentityColumns.class )\n@Jira( \"https://hibernate.atlassian.net/browse/HHH-17322\" )\npublic class MixedTimingGeneratorsTest {\n\t@Test\n\t@SkipForDialect( dialectClass = SQLServerDialect.class, reason = \"SQLServer does not support setting explicit values for identity columns\" )\n\t@SkipForDialect( dialectClass = OracleDialect.class, reason = \"Oracle does not support setting explicit values for identity columns\" )\n\t@SkipForDialect( dialectClass = SybaseASEDialect.class, reason = \"Sybase does not support setting explicit values for identity columns\" )\n\tpublic void testIdentityOrAssignedId(SessionFactoryScope scope) {\n\t\t// on execution generation\n\t\tscope.inTransaction( session -> session.persist( new AssignedEntity( \"identity\" ) ) );\n\t\tscope.inSession( session -> assertThat( session.createQuery(\n\t\t\t\t\"from AssignedEntity where name = :name\",\n\t\t\t\tAssignedEntity.class\n\t\t).setParameter( \"name\", \"identity\" ).getSingleResult().getId() ).isNotEqualTo( 42L ) );\n\t\t// before execution generation\n\t\tscope.inTransaction( session -> session.persist( new AssignedEntity( 42L, \"assigned\" ) ) );\n\t\tscope.inSession( session -> assertThat( session.createQuery(\n\t\t\t\t\"from AssignedEntity where name = :name\",\n\t\t\t\tAssignedEntity.class\n\t\t).setParameter( \"name\", \"assigned\" ).getSingleResult().getId() ).isEqualTo( 42L ) );\n\t}\n\n\t@Test\n\t@SkipForDialect( dialectClass = SQLServerDialect.class, reason = \"SQLServer does not support setting explicit values for identity columns\" )\n\t@SkipForDialect( dialectClass = OracleDialect.class, reason = \"Oracle does not support setting explicit values for identity columns\" )\n\t@SkipForDialect( dialectClass = SybaseASEDialect.class, reason = \"Sybase does not support setting explicit values for identity columns\" )\n\tpublic void testIdentityOrAssignedIdStateless(SessionFactoryScope scope) {\n\t\t// on execution generation\n\t\tscope.inStatelessTransaction( session -> session.insert( new AssignedEntity( \"stateless_identity\" ) ) );\n\t\tscope.inStatelessSession( session -> assertThat( session.createQuery(\n\t\t\t\t\"from AssignedEntity where name = :name\",\n\t\t\t\tAssignedEntity.class\n\t\t).setParameter( \"name\", \"stateless_identity\" ).getSingleResult().getId() ).isNotEqualTo( 23L ) );\n\t\t// before execution generation\n\t\tscope.inStatelessTransaction( session -> session.insert( new AssignedEntity( 23L, \"stateless_assigned\" ) ) );\n\t\tscope.inStatelessSession( session -> assertThat( session.createQuery(\n\t\t\t\t\"from AssignedEntity where name = :name\",\n\t\t\t\tAssignedEntity.class\n\t\t).setParameter( \"name\", \"stateless_assigned\" ).getSingleResult().getId() ).isEqualTo( 23L ) );\n\t}\n\n\t@Test\n\t@SkipForDialect( dialectClass = SQLServerDialect.class, reason = \"SQLServer does not support setting explicit values for identity columns\" )\n\t@SkipForDialect( dialectClass = OracleDialect.class, reason = \"Oracle does not support setting explicit values for identity columns\" )\n\t@SkipForDialect( dialectClass = SybaseASEDialect.class, reason = \"Sybase does not support setting explicit values for identity columns\" )\n\tpublic void testIdentityOrRandomId(SessionFactoryScope scope) {\n\t\t// on execution generation\n\t\tscope.inTransaction( session -> session.persist( new RandomEntity( \"identity\" ) ) );\n\t\tscope.inSession( session -> assertThat( session.createQuery(\n\t\t\t\t\"from RandomEntity where name = :name\",\n\t\t\t\tRandomEntity.class\n\t\t).setParameter( \"name\", \"identity\" ).getSingleResult().getId() ).isLessThan( 100L ) );\n\t\t// before execution generation\n\t\tscope.inTransaction( session -> session.persist( new RandomEntity( \"random\" ) ) );\n\t\tscope.inSession( session -> assertThat( session.createQuery(\n\t\t\t\t\"from RandomEntity where name = :name\",\n\t\t\t\tRandomEntity.class\n\t\t).setParameter( \"name\", \"random\" ).getSingleResult().getId() ).isGreaterThanOrEqualTo( 100L ) );\n\t}\n\n\t@Test\n\tpublic void testGeneratedPropInsert(SessionFactoryScope scope) {\n\t\t// on execution generation\n\t\tscope.inTransaction( session -> session.persist( new StringGeneratedEntity( 1L, \"literal\" ) ) );\n\t\tscope.inSession( session -> assertThat(\n\t\t\t\tsession.find( StringGeneratedEntity.class, 1L ).getGeneratedProp()\n\t\t).startsWith( \"literal\" ) );\n\t\t// before execution generation\n\t\tscope.inTransaction( session -> session.persist( new StringGeneratedEntity( 2L, \"generated\" ) ) );\n\t\tscope.inSession( session -> assertThat(\n\t\t\t\tsession.find( StringGeneratedEntity.class, 2L ).getGeneratedProp()\n\t\t).startsWith( \"generated\" ) );\n\t}\n\n\t@Test\n\tpublic void testGeneratedPropUpdate(SessionFactoryScope scope) {\n\t\t// on execution generation\n\t\tfinal int literalCount = scope.fromTransaction( session -> {\n\t\t\tfinal StringGeneratedEntity entity = new StringGeneratedEntity( 3L, \"literal_inserted\" );\n\t\t\tsession.persist( entity );\n\t\t\tsession.flush();\n\t\t\tassertThat( entity.getGeneratedProp() ).startsWith( \"literal\" );\n\t\t\tentity.setName( \"literal_updated\" );\n\t\t\treturn Integer.parseInt( entity.getGeneratedProp().split( \"_\" )[1] );\n\t\t} );\n\t\tscope.inSession( session -> {\n\t\t\tfinal StringGeneratedEntity entity = session.find( StringGeneratedEntity.class, 3L );\n\t\t\tfinal String generatedProp = entity.getGeneratedProp();\n\t\t\tassertThat( generatedProp ).startsWith( \"literal\" );\n\t\t\tassertThat( Integer.parseInt( generatedProp.split( \"_\" )[1] ) ).isGreaterThan( literalCount );\n\t\t} );\n\t\t// before execution generation\n\t\tfinal int generatedCount = scope.fromTransaction( session -> {\n\t\t\tfinal StringGeneratedEntity entity = new StringGeneratedEntity( 4L, \"generated_inserted\" );\n\t\t\tsession.persist( entity );\n\t\t\tsession.flush();\n\t\t\tassertThat( entity.getGeneratedProp() ).startsWith( \"generated\" );\n\t\t\tentity.setName( \"generated_updated\" );\n\t\t\treturn Integer.parseInt( entity.getGeneratedProp().split( \"_\" )[1] );\n\t\t} );\n\t\tscope.inSession( session -> {\n\t\t\tfinal StringGeneratedEntity entity = session.find( StringGeneratedEntity.class, 4L );\n\t\t\tfinal String generatedProp = entity.getGeneratedProp();\n\t\t\tassertThat( generatedProp ).startsWith( \"generated\" );\n\t\t\tassertThat( Integer.parseInt( generatedProp.split( \"_\" )[1] ) ).isGreaterThan( generatedCount );\n\t\t} );\n\t}\n\n\t@Entity( name = \"AssignedEntity\" )\n\tpublic static class AssignedEntity {\n\t\t@Id\n\t\t@GeneratedValue( generator = \"identity_or_assigned\" )\n\t\t@GenericGenerator( name = \"identity_or_assigned\", type = IdentityOrAssignedGenerator.class )\n\t\tprivate Long id;\n\n\t\tprivate String name;\n\n\t\tpublic AssignedEntity() {\n\t\t}\n\n\t\tpublic AssignedEntity(String name) {\n\t\t\tthis.name = name;\n\t\t}\n\n\t\tpublic AssignedEntity(Long id, String name) {\n\t\t\tthis.id = id;\n\t\t\tthis.name = name;\n\t\t}\n\n\t\tpublic Long getId() {\n\t\t\treturn id;\n\t\t}\n\t}\n\n\t@Entity( name = \"RandomEntity\" )\n\tpublic static class RandomEntity {\n\t\t@Id\n\t\t@GeneratedValue( generator = \"identity_or_random\" )\n\t\t@GenericGenerator( name = \"identity_or_random\", type = IdentityOrRandomGenerator.class )\n\t\tprivate Long id;\n\n\t\tprivate String name;\n\n\t\tpublic RandomEntity() {\n\t\t}\n\n\t\tpublic RandomEntity(String name) {\n\t\t\tthis.name = name;\n\t\t}\n\n\t\tpublic Long getId() {\n\t\t\treturn id;\n\t\t}\n\n\t\tpublic String getName() {\n\t\t\treturn name;\n\t\t}\n\t}\n\n\t@ValueGenerationType( generatedBy = LiteralOrGeneratedStringGenerator.class )\n\t@Retention( RUNTIME )\n\t@Target( { FIELD, METHOD } )\n\tpublic @interface GeneratedString {\n\t\t/**\n\t\t * Specifies how the timestamp is generated. By default, it is generated\n\t\t * in memory, which saves a round trip to the database.\n\t\t */\n\t\tSourceType source() default SourceType.VM;\n\t}\n\n\n\t@Entity( name = \"StringGeneratedEntity\" )\n\tpublic static class StringGeneratedEntity {\n\t\t@Id\n\t\tprivate Long id;\n\n\t\tprivate String name;\n\n\t\t@GeneratedString\n\t\tprivate String generatedProp;\n\n\t\tpublic StringGeneratedEntity() {\n\t\t}\n\n\t\tpublic StringGeneratedEntity(Long id, String name) {\n\t\t\tthis.id = id;\n\t\t\tthis.name = name;\n\t\t}\n\n\t\tpublic String getName() {\n\t\t\treturn name;\n\t\t}\n\n\t\tpublic void setName(String name) {\n\t\t\tthis.name = name;\n\t\t}\n\n\t\tpublic String getGeneratedProp() {\n\t\t\treturn generatedProp;\n\t\t}\n\t}\n\n\tpublic static class IdentityOrAssignedGenerator extends IdentityGenerator implements IdentifierGenerator {\n\t\t@Override\n\t\tpublic Object generate(SharedSessionContractImplementor session, Object object) {\n\t\t\tfinal EntityPersister entityPersister = session.getEntityPersister( null, object );\n\t\t\treturn entityPersister.getIdentifier( object, session );\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean generatedOnExecution() {\n\t\t\treturn true;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean generatedOnExecution(Object owner, SharedSessionContractImplementor session) {\n\t\t\treturn generate( session, owner, null, null ) == null;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean allowAssignedIdentifiers() {\n\t\t\treturn true;\n\t\t}\n\n\t\t@Override\n\t\tpublic EnumSet<EventType> getEventTypes() {\n\t\t\treturn INSERT_ONLY;\n\t\t}\n\n\t\t@Override\n\t\tpublic void configure(Type type, Properties params, ServiceRegistry serviceRegistry) {\n\t\t}\n\t}\n\n\tpublic static class IdentityOrRandomGenerator extends IdentityGenerator implements BeforeExecutionGenerator {\n\t\t@Override\n\t\tpublic Object generate(\n\t\t\t\tSharedSessionContractImplementor session,\n\t\t\t\tObject owner,\n\t\t\t\tObject currentValue,\n\t\t\t\tEventType eventType) {\n\t\t\treturn ThreadLocalRandom.current().nextLong( 100, 1_000 );\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean generatedOnExecution() {\n\t\t\treturn true;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean generatedOnExecution(Object owner, SharedSessionContractImplementor session) {\n\t\t\treturn !( (RandomEntity) owner ).getName().contains( \"random\" );\n\t\t}\n\t}\n\n\tpublic static class LiteralOrGeneratedStringGenerator implements OnExecutionGenerator, BeforeExecutionGenerator {\n\t\tprivate int count;\n\n\t\tpublic LiteralOrGeneratedStringGenerator() {\n\t\t\tcount = 0;\n\t\t}\n\n\t\t@Override\n\t\tpublic Object generate(\n\t\t\t\tSharedSessionContractImplementor session,\n\t\t\t\tObject owner,\n\t\t\t\tObject currentValue,\n\t\t\t\tEventType eventType) {\n\t\t\treturn \"generated_\" + count++;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean generatedOnExecution() {\n\t\t\treturn true;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean generatedOnExecution(Object owner, SharedSessionContractImplementor session) {\n\t\t\treturn !( (StringGeneratedEntity) owner ).getName().contains( \"generated\" );\n\t\t}\n\n\t\t@Override\n\t\tpublic EnumSet<EventType> getEventTypes() {\n\t\t\treturn EventTypeSets.ALL;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean referenceColumnsInSql(Dialect dialect) {\n\t\t\treturn true;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean writePropertyValue() {\n\t\t\treturn false;\n\t\t}\n\n\t\t@Override\n\t\tpublic String[] getReferencedColumnValues(Dialect dialect) {\n\t\t\treturn new String[] { \"'literal_\" + count++ + \"'\" };\n\t\t}\n\t}\n}\n",
        "filePathAfter": "hibernate-core/src/test/java/org/hibernate/orm/test/idgen/userdefined/MixedTimingGeneratorsTest.java",
        "sourceCodeAfterForWhole": "/*\n * SPDX-License-Identifier: LGPL-2.1-or-later\n * Copyright Red Hat Inc. and Hibernate Authors\n */\npackage org.hibernate.orm.test.idgen.userdefined;\n\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.Target;\nimport java.util.EnumSet;\nimport java.util.Properties;\nimport java.util.concurrent.ThreadLocalRandom;\n\nimport org.hibernate.annotations.GenericGenerator;\nimport org.hibernate.annotations.SourceType;\nimport org.hibernate.annotations.ValueGenerationType;\nimport org.hibernate.dialect.Dialect;\nimport org.hibernate.dialect.OracleDialect;\nimport org.hibernate.dialect.SQLServerDialect;\nimport org.hibernate.dialect.SybaseASEDialect;\nimport org.hibernate.engine.spi.SharedSessionContractImplementor;\nimport org.hibernate.generator.BeforeExecutionGenerator;\nimport org.hibernate.generator.EventType;\nimport org.hibernate.generator.EventTypeSets;\nimport org.hibernate.generator.OnExecutionGenerator;\nimport org.hibernate.id.IdentifierGenerator;\nimport org.hibernate.id.IdentityGenerator;\nimport org.hibernate.persister.entity.EntityPersister;\nimport org.hibernate.service.ServiceRegistry;\nimport org.hibernate.type.Type;\n\nimport org.hibernate.testing.orm.junit.DialectFeatureChecks;\nimport org.hibernate.testing.orm.junit.DomainModel;\nimport org.hibernate.testing.orm.junit.Jira;\nimport org.hibernate.testing.orm.junit.RequiresDialectFeature;\nimport org.hibernate.testing.orm.junit.SessionFactory;\nimport org.hibernate.testing.orm.junit.SessionFactoryScope;\nimport org.hibernate.testing.orm.junit.SkipForDialect;\nimport org.junit.jupiter.api.Test;\n\nimport jakarta.persistence.Entity;\nimport jakarta.persistence.GeneratedValue;\nimport jakarta.persistence.Id;\n\nimport static java.lang.annotation.ElementType.FIELD;\nimport static java.lang.annotation.ElementType.METHOD;\nimport static java.lang.annotation.RetentionPolicy.RUNTIME;\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.hibernate.generator.EventTypeSets.INSERT_ONLY;\n\n/**\n * @author Marco Belladelli\n */\n@DomainModel( annotatedClasses = {\n\t\tMixedTimingGeneratorsTest.AssignedEntity.class,\n\t\tMixedTimingGeneratorsTest.RandomEntity.class,\n\t\tMixedTimingGeneratorsTest.StringGeneratedEntity.class,\n} )\n@SessionFactory\n@RequiresDialectFeature( feature = DialectFeatureChecks.SupportsIdentityColumns.class )\n@Jira( \"https://hibernate.atlassian.net/browse/HHH-17322\" )\npublic class MixedTimingGeneratorsTest {\n\t@Test\n\t@SkipForDialect( dialectClass = SQLServerDialect.class, reason = \"SQLServer does not support setting explicit values for identity columns\" )\n\t@SkipForDialect( dialectClass = OracleDialect.class, reason = \"Oracle does not support setting explicit values for identity columns\" )\n\t@SkipForDialect( dialectClass = SybaseASEDialect.class, reason = \"Sybase does not support setting explicit values for identity columns\" )\n\tpublic void testIdentityOrAssignedId(SessionFactoryScope scope) {\n\t\t// on execution generation\n\t\tscope.inTransaction( session -> session.persist( new AssignedEntity( \"identity\" ) ) );\n\t\tscope.inSession( session -> assertThat( session.createQuery(\n\t\t\t\t\"from AssignedEntity where name = :name\",\n\t\t\t\tAssignedEntity.class\n\t\t).setParameter( \"name\", \"identity\" ).getSingleResult().getId() ).isNotEqualTo( 42L ) );\n\t\t// before execution generation\n\t\tscope.inTransaction( session -> session.persist( new AssignedEntity( 42L, \"assigned\" ) ) );\n\t\tscope.inSession( session -> assertThat( session.createQuery(\n\t\t\t\t\"from AssignedEntity where name = :name\",\n\t\t\t\tAssignedEntity.class\n\t\t).setParameter( \"name\", \"assigned\" ).getSingleResult().getId() ).isEqualTo( 42L ) );\n\t}\n\n\t@Test\n\t@SkipForDialect( dialectClass = SQLServerDialect.class, reason = \"SQLServer does not support setting explicit values for identity columns\" )\n\t@SkipForDialect( dialectClass = OracleDialect.class, reason = \"Oracle does not support setting explicit values for identity columns\" )\n\t@SkipForDialect( dialectClass = SybaseASEDialect.class, reason = \"Sybase does not support setting explicit values for identity columns\" )\n\tpublic void testIdentityOrAssignedIdStateless(SessionFactoryScope scope) {\n\t\t// on execution generation\n\t\tscope.inStatelessTransaction( session -> session.insert( new AssignedEntity( \"stateless_identity\" ) ) );\n\t\tscope.inStatelessSession( session -> assertThat( session.createQuery(\n\t\t\t\t\"from AssignedEntity where name = :name\",\n\t\t\t\tAssignedEntity.class\n\t\t).setParameter( \"name\", \"stateless_identity\" ).getSingleResult().getId() ).isNotEqualTo( 23L ) );\n\t\t// before execution generation\n\t\tscope.inStatelessTransaction( session -> session.insert( new AssignedEntity( 23L, \"stateless_assigned\" ) ) );\n\t\tscope.inStatelessSession( session -> assertThat( session.createQuery(\n\t\t\t\t\"from AssignedEntity where name = :name\",\n\t\t\t\tAssignedEntity.class\n\t\t).setParameter( \"name\", \"stateless_assigned\" ).getSingleResult().getId() ).isEqualTo( 23L ) );\n\t}\n\n\t@Test\n\t@SkipForDialect( dialectClass = SQLServerDialect.class, reason = \"SQLServer does not support setting explicit values for identity columns\" )\n\t@SkipForDialect( dialectClass = OracleDialect.class, reason = \"Oracle does not support setting explicit values for identity columns\" )\n\t@SkipForDialect( dialectClass = SybaseASEDialect.class, reason = \"Sybase does not support setting explicit values for identity columns\" )\n\tpublic void testIdentityOrRandomId(SessionFactoryScope scope) {\n\t\t// on execution generation\n\t\tscope.inTransaction( session -> session.persist( new RandomEntity( \"identity\" ) ) );\n\t\tscope.inSession( session -> assertThat( session.createQuery(\n\t\t\t\t\"from RandomEntity where name = :name\",\n\t\t\t\tRandomEntity.class\n\t\t).setParameter( \"name\", \"identity\" ).getSingleResult().getId() ).isLessThan( 100L ) );\n\t\t// before execution generation\n\t\tscope.inTransaction( session -> session.persist( new RandomEntity( \"random\" ) ) );\n\t\tscope.inSession( session -> assertThat( session.createQuery(\n\t\t\t\t\"from RandomEntity where name = :name\",\n\t\t\t\tRandomEntity.class\n\t\t).setParameter( \"name\", \"random\" ).getSingleResult().getId() ).isGreaterThanOrEqualTo( 100L ) );\n\t}\n\n\t@Test\n\tpublic void testGeneratedPropInsert(SessionFactoryScope scope) {\n\t\t// on execution generation\n\t\tscope.inTransaction( session -> session.persist( new StringGeneratedEntity( 1L, \"literal\" ) ) );\n\t\tscope.inSession( session -> assertThat(\n\t\t\t\tsession.find( StringGeneratedEntity.class, 1L ).getGeneratedProp()\n\t\t).startsWith( \"literal\" ) );\n\t\t// before execution generation\n\t\tscope.inTransaction( session -> session.persist( new StringGeneratedEntity( 2L, \"generated\" ) ) );\n\t\tscope.inSession( session -> assertThat(\n\t\t\t\tsession.find( StringGeneratedEntity.class, 2L ).getGeneratedProp()\n\t\t).startsWith( \"generated\" ) );\n\t}\n\n\t@Test\n\tpublic void testGeneratedPropUpdate(SessionFactoryScope scope) {\n\t\t// on execution generation\n\t\tfinal int literalCount = scope.fromTransaction( session -> {\n\t\t\tfinal StringGeneratedEntity entity = new StringGeneratedEntity( 3L, \"literal_inserted\" );\n\t\t\tsession.persist( entity );\n\t\t\tsession.flush();\n\t\t\tassertThat( entity.getGeneratedProp() ).startsWith( \"literal\" );\n\t\t\tentity.setName( \"literal_updated\" );\n\t\t\treturn Integer.parseInt( entity.getGeneratedProp().split( \"_\" )[1] );\n\t\t} );\n\t\tscope.inSession( session -> {\n\t\t\tfinal StringGeneratedEntity entity = session.find( StringGeneratedEntity.class, 3L );\n\t\t\tfinal String generatedProp = entity.getGeneratedProp();\n\t\t\tassertThat( generatedProp ).startsWith( \"literal\" );\n\t\t\tassertThat( Integer.parseInt( generatedProp.split( \"_\" )[1] ) ).isGreaterThan( literalCount );\n\t\t} );\n\t\t// before execution generation\n\t\tfinal int generatedCount = scope.fromTransaction( session -> {\n\t\t\tfinal StringGeneratedEntity entity = new StringGeneratedEntity( 4L, \"generated_inserted\" );\n\t\t\tsession.persist( entity );\n\t\t\tsession.flush();\n\t\t\tassertThat( entity.getGeneratedProp() ).startsWith( \"generated\" );\n\t\t\tentity.setName( \"generated_updated\" );\n\t\t\treturn Integer.parseInt( entity.getGeneratedProp().split( \"_\" )[1] );\n\t\t} );\n\t\tscope.inSession( session -> {\n\t\t\tfinal StringGeneratedEntity entity = session.find( StringGeneratedEntity.class, 4L );\n\t\t\tfinal String generatedProp = entity.getGeneratedProp();\n\t\t\tassertThat( generatedProp ).startsWith( \"generated\" );\n\t\t\tassertThat( Integer.parseInt( generatedProp.split( \"_\" )[1] ) ).isGreaterThan( generatedCount );\n\t\t} );\n\t}\n\n\t@Entity( name = \"AssignedEntity\" )\n\tpublic static class AssignedEntity {\n\t\t@Id\n\t\t@GeneratedValue( generator = \"identity_or_assigned\" )\n\t\t@GenericGenerator( name = \"identity_or_assigned\", type = IdentityOrAssignedGenerator.class )\n\t\tprivate Long id;\n\n\t\tprivate String name;\n\n\t\tpublic AssignedEntity() {\n\t\t}\n\n\t\tpublic AssignedEntity(String name) {\n\t\t\tthis.name = name;\n\t\t}\n\n\t\tpublic AssignedEntity(Long id, String name) {\n\t\t\tthis.id = id;\n\t\t\tthis.name = name;\n\t\t}\n\n\t\tpublic Long getId() {\n\t\t\treturn id;\n\t\t}\n\t}\n\n\t@Entity( name = \"RandomEntity\" )\n\tpublic static class RandomEntity {\n\t\t@Id\n\t\t@GeneratedValue( generator = \"identity_or_random\" )\n\t\t@GenericGenerator( name = \"identity_or_random\", type = IdentityOrRandomGenerator.class )\n\t\tprivate Long id;\n\n\t\tprivate String name;\n\n\t\tpublic RandomEntity() {\n\t\t}\n\n\t\tpublic RandomEntity(String name) {\n\t\t\tthis.name = name;\n\t\t}\n\n\t\tpublic Long getId() {\n\t\t\treturn id;\n\t\t}\n\n\t\tpublic String getName() {\n\t\t\treturn name;\n\t\t}\n\t}\n\n\t@ValueGenerationType( generatedBy = LiteralOrGeneratedStringGenerator.class )\n\t@Retention( RUNTIME )\n\t@Target( { FIELD, METHOD } )\n\tpublic @interface GeneratedString {\n\t\t/**\n\t\t * Specifies how the timestamp is generated. By default, it is generated\n\t\t * in memory, which saves a round trip to the database.\n\t\t */\n\t\tSourceType source() default SourceType.VM;\n\t}\n\n\n\t@Entity( name = \"StringGeneratedEntity\" )\n\tpublic static class StringGeneratedEntity {\n\t\t@Id\n\t\tprivate Long id;\n\n\t\tprivate String name;\n\n\t\t@GeneratedString\n\t\tprivate String generatedProp;\n\n\t\tpublic StringGeneratedEntity() {\n\t\t}\n\n\t\tpublic StringGeneratedEntity(Long id, String name) {\n\t\t\tthis.id = id;\n\t\t\tthis.name = name;\n\t\t}\n\n\t\tpublic String getName() {\n\t\t\treturn name;\n\t\t}\n\n\t\tpublic void setName(String name) {\n\t\t\tthis.name = name;\n\t\t}\n\n\t\tpublic String getGeneratedProp() {\n\t\t\treturn generatedProp;\n\t\t}\n\t}\n\n\tpublic static class IdentityOrAssignedGenerator extends IdentityGenerator implements IdentifierGenerator {\n\t\t@Override\n\t\tpublic Object generate(SharedSessionContractImplementor session, Object object) {\n\t\t\tfinal EntityPersister entityPersister = session.getEntityPersister( null, object );\n\t\t\treturn entityPersister.getIdentifier( object, session );\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean generatedOnExecution() {\n\t\t\treturn true;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean generatedOnExecution(Object owner, SharedSessionContractImplementor session) {\n\t\t\treturn generate( session, owner, null, null ) == null;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean allowAssignedIdentifiers() {\n\t\t\treturn true;\n\t\t}\n\n\t\t@Override\n\t\tpublic EnumSet<EventType> getEventTypes() {\n\t\t\treturn INSERT_ONLY;\n\t\t}\n\n\t\t@Override\n\t\tpublic void configure(Type type, Properties params, ServiceRegistry serviceRegistry) {\n\t\t}\n\t}\n\n\tpublic static class IdentityOrRandomGenerator extends IdentityGenerator implements BeforeExecutionGenerator {\n\t\t@Override\n\t\tpublic Object generate(\n\t\t\t\tSharedSessionContractImplementor session,\n\t\t\t\tObject owner,\n\t\t\t\tObject currentValue,\n\t\t\t\tEventType eventType) {\n\t\t\treturn ThreadLocalRandom.current().nextLong( 100, 1_000 );\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean generatedOnExecution() {\n\t\t\treturn true;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean generatedOnExecution(Object entity, SharedSessionContractImplementor session) {\n\t\t\treturn !generatedBeforeExecution( entity, session );\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean generatedBeforeExecution(Object entity, SharedSessionContractImplementor session) {\n\t\t\treturn ( (RandomEntity) entity ).getName().contains( \"random\" );\n\t\t}\n\t}\n\n\tpublic static class LiteralOrGeneratedStringGenerator implements OnExecutionGenerator, BeforeExecutionGenerator {\n\t\tprivate int count;\n\n\t\tpublic LiteralOrGeneratedStringGenerator() {\n\t\t\tcount = 0;\n\t\t}\n\n\t\t@Override\n\t\tpublic Object generate(\n\t\t\t\tSharedSessionContractImplementor session,\n\t\t\t\tObject owner,\n\t\t\t\tObject currentValue,\n\t\t\t\tEventType eventType) {\n\t\t\treturn \"generated_\" + count++;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean generatedOnExecution() {\n\t\t\treturn true;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean generatedOnExecution(Object entity, SharedSessionContractImplementor session) {\n\t\t\treturn !generatedBeforeExecution( entity, session );\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean generatedBeforeExecution(Object entity, SharedSessionContractImplementor session) {\n\t\t\treturn ( (StringGeneratedEntity) entity ).getName().contains( \"generated\" );\n\t\t}\n\n\t\t@Override\n\t\tpublic EnumSet<EventType> getEventTypes() {\n\t\t\treturn EventTypeSets.ALL;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean referenceColumnsInSql(Dialect dialect) {\n\t\t\treturn true;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean writePropertyValue() {\n\t\t\treturn false;\n\t\t}\n\n\t\t@Override\n\t\tpublic String[] getReferencedColumnValues(Dialect dialect) {\n\t\t\treturn new String[] { \"'literal_\" + count++ + \"'\" };\n\t\t}\n\t}\n}\n",
        "diffSourceCodeSet": [
            "@Override\n\t\tpublic boolean generatedBeforeExecution(Object entity, SharedSessionContractImplementor session) {\n\t\t\treturn ( (RandomEntity) entity ).getName().contains( \"random\" );\n\t\t}"
        ],
        "invokedMethodSet": [
            "methodSignature: org.hibernate.orm.test.idgen.userdefined.MixedTimingGeneratorsTest.RandomEntity#getName\n methodBody: public String getName() {\nreturn name;\n}",
            "methodSignature: org.hibernate.orm.test.idgen.userdefined.MixedTimingGeneratorsTest.StringGeneratedEntity#getName\n methodBody: public String getName() {\nreturn name;\n}"
        ],
        "sourceCodeAfterRefactoring": "@Override\n\t\tpublic boolean generatedOnExecution(Object entity, SharedSessionContractImplementor session) {\n\t\t\treturn !generatedBeforeExecution( entity, session );\n\t\t}\n@Override\n\t\tpublic boolean generatedBeforeExecution(Object entity, SharedSessionContractImplementor session) {\n\t\t\treturn ( (RandomEntity) entity ).getName().contains( \"random\" );\n\t\t}",
        "diffSourceCode": "   308: \t\t@Override\n-  309: \t\tpublic boolean generatedOnExecution(Object owner, SharedSessionContractImplementor session) {\n-  310: \t\t\treturn !( (RandomEntity) owner ).getName().contains( \"random\" );\n+  309: \t\tpublic boolean generatedOnExecution(Object entity, SharedSessionContractImplementor session) {\n+  310: \t\t\treturn !generatedBeforeExecution( entity, session );\n   311: \t\t}\n-  313: \n-  314: \tpublic static class LiteralOrGeneratedStringGenerator implements OnExecutionGenerator, BeforeExecutionGenerator {\n-  315: \t\tprivate int count;\n-  316: \n+  313: \t\t@Override\n+  314: \t\tpublic boolean generatedBeforeExecution(Object entity, SharedSessionContractImplementor session) {\n+  315: \t\t\treturn ( (RandomEntity) entity ).getName().contains( \"random\" );\n+  316: \t\t}\n",
        "uniqueId": "cf0ab77cf2b26ca65db7b538233cab2ba1cbe4d7_308_311_313_316_308_311",
        "moveFileExist": true,
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 21,
        "testResult": true,
        "coverageInfo": {
            "testMethod": {
                "missed": 0,
                "covered": 1
            }
        }
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprotected createSettings() : Map<String,Object> extracted from private init() : void in class org.hibernate.orm.test.multitenancy.AbstractMultiTenancyTest",
        "diffLocations": [
            {
                "filePath": "hibernate-core/src/test/java/org/hibernate/orm/test/multitenancy/AbstractMultiTenancyTest.java",
                "startLine": 67,
                "endLine": 77,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/test/java/org/hibernate/orm/test/multitenancy/AbstractMultiTenancyTest.java",
                "startLine": 67,
                "endLine": 71,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/test/java/org/hibernate/orm/test/multitenancy/AbstractMultiTenancyTest.java",
                "startLine": 73,
                "endLine": 79,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "private void init() {\n\t\tregisterConnectionProvider(FRONT_END_TENANT);\n\t\tregisterConnectionProvider(BACK_END_TENANT);\n\n\t\tMap<String, Object> settings = new HashMap<>();\n\n\t\tsettings.put(AvailableSettings.MULTI_TENANT_CONNECTION_PROVIDER,\n\t\t\tnew ConfigurableMultiTenantConnectionProvider(connectionProviderMap));\n\n\t\tsessionFactory = sessionFactory(settings);\n\t}",
        "filePathBefore": "hibernate-core/src/test/java/org/hibernate/orm/test/multitenancy/AbstractMultiTenancyTest.java",
        "isPureRefactoring": true,
        "commitId": "7c315fdbfa45019322e2be4701d6555db886ace7",
        "packageNameBefore": "org.hibernate.orm.test.multitenancy",
        "classNameBefore": "org.hibernate.orm.test.multitenancy.AbstractMultiTenancyTest",
        "methodNameBefore": "org.hibernate.orm.test.multitenancy.AbstractMultiTenancyTest#init",
        "invokedMethod": "methodSignature: org.hibernate.orm.test.multitenancy.AbstractMultiTenancyTest#registerConnectionProvider\n methodBody: protected void registerConnectionProvider(String tenantIdentifier) {\nProperties properties=properties();\nproperties.put(Environment.URL,tenantUrl(properties.getProperty(Environment.URL),tenantIdentifier));\nDriverManagerConnectionProviderImpl connectionProvider=new DriverManagerConnectionProviderImpl();\nconnectionProvider.configure(PropertiesHelper.map(properties));\nconnectionProviderMap.put(tenantIdentifier,connectionProvider);\n}\nmethodSignature: org.hibernate.orm.test.multitenancy.AbstractMultiTenancyTest#sessionFactory\n methodBody: protected SessionFactory sessionFactory(Map<String, Object> settings) {\nServiceRegistryImplementor serviceRegistry=(ServiceRegistryImplementor)ServiceRegistryUtil.serviceRegistryBuilder().applySettings(settings).build();\nMetadataSources metadataSources=new MetadataSources(serviceRegistry);\nfor(Class annotatedClasses: getAnnotatedClasses()){metadataSources.addAnnotatedClass(annotatedClasses);\n}Metadata metadata=metadataSources.buildMetadata();\nHibernateSchemaManagementTool tool=new HibernateSchemaManagementTool();\ntool.injectServices(serviceRegistry);\nnew SchemaDropperImpl(serviceRegistry).doDrop(metadata,serviceRegistry,settings,true,new GenerationTargetToDatabase(new DdlTransactionIsolatorTestingImpl(serviceRegistry,connectionProviderMap.get(FRONT_END_TENANT))),new GenerationTargetToDatabase(new DdlTransactionIsolatorTestingImpl(serviceRegistry,connectionProviderMap.get(BACK_END_TENANT))));\nnew SchemaCreatorImpl(serviceRegistry).doCreation(metadata,serviceRegistry,settings,true,new GenerationTargetToDatabase(new DdlTransactionIsolatorTestingImpl(serviceRegistry,connectionProviderMap.get(FRONT_END_TENANT))),new GenerationTargetToDatabase(new DdlTransactionIsolatorTestingImpl(serviceRegistry,connectionProviderMap.get(BACK_END_TENANT))));\nfinal SessionFactoryBuilder sessionFactoryBuilder=metadata.getSessionFactoryBuilder();\nreturn sessionFactoryBuilder.build();\n}",
        "classSignatureBefore": "public abstract class AbstractMultiTenancyTest extends BaseUnitTestCase ",
        "methodNameBeforeSet": [
            "org.hibernate.orm.test.multitenancy.AbstractMultiTenancyTest#init"
        ],
        "classNameBeforeSet": [
            "org.hibernate.orm.test.multitenancy.AbstractMultiTenancyTest"
        ],
        "classSignatureBeforeSet": [
            "public abstract class AbstractMultiTenancyTest extends BaseUnitTestCase "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "",
                "description": "Argument replaced with return expression - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * SPDX-License-Identifier: LGPL-2.1-or-later\n * Copyright Red Hat Inc. and Hibernate Authors\n */\npackage org.hibernate.orm.test.multitenancy;\n\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.net.URL;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Properties;\nimport java.util.function.Consumer;\nimport jakarta.persistence.Entity;\nimport jakarta.persistence.Id;\n\nimport org.hibernate.Session;\nimport org.hibernate.SessionException;\nimport org.hibernate.SessionFactory;\nimport org.hibernate.Transaction;\nimport org.hibernate.boot.Metadata;\nimport org.hibernate.boot.MetadataSources;\nimport org.hibernate.boot.SessionFactoryBuilder;\nimport org.hibernate.cfg.AvailableSettings;\nimport org.hibernate.cfg.Environment;\nimport org.hibernate.engine.jdbc.connections.internal.DriverManagerConnectionProviderImpl;\nimport org.hibernate.engine.jdbc.connections.spi.ConnectionProvider;\nimport org.hibernate.internal.util.PropertiesHelper;\nimport org.hibernate.query.Query;\nimport org.hibernate.service.spi.ServiceRegistryImplementor;\nimport org.hibernate.service.spi.Stoppable;\nimport org.hibernate.tool.schema.internal.HibernateSchemaManagementTool;\nimport org.hibernate.tool.schema.internal.SchemaCreatorImpl;\nimport org.hibernate.tool.schema.internal.SchemaDropperImpl;\nimport org.hibernate.tool.schema.internal.exec.GenerationTargetToDatabase;\n\nimport org.hibernate.testing.AfterClassOnce;\nimport org.hibernate.testing.junit4.BaseUnitTestCase;\nimport org.hibernate.testing.orm.junit.JiraKey;\nimport org.hibernate.testing.util.ServiceRegistryUtil;\n\nimport org.hibernate.orm.test.util.DdlTransactionIsolatorTestingImpl;\n\nimport org.junit.After;\nimport org.junit.Assert;\nimport org.junit.Test;\n\nimport static org.junit.Assert.assertEquals;\n\n/**\n * @author Vlad Mihalcea\n */\npublic abstract class AbstractMultiTenancyTest extends BaseUnitTestCase {\n\n\tprotected static final String FRONT_END_TENANT = \"front_end\";\n\tprotected static final String BACK_END_TENANT = \"back_end\";\n\n\tprivate Map<String, ConnectionProvider> connectionProviderMap = new HashMap<>();\n\n\tprivate SessionFactory sessionFactory;\n\n\tpublic AbstractMultiTenancyTest() {\n\t\tinit();\n\t}\n\n\t//tag::multitenacy-hibernate-MultiTenantConnectionProvider-example[]\n\tprivate void init() {\n\t\tregisterConnectionProvider(FRONT_END_TENANT);\n\t\tregisterConnectionProvider(BACK_END_TENANT);\n\n\t\tMap<String, Object> settings = new HashMap<>();\n\n\t\tsettings.put(AvailableSettings.MULTI_TENANT_CONNECTION_PROVIDER,\n\t\t\tnew ConfigurableMultiTenantConnectionProvider(connectionProviderMap));\n\n\t\tsessionFactory = sessionFactory(settings);\n\t}\n\t//end::multitenacy-hibernate-MultiTenantConnectionProvider-example[]\n\n\t@AfterClassOnce\n\tpublic void destroy() {\n\t\tsessionFactory.close();\n\t\tfor (ConnectionProvider connectionProvider : connectionProviderMap.values()) {\n\t\t\tif (connectionProvider instanceof Stoppable) {\n\t\t\t\t((Stoppable) connectionProvider).stop();\n\t\t\t}\n\t\t}\n\t}\n\n\t@After\n\tpublic void cleanup() {\n\t\tdoInSession(FRONT_END_TENANT, session -> session.createMutationQuery( \"delete from Person\" ).executeUpdate() );\n\t\tdoInSession(BACK_END_TENANT, session -> session.createMutationQuery( \"delete from Person\" ).executeUpdate() );\n\t}\n\n\t//tag::multitenacy-hibernate-MultiTenantConnectionProvider-example[]\n\n\tprotected void registerConnectionProvider(String tenantIdentifier) {\n\t\tProperties properties = properties();\n\t\tproperties.put(Environment.URL,\n\t\t\ttenantUrl(properties.getProperty(Environment.URL), tenantIdentifier));\n\n\t\tDriverManagerConnectionProviderImpl connectionProvider =\n\t\t\tnew DriverManagerConnectionProviderImpl();\n\t\tconnectionProvider.configure( PropertiesHelper.map(properties) );\n\t\tconnectionProviderMap.put(tenantIdentifier, connectionProvider);\n\t}\n\t//end::multitenacy-hibernate-MultiTenantConnectionProvider-example[]\n\n\t@Test\n\tpublic void testBasicExpectedBehavior() {\n\n\t\t//tag::multitenacy-multitenacy-hibernate-same-entity-example[]\n\t\tdoInSession(FRONT_END_TENANT, session -> {\n\t\t\tPerson person = new Person();\n\t\t\tperson.setId(1L);\n\t\t\tperson.setName(\"John Doe\");\n\t\t\tsession.persist(person);\n\t\t});\n\n\t\tdoInSession(BACK_END_TENANT, session -> {\n\t\t\tPerson person = new Person();\n\t\t\tperson.setId(1L);\n\t\t\tperson.setName(\"John Doe\");\n\t\t\tsession.persist(person);\n\t\t});\n\t\t//end::multitenacy-multitenacy-hibernate-same-entity-example[]\n\t}\n\n\t@Test\n\t@JiraKey( value = \"HHH-17972\")\n\tpublic void testChangeTenantWithoutConnectionReuse() {\n\t\tPerson person = new Person();\n\t\tperson.setId( 1L );\n\t\tperson.setName( \"John Doe\" );\n\t\tPerson person2 = new Person();\n\t\tperson2.setId( 2L );\n\t\tperson2.setName( \"Jane Doe\" );\n\n\t\tTransaction t;\n\t\tSession session = null;\n\t\tSession newSession = null;\n\t\ttry {\n\t\t\tsession = sessionFactory.withOptions().tenantIdentifier( FRONT_END_TENANT ).openSession();\n\t\t\tt = session.beginTransaction();\n\t\t\tsession.persist( person );\n\t\t\tt.commit();\n\n\t\t\tQuery<Person> sessionQuery = session.createQuery( \"from Person\", Person.class );\n\t\t\tassertEquals( 1, sessionQuery.getResultList().size() );\n\t\t\tassertEquals( \"John Doe\", sessionQuery.getResultList().get( 0 ).getName() );\n\n\t\t\tnewSession = session.sessionWithOptions().tenantIdentifier( BACK_END_TENANT ).openSession();\n\t\t\tt = newSession.beginTransaction();\n\t\t\tnewSession.persist( person2 );\n\t\t\tt.commit();\n\n\t\t\tQuery<Person> newSessionQuery = newSession.createQuery( \"from Person\", Person.class );\n\t\t\tassertEquals( 1, newSessionQuery.getResultList().size() );\n\t\t\tassertEquals( \"Jane Doe\", newSessionQuery.getResultList().get( 0 ).getName() );\n\t\t}\n\t\tfinally {\n\t\t\tif (session != null) {\n\t\t\t\tsession.close();\n\t\t\t}\n\t\t\tif (newSession != null) {\n\t\t\t\tnewSession.close();\n\t\t\t}\n\t\t}\n\t}\n\n\t@Test\n\t@JiraKey( value = \"HHH-17972\")\n\tpublic void testChangeTenantWithConnectionReuse() {\n\t\ttry (Session session = sessionFactory.withOptions().tenantIdentifier( FRONT_END_TENANT ).openSession()) {\n\t\t\tAssert.assertThrows( \"Cannot redefine the tenant identifier on a child session if the connection is reused\",\n\t\t\t\t\t\t\t\tSessionException.class,\n\t\t\t\t\t\t\t\t() -> session.sessionWithOptions().tenantIdentifier( BACK_END_TENANT ).connection().openSession()\n\t\t\t);\n\t\t\tAssert.assertThrows( \"Cannot redefine the tenant identifier on a child session if the connection is reused\",\n\t\t\t\t\t\t\t\tSessionException.class,\n\t\t\t\t\t\t\t\t() -> session.sessionWithOptions().connection().tenantIdentifier( BACK_END_TENANT ).openSession()\n\t\t\t);\n\t\t}\n\t}\n\n\tprotected Properties properties() {\n\t\tProperties properties = new Properties();\n\t\tURL propertiesURL = Thread.currentThread().getContextClassLoader().getResource(\"hibernate.properties\");\n\t\ttry(FileInputStream inputStream = new FileInputStream(propertiesURL.getFile())) {\n\t\t\tproperties.load(inputStream);\n\t\t}\n\t\tcatch (IOException e) {\n\t\t\tthrow new IllegalArgumentException(e);\n\t\t}\n\t\treturn properties;\n\t}\n\n\tprotected abstract String tenantUrl(String originalUrl, String tenantIdentifier);\n\n\tprotected SessionFactory sessionFactory(Map<String, Object> settings) {\n\n\t\tServiceRegistryImplementor serviceRegistry = (ServiceRegistryImplementor) ServiceRegistryUtil.serviceRegistryBuilder()\n\t\t\t.applySettings(settings)\n\t\t\t.build();\n\n\t\tMetadataSources metadataSources = new MetadataSources(serviceRegistry);\n\t\tfor(Class annotatedClasses : getAnnotatedClasses()) {\n\t\t\tmetadataSources.addAnnotatedClass(annotatedClasses);\n\t\t}\n\n\t\tMetadata metadata = metadataSources.buildMetadata();\n\n\t\tHibernateSchemaManagementTool tool = new HibernateSchemaManagementTool();\n\t\ttool.injectServices(serviceRegistry);\n\n\t\tnew SchemaDropperImpl( serviceRegistry ).doDrop(\n\t\t\t\tmetadata,\n\t\t\t\tserviceRegistry,\n\t\t\t\tsettings,\n\t\t\t\ttrue,\n\t\t\t\tnew GenerationTargetToDatabase(\n\t\t\t\t\t\tnew DdlTransactionIsolatorTestingImpl(\n\t\t\t\t\t\t\t\tserviceRegistry,\n\t\t\t\t\t\t\t\tconnectionProviderMap.get( FRONT_END_TENANT )\n\t\t\t\t\t\t)\n\t\t\t\t),\n\t\t\t\tnew GenerationTargetToDatabase(\n\t\t\t\t\t\tnew DdlTransactionIsolatorTestingImpl(\n\t\t\t\t\t\t\t\tserviceRegistry,\n\t\t\t\t\t\t\t\tconnectionProviderMap.get( BACK_END_TENANT )\n\t\t\t\t\t\t)\n\t\t\t\t)\n\t\t);\n\n\t\tnew SchemaCreatorImpl( serviceRegistry ).doCreation(\n\t\t\t\tmetadata,\n\t\t\t\tserviceRegistry,\n\t\t\t\tsettings,\n\t\t\t\ttrue,\n\t\t\t\tnew GenerationTargetToDatabase(\n\t\t\t\t\t\tnew DdlTransactionIsolatorTestingImpl(\n\t\t\t\t\t\t\t\tserviceRegistry,\n\t\t\t\t\t\t\t\tconnectionProviderMap.get( FRONT_END_TENANT )\n\t\t\t\t\t\t)\n\t\t\t\t),\n\t\t\t\tnew GenerationTargetToDatabase(\n\t\t\t\t\t\tnew DdlTransactionIsolatorTestingImpl(\n\t\t\t\t\t\t\t\tserviceRegistry,\n\t\t\t\t\t\t\t\tconnectionProviderMap.get( BACK_END_TENANT )\n\t\t\t\t\t\t)\n\t\t\t\t)\n\t\t);\n\n\t\tfinal SessionFactoryBuilder sessionFactoryBuilder = metadata.getSessionFactoryBuilder();\n\t\treturn sessionFactoryBuilder.build();\n\t}\n\n\tprotected Class<?>[] getAnnotatedClasses() {\n\t\treturn new Class<?>[] {\n\t\t\tPerson.class\n\t\t};\n\t}\n\n\t//tag::multitenacy-hibernate-session-example[]\n\tprivate void doInSession(String tenant, Consumer<Session> function) {\n\t\tSession session = null;\n\t\tTransaction txn = null;\n\t\ttry {\n\t\t\tsession = sessionFactory\n\t\t\t\t.withOptions()\n\t\t\t\t.tenantIdentifier(tenant)\n\t\t\t\t.openSession();\n\t\t\ttxn = session.getTransaction();\n\t\t\ttxn.begin();\n\t\t\tfunction.accept(session);\n\t\t\ttxn.commit();\n\t\t} catch (Throwable e) {\n\t\t\tif (txn != null) txn.rollback();\n\t\t\tthrow e;\n\t\t} finally {\n\t\t\tif (session != null) {\n\t\t\t\tsession.close();\n\t\t\t}\n\t\t}\n\t}\n\t//end::multitenacy-hibernate-session-example[]\n\n\t@Entity(name = \"Person\")\n\tpublic static class Person {\n\n\t\t@Id\n\t\tprivate Long id;\n\n\t\tprivate String name;\n\n\t\tpublic Long getId() {\n\t\t\treturn id;\n\t\t}\n\n\t\tpublic void setId(Long id) {\n\t\t\tthis.id = id;\n\t\t}\n\n\t\tpublic String getName() {\n\t\t\treturn name;\n\t\t}\n\n\t\tpublic void setName(String name) {\n\t\t\tthis.name = name;\n\t\t}\n\t}\n\n}\n",
        "filePathAfter": "hibernate-core/src/test/java/org/hibernate/orm/test/multitenancy/AbstractMultiTenancyTest.java",
        "sourceCodeAfterForWhole": "/*\n * SPDX-License-Identifier: LGPL-2.1-or-later\n * Copyright Red Hat Inc. and Hibernate Authors\n */\npackage org.hibernate.orm.test.multitenancy;\n\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.net.URL;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Properties;\nimport java.util.function.Consumer;\nimport jakarta.persistence.Entity;\nimport jakarta.persistence.Id;\n\nimport org.hibernate.Session;\nimport org.hibernate.SessionException;\nimport org.hibernate.SessionFactory;\nimport org.hibernate.Transaction;\nimport org.hibernate.boot.Metadata;\nimport org.hibernate.boot.MetadataSources;\nimport org.hibernate.boot.SessionFactoryBuilder;\nimport org.hibernate.cfg.AvailableSettings;\nimport org.hibernate.cfg.Environment;\nimport org.hibernate.engine.jdbc.connections.internal.DriverManagerConnectionProviderImpl;\nimport org.hibernate.engine.jdbc.connections.spi.ConnectionProvider;\nimport org.hibernate.internal.util.PropertiesHelper;\nimport org.hibernate.query.Query;\nimport org.hibernate.service.spi.ServiceRegistryImplementor;\nimport org.hibernate.service.spi.Stoppable;\nimport org.hibernate.tool.schema.internal.HibernateSchemaManagementTool;\nimport org.hibernate.tool.schema.internal.SchemaCreatorImpl;\nimport org.hibernate.tool.schema.internal.SchemaDropperImpl;\nimport org.hibernate.tool.schema.internal.exec.GenerationTargetToDatabase;\n\nimport org.hibernate.testing.AfterClassOnce;\nimport org.hibernate.testing.junit4.BaseUnitTestCase;\nimport org.hibernate.testing.orm.junit.JiraKey;\nimport org.hibernate.testing.util.ServiceRegistryUtil;\n\nimport org.hibernate.orm.test.util.DdlTransactionIsolatorTestingImpl;\n\nimport org.junit.After;\nimport org.junit.Assert;\nimport org.junit.Test;\n\nimport static org.junit.Assert.assertEquals;\n\n/**\n * @author Vlad Mihalcea\n */\npublic abstract class AbstractMultiTenancyTest extends BaseUnitTestCase {\n\n\tprotected static final String FRONT_END_TENANT = \"front_end\";\n\tprotected static final String BACK_END_TENANT = \"back_end\";\n\n\tprotected Map<String, ConnectionProvider> connectionProviderMap = new HashMap<>();\n\n\tprotected SessionFactory sessionFactory;\n\n\tpublic AbstractMultiTenancyTest() {\n\t\tinit();\n\t}\n\n\t//tag::multitenacy-hibernate-MultiTenantConnectionProvider-example[]\n\tprivate void init() {\n\t\tregisterConnectionProvider(FRONT_END_TENANT);\n\t\tregisterConnectionProvider(BACK_END_TENANT);\n\t\tsessionFactory = sessionFactory(createSettings());\n\t}\n\n\tprotected Map<String, Object> createSettings() {\n\t\tMap<String, Object> settings = new HashMap<>();\n\n\t\tsettings.put(AvailableSettings.MULTI_TENANT_CONNECTION_PROVIDER,\n\t\t\t\tnew ConfigurableMultiTenantConnectionProvider(connectionProviderMap));\n\t\treturn settings;\n\t}\n\t//end::multitenacy-hibernate-MultiTenantConnectionProvider-example[]\n\n\t@AfterClassOnce\n\tpublic void destroy() {\n\t\tsessionFactory.close();\n\t\tfor (ConnectionProvider connectionProvider : connectionProviderMap.values()) {\n\t\t\tif (connectionProvider instanceof Stoppable) {\n\t\t\t\t((Stoppable) connectionProvider).stop();\n\t\t\t}\n\t\t}\n\t}\n\n\t@After\n\tpublic void cleanup() {\n\t\tdoInSession(FRONT_END_TENANT, session -> session.createMutationQuery( \"delete from Person\" ).executeUpdate() );\n\t\tdoInSession(BACK_END_TENANT, session -> session.createMutationQuery( \"delete from Person\" ).executeUpdate() );\n\t}\n\n\t//tag::multitenacy-hibernate-MultiTenantConnectionProvider-example[]\n\n\tprotected void registerConnectionProvider(String tenantIdentifier) {\n\t\tProperties properties = properties();\n\t\tproperties.put(Environment.URL,\n\t\t\ttenantUrl(properties.getProperty(Environment.URL), tenantIdentifier));\n\n\t\tDriverManagerConnectionProviderImpl connectionProvider =\n\t\t\tnew DriverManagerConnectionProviderImpl();\n\t\tconnectionProvider.configure( PropertiesHelper.map(properties) );\n\t\tconnectionProviderMap.put(tenantIdentifier, connectionProvider);\n\t}\n\t//end::multitenacy-hibernate-MultiTenantConnectionProvider-example[]\n\n\t@Test\n\tpublic void testBasicExpectedBehavior() {\n\n\t\t//tag::multitenacy-multitenacy-hibernate-same-entity-example[]\n\t\tdoInSession(FRONT_END_TENANT, session -> {\n\t\t\tPerson person = new Person();\n\t\t\tperson.setId(1L);\n\t\t\tperson.setName(\"John Doe\");\n\t\t\tsession.persist(person);\n\t\t});\n\n\t\tdoInSession(BACK_END_TENANT, session -> {\n\t\t\tPerson person = new Person();\n\t\t\tperson.setId(1L);\n\t\t\tperson.setName(\"John Doe\");\n\t\t\tsession.persist(person);\n\t\t});\n\t\t//end::multitenacy-multitenacy-hibernate-same-entity-example[]\n\t}\n\n\t@Test\n\t@JiraKey( value = \"HHH-17972\")\n\tpublic void testChangeTenantWithoutConnectionReuse() {\n\t\tPerson person = new Person();\n\t\tperson.setId( 1L );\n\t\tperson.setName( \"John Doe\" );\n\t\tPerson person2 = new Person();\n\t\tperson2.setId( 2L );\n\t\tperson2.setName( \"Jane Doe\" );\n\n\t\tTransaction t;\n\t\tSession session = null;\n\t\tSession newSession = null;\n\t\ttry {\n\t\t\tsession = sessionFactory.withOptions().tenantIdentifier( FRONT_END_TENANT ).openSession();\n\t\t\tt = session.beginTransaction();\n\t\t\tsession.persist( person );\n\t\t\tt.commit();\n\n\t\t\tQuery<Person> sessionQuery = session.createQuery( \"from Person\", Person.class );\n\t\t\tassertEquals( 1, sessionQuery.getResultList().size() );\n\t\t\tassertEquals( \"John Doe\", sessionQuery.getResultList().get( 0 ).getName() );\n\n\t\t\tnewSession = session.sessionWithOptions().tenantIdentifier( BACK_END_TENANT ).openSession();\n\t\t\tt = newSession.beginTransaction();\n\t\t\tnewSession.persist( person2 );\n\t\t\tt.commit();\n\n\t\t\tQuery<Person> newSessionQuery = newSession.createQuery( \"from Person\", Person.class );\n\t\t\tassertEquals( 1, newSessionQuery.getResultList().size() );\n\t\t\tassertEquals( \"Jane Doe\", newSessionQuery.getResultList().get( 0 ).getName() );\n\t\t}\n\t\tfinally {\n\t\t\tif (session != null) {\n\t\t\t\tsession.close();\n\t\t\t}\n\t\t\tif (newSession != null) {\n\t\t\t\tnewSession.close();\n\t\t\t}\n\t\t}\n\t}\n\n\t@Test\n\t@JiraKey( value = \"HHH-17972\")\n\tpublic void testChangeTenantWithConnectionReuse() {\n\t\ttry (Session session = sessionFactory.withOptions().tenantIdentifier( FRONT_END_TENANT ).openSession()) {\n\t\t\tAssert.assertThrows( \"Cannot redefine the tenant identifier on a child session if the connection is reused\",\n\t\t\t\t\t\t\t\tSessionException.class,\n\t\t\t\t\t\t\t\t() -> session.sessionWithOptions().tenantIdentifier( BACK_END_TENANT ).connection().openSession()\n\t\t\t);\n\t\t\tAssert.assertThrows( \"Cannot redefine the tenant identifier on a child session if the connection is reused\",\n\t\t\t\t\t\t\t\tSessionException.class,\n\t\t\t\t\t\t\t\t() -> session.sessionWithOptions().connection().tenantIdentifier( BACK_END_TENANT ).openSession()\n\t\t\t);\n\t\t}\n\t}\n\n\tprotected Properties properties() {\n\t\tProperties properties = new Properties();\n\t\tURL propertiesURL = Thread.currentThread().getContextClassLoader().getResource(\"hibernate.properties\");\n\t\ttry(FileInputStream inputStream = new FileInputStream(propertiesURL.getFile())) {\n\t\t\tproperties.load(inputStream);\n\t\t}\n\t\tcatch (IOException e) {\n\t\t\tthrow new IllegalArgumentException(e);\n\t\t}\n\t\treturn properties;\n\t}\n\n\tprotected abstract String tenantUrl(String originalUrl, String tenantIdentifier);\n\n\tprotected SessionFactory sessionFactory(Map<String, Object> settings) {\n\n\t\tServiceRegistryImplementor serviceRegistry = (ServiceRegistryImplementor) ServiceRegistryUtil.serviceRegistryBuilder()\n\t\t\t.applySettings(settings)\n\t\t\t.build();\n\n\t\tMetadataSources metadataSources = new MetadataSources(serviceRegistry);\n\t\tfor(Class annotatedClasses : getAnnotatedClasses()) {\n\t\t\tmetadataSources.addAnnotatedClass(annotatedClasses);\n\t\t}\n\n\t\tMetadata metadata = metadataSources.buildMetadata();\n\n\t\tHibernateSchemaManagementTool tool = new HibernateSchemaManagementTool();\n\t\ttool.injectServices(serviceRegistry);\n\n\t\tnew SchemaDropperImpl( serviceRegistry ).doDrop(\n\t\t\t\tmetadata,\n\t\t\t\tserviceRegistry,\n\t\t\t\tsettings,\n\t\t\t\ttrue,\n\t\t\t\tnew GenerationTargetToDatabase(\n\t\t\t\t\t\tnew DdlTransactionIsolatorTestingImpl(\n\t\t\t\t\t\t\t\tserviceRegistry,\n\t\t\t\t\t\t\t\tconnectionProviderMap.get( FRONT_END_TENANT )\n\t\t\t\t\t\t)\n\t\t\t\t),\n\t\t\t\tnew GenerationTargetToDatabase(\n\t\t\t\t\t\tnew DdlTransactionIsolatorTestingImpl(\n\t\t\t\t\t\t\t\tserviceRegistry,\n\t\t\t\t\t\t\t\tconnectionProviderMap.get( BACK_END_TENANT )\n\t\t\t\t\t\t)\n\t\t\t\t)\n\t\t);\n\n\t\tnew SchemaCreatorImpl( serviceRegistry ).doCreation(\n\t\t\t\tmetadata,\n\t\t\t\tserviceRegistry,\n\t\t\t\tsettings,\n\t\t\t\ttrue,\n\t\t\t\tnew GenerationTargetToDatabase(\n\t\t\t\t\t\tnew DdlTransactionIsolatorTestingImpl(\n\t\t\t\t\t\t\t\tserviceRegistry,\n\t\t\t\t\t\t\t\tconnectionProviderMap.get( FRONT_END_TENANT )\n\t\t\t\t\t\t)\n\t\t\t\t),\n\t\t\t\tnew GenerationTargetToDatabase(\n\t\t\t\t\t\tnew DdlTransactionIsolatorTestingImpl(\n\t\t\t\t\t\t\t\tserviceRegistry,\n\t\t\t\t\t\t\t\tconnectionProviderMap.get( BACK_END_TENANT )\n\t\t\t\t\t\t)\n\t\t\t\t)\n\t\t);\n\n\t\tfinal SessionFactoryBuilder sessionFactoryBuilder = metadata.getSessionFactoryBuilder();\n\t\treturn sessionFactoryBuilder.build();\n\t}\n\n\tprotected Class<?>[] getAnnotatedClasses() {\n\t\treturn new Class<?>[] {\n\t\t\tPerson.class\n\t\t};\n\t}\n\n\t//tag::multitenacy-hibernate-session-example[]\n\tprivate void doInSession(String tenant, Consumer<Session> function) {\n\t\tSession session = null;\n\t\tTransaction txn = null;\n\t\ttry {\n\t\t\tsession = sessionFactory\n\t\t\t\t.withOptions()\n\t\t\t\t.tenantIdentifier(tenant)\n\t\t\t\t.openSession();\n\t\t\ttxn = session.getTransaction();\n\t\t\ttxn.begin();\n\t\t\tfunction.accept(session);\n\t\t\ttxn.commit();\n\t\t} catch (Throwable e) {\n\t\t\tif (txn != null) txn.rollback();\n\t\t\tthrow e;\n\t\t} finally {\n\t\t\tif (session != null) {\n\t\t\t\tsession.close();\n\t\t\t}\n\t\t}\n\t}\n\t//end::multitenacy-hibernate-session-example[]\n\n\t@Entity(name = \"Person\")\n\tpublic static class Person {\n\n\t\t@Id\n\t\tprivate Long id;\n\n\t\tprivate String name;\n\n\t\tpublic Long getId() {\n\t\t\treturn id;\n\t\t}\n\n\t\tpublic void setId(Long id) {\n\t\t\tthis.id = id;\n\t\t}\n\n\t\tpublic String getName() {\n\t\t\treturn name;\n\t\t}\n\n\t\tpublic void setName(String name) {\n\t\t\tthis.name = name;\n\t\t}\n\t}\n\n}\n",
        "diffSourceCodeSet": [
            "protected Map<String, Object> createSettings() {\n\t\tMap<String, Object> settings = new HashMap<>();\n\n\t\tsettings.put(AvailableSettings.MULTI_TENANT_CONNECTION_PROVIDER,\n\t\t\t\tnew ConfigurableMultiTenantConnectionProvider(connectionProviderMap));\n\t\treturn settings;\n\t}"
        ],
        "invokedMethodSet": [
            "methodSignature: org.hibernate.orm.test.multitenancy.AbstractMultiTenancyTest#registerConnectionProvider\n methodBody: protected void registerConnectionProvider(String tenantIdentifier) {\nProperties properties=properties();\nproperties.put(Environment.URL,tenantUrl(properties.getProperty(Environment.URL),tenantIdentifier));\nDriverManagerConnectionProviderImpl connectionProvider=new DriverManagerConnectionProviderImpl();\nconnectionProvider.configure(PropertiesHelper.map(properties));\nconnectionProviderMap.put(tenantIdentifier,connectionProvider);\n}",
            "methodSignature: org.hibernate.orm.test.multitenancy.AbstractMultiTenancyTest#sessionFactory\n methodBody: protected SessionFactory sessionFactory(Map<String, Object> settings) {\nServiceRegistryImplementor serviceRegistry=(ServiceRegistryImplementor)ServiceRegistryUtil.serviceRegistryBuilder().applySettings(settings).build();\nMetadataSources metadataSources=new MetadataSources(serviceRegistry);\nfor(Class annotatedClasses: getAnnotatedClasses()){metadataSources.addAnnotatedClass(annotatedClasses);\n}Metadata metadata=metadataSources.buildMetadata();\nHibernateSchemaManagementTool tool=new HibernateSchemaManagementTool();\ntool.injectServices(serviceRegistry);\nnew SchemaDropperImpl(serviceRegistry).doDrop(metadata,serviceRegistry,settings,true,new GenerationTargetToDatabase(new DdlTransactionIsolatorTestingImpl(serviceRegistry,connectionProviderMap.get(FRONT_END_TENANT))),new GenerationTargetToDatabase(new DdlTransactionIsolatorTestingImpl(serviceRegistry,connectionProviderMap.get(BACK_END_TENANT))));\nnew SchemaCreatorImpl(serviceRegistry).doCreation(metadata,serviceRegistry,settings,true,new GenerationTargetToDatabase(new DdlTransactionIsolatorTestingImpl(serviceRegistry,connectionProviderMap.get(FRONT_END_TENANT))),new GenerationTargetToDatabase(new DdlTransactionIsolatorTestingImpl(serviceRegistry,connectionProviderMap.get(BACK_END_TENANT))));\nfinal SessionFactoryBuilder sessionFactoryBuilder=metadata.getSessionFactoryBuilder();\nreturn sessionFactoryBuilder.build();\n}"
        ],
        "sourceCodeAfterRefactoring": "private void init() {\n\t\tregisterConnectionProvider(FRONT_END_TENANT);\n\t\tregisterConnectionProvider(BACK_END_TENANT);\n\t\tsessionFactory = sessionFactory(createSettings());\n\t}\nprotected Map<String, Object> createSettings() {\n\t\tMap<String, Object> settings = new HashMap<>();\n\n\t\tsettings.put(AvailableSettings.MULTI_TENANT_CONNECTION_PROVIDER,\n\t\t\t\tnew ConfigurableMultiTenantConnectionProvider(connectionProviderMap));\n\t\treturn settings;\n\t}",
        "diffSourceCode": "    67: \tprivate void init() {\n    68: \t\tregisterConnectionProvider(FRONT_END_TENANT);\n    69: \t\tregisterConnectionProvider(BACK_END_TENANT);\n-   70: \n-   71: \t\tMap<String, Object> settings = new HashMap<>();\n+   70: \t\tsessionFactory = sessionFactory(createSettings());\n+   71: \t}\n    72: \n-   73: \t\tsettings.put(AvailableSettings.MULTI_TENANT_CONNECTION_PROVIDER,\n-   74: \t\t\tnew ConfigurableMultiTenantConnectionProvider(connectionProviderMap));\n+   73: \tprotected Map<String, Object> createSettings() {\n+   74: \t\tMap<String, Object> settings = new HashMap<>();\n    75: \n-   76: \t\tsessionFactory = sessionFactory(settings);\n-   77: \t}\n-   78: \t//end::multitenacy-hibernate-MultiTenantConnectionProvider-example[]\n-   79: \n+   76: \t\tsettings.put(AvailableSettings.MULTI_TENANT_CONNECTION_PROVIDER,\n+   77: \t\t\t\tnew ConfigurableMultiTenantConnectionProvider(connectionProviderMap));\n+   78: \t\treturn settings;\n+   79: \t}\n",
        "uniqueId": "7c315fdbfa45019322e2be4701d6555db886ace7_67_77_73_79_67_71",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "testMethod": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 21
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprivate endSlowQueryLogging(sql String, executeStartNanos long) : void extracted from public extract(statement Statement, sql String) : ResultSet in class org.hibernate.engine.jdbc.internal.ResultSetReturnImpl",
        "diffLocations": [
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/engine/jdbc/internal/ResultSetReturnImpl.java",
                "startLine": 88,
                "endLine": 114,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/engine/jdbc/internal/ResultSetReturnImpl.java",
                "startLine": 95,
                "endLine": 119,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/engine/jdbc/internal/ResultSetReturnImpl.java",
                "startLine": 225,
                "endLine": 227,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "@Override\n\tpublic ResultSet extract(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\trs = statement.executeQuery( sql );\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not extract ResultSet\", sql );\n\t\t}\n\t}",
        "filePathBefore": "hibernate-core/src/main/java/org/hibernate/engine/jdbc/internal/ResultSetReturnImpl.java",
        "isPureRefactoring": true,
        "commitId": "7b8c403df746e127f38d3f5f3efb45b941c36af2",
        "packageNameBefore": "org.hibernate.engine.jdbc.internal",
        "classNameBefore": "org.hibernate.engine.jdbc.internal.ResultSetReturnImpl",
        "methodNameBefore": "org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#extract",
        "invokedMethod": "methodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#jdbcExecuteStatementStart\n methodBody: private void jdbcExecuteStatementStart() {\njdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getEventHandler().jdbcExecuteStatementStart();\n}\nmethodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#context\n methodBody: private JdbcSessionContext context() {\nreturn jdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext();\n}\nmethodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#jdbcExecuteStatementEnd\n methodBody: private void jdbcExecuteStatementEnd() {\njdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getEventHandler().jdbcExecuteStatementEnd();\n}\nmethodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#postExtract\n methodBody: private void postExtract(ResultSet rs, Statement st) {\nif(rs != null){jdbcCoordinator.getLogicalConnection().getResourceRegistry().register(rs,st);\n}}",
        "classSignatureBefore": "public class ResultSetReturnImpl implements ResultSetReturn ",
        "methodNameBeforeSet": [
            "org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#extract"
        ],
        "classNameBeforeSet": [
            "org.hibernate.engine.jdbc.internal.ResultSetReturnImpl"
        ],
        "classSignatureBeforeSet": [
            "public class ResultSetReturnImpl implements ResultSetReturn "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.\n */\npackage org.hibernate.engine.jdbc.internal;\n\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\nimport org.hibernate.dialect.Dialect;\nimport org.hibernate.engine.jdbc.spi.JdbcCoordinator;\nimport org.hibernate.engine.jdbc.spi.JdbcServices;\nimport org.hibernate.engine.jdbc.spi.ResultSetReturn;\nimport org.hibernate.engine.jdbc.spi.SqlExceptionHelper;\nimport org.hibernate.engine.jdbc.spi.SqlStatementLogger;\nimport org.hibernate.event.spi.EventManager;\nimport org.hibernate.event.spi.HibernateMonitoringEvent;\nimport org.hibernate.resource.jdbc.spi.JdbcSessionContext;\n\n/**\n * Standard implementation of the ResultSetReturn contract\n *\n * @author Brett Meyer\n */\npublic class ResultSetReturnImpl implements ResultSetReturn {\n\tprivate final JdbcCoordinator jdbcCoordinator;\n\n\tprivate final Dialect dialect;\n\tprivate final SqlStatementLogger sqlStatementLogger;\n\tprivate final SqlExceptionHelper sqlExceptionHelper;\n\n\t/**\n\t * Constructs a ResultSetReturnImpl\n\t *\n\t * @param jdbcCoordinator The JdbcCoordinator\n\t */\n\tpublic ResultSetReturnImpl(JdbcCoordinator jdbcCoordinator, JdbcServices jdbcServices) {\n\t\tthis.jdbcCoordinator = jdbcCoordinator;\n\t\tthis.dialect = jdbcServices.getDialect();\n\t\tthis.sqlStatementLogger = jdbcServices.getSqlStatementLogger();\n\t\tthis.sqlExceptionHelper = jdbcServices.getSqlExceptionHelper();\n\t}\n\n\t@Override\n\tpublic ResultSet extract(PreparedStatement statement, String sql) {\n\t\t// IMPL NOTE : SQL logged by caller\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\trs = statement.executeQuery();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not extract ResultSet\", sql );\n\t\t}\n\t}\n\n\tprivate JdbcSessionContext context() {\n\t\treturn jdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext();\n\t}\n\n\tprivate void jdbcExecuteStatementEnd() {\n\t\tjdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getEventHandler().jdbcExecuteStatementEnd();\n\t}\n\n\tprivate void jdbcExecuteStatementStart() {\n\t\tjdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getEventHandler().jdbcExecuteStatementStart();\n\t}\n\n\t@Override\n\tpublic ResultSet extract(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\trs = statement.executeQuery( sql );\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not extract ResultSet\", sql );\n\t\t}\n\t}\n\n\t@Override\n\tpublic ResultSet execute(PreparedStatement statement, String sql) {\n\t\t// sql logged by StatementPreparerImpl\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\tif ( !statement.execute() ) {\n\t\t\t\t\twhile ( !statement.getMoreResults() && statement.getUpdateCount() != -1 ) {\n\t\t\t\t\t\t// do nothing until we hit the resultset\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trs = statement.getResultSet();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t}\n\n\t@Override\n\tpublic ResultSet execute(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\tif ( !statement.execute( sql ) ) {\n\t\t\t\t\twhile ( !statement.getMoreResults() && statement.getUpdateCount() != -1 ) {\n\t\t\t\t\t\t// do nothing until we hit the resultset\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trs = statement.getResultSet();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t}\n\n\t@Override\n\tpublic int executeUpdate(PreparedStatement statement, String sql) {\n\t\tassert statement != null;\n\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\ttry {\n\t\t\tjdbcExecuteStatementStart();\n\t\t\treturn statement.executeUpdate();\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t\tfinally {\n\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\tjdbcExecuteStatementEnd();\n\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t}\n\t}\n\n\t@Override\n\tpublic int executeUpdate(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\ttry {\n\t\t\tjdbcExecuteStatementStart();\n\t\t\treturn statement.executeUpdate( sql );\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t\tfinally {\n\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\tjdbcExecuteStatementEnd();\n\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t}\n\t}\n\n\tprivate void postExtract(ResultSet rs, Statement st) {\n\t\tif ( rs != null ) {\n\t\t\tjdbcCoordinator.getLogicalConnection().getResourceRegistry().register( rs, st );\n\t\t}\n\t}\n\n}\n",
        "filePathAfter": "hibernate-core/src/main/java/org/hibernate/engine/jdbc/internal/ResultSetReturnImpl.java",
        "sourceCodeAfterForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.\n */\npackage org.hibernate.engine.jdbc.internal;\n\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\nimport org.hibernate.engine.jdbc.spi.JdbcCoordinator;\nimport org.hibernate.engine.jdbc.spi.JdbcServices;\nimport org.hibernate.engine.jdbc.spi.ResultSetReturn;\nimport org.hibernate.engine.jdbc.spi.SqlExceptionHelper;\nimport org.hibernate.engine.jdbc.spi.SqlStatementLogger;\nimport org.hibernate.event.spi.EventManager;\nimport org.hibernate.event.spi.HibernateMonitoringEvent;\nimport org.hibernate.resource.jdbc.spi.JdbcEventHandler;\nimport org.hibernate.resource.jdbc.spi.JdbcSessionContext;\n\n/**\n * Standard implementation of the ResultSetReturn contract\n *\n * @author Brett Meyer\n */\npublic class ResultSetReturnImpl implements ResultSetReturn {\n\tprivate final JdbcCoordinator jdbcCoordinator;\n\n\tprivate final SqlStatementLogger sqlStatementLogger;\n\tprivate final SqlExceptionHelper sqlExceptionHelper;\n\n\t/**\n\t * Constructs a ResultSetReturnImpl\n\t *\n\t * @param jdbcCoordinator The JdbcCoordinator\n\t */\n\tpublic ResultSetReturnImpl(JdbcCoordinator jdbcCoordinator, JdbcServices jdbcServices) {\n\t\tthis.jdbcCoordinator = jdbcCoordinator;\n\t\tthis.sqlStatementLogger = jdbcServices.getSqlStatementLogger();\n\t\tthis.sqlExceptionHelper = jdbcServices.getSqlExceptionHelper();\n\t}\n\n\t@Override\n\tpublic ResultSet extract(PreparedStatement statement, String sql) {\n\t\t// IMPL NOTE : SQL logged by caller\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = getEventManager();\n\t\t\tfinal HibernateMonitoringEvent executionEvent =\n\t\t\t\t\teventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\trs = statement.executeQuery();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( executionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tendSlowQueryLogging(sql, executeStartNanos);\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not extract ResultSet\", sql );\n\t\t}\n\t}\n\n\tprivate EventManager getEventManager() {\n\t\treturn jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t}\n\n\tprivate JdbcEventHandler getEventHandler() {\n\t\treturn jdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getEventHandler();\n\t}\n\n\tprivate JdbcSessionContext context() {\n\t\treturn jdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext();\n\t}\n\n\tprivate void jdbcExecuteStatementEnd() {\n\t\tgetEventHandler().jdbcExecuteStatementEnd();\n\t}\n\n\tprivate void jdbcExecuteStatementStart() {\n\t\tgetEventHandler().jdbcExecuteStatementStart();\n\t}\n\n\t@Override\n\tpublic ResultSet extract(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = beginSlowQueryLogging();\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = getEventManager();\n\t\t\tfinal HibernateMonitoringEvent executionEvent =\n\t\t\t\t\teventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\trs = statement.executeQuery( sql );\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( executionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tendSlowQueryLogging( sql, executeStartNanos );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not extract ResultSet\", sql );\n\t\t}\n\t}\n\n\t@Override\n\tpublic ResultSet execute(PreparedStatement statement, String sql) {\n\t\t// sql logged by StatementPreparerImpl\n\t\tlong executeStartNanos = beginSlowQueryLogging();\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = getEventManager();\n\t\t\tfinal HibernateMonitoringEvent executionEvent =\n\t\t\t\t\teventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\tif ( !statement.execute() ) {\n\t\t\t\t\twhile ( !statement.getMoreResults() && statement.getUpdateCount() != -1 ) {\n\t\t\t\t\t\t// do nothing until we hit the resultset\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trs = statement.getResultSet();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( executionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tendSlowQueryLogging( sql, executeStartNanos );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t}\n\n\t@Override\n\tpublic ResultSet execute(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = beginSlowQueryLogging();\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = getEventManager();\n\t\t\tfinal HibernateMonitoringEvent executionEvent =\n\t\t\t\t\teventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\tif ( !statement.execute( sql ) ) {\n\t\t\t\t\twhile ( !statement.getMoreResults() && statement.getUpdateCount() != -1 ) {\n\t\t\t\t\t\t// do nothing until we hit the resultset\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trs = statement.getResultSet();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( executionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tendSlowQueryLogging( sql, executeStartNanos );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t}\n\n\t@Override\n\tpublic int executeUpdate(PreparedStatement statement, String sql) {\n\t\tassert statement != null;\n\t\tlong executeStartNanos = beginSlowQueryLogging();\n\t\tfinal EventManager eventManager = getEventManager();\n\t\tfinal HibernateMonitoringEvent executionEvent =\n\t\t\t\teventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\ttry {\n\t\t\tjdbcExecuteStatementStart();\n\t\t\treturn statement.executeUpdate();\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t\tfinally {\n\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( executionEvent, sql );\n\t\t\tjdbcExecuteStatementEnd();\n\t\t\tendSlowQueryLogging( sql, executeStartNanos );\n\t\t}\n\t}\n\n\t@Override\n\tpublic int executeUpdate(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = beginSlowQueryLogging();\n\t\tfinal EventManager eventManager = getEventManager();\n\t\tfinal HibernateMonitoringEvent executionEvent =\n\t\t\t\teventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\ttry {\n\t\t\tjdbcExecuteStatementStart();\n\t\t\treturn statement.executeUpdate( sql );\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t\tfinally {\n\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( executionEvent, sql );\n\t\t\tjdbcExecuteStatementEnd();\n\t\t\tendSlowQueryLogging( sql, executeStartNanos );\n\t\t}\n\t}\n\n\tprivate void endSlowQueryLogging(String sql, long executeStartNanos) {\n\t\tsqlStatementLogger.logSlowQuery(sql, executeStartNanos, context() );\n\t}\n\n\tprivate long beginSlowQueryLogging() {\n\t\treturn sqlStatementLogger.getLogSlowQuery() > 0 ? System.nanoTime() : 0;\n\t}\n\n\tprivate void postExtract(ResultSet rs, Statement st) {\n\t\tif ( rs != null ) {\n\t\t\tjdbcCoordinator.getLogicalConnection().getResourceRegistry().register( rs, st );\n\t\t}\n\t}\n\n}\n",
        "diffSourceCodeSet": [
            "private void endSlowQueryLogging(String sql, long executeStartNanos) {\n\t\tsqlStatementLogger.logSlowQuery(sql, executeStartNanos, context() );\n\t}"
        ],
        "invokedMethodSet": [
            "methodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#jdbcExecuteStatementStart\n methodBody: private void jdbcExecuteStatementStart() {\njdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getEventHandler().jdbcExecuteStatementStart();\n}",
            "methodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#context\n methodBody: private JdbcSessionContext context() {\nreturn jdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext();\n}",
            "methodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#jdbcExecuteStatementEnd\n methodBody: private void jdbcExecuteStatementEnd() {\njdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getEventHandler().jdbcExecuteStatementEnd();\n}",
            "methodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#postExtract\n methodBody: private void postExtract(ResultSet rs, Statement st) {\nif(rs != null){jdbcCoordinator.getLogicalConnection().getResourceRegistry().register(rs,st);\n}}"
        ],
        "sourceCodeAfterRefactoring": "@Override\n\tpublic ResultSet extract(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = beginSlowQueryLogging();\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = getEventManager();\n\t\t\tfinal HibernateMonitoringEvent executionEvent =\n\t\t\t\t\teventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\trs = statement.executeQuery( sql );\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( executionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tendSlowQueryLogging( sql, executeStartNanos );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not extract ResultSet\", sql );\n\t\t}\n\t}\nprivate void endSlowQueryLogging(String sql, long executeStartNanos) {\n\t\tsqlStatementLogger.logSlowQuery(sql, executeStartNanos, context() );\n\t}",
        "diffSourceCode": "-   88: \t@Override\n-   89: \tpublic ResultSet extract(Statement statement, String sql) {\n-   90: \t\tsqlStatementLogger.logStatement( sql );\n-   91: \t\tlong executeStartNanos = 0;\n-   92: \t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n-   93: \t\t\texecuteStartNanos = System.nanoTime();\n-   94: \t\t}\n-   95: \t\ttry {\n-   96: \t\t\tfinal ResultSet rs;\n-   97: \t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n-   98: \t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n-   99: \t\t\ttry {\n-  100: \t\t\t\tjdbcExecuteStatementStart();\n-  101: \t\t\t\trs = statement.executeQuery( sql );\n-  102: \t\t\t}\n-  103: \t\t\tfinally {\n-  104: \t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n-  105: \t\t\t\tjdbcExecuteStatementEnd();\n-  106: \t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n+   88: \t\tgetEventHandler().jdbcExecuteStatementEnd();\n+   89: \t}\n+   90: \n+   91: \tprivate void jdbcExecuteStatementStart() {\n+   92: \t\tgetEventHandler().jdbcExecuteStatementStart();\n+   93: \t}\n+   94: \n+   95: \t@Override\n+   96: \tpublic ResultSet extract(Statement statement, String sql) {\n+   97: \t\tsqlStatementLogger.logStatement( sql );\n+   98: \t\tlong executeStartNanos = beginSlowQueryLogging();\n+   99: \t\ttry {\n+  100: \t\t\tfinal ResultSet rs;\n+  101: \t\t\tfinal EventManager eventManager = getEventManager();\n+  102: \t\t\tfinal HibernateMonitoringEvent executionEvent =\n+  103: \t\t\t\t\teventManager.beginJdbcPreparedStatementExecutionEvent();\n+  104: \t\t\ttry {\n+  105: \t\t\t\tjdbcExecuteStatementStart();\n+  106: \t\t\t\trs = statement.executeQuery( sql );\n   107: \t\t\t}\n-  108: \t\t\tpostExtract( rs, statement );\n-  109: \t\t\treturn rs;\n-  110: \t\t}\n-  111: \t\tcatch (SQLException e) {\n-  112: \t\t\tthrow sqlExceptionHelper.convert( e, \"could not extract ResultSet\", sql );\n-  113: \t\t}\n-  114: \t}\n-  115: \n-  116: \t@Override\n-  117: \tpublic ResultSet execute(PreparedStatement statement, String sql) {\n-  118: \t\t// sql logged by StatementPreparerImpl\n-  119: \t\tlong executeStartNanos = 0;\n-  225: \t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n-  226: \t\t}\n+  108: \t\t\tfinally {\n+  109: \t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( executionEvent, sql );\n+  110: \t\t\t\tjdbcExecuteStatementEnd();\n+  111: \t\t\t\tendSlowQueryLogging( sql, executeStartNanos );\n+  112: \t\t\t}\n+  113: \t\t\tpostExtract( rs, statement );\n+  114: \t\t\treturn rs;\n+  115: \t\t}\n+  116: \t\tcatch (SQLException e) {\n+  117: \t\t\tthrow sqlExceptionHelper.convert( e, \"could not extract ResultSet\", sql );\n+  118: \t\t}\n+  119: \t}\n+  225: \tprivate void endSlowQueryLogging(String sql, long executeStartNanos) {\n+  226: \t\tsqlStatementLogger.logSlowQuery(sql, executeStartNanos, context() );\n   227: \t}\n",
        "uniqueId": "7b8c403df746e127f38d3f5f3efb45b941c36af2_88_114_225_227_95_119",
        "moveFileExist": true,
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 21,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 0,
                "covered": 43
            },
            "LINE": {
                "missed": 0,
                "covered": 14
            },
            "COMPLEXITY": {
                "missed": 0,
                "covered": 1
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        }
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprivate getEventManager() : EventManager extracted from public extract(statement Statement, sql String) : ResultSet in class org.hibernate.engine.jdbc.internal.ResultSetReturnImpl",
        "diffLocations": [
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/engine/jdbc/internal/ResultSetReturnImpl.java",
                "startLine": 88,
                "endLine": 114,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/engine/jdbc/internal/ResultSetReturnImpl.java",
                "startLine": 95,
                "endLine": 119,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/engine/jdbc/internal/ResultSetReturnImpl.java",
                "startLine": 75,
                "endLine": 77,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "@Override\n\tpublic ResultSet extract(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\trs = statement.executeQuery( sql );\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not extract ResultSet\", sql );\n\t\t}\n\t}",
        "filePathBefore": "hibernate-core/src/main/java/org/hibernate/engine/jdbc/internal/ResultSetReturnImpl.java",
        "isPureRefactoring": true,
        "commitId": "7b8c403df746e127f38d3f5f3efb45b941c36af2",
        "packageNameBefore": "org.hibernate.engine.jdbc.internal",
        "classNameBefore": "org.hibernate.engine.jdbc.internal.ResultSetReturnImpl",
        "methodNameBefore": "org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#extract",
        "invokedMethod": "methodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#jdbcExecuteStatementStart\n methodBody: private void jdbcExecuteStatementStart() {\njdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getEventHandler().jdbcExecuteStatementStart();\n}\nmethodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#context\n methodBody: private JdbcSessionContext context() {\nreturn jdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext();\n}\nmethodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#jdbcExecuteStatementEnd\n methodBody: private void jdbcExecuteStatementEnd() {\njdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getEventHandler().jdbcExecuteStatementEnd();\n}\nmethodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#postExtract\n methodBody: private void postExtract(ResultSet rs, Statement st) {\nif(rs != null){jdbcCoordinator.getLogicalConnection().getResourceRegistry().register(rs,st);\n}}",
        "classSignatureBefore": "public class ResultSetReturnImpl implements ResultSetReturn ",
        "methodNameBeforeSet": [
            "org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#extract"
        ],
        "classNameBeforeSet": [
            "org.hibernate.engine.jdbc.internal.ResultSetReturnImpl"
        ],
        "classSignatureBeforeSet": [
            "public class ResultSetReturnImpl implements ResultSetReturn "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.\n */\npackage org.hibernate.engine.jdbc.internal;\n\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\nimport org.hibernate.dialect.Dialect;\nimport org.hibernate.engine.jdbc.spi.JdbcCoordinator;\nimport org.hibernate.engine.jdbc.spi.JdbcServices;\nimport org.hibernate.engine.jdbc.spi.ResultSetReturn;\nimport org.hibernate.engine.jdbc.spi.SqlExceptionHelper;\nimport org.hibernate.engine.jdbc.spi.SqlStatementLogger;\nimport org.hibernate.event.spi.EventManager;\nimport org.hibernate.event.spi.HibernateMonitoringEvent;\nimport org.hibernate.resource.jdbc.spi.JdbcSessionContext;\n\n/**\n * Standard implementation of the ResultSetReturn contract\n *\n * @author Brett Meyer\n */\npublic class ResultSetReturnImpl implements ResultSetReturn {\n\tprivate final JdbcCoordinator jdbcCoordinator;\n\n\tprivate final Dialect dialect;\n\tprivate final SqlStatementLogger sqlStatementLogger;\n\tprivate final SqlExceptionHelper sqlExceptionHelper;\n\n\t/**\n\t * Constructs a ResultSetReturnImpl\n\t *\n\t * @param jdbcCoordinator The JdbcCoordinator\n\t */\n\tpublic ResultSetReturnImpl(JdbcCoordinator jdbcCoordinator, JdbcServices jdbcServices) {\n\t\tthis.jdbcCoordinator = jdbcCoordinator;\n\t\tthis.dialect = jdbcServices.getDialect();\n\t\tthis.sqlStatementLogger = jdbcServices.getSqlStatementLogger();\n\t\tthis.sqlExceptionHelper = jdbcServices.getSqlExceptionHelper();\n\t}\n\n\t@Override\n\tpublic ResultSet extract(PreparedStatement statement, String sql) {\n\t\t// IMPL NOTE : SQL logged by caller\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\trs = statement.executeQuery();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not extract ResultSet\", sql );\n\t\t}\n\t}\n\n\tprivate JdbcSessionContext context() {\n\t\treturn jdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext();\n\t}\n\n\tprivate void jdbcExecuteStatementEnd() {\n\t\tjdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getEventHandler().jdbcExecuteStatementEnd();\n\t}\n\n\tprivate void jdbcExecuteStatementStart() {\n\t\tjdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getEventHandler().jdbcExecuteStatementStart();\n\t}\n\n\t@Override\n\tpublic ResultSet extract(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\trs = statement.executeQuery( sql );\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not extract ResultSet\", sql );\n\t\t}\n\t}\n\n\t@Override\n\tpublic ResultSet execute(PreparedStatement statement, String sql) {\n\t\t// sql logged by StatementPreparerImpl\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\tif ( !statement.execute() ) {\n\t\t\t\t\twhile ( !statement.getMoreResults() && statement.getUpdateCount() != -1 ) {\n\t\t\t\t\t\t// do nothing until we hit the resultset\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trs = statement.getResultSet();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t}\n\n\t@Override\n\tpublic ResultSet execute(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\tif ( !statement.execute( sql ) ) {\n\t\t\t\t\twhile ( !statement.getMoreResults() && statement.getUpdateCount() != -1 ) {\n\t\t\t\t\t\t// do nothing until we hit the resultset\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trs = statement.getResultSet();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t}\n\n\t@Override\n\tpublic int executeUpdate(PreparedStatement statement, String sql) {\n\t\tassert statement != null;\n\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\ttry {\n\t\t\tjdbcExecuteStatementStart();\n\t\t\treturn statement.executeUpdate();\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t\tfinally {\n\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\tjdbcExecuteStatementEnd();\n\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t}\n\t}\n\n\t@Override\n\tpublic int executeUpdate(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\ttry {\n\t\t\tjdbcExecuteStatementStart();\n\t\t\treturn statement.executeUpdate( sql );\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t\tfinally {\n\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\tjdbcExecuteStatementEnd();\n\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t}\n\t}\n\n\tprivate void postExtract(ResultSet rs, Statement st) {\n\t\tif ( rs != null ) {\n\t\t\tjdbcCoordinator.getLogicalConnection().getResourceRegistry().register( rs, st );\n\t\t}\n\t}\n\n}\n",
        "filePathAfter": "hibernate-core/src/main/java/org/hibernate/engine/jdbc/internal/ResultSetReturnImpl.java",
        "sourceCodeAfterForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.\n */\npackage org.hibernate.engine.jdbc.internal;\n\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\nimport org.hibernate.engine.jdbc.spi.JdbcCoordinator;\nimport org.hibernate.engine.jdbc.spi.JdbcServices;\nimport org.hibernate.engine.jdbc.spi.ResultSetReturn;\nimport org.hibernate.engine.jdbc.spi.SqlExceptionHelper;\nimport org.hibernate.engine.jdbc.spi.SqlStatementLogger;\nimport org.hibernate.event.spi.EventManager;\nimport org.hibernate.event.spi.HibernateMonitoringEvent;\nimport org.hibernate.resource.jdbc.spi.JdbcEventHandler;\nimport org.hibernate.resource.jdbc.spi.JdbcSessionContext;\n\n/**\n * Standard implementation of the ResultSetReturn contract\n *\n * @author Brett Meyer\n */\npublic class ResultSetReturnImpl implements ResultSetReturn {\n\tprivate final JdbcCoordinator jdbcCoordinator;\n\n\tprivate final SqlStatementLogger sqlStatementLogger;\n\tprivate final SqlExceptionHelper sqlExceptionHelper;\n\n\t/**\n\t * Constructs a ResultSetReturnImpl\n\t *\n\t * @param jdbcCoordinator The JdbcCoordinator\n\t */\n\tpublic ResultSetReturnImpl(JdbcCoordinator jdbcCoordinator, JdbcServices jdbcServices) {\n\t\tthis.jdbcCoordinator = jdbcCoordinator;\n\t\tthis.sqlStatementLogger = jdbcServices.getSqlStatementLogger();\n\t\tthis.sqlExceptionHelper = jdbcServices.getSqlExceptionHelper();\n\t}\n\n\t@Override\n\tpublic ResultSet extract(PreparedStatement statement, String sql) {\n\t\t// IMPL NOTE : SQL logged by caller\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = getEventManager();\n\t\t\tfinal HibernateMonitoringEvent executionEvent =\n\t\t\t\t\teventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\trs = statement.executeQuery();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( executionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tendSlowQueryLogging(sql, executeStartNanos);\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not extract ResultSet\", sql );\n\t\t}\n\t}\n\n\tprivate EventManager getEventManager() {\n\t\treturn jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t}\n\n\tprivate JdbcEventHandler getEventHandler() {\n\t\treturn jdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getEventHandler();\n\t}\n\n\tprivate JdbcSessionContext context() {\n\t\treturn jdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext();\n\t}\n\n\tprivate void jdbcExecuteStatementEnd() {\n\t\tgetEventHandler().jdbcExecuteStatementEnd();\n\t}\n\n\tprivate void jdbcExecuteStatementStart() {\n\t\tgetEventHandler().jdbcExecuteStatementStart();\n\t}\n\n\t@Override\n\tpublic ResultSet extract(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = beginSlowQueryLogging();\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = getEventManager();\n\t\t\tfinal HibernateMonitoringEvent executionEvent =\n\t\t\t\t\teventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\trs = statement.executeQuery( sql );\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( executionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tendSlowQueryLogging( sql, executeStartNanos );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not extract ResultSet\", sql );\n\t\t}\n\t}\n\n\t@Override\n\tpublic ResultSet execute(PreparedStatement statement, String sql) {\n\t\t// sql logged by StatementPreparerImpl\n\t\tlong executeStartNanos = beginSlowQueryLogging();\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = getEventManager();\n\t\t\tfinal HibernateMonitoringEvent executionEvent =\n\t\t\t\t\teventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\tif ( !statement.execute() ) {\n\t\t\t\t\twhile ( !statement.getMoreResults() && statement.getUpdateCount() != -1 ) {\n\t\t\t\t\t\t// do nothing until we hit the resultset\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trs = statement.getResultSet();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( executionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tendSlowQueryLogging( sql, executeStartNanos );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t}\n\n\t@Override\n\tpublic ResultSet execute(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = beginSlowQueryLogging();\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = getEventManager();\n\t\t\tfinal HibernateMonitoringEvent executionEvent =\n\t\t\t\t\teventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\tif ( !statement.execute( sql ) ) {\n\t\t\t\t\twhile ( !statement.getMoreResults() && statement.getUpdateCount() != -1 ) {\n\t\t\t\t\t\t// do nothing until we hit the resultset\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trs = statement.getResultSet();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( executionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tendSlowQueryLogging( sql, executeStartNanos );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t}\n\n\t@Override\n\tpublic int executeUpdate(PreparedStatement statement, String sql) {\n\t\tassert statement != null;\n\t\tlong executeStartNanos = beginSlowQueryLogging();\n\t\tfinal EventManager eventManager = getEventManager();\n\t\tfinal HibernateMonitoringEvent executionEvent =\n\t\t\t\teventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\ttry {\n\t\t\tjdbcExecuteStatementStart();\n\t\t\treturn statement.executeUpdate();\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t\tfinally {\n\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( executionEvent, sql );\n\t\t\tjdbcExecuteStatementEnd();\n\t\t\tendSlowQueryLogging( sql, executeStartNanos );\n\t\t}\n\t}\n\n\t@Override\n\tpublic int executeUpdate(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = beginSlowQueryLogging();\n\t\tfinal EventManager eventManager = getEventManager();\n\t\tfinal HibernateMonitoringEvent executionEvent =\n\t\t\t\teventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\ttry {\n\t\t\tjdbcExecuteStatementStart();\n\t\t\treturn statement.executeUpdate( sql );\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t\tfinally {\n\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( executionEvent, sql );\n\t\t\tjdbcExecuteStatementEnd();\n\t\t\tendSlowQueryLogging( sql, executeStartNanos );\n\t\t}\n\t}\n\n\tprivate void endSlowQueryLogging(String sql, long executeStartNanos) {\n\t\tsqlStatementLogger.logSlowQuery(sql, executeStartNanos, context() );\n\t}\n\n\tprivate long beginSlowQueryLogging() {\n\t\treturn sqlStatementLogger.getLogSlowQuery() > 0 ? System.nanoTime() : 0;\n\t}\n\n\tprivate void postExtract(ResultSet rs, Statement st) {\n\t\tif ( rs != null ) {\n\t\t\tjdbcCoordinator.getLogicalConnection().getResourceRegistry().register( rs, st );\n\t\t}\n\t}\n\n}\n",
        "diffSourceCodeSet": [
            "private EventManager getEventManager() {\n\t\treturn jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t}"
        ],
        "invokedMethodSet": [
            "methodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#jdbcExecuteStatementStart\n methodBody: private void jdbcExecuteStatementStart() {\njdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getEventHandler().jdbcExecuteStatementStart();\n}",
            "methodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#context\n methodBody: private JdbcSessionContext context() {\nreturn jdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext();\n}",
            "methodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#jdbcExecuteStatementEnd\n methodBody: private void jdbcExecuteStatementEnd() {\njdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getEventHandler().jdbcExecuteStatementEnd();\n}",
            "methodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#postExtract\n methodBody: private void postExtract(ResultSet rs, Statement st) {\nif(rs != null){jdbcCoordinator.getLogicalConnection().getResourceRegistry().register(rs,st);\n}}"
        ],
        "sourceCodeAfterRefactoring": "@Override\n\tpublic ResultSet extract(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = beginSlowQueryLogging();\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = getEventManager();\n\t\t\tfinal HibernateMonitoringEvent executionEvent =\n\t\t\t\t\teventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\trs = statement.executeQuery( sql );\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( executionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tendSlowQueryLogging( sql, executeStartNanos );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not extract ResultSet\", sql );\n\t\t}\n\t}\nprivate EventManager getEventManager() {\n\t\treturn jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t}",
        "diffSourceCode": "-   75: \n-   76: \tprivate JdbcSessionContext context() {\n-   77: \t\treturn jdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext();\n-   88: \t@Override\n-   89: \tpublic ResultSet extract(Statement statement, String sql) {\n-   90: \t\tsqlStatementLogger.logStatement( sql );\n-   91: \t\tlong executeStartNanos = 0;\n-   92: \t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n-   93: \t\t\texecuteStartNanos = System.nanoTime();\n-   94: \t\t}\n-   95: \t\ttry {\n-   96: \t\t\tfinal ResultSet rs;\n-   97: \t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n-   98: \t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n-   99: \t\t\ttry {\n-  100: \t\t\t\tjdbcExecuteStatementStart();\n-  101: \t\t\t\trs = statement.executeQuery( sql );\n-  102: \t\t\t}\n-  103: \t\t\tfinally {\n-  104: \t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n-  105: \t\t\t\tjdbcExecuteStatementEnd();\n-  106: \t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n+   75: \tprivate EventManager getEventManager() {\n+   76: \t\treturn jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n+   77: \t}\n+   88: \t\tgetEventHandler().jdbcExecuteStatementEnd();\n+   89: \t}\n+   90: \n+   91: \tprivate void jdbcExecuteStatementStart() {\n+   92: \t\tgetEventHandler().jdbcExecuteStatementStart();\n+   93: \t}\n+   94: \n+   95: \t@Override\n+   96: \tpublic ResultSet extract(Statement statement, String sql) {\n+   97: \t\tsqlStatementLogger.logStatement( sql );\n+   98: \t\tlong executeStartNanos = beginSlowQueryLogging();\n+   99: \t\ttry {\n+  100: \t\t\tfinal ResultSet rs;\n+  101: \t\t\tfinal EventManager eventManager = getEventManager();\n+  102: \t\t\tfinal HibernateMonitoringEvent executionEvent =\n+  103: \t\t\t\t\teventManager.beginJdbcPreparedStatementExecutionEvent();\n+  104: \t\t\ttry {\n+  105: \t\t\t\tjdbcExecuteStatementStart();\n+  106: \t\t\t\trs = statement.executeQuery( sql );\n   107: \t\t\t}\n-  108: \t\t\tpostExtract( rs, statement );\n-  109: \t\t\treturn rs;\n-  110: \t\t}\n-  111: \t\tcatch (SQLException e) {\n-  112: \t\t\tthrow sqlExceptionHelper.convert( e, \"could not extract ResultSet\", sql );\n-  113: \t\t}\n-  114: \t}\n-  115: \n-  116: \t@Override\n-  117: \tpublic ResultSet execute(PreparedStatement statement, String sql) {\n-  118: \t\t// sql logged by StatementPreparerImpl\n-  119: \t\tlong executeStartNanos = 0;\n+  108: \t\t\tfinally {\n+  109: \t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( executionEvent, sql );\n+  110: \t\t\t\tjdbcExecuteStatementEnd();\n+  111: \t\t\t\tendSlowQueryLogging( sql, executeStartNanos );\n+  112: \t\t\t}\n+  113: \t\t\tpostExtract( rs, statement );\n+  114: \t\t\treturn rs;\n+  115: \t\t}\n+  116: \t\tcatch (SQLException e) {\n+  117: \t\t\tthrow sqlExceptionHelper.convert( e, \"could not extract ResultSet\", sql );\n+  118: \t\t}\n+  119: \t}\n",
        "uniqueId": "7b8c403df746e127f38d3f5f3efb45b941c36af2_88_114_75_77_95_119",
        "moveFileExist": true,
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 21,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 0,
                "covered": 43
            },
            "LINE": {
                "missed": 0,
                "covered": 14
            },
            "COMPLEXITY": {
                "missed": 0,
                "covered": 1
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        }
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprivate endSlowQueryLogging(sql String, executeStartNanos long) : void extracted from public extract(statement PreparedStatement, sql String) : ResultSet in class org.hibernate.engine.jdbc.internal.ResultSetReturnImpl",
        "diffLocations": [
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/engine/jdbc/internal/ResultSetReturnImpl.java",
                "startLine": 48,
                "endLine": 74,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/engine/jdbc/internal/ResultSetReturnImpl.java",
                "startLine": 46,
                "endLine": 73,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/engine/jdbc/internal/ResultSetReturnImpl.java",
                "startLine": 225,
                "endLine": 227,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "@Override\n\tpublic ResultSet extract(PreparedStatement statement, String sql) {\n\t\t// IMPL NOTE : SQL logged by caller\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\trs = statement.executeQuery();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not extract ResultSet\", sql );\n\t\t}\n\t}",
        "filePathBefore": "hibernate-core/src/main/java/org/hibernate/engine/jdbc/internal/ResultSetReturnImpl.java",
        "isPureRefactoring": true,
        "commitId": "7b8c403df746e127f38d3f5f3efb45b941c36af2",
        "packageNameBefore": "org.hibernate.engine.jdbc.internal",
        "classNameBefore": "org.hibernate.engine.jdbc.internal.ResultSetReturnImpl",
        "methodNameBefore": "org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#extract",
        "invokedMethod": "methodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#jdbcExecuteStatementStart\n methodBody: private void jdbcExecuteStatementStart() {\njdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getEventHandler().jdbcExecuteStatementStart();\n}\nmethodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#context\n methodBody: private JdbcSessionContext context() {\nreturn jdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext();\n}\nmethodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#jdbcExecuteStatementEnd\n methodBody: private void jdbcExecuteStatementEnd() {\njdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getEventHandler().jdbcExecuteStatementEnd();\n}\nmethodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#postExtract\n methodBody: private void postExtract(ResultSet rs, Statement st) {\nif(rs != null){jdbcCoordinator.getLogicalConnection().getResourceRegistry().register(rs,st);\n}}",
        "classSignatureBefore": "public class ResultSetReturnImpl implements ResultSetReturn ",
        "methodNameBeforeSet": [
            "org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#extract"
        ],
        "classNameBeforeSet": [
            "org.hibernate.engine.jdbc.internal.ResultSetReturnImpl"
        ],
        "classSignatureBeforeSet": [
            "public class ResultSetReturnImpl implements ResultSetReturn "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.\n */\npackage org.hibernate.engine.jdbc.internal;\n\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\nimport org.hibernate.dialect.Dialect;\nimport org.hibernate.engine.jdbc.spi.JdbcCoordinator;\nimport org.hibernate.engine.jdbc.spi.JdbcServices;\nimport org.hibernate.engine.jdbc.spi.ResultSetReturn;\nimport org.hibernate.engine.jdbc.spi.SqlExceptionHelper;\nimport org.hibernate.engine.jdbc.spi.SqlStatementLogger;\nimport org.hibernate.event.spi.EventManager;\nimport org.hibernate.event.spi.HibernateMonitoringEvent;\nimport org.hibernate.resource.jdbc.spi.JdbcSessionContext;\n\n/**\n * Standard implementation of the ResultSetReturn contract\n *\n * @author Brett Meyer\n */\npublic class ResultSetReturnImpl implements ResultSetReturn {\n\tprivate final JdbcCoordinator jdbcCoordinator;\n\n\tprivate final Dialect dialect;\n\tprivate final SqlStatementLogger sqlStatementLogger;\n\tprivate final SqlExceptionHelper sqlExceptionHelper;\n\n\t/**\n\t * Constructs a ResultSetReturnImpl\n\t *\n\t * @param jdbcCoordinator The JdbcCoordinator\n\t */\n\tpublic ResultSetReturnImpl(JdbcCoordinator jdbcCoordinator, JdbcServices jdbcServices) {\n\t\tthis.jdbcCoordinator = jdbcCoordinator;\n\t\tthis.dialect = jdbcServices.getDialect();\n\t\tthis.sqlStatementLogger = jdbcServices.getSqlStatementLogger();\n\t\tthis.sqlExceptionHelper = jdbcServices.getSqlExceptionHelper();\n\t}\n\n\t@Override\n\tpublic ResultSet extract(PreparedStatement statement, String sql) {\n\t\t// IMPL NOTE : SQL logged by caller\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\trs = statement.executeQuery();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not extract ResultSet\", sql );\n\t\t}\n\t}\n\n\tprivate JdbcSessionContext context() {\n\t\treturn jdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext();\n\t}\n\n\tprivate void jdbcExecuteStatementEnd() {\n\t\tjdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getEventHandler().jdbcExecuteStatementEnd();\n\t}\n\n\tprivate void jdbcExecuteStatementStart() {\n\t\tjdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getEventHandler().jdbcExecuteStatementStart();\n\t}\n\n\t@Override\n\tpublic ResultSet extract(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\trs = statement.executeQuery( sql );\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not extract ResultSet\", sql );\n\t\t}\n\t}\n\n\t@Override\n\tpublic ResultSet execute(PreparedStatement statement, String sql) {\n\t\t// sql logged by StatementPreparerImpl\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\tif ( !statement.execute() ) {\n\t\t\t\t\twhile ( !statement.getMoreResults() && statement.getUpdateCount() != -1 ) {\n\t\t\t\t\t\t// do nothing until we hit the resultset\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trs = statement.getResultSet();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t}\n\n\t@Override\n\tpublic ResultSet execute(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\tif ( !statement.execute( sql ) ) {\n\t\t\t\t\twhile ( !statement.getMoreResults() && statement.getUpdateCount() != -1 ) {\n\t\t\t\t\t\t// do nothing until we hit the resultset\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trs = statement.getResultSet();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t}\n\n\t@Override\n\tpublic int executeUpdate(PreparedStatement statement, String sql) {\n\t\tassert statement != null;\n\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\ttry {\n\t\t\tjdbcExecuteStatementStart();\n\t\t\treturn statement.executeUpdate();\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t\tfinally {\n\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\tjdbcExecuteStatementEnd();\n\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t}\n\t}\n\n\t@Override\n\tpublic int executeUpdate(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\ttry {\n\t\t\tjdbcExecuteStatementStart();\n\t\t\treturn statement.executeUpdate( sql );\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t\tfinally {\n\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\tjdbcExecuteStatementEnd();\n\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t}\n\t}\n\n\tprivate void postExtract(ResultSet rs, Statement st) {\n\t\tif ( rs != null ) {\n\t\t\tjdbcCoordinator.getLogicalConnection().getResourceRegistry().register( rs, st );\n\t\t}\n\t}\n\n}\n",
        "filePathAfter": "hibernate-core/src/main/java/org/hibernate/engine/jdbc/internal/ResultSetReturnImpl.java",
        "sourceCodeAfterForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.\n */\npackage org.hibernate.engine.jdbc.internal;\n\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\nimport org.hibernate.engine.jdbc.spi.JdbcCoordinator;\nimport org.hibernate.engine.jdbc.spi.JdbcServices;\nimport org.hibernate.engine.jdbc.spi.ResultSetReturn;\nimport org.hibernate.engine.jdbc.spi.SqlExceptionHelper;\nimport org.hibernate.engine.jdbc.spi.SqlStatementLogger;\nimport org.hibernate.event.spi.EventManager;\nimport org.hibernate.event.spi.HibernateMonitoringEvent;\nimport org.hibernate.resource.jdbc.spi.JdbcEventHandler;\nimport org.hibernate.resource.jdbc.spi.JdbcSessionContext;\n\n/**\n * Standard implementation of the ResultSetReturn contract\n *\n * @author Brett Meyer\n */\npublic class ResultSetReturnImpl implements ResultSetReturn {\n\tprivate final JdbcCoordinator jdbcCoordinator;\n\n\tprivate final SqlStatementLogger sqlStatementLogger;\n\tprivate final SqlExceptionHelper sqlExceptionHelper;\n\n\t/**\n\t * Constructs a ResultSetReturnImpl\n\t *\n\t * @param jdbcCoordinator The JdbcCoordinator\n\t */\n\tpublic ResultSetReturnImpl(JdbcCoordinator jdbcCoordinator, JdbcServices jdbcServices) {\n\t\tthis.jdbcCoordinator = jdbcCoordinator;\n\t\tthis.sqlStatementLogger = jdbcServices.getSqlStatementLogger();\n\t\tthis.sqlExceptionHelper = jdbcServices.getSqlExceptionHelper();\n\t}\n\n\t@Override\n\tpublic ResultSet extract(PreparedStatement statement, String sql) {\n\t\t// IMPL NOTE : SQL logged by caller\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = getEventManager();\n\t\t\tfinal HibernateMonitoringEvent executionEvent =\n\t\t\t\t\teventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\trs = statement.executeQuery();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( executionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tendSlowQueryLogging(sql, executeStartNanos);\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not extract ResultSet\", sql );\n\t\t}\n\t}\n\n\tprivate EventManager getEventManager() {\n\t\treturn jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t}\n\n\tprivate JdbcEventHandler getEventHandler() {\n\t\treturn jdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getEventHandler();\n\t}\n\n\tprivate JdbcSessionContext context() {\n\t\treturn jdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext();\n\t}\n\n\tprivate void jdbcExecuteStatementEnd() {\n\t\tgetEventHandler().jdbcExecuteStatementEnd();\n\t}\n\n\tprivate void jdbcExecuteStatementStart() {\n\t\tgetEventHandler().jdbcExecuteStatementStart();\n\t}\n\n\t@Override\n\tpublic ResultSet extract(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = beginSlowQueryLogging();\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = getEventManager();\n\t\t\tfinal HibernateMonitoringEvent executionEvent =\n\t\t\t\t\teventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\trs = statement.executeQuery( sql );\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( executionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tendSlowQueryLogging( sql, executeStartNanos );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not extract ResultSet\", sql );\n\t\t}\n\t}\n\n\t@Override\n\tpublic ResultSet execute(PreparedStatement statement, String sql) {\n\t\t// sql logged by StatementPreparerImpl\n\t\tlong executeStartNanos = beginSlowQueryLogging();\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = getEventManager();\n\t\t\tfinal HibernateMonitoringEvent executionEvent =\n\t\t\t\t\teventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\tif ( !statement.execute() ) {\n\t\t\t\t\twhile ( !statement.getMoreResults() && statement.getUpdateCount() != -1 ) {\n\t\t\t\t\t\t// do nothing until we hit the resultset\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trs = statement.getResultSet();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( executionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tendSlowQueryLogging( sql, executeStartNanos );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t}\n\n\t@Override\n\tpublic ResultSet execute(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = beginSlowQueryLogging();\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = getEventManager();\n\t\t\tfinal HibernateMonitoringEvent executionEvent =\n\t\t\t\t\teventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\tif ( !statement.execute( sql ) ) {\n\t\t\t\t\twhile ( !statement.getMoreResults() && statement.getUpdateCount() != -1 ) {\n\t\t\t\t\t\t// do nothing until we hit the resultset\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trs = statement.getResultSet();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( executionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tendSlowQueryLogging( sql, executeStartNanos );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t}\n\n\t@Override\n\tpublic int executeUpdate(PreparedStatement statement, String sql) {\n\t\tassert statement != null;\n\t\tlong executeStartNanos = beginSlowQueryLogging();\n\t\tfinal EventManager eventManager = getEventManager();\n\t\tfinal HibernateMonitoringEvent executionEvent =\n\t\t\t\teventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\ttry {\n\t\t\tjdbcExecuteStatementStart();\n\t\t\treturn statement.executeUpdate();\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t\tfinally {\n\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( executionEvent, sql );\n\t\t\tjdbcExecuteStatementEnd();\n\t\t\tendSlowQueryLogging( sql, executeStartNanos );\n\t\t}\n\t}\n\n\t@Override\n\tpublic int executeUpdate(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = beginSlowQueryLogging();\n\t\tfinal EventManager eventManager = getEventManager();\n\t\tfinal HibernateMonitoringEvent executionEvent =\n\t\t\t\teventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\ttry {\n\t\t\tjdbcExecuteStatementStart();\n\t\t\treturn statement.executeUpdate( sql );\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t\tfinally {\n\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( executionEvent, sql );\n\t\t\tjdbcExecuteStatementEnd();\n\t\t\tendSlowQueryLogging( sql, executeStartNanos );\n\t\t}\n\t}\n\n\tprivate void endSlowQueryLogging(String sql, long executeStartNanos) {\n\t\tsqlStatementLogger.logSlowQuery(sql, executeStartNanos, context() );\n\t}\n\n\tprivate long beginSlowQueryLogging() {\n\t\treturn sqlStatementLogger.getLogSlowQuery() > 0 ? System.nanoTime() : 0;\n\t}\n\n\tprivate void postExtract(ResultSet rs, Statement st) {\n\t\tif ( rs != null ) {\n\t\t\tjdbcCoordinator.getLogicalConnection().getResourceRegistry().register( rs, st );\n\t\t}\n\t}\n\n}\n",
        "diffSourceCodeSet": [
            "private void endSlowQueryLogging(String sql, long executeStartNanos) {\n\t\tsqlStatementLogger.logSlowQuery(sql, executeStartNanos, context() );\n\t}"
        ],
        "invokedMethodSet": [
            "methodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#jdbcExecuteStatementStart\n methodBody: private void jdbcExecuteStatementStart() {\njdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getEventHandler().jdbcExecuteStatementStart();\n}",
            "methodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#context\n methodBody: private JdbcSessionContext context() {\nreturn jdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext();\n}",
            "methodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#jdbcExecuteStatementEnd\n methodBody: private void jdbcExecuteStatementEnd() {\njdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getEventHandler().jdbcExecuteStatementEnd();\n}",
            "methodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#postExtract\n methodBody: private void postExtract(ResultSet rs, Statement st) {\nif(rs != null){jdbcCoordinator.getLogicalConnection().getResourceRegistry().register(rs,st);\n}}"
        ],
        "sourceCodeAfterRefactoring": "@Override\n\tpublic ResultSet extract(PreparedStatement statement, String sql) {\n\t\t// IMPL NOTE : SQL logged by caller\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = getEventManager();\n\t\t\tfinal HibernateMonitoringEvent executionEvent =\n\t\t\t\t\teventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\trs = statement.executeQuery();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( executionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tendSlowQueryLogging(sql, executeStartNanos);\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not extract ResultSet\", sql );\n\t\t}\n\t}\nprivate void endSlowQueryLogging(String sql, long executeStartNanos) {\n\t\tsqlStatementLogger.logSlowQuery(sql, executeStartNanos, context() );\n\t}",
        "diffSourceCode": "-   46: \t}\n-   47: \n-   48: \t@Override\n-   49: \tpublic ResultSet extract(PreparedStatement statement, String sql) {\n-   50: \t\t// IMPL NOTE : SQL logged by caller\n-   51: \t\tlong executeStartNanos = 0;\n-   52: \t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n-   53: \t\t\texecuteStartNanos = System.nanoTime();\n-   54: \t\t}\n-   55: \t\ttry {\n-   56: \t\t\tfinal ResultSet rs;\n-   57: \t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n-   58: \t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n-   59: \t\t\ttry {\n-   60: \t\t\t\tjdbcExecuteStatementStart();\n-   61: \t\t\t\trs = statement.executeQuery();\n-   62: \t\t\t}\n-   63: \t\t\tfinally {\n-   64: \t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n-   65: \t\t\t\tjdbcExecuteStatementEnd();\n-   66: \t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n-   67: \t\t\t}\n-   68: \t\t\tpostExtract( rs, statement );\n-   69: \t\t\treturn rs;\n-   70: \t\t}\n-   71: \t\tcatch (SQLException e) {\n-   72: \t\t\tthrow sqlExceptionHelper.convert( e, \"could not extract ResultSet\", sql );\n-   73: \t\t}\n-   74: \t}\n-  225: \t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n-  226: \t\t}\n+   46: \t@Override\n+   47: \tpublic ResultSet extract(PreparedStatement statement, String sql) {\n+   48: \t\t// IMPL NOTE : SQL logged by caller\n+   49: \t\tlong executeStartNanos = 0;\n+   50: \t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n+   51: \t\t\texecuteStartNanos = System.nanoTime();\n+   52: \t\t}\n+   53: \t\ttry {\n+   54: \t\t\tfinal ResultSet rs;\n+   55: \t\t\tfinal EventManager eventManager = getEventManager();\n+   56: \t\t\tfinal HibernateMonitoringEvent executionEvent =\n+   57: \t\t\t\t\teventManager.beginJdbcPreparedStatementExecutionEvent();\n+   58: \t\t\ttry {\n+   59: \t\t\t\tjdbcExecuteStatementStart();\n+   60: \t\t\t\trs = statement.executeQuery();\n+   61: \t\t\t}\n+   62: \t\t\tfinally {\n+   63: \t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( executionEvent, sql );\n+   64: \t\t\t\tjdbcExecuteStatementEnd();\n+   65: \t\t\t\tendSlowQueryLogging(sql, executeStartNanos);\n+   66: \t\t\t}\n+   67: \t\t\tpostExtract( rs, statement );\n+   68: \t\t\treturn rs;\n+   69: \t\t}\n+   70: \t\tcatch (SQLException e) {\n+   71: \t\t\tthrow sqlExceptionHelper.convert( e, \"could not extract ResultSet\", sql );\n+   72: \t\t}\n+   73: \t}\n+   74: \n+  225: \tprivate void endSlowQueryLogging(String sql, long executeStartNanos) {\n+  226: \t\tsqlStatementLogger.logSlowQuery(sql, executeStartNanos, context() );\n   227: \t}\n",
        "uniqueId": "7b8c403df746e127f38d3f5f3efb45b941c36af2_48_74_225_227_46_73",
        "moveFileExist": true,
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 21,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 0,
                "covered": 43
            },
            "LINE": {
                "missed": 0,
                "covered": 14
            },
            "COMPLEXITY": {
                "missed": 0,
                "covered": 1
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        }
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprivate getEventManager() : EventManager extracted from public extract(statement PreparedStatement, sql String) : ResultSet in class org.hibernate.engine.jdbc.internal.ResultSetReturnImpl",
        "diffLocations": [
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/engine/jdbc/internal/ResultSetReturnImpl.java",
                "startLine": 48,
                "endLine": 74,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/engine/jdbc/internal/ResultSetReturnImpl.java",
                "startLine": 46,
                "endLine": 73,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/engine/jdbc/internal/ResultSetReturnImpl.java",
                "startLine": 75,
                "endLine": 77,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "@Override\n\tpublic ResultSet extract(PreparedStatement statement, String sql) {\n\t\t// IMPL NOTE : SQL logged by caller\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\trs = statement.executeQuery();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not extract ResultSet\", sql );\n\t\t}\n\t}",
        "filePathBefore": "hibernate-core/src/main/java/org/hibernate/engine/jdbc/internal/ResultSetReturnImpl.java",
        "isPureRefactoring": true,
        "commitId": "7b8c403df746e127f38d3f5f3efb45b941c36af2",
        "packageNameBefore": "org.hibernate.engine.jdbc.internal",
        "classNameBefore": "org.hibernate.engine.jdbc.internal.ResultSetReturnImpl",
        "methodNameBefore": "org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#extract",
        "invokedMethod": "methodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#jdbcExecuteStatementStart\n methodBody: private void jdbcExecuteStatementStart() {\njdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getEventHandler().jdbcExecuteStatementStart();\n}\nmethodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#context\n methodBody: private JdbcSessionContext context() {\nreturn jdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext();\n}\nmethodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#jdbcExecuteStatementEnd\n methodBody: private void jdbcExecuteStatementEnd() {\njdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getEventHandler().jdbcExecuteStatementEnd();\n}\nmethodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#postExtract\n methodBody: private void postExtract(ResultSet rs, Statement st) {\nif(rs != null){jdbcCoordinator.getLogicalConnection().getResourceRegistry().register(rs,st);\n}}",
        "classSignatureBefore": "public class ResultSetReturnImpl implements ResultSetReturn ",
        "methodNameBeforeSet": [
            "org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#extract"
        ],
        "classNameBeforeSet": [
            "org.hibernate.engine.jdbc.internal.ResultSetReturnImpl"
        ],
        "classSignatureBeforeSet": [
            "public class ResultSetReturnImpl implements ResultSetReturn "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.\n */\npackage org.hibernate.engine.jdbc.internal;\n\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\nimport org.hibernate.dialect.Dialect;\nimport org.hibernate.engine.jdbc.spi.JdbcCoordinator;\nimport org.hibernate.engine.jdbc.spi.JdbcServices;\nimport org.hibernate.engine.jdbc.spi.ResultSetReturn;\nimport org.hibernate.engine.jdbc.spi.SqlExceptionHelper;\nimport org.hibernate.engine.jdbc.spi.SqlStatementLogger;\nimport org.hibernate.event.spi.EventManager;\nimport org.hibernate.event.spi.HibernateMonitoringEvent;\nimport org.hibernate.resource.jdbc.spi.JdbcSessionContext;\n\n/**\n * Standard implementation of the ResultSetReturn contract\n *\n * @author Brett Meyer\n */\npublic class ResultSetReturnImpl implements ResultSetReturn {\n\tprivate final JdbcCoordinator jdbcCoordinator;\n\n\tprivate final Dialect dialect;\n\tprivate final SqlStatementLogger sqlStatementLogger;\n\tprivate final SqlExceptionHelper sqlExceptionHelper;\n\n\t/**\n\t * Constructs a ResultSetReturnImpl\n\t *\n\t * @param jdbcCoordinator The JdbcCoordinator\n\t */\n\tpublic ResultSetReturnImpl(JdbcCoordinator jdbcCoordinator, JdbcServices jdbcServices) {\n\t\tthis.jdbcCoordinator = jdbcCoordinator;\n\t\tthis.dialect = jdbcServices.getDialect();\n\t\tthis.sqlStatementLogger = jdbcServices.getSqlStatementLogger();\n\t\tthis.sqlExceptionHelper = jdbcServices.getSqlExceptionHelper();\n\t}\n\n\t@Override\n\tpublic ResultSet extract(PreparedStatement statement, String sql) {\n\t\t// IMPL NOTE : SQL logged by caller\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\trs = statement.executeQuery();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not extract ResultSet\", sql );\n\t\t}\n\t}\n\n\tprivate JdbcSessionContext context() {\n\t\treturn jdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext();\n\t}\n\n\tprivate void jdbcExecuteStatementEnd() {\n\t\tjdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getEventHandler().jdbcExecuteStatementEnd();\n\t}\n\n\tprivate void jdbcExecuteStatementStart() {\n\t\tjdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getEventHandler().jdbcExecuteStatementStart();\n\t}\n\n\t@Override\n\tpublic ResultSet extract(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\trs = statement.executeQuery( sql );\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not extract ResultSet\", sql );\n\t\t}\n\t}\n\n\t@Override\n\tpublic ResultSet execute(PreparedStatement statement, String sql) {\n\t\t// sql logged by StatementPreparerImpl\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\tif ( !statement.execute() ) {\n\t\t\t\t\twhile ( !statement.getMoreResults() && statement.getUpdateCount() != -1 ) {\n\t\t\t\t\t\t// do nothing until we hit the resultset\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trs = statement.getResultSet();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t}\n\n\t@Override\n\tpublic ResultSet execute(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\tif ( !statement.execute( sql ) ) {\n\t\t\t\t\twhile ( !statement.getMoreResults() && statement.getUpdateCount() != -1 ) {\n\t\t\t\t\t\t// do nothing until we hit the resultset\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trs = statement.getResultSet();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t}\n\n\t@Override\n\tpublic int executeUpdate(PreparedStatement statement, String sql) {\n\t\tassert statement != null;\n\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\ttry {\n\t\t\tjdbcExecuteStatementStart();\n\t\t\treturn statement.executeUpdate();\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t\tfinally {\n\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\tjdbcExecuteStatementEnd();\n\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t}\n\t}\n\n\t@Override\n\tpublic int executeUpdate(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\ttry {\n\t\t\tjdbcExecuteStatementStart();\n\t\t\treturn statement.executeUpdate( sql );\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t\tfinally {\n\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\tjdbcExecuteStatementEnd();\n\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t}\n\t}\n\n\tprivate void postExtract(ResultSet rs, Statement st) {\n\t\tif ( rs != null ) {\n\t\t\tjdbcCoordinator.getLogicalConnection().getResourceRegistry().register( rs, st );\n\t\t}\n\t}\n\n}\n",
        "filePathAfter": "hibernate-core/src/main/java/org/hibernate/engine/jdbc/internal/ResultSetReturnImpl.java",
        "sourceCodeAfterForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.\n */\npackage org.hibernate.engine.jdbc.internal;\n\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\nimport org.hibernate.engine.jdbc.spi.JdbcCoordinator;\nimport org.hibernate.engine.jdbc.spi.JdbcServices;\nimport org.hibernate.engine.jdbc.spi.ResultSetReturn;\nimport org.hibernate.engine.jdbc.spi.SqlExceptionHelper;\nimport org.hibernate.engine.jdbc.spi.SqlStatementLogger;\nimport org.hibernate.event.spi.EventManager;\nimport org.hibernate.event.spi.HibernateMonitoringEvent;\nimport org.hibernate.resource.jdbc.spi.JdbcEventHandler;\nimport org.hibernate.resource.jdbc.spi.JdbcSessionContext;\n\n/**\n * Standard implementation of the ResultSetReturn contract\n *\n * @author Brett Meyer\n */\npublic class ResultSetReturnImpl implements ResultSetReturn {\n\tprivate final JdbcCoordinator jdbcCoordinator;\n\n\tprivate final SqlStatementLogger sqlStatementLogger;\n\tprivate final SqlExceptionHelper sqlExceptionHelper;\n\n\t/**\n\t * Constructs a ResultSetReturnImpl\n\t *\n\t * @param jdbcCoordinator The JdbcCoordinator\n\t */\n\tpublic ResultSetReturnImpl(JdbcCoordinator jdbcCoordinator, JdbcServices jdbcServices) {\n\t\tthis.jdbcCoordinator = jdbcCoordinator;\n\t\tthis.sqlStatementLogger = jdbcServices.getSqlStatementLogger();\n\t\tthis.sqlExceptionHelper = jdbcServices.getSqlExceptionHelper();\n\t}\n\n\t@Override\n\tpublic ResultSet extract(PreparedStatement statement, String sql) {\n\t\t// IMPL NOTE : SQL logged by caller\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = getEventManager();\n\t\t\tfinal HibernateMonitoringEvent executionEvent =\n\t\t\t\t\teventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\trs = statement.executeQuery();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( executionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tendSlowQueryLogging(sql, executeStartNanos);\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not extract ResultSet\", sql );\n\t\t}\n\t}\n\n\tprivate EventManager getEventManager() {\n\t\treturn jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t}\n\n\tprivate JdbcEventHandler getEventHandler() {\n\t\treturn jdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getEventHandler();\n\t}\n\n\tprivate JdbcSessionContext context() {\n\t\treturn jdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext();\n\t}\n\n\tprivate void jdbcExecuteStatementEnd() {\n\t\tgetEventHandler().jdbcExecuteStatementEnd();\n\t}\n\n\tprivate void jdbcExecuteStatementStart() {\n\t\tgetEventHandler().jdbcExecuteStatementStart();\n\t}\n\n\t@Override\n\tpublic ResultSet extract(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = beginSlowQueryLogging();\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = getEventManager();\n\t\t\tfinal HibernateMonitoringEvent executionEvent =\n\t\t\t\t\teventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\trs = statement.executeQuery( sql );\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( executionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tendSlowQueryLogging( sql, executeStartNanos );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not extract ResultSet\", sql );\n\t\t}\n\t}\n\n\t@Override\n\tpublic ResultSet execute(PreparedStatement statement, String sql) {\n\t\t// sql logged by StatementPreparerImpl\n\t\tlong executeStartNanos = beginSlowQueryLogging();\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = getEventManager();\n\t\t\tfinal HibernateMonitoringEvent executionEvent =\n\t\t\t\t\teventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\tif ( !statement.execute() ) {\n\t\t\t\t\twhile ( !statement.getMoreResults() && statement.getUpdateCount() != -1 ) {\n\t\t\t\t\t\t// do nothing until we hit the resultset\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trs = statement.getResultSet();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( executionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tendSlowQueryLogging( sql, executeStartNanos );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t}\n\n\t@Override\n\tpublic ResultSet execute(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = beginSlowQueryLogging();\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = getEventManager();\n\t\t\tfinal HibernateMonitoringEvent executionEvent =\n\t\t\t\t\teventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\tif ( !statement.execute( sql ) ) {\n\t\t\t\t\twhile ( !statement.getMoreResults() && statement.getUpdateCount() != -1 ) {\n\t\t\t\t\t\t// do nothing until we hit the resultset\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trs = statement.getResultSet();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( executionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tendSlowQueryLogging( sql, executeStartNanos );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t}\n\n\t@Override\n\tpublic int executeUpdate(PreparedStatement statement, String sql) {\n\t\tassert statement != null;\n\t\tlong executeStartNanos = beginSlowQueryLogging();\n\t\tfinal EventManager eventManager = getEventManager();\n\t\tfinal HibernateMonitoringEvent executionEvent =\n\t\t\t\teventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\ttry {\n\t\t\tjdbcExecuteStatementStart();\n\t\t\treturn statement.executeUpdate();\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t\tfinally {\n\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( executionEvent, sql );\n\t\t\tjdbcExecuteStatementEnd();\n\t\t\tendSlowQueryLogging( sql, executeStartNanos );\n\t\t}\n\t}\n\n\t@Override\n\tpublic int executeUpdate(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = beginSlowQueryLogging();\n\t\tfinal EventManager eventManager = getEventManager();\n\t\tfinal HibernateMonitoringEvent executionEvent =\n\t\t\t\teventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\ttry {\n\t\t\tjdbcExecuteStatementStart();\n\t\t\treturn statement.executeUpdate( sql );\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t\tfinally {\n\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( executionEvent, sql );\n\t\t\tjdbcExecuteStatementEnd();\n\t\t\tendSlowQueryLogging( sql, executeStartNanos );\n\t\t}\n\t}\n\n\tprivate void endSlowQueryLogging(String sql, long executeStartNanos) {\n\t\tsqlStatementLogger.logSlowQuery(sql, executeStartNanos, context() );\n\t}\n\n\tprivate long beginSlowQueryLogging() {\n\t\treturn sqlStatementLogger.getLogSlowQuery() > 0 ? System.nanoTime() : 0;\n\t}\n\n\tprivate void postExtract(ResultSet rs, Statement st) {\n\t\tif ( rs != null ) {\n\t\t\tjdbcCoordinator.getLogicalConnection().getResourceRegistry().register( rs, st );\n\t\t}\n\t}\n\n}\n",
        "diffSourceCodeSet": [
            "private EventManager getEventManager() {\n\t\treturn jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t}"
        ],
        "invokedMethodSet": [
            "methodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#jdbcExecuteStatementStart\n methodBody: private void jdbcExecuteStatementStart() {\njdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getEventHandler().jdbcExecuteStatementStart();\n}",
            "methodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#context\n methodBody: private JdbcSessionContext context() {\nreturn jdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext();\n}",
            "methodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#jdbcExecuteStatementEnd\n methodBody: private void jdbcExecuteStatementEnd() {\njdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getEventHandler().jdbcExecuteStatementEnd();\n}",
            "methodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#postExtract\n methodBody: private void postExtract(ResultSet rs, Statement st) {\nif(rs != null){jdbcCoordinator.getLogicalConnection().getResourceRegistry().register(rs,st);\n}}"
        ],
        "sourceCodeAfterRefactoring": "@Override\n\tpublic ResultSet extract(PreparedStatement statement, String sql) {\n\t\t// IMPL NOTE : SQL logged by caller\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = getEventManager();\n\t\t\tfinal HibernateMonitoringEvent executionEvent =\n\t\t\t\t\teventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\trs = statement.executeQuery();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( executionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tendSlowQueryLogging(sql, executeStartNanos);\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not extract ResultSet\", sql );\n\t\t}\n\t}\nprivate EventManager getEventManager() {\n\t\treturn jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t}",
        "diffSourceCode": "-   46: \t}\n-   47: \n-   48: \t@Override\n-   49: \tpublic ResultSet extract(PreparedStatement statement, String sql) {\n-   50: \t\t// IMPL NOTE : SQL logged by caller\n-   51: \t\tlong executeStartNanos = 0;\n-   52: \t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n-   53: \t\t\texecuteStartNanos = System.nanoTime();\n-   54: \t\t}\n-   55: \t\ttry {\n-   56: \t\t\tfinal ResultSet rs;\n-   57: \t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n-   58: \t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n-   59: \t\t\ttry {\n-   60: \t\t\t\tjdbcExecuteStatementStart();\n-   61: \t\t\t\trs = statement.executeQuery();\n-   62: \t\t\t}\n-   63: \t\t\tfinally {\n-   64: \t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n-   65: \t\t\t\tjdbcExecuteStatementEnd();\n-   66: \t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n-   67: \t\t\t}\n-   68: \t\t\tpostExtract( rs, statement );\n-   69: \t\t\treturn rs;\n-   70: \t\t}\n-   71: \t\tcatch (SQLException e) {\n-   72: \t\t\tthrow sqlExceptionHelper.convert( e, \"could not extract ResultSet\", sql );\n-   73: \t\t}\n-   74: \t}\n-   75: \n-   76: \tprivate JdbcSessionContext context() {\n-   77: \t\treturn jdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext();\n+   46: \t@Override\n+   47: \tpublic ResultSet extract(PreparedStatement statement, String sql) {\n+   48: \t\t// IMPL NOTE : SQL logged by caller\n+   49: \t\tlong executeStartNanos = 0;\n+   50: \t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n+   51: \t\t\texecuteStartNanos = System.nanoTime();\n+   52: \t\t}\n+   53: \t\ttry {\n+   54: \t\t\tfinal ResultSet rs;\n+   55: \t\t\tfinal EventManager eventManager = getEventManager();\n+   56: \t\t\tfinal HibernateMonitoringEvent executionEvent =\n+   57: \t\t\t\t\teventManager.beginJdbcPreparedStatementExecutionEvent();\n+   58: \t\t\ttry {\n+   59: \t\t\t\tjdbcExecuteStatementStart();\n+   60: \t\t\t\trs = statement.executeQuery();\n+   61: \t\t\t}\n+   62: \t\t\tfinally {\n+   63: \t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( executionEvent, sql );\n+   64: \t\t\t\tjdbcExecuteStatementEnd();\n+   65: \t\t\t\tendSlowQueryLogging(sql, executeStartNanos);\n+   66: \t\t\t}\n+   67: \t\t\tpostExtract( rs, statement );\n+   68: \t\t\treturn rs;\n+   69: \t\t}\n+   70: \t\tcatch (SQLException e) {\n+   71: \t\t\tthrow sqlExceptionHelper.convert( e, \"could not extract ResultSet\", sql );\n+   72: \t\t}\n+   73: \t}\n+   74: \n+   75: \tprivate EventManager getEventManager() {\n+   76: \t\treturn jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n+   77: \t}\n",
        "uniqueId": "7b8c403df746e127f38d3f5f3efb45b941c36af2_48_74_75_77_46_73",
        "moveFileExist": true,
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 21,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 0,
                "covered": 43
            },
            "LINE": {
                "missed": 0,
                "covered": 14
            },
            "COMPLEXITY": {
                "missed": 0,
                "covered": 1
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        }
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprivate sequenceInformation(connection Connection, jdbcEnvironment JdbcEnvironment) : Iterable<SequenceInformation> extracted from private fetchSequenceInformation(sequenceName String) : SequenceInformation in class org.hibernate.orm.test.dialect.functional.OracleDialectSequenceInformationTest",
        "diffLocations": [
            {
                "filePath": "hibernate-core/src/test/java/org/hibernate/orm/test/dialect/functional/OracleDialectSequenceInformationTest.java",
                "startLine": 74,
                "endLine": 110,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/test/java/org/hibernate/orm/test/dialect/functional/OracleDialectSequenceInformationTest.java",
                "startLine": 74,
                "endLine": 89,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/test/java/org/hibernate/orm/test/dialect/functional/OracleDialectSequenceInformationTest.java",
                "startLine": 95,
                "endLine": 110,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "private SequenceInformation fetchSequenceInformation(String sequenceName) throws SQLException {\n\t\treturn TransactionUtil.doWithJDBC(\n\t\t\t\tsessionFactory().getServiceRegistry(),\n\t\t\t\tconnection -> {\n\t\t\t\t\tJdbcEnvironment jdbcEnvironment = sessionFactory().getJdbcServices().getJdbcEnvironment();\n\t\t\t\t\tSequenceInformationExtractorOracleDatabaseImpl sequenceExtractor = SequenceInformationExtractorOracleDatabaseImpl.INSTANCE;\n\t\t\t\t\tIterable<SequenceInformation> sequenceInformations = sequenceExtractor.extractMetadata(\n\t\t\t\t\t\t\tnew ExtractionContext.EmptyExtractionContext() {\n\n\t\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\t\tpublic Connection getJdbcConnection() {\n\t\t\t\t\t\t\t\t\treturn connection;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\t\tpublic JdbcEnvironment getJdbcEnvironment() {\n\t\t\t\t\t\t\t\t\treturn jdbcEnvironment;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} );\n\n\t\t\t\t\t// lets skip system sequences\n\t\t\t\t\tOptional<SequenceInformation> foundSequence = StreamSupport.stream(\n\t\t\t\t\t\t\t\t\tsequenceInformations.spliterator(),\n\t\t\t\t\t\t\t\t\tfalse\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t.filter( sequence -> sequenceName.equals( sequence.getSequenceName()\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  .getSequenceName()\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  .getText()\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  .toUpperCase() ) )\n\t\t\t\t\t\t\t.findFirst();\n\n\t\t\t\t\tassertTrue( sequenceName + \" not found\", foundSequence.isPresent() );\n\n\t\t\t\t\treturn foundSequence.get();\n\t\t\t\t}\n\t\t);\n\t}",
        "filePathBefore": "hibernate-core/src/test/java/org/hibernate/orm/test/dialect/functional/OracleDialectSequenceInformationTest.java",
        "isPureRefactoring": true,
        "commitId": "72e42817e3759f3f130eefb302d9aa7a3e0cfa58",
        "packageNameBefore": "org.hibernate.orm.test.dialect.functional",
        "classNameBefore": "org.hibernate.orm.test.dialect.functional.OracleDialectSequenceInformationTest",
        "methodNameBefore": "org.hibernate.orm.test.dialect.functional.OracleDialectSequenceInformationTest#fetchSequenceInformation",
        "invokedMethod": "methodSignature: org.hibernate.query.results.implicit.ImplicitFetchBuilderEntity#equals\n methodBody: public boolean equals(Object o) {\nif(this == o){return true;\n}if(o == null || getClass() != o.getClass()){return false;\n}final ImplicitFetchBuilderEntity that=(ImplicitFetchBuilderEntity)o;\nreturn fetchPath.equals(that.fetchPath) && fetchable.equals(that.fetchable) && fetchBuilders.equals(that.fetchBuilders);\n}\nmethodSignature: org.hibernate.boot.beanvalidation.GroupsPerOperation#get\n methodBody: public Class<?>[] get(Operation operation) {\nreturn groupsPerOperation.get(operation);\n}\nmethodSignature: org.hibernate.engine.jdbc.env.internal.JdbcEnvironmentInitiator.TemporaryJdbcSessionOwner#getJdbcServices\n methodBody: public JdbcServices getJdbcServices() {\nreturn jdbcServices;\n}\nmethodSignature: org.hibernate.boot.model.relational.QualifiedNameParser.NameParts#equals\n methodBody: public boolean equals(Object o) {\nif(this == o){return true;\n}if(o == null || getClass() != o.getClass()){return false;\n}NameParts that=(NameParts)o;\nreturn Objects.equals(this.getCatalogName(),that.getCatalogName()) && Objects.equals(this.getSchemaName(),that.getSchemaName()) && Objects.equals(this.getObjectName(),that.getObjectName());\n}\nmethodSignature: org.hibernate.engine.jdbc.env.internal.ExtractedDatabaseMetaDataImpl#getJdbcEnvironment\n methodBody: public JdbcEnvironment getJdbcEnvironment() {\nreturn jdbcEnvironment;\n}\nmethodSignature: org.hibernate.metamodel.mapping.SelectablePath#equals\n methodBody: public boolean equals(Object o) {\nif(this == o){return true;\n}if(o == null || getClass() != o.getClass()){return false;\n}SelectablePath that=(SelectablePath)o;\nif(!Objects.equals(parent,that.parent)){return false;\n}return name.equals(that.name);\n}",
        "classSignatureBefore": "public class OracleDialectSequenceInformationTest extends BaseNonConfigCoreFunctionalTestCase ",
        "methodNameBeforeSet": [
            "org.hibernate.orm.test.dialect.functional.OracleDialectSequenceInformationTest#fetchSequenceInformation"
        ],
        "classNameBeforeSet": [
            "org.hibernate.orm.test.dialect.functional.OracleDialectSequenceInformationTest"
        ],
        "classSignatureBeforeSet": [
            "public class OracleDialectSequenceInformationTest extends BaseNonConfigCoreFunctionalTestCase "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.\n */\npackage org.hibernate.orm.test.dialect.functional;\n\nimport java.math.BigDecimal;\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.Optional;\nimport java.util.stream.StreamSupport;\n\nimport org.hibernate.dialect.OracleDialect;\nimport org.hibernate.engine.jdbc.env.spi.JdbcEnvironment;\nimport org.hibernate.testing.RequiresDialect;\nimport org.hibernate.testing.TestForIssue;\nimport org.hibernate.testing.junit4.BaseNonConfigCoreFunctionalTestCase;\nimport org.hibernate.testing.transaction.TransactionUtil;\n\nimport org.hibernate.tool.schema.extract.internal.SequenceInformationExtractorOracleDatabaseImpl;\nimport org.hibernate.tool.schema.extract.spi.ExtractionContext;\nimport org.hibernate.tool.schema.extract.spi.SequenceInformation;\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport static org.hibernate.testing.transaction.TransactionUtil.doInAutoCommit;\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertTrue;\n\n@RequiresDialect(OracleDialect.class)\n@TestForIssue(jiraKey = \"HHH-13694\")\npublic class OracleDialectSequenceInformationTest extends BaseNonConfigCoreFunctionalTestCase {\n\n\tprivate static final String MIN_SEQUENCE_NAME = \"SEQ_MIN_TEST\";\n\tprivate static final String MAX_SEQUENCE_NAME = \"SEQ_MAX_TEST\";\n\tprivate static final String MIN_VALUE = \"-99999999999999999999999999\";\n\tprivate static final String MAX_VALUE =  \"99999999999999999999999999\";\n\n\t@Before\n\tpublic void prepareTest() throws Exception {\n\t\tdoInAutoCommit(\n\t\t\t\t\"DROP SEQUENCE \" + MIN_SEQUENCE_NAME,\n\t\t\t\t\"CREATE SEQUENCE \" + MIN_SEQUENCE_NAME + \" MINVALUE \" + MIN_VALUE + \" MAXVALUE -1 INCREMENT BY -1\",\n\t\t\t\t\"DROP SEQUENCE \" + MAX_SEQUENCE_NAME,\n\t\t\t\t\"CREATE SEQUENCE \" + MAX_SEQUENCE_NAME + \" MINVALUE 0 MAXVALUE \" + MAX_VALUE + \" INCREMENT BY 1\" );\n\t}\n\n\t@After\n\tpublic void cleanupTest() throws Exception {\n\t\tdoInAutoCommit(\n\t\t\t\t\"DROP SEQUENCE \" + MIN_SEQUENCE_NAME,\n\t\t\t\t\"DROP SEQUENCE \" + MAX_SEQUENCE_NAME );\n\t}\n\n\t@Test\n\tpublic void testExtractSequenceWithMinValueLowerThanLongMinValue() throws SQLException {\n\t\tSequenceInformation sequence = fetchSequenceInformation( MIN_SEQUENCE_NAME );\n\n\t\tassertEquals( -1L, sequence.getIncrementValue().longValue() );\n\t\tassertEquals( new BigDecimal( MIN_VALUE ), sequence.getMinValue() );\n\t}\n\n\t@Test\n\tpublic void testExtractSequenceWithMaxValueGreaterThanLongMaxValue() throws SQLException {\n\t\tSequenceInformation sequence = fetchSequenceInformation( MAX_SEQUENCE_NAME );\n\n\t\tassertEquals( 1L, sequence.getIncrementValue().longValue() );\n\t\tassertEquals( new BigDecimal( MAX_VALUE ), sequence.getMaxValue() );\n\t}\n\n\tprivate SequenceInformation fetchSequenceInformation(String sequenceName) throws SQLException {\n\t\treturn TransactionUtil.doWithJDBC(\n\t\t\t\tsessionFactory().getServiceRegistry(),\n\t\t\t\tconnection -> {\n\t\t\t\t\tJdbcEnvironment jdbcEnvironment = sessionFactory().getJdbcServices().getJdbcEnvironment();\n\t\t\t\t\tSequenceInformationExtractorOracleDatabaseImpl sequenceExtractor = SequenceInformationExtractorOracleDatabaseImpl.INSTANCE;\n\t\t\t\t\tIterable<SequenceInformation> sequenceInformations = sequenceExtractor.extractMetadata(\n\t\t\t\t\t\t\tnew ExtractionContext.EmptyExtractionContext() {\n\n\t\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\t\tpublic Connection getJdbcConnection() {\n\t\t\t\t\t\t\t\t\treturn connection;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\t\tpublic JdbcEnvironment getJdbcEnvironment() {\n\t\t\t\t\t\t\t\t\treturn jdbcEnvironment;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} );\n\n\t\t\t\t\t// lets skip system sequences\n\t\t\t\t\tOptional<SequenceInformation> foundSequence = StreamSupport.stream(\n\t\t\t\t\t\t\t\t\tsequenceInformations.spliterator(),\n\t\t\t\t\t\t\t\t\tfalse\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t.filter( sequence -> sequenceName.equals( sequence.getSequenceName()\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  .getSequenceName()\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  .getText()\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  .toUpperCase() ) )\n\t\t\t\t\t\t\t.findFirst();\n\n\t\t\t\t\tassertTrue( sequenceName + \" not found\", foundSequence.isPresent() );\n\n\t\t\t\t\treturn foundSequence.get();\n\t\t\t\t}\n\t\t);\n\t}\n}",
        "filePathAfter": "hibernate-core/src/test/java/org/hibernate/orm/test/dialect/functional/OracleDialectSequenceInformationTest.java",
        "sourceCodeAfterForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.\n */\npackage org.hibernate.orm.test.dialect.functional;\n\nimport java.math.BigDecimal;\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.Optional;\n\nimport org.hibernate.dialect.OracleDialect;\nimport org.hibernate.engine.jdbc.env.spi.JdbcEnvironment;\nimport org.hibernate.testing.RequiresDialect;\nimport org.hibernate.testing.TestForIssue;\nimport org.hibernate.testing.junit4.BaseNonConfigCoreFunctionalTestCase;\nimport org.hibernate.testing.transaction.TransactionUtil;\n\nimport org.hibernate.tool.schema.extract.internal.SequenceInformationExtractorOracleDatabaseImpl;\nimport org.hibernate.tool.schema.extract.spi.ExtractionContext;\nimport org.hibernate.tool.schema.extract.spi.SequenceInformation;\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport static java.util.stream.StreamSupport.stream;\nimport static org.hibernate.testing.transaction.TransactionUtil.doInAutoCommit;\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertTrue;\n\n@RequiresDialect(OracleDialect.class)\n@TestForIssue(jiraKey = \"HHH-13694\")\npublic class OracleDialectSequenceInformationTest extends BaseNonConfigCoreFunctionalTestCase {\n\n\tprivate static final String MIN_SEQUENCE_NAME = \"SEQ_MIN_TEST\";\n\tprivate static final String MAX_SEQUENCE_NAME = \"SEQ_MAX_TEST\";\n\tprivate static final String MIN_VALUE = \"-99999999999999999999999999\";\n\tprivate static final String MAX_VALUE =  \"99999999999999999999999999\";\n\n\t@Before\n\tpublic void prepareTest() throws Exception {\n\t\tdoInAutoCommit(\n\t\t\t\t\"DROP SEQUENCE \" + MIN_SEQUENCE_NAME,\n\t\t\t\t\"CREATE SEQUENCE \" + MIN_SEQUENCE_NAME + \" MINVALUE \" + MIN_VALUE + \" MAXVALUE -1 INCREMENT BY -1\",\n\t\t\t\t\"DROP SEQUENCE \" + MAX_SEQUENCE_NAME,\n\t\t\t\t\"CREATE SEQUENCE \" + MAX_SEQUENCE_NAME + \" MINVALUE 0 MAXVALUE \" + MAX_VALUE + \" INCREMENT BY 1\" );\n\t}\n\n\t@After\n\tpublic void cleanupTest() throws Exception {\n\t\tdoInAutoCommit(\n\t\t\t\t\"DROP SEQUENCE \" + MIN_SEQUENCE_NAME,\n\t\t\t\t\"DROP SEQUENCE \" + MAX_SEQUENCE_NAME );\n\t}\n\n\t@Test\n\tpublic void testExtractSequenceWithMinValueLowerThanLongMinValue() throws SQLException {\n\t\tSequenceInformation sequence = fetchSequenceInformation( MIN_SEQUENCE_NAME );\n\n\t\tassertEquals( -1L, sequence.getIncrementValue().longValue() );\n\t\tassertEquals( new BigDecimal( MIN_VALUE ), sequence.getMinValue() );\n\t}\n\n\t@Test\n\tpublic void testExtractSequenceWithMaxValueGreaterThanLongMaxValue() throws SQLException {\n\t\tSequenceInformation sequence = fetchSequenceInformation( MAX_SEQUENCE_NAME );\n\n\t\tassertEquals( 1L, sequence.getIncrementValue().longValue() );\n\t\tassertEquals( new BigDecimal( MAX_VALUE ), sequence.getMaxValue() );\n\t}\n\n\tprivate SequenceInformation fetchSequenceInformation(String sequenceName) throws SQLException {\n\t\treturn TransactionUtil.doWithJDBC(\n\t\t\t\tsessionFactory().getServiceRegistry(),\n\t\t\t\tconnection -> {\n\t\t\t\t\tfinal JdbcEnvironment jdbcEnvironment =\n\t\t\t\t\t\t\tsessionFactory().getJdbcServices().getJdbcEnvironment();\n\t\t\t\t\t// lets skip system sequences\n\t\t\t\t\tOptional<SequenceInformation> foundSequence =\n\t\t\t\t\t\t\tstream( sequenceInformation( connection, jdbcEnvironment ).spliterator(), false )\n\t\t\t\t\t\t\t.filter( sequence -> isSameSequence( sequenceName, sequence ) )\n\t\t\t\t\t\t\t.findFirst();\n\t\t\t\t\tassertTrue( sequenceName + \" not found\", foundSequence.isPresent() );\n\t\t\t\t\treturn foundSequence.get();\n\t\t\t\t}\n\t\t);\n\t}\n\n\tprivate static boolean isSameSequence(String sequenceName, SequenceInformation sequence) {\n\t\treturn sequenceName.equals( sequence.getSequenceName().getSequenceName().getText().toUpperCase() );\n\t}\n\n\tprivate static Iterable<SequenceInformation> sequenceInformation(Connection connection, JdbcEnvironment jdbcEnvironment)\n\t\t\tthrows SQLException {\n\t\treturn SequenceInformationExtractorOracleDatabaseImpl.INSTANCE.extractMetadata(\n\t\t\t\tnew ExtractionContext.EmptyExtractionContext() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic Connection getJdbcConnection() {\n\t\t\t\t\t\treturn connection;\n\t\t\t\t\t}\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic JdbcEnvironment getJdbcEnvironment() {\n\t\t\t\t\t\treturn jdbcEnvironment;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t);\n\t}\n}",
        "diffSourceCodeSet": [
            "private static Iterable<SequenceInformation> sequenceInformation(Connection connection, JdbcEnvironment jdbcEnvironment)\n\t\t\tthrows SQLException {\n\t\treturn SequenceInformationExtractorOracleDatabaseImpl.INSTANCE.extractMetadata(\n\t\t\t\tnew ExtractionContext.EmptyExtractionContext() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic Connection getJdbcConnection() {\n\t\t\t\t\t\treturn connection;\n\t\t\t\t\t}\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic JdbcEnvironment getJdbcEnvironment() {\n\t\t\t\t\t\treturn jdbcEnvironment;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t);\n\t}"
        ],
        "invokedMethodSet": [
            "methodSignature: org.hibernate.query.results.implicit.ImplicitFetchBuilderEntity#equals\n methodBody: public boolean equals(Object o) {\nif(this == o){return true;\n}if(o == null || getClass() != o.getClass()){return false;\n}final ImplicitFetchBuilderEntity that=(ImplicitFetchBuilderEntity)o;\nreturn fetchPath.equals(that.fetchPath) && fetchable.equals(that.fetchable) && fetchBuilders.equals(that.fetchBuilders);\n}",
            "methodSignature: org.hibernate.boot.beanvalidation.GroupsPerOperation#get\n methodBody: public Class<?>[] get(Operation operation) {\nreturn groupsPerOperation.get(operation);\n}",
            "methodSignature: org.hibernate.engine.jdbc.env.internal.JdbcEnvironmentInitiator.TemporaryJdbcSessionOwner#getJdbcServices\n methodBody: public JdbcServices getJdbcServices() {\nreturn jdbcServices;\n}",
            "methodSignature: org.hibernate.boot.model.relational.QualifiedNameParser.NameParts#equals\n methodBody: public boolean equals(Object o) {\nif(this == o){return true;\n}if(o == null || getClass() != o.getClass()){return false;\n}NameParts that=(NameParts)o;\nreturn Objects.equals(this.getCatalogName(),that.getCatalogName()) && Objects.equals(this.getSchemaName(),that.getSchemaName()) && Objects.equals(this.getObjectName(),that.getObjectName());\n}",
            "methodSignature: org.hibernate.engine.jdbc.env.internal.ExtractedDatabaseMetaDataImpl#getJdbcEnvironment\n methodBody: public JdbcEnvironment getJdbcEnvironment() {\nreturn jdbcEnvironment;\n}",
            "methodSignature: org.hibernate.metamodel.mapping.SelectablePath#equals\n methodBody: public boolean equals(Object o) {\nif(this == o){return true;\n}if(o == null || getClass() != o.getClass()){return false;\n}SelectablePath that=(SelectablePath)o;\nif(!Objects.equals(parent,that.parent)){return false;\n}return name.equals(that.name);\n}"
        ],
        "sourceCodeAfterRefactoring": "private SequenceInformation fetchSequenceInformation(String sequenceName) throws SQLException {\n\t\treturn TransactionUtil.doWithJDBC(\n\t\t\t\tsessionFactory().getServiceRegistry(),\n\t\t\t\tconnection -> {\n\t\t\t\t\tfinal JdbcEnvironment jdbcEnvironment =\n\t\t\t\t\t\t\tsessionFactory().getJdbcServices().getJdbcEnvironment();\n\t\t\t\t\t// lets skip system sequences\n\t\t\t\t\tOptional<SequenceInformation> foundSequence =\n\t\t\t\t\t\t\tstream( sequenceInformation( connection, jdbcEnvironment ).spliterator(), false )\n\t\t\t\t\t\t\t.filter( sequence -> isSameSequence( sequenceName, sequence ) )\n\t\t\t\t\t\t\t.findFirst();\n\t\t\t\t\tassertTrue( sequenceName + \" not found\", foundSequence.isPresent() );\n\t\t\t\t\treturn foundSequence.get();\n\t\t\t\t}\n\t\t);\n\t}\nprivate static Iterable<SequenceInformation> sequenceInformation(Connection connection, JdbcEnvironment jdbcEnvironment)\n\t\t\tthrows SQLException {\n\t\treturn SequenceInformationExtractorOracleDatabaseImpl.INSTANCE.extractMetadata(\n\t\t\t\tnew ExtractionContext.EmptyExtractionContext() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic Connection getJdbcConnection() {\n\t\t\t\t\t\treturn connection;\n\t\t\t\t\t}\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic JdbcEnvironment getJdbcEnvironment() {\n\t\t\t\t\t\treturn jdbcEnvironment;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t);\n\t}",
        "diffSourceCode": "    74: \tprivate SequenceInformation fetchSequenceInformation(String sequenceName) throws SQLException {\n    75: \t\treturn TransactionUtil.doWithJDBC(\n    76: \t\t\t\tsessionFactory().getServiceRegistry(),\n    77: \t\t\t\tconnection -> {\n-   78: \t\t\t\t\tJdbcEnvironment jdbcEnvironment = sessionFactory().getJdbcServices().getJdbcEnvironment();\n-   79: \t\t\t\t\tSequenceInformationExtractorOracleDatabaseImpl sequenceExtractor = SequenceInformationExtractorOracleDatabaseImpl.INSTANCE;\n-   80: \t\t\t\t\tIterable<SequenceInformation> sequenceInformations = sequenceExtractor.extractMetadata(\n-   81: \t\t\t\t\t\t\tnew ExtractionContext.EmptyExtractionContext() {\n-   82: \n-   83: \t\t\t\t\t\t\t\t@Override\n-   84: \t\t\t\t\t\t\t\tpublic Connection getJdbcConnection() {\n-   85: \t\t\t\t\t\t\t\t\treturn connection;\n-   86: \t\t\t\t\t\t\t\t}\n-   87: \n-   88: \t\t\t\t\t\t\t\t@Override\n-   89: \t\t\t\t\t\t\t\tpublic JdbcEnvironment getJdbcEnvironment() {\n-   90: \t\t\t\t\t\t\t\t\treturn jdbcEnvironment;\n-   91: \t\t\t\t\t\t\t\t}\n-   92: \t\t\t\t\t\t\t} );\n-   93: \n-   94: \t\t\t\t\t// lets skip system sequences\n-   95: \t\t\t\t\tOptional<SequenceInformation> foundSequence = StreamSupport.stream(\n-   96: \t\t\t\t\t\t\t\t\tsequenceInformations.spliterator(),\n-   97: \t\t\t\t\t\t\t\t\tfalse\n-   98: \t\t\t\t\t\t\t)\n-   99: \t\t\t\t\t\t\t.filter( sequence -> sequenceName.equals( sequence.getSequenceName()\n-  100: \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  .getSequenceName()\n-  101: \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  .getText()\n-  102: \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  .toUpperCase() ) )\n-  103: \t\t\t\t\t\t\t.findFirst();\n-  104: \n-  105: \t\t\t\t\tassertTrue( sequenceName + \" not found\", foundSequence.isPresent() );\n-  106: \n-  107: \t\t\t\t\treturn foundSequence.get();\n+   78: \t\t\t\t\tfinal JdbcEnvironment jdbcEnvironment =\n+   79: \t\t\t\t\t\t\tsessionFactory().getJdbcServices().getJdbcEnvironment();\n+   80: \t\t\t\t\t// lets skip system sequences\n+   81: \t\t\t\t\tOptional<SequenceInformation> foundSequence =\n+   82: \t\t\t\t\t\t\tstream( sequenceInformation( connection, jdbcEnvironment ).spliterator(), false )\n+   83: \t\t\t\t\t\t\t.filter( sequence -> isSameSequence( sequenceName, sequence ) )\n+   84: \t\t\t\t\t\t\t.findFirst();\n+   85: \t\t\t\t\tassertTrue( sequenceName + \" not found\", foundSequence.isPresent() );\n+   86: \t\t\t\t\treturn foundSequence.get();\n+   87: \t\t\t\t}\n+   88: \t\t);\n+   89: \t}\n+   90: \n+   91: \tprivate static boolean isSameSequence(String sequenceName, SequenceInformation sequence) {\n+   92: \t\treturn sequenceName.equals( sequence.getSequenceName().getSequenceName().getText().toUpperCase() );\n+   93: \t}\n+   94: \n+   95: \tprivate static Iterable<SequenceInformation> sequenceInformation(Connection connection, JdbcEnvironment jdbcEnvironment)\n+   96: \t\t\tthrows SQLException {\n+   97: \t\treturn SequenceInformationExtractorOracleDatabaseImpl.INSTANCE.extractMetadata(\n+   98: \t\t\t\tnew ExtractionContext.EmptyExtractionContext() {\n+   99: \t\t\t\t\t@Override\n+  100: \t\t\t\t\tpublic Connection getJdbcConnection() {\n+  101: \t\t\t\t\t\treturn connection;\n+  102: \t\t\t\t\t}\n+  103: \n+  104: \t\t\t\t\t@Override\n+  105: \t\t\t\t\tpublic JdbcEnvironment getJdbcEnvironment() {\n+  106: \t\t\t\t\t\treturn jdbcEnvironment;\n+  107: \t\t\t\t\t}\n   108: \t\t\t\t}\n   109: \t\t);\n   110: \t}\n",
        "uniqueId": "72e42817e3759f3f130eefb302d9aa7a3e0cfa58_74_110_95_110_74_89",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "testMethod": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 21
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprivate isSameSequence(sequenceName String, sequence SequenceInformation) : boolean extracted from private fetchSequenceInformation(sequenceName String) : SequenceInformation in class org.hibernate.orm.test.dialect.functional.OracleDialectSequenceInformationTest",
        "diffLocations": [
            {
                "filePath": "hibernate-core/src/test/java/org/hibernate/orm/test/dialect/functional/OracleDialectSequenceInformationTest.java",
                "startLine": 74,
                "endLine": 110,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/test/java/org/hibernate/orm/test/dialect/functional/OracleDialectSequenceInformationTest.java",
                "startLine": 74,
                "endLine": 89,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/test/java/org/hibernate/orm/test/dialect/functional/OracleDialectSequenceInformationTest.java",
                "startLine": 91,
                "endLine": 93,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "private SequenceInformation fetchSequenceInformation(String sequenceName) throws SQLException {\n\t\treturn TransactionUtil.doWithJDBC(\n\t\t\t\tsessionFactory().getServiceRegistry(),\n\t\t\t\tconnection -> {\n\t\t\t\t\tJdbcEnvironment jdbcEnvironment = sessionFactory().getJdbcServices().getJdbcEnvironment();\n\t\t\t\t\tSequenceInformationExtractorOracleDatabaseImpl sequenceExtractor = SequenceInformationExtractorOracleDatabaseImpl.INSTANCE;\n\t\t\t\t\tIterable<SequenceInformation> sequenceInformations = sequenceExtractor.extractMetadata(\n\t\t\t\t\t\t\tnew ExtractionContext.EmptyExtractionContext() {\n\n\t\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\t\tpublic Connection getJdbcConnection() {\n\t\t\t\t\t\t\t\t\treturn connection;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\t\tpublic JdbcEnvironment getJdbcEnvironment() {\n\t\t\t\t\t\t\t\t\treturn jdbcEnvironment;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} );\n\n\t\t\t\t\t// lets skip system sequences\n\t\t\t\t\tOptional<SequenceInformation> foundSequence = StreamSupport.stream(\n\t\t\t\t\t\t\t\t\tsequenceInformations.spliterator(),\n\t\t\t\t\t\t\t\t\tfalse\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t.filter( sequence -> sequenceName.equals( sequence.getSequenceName()\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  .getSequenceName()\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  .getText()\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  .toUpperCase() ) )\n\t\t\t\t\t\t\t.findFirst();\n\n\t\t\t\t\tassertTrue( sequenceName + \" not found\", foundSequence.isPresent() );\n\n\t\t\t\t\treturn foundSequence.get();\n\t\t\t\t}\n\t\t);\n\t}",
        "filePathBefore": "hibernate-core/src/test/java/org/hibernate/orm/test/dialect/functional/OracleDialectSequenceInformationTest.java",
        "isPureRefactoring": true,
        "commitId": "72e42817e3759f3f130eefb302d9aa7a3e0cfa58",
        "packageNameBefore": "org.hibernate.orm.test.dialect.functional",
        "classNameBefore": "org.hibernate.orm.test.dialect.functional.OracleDialectSequenceInformationTest",
        "methodNameBefore": "org.hibernate.orm.test.dialect.functional.OracleDialectSequenceInformationTest#fetchSequenceInformation",
        "invokedMethod": "methodSignature: org.hibernate.query.results.implicit.ImplicitFetchBuilderEntity#equals\n methodBody: public boolean equals(Object o) {\nif(this == o){return true;\n}if(o == null || getClass() != o.getClass()){return false;\n}final ImplicitFetchBuilderEntity that=(ImplicitFetchBuilderEntity)o;\nreturn fetchPath.equals(that.fetchPath) && fetchable.equals(that.fetchable) && fetchBuilders.equals(that.fetchBuilders);\n}\nmethodSignature: org.hibernate.boot.beanvalidation.GroupsPerOperation#get\n methodBody: public Class<?>[] get(Operation operation) {\nreturn groupsPerOperation.get(operation);\n}\nmethodSignature: org.hibernate.engine.jdbc.env.internal.JdbcEnvironmentInitiator.TemporaryJdbcSessionOwner#getJdbcServices\n methodBody: public JdbcServices getJdbcServices() {\nreturn jdbcServices;\n}\nmethodSignature: org.hibernate.boot.model.relational.QualifiedNameParser.NameParts#equals\n methodBody: public boolean equals(Object o) {\nif(this == o){return true;\n}if(o == null || getClass() != o.getClass()){return false;\n}NameParts that=(NameParts)o;\nreturn Objects.equals(this.getCatalogName(),that.getCatalogName()) && Objects.equals(this.getSchemaName(),that.getSchemaName()) && Objects.equals(this.getObjectName(),that.getObjectName());\n}\nmethodSignature: org.hibernate.engine.jdbc.env.internal.ExtractedDatabaseMetaDataImpl#getJdbcEnvironment\n methodBody: public JdbcEnvironment getJdbcEnvironment() {\nreturn jdbcEnvironment;\n}\nmethodSignature: org.hibernate.metamodel.mapping.SelectablePath#equals\n methodBody: public boolean equals(Object o) {\nif(this == o){return true;\n}if(o == null || getClass() != o.getClass()){return false;\n}SelectablePath that=(SelectablePath)o;\nif(!Objects.equals(parent,that.parent)){return false;\n}return name.equals(that.name);\n}",
        "classSignatureBefore": "public class OracleDialectSequenceInformationTest extends BaseNonConfigCoreFunctionalTestCase ",
        "methodNameBeforeSet": [
            "org.hibernate.orm.test.dialect.functional.OracleDialectSequenceInformationTest#fetchSequenceInformation"
        ],
        "classNameBeforeSet": [
            "org.hibernate.orm.test.dialect.functional.OracleDialectSequenceInformationTest"
        ],
        "classSignatureBeforeSet": [
            "public class OracleDialectSequenceInformationTest extends BaseNonConfigCoreFunctionalTestCase "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.\n */\npackage org.hibernate.orm.test.dialect.functional;\n\nimport java.math.BigDecimal;\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.Optional;\nimport java.util.stream.StreamSupport;\n\nimport org.hibernate.dialect.OracleDialect;\nimport org.hibernate.engine.jdbc.env.spi.JdbcEnvironment;\nimport org.hibernate.testing.RequiresDialect;\nimport org.hibernate.testing.TestForIssue;\nimport org.hibernate.testing.junit4.BaseNonConfigCoreFunctionalTestCase;\nimport org.hibernate.testing.transaction.TransactionUtil;\n\nimport org.hibernate.tool.schema.extract.internal.SequenceInformationExtractorOracleDatabaseImpl;\nimport org.hibernate.tool.schema.extract.spi.ExtractionContext;\nimport org.hibernate.tool.schema.extract.spi.SequenceInformation;\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport static org.hibernate.testing.transaction.TransactionUtil.doInAutoCommit;\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertTrue;\n\n@RequiresDialect(OracleDialect.class)\n@TestForIssue(jiraKey = \"HHH-13694\")\npublic class OracleDialectSequenceInformationTest extends BaseNonConfigCoreFunctionalTestCase {\n\n\tprivate static final String MIN_SEQUENCE_NAME = \"SEQ_MIN_TEST\";\n\tprivate static final String MAX_SEQUENCE_NAME = \"SEQ_MAX_TEST\";\n\tprivate static final String MIN_VALUE = \"-99999999999999999999999999\";\n\tprivate static final String MAX_VALUE =  \"99999999999999999999999999\";\n\n\t@Before\n\tpublic void prepareTest() throws Exception {\n\t\tdoInAutoCommit(\n\t\t\t\t\"DROP SEQUENCE \" + MIN_SEQUENCE_NAME,\n\t\t\t\t\"CREATE SEQUENCE \" + MIN_SEQUENCE_NAME + \" MINVALUE \" + MIN_VALUE + \" MAXVALUE -1 INCREMENT BY -1\",\n\t\t\t\t\"DROP SEQUENCE \" + MAX_SEQUENCE_NAME,\n\t\t\t\t\"CREATE SEQUENCE \" + MAX_SEQUENCE_NAME + \" MINVALUE 0 MAXVALUE \" + MAX_VALUE + \" INCREMENT BY 1\" );\n\t}\n\n\t@After\n\tpublic void cleanupTest() throws Exception {\n\t\tdoInAutoCommit(\n\t\t\t\t\"DROP SEQUENCE \" + MIN_SEQUENCE_NAME,\n\t\t\t\t\"DROP SEQUENCE \" + MAX_SEQUENCE_NAME );\n\t}\n\n\t@Test\n\tpublic void testExtractSequenceWithMinValueLowerThanLongMinValue() throws SQLException {\n\t\tSequenceInformation sequence = fetchSequenceInformation( MIN_SEQUENCE_NAME );\n\n\t\tassertEquals( -1L, sequence.getIncrementValue().longValue() );\n\t\tassertEquals( new BigDecimal( MIN_VALUE ), sequence.getMinValue() );\n\t}\n\n\t@Test\n\tpublic void testExtractSequenceWithMaxValueGreaterThanLongMaxValue() throws SQLException {\n\t\tSequenceInformation sequence = fetchSequenceInformation( MAX_SEQUENCE_NAME );\n\n\t\tassertEquals( 1L, sequence.getIncrementValue().longValue() );\n\t\tassertEquals( new BigDecimal( MAX_VALUE ), sequence.getMaxValue() );\n\t}\n\n\tprivate SequenceInformation fetchSequenceInformation(String sequenceName) throws SQLException {\n\t\treturn TransactionUtil.doWithJDBC(\n\t\t\t\tsessionFactory().getServiceRegistry(),\n\t\t\t\tconnection -> {\n\t\t\t\t\tJdbcEnvironment jdbcEnvironment = sessionFactory().getJdbcServices().getJdbcEnvironment();\n\t\t\t\t\tSequenceInformationExtractorOracleDatabaseImpl sequenceExtractor = SequenceInformationExtractorOracleDatabaseImpl.INSTANCE;\n\t\t\t\t\tIterable<SequenceInformation> sequenceInformations = sequenceExtractor.extractMetadata(\n\t\t\t\t\t\t\tnew ExtractionContext.EmptyExtractionContext() {\n\n\t\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\t\tpublic Connection getJdbcConnection() {\n\t\t\t\t\t\t\t\t\treturn connection;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\t\tpublic JdbcEnvironment getJdbcEnvironment() {\n\t\t\t\t\t\t\t\t\treturn jdbcEnvironment;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} );\n\n\t\t\t\t\t// lets skip system sequences\n\t\t\t\t\tOptional<SequenceInformation> foundSequence = StreamSupport.stream(\n\t\t\t\t\t\t\t\t\tsequenceInformations.spliterator(),\n\t\t\t\t\t\t\t\t\tfalse\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t.filter( sequence -> sequenceName.equals( sequence.getSequenceName()\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  .getSequenceName()\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  .getText()\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  .toUpperCase() ) )\n\t\t\t\t\t\t\t.findFirst();\n\n\t\t\t\t\tassertTrue( sequenceName + \" not found\", foundSequence.isPresent() );\n\n\t\t\t\t\treturn foundSequence.get();\n\t\t\t\t}\n\t\t);\n\t}\n}",
        "filePathAfter": "hibernate-core/src/test/java/org/hibernate/orm/test/dialect/functional/OracleDialectSequenceInformationTest.java",
        "sourceCodeAfterForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.\n */\npackage org.hibernate.orm.test.dialect.functional;\n\nimport java.math.BigDecimal;\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.Optional;\n\nimport org.hibernate.dialect.OracleDialect;\nimport org.hibernate.engine.jdbc.env.spi.JdbcEnvironment;\nimport org.hibernate.testing.RequiresDialect;\nimport org.hibernate.testing.TestForIssue;\nimport org.hibernate.testing.junit4.BaseNonConfigCoreFunctionalTestCase;\nimport org.hibernate.testing.transaction.TransactionUtil;\n\nimport org.hibernate.tool.schema.extract.internal.SequenceInformationExtractorOracleDatabaseImpl;\nimport org.hibernate.tool.schema.extract.spi.ExtractionContext;\nimport org.hibernate.tool.schema.extract.spi.SequenceInformation;\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport static java.util.stream.StreamSupport.stream;\nimport static org.hibernate.testing.transaction.TransactionUtil.doInAutoCommit;\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertTrue;\n\n@RequiresDialect(OracleDialect.class)\n@TestForIssue(jiraKey = \"HHH-13694\")\npublic class OracleDialectSequenceInformationTest extends BaseNonConfigCoreFunctionalTestCase {\n\n\tprivate static final String MIN_SEQUENCE_NAME = \"SEQ_MIN_TEST\";\n\tprivate static final String MAX_SEQUENCE_NAME = \"SEQ_MAX_TEST\";\n\tprivate static final String MIN_VALUE = \"-99999999999999999999999999\";\n\tprivate static final String MAX_VALUE =  \"99999999999999999999999999\";\n\n\t@Before\n\tpublic void prepareTest() throws Exception {\n\t\tdoInAutoCommit(\n\t\t\t\t\"DROP SEQUENCE \" + MIN_SEQUENCE_NAME,\n\t\t\t\t\"CREATE SEQUENCE \" + MIN_SEQUENCE_NAME + \" MINVALUE \" + MIN_VALUE + \" MAXVALUE -1 INCREMENT BY -1\",\n\t\t\t\t\"DROP SEQUENCE \" + MAX_SEQUENCE_NAME,\n\t\t\t\t\"CREATE SEQUENCE \" + MAX_SEQUENCE_NAME + \" MINVALUE 0 MAXVALUE \" + MAX_VALUE + \" INCREMENT BY 1\" );\n\t}\n\n\t@After\n\tpublic void cleanupTest() throws Exception {\n\t\tdoInAutoCommit(\n\t\t\t\t\"DROP SEQUENCE \" + MIN_SEQUENCE_NAME,\n\t\t\t\t\"DROP SEQUENCE \" + MAX_SEQUENCE_NAME );\n\t}\n\n\t@Test\n\tpublic void testExtractSequenceWithMinValueLowerThanLongMinValue() throws SQLException {\n\t\tSequenceInformation sequence = fetchSequenceInformation( MIN_SEQUENCE_NAME );\n\n\t\tassertEquals( -1L, sequence.getIncrementValue().longValue() );\n\t\tassertEquals( new BigDecimal( MIN_VALUE ), sequence.getMinValue() );\n\t}\n\n\t@Test\n\tpublic void testExtractSequenceWithMaxValueGreaterThanLongMaxValue() throws SQLException {\n\t\tSequenceInformation sequence = fetchSequenceInformation( MAX_SEQUENCE_NAME );\n\n\t\tassertEquals( 1L, sequence.getIncrementValue().longValue() );\n\t\tassertEquals( new BigDecimal( MAX_VALUE ), sequence.getMaxValue() );\n\t}\n\n\tprivate SequenceInformation fetchSequenceInformation(String sequenceName) throws SQLException {\n\t\treturn TransactionUtil.doWithJDBC(\n\t\t\t\tsessionFactory().getServiceRegistry(),\n\t\t\t\tconnection -> {\n\t\t\t\t\tfinal JdbcEnvironment jdbcEnvironment =\n\t\t\t\t\t\t\tsessionFactory().getJdbcServices().getJdbcEnvironment();\n\t\t\t\t\t// lets skip system sequences\n\t\t\t\t\tOptional<SequenceInformation> foundSequence =\n\t\t\t\t\t\t\tstream( sequenceInformation( connection, jdbcEnvironment ).spliterator(), false )\n\t\t\t\t\t\t\t.filter( sequence -> isSameSequence( sequenceName, sequence ) )\n\t\t\t\t\t\t\t.findFirst();\n\t\t\t\t\tassertTrue( sequenceName + \" not found\", foundSequence.isPresent() );\n\t\t\t\t\treturn foundSequence.get();\n\t\t\t\t}\n\t\t);\n\t}\n\n\tprivate static boolean isSameSequence(String sequenceName, SequenceInformation sequence) {\n\t\treturn sequenceName.equals( sequence.getSequenceName().getSequenceName().getText().toUpperCase() );\n\t}\n\n\tprivate static Iterable<SequenceInformation> sequenceInformation(Connection connection, JdbcEnvironment jdbcEnvironment)\n\t\t\tthrows SQLException {\n\t\treturn SequenceInformationExtractorOracleDatabaseImpl.INSTANCE.extractMetadata(\n\t\t\t\tnew ExtractionContext.EmptyExtractionContext() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic Connection getJdbcConnection() {\n\t\t\t\t\t\treturn connection;\n\t\t\t\t\t}\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic JdbcEnvironment getJdbcEnvironment() {\n\t\t\t\t\t\treturn jdbcEnvironment;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t);\n\t}\n}",
        "diffSourceCodeSet": [
            "private static boolean isSameSequence(String sequenceName, SequenceInformation sequence) {\n\t\treturn sequenceName.equals( sequence.getSequenceName().getSequenceName().getText().toUpperCase() );\n\t}"
        ],
        "invokedMethodSet": [
            "methodSignature: org.hibernate.query.results.implicit.ImplicitFetchBuilderEntity#equals\n methodBody: public boolean equals(Object o) {\nif(this == o){return true;\n}if(o == null || getClass() != o.getClass()){return false;\n}final ImplicitFetchBuilderEntity that=(ImplicitFetchBuilderEntity)o;\nreturn fetchPath.equals(that.fetchPath) && fetchable.equals(that.fetchable) && fetchBuilders.equals(that.fetchBuilders);\n}",
            "methodSignature: org.hibernate.boot.beanvalidation.GroupsPerOperation#get\n methodBody: public Class<?>[] get(Operation operation) {\nreturn groupsPerOperation.get(operation);\n}",
            "methodSignature: org.hibernate.engine.jdbc.env.internal.JdbcEnvironmentInitiator.TemporaryJdbcSessionOwner#getJdbcServices\n methodBody: public JdbcServices getJdbcServices() {\nreturn jdbcServices;\n}",
            "methodSignature: org.hibernate.boot.model.relational.QualifiedNameParser.NameParts#equals\n methodBody: public boolean equals(Object o) {\nif(this == o){return true;\n}if(o == null || getClass() != o.getClass()){return false;\n}NameParts that=(NameParts)o;\nreturn Objects.equals(this.getCatalogName(),that.getCatalogName()) && Objects.equals(this.getSchemaName(),that.getSchemaName()) && Objects.equals(this.getObjectName(),that.getObjectName());\n}",
            "methodSignature: org.hibernate.engine.jdbc.env.internal.ExtractedDatabaseMetaDataImpl#getJdbcEnvironment\n methodBody: public JdbcEnvironment getJdbcEnvironment() {\nreturn jdbcEnvironment;\n}",
            "methodSignature: org.hibernate.metamodel.mapping.SelectablePath#equals\n methodBody: public boolean equals(Object o) {\nif(this == o){return true;\n}if(o == null || getClass() != o.getClass()){return false;\n}SelectablePath that=(SelectablePath)o;\nif(!Objects.equals(parent,that.parent)){return false;\n}return name.equals(that.name);\n}"
        ],
        "sourceCodeAfterRefactoring": "private SequenceInformation fetchSequenceInformation(String sequenceName) throws SQLException {\n\t\treturn TransactionUtil.doWithJDBC(\n\t\t\t\tsessionFactory().getServiceRegistry(),\n\t\t\t\tconnection -> {\n\t\t\t\t\tfinal JdbcEnvironment jdbcEnvironment =\n\t\t\t\t\t\t\tsessionFactory().getJdbcServices().getJdbcEnvironment();\n\t\t\t\t\t// lets skip system sequences\n\t\t\t\t\tOptional<SequenceInformation> foundSequence =\n\t\t\t\t\t\t\tstream( sequenceInformation( connection, jdbcEnvironment ).spliterator(), false )\n\t\t\t\t\t\t\t.filter( sequence -> isSameSequence( sequenceName, sequence ) )\n\t\t\t\t\t\t\t.findFirst();\n\t\t\t\t\tassertTrue( sequenceName + \" not found\", foundSequence.isPresent() );\n\t\t\t\t\treturn foundSequence.get();\n\t\t\t\t}\n\t\t);\n\t}\nprivate static boolean isSameSequence(String sequenceName, SequenceInformation sequence) {\n\t\treturn sequenceName.equals( sequence.getSequenceName().getSequenceName().getText().toUpperCase() );\n\t}",
        "diffSourceCode": "    74: \tprivate SequenceInformation fetchSequenceInformation(String sequenceName) throws SQLException {\n    75: \t\treturn TransactionUtil.doWithJDBC(\n    76: \t\t\t\tsessionFactory().getServiceRegistry(),\n    77: \t\t\t\tconnection -> {\n-   78: \t\t\t\t\tJdbcEnvironment jdbcEnvironment = sessionFactory().getJdbcServices().getJdbcEnvironment();\n-   79: \t\t\t\t\tSequenceInformationExtractorOracleDatabaseImpl sequenceExtractor = SequenceInformationExtractorOracleDatabaseImpl.INSTANCE;\n-   80: \t\t\t\t\tIterable<SequenceInformation> sequenceInformations = sequenceExtractor.extractMetadata(\n-   81: \t\t\t\t\t\t\tnew ExtractionContext.EmptyExtractionContext() {\n-   82: \n-   83: \t\t\t\t\t\t\t\t@Override\n-   84: \t\t\t\t\t\t\t\tpublic Connection getJdbcConnection() {\n-   85: \t\t\t\t\t\t\t\t\treturn connection;\n-   86: \t\t\t\t\t\t\t\t}\n-   87: \n-   88: \t\t\t\t\t\t\t\t@Override\n-   89: \t\t\t\t\t\t\t\tpublic JdbcEnvironment getJdbcEnvironment() {\n-   90: \t\t\t\t\t\t\t\t\treturn jdbcEnvironment;\n-   91: \t\t\t\t\t\t\t\t}\n-   92: \t\t\t\t\t\t\t} );\n-   93: \n-   94: \t\t\t\t\t// lets skip system sequences\n-   95: \t\t\t\t\tOptional<SequenceInformation> foundSequence = StreamSupport.stream(\n-   96: \t\t\t\t\t\t\t\t\tsequenceInformations.spliterator(),\n-   97: \t\t\t\t\t\t\t\t\tfalse\n-   98: \t\t\t\t\t\t\t)\n-   99: \t\t\t\t\t\t\t.filter( sequence -> sequenceName.equals( sequence.getSequenceName()\n-  100: \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  .getSequenceName()\n-  101: \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  .getText()\n-  102: \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  .toUpperCase() ) )\n-  103: \t\t\t\t\t\t\t.findFirst();\n-  104: \n-  105: \t\t\t\t\tassertTrue( sequenceName + \" not found\", foundSequence.isPresent() );\n-  106: \n-  107: \t\t\t\t\treturn foundSequence.get();\n+   78: \t\t\t\t\tfinal JdbcEnvironment jdbcEnvironment =\n+   79: \t\t\t\t\t\t\tsessionFactory().getJdbcServices().getJdbcEnvironment();\n+   80: \t\t\t\t\t// lets skip system sequences\n+   81: \t\t\t\t\tOptional<SequenceInformation> foundSequence =\n+   82: \t\t\t\t\t\t\tstream( sequenceInformation( connection, jdbcEnvironment ).spliterator(), false )\n+   83: \t\t\t\t\t\t\t.filter( sequence -> isSameSequence( sequenceName, sequence ) )\n+   84: \t\t\t\t\t\t\t.findFirst();\n+   85: \t\t\t\t\tassertTrue( sequenceName + \" not found\", foundSequence.isPresent() );\n+   86: \t\t\t\t\treturn foundSequence.get();\n+   87: \t\t\t\t}\n+   88: \t\t);\n+   89: \t}\n+   90: \n+   91: \tprivate static boolean isSameSequence(String sequenceName, SequenceInformation sequence) {\n+   92: \t\treturn sequenceName.equals( sequence.getSequenceName().getSequenceName().getText().toUpperCase() );\n+   93: \t}\n+   94: \n+   95: \tprivate static Iterable<SequenceInformation> sequenceInformation(Connection connection, JdbcEnvironment jdbcEnvironment)\n+   96: \t\t\tthrows SQLException {\n+   97: \t\treturn SequenceInformationExtractorOracleDatabaseImpl.INSTANCE.extractMetadata(\n+   98: \t\t\t\tnew ExtractionContext.EmptyExtractionContext() {\n+   99: \t\t\t\t\t@Override\n+  100: \t\t\t\t\tpublic Connection getJdbcConnection() {\n+  101: \t\t\t\t\t\treturn connection;\n+  102: \t\t\t\t\t}\n+  103: \n+  104: \t\t\t\t\t@Override\n+  105: \t\t\t\t\tpublic JdbcEnvironment getJdbcEnvironment() {\n+  106: \t\t\t\t\t\treturn jdbcEnvironment;\n+  107: \t\t\t\t\t}\n   108: \t\t\t\t}\n   109: \t\t);\n   110: \t}\n",
        "uniqueId": "72e42817e3759f3f130eefb302d9aa7a3e0cfa58_74_110_91_93_74_89",
        "moveFileExist": true,
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 21,
        "testResult": true,
        "coverageInfo": {
            "testMethod": {
                "missed": 0,
                "covered": 1
            }
        }
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprivate sequenceInformation(connection Connection, jdbcEnvironment JdbcEnvironment) : Iterable<SequenceInformation> extracted from private sequenceInformationList() : List<SequenceInformation> in class org.hibernate.engine.jdbc.env.internal.ExtractedDatabaseMetaDataImpl",
        "diffLocations": [
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/engine/jdbc/env/internal/ExtractedDatabaseMetaDataImpl.java",
                "startLine": 276,
                "endLine": 319,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/engine/jdbc/env/internal/ExtractedDatabaseMetaDataImpl.java",
                "startLine": 270,
                "endLine": 295,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/engine/jdbc/env/internal/ExtractedDatabaseMetaDataImpl.java",
                "startLine": 297,
                "endLine": 311,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "/**\n\t * Get the sequence information List from the database.\n\t *\n\t * @return sequence information List\n\t */\n\tprivate List<SequenceInformation> sequenceInformationList() {\n\t\tfinal JdbcEnvironment jdbcEnvironment = this.jdbcEnvironment;\n\t\tfinal Dialect dialect = this.jdbcEnvironment.getDialect();\n\n\t\tConnection connection = null;\n\t\ttry {\n\t\t\tconnection = connectionAccess.obtainConnection();\n\t\t\tfinal Connection c = connection;\n\t\t\tIterable<SequenceInformation> sequenceInformationIterable = dialect\n\t\t\t\t\t.getSequenceInformationExtractor()\n\t\t\t\t\t.extractMetadata( new ExtractionContext.EmptyExtractionContext() {\n\t\t\t\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\t\t\t\tpublic Connection getJdbcConnection() {\n\t\t\t\t\t\t\t\t\t\t\treturn c;\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\t\t\t\tpublic JdbcEnvironment getJdbcEnvironment() {\n\t\t\t\t\t\t\t\t\t\t\treturn jdbcEnvironment;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t);\n\t\t\treturn StreamSupport.stream( sequenceInformationIterable.spliterator(), false )\n\t\t\t\t\t.collect( Collectors.toList() );\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow new HibernateException( \"Could not fetch the SequenceInformation from the database\", e );\n\t\t}\n\t\tfinally {\n\t\t\tif ( connection != null ) {\n\t\t\t\ttry {\n\t\t\t\t\tconnectionAccess.releaseConnection( connection );\n\t\t\t\t}\n\t\t\t\tcatch (SQLException throwables) {\n\t\t\t\t\t//ignored\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}",
        "filePathBefore": "hibernate-core/src/main/java/org/hibernate/engine/jdbc/env/internal/ExtractedDatabaseMetaDataImpl.java",
        "isPureRefactoring": true,
        "commitId": "72e42817e3759f3f130eefb302d9aa7a3e0cfa58",
        "packageNameBefore": "org.hibernate.engine.jdbc.env.internal",
        "classNameBefore": "org.hibernate.engine.jdbc.env.internal.ExtractedDatabaseMetaDataImpl",
        "methodNameBefore": "org.hibernate.engine.jdbc.env.internal.ExtractedDatabaseMetaDataImpl#sequenceInformationList",
        "invokedMethod": "methodSignature: org.hibernate.dialect.H2Dialect#getSequenceInformationExtractor\n methodBody: public SequenceInformationExtractor getSequenceInformationExtractor() {\nreturn sequenceInformationExtractor;\n}\nmethodSignature: org.hibernate.community.dialect.H2LegacyDialect#getSequenceInformationExtractor\n methodBody: public SequenceInformationExtractor getSequenceInformationExtractor() {\nreturn sequenceInformationExtractor;\n}\nmethodSignature: org.hibernate.dialect.Dialect#getSequenceInformationExtractor\n methodBody: public SequenceInformationExtractor getSequenceInformationExtractor() {\nreturn getQuerySequencesString() == null ? SequenceInformationExtractorNoOpImpl.INSTANCE : SequenceInformationExtractorLegacyImpl.INSTANCE;\n}\nmethodSignature: org.hibernate.engine.jdbc.env.internal.JdbcEnvironmentInitiator.ConnectionProviderJdbcConnectionAccess#obtainConnection\n methodBody: public Connection obtainConnection() throws SQLException {\nreturn connectionProvider.getConnection();\n}\nmethodSignature: org.hibernate.engine.jdbc.env.internal.JdbcEnvironmentInitiator.MultiTenantConnectionProviderJdbcConnectionAccess#obtainConnection\n methodBody: public Connection obtainConnection() throws SQLException {\nreturn connectionProvider.getAnyConnection();\n}\nmethodSignature: org.hibernate.engine.jdbc.env.internal.JdbcEnvironmentInitiator.ConnectionProviderJdbcConnectionAccess#releaseConnection\n methodBody: public void releaseConnection(Connection connection) throws SQLException {\nconnectionProvider.closeConnection(connection);\n}\nmethodSignature: org.hibernate.engine.jdbc.env.internal.JdbcEnvironmentInitiator.MultiTenantConnectionProviderJdbcConnectionAccess#releaseConnection\n methodBody: public void releaseConnection(Connection connection) throws SQLException {\nconnectionProvider.releaseAnyConnection(connection);\n}",
        "classSignatureBefore": "public class ExtractedDatabaseMetaDataImpl implements ExtractedDatabaseMetaData ",
        "methodNameBeforeSet": [
            "org.hibernate.engine.jdbc.env.internal.ExtractedDatabaseMetaDataImpl#sequenceInformationList"
        ],
        "classNameBeforeSet": [
            "org.hibernate.engine.jdbc.env.internal.ExtractedDatabaseMetaDataImpl"
        ],
        "classSignatureBeforeSet": [
            "public class ExtractedDatabaseMetaDataImpl implements ExtractedDatabaseMetaData "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Overlapped refactoring - can be identical by undoing the overlapped refactoring\n- Inline Variable- Severe changes",
                "description": "Return expression has been added within the Extract Method mechanics - with non-mapped leaves",
                "mappingState": 2
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.\n */\npackage org.hibernate.engine.jdbc.env.internal;\n\nimport java.sql.Connection;\nimport java.sql.DatabaseMetaData;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.stream.Collectors;\nimport java.util.stream.StreamSupport;\n\nimport org.hibernate.HibernateException;\nimport org.hibernate.boot.model.source.internal.hbm.CommaSeparatedStringHelper;\nimport org.hibernate.dialect.Dialect;\nimport org.hibernate.engine.jdbc.connections.spi.JdbcConnectionAccess;\nimport org.hibernate.engine.jdbc.cursor.internal.StandardRefCursorSupport;\nimport org.hibernate.engine.jdbc.env.spi.ExtractedDatabaseMetaData;\nimport org.hibernate.engine.jdbc.env.spi.JdbcEnvironment;\nimport org.hibernate.engine.jdbc.env.spi.SQLStateType;\nimport org.hibernate.tool.schema.extract.spi.ExtractionContext;\nimport org.hibernate.tool.schema.extract.spi.SequenceInformation;\n\n/**\n * Standard implementation of ExtractedDatabaseMetaData\n *\n * @author Steve Ebersole\n */\npublic class ExtractedDatabaseMetaDataImpl implements ExtractedDatabaseMetaData {\n\n\tprivate final JdbcEnvironment jdbcEnvironment;\n\tprivate final JdbcConnectionAccess connectionAccess;\n\n\tprivate final String connectionCatalogName;\n\tprivate final String connectionSchemaName;\n\n\tprivate final boolean supportsRefCursors;\n\tprivate final boolean supportsNamedParameters;\n\tprivate final boolean supportsScrollableResults;\n\tprivate final boolean supportsGetGeneratedKeys;\n\tprivate final boolean supportsBatchUpdates;\n\tprivate final boolean supportsDataDefinitionInTransaction;\n\tprivate final boolean doesDataDefinitionCauseTransactionCommit;\n\tprivate final SQLStateType sqlStateType;\n\tprivate final boolean jdbcMetadataAccessible;\n\n\n\t//Lazily initialized: loading all sequence information upfront has been\n\t//shown to be too slow in some cases. In this way we only load it\n\t//when there is actual need for these details.\n\tprivate List<SequenceInformation> sequenceInformationList;\n\n\tprivate ExtractedDatabaseMetaDataImpl(\n\t\t\tJdbcEnvironment jdbcEnvironment,\n\t\t\tJdbcConnectionAccess connectionAccess,\n\t\t\tString connectionCatalogName,\n\t\t\tString connectionSchemaName,\n\t\t\tboolean supportsRefCursors,\n\t\t\tboolean supportsNamedParameters,\n\t\t\tboolean supportsScrollableResults,\n\t\t\tboolean supportsGetGeneratedKeys,\n\t\t\tboolean supportsBatchUpdates,\n\t\t\tboolean supportsDataDefinitionInTransaction,\n\t\t\tboolean doesDataDefinitionCauseTransactionCommit,\n\t\t\tSQLStateType sqlStateType,\n\t\t\tboolean jdbcMetadataIsAccessible) {\n\t\tthis.jdbcEnvironment = jdbcEnvironment;\n\t\tthis.connectionAccess = connectionAccess;\n\t\tthis.connectionCatalogName = connectionCatalogName;\n\t\tthis.connectionSchemaName = connectionSchemaName;\n\t\tthis.supportsRefCursors = supportsRefCursors;\n\t\tthis.supportsNamedParameters = supportsNamedParameters;\n\t\tthis.supportsScrollableResults = supportsScrollableResults;\n\t\tthis.supportsGetGeneratedKeys = supportsGetGeneratedKeys;\n\t\tthis.supportsBatchUpdates = supportsBatchUpdates;\n\t\tthis.supportsDataDefinitionInTransaction = supportsDataDefinitionInTransaction;\n\t\tthis.doesDataDefinitionCauseTransactionCommit = doesDataDefinitionCauseTransactionCommit;\n\t\tthis.sqlStateType = sqlStateType;\n\t\tthis.jdbcMetadataAccessible = jdbcMetadataIsAccessible;\n\t}\n\n\t@Override\n\tpublic boolean supportsRefCursors() {\n\t\treturn supportsRefCursors;\n\t}\n\n\t@Override\n\tpublic JdbcEnvironment getJdbcEnvironment() {\n\t\treturn jdbcEnvironment;\n\t}\n\n\t@Override\n\tpublic boolean supportsNamedParameters() {\n\t\treturn supportsNamedParameters;\n\t}\n\n\t@Override\n\tpublic boolean supportsScrollableResults() {\n\t\treturn supportsScrollableResults;\n\t}\n\n\t@Override\n\tpublic boolean supportsGetGeneratedKeys() {\n\t\treturn supportsGetGeneratedKeys;\n\t}\n\n\t@Override\n\tpublic boolean supportsBatchUpdates() {\n\t\treturn supportsBatchUpdates;\n\t}\n\n\t@Override\n\tpublic boolean supportsDataDefinitionInTransaction() {\n\t\treturn supportsDataDefinitionInTransaction;\n\t}\n\n\t@Override\n\tpublic boolean doesDataDefinitionCauseTransactionCommit() {\n\t\treturn doesDataDefinitionCauseTransactionCommit;\n\t}\n\n\t@Override\n\tpublic SQLStateType getSqlStateType() {\n\t\treturn sqlStateType;\n\t}\n\n\t@Override\n\tpublic String getConnectionCatalogName() {\n\t\treturn connectionCatalogName;\n\t}\n\n\t@Override\n\tpublic String getConnectionSchemaName() {\n\t\treturn connectionSchemaName;\n\t}\n\n\t@Override\n\tpublic synchronized List<SequenceInformation> getSequenceInformationList() {\n\t\tif ( jdbcMetadataAccessible ) {\n\t\t\t//Loading the sequence information can take a while on large databases,\n\t\t\t//even minutes in some cases.\n\t\t\t//We trigger this lazily as only certain combinations of configurations,\n\t\t\t//mappings and used features actually trigger any use of such details.\n\t\t\tif ( sequenceInformationList == null ) {\n\t\t\t\tsequenceInformationList = sequenceInformationList();\n\t\t\t}\n\t\t\treturn sequenceInformationList;\n\t\t}\n\t\telse {\n\t\t\treturn Collections.emptyList();\n\t\t}\n\t}\n\n\t// For tests\n\tpublic boolean isJdbcMetadataAccessible() {\n\t\treturn jdbcMetadataAccessible;\n\t}\n\n\tpublic static class Builder {\n\t\tprivate final JdbcEnvironment jdbcEnvironment;\n\t\tprivate final boolean jdbcMetadataIsAccessible;\n\t\tprivate final JdbcConnectionAccess connectionAccess;\n\n\t\tprivate String connectionSchemaName;\n\t\tprivate String connectionCatalogName;\n\n\t\tprivate boolean supportsRefCursors;\n\t\tprivate boolean supportsNamedParameters;\n\t\tprivate boolean supportsScrollableResults;\n\t\tprivate boolean supportsGetGeneratedKeys;\n\t\t// In absence of DatabaseMetaData batching updates is assumed to be supported\n\t\tprivate boolean supportsBatchUpdates = true;\n\t\tprivate boolean supportsDataDefinitionInTransaction;\n\t\tprivate boolean doesDataDefinitionCauseTransactionCommit;\n\t\tprivate SQLStateType sqlStateType;\n\n\t\tpublic Builder(JdbcEnvironment jdbcEnvironment, boolean jdbcMetadataIsAccessible, JdbcConnectionAccess connectionAccess) {\n\t\t\tthis.jdbcEnvironment = jdbcEnvironment;\n\t\t\tthis.jdbcMetadataIsAccessible = jdbcMetadataIsAccessible;\n\t\t\tthis.connectionAccess = connectionAccess;\n\t\t}\n\n\t\tpublic Builder apply(DatabaseMetaData databaseMetaData) throws SQLException {\n\t\t\tconnectionCatalogName = databaseMetaData.getConnection().getCatalog();\n\t\t\t// NOTE : databaseMetaData.getConnection().getSchema() would require java 1.7 as baseline\n\t\t\tsupportsRefCursors = StandardRefCursorSupport.supportsRefCursors( databaseMetaData );\n\t\t\tsupportsNamedParameters = databaseMetaData.supportsNamedParameters();\n\t\t\tsupportsScrollableResults = databaseMetaData.supportsResultSetType( ResultSet.TYPE_SCROLL_INSENSITIVE );\n\t\t\tsupportsGetGeneratedKeys = databaseMetaData.supportsGetGeneratedKeys();\n\t\t\tsupportsBatchUpdates = databaseMetaData.supportsBatchUpdates();\n\t\t\tsupportsDataDefinitionInTransaction = !databaseMetaData.dataDefinitionIgnoredInTransactions();\n\t\t\tdoesDataDefinitionCauseTransactionCommit = databaseMetaData.dataDefinitionCausesTransactionCommit();\n\t\t\tsqlStateType = SQLStateType.interpretReportedSQLStateType( databaseMetaData.getSQLStateType() );\n\t\t\treturn this;\n\t\t}\n\n\t\tprivate Set<String> parseKeywords(String extraKeywordsString) {\n\t\t\treturn CommaSeparatedStringHelper.split( extraKeywordsString );\n\t\t}\n\n\t\tpublic Builder setConnectionSchemaName(String connectionSchemaName) {\n\t\t\tthis.connectionSchemaName = connectionSchemaName;\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic Builder setConnectionCatalogName(String connectionCatalogName) {\n\t\t\tthis.connectionCatalogName = connectionCatalogName;\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic Builder setSupportsRefCursors(boolean supportsRefCursors) {\n\t\t\tthis.supportsRefCursors = supportsRefCursors;\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic Builder setSupportsNamedParameters(boolean supportsNamedParameters) {\n\t\t\tthis.supportsNamedParameters = supportsNamedParameters;\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic Builder setSupportsScrollableResults(boolean supportsScrollableResults) {\n\t\t\tthis.supportsScrollableResults = supportsScrollableResults;\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic Builder setSupportsGetGeneratedKeys(boolean supportsGetGeneratedKeys) {\n\t\t\tthis.supportsGetGeneratedKeys = supportsGetGeneratedKeys;\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic Builder setSupportsBatchUpdates(boolean supportsBatchUpdates) {\n\t\t\tthis.supportsBatchUpdates = supportsBatchUpdates;\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic Builder setSupportsDataDefinitionInTransaction(boolean supportsDataDefinitionInTransaction) {\n\t\t\tthis.supportsDataDefinitionInTransaction = supportsDataDefinitionInTransaction;\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic Builder setDoesDataDefinitionCauseTransactionCommit(boolean doesDataDefinitionCauseTransactionCommit) {\n\t\t\tthis.doesDataDefinitionCauseTransactionCommit = doesDataDefinitionCauseTransactionCommit;\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic Builder setSqlStateType(SQLStateType sqlStateType) {\n\t\t\tthis.sqlStateType = sqlStateType;\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ExtractedDatabaseMetaDataImpl build() {\n\t\t\treturn new ExtractedDatabaseMetaDataImpl(\n\t\t\t\t\tjdbcEnvironment,\n\t\t\t\t\tconnectionAccess,\n\t\t\t\t\tconnectionCatalogName,\n\t\t\t\t\tconnectionSchemaName,\n\t\t\t\t\tsupportsRefCursors,\n\t\t\t\t\tsupportsNamedParameters,\n\t\t\t\t\tsupportsScrollableResults,\n\t\t\t\t\tsupportsGetGeneratedKeys,\n\t\t\t\t\tsupportsBatchUpdates,\n\t\t\t\t\tsupportsDataDefinitionInTransaction,\n\t\t\t\t\tdoesDataDefinitionCauseTransactionCommit,\n\t\t\t\t\tsqlStateType,\n\t\t\t\t\tjdbcMetadataIsAccessible\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * Get the sequence information List from the database.\n\t *\n\t * @return sequence information List\n\t */\n\tprivate List<SequenceInformation> sequenceInformationList() {\n\t\tfinal JdbcEnvironment jdbcEnvironment = this.jdbcEnvironment;\n\t\tfinal Dialect dialect = this.jdbcEnvironment.getDialect();\n\n\t\tConnection connection = null;\n\t\ttry {\n\t\t\tconnection = connectionAccess.obtainConnection();\n\t\t\tfinal Connection c = connection;\n\t\t\tIterable<SequenceInformation> sequenceInformationIterable = dialect\n\t\t\t\t\t.getSequenceInformationExtractor()\n\t\t\t\t\t.extractMetadata( new ExtractionContext.EmptyExtractionContext() {\n\t\t\t\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\t\t\t\tpublic Connection getJdbcConnection() {\n\t\t\t\t\t\t\t\t\t\t\treturn c;\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\t\t\t\tpublic JdbcEnvironment getJdbcEnvironment() {\n\t\t\t\t\t\t\t\t\t\t\treturn jdbcEnvironment;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t);\n\t\t\treturn StreamSupport.stream( sequenceInformationIterable.spliterator(), false )\n\t\t\t\t\t.collect( Collectors.toList() );\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow new HibernateException( \"Could not fetch the SequenceInformation from the database\", e );\n\t\t}\n\t\tfinally {\n\t\t\tif ( connection != null ) {\n\t\t\t\ttry {\n\t\t\t\t\tconnectionAccess.releaseConnection( connection );\n\t\t\t\t}\n\t\t\t\tcatch (SQLException throwables) {\n\t\t\t\t\t//ignored\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n}\n",
        "filePathAfter": "hibernate-core/src/main/java/org/hibernate/engine/jdbc/env/internal/ExtractedDatabaseMetaDataImpl.java",
        "sourceCodeAfterForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.\n */\npackage org.hibernate.engine.jdbc.env.internal;\n\nimport java.sql.Connection;\nimport java.sql.DatabaseMetaData;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.stream.Collectors;\n\nimport org.hibernate.HibernateException;\nimport org.hibernate.engine.jdbc.connections.spi.JdbcConnectionAccess;\nimport org.hibernate.engine.jdbc.cursor.internal.StandardRefCursorSupport;\nimport org.hibernate.engine.jdbc.env.spi.ExtractedDatabaseMetaData;\nimport org.hibernate.engine.jdbc.env.spi.JdbcEnvironment;\nimport org.hibernate.engine.jdbc.env.spi.SQLStateType;\nimport org.hibernate.tool.schema.extract.spi.ExtractionContext;\nimport org.hibernate.tool.schema.extract.spi.SequenceInformation;\n\nimport static java.util.stream.StreamSupport.stream;\n\n/**\n * Standard implementation of ExtractedDatabaseMetaData\n *\n * @author Steve Ebersole\n */\npublic class ExtractedDatabaseMetaDataImpl implements ExtractedDatabaseMetaData {\n\n\tprivate final JdbcEnvironment jdbcEnvironment;\n\tprivate final JdbcConnectionAccess connectionAccess;\n\n\tprivate final String connectionCatalogName;\n\tprivate final String connectionSchemaName;\n\n\tprivate final boolean supportsRefCursors;\n\tprivate final boolean supportsNamedParameters;\n\tprivate final boolean supportsScrollableResults;\n\tprivate final boolean supportsGetGeneratedKeys;\n\tprivate final boolean supportsBatchUpdates;\n\tprivate final boolean supportsDataDefinitionInTransaction;\n\tprivate final boolean doesDataDefinitionCauseTransactionCommit;\n\tprivate final SQLStateType sqlStateType;\n\tprivate final boolean jdbcMetadataAccessible;\n\n\n\t//Lazily initialized: loading all sequence information upfront has been\n\t//shown to be too slow in some cases. In this way we only load it\n\t//when there is actual need for these details.\n\tprivate List<SequenceInformation> sequenceInformationList;\n\n\tprivate ExtractedDatabaseMetaDataImpl(\n\t\t\tJdbcEnvironment jdbcEnvironment,\n\t\t\tJdbcConnectionAccess connectionAccess,\n\t\t\tString connectionCatalogName,\n\t\t\tString connectionSchemaName,\n\t\t\tboolean supportsRefCursors,\n\t\t\tboolean supportsNamedParameters,\n\t\t\tboolean supportsScrollableResults,\n\t\t\tboolean supportsGetGeneratedKeys,\n\t\t\tboolean supportsBatchUpdates,\n\t\t\tboolean supportsDataDefinitionInTransaction,\n\t\t\tboolean doesDataDefinitionCauseTransactionCommit,\n\t\t\tSQLStateType sqlStateType,\n\t\t\tboolean jdbcMetadataIsAccessible) {\n\t\tthis.jdbcEnvironment = jdbcEnvironment;\n\t\tthis.connectionAccess = connectionAccess;\n\t\tthis.connectionCatalogName = connectionCatalogName;\n\t\tthis.connectionSchemaName = connectionSchemaName;\n\t\tthis.supportsRefCursors = supportsRefCursors;\n\t\tthis.supportsNamedParameters = supportsNamedParameters;\n\t\tthis.supportsScrollableResults = supportsScrollableResults;\n\t\tthis.supportsGetGeneratedKeys = supportsGetGeneratedKeys;\n\t\tthis.supportsBatchUpdates = supportsBatchUpdates;\n\t\tthis.supportsDataDefinitionInTransaction = supportsDataDefinitionInTransaction;\n\t\tthis.doesDataDefinitionCauseTransactionCommit = doesDataDefinitionCauseTransactionCommit;\n\t\tthis.sqlStateType = sqlStateType;\n\t\tthis.jdbcMetadataAccessible = jdbcMetadataIsAccessible;\n\t}\n\n\t@Override\n\tpublic boolean supportsRefCursors() {\n\t\treturn supportsRefCursors;\n\t}\n\n\t@Override\n\tpublic JdbcEnvironment getJdbcEnvironment() {\n\t\treturn jdbcEnvironment;\n\t}\n\n\t@Override\n\tpublic boolean supportsNamedParameters() {\n\t\treturn supportsNamedParameters;\n\t}\n\n\t@Override\n\tpublic boolean supportsScrollableResults() {\n\t\treturn supportsScrollableResults;\n\t}\n\n\t@Override\n\tpublic boolean supportsGetGeneratedKeys() {\n\t\treturn supportsGetGeneratedKeys;\n\t}\n\n\t@Override\n\tpublic boolean supportsBatchUpdates() {\n\t\treturn supportsBatchUpdates;\n\t}\n\n\t@Override\n\tpublic boolean supportsDataDefinitionInTransaction() {\n\t\treturn supportsDataDefinitionInTransaction;\n\t}\n\n\t@Override\n\tpublic boolean doesDataDefinitionCauseTransactionCommit() {\n\t\treturn doesDataDefinitionCauseTransactionCommit;\n\t}\n\n\t@Override\n\tpublic SQLStateType getSqlStateType() {\n\t\treturn sqlStateType;\n\t}\n\n\t@Override\n\tpublic String getConnectionCatalogName() {\n\t\treturn connectionCatalogName;\n\t}\n\n\t@Override\n\tpublic String getConnectionSchemaName() {\n\t\treturn connectionSchemaName;\n\t}\n\n\t@Override\n\tpublic synchronized List<SequenceInformation> getSequenceInformationList() {\n\t\tif ( jdbcMetadataAccessible ) {\n\t\t\t//Loading the sequence information can take a while on large databases,\n\t\t\t//even minutes in some cases.\n\t\t\t//We trigger this lazily as only certain combinations of configurations,\n\t\t\t//mappings and used features actually trigger any use of such details.\n\t\t\tif ( sequenceInformationList == null ) {\n\t\t\t\tsequenceInformationList = sequenceInformationList();\n\t\t\t}\n\t\t\treturn sequenceInformationList;\n\t\t}\n\t\telse {\n\t\t\treturn Collections.emptyList();\n\t\t}\n\t}\n\n\t// For tests\n\tpublic boolean isJdbcMetadataAccessible() {\n\t\treturn jdbcMetadataAccessible;\n\t}\n\n\tpublic static class Builder {\n\t\tprivate final JdbcEnvironment jdbcEnvironment;\n\t\tprivate final boolean jdbcMetadataIsAccessible;\n\t\tprivate final JdbcConnectionAccess connectionAccess;\n\n\t\tprivate String connectionSchemaName;\n\t\tprivate String connectionCatalogName;\n\n\t\tprivate boolean supportsRefCursors;\n\t\tprivate boolean supportsNamedParameters;\n\t\tprivate boolean supportsScrollableResults;\n\t\tprivate boolean supportsGetGeneratedKeys;\n\t\t// In absence of DatabaseMetaData batching updates is assumed to be supported\n\t\tprivate boolean supportsBatchUpdates = true;\n\t\tprivate boolean supportsDataDefinitionInTransaction;\n\t\tprivate boolean doesDataDefinitionCauseTransactionCommit;\n\t\tprivate SQLStateType sqlStateType;\n\n\t\tpublic Builder(JdbcEnvironment jdbcEnvironment, boolean jdbcMetadataIsAccessible, JdbcConnectionAccess connectionAccess) {\n\t\t\tthis.jdbcEnvironment = jdbcEnvironment;\n\t\t\tthis.jdbcMetadataIsAccessible = jdbcMetadataIsAccessible;\n\t\t\tthis.connectionAccess = connectionAccess;\n\t\t}\n\n\t\tpublic Builder apply(DatabaseMetaData databaseMetaData) throws SQLException {\n\t\t\tconnectionCatalogName = databaseMetaData.getConnection().getCatalog();\n\t\t\t// NOTE : databaseMetaData.getConnection().getSchema() would require java 1.7 as baseline\n\t\t\tsupportsRefCursors = StandardRefCursorSupport.supportsRefCursors( databaseMetaData );\n\t\t\tsupportsNamedParameters = databaseMetaData.supportsNamedParameters();\n\t\t\tsupportsScrollableResults = databaseMetaData.supportsResultSetType( ResultSet.TYPE_SCROLL_INSENSITIVE );\n\t\t\tsupportsGetGeneratedKeys = databaseMetaData.supportsGetGeneratedKeys();\n\t\t\tsupportsBatchUpdates = databaseMetaData.supportsBatchUpdates();\n\t\t\tsupportsDataDefinitionInTransaction = !databaseMetaData.dataDefinitionIgnoredInTransactions();\n\t\t\tdoesDataDefinitionCauseTransactionCommit = databaseMetaData.dataDefinitionCausesTransactionCommit();\n\t\t\tsqlStateType = SQLStateType.interpretReportedSQLStateType( databaseMetaData.getSQLStateType() );\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic Builder setConnectionSchemaName(String connectionSchemaName) {\n\t\t\tthis.connectionSchemaName = connectionSchemaName;\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic Builder setConnectionCatalogName(String connectionCatalogName) {\n\t\t\tthis.connectionCatalogName = connectionCatalogName;\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic Builder setSupportsRefCursors(boolean supportsRefCursors) {\n\t\t\tthis.supportsRefCursors = supportsRefCursors;\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic Builder setSupportsNamedParameters(boolean supportsNamedParameters) {\n\t\t\tthis.supportsNamedParameters = supportsNamedParameters;\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic Builder setSupportsScrollableResults(boolean supportsScrollableResults) {\n\t\t\tthis.supportsScrollableResults = supportsScrollableResults;\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic Builder setSupportsGetGeneratedKeys(boolean supportsGetGeneratedKeys) {\n\t\t\tthis.supportsGetGeneratedKeys = supportsGetGeneratedKeys;\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic Builder setSupportsBatchUpdates(boolean supportsBatchUpdates) {\n\t\t\tthis.supportsBatchUpdates = supportsBatchUpdates;\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic Builder setSupportsDataDefinitionInTransaction(boolean supportsDataDefinitionInTransaction) {\n\t\t\tthis.supportsDataDefinitionInTransaction = supportsDataDefinitionInTransaction;\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic Builder setDoesDataDefinitionCauseTransactionCommit(boolean doesDataDefinitionCauseTransactionCommit) {\n\t\t\tthis.doesDataDefinitionCauseTransactionCommit = doesDataDefinitionCauseTransactionCommit;\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic Builder setSqlStateType(SQLStateType sqlStateType) {\n\t\t\tthis.sqlStateType = sqlStateType;\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ExtractedDatabaseMetaDataImpl build() {\n\t\t\treturn new ExtractedDatabaseMetaDataImpl(\n\t\t\t\t\tjdbcEnvironment,\n\t\t\t\t\tconnectionAccess,\n\t\t\t\t\tconnectionCatalogName,\n\t\t\t\t\tconnectionSchemaName,\n\t\t\t\t\tsupportsRefCursors,\n\t\t\t\t\tsupportsNamedParameters,\n\t\t\t\t\tsupportsScrollableResults,\n\t\t\t\t\tsupportsGetGeneratedKeys,\n\t\t\t\t\tsupportsBatchUpdates,\n\t\t\t\t\tsupportsDataDefinitionInTransaction,\n\t\t\t\t\tdoesDataDefinitionCauseTransactionCommit,\n\t\t\t\t\tsqlStateType,\n\t\t\t\t\tjdbcMetadataIsAccessible\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * Get the sequence information List from the database.\n\t *\n\t * @return sequence information List\n\t */\n\tprivate List<SequenceInformation> sequenceInformationList() {\n\t\tConnection connection = null;\n\t\ttry {\n\t\t\tconnection = connectionAccess.obtainConnection();\n\t\t\treturn stream( sequenceInformation( connection, jdbcEnvironment ).spliterator(), false )\n\t\t\t\t\t.collect( Collectors.toList() );\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow new HibernateException( \"Could not fetch the SequenceInformation from the database\", e );\n\t\t}\n\t\tfinally {\n\t\t\tif ( connection != null ) {\n\t\t\t\ttry {\n\t\t\t\t\tconnectionAccess.releaseConnection( connection );\n\t\t\t\t}\n\t\t\t\tcatch (SQLException exception) {\n\t\t\t\t\t//ignored\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate static Iterable<SequenceInformation> sequenceInformation(Connection connection, JdbcEnvironment jdbcEnvironment)\n\t\t\tthrows SQLException {\n\t\treturn jdbcEnvironment.getDialect().getSequenceInformationExtractor().extractMetadata(\n\t\t\t\tnew ExtractionContext.EmptyExtractionContext() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic Connection getJdbcConnection() {\n\t\t\t\t\t\treturn connection;\n\t\t\t\t\t}\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic JdbcEnvironment getJdbcEnvironment() {\n\t\t\t\t\t\treturn jdbcEnvironment;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t);\n\t}\n}\n",
        "diffSourceCodeSet": [
            "private static Iterable<SequenceInformation> sequenceInformation(Connection connection, JdbcEnvironment jdbcEnvironment)\n\t\t\tthrows SQLException {\n\t\treturn jdbcEnvironment.getDialect().getSequenceInformationExtractor().extractMetadata(\n\t\t\t\tnew ExtractionContext.EmptyExtractionContext() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic Connection getJdbcConnection() {\n\t\t\t\t\t\treturn connection;\n\t\t\t\t\t}\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic JdbcEnvironment getJdbcEnvironment() {\n\t\t\t\t\t\treturn jdbcEnvironment;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t);\n\t}"
        ],
        "invokedMethodSet": [
            "methodSignature: org.hibernate.dialect.H2Dialect#getSequenceInformationExtractor\n methodBody: public SequenceInformationExtractor getSequenceInformationExtractor() {\nreturn sequenceInformationExtractor;\n}",
            "methodSignature: org.hibernate.community.dialect.H2LegacyDialect#getSequenceInformationExtractor\n methodBody: public SequenceInformationExtractor getSequenceInformationExtractor() {\nreturn sequenceInformationExtractor;\n}",
            "methodSignature: org.hibernate.dialect.Dialect#getSequenceInformationExtractor\n methodBody: public SequenceInformationExtractor getSequenceInformationExtractor() {\nreturn getQuerySequencesString() == null ? SequenceInformationExtractorNoOpImpl.INSTANCE : SequenceInformationExtractorLegacyImpl.INSTANCE;\n}",
            "methodSignature: org.hibernate.engine.jdbc.env.internal.JdbcEnvironmentInitiator.ConnectionProviderJdbcConnectionAccess#obtainConnection\n methodBody: public Connection obtainConnection() throws SQLException {\nreturn connectionProvider.getConnection();\n}",
            "methodSignature: org.hibernate.engine.jdbc.env.internal.JdbcEnvironmentInitiator.MultiTenantConnectionProviderJdbcConnectionAccess#obtainConnection\n methodBody: public Connection obtainConnection() throws SQLException {\nreturn connectionProvider.getAnyConnection();\n}",
            "methodSignature: org.hibernate.engine.jdbc.env.internal.JdbcEnvironmentInitiator.ConnectionProviderJdbcConnectionAccess#releaseConnection\n methodBody: public void releaseConnection(Connection connection) throws SQLException {\nconnectionProvider.closeConnection(connection);\n}",
            "methodSignature: org.hibernate.engine.jdbc.env.internal.JdbcEnvironmentInitiator.MultiTenantConnectionProviderJdbcConnectionAccess#releaseConnection\n methodBody: public void releaseConnection(Connection connection) throws SQLException {\nconnectionProvider.releaseAnyConnection(connection);\n}"
        ],
        "sourceCodeAfterRefactoring": "/**\n\t * Get the sequence information List from the database.\n\t *\n\t * @return sequence information List\n\t */\n\tprivate List<SequenceInformation> sequenceInformationList() {\n\t\tConnection connection = null;\n\t\ttry {\n\t\t\tconnection = connectionAccess.obtainConnection();\n\t\t\treturn stream( sequenceInformation( connection, jdbcEnvironment ).spliterator(), false )\n\t\t\t\t\t.collect( Collectors.toList() );\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow new HibernateException( \"Could not fetch the SequenceInformation from the database\", e );\n\t\t}\n\t\tfinally {\n\t\t\tif ( connection != null ) {\n\t\t\t\ttry {\n\t\t\t\t\tconnectionAccess.releaseConnection( connection );\n\t\t\t\t}\n\t\t\t\tcatch (SQLException exception) {\n\t\t\t\t\t//ignored\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\nprivate static Iterable<SequenceInformation> sequenceInformation(Connection connection, JdbcEnvironment jdbcEnvironment)\n\t\t\tthrows SQLException {\n\t\treturn jdbcEnvironment.getDialect().getSequenceInformationExtractor().extractMetadata(\n\t\t\t\tnew ExtractionContext.EmptyExtractionContext() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic Connection getJdbcConnection() {\n\t\t\t\t\t\treturn connection;\n\t\t\t\t\t}\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic JdbcEnvironment getJdbcEnvironment() {\n\t\t\t\t\t\treturn jdbcEnvironment;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t);\n\t}",
        "diffSourceCode": "-  270: \t\t\t\t\tsqlStateType,\n-  271: \t\t\t\t\tjdbcMetadataIsAccessible\n-  272: \t\t\t);\n-  273: \t\t}\n-  274: \t}\n-  275: \n-  276: \t/**\n-  277: \t * Get the sequence information List from the database.\n-  278: \t *\n-  279: \t * @return sequence information List\n-  280: \t */\n-  281: \tprivate List<SequenceInformation> sequenceInformationList() {\n-  282: \t\tfinal JdbcEnvironment jdbcEnvironment = this.jdbcEnvironment;\n-  283: \t\tfinal Dialect dialect = this.jdbcEnvironment.getDialect();\n-  284: \n-  285: \t\tConnection connection = null;\n-  286: \t\ttry {\n-  287: \t\t\tconnection = connectionAccess.obtainConnection();\n-  288: \t\t\tfinal Connection c = connection;\n-  289: \t\t\tIterable<SequenceInformation> sequenceInformationIterable = dialect\n-  290: \t\t\t\t\t.getSequenceInformationExtractor()\n-  291: \t\t\t\t\t.extractMetadata( new ExtractionContext.EmptyExtractionContext() {\n-  292: \t\t\t\t\t\t\t\t\t\t@Override\n-  293: \t\t\t\t\t\t\t\t\t\tpublic Connection getJdbcConnection() {\n-  294: \t\t\t\t\t\t\t\t\t\t\treturn c;\n-  295: \t\t\t\t\t\t\t\t\t\t}\n+  270: \t/**\n+  271: \t * Get the sequence information List from the database.\n+  272: \t *\n+  273: \t * @return sequence information List\n+  274: \t */\n+  275: \tprivate List<SequenceInformation> sequenceInformationList() {\n+  276: \t\tConnection connection = null;\n+  277: \t\ttry {\n+  278: \t\t\tconnection = connectionAccess.obtainConnection();\n+  279: \t\t\treturn stream( sequenceInformation( connection, jdbcEnvironment ).spliterator(), false )\n+  280: \t\t\t\t\t.collect( Collectors.toList() );\n+  281: \t\t}\n+  282: \t\tcatch (SQLException e) {\n+  283: \t\t\tthrow new HibernateException( \"Could not fetch the SequenceInformation from the database\", e );\n+  284: \t\t}\n+  285: \t\tfinally {\n+  286: \t\t\tif ( connection != null ) {\n+  287: \t\t\t\ttry {\n+  288: \t\t\t\t\tconnectionAccess.releaseConnection( connection );\n+  289: \t\t\t\t}\n+  290: \t\t\t\tcatch (SQLException exception) {\n+  291: \t\t\t\t\t//ignored\n+  292: \t\t\t\t}\n+  293: \t\t\t}\n+  294: \t\t}\n+  295: \t}\n   296: \n-  297: \t\t\t\t\t\t\t\t\t\t@Override\n-  298: \t\t\t\t\t\t\t\t\t\tpublic JdbcEnvironment getJdbcEnvironment() {\n-  299: \t\t\t\t\t\t\t\t\t\t\treturn jdbcEnvironment;\n-  300: \t\t\t\t\t\t\t\t\t\t}\n-  301: \t\t\t\t\t\t\t\t\t}\n-  302: \t\t\t\t\t);\n-  303: \t\t\treturn StreamSupport.stream( sequenceInformationIterable.spliterator(), false )\n-  304: \t\t\t\t\t.collect( Collectors.toList() );\n-  305: \t\t}\n-  306: \t\tcatch (SQLException e) {\n-  307: \t\t\tthrow new HibernateException( \"Could not fetch the SequenceInformation from the database\", e );\n-  308: \t\t}\n-  309: \t\tfinally {\n-  310: \t\t\tif ( connection != null ) {\n-  311: \t\t\t\ttry {\n-  312: \t\t\t\t\tconnectionAccess.releaseConnection( connection );\n-  313: \t\t\t\t}\n-  314: \t\t\t\tcatch (SQLException throwables) {\n-  315: \t\t\t\t\t//ignored\n-  316: \t\t\t\t}\n-  317: \t\t\t}\n-  318: \t\t}\n-  319: \t}\n+  297: \tprivate static Iterable<SequenceInformation> sequenceInformation(Connection connection, JdbcEnvironment jdbcEnvironment)\n+  298: \t\t\tthrows SQLException {\n+  299: \t\treturn jdbcEnvironment.getDialect().getSequenceInformationExtractor().extractMetadata(\n+  300: \t\t\t\tnew ExtractionContext.EmptyExtractionContext() {\n+  301: \t\t\t\t\t@Override\n+  302: \t\t\t\t\tpublic Connection getJdbcConnection() {\n+  303: \t\t\t\t\t\treturn connection;\n+  304: \t\t\t\t\t}\n+  305: \t\t\t\t\t@Override\n+  306: \t\t\t\t\tpublic JdbcEnvironment getJdbcEnvironment() {\n+  307: \t\t\t\t\t\treturn jdbcEnvironment;\n+  308: \t\t\t\t\t}\n+  309: \t\t\t\t}\n+  310: \t\t);\n+  311: \t}\n+  312: }\n",
        "uniqueId": "72e42817e3759f3f130eefb302d9aa7a3e0cfa58_276_319_297_311_270_295",
        "moveFileExist": true,
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 21,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 8,
                "covered": 26
            },
            "BRANCH": {
                "missed": 1,
                "covered": 1
            },
            "LINE": {
                "missed": 3,
                "covered": 7
            },
            "COMPLEXITY": {
                "missed": 1,
                "covered": 1
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        }
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprotected mappingDefinedAttributeOverrideOnElement(property MemberDetails) : boolean extracted from private annotatedElementType(isEmbedded boolean, isPrimitive boolean, property MemberDetails, elementClass ClassDetails) : AnnotatedClassType in class org.hibernate.boot.model.internal.CollectionBinder",
        "diffLocations": [
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/boot/model/internal/CollectionBinder.java",
                "startLine": 2349,
                "endLine": 2366,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/boot/model/internal/CollectionBinder.java",
                "startLine": 2349,
                "endLine": 2365,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/boot/model/internal/CollectionBinder.java",
                "startLine": 2367,
                "endLine": 2370,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "private AnnotatedClassType annotatedElementType(\n\t\t\tboolean isEmbedded,\n\t\t\tboolean isPrimitive,\n\t\t\tMemberDetails property,\n\t\t\tClassDetails elementClass) {\n\t\tif ( isPrimitive ) {\n\t\t\treturn NONE;\n\t\t}\n\t\telse {\n\t\t\t//force in case of attribute override\n\t\t\tfinal boolean attributeOverride = property.hasDirectAnnotationUsage( AttributeOverride.class )\n\t\t\t\t\t|| property.hasDirectAnnotationUsage( AttributeOverrides.class );\n\t\t\t// todo : force in the case of Convert annotation(s) with embedded paths (beyond key/value prefixes)?\n\t\t\treturn isEmbedded || attributeOverride\n\t\t\t\t\t? EMBEDDABLE\n\t\t\t\t\t: buildingContext.getMetadataCollector().getClassType( elementClass );\n\t\t}\n\t}",
        "filePathBefore": "hibernate-core/src/main/java/org/hibernate/boot/model/internal/CollectionBinder.java",
        "isPureRefactoring": true,
        "commitId": "ad6f326090f856d4de26935428a89b1cc0f3644e",
        "packageNameBefore": "org.hibernate.boot.model.internal",
        "classNameBefore": "org.hibernate.boot.model.internal.CollectionBinder",
        "methodNameBefore": "org.hibernate.boot.model.internal.CollectionBinder#annotatedElementType",
        "classSignatureBefore": "public abstract class CollectionBinder ",
        "methodNameBeforeSet": [
            "org.hibernate.boot.model.internal.CollectionBinder#annotatedElementType"
        ],
        "classNameBeforeSet": [
            "org.hibernate.boot.model.internal.CollectionBinder"
        ],
        "classSignatureBeforeSet": [
            "public abstract class CollectionBinder "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n * See the lgpl.txt file in the root directory or http://www.gnu.org/licenses/lgpl-2.1.html.\n */\npackage org.hibernate.boot.model.internal;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.invoke.MethodHandles;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Properties;\nimport java.util.function.Supplier;\n\nimport org.hibernate.AnnotationException;\nimport org.hibernate.AssertionFailure;\nimport org.hibernate.FetchMode;\nimport org.hibernate.MappingException;\nimport org.hibernate.annotations.Bag;\nimport org.hibernate.annotations.Cache;\nimport org.hibernate.annotations.CacheLayout;\nimport org.hibernate.annotations.Cascade;\nimport org.hibernate.annotations.Check;\nimport org.hibernate.annotations.Checks;\nimport org.hibernate.annotations.CollectionId;\nimport org.hibernate.annotations.CollectionIdJavaType;\nimport org.hibernate.annotations.CollectionIdJdbcType;\nimport org.hibernate.annotations.CollectionIdJdbcTypeCode;\nimport org.hibernate.annotations.CollectionType;\nimport org.hibernate.annotations.Columns;\nimport org.hibernate.annotations.CompositeType;\nimport org.hibernate.annotations.Fetch;\nimport org.hibernate.annotations.FetchProfileOverride;\nimport org.hibernate.annotations.Filter;\nimport org.hibernate.annotations.FilterJoinTable;\nimport org.hibernate.annotations.Formula;\nimport org.hibernate.annotations.HQLSelect;\nimport org.hibernate.annotations.Immutable;\nimport org.hibernate.annotations.LazyGroup;\nimport org.hibernate.annotations.ListIndexBase;\nimport org.hibernate.annotations.ListIndexJavaType;\nimport org.hibernate.annotations.ListIndexJdbcType;\nimport org.hibernate.annotations.ListIndexJdbcTypeCode;\nimport org.hibernate.annotations.ManyToAny;\nimport org.hibernate.annotations.MapKeyJavaType;\nimport org.hibernate.annotations.MapKeyJdbcType;\nimport org.hibernate.annotations.MapKeyJdbcTypeCode;\nimport org.hibernate.annotations.MapKeyMutability;\nimport org.hibernate.annotations.MapKeyType;\nimport org.hibernate.annotations.NotFound;\nimport org.hibernate.annotations.NotFoundAction;\nimport org.hibernate.annotations.OnDelete;\nimport org.hibernate.annotations.OnDeleteAction;\nimport org.hibernate.annotations.OptimisticLock;\nimport org.hibernate.annotations.Parameter;\nimport org.hibernate.annotations.QueryCacheLayout;\nimport org.hibernate.annotations.SQLDelete;\nimport org.hibernate.annotations.SQLDeleteAll;\nimport org.hibernate.annotations.SQLInsert;\nimport org.hibernate.annotations.SQLJoinTableRestriction;\nimport org.hibernate.annotations.SQLOrder;\nimport org.hibernate.annotations.SQLRestriction;\nimport org.hibernate.annotations.SQLSelect;\nimport org.hibernate.annotations.SQLUpdate;\nimport org.hibernate.annotations.SoftDelete;\nimport org.hibernate.annotations.SortComparator;\nimport org.hibernate.annotations.SortNatural;\nimport org.hibernate.annotations.SqlFragmentAlias;\nimport org.hibernate.annotations.Synchronize;\nimport org.hibernate.boot.BootLogging;\nimport org.hibernate.boot.model.IdentifierGeneratorDefinition;\nimport org.hibernate.boot.model.TypeDefinition;\nimport org.hibernate.boot.models.JpaAnnotations;\nimport org.hibernate.boot.models.annotations.internal.JoinColumnJpaAnnotation;\nimport org.hibernate.boot.models.annotations.internal.MapKeyColumnJpaAnnotation;\nimport org.hibernate.boot.spi.AccessType;\nimport org.hibernate.boot.spi.InFlightMetadataCollector;\nimport org.hibernate.boot.spi.InFlightMetadataCollector.CollectionTypeRegistrationDescriptor;\nimport org.hibernate.boot.spi.MetadataBuildingContext;\nimport org.hibernate.boot.spi.PropertyData;\nimport org.hibernate.boot.spi.SecondPass;\nimport org.hibernate.engine.jdbc.env.spi.JdbcEnvironment;\nimport org.hibernate.engine.spi.FilterDefinition;\nimport org.hibernate.internal.CoreMessageLogger;\nimport org.hibernate.internal.util.StringHelper;\nimport org.hibernate.internal.util.collections.ArrayHelper;\nimport org.hibernate.internal.util.collections.CollectionHelper;\nimport org.hibernate.jdbc.Expectation;\nimport org.hibernate.mapping.Any;\nimport org.hibernate.mapping.Backref;\nimport org.hibernate.mapping.CheckConstraint;\nimport org.hibernate.mapping.Collection;\nimport org.hibernate.mapping.Column;\nimport org.hibernate.mapping.Component;\nimport org.hibernate.mapping.DependantValue;\nimport org.hibernate.mapping.Join;\nimport org.hibernate.mapping.KeyValue;\nimport org.hibernate.mapping.ManyToOne;\nimport org.hibernate.mapping.PersistentClass;\nimport org.hibernate.mapping.Property;\nimport org.hibernate.mapping.Selectable;\nimport org.hibernate.mapping.SimpleValue;\nimport org.hibernate.mapping.Table;\nimport org.hibernate.mapping.Value;\nimport org.hibernate.metamodel.CollectionClassification;\nimport org.hibernate.metamodel.UnsupportedMappingException;\nimport org.hibernate.metamodel.spi.EmbeddableInstantiator;\nimport org.hibernate.models.internal.ClassTypeDetailsImpl;\nimport org.hibernate.models.spi.ClassDetails;\nimport org.hibernate.models.spi.ClassDetailsRegistry;\nimport org.hibernate.models.spi.MemberDetails;\nimport org.hibernate.models.spi.SourceModelBuildingContext;\nimport org.hibernate.models.spi.TypeDetails;\nimport org.hibernate.resource.beans.spi.ManagedBean;\nimport org.hibernate.resource.beans.spi.ManagedBeanRegistry;\nimport org.hibernate.usertype.CompositeUserType;\nimport org.hibernate.usertype.ParameterizedType;\nimport org.hibernate.usertype.UserCollectionType;\n\nimport org.jboss.logging.Logger;\n\nimport jakarta.persistence.Access;\nimport jakarta.persistence.AttributeOverride;\nimport jakarta.persistence.AttributeOverrides;\nimport jakarta.persistence.CollectionTable;\nimport jakarta.persistence.ConstraintMode;\nimport jakarta.persistence.ElementCollection;\nimport jakarta.persistence.Embedded;\nimport jakarta.persistence.Entity;\nimport jakarta.persistence.FetchType;\nimport jakarta.persistence.ForeignKey;\nimport jakarta.persistence.Index;\nimport jakarta.persistence.JoinColumn;\nimport jakarta.persistence.JoinColumns;\nimport jakarta.persistence.JoinTable;\nimport jakarta.persistence.ManyToMany;\nimport jakarta.persistence.MapKey;\nimport jakarta.persistence.MapKeyColumn;\nimport jakarta.persistence.MapKeyJoinColumn;\nimport jakarta.persistence.OneToMany;\nimport jakarta.persistence.OrderBy;\nimport jakarta.persistence.OrderColumn;\nimport jakarta.persistence.UniqueConstraint;\n\nimport static jakarta.persistence.AccessType.PROPERTY;\nimport static jakarta.persistence.ConstraintMode.NO_CONSTRAINT;\nimport static jakarta.persistence.ConstraintMode.PROVIDER_DEFAULT;\nimport static jakarta.persistence.FetchType.LAZY;\nimport static org.hibernate.boot.model.internal.AnnotatedClassType.EMBEDDABLE;\nimport static org.hibernate.boot.model.internal.AnnotatedClassType.NONE;\nimport static org.hibernate.boot.model.internal.AnnotatedColumn.buildColumnFromAnnotation;\nimport static org.hibernate.boot.model.internal.AnnotatedColumn.buildColumnFromNoAnnotation;\nimport static org.hibernate.boot.model.internal.AnnotatedColumn.buildColumnsFromAnnotations;\nimport static org.hibernate.boot.model.internal.AnnotatedColumn.buildFormulaFromAnnotation;\nimport static org.hibernate.boot.model.internal.AnnotatedJoinColumns.buildJoinColumnsWithDefaultColumnSuffix;\nimport static org.hibernate.boot.model.internal.AnnotatedJoinColumns.buildJoinTableJoinColumns;\nimport static org.hibernate.boot.model.internal.BinderHelper.buildAnyValue;\nimport static org.hibernate.boot.model.internal.BinderHelper.checkMappedByType;\nimport static org.hibernate.boot.model.internal.BinderHelper.createSyntheticPropertyReference;\nimport static org.hibernate.boot.model.internal.BinderHelper.extractFromPackage;\nimport static org.hibernate.boot.model.internal.BinderHelper.getCascadeStrategy;\nimport static org.hibernate.boot.model.internal.BinderHelper.getFetchMode;\nimport static org.hibernate.boot.model.internal.BinderHelper.getPath;\nimport static org.hibernate.boot.model.internal.BinderHelper.isDefault;\nimport static org.hibernate.boot.model.internal.BinderHelper.isPrimitive;\nimport static org.hibernate.boot.model.internal.DialectOverridesAnnotationHelper.getOverridableAnnotation;\nimport static org.hibernate.boot.model.internal.EmbeddableBinder.fillEmbeddable;\nimport static org.hibernate.boot.model.internal.GeneratorBinder.buildGenerators;\nimport static org.hibernate.boot.model.internal.PropertyHolderBuilder.buildPropertyHolder;\nimport static org.hibernate.engine.spi.ExecuteUpdateResultCheckStyle.fromResultCheckStyle;\nimport static org.hibernate.internal.util.ReflectHelper.getDefaultSupplier;\nimport static org.hibernate.internal.util.StringHelper.getNonEmptyOrConjunctionIfBothNonEmpty;\nimport static org.hibernate.internal.util.StringHelper.isEmpty;\nimport static org.hibernate.internal.util.StringHelper.isNotEmpty;\nimport static org.hibernate.internal.util.StringHelper.nullIfEmpty;\nimport static org.hibernate.internal.util.StringHelper.qualify;\nimport static org.hibernate.mapping.MappingHelper.createLocalUserCollectionTypeBean;\n\n/**\n * Base class for stateful binders responsible for producing mapping model objects of type {@link Collection}.\n *\n * @author inger\n * @author Emmanuel Bernard\n */\npublic abstract class CollectionBinder {\n\tprivate static final CoreMessageLogger LOG = Logger.getMessageLogger( MethodHandles.lookup(), CoreMessageLogger.class, CollectionBinder.class.getName() );\n\n\tprivate static final List<Class<?>> INFERRED_CLASS_PRIORITY = List.of(\n\t\t\tList.class,\n\t\t\tjava.util.SortedSet.class,\n\t\t\tjava.util.Set.class,\n\t\t\tjava.util.SortedMap.class,\n\t\t\tMap.class,\n\t\t\tjava.util.Collection.class\n\t);\n\n\tfinal MetadataBuildingContext buildingContext;\n\tprivate final Supplier<ManagedBean<? extends UserCollectionType>> customTypeBeanResolver;\n\tprivate final boolean isSortedCollection;\n\n\tprotected Collection collection;\n\tprotected String propertyName;\n\tprotected PropertyHolder propertyHolder;\n\tprivate String mappedBy;\n\tprotected ClassDetails declaringClass;\n\tprotected MemberDetails property;\n\tprivate TypeDetails collectionElementType;\n\tprivate TypeDetails targetEntity;\n\tprivate String cascadeStrategy;\n\tprivate String cacheConcurrencyStrategy;\n\tprivate String cacheRegionName;\n\tprivate CacheLayout queryCacheLayout;\n\tprivate boolean oneToMany;\n\tprotected IndexColumn indexColumn;\n\tprotected OnDeleteAction onDeleteAction;\n\tprotected boolean hasMapKeyProperty;\n\tprotected String mapKeyPropertyName;\n\tprivate boolean insertable = true;\n\tprivate boolean updatable = true;\n\tprotected AnnotatedJoinColumns inverseJoinColumns;\n\tprotected AnnotatedJoinColumns foreignJoinColumns;\n\tprivate AnnotatedJoinColumns joinColumns;\n\tprivate boolean isExplicitAssociationTable;\n\tprivate AnnotatedColumns elementColumns;\n\tprotected boolean isEmbedded;\n\tprotected NotFoundAction notFoundAction;\n\tprivate TableBinder tableBinder;\n\tprotected AnnotatedColumns mapKeyColumns;\n\tprotected AnnotatedJoinColumns mapKeyManyToManyColumns;\n\tprotected Map<String, IdentifierGeneratorDefinition> localGenerators;\n\tprotected Map<ClassDetails, InheritanceState> inheritanceStatePerClass;\n\tprivate boolean declaringClassSet;\n\tprivate AccessType accessType;\n\tprivate boolean hibernateExtensionMapping;\n\n\tprivate jakarta.persistence.OrderBy jpaOrderBy;\n\tprivate org.hibernate.annotations.OrderBy sqlOrderBy;\n\tprivate SQLOrder sqlOrder;\n\tprivate SortNatural naturalSort;\n\tprivate SortComparator comparatorSort;\n\n\tprivate String explicitType;\n\tprivate final Map<String,String> explicitTypeParameters = new HashMap<>();\n\n\tprotected CollectionBinder(\n\t\t\tSupplier<ManagedBean<? extends UserCollectionType>> customTypeBeanResolver,\n\t\t\tboolean isSortedCollection,\n\t\t\tMetadataBuildingContext buildingContext) {\n\t\tthis.customTypeBeanResolver = customTypeBeanResolver;\n\t\tthis.isSortedCollection = isSortedCollection;\n\t\tthis.buildingContext = buildingContext;\n\t}\n\n\t/**\n\t * The first pass at binding a collection.\n\t */\n\tpublic static void bindCollection(\n\t\t\tPropertyHolder propertyHolder,\n\t\t\tNullability nullability,\n\t\t\tPropertyData inferredData,\n\t\t\tMap<String, IdentifierGeneratorDefinition> classGenerators,\n\t\t\tEntityBinder entityBinder,\n\t\t\tboolean isIdentifierMapper,\n\t\t\tMetadataBuildingContext context,\n\t\t\tMap<ClassDetails, InheritanceState> inheritanceStatePerClass,\n\t\t\tMemberDetails property,\n\t\t\tAnnotatedJoinColumns joinColumns) {\n\t\tfinal SourceModelBuildingContext sourceModelContext = context.getMetadataCollector().getSourceModelBuildingContext();\n\n\t\tfinal OneToMany oneToManyAnn = property.getAnnotationUsage( OneToMany.class, sourceModelContext );\n\t\tfinal ManyToMany manyToManyAnn = property.getAnnotationUsage( ManyToMany.class, sourceModelContext );\n\t\tfinal ElementCollection elementCollectionAnn = property.getAnnotationUsage( ElementCollection.class, sourceModelContext );\n\t\tcheckAnnotations( propertyHolder, inferredData, property, oneToManyAnn, manyToManyAnn, elementCollectionAnn );\n\n\t\tfinal CollectionBinder collectionBinder = getCollectionBinder( property, hasMapKeyAnnotation( property ), context );\n\t\tcollectionBinder.setIndexColumn( getIndexColumn( propertyHolder, inferredData, entityBinder, context, property ) );\n\t\tcollectionBinder.setMapKey( property.getAnnotationUsage( MapKey.class, sourceModelContext ) );\n\t\tcollectionBinder.setPropertyName( inferredData.getPropertyName() );\n\t\tcollectionBinder.setJpaOrderBy( property.getAnnotationUsage( OrderBy.class, sourceModelContext ) );\n\t\tcollectionBinder.setSqlOrderBy( getOverridableAnnotation( property, org.hibernate.annotations.OrderBy.class, context ) );\n\t\tcollectionBinder.setSqlOrder( getOverridableAnnotation( property, SQLOrder.class, context ) );\n\t\tcollectionBinder.setNaturalSort( property.getAnnotationUsage( SortNatural.class, sourceModelContext ) );\n\t\tcollectionBinder.setComparatorSort( property.getAnnotationUsage( SortComparator.class, sourceModelContext ) );\n\t\tcollectionBinder.setCache( property.getAnnotationUsage( Cache.class, sourceModelContext ) );\n\t\tcollectionBinder.setQueryCacheLayout( property.getAnnotationUsage( QueryCacheLayout.class, sourceModelContext ) );\n\t\tcollectionBinder.setPropertyHolder(propertyHolder);\n\n\t\tcollectionBinder.setNotFoundAction( notFoundAction( propertyHolder, inferredData, property, manyToManyAnn, sourceModelContext ) );\n\t\tcollectionBinder.setElementType( inferredData.getClassOrElementType() );\n\t\tcollectionBinder.setAccessType( inferredData.getDefaultAccess() );\n\t\tcollectionBinder.setEmbedded( property.hasAnnotationUsage( Embedded.class, sourceModelContext ) );\n\t\tcollectionBinder.setProperty( property );\n\t\tcollectionBinder.setOnDeleteActionAction( onDeleteAction( property ) );\n\t\tcollectionBinder.setInheritanceStatePerClass( inheritanceStatePerClass );\n\t\tcollectionBinder.setDeclaringClass( inferredData.getDeclaringClass() );\n\n//\t\tfinal Comment comment = property.getAnnotation( Comment.class );\n\t\tfinal Cascade hibernateCascade = property.getAnnotationUsage( Cascade.class, sourceModelContext );\n\n\t\tcollectionBinder.setElementColumns( elementColumns(\n\t\t\t\tpropertyHolder,\n\t\t\t\tnullability,\n\t\t\t\tentityBinder,\n\t\t\t\tcontext,\n\t\t\t\tproperty,\n\t\t\t\tvirtualPropertyData( inferredData, property )\n//\t\t\t\tcomment\n\t\t) );\n\n\t\tcollectionBinder.setMapKeyColumns( mapKeyColumns(\n\t\t\t\tpropertyHolder,\n\t\t\t\tinferredData,\n\t\t\t\tentityBinder,\n\t\t\t\tcontext,\n\t\t\t\tproperty\n//\t\t\t\tcomment\n\t\t) );\n\n\t\tcollectionBinder.setMapKeyManyToManyColumns( mapKeyJoinColumns(\n\t\t\t\tpropertyHolder,\n\t\t\t\tinferredData,\n\t\t\t\tentityBinder,\n\t\t\t\tcontext,\n\t\t\t\tproperty\n//\t\t\t\tcomment\n\t\t) );\n\n\t\tbindJoinedTableAssociation(\n\t\t\t\tproperty,\n\t\t\t\tcontext,\n\t\t\t\tentityBinder,\n\t\t\t\tcollectionBinder,\n\t\t\t\tpropertyHolder,\n\t\t\t\tinferredData,\n\t\t\t\thandleTargetEntity(\n\t\t\t\t\t\tpropertyHolder,\n\t\t\t\t\t\tinferredData,\n\t\t\t\t\t\tcontext,\n\t\t\t\t\t\tproperty,\n\t\t\t\t\t\tjoinColumns,\n\t\t\t\t\t\toneToManyAnn,\n\t\t\t\t\t\tmanyToManyAnn,\n\t\t\t\t\t\telementCollectionAnn,\n\t\t\t\t\t\tcollectionBinder,\n\t\t\t\t\t\thibernateCascade\n\t\t\t\t)\n\t\t);\n\n\t\tif ( isIdentifierMapper ) {\n\t\t\tcollectionBinder.setInsertable( false );\n\t\t\tcollectionBinder.setUpdatable( false );\n\t\t}\n\n\t\tif ( property.hasAnnotationUsage( CollectionId.class, sourceModelContext ) ) {\n\t\t\t//do not compute the generators unless necessary\n\t\t\tfinal HashMap<String, IdentifierGeneratorDefinition> localGenerators = new HashMap<>(classGenerators);\n\t\t\tlocalGenerators.putAll( buildGenerators( property, context ) );\n\t\t\tcollectionBinder.setLocalGenerators( localGenerators );\n\n\t\t}\n\t\tcollectionBinder.bind();\n\t}\n\n\tprivate static NotFoundAction notFoundAction(\n\t\t\tPropertyHolder propertyHolder,\n\t\t\tPropertyData inferredData,\n\t\t\tMemberDetails property,\n\t\t\tManyToMany manyToManyAnn,\n\t\t\tSourceModelBuildingContext sourceModelContext) {\n\t\tfinal NotFound notFound = property.getAnnotationUsage( NotFound.class, sourceModelContext );\n\t\tif ( notFound != null ) {\n\t\t\tif ( manyToManyAnn == null ) {\n\t\t\t\tthrow new AnnotationException( \"Collection '\" + getPath(propertyHolder, inferredData)\n\t\t\t\t\t\t+ \"' annotated '@NotFound' is not a '@ManyToMany' association\" );\n\t\t\t}\n\t\t\treturn notFound.action();\n\t\t}\n\t\telse {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tprivate static AnnotatedJoinColumns mapKeyJoinColumns(\n\t\t\tPropertyHolder propertyHolder,\n\t\t\tPropertyData inferredData,\n\t\t\tEntityBinder entityBinder,\n\t\t\tMetadataBuildingContext context,\n\t\t\tMemberDetails property) {\n//\t\t\tComment comment) {\n\t\treturn buildJoinColumnsWithDefaultColumnSuffix(\n\t\t\t\tmapKeyJoinColumnAnnotations( propertyHolder, inferredData, property, context ),\n//\t\t\t\tcomment,\n\t\t\t\tnull,\n\t\t\t\tentityBinder.getSecondaryTables(),\n\t\t\t\tpropertyHolder,\n\t\t\t\tinferredData,\n\t\t\t\t\"_KEY\",\n\t\t\t\tcontext\n\t\t);\n\t}\n\n\tprivate static OnDeleteAction onDeleteAction(MemberDetails property) {\n\t\tfinal OnDelete onDelete = property.getDirectAnnotationUsage( OnDelete.class );\n\t\treturn onDelete == null ? null : onDelete.action();\n\t}\n\n\tprivate static PropertyData virtualPropertyData(PropertyData inferredData, MemberDetails property) {\n\t\t//do not use \"element\" if you are a JPA 2 @ElementCollection, only for legacy Hibernate mappings\n\t\treturn property.hasDirectAnnotationUsage( ElementCollection.class )\n\t\t\t\t? inferredData\n\t\t\t\t: new WrappedInferredData(inferredData, \"element\" );\n\t}\n\n\tprivate static void checkAnnotations(\n\t\t\tPropertyHolder propertyHolder,\n\t\t\tPropertyData inferredData,\n\t\t\tMemberDetails property,\n\t\t\tOneToMany oneToMany,\n\t\t\tManyToMany manyToMany,\n\t\t\tElementCollection elementCollection) {\n\t\tif ( ( oneToMany != null || manyToMany != null || elementCollection != null )\n\t\t\t\t&& isToManyAssociationWithinEmbeddableCollection( propertyHolder ) ) {\n\t\t\tthrow new AnnotationException( \"Property '\" + getPath( propertyHolder, inferredData ) +\n\t\t\t\t\t\"' belongs to an '@Embeddable' class that is contained in an '@ElementCollection' and may not be a \"\n\t\t\t\t\t+ annotationName( oneToMany, manyToMany, elementCollection ));\n\t\t}\n\n\t\tif ( oneToMany != null && property.hasDirectAnnotationUsage( SoftDelete.class ) ) {\n\t\t\tthrow new UnsupportedMappingException(\n\t\t\t\t\t\"@SoftDelete cannot be applied to @OneToMany - \" +\n\t\t\t\t\t\t\tproperty.getDeclaringType().getName() + \".\" + property.getName()\n\t\t\t);\n\t\t}\n\n\t\tif ( property.hasDirectAnnotationUsage( OrderColumn.class )\n\t\t\t\t&& manyToMany != null\n\t\t\t\t&& StringHelper.isNotEmpty( manyToMany.mappedBy() ) ) {\n\t\t\tthrow new AnnotationException(\"Collection '\" + getPath( propertyHolder, inferredData ) +\n\t\t\t\t\t\"' is the unowned side of a bidirectional '@ManyToMany' and may not have an '@OrderColumn'\");\n\t\t}\n\n\t\tif ( manyToMany != null || elementCollection != null ) {\n\t\t\tif ( property.hasDirectAnnotationUsage( JoinColumn.class )\n\t\t\t\t\t|| property.hasDirectAnnotationUsage( JoinColumns.class ) ) {\n\t\t\t\tthrow new AnnotationException( \"Property '\" + getPath( propertyHolder, inferredData )\n\t\t\t\t\t\t+ \"' is a \" + annotationName( oneToMany, manyToMany, elementCollection )\n\t\t\t\t\t\t+ \" and is directly annotated '@JoinColumn'\"\n\t\t\t\t\t\t+ \" (specify '@JoinColumn' inside '@JoinTable' or '@CollectionTable')\" );\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate static String annotationName(\n\t\t\tOneToMany oneToMany,\n\t\t\tManyToMany manyToMany,\n\t\t\tElementCollection elementCollection) {\n\t\treturn oneToMany != null ? \"'@OneToMany'\" : manyToMany != null ? \"'@ManyToMany'\" : \"'@ElementCollection'\";\n\t}\n\n\tprivate static IndexColumn getIndexColumn(\n\t\t\tPropertyHolder propertyHolder,\n\t\t\tPropertyData inferredData,\n\t\t\tEntityBinder entityBinder,\n\t\t\tMetadataBuildingContext context,\n\t\t\tMemberDetails property) {\n\t\treturn IndexColumn.fromAnnotations(\n\t\t\t\tproperty.getDirectAnnotationUsage( OrderColumn.class ),\n\t\t\t\tproperty.getDirectAnnotationUsage( ListIndexBase.class ),\n\t\t\t\tpropertyHolder,\n\t\t\t\tinferredData,\n\t\t\t\tentityBinder.getSecondaryTables(),\n\t\t\t\tcontext\n\t\t);\n\t}\n\n\tprivate static String handleTargetEntity(\n\t\t\tPropertyHolder propertyHolder,\n\t\t\tPropertyData inferredData,\n\t\t\tMetadataBuildingContext context,\n\t\t\tMemberDetails property,\n\t\t\tAnnotatedJoinColumns joinColumns,\n\t\t\tOneToMany oneToManyAnn,\n\t\t\tManyToMany manyToManyAnn,\n\t\t\tElementCollection elementCollectionAnn,\n\t\t\tCollectionBinder collectionBinder,\n\t\t\tCascade hibernateCascade) {\n\n\t\t//TODO enhance exception with @ManyToAny and @CollectionOfElements\n\t\tif ( oneToManyAnn != null && manyToManyAnn != null ) {\n\t\t\tthrow new AnnotationException( \"Property '\" + getPath( propertyHolder, inferredData )\n\t\t\t\t\t+ \"' is annotated both '@OneToMany' and '@ManyToMany'\" );\n\t\t}\n\t\tfinal String mappedBy;\n\t\tif ( oneToManyAnn != null ) {\n\t\t\tif ( joinColumns.isSecondary() ) {\n\t\t\t\tthrow new AnnotationException( \"Collection '\" + getPath( propertyHolder, inferredData )\n\t\t\t\t\t\t+ \"' has foreign key in secondary table\" );\n\t\t\t}\n\t\t\tcollectionBinder.setFkJoinColumns( joinColumns );\n\t\t\tmappedBy = nullIfEmpty( oneToManyAnn.mappedBy() );\n\t\t\tcollectionBinder.setTargetEntity( oneToManyAnn.targetEntity() );\n\t\t\tcollectionBinder.setCascadeStrategy( getCascadeStrategy(\n\t\t\t\t\toneToManyAnn.cascade(),\n\t\t\t\t\thibernateCascade,\n\t\t\t\t\toneToManyAnn.orphanRemoval(),\n\t\t\t\t\tcontext\n\t\t\t) );\n\t\t\tcollectionBinder.setOneToMany( true );\n\t\t}\n\t\telse if ( elementCollectionAnn != null ) {\n\t\t\tif ( joinColumns.isSecondary() ) {\n\t\t\t\tthrow new AnnotationException( \"Collection '\" + getPath( propertyHolder, inferredData )\n\t\t\t\t\t\t+ \"' has foreign key in secondary table\" );\n\t\t\t}\n\t\t\tcollectionBinder.setFkJoinColumns( joinColumns );\n\t\t\tmappedBy = null;\n\t\t\tcollectionBinder.setTargetEntity( elementCollectionAnn.targetClass() );\n\t\t\tcollectionBinder.setOneToMany( false );\n\t\t}\n\t\telse if ( manyToManyAnn != null ) {\n\t\t\tmappedBy = nullIfEmpty( manyToManyAnn.mappedBy() );\n\t\t\tcollectionBinder.setTargetEntity( manyToManyAnn.targetEntity() );\n\t\t\tcollectionBinder.setCascadeStrategy( getCascadeStrategy(\n\t\t\t\t\tmanyToManyAnn.cascade(),\n\t\t\t\t\thibernateCascade,\n\t\t\t\t\tfalse,\n\t\t\t\t\tcontext\n\t\t\t) );\n\t\t\tcollectionBinder.setOneToMany( false );\n\t\t}\n\t\telse if ( property.hasDirectAnnotationUsage( ManyToAny.class ) ) {\n\t\t\tmappedBy = null;\n\t\t\tcollectionBinder.setTargetEntity( ClassDetails.VOID_CLASS_DETAILS );\n\t\t\tcollectionBinder.setCascadeStrategy( getCascadeStrategy(\n\t\t\t\t\tnull,\n\t\t\t\t\thibernateCascade,\n\t\t\t\t\tfalse,\n\t\t\t\t\tcontext\n\t\t\t) );\n\t\t\tcollectionBinder.setOneToMany( false );\n\t\t}\n\t\telse {\n\t\t\tmappedBy = null;\n\t\t}\n\t\tcollectionBinder.setMappedBy( mappedBy );\n\t\treturn mappedBy;\n\t}\n\n\tprivate static boolean hasMapKeyAnnotation(MemberDetails property) {\n\t\treturn property.hasDirectAnnotationUsage(MapKeyJavaType.class)\n\t\t\t|| property.hasDirectAnnotationUsage(MapKeyJdbcType.class)\n\t\t\t|| property.hasDirectAnnotationUsage(MapKeyJdbcTypeCode.class)\n\t\t\t|| property.hasDirectAnnotationUsage(MapKeyMutability.class)\n\t\t\t|| property.hasDirectAnnotationUsage(MapKey.class)\n\t\t\t|| property.hasDirectAnnotationUsage(MapKeyType.class);\n\t}\n\n\tprivate static boolean isToManyAssociationWithinEmbeddableCollection(PropertyHolder propertyHolder) {\n\t\tif ( propertyHolder instanceof ComponentPropertyHolder ) {\n\t\t\tComponentPropertyHolder componentPropertyHolder = (ComponentPropertyHolder) propertyHolder;\n\t\t\treturn componentPropertyHolder.isWithinElementCollection();\n\t\t}\n\t\telse {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tprivate static AnnotatedColumns elementColumns(\n\t\t\tPropertyHolder propertyHolder,\n\t\t\tNullability nullability,\n\t\t\tEntityBinder entityBinder,\n\t\t\tMetadataBuildingContext context,\n\t\t\tMemberDetails property,\n\t\t\tPropertyData virtualProperty) {\n//\t\t\tComment comment) {\n\t\tif ( property.hasDirectAnnotationUsage( jakarta.persistence.Column.class ) ) {\n\t\t\treturn buildColumnFromAnnotation(\n\t\t\t\t\tproperty.getDirectAnnotationUsage( jakarta.persistence.Column.class ),\n\t\t\t\t\tnull,\n//\t\t\t\t\tcomment,\n\t\t\t\t\tnullability,\n\t\t\t\t\tpropertyHolder,\n\t\t\t\t\tvirtualProperty,\n\t\t\t\t\tentityBinder.getSecondaryTables(),\n\t\t\t\t\tcontext\n\t\t\t);\n\t\t}\n\t\telse if ( property.hasDirectAnnotationUsage( Formula.class ) ) {\n\t\t\treturn buildFormulaFromAnnotation(\n\t\t\t\t\tgetOverridableAnnotation(property, Formula.class, context),\n//\t\t\t\t\tcomment,\n\t\t\t\t\tnullability,\n\t\t\t\t\tpropertyHolder,\n\t\t\t\t\tvirtualProperty,\n\t\t\t\t\tentityBinder.getSecondaryTables(),\n\t\t\t\t\tcontext\n\t\t\t);\n\t\t}\n\t\telse if ( property.hasDirectAnnotationUsage( Columns.class ) ) {\n\t\t\treturn buildColumnsFromAnnotations(\n\t\t\t\t\tproperty.getDirectAnnotationUsage( Columns.class ).columns(),\n\t\t\t\t\tnull,\n//\t\t\t\t\tcomment,\n\t\t\t\t\tnullability,\n\t\t\t\t\tpropertyHolder,\n\t\t\t\t\tvirtualProperty,\n\t\t\t\t\tentityBinder.getSecondaryTables(),\n\t\t\t\t\tcontext\n\t\t\t);\n\t\t}\n\t\telse {\n\t\t\treturn buildColumnFromNoAnnotation(\n\t\t\t\t\tnull,\n//\t\t\t\t\tcomment,\n\t\t\t\t\tnullability,\n\t\t\t\t\tpropertyHolder,\n\t\t\t\t\tvirtualProperty,\n\t\t\t\t\tentityBinder.getSecondaryTables(),\n\t\t\t\t\tcontext\n\t\t\t);\n\t\t}\n\t}\n\n\tprivate static JoinColumn[] mapKeyJoinColumnAnnotations(\n\t\t\tPropertyHolder propertyHolder,\n\t\t\tPropertyData inferredData,\n\t\t\tMemberDetails property,\n\t\t\tMetadataBuildingContext context) {\n\t\tfinal MapKeyJoinColumn[] mapKeyJoinColumns = property.getRepeatedAnnotationUsages(\n\t\t\t\tJpaAnnotations.MAP_KEY_JOIN_COLUMN,\n\t\t\t\tcontext.getMetadataCollector().getSourceModelBuildingContext()\n\t\t);\n\n\t\tif ( CollectionHelper.isEmpty( mapKeyJoinColumns ) ) {\n\t\t\treturn null;\n\t\t}\n\n\t\tfinal JoinColumn[] joinColumns = new JoinColumn[mapKeyJoinColumns.length];\n\t\tfor ( int i = 0; i < mapKeyJoinColumns.length; i++ ) {\n\t\t\tfinal JoinColumn joinColumn = JoinColumnJpaAnnotation.toJoinColumn(\n\t\t\t\t\tmapKeyJoinColumns[i],\n\t\t\t\t\tcontext.getMetadataCollector().getSourceModelBuildingContext()\n\t\t\t);\n\t\t\tjoinColumns[i] = joinColumn;\n\t\t}\n\t\treturn joinColumns;\n\t}\n\n\tprivate static AnnotatedColumns mapKeyColumns(\n\t\t\tPropertyHolder propertyHolder,\n\t\t\tPropertyData inferredData,\n\t\t\tEntityBinder entityBinder,\n\t\t\tMetadataBuildingContext context,\n\t\t\tMemberDetails property) {\n//\t\t\tComment comment) {\n\t\tfinal jakarta.persistence.Column column;\n\t\tif ( property.hasDirectAnnotationUsage( MapKeyColumn.class ) ) {\n\t\t\tcolumn = MapKeyColumnJpaAnnotation.toColumnAnnotation(\n\t\t\t\t\tproperty.getDirectAnnotationUsage( MapKeyColumn.class ),\n\t\t\t\t\tcontext.getMetadataCollector().getSourceModelBuildingContext()\n\t\t\t);\n\t\t}\n\t\telse {\n\t\t\tcolumn = null;\n\t\t}\n\t\treturn buildColumnsFromAnnotations(\n\t\t\t\tcolumn == null ? null : new jakarta.persistence.Column[] { column },\n//\t\t\t\tcomment,\n\t\t\t\tNullability.FORCED_NOT_NULL,\n\t\t\t\tpropertyHolder,\n\t\t\t\tinferredData,\n\t\t\t\t\"_KEY\",\n\t\t\t\tentityBinder.getSecondaryTables(),\n\t\t\t\tcontext\n\t\t);\n\t}\n\n\tprivate static void bindJoinedTableAssociation(\n\t\t\tMemberDetails property,\n\t\t\tMetadataBuildingContext buildingContext,\n\t\t\tEntityBinder entityBinder,\n\t\t\tCollectionBinder collectionBinder,\n\t\t\tPropertyHolder propertyHolder,\n\t\t\tPropertyData inferredData,\n\t\t\tString mappedBy) {\n\t\tfinal TableBinder associationTableBinder = new TableBinder();\n\t\tfinal JoinTable assocTable = propertyHolder.getJoinTable( property );\n\t\tfinal CollectionTable collectionTable = property.getDirectAnnotationUsage( CollectionTable.class );\n\n\t\tfinal JoinColumn[] annJoins;\n\t\tfinal JoinColumn[] annInverseJoins;\n\t\tif ( assocTable != null || collectionTable != null ) {\n\t\t\tfinal String catalog;\n\t\t\tfinal String schema;\n\t\t\tfinal String tableName;\n\t\t\tfinal UniqueConstraint[] uniqueConstraints;\n\t\t\tfinal JoinColumn[] joins;\n\t\t\tfinal JoinColumn[] inverseJoins;\n\t\t\tfinal Index[] jpaIndexes;\n\t\t\tfinal String options;\n\n\t\t\t//JPA 2 has priority\n\t\t\tif ( collectionTable != null ) {\n\t\t\t\tcatalog = collectionTable.catalog();\n\t\t\t\tschema = collectionTable.schema();\n\t\t\t\ttableName = collectionTable.name();\n\t\t\t\tuniqueConstraints = collectionTable.uniqueConstraints();\n\t\t\t\tjoins = collectionTable.joinColumns();\n\t\t\t\tinverseJoins = null;\n\t\t\t\tjpaIndexes = collectionTable.indexes();\n\t\t\t\toptions = collectionTable.options();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcatalog = assocTable.catalog();\n\t\t\t\tschema = assocTable.schema();\n\t\t\t\ttableName = assocTable.name();\n\t\t\t\tuniqueConstraints = assocTable.uniqueConstraints();\n\t\t\t\tjoins = assocTable.joinColumns();\n\t\t\t\tinverseJoins = assocTable.inverseJoinColumns();\n\t\t\t\tjpaIndexes = assocTable.indexes();\n\t\t\t\toptions = assocTable.options();\n\t\t\t}\n\n\t\t\tcollectionBinder.setExplicitAssociationTable( true );\n\t\t\tif ( CollectionHelper.isNotEmpty( jpaIndexes ) ) {\n\t\t\t\tassociationTableBinder.setJpaIndex( jpaIndexes );\n\t\t\t}\n\t\t\tif ( !schema.isEmpty() ) {\n\t\t\t\tassociationTableBinder.setSchema( schema );\n\t\t\t}\n\t\t\tif ( !catalog.isEmpty() ) {\n\t\t\t\tassociationTableBinder.setCatalog( catalog );\n\t\t\t}\n\t\t\tif ( !tableName.isEmpty() ) {\n\t\t\t\tassociationTableBinder.setName( tableName );\n\t\t\t}\n\t\t\tassociationTableBinder.setUniqueConstraints( uniqueConstraints );\n\t\t\tassociationTableBinder.setJpaIndex( jpaIndexes );\n\t\t\tassociationTableBinder.setOptions( options );\n\t\t\t//set check constraint in the second pass\n\t\t\tannJoins = ArrayHelper.isEmpty( joins ) ? null : joins;\n\t\t\tannInverseJoins = inverseJoins == null || ArrayHelper.isEmpty( inverseJoins ) ? null : inverseJoins;\n\t\t}\n\t\telse {\n\t\t\tannJoins = null;\n\t\t\tannInverseJoins = null;\n\t\t}\n\t\tassociationTableBinder.setBuildingContext( buildingContext );\n\t\tcollectionBinder.setTableBinder( associationTableBinder );\n\t\tcollectionBinder.setJoinColumns( buildJoinTableJoinColumns(\n\t\t\t\tannJoins,\n\t\t\t\tentityBinder.getSecondaryTables(),\n\t\t\t\tpropertyHolder,\n\t\t\t\tinferredData,\n\t\t\t\tmappedBy,\n\t\t\t\tbuildingContext\n\t\t) );\n\t\tcollectionBinder.setInverseJoinColumns( buildJoinTableJoinColumns(\n\t\t\t\tannInverseJoins,\n\t\t\t\tentityBinder.getSecondaryTables(),\n\t\t\t\tpropertyHolder,\n\t\t\t\tinferredData,\n\t\t\t\tmappedBy,\n\t\t\t\tbuildingContext\n\t\t) );\n\t}\n\n\tprotected MetadataBuildingContext getBuildingContext() {\n\t\treturn buildingContext;\n\t}\n\n\tpublic Supplier<ManagedBean<? extends UserCollectionType>> getCustomTypeBeanResolver() {\n\t\treturn customTypeBeanResolver;\n\t}\n\n\tpublic boolean isMap() {\n\t\treturn false;\n\t}\n\n\tprotected void setIsHibernateExtensionMapping(boolean hibernateExtensionMapping) {\n\t\tthis.hibernateExtensionMapping = hibernateExtensionMapping;\n\t}\n\n\tprotected boolean isHibernateExtensionMapping() {\n\t\treturn hibernateExtensionMapping;\n\t}\n\n\tpublic void setUpdatable(boolean updatable) {\n\t\tthis.updatable = updatable;\n\t}\n\n\tpublic void setInheritanceStatePerClass(Map<ClassDetails, InheritanceState> inheritanceStatePerClass) {\n\t\tthis.inheritanceStatePerClass = inheritanceStatePerClass;\n\t}\n\n\tpublic void setInsertable(boolean insertable) {\n\t\tthis.insertable = insertable;\n\t}\n\n\tpublic void setCascadeStrategy(String cascadeStrategy) {\n\t\tthis.cascadeStrategy = cascadeStrategy;\n\t}\n\n\tpublic void setAccessType(AccessType accessType) {\n\t\tthis.accessType = accessType;\n\t}\n\n\tpublic void setInverseJoinColumns(AnnotatedJoinColumns inverseJoinColumns) {\n\t\tthis.inverseJoinColumns = inverseJoinColumns;\n\t}\n\n\tpublic void setJoinColumns(AnnotatedJoinColumns joinColumns) {\n\t\tthis.joinColumns = joinColumns;\n\t}\n\n\tpublic void setPropertyHolder(PropertyHolder propertyHolder) {\n\t\tthis.propertyHolder = propertyHolder;\n\t}\n\n\tpublic void setJpaOrderBy(jakarta.persistence.OrderBy jpaOrderBy) {\n\t\tthis.jpaOrderBy = jpaOrderBy;\n\t}\n\n\t@SuppressWarnings(\"removal\")\n\tpublic void setSqlOrderBy(org.hibernate.annotations.OrderBy sqlOrderBy) {\n\t\tthis.sqlOrderBy = sqlOrderBy;\n\t}\n\n\tpublic void setSqlOrder(SQLOrder sqlOrder) {\n\t\tthis.sqlOrder = sqlOrder;\n\t}\n\n\tpublic void setNaturalSort(SortNatural naturalSort) {\n\t\tthis.naturalSort = naturalSort;\n\t}\n\n\tpublic void setComparatorSort(SortComparator comparatorSort) {\n\t\tthis.comparatorSort = comparatorSort;\n\t}\n\n\t/**\n\t * collection binder factory\n\t */\n\tpublic static CollectionBinder getCollectionBinder(\n\t\t\tMemberDetails property,\n\t\t\tboolean isHibernateExtensionMapping,\n\t\t\tMetadataBuildingContext buildingContext) {\n\n\t\tfinal CollectionBinder binder;\n\t\tfinal CollectionType typeAnnotation = property.getAnnotationUsage( CollectionType.class, buildingContext.getMetadataCollector().getSourceModelBuildingContext() );\n\t\tif ( typeAnnotation != null ) {\n\t\t\tbinder = createBinderFromCustomTypeAnnotation( property, typeAnnotation, buildingContext );\n\t\t\t// todo (6.0) - technically, these should no longer be needed\n\t\t\tbinder.explicitType = typeAnnotation.type().getName();\n\t\t\tfor ( Parameter param : typeAnnotation.parameters() ) {\n\t\t\t\tbinder.explicitTypeParameters.put( param.name(), param.value() );\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tbinder = createBinderAutomatically( property, buildingContext );\n\t\t}\n\t\tbinder.setIsHibernateExtensionMapping( isHibernateExtensionMapping );\n\t\treturn binder;\n\t}\n\n\tprivate static CollectionBinder createBinderAutomatically(MemberDetails property, MetadataBuildingContext context) {\n\t\tfinal CollectionClassification classification = determineCollectionClassification( property, context );\n\t\tfinal CollectionTypeRegistrationDescriptor typeRegistration =\n\t\t\t\tcontext.getMetadataCollector().findCollectionTypeRegistration( classification );\n\t\treturn typeRegistration != null\n\t\t\t\t? createBinderFromTypeRegistration( property, classification, typeRegistration, context )\n\t\t\t\t: createBinderFromProperty( property, context );\n\t}\n\n\tprivate static CollectionBinder createBinderFromTypeRegistration(\n\t\t\tMemberDetails property,\n\t\t\tCollectionClassification classification,\n\t\t\tCollectionTypeRegistrationDescriptor typeRegistration,\n\t\t\tMetadataBuildingContext buildingContext) {\n\t\treturn createBinder(\n\t\t\t\tproperty,\n\t\t\t\t() -> createCustomType(\n\t\t\t\t\t\tproperty.getDeclaringType().getName() + \"#\" + property.getName(),\n\t\t\t\t\t\ttypeRegistration.getImplementation(),\n\t\t\t\t\t\ttypeRegistration.getParameters(),\n\t\t\t\t\t\tbuildingContext\n\t\t\t\t),\n\t\t\t\tclassification,\n\t\t\t\tbuildingContext\n\t\t);\n\t}\n\n\tprivate static ManagedBean<? extends UserCollectionType> createCustomType(\n\t\t\tString role,\n\t\t\tClass<? extends UserCollectionType> implementation,\n\t\t\tMap<String,String> parameters,\n\t\t\tMetadataBuildingContext buildingContext) {\n\t\tfinal boolean hasParameters = CollectionHelper.isNotEmpty( parameters );\n\t\tif ( !buildingContext.getBuildingOptions().isAllowExtensionsInCdi() ) {\n\t\t\t// if deferred container access is enabled, we locally create the user-type\n\t\t\treturn createLocalUserCollectionTypeBean( role, implementation, hasParameters, parameters );\n\t\t}\n\n\t\tfinal ManagedBean<? extends UserCollectionType> managedBean =\n\t\t\t\tbuildingContext.getBuildingOptions().getServiceRegistry()\n\t\t\t\t\t\t.requireService( ManagedBeanRegistry.class )\n\t\t\t\t\t\t.getBean( implementation );\n\n\t\tif ( hasParameters ) {\n\t\t\tif ( ParameterizedType.class.isAssignableFrom( managedBean.getBeanClass() ) ) {\n\t\t\t\t// create a copy of the parameters and create a bean wrapper to delay injecting\n\t\t\t\t// the parameters, thereby delaying the need to resolve the instance from the\n\t\t\t\t// wrapped bean\n\t\t\t\tfinal Properties copy = new Properties();\n\t\t\t\tcopy.putAll( parameters );\n\t\t\t\treturn new DelayedParameterizedTypeBean<>( managedBean, copy );\n\t\t\t}\n\n\t\t\t// there were parameters, but the custom-type does not implement the interface\n\t\t\t// used to inject them - log a \"warning\"\n\t\t\tBootLogging.BOOT_LOGGER.debugf(\n\t\t\t\t\t\"`@CollectionType` (%s) specified parameters, but the\" +\n\t\t\t\t\t\t\t\" implementation does not implement `%s` which is used to inject them - `%s`\",\n\t\t\t\t\trole,\n\t\t\t\t\tParameterizedType.class.getName(),\n\t\t\t\t\timplementation.getName()\n\t\t\t);\n\n\t\t\t// fall through to returning `managedBean`\n\t\t}\n\n\t\treturn managedBean;\n\t}\n\n\tprivate static CollectionBinder createBinderFromProperty(MemberDetails property, MetadataBuildingContext context) {\n\t\tfinal CollectionClassification classification = determineCollectionClassification( property, context );\n\t\treturn createBinder( property, null, classification, context );\n\t}\n\n\tprivate static CollectionBinder createBinderFromCustomTypeAnnotation(\n\t\t\tMemberDetails property,\n\t\t\tCollectionType typeAnnotation,\n\t\t\tMetadataBuildingContext buildingContext) {\n\t\tdetermineSemanticJavaType( property, buildingContext );\n\t\tfinal ManagedBean<? extends UserCollectionType> customTypeBean = resolveCustomType(\n\t\t\t\tproperty,\n\t\t\t\ttypeAnnotation,\n\t\t\t\tbuildingContext\n\t\t);\n\t\treturn createBinder(\n\t\t\t\tproperty,\n\t\t\t\t() -> customTypeBean,\n\t\t\t\tcustomTypeBean.getBeanInstance().getClassification(),\n\t\t\t\tbuildingContext\n\t\t);\n\t}\n\n\tpublic static ManagedBean<? extends UserCollectionType> resolveCustomType(\n\t\t\tMemberDetails property,\n\t\t\tCollectionType typeAnnotation,\n\t\t\tMetadataBuildingContext context) {\n\t\tfinal Properties parameters = extractParameters( typeAnnotation );\n\n\t\t//noinspection unchecked,rawtypes\n\t\treturn createCustomType(\n\t\t\t\tproperty.getDeclaringType().getName() + \".\" + property.getName(),\n\t\t\t\ttypeAnnotation.type(),\n\t\t\t\t(Map) parameters,\n\t\t\t\tcontext\n\t\t);\n\t}\n\n\tprivate static Properties extractParameters(CollectionType typeAnnotation) {\n\t\tfinal Parameter[] parameterAnnotations = typeAnnotation.parameters();\n\t\tfinal Properties configParams = new Properties( parameterAnnotations.length );\n\t\tfor ( Parameter parameterAnnotation : parameterAnnotations ) {\n\t\t\tconfigParams.put( parameterAnnotation.name(), parameterAnnotation.value() );\n\t\t}\n\t\treturn configParams;\n\t}\n\n\tprivate static CollectionBinder createBinder(\n\t\t\tMemberDetails property,\n\t\t\tSupplier<ManagedBean<? extends UserCollectionType>> customTypeBeanAccess,\n\t\t\tCollectionClassification classification,\n\t\t\tMetadataBuildingContext buildingContext) {\n\t\tfinal TypeDetails elementType = property.getElementType();\n\n\t\treturn switch ( classification ) {\n\t\t\tcase ARRAY -> elementType.getTypeKind() == TypeDetails.Kind.PRIMITIVE\n\t\t\t\t\t? new PrimitiveArrayBinder( customTypeBeanAccess, buildingContext )\n\t\t\t\t\t: new ArrayBinder( customTypeBeanAccess, buildingContext );\n\t\t\tcase BAG -> new BagBinder( customTypeBeanAccess, buildingContext );\n\t\t\tcase ID_BAG -> new IdBagBinder( customTypeBeanAccess, buildingContext );\n\t\t\tcase LIST -> new ListBinder( customTypeBeanAccess, buildingContext );\n\t\t\tcase MAP, ORDERED_MAP -> new MapBinder( customTypeBeanAccess, false, buildingContext );\n\t\t\tcase SORTED_MAP -> new MapBinder( customTypeBeanAccess, true, buildingContext );\n\t\t\tcase SET, ORDERED_SET -> new SetBinder( customTypeBeanAccess, false, buildingContext );\n\t\t\tcase SORTED_SET -> new SetBinder( customTypeBeanAccess, true, buildingContext );\n\t\t};\n\t}\n\n\tprivate static CollectionClassification determineCollectionClassification(\n\t\t\tMemberDetails property,\n\t\t\tMetadataBuildingContext buildingContext) {\n\t\tif ( property.isArray() ) {\n\t\t\treturn CollectionClassification.ARRAY;\n\t\t}\n\n\t\tfinal SourceModelBuildingContext sourceModelContext = buildingContext.getMetadataCollector().getSourceModelBuildingContext();\n\n\t\tif ( !property.hasAnnotationUsage( Bag.class, sourceModelContext ) ) {\n\t\t\treturn determineCollectionClassification( determineSemanticJavaType( property, buildingContext ), property, buildingContext );\n\t\t}\n\n\t\tif ( property.hasAnnotationUsage( OrderColumn.class, sourceModelContext ) ) {\n\t\t\tthrow new AnnotationException( \"Attribute '\"\n\t\t\t\t\t+ qualify( property.getDeclaringType().getName(), property.getName() )\n\t\t\t\t\t+ \"' is annotated '@Bag' and may not also be annotated '@OrderColumn'\" );\n\t\t}\n\n\t\tif ( property.hasAnnotationUsage( ListIndexBase.class, sourceModelContext ) ) {\n\t\t\tthrow new AnnotationException( \"Attribute '\"\n\t\t\t\t\t+ qualify( property.getDeclaringType().getName(), property.getName() )\n\t\t\t\t\t+ \"' is annotated '@Bag' and may not also be annotated '@ListIndexBase'\" );\n\t\t}\n\n\t\tfinal ClassDetails collectionClassDetails = property.getType().determineRawClass();\n\t\tfinal Class<?> collectionJavaType = collectionClassDetails.toJavaClass();\n\t\tif ( java.util.List.class.equals( collectionJavaType )\n\t\t\t\t|| java.util.Collection.class.equals( collectionJavaType ) ) {\n\t\t\treturn CollectionClassification.BAG;\n\t\t}\n\t\telse {\n\t\t\tthrow new AnnotationException(\n\t\t\t\t\tString.format(\n\t\t\t\t\t\t\tLocale.ROOT,\n\t\t\t\t\t\t\t\"Attribute '%s.%s' of type '%s' is annotated '@Bag' (bags are of type '%s' or '%s')\",\n\t\t\t\t\t\t\tproperty.getDeclaringType().getName(),\n\t\t\t\t\t\t\tproperty.getName(),\n\t\t\t\t\t\t\tcollectionJavaType.getName(),\n\t\t\t\t\t\t\tjava.util.List.class.getName(),\n\t\t\t\t\t\t\tjava.util.Collection.class.getName()\n\t\t\t\t\t)\n\t\t\t);\n\t\t}\n\t}\n\n\tprivate static CollectionClassification determineCollectionClassification(\n\t\t\tClass<?> semanticJavaType,\n\t\t\tMemberDetails property,\n\t\t\tMetadataBuildingContext buildingContext) {\n\t\tif ( semanticJavaType.isArray() ) {\n\t\t\treturn CollectionClassification.ARRAY;\n\t\t}\n\n\t\tif ( property.hasDirectAnnotationUsage( CollectionId.class )\n\t\t\t\t|| property.hasDirectAnnotationUsage( CollectionIdJdbcType.class )\n\t\t\t\t|| property.hasDirectAnnotationUsage( CollectionIdJdbcTypeCode.class )\n\t\t\t\t|| property.hasDirectAnnotationUsage( CollectionIdJavaType.class ) ) {\n\t\t\t// explicitly an ID_BAG\n\t\t\treturn CollectionClassification.ID_BAG;\n\t\t}\n\n\t\tif ( java.util.List.class.isAssignableFrom( semanticJavaType ) ) {\n\t\t\tif ( property.hasDirectAnnotationUsage( OrderColumn.class )\n\t\t\t\t\t|| property.hasDirectAnnotationUsage( ListIndexBase.class )\n\t\t\t\t\t|| property.hasDirectAnnotationUsage( ListIndexJdbcType.class )\n\t\t\t\t\t|| property.hasDirectAnnotationUsage( ListIndexJdbcTypeCode.class )\n\t\t\t\t\t|| property.hasDirectAnnotationUsage( ListIndexJavaType.class ) ) {\n\t\t\t\t// it is implicitly a LIST because of presence of explicit List index config\n\t\t\t\treturn CollectionClassification.LIST;\n\t\t\t}\n\n\t\t\tif ( property.hasDirectAnnotationUsage( jakarta.persistence.OrderBy.class )\n\t\t\t\t\t|| property.hasDirectAnnotationUsage( org.hibernate.annotations.OrderBy.class ) ) {\n\t\t\t\treturn CollectionClassification.BAG;\n\t\t\t}\n\n\t\t\tfinal SourceModelBuildingContext sourceModelContext = buildingContext.getMetadataCollector().getSourceModelBuildingContext();\n\t\t\tfinal ManyToMany manyToMany = property.getAnnotationUsage( ManyToMany.class, sourceModelContext );\n\t\t\tif ( manyToMany != null && !manyToMany.mappedBy().isEmpty() ) {\n\t\t\t\t// We don't support @OrderColumn on the non-owning side of a many-to-many association.\n\t\t\t\treturn CollectionClassification.BAG;\n\t\t\t}\n\n\t\t\tfinal OneToMany oneToMany = property.getAnnotationUsage( OneToMany.class, sourceModelContext );\n\t\t\tif ( oneToMany != null && !oneToMany.mappedBy().isEmpty() ) {\n\t\t\t\t// Unowned to-many mappings are always considered BAG by default\n\t\t\t\treturn CollectionClassification.BAG;\n\t\t\t}\n\n\t\t\t// otherwise, return the implicit classification for List attributes\n\t\t\treturn buildingContext.getBuildingOptions().getMappingDefaults().getImplicitListClassification();\n\t\t}\n\n\t\tif ( java.util.SortedSet.class.isAssignableFrom( semanticJavaType ) ) {\n\t\t\treturn CollectionClassification.SORTED_SET;\n\t\t}\n\n\t\tif ( java.util.Set.class.isAssignableFrom( semanticJavaType ) ) {\n\t\t\treturn CollectionClassification.SET;\n\t\t}\n\n\t\tif ( java.util.SortedMap.class.isAssignableFrom( semanticJavaType ) ) {\n\t\t\treturn CollectionClassification.SORTED_MAP;\n\t\t}\n\n\t\tif ( java.util.Map.class.isAssignableFrom( semanticJavaType ) ) {\n\t\t\treturn CollectionClassification.MAP;\n\t\t}\n\n\t\tif ( java.util.Collection.class.isAssignableFrom( semanticJavaType ) ) {\n\t\t\tif ( property.hasDirectAnnotationUsage( CollectionId.class ) ) {\n\t\t\t\treturn CollectionClassification.ID_BAG;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn CollectionClassification.BAG;\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tprivate static Class<?> determineSemanticJavaType(MemberDetails property, MetadataBuildingContext buildingContext) {\n\t\tif ( property.isPlural() ) {\n\t\t\tfinal ClassDetails collectionClassDetails = property.getType().determineRawClass();\n\t\t\tfinal Class<?> collectionClass = collectionClassDetails.toJavaClass();\n\t\t\treturn inferCollectionClassFromSubclass( collectionClass );\n\t\t}\n\t\telse {\n\t\t\tthrow new AnnotationException(\n\t\t\t\t\tString.format(\n\t\t\t\t\t\t\tLocale.ROOT,\n\t\t\t\t\t\t\t\"Property '%s.%s' is not a collection and may not be a '@OneToMany', '@ManyToMany', or '@ElementCollection'\",\n\t\t\t\t\t\t\tproperty.getDeclaringType().getName(),\n\t\t\t\t\t\t\tproperty.resolveAttributeName()\n\t\t\t\t\t)\n\t\t\t);\n\t\t}\n\t}\n\n\tprivate static Class<?> inferCollectionClassFromSubclass(Class<?> clazz) {\n\t\tfor ( Class<?> priorityClass : INFERRED_CLASS_PRIORITY ) {\n\t\t\tif ( priorityClass.isAssignableFrom( clazz ) ) {\n\t\t\t\treturn priorityClass;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic void setMappedBy(String mappedBy) {\n\t\tthis.mappedBy = nullIfEmpty( mappedBy );\n\t}\n\n\tpublic void setTableBinder(TableBinder tableBinder) {\n\t\tthis.tableBinder = tableBinder;\n\t}\n\n\tpublic void setElementType(TypeDetails collectionElementType) {\n\t\tthis.collectionElementType = collectionElementType;\n\t}\n\n\tpublic void setTargetEntity(Class<?> targetEntity) {\n\t\tfinal SourceModelBuildingContext sourceModelContext = buildingContext.getMetadataCollector().getSourceModelBuildingContext();\n\t\tfinal ClassDetailsRegistry classDetailsRegistry = sourceModelContext.getClassDetailsRegistry();\n\t\tsetTargetEntity( classDetailsRegistry.resolveClassDetails( targetEntity.getName() ) );\n\t}\n\n\tpublic void setTargetEntity(ClassDetails targetEntity) {\n\t\tsetTargetEntity( new ClassTypeDetailsImpl( targetEntity, TypeDetails.Kind.CLASS ) );\n\t}\n\n\tpublic void setTargetEntity(TypeDetails targetEntity) {\n\t\tthis.targetEntity = targetEntity;\n\t}\n\n\tprotected abstract Collection createCollection(PersistentClass persistentClass);\n\n\tpublic Collection getCollection() {\n\t\treturn collection;\n\t}\n\n\tpublic void setPropertyName(String propertyName) {\n\t\tthis.propertyName = propertyName;\n\t}\n\n\tpublic void setDeclaringClass(ClassDetails declaringClass) {\n\t\tthis.declaringClass = declaringClass;\n\t\tthis.declaringClassSet = true;\n\t}\n\n\tpublic void bind() {\n\t\tcollection = createCollection( propertyHolder.getPersistentClass() );\n\t\tfinal String role = qualify( propertyHolder.getPath(), propertyName );\n\t\tLOG.debugf( \"Collection role: %s\", role );\n\t\tcollection.setRole( role );\n\t\tcollection.setMappedByProperty( mappedBy );\n\n\t\tcheckMapKeyColumn();\n\t\tbindExplicitTypes();\n\t\t//set laziness\n\t\tdefineFetchingStrategy();\n\t\tcollection.setMutable( isMutable() );\n\t\t//work on association\n\t\tboolean isUnowned = isUnownedCollection();\n\t\tbindOptimisticLock( isUnowned );\n\t\tapplySortingAndOrdering();\n\t\tbindCache();\n\t\tbindLoader();\n\t\tdetectMappedByProblem( isUnowned );\n\t\tcollection.setInverse( isUnowned );\n\n\t\t//TODO reduce tableBinder != null and oneToMany\n\t\tscheduleSecondPass( isUnowned );\n\t\tbuildingContext.getMetadataCollector().addCollectionBinding( collection );\n\t\tbindProperty();\n\t}\n\n\tprivate boolean isUnownedCollection() {\n\t\treturn mappedBy != null;\n\t}\n\n\tprivate boolean isMutable() {\n\t\treturn !property.hasDirectAnnotationUsage( Immutable.class );\n\t}\n\n\tprivate void checkMapKeyColumn() {\n\t\tif ( property.hasDirectAnnotationUsage( MapKeyColumn.class ) && hasMapKeyProperty ) {\n\t\t\tthrow new AnnotationException( \"Collection '\" + qualify( propertyHolder.getPath(), propertyName )\n\t\t\t\t\t+ \"' is annotated both '@MapKey' and '@MapKeyColumn'\" );\n\t\t}\n\t}\n\n\tprivate void scheduleSecondPass(boolean isMappedBy) {\n\t\tfinal InFlightMetadataCollector metadataCollector = buildingContext.getMetadataCollector();\n\t\t//many to many may need some second pass information\n\t\tif ( !oneToMany && isMappedBy ) {\n\t\t\tmetadataCollector.addMappedBy( getElementType().getName(), mappedBy, propertyName );\n\t\t}\n\n\t\tif ( inheritanceStatePerClass == null) {\n\t\t\tthrow new AssertionFailure( \"inheritanceStatePerClass not set\" );\n\t\t}\n\t\tmetadataCollector.addSecondPass( getSecondPass(), !isMappedBy );\n\t}\n\n\tprivate void bindOptimisticLock(boolean isMappedBy) {\n\t\tfinal OptimisticLock lockAnn = property.getDirectAnnotationUsage( OptimisticLock.class );\n\t\tfinal boolean includeInOptimisticLockChecks = lockAnn != null ? !lockAnn.excluded() : !isMappedBy;\n\t\tcollection.setOptimisticLocked( includeInOptimisticLockChecks );\n\t}\n\n\tprivate void bindCache() {\n\t\t//set cache\n\t\tif ( isNotEmpty( cacheConcurrencyStrategy ) ) {\n\t\t\tcollection.setCacheConcurrencyStrategy( cacheConcurrencyStrategy );\n\t\t\tcollection.setCacheRegionName( cacheRegionName );\n\t\t}\n\t\tcollection.setQueryCacheLayout( queryCacheLayout );\n\t}\n\n\tprivate void bindExplicitTypes() {\n\t\t// set explicit type information\n\t\tfinal InFlightMetadataCollector metadataCollector = buildingContext.getMetadataCollector();\n\t\tif ( explicitType != null ) {\n\t\t\tfinal TypeDefinition typeDef = metadataCollector.getTypeDefinition( explicitType );\n\t\t\tif ( typeDef == null ) {\n\t\t\t\tcollection.setTypeName( explicitType );\n\t\t\t\tcollection.setTypeParameters( explicitTypeParameters );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcollection.setTypeName( typeDef.getTypeImplementorClass().getName() );\n\t\t\t\tcollection.setTypeParameters( typeDef.getParameters() );\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate void detectMappedByProblem(boolean isMappedBy) {\n\t\tif ( isMappedBy\n\t\t\t\t&& ( property.hasDirectAnnotationUsage( JoinColumn.class )\n\t\t\t\t\t|| property.hasDirectAnnotationUsage( JoinColumns.class ) ) ) {\n\t\t\tthrow new AnnotationException( \"Association '\"\n\t\t\t\t\t+ qualify( propertyHolder.getPath(), propertyName )\n\t\t\t\t\t+ \"' is 'mappedBy' another entity and may not specify the '@JoinColumn'\" );\n\t\t}\n\n\t\tif ( isMappedBy\n\t\t\t\t&& propertyHolder.getJoinTable( property ) != null ) {\n\t\t\tthrow new AnnotationException( \"Association '\"\n\t\t\t\t\t+ qualify( propertyHolder.getPath(), propertyName )\n\t\t\t\t\t+ \"' is 'mappedBy' another entity and may not specify the '@JoinTable'\" );\n\t\t}\n\n\t\tif ( !isMappedBy\n\t\t\t\t&& oneToMany\n\t\t\t\t&& property.hasDirectAnnotationUsage( OnDelete.class )\n\t\t\t\t&& !property.hasDirectAnnotationUsage( JoinColumn.class )\n\t\t\t\t&& !property.hasDirectAnnotationUsage( JoinColumns.class )) {\n\t\t\tthrow new AnnotationException( \"Unidirectional '@OneToMany' association '\"\n\t\t\t\t\t+ qualify( propertyHolder.getPath(), propertyName )\n\t\t\t\t\t+ \"' is annotated '@OnDelete' and must explicitly specify a '@JoinColumn'\" );\n\t\t}\n\t}\n\n\tprivate void bindProperty() {\n\t\t//property building\n\t\tPropertyBinder binder = new PropertyBinder();\n\t\tbinder.setName( propertyName );\n\t\tbinder.setValue( collection );\n\t\tbinder.setCascade( cascadeStrategy );\n\t\tif ( cascadeStrategy != null && cascadeStrategy.contains( \"delete-orphan\" ) ) {\n\t\t\tcollection.setOrphanDelete( true );\n\t\t}\n\t\tbinder.setLazy( collection.isLazy() );\n\t\tfinal LazyGroup lazyGroupAnnotation = property.getDirectAnnotationUsage( LazyGroup.class );\n\t\tif ( lazyGroupAnnotation != null ) {\n\t\t\tbinder.setLazyGroup( lazyGroupAnnotation.value() );\n\t\t}\n\t\tbinder.setAccessType( accessType );\n\t\tbinder.setMemberDetails( property );\n\t\tbinder.setInsertable( insertable );\n\t\tbinder.setUpdatable( updatable );\n\t\tbinder.setBuildingContext( buildingContext );\n\t\tbinder.setHolder( propertyHolder );\n\t\tProperty prop = binder.makeProperty();\n\t\t//we don't care about the join stuffs because the column is on the association table.\n\t\tif ( !declaringClassSet ) {\n\t\t\tthrow new AssertionFailure( \"DeclaringClass is not set in CollectionBinder while binding\" );\n\t\t}\n\t\tpropertyHolder.addProperty( prop, property, declaringClass );\n\t\tbinder.callAttributeBindersInSecondPass( prop );\n\t}\n\n\t@SuppressWarnings(\"deprecation\")\n\tprivate void bindLoader() {\n\t\t//SQL overriding\n\n\t\tfinal SQLInsert sqlInsert = property.getDirectAnnotationUsage( SQLInsert.class );\n\t\tif ( sqlInsert != null ) {\n\t\t\tcollection.setCustomSQLInsert(\n\t\t\t\t\tsqlInsert.sql().trim(),\n\t\t\t\t\tsqlInsert.callable(),\n\t\t\t\t\tfromResultCheckStyle( sqlInsert.check() )\n\t\t\t);\n\t\t\tfinal Class<? extends Expectation> verifier = sqlInsert.verify();\n\t\t\tif ( !Expectation.class.equals( verifier ) ) {\n\t\t\t\tcollection.setInsertExpectation( getDefaultSupplier( verifier ) );\n\t\t\t}\n\t\t}\n\n\t\tfinal SQLUpdate sqlUpdate = property.getDirectAnnotationUsage( SQLUpdate.class );\n\t\tif ( sqlUpdate != null ) {\n\t\t\tcollection.setCustomSQLUpdate(\n\t\t\t\t\tsqlUpdate.sql().trim(),\n\t\t\t\t\tsqlUpdate.callable(),\n\t\t\t\t\tfromResultCheckStyle( sqlUpdate.check() )\n\t\t\t);\n\t\t\tfinal Class<? extends Expectation> verifier = sqlUpdate.verify();\n\t\t\tif ( !Expectation.class.equals( verifier ) ) {\n\t\t\t\tcollection.setUpdateExpectation( getDefaultSupplier( verifier ) );\n\t\t\t}\n\t\t}\n\n\t\tfinal SQLDelete sqlDelete = property.getDirectAnnotationUsage( SQLDelete.class );\n\t\tif ( sqlDelete != null ) {\n\t\t\tcollection.setCustomSQLDelete(\n\t\t\t\t\tsqlDelete.sql().trim(),\n\t\t\t\t\tsqlDelete.callable(),\n\t\t\t\t\tfromResultCheckStyle( sqlDelete.check() )\n\t\t\t);\n\t\t\tfinal Class<? extends Expectation> verifier = sqlDelete.verify();\n\t\t\tif ( !Expectation.class.equals( verifier ) ) {\n\t\t\t\tcollection.setDeleteExpectation( getDefaultSupplier( verifier ) );\n\t\t\t}\n\t\t}\n\n\t\tfinal SQLDeleteAll sqlDeleteAll = property.getDirectAnnotationUsage( SQLDeleteAll.class );\n\t\tif ( sqlDeleteAll != null ) {\n\t\t\tcollection.setCustomSQLDeleteAll(\n\t\t\t\t\tsqlDeleteAll.sql().trim(),\n\t\t\t\t\tsqlDeleteAll.callable(),\n\t\t\t\t\tfromResultCheckStyle( sqlDeleteAll.check() )\n\t\t\t);\n\t\t\tfinal Class<? extends Expectation> verifier = sqlDeleteAll.verify();\n\t\t\tif ( !Expectation.class.equals( verifier ) ) {\n\t\t\t\tcollection.setDeleteAllExpectation( getDefaultSupplier( verifier ) );\n\t\t\t}\n\t\t}\n\n\t\tfinal SQLSelect sqlSelect = property.getDirectAnnotationUsage( SQLSelect.class );\n\t\tif ( sqlSelect != null ) {\n\t\t\tfinal String loaderName = collection.getRole() + \"$SQLSelect\";\n\t\t\tcollection.setLoaderName( loaderName );\n\t\t\t// TODO: pass in the collection element type here\n\t\t\tQueryBinder.bindNativeQuery( loaderName, sqlSelect, null, buildingContext );\n\t\t}\n\n\t\tfinal HQLSelect hqlSelect = property.getDirectAnnotationUsage( HQLSelect.class );\n\t\tif ( hqlSelect != null ) {\n\t\t\tfinal String loaderName = collection.getRole() + \"$HQLSelect\";\n\t\t\tcollection.setLoaderName( loaderName );\n\t\t\tQueryBinder.bindQuery( loaderName, hqlSelect, buildingContext );\n\t\t}\n\t}\n\n\tprivate void applySortingAndOrdering() {\n\n\t\tif ( naturalSort != null && comparatorSort != null ) {\n\t\t\tthrow buildIllegalSortCombination();\n\t\t}\n\t\tfinal boolean sorted = naturalSort != null || comparatorSort != null;\n\t\tfinal Class<? extends Comparator<?>> comparatorClass;\n\t\tif ( naturalSort != null ) {\n\t\t\tcomparatorClass = null;\n\t\t}\n\t\telse if ( comparatorSort != null ) {\n\t\t\tcomparatorClass = comparatorSort.value();\n\t\t}\n\t\telse {\n\t\t\tcomparatorClass = null;\n\t\t}\n\n\t\tif ( jpaOrderBy != null && ( sqlOrderBy != null || sqlOrder != null ) ) {\n\t\t\tthrow buildIllegalOrderCombination();\n\t\t}\n\t\tboolean ordered = jpaOrderBy != null || sqlOrderBy != null || sqlOrder != null ;\n\t\tif ( ordered ) {\n\t\t\t// we can only apply the sql-based order by up front.  The jpa order by has to wait for second pass\n\t\t\tif ( sqlOrderBy != null ) {\n\t\t\t\tcollection.setOrderBy( sqlOrderBy.clause() );\n\t\t\t}\n\t\t\tif ( sqlOrder != null ) {\n\t\t\t\tcollection.setOrderBy( sqlOrder.value() );\n\t\t\t}\n\t\t}\n\n\t\tfinal boolean isSorted = isSortedCollection || sorted;\n\t\tif ( isSorted && ordered ) {\n\t\t\tthrow buildIllegalOrderAndSortCombination();\n\t\t}\n\t\tcollection.setSorted( isSorted );\n\t\tinstantiateComparator( collection, comparatorClass );\n\t}\n\n\tprivate void instantiateComparator(Collection collection, Class<? extends Comparator<?>> comparatorClass) {\n\t\tif ( comparatorClass != null ) {\n\t\t\ttry {\n\t\t\t\tcollection.setComparator( comparatorClass.newInstance() );\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tthrow new AnnotationException(\n\t\t\t\t\t\tString.format(\n\t\t\t\t\t\t\t\t\"Could not instantiate comparator class '%s' for collection '%s'\",\n\t\t\t\t\t\t\t\tcomparatorClass.getName(),\n\t\t\t\t\t\t\t\tsafeCollectionRole()\n\t\t\t\t\t\t),\n\t\t\t\t\t\te\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate AnnotationException buildIllegalOrderCombination() {\n\t\treturn new AnnotationException(\n\t\t\t\tString.format(\n\t\t\t\t\t\tLocale.ROOT,\n\t\t\t\t\t\t\"Collection '%s' is annotated both '@%s' and '@%s'\",\n\t\t\t\t\t\tsafeCollectionRole(),\n\t\t\t\t\t\tjakarta.persistence.OrderBy.class.getName(),\n\t\t\t\t\t\torg.hibernate.annotations.OrderBy.class.getName()\n\t\t\t\t)\n\t\t);\n\t}\n\n\tprivate AnnotationException buildIllegalOrderAndSortCombination() {\n\t\tthrow new AnnotationException(\n\t\t\t\tString.format(\n\t\t\t\t\t\tLocale.ROOT,\n\t\t\t\t\t\t\"Collection '%s' is both sorted and ordered (only one of '@%s', '@%s', '@%s', and '@%s' may be used)\",\n\t\t\t\t\t\tsafeCollectionRole(),\n\t\t\t\t\t\tjakarta.persistence.OrderBy.class.getName(),\n\t\t\t\t\t\torg.hibernate.annotations.OrderBy.class.getName(),\n\t\t\t\t\t\tSortComparator.class.getName(),\n\t\t\t\t\t\tSortNatural.class.getName()\n\t\t\t\t)\n\t\t);\n\t}\n\n\tprivate AnnotationException buildIllegalSortCombination() {\n\t\treturn new AnnotationException(\n\t\t\t\tString.format(\n\t\t\t\t\t\t\"Collection '%s' is annotated both '@%s' and '@%s'\",\n\t\t\t\t\t\tsafeCollectionRole(),\n\t\t\t\t\t\tSortNatural.class.getName(),\n\t\t\t\t\t\tSortComparator.class.getName()\n\t\t\t\t)\n\t\t);\n\t}\n\n\tprivate void defineFetchingStrategy() {\n\t\thandleLazy();\n\t\thandleFetch();\n\t\thandleFetchProfileOverrides();\n\t}\n\n\tprivate SourceModelBuildingContext sourceModelContext() {\n\t\treturn buildingContext.getMetadataCollector().getSourceModelBuildingContext();\n\t}\n\n\tprivate void handleFetchProfileOverrides() {\n\t\tproperty.forEachAnnotationUsage( FetchProfileOverride.class, sourceModelContext(), (usage) -> {\n\t\t\tbuildingContext.getMetadataCollector().addSecondPass( new FetchSecondPass(\n\t\t\t\t\tusage,\n\t\t\t\t\tpropertyHolder,\n\t\t\t\t\tpropertyName,\n\t\t\t\t\tbuildingContext\n\t\t\t) );\n\t\t} );\n\t}\n\n\tprivate void handleFetch() {\n\t\tfinal Fetch fetchAnnotation = property.getDirectAnnotationUsage( Fetch.class );\n\t\tif ( fetchAnnotation != null ) {\n\t\t\t// Hibernate @Fetch annotation takes precedence\n\t\t\tsetHibernateFetchMode( fetchAnnotation.value() );\n\t\t}\n\t\telse {\n\t\t\tcollection.setFetchMode( getFetchMode( getJpaFetchType() ) );\n\t\t}\n\t}\n\n\tprivate void setHibernateFetchMode(org.hibernate.annotations.FetchMode fetchMode) {\n\t\tswitch ( fetchMode ) {\n\t\t\tcase JOIN -> {\n\t\t\t\tcollection.setFetchMode( FetchMode.JOIN );\n\t\t\t\tcollection.setLazy( false );\n\t\t\t}\n\t\t\tcase SELECT -> {\n\t\t\t\tcollection.setFetchMode( FetchMode.SELECT );\n\t\t\t}\n\t\t\tcase SUBSELECT -> {\n\t\t\t\tcollection.setFetchMode( FetchMode.SELECT );\n\t\t\t\tcollection.setSubselectLoadable( true );\n\t\t\t\tcollection.getOwner().setSubselectLoadableCollections( true );\n\t\t\t}\n\t\t\tdefault -> {\n\t\t\t\tthrow new AssertionFailure( \"unknown fetch type\" );\n\t\t\t}\n\t\t}\n\t}\n\n\t@SuppressWarnings(\"deprecation\")\n\tprivate void handleLazy() {\n\t\tfinal FetchType jpaFetchType = getJpaFetchType();\n\t\tcollection.setLazy( jpaFetchType == LAZY );\n\t\tcollection.setExtraLazy( false );\n\t}\n\n\tprivate FetchType getJpaFetchType() {\n\t\tfinal OneToMany oneToMany = property.getDirectAnnotationUsage( OneToMany.class );\n\t\tfinal ManyToMany manyToMany = property.getDirectAnnotationUsage( ManyToMany.class );\n\t\tfinal ElementCollection elementCollection = property.getDirectAnnotationUsage( ElementCollection.class );\n\t\tfinal ManyToAny manyToAny = property.getDirectAnnotationUsage( ManyToAny.class );\n\t\tif ( oneToMany != null ) {\n\t\t\treturn oneToMany.fetch();\n\t\t}\n\n\t\tif ( manyToMany != null ) {\n\t\t\treturn manyToMany.fetch();\n\t\t}\n\n\t\tif ( elementCollection != null ) {\n\t\t\treturn elementCollection.fetch();\n\t\t}\n\n\t\tif ( manyToAny != null ) {\n\t\t\treturn LAZY;\n\t\t}\n\n\t\tthrow new AssertionFailure(\n\t\t\t\t\"Define fetch strategy on a property not annotated with @ManyToOne nor @OneToMany nor @CollectionOfElements\"\n\t\t);\n\t}\n\n\tTypeDetails getElementType() {\n\t\tif ( isDefault( targetEntity ) ) {\n\t\t\tif ( collectionElementType != null ) {\n\t\t\t\treturn collectionElementType;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new AnnotationException( \"Collection '\" + safeCollectionRole()\n\t\t\t\t\t\t+ \"' is declared with a raw type and has an explicit 'targetEntity'\" );\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\treturn targetEntity;\n\t\t}\n\t}\n\n\tSecondPass getSecondPass() {\n\t\treturn new CollectionSecondPass( collection ) {\n\t\t\t@Override\n\t\t\tpublic void secondPass(Map<String, PersistentClass> persistentClasses) throws MappingException {\n\t\t\t\tbindStarToManySecondPass( persistentClasses );\n\t\t\t}\n\t\t};\n\t}\n\n\t/**\n\t * return true if it's a Fk, false if it's an association table\n\t */\n\tprotected boolean bindStarToManySecondPass(Map<String, PersistentClass> persistentClasses) {\n\t\tif ( noAssociationTable( persistentClasses ) ) {\n\t\t\t//this is a foreign key\n\t\t\tbindOneToManySecondPass( persistentClasses );\n\t\t\treturn true;\n\t\t}\n\t\telse {\n\t\t\t//this is an association table\n\t\t\tbindManyToManySecondPass( persistentClasses );\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tprivate boolean isReversePropertyInJoin(\n\t\t\tTypeDetails elementType,\n\t\t\tPersistentClass persistentClass,\n\t\t\tMap<String, PersistentClass> persistentClasses) {\n\t\tif ( persistentClass != null && isUnownedCollection() ) {\n\t\t\tfinal Property mappedByProperty;\n\t\t\ttry {\n\t\t\t\tmappedByProperty = persistentClass.getRecursiveProperty( mappedBy );\n\t\t\t}\n\t\t\tcatch (MappingException e) {\n\t\t\t\tthrow new AnnotationException(\n\t\t\t\t\t\t\"Collection '\" + safeCollectionRole()\n\t\t\t\t\t\t\t\t+ \"' is 'mappedBy' a property named '\" + mappedBy\n\t\t\t\t\t\t\t\t+ \"' which does not exist in the target entity '\" + elementType.getName() + \"'\"\n\t\t\t\t);\n\t\t\t}\n\t\t\tcheckMappedByType( mappedBy, mappedByProperty.getValue(), propertyName, propertyHolder, persistentClasses );\n\t\t\treturn persistentClass.getJoinNumber( mappedByProperty ) != 0;\n\t\t}\n\t\telse {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tprivate boolean noAssociationTable(Map<String, PersistentClass> persistentClasses) {\n\t\tfinal PersistentClass persistentClass = persistentClasses.get( getElementType().getName() );\n\t\treturn persistentClass != null\n\t\t\t&& !isReversePropertyInJoin( getElementType(), persistentClass, persistentClasses )\n\t\t\t&& oneToMany\n\t\t\t&& !isExplicitAssociationTable\n\t\t\t&& ( implicitJoinColumn() || explicitForeignJoinColumn() );\n\t}\n\n\tprivate boolean implicitJoinColumn() {\n\t\treturn joinColumns.getJoinColumns().get(0).isImplicit()\n\t\t\t&& isUnownedCollection(); //implicit @JoinColumn\n\t}\n\n\tprivate boolean explicitForeignJoinColumn() {\n\t\treturn !foreignJoinColumns.getJoinColumns().get(0).isImplicit(); //this is an explicit @JoinColumn\n\t}\n\n\t/**\n\t * Bind a {@link OneToMany} association.\n\t */\n\tprotected void bindOneToManySecondPass(Map<String, PersistentClass> persistentClasses) {\n\t\tif ( property == null ) {\n\t\t\tthrow new AssertionFailure( \"null was passed for argument property\" );\n\t\t}\n\n\t\tlogOneToManySecondPass();\n\n\t\tfinal org.hibernate.mapping.OneToMany oneToMany =\n\t\t\t\tnew org.hibernate.mapping.OneToMany( buildingContext, getCollection().getOwner() );\n\t\tcollection.setElement( oneToMany );\n\t\toneToMany.setReferencedEntityName( getElementType().getName() );\n\t\toneToMany.setNotFoundAction( notFoundAction );\n\n\t\tfinal String referencedEntityName = oneToMany.getReferencedEntityName();\n\t\tfinal PersistentClass associatedClass = persistentClasses.get( referencedEntityName );\n\t\thandleJpaOrderBy( collection, associatedClass );\n\t\tif ( associatedClass == null ) {\n\t\t\tthrow new MappingException(\n\t\t\t\t\tString.format( \"Association [%s] for entity [%s] references unmapped class [%s]\",\n\t\t\t\t\t\t\tpropertyName, propertyHolder.getClassName(), referencedEntityName )\n\t\t\t);\n\t\t}\n\t\toneToMany.setAssociatedClass( associatedClass );\n\n\t\tfinal Map<String, Join> joins = buildingContext.getMetadataCollector().getJoins( referencedEntityName );\n\t\tforeignJoinColumns.setPropertyHolder( buildPropertyHolder(\n\t\t\t\tassociatedClass,\n\t\t\t\tjoins,\n\t\t\t\tforeignJoinColumns.getBuildingContext(),\n\t\t\t\tinheritanceStatePerClass\n\t\t) );\n\t\tforeignJoinColumns.setJoins( joins );\n\t\tif ( foreignJoinColumns.hasMappedBy() ) {\n\t\t\tcollection.setCollectionTable( associatedClass.getRecursiveProperty( foreignJoinColumns.getMappedBy() ).getValue().getTable() );\n\t\t}\n\t\telse {\n\t\t\tcollection.setCollectionTable( foreignJoinColumns.getTable() );\n\t\t}\n\t\tif ( LOG.isDebugEnabled() ) {\n\t\t\tLOG.debugf( \"Mapping collection: %s -> %s\", collection.getRole(), collection.getCollectionTable().getName() );\n\t\t}\n\n\t\tbindSynchronize();\n\t\tbindFilters( false );\n\t\thandleWhere( false );\n\n\t\tfinal PersistentClass targetEntity = persistentClasses.get( getElementType().getName() );\n\t\tbindCollectionSecondPass( targetEntity, foreignJoinColumns );\n\n\t\tif ( !collection.isInverse() && !collection.getKey().isNullable() ) {\n\t\t\tcreateOneToManyBackref( oneToMany );\n\t\t}\n\t}\n\n\tprivate void createOneToManyBackref(org.hibernate.mapping.OneToMany oneToMany) {\n\t\tfinal InFlightMetadataCollector collector = buildingContext.getMetadataCollector();\n\t\t// for non-inverse one-to-many, with a not-null fk, add a backref!\n\t\tfinal String entityName = oneToMany.getReferencedEntityName();\n\t\tfinal PersistentClass referenced = collector.getEntityBinding( entityName );\n\t\tfinal Backref backref = new Backref();\n\t\tfinal String backrefName = '_' + foreignJoinColumns.getPropertyName()\n\t\t\t\t+ '_' + foreignJoinColumns.getColumns().get(0).getLogicalColumnName()\n\t\t\t\t+ \"Backref\";\n\t\tbackref.setName( backrefName );\n\t\tbackref.setOptional( true );\n\t\tbackref.setUpdateable( false);\n\t\tbackref.setSelectable( false );\n\t\tbackref.setCollectionRole( collection.getRole() );\n\t\tbackref.setEntityName( collection.getOwner().getEntityName() );\n\t\tbackref.setValue( collection.getKey() );\n\t\treferenced.addProperty( backref );\n\t}\n\n\tprivate void handleJpaOrderBy(Collection collection, PersistentClass associatedClass) {\n\t\tif ( jpaOrderBy != null ) {\n\t\t\tfinal String orderByFragment = buildOrderByClauseFromHql( jpaOrderBy.value(), associatedClass );\n\t\t\tif ( isNotEmpty( orderByFragment ) ) {\n\t\t\t\tcollection.setOrderBy( orderByFragment );\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate void bindSynchronize() {\n\t\tfinal Synchronize synchronizeAnnotation = property.getDirectAnnotationUsage( Synchronize.class );\n\t\tif ( synchronizeAnnotation != null ) {\n\t\t\tfinal JdbcEnvironment jdbcEnvironment = buildingContext.getMetadataCollector().getDatabase().getJdbcEnvironment();\n\t\t\tfor ( String table : synchronizeAnnotation.value() ) {\n\t\t\t\tString physicalName = synchronizeAnnotation.logical()\n\t\t\t\t\t\t? toPhysicalName( jdbcEnvironment, table )\n\t\t\t\t\t\t: table;\n\t\t\t\tcollection.addSynchronizedTable( physicalName );\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate String toPhysicalName(JdbcEnvironment jdbcEnvironment, String logicalName) {\n\t\treturn buildingContext.getBuildingOptions().getPhysicalNamingStrategy()\n\t\t\t\t.toPhysicalTableName(\n\t\t\t\t\t\tjdbcEnvironment.getIdentifierHelper().toIdentifier( logicalName ),\n\t\t\t\t\t\tjdbcEnvironment\n\t\t\t\t)\n\t\t\t\t.render( jdbcEnvironment.getDialect() );\n\t}\n\n\tprivate void bindFilters(boolean hasAssociationTable) {\n\t\tproperty.forEachAnnotationUsage( Filter.class, sourceModelContext(), (usage) -> {\n\t\t\taddFilter( hasAssociationTable, usage );\n\t\t} );\n\n\t\tproperty.forEachAnnotationUsage( FilterJoinTable.class, sourceModelContext(), (usage) -> {\n\t\t\taddFilterJoinTable( hasAssociationTable, usage );\n\t\t} );\n\t}\n\n\tprivate void addFilter(boolean hasAssociationTable, Filter filterAnnotation) {\n\t\tfinal Map<String,String> aliasTableMap = new HashMap<>();\n\t\tfinal Map<String,String> aliasEntityMap = new HashMap<>();\n\t\tfinal SqlFragmentAlias[] aliasAnnotations = filterAnnotation.aliases();\n\t\tfor ( SqlFragmentAlias aliasAnnotation : aliasAnnotations ) {\n\t\t\tfinal String alias = aliasAnnotation.alias();\n\n\t\t\tfinal String table = aliasAnnotation.table();\n\t\t\tif ( isNotEmpty( table ) ) {\n\t\t\t\taliasTableMap.put( alias, table );\n\t\t\t}\n\n\t\t\tfinal Class<?> entityClassDetails = aliasAnnotation.entity();\n\t\t\tif ( entityClassDetails != void.class ) {\n\t\t\t\taliasEntityMap.put( alias, entityClassDetails.getName() );\n\t\t\t}\n\t\t}\n\n\t\tif ( hasAssociationTable ) {\n\t\t\tcollection.addManyToManyFilter(\n\t\t\t\t\tfilterAnnotation.name(),\n\t\t\t\t\tgetFilterCondition( filterAnnotation ),\n\t\t\t\t\tfilterAnnotation.deduceAliasInjectionPoints(),\n\t\t\t\t\taliasTableMap,\n\t\t\t\t\taliasEntityMap\n\t\t\t);\n\t\t}\n\t\telse {\n\t\t\tcollection.addFilter(\n\t\t\t\t\tfilterAnnotation.name(),\n\t\t\t\t\tgetFilterCondition( filterAnnotation ),\n\t\t\t\t\tfilterAnnotation.deduceAliasInjectionPoints(),\n\t\t\t\t\taliasTableMap,\n\t\t\t\t\taliasEntityMap\n\t\t\t);\n\t\t}\n\t}\n\n\tprivate void handleWhere(boolean hasAssociationTable) {\n\t\tfinal String whereClause = getWhereClause();\n\t\tif ( hasAssociationTable ) {\n\t\t\t// A many-to-many association has an association (join) table\n\t\t\t// Collection#setManytoManyWhere is used to set the \"where\" clause that applies\n\t\t\t// to the many-to-many associated entity table (not the join table).\n\t\t\tcollection.setManyToManyWhere( whereClause );\n\t\t}\n\t\telse {\n\t\t\t// A one-to-many association does not have an association (join) table.\n\t\t\t// Collection#setWhere is used to set the \"where\" clause that applies to the collection table\n\t\t\t// (which is the associated entity table for a one-to-many association).\n\t\t\tcollection.setWhere( whereClause );\n\t\t}\n\n\t\tfinal String whereJoinTableClause = getWhereJoinTableClause();\n\t\tif ( isNotEmpty( whereJoinTableClause ) ) {\n\t\t\tif ( hasAssociationTable ) {\n\t\t\t\t// This is a many-to-many association.\n\t\t\t\t// Collection#setWhere is used to set the \"where\" clause that applies to the collection table\n\t\t\t\t// (which is the join table for a many-to-many association).\n\t\t\t\tcollection.setWhere( whereJoinTableClause );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new AnnotationException(\n\t\t\t\t\t\t\"Collection '\" + qualify( propertyHolder.getPath(), propertyName )\n\t\t\t\t\t\t\t\t+ \"' is an association with no join table and may not have a 'WhereJoinTable'\"\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate String getWhereJoinTableClause() {\n\t\tfinal SQLJoinTableRestriction joinTableRestriction = property.getDirectAnnotationUsage( SQLJoinTableRestriction.class );\n\t\treturn joinTableRestriction != null ? joinTableRestriction.value() : null;\n\t}\n\n\tprivate String getWhereClause() {\n\t\t// There are 2 possible sources of \"where\" clauses that apply to the associated entity table:\n\t\t// 1) from the associated entity mapping; i.e., @Entity @Where(clause=\"...\")\n\t\t//    (ignored if useEntityWhereClauseForCollections == false)\n\t\t// 2) from the collection mapping;\n\t\t//    for one-to-many, e.g., @OneToMany @JoinColumn @Where(clause=\"...\") public Set<Rating> getRatings();\n\t\t//    for many-to-many e.g., @ManyToMany @Where(clause=\"...\") public Set<Rating> getRatings();\n\t\treturn getNonEmptyOrConjunctionIfBothNonEmpty( getWhereOnClassClause(), getWhereOnCollectionClause() );\n\t}\n\n\tprivate String getWhereOnCollectionClause() {\n\t\tfinal SQLRestriction restrictionOnCollection = getOverridableAnnotation( property, SQLRestriction.class, getBuildingContext() );\n\t\treturn restrictionOnCollection != null ? restrictionOnCollection.value() : null;\n\t}\n\n\tprivate String getWhereOnClassClause() {\n\t\tfinal TypeDetails elementType = property.getElementType();\n\t\tfinal SQLRestriction restrictionOnClass = getOverridableAnnotation(\n\t\t\t\tproperty.getAssociatedType().determineRawClass(),\n\t\t\t\tSQLRestriction.class,\n\t\t\t\tbuildingContext\n\t\t);\n\t\treturn restrictionOnClass != null ? restrictionOnClass.value() : null;\n\t}\n\n\tprivate void addFilterJoinTable(boolean hasAssociationTable, FilterJoinTable filter) {\n\t\tif ( hasAssociationTable ) {\n\t\t\tfinal Map<String,String> aliasTableMap = new HashMap<>();\n\t\t\tfinal Map<String,String> aliasEntityMap = new HashMap<>();\n\t\t\tfinal SqlFragmentAlias[] aliasAnnotations = filter.aliases();\n\t\t\tfor ( SqlFragmentAlias aliasAnnotation : aliasAnnotations ) {\n\t\t\t\tfinal String alias = aliasAnnotation.alias();\n\n\t\t\t\tfinal String table = aliasAnnotation.table();\n\t\t\t\tif ( isNotEmpty( table ) ) {\n\t\t\t\t\taliasTableMap.put( alias, table );\n\t\t\t\t}\n\n\t\t\t\tfinal Class<?> entityClassDetails = aliasAnnotation.entity();\n\t\t\t\tif ( entityClassDetails != void.class ) {\n\t\t\t\t\taliasEntityMap.put( alias, entityClassDetails.getName() );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcollection.addFilter(\n\t\t\t\t\tfilter.name(),\n\t\t\t\t\tgetFilterConditionForJoinTable( filter ),\n\t\t\t\t\tfilter.deduceAliasInjectionPoints(),\n\t\t\t\t\taliasTableMap,\n\t\t\t\t\taliasEntityMap\n\t\t\t);\n\t\t}\n\t\telse {\n\t\t\tthrow new AnnotationException( \"Collection '\" + qualify( propertyHolder.getPath(), propertyName )\n\t\t\t\t\t+ \"' is an association with no join table and may not have a '@FilterJoinTable'\" );\n\t\t}\n\t}\n\n\tprivate String getFilterConditionForJoinTable(FilterJoinTable filterJoinTableAnnotation) {\n\t\tfinal String condition = filterJoinTableAnnotation.condition();\n\t\treturn condition.isEmpty()\n\t\t\t\t? getDefaultFilterCondition( filterJoinTableAnnotation.name(), filterJoinTableAnnotation )\n\t\t\t\t: condition;\n\t}\n\n\tprivate String getFilterCondition(Filter filter) {\n\t\tfinal String condition = filter.condition();\n\t\treturn condition.isEmpty()\n\t\t\t\t? getDefaultFilterCondition( filter.name(), filter )\n\t\t\t\t: condition;\n\t}\n\n\tprivate String getDefaultFilterCondition(String name, Annotation annotation) {\n\t\tfinal FilterDefinition definition = buildingContext.getMetadataCollector().getFilterDefinition( name );\n\t\tif ( definition == null ) {\n\t\t\tthrow new AnnotationException( \"Collection '\" + qualify( propertyHolder.getPath(), propertyName )\n\t\t\t\t\t+ \"' has a '@\" + annotation.annotationType().getSimpleName()\n\t\t\t\t\t+ \"' for an undefined filter named '\" + name + \"'\" );\n\t\t}\n\t\tfinal String defaultCondition = definition.getDefaultFilterCondition();\n\t\tif ( isEmpty( defaultCondition ) ) {\n\t\t\tthrow new AnnotationException( \"Collection '\" + qualify( propertyHolder.getPath(), propertyName ) +\n\t\t\t\t\t\"' has a '@\"  + annotation.annotationType().getSimpleName()\n\t\t\t\t\t+ \"' with no 'condition' and no default condition was given by the '@FilterDef' named '\"\n\t\t\t\t\t+ name + \"'\" );\n\t\t}\n\t\treturn defaultCondition;\n\t}\n\n\tpublic void setCache(Cache cache) {\n\t\tif ( cache != null ) {\n\t\t\tcacheRegionName = nullIfEmpty( cache.region() );\n\t\t\tcacheConcurrencyStrategy = EntityBinder.getCacheConcurrencyStrategy( cache.usage() );\n\t\t}\n\t\telse {\n\t\t\tcacheConcurrencyStrategy = null;\n\t\t\tcacheRegionName = null;\n\t\t}\n\t}\n\n\tpublic void setQueryCacheLayout(QueryCacheLayout queryCacheLayout) {\n\t\tthis.queryCacheLayout = queryCacheLayout == null ? null : queryCacheLayout.layout();\n\t}\n\n\tpublic void setOneToMany(boolean oneToMany) {\n\t\tthis.oneToMany = oneToMany;\n\t}\n\n\tpublic void setIndexColumn(IndexColumn indexColumn) {\n\t\tthis.indexColumn = indexColumn;\n\t}\n\n\tpublic void setMapKey(MapKey key) {\n\t\thasMapKeyProperty = key != null;\n\t\tif ( hasMapKeyProperty ) {\n\t\t\tmapKeyPropertyName = nullIfEmpty( key.name() );\n\t\t}\n\t}\n\n\tprivate static String buildOrderByClauseFromHql(String orderByFragment, PersistentClass associatedClass) {\n\t\tif ( orderByFragment == null ) {\n\t\t\treturn null;\n\t\t}\n\t\telse if ( orderByFragment.isEmpty() ) {\n\t\t\t//order by id\n\t\t\treturn buildOrderById( associatedClass, \" asc\" );\n\t\t}\n\t\telse if ( \"desc\".equalsIgnoreCase( orderByFragment ) ) {\n\t\t\treturn buildOrderById( associatedClass, \" desc\" );\n\t\t}\n\t\telse {\n\t\t\treturn orderByFragment;\n\t\t}\n\t}\n\n\tprivate static String buildOrderById(PersistentClass associatedClass, String order) {\n\t\tfinal StringBuilder sb = new StringBuilder();\n\t\tfor ( Selectable selectable: associatedClass.getIdentifier().getSelectables() ) {\n\t\t\tsb.append( selectable.getText() );\n\t\t\tsb.append( order );\n\t\t\tsb.append( \", \" );\n\t\t}\n\t\tsb.setLength( sb.length() - 2 );\n\t\treturn sb.toString();\n\t}\n\n\tpublic static String adjustUserSuppliedValueCollectionOrderingFragment(String orderByFragment) {\n\t\tif ( orderByFragment != null ) {\n\t\t\torderByFragment = orderByFragment.trim();\n\t\t\tif ( orderByFragment.length() == 0 || orderByFragment.equalsIgnoreCase( \"asc\" ) ) {\n\t\t\t\t// This indicates something like either:\n\t\t\t\t//\t\t`@OrderBy()`\n\t\t\t\t//\t\t`@OrderBy(\"asc\")\n\t\t\t\t//\n\t\t\t\t// JPA says this should indicate an ascending natural ordering of the elements - id for\n\t\t\t\t//\t\tentity associations or the value(s) for \"element collections\"\n\t\t\t\treturn \"$element$ asc\";\n\t\t\t}\n\t\t\telse if ( orderByFragment.equalsIgnoreCase( \"desc\" ) ) {\n\t\t\t\t// This indicates:\n\t\t\t\t//\t\t`@OrderBy(\"desc\")`\n\t\t\t\t//\n\t\t\t\t// JPA says this should indicate a descending natural ordering of the elements - id for\n\t\t\t\t//\t\tentity associations or the value(s) for \"element collections\"\n\t\t\t\treturn \"$element$ desc\";\n\t\t\t}\n\t\t}\n\n\t\treturn orderByFragment;\n\t}\n\n\tprivate DependantValue buildCollectionKey(AnnotatedJoinColumns joinColumns, OnDeleteAction onDeleteAction) {\n\n\t\tfinal boolean noConstraintByDefault = buildingContext.getBuildingOptions().isNoConstraintByDefault();\n\n\t\t// give a chance to override the referenced property name\n\t\t// has to do that here because the referencedProperty creation happens in a FKSecondPass for ManyToOne yuk!\n\t\toverrideReferencedPropertyName( collection, joinColumns );\n\n\t\tfinal String referencedPropertyName = collection.getReferencedPropertyName();\n\t\t//binding key reference using column\n\t\tfinal PersistentClass owner = collection.getOwner();\n\t\tfinal KeyValue keyValue = referencedPropertyName == null\n\t\t\t\t? owner.getIdentifier()\n\t\t\t\t: (KeyValue) owner.getReferencedProperty( referencedPropertyName ).getValue();\n\n\t\tfinal DependantValue key = new DependantValue( buildingContext, collection.getCollectionTable(), keyValue );\n\t\tkey.setTypeName( null );\n\t\tjoinColumns.checkPropertyConsistency();\n\t\tfinal List<AnnotatedColumn> columns = joinColumns.getColumns();\n\t\tkey.setNullable( columns.isEmpty() || columns.get(0).isNullable() );\n\t\tkey.setUpdateable( columns.isEmpty() || columns.get(0).isUpdatable() );\n\t\tkey.setOnDeleteAction( onDeleteAction );\n\t\tcollection.setKey( key );\n\n\t\tif ( property != null ) {\n\t\t\tfinal CollectionTable collectionTableAnn = property.getDirectAnnotationUsage( CollectionTable.class );\n\t\t\tif ( collectionTableAnn != null ) {\n\t\t\t\tfinal ForeignKey foreignKey = collectionTableAnn.foreignKey();\n\t\t\t\tfinal ConstraintMode constraintMode = foreignKey.value();\n\t\t\t\tif ( constraintMode == NO_CONSTRAINT\n\t\t\t\t\t\t|| constraintMode == PROVIDER_DEFAULT && noConstraintByDefault ) {\n\t\t\t\t\tkey.disableForeignKey();\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tkey.setForeignKeyName( nullIfEmpty( foreignKey.name() ) );\n\t\t\t\t\tkey.setForeignKeyDefinition( nullIfEmpty( foreignKey.foreignKeyDefinition() ) );\n\t\t\t\t\tif ( key.getForeignKeyName() == null\n\t\t\t\t\t\t\t&& key.getForeignKeyDefinition() == null\n\t\t\t\t\t\t\t&& collectionTableAnn.joinColumns().length == 1 ) {\n\t\t\t\t\t\t//noinspection unchecked\n\t\t\t\t\t\tfinal JoinColumn joinColumn = collectionTableAnn.joinColumns()[0];\n\t\t\t\t\t\tfinal ForeignKey nestedForeignKey = joinColumn.foreignKey();\n\t\t\t\t\t\tkey.setForeignKeyName( nullIfEmpty( nestedForeignKey.name() ) );\n\t\t\t\t\t\tkey.setForeignKeyDefinition( nullIfEmpty( nestedForeignKey.foreignKeyDefinition() ) );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfinal JoinTable joinTableAnn = property.getDirectAnnotationUsage( JoinTable.class );\n\t\t\t\tif ( joinTableAnn != null ) {\n\t\t\t\t\tfinal ForeignKey foreignKey = joinTableAnn.foreignKey();\n\t\t\t\t\tString foreignKeyName = foreignKey.name();\n\t\t\t\t\tString foreignKeyDefinition = foreignKey.foreignKeyDefinition();\n\t\t\t\t\tConstraintMode foreignKeyValue = foreignKey.value();\n\t\t\t\t\tfinal JoinColumn[] joinColumnAnnotations = joinTableAnn.joinColumns();\n\t\t\t\t\tif ( !ArrayHelper.isEmpty( joinColumnAnnotations ) ) {\n\t\t\t\t\t\tfinal JoinColumn joinColumnAnn = joinColumnAnnotations[0];\n\t\t\t\t\t\tfinal ForeignKey joinColumnForeignKey = joinColumnAnn.foreignKey();\n\t\t\t\t\t\tif ( foreignKeyName.isEmpty() ) {\n\t\t\t\t\t\t\tforeignKeyName = joinColumnForeignKey.name();\n\t\t\t\t\t\t\tforeignKeyDefinition = joinColumnForeignKey.foreignKeyDefinition();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( foreignKeyValue != NO_CONSTRAINT ) {\n\t\t\t\t\t\t\tforeignKeyValue = joinColumnForeignKey.value();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif ( foreignKeyValue == NO_CONSTRAINT\n\t\t\t\t\t\t\t|| foreignKeyValue == PROVIDER_DEFAULT && noConstraintByDefault ) {\n\t\t\t\t\t\tkey.disableForeignKey();\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tkey.setForeignKeyName( nullIfEmpty( foreignKeyName ) );\n\t\t\t\t\t\tkey.setForeignKeyDefinition( nullIfEmpty( foreignKeyDefinition ) );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tfinal String propertyPath = qualify( propertyHolder.getPath(), property.getName() );\n\t\t\t\t\tfinal ForeignKey foreignKey = propertyHolder.getOverriddenForeignKey( propertyPath );\n\t\t\t\t\tif ( foreignKey != null ) {\n\t\t\t\t\t\thandleForeignKeyConstraint( noConstraintByDefault, key, foreignKey );\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tfinal OneToMany oneToManyAnn = property.getDirectAnnotationUsage( OneToMany.class );\n\t\t\t\t\t\tfinal OnDelete onDeleteAnn = property.getDirectAnnotationUsage( OnDelete.class );\n\t\t\t\t\t\tif ( oneToManyAnn != null\n\t\t\t\t\t\t\t\t&& !oneToManyAnn.mappedBy().isEmpty()\n\t\t\t\t\t\t\t\t&& ( onDeleteAnn == null || onDeleteAnn.action() != OnDeleteAction.CASCADE ) ) {\n\t\t\t\t\t\t\t// foreign key should be up to @ManyToOne side\n\t\t\t\t\t\t\t// @OnDelete generate \"on delete cascade\" foreign key\n\t\t\t\t\t\t\tkey.disableForeignKey();\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tfinal JoinColumn joinColumnAnn = property.getDirectAnnotationUsage( JoinColumn.class );\n\t\t\t\t\t\t\tif ( joinColumnAnn != null ) {\n\t\t\t\t\t\t\t\thandleForeignKeyConstraint( noConstraintByDefault, key, joinColumnAnn.foreignKey() );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn key;\n\t}\n\n\tprivate static void handleForeignKeyConstraint(\n\t\t\tboolean noConstraintByDefault,\n\t\t\tDependantValue key,\n\t\t\tForeignKey foreignKey) {\n\t\tfinal ConstraintMode constraintMode = foreignKey.value();\n\t\tif ( constraintMode == NO_CONSTRAINT\n\t\t\t\t|| constraintMode == PROVIDER_DEFAULT && noConstraintByDefault) {\n\t\t\tkey.disableForeignKey();\n\t\t}\n\t\telse {\n\t\t\tkey.setForeignKeyName( nullIfEmpty( foreignKey.name() ) );\n\t\t\tkey.setForeignKeyDefinition( nullIfEmpty( foreignKey.foreignKeyDefinition() ) );\n\t\t}\n\t}\n\n\tprivate void overrideReferencedPropertyName(Collection collection, AnnotatedJoinColumns joinColumns) {\n\t\tif ( isUnownedCollection() && !joinColumns.getColumns().isEmpty() ) {\n\t\t\tfinal String entityName = joinColumns.getManyToManyOwnerSideEntityName() != null\n\t\t\t\t\t? \"inverse__\" + joinColumns.getManyToManyOwnerSideEntityName()\n\t\t\t\t\t: joinColumns.getPropertyHolder().getEntityName();\n\t\t\tfinal InFlightMetadataCollector collector = buildingContext.getMetadataCollector();\n\t\t\tfinal String referencedProperty = collector.getPropertyReferencedAssociation( entityName, mappedBy );\n\t\t\tif ( referencedProperty != null ) {\n\t\t\t\tcollection.setReferencedPropertyName( referencedProperty );\n\t\t\t\tcollector.addPropertyReference( collection.getOwnerEntityName(), referencedProperty );\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Bind a {@link ManyToMany} association or {@link ElementCollection}.\n\t */\n\tprivate void bindManyToManySecondPass(Map<String, PersistentClass> persistentClasses) throws MappingException {\n\t\tif ( property == null ) {\n\t\t\tthrow new AssertionFailure( \"null was passed for argument property\" );\n\t\t}\n\n\t\tfinal TypeDetails elementType = getElementType();\n\t\tfinal PersistentClass targetEntity = persistentClasses.get( elementType.getName() ); //null if this is an @ElementCollection\n\t\tfinal String hqlOrderBy = extractHqlOrderBy( jpaOrderBy );\n\n\t\tfinal boolean isCollectionOfEntities = targetEntity != null;\n\t\tfinal boolean isManyToAny = property.hasDirectAnnotationUsage( ManyToAny.class );\n\n\t\tlogManyToManySecondPass( oneToMany, isCollectionOfEntities, isManyToAny );\n\n\t\t//check for user error\n\t\tdetectManyToManyProblems( elementType, isCollectionOfEntities, isManyToAny );\n\n\t\tif ( isUnownedCollection() ) {\n\t\t\thandleUnownedManyToMany( elementType, targetEntity, isCollectionOfEntities );\n\t\t}\n\t\telse {\n\t\t\thandleOwnedManyToMany( targetEntity, isCollectionOfEntities );\n\t\t}\n\n\t\tbindSynchronize();\n\t\tbindFilters( isCollectionOfEntities );\n\t\thandleWhere( isCollectionOfEntities );\n\n\t\tbindCollectionSecondPass( targetEntity, joinColumns );\n\n\t\tif ( isCollectionOfEntities ) {\n\t\t\tfinal ManyToOne element = handleCollectionOfEntities( elementType, targetEntity, hqlOrderBy );\n\t\t\tbindManyToManyInverseForeignKey( targetEntity, inverseJoinColumns, element, oneToMany );\n\t\t}\n\t\telse if ( isManyToAny ) {\n\t\t\thandleManyToAny();\n\t\t}\n\t\telse {\n\t\t\thandleElementCollection( elementType, hqlOrderBy );\n\t\t}\n\n\t\tcheckFilterConditions( collection );\n\t\tcheckConsistentColumnMutability( collection );\n\t}\n\n\tprivate void handleElementCollection(TypeDetails elementType, String hqlOrderBy) {\n\t\t// 'propertyHolder' is the PropertyHolder for the owner of the collection\n\t\t// 'holder' is the CollectionPropertyHolder.\n\t\t// 'property' is the collection XProperty\n\n\t\tfinal boolean isPrimitive = isPrimitive( elementType.getName() );\n\t\tfinal ClassDetails elementClass = isPrimitive\n\t\t\t\t? null\n\t\t\t\t: elementType.determineRawClass();\n\t\tfinal AnnotatedClassType classType = annotatedElementType( isEmbedded, isPrimitive, property, elementClass );\n\t\tif ( !isPrimitive ) {\n\t\t\tpropertyHolder.startingProperty( property );\n\t\t}\n\n\t\tfinal CollectionPropertyHolder holder = buildPropertyHolder(\n\t\t\t\tcollection,\n\t\t\t\tcollection.getRole(),\n\t\t\t\telementClass,\n\t\t\t\tproperty,\n\t\t\t\tpropertyHolder,\n\t\t\t\tbuildingContext\n\t\t);\n\n\t\tfinal Class<? extends CompositeUserType<?>> compositeUserType = resolveCompositeUserType( property, elementClass, buildingContext );\n\t\tboolean isComposite = classType == EMBEDDABLE || compositeUserType != null;\n\t\tholder.prepare( property, isComposite );\n\n\t\tif ( isComposite ) {\n\t\t\thandleCompositeCollectionElement( hqlOrderBy, elementType, elementClass, holder, compositeUserType );\n\t\t}\n\t\telse {\n\t\t\thandleCollectionElement( elementType, hqlOrderBy, elementClass, holder );\n\t\t}\n\t}\n\n\tprivate void handleCollectionElement(\n\t\t\tTypeDetails elementType,\n\t\t\tString hqlOrderBy,\n\t\t\tClassDetails elementClass,\n\t\t\tCollectionPropertyHolder holder) {\n\t\tfinal BasicValueBinder elementBinder =\n\t\t\t\tnew BasicValueBinder( BasicValueBinder.Kind.COLLECTION_ELEMENT, buildingContext );\n\t\telementBinder.setReturnedClassName( elementType.getName() );\n\t\tfinal AnnotatedColumns actualColumns = createElementColumnsIfNecessary(\n\t\t\t\tcollection,\n\t\t\t\telementColumns,\n\t\t\t\tCollection.DEFAULT_ELEMENT_COLUMN_NAME,\n\t\t\t\tnull,\n\t\t\t\tbuildingContext\n\t\t);\n\t\telementBinder.setColumns( actualColumns );\n\t\telementBinder.setType(\n\t\t\t\tproperty,\n\t\t\t\telementType,\n\t\t\t\tcollection.getOwnerEntityName(),\n\t\t\t\tholder.resolveElementAttributeConverterDescriptor( property, elementClass )\n\t\t);\n\t\telementBinder.setPersistentClassName( propertyHolder.getEntityName() );\n\t\telementBinder.setAccessType( accessType );\n\t\tcollection.setElement( elementBinder.make() );\n\t\tfinal String orderBy = adjustUserSuppliedValueCollectionOrderingFragment( hqlOrderBy );\n\t\tif ( orderBy != null ) {\n\t\t\tcollection.setOrderBy( orderBy );\n\t\t}\n\t}\n\n\tprivate void handleCompositeCollectionElement(\n\t\t\tString hqlOrderBy,\n\t\t\tTypeDetails elementType,\n\t\t\tClassDetails elementClass,\n\t\t\tCollectionPropertyHolder holder,\n\t\t\tClass<? extends CompositeUserType<?>> compositeUserType) {\n\t\t//TODO be smart with isNullable\n\t\tfinal AccessType accessType = accessType( property, collection.getOwner() );\n\t\t// We create a new entity binder here because it is needed for processing the embeddable\n\t\t// Since this is an element collection, there is no real entity binder though,\n\t\t// so we just create an \"empty shell\" for the purpose of avoiding null checks in the fillEmbeddable() method etc.\n\t\tfinal EntityBinder entityBinder = new EntityBinder( buildingContext );\n\t\t// Copy over the access type that we resolve for the element collection,\n\t\t// so that nested components use the same access type. This fixes HHH-15966\n\t\tentityBinder.setPropertyAccessType( accessType );\n\t\tfinal Component component = fillEmbeddable(\n\t\t\t\tholder,\n\t\t\t\tgetSpecialMembers( elementType ),\n\t\t\t\taccessType,\n\t\t\t\ttrue,\n\t\t\t\tentityBinder,\n\t\t\t\tfalse,\n\t\t\t\tfalse,\n\t\t\t\ttrue,\n\t\t\t\tresolveCustomInstantiator( property, elementType, buildingContext ),\n\t\t\t\tcompositeUserType,\n\t\t\t\tnull,\n\t\t\t\tbuildingContext,\n\t\t\t\tinheritanceStatePerClass\n\t\t);\n\t\tcollection.setElement( component );\n\t\tif ( isNotEmpty( hqlOrderBy ) ) {\n\t\t\tfinal String orderBy = adjustUserSuppliedValueCollectionOrderingFragment( hqlOrderBy );\n\t\t\tif ( orderBy != null ) {\n\t\t\t\tcollection.setOrderBy( orderBy );\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic AccessType accessType(MemberDetails property, PersistentClass owner) {\n\t\tfinal Access accessAnn = property.getDirectAnnotationUsage( Access.class );\n\t\tif ( accessAnn != null ) {\n\t\t\t// the attribute is locally annotated with `@Access`, use that\n\t\t\treturn accessAnn.value() == PROPERTY\n\t\t\t\t\t? AccessType.PROPERTY\n\t\t\t\t\t: AccessType.FIELD;\n\t\t}\n\n\t\tif ( owner.getIdentifierProperty() != null ) {\n\t\t\t// use the access for the owning entity's id attribute, if one\n\t\t\treturn owner.getIdentifierProperty().getPropertyAccessorName().equals( \"property\" )\n\t\t\t\t\t? AccessType.PROPERTY\n\t\t\t\t\t: AccessType.FIELD;\n\t\t}\n\n\t\tif ( owner.getIdentifierMapper() != null && owner.getIdentifierMapper().getPropertySpan() > 0 ) {\n\t\t\t// use the access for the owning entity's \"id mapper\", if one\n\t\t\treturn owner.getIdentifierMapper().getProperties().get(0).getPropertyAccessorName().equals( \"property\" )\n\t\t\t\t\t? AccessType.PROPERTY\n\t\t\t\t\t: AccessType.FIELD;\n\t\t}\n\n\t\t// otherwise...\n\t\tthrow new AssertionFailure( \"Unable to guess collection property accessor name\" );\n\t}\n\n\tprivate AnnotatedClassType annotatedElementType(\n\t\t\tboolean isEmbedded,\n\t\t\tboolean isPrimitive,\n\t\t\tMemberDetails property,\n\t\t\tClassDetails elementClass) {\n\t\tif ( isPrimitive ) {\n\t\t\treturn NONE;\n\t\t}\n\t\telse {\n\t\t\t//force in case of attribute override\n\t\t\tfinal boolean attributeOverride = property.hasDirectAnnotationUsage( AttributeOverride.class )\n\t\t\t\t\t|| property.hasDirectAnnotationUsage( AttributeOverrides.class );\n\t\t\t// todo : force in the case of Convert annotation(s) with embedded paths (beyond key/value prefixes)?\n\t\t\treturn isEmbedded || attributeOverride\n\t\t\t\t\t? EMBEDDABLE\n\t\t\t\t\t: buildingContext.getMetadataCollector().getClassType( elementClass );\n\t\t}\n\t}\n\n\tstatic AnnotatedColumns createElementColumnsIfNecessary(\n\t\t\tCollection collection,\n\t\t\tAnnotatedColumns elementColumns,\n\t\t\tString defaultName,\n\t\t\tLong defaultLength,\n\t\t\tMetadataBuildingContext context) {\n\t\tif ( elementColumns == null || elementColumns.getColumns().isEmpty() ) {\n\t\t\tfinal AnnotatedColumns columns = new AnnotatedColumns();\n\t\t\tcolumns.setBuildingContext( context );\n\t\t\tfinal AnnotatedColumn column = new AnnotatedColumn();\n\t\t\tcolumn.setLogicalColumnName( defaultName );\n\t\t\tif ( defaultLength != null ) {\n\t\t\t\tcolumn.setLength( defaultLength );\n\t\t\t}\n\t\t\tcolumn.setImplicit( false );\n\t\t\t//not following the spec but more clean\n\t\t\tcolumn.setNullable( true );\n//\t\t\tcolumn.setContext( context );\n\t\t\tcolumn.setParent( columns );\n\t\t\tcolumn.bind();\n\t\t\telementColumns = columns;\n\t\t}\n\t\t//override the table\n\t\telementColumns.setTable( collection.getCollectionTable() );\n\t\treturn elementColumns;\n\t}\n\n\tprivate ManyToOne handleCollectionOfEntities(\n\t\t\tTypeDetails elementType,\n\t\t\tPersistentClass collectionEntity,\n\t\t\tString hqlOrderBy) {\n\t\tfinal ManyToOne element = new ManyToOne( buildingContext,  collection.getCollectionTable() );\n\t\tcollection.setElement( element );\n\t\telement.setReferencedEntityName( elementType.getName() );\n\t\t//element.setFetchMode( fetchMode );\n\t\t//element.setLazy( fetchMode != FetchMode.JOIN );\n\t\t//make the second join non-lazy\n\t\telement.setFetchMode( FetchMode.JOIN );\n\t\telement.setLazy( false );\n\t\telement.setNotFoundAction( notFoundAction );\n\t\t// as per 11.1.38 of JPA 2.0 spec, default to primary key if no column is specified by @OrderBy.\n\t\tif ( hqlOrderBy != null ) {\n\t\t\tcollection.setManyToManyOrdering( buildOrderByClauseFromHql( hqlOrderBy, collectionEntity ) );\n\t\t}\n\n\t\tfinal JoinTable joinTableAnn = property.getDirectAnnotationUsage( JoinTable.class );\n\t\tif ( joinTableAnn != null ) {\n\t\t\tfinal ForeignKey inverseForeignKey = joinTableAnn.inverseForeignKey();\n\t\t\tString foreignKeyName = inverseForeignKey.name();\n\t\t\tString foreignKeyDefinition = inverseForeignKey.foreignKeyDefinition();\n\n\t\t\tfinal JoinColumn[] inverseJoinColumns = joinTableAnn.inverseJoinColumns();\n\t\t\tif ( !ArrayHelper.isEmpty( inverseJoinColumns ) ) {\n\t\t\t\tfinal JoinColumn joinColumnAnn = inverseJoinColumns[0];\n\t\t\t\tif ( foreignKeyName.isEmpty() ) {\n\t\t\t\t\tfinal ForeignKey inverseJoinColumnForeignKey = joinColumnAnn.foreignKey();\n\t\t\t\t\tforeignKeyName = inverseJoinColumnForeignKey.name();\n\t\t\t\t\tforeignKeyDefinition = inverseJoinColumnForeignKey.foreignKeyDefinition();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfinal ConstraintMode constraintMode = inverseForeignKey.value();\n\t\t\tif ( constraintMode == NO_CONSTRAINT\n\t\t\t\t\t|| constraintMode == PROVIDER_DEFAULT\n\t\t\t\t\t\t\t&& buildingContext.getBuildingOptions().isNoConstraintByDefault() ) {\n\t\t\t\telement.disableForeignKey();\n\t\t\t}\n\t\t\telse {\n\t\t\t\telement.setForeignKeyName( nullIfEmpty( foreignKeyName ) );\n\t\t\t\telement.setForeignKeyDefinition( nullIfEmpty( foreignKeyDefinition ) );\n\t\t\t}\n\t\t}\n\t\treturn element;\n\t}\n\n\tprivate void handleManyToAny() {\n\t\t//@ManyToAny\n\t\t//Make sure that collTyp is never used during the @ManyToAny branch: it will be set to void.class\n\t\tfinal PropertyData inferredData = new PropertyInferredData(\n\t\t\t\tnull,\n\t\t\t\tdeclaringClass,\n\t\t\t\tproperty,\n\t\t\t\t\"unsupported\",\n\t\t\t\tbuildingContext\n\t\t);\n\n\t\tfinal MemberDetails prop = inferredData.getAttributeMember();\n\t\tfinal jakarta.persistence.Column discriminatorColumnAnn = prop.getDirectAnnotationUsage( jakarta.persistence.Column.class );\n\t\tfinal Formula discriminatorFormulaAnn = getOverridableAnnotation( prop, Formula.class, buildingContext );\n\n\t\t//override the table\n\t\tinverseJoinColumns.setTable( collection.getCollectionTable() );\n\n\t\tfinal ManyToAny anyAnn = property.getDirectAnnotationUsage( ManyToAny.class );\n\t\tfinal Any any = buildAnyValue(\n\t\t\t\tdiscriminatorColumnAnn,\n\t\t\t\tdiscriminatorFormulaAnn,\n\t\t\t\tinverseJoinColumns,\n\t\t\t\tinferredData,\n\t\t\t\tonDeleteAction,\n\t\t\t\tanyAnn.fetch() == LAZY,\n\t\t\t\tNullability.NO_CONSTRAINT,\n\t\t\t\tpropertyHolder,\n\t\t\t\tnew EntityBinder( buildingContext ),\n\t\t\t\ttrue,\n\t\t\t\tbuildingContext\n\t\t);\n\t\tcollection.setElement( any );\n\t}\n\n\tprivate PropertyData getSpecialMembers(TypeDetails elementClass) {\n\t\tif ( isMap() ) {\n\t\t\t//\"value\" is the JPA 2 prefix for map values (used to be \"element\")\n\t\t\tif ( isHibernateExtensionMapping() ) {\n\t\t\t\treturn new PropertyPreloadedData( AccessType.PROPERTY, \"element\", elementClass );\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn new PropertyPreloadedData( AccessType.PROPERTY, \"value\", elementClass );\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif ( isHibernateExtensionMapping() ) {\n\t\t\t\treturn new PropertyPreloadedData( AccessType.PROPERTY, \"element\", elementClass );\n\t\t\t}\n\t\t\telse {\n\t\t\t\t//\"{element}\" is not a valid property name => placeholder\n\t\t\t\treturn new PropertyPreloadedData( AccessType.PROPERTY, \"{element}\", elementClass );\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate void handleOwnedManyToMany(PersistentClass collectionEntity, boolean isCollectionOfEntities) {\n\t\t//TODO: only for implicit columns?\n\t\t//FIXME NamingStrategy\n\t\tfinal InFlightMetadataCollector collector = buildingContext.getMetadataCollector();\n\t\tfinal PersistentClass owner = collection.getOwner();\n\t\tjoinColumns.setMappedBy(\n\t\t\t\towner.getEntityName(),\n\t\t\t\tcollector.getLogicalTableName( owner.getTable() ),\n\t\t\t\tcollector.getFromMappedBy( owner.getEntityName(), joinColumns.getPropertyName() )\n\t\t);\n\t\tif ( isEmpty( tableBinder.getName() ) ) {\n\t\t\t//default value\n\t\t\ttableBinder.setDefaultName(\n\t\t\t\t\towner.getClassName(),\n\t\t\t\t\towner.getEntityName(),\n\t\t\t\t\towner.getJpaEntityName(),\n\t\t\t\t\tcollector.getLogicalTableName( owner.getTable() ),\n\t\t\t\t\tcollectionEntity != null ? collectionEntity.getClassName() : null,\n\t\t\t\t\tcollectionEntity != null ? collectionEntity.getEntityName() : null,\n\t\t\t\t\tcollectionEntity != null ? collectionEntity.getJpaEntityName() : null,\n\t\t\t\t\tcollectionEntity != null ? collector.getLogicalTableName( collectionEntity.getTable() ) : null,\n\t\t\t\t\tjoinColumns.getPropertyName()\n\t\t\t);\n\t\t}\n\t\ttableBinder.setJPA2ElementCollection(\n\t\t\t\t!isCollectionOfEntities && property.hasDirectAnnotationUsage( ElementCollection.class )\n\t\t);\n\t\tfinal Table collectionTable = tableBinder.bind();\n\t\tcollection.setCollectionTable( collectionTable );\n\t\thandleCheckConstraints( collectionTable );\n\t\tprocessSoftDeletes();\n\t}\n\n\tprivate void handleCheckConstraints(Table collectionTable) {\n\t\tproperty.forEachAnnotationUsage( Check.class, sourceModelContext(), (usage) -> {\n\t\t\taddCheckToCollection( collectionTable, usage );\n\t\t} );\n\t\tproperty.forEachAnnotationUsage( jakarta.persistence.JoinTable.class, sourceModelContext(), (usage) -> {\n\t\t\tTableBinder.addTableCheck( collectionTable, usage.check() );\n\t\t\tTableBinder.addTableComment( collectionTable, usage.comment() );\n\t\t\tTableBinder.addTableOptions( collectionTable, usage.options() );\n\t\t} );\n\t}\n\n\tprivate static void addCheckToCollection(Table collectionTable, Check check) {\n\t\tfinal String name = check.name();\n\t\tfinal String constraint = check.constraints();\n\t\tcollectionTable.addCheck( name.isEmpty()\n\t\t\t\t? new CheckConstraint( constraint )\n\t\t\t\t: new CheckConstraint( name, constraint ) );\n\t}\n\n\tprivate void processSoftDeletes() {\n\t\tassert collection.getCollectionTable() != null;\n\n\t\tfinal SoftDelete softDelete = extractSoftDelete( property, propertyHolder, buildingContext );\n\t\tif ( softDelete == null ) {\n\t\t\treturn;\n\t\t}\n\n\t\tSoftDeleteHelper.bindSoftDeleteIndicator(\n\t\t\t\tsoftDelete,\n\t\t\t\tcollection,\n\t\t\t\tcollection.getCollectionTable(),\n\t\t\t\tbuildingContext\n\t\t);\n\t}\n\n\tprivate static SoftDelete extractSoftDelete(\n\t\t\tMemberDetails property,\n\t\t\tPropertyHolder propertyHolder,\n\t\t\tMetadataBuildingContext context) {\n\t\tfinal SoftDelete fromProperty = property.getDirectAnnotationUsage( SoftDelete.class );\n\t\tif ( fromProperty != null ) {\n\t\t\treturn fromProperty;\n\t\t}\n\n\t\treturn extractFromPackage(\n\t\t\t\tSoftDelete.class,\n\t\t\t\tproperty.getDeclaringType(),\n\t\t\t\tcontext\n\t\t);\n\t}\n\n\tprivate void handleUnownedManyToMany(\n\t\t\tTypeDetails elementType,\n\t\t\tPersistentClass collectionEntity,\n\t\t\tboolean isCollectionOfEntities) {\n\t\tif ( !isCollectionOfEntities) {\n\t\t\tthrow new AnnotationException( \"Association '\" + safeCollectionRole() + \"'\"\n\t\t\t\t\t+ targetEntityMessage( elementType ) );\n\t\t}\n\n\t\tjoinColumns.setManyToManyOwnerSideEntityName( collectionEntity.getEntityName() );\n\n\t\tfinal Property otherSideProperty;\n\t\ttry {\n\t\t\totherSideProperty = collectionEntity.getRecursiveProperty( mappedBy );\n\t\t}\n\t\tcatch ( MappingException e ) {\n\t\t\tthrow new AnnotationException( \"Association '\" + safeCollectionRole()\n\t\t\t\t\t+ \"is 'mappedBy' a property named '\" + mappedBy\n\t\t\t\t\t+ \"' which does not exist in the target entity '\" + elementType.getName() + \"'\" );\n\t\t}\n\t\tfinal Value otherSidePropertyValue = otherSideProperty.getValue();\n\t\tfinal Table table = otherSidePropertyValue instanceof Collection\n\t\t\t\t// this is a collection on the other side\n\t\t\t\t? ( (Collection) otherSidePropertyValue ).getCollectionTable()\n\t\t\t\t// this is a ToOne with a @JoinTable or a regular property\n\t\t\t\t: otherSidePropertyValue.getTable();\n\t\tcollection.setCollectionTable( table );\n\t\tprocessSoftDeletes();\n\n\t\tif ( property.hasDirectAnnotationUsage( Checks.class )\n\t\t\t\t|| property.hasDirectAnnotationUsage( Check.class ) ) {\n\t\t\tthrow new AnnotationException( \"Association '\" + safeCollectionRole()\n\t\t\t\t\t+ \" is an unowned collection and may not be annotated '@Check'\" );\n\t\t}\n\t}\n\n\tprivate void detectManyToManyProblems(\n\t\t\tTypeDetails elementType,\n\t\t\tboolean isCollectionOfEntities,\n\t\t\tboolean isManyToAny) {\n\n\t\tif ( !isCollectionOfEntities) {\n\t\t\tif ( property.hasDirectAnnotationUsage( ManyToMany.class )\n\t\t\t\t\t|| property.hasDirectAnnotationUsage( OneToMany.class ) ) {\n\t\t\t\tthrow new AnnotationException( \"Association '\" + safeCollectionRole() + \"'\"\n\t\t\t\t\t\t+ targetEntityMessage( elementType ) );\n\t\t\t}\n\t\t\telse if (isManyToAny) {\n\t\t\t\tif ( propertyHolder.getJoinTable( property ) == null ) {\n\t\t\t\t\tthrow new AnnotationException( \"Association '\" + safeCollectionRole()\n\t\t\t\t\t\t\t+ \"' is a '@ManyToAny' and must specify a '@JoinTable'\" );\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfinal JoinTable joinTableAnn = propertyHolder.getJoinTable( property );\n\t\t\t\tif ( joinTableAnn != null && !ArrayHelper.isEmpty( joinTableAnn.inverseJoinColumns() ) ) {\n\t\t\t\t\tthrow new AnnotationException( \"Association '\" + safeCollectionRole()\n\t\t\t\t\t\t\t+ \" has a '@JoinTable' with 'inverseJoinColumns' and\"\n\t\t\t\t\t\t\t+ targetEntityMessage( elementType ) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic String targetEntityMessage(TypeDetails elementType) {\n\t\tfinal String problem = elementType.determineRawClass().hasDirectAnnotationUsage( Entity.class )\n\t\t\t\t? \" which does not belong to the same persistence unit\"\n\t\t\t\t: \" which is not an '@Entity' type\";\n\t\treturn \" targets the type '\" + elementType.getName() + \"'\" + problem;\n\t}\n\n\tprivate Class<? extends EmbeddableInstantiator> resolveCustomInstantiator(\n\t\t\tMemberDetails property,\n\t\t\tTypeDetails propertyClass,\n\t\t\tMetadataBuildingContext context) {\n\t\tfinal org.hibernate.annotations.EmbeddableInstantiator propertyAnnotation\n\t\t\t\t= property.getDirectAnnotationUsage( org.hibernate.annotations.EmbeddableInstantiator.class );\n\t\tif ( propertyAnnotation != null ) {\n\t\t\treturn propertyAnnotation.value();\n\t\t}\n\n\t\tfinal ClassDetails rawPropertyClassDetails = propertyClass.determineRawClass();\n\t\tfinal org.hibernate.annotations.EmbeddableInstantiator classAnnotation\n\t\t\t\t= rawPropertyClassDetails.getDirectAnnotationUsage( org.hibernate.annotations.EmbeddableInstantiator.class );\n\t\tif ( classAnnotation != null ) {\n\t\t\treturn classAnnotation.value();\n\t\t}\n\n\t\tfinal Class<?> embeddableClass = rawPropertyClassDetails.toJavaClass();\n\t\tif ( embeddableClass != null ) {\n\t\t\treturn context.getMetadataCollector().findRegisteredEmbeddableInstantiator( embeddableClass );\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tprivate static Class<? extends CompositeUserType<?>> resolveCompositeUserType(\n\t\t\tMemberDetails property,\n\t\t\tClassDetails returnedClass,\n\t\t\tMetadataBuildingContext context) {\n\t\tfinal CompositeType compositeType = property.getDirectAnnotationUsage( CompositeType.class );\n\t\tif ( compositeType != null ) {\n\t\t\treturn compositeType.value();\n\t\t}\n\n\t\tif ( returnedClass != null ) {\n\t\t\tfinal Class<?> embeddableClass = returnedClass.toJavaClass();\n\t\t\treturn embeddableClass == null\n\t\t\t\t\t? null\n\t\t\t\t\t: context.getMetadataCollector().findRegisteredCompositeUserType( embeddableClass );\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tprivate String extractHqlOrderBy(OrderBy jpaOrderBy) {\n\t\tif ( jpaOrderBy != null ) {\n\t\t\t// Null not possible. In case of empty expression, apply default ordering.\n\t\t\treturn jpaOrderBy.value();\n\t\t}\n\t\telse {\n\t\t\t// @OrderBy not found.\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tprivate static void checkFilterConditions(Collection collection) {\n\t\t//for now it can't happen, but sometime soon...\n\t\tif ( ( !collection.getFilters().isEmpty() || isNotEmpty( collection.getWhere() ) )\n\t\t\t\t&& collection.getFetchMode() == FetchMode.JOIN\n\t\t\t\t&& !( collection.getElement() instanceof SimpleValue ) //SimpleValue (CollectionOfElements) are always SELECT but it does not matter\n\t\t\t\t&& collection.getElement().getFetchMode() != FetchMode.JOIN ) {\n\t\t\tthrow new MappingException(\n\t\t\t\t\t\"@ManyToMany or @ElementCollection defining filter or where without join fetching \"\n\t\t\t\t\t\t\t+ \"not valid within collection using join fetching[\" + collection.getRole() + \"]\"\n\t\t\t);\n\t\t}\n\t}\n\n\tprivate static void checkConsistentColumnMutability(Collection collection) {\n\t\tcheckConsistentColumnMutability( collection.getRole(), collection.getKey() );\n\t\tcheckConsistentColumnMutability( collection.getRole(), collection.getElement() );\n\t}\n\n\tprivate static void checkConsistentColumnMutability(String collectionRole, Value value) {\n\t\tBoolean readOnly = null;\n\t\tfor ( int i = 0; i < value.getColumnSpan(); i++ ) {\n\t\t\tfinal boolean insertable = value.isColumnInsertable( i );\n\t\t\tif ( insertable != value.isColumnUpdateable( i ) ) {\n\t\t\t\tthrow new AnnotationException(\n\t\t\t\t\t\t\"Join column '\" + value.getColumns().get( i ).getName() + \"' on collection property '\"\n\t\t\t\t\t\t\t\t+ collectionRole + \"' must be defined with the same insertable and updatable attributes\"\n\t\t\t\t);\n\t\t\t}\n\t\t\tif ( readOnly == null ) {\n\t\t\t\treadOnly = insertable;\n\t\t\t}\n\t\t\telse if ( readOnly != insertable && !value.getColumns().get( i ).isFormula() ) {\n\t\t\t\t// We also assert that all join columns have the same mutability (except formulas)\n\t\t\t\tthrow new AnnotationException(\n\t\t\t\t\t\t\"All join columns on collection '\" + collectionRole + \"' should have\" +\n\t\t\t\t\t\t\t\t\" the same insertable and updatable setting\"\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate void bindCollectionSecondPass(PersistentClass targetEntity, AnnotatedJoinColumns joinColumns) {\n\n\t\tif ( !isUnownedCollection() ) {\n\t\t\tcreateSyntheticPropertyReference(\n\t\t\t\t\tjoinColumns,\n\t\t\t\t\tcollection.getOwner(),\n\t\t\t\t\tcollection.getOwner(),\n\t\t\t\t\tcollection,\n\t\t\t\t\tpropertyName,\n\t\t\t\t\tfalse,\n\t\t\t\t\tbuildingContext\n\t\t\t);\n\t\t}\n\n\t\tif ( property.hasDirectAnnotationUsage( ElementCollection.class ) ) {\n\t\t\tjoinColumns.setElementCollection( true );\n\t\t}\n\n\t\tfinal DependantValue key = buildCollectionKey( joinColumns, onDeleteAction );\n\t\tTableBinder.bindForeignKey(\n\t\t\t\tcollection.getOwner(),\n\t\t\t\ttargetEntity,\n\t\t\t\tjoinColumns,\n\t\t\t\tkey,\n\t\t\t\tfalse,\n\t\t\t\tbuildingContext\n\t\t);\n\t\tkey.sortProperties();\n\t}\n\n\tpublic void setOnDeleteActionAction(OnDeleteAction onDeleteAction) {\n\t\tthis.onDeleteAction = onDeleteAction;\n\t}\n\n\tString safeCollectionRole() {\n\t\treturn propertyHolder != null ? propertyHolder.getEntityName() + \".\" + propertyName : \"\";\n\t}\n\n\t/**\n\t * Bind the inverse foreign key of a {@link ManyToMany}, that is, the columns\n\t * specified by {@code @JoinTable(inverseJoinColumns=...)}, which are the\n\t * columns that reference the target entity of the many-to-many association.\n\t * If we are in a {@code mappedBy} case, read the columns from the associated\n\t * collection element in the target entity.\n\t */\n\tpublic void bindManyToManyInverseForeignKey(\n\t\t\tPersistentClass targetEntity,\n\t\t\tAnnotatedJoinColumns joinColumns,\n\t\t\tSimpleValue value,\n\t\t\tboolean unique) {\n\t\t// This method is also called for entity valued map keys, so we must consider\n\t\t// the mappedBy of the join columns instead of the collection's one\n\t\tif ( joinColumns.hasMappedBy() ) {\n\t\t\tbindUnownedManyToManyInverseForeignKey( targetEntity, joinColumns, value );\n\t\t}\n\t\telse {\n\t\t\tbindOwnedManyToManyForeignKeyMappedBy( targetEntity, joinColumns, value, unique );\n\t\t}\n\t}\n\n\tprivate void bindOwnedManyToManyForeignKeyMappedBy(\n\t\t\tPersistentClass targetEntity,\n\t\t\tAnnotatedJoinColumns joinColumns,\n\t\t\tSimpleValue value,\n\t\t\tboolean unique) { // true when it's actually a logical @OneToMany\n\t\tcreateSyntheticPropertyReference(\n\t\t\t\tjoinColumns,\n\t\t\t\ttargetEntity,\n\t\t\t\tcollection.getOwner(),\n\t\t\t\tvalue,\n\t\t\t\tpropertyName,\n\t\t\t\ttrue,\n\t\t\t\tbuildingContext\n\t\t);\n\t\tif ( notFoundAction == NotFoundAction.IGNORE ) {\n\t\t\tvalue.disableForeignKey();\n\t\t}\n\t\tTableBinder.bindForeignKey(\n\t\t\t\ttargetEntity,\n\t\t\t\tcollection.getOwner(),\n\t\t\t\tjoinColumns,\n\t\t\t\tvalue,\n\t\t\t\tunique,\n\t\t\t\tbuildingContext\n\t\t);\n\t}\n\n\tprivate void bindUnownedManyToManyInverseForeignKey(\n\t\t\tPersistentClass targetEntity,\n\t\t\tAnnotatedJoinColumns joinColumns,\n\t\t\tSimpleValue value) {\n\t\tfinal Property property = targetEntity.getRecursiveProperty( mappedBy );\n\t\tfinal List<Selectable> mappedByColumns = mappedByColumns( targetEntity, property );\n\t\tfinal AnnotatedJoinColumn firstColumn = joinColumns.getJoinColumns().get(0);\n\t\tfor ( Selectable selectable: mappedByColumns ) {\n\t\t\tfirstColumn.linkValueUsingAColumnCopy( (Column) selectable, value);\n\t\t}\n\t\tfinal String referencedPropertyName = buildingContext.getMetadataCollector()\n\t\t\t\t.getPropertyReferencedAssociation( targetEntity.getEntityName(), mappedBy );\n\t\tif ( referencedPropertyName != null ) {\n\t\t\t//TODO always a many to one?\n\t\t\t( (ManyToOne) value).setReferencedPropertyName( referencedPropertyName );\n\t\t\tbuildingContext.getMetadataCollector()\n\t\t\t\t\t.addUniquePropertyReference( targetEntity.getEntityName(), referencedPropertyName );\n\t\t}\n\t\t( (ManyToOne) value).setReferenceToPrimaryKey( referencedPropertyName == null );\n\t\tvalue.createForeignKey();\n\t}\n\n\tprivate static List<Selectable> mappedByColumns(PersistentClass referencedEntity, Property property) {\n\t\tif ( property.getValue() instanceof Collection ) {\n\t\t\treturn ( (Collection) property.getValue() ).getKey().getSelectables();\n\t\t}\n\t\telse {\n\t\t\t//find the appropriate reference key, can be in a join\n\t\t\tKeyValue key = null;\n\t\t\tfor ( Join join : referencedEntity.getJoins() ) {\n\t\t\t\tif ( join.containsProperty(property) ) {\n\t\t\t\t\tkey = join.getKey();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( key == null ) {\n\t\t\t\tkey = property.getPersistentClass().getIdentifier();\n\t\t\t}\n\t\t\treturn key.getSelectables();\n\t\t}\n\t}\n\n\tpublic void setFkJoinColumns(AnnotatedJoinColumns annotatedJoinColumns) {\n\t\tthis.foreignJoinColumns = annotatedJoinColumns;\n\t}\n\n\tpublic void setExplicitAssociationTable(boolean isExplicitAssociationTable) {\n\t\tthis.isExplicitAssociationTable = isExplicitAssociationTable;\n\t}\n\n\tpublic void setElementColumns(AnnotatedColumns elementColumns) {\n\t\tthis.elementColumns = elementColumns;\n\t}\n\n\tpublic void setEmbedded(boolean annotationPresent) {\n\t\tthis.isEmbedded = annotationPresent;\n\t}\n\n\tpublic void setProperty(MemberDetails property) {\n\t\tthis.property = property;\n\t}\n\n\tpublic NotFoundAction getNotFoundAction() {\n\t\treturn notFoundAction;\n\t}\n\n\tpublic void setNotFoundAction(NotFoundAction notFoundAction) {\n\t\tthis.notFoundAction = notFoundAction;\n\t}\n\n\tpublic void setMapKeyColumns(AnnotatedColumns mapKeyColumns) {\n\t\tthis.mapKeyColumns = mapKeyColumns;\n\t}\n\n\tpublic void setMapKeyManyToManyColumns(AnnotatedJoinColumns mapJoinColumns) {\n\t\tthis.mapKeyManyToManyColumns = mapJoinColumns;\n\t}\n\n\tpublic void setLocalGenerators(Map<String, IdentifierGeneratorDefinition> localGenerators) {\n\t\tthis.localGenerators = localGenerators;\n\t}\n\n\tprivate void logOneToManySecondPass() {\n\t\tif ( LOG.isDebugEnabled() ) {\n\t\t\tLOG.debugf( \"Binding a OneToMany: %s through a foreign key\", safeCollectionRole() );\n\t\t}\n\t}\n\n\tprivate void logManyToManySecondPass(\n\t\t\tboolean isOneToMany,\n\t\t\tboolean isCollectionOfEntities,\n\t\t\tboolean isManyToAny) {\n\t\tif ( LOG.isDebugEnabled() ) {\n\t\t\tif ( isCollectionOfEntities && isOneToMany ) {\n\t\t\t\tLOG.debugf( \"Binding a OneToMany: %s through an association table\", safeCollectionRole() );\n\t\t\t}\n\t\t\telse if ( isCollectionOfEntities ) {\n\t\t\t\tLOG.debugf( \"Binding a ManyToMany: %s\", safeCollectionRole() );\n\t\t\t}\n\t\t\telse if ( isManyToAny ) {\n\t\t\t\tLOG.debugf( \"Binding a ManyToAny: %s\", safeCollectionRole() );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tLOG.debugf( \"Binding a collection of element: %s\", safeCollectionRole() );\n\t\t\t}\n\t\t}\n\t}\n\n}\n",
        "filePathAfter": "hibernate-core/src/main/java/org/hibernate/boot/model/internal/CollectionBinder.java",
        "sourceCodeAfterForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n * See the lgpl.txt file in the root directory or http://www.gnu.org/licenses/lgpl-2.1.html.\n */\npackage org.hibernate.boot.model.internal;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.invoke.MethodHandles;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Properties;\nimport java.util.function.Supplier;\n\nimport org.hibernate.AnnotationException;\nimport org.hibernate.AssertionFailure;\nimport org.hibernate.FetchMode;\nimport org.hibernate.MappingException;\nimport org.hibernate.annotations.Bag;\nimport org.hibernate.annotations.Cache;\nimport org.hibernate.annotations.CacheLayout;\nimport org.hibernate.annotations.Cascade;\nimport org.hibernate.annotations.Check;\nimport org.hibernate.annotations.Checks;\nimport org.hibernate.annotations.CollectionId;\nimport org.hibernate.annotations.CollectionIdJavaType;\nimport org.hibernate.annotations.CollectionIdJdbcType;\nimport org.hibernate.annotations.CollectionIdJdbcTypeCode;\nimport org.hibernate.annotations.CollectionType;\nimport org.hibernate.annotations.Columns;\nimport org.hibernate.annotations.CompositeType;\nimport org.hibernate.annotations.Fetch;\nimport org.hibernate.annotations.FetchProfileOverride;\nimport org.hibernate.annotations.Filter;\nimport org.hibernate.annotations.FilterJoinTable;\nimport org.hibernate.annotations.Formula;\nimport org.hibernate.annotations.HQLSelect;\nimport org.hibernate.annotations.Immutable;\nimport org.hibernate.annotations.LazyGroup;\nimport org.hibernate.annotations.ListIndexBase;\nimport org.hibernate.annotations.ListIndexJavaType;\nimport org.hibernate.annotations.ListIndexJdbcType;\nimport org.hibernate.annotations.ListIndexJdbcTypeCode;\nimport org.hibernate.annotations.ManyToAny;\nimport org.hibernate.annotations.MapKeyJavaType;\nimport org.hibernate.annotations.MapKeyJdbcType;\nimport org.hibernate.annotations.MapKeyJdbcTypeCode;\nimport org.hibernate.annotations.MapKeyMutability;\nimport org.hibernate.annotations.MapKeyType;\nimport org.hibernate.annotations.NotFound;\nimport org.hibernate.annotations.NotFoundAction;\nimport org.hibernate.annotations.OnDelete;\nimport org.hibernate.annotations.OnDeleteAction;\nimport org.hibernate.annotations.OptimisticLock;\nimport org.hibernate.annotations.Parameter;\nimport org.hibernate.annotations.QueryCacheLayout;\nimport org.hibernate.annotations.SQLDelete;\nimport org.hibernate.annotations.SQLDeleteAll;\nimport org.hibernate.annotations.SQLInsert;\nimport org.hibernate.annotations.SQLJoinTableRestriction;\nimport org.hibernate.annotations.SQLOrder;\nimport org.hibernate.annotations.SQLRestriction;\nimport org.hibernate.annotations.SQLSelect;\nimport org.hibernate.annotations.SQLUpdate;\nimport org.hibernate.annotations.SoftDelete;\nimport org.hibernate.annotations.SortComparator;\nimport org.hibernate.annotations.SortNatural;\nimport org.hibernate.annotations.SqlFragmentAlias;\nimport org.hibernate.annotations.Synchronize;\nimport org.hibernate.boot.BootLogging;\nimport org.hibernate.boot.model.IdentifierGeneratorDefinition;\nimport org.hibernate.boot.model.TypeDefinition;\nimport org.hibernate.boot.models.JpaAnnotations;\nimport org.hibernate.boot.models.annotations.internal.JoinColumnJpaAnnotation;\nimport org.hibernate.boot.models.annotations.internal.MapKeyColumnJpaAnnotation;\nimport org.hibernate.boot.spi.AccessType;\nimport org.hibernate.boot.spi.InFlightMetadataCollector;\nimport org.hibernate.boot.spi.InFlightMetadataCollector.CollectionTypeRegistrationDescriptor;\nimport org.hibernate.boot.spi.MetadataBuildingContext;\nimport org.hibernate.boot.spi.PropertyData;\nimport org.hibernate.boot.spi.SecondPass;\nimport org.hibernate.engine.jdbc.env.spi.JdbcEnvironment;\nimport org.hibernate.engine.spi.FilterDefinition;\nimport org.hibernate.internal.CoreMessageLogger;\nimport org.hibernate.internal.util.StringHelper;\nimport org.hibernate.internal.util.collections.ArrayHelper;\nimport org.hibernate.internal.util.collections.CollectionHelper;\nimport org.hibernate.jdbc.Expectation;\nimport org.hibernate.mapping.Any;\nimport org.hibernate.mapping.Backref;\nimport org.hibernate.mapping.CheckConstraint;\nimport org.hibernate.mapping.Collection;\nimport org.hibernate.mapping.Column;\nimport org.hibernate.mapping.Component;\nimport org.hibernate.mapping.DependantValue;\nimport org.hibernate.mapping.Join;\nimport org.hibernate.mapping.KeyValue;\nimport org.hibernate.mapping.ManyToOne;\nimport org.hibernate.mapping.PersistentClass;\nimport org.hibernate.mapping.Property;\nimport org.hibernate.mapping.Selectable;\nimport org.hibernate.mapping.SimpleValue;\nimport org.hibernate.mapping.Table;\nimport org.hibernate.mapping.Value;\nimport org.hibernate.metamodel.CollectionClassification;\nimport org.hibernate.metamodel.UnsupportedMappingException;\nimport org.hibernate.metamodel.spi.EmbeddableInstantiator;\nimport org.hibernate.models.internal.ClassTypeDetailsImpl;\nimport org.hibernate.models.spi.ClassDetails;\nimport org.hibernate.models.spi.ClassDetailsRegistry;\nimport org.hibernate.models.spi.MemberDetails;\nimport org.hibernate.models.spi.SourceModelBuildingContext;\nimport org.hibernate.models.spi.TypeDetails;\nimport org.hibernate.resource.beans.spi.ManagedBean;\nimport org.hibernate.resource.beans.spi.ManagedBeanRegistry;\nimport org.hibernate.usertype.CompositeUserType;\nimport org.hibernate.usertype.ParameterizedType;\nimport org.hibernate.usertype.UserCollectionType;\n\nimport org.jboss.logging.Logger;\n\nimport jakarta.persistence.Access;\nimport jakarta.persistence.AttributeOverride;\nimport jakarta.persistence.AttributeOverrides;\nimport jakarta.persistence.CollectionTable;\nimport jakarta.persistence.ConstraintMode;\nimport jakarta.persistence.ElementCollection;\nimport jakarta.persistence.Embedded;\nimport jakarta.persistence.Entity;\nimport jakarta.persistence.FetchType;\nimport jakarta.persistence.ForeignKey;\nimport jakarta.persistence.Index;\nimport jakarta.persistence.JoinColumn;\nimport jakarta.persistence.JoinColumns;\nimport jakarta.persistence.JoinTable;\nimport jakarta.persistence.ManyToMany;\nimport jakarta.persistence.MapKey;\nimport jakarta.persistence.MapKeyColumn;\nimport jakarta.persistence.MapKeyJoinColumn;\nimport jakarta.persistence.OneToMany;\nimport jakarta.persistence.OrderBy;\nimport jakarta.persistence.OrderColumn;\nimport jakarta.persistence.UniqueConstraint;\n\nimport static jakarta.persistence.AccessType.PROPERTY;\nimport static jakarta.persistence.ConstraintMode.NO_CONSTRAINT;\nimport static jakarta.persistence.ConstraintMode.PROVIDER_DEFAULT;\nimport static jakarta.persistence.FetchType.LAZY;\nimport static org.hibernate.boot.model.internal.AnnotatedClassType.EMBEDDABLE;\nimport static org.hibernate.boot.model.internal.AnnotatedClassType.NONE;\nimport static org.hibernate.boot.model.internal.AnnotatedColumn.buildColumnFromAnnotation;\nimport static org.hibernate.boot.model.internal.AnnotatedColumn.buildColumnFromNoAnnotation;\nimport static org.hibernate.boot.model.internal.AnnotatedColumn.buildColumnsFromAnnotations;\nimport static org.hibernate.boot.model.internal.AnnotatedColumn.buildFormulaFromAnnotation;\nimport static org.hibernate.boot.model.internal.AnnotatedJoinColumns.buildJoinColumnsWithDefaultColumnSuffix;\nimport static org.hibernate.boot.model.internal.AnnotatedJoinColumns.buildJoinTableJoinColumns;\nimport static org.hibernate.boot.model.internal.BinderHelper.buildAnyValue;\nimport static org.hibernate.boot.model.internal.BinderHelper.checkMappedByType;\nimport static org.hibernate.boot.model.internal.BinderHelper.createSyntheticPropertyReference;\nimport static org.hibernate.boot.model.internal.BinderHelper.extractFromPackage;\nimport static org.hibernate.boot.model.internal.BinderHelper.getCascadeStrategy;\nimport static org.hibernate.boot.model.internal.BinderHelper.getFetchMode;\nimport static org.hibernate.boot.model.internal.BinderHelper.getPath;\nimport static org.hibernate.boot.model.internal.BinderHelper.isDefault;\nimport static org.hibernate.boot.model.internal.BinderHelper.isPrimitive;\nimport static org.hibernate.boot.model.internal.DialectOverridesAnnotationHelper.getOverridableAnnotation;\nimport static org.hibernate.boot.model.internal.EmbeddableBinder.fillEmbeddable;\nimport static org.hibernate.boot.model.internal.GeneratorBinder.buildGenerators;\nimport static org.hibernate.boot.model.internal.PropertyHolderBuilder.buildPropertyHolder;\nimport static org.hibernate.engine.spi.ExecuteUpdateResultCheckStyle.fromResultCheckStyle;\nimport static org.hibernate.internal.util.ReflectHelper.getDefaultSupplier;\nimport static org.hibernate.internal.util.StringHelper.getNonEmptyOrConjunctionIfBothNonEmpty;\nimport static org.hibernate.internal.util.StringHelper.isEmpty;\nimport static org.hibernate.internal.util.StringHelper.isNotEmpty;\nimport static org.hibernate.internal.util.StringHelper.nullIfEmpty;\nimport static org.hibernate.internal.util.StringHelper.qualify;\nimport static org.hibernate.mapping.MappingHelper.createLocalUserCollectionTypeBean;\n\n/**\n * Base class for stateful binders responsible for producing mapping model objects of type {@link Collection}.\n *\n * @author inger\n * @author Emmanuel Bernard\n */\npublic abstract class CollectionBinder {\n\tprivate static final CoreMessageLogger LOG = Logger.getMessageLogger( MethodHandles.lookup(), CoreMessageLogger.class, CollectionBinder.class.getName() );\n\n\tprivate static final List<Class<?>> INFERRED_CLASS_PRIORITY = List.of(\n\t\t\tList.class,\n\t\t\tjava.util.SortedSet.class,\n\t\t\tjava.util.Set.class,\n\t\t\tjava.util.SortedMap.class,\n\t\t\tMap.class,\n\t\t\tjava.util.Collection.class\n\t);\n\n\tfinal MetadataBuildingContext buildingContext;\n\tprivate final Supplier<ManagedBean<? extends UserCollectionType>> customTypeBeanResolver;\n\tprivate final boolean isSortedCollection;\n\n\tprotected Collection collection;\n\tprotected String propertyName;\n\tprotected PropertyHolder propertyHolder;\n\tprivate String mappedBy;\n\tprotected ClassDetails declaringClass;\n\tprotected MemberDetails property;\n\tprivate TypeDetails collectionElementType;\n\tprivate TypeDetails targetEntity;\n\tprivate String cascadeStrategy;\n\tprivate String cacheConcurrencyStrategy;\n\tprivate String cacheRegionName;\n\tprivate CacheLayout queryCacheLayout;\n\tprivate boolean oneToMany;\n\tprotected IndexColumn indexColumn;\n\tprotected OnDeleteAction onDeleteAction;\n\tprotected boolean hasMapKeyProperty;\n\tprotected String mapKeyPropertyName;\n\tprivate boolean insertable = true;\n\tprivate boolean updatable = true;\n\tprotected AnnotatedJoinColumns inverseJoinColumns;\n\tprotected AnnotatedJoinColumns foreignJoinColumns;\n\tprivate AnnotatedJoinColumns joinColumns;\n\tprivate boolean isExplicitAssociationTable;\n\tprivate AnnotatedColumns elementColumns;\n\tprotected boolean isEmbedded;\n\tprotected NotFoundAction notFoundAction;\n\tprivate TableBinder tableBinder;\n\tprotected AnnotatedColumns mapKeyColumns;\n\tprotected AnnotatedJoinColumns mapKeyManyToManyColumns;\n\tprotected Map<String, IdentifierGeneratorDefinition> localGenerators;\n\tprotected Map<ClassDetails, InheritanceState> inheritanceStatePerClass;\n\tprivate boolean declaringClassSet;\n\tprivate AccessType accessType;\n\tprivate boolean hibernateExtensionMapping;\n\n\tprivate jakarta.persistence.OrderBy jpaOrderBy;\n\tprivate org.hibernate.annotations.OrderBy sqlOrderBy;\n\tprivate SQLOrder sqlOrder;\n\tprivate SortNatural naturalSort;\n\tprivate SortComparator comparatorSort;\n\n\tprivate String explicitType;\n\tprivate final Map<String,String> explicitTypeParameters = new HashMap<>();\n\n\tprotected CollectionBinder(\n\t\t\tSupplier<ManagedBean<? extends UserCollectionType>> customTypeBeanResolver,\n\t\t\tboolean isSortedCollection,\n\t\t\tMetadataBuildingContext buildingContext) {\n\t\tthis.customTypeBeanResolver = customTypeBeanResolver;\n\t\tthis.isSortedCollection = isSortedCollection;\n\t\tthis.buildingContext = buildingContext;\n\t}\n\n\t/**\n\t * The first pass at binding a collection.\n\t */\n\tpublic static void bindCollection(\n\t\t\tPropertyHolder propertyHolder,\n\t\t\tNullability nullability,\n\t\t\tPropertyData inferredData,\n\t\t\tMap<String, IdentifierGeneratorDefinition> classGenerators,\n\t\t\tEntityBinder entityBinder,\n\t\t\tboolean isIdentifierMapper,\n\t\t\tMetadataBuildingContext context,\n\t\t\tMap<ClassDetails, InheritanceState> inheritanceStatePerClass,\n\t\t\tMemberDetails property,\n\t\t\tAnnotatedJoinColumns joinColumns) {\n\t\tfinal SourceModelBuildingContext sourceModelContext = context.getMetadataCollector().getSourceModelBuildingContext();\n\n\t\tfinal OneToMany oneToManyAnn = property.getAnnotationUsage( OneToMany.class, sourceModelContext );\n\t\tfinal ManyToMany manyToManyAnn = property.getAnnotationUsage( ManyToMany.class, sourceModelContext );\n\t\tfinal ElementCollection elementCollectionAnn = property.getAnnotationUsage( ElementCollection.class, sourceModelContext );\n\t\tcheckAnnotations( propertyHolder, inferredData, property, oneToManyAnn, manyToManyAnn, elementCollectionAnn );\n\n\t\tfinal CollectionBinder collectionBinder = getCollectionBinder( property, hasMapKeyAnnotation( property ), context );\n\t\tcollectionBinder.setIndexColumn( getIndexColumn( propertyHolder, inferredData, entityBinder, context, property ) );\n\t\tcollectionBinder.setMapKey( property.getAnnotationUsage( MapKey.class, sourceModelContext ) );\n\t\tcollectionBinder.setPropertyName( inferredData.getPropertyName() );\n\t\tcollectionBinder.setJpaOrderBy( property.getAnnotationUsage( OrderBy.class, sourceModelContext ) );\n\t\tcollectionBinder.setSqlOrderBy( getOverridableAnnotation( property, org.hibernate.annotations.OrderBy.class, context ) );\n\t\tcollectionBinder.setSqlOrder( getOverridableAnnotation( property, SQLOrder.class, context ) );\n\t\tcollectionBinder.setNaturalSort( property.getAnnotationUsage( SortNatural.class, sourceModelContext ) );\n\t\tcollectionBinder.setComparatorSort( property.getAnnotationUsage( SortComparator.class, sourceModelContext ) );\n\t\tcollectionBinder.setCache( property.getAnnotationUsage( Cache.class, sourceModelContext ) );\n\t\tcollectionBinder.setQueryCacheLayout( property.getAnnotationUsage( QueryCacheLayout.class, sourceModelContext ) );\n\t\tcollectionBinder.setPropertyHolder(propertyHolder);\n\n\t\tcollectionBinder.setNotFoundAction( notFoundAction( propertyHolder, inferredData, property, manyToManyAnn, sourceModelContext ) );\n\t\tcollectionBinder.setElementType( inferredData.getClassOrElementType() );\n\t\tcollectionBinder.setAccessType( inferredData.getDefaultAccess() );\n\t\tcollectionBinder.setEmbedded( property.hasAnnotationUsage( Embedded.class, sourceModelContext ) );\n\t\tcollectionBinder.setProperty( property );\n\t\tcollectionBinder.setOnDeleteActionAction( onDeleteAction( property ) );\n\t\tcollectionBinder.setInheritanceStatePerClass( inheritanceStatePerClass );\n\t\tcollectionBinder.setDeclaringClass( inferredData.getDeclaringClass() );\n\n//\t\tfinal Comment comment = property.getAnnotation( Comment.class );\n\t\tfinal Cascade hibernateCascade = property.getAnnotationUsage( Cascade.class, sourceModelContext );\n\n\t\tcollectionBinder.setElementColumns( elementColumns(\n\t\t\t\tpropertyHolder,\n\t\t\t\tnullability,\n\t\t\t\tentityBinder,\n\t\t\t\tcontext,\n\t\t\t\tproperty,\n\t\t\t\tvirtualPropertyData( inferredData, property )\n//\t\t\t\tcomment\n\t\t) );\n\n\t\tcollectionBinder.setMapKeyColumns( mapKeyColumns(\n\t\t\t\tpropertyHolder,\n\t\t\t\tinferredData,\n\t\t\t\tentityBinder,\n\t\t\t\tcontext,\n\t\t\t\tproperty\n//\t\t\t\tcomment\n\t\t) );\n\n\t\tcollectionBinder.setMapKeyManyToManyColumns( mapKeyJoinColumns(\n\t\t\t\tpropertyHolder,\n\t\t\t\tinferredData,\n\t\t\t\tentityBinder,\n\t\t\t\tcontext,\n\t\t\t\tproperty\n//\t\t\t\tcomment\n\t\t) );\n\n\t\tbindJoinedTableAssociation(\n\t\t\t\tproperty,\n\t\t\t\tcontext,\n\t\t\t\tentityBinder,\n\t\t\t\tcollectionBinder,\n\t\t\t\tpropertyHolder,\n\t\t\t\tinferredData,\n\t\t\t\thandleTargetEntity(\n\t\t\t\t\t\tpropertyHolder,\n\t\t\t\t\t\tinferredData,\n\t\t\t\t\t\tcontext,\n\t\t\t\t\t\tproperty,\n\t\t\t\t\t\tjoinColumns,\n\t\t\t\t\t\toneToManyAnn,\n\t\t\t\t\t\tmanyToManyAnn,\n\t\t\t\t\t\telementCollectionAnn,\n\t\t\t\t\t\tcollectionBinder,\n\t\t\t\t\t\thibernateCascade\n\t\t\t\t)\n\t\t);\n\n\t\tif ( isIdentifierMapper ) {\n\t\t\tcollectionBinder.setInsertable( false );\n\t\t\tcollectionBinder.setUpdatable( false );\n\t\t}\n\n\t\tif ( property.hasAnnotationUsage( CollectionId.class, sourceModelContext ) ) {\n\t\t\t//do not compute the generators unless necessary\n\t\t\tfinal HashMap<String, IdentifierGeneratorDefinition> localGenerators = new HashMap<>(classGenerators);\n\t\t\tlocalGenerators.putAll( buildGenerators( property, context ) );\n\t\t\tcollectionBinder.setLocalGenerators( localGenerators );\n\n\t\t}\n\t\tcollectionBinder.bind();\n\t}\n\n\tprivate static NotFoundAction notFoundAction(\n\t\t\tPropertyHolder propertyHolder,\n\t\t\tPropertyData inferredData,\n\t\t\tMemberDetails property,\n\t\t\tManyToMany manyToManyAnn,\n\t\t\tSourceModelBuildingContext sourceModelContext) {\n\t\tfinal NotFound notFound = property.getAnnotationUsage( NotFound.class, sourceModelContext );\n\t\tif ( notFound != null ) {\n\t\t\tif ( manyToManyAnn == null ) {\n\t\t\t\tthrow new AnnotationException( \"Collection '\" + getPath(propertyHolder, inferredData)\n\t\t\t\t\t\t+ \"' annotated '@NotFound' is not a '@ManyToMany' association\" );\n\t\t\t}\n\t\t\treturn notFound.action();\n\t\t}\n\t\telse {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tprivate static AnnotatedJoinColumns mapKeyJoinColumns(\n\t\t\tPropertyHolder propertyHolder,\n\t\t\tPropertyData inferredData,\n\t\t\tEntityBinder entityBinder,\n\t\t\tMetadataBuildingContext context,\n\t\t\tMemberDetails property) {\n//\t\t\tComment comment) {\n\t\treturn buildJoinColumnsWithDefaultColumnSuffix(\n\t\t\t\tmapKeyJoinColumnAnnotations( propertyHolder, inferredData, property, context ),\n//\t\t\t\tcomment,\n\t\t\t\tnull,\n\t\t\t\tentityBinder.getSecondaryTables(),\n\t\t\t\tpropertyHolder,\n\t\t\t\tinferredData,\n\t\t\t\t\"_KEY\",\n\t\t\t\tcontext\n\t\t);\n\t}\n\n\tprivate static OnDeleteAction onDeleteAction(MemberDetails property) {\n\t\tfinal OnDelete onDelete = property.getDirectAnnotationUsage( OnDelete.class );\n\t\treturn onDelete == null ? null : onDelete.action();\n\t}\n\n\tprivate static PropertyData virtualPropertyData(PropertyData inferredData, MemberDetails property) {\n\t\t//do not use \"element\" if you are a JPA 2 @ElementCollection, only for legacy Hibernate mappings\n\t\treturn property.hasDirectAnnotationUsage( ElementCollection.class )\n\t\t\t\t? inferredData\n\t\t\t\t: new WrappedInferredData(inferredData, \"element\" );\n\t}\n\n\tprivate static void checkAnnotations(\n\t\t\tPropertyHolder propertyHolder,\n\t\t\tPropertyData inferredData,\n\t\t\tMemberDetails property,\n\t\t\tOneToMany oneToMany,\n\t\t\tManyToMany manyToMany,\n\t\t\tElementCollection elementCollection) {\n\t\tif ( ( oneToMany != null || manyToMany != null || elementCollection != null )\n\t\t\t\t&& isToManyAssociationWithinEmbeddableCollection( propertyHolder ) ) {\n\t\t\tthrow new AnnotationException( \"Property '\" + getPath( propertyHolder, inferredData ) +\n\t\t\t\t\t\"' belongs to an '@Embeddable' class that is contained in an '@ElementCollection' and may not be a \"\n\t\t\t\t\t+ annotationName( oneToMany, manyToMany, elementCollection ));\n\t\t}\n\n\t\tif ( oneToMany != null && property.hasDirectAnnotationUsage( SoftDelete.class ) ) {\n\t\t\tthrow new UnsupportedMappingException(\n\t\t\t\t\t\"@SoftDelete cannot be applied to @OneToMany - \" +\n\t\t\t\t\t\t\tproperty.getDeclaringType().getName() + \".\" + property.getName()\n\t\t\t);\n\t\t}\n\n\t\tif ( property.hasDirectAnnotationUsage( OrderColumn.class )\n\t\t\t\t&& manyToMany != null\n\t\t\t\t&& StringHelper.isNotEmpty( manyToMany.mappedBy() ) ) {\n\t\t\tthrow new AnnotationException(\"Collection '\" + getPath( propertyHolder, inferredData ) +\n\t\t\t\t\t\"' is the unowned side of a bidirectional '@ManyToMany' and may not have an '@OrderColumn'\");\n\t\t}\n\n\t\tif ( manyToMany != null || elementCollection != null ) {\n\t\t\tif ( property.hasDirectAnnotationUsage( JoinColumn.class )\n\t\t\t\t\t|| property.hasDirectAnnotationUsage( JoinColumns.class ) ) {\n\t\t\t\tthrow new AnnotationException( \"Property '\" + getPath( propertyHolder, inferredData )\n\t\t\t\t\t\t+ \"' is a \" + annotationName( oneToMany, manyToMany, elementCollection )\n\t\t\t\t\t\t+ \" and is directly annotated '@JoinColumn'\"\n\t\t\t\t\t\t+ \" (specify '@JoinColumn' inside '@JoinTable' or '@CollectionTable')\" );\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate static String annotationName(\n\t\t\tOneToMany oneToMany,\n\t\t\tManyToMany manyToMany,\n\t\t\tElementCollection elementCollection) {\n\t\treturn oneToMany != null ? \"'@OneToMany'\" : manyToMany != null ? \"'@ManyToMany'\" : \"'@ElementCollection'\";\n\t}\n\n\tprivate static IndexColumn getIndexColumn(\n\t\t\tPropertyHolder propertyHolder,\n\t\t\tPropertyData inferredData,\n\t\t\tEntityBinder entityBinder,\n\t\t\tMetadataBuildingContext context,\n\t\t\tMemberDetails property) {\n\t\treturn IndexColumn.fromAnnotations(\n\t\t\t\tproperty.getDirectAnnotationUsage( OrderColumn.class ),\n\t\t\t\tproperty.getDirectAnnotationUsage( ListIndexBase.class ),\n\t\t\t\tpropertyHolder,\n\t\t\t\tinferredData,\n\t\t\t\tentityBinder.getSecondaryTables(),\n\t\t\t\tcontext\n\t\t);\n\t}\n\n\tprivate static String handleTargetEntity(\n\t\t\tPropertyHolder propertyHolder,\n\t\t\tPropertyData inferredData,\n\t\t\tMetadataBuildingContext context,\n\t\t\tMemberDetails property,\n\t\t\tAnnotatedJoinColumns joinColumns,\n\t\t\tOneToMany oneToManyAnn,\n\t\t\tManyToMany manyToManyAnn,\n\t\t\tElementCollection elementCollectionAnn,\n\t\t\tCollectionBinder collectionBinder,\n\t\t\tCascade hibernateCascade) {\n\n\t\t//TODO enhance exception with @ManyToAny and @CollectionOfElements\n\t\tif ( oneToManyAnn != null && manyToManyAnn != null ) {\n\t\t\tthrow new AnnotationException( \"Property '\" + getPath( propertyHolder, inferredData )\n\t\t\t\t\t+ \"' is annotated both '@OneToMany' and '@ManyToMany'\" );\n\t\t}\n\t\tfinal String mappedBy;\n\t\tif ( oneToManyAnn != null ) {\n\t\t\tif ( joinColumns.isSecondary() ) {\n\t\t\t\tthrow new AnnotationException( \"Collection '\" + getPath( propertyHolder, inferredData )\n\t\t\t\t\t\t+ \"' has foreign key in secondary table\" );\n\t\t\t}\n\t\t\tcollectionBinder.setFkJoinColumns( joinColumns );\n\t\t\tmappedBy = nullIfEmpty( oneToManyAnn.mappedBy() );\n\t\t\tcollectionBinder.setTargetEntity( oneToManyAnn.targetEntity() );\n\t\t\tcollectionBinder.setCascadeStrategy( getCascadeStrategy(\n\t\t\t\t\toneToManyAnn.cascade(),\n\t\t\t\t\thibernateCascade,\n\t\t\t\t\toneToManyAnn.orphanRemoval(),\n\t\t\t\t\tcontext\n\t\t\t) );\n\t\t\tcollectionBinder.setOneToMany( true );\n\t\t}\n\t\telse if ( elementCollectionAnn != null ) {\n\t\t\tif ( joinColumns.isSecondary() ) {\n\t\t\t\tthrow new AnnotationException( \"Collection '\" + getPath( propertyHolder, inferredData )\n\t\t\t\t\t\t+ \"' has foreign key in secondary table\" );\n\t\t\t}\n\t\t\tcollectionBinder.setFkJoinColumns( joinColumns );\n\t\t\tmappedBy = null;\n\t\t\tcollectionBinder.setTargetEntity( elementCollectionAnn.targetClass() );\n\t\t\tcollectionBinder.setOneToMany( false );\n\t\t}\n\t\telse if ( manyToManyAnn != null ) {\n\t\t\tmappedBy = nullIfEmpty( manyToManyAnn.mappedBy() );\n\t\t\tcollectionBinder.setTargetEntity( manyToManyAnn.targetEntity() );\n\t\t\tcollectionBinder.setCascadeStrategy( getCascadeStrategy(\n\t\t\t\t\tmanyToManyAnn.cascade(),\n\t\t\t\t\thibernateCascade,\n\t\t\t\t\tfalse,\n\t\t\t\t\tcontext\n\t\t\t) );\n\t\t\tcollectionBinder.setOneToMany( false );\n\t\t}\n\t\telse if ( property.hasDirectAnnotationUsage( ManyToAny.class ) ) {\n\t\t\tmappedBy = null;\n\t\t\tcollectionBinder.setTargetEntity( ClassDetails.VOID_CLASS_DETAILS );\n\t\t\tcollectionBinder.setCascadeStrategy( getCascadeStrategy(\n\t\t\t\t\tnull,\n\t\t\t\t\thibernateCascade,\n\t\t\t\t\tfalse,\n\t\t\t\t\tcontext\n\t\t\t) );\n\t\t\tcollectionBinder.setOneToMany( false );\n\t\t}\n\t\telse {\n\t\t\tmappedBy = null;\n\t\t}\n\t\tcollectionBinder.setMappedBy( mappedBy );\n\t\treturn mappedBy;\n\t}\n\n\tprivate static boolean hasMapKeyAnnotation(MemberDetails property) {\n\t\treturn property.hasDirectAnnotationUsage(MapKeyJavaType.class)\n\t\t\t|| property.hasDirectAnnotationUsage(MapKeyJdbcType.class)\n\t\t\t|| property.hasDirectAnnotationUsage(MapKeyJdbcTypeCode.class)\n\t\t\t|| property.hasDirectAnnotationUsage(MapKeyMutability.class)\n\t\t\t|| property.hasDirectAnnotationUsage(MapKey.class)\n\t\t\t|| property.hasDirectAnnotationUsage(MapKeyType.class);\n\t}\n\n\tprivate static boolean isToManyAssociationWithinEmbeddableCollection(PropertyHolder propertyHolder) {\n\t\tif ( propertyHolder instanceof ComponentPropertyHolder ) {\n\t\t\tComponentPropertyHolder componentPropertyHolder = (ComponentPropertyHolder) propertyHolder;\n\t\t\treturn componentPropertyHolder.isWithinElementCollection();\n\t\t}\n\t\telse {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tprivate static AnnotatedColumns elementColumns(\n\t\t\tPropertyHolder propertyHolder,\n\t\t\tNullability nullability,\n\t\t\tEntityBinder entityBinder,\n\t\t\tMetadataBuildingContext context,\n\t\t\tMemberDetails property,\n\t\t\tPropertyData virtualProperty) {\n//\t\t\tComment comment) {\n\t\tif ( property.hasDirectAnnotationUsage( jakarta.persistence.Column.class ) ) {\n\t\t\treturn buildColumnFromAnnotation(\n\t\t\t\t\tproperty.getDirectAnnotationUsage( jakarta.persistence.Column.class ),\n\t\t\t\t\tnull,\n//\t\t\t\t\tcomment,\n\t\t\t\t\tnullability,\n\t\t\t\t\tpropertyHolder,\n\t\t\t\t\tvirtualProperty,\n\t\t\t\t\tentityBinder.getSecondaryTables(),\n\t\t\t\t\tcontext\n\t\t\t);\n\t\t}\n\t\telse if ( property.hasDirectAnnotationUsage( Formula.class ) ) {\n\t\t\treturn buildFormulaFromAnnotation(\n\t\t\t\t\tgetOverridableAnnotation(property, Formula.class, context),\n//\t\t\t\t\tcomment,\n\t\t\t\t\tnullability,\n\t\t\t\t\tpropertyHolder,\n\t\t\t\t\tvirtualProperty,\n\t\t\t\t\tentityBinder.getSecondaryTables(),\n\t\t\t\t\tcontext\n\t\t\t);\n\t\t}\n\t\telse if ( property.hasDirectAnnotationUsage( Columns.class ) ) {\n\t\t\treturn buildColumnsFromAnnotations(\n\t\t\t\t\tproperty.getDirectAnnotationUsage( Columns.class ).columns(),\n\t\t\t\t\tnull,\n//\t\t\t\t\tcomment,\n\t\t\t\t\tnullability,\n\t\t\t\t\tpropertyHolder,\n\t\t\t\t\tvirtualProperty,\n\t\t\t\t\tentityBinder.getSecondaryTables(),\n\t\t\t\t\tcontext\n\t\t\t);\n\t\t}\n\t\telse {\n\t\t\treturn buildColumnFromNoAnnotation(\n\t\t\t\t\tnull,\n//\t\t\t\t\tcomment,\n\t\t\t\t\tnullability,\n\t\t\t\t\tpropertyHolder,\n\t\t\t\t\tvirtualProperty,\n\t\t\t\t\tentityBinder.getSecondaryTables(),\n\t\t\t\t\tcontext\n\t\t\t);\n\t\t}\n\t}\n\n\tprivate static JoinColumn[] mapKeyJoinColumnAnnotations(\n\t\t\tPropertyHolder propertyHolder,\n\t\t\tPropertyData inferredData,\n\t\t\tMemberDetails property,\n\t\t\tMetadataBuildingContext context) {\n\t\tfinal MapKeyJoinColumn[] mapKeyJoinColumns = property.getRepeatedAnnotationUsages(\n\t\t\t\tJpaAnnotations.MAP_KEY_JOIN_COLUMN,\n\t\t\t\tcontext.getMetadataCollector().getSourceModelBuildingContext()\n\t\t);\n\n\t\tif ( CollectionHelper.isEmpty( mapKeyJoinColumns ) ) {\n\t\t\treturn null;\n\t\t}\n\n\t\tfinal JoinColumn[] joinColumns = new JoinColumn[mapKeyJoinColumns.length];\n\t\tfor ( int i = 0; i < mapKeyJoinColumns.length; i++ ) {\n\t\t\tfinal JoinColumn joinColumn = JoinColumnJpaAnnotation.toJoinColumn(\n\t\t\t\t\tmapKeyJoinColumns[i],\n\t\t\t\t\tcontext.getMetadataCollector().getSourceModelBuildingContext()\n\t\t\t);\n\t\t\tjoinColumns[i] = joinColumn;\n\t\t}\n\t\treturn joinColumns;\n\t}\n\n\tprivate static AnnotatedColumns mapKeyColumns(\n\t\t\tPropertyHolder propertyHolder,\n\t\t\tPropertyData inferredData,\n\t\t\tEntityBinder entityBinder,\n\t\t\tMetadataBuildingContext context,\n\t\t\tMemberDetails property) {\n//\t\t\tComment comment) {\n\t\tfinal jakarta.persistence.Column column;\n\t\tif ( property.hasDirectAnnotationUsage( MapKeyColumn.class ) ) {\n\t\t\tcolumn = MapKeyColumnJpaAnnotation.toColumnAnnotation(\n\t\t\t\t\tproperty.getDirectAnnotationUsage( MapKeyColumn.class ),\n\t\t\t\t\tcontext.getMetadataCollector().getSourceModelBuildingContext()\n\t\t\t);\n\t\t}\n\t\telse {\n\t\t\tcolumn = null;\n\t\t}\n\t\treturn buildColumnsFromAnnotations(\n\t\t\t\tcolumn == null ? null : new jakarta.persistence.Column[] { column },\n//\t\t\t\tcomment,\n\t\t\t\tNullability.FORCED_NOT_NULL,\n\t\t\t\tpropertyHolder,\n\t\t\t\tinferredData,\n\t\t\t\t\"_KEY\",\n\t\t\t\tentityBinder.getSecondaryTables(),\n\t\t\t\tcontext\n\t\t);\n\t}\n\n\tprivate static void bindJoinedTableAssociation(\n\t\t\tMemberDetails property,\n\t\t\tMetadataBuildingContext buildingContext,\n\t\t\tEntityBinder entityBinder,\n\t\t\tCollectionBinder collectionBinder,\n\t\t\tPropertyHolder propertyHolder,\n\t\t\tPropertyData inferredData,\n\t\t\tString mappedBy) {\n\t\tfinal TableBinder associationTableBinder = new TableBinder();\n\t\tfinal JoinTable assocTable = propertyHolder.getJoinTable( property );\n\t\tfinal CollectionTable collectionTable = property.getDirectAnnotationUsage( CollectionTable.class );\n\n\t\tfinal JoinColumn[] annJoins;\n\t\tfinal JoinColumn[] annInverseJoins;\n\t\tif ( assocTable != null || collectionTable != null ) {\n\t\t\tfinal String catalog;\n\t\t\tfinal String schema;\n\t\t\tfinal String tableName;\n\t\t\tfinal UniqueConstraint[] uniqueConstraints;\n\t\t\tfinal JoinColumn[] joins;\n\t\t\tfinal JoinColumn[] inverseJoins;\n\t\t\tfinal Index[] jpaIndexes;\n\t\t\tfinal String options;\n\n\t\t\t//JPA 2 has priority\n\t\t\tif ( collectionTable != null ) {\n\t\t\t\tcatalog = collectionTable.catalog();\n\t\t\t\tschema = collectionTable.schema();\n\t\t\t\ttableName = collectionTable.name();\n\t\t\t\tuniqueConstraints = collectionTable.uniqueConstraints();\n\t\t\t\tjoins = collectionTable.joinColumns();\n\t\t\t\tinverseJoins = null;\n\t\t\t\tjpaIndexes = collectionTable.indexes();\n\t\t\t\toptions = collectionTable.options();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcatalog = assocTable.catalog();\n\t\t\t\tschema = assocTable.schema();\n\t\t\t\ttableName = assocTable.name();\n\t\t\t\tuniqueConstraints = assocTable.uniqueConstraints();\n\t\t\t\tjoins = assocTable.joinColumns();\n\t\t\t\tinverseJoins = assocTable.inverseJoinColumns();\n\t\t\t\tjpaIndexes = assocTable.indexes();\n\t\t\t\toptions = assocTable.options();\n\t\t\t}\n\n\t\t\tcollectionBinder.setExplicitAssociationTable( true );\n\t\t\tif ( CollectionHelper.isNotEmpty( jpaIndexes ) ) {\n\t\t\t\tassociationTableBinder.setJpaIndex( jpaIndexes );\n\t\t\t}\n\t\t\tif ( !schema.isEmpty() ) {\n\t\t\t\tassociationTableBinder.setSchema( schema );\n\t\t\t}\n\t\t\tif ( !catalog.isEmpty() ) {\n\t\t\t\tassociationTableBinder.setCatalog( catalog );\n\t\t\t}\n\t\t\tif ( !tableName.isEmpty() ) {\n\t\t\t\tassociationTableBinder.setName( tableName );\n\t\t\t}\n\t\t\tassociationTableBinder.setUniqueConstraints( uniqueConstraints );\n\t\t\tassociationTableBinder.setJpaIndex( jpaIndexes );\n\t\t\tassociationTableBinder.setOptions( options );\n\t\t\t//set check constraint in the second pass\n\t\t\tannJoins = ArrayHelper.isEmpty( joins ) ? null : joins;\n\t\t\tannInverseJoins = inverseJoins == null || ArrayHelper.isEmpty( inverseJoins ) ? null : inverseJoins;\n\t\t}\n\t\telse {\n\t\t\tannJoins = null;\n\t\t\tannInverseJoins = null;\n\t\t}\n\t\tassociationTableBinder.setBuildingContext( buildingContext );\n\t\tcollectionBinder.setTableBinder( associationTableBinder );\n\t\tcollectionBinder.setJoinColumns( buildJoinTableJoinColumns(\n\t\t\t\tannJoins,\n\t\t\t\tentityBinder.getSecondaryTables(),\n\t\t\t\tpropertyHolder,\n\t\t\t\tinferredData,\n\t\t\t\tmappedBy,\n\t\t\t\tbuildingContext\n\t\t) );\n\t\tcollectionBinder.setInverseJoinColumns( buildJoinTableJoinColumns(\n\t\t\t\tannInverseJoins,\n\t\t\t\tentityBinder.getSecondaryTables(),\n\t\t\t\tpropertyHolder,\n\t\t\t\tinferredData,\n\t\t\t\tmappedBy,\n\t\t\t\tbuildingContext\n\t\t) );\n\t}\n\n\tprotected MetadataBuildingContext getBuildingContext() {\n\t\treturn buildingContext;\n\t}\n\n\tpublic Supplier<ManagedBean<? extends UserCollectionType>> getCustomTypeBeanResolver() {\n\t\treturn customTypeBeanResolver;\n\t}\n\n\tpublic boolean isMap() {\n\t\treturn false;\n\t}\n\n\tprotected void setIsHibernateExtensionMapping(boolean hibernateExtensionMapping) {\n\t\tthis.hibernateExtensionMapping = hibernateExtensionMapping;\n\t}\n\n\tprotected boolean isHibernateExtensionMapping() {\n\t\treturn hibernateExtensionMapping;\n\t}\n\n\tpublic void setUpdatable(boolean updatable) {\n\t\tthis.updatable = updatable;\n\t}\n\n\tpublic void setInheritanceStatePerClass(Map<ClassDetails, InheritanceState> inheritanceStatePerClass) {\n\t\tthis.inheritanceStatePerClass = inheritanceStatePerClass;\n\t}\n\n\tpublic void setInsertable(boolean insertable) {\n\t\tthis.insertable = insertable;\n\t}\n\n\tpublic void setCascadeStrategy(String cascadeStrategy) {\n\t\tthis.cascadeStrategy = cascadeStrategy;\n\t}\n\n\tpublic void setAccessType(AccessType accessType) {\n\t\tthis.accessType = accessType;\n\t}\n\n\tpublic void setInverseJoinColumns(AnnotatedJoinColumns inverseJoinColumns) {\n\t\tthis.inverseJoinColumns = inverseJoinColumns;\n\t}\n\n\tpublic void setJoinColumns(AnnotatedJoinColumns joinColumns) {\n\t\tthis.joinColumns = joinColumns;\n\t}\n\n\tpublic void setPropertyHolder(PropertyHolder propertyHolder) {\n\t\tthis.propertyHolder = propertyHolder;\n\t}\n\n\tpublic void setJpaOrderBy(jakarta.persistence.OrderBy jpaOrderBy) {\n\t\tthis.jpaOrderBy = jpaOrderBy;\n\t}\n\n\t@SuppressWarnings(\"removal\")\n\tpublic void setSqlOrderBy(org.hibernate.annotations.OrderBy sqlOrderBy) {\n\t\tthis.sqlOrderBy = sqlOrderBy;\n\t}\n\n\tpublic void setSqlOrder(SQLOrder sqlOrder) {\n\t\tthis.sqlOrder = sqlOrder;\n\t}\n\n\tpublic void setNaturalSort(SortNatural naturalSort) {\n\t\tthis.naturalSort = naturalSort;\n\t}\n\n\tpublic void setComparatorSort(SortComparator comparatorSort) {\n\t\tthis.comparatorSort = comparatorSort;\n\t}\n\n\t/**\n\t * collection binder factory\n\t */\n\tpublic static CollectionBinder getCollectionBinder(\n\t\t\tMemberDetails property,\n\t\t\tboolean isHibernateExtensionMapping,\n\t\t\tMetadataBuildingContext buildingContext) {\n\n\t\tfinal CollectionBinder binder;\n\t\tfinal CollectionType typeAnnotation = property.getAnnotationUsage( CollectionType.class, buildingContext.getMetadataCollector().getSourceModelBuildingContext() );\n\t\tif ( typeAnnotation != null ) {\n\t\t\tbinder = createBinderFromCustomTypeAnnotation( property, typeAnnotation, buildingContext );\n\t\t\t// todo (6.0) - technically, these should no longer be needed\n\t\t\tbinder.explicitType = typeAnnotation.type().getName();\n\t\t\tfor ( Parameter param : typeAnnotation.parameters() ) {\n\t\t\t\tbinder.explicitTypeParameters.put( param.name(), param.value() );\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tbinder = createBinderAutomatically( property, buildingContext );\n\t\t}\n\t\tbinder.setIsHibernateExtensionMapping( isHibernateExtensionMapping );\n\t\treturn binder;\n\t}\n\n\tprivate static CollectionBinder createBinderAutomatically(MemberDetails property, MetadataBuildingContext context) {\n\t\tfinal CollectionClassification classification = determineCollectionClassification( property, context );\n\t\tfinal CollectionTypeRegistrationDescriptor typeRegistration =\n\t\t\t\tcontext.getMetadataCollector().findCollectionTypeRegistration( classification );\n\t\treturn typeRegistration != null\n\t\t\t\t? createBinderFromTypeRegistration( property, classification, typeRegistration, context )\n\t\t\t\t: createBinderFromProperty( property, context );\n\t}\n\n\tprivate static CollectionBinder createBinderFromTypeRegistration(\n\t\t\tMemberDetails property,\n\t\t\tCollectionClassification classification,\n\t\t\tCollectionTypeRegistrationDescriptor typeRegistration,\n\t\t\tMetadataBuildingContext buildingContext) {\n\t\treturn createBinder(\n\t\t\t\tproperty,\n\t\t\t\t() -> createCustomType(\n\t\t\t\t\t\tproperty.getDeclaringType().getName() + \"#\" + property.getName(),\n\t\t\t\t\t\ttypeRegistration.getImplementation(),\n\t\t\t\t\t\ttypeRegistration.getParameters(),\n\t\t\t\t\t\tbuildingContext\n\t\t\t\t),\n\t\t\t\tclassification,\n\t\t\t\tbuildingContext\n\t\t);\n\t}\n\n\tprivate static ManagedBean<? extends UserCollectionType> createCustomType(\n\t\t\tString role,\n\t\t\tClass<? extends UserCollectionType> implementation,\n\t\t\tMap<String,String> parameters,\n\t\t\tMetadataBuildingContext buildingContext) {\n\t\tfinal boolean hasParameters = CollectionHelper.isNotEmpty( parameters );\n\t\tif ( !buildingContext.getBuildingOptions().isAllowExtensionsInCdi() ) {\n\t\t\t// if deferred container access is enabled, we locally create the user-type\n\t\t\treturn createLocalUserCollectionTypeBean( role, implementation, hasParameters, parameters );\n\t\t}\n\n\t\tfinal ManagedBean<? extends UserCollectionType> managedBean =\n\t\t\t\tbuildingContext.getBuildingOptions().getServiceRegistry()\n\t\t\t\t\t\t.requireService( ManagedBeanRegistry.class )\n\t\t\t\t\t\t.getBean( implementation );\n\n\t\tif ( hasParameters ) {\n\t\t\tif ( ParameterizedType.class.isAssignableFrom( managedBean.getBeanClass() ) ) {\n\t\t\t\t// create a copy of the parameters and create a bean wrapper to delay injecting\n\t\t\t\t// the parameters, thereby delaying the need to resolve the instance from the\n\t\t\t\t// wrapped bean\n\t\t\t\tfinal Properties copy = new Properties();\n\t\t\t\tcopy.putAll( parameters );\n\t\t\t\treturn new DelayedParameterizedTypeBean<>( managedBean, copy );\n\t\t\t}\n\n\t\t\t// there were parameters, but the custom-type does not implement the interface\n\t\t\t// used to inject them - log a \"warning\"\n\t\t\tBootLogging.BOOT_LOGGER.debugf(\n\t\t\t\t\t\"`@CollectionType` (%s) specified parameters, but the\" +\n\t\t\t\t\t\t\t\" implementation does not implement `%s` which is used to inject them - `%s`\",\n\t\t\t\t\trole,\n\t\t\t\t\tParameterizedType.class.getName(),\n\t\t\t\t\timplementation.getName()\n\t\t\t);\n\n\t\t\t// fall through to returning `managedBean`\n\t\t}\n\n\t\treturn managedBean;\n\t}\n\n\tprivate static CollectionBinder createBinderFromProperty(MemberDetails property, MetadataBuildingContext context) {\n\t\tfinal CollectionClassification classification = determineCollectionClassification( property, context );\n\t\treturn createBinder( property, null, classification, context );\n\t}\n\n\tprivate static CollectionBinder createBinderFromCustomTypeAnnotation(\n\t\t\tMemberDetails property,\n\t\t\tCollectionType typeAnnotation,\n\t\t\tMetadataBuildingContext buildingContext) {\n\t\tdetermineSemanticJavaType( property, buildingContext );\n\t\tfinal ManagedBean<? extends UserCollectionType> customTypeBean = resolveCustomType(\n\t\t\t\tproperty,\n\t\t\t\ttypeAnnotation,\n\t\t\t\tbuildingContext\n\t\t);\n\t\treturn createBinder(\n\t\t\t\tproperty,\n\t\t\t\t() -> customTypeBean,\n\t\t\t\tcustomTypeBean.getBeanInstance().getClassification(),\n\t\t\t\tbuildingContext\n\t\t);\n\t}\n\n\tpublic static ManagedBean<? extends UserCollectionType> resolveCustomType(\n\t\t\tMemberDetails property,\n\t\t\tCollectionType typeAnnotation,\n\t\t\tMetadataBuildingContext context) {\n\t\tfinal Properties parameters = extractParameters( typeAnnotation );\n\n\t\t//noinspection unchecked,rawtypes\n\t\treturn createCustomType(\n\t\t\t\tproperty.getDeclaringType().getName() + \".\" + property.getName(),\n\t\t\t\ttypeAnnotation.type(),\n\t\t\t\t(Map) parameters,\n\t\t\t\tcontext\n\t\t);\n\t}\n\n\tprivate static Properties extractParameters(CollectionType typeAnnotation) {\n\t\tfinal Parameter[] parameterAnnotations = typeAnnotation.parameters();\n\t\tfinal Properties configParams = new Properties( parameterAnnotations.length );\n\t\tfor ( Parameter parameterAnnotation : parameterAnnotations ) {\n\t\t\tconfigParams.put( parameterAnnotation.name(), parameterAnnotation.value() );\n\t\t}\n\t\treturn configParams;\n\t}\n\n\tprivate static CollectionBinder createBinder(\n\t\t\tMemberDetails property,\n\t\t\tSupplier<ManagedBean<? extends UserCollectionType>> customTypeBeanAccess,\n\t\t\tCollectionClassification classification,\n\t\t\tMetadataBuildingContext buildingContext) {\n\t\tfinal TypeDetails elementType = property.getElementType();\n\n\t\treturn switch ( classification ) {\n\t\t\tcase ARRAY -> elementType.getTypeKind() == TypeDetails.Kind.PRIMITIVE\n\t\t\t\t\t? new PrimitiveArrayBinder( customTypeBeanAccess, buildingContext )\n\t\t\t\t\t: new ArrayBinder( customTypeBeanAccess, buildingContext );\n\t\t\tcase BAG -> new BagBinder( customTypeBeanAccess, buildingContext );\n\t\t\tcase ID_BAG -> new IdBagBinder( customTypeBeanAccess, buildingContext );\n\t\t\tcase LIST -> new ListBinder( customTypeBeanAccess, buildingContext );\n\t\t\tcase MAP, ORDERED_MAP -> new MapBinder( customTypeBeanAccess, false, buildingContext );\n\t\t\tcase SORTED_MAP -> new MapBinder( customTypeBeanAccess, true, buildingContext );\n\t\t\tcase SET, ORDERED_SET -> new SetBinder( customTypeBeanAccess, false, buildingContext );\n\t\t\tcase SORTED_SET -> new SetBinder( customTypeBeanAccess, true, buildingContext );\n\t\t};\n\t}\n\n\tprivate static CollectionClassification determineCollectionClassification(\n\t\t\tMemberDetails property,\n\t\t\tMetadataBuildingContext buildingContext) {\n\t\tif ( property.isArray() ) {\n\t\t\treturn CollectionClassification.ARRAY;\n\t\t}\n\n\t\tfinal SourceModelBuildingContext sourceModelContext = buildingContext.getMetadataCollector().getSourceModelBuildingContext();\n\n\t\tif ( !property.hasAnnotationUsage( Bag.class, sourceModelContext ) ) {\n\t\t\treturn determineCollectionClassification( determineSemanticJavaType( property, buildingContext ), property, buildingContext );\n\t\t}\n\n\t\tif ( property.hasAnnotationUsage( OrderColumn.class, sourceModelContext ) ) {\n\t\t\tthrow new AnnotationException( \"Attribute '\"\n\t\t\t\t\t+ qualify( property.getDeclaringType().getName(), property.getName() )\n\t\t\t\t\t+ \"' is annotated '@Bag' and may not also be annotated '@OrderColumn'\" );\n\t\t}\n\n\t\tif ( property.hasAnnotationUsage( ListIndexBase.class, sourceModelContext ) ) {\n\t\t\tthrow new AnnotationException( \"Attribute '\"\n\t\t\t\t\t+ qualify( property.getDeclaringType().getName(), property.getName() )\n\t\t\t\t\t+ \"' is annotated '@Bag' and may not also be annotated '@ListIndexBase'\" );\n\t\t}\n\n\t\tfinal ClassDetails collectionClassDetails = property.getType().determineRawClass();\n\t\tfinal Class<?> collectionJavaType = collectionClassDetails.toJavaClass();\n\t\tif ( java.util.List.class.equals( collectionJavaType )\n\t\t\t\t|| java.util.Collection.class.equals( collectionJavaType ) ) {\n\t\t\treturn CollectionClassification.BAG;\n\t\t}\n\t\telse {\n\t\t\tthrow new AnnotationException(\n\t\t\t\t\tString.format(\n\t\t\t\t\t\t\tLocale.ROOT,\n\t\t\t\t\t\t\t\"Attribute '%s.%s' of type '%s' is annotated '@Bag' (bags are of type '%s' or '%s')\",\n\t\t\t\t\t\t\tproperty.getDeclaringType().getName(),\n\t\t\t\t\t\t\tproperty.getName(),\n\t\t\t\t\t\t\tcollectionJavaType.getName(),\n\t\t\t\t\t\t\tjava.util.List.class.getName(),\n\t\t\t\t\t\t\tjava.util.Collection.class.getName()\n\t\t\t\t\t)\n\t\t\t);\n\t\t}\n\t}\n\n\tprivate static CollectionClassification determineCollectionClassification(\n\t\t\tClass<?> semanticJavaType,\n\t\t\tMemberDetails property,\n\t\t\tMetadataBuildingContext buildingContext) {\n\t\tif ( semanticJavaType.isArray() ) {\n\t\t\treturn CollectionClassification.ARRAY;\n\t\t}\n\n\t\tif ( property.hasDirectAnnotationUsage( CollectionId.class )\n\t\t\t\t|| property.hasDirectAnnotationUsage( CollectionIdJdbcType.class )\n\t\t\t\t|| property.hasDirectAnnotationUsage( CollectionIdJdbcTypeCode.class )\n\t\t\t\t|| property.hasDirectAnnotationUsage( CollectionIdJavaType.class ) ) {\n\t\t\t// explicitly an ID_BAG\n\t\t\treturn CollectionClassification.ID_BAG;\n\t\t}\n\n\t\tif ( java.util.List.class.isAssignableFrom( semanticJavaType ) ) {\n\t\t\tif ( property.hasDirectAnnotationUsage( OrderColumn.class )\n\t\t\t\t\t|| property.hasDirectAnnotationUsage( ListIndexBase.class )\n\t\t\t\t\t|| property.hasDirectAnnotationUsage( ListIndexJdbcType.class )\n\t\t\t\t\t|| property.hasDirectAnnotationUsage( ListIndexJdbcTypeCode.class )\n\t\t\t\t\t|| property.hasDirectAnnotationUsage( ListIndexJavaType.class ) ) {\n\t\t\t\t// it is implicitly a LIST because of presence of explicit List index config\n\t\t\t\treturn CollectionClassification.LIST;\n\t\t\t}\n\n\t\t\tif ( property.hasDirectAnnotationUsage( jakarta.persistence.OrderBy.class )\n\t\t\t\t\t|| property.hasDirectAnnotationUsage( org.hibernate.annotations.OrderBy.class ) ) {\n\t\t\t\treturn CollectionClassification.BAG;\n\t\t\t}\n\n\t\t\tfinal SourceModelBuildingContext sourceModelContext = buildingContext.getMetadataCollector().getSourceModelBuildingContext();\n\t\t\tfinal ManyToMany manyToMany = property.getAnnotationUsage( ManyToMany.class, sourceModelContext );\n\t\t\tif ( manyToMany != null && !manyToMany.mappedBy().isEmpty() ) {\n\t\t\t\t// We don't support @OrderColumn on the non-owning side of a many-to-many association.\n\t\t\t\treturn CollectionClassification.BAG;\n\t\t\t}\n\n\t\t\tfinal OneToMany oneToMany = property.getAnnotationUsage( OneToMany.class, sourceModelContext );\n\t\t\tif ( oneToMany != null && !oneToMany.mappedBy().isEmpty() ) {\n\t\t\t\t// Unowned to-many mappings are always considered BAG by default\n\t\t\t\treturn CollectionClassification.BAG;\n\t\t\t}\n\n\t\t\t// otherwise, return the implicit classification for List attributes\n\t\t\treturn buildingContext.getBuildingOptions().getMappingDefaults().getImplicitListClassification();\n\t\t}\n\n\t\tif ( java.util.SortedSet.class.isAssignableFrom( semanticJavaType ) ) {\n\t\t\treturn CollectionClassification.SORTED_SET;\n\t\t}\n\n\t\tif ( java.util.Set.class.isAssignableFrom( semanticJavaType ) ) {\n\t\t\treturn CollectionClassification.SET;\n\t\t}\n\n\t\tif ( java.util.SortedMap.class.isAssignableFrom( semanticJavaType ) ) {\n\t\t\treturn CollectionClassification.SORTED_MAP;\n\t\t}\n\n\t\tif ( java.util.Map.class.isAssignableFrom( semanticJavaType ) ) {\n\t\t\treturn CollectionClassification.MAP;\n\t\t}\n\n\t\tif ( java.util.Collection.class.isAssignableFrom( semanticJavaType ) ) {\n\t\t\tif ( property.hasDirectAnnotationUsage( CollectionId.class ) ) {\n\t\t\t\treturn CollectionClassification.ID_BAG;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn CollectionClassification.BAG;\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tprivate static Class<?> determineSemanticJavaType(MemberDetails property, MetadataBuildingContext buildingContext) {\n\t\tif ( property.isPlural() ) {\n\t\t\tfinal ClassDetails collectionClassDetails = property.getType().determineRawClass();\n\t\t\tfinal Class<?> collectionClass = collectionClassDetails.toJavaClass();\n\t\t\treturn inferCollectionClassFromSubclass( collectionClass );\n\t\t}\n\t\telse {\n\t\t\tthrow new AnnotationException(\n\t\t\t\t\tString.format(\n\t\t\t\t\t\t\tLocale.ROOT,\n\t\t\t\t\t\t\t\"Property '%s.%s' is not a collection and may not be a '@OneToMany', '@ManyToMany', or '@ElementCollection'\",\n\t\t\t\t\t\t\tproperty.getDeclaringType().getName(),\n\t\t\t\t\t\t\tproperty.resolveAttributeName()\n\t\t\t\t\t)\n\t\t\t);\n\t\t}\n\t}\n\n\tprivate static Class<?> inferCollectionClassFromSubclass(Class<?> clazz) {\n\t\tfor ( Class<?> priorityClass : INFERRED_CLASS_PRIORITY ) {\n\t\t\tif ( priorityClass.isAssignableFrom( clazz ) ) {\n\t\t\t\treturn priorityClass;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic void setMappedBy(String mappedBy) {\n\t\tthis.mappedBy = nullIfEmpty( mappedBy );\n\t}\n\n\tpublic void setTableBinder(TableBinder tableBinder) {\n\t\tthis.tableBinder = tableBinder;\n\t}\n\n\tpublic void setElementType(TypeDetails collectionElementType) {\n\t\tthis.collectionElementType = collectionElementType;\n\t}\n\n\tpublic void setTargetEntity(Class<?> targetEntity) {\n\t\tfinal SourceModelBuildingContext sourceModelContext = buildingContext.getMetadataCollector().getSourceModelBuildingContext();\n\t\tfinal ClassDetailsRegistry classDetailsRegistry = sourceModelContext.getClassDetailsRegistry();\n\t\tsetTargetEntity( classDetailsRegistry.resolveClassDetails( targetEntity.getName() ) );\n\t}\n\n\tpublic void setTargetEntity(ClassDetails targetEntity) {\n\t\tsetTargetEntity( new ClassTypeDetailsImpl( targetEntity, TypeDetails.Kind.CLASS ) );\n\t}\n\n\tpublic void setTargetEntity(TypeDetails targetEntity) {\n\t\tthis.targetEntity = targetEntity;\n\t}\n\n\tprotected abstract Collection createCollection(PersistentClass persistentClass);\n\n\tpublic Collection getCollection() {\n\t\treturn collection;\n\t}\n\n\tpublic void setPropertyName(String propertyName) {\n\t\tthis.propertyName = propertyName;\n\t}\n\n\tpublic void setDeclaringClass(ClassDetails declaringClass) {\n\t\tthis.declaringClass = declaringClass;\n\t\tthis.declaringClassSet = true;\n\t}\n\n\tpublic void bind() {\n\t\tcollection = createCollection( propertyHolder.getPersistentClass() );\n\t\tfinal String role = qualify( propertyHolder.getPath(), propertyName );\n\t\tLOG.debugf( \"Collection role: %s\", role );\n\t\tcollection.setRole( role );\n\t\tcollection.setMappedByProperty( mappedBy );\n\n\t\tcheckMapKeyColumn();\n\t\tbindExplicitTypes();\n\t\t//set laziness\n\t\tdefineFetchingStrategy();\n\t\tcollection.setMutable( isMutable() );\n\t\t//work on association\n\t\tboolean isUnowned = isUnownedCollection();\n\t\tbindOptimisticLock( isUnowned );\n\t\tapplySortingAndOrdering();\n\t\tbindCache();\n\t\tbindLoader();\n\t\tdetectMappedByProblem( isUnowned );\n\t\tcollection.setInverse( isUnowned );\n\n\t\t//TODO reduce tableBinder != null and oneToMany\n\t\tscheduleSecondPass( isUnowned );\n\t\tbuildingContext.getMetadataCollector().addCollectionBinding( collection );\n\t\tbindProperty();\n\t}\n\n\tprivate boolean isUnownedCollection() {\n\t\treturn mappedBy != null;\n\t}\n\n\tprivate boolean isMutable() {\n\t\treturn !property.hasDirectAnnotationUsage( Immutable.class );\n\t}\n\n\tprivate void checkMapKeyColumn() {\n\t\tif ( property.hasDirectAnnotationUsage( MapKeyColumn.class ) && hasMapKeyProperty ) {\n\t\t\tthrow new AnnotationException( \"Collection '\" + qualify( propertyHolder.getPath(), propertyName )\n\t\t\t\t\t+ \"' is annotated both '@MapKey' and '@MapKeyColumn'\" );\n\t\t}\n\t}\n\n\tprivate void scheduleSecondPass(boolean isMappedBy) {\n\t\tfinal InFlightMetadataCollector metadataCollector = buildingContext.getMetadataCollector();\n\t\t//many to many may need some second pass information\n\t\tif ( !oneToMany && isMappedBy ) {\n\t\t\tmetadataCollector.addMappedBy( getElementType().getName(), mappedBy, propertyName );\n\t\t}\n\n\t\tif ( inheritanceStatePerClass == null) {\n\t\t\tthrow new AssertionFailure( \"inheritanceStatePerClass not set\" );\n\t\t}\n\t\tmetadataCollector.addSecondPass( getSecondPass(), !isMappedBy );\n\t}\n\n\tprivate void bindOptimisticLock(boolean isMappedBy) {\n\t\tfinal OptimisticLock lockAnn = property.getDirectAnnotationUsage( OptimisticLock.class );\n\t\tfinal boolean includeInOptimisticLockChecks = lockAnn != null ? !lockAnn.excluded() : !isMappedBy;\n\t\tcollection.setOptimisticLocked( includeInOptimisticLockChecks );\n\t}\n\n\tprivate void bindCache() {\n\t\t//set cache\n\t\tif ( isNotEmpty( cacheConcurrencyStrategy ) ) {\n\t\t\tcollection.setCacheConcurrencyStrategy( cacheConcurrencyStrategy );\n\t\t\tcollection.setCacheRegionName( cacheRegionName );\n\t\t}\n\t\tcollection.setQueryCacheLayout( queryCacheLayout );\n\t}\n\n\tprivate void bindExplicitTypes() {\n\t\t// set explicit type information\n\t\tfinal InFlightMetadataCollector metadataCollector = buildingContext.getMetadataCollector();\n\t\tif ( explicitType != null ) {\n\t\t\tfinal TypeDefinition typeDef = metadataCollector.getTypeDefinition( explicitType );\n\t\t\tif ( typeDef == null ) {\n\t\t\t\tcollection.setTypeName( explicitType );\n\t\t\t\tcollection.setTypeParameters( explicitTypeParameters );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcollection.setTypeName( typeDef.getTypeImplementorClass().getName() );\n\t\t\t\tcollection.setTypeParameters( typeDef.getParameters() );\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate void detectMappedByProblem(boolean isMappedBy) {\n\t\tif ( isMappedBy\n\t\t\t\t&& ( property.hasDirectAnnotationUsage( JoinColumn.class )\n\t\t\t\t\t|| property.hasDirectAnnotationUsage( JoinColumns.class ) ) ) {\n\t\t\tthrow new AnnotationException( \"Association '\"\n\t\t\t\t\t+ qualify( propertyHolder.getPath(), propertyName )\n\t\t\t\t\t+ \"' is 'mappedBy' another entity and may not specify the '@JoinColumn'\" );\n\t\t}\n\n\t\tif ( isMappedBy\n\t\t\t\t&& propertyHolder.getJoinTable( property ) != null ) {\n\t\t\tthrow new AnnotationException( \"Association '\"\n\t\t\t\t\t+ qualify( propertyHolder.getPath(), propertyName )\n\t\t\t\t\t+ \"' is 'mappedBy' another entity and may not specify the '@JoinTable'\" );\n\t\t}\n\n\t\tif ( !isMappedBy\n\t\t\t\t&& oneToMany\n\t\t\t\t&& property.hasDirectAnnotationUsage( OnDelete.class )\n\t\t\t\t&& !property.hasDirectAnnotationUsage( JoinColumn.class )\n\t\t\t\t&& !property.hasDirectAnnotationUsage( JoinColumns.class )) {\n\t\t\tthrow new AnnotationException( \"Unidirectional '@OneToMany' association '\"\n\t\t\t\t\t+ qualify( propertyHolder.getPath(), propertyName )\n\t\t\t\t\t+ \"' is annotated '@OnDelete' and must explicitly specify a '@JoinColumn'\" );\n\t\t}\n\t}\n\n\tprivate void bindProperty() {\n\t\t//property building\n\t\tPropertyBinder binder = new PropertyBinder();\n\t\tbinder.setName( propertyName );\n\t\tbinder.setValue( collection );\n\t\tbinder.setCascade( cascadeStrategy );\n\t\tif ( cascadeStrategy != null && cascadeStrategy.contains( \"delete-orphan\" ) ) {\n\t\t\tcollection.setOrphanDelete( true );\n\t\t}\n\t\tbinder.setLazy( collection.isLazy() );\n\t\tfinal LazyGroup lazyGroupAnnotation = property.getDirectAnnotationUsage( LazyGroup.class );\n\t\tif ( lazyGroupAnnotation != null ) {\n\t\t\tbinder.setLazyGroup( lazyGroupAnnotation.value() );\n\t\t}\n\t\tbinder.setAccessType( accessType );\n\t\tbinder.setMemberDetails( property );\n\t\tbinder.setInsertable( insertable );\n\t\tbinder.setUpdatable( updatable );\n\t\tbinder.setBuildingContext( buildingContext );\n\t\tbinder.setHolder( propertyHolder );\n\t\tProperty prop = binder.makeProperty();\n\t\t//we don't care about the join stuffs because the column is on the association table.\n\t\tif ( !declaringClassSet ) {\n\t\t\tthrow new AssertionFailure( \"DeclaringClass is not set in CollectionBinder while binding\" );\n\t\t}\n\t\tpropertyHolder.addProperty( prop, property, declaringClass );\n\t\tbinder.callAttributeBindersInSecondPass( prop );\n\t}\n\n\t@SuppressWarnings(\"deprecation\")\n\tprivate void bindLoader() {\n\t\t//SQL overriding\n\n\t\tfinal SQLInsert sqlInsert = property.getDirectAnnotationUsage( SQLInsert.class );\n\t\tif ( sqlInsert != null ) {\n\t\t\tcollection.setCustomSQLInsert(\n\t\t\t\t\tsqlInsert.sql().trim(),\n\t\t\t\t\tsqlInsert.callable(),\n\t\t\t\t\tfromResultCheckStyle( sqlInsert.check() )\n\t\t\t);\n\t\t\tfinal Class<? extends Expectation> verifier = sqlInsert.verify();\n\t\t\tif ( !Expectation.class.equals( verifier ) ) {\n\t\t\t\tcollection.setInsertExpectation( getDefaultSupplier( verifier ) );\n\t\t\t}\n\t\t}\n\n\t\tfinal SQLUpdate sqlUpdate = property.getDirectAnnotationUsage( SQLUpdate.class );\n\t\tif ( sqlUpdate != null ) {\n\t\t\tcollection.setCustomSQLUpdate(\n\t\t\t\t\tsqlUpdate.sql().trim(),\n\t\t\t\t\tsqlUpdate.callable(),\n\t\t\t\t\tfromResultCheckStyle( sqlUpdate.check() )\n\t\t\t);\n\t\t\tfinal Class<? extends Expectation> verifier = sqlUpdate.verify();\n\t\t\tif ( !Expectation.class.equals( verifier ) ) {\n\t\t\t\tcollection.setUpdateExpectation( getDefaultSupplier( verifier ) );\n\t\t\t}\n\t\t}\n\n\t\tfinal SQLDelete sqlDelete = property.getDirectAnnotationUsage( SQLDelete.class );\n\t\tif ( sqlDelete != null ) {\n\t\t\tcollection.setCustomSQLDelete(\n\t\t\t\t\tsqlDelete.sql().trim(),\n\t\t\t\t\tsqlDelete.callable(),\n\t\t\t\t\tfromResultCheckStyle( sqlDelete.check() )\n\t\t\t);\n\t\t\tfinal Class<? extends Expectation> verifier = sqlDelete.verify();\n\t\t\tif ( !Expectation.class.equals( verifier ) ) {\n\t\t\t\tcollection.setDeleteExpectation( getDefaultSupplier( verifier ) );\n\t\t\t}\n\t\t}\n\n\t\tfinal SQLDeleteAll sqlDeleteAll = property.getDirectAnnotationUsage( SQLDeleteAll.class );\n\t\tif ( sqlDeleteAll != null ) {\n\t\t\tcollection.setCustomSQLDeleteAll(\n\t\t\t\t\tsqlDeleteAll.sql().trim(),\n\t\t\t\t\tsqlDeleteAll.callable(),\n\t\t\t\t\tfromResultCheckStyle( sqlDeleteAll.check() )\n\t\t\t);\n\t\t\tfinal Class<? extends Expectation> verifier = sqlDeleteAll.verify();\n\t\t\tif ( !Expectation.class.equals( verifier ) ) {\n\t\t\t\tcollection.setDeleteAllExpectation( getDefaultSupplier( verifier ) );\n\t\t\t}\n\t\t}\n\n\t\tfinal SQLSelect sqlSelect = property.getDirectAnnotationUsage( SQLSelect.class );\n\t\tif ( sqlSelect != null ) {\n\t\t\tfinal String loaderName = collection.getRole() + \"$SQLSelect\";\n\t\t\tcollection.setLoaderName( loaderName );\n\t\t\t// TODO: pass in the collection element type here\n\t\t\tQueryBinder.bindNativeQuery( loaderName, sqlSelect, null, buildingContext );\n\t\t}\n\n\t\tfinal HQLSelect hqlSelect = property.getDirectAnnotationUsage( HQLSelect.class );\n\t\tif ( hqlSelect != null ) {\n\t\t\tfinal String loaderName = collection.getRole() + \"$HQLSelect\";\n\t\t\tcollection.setLoaderName( loaderName );\n\t\t\tQueryBinder.bindQuery( loaderName, hqlSelect, buildingContext );\n\t\t}\n\t}\n\n\tprivate void applySortingAndOrdering() {\n\n\t\tif ( naturalSort != null && comparatorSort != null ) {\n\t\t\tthrow buildIllegalSortCombination();\n\t\t}\n\t\tfinal boolean sorted = naturalSort != null || comparatorSort != null;\n\t\tfinal Class<? extends Comparator<?>> comparatorClass;\n\t\tif ( naturalSort != null ) {\n\t\t\tcomparatorClass = null;\n\t\t}\n\t\telse if ( comparatorSort != null ) {\n\t\t\tcomparatorClass = comparatorSort.value();\n\t\t}\n\t\telse {\n\t\t\tcomparatorClass = null;\n\t\t}\n\n\t\tif ( jpaOrderBy != null && ( sqlOrderBy != null || sqlOrder != null ) ) {\n\t\t\tthrow buildIllegalOrderCombination();\n\t\t}\n\t\tboolean ordered = jpaOrderBy != null || sqlOrderBy != null || sqlOrder != null ;\n\t\tif ( ordered ) {\n\t\t\t// we can only apply the sql-based order by up front.  The jpa order by has to wait for second pass\n\t\t\tif ( sqlOrderBy != null ) {\n\t\t\t\tcollection.setOrderBy( sqlOrderBy.clause() );\n\t\t\t}\n\t\t\tif ( sqlOrder != null ) {\n\t\t\t\tcollection.setOrderBy( sqlOrder.value() );\n\t\t\t}\n\t\t}\n\n\t\tfinal boolean isSorted = isSortedCollection || sorted;\n\t\tif ( isSorted && ordered ) {\n\t\t\tthrow buildIllegalOrderAndSortCombination();\n\t\t}\n\t\tcollection.setSorted( isSorted );\n\t\tinstantiateComparator( collection, comparatorClass );\n\t}\n\n\tprivate void instantiateComparator(Collection collection, Class<? extends Comparator<?>> comparatorClass) {\n\t\tif ( comparatorClass != null ) {\n\t\t\ttry {\n\t\t\t\tcollection.setComparator( comparatorClass.newInstance() );\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tthrow new AnnotationException(\n\t\t\t\t\t\tString.format(\n\t\t\t\t\t\t\t\t\"Could not instantiate comparator class '%s' for collection '%s'\",\n\t\t\t\t\t\t\t\tcomparatorClass.getName(),\n\t\t\t\t\t\t\t\tsafeCollectionRole()\n\t\t\t\t\t\t),\n\t\t\t\t\t\te\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate AnnotationException buildIllegalOrderCombination() {\n\t\treturn new AnnotationException(\n\t\t\t\tString.format(\n\t\t\t\t\t\tLocale.ROOT,\n\t\t\t\t\t\t\"Collection '%s' is annotated both '@%s' and '@%s'\",\n\t\t\t\t\t\tsafeCollectionRole(),\n\t\t\t\t\t\tjakarta.persistence.OrderBy.class.getName(),\n\t\t\t\t\t\torg.hibernate.annotations.OrderBy.class.getName()\n\t\t\t\t)\n\t\t);\n\t}\n\n\tprivate AnnotationException buildIllegalOrderAndSortCombination() {\n\t\tthrow new AnnotationException(\n\t\t\t\tString.format(\n\t\t\t\t\t\tLocale.ROOT,\n\t\t\t\t\t\t\"Collection '%s' is both sorted and ordered (only one of '@%s', '@%s', '@%s', and '@%s' may be used)\",\n\t\t\t\t\t\tsafeCollectionRole(),\n\t\t\t\t\t\tjakarta.persistence.OrderBy.class.getName(),\n\t\t\t\t\t\torg.hibernate.annotations.OrderBy.class.getName(),\n\t\t\t\t\t\tSortComparator.class.getName(),\n\t\t\t\t\t\tSortNatural.class.getName()\n\t\t\t\t)\n\t\t);\n\t}\n\n\tprivate AnnotationException buildIllegalSortCombination() {\n\t\treturn new AnnotationException(\n\t\t\t\tString.format(\n\t\t\t\t\t\t\"Collection '%s' is annotated both '@%s' and '@%s'\",\n\t\t\t\t\t\tsafeCollectionRole(),\n\t\t\t\t\t\tSortNatural.class.getName(),\n\t\t\t\t\t\tSortComparator.class.getName()\n\t\t\t\t)\n\t\t);\n\t}\n\n\tprivate void defineFetchingStrategy() {\n\t\thandleLazy();\n\t\thandleFetch();\n\t\thandleFetchProfileOverrides();\n\t}\n\n\tprivate SourceModelBuildingContext sourceModelContext() {\n\t\treturn buildingContext.getMetadataCollector().getSourceModelBuildingContext();\n\t}\n\n\tprivate void handleFetchProfileOverrides() {\n\t\tproperty.forEachAnnotationUsage( FetchProfileOverride.class, sourceModelContext(), (usage) -> {\n\t\t\tbuildingContext.getMetadataCollector().addSecondPass( new FetchSecondPass(\n\t\t\t\t\tusage,\n\t\t\t\t\tpropertyHolder,\n\t\t\t\t\tpropertyName,\n\t\t\t\t\tbuildingContext\n\t\t\t) );\n\t\t} );\n\t}\n\n\tprivate void handleFetch() {\n\t\tfinal Fetch fetchAnnotation = property.getDirectAnnotationUsage( Fetch.class );\n\t\tif ( fetchAnnotation != null ) {\n\t\t\t// Hibernate @Fetch annotation takes precedence\n\t\t\tsetHibernateFetchMode( fetchAnnotation.value() );\n\t\t}\n\t\telse {\n\t\t\tcollection.setFetchMode( getFetchMode( getJpaFetchType() ) );\n\t\t}\n\t}\n\n\tprivate void setHibernateFetchMode(org.hibernate.annotations.FetchMode fetchMode) {\n\t\tswitch ( fetchMode ) {\n\t\t\tcase JOIN -> {\n\t\t\t\tcollection.setFetchMode( FetchMode.JOIN );\n\t\t\t\tcollection.setLazy( false );\n\t\t\t}\n\t\t\tcase SELECT -> {\n\t\t\t\tcollection.setFetchMode( FetchMode.SELECT );\n\t\t\t}\n\t\t\tcase SUBSELECT -> {\n\t\t\t\tcollection.setFetchMode( FetchMode.SELECT );\n\t\t\t\tcollection.setSubselectLoadable( true );\n\t\t\t\tcollection.getOwner().setSubselectLoadableCollections( true );\n\t\t\t}\n\t\t\tdefault -> {\n\t\t\t\tthrow new AssertionFailure( \"unknown fetch type\" );\n\t\t\t}\n\t\t}\n\t}\n\n\t@SuppressWarnings(\"deprecation\")\n\tprivate void handleLazy() {\n\t\tfinal FetchType jpaFetchType = getJpaFetchType();\n\t\tcollection.setLazy( jpaFetchType == LAZY );\n\t\tcollection.setExtraLazy( false );\n\t}\n\n\tprivate FetchType getJpaFetchType() {\n\t\tfinal OneToMany oneToMany = property.getDirectAnnotationUsage( OneToMany.class );\n\t\tfinal ManyToMany manyToMany = property.getDirectAnnotationUsage( ManyToMany.class );\n\t\tfinal ElementCollection elementCollection = property.getDirectAnnotationUsage( ElementCollection.class );\n\t\tfinal ManyToAny manyToAny = property.getDirectAnnotationUsage( ManyToAny.class );\n\t\tif ( oneToMany != null ) {\n\t\t\treturn oneToMany.fetch();\n\t\t}\n\n\t\tif ( manyToMany != null ) {\n\t\t\treturn manyToMany.fetch();\n\t\t}\n\n\t\tif ( elementCollection != null ) {\n\t\t\treturn elementCollection.fetch();\n\t\t}\n\n\t\tif ( manyToAny != null ) {\n\t\t\treturn LAZY;\n\t\t}\n\n\t\tthrow new AssertionFailure(\n\t\t\t\t\"Define fetch strategy on a property not annotated with @ManyToOne nor @OneToMany nor @CollectionOfElements\"\n\t\t);\n\t}\n\n\tTypeDetails getElementType() {\n\t\tif ( isDefault( targetEntity ) ) {\n\t\t\tif ( collectionElementType != null ) {\n\t\t\t\treturn collectionElementType;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new AnnotationException( \"Collection '\" + safeCollectionRole()\n\t\t\t\t\t\t+ \"' is declared with a raw type and has an explicit 'targetEntity'\" );\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\treturn targetEntity;\n\t\t}\n\t}\n\n\tSecondPass getSecondPass() {\n\t\treturn new CollectionSecondPass( collection ) {\n\t\t\t@Override\n\t\t\tpublic void secondPass(Map<String, PersistentClass> persistentClasses) throws MappingException {\n\t\t\t\tbindStarToManySecondPass( persistentClasses );\n\t\t\t}\n\t\t};\n\t}\n\n\t/**\n\t * return true if it's a Fk, false if it's an association table\n\t */\n\tprotected boolean bindStarToManySecondPass(Map<String, PersistentClass> persistentClasses) {\n\t\tif ( noAssociationTable( persistentClasses ) ) {\n\t\t\t//this is a foreign key\n\t\t\tbindOneToManySecondPass( persistentClasses );\n\t\t\treturn true;\n\t\t}\n\t\telse {\n\t\t\t//this is an association table\n\t\t\tbindManyToManySecondPass( persistentClasses );\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tprivate boolean isReversePropertyInJoin(\n\t\t\tTypeDetails elementType,\n\t\t\tPersistentClass persistentClass,\n\t\t\tMap<String, PersistentClass> persistentClasses) {\n\t\tif ( persistentClass != null && isUnownedCollection() ) {\n\t\t\tfinal Property mappedByProperty;\n\t\t\ttry {\n\t\t\t\tmappedByProperty = persistentClass.getRecursiveProperty( mappedBy );\n\t\t\t}\n\t\t\tcatch (MappingException e) {\n\t\t\t\tthrow new AnnotationException(\n\t\t\t\t\t\t\"Collection '\" + safeCollectionRole()\n\t\t\t\t\t\t\t\t+ \"' is 'mappedBy' a property named '\" + mappedBy\n\t\t\t\t\t\t\t\t+ \"' which does not exist in the target entity '\" + elementType.getName() + \"'\"\n\t\t\t\t);\n\t\t\t}\n\t\t\tcheckMappedByType( mappedBy, mappedByProperty.getValue(), propertyName, propertyHolder, persistentClasses );\n\t\t\treturn persistentClass.getJoinNumber( mappedByProperty ) != 0;\n\t\t}\n\t\telse {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tprivate boolean noAssociationTable(Map<String, PersistentClass> persistentClasses) {\n\t\tfinal PersistentClass persistentClass = persistentClasses.get( getElementType().getName() );\n\t\treturn persistentClass != null\n\t\t\t&& !isReversePropertyInJoin( getElementType(), persistentClass, persistentClasses )\n\t\t\t&& oneToMany\n\t\t\t&& !isExplicitAssociationTable\n\t\t\t&& ( implicitJoinColumn() || explicitForeignJoinColumn() );\n\t}\n\n\tprivate boolean implicitJoinColumn() {\n\t\treturn joinColumns.getJoinColumns().get(0).isImplicit()\n\t\t\t&& isUnownedCollection(); //implicit @JoinColumn\n\t}\n\n\tprivate boolean explicitForeignJoinColumn() {\n\t\treturn !foreignJoinColumns.getJoinColumns().get(0).isImplicit(); //this is an explicit @JoinColumn\n\t}\n\n\t/**\n\t * Bind a {@link OneToMany} association.\n\t */\n\tprotected void bindOneToManySecondPass(Map<String, PersistentClass> persistentClasses) {\n\t\tif ( property == null ) {\n\t\t\tthrow new AssertionFailure( \"null was passed for argument property\" );\n\t\t}\n\n\t\tlogOneToManySecondPass();\n\n\t\tfinal org.hibernate.mapping.OneToMany oneToMany =\n\t\t\t\tnew org.hibernate.mapping.OneToMany( buildingContext, getCollection().getOwner() );\n\t\tcollection.setElement( oneToMany );\n\t\toneToMany.setReferencedEntityName( getElementType().getName() );\n\t\toneToMany.setNotFoundAction( notFoundAction );\n\n\t\tfinal String referencedEntityName = oneToMany.getReferencedEntityName();\n\t\tfinal PersistentClass associatedClass = persistentClasses.get( referencedEntityName );\n\t\thandleJpaOrderBy( collection, associatedClass );\n\t\tif ( associatedClass == null ) {\n\t\t\tthrow new MappingException(\n\t\t\t\t\tString.format( \"Association [%s] for entity [%s] references unmapped class [%s]\",\n\t\t\t\t\t\t\tpropertyName, propertyHolder.getClassName(), referencedEntityName )\n\t\t\t);\n\t\t}\n\t\toneToMany.setAssociatedClass( associatedClass );\n\n\t\tfinal Map<String, Join> joins = buildingContext.getMetadataCollector().getJoins( referencedEntityName );\n\t\tforeignJoinColumns.setPropertyHolder( buildPropertyHolder(\n\t\t\t\tassociatedClass,\n\t\t\t\tjoins,\n\t\t\t\tforeignJoinColumns.getBuildingContext(),\n\t\t\t\tinheritanceStatePerClass\n\t\t) );\n\t\tforeignJoinColumns.setJoins( joins );\n\t\tif ( foreignJoinColumns.hasMappedBy() ) {\n\t\t\tcollection.setCollectionTable( associatedClass.getRecursiveProperty( foreignJoinColumns.getMappedBy() ).getValue().getTable() );\n\t\t}\n\t\telse {\n\t\t\tcollection.setCollectionTable( foreignJoinColumns.getTable() );\n\t\t}\n\t\tif ( LOG.isDebugEnabled() ) {\n\t\t\tLOG.debugf( \"Mapping collection: %s -> %s\", collection.getRole(), collection.getCollectionTable().getName() );\n\t\t}\n\n\t\tbindSynchronize();\n\t\tbindFilters( false );\n\t\thandleWhere( false );\n\n\t\tfinal PersistentClass targetEntity = persistentClasses.get( getElementType().getName() );\n\t\tbindCollectionSecondPass( targetEntity, foreignJoinColumns );\n\n\t\tif ( !collection.isInverse() && !collection.getKey().isNullable() ) {\n\t\t\tcreateOneToManyBackref( oneToMany );\n\t\t}\n\t}\n\n\tprivate void createOneToManyBackref(org.hibernate.mapping.OneToMany oneToMany) {\n\t\tfinal InFlightMetadataCollector collector = buildingContext.getMetadataCollector();\n\t\t// for non-inverse one-to-many, with a not-null fk, add a backref!\n\t\tfinal String entityName = oneToMany.getReferencedEntityName();\n\t\tfinal PersistentClass referenced = collector.getEntityBinding( entityName );\n\t\tfinal Backref backref = new Backref();\n\t\tfinal String backrefName = '_' + foreignJoinColumns.getPropertyName()\n\t\t\t\t+ '_' + foreignJoinColumns.getColumns().get(0).getLogicalColumnName()\n\t\t\t\t+ \"Backref\";\n\t\tbackref.setName( backrefName );\n\t\tbackref.setOptional( true );\n\t\tbackref.setUpdateable( false);\n\t\tbackref.setSelectable( false );\n\t\tbackref.setCollectionRole( collection.getRole() );\n\t\tbackref.setEntityName( collection.getOwner().getEntityName() );\n\t\tbackref.setValue( collection.getKey() );\n\t\treferenced.addProperty( backref );\n\t}\n\n\tprivate void handleJpaOrderBy(Collection collection, PersistentClass associatedClass) {\n\t\tif ( jpaOrderBy != null ) {\n\t\t\tfinal String orderByFragment = buildOrderByClauseFromHql( jpaOrderBy.value(), associatedClass );\n\t\t\tif ( isNotEmpty( orderByFragment ) ) {\n\t\t\t\tcollection.setOrderBy( orderByFragment );\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate void bindSynchronize() {\n\t\tfinal Synchronize synchronizeAnnotation = property.getDirectAnnotationUsage( Synchronize.class );\n\t\tif ( synchronizeAnnotation != null ) {\n\t\t\tfinal JdbcEnvironment jdbcEnvironment = buildingContext.getMetadataCollector().getDatabase().getJdbcEnvironment();\n\t\t\tfor ( String table : synchronizeAnnotation.value() ) {\n\t\t\t\tString physicalName = synchronizeAnnotation.logical()\n\t\t\t\t\t\t? toPhysicalName( jdbcEnvironment, table )\n\t\t\t\t\t\t: table;\n\t\t\t\tcollection.addSynchronizedTable( physicalName );\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate String toPhysicalName(JdbcEnvironment jdbcEnvironment, String logicalName) {\n\t\treturn buildingContext.getBuildingOptions().getPhysicalNamingStrategy()\n\t\t\t\t.toPhysicalTableName(\n\t\t\t\t\t\tjdbcEnvironment.getIdentifierHelper().toIdentifier( logicalName ),\n\t\t\t\t\t\tjdbcEnvironment\n\t\t\t\t)\n\t\t\t\t.render( jdbcEnvironment.getDialect() );\n\t}\n\n\tprivate void bindFilters(boolean hasAssociationTable) {\n\t\tproperty.forEachAnnotationUsage( Filter.class, sourceModelContext(), (usage) -> {\n\t\t\taddFilter( hasAssociationTable, usage );\n\t\t} );\n\n\t\tproperty.forEachAnnotationUsage( FilterJoinTable.class, sourceModelContext(), (usage) -> {\n\t\t\taddFilterJoinTable( hasAssociationTable, usage );\n\t\t} );\n\t}\n\n\tprivate void addFilter(boolean hasAssociationTable, Filter filterAnnotation) {\n\t\tfinal Map<String,String> aliasTableMap = new HashMap<>();\n\t\tfinal Map<String,String> aliasEntityMap = new HashMap<>();\n\t\tfinal SqlFragmentAlias[] aliasAnnotations = filterAnnotation.aliases();\n\t\tfor ( SqlFragmentAlias aliasAnnotation : aliasAnnotations ) {\n\t\t\tfinal String alias = aliasAnnotation.alias();\n\n\t\t\tfinal String table = aliasAnnotation.table();\n\t\t\tif ( isNotEmpty( table ) ) {\n\t\t\t\taliasTableMap.put( alias, table );\n\t\t\t}\n\n\t\t\tfinal Class<?> entityClassDetails = aliasAnnotation.entity();\n\t\t\tif ( entityClassDetails != void.class ) {\n\t\t\t\taliasEntityMap.put( alias, entityClassDetails.getName() );\n\t\t\t}\n\t\t}\n\n\t\tif ( hasAssociationTable ) {\n\t\t\tcollection.addManyToManyFilter(\n\t\t\t\t\tfilterAnnotation.name(),\n\t\t\t\t\tgetFilterCondition( filterAnnotation ),\n\t\t\t\t\tfilterAnnotation.deduceAliasInjectionPoints(),\n\t\t\t\t\taliasTableMap,\n\t\t\t\t\taliasEntityMap\n\t\t\t);\n\t\t}\n\t\telse {\n\t\t\tcollection.addFilter(\n\t\t\t\t\tfilterAnnotation.name(),\n\t\t\t\t\tgetFilterCondition( filterAnnotation ),\n\t\t\t\t\tfilterAnnotation.deduceAliasInjectionPoints(),\n\t\t\t\t\taliasTableMap,\n\t\t\t\t\taliasEntityMap\n\t\t\t);\n\t\t}\n\t}\n\n\tprivate void handleWhere(boolean hasAssociationTable) {\n\t\tfinal String whereClause = getWhereClause();\n\t\tif ( hasAssociationTable ) {\n\t\t\t// A many-to-many association has an association (join) table\n\t\t\t// Collection#setManytoManyWhere is used to set the \"where\" clause that applies\n\t\t\t// to the many-to-many associated entity table (not the join table).\n\t\t\tcollection.setManyToManyWhere( whereClause );\n\t\t}\n\t\telse {\n\t\t\t// A one-to-many association does not have an association (join) table.\n\t\t\t// Collection#setWhere is used to set the \"where\" clause that applies to the collection table\n\t\t\t// (which is the associated entity table for a one-to-many association).\n\t\t\tcollection.setWhere( whereClause );\n\t\t}\n\n\t\tfinal String whereJoinTableClause = getWhereJoinTableClause();\n\t\tif ( isNotEmpty( whereJoinTableClause ) ) {\n\t\t\tif ( hasAssociationTable ) {\n\t\t\t\t// This is a many-to-many association.\n\t\t\t\t// Collection#setWhere is used to set the \"where\" clause that applies to the collection table\n\t\t\t\t// (which is the join table for a many-to-many association).\n\t\t\t\tcollection.setWhere( whereJoinTableClause );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new AnnotationException(\n\t\t\t\t\t\t\"Collection '\" + qualify( propertyHolder.getPath(), propertyName )\n\t\t\t\t\t\t\t\t+ \"' is an association with no join table and may not have a 'WhereJoinTable'\"\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate String getWhereJoinTableClause() {\n\t\tfinal SQLJoinTableRestriction joinTableRestriction = property.getDirectAnnotationUsage( SQLJoinTableRestriction.class );\n\t\treturn joinTableRestriction != null ? joinTableRestriction.value() : null;\n\t}\n\n\tprivate String getWhereClause() {\n\t\t// There are 2 possible sources of \"where\" clauses that apply to the associated entity table:\n\t\t// 1) from the associated entity mapping; i.e., @Entity @Where(clause=\"...\")\n\t\t//    (ignored if useEntityWhereClauseForCollections == false)\n\t\t// 2) from the collection mapping;\n\t\t//    for one-to-many, e.g., @OneToMany @JoinColumn @Where(clause=\"...\") public Set<Rating> getRatings();\n\t\t//    for many-to-many e.g., @ManyToMany @Where(clause=\"...\") public Set<Rating> getRatings();\n\t\treturn getNonEmptyOrConjunctionIfBothNonEmpty( getWhereOnClassClause(), getWhereOnCollectionClause() );\n\t}\n\n\tprivate String getWhereOnCollectionClause() {\n\t\tfinal SQLRestriction restrictionOnCollection = getOverridableAnnotation( property, SQLRestriction.class, getBuildingContext() );\n\t\treturn restrictionOnCollection != null ? restrictionOnCollection.value() : null;\n\t}\n\n\tprivate String getWhereOnClassClause() {\n\t\tfinal TypeDetails elementType = property.getElementType();\n\t\tfinal SQLRestriction restrictionOnClass = getOverridableAnnotation(\n\t\t\t\tproperty.getAssociatedType().determineRawClass(),\n\t\t\t\tSQLRestriction.class,\n\t\t\t\tbuildingContext\n\t\t);\n\t\treturn restrictionOnClass != null ? restrictionOnClass.value() : null;\n\t}\n\n\tprivate void addFilterJoinTable(boolean hasAssociationTable, FilterJoinTable filter) {\n\t\tif ( hasAssociationTable ) {\n\t\t\tfinal Map<String,String> aliasTableMap = new HashMap<>();\n\t\t\tfinal Map<String,String> aliasEntityMap = new HashMap<>();\n\t\t\tfinal SqlFragmentAlias[] aliasAnnotations = filter.aliases();\n\t\t\tfor ( SqlFragmentAlias aliasAnnotation : aliasAnnotations ) {\n\t\t\t\tfinal String alias = aliasAnnotation.alias();\n\n\t\t\t\tfinal String table = aliasAnnotation.table();\n\t\t\t\tif ( isNotEmpty( table ) ) {\n\t\t\t\t\taliasTableMap.put( alias, table );\n\t\t\t\t}\n\n\t\t\t\tfinal Class<?> entityClassDetails = aliasAnnotation.entity();\n\t\t\t\tif ( entityClassDetails != void.class ) {\n\t\t\t\t\taliasEntityMap.put( alias, entityClassDetails.getName() );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcollection.addFilter(\n\t\t\t\t\tfilter.name(),\n\t\t\t\t\tgetFilterConditionForJoinTable( filter ),\n\t\t\t\t\tfilter.deduceAliasInjectionPoints(),\n\t\t\t\t\taliasTableMap,\n\t\t\t\t\taliasEntityMap\n\t\t\t);\n\t\t}\n\t\telse {\n\t\t\tthrow new AnnotationException( \"Collection '\" + qualify( propertyHolder.getPath(), propertyName )\n\t\t\t\t\t+ \"' is an association with no join table and may not have a '@FilterJoinTable'\" );\n\t\t}\n\t}\n\n\tprivate String getFilterConditionForJoinTable(FilterJoinTable filterJoinTableAnnotation) {\n\t\tfinal String condition = filterJoinTableAnnotation.condition();\n\t\treturn condition.isEmpty()\n\t\t\t\t? getDefaultFilterCondition( filterJoinTableAnnotation.name(), filterJoinTableAnnotation )\n\t\t\t\t: condition;\n\t}\n\n\tprivate String getFilterCondition(Filter filter) {\n\t\tfinal String condition = filter.condition();\n\t\treturn condition.isEmpty()\n\t\t\t\t? getDefaultFilterCondition( filter.name(), filter )\n\t\t\t\t: condition;\n\t}\n\n\tprivate String getDefaultFilterCondition(String name, Annotation annotation) {\n\t\tfinal FilterDefinition definition = buildingContext.getMetadataCollector().getFilterDefinition( name );\n\t\tif ( definition == null ) {\n\t\t\tthrow new AnnotationException( \"Collection '\" + qualify( propertyHolder.getPath(), propertyName )\n\t\t\t\t\t+ \"' has a '@\" + annotation.annotationType().getSimpleName()\n\t\t\t\t\t+ \"' for an undefined filter named '\" + name + \"'\" );\n\t\t}\n\t\tfinal String defaultCondition = definition.getDefaultFilterCondition();\n\t\tif ( isEmpty( defaultCondition ) ) {\n\t\t\tthrow new AnnotationException( \"Collection '\" + qualify( propertyHolder.getPath(), propertyName ) +\n\t\t\t\t\t\"' has a '@\"  + annotation.annotationType().getSimpleName()\n\t\t\t\t\t+ \"' with no 'condition' and no default condition was given by the '@FilterDef' named '\"\n\t\t\t\t\t+ name + \"'\" );\n\t\t}\n\t\treturn defaultCondition;\n\t}\n\n\tpublic void setCache(Cache cache) {\n\t\tif ( cache != null ) {\n\t\t\tcacheRegionName = nullIfEmpty( cache.region() );\n\t\t\tcacheConcurrencyStrategy = EntityBinder.getCacheConcurrencyStrategy( cache.usage() );\n\t\t}\n\t\telse {\n\t\t\tcacheConcurrencyStrategy = null;\n\t\t\tcacheRegionName = null;\n\t\t}\n\t}\n\n\tpublic void setQueryCacheLayout(QueryCacheLayout queryCacheLayout) {\n\t\tthis.queryCacheLayout = queryCacheLayout == null ? null : queryCacheLayout.layout();\n\t}\n\n\tpublic void setOneToMany(boolean oneToMany) {\n\t\tthis.oneToMany = oneToMany;\n\t}\n\n\tpublic void setIndexColumn(IndexColumn indexColumn) {\n\t\tthis.indexColumn = indexColumn;\n\t}\n\n\tpublic void setMapKey(MapKey key) {\n\t\thasMapKeyProperty = key != null;\n\t\tif ( hasMapKeyProperty ) {\n\t\t\tmapKeyPropertyName = nullIfEmpty( key.name() );\n\t\t}\n\t}\n\n\tprivate static String buildOrderByClauseFromHql(String orderByFragment, PersistentClass associatedClass) {\n\t\tif ( orderByFragment == null ) {\n\t\t\treturn null;\n\t\t}\n\t\telse if ( orderByFragment.isEmpty() ) {\n\t\t\t//order by id\n\t\t\treturn buildOrderById( associatedClass, \" asc\" );\n\t\t}\n\t\telse if ( \"desc\".equalsIgnoreCase( orderByFragment ) ) {\n\t\t\treturn buildOrderById( associatedClass, \" desc\" );\n\t\t}\n\t\telse {\n\t\t\treturn orderByFragment;\n\t\t}\n\t}\n\n\tprivate static String buildOrderById(PersistentClass associatedClass, String order) {\n\t\tfinal StringBuilder sb = new StringBuilder();\n\t\tfor ( Selectable selectable: associatedClass.getIdentifier().getSelectables() ) {\n\t\t\tsb.append( selectable.getText() );\n\t\t\tsb.append( order );\n\t\t\tsb.append( \", \" );\n\t\t}\n\t\tsb.setLength( sb.length() - 2 );\n\t\treturn sb.toString();\n\t}\n\n\tpublic static String adjustUserSuppliedValueCollectionOrderingFragment(String orderByFragment) {\n\t\tif ( orderByFragment != null ) {\n\t\t\torderByFragment = orderByFragment.trim();\n\t\t\tif ( orderByFragment.length() == 0 || orderByFragment.equalsIgnoreCase( \"asc\" ) ) {\n\t\t\t\t// This indicates something like either:\n\t\t\t\t//\t\t`@OrderBy()`\n\t\t\t\t//\t\t`@OrderBy(\"asc\")\n\t\t\t\t//\n\t\t\t\t// JPA says this should indicate an ascending natural ordering of the elements - id for\n\t\t\t\t//\t\tentity associations or the value(s) for \"element collections\"\n\t\t\t\treturn \"$element$ asc\";\n\t\t\t}\n\t\t\telse if ( orderByFragment.equalsIgnoreCase( \"desc\" ) ) {\n\t\t\t\t// This indicates:\n\t\t\t\t//\t\t`@OrderBy(\"desc\")`\n\t\t\t\t//\n\t\t\t\t// JPA says this should indicate a descending natural ordering of the elements - id for\n\t\t\t\t//\t\tentity associations or the value(s) for \"element collections\"\n\t\t\t\treturn \"$element$ desc\";\n\t\t\t}\n\t\t}\n\n\t\treturn orderByFragment;\n\t}\n\n\tprivate DependantValue buildCollectionKey(AnnotatedJoinColumns joinColumns, OnDeleteAction onDeleteAction) {\n\n\t\tfinal boolean noConstraintByDefault = buildingContext.getBuildingOptions().isNoConstraintByDefault();\n\n\t\t// give a chance to override the referenced property name\n\t\t// has to do that here because the referencedProperty creation happens in a FKSecondPass for ManyToOne yuk!\n\t\toverrideReferencedPropertyName( collection, joinColumns );\n\n\t\tfinal String referencedPropertyName = collection.getReferencedPropertyName();\n\t\t//binding key reference using column\n\t\tfinal PersistentClass owner = collection.getOwner();\n\t\tfinal KeyValue keyValue = referencedPropertyName == null\n\t\t\t\t? owner.getIdentifier()\n\t\t\t\t: (KeyValue) owner.getReferencedProperty( referencedPropertyName ).getValue();\n\n\t\tfinal DependantValue key = new DependantValue( buildingContext, collection.getCollectionTable(), keyValue );\n\t\tkey.setTypeName( null );\n\t\tjoinColumns.checkPropertyConsistency();\n\t\tfinal List<AnnotatedColumn> columns = joinColumns.getColumns();\n\t\tkey.setNullable( columns.isEmpty() || columns.get(0).isNullable() );\n\t\tkey.setUpdateable( columns.isEmpty() || columns.get(0).isUpdatable() );\n\t\tkey.setOnDeleteAction( onDeleteAction );\n\t\tcollection.setKey( key );\n\n\t\tif ( property != null ) {\n\t\t\tfinal CollectionTable collectionTableAnn = property.getDirectAnnotationUsage( CollectionTable.class );\n\t\t\tif ( collectionTableAnn != null ) {\n\t\t\t\tfinal ForeignKey foreignKey = collectionTableAnn.foreignKey();\n\t\t\t\tfinal ConstraintMode constraintMode = foreignKey.value();\n\t\t\t\tif ( constraintMode == NO_CONSTRAINT\n\t\t\t\t\t\t|| constraintMode == PROVIDER_DEFAULT && noConstraintByDefault ) {\n\t\t\t\t\tkey.disableForeignKey();\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tkey.setForeignKeyName( nullIfEmpty( foreignKey.name() ) );\n\t\t\t\t\tkey.setForeignKeyDefinition( nullIfEmpty( foreignKey.foreignKeyDefinition() ) );\n\t\t\t\t\tif ( key.getForeignKeyName() == null\n\t\t\t\t\t\t\t&& key.getForeignKeyDefinition() == null\n\t\t\t\t\t\t\t&& collectionTableAnn.joinColumns().length == 1 ) {\n\t\t\t\t\t\t//noinspection unchecked\n\t\t\t\t\t\tfinal JoinColumn joinColumn = collectionTableAnn.joinColumns()[0];\n\t\t\t\t\t\tfinal ForeignKey nestedForeignKey = joinColumn.foreignKey();\n\t\t\t\t\t\tkey.setForeignKeyName( nullIfEmpty( nestedForeignKey.name() ) );\n\t\t\t\t\t\tkey.setForeignKeyDefinition( nullIfEmpty( nestedForeignKey.foreignKeyDefinition() ) );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfinal JoinTable joinTableAnn = property.getDirectAnnotationUsage( JoinTable.class );\n\t\t\t\tif ( joinTableAnn != null ) {\n\t\t\t\t\tfinal ForeignKey foreignKey = joinTableAnn.foreignKey();\n\t\t\t\t\tString foreignKeyName = foreignKey.name();\n\t\t\t\t\tString foreignKeyDefinition = foreignKey.foreignKeyDefinition();\n\t\t\t\t\tConstraintMode foreignKeyValue = foreignKey.value();\n\t\t\t\t\tfinal JoinColumn[] joinColumnAnnotations = joinTableAnn.joinColumns();\n\t\t\t\t\tif ( !ArrayHelper.isEmpty( joinColumnAnnotations ) ) {\n\t\t\t\t\t\tfinal JoinColumn joinColumnAnn = joinColumnAnnotations[0];\n\t\t\t\t\t\tfinal ForeignKey joinColumnForeignKey = joinColumnAnn.foreignKey();\n\t\t\t\t\t\tif ( foreignKeyName.isEmpty() ) {\n\t\t\t\t\t\t\tforeignKeyName = joinColumnForeignKey.name();\n\t\t\t\t\t\t\tforeignKeyDefinition = joinColumnForeignKey.foreignKeyDefinition();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( foreignKeyValue != NO_CONSTRAINT ) {\n\t\t\t\t\t\t\tforeignKeyValue = joinColumnForeignKey.value();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif ( foreignKeyValue == NO_CONSTRAINT\n\t\t\t\t\t\t\t|| foreignKeyValue == PROVIDER_DEFAULT && noConstraintByDefault ) {\n\t\t\t\t\t\tkey.disableForeignKey();\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tkey.setForeignKeyName( nullIfEmpty( foreignKeyName ) );\n\t\t\t\t\t\tkey.setForeignKeyDefinition( nullIfEmpty( foreignKeyDefinition ) );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tfinal String propertyPath = qualify( propertyHolder.getPath(), property.getName() );\n\t\t\t\t\tfinal ForeignKey foreignKey = propertyHolder.getOverriddenForeignKey( propertyPath );\n\t\t\t\t\tif ( foreignKey != null ) {\n\t\t\t\t\t\thandleForeignKeyConstraint( noConstraintByDefault, key, foreignKey );\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tfinal OneToMany oneToManyAnn = property.getDirectAnnotationUsage( OneToMany.class );\n\t\t\t\t\t\tfinal OnDelete onDeleteAnn = property.getDirectAnnotationUsage( OnDelete.class );\n\t\t\t\t\t\tif ( oneToManyAnn != null\n\t\t\t\t\t\t\t\t&& !oneToManyAnn.mappedBy().isEmpty()\n\t\t\t\t\t\t\t\t&& ( onDeleteAnn == null || onDeleteAnn.action() != OnDeleteAction.CASCADE ) ) {\n\t\t\t\t\t\t\t// foreign key should be up to @ManyToOne side\n\t\t\t\t\t\t\t// @OnDelete generate \"on delete cascade\" foreign key\n\t\t\t\t\t\t\tkey.disableForeignKey();\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tfinal JoinColumn joinColumnAnn = property.getDirectAnnotationUsage( JoinColumn.class );\n\t\t\t\t\t\t\tif ( joinColumnAnn != null ) {\n\t\t\t\t\t\t\t\thandleForeignKeyConstraint( noConstraintByDefault, key, joinColumnAnn.foreignKey() );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn key;\n\t}\n\n\tprivate static void handleForeignKeyConstraint(\n\t\t\tboolean noConstraintByDefault,\n\t\t\tDependantValue key,\n\t\t\tForeignKey foreignKey) {\n\t\tfinal ConstraintMode constraintMode = foreignKey.value();\n\t\tif ( constraintMode == NO_CONSTRAINT\n\t\t\t\t|| constraintMode == PROVIDER_DEFAULT && noConstraintByDefault) {\n\t\t\tkey.disableForeignKey();\n\t\t}\n\t\telse {\n\t\t\tkey.setForeignKeyName( nullIfEmpty( foreignKey.name() ) );\n\t\t\tkey.setForeignKeyDefinition( nullIfEmpty( foreignKey.foreignKeyDefinition() ) );\n\t\t}\n\t}\n\n\tprivate void overrideReferencedPropertyName(Collection collection, AnnotatedJoinColumns joinColumns) {\n\t\tif ( isUnownedCollection() && !joinColumns.getColumns().isEmpty() ) {\n\t\t\tfinal String entityName = joinColumns.getManyToManyOwnerSideEntityName() != null\n\t\t\t\t\t? \"inverse__\" + joinColumns.getManyToManyOwnerSideEntityName()\n\t\t\t\t\t: joinColumns.getPropertyHolder().getEntityName();\n\t\t\tfinal InFlightMetadataCollector collector = buildingContext.getMetadataCollector();\n\t\t\tfinal String referencedProperty = collector.getPropertyReferencedAssociation( entityName, mappedBy );\n\t\t\tif ( referencedProperty != null ) {\n\t\t\t\tcollection.setReferencedPropertyName( referencedProperty );\n\t\t\t\tcollector.addPropertyReference( collection.getOwnerEntityName(), referencedProperty );\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Bind a {@link ManyToMany} association or {@link ElementCollection}.\n\t */\n\tprivate void bindManyToManySecondPass(Map<String, PersistentClass> persistentClasses) throws MappingException {\n\t\tif ( property == null ) {\n\t\t\tthrow new AssertionFailure( \"null was passed for argument property\" );\n\t\t}\n\n\t\tfinal TypeDetails elementType = getElementType();\n\t\tfinal PersistentClass targetEntity = persistentClasses.get( elementType.getName() ); //null if this is an @ElementCollection\n\t\tfinal String hqlOrderBy = extractHqlOrderBy( jpaOrderBy );\n\n\t\tfinal boolean isCollectionOfEntities = targetEntity != null;\n\t\tfinal boolean isManyToAny = property.hasDirectAnnotationUsage( ManyToAny.class );\n\n\t\tlogManyToManySecondPass( oneToMany, isCollectionOfEntities, isManyToAny );\n\n\t\t//check for user error\n\t\tdetectManyToManyProblems( elementType, isCollectionOfEntities, isManyToAny );\n\n\t\tif ( isUnownedCollection() ) {\n\t\t\thandleUnownedManyToMany( elementType, targetEntity, isCollectionOfEntities );\n\t\t}\n\t\telse {\n\t\t\thandleOwnedManyToMany( targetEntity, isCollectionOfEntities );\n\t\t}\n\n\t\tbindSynchronize();\n\t\tbindFilters( isCollectionOfEntities );\n\t\thandleWhere( isCollectionOfEntities );\n\n\t\tbindCollectionSecondPass( targetEntity, joinColumns );\n\n\t\tif ( isCollectionOfEntities ) {\n\t\t\tfinal ManyToOne element = handleCollectionOfEntities( elementType, targetEntity, hqlOrderBy );\n\t\t\tbindManyToManyInverseForeignKey( targetEntity, inverseJoinColumns, element, oneToMany );\n\t\t}\n\t\telse if ( isManyToAny ) {\n\t\t\thandleManyToAny();\n\t\t}\n\t\telse {\n\t\t\thandleElementCollection( elementType, hqlOrderBy );\n\t\t}\n\n\t\tcheckFilterConditions( collection );\n\t\tcheckConsistentColumnMutability( collection );\n\t}\n\n\tprivate void handleElementCollection(TypeDetails elementType, String hqlOrderBy) {\n\t\t// 'propertyHolder' is the PropertyHolder for the owner of the collection\n\t\t// 'holder' is the CollectionPropertyHolder.\n\t\t// 'property' is the collection XProperty\n\n\t\tfinal boolean isPrimitive = isPrimitive( elementType.getName() );\n\t\tfinal ClassDetails elementClass = isPrimitive\n\t\t\t\t? null\n\t\t\t\t: elementType.determineRawClass();\n\t\tfinal AnnotatedClassType classType = annotatedElementType( isEmbedded, isPrimitive, property, elementClass );\n\t\tif ( !isPrimitive ) {\n\t\t\tpropertyHolder.startingProperty( property );\n\t\t}\n\n\t\tfinal CollectionPropertyHolder holder = buildPropertyHolder(\n\t\t\t\tcollection,\n\t\t\t\tcollection.getRole(),\n\t\t\t\telementClass,\n\t\t\t\tproperty,\n\t\t\t\tpropertyHolder,\n\t\t\t\tbuildingContext\n\t\t);\n\n\t\tfinal Class<? extends CompositeUserType<?>> compositeUserType = resolveCompositeUserType( property, elementClass, buildingContext );\n\t\tboolean isComposite = classType == EMBEDDABLE || compositeUserType != null;\n\t\tholder.prepare( property, isComposite );\n\n\t\tif ( isComposite ) {\n\t\t\thandleCompositeCollectionElement( hqlOrderBy, elementType, elementClass, holder, compositeUserType );\n\t\t}\n\t\telse {\n\t\t\thandleCollectionElement( elementType, hqlOrderBy, elementClass, holder );\n\t\t}\n\t}\n\n\tprivate void handleCollectionElement(\n\t\t\tTypeDetails elementType,\n\t\t\tString hqlOrderBy,\n\t\t\tClassDetails elementClass,\n\t\t\tCollectionPropertyHolder holder) {\n\t\tfinal BasicValueBinder elementBinder =\n\t\t\t\tnew BasicValueBinder( BasicValueBinder.Kind.COLLECTION_ELEMENT, buildingContext );\n\t\telementBinder.setReturnedClassName( elementType.getName() );\n\t\tfinal AnnotatedColumns actualColumns = createElementColumnsIfNecessary(\n\t\t\t\tcollection,\n\t\t\t\telementColumns,\n\t\t\t\tCollection.DEFAULT_ELEMENT_COLUMN_NAME,\n\t\t\t\tnull,\n\t\t\t\tbuildingContext\n\t\t);\n\t\telementBinder.setColumns( actualColumns );\n\t\telementBinder.setType(\n\t\t\t\tproperty,\n\t\t\t\telementType,\n\t\t\t\tcollection.getOwnerEntityName(),\n\t\t\t\tholder.resolveElementAttributeConverterDescriptor( property, elementClass )\n\t\t);\n\t\telementBinder.setPersistentClassName( propertyHolder.getEntityName() );\n\t\telementBinder.setAccessType( accessType );\n\t\tcollection.setElement( elementBinder.make() );\n\t\tfinal String orderBy = adjustUserSuppliedValueCollectionOrderingFragment( hqlOrderBy );\n\t\tif ( orderBy != null ) {\n\t\t\tcollection.setOrderBy( orderBy );\n\t\t}\n\t}\n\n\tprivate void handleCompositeCollectionElement(\n\t\t\tString hqlOrderBy,\n\t\t\tTypeDetails elementType,\n\t\t\tClassDetails elementClass,\n\t\t\tCollectionPropertyHolder holder,\n\t\t\tClass<? extends CompositeUserType<?>> compositeUserType) {\n\t\t//TODO be smart with isNullable\n\t\tfinal AccessType accessType = accessType( property, collection.getOwner() );\n\t\t// We create a new entity binder here because it is needed for processing the embeddable\n\t\t// Since this is an element collection, there is no real entity binder though,\n\t\t// so we just create an \"empty shell\" for the purpose of avoiding null checks in the fillEmbeddable() method etc.\n\t\tfinal EntityBinder entityBinder = new EntityBinder( buildingContext );\n\t\t// Copy over the access type that we resolve for the element collection,\n\t\t// so that nested components use the same access type. This fixes HHH-15966\n\t\tentityBinder.setPropertyAccessType( accessType );\n\t\tfinal Component component = fillEmbeddable(\n\t\t\t\tholder,\n\t\t\t\tgetSpecialMembers( elementType ),\n\t\t\t\taccessType,\n\t\t\t\ttrue,\n\t\t\t\tentityBinder,\n\t\t\t\tfalse,\n\t\t\t\tfalse,\n\t\t\t\ttrue,\n\t\t\t\tresolveCustomInstantiator( property, elementType, buildingContext ),\n\t\t\t\tcompositeUserType,\n\t\t\t\tnull,\n\t\t\t\tbuildingContext,\n\t\t\t\tinheritanceStatePerClass\n\t\t);\n\t\tcollection.setElement( component );\n\t\tif ( isNotEmpty( hqlOrderBy ) ) {\n\t\t\tfinal String orderBy = adjustUserSuppliedValueCollectionOrderingFragment( hqlOrderBy );\n\t\t\tif ( orderBy != null ) {\n\t\t\t\tcollection.setOrderBy( orderBy );\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic AccessType accessType(MemberDetails property, PersistentClass owner) {\n\t\tfinal Access accessAnn = property.getDirectAnnotationUsage( Access.class );\n\t\tif ( accessAnn != null ) {\n\t\t\t// the attribute is locally annotated with `@Access`, use that\n\t\t\treturn accessAnn.value() == PROPERTY\n\t\t\t\t\t? AccessType.PROPERTY\n\t\t\t\t\t: AccessType.FIELD;\n\t\t}\n\n\t\tif ( owner.getIdentifierProperty() != null ) {\n\t\t\t// use the access for the owning entity's id attribute, if one\n\t\t\treturn owner.getIdentifierProperty().getPropertyAccessorName().equals( \"property\" )\n\t\t\t\t\t? AccessType.PROPERTY\n\t\t\t\t\t: AccessType.FIELD;\n\t\t}\n\n\t\tif ( owner.getIdentifierMapper() != null && owner.getIdentifierMapper().getPropertySpan() > 0 ) {\n\t\t\t// use the access for the owning entity's \"id mapper\", if one\n\t\t\treturn owner.getIdentifierMapper().getProperties().get(0).getPropertyAccessorName().equals( \"property\" )\n\t\t\t\t\t? AccessType.PROPERTY\n\t\t\t\t\t: AccessType.FIELD;\n\t\t}\n\n\t\t// otherwise...\n\t\tthrow new AssertionFailure( \"Unable to guess collection property accessor name\" );\n\t}\n\n\tprivate AnnotatedClassType annotatedElementType(\n\t\t\tboolean isEmbedded,\n\t\t\tboolean isPrimitive,\n\t\t\tMemberDetails property,\n\t\t\tClassDetails elementClass) {\n\t\tif ( isPrimitive ) {\n\t\t\treturn NONE;\n\t\t}\n\t\telse {\n\t\t\t//force in case of attribute override\n\t\t\tfinal boolean attributeOverride = mappingDefinedAttributeOverrideOnElement(property);\n\t\t\t// todo : force in the case of Convert annotation(s) with embedded paths (beyond key/value prefixes)?\n\t\t\treturn isEmbedded || attributeOverride\n\t\t\t\t\t? EMBEDDABLE\n\t\t\t\t\t: buildingContext.getMetadataCollector().getClassType( elementClass );\n\t\t}\n\t}\n\n\tprotected boolean mappingDefinedAttributeOverrideOnElement(MemberDetails property) {\n\t\treturn property.hasDirectAnnotationUsage( AttributeOverride.class )\n\t\t\t\t|| property.hasDirectAnnotationUsage( AttributeOverrides.class );\n\t}\n\n\tstatic AnnotatedColumns createElementColumnsIfNecessary(\n\t\t\tCollection collection,\n\t\t\tAnnotatedColumns elementColumns,\n\t\t\tString defaultName,\n\t\t\tLong defaultLength,\n\t\t\tMetadataBuildingContext context) {\n\t\tif ( elementColumns == null || elementColumns.getColumns().isEmpty() ) {\n\t\t\tfinal AnnotatedColumns columns = new AnnotatedColumns();\n\t\t\tcolumns.setBuildingContext( context );\n\t\t\tfinal AnnotatedColumn column = new AnnotatedColumn();\n\t\t\tcolumn.setLogicalColumnName( defaultName );\n\t\t\tif ( defaultLength != null ) {\n\t\t\t\tcolumn.setLength( defaultLength );\n\t\t\t}\n\t\t\tcolumn.setImplicit( false );\n\t\t\t//not following the spec but more clean\n\t\t\tcolumn.setNullable( true );\n//\t\t\tcolumn.setContext( context );\n\t\t\tcolumn.setParent( columns );\n\t\t\tcolumn.bind();\n\t\t\telementColumns = columns;\n\t\t}\n\t\t//override the table\n\t\telementColumns.setTable( collection.getCollectionTable() );\n\t\treturn elementColumns;\n\t}\n\n\tprivate ManyToOne handleCollectionOfEntities(\n\t\t\tTypeDetails elementType,\n\t\t\tPersistentClass collectionEntity,\n\t\t\tString hqlOrderBy) {\n\t\tfinal ManyToOne element = new ManyToOne( buildingContext,  collection.getCollectionTable() );\n\t\tcollection.setElement( element );\n\t\telement.setReferencedEntityName( elementType.getName() );\n\t\t//element.setFetchMode( fetchMode );\n\t\t//element.setLazy( fetchMode != FetchMode.JOIN );\n\t\t//make the second join non-lazy\n\t\telement.setFetchMode( FetchMode.JOIN );\n\t\telement.setLazy( false );\n\t\telement.setNotFoundAction( notFoundAction );\n\t\t// as per 11.1.38 of JPA 2.0 spec, default to primary key if no column is specified by @OrderBy.\n\t\tif ( hqlOrderBy != null ) {\n\t\t\tcollection.setManyToManyOrdering( buildOrderByClauseFromHql( hqlOrderBy, collectionEntity ) );\n\t\t}\n\n\t\tfinal JoinTable joinTableAnn = property.getDirectAnnotationUsage( JoinTable.class );\n\t\tif ( joinTableAnn != null ) {\n\t\t\tfinal ForeignKey inverseForeignKey = joinTableAnn.inverseForeignKey();\n\t\t\tString foreignKeyName = inverseForeignKey.name();\n\t\t\tString foreignKeyDefinition = inverseForeignKey.foreignKeyDefinition();\n\n\t\t\tfinal JoinColumn[] inverseJoinColumns = joinTableAnn.inverseJoinColumns();\n\t\t\tif ( !ArrayHelper.isEmpty( inverseJoinColumns ) ) {\n\t\t\t\tfinal JoinColumn joinColumnAnn = inverseJoinColumns[0];\n\t\t\t\tif ( foreignKeyName.isEmpty() ) {\n\t\t\t\t\tfinal ForeignKey inverseJoinColumnForeignKey = joinColumnAnn.foreignKey();\n\t\t\t\t\tforeignKeyName = inverseJoinColumnForeignKey.name();\n\t\t\t\t\tforeignKeyDefinition = inverseJoinColumnForeignKey.foreignKeyDefinition();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfinal ConstraintMode constraintMode = inverseForeignKey.value();\n\t\t\tif ( constraintMode == NO_CONSTRAINT\n\t\t\t\t\t|| constraintMode == PROVIDER_DEFAULT\n\t\t\t\t\t\t\t&& buildingContext.getBuildingOptions().isNoConstraintByDefault() ) {\n\t\t\t\telement.disableForeignKey();\n\t\t\t}\n\t\t\telse {\n\t\t\t\telement.setForeignKeyName( nullIfEmpty( foreignKeyName ) );\n\t\t\t\telement.setForeignKeyDefinition( nullIfEmpty( foreignKeyDefinition ) );\n\t\t\t}\n\t\t}\n\t\treturn element;\n\t}\n\n\tprivate void handleManyToAny() {\n\t\t//@ManyToAny\n\t\t//Make sure that collTyp is never used during the @ManyToAny branch: it will be set to void.class\n\t\tfinal PropertyData inferredData = new PropertyInferredData(\n\t\t\t\tnull,\n\t\t\t\tdeclaringClass,\n\t\t\t\tproperty,\n\t\t\t\t\"unsupported\",\n\t\t\t\tbuildingContext\n\t\t);\n\n\t\tfinal MemberDetails prop = inferredData.getAttributeMember();\n\t\tfinal jakarta.persistence.Column discriminatorColumnAnn = prop.getDirectAnnotationUsage( jakarta.persistence.Column.class );\n\t\tfinal Formula discriminatorFormulaAnn = getOverridableAnnotation( prop, Formula.class, buildingContext );\n\n\t\t//override the table\n\t\tinverseJoinColumns.setTable( collection.getCollectionTable() );\n\n\t\tfinal ManyToAny anyAnn = property.getDirectAnnotationUsage( ManyToAny.class );\n\t\tfinal Any any = buildAnyValue(\n\t\t\t\tdiscriminatorColumnAnn,\n\t\t\t\tdiscriminatorFormulaAnn,\n\t\t\t\tinverseJoinColumns,\n\t\t\t\tinferredData,\n\t\t\t\tonDeleteAction,\n\t\t\t\tanyAnn.fetch() == LAZY,\n\t\t\t\tNullability.NO_CONSTRAINT,\n\t\t\t\tpropertyHolder,\n\t\t\t\tnew EntityBinder( buildingContext ),\n\t\t\t\ttrue,\n\t\t\t\tbuildingContext\n\t\t);\n\t\tcollection.setElement( any );\n\t}\n\n\tprivate PropertyData getSpecialMembers(TypeDetails elementClass) {\n\t\tif ( isMap() ) {\n\t\t\t//\"value\" is the JPA 2 prefix for map values (used to be \"element\")\n\t\t\tif ( isHibernateExtensionMapping() ) {\n\t\t\t\treturn new PropertyPreloadedData( AccessType.PROPERTY, \"element\", elementClass );\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn new PropertyPreloadedData( AccessType.PROPERTY, \"value\", elementClass );\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif ( isHibernateExtensionMapping() ) {\n\t\t\t\treturn new PropertyPreloadedData( AccessType.PROPERTY, \"element\", elementClass );\n\t\t\t}\n\t\t\telse {\n\t\t\t\t//\"{element}\" is not a valid property name => placeholder\n\t\t\t\treturn new PropertyPreloadedData( AccessType.PROPERTY, \"{element}\", elementClass );\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate void handleOwnedManyToMany(PersistentClass collectionEntity, boolean isCollectionOfEntities) {\n\t\t//TODO: only for implicit columns?\n\t\t//FIXME NamingStrategy\n\t\tfinal InFlightMetadataCollector collector = buildingContext.getMetadataCollector();\n\t\tfinal PersistentClass owner = collection.getOwner();\n\t\tjoinColumns.setMappedBy(\n\t\t\t\towner.getEntityName(),\n\t\t\t\tcollector.getLogicalTableName( owner.getTable() ),\n\t\t\t\tcollector.getFromMappedBy( owner.getEntityName(), joinColumns.getPropertyName() )\n\t\t);\n\t\tif ( isEmpty( tableBinder.getName() ) ) {\n\t\t\t//default value\n\t\t\ttableBinder.setDefaultName(\n\t\t\t\t\towner.getClassName(),\n\t\t\t\t\towner.getEntityName(),\n\t\t\t\t\towner.getJpaEntityName(),\n\t\t\t\t\tcollector.getLogicalTableName( owner.getTable() ),\n\t\t\t\t\tcollectionEntity != null ? collectionEntity.getClassName() : null,\n\t\t\t\t\tcollectionEntity != null ? collectionEntity.getEntityName() : null,\n\t\t\t\t\tcollectionEntity != null ? collectionEntity.getJpaEntityName() : null,\n\t\t\t\t\tcollectionEntity != null ? collector.getLogicalTableName( collectionEntity.getTable() ) : null,\n\t\t\t\t\tjoinColumns.getPropertyName()\n\t\t\t);\n\t\t}\n\t\ttableBinder.setJPA2ElementCollection(\n\t\t\t\t!isCollectionOfEntities && property.hasDirectAnnotationUsage( ElementCollection.class )\n\t\t);\n\t\tfinal Table collectionTable = tableBinder.bind();\n\t\tcollection.setCollectionTable( collectionTable );\n\t\thandleCheckConstraints( collectionTable );\n\t\tprocessSoftDeletes();\n\t}\n\n\tprivate void handleCheckConstraints(Table collectionTable) {\n\t\tproperty.forEachAnnotationUsage( Check.class, sourceModelContext(), (usage) -> {\n\t\t\taddCheckToCollection( collectionTable, usage );\n\t\t} );\n\t\tproperty.forEachAnnotationUsage( jakarta.persistence.JoinTable.class, sourceModelContext(), (usage) -> {\n\t\t\tTableBinder.addTableCheck( collectionTable, usage.check() );\n\t\t\tTableBinder.addTableComment( collectionTable, usage.comment() );\n\t\t\tTableBinder.addTableOptions( collectionTable, usage.options() );\n\t\t} );\n\t}\n\n\tprivate static void addCheckToCollection(Table collectionTable, Check check) {\n\t\tfinal String name = check.name();\n\t\tfinal String constraint = check.constraints();\n\t\tcollectionTable.addCheck( name.isEmpty()\n\t\t\t\t? new CheckConstraint( constraint )\n\t\t\t\t: new CheckConstraint( name, constraint ) );\n\t}\n\n\tprivate void processSoftDeletes() {\n\t\tassert collection.getCollectionTable() != null;\n\n\t\tfinal SoftDelete softDelete = extractSoftDelete( property, propertyHolder, buildingContext );\n\t\tif ( softDelete == null ) {\n\t\t\treturn;\n\t\t}\n\n\t\tSoftDeleteHelper.bindSoftDeleteIndicator(\n\t\t\t\tsoftDelete,\n\t\t\t\tcollection,\n\t\t\t\tcollection.getCollectionTable(),\n\t\t\t\tbuildingContext\n\t\t);\n\t}\n\n\tprivate static SoftDelete extractSoftDelete(\n\t\t\tMemberDetails property,\n\t\t\tPropertyHolder propertyHolder,\n\t\t\tMetadataBuildingContext context) {\n\t\tfinal SoftDelete fromProperty = property.getDirectAnnotationUsage( SoftDelete.class );\n\t\tif ( fromProperty != null ) {\n\t\t\treturn fromProperty;\n\t\t}\n\n\t\treturn extractFromPackage(\n\t\t\t\tSoftDelete.class,\n\t\t\t\tproperty.getDeclaringType(),\n\t\t\t\tcontext\n\t\t);\n\t}\n\n\tprivate void handleUnownedManyToMany(\n\t\t\tTypeDetails elementType,\n\t\t\tPersistentClass collectionEntity,\n\t\t\tboolean isCollectionOfEntities) {\n\t\tif ( !isCollectionOfEntities) {\n\t\t\tthrow new AnnotationException( \"Association '\" + safeCollectionRole() + \"'\"\n\t\t\t\t\t+ targetEntityMessage( elementType ) );\n\t\t}\n\n\t\tjoinColumns.setManyToManyOwnerSideEntityName( collectionEntity.getEntityName() );\n\n\t\tfinal Property otherSideProperty;\n\t\ttry {\n\t\t\totherSideProperty = collectionEntity.getRecursiveProperty( mappedBy );\n\t\t}\n\t\tcatch ( MappingException e ) {\n\t\t\tthrow new AnnotationException( \"Association '\" + safeCollectionRole()\n\t\t\t\t\t+ \"is 'mappedBy' a property named '\" + mappedBy\n\t\t\t\t\t+ \"' which does not exist in the target entity '\" + elementType.getName() + \"'\" );\n\t\t}\n\t\tfinal Value otherSidePropertyValue = otherSideProperty.getValue();\n\t\tfinal Table table = otherSidePropertyValue instanceof Collection\n\t\t\t\t// this is a collection on the other side\n\t\t\t\t? ( (Collection) otherSidePropertyValue ).getCollectionTable()\n\t\t\t\t// this is a ToOne with a @JoinTable or a regular property\n\t\t\t\t: otherSidePropertyValue.getTable();\n\t\tcollection.setCollectionTable( table );\n\t\tprocessSoftDeletes();\n\n\t\tif ( property.hasDirectAnnotationUsage( Checks.class )\n\t\t\t\t|| property.hasDirectAnnotationUsage( Check.class ) ) {\n\t\t\tthrow new AnnotationException( \"Association '\" + safeCollectionRole()\n\t\t\t\t\t+ \" is an unowned collection and may not be annotated '@Check'\" );\n\t\t}\n\t}\n\n\tprivate void detectManyToManyProblems(\n\t\t\tTypeDetails elementType,\n\t\t\tboolean isCollectionOfEntities,\n\t\t\tboolean isManyToAny) {\n\n\t\tif ( !isCollectionOfEntities) {\n\t\t\tif ( property.hasDirectAnnotationUsage( ManyToMany.class )\n\t\t\t\t\t|| property.hasDirectAnnotationUsage( OneToMany.class ) ) {\n\t\t\t\tthrow new AnnotationException( \"Association '\" + safeCollectionRole() + \"'\"\n\t\t\t\t\t\t+ targetEntityMessage( elementType ) );\n\t\t\t}\n\t\t\telse if (isManyToAny) {\n\t\t\t\tif ( propertyHolder.getJoinTable( property ) == null ) {\n\t\t\t\t\tthrow new AnnotationException( \"Association '\" + safeCollectionRole()\n\t\t\t\t\t\t\t+ \"' is a '@ManyToAny' and must specify a '@JoinTable'\" );\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfinal JoinTable joinTableAnn = propertyHolder.getJoinTable( property );\n\t\t\t\tif ( joinTableAnn != null && !ArrayHelper.isEmpty( joinTableAnn.inverseJoinColumns() ) ) {\n\t\t\t\t\tthrow new AnnotationException( \"Association '\" + safeCollectionRole()\n\t\t\t\t\t\t\t+ \" has a '@JoinTable' with 'inverseJoinColumns' and\"\n\t\t\t\t\t\t\t+ targetEntityMessage( elementType ) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic String targetEntityMessage(TypeDetails elementType) {\n\t\tfinal String problem = elementType.determineRawClass().hasDirectAnnotationUsage( Entity.class )\n\t\t\t\t? \" which does not belong to the same persistence unit\"\n\t\t\t\t: \" which is not an '@Entity' type\";\n\t\treturn \" targets the type '\" + elementType.getName() + \"'\" + problem;\n\t}\n\n\tprivate Class<? extends EmbeddableInstantiator> resolveCustomInstantiator(\n\t\t\tMemberDetails property,\n\t\t\tTypeDetails propertyClass,\n\t\t\tMetadataBuildingContext context) {\n\t\tfinal org.hibernate.annotations.EmbeddableInstantiator propertyAnnotation\n\t\t\t\t= property.getDirectAnnotationUsage( org.hibernate.annotations.EmbeddableInstantiator.class );\n\t\tif ( propertyAnnotation != null ) {\n\t\t\treturn propertyAnnotation.value();\n\t\t}\n\n\t\tfinal ClassDetails rawPropertyClassDetails = propertyClass.determineRawClass();\n\t\tfinal org.hibernate.annotations.EmbeddableInstantiator classAnnotation\n\t\t\t\t= rawPropertyClassDetails.getDirectAnnotationUsage( org.hibernate.annotations.EmbeddableInstantiator.class );\n\t\tif ( classAnnotation != null ) {\n\t\t\treturn classAnnotation.value();\n\t\t}\n\n\t\tfinal Class<?> embeddableClass = rawPropertyClassDetails.toJavaClass();\n\t\tif ( embeddableClass != null ) {\n\t\t\treturn context.getMetadataCollector().findRegisteredEmbeddableInstantiator( embeddableClass );\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tprivate static Class<? extends CompositeUserType<?>> resolveCompositeUserType(\n\t\t\tMemberDetails property,\n\t\t\tClassDetails returnedClass,\n\t\t\tMetadataBuildingContext context) {\n\t\tfinal CompositeType compositeType = property.getDirectAnnotationUsage( CompositeType.class );\n\t\tif ( compositeType != null ) {\n\t\t\treturn compositeType.value();\n\t\t}\n\n\t\tif ( returnedClass != null ) {\n\t\t\tfinal Class<?> embeddableClass = returnedClass.toJavaClass();\n\t\t\treturn embeddableClass == null\n\t\t\t\t\t? null\n\t\t\t\t\t: context.getMetadataCollector().findRegisteredCompositeUserType( embeddableClass );\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tprivate String extractHqlOrderBy(OrderBy jpaOrderBy) {\n\t\tif ( jpaOrderBy != null ) {\n\t\t\t// Null not possible. In case of empty expression, apply default ordering.\n\t\t\treturn jpaOrderBy.value();\n\t\t}\n\t\telse {\n\t\t\t// @OrderBy not found.\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tprivate static void checkFilterConditions(Collection collection) {\n\t\t//for now it can't happen, but sometime soon...\n\t\tif ( ( !collection.getFilters().isEmpty() || isNotEmpty( collection.getWhere() ) )\n\t\t\t\t&& collection.getFetchMode() == FetchMode.JOIN\n\t\t\t\t&& !( collection.getElement() instanceof SimpleValue ) //SimpleValue (CollectionOfElements) are always SELECT but it does not matter\n\t\t\t\t&& collection.getElement().getFetchMode() != FetchMode.JOIN ) {\n\t\t\tthrow new MappingException(\n\t\t\t\t\t\"@ManyToMany or @ElementCollection defining filter or where without join fetching \"\n\t\t\t\t\t\t\t+ \"not valid within collection using join fetching[\" + collection.getRole() + \"]\"\n\t\t\t);\n\t\t}\n\t}\n\n\tprivate static void checkConsistentColumnMutability(Collection collection) {\n\t\tcheckConsistentColumnMutability( collection.getRole(), collection.getKey() );\n\t\tcheckConsistentColumnMutability( collection.getRole(), collection.getElement() );\n\t}\n\n\tprivate static void checkConsistentColumnMutability(String collectionRole, Value value) {\n\t\tBoolean readOnly = null;\n\t\tfor ( int i = 0; i < value.getColumnSpan(); i++ ) {\n\t\t\tfinal boolean insertable = value.isColumnInsertable( i );\n\t\t\tif ( insertable != value.isColumnUpdateable( i ) ) {\n\t\t\t\tthrow new AnnotationException(\n\t\t\t\t\t\t\"Join column '\" + value.getColumns().get( i ).getName() + \"' on collection property '\"\n\t\t\t\t\t\t\t\t+ collectionRole + \"' must be defined with the same insertable and updatable attributes\"\n\t\t\t\t);\n\t\t\t}\n\t\t\tif ( readOnly == null ) {\n\t\t\t\treadOnly = insertable;\n\t\t\t}\n\t\t\telse if ( readOnly != insertable && !value.getColumns().get( i ).isFormula() ) {\n\t\t\t\t// We also assert that all join columns have the same mutability (except formulas)\n\t\t\t\tthrow new AnnotationException(\n\t\t\t\t\t\t\"All join columns on collection '\" + collectionRole + \"' should have\" +\n\t\t\t\t\t\t\t\t\" the same insertable and updatable setting\"\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate void bindCollectionSecondPass(PersistentClass targetEntity, AnnotatedJoinColumns joinColumns) {\n\n\t\tif ( !isUnownedCollection() ) {\n\t\t\tcreateSyntheticPropertyReference(\n\t\t\t\t\tjoinColumns,\n\t\t\t\t\tcollection.getOwner(),\n\t\t\t\t\tcollection.getOwner(),\n\t\t\t\t\tcollection,\n\t\t\t\t\tpropertyName,\n\t\t\t\t\tfalse,\n\t\t\t\t\tbuildingContext\n\t\t\t);\n\t\t}\n\n\t\tif ( property.hasDirectAnnotationUsage( ElementCollection.class ) ) {\n\t\t\tjoinColumns.setElementCollection( true );\n\t\t}\n\n\t\tfinal DependantValue key = buildCollectionKey( joinColumns, onDeleteAction );\n\t\tTableBinder.bindForeignKey(\n\t\t\t\tcollection.getOwner(),\n\t\t\t\ttargetEntity,\n\t\t\t\tjoinColumns,\n\t\t\t\tkey,\n\t\t\t\tfalse,\n\t\t\t\tbuildingContext\n\t\t);\n\t\tkey.sortProperties();\n\t}\n\n\tpublic void setOnDeleteActionAction(OnDeleteAction onDeleteAction) {\n\t\tthis.onDeleteAction = onDeleteAction;\n\t}\n\n\tString safeCollectionRole() {\n\t\treturn propertyHolder != null ? propertyHolder.getEntityName() + \".\" + propertyName : \"\";\n\t}\n\n\t/**\n\t * Bind the inverse foreign key of a {@link ManyToMany}, that is, the columns\n\t * specified by {@code @JoinTable(inverseJoinColumns=...)}, which are the\n\t * columns that reference the target entity of the many-to-many association.\n\t * If we are in a {@code mappedBy} case, read the columns from the associated\n\t * collection element in the target entity.\n\t */\n\tpublic void bindManyToManyInverseForeignKey(\n\t\t\tPersistentClass targetEntity,\n\t\t\tAnnotatedJoinColumns joinColumns,\n\t\t\tSimpleValue value,\n\t\t\tboolean unique) {\n\t\t// This method is also called for entity valued map keys, so we must consider\n\t\t// the mappedBy of the join columns instead of the collection's one\n\t\tif ( joinColumns.hasMappedBy() ) {\n\t\t\tbindUnownedManyToManyInverseForeignKey( targetEntity, joinColumns, value );\n\t\t}\n\t\telse {\n\t\t\tbindOwnedManyToManyForeignKeyMappedBy( targetEntity, joinColumns, value, unique );\n\t\t}\n\t}\n\n\tprivate void bindOwnedManyToManyForeignKeyMappedBy(\n\t\t\tPersistentClass targetEntity,\n\t\t\tAnnotatedJoinColumns joinColumns,\n\t\t\tSimpleValue value,\n\t\t\tboolean unique) { // true when it's actually a logical @OneToMany\n\t\tcreateSyntheticPropertyReference(\n\t\t\t\tjoinColumns,\n\t\t\t\ttargetEntity,\n\t\t\t\tcollection.getOwner(),\n\t\t\t\tvalue,\n\t\t\t\tpropertyName,\n\t\t\t\ttrue,\n\t\t\t\tbuildingContext\n\t\t);\n\t\tif ( notFoundAction == NotFoundAction.IGNORE ) {\n\t\t\tvalue.disableForeignKey();\n\t\t}\n\t\tTableBinder.bindForeignKey(\n\t\t\t\ttargetEntity,\n\t\t\t\tcollection.getOwner(),\n\t\t\t\tjoinColumns,\n\t\t\t\tvalue,\n\t\t\t\tunique,\n\t\t\t\tbuildingContext\n\t\t);\n\t}\n\n\tprivate void bindUnownedManyToManyInverseForeignKey(\n\t\t\tPersistentClass targetEntity,\n\t\t\tAnnotatedJoinColumns joinColumns,\n\t\t\tSimpleValue value) {\n\t\tfinal Property property = targetEntity.getRecursiveProperty( mappedBy );\n\t\tfinal List<Selectable> mappedByColumns = mappedByColumns( targetEntity, property );\n\t\tfinal AnnotatedJoinColumn firstColumn = joinColumns.getJoinColumns().get(0);\n\t\tfor ( Selectable selectable: mappedByColumns ) {\n\t\t\tfirstColumn.linkValueUsingAColumnCopy( (Column) selectable, value);\n\t\t}\n\t\tfinal String referencedPropertyName = buildingContext.getMetadataCollector()\n\t\t\t\t.getPropertyReferencedAssociation( targetEntity.getEntityName(), mappedBy );\n\t\tif ( referencedPropertyName != null ) {\n\t\t\t//TODO always a many to one?\n\t\t\t( (ManyToOne) value).setReferencedPropertyName( referencedPropertyName );\n\t\t\tbuildingContext.getMetadataCollector()\n\t\t\t\t\t.addUniquePropertyReference( targetEntity.getEntityName(), referencedPropertyName );\n\t\t}\n\t\t( (ManyToOne) value).setReferenceToPrimaryKey( referencedPropertyName == null );\n\t\tvalue.createForeignKey();\n\t}\n\n\tprivate static List<Selectable> mappedByColumns(PersistentClass referencedEntity, Property property) {\n\t\tif ( property.getValue() instanceof Collection ) {\n\t\t\treturn ( (Collection) property.getValue() ).getKey().getSelectables();\n\t\t}\n\t\telse {\n\t\t\t//find the appropriate reference key, can be in a join\n\t\t\tKeyValue key = null;\n\t\t\tfor ( Join join : referencedEntity.getJoins() ) {\n\t\t\t\tif ( join.containsProperty(property) ) {\n\t\t\t\t\tkey = join.getKey();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( key == null ) {\n\t\t\t\tkey = property.getPersistentClass().getIdentifier();\n\t\t\t}\n\t\t\treturn key.getSelectables();\n\t\t}\n\t}\n\n\tpublic void setFkJoinColumns(AnnotatedJoinColumns annotatedJoinColumns) {\n\t\tthis.foreignJoinColumns = annotatedJoinColumns;\n\t}\n\n\tpublic void setExplicitAssociationTable(boolean isExplicitAssociationTable) {\n\t\tthis.isExplicitAssociationTable = isExplicitAssociationTable;\n\t}\n\n\tpublic void setElementColumns(AnnotatedColumns elementColumns) {\n\t\tthis.elementColumns = elementColumns;\n\t}\n\n\tpublic void setEmbedded(boolean annotationPresent) {\n\t\tthis.isEmbedded = annotationPresent;\n\t}\n\n\tpublic void setProperty(MemberDetails property) {\n\t\tthis.property = property;\n\t}\n\n\tpublic NotFoundAction getNotFoundAction() {\n\t\treturn notFoundAction;\n\t}\n\n\tpublic void setNotFoundAction(NotFoundAction notFoundAction) {\n\t\tthis.notFoundAction = notFoundAction;\n\t}\n\n\tpublic void setMapKeyColumns(AnnotatedColumns mapKeyColumns) {\n\t\tthis.mapKeyColumns = mapKeyColumns;\n\t}\n\n\tpublic void setMapKeyManyToManyColumns(AnnotatedJoinColumns mapJoinColumns) {\n\t\tthis.mapKeyManyToManyColumns = mapJoinColumns;\n\t}\n\n\tpublic void setLocalGenerators(Map<String, IdentifierGeneratorDefinition> localGenerators) {\n\t\tthis.localGenerators = localGenerators;\n\t}\n\n\tprivate void logOneToManySecondPass() {\n\t\tif ( LOG.isDebugEnabled() ) {\n\t\t\tLOG.debugf( \"Binding a OneToMany: %s through a foreign key\", safeCollectionRole() );\n\t\t}\n\t}\n\n\tprivate void logManyToManySecondPass(\n\t\t\tboolean isOneToMany,\n\t\t\tboolean isCollectionOfEntities,\n\t\t\tboolean isManyToAny) {\n\t\tif ( LOG.isDebugEnabled() ) {\n\t\t\tif ( isCollectionOfEntities && isOneToMany ) {\n\t\t\t\tLOG.debugf( \"Binding a OneToMany: %s through an association table\", safeCollectionRole() );\n\t\t\t}\n\t\t\telse if ( isCollectionOfEntities ) {\n\t\t\t\tLOG.debugf( \"Binding a ManyToMany: %s\", safeCollectionRole() );\n\t\t\t}\n\t\t\telse if ( isManyToAny ) {\n\t\t\t\tLOG.debugf( \"Binding a ManyToAny: %s\", safeCollectionRole() );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tLOG.debugf( \"Binding a collection of element: %s\", safeCollectionRole() );\n\t\t\t}\n\t\t}\n\t}\n\n}\n",
        "diffSourceCodeSet": [
            "protected boolean mappingDefinedAttributeOverrideOnElement(MemberDetails property) {\n\t\treturn property.hasDirectAnnotationUsage( AttributeOverride.class )\n\t\t\t\t|| property.hasDirectAnnotationUsage( AttributeOverrides.class );\n\t}"
        ],
        "invokedMethodSet": [],
        "sourceCodeAfterRefactoring": "private AnnotatedClassType annotatedElementType(\n\t\t\tboolean isEmbedded,\n\t\t\tboolean isPrimitive,\n\t\t\tMemberDetails property,\n\t\t\tClassDetails elementClass) {\n\t\tif ( isPrimitive ) {\n\t\t\treturn NONE;\n\t\t}\n\t\telse {\n\t\t\t//force in case of attribute override\n\t\t\tfinal boolean attributeOverride = mappingDefinedAttributeOverrideOnElement(property);\n\t\t\t// todo : force in the case of Convert annotation(s) with embedded paths (beyond key/value prefixes)?\n\t\t\treturn isEmbedded || attributeOverride\n\t\t\t\t\t? EMBEDDABLE\n\t\t\t\t\t: buildingContext.getMetadataCollector().getClassType( elementClass );\n\t\t}\n\t}\nprotected boolean mappingDefinedAttributeOverrideOnElement(MemberDetails property) {\n\t\treturn property.hasDirectAnnotationUsage( AttributeOverride.class )\n\t\t\t\t|| property.hasDirectAnnotationUsage( AttributeOverrides.class );\n\t}",
        "diffSourceCode": "  2349: \tprivate AnnotatedClassType annotatedElementType(\n  2350: \t\t\tboolean isEmbedded,\n  2351: \t\t\tboolean isPrimitive,\n  2352: \t\t\tMemberDetails property,\n  2353: \t\t\tClassDetails elementClass) {\n  2354: \t\tif ( isPrimitive ) {\n  2355: \t\t\treturn NONE;\n  2356: \t\t}\n  2357: \t\telse {\n  2358: \t\t\t//force in case of attribute override\n- 2359: \t\t\tfinal boolean attributeOverride = property.hasDirectAnnotationUsage( AttributeOverride.class )\n- 2360: \t\t\t\t\t|| property.hasDirectAnnotationUsage( AttributeOverrides.class );\n- 2361: \t\t\t// todo : force in the case of Convert annotation(s) with embedded paths (beyond key/value prefixes)?\n- 2362: \t\t\treturn isEmbedded || attributeOverride\n- 2363: \t\t\t\t\t? EMBEDDABLE\n- 2364: \t\t\t\t\t: buildingContext.getMetadataCollector().getClassType( elementClass );\n- 2365: \t\t}\n- 2366: \t}\n- 2367: \n- 2368: \tstatic AnnotatedColumns createElementColumnsIfNecessary(\n- 2369: \t\t\tCollection collection,\n- 2370: \t\t\tAnnotatedColumns elementColumns,\n+ 2359: \t\t\tfinal boolean attributeOverride = mappingDefinedAttributeOverrideOnElement(property);\n+ 2360: \t\t\t// todo : force in the case of Convert annotation(s) with embedded paths (beyond key/value prefixes)?\n+ 2361: \t\t\treturn isEmbedded || attributeOverride\n+ 2362: \t\t\t\t\t? EMBEDDABLE\n+ 2363: \t\t\t\t\t: buildingContext.getMetadataCollector().getClassType( elementClass );\n+ 2364: \t\t}\n+ 2365: \t}\n+ 2366: \n+ 2367: \tprotected boolean mappingDefinedAttributeOverrideOnElement(MemberDetails property) {\n+ 2368: \t\treturn property.hasDirectAnnotationUsage( AttributeOverride.class )\n+ 2369: \t\t\t\t|| property.hasDirectAnnotationUsage( AttributeOverrides.class );\n+ 2370: \t}\n",
        "uniqueId": "ad6f326090f856d4de26935428a89b1cc0f3644e_2349_2366_2367_2370_2349_2365",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 0,
                "covered": 28
            },
            "BRANCH": {
                "missed": 0,
                "covered": 10
            },
            "LINE": {
                "missed": 0,
                "covered": 7
            },
            "COMPLEXITY": {
                "missed": 0,
                "covered": 6
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 21
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprivate createQueryDefinition(namedNativeQuery org.hibernate.annotations.NamedNativeQuery, registrationName String, resultSetMappingName String, resultClass Class<T>, timeout int, fetchSize int, querySpaces HashSet<String>) : NamedNativeQueryDefinition.Builder<T> extracted from public bindNativeQuery(namedNativeQuery org.hibernate.annotations.NamedNativeQuery, context MetadataBuildingContext) : void in class org.hibernate.boot.model.internal.QueryBinder",
        "diffLocations": [
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/boot/model/internal/QueryBinder.java",
                "startLine": 205,
                "endLine": 267,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/boot/model/internal/QueryBinder.java",
                "startLine": 211,
                "endLine": 257,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/boot/model/internal/QueryBinder.java",
                "startLine": 259,
                "endLine": 278,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "public static void bindNativeQuery(\n\t\t\torg.hibernate.annotations.NamedNativeQuery namedNativeQuery,\n\t\t\tMetadataBuildingContext context) {\n\t\tif ( namedNativeQuery == null ) {\n\t\t\treturn;\n\t\t}\n\n\t\tfinal String registrationName = namedNativeQuery.name();\n\n\t\t//ResultSetMappingDefinition mappingDefinition = mappings.getJdbcValuesMappingProducer( queryAnn.resultSetMapping() );\n\t\tif ( registrationName.isEmpty() ) {\n\t\t\tthrow new AnnotationException( \"Class or package level '@NamedNativeQuery' annotation must specify a 'name'\" );\n\t\t}\n\n\t\tfinal String resultSetMappingName = namedNativeQuery.resultSetMapping();\n\t\tfinal Class<?> resultClassDetails = namedNativeQuery.resultClass();\n\t\tfinal Class<Object> resultClass = resultClassDetails == void.class\n\t\t\t\t? null\n\t\t\t\t: (Class<Object>) resultClassDetails;\n\n\t\tfinal Integer timeout = namedNativeQuery.timeout();\n\t\tfinal Integer fetchSize = namedNativeQuery.fetchSize();\n\n\t\tfinal String[] querySpacesList = namedNativeQuery.querySpaces();\n\t\tfinal HashSet<String> querySpaces = new HashSet<>( determineProperSizing( querySpacesList.length ) );\n\t\tCollections.addAll( querySpaces, querySpacesList );\n\n\t\tfinal NamedNativeQueryDefinition.Builder<?> builder = new NamedNativeQueryDefinition.Builder<>( registrationName )\n\t\t\t\t.setSqlString( namedNativeQuery.query() )\n\t\t\t\t.setResultSetMappingName( resultSetMappingName )\n\t\t\t\t.setResultClass( resultClass )\n\t\t\t\t.setCacheable( namedNativeQuery.cacheable() )\n\t\t\t\t.setCacheRegion( nullIfEmpty( namedNativeQuery.cacheRegion() ) )\n\t\t\t\t.setCacheMode( getCacheMode( namedNativeQuery.cacheRetrieveMode(), namedNativeQuery.cacheStoreMode() ) )\n\t\t\t\t.setTimeout( timeout < 0 ? null : timeout )\n\t\t\t\t.setFetchSize( fetchSize < 0 ? null : fetchSize )\n\t\t\t\t.setFlushMode( getFlushMode( namedNativeQuery.flushMode() ) )\n\t\t\t\t.setReadOnly( namedNativeQuery.readOnly() )\n\t\t\t\t.setQuerySpaces( querySpaces )\n\t\t\t\t.setComment( nullIfEmpty( namedNativeQuery.comment() ) );\n\n\t\tif ( TRUE == namedNativeQuery.callable() ) {\n\t\t\tfinal NamedProcedureCallDefinition definition =\n\t\t\t\t\tcreateStoredProcedure( builder, context, () -> illegalCallSyntax( namedNativeQuery ) );\n\t\t\tcontext.getMetadataCollector().addNamedProcedureCallDefinition( definition );\n\t\t\tDeprecationLogger.DEPRECATION_LOGGER.warn(\n\t\t\t\t\t\"Marking named native queries as callable is no longer supported; use '@jakarta.persistence.NamedStoredProcedureQuery' instead. Ignoring.\"\n\t\t\t);\n\t\t}\n\t\telse {\n\t\t\tfinal NamedNativeQueryDefinition<?> queryDefinition = builder.build();\n\n\t\t\tif ( LOG.isDebugEnabled() ) {\n\t\t\t\tLOG.debugf(\n\t\t\t\t\t\t\"Binding named native query: %s => %s\",\n\t\t\t\t\t\tqueryDefinition.getRegistrationName(),\n\t\t\t\t\t\tqueryDefinition.getSqlQueryString()\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tcontext.getMetadataCollector().addNamedNativeQuery( queryDefinition );\n\t\t}\n\t}",
        "filePathBefore": "hibernate-core/src/main/java/org/hibernate/boot/model/internal/QueryBinder.java",
        "isPureRefactoring": true,
        "commitId": "b53728f7278c40ef41e22326f917ca5c718ce6e7",
        "packageNameBefore": "org.hibernate.boot.model.internal",
        "classNameBefore": "org.hibernate.boot.model.internal.QueryBinder",
        "methodNameBefore": "org.hibernate.boot.model.internal.QueryBinder#bindNativeQuery",
        "invokedMethod": "methodSignature: org.hibernate.boot.model.internal.QueryBinder#getCacheMode\n methodBody: private static CacheMode getCacheMode(CacheRetrieveMode cacheRetrieveMode, CacheStoreMode cacheStoreMode) {\nfinal CacheMode cacheMode=CacheMode.fromJpaModes(cacheRetrieveMode,cacheStoreMode);\nreturn cacheMode == null ? CacheMode.NORMAL : cacheMode;\n}\nmethodSignature: org.hibernate.boot.model.internal.QueryBinder#illegalCallSyntax\n methodBody: private static AnnotationException illegalCallSyntax(org.hibernate.annotations.NamedNativeQuery queryAnn) {\nreturn new AnnotationException(\"Callable 'NamedNativeQuery' named '\" + queryAnn.name() + \"' does not use the JDBC call syntax\");\n}\nmethodSignature: org.hibernate.boot.model.internal.QueryBinder#createStoredProcedure\n methodBody: public static NamedProcedureCallDefinition createStoredProcedure(\n\t\t\tNamedNativeQueryDefinition.Builder<?> builder,\n\t\t\tMetadataBuildingContext context,\n\t\t\tSupplier<RuntimeException> exceptionProducer) {\nfinal String sqlString=builder.getSqlString().trim();\nif(!sqlString.startsWith(\"{\") || !sqlString.endsWith(\"}\")){throw exceptionProducer.get();\n}final JdbcCall jdbcCall=parseJdbcCall(sqlString,exceptionProducer);\nfinal SourceModelBuildingContext sourceModelBuildingContext=context.getMetadataCollector().getSourceModelBuildingContext();\nfinal NamedStoredProcedureQueryJpaAnnotation nameStoredProcedureQueryAnn=JpaAnnotations.NAMED_STORED_PROCEDURE_QUERY.createUsage(sourceModelBuildingContext);\nnameStoredProcedureQueryAnn.name(builder.getName());\nnameStoredProcedureQueryAnn.procedureName(jdbcCall.callableName);\nfinal StoredProcedureParameter[] parameters=new StoredProcedureParameter[jdbcCall.parameters.size()];\nnameStoredProcedureQueryAnn.parameters(parameters);\nfor(int i=0; i < jdbcCall.parameters.size(); i++){final StoredProcedureParameterJpaAnnotation param=JpaAnnotations.STORED_PROCEDURE_PARAMETER.createUsage(sourceModelBuildingContext);\nparameters[i]=param;\nfinal String paramName=jdbcCall.parameters.get(i);\nparam.name(paramName);\nparam.mode(ParameterMode.IN);\nfinal String typeName=builder.getParameterTypes().get(paramName);\nfinal ClassDetails classDetails;\nif(StringHelper.isEmpty(typeName)){classDetails=ClassDetails.VOID_CLASS_DETAILS;\n}{final BasicType<Object> registeredType=context.getBootstrapContext().getTypeConfiguration().getBasicTypeRegistry().getRegisteredType(typeName);\nclassDetails=context.getMetadataCollector().getClassDetailsRegistry().getClassDetails(registeredType.getJavaType().getName());\n}param.type(classDetails.toJavaClass());\n}if(builder.getResultSetMappingName() != null){nameStoredProcedureQueryAnn.resultSetMappings(new String[]{builder.getResultSetMappingName()});\n}final Class<?> resultClass=builder.getResultClass();\nif(resultClass != null){nameStoredProcedureQueryAnn.resultClasses(new Class[]{builder.getResultClass()});\n}final List<QueryHintJpaAnnotation> hints=new ArrayList<>();\nif(builder.getQuerySpaces() != null){final QueryHintJpaAnnotation hint=JpaAnnotations.QUERY_HINT.createUsage(sourceModelBuildingContext);\nhint.name(HibernateHints.HINT_NATIVE_SPACES);\nhint.value(String.join(\" \",builder.getQuerySpaces()));\nhints.add(hint);\n}if(jdbcCall.resultParameter){final QueryHintJpaAnnotation hint=JpaAnnotations.QUERY_HINT.createUsage(sourceModelBuildingContext);\nhint.name(HibernateHints.HINT_CALLABLE_FUNCTION);\nhint.value(\"true\");\nhints.add(hint);\n}nameStoredProcedureQueryAnn.hints(hints.toArray(QueryHint[]::new));\nreturn new NamedProcedureCallDefinitionImpl(nameStoredProcedureQueryAnn);\n}\nmethodSignature: org.hibernate.boot.model.internal.QueryBinder#getFlushMode\n methodBody: private static FlushMode getFlushMode(FlushModeType flushModeType) {\nreturn switch (flushModeType) {\ncase ALWAYS ->  yield FlushMode.ALWAYS;\ncase AUTO ->yield FlushMode.AUTO;\ncase COMMIT ->yield FlushMode.COMMIT;\ncase MANUAL ->yield FlushMode.MANUAL;\ncase PERSISTENCE_CONTEXT ->yield null;\n}\n;\n}",
        "classSignatureBefore": "public abstract class QueryBinder ",
        "methodNameBeforeSet": [
            "org.hibernate.boot.model.internal.QueryBinder#bindNativeQuery"
        ],
        "classNameBeforeSet": [
            "org.hibernate.boot.model.internal.QueryBinder"
        ],
        "classSignatureBeforeSet": [
            "public abstract class QueryBinder "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n * See the lgpl.txt file in the root directory or http://www.gnu.org/licenses/lgpl-2.1.html.\n */\npackage org.hibernate.boot.model.internal;\n\nimport java.lang.invoke.MethodHandles;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.function.Supplier;\n\nimport org.hibernate.AnnotationException;\nimport org.hibernate.CacheMode;\nimport org.hibernate.FlushMode;\nimport org.hibernate.annotations.FlushModeType;\nimport org.hibernate.annotations.HQLSelect;\nimport org.hibernate.annotations.SQLSelect;\nimport org.hibernate.boot.internal.NamedHqlQueryDefinitionImpl;\nimport org.hibernate.boot.internal.NamedProcedureCallDefinitionImpl;\nimport org.hibernate.boot.models.JpaAnnotations;\nimport org.hibernate.boot.models.annotations.internal.NamedStoredProcedureQueryJpaAnnotation;\nimport org.hibernate.boot.models.annotations.internal.QueryHintJpaAnnotation;\nimport org.hibernate.boot.models.annotations.internal.StoredProcedureParameterJpaAnnotation;\nimport org.hibernate.boot.query.NamedHqlQueryDefinition;\nimport org.hibernate.boot.query.NamedNativeQueryDefinition;\nimport org.hibernate.boot.query.NamedProcedureCallDefinition;\nimport org.hibernate.boot.query.SqlResultSetMappingDescriptor;\nimport org.hibernate.boot.registry.classloading.spi.ClassLoaderService;\nimport org.hibernate.boot.spi.MetadataBuildingContext;\nimport org.hibernate.internal.CoreMessageLogger;\nimport org.hibernate.internal.log.DeprecationLogger;\nimport org.hibernate.internal.util.collections.ArrayHelper;\nimport org.hibernate.jpa.HibernateHints;\nimport org.hibernate.models.internal.util.StringHelper;\nimport org.hibernate.models.spi.ClassDetails;\nimport org.hibernate.models.spi.SourceModelBuildingContext;\nimport org.hibernate.query.sql.internal.ParameterParser;\nimport org.hibernate.query.sql.spi.ParameterRecognizer;\nimport org.hibernate.type.BasicType;\n\nimport org.jboss.logging.Logger;\n\nimport jakarta.persistence.CacheRetrieveMode;\nimport jakarta.persistence.CacheStoreMode;\nimport jakarta.persistence.NamedNativeQuery;\nimport jakarta.persistence.NamedQuery;\nimport jakarta.persistence.NamedStoredProcedureQuery;\nimport jakarta.persistence.ParameterMode;\nimport jakarta.persistence.QueryHint;\nimport jakarta.persistence.SqlResultSetMapping;\nimport jakarta.persistence.StoredProcedureParameter;\n\nimport static java.lang.Boolean.TRUE;\nimport static org.hibernate.internal.util.StringHelper.nullIfEmpty;\nimport static org.hibernate.internal.util.collections.CollectionHelper.determineProperSizing;\nimport static org.hibernate.internal.util.collections.CollectionHelper.setOf;\n\n/**\n * Responsible for reading named queries defined in annotations and registering\n * {@link org.hibernate.boot.query.NamedQueryDefinition} objects.\n *\n * @implNote This class is stateless, unlike most of the other \"binders\".\n *\n * @author Emmanuel Bernard\n */\npublic abstract class QueryBinder {\n\tprivate static final CoreMessageLogger LOG = Logger.getMessageLogger( MethodHandles.lookup(), CoreMessageLogger.class, QueryBinder.class.getName() );\n\n\tpublic static void bindQuery(\n\t\t\tNamedQuery namedQuery,\n\t\t\tMetadataBuildingContext context,\n\t\t\tboolean isDefault) {\n\t\tif ( namedQuery == null ) {\n\t\t\treturn;\n\t\t}\n\n\t\tfinal String queryName = namedQuery.name();\n\t\tfinal String queryString = namedQuery.query();\n\n\t\tif ( queryName.isEmpty() ) {\n\t\t\tthrow new AnnotationException( \"Class or package level '@NamedQuery' annotation must specify a 'name'\" );\n\t\t}\n\n\t\tif ( LOG.isDebugEnabled() ) {\n\t\t\tLOG.debugf( \"Binding named query: %s => %s\", queryName, queryString );\n\t\t}\n\n\t\tfinal QueryHintDefinition hints = new QueryHintDefinition( queryName, namedQuery.hints() );\n\n\t\tfinal NamedHqlQueryDefinition<?> queryMapping = new NamedHqlQueryDefinitionImpl.Builder<>( queryName )\n\t\t\t\t.setHqlString( queryString )\n\t\t\t\t.setResultClass( (Class<Object>) namedQuery.resultClass() )\n\t\t\t\t.setCacheable( hints.getCacheability() )\n\t\t\t\t.setCacheMode( hints.getCacheMode() )\n\t\t\t\t.setCacheRegion( hints.getString( HibernateHints.HINT_CACHE_REGION ) )\n\t\t\t\t.setTimeout( hints.getTimeout() )\n\t\t\t\t.setFetchSize( hints.getInteger( HibernateHints.HINT_FETCH_SIZE ) )\n\t\t\t\t.setFlushMode( hints.getFlushMode() )\n\t\t\t\t.setReadOnly( hints.getBooleanWrapper( HibernateHints.HINT_READ_ONLY ) )\n\t\t\t\t.setLockOptions( hints.determineLockOptions( namedQuery ) )\n\t\t\t\t.setComment( hints.getString( HibernateHints.HINT_COMMENT ) )\n\t\t\t\t.build();\n\n\t\tif ( isDefault ) {\n\t\t\tcontext.getMetadataCollector().addDefaultQuery( queryMapping );\n\t\t}\n\t\telse {\n\t\t\tcontext.getMetadataCollector().addNamedQuery( queryMapping );\n\t\t}\n\t}\n\n\tprivate static Class<Object> loadClass(ClassDetails classDetails, MetadataBuildingContext context) {\n\t\treturn ClassDetails.VOID_CLASS_DETAILS == classDetails\n\t\t\t\t? null\n\t\t\t\t: context.getBootstrapContext()\n\t\t\t\t\t\t.getServiceRegistry()\n\t\t\t\t\t\t.requireService( ClassLoaderService.class )\n\t\t\t\t\t\t.classForName( classDetails.getName() );\n\t}\n\n\tpublic static void bindNativeQuery(\n\t\t\tNamedNativeQuery namedNativeQuery,\n\t\t\tMetadataBuildingContext context,\n\t\t\tboolean isDefault) {\n\t\tif ( namedNativeQuery == null ) {\n\t\t\treturn;\n\t\t}\n\n\t\tfinal String registrationName = namedNativeQuery.name();\n\t\tfinal String queryString = namedNativeQuery.query();\n\n\t\tif ( registrationName.isEmpty() ) {\n\t\t\tthrow new AnnotationException( \"Class or package level '@NamedNativeQuery' annotation must specify a 'name'\" );\n\t\t}\n\n\t\tfinal QueryHintDefinition hints = new QueryHintDefinition( registrationName, namedNativeQuery.hints() );\n\n\t\tfinal String resultSetMappingName = namedNativeQuery.resultSetMapping();\n\t\tfinal Class<?> resultClassDetails = namedNativeQuery.resultClass();\n\t\tfinal Class<Object> resultClass = void.class == resultClassDetails\n\t\t\t\t? null\n\t\t\t\t: (Class<Object>) resultClassDetails;\n\n\t\tfinal NamedNativeQueryDefinition.Builder<?> builder = new NamedNativeQueryDefinition.Builder<>( registrationName )\n\t\t\t\t.setSqlString( queryString )\n\t\t\t\t.setResultClass( resultClass )\n\t\t\t\t.setResultSetMappingName( resultSetMappingName )\n\t\t\t\t.setQuerySpaces( null )\n\t\t\t\t.setCacheable( hints.getCacheability() )\n\t\t\t\t.setCacheMode( hints.getCacheMode() )\n\t\t\t\t.setCacheRegion( hints.getString( HibernateHints.HINT_CACHE_REGION ) )\n\t\t\t\t.setTimeout( hints.getTimeout() )\n\t\t\t\t.setFetchSize( hints.getInteger( HibernateHints.HINT_FETCH_SIZE ) )\n\t\t\t\t.setFlushMode( hints.getFlushMode() )\n\t\t\t\t.setReadOnly( hints.getBooleanWrapper( HibernateHints.HINT_READ_ONLY ) )\n\t\t\t\t.setComment( hints.getString( HibernateHints.HINT_COMMENT ) )\n\t\t\t\t.addHints( hints.getHintsMap() );\n\n\t\tfinal NamedNativeQueryDefinition<?> queryDefinition = builder.build();\n\n\t\tif ( LOG.isDebugEnabled() ) {\n\t\t\tLOG.debugf( \"Binding named native query: %s => %s\", queryDefinition.getRegistrationName(), queryDefinition.getSqlQueryString() );\n\t\t}\n\n\t\tif ( isDefault ) {\n\t\t\tcontext.getMetadataCollector().addDefaultNamedNativeQuery( queryDefinition );\n\t\t}\n\t\telse {\n\t\t\tcontext.getMetadataCollector().addNamedNativeQuery( queryDefinition );\n\t\t}\n\t}\n\n\tpublic static void bindNativeQuery(\n\t\t\tString name,\n\t\t\tSQLSelect sqlSelect,\n\t\t\tClassDetails annotatedClass,\n\t\t\tMetadataBuildingContext context) {\n\t\tfinal NamedNativeQueryDefinition.Builder<?> builder = new NamedNativeQueryDefinition.Builder<>( name )\n\t\t\t\t.setFlushMode( FlushMode.MANUAL )\n\t\t\t\t.setSqlString( sqlSelect.sql() )\n\t\t\t\t.setQuerySpaces( setOf( sqlSelect.querySpaces() ) );\n\n\t\tif ( annotatedClass != null ) {\n\t\t\tbuilder.setResultClass(\n\t\t\t\t\tcontext.getBootstrapContext().getServiceRegistry().requireService( ClassLoaderService.class )\n\t\t\t\t\t\t\t.classForName( annotatedClass.getClassName() )\n\t\t\t);\n\t\t}\n\n\t\tfinal SqlResultSetMapping resultSetMapping = sqlSelect.resultSetMapping();\n\t\tif ( !ArrayHelper.isEmpty( resultSetMapping.columns() )\n\t\t\t\t|| !ArrayHelper.isEmpty( resultSetMapping.entities() )\n\t\t\t\t|| !ArrayHelper.isEmpty( resultSetMapping.classes() ) ) {\n\t\t\tcontext.getMetadataCollector().addResultSetMapping( SqlResultSetMappingDescriptor.from( resultSetMapping, name ) );\n\t\t\tbuilder.setResultSetMappingName( name );\n\t\t}\n\n\t\tcontext.getMetadataCollector().addNamedNativeQuery( builder.build() );\n\t}\n\n\tpublic static void bindNativeQuery(\n\t\t\torg.hibernate.annotations.NamedNativeQuery namedNativeQuery,\n\t\t\tMetadataBuildingContext context) {\n\t\tif ( namedNativeQuery == null ) {\n\t\t\treturn;\n\t\t}\n\n\t\tfinal String registrationName = namedNativeQuery.name();\n\n\t\t//ResultSetMappingDefinition mappingDefinition = mappings.getJdbcValuesMappingProducer( queryAnn.resultSetMapping() );\n\t\tif ( registrationName.isEmpty() ) {\n\t\t\tthrow new AnnotationException( \"Class or package level '@NamedNativeQuery' annotation must specify a 'name'\" );\n\t\t}\n\n\t\tfinal String resultSetMappingName = namedNativeQuery.resultSetMapping();\n\t\tfinal Class<?> resultClassDetails = namedNativeQuery.resultClass();\n\t\tfinal Class<Object> resultClass = resultClassDetails == void.class\n\t\t\t\t? null\n\t\t\t\t: (Class<Object>) resultClassDetails;\n\n\t\tfinal Integer timeout = namedNativeQuery.timeout();\n\t\tfinal Integer fetchSize = namedNativeQuery.fetchSize();\n\n\t\tfinal String[] querySpacesList = namedNativeQuery.querySpaces();\n\t\tfinal HashSet<String> querySpaces = new HashSet<>( determineProperSizing( querySpacesList.length ) );\n\t\tCollections.addAll( querySpaces, querySpacesList );\n\n\t\tfinal NamedNativeQueryDefinition.Builder<?> builder = new NamedNativeQueryDefinition.Builder<>( registrationName )\n\t\t\t\t.setSqlString( namedNativeQuery.query() )\n\t\t\t\t.setResultSetMappingName( resultSetMappingName )\n\t\t\t\t.setResultClass( resultClass )\n\t\t\t\t.setCacheable( namedNativeQuery.cacheable() )\n\t\t\t\t.setCacheRegion( nullIfEmpty( namedNativeQuery.cacheRegion() ) )\n\t\t\t\t.setCacheMode( getCacheMode( namedNativeQuery.cacheRetrieveMode(), namedNativeQuery.cacheStoreMode() ) )\n\t\t\t\t.setTimeout( timeout < 0 ? null : timeout )\n\t\t\t\t.setFetchSize( fetchSize < 0 ? null : fetchSize )\n\t\t\t\t.setFlushMode( getFlushMode( namedNativeQuery.flushMode() ) )\n\t\t\t\t.setReadOnly( namedNativeQuery.readOnly() )\n\t\t\t\t.setQuerySpaces( querySpaces )\n\t\t\t\t.setComment( nullIfEmpty( namedNativeQuery.comment() ) );\n\n\t\tif ( TRUE == namedNativeQuery.callable() ) {\n\t\t\tfinal NamedProcedureCallDefinition definition =\n\t\t\t\t\tcreateStoredProcedure( builder, context, () -> illegalCallSyntax( namedNativeQuery ) );\n\t\t\tcontext.getMetadataCollector().addNamedProcedureCallDefinition( definition );\n\t\t\tDeprecationLogger.DEPRECATION_LOGGER.warn(\n\t\t\t\t\t\"Marking named native queries as callable is no longer supported; use '@jakarta.persistence.NamedStoredProcedureQuery' instead. Ignoring.\"\n\t\t\t);\n\t\t}\n\t\telse {\n\t\t\tfinal NamedNativeQueryDefinition<?> queryDefinition = builder.build();\n\n\t\t\tif ( LOG.isDebugEnabled() ) {\n\t\t\t\tLOG.debugf(\n\t\t\t\t\t\t\"Binding named native query: %s => %s\",\n\t\t\t\t\t\tqueryDefinition.getRegistrationName(),\n\t\t\t\t\t\tqueryDefinition.getSqlQueryString()\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tcontext.getMetadataCollector().addNamedNativeQuery( queryDefinition );\n\t\t}\n\t}\n\n\t/**\n\t * Handles legacy cases where a named native query was used to specify a procedure call\n\t *\n\t * @deprecated User should use {@linkplain NamedStoredProcedureQuery} instead\n\t */\n\t@Deprecated\n\tpublic static NamedProcedureCallDefinition createStoredProcedure(\n\t\t\tNamedNativeQueryDefinition.Builder<?> builder,\n\t\t\tMetadataBuildingContext context,\n\t\t\tSupplier<RuntimeException> exceptionProducer) {\n\t\tfinal String sqlString = builder.getSqlString().trim();\n\t\tif ( !sqlString.startsWith( \"{\" ) || !sqlString.endsWith( \"}\" ) ) {\n\t\t\tthrow exceptionProducer.get();\n\t\t}\n\t\tfinal JdbcCall jdbcCall = parseJdbcCall( sqlString, exceptionProducer );\n\n\t\tfinal SourceModelBuildingContext sourceModelBuildingContext = context.getMetadataCollector()\n\t\t\t\t.getSourceModelBuildingContext();\n\t\tfinal NamedStoredProcedureQueryJpaAnnotation nameStoredProcedureQueryAnn = JpaAnnotations.NAMED_STORED_PROCEDURE_QUERY.createUsage( sourceModelBuildingContext );\n\t\tnameStoredProcedureQueryAnn.name( builder.getName() );\n\t\tnameStoredProcedureQueryAnn.procedureName( jdbcCall.callableName );\n\n\t\tfinal StoredProcedureParameter[] parameters = new StoredProcedureParameter[jdbcCall.parameters.size()];\n\t\tnameStoredProcedureQueryAnn.parameters( parameters );\n\n\t\tfor ( int i = 0; i < jdbcCall.parameters.size(); i++ ) {\n\t\t\tfinal StoredProcedureParameterJpaAnnotation param = JpaAnnotations.STORED_PROCEDURE_PARAMETER.createUsage( sourceModelBuildingContext );\n\t\t\tparameters[i] = param;\n\n\t\t\tfinal String paramName = jdbcCall.parameters.get( i );\n\t\t\tparam.name( paramName );\n\t\t\tparam.mode( ParameterMode.IN );\n\n\t\t\tfinal String typeName = builder.getParameterTypes().get( paramName );\n\t\t\tfinal ClassDetails classDetails;\n\t\t\tif ( StringHelper.isEmpty( typeName ) ) {\n\t\t\t\tclassDetails = ClassDetails.VOID_CLASS_DETAILS;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfinal BasicType<Object> registeredType = context.getBootstrapContext()\n\t\t\t\t\t\t.getTypeConfiguration()\n\t\t\t\t\t\t.getBasicTypeRegistry()\n\t\t\t\t\t\t.getRegisteredType( typeName );\n\t\t\t\tclassDetails = context.getMetadataCollector().getClassDetailsRegistry().getClassDetails( registeredType.getJavaType().getName() );\n\t\t\t}\n\t\t\tparam.type( classDetails.toJavaClass() );\n\t\t}\n\n\t\tif ( builder.getResultSetMappingName() != null ) {\n\t\t\tnameStoredProcedureQueryAnn.resultSetMappings( new String[] { builder.getResultSetMappingName() } );\n\t\t}\n\n\t\tfinal Class<?> resultClass = builder.getResultClass();\n\t\tif ( resultClass != null ) {\n\t\t\tnameStoredProcedureQueryAnn.resultClasses( new Class[]{ builder.getResultClass() } );\n\t\t}\n\n\t\tfinal List<QueryHintJpaAnnotation> hints = new ArrayList<>();\n\n\t\tif ( builder.getQuerySpaces() != null ) {\n\t\t\tfinal QueryHintJpaAnnotation hint = JpaAnnotations.QUERY_HINT.createUsage( sourceModelBuildingContext );\n\t\t\thint.name( HibernateHints.HINT_NATIVE_SPACES );\n\t\t\thint.value( String.join( \" \", builder.getQuerySpaces() ) );\n\t\t\thints.add( hint );\n\t\t}\n\n\t\tif ( jdbcCall.resultParameter ) {\n\t\t\t// Mark native queries that have a result parameter as callable functions\n\t\t\tfinal QueryHintJpaAnnotation hint = JpaAnnotations.QUERY_HINT.createUsage( sourceModelBuildingContext );\n\t\t\thint.name( HibernateHints.HINT_CALLABLE_FUNCTION );\n\t\t\thint.value( \"true\" );\n\t\t\thints.add( hint );\n\t\t}\n\n\t\tnameStoredProcedureQueryAnn.hints( hints.toArray(QueryHint[]::new) );\n\n\t\treturn new NamedProcedureCallDefinitionImpl( nameStoredProcedureQueryAnn );\n\t}\n\n\tpublic static void bindQuery(\n\t\t\tString name,\n\t\t\tHQLSelect hqlSelect,\n\t\t\tMetadataBuildingContext context) {\n\t\tfinal NamedHqlQueryDefinition<?> hqlQueryDefinition = new NamedHqlQueryDefinition.Builder<>( name )\n\t\t\t\t.setFlushMode( FlushMode.MANUAL )\n\t\t\t\t.setHqlString( hqlSelect.query() )\n\t\t\t\t.build();\n\n\t\tcontext.getMetadataCollector().addNamedQuery( hqlQueryDefinition );\n\t}\n\n\tpublic static void bindQuery(\n\t\t\torg.hibernate.annotations.NamedQuery namedQuery,\n\t\t\tMetadataBuildingContext context) {\n\t\tif ( namedQuery == null ) {\n\t\t\treturn;\n\t\t}\n\n\t\tfinal String registrationName = namedQuery.name();\n\n\t\t//ResultSetMappingDefinition mappingDefinition = mappings.getJdbcValuesMappingProducer( namedQuery.resultSetMapping() );\n\t\tif ( registrationName.isEmpty() ) {\n\t\t\tthrow new AnnotationException( \"Class or package level '@NamedQuery' annotation must specify a 'name'\" );\n\t\t}\n\n\t\tfinal int timeout = namedQuery.timeout();\n\t\tfinal int fetchSize = namedQuery.fetchSize();\n\n\t\tfinal NamedHqlQueryDefinition.Builder<?> builder = new NamedHqlQueryDefinition.Builder<>( registrationName )\n\t\t\t\t.setHqlString( namedQuery.query() )\n\t\t\t\t.setResultClass( (Class<Object>) namedQuery.resultClass() )\n\t\t\t\t.setCacheable( namedQuery.cacheable() )\n\t\t\t\t.setCacheRegion( nullIfEmpty( namedQuery.cacheRegion() ) )\n\t\t\t\t.setCacheMode( getCacheMode( namedQuery.cacheRetrieveMode(), namedQuery.cacheStoreMode() ) )\n\t\t\t\t.setTimeout( timeout < 0 ? null : timeout )\n\t\t\t\t.setFetchSize( fetchSize < 0 ? null : fetchSize )\n\t\t\t\t.setFlushMode( getFlushMode( namedQuery.flushMode() ) )\n\t\t\t\t.setReadOnly( namedQuery.readOnly() )\n\t\t\t\t.setComment( nullIfEmpty( namedQuery.comment() ) );\n\n\t\tfinal NamedHqlQueryDefinitionImpl<?> hqlQueryDefinition = builder.build();\n\n\t\tif ( LOG.isDebugEnabled() ) {\n\t\t\tLOG.debugf( \"Binding named query: %s => %s\", hqlQueryDefinition.getRegistrationName(), hqlQueryDefinition.getHqlString() );\n\t\t}\n\n\t\tcontext.getMetadataCollector().addNamedQuery( hqlQueryDefinition );\n\t}\n\n\tprivate static CacheMode getCacheMode(CacheRetrieveMode cacheRetrieveMode, CacheStoreMode cacheStoreMode) {\n\t\tfinal CacheMode cacheMode = CacheMode.fromJpaModes( cacheRetrieveMode, cacheStoreMode );\n\t\treturn cacheMode == null ? CacheMode.NORMAL : cacheMode;\n\t}\n\n\tprivate static FlushMode getFlushMode(FlushModeType flushModeType) {\n\t\treturn switch ( flushModeType ) {\n\t\t\tcase ALWAYS -> FlushMode.ALWAYS;\n\t\t\tcase AUTO -> FlushMode.AUTO;\n\t\t\tcase COMMIT -> FlushMode.COMMIT;\n\t\t\tcase MANUAL -> FlushMode.MANUAL;\n\t\t\tcase PERSISTENCE_CONTEXT -> null;\n\t\t};\n\t}\n\n\tpublic static void bindNamedStoredProcedureQuery(\n\t\t\tNamedStoredProcedureQuery namedStoredProcedureQuery,\n\t\t\tMetadataBuildingContext context,\n\t\t\tboolean isDefault) {\n\t\tif ( namedStoredProcedureQuery != null ) {\n\t\t\tif ( namedStoredProcedureQuery.name().isEmpty() ) {\n\t\t\t\tthrow new AnnotationException( \"Class or package level '@NamedStoredProcedureQuery' annotation must specify a 'name'\" );\n\t\t\t}\n\n\t\t\tfinal NamedProcedureCallDefinitionImpl definition = new NamedProcedureCallDefinitionImpl( namedStoredProcedureQuery );\n\t\t\tif ( isDefault ) {\n\t\t\t\tcontext.getMetadataCollector().addDefaultNamedProcedureCall( definition );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcontext.getMetadataCollector().addNamedProcedureCallDefinition( definition );\n\t\t\t}\n\t\t\tLOG.debugf( \"Bound named stored procedure query : %s => %s\", definition.getRegistrationName(), definition.getProcedureName() );\n\t\t}\n\t}\n\n\tpublic static void bindSqlResultSetMapping(\n\t\t\tSqlResultSetMapping resultSetMappingAnn,\n\t\t\tMetadataBuildingContext context,\n\t\t\tboolean isDefault) {\n\t\t//no need to handle inSecondPass\n\t\tcontext.getMetadataCollector().addSecondPass( new ResultSetMappingSecondPass( resultSetMappingAnn, context, isDefault ) );\n\t}\n\n\tprivate static class JdbcCall {\n\t\tprivate final String callableName;\n\t\tprivate final boolean resultParameter;\n\t\tprivate final ArrayList<String> parameters;\n\n\t\tpublic JdbcCall(String callableName, boolean resultParameter, ArrayList<String> parameters) {\n\t\t\tthis.callableName = callableName;\n\t\t\tthis.resultParameter = resultParameter;\n\t\t\tthis.parameters = parameters;\n\t\t}\n\t}\n\n\tprivate static JdbcCall parseJdbcCall(String sqlString, Supplier<RuntimeException> exceptionProducer) {\n\t\tString callableName = null;\n\t\tboolean resultParameter = false;\n\t\tint index = skipWhitespace( sqlString, 1 );\n\t\t// Parse the out param `?=` part\n\t\tif ( sqlString.charAt( index ) == '?' ) {\n\t\t\tresultParameter = true;\n\t\t\tindex++;\n\t\t\tindex = skipWhitespace( sqlString, index );\n\t\t\tif ( sqlString.charAt( index ) != '=' ) {\n\t\t\t\tthrow exceptionProducer.get();\n\t\t\t}\n\t\t\tindex++;\n\t\t\tindex = skipWhitespace( sqlString, index );\n\t\t}\n\t\t// Parse the call keyword\n\t\tif ( !sqlString.regionMatches( true, index, \"call\", 0, 4 ) ) {\n\t\t\tthrow exceptionProducer.get();\n\t\t}\n\t\tindex += 4;\n\t\tindex = skipWhitespace( sqlString, index );\n\n\t\t// Parse the procedure name\n\t\tfinal int procedureStart = index;\n\t\tfor ( ; index < sqlString.length(); index++ ) {\n\t\t\tfinal char c = sqlString.charAt( index );\n\t\t\tif ( c == '(' || Character.isWhitespace( c ) ) {\n\t\t\t\tcallableName = sqlString.substring( procedureStart, index );\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tindex = skipWhitespace( sqlString, index );\n\t\tfinal ArrayList<String> parameters = new ArrayList<>();\n\t\tParameterParser.parse(\n\t\t\t\tsqlString.substring( index, sqlString.length() - 1 ),\n\t\t\t\tnew ParameterRecognizer() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void ordinalParameter(int sourcePosition) {\n\t\t\t\t\t\tparameters.add( \"\" );\n\t\t\t\t\t}\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void namedParameter(String name, int sourcePosition) {\n\t\t\t\t\t\tparameters.add( name );\n\t\t\t\t\t}\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void jpaPositionalParameter(int label, int sourcePosition) {\n\t\t\t\t\t\tparameters.add( \"\" );\n\t\t\t\t\t}\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void other(char character) {\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t);\n\t\treturn new JdbcCall( callableName, resultParameter, parameters );\n\t}\n\n\tprivate static int skipWhitespace(String sqlString, int i) {\n\t\twhile ( i < sqlString.length() ) {\n\t\t\tif ( !Character.isWhitespace( sqlString.charAt( i ) ) ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\treturn i;\n\t}\n\n\tprivate static AnnotationException illegalCallSyntax(org.hibernate.annotations.NamedNativeQuery queryAnn) {\n\t\treturn new AnnotationException( \"Callable 'NamedNativeQuery' named '\" + queryAnn.name()\n\t\t\t\t+ \"' does not use the JDBC call syntax\" );\n\t}\n}\n",
        "filePathAfter": "hibernate-core/src/main/java/org/hibernate/boot/model/internal/QueryBinder.java",
        "sourceCodeAfterForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n * See the lgpl.txt file in the root directory or http://www.gnu.org/licenses/lgpl-2.1.html.\n */\npackage org.hibernate.boot.model.internal;\n\nimport java.lang.invoke.MethodHandles;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.function.Supplier;\n\nimport org.hibernate.AnnotationException;\nimport org.hibernate.CacheMode;\nimport org.hibernate.FlushMode;\nimport org.hibernate.LockOptions;\nimport org.hibernate.annotations.FlushModeType;\nimport org.hibernate.annotations.HQLSelect;\nimport org.hibernate.annotations.SQLSelect;\nimport org.hibernate.boot.internal.NamedHqlQueryDefinitionImpl;\nimport org.hibernate.boot.internal.NamedProcedureCallDefinitionImpl;\nimport org.hibernate.boot.models.JpaAnnotations;\nimport org.hibernate.boot.models.annotations.internal.NamedStoredProcedureQueryJpaAnnotation;\nimport org.hibernate.boot.models.annotations.internal.QueryHintJpaAnnotation;\nimport org.hibernate.boot.models.annotations.internal.StoredProcedureParameterJpaAnnotation;\nimport org.hibernate.boot.query.NamedHqlQueryDefinition;\nimport org.hibernate.boot.query.NamedNativeQueryDefinition;\nimport org.hibernate.boot.query.NamedProcedureCallDefinition;\nimport org.hibernate.boot.query.SqlResultSetMappingDescriptor;\nimport org.hibernate.boot.registry.classloading.spi.ClassLoaderService;\nimport org.hibernate.boot.spi.MetadataBuildingContext;\nimport org.hibernate.internal.CoreMessageLogger;\nimport org.hibernate.internal.log.DeprecationLogger;\nimport org.hibernate.jpa.HibernateHints;\nimport org.hibernate.models.internal.util.StringHelper;\nimport org.hibernate.models.spi.ClassDetails;\nimport org.hibernate.models.spi.SourceModelBuildingContext;\nimport org.hibernate.query.sql.internal.ParameterParser;\nimport org.hibernate.query.sql.spi.ParameterRecognizer;\nimport org.hibernate.type.BasicType;\n\nimport org.jboss.logging.Logger;\n\nimport jakarta.persistence.CacheRetrieveMode;\nimport jakarta.persistence.CacheStoreMode;\nimport jakarta.persistence.NamedNativeQuery;\nimport jakarta.persistence.NamedQuery;\nimport jakarta.persistence.NamedStoredProcedureQuery;\nimport jakarta.persistence.ParameterMode;\nimport jakarta.persistence.QueryHint;\nimport jakarta.persistence.SqlResultSetMapping;\nimport jakarta.persistence.StoredProcedureParameter;\n\nimport static java.lang.Boolean.TRUE;\nimport static org.hibernate.internal.util.StringHelper.nullIfEmpty;\nimport static org.hibernate.internal.util.collections.ArrayHelper.isEmpty;\nimport static org.hibernate.internal.util.collections.CollectionHelper.determineProperSizing;\nimport static org.hibernate.internal.util.collections.CollectionHelper.setOf;\n\n/**\n * Responsible for reading named queries defined in annotations and registering\n * {@link org.hibernate.boot.query.NamedQueryDefinition} objects.\n *\n * @implNote This class is stateless, unlike most of the other \"binders\".\n *\n * @author Emmanuel Bernard\n */\npublic abstract class QueryBinder {\n\tprivate static final CoreMessageLogger LOG = Logger.getMessageLogger( MethodHandles.lookup(), CoreMessageLogger.class, QueryBinder.class.getName() );\n\n\tpublic static void bindQuery(\n\t\t\tNamedQuery namedQuery,\n\t\t\tMetadataBuildingContext context,\n\t\t\tboolean isDefault) {\n\t\tif ( namedQuery == null ) {\n\t\t\treturn;\n\t\t}\n\n\t\tfinal String queryName = namedQuery.name();\n\t\tfinal String queryString = namedQuery.query();\n\t\tfinal Class<?> resultClass = namedQuery.resultClass();\n\n\t\tif ( queryName.isEmpty() ) {\n\t\t\tthrow new AnnotationException( \"Class or package level '@NamedQuery' annotation must specify a 'name'\" );\n\t\t}\n\n\t\tif ( LOG.isDebugEnabled() ) {\n\t\t\tLOG.debugf( \"Binding named query: %s => %s\", queryName, queryString );\n\t\t}\n\n\t\tfinal QueryHintDefinition hints = new QueryHintDefinition( queryName, namedQuery.hints() );\n\t\tfinal NamedHqlQueryDefinition<?> queryMapping =\n\t\t\t\tcreateNamedQueryDefinition( queryName, queryString, resultClass,\n\t\t\t\t\t\thints.determineLockOptions( namedQuery ), hints );\n\t\tif ( isDefault ) {\n\t\t\tcontext.getMetadataCollector().addDefaultQuery( queryMapping );\n\t\t}\n\t\telse {\n\t\t\tcontext.getMetadataCollector().addNamedQuery( queryMapping );\n\t\t}\n\t}\n\n\tprivate static <T> NamedHqlQueryDefinitionImpl<T> createNamedQueryDefinition(\n\t\t\tString queryName, String queryString, Class<T> resultClass, LockOptions lockOptions,\n\t\t\tQueryHintDefinition hints) {\n\t\treturn new NamedHqlQueryDefinitionImpl.Builder<T>(queryName)\n\t\t\t\t.setHqlString(queryString)\n\t\t\t\t.setResultClass(resultClass)\n\t\t\t\t.setCacheable(hints.getCacheability())\n\t\t\t\t.setCacheMode(hints.getCacheMode())\n\t\t\t\t.setCacheRegion(hints.getString(HibernateHints.HINT_CACHE_REGION))\n\t\t\t\t.setTimeout(hints.getTimeout())\n\t\t\t\t.setFetchSize(hints.getInteger(HibernateHints.HINT_FETCH_SIZE))\n\t\t\t\t.setFlushMode(hints.getFlushMode())\n\t\t\t\t.setReadOnly(hints.getBooleanWrapper(HibernateHints.HINT_READ_ONLY))\n\t\t\t\t.setLockOptions(lockOptions)\n\t\t\t\t.setComment(hints.getString(HibernateHints.HINT_COMMENT))\n\t\t\t\t.build();\n\t}\n\n\tpublic static void bindNativeQuery(\n\t\t\tNamedNativeQuery namedNativeQuery,\n\t\t\tMetadataBuildingContext context,\n\t\t\tboolean isDefault) {\n\t\tif ( namedNativeQuery == null ) {\n\t\t\treturn;\n\t\t}\n\n\t\tfinal String registrationName = namedNativeQuery.name();\n\t\tfinal String queryString = namedNativeQuery.query();\n\n\t\tif ( registrationName.isEmpty() ) {\n\t\t\tthrow new AnnotationException( \"Class or package level '@NamedNativeQuery' annotation must specify a 'name'\" );\n\t\t}\n\n\t\tfinal QueryHintDefinition hints = new QueryHintDefinition( registrationName, namedNativeQuery.hints() );\n\n\t\tfinal String resultSetMappingName = namedNativeQuery.resultSetMapping();\n\t\tfinal Class<?> resultClassDetails = namedNativeQuery.resultClass();\n\t\tfinal Class<?> resultClass = void.class == resultClassDetails ? null : resultClassDetails;\n\n\t\tfinal NamedNativeQueryDefinition<?> queryDefinition =\n\t\t\t\tcreateNamedQueryDefinition( registrationName, queryString, resultClass, resultSetMappingName, hints );\n\n\t\tif ( LOG.isDebugEnabled() ) {\n\t\t\tLOG.debugf( \"Binding named native query: %s => %s\",\n\t\t\t\t\tqueryDefinition.getRegistrationName(), queryDefinition.getSqlQueryString() );\n\t\t}\n\n\t\tif ( isDefault ) {\n\t\t\tcontext.getMetadataCollector().addDefaultNamedNativeQuery( queryDefinition );\n\t\t}\n\t\telse {\n\t\t\tcontext.getMetadataCollector().addNamedNativeQuery( queryDefinition );\n\t\t}\n\t}\n\n\tprivate static <T> NamedNativeQueryDefinition<T> createNamedQueryDefinition(\n\t\t\tString registrationName, String queryString,\n\t\t\tClass<T> resultClass, String resultSetMappingName,\n\t\t\tQueryHintDefinition hints) {\n\t\treturn new NamedNativeQueryDefinition.Builder<T>(registrationName)\n\t\t\t\t.setSqlString(queryString)\n\t\t\t\t.setResultClass(resultClass)\n\t\t\t\t.setResultSetMappingName(resultSetMappingName)\n\t\t\t\t.setQuerySpaces(null)\n\t\t\t\t.setCacheable(hints.getCacheability())\n\t\t\t\t.setCacheMode(hints.getCacheMode())\n\t\t\t\t.setCacheRegion(hints.getString(HibernateHints.HINT_CACHE_REGION))\n\t\t\t\t.setTimeout(hints.getTimeout())\n\t\t\t\t.setFetchSize(hints.getInteger(HibernateHints.HINT_FETCH_SIZE))\n\t\t\t\t.setFlushMode(hints.getFlushMode())\n\t\t\t\t.setReadOnly(hints.getBooleanWrapper(HibernateHints.HINT_READ_ONLY))\n\t\t\t\t.setComment(hints.getString(HibernateHints.HINT_COMMENT))\n\t\t\t\t.addHints(hints.getHintsMap())\n\t\t\t\t.build();\n\t}\n\n\tpublic static void bindNativeQuery(\n\t\t\tString name,\n\t\t\tSQLSelect sqlSelect,\n\t\t\tClassDetails annotatedClass,\n\t\t\tMetadataBuildingContext context) {\n\t\tfinal NamedNativeQueryDefinition.Builder<?> builder = new NamedNativeQueryDefinition.Builder<>( name )\n\t\t\t\t.setFlushMode( FlushMode.MANUAL )\n\t\t\t\t.setSqlString( sqlSelect.sql() )\n\t\t\t\t.setQuerySpaces( setOf( sqlSelect.querySpaces() ) );\n\n\t\tif ( annotatedClass != null ) {\n\t\t\tbuilder.setResultClass(\n\t\t\t\t\tcontext.getBootstrapContext().getServiceRegistry().requireService( ClassLoaderService.class )\n\t\t\t\t\t\t\t.classForName( annotatedClass.getClassName() )\n\t\t\t);\n\t\t}\n\n\t\tfinal SqlResultSetMapping resultSetMapping = sqlSelect.resultSetMapping();\n\t\tif ( !isEmpty( resultSetMapping.columns() )\n\t\t\t\t|| !isEmpty( resultSetMapping.entities() )\n\t\t\t\t|| !isEmpty( resultSetMapping.classes() ) ) {\n\t\t\tcontext.getMetadataCollector()\n\t\t\t\t\t.addResultSetMapping( SqlResultSetMappingDescriptor.from( resultSetMapping, name ) );\n\t\t\tbuilder.setResultSetMappingName( name );\n\t\t}\n\n\t\tcontext.getMetadataCollector().addNamedNativeQuery( builder.build() );\n\t}\n\n\tpublic static void bindNativeQuery(\n\t\t\torg.hibernate.annotations.NamedNativeQuery namedNativeQuery,\n\t\t\tMetadataBuildingContext context) {\n\t\tif ( namedNativeQuery == null ) {\n\t\t\treturn;\n\t\t}\n\n\t\tfinal String registrationName = namedNativeQuery.name();\n\n\t\tif ( registrationName.isEmpty() ) {\n\t\t\tthrow new AnnotationException( \"Class or package level '@NamedNativeQuery' annotation must specify a 'name'\" );\n\t\t}\n\n\t\tfinal String resultSetMappingName = namedNativeQuery.resultSetMapping();\n\t\tfinal Class<?> resultClassDetails = namedNativeQuery.resultClass();\n\t\tfinal Class<?> resultClass = resultClassDetails == void.class ? null : resultClassDetails;\n\n\t\tfinal String[] querySpacesList = namedNativeQuery.querySpaces();\n\t\tfinal HashSet<String> querySpaces = new HashSet<>( determineProperSizing( querySpacesList.length ) );\n\t\tCollections.addAll( querySpaces, querySpacesList );\n\n\t\tfinal NamedNativeQueryDefinition.Builder<?> builder =\n\t\t\t\tcreateQueryDefinition( namedNativeQuery, registrationName, resultSetMappingName, resultClass,\n\t\t\t\t\t\tnamedNativeQuery.timeout(), namedNativeQuery.fetchSize(), querySpaces );\n\n\t\tif ( TRUE == namedNativeQuery.callable() ) {\n\t\t\tfinal NamedProcedureCallDefinition definition =\n\t\t\t\t\tcreateStoredProcedure( builder, context, () -> illegalCallSyntax( namedNativeQuery ) );\n\t\t\tcontext.getMetadataCollector().addNamedProcedureCallDefinition( definition );\n\t\t\tDeprecationLogger.DEPRECATION_LOGGER.warn(\n\t\t\t\t\t\"Marking named native queries as callable is no longer supported; use '@jakarta.persistence.NamedStoredProcedureQuery' instead. Ignoring.\"\n\t\t\t);\n\t\t}\n\t\telse {\n\t\t\tfinal NamedNativeQueryDefinition<?> queryDefinition = builder.build();\n\n\t\t\tif ( LOG.isDebugEnabled() ) {\n\t\t\t\tLOG.debugf(\n\t\t\t\t\t\t\"Binding named native query: %s => %s\",\n\t\t\t\t\t\tqueryDefinition.getRegistrationName(),\n\t\t\t\t\t\tqueryDefinition.getSqlQueryString()\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tcontext.getMetadataCollector().addNamedNativeQuery( queryDefinition );\n\t\t}\n\t}\n\n\tprivate static <T> NamedNativeQueryDefinition.Builder<T> createQueryDefinition(\n\t\t\torg.hibernate.annotations.NamedNativeQuery namedNativeQuery,\n\t\t\tString registrationName, String resultSetMappingName,\n\t\t\tClass<T> resultClass,\n\t\t\tint timeout, int fetchSize,\n\t\t\tHashSet<String> querySpaces) {\n\t\treturn new NamedNativeQueryDefinition.Builder<T>(registrationName)\n\t\t\t\t.setSqlString(namedNativeQuery.query())\n\t\t\t\t.setResultSetMappingName(resultSetMappingName)\n\t\t\t\t.setResultClass(resultClass)\n\t\t\t\t.setCacheable(namedNativeQuery.cacheable())\n\t\t\t\t.setCacheRegion(nullIfEmpty(namedNativeQuery.cacheRegion()))\n\t\t\t\t.setCacheMode(getCacheMode(namedNativeQuery.cacheRetrieveMode(), namedNativeQuery.cacheStoreMode()))\n\t\t\t\t.setTimeout(timeout < 0 ? null : timeout)\n\t\t\t\t.setFetchSize(fetchSize < 0 ? null : fetchSize)\n\t\t\t\t.setFlushMode(getFlushMode(namedNativeQuery.flushMode()))\n\t\t\t\t.setReadOnly(namedNativeQuery.readOnly())\n\t\t\t\t.setQuerySpaces(querySpaces)\n\t\t\t\t.setComment(nullIfEmpty(namedNativeQuery.comment()));\n\t}\n\n\t/**\n\t * Handles legacy cases where a named native query was used to specify a procedure call\n\t *\n\t * @deprecated User should use {@linkplain NamedStoredProcedureQuery} instead\n\t */\n\t@Deprecated\n\tpublic static NamedProcedureCallDefinition createStoredProcedure(\n\t\t\tNamedNativeQueryDefinition.Builder<?> builder,\n\t\t\tMetadataBuildingContext context,\n\t\t\tSupplier<RuntimeException> exceptionProducer) {\n\t\tfinal String sqlString = builder.getSqlString().trim();\n\t\tif ( !sqlString.startsWith( \"{\" ) || !sqlString.endsWith( \"}\" ) ) {\n\t\t\tthrow exceptionProducer.get();\n\t\t}\n\t\tfinal JdbcCall jdbcCall = parseJdbcCall( sqlString, exceptionProducer );\n\n\t\tfinal SourceModelBuildingContext sourceModelBuildingContext = context.getMetadataCollector()\n\t\t\t\t.getSourceModelBuildingContext();\n\t\tfinal NamedStoredProcedureQueryJpaAnnotation nameStoredProcedureQueryAnn =\n\t\t\t\tJpaAnnotations.NAMED_STORED_PROCEDURE_QUERY.createUsage( sourceModelBuildingContext );\n\t\tnameStoredProcedureQueryAnn.name( builder.getName() );\n\t\tnameStoredProcedureQueryAnn.procedureName( jdbcCall.callableName );\n\n\t\tfinal StoredProcedureParameter[] parameters = new StoredProcedureParameter[jdbcCall.parameters.size()];\n\t\tnameStoredProcedureQueryAnn.parameters( parameters );\n\n\t\tfor ( int i = 0; i < jdbcCall.parameters.size(); i++ ) {\n\t\t\tfinal StoredProcedureParameterJpaAnnotation param =\n\t\t\t\t\tJpaAnnotations.STORED_PROCEDURE_PARAMETER.createUsage( sourceModelBuildingContext );\n\t\t\tparameters[i] = param;\n\n\t\t\tfinal String paramName = jdbcCall.parameters.get( i );\n\t\t\tparam.name( paramName );\n\t\t\tparam.mode( ParameterMode.IN );\n\n\t\t\tfinal String typeName = builder.getParameterTypes().get( paramName );\n\t\t\tfinal ClassDetails classDetails;\n\t\t\tif ( StringHelper.isEmpty( typeName ) ) {\n\t\t\t\tclassDetails = ClassDetails.VOID_CLASS_DETAILS;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfinal BasicType<Object> registeredType = context.getBootstrapContext()\n\t\t\t\t\t\t.getTypeConfiguration()\n\t\t\t\t\t\t.getBasicTypeRegistry()\n\t\t\t\t\t\t.getRegisteredType( typeName );\n\t\t\t\tclassDetails = context.getMetadataCollector().getClassDetailsRegistry()\n\t\t\t\t\t\t.getClassDetails( registeredType.getJavaType().getName() );\n\t\t\t}\n\t\t\tparam.type( classDetails.toJavaClass() );\n\t\t}\n\n\t\tif ( builder.getResultSetMappingName() != null ) {\n\t\t\tnameStoredProcedureQueryAnn.resultSetMappings( new String[] { builder.getResultSetMappingName() } );\n\t\t}\n\n\t\tfinal Class<?> resultClass = builder.getResultClass();\n\t\tif ( resultClass != null ) {\n\t\t\tnameStoredProcedureQueryAnn.resultClasses( new Class[]{ builder.getResultClass() } );\n\t\t}\n\n\t\tfinal List<QueryHintJpaAnnotation> hints = new ArrayList<>();\n\n\t\tif ( builder.getQuerySpaces() != null ) {\n\t\t\tfinal QueryHintJpaAnnotation hint =\n\t\t\t\t\tJpaAnnotations.QUERY_HINT.createUsage( sourceModelBuildingContext );\n\t\t\thint.name( HibernateHints.HINT_NATIVE_SPACES );\n\t\t\thint.value( String.join( \" \", builder.getQuerySpaces() ) );\n\t\t\thints.add( hint );\n\t\t}\n\n\t\tif ( jdbcCall.resultParameter ) {\n\t\t\t// Mark native queries that have a result parameter as callable functions\n\t\t\tfinal QueryHintJpaAnnotation hint =\n\t\t\t\t\tJpaAnnotations.QUERY_HINT.createUsage( sourceModelBuildingContext );\n\t\t\thint.name( HibernateHints.HINT_CALLABLE_FUNCTION );\n\t\t\thint.value( \"true\" );\n\t\t\thints.add( hint );\n\t\t}\n\n\t\tnameStoredProcedureQueryAnn.hints( hints.toArray(QueryHint[]::new) );\n\n\t\treturn new NamedProcedureCallDefinitionImpl( nameStoredProcedureQueryAnn );\n\t}\n\n\tpublic static void bindQuery(\n\t\t\tString name,\n\t\t\tHQLSelect hqlSelect,\n\t\t\tMetadataBuildingContext context) {\n\t\tfinal NamedHqlQueryDefinition<?> hqlQueryDefinition = new NamedHqlQueryDefinition.Builder<>( name )\n\t\t\t\t.setFlushMode( FlushMode.MANUAL )\n\t\t\t\t.setHqlString( hqlSelect.query() )\n\t\t\t\t.build();\n\n\t\tcontext.getMetadataCollector().addNamedQuery( hqlQueryDefinition );\n\t}\n\n\tpublic static void bindQuery(\n\t\t\torg.hibernate.annotations.NamedQuery namedQuery,\n\t\t\tMetadataBuildingContext context) {\n\t\tif ( namedQuery == null ) {\n\t\t\treturn;\n\t\t}\n\n\t\tfinal String registrationName = namedQuery.name();\n\t\tfinal Class<?> resultClass = namedQuery.resultClass();\n\n\t\tif ( registrationName.isEmpty() ) {\n\t\t\tthrow new AnnotationException( \"Class or package level '@NamedQuery' annotation must specify a 'name'\" );\n\t\t}\n\n\t\tfinal NamedHqlQueryDefinition.Builder<?> builder =\n\t\t\t\tcreateQueryDefinition( namedQuery, registrationName, resultClass,\n\t\t\t\t\t\tnamedQuery.timeout(), namedQuery.fetchSize() ) ;\n\n\t\tfinal NamedHqlQueryDefinitionImpl<?> hqlQueryDefinition = builder.build();\n\n\t\tif ( LOG.isDebugEnabled() ) {\n\t\t\tLOG.debugf( \"Binding named query: %s => %s\",\n\t\t\t\t\thqlQueryDefinition.getRegistrationName(), hqlQueryDefinition.getHqlString() );\n\t\t}\n\n\t\tcontext.getMetadataCollector().addNamedQuery( hqlQueryDefinition );\n\t}\n\n\tprivate static <T> NamedHqlQueryDefinition.Builder<T> createQueryDefinition(\n\t\t\torg.hibernate.annotations.NamedQuery namedQuery,\n\t\t\tString registrationName, Class<T> resultClass, int timeout, int fetchSize) {\n\t\treturn new NamedHqlQueryDefinition.Builder<T>(registrationName)\n\t\t\t\t.setHqlString(namedQuery.query())\n\t\t\t\t.setResultClass(resultClass)\n\t\t\t\t.setCacheable(namedQuery.cacheable())\n\t\t\t\t.setCacheRegion(nullIfEmpty(namedQuery.cacheRegion()))\n\t\t\t\t.setCacheMode(getCacheMode(namedQuery.cacheRetrieveMode(), namedQuery.cacheStoreMode()))\n\t\t\t\t.setTimeout(timeout < 0 ? null : timeout)\n\t\t\t\t.setFetchSize(fetchSize < 0 ? null : fetchSize)\n\t\t\t\t.setFlushMode(getFlushMode(namedQuery.flushMode()))\n\t\t\t\t.setReadOnly(namedQuery.readOnly())\n\t\t\t\t.setComment(nullIfEmpty(namedQuery.comment()));\n\t}\n\n\tprivate static CacheMode getCacheMode(CacheRetrieveMode cacheRetrieveMode, CacheStoreMode cacheStoreMode) {\n\t\tfinal CacheMode cacheMode = CacheMode.fromJpaModes( cacheRetrieveMode, cacheStoreMode );\n\t\treturn cacheMode == null ? CacheMode.NORMAL : cacheMode;\n\t}\n\n\tprivate static FlushMode getFlushMode(FlushModeType flushModeType) {\n\t\treturn switch ( flushModeType ) {\n\t\t\tcase ALWAYS -> FlushMode.ALWAYS;\n\t\t\tcase AUTO -> FlushMode.AUTO;\n\t\t\tcase COMMIT -> FlushMode.COMMIT;\n\t\t\tcase MANUAL -> FlushMode.MANUAL;\n\t\t\tcase PERSISTENCE_CONTEXT -> null;\n\t\t};\n\t}\n\n\tpublic static void bindNamedStoredProcedureQuery(\n\t\t\tNamedStoredProcedureQuery namedStoredProcedureQuery,\n\t\t\tMetadataBuildingContext context,\n\t\t\tboolean isDefault) {\n\t\tif ( namedStoredProcedureQuery != null ) {\n\t\t\tif ( namedStoredProcedureQuery.name().isEmpty() ) {\n\t\t\t\tthrow new AnnotationException( \"Class or package level '@NamedStoredProcedureQuery' annotation must specify a 'name'\" );\n\t\t\t}\n\n\t\t\tfinal NamedProcedureCallDefinitionImpl definition =\n\t\t\t\t\tnew NamedProcedureCallDefinitionImpl( namedStoredProcedureQuery );\n\t\t\tif ( isDefault ) {\n\t\t\t\tcontext.getMetadataCollector().addDefaultNamedProcedureCall( definition );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcontext.getMetadataCollector().addNamedProcedureCallDefinition( definition );\n\t\t\t}\n\t\t\tLOG.debugf( \"Bound named stored procedure query : %s => %s\",\n\t\t\t\t\tdefinition.getRegistrationName(), definition.getProcedureName() );\n\t\t}\n\t}\n\n\tpublic static void bindSqlResultSetMapping(\n\t\t\tSqlResultSetMapping resultSetMappingAnn,\n\t\t\tMetadataBuildingContext context,\n\t\t\tboolean isDefault) {\n\t\t//no need to handle inSecondPass\n\t\tcontext.getMetadataCollector()\n\t\t\t\t.addSecondPass( new ResultSetMappingSecondPass( resultSetMappingAnn, context, isDefault ) );\n\t}\n\n\tprivate static class JdbcCall {\n\t\tprivate final String callableName;\n\t\tprivate final boolean resultParameter;\n\t\tprivate final ArrayList<String> parameters;\n\n\t\tpublic JdbcCall(String callableName, boolean resultParameter, ArrayList<String> parameters) {\n\t\t\tthis.callableName = callableName;\n\t\t\tthis.resultParameter = resultParameter;\n\t\t\tthis.parameters = parameters;\n\t\t}\n\t}\n\n\tprivate static JdbcCall parseJdbcCall(String sqlString, Supplier<RuntimeException> exceptionProducer) {\n\t\tString callableName = null;\n\t\tboolean resultParameter = false;\n\t\tint index = skipWhitespace( sqlString, 1 );\n\t\t// Parse the out param `?=` part\n\t\tif ( sqlString.charAt( index ) == '?' ) {\n\t\t\tresultParameter = true;\n\t\t\tindex++;\n\t\t\tindex = skipWhitespace( sqlString, index );\n\t\t\tif ( sqlString.charAt( index ) != '=' ) {\n\t\t\t\tthrow exceptionProducer.get();\n\t\t\t}\n\t\t\tindex++;\n\t\t\tindex = skipWhitespace( sqlString, index );\n\t\t}\n\t\t// Parse the call keyword\n\t\tif ( !sqlString.regionMatches( true, index, \"call\", 0, 4 ) ) {\n\t\t\tthrow exceptionProducer.get();\n\t\t}\n\t\tindex += 4;\n\t\tindex = skipWhitespace( sqlString, index );\n\n\t\t// Parse the procedure name\n\t\tfinal int procedureStart = index;\n\t\tfor ( ; index < sqlString.length(); index++ ) {\n\t\t\tfinal char c = sqlString.charAt( index );\n\t\t\tif ( c == '(' || Character.isWhitespace( c ) ) {\n\t\t\t\tcallableName = sqlString.substring( procedureStart, index );\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tindex = skipWhitespace( sqlString, index );\n\t\tfinal ArrayList<String> parameters = new ArrayList<>();\n\t\tParameterParser.parse(\n\t\t\t\tsqlString.substring( index, sqlString.length() - 1 ),\n\t\t\t\tnew ParameterRecognizer() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void ordinalParameter(int sourcePosition) {\n\t\t\t\t\t\tparameters.add( \"\" );\n\t\t\t\t\t}\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void namedParameter(String name, int sourcePosition) {\n\t\t\t\t\t\tparameters.add( name );\n\t\t\t\t\t}\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void jpaPositionalParameter(int label, int sourcePosition) {\n\t\t\t\t\t\tparameters.add( \"\" );\n\t\t\t\t\t}\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void other(char character) {\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t);\n\t\treturn new JdbcCall( callableName, resultParameter, parameters );\n\t}\n\n\tprivate static int skipWhitespace(String sqlString, int i) {\n\t\twhile ( i < sqlString.length() ) {\n\t\t\tif ( !Character.isWhitespace( sqlString.charAt( i ) ) ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\treturn i;\n\t}\n\n\tprivate static AnnotationException illegalCallSyntax(org.hibernate.annotations.NamedNativeQuery queryAnn) {\n\t\treturn new AnnotationException( \"Callable 'NamedNativeQuery' named '\" + queryAnn.name()\n\t\t\t\t+ \"' does not use the JDBC call syntax\" );\n\t}\n}\n",
        "diffSourceCodeSet": [
            "private static <T> NamedNativeQueryDefinition.Builder<T> createQueryDefinition(\n\t\t\torg.hibernate.annotations.NamedNativeQuery namedNativeQuery,\n\t\t\tString registrationName, String resultSetMappingName,\n\t\t\tClass<T> resultClass,\n\t\t\tint timeout, int fetchSize,\n\t\t\tHashSet<String> querySpaces) {\n\t\treturn new NamedNativeQueryDefinition.Builder<T>(registrationName)\n\t\t\t\t.setSqlString(namedNativeQuery.query())\n\t\t\t\t.setResultSetMappingName(resultSetMappingName)\n\t\t\t\t.setResultClass(resultClass)\n\t\t\t\t.setCacheable(namedNativeQuery.cacheable())\n\t\t\t\t.setCacheRegion(nullIfEmpty(namedNativeQuery.cacheRegion()))\n\t\t\t\t.setCacheMode(getCacheMode(namedNativeQuery.cacheRetrieveMode(), namedNativeQuery.cacheStoreMode()))\n\t\t\t\t.setTimeout(timeout < 0 ? null : timeout)\n\t\t\t\t.setFetchSize(fetchSize < 0 ? null : fetchSize)\n\t\t\t\t.setFlushMode(getFlushMode(namedNativeQuery.flushMode()))\n\t\t\t\t.setReadOnly(namedNativeQuery.readOnly())\n\t\t\t\t.setQuerySpaces(querySpaces)\n\t\t\t\t.setComment(nullIfEmpty(namedNativeQuery.comment()));\n\t}"
        ],
        "invokedMethodSet": [
            "methodSignature: org.hibernate.boot.model.internal.QueryBinder#getCacheMode\n methodBody: private static CacheMode getCacheMode(CacheRetrieveMode cacheRetrieveMode, CacheStoreMode cacheStoreMode) {\nfinal CacheMode cacheMode=CacheMode.fromJpaModes(cacheRetrieveMode,cacheStoreMode);\nreturn cacheMode == null ? CacheMode.NORMAL : cacheMode;\n}",
            "methodSignature: org.hibernate.boot.model.internal.QueryBinder#illegalCallSyntax\n methodBody: private static AnnotationException illegalCallSyntax(org.hibernate.annotations.NamedNativeQuery queryAnn) {\nreturn new AnnotationException(\"Callable 'NamedNativeQuery' named '\" + queryAnn.name() + \"' does not use the JDBC call syntax\");\n}",
            "methodSignature: org.hibernate.boot.model.internal.QueryBinder#createStoredProcedure\n methodBody: public static NamedProcedureCallDefinition createStoredProcedure(\n\t\t\tNamedNativeQueryDefinition.Builder<?> builder,\n\t\t\tMetadataBuildingContext context,\n\t\t\tSupplier<RuntimeException> exceptionProducer) {\nfinal String sqlString=builder.getSqlString().trim();\nif(!sqlString.startsWith(\"{\") || !sqlString.endsWith(\"}\")){throw exceptionProducer.get();\n}final JdbcCall jdbcCall=parseJdbcCall(sqlString,exceptionProducer);\nfinal SourceModelBuildingContext sourceModelBuildingContext=context.getMetadataCollector().getSourceModelBuildingContext();\nfinal NamedStoredProcedureQueryJpaAnnotation nameStoredProcedureQueryAnn=JpaAnnotations.NAMED_STORED_PROCEDURE_QUERY.createUsage(sourceModelBuildingContext);\nnameStoredProcedureQueryAnn.name(builder.getName());\nnameStoredProcedureQueryAnn.procedureName(jdbcCall.callableName);\nfinal StoredProcedureParameter[] parameters=new StoredProcedureParameter[jdbcCall.parameters.size()];\nnameStoredProcedureQueryAnn.parameters(parameters);\nfor(int i=0; i < jdbcCall.parameters.size(); i++){final StoredProcedureParameterJpaAnnotation param=JpaAnnotations.STORED_PROCEDURE_PARAMETER.createUsage(sourceModelBuildingContext);\nparameters[i]=param;\nfinal String paramName=jdbcCall.parameters.get(i);\nparam.name(paramName);\nparam.mode(ParameterMode.IN);\nfinal String typeName=builder.getParameterTypes().get(paramName);\nfinal ClassDetails classDetails;\nif(StringHelper.isEmpty(typeName)){classDetails=ClassDetails.VOID_CLASS_DETAILS;\n}{final BasicType<Object> registeredType=context.getBootstrapContext().getTypeConfiguration().getBasicTypeRegistry().getRegisteredType(typeName);\nclassDetails=context.getMetadataCollector().getClassDetailsRegistry().getClassDetails(registeredType.getJavaType().getName());\n}param.type(classDetails.toJavaClass());\n}if(builder.getResultSetMappingName() != null){nameStoredProcedureQueryAnn.resultSetMappings(new String[]{builder.getResultSetMappingName()});\n}final Class<?> resultClass=builder.getResultClass();\nif(resultClass != null){nameStoredProcedureQueryAnn.resultClasses(new Class[]{builder.getResultClass()});\n}final List<QueryHintJpaAnnotation> hints=new ArrayList<>();\nif(builder.getQuerySpaces() != null){final QueryHintJpaAnnotation hint=JpaAnnotations.QUERY_HINT.createUsage(sourceModelBuildingContext);\nhint.name(HibernateHints.HINT_NATIVE_SPACES);\nhint.value(String.join(\" \",builder.getQuerySpaces()));\nhints.add(hint);\n}if(jdbcCall.resultParameter){final QueryHintJpaAnnotation hint=JpaAnnotations.QUERY_HINT.createUsage(sourceModelBuildingContext);\nhint.name(HibernateHints.HINT_CALLABLE_FUNCTION);\nhint.value(\"true\");\nhints.add(hint);\n}nameStoredProcedureQueryAnn.hints(hints.toArray(QueryHint[]::new));\nreturn new NamedProcedureCallDefinitionImpl(nameStoredProcedureQueryAnn);\n}",
            "methodSignature: org.hibernate.boot.model.internal.QueryBinder#getFlushMode\n methodBody: private static FlushMode getFlushMode(FlushModeType flushModeType) {\nreturn switch (flushModeType) {\ncase ALWAYS ->  yield FlushMode.ALWAYS;\ncase AUTO ->yield FlushMode.AUTO;\ncase COMMIT ->yield FlushMode.COMMIT;\ncase MANUAL ->yield FlushMode.MANUAL;\ncase PERSISTENCE_CONTEXT ->yield null;\n}\n;\n}"
        ],
        "sourceCodeAfterRefactoring": "public static void bindNativeQuery(\n\t\t\torg.hibernate.annotations.NamedNativeQuery namedNativeQuery,\n\t\t\tMetadataBuildingContext context) {\n\t\tif ( namedNativeQuery == null ) {\n\t\t\treturn;\n\t\t}\n\n\t\tfinal String registrationName = namedNativeQuery.name();\n\n\t\tif ( registrationName.isEmpty() ) {\n\t\t\tthrow new AnnotationException( \"Class or package level '@NamedNativeQuery' annotation must specify a 'name'\" );\n\t\t}\n\n\t\tfinal String resultSetMappingName = namedNativeQuery.resultSetMapping();\n\t\tfinal Class<?> resultClassDetails = namedNativeQuery.resultClass();\n\t\tfinal Class<?> resultClass = resultClassDetails == void.class ? null : resultClassDetails;\n\n\t\tfinal String[] querySpacesList = namedNativeQuery.querySpaces();\n\t\tfinal HashSet<String> querySpaces = new HashSet<>( determineProperSizing( querySpacesList.length ) );\n\t\tCollections.addAll( querySpaces, querySpacesList );\n\n\t\tfinal NamedNativeQueryDefinition.Builder<?> builder =\n\t\t\t\tcreateQueryDefinition( namedNativeQuery, registrationName, resultSetMappingName, resultClass,\n\t\t\t\t\t\tnamedNativeQuery.timeout(), namedNativeQuery.fetchSize(), querySpaces );\n\n\t\tif ( TRUE == namedNativeQuery.callable() ) {\n\t\t\tfinal NamedProcedureCallDefinition definition =\n\t\t\t\t\tcreateStoredProcedure( builder, context, () -> illegalCallSyntax( namedNativeQuery ) );\n\t\t\tcontext.getMetadataCollector().addNamedProcedureCallDefinition( definition );\n\t\t\tDeprecationLogger.DEPRECATION_LOGGER.warn(\n\t\t\t\t\t\"Marking named native queries as callable is no longer supported; use '@jakarta.persistence.NamedStoredProcedureQuery' instead. Ignoring.\"\n\t\t\t);\n\t\t}\n\t\telse {\n\t\t\tfinal NamedNativeQueryDefinition<?> queryDefinition = builder.build();\n\n\t\t\tif ( LOG.isDebugEnabled() ) {\n\t\t\t\tLOG.debugf(\n\t\t\t\t\t\t\"Binding named native query: %s => %s\",\n\t\t\t\t\t\tqueryDefinition.getRegistrationName(),\n\t\t\t\t\t\tqueryDefinition.getSqlQueryString()\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tcontext.getMetadataCollector().addNamedNativeQuery( queryDefinition );\n\t\t}\n\t}\nprivate static <T> NamedNativeQueryDefinition.Builder<T> createQueryDefinition(\n\t\t\torg.hibernate.annotations.NamedNativeQuery namedNativeQuery,\n\t\t\tString registrationName, String resultSetMappingName,\n\t\t\tClass<T> resultClass,\n\t\t\tint timeout, int fetchSize,\n\t\t\tHashSet<String> querySpaces) {\n\t\treturn new NamedNativeQueryDefinition.Builder<T>(registrationName)\n\t\t\t\t.setSqlString(namedNativeQuery.query())\n\t\t\t\t.setResultSetMappingName(resultSetMappingName)\n\t\t\t\t.setResultClass(resultClass)\n\t\t\t\t.setCacheable(namedNativeQuery.cacheable())\n\t\t\t\t.setCacheRegion(nullIfEmpty(namedNativeQuery.cacheRegion()))\n\t\t\t\t.setCacheMode(getCacheMode(namedNativeQuery.cacheRetrieveMode(), namedNativeQuery.cacheStoreMode()))\n\t\t\t\t.setTimeout(timeout < 0 ? null : timeout)\n\t\t\t\t.setFetchSize(fetchSize < 0 ? null : fetchSize)\n\t\t\t\t.setFlushMode(getFlushMode(namedNativeQuery.flushMode()))\n\t\t\t\t.setReadOnly(namedNativeQuery.readOnly())\n\t\t\t\t.setQuerySpaces(querySpaces)\n\t\t\t\t.setComment(nullIfEmpty(namedNativeQuery.comment()));\n\t}",
        "diffSourceCode": "-  205: \tpublic static void bindNativeQuery(\n-  206: \t\t\torg.hibernate.annotations.NamedNativeQuery namedNativeQuery,\n-  207: \t\t\tMetadataBuildingContext context) {\n-  208: \t\tif ( namedNativeQuery == null ) {\n-  209: \t\t\treturn;\n-  210: \t\t}\n-  211: \n-  212: \t\tfinal String registrationName = namedNativeQuery.name();\n-  213: \n-  214: \t\t//ResultSetMappingDefinition mappingDefinition = mappings.getJdbcValuesMappingProducer( queryAnn.resultSetMapping() );\n-  215: \t\tif ( registrationName.isEmpty() ) {\n-  216: \t\t\tthrow new AnnotationException( \"Class or package level '@NamedNativeQuery' annotation must specify a 'name'\" );\n-  217: \t\t}\n-  218: \n-  219: \t\tfinal String resultSetMappingName = namedNativeQuery.resultSetMapping();\n-  220: \t\tfinal Class<?> resultClassDetails = namedNativeQuery.resultClass();\n-  221: \t\tfinal Class<Object> resultClass = resultClassDetails == void.class\n-  222: \t\t\t\t? null\n-  223: \t\t\t\t: (Class<Object>) resultClassDetails;\n-  224: \n-  225: \t\tfinal Integer timeout = namedNativeQuery.timeout();\n-  226: \t\tfinal Integer fetchSize = namedNativeQuery.fetchSize();\n+  205: \t\t\tbuilder.setResultSetMappingName( name );\n+  206: \t\t}\n+  207: \n+  208: \t\tcontext.getMetadataCollector().addNamedNativeQuery( builder.build() );\n+  209: \t}\n+  210: \n+  211: \tpublic static void bindNativeQuery(\n+  212: \t\t\torg.hibernate.annotations.NamedNativeQuery namedNativeQuery,\n+  213: \t\t\tMetadataBuildingContext context) {\n+  214: \t\tif ( namedNativeQuery == null ) {\n+  215: \t\t\treturn;\n+  216: \t\t}\n+  217: \n+  218: \t\tfinal String registrationName = namedNativeQuery.name();\n+  219: \n+  220: \t\tif ( registrationName.isEmpty() ) {\n+  221: \t\t\tthrow new AnnotationException( \"Class or package level '@NamedNativeQuery' annotation must specify a 'name'\" );\n+  222: \t\t}\n+  223: \n+  224: \t\tfinal String resultSetMappingName = namedNativeQuery.resultSetMapping();\n+  225: \t\tfinal Class<?> resultClassDetails = namedNativeQuery.resultClass();\n+  226: \t\tfinal Class<?> resultClass = resultClassDetails == void.class ? null : resultClassDetails;\n   227: \n   228: \t\tfinal String[] querySpacesList = namedNativeQuery.querySpaces();\n   229: \t\tfinal HashSet<String> querySpaces = new HashSet<>( determineProperSizing( querySpacesList.length ) );\n   230: \t\tCollections.addAll( querySpaces, querySpacesList );\n   231: \n-  232: \t\tfinal NamedNativeQueryDefinition.Builder<?> builder = new NamedNativeQueryDefinition.Builder<>( registrationName )\n-  233: \t\t\t\t.setSqlString( namedNativeQuery.query() )\n-  234: \t\t\t\t.setResultSetMappingName( resultSetMappingName )\n-  235: \t\t\t\t.setResultClass( resultClass )\n-  236: \t\t\t\t.setCacheable( namedNativeQuery.cacheable() )\n-  237: \t\t\t\t.setCacheRegion( nullIfEmpty( namedNativeQuery.cacheRegion() ) )\n-  238: \t\t\t\t.setCacheMode( getCacheMode( namedNativeQuery.cacheRetrieveMode(), namedNativeQuery.cacheStoreMode() ) )\n-  239: \t\t\t\t.setTimeout( timeout < 0 ? null : timeout )\n-  240: \t\t\t\t.setFetchSize( fetchSize < 0 ? null : fetchSize )\n-  241: \t\t\t\t.setFlushMode( getFlushMode( namedNativeQuery.flushMode() ) )\n-  242: \t\t\t\t.setReadOnly( namedNativeQuery.readOnly() )\n-  243: \t\t\t\t.setQuerySpaces( querySpaces )\n-  244: \t\t\t\t.setComment( nullIfEmpty( namedNativeQuery.comment() ) );\n-  245: \n-  246: \t\tif ( TRUE == namedNativeQuery.callable() ) {\n-  247: \t\t\tfinal NamedProcedureCallDefinition definition =\n-  248: \t\t\t\t\tcreateStoredProcedure( builder, context, () -> illegalCallSyntax( namedNativeQuery ) );\n-  249: \t\t\tcontext.getMetadataCollector().addNamedProcedureCallDefinition( definition );\n-  250: \t\t\tDeprecationLogger.DEPRECATION_LOGGER.warn(\n-  251: \t\t\t\t\t\"Marking named native queries as callable is no longer supported; use '@jakarta.persistence.NamedStoredProcedureQuery' instead. Ignoring.\"\n-  252: \t\t\t);\n-  253: \t\t}\n-  254: \t\telse {\n-  255: \t\t\tfinal NamedNativeQueryDefinition<?> queryDefinition = builder.build();\n-  256: \n-  257: \t\t\tif ( LOG.isDebugEnabled() ) {\n-  258: \t\t\t\tLOG.debugf(\n-  259: \t\t\t\t\t\t\"Binding named native query: %s => %s\",\n-  260: \t\t\t\t\t\tqueryDefinition.getRegistrationName(),\n-  261: \t\t\t\t\t\tqueryDefinition.getSqlQueryString()\n-  262: \t\t\t\t);\n-  263: \t\t\t}\n-  264: \n-  265: \t\t\tcontext.getMetadataCollector().addNamedNativeQuery( queryDefinition );\n-  266: \t\t}\n-  267: \t}\n-  268: \n-  269: \t/**\n-  270: \t * Handles legacy cases where a named native query was used to specify a procedure call\n-  271: \t *\n-  272: \t * @deprecated User should use {@linkplain NamedStoredProcedureQuery} instead\n-  273: \t */\n-  274: \t@Deprecated\n-  275: \tpublic static NamedProcedureCallDefinition createStoredProcedure(\n-  276: \t\t\tNamedNativeQueryDefinition.Builder<?> builder,\n-  277: \t\t\tMetadataBuildingContext context,\n-  278: \t\t\tSupplier<RuntimeException> exceptionProducer) {\n+  232: \t\tfinal NamedNativeQueryDefinition.Builder<?> builder =\n+  233: \t\t\t\tcreateQueryDefinition( namedNativeQuery, registrationName, resultSetMappingName, resultClass,\n+  234: \t\t\t\t\t\tnamedNativeQuery.timeout(), namedNativeQuery.fetchSize(), querySpaces );\n+  235: \n+  236: \t\tif ( TRUE == namedNativeQuery.callable() ) {\n+  237: \t\t\tfinal NamedProcedureCallDefinition definition =\n+  238: \t\t\t\t\tcreateStoredProcedure( builder, context, () -> illegalCallSyntax( namedNativeQuery ) );\n+  239: \t\t\tcontext.getMetadataCollector().addNamedProcedureCallDefinition( definition );\n+  240: \t\t\tDeprecationLogger.DEPRECATION_LOGGER.warn(\n+  241: \t\t\t\t\t\"Marking named native queries as callable is no longer supported; use '@jakarta.persistence.NamedStoredProcedureQuery' instead. Ignoring.\"\n+  242: \t\t\t);\n+  243: \t\t}\n+  244: \t\telse {\n+  245: \t\t\tfinal NamedNativeQueryDefinition<?> queryDefinition = builder.build();\n+  246: \n+  247: \t\t\tif ( LOG.isDebugEnabled() ) {\n+  248: \t\t\t\tLOG.debugf(\n+  249: \t\t\t\t\t\t\"Binding named native query: %s => %s\",\n+  250: \t\t\t\t\t\tqueryDefinition.getRegistrationName(),\n+  251: \t\t\t\t\t\tqueryDefinition.getSqlQueryString()\n+  252: \t\t\t\t);\n+  253: \t\t\t}\n+  254: \n+  255: \t\t\tcontext.getMetadataCollector().addNamedNativeQuery( queryDefinition );\n+  256: \t\t}\n+  257: \t}\n+  258: \n+  259: \tprivate static <T> NamedNativeQueryDefinition.Builder<T> createQueryDefinition(\n+  260: \t\t\torg.hibernate.annotations.NamedNativeQuery namedNativeQuery,\n+  261: \t\t\tString registrationName, String resultSetMappingName,\n+  262: \t\t\tClass<T> resultClass,\n+  263: \t\t\tint timeout, int fetchSize,\n+  264: \t\t\tHashSet<String> querySpaces) {\n+  265: \t\treturn new NamedNativeQueryDefinition.Builder<T>(registrationName)\n+  266: \t\t\t\t.setSqlString(namedNativeQuery.query())\n+  267: \t\t\t\t.setResultSetMappingName(resultSetMappingName)\n+  268: \t\t\t\t.setResultClass(resultClass)\n+  269: \t\t\t\t.setCacheable(namedNativeQuery.cacheable())\n+  270: \t\t\t\t.setCacheRegion(nullIfEmpty(namedNativeQuery.cacheRegion()))\n+  271: \t\t\t\t.setCacheMode(getCacheMode(namedNativeQuery.cacheRetrieveMode(), namedNativeQuery.cacheStoreMode()))\n+  272: \t\t\t\t.setTimeout(timeout < 0 ? null : timeout)\n+  273: \t\t\t\t.setFetchSize(fetchSize < 0 ? null : fetchSize)\n+  274: \t\t\t\t.setFlushMode(getFlushMode(namedNativeQuery.flushMode()))\n+  275: \t\t\t\t.setReadOnly(namedNativeQuery.readOnly())\n+  276: \t\t\t\t.setQuerySpaces(querySpaces)\n+  277: \t\t\t\t.setComment(nullIfEmpty(namedNativeQuery.comment()));\n+  278: \t}\n",
        "uniqueId": "b53728f7278c40ef41e22326f917ca5c718ce6e7_205_267_259_278_211_257",
        "moveFileExist": true,
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 21,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 27,
                "covered": 62
            },
            "BRANCH": {
                "missed": 4,
                "covered": 6
            },
            "LINE": {
                "missed": 10,
                "covered": 17
            },
            "COMPLEXITY": {
                "missed": 4,
                "covered": 2
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        }
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprivate createNamedQueryDefinition(queryName String, queryString String, resultClass Class<T>, lockOptions LockOptions, hints QueryHintDefinition) : NamedHqlQueryDefinitionImpl<T> extracted from public bindQuery(namedQuery NamedQuery, context MetadataBuildingContext, isDefault boolean) : void in class org.hibernate.boot.model.internal.QueryBinder",
        "diffLocations": [
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/boot/model/internal/QueryBinder.java",
                "startLine": 73,
                "endLine": 114,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/boot/model/internal/QueryBinder.java",
                "startLine": 74,
                "endLine": 104,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/boot/model/internal/QueryBinder.java",
                "startLine": 106,
                "endLine": 122,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "public static void bindQuery(\n\t\t\tNamedQuery namedQuery,\n\t\t\tMetadataBuildingContext context,\n\t\t\tboolean isDefault) {\n\t\tif ( namedQuery == null ) {\n\t\t\treturn;\n\t\t}\n\n\t\tfinal String queryName = namedQuery.name();\n\t\tfinal String queryString = namedQuery.query();\n\n\t\tif ( queryName.isEmpty() ) {\n\t\t\tthrow new AnnotationException( \"Class or package level '@NamedQuery' annotation must specify a 'name'\" );\n\t\t}\n\n\t\tif ( LOG.isDebugEnabled() ) {\n\t\t\tLOG.debugf( \"Binding named query: %s => %s\", queryName, queryString );\n\t\t}\n\n\t\tfinal QueryHintDefinition hints = new QueryHintDefinition( queryName, namedQuery.hints() );\n\n\t\tfinal NamedHqlQueryDefinition<?> queryMapping = new NamedHqlQueryDefinitionImpl.Builder<>( queryName )\n\t\t\t\t.setHqlString( queryString )\n\t\t\t\t.setResultClass( (Class<Object>) namedQuery.resultClass() )\n\t\t\t\t.setCacheable( hints.getCacheability() )\n\t\t\t\t.setCacheMode( hints.getCacheMode() )\n\t\t\t\t.setCacheRegion( hints.getString( HibernateHints.HINT_CACHE_REGION ) )\n\t\t\t\t.setTimeout( hints.getTimeout() )\n\t\t\t\t.setFetchSize( hints.getInteger( HibernateHints.HINT_FETCH_SIZE ) )\n\t\t\t\t.setFlushMode( hints.getFlushMode() )\n\t\t\t\t.setReadOnly( hints.getBooleanWrapper( HibernateHints.HINT_READ_ONLY ) )\n\t\t\t\t.setLockOptions( hints.determineLockOptions( namedQuery ) )\n\t\t\t\t.setComment( hints.getString( HibernateHints.HINT_COMMENT ) )\n\t\t\t\t.build();\n\n\t\tif ( isDefault ) {\n\t\t\tcontext.getMetadataCollector().addDefaultQuery( queryMapping );\n\t\t}\n\t\telse {\n\t\t\tcontext.getMetadataCollector().addNamedQuery( queryMapping );\n\t\t}\n\t}",
        "filePathBefore": "hibernate-core/src/main/java/org/hibernate/boot/model/internal/QueryBinder.java",
        "isPureRefactoring": true,
        "commitId": "b53728f7278c40ef41e22326f917ca5c718ce6e7",
        "packageNameBefore": "org.hibernate.boot.model.internal",
        "classNameBefore": "org.hibernate.boot.model.internal.QueryBinder",
        "methodNameBefore": "org.hibernate.boot.model.internal.QueryBinder#bindQuery",
        "invokedMethod": "methodSignature: org.hibernate.boot.model.internal.QueryBinder#getCacheMode\n methodBody: private static CacheMode getCacheMode(CacheRetrieveMode cacheRetrieveMode, CacheStoreMode cacheStoreMode) {\nfinal CacheMode cacheMode=CacheMode.fromJpaModes(cacheRetrieveMode,cacheStoreMode);\nreturn cacheMode == null ? CacheMode.NORMAL : cacheMode;\n}\nmethodSignature: org.hibernate.boot.model.internal.QueryBinder#getFlushMode\n methodBody: private static FlushMode getFlushMode(FlushModeType flushModeType) {\nreturn switch (flushModeType) {\ncase ALWAYS ->  yield FlushMode.ALWAYS;\ncase AUTO ->yield FlushMode.AUTO;\ncase COMMIT ->yield FlushMode.COMMIT;\ncase MANUAL ->yield FlushMode.MANUAL;\ncase PERSISTENCE_CONTEXT ->yield null;\n}\n;\n}",
        "classSignatureBefore": "public abstract class QueryBinder ",
        "methodNameBeforeSet": [
            "org.hibernate.boot.model.internal.QueryBinder#bindQuery"
        ],
        "classNameBeforeSet": [
            "org.hibernate.boot.model.internal.QueryBinder"
        ],
        "classSignatureBeforeSet": [
            "public abstract class QueryBinder "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Changes are within the Extract Method refactoring mechanics",
                "description": "All replacements have been justified - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n * See the lgpl.txt file in the root directory or http://www.gnu.org/licenses/lgpl-2.1.html.\n */\npackage org.hibernate.boot.model.internal;\n\nimport java.lang.invoke.MethodHandles;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.function.Supplier;\n\nimport org.hibernate.AnnotationException;\nimport org.hibernate.CacheMode;\nimport org.hibernate.FlushMode;\nimport org.hibernate.annotations.FlushModeType;\nimport org.hibernate.annotations.HQLSelect;\nimport org.hibernate.annotations.SQLSelect;\nimport org.hibernate.boot.internal.NamedHqlQueryDefinitionImpl;\nimport org.hibernate.boot.internal.NamedProcedureCallDefinitionImpl;\nimport org.hibernate.boot.models.JpaAnnotations;\nimport org.hibernate.boot.models.annotations.internal.NamedStoredProcedureQueryJpaAnnotation;\nimport org.hibernate.boot.models.annotations.internal.QueryHintJpaAnnotation;\nimport org.hibernate.boot.models.annotations.internal.StoredProcedureParameterJpaAnnotation;\nimport org.hibernate.boot.query.NamedHqlQueryDefinition;\nimport org.hibernate.boot.query.NamedNativeQueryDefinition;\nimport org.hibernate.boot.query.NamedProcedureCallDefinition;\nimport org.hibernate.boot.query.SqlResultSetMappingDescriptor;\nimport org.hibernate.boot.registry.classloading.spi.ClassLoaderService;\nimport org.hibernate.boot.spi.MetadataBuildingContext;\nimport org.hibernate.internal.CoreMessageLogger;\nimport org.hibernate.internal.log.DeprecationLogger;\nimport org.hibernate.internal.util.collections.ArrayHelper;\nimport org.hibernate.jpa.HibernateHints;\nimport org.hibernate.models.internal.util.StringHelper;\nimport org.hibernate.models.spi.ClassDetails;\nimport org.hibernate.models.spi.SourceModelBuildingContext;\nimport org.hibernate.query.sql.internal.ParameterParser;\nimport org.hibernate.query.sql.spi.ParameterRecognizer;\nimport org.hibernate.type.BasicType;\n\nimport org.jboss.logging.Logger;\n\nimport jakarta.persistence.CacheRetrieveMode;\nimport jakarta.persistence.CacheStoreMode;\nimport jakarta.persistence.NamedNativeQuery;\nimport jakarta.persistence.NamedQuery;\nimport jakarta.persistence.NamedStoredProcedureQuery;\nimport jakarta.persistence.ParameterMode;\nimport jakarta.persistence.QueryHint;\nimport jakarta.persistence.SqlResultSetMapping;\nimport jakarta.persistence.StoredProcedureParameter;\n\nimport static java.lang.Boolean.TRUE;\nimport static org.hibernate.internal.util.StringHelper.nullIfEmpty;\nimport static org.hibernate.internal.util.collections.CollectionHelper.determineProperSizing;\nimport static org.hibernate.internal.util.collections.CollectionHelper.setOf;\n\n/**\n * Responsible for reading named queries defined in annotations and registering\n * {@link org.hibernate.boot.query.NamedQueryDefinition} objects.\n *\n * @implNote This class is stateless, unlike most of the other \"binders\".\n *\n * @author Emmanuel Bernard\n */\npublic abstract class QueryBinder {\n\tprivate static final CoreMessageLogger LOG = Logger.getMessageLogger( MethodHandles.lookup(), CoreMessageLogger.class, QueryBinder.class.getName() );\n\n\tpublic static void bindQuery(\n\t\t\tNamedQuery namedQuery,\n\t\t\tMetadataBuildingContext context,\n\t\t\tboolean isDefault) {\n\t\tif ( namedQuery == null ) {\n\t\t\treturn;\n\t\t}\n\n\t\tfinal String queryName = namedQuery.name();\n\t\tfinal String queryString = namedQuery.query();\n\n\t\tif ( queryName.isEmpty() ) {\n\t\t\tthrow new AnnotationException( \"Class or package level '@NamedQuery' annotation must specify a 'name'\" );\n\t\t}\n\n\t\tif ( LOG.isDebugEnabled() ) {\n\t\t\tLOG.debugf( \"Binding named query: %s => %s\", queryName, queryString );\n\t\t}\n\n\t\tfinal QueryHintDefinition hints = new QueryHintDefinition( queryName, namedQuery.hints() );\n\n\t\tfinal NamedHqlQueryDefinition<?> queryMapping = new NamedHqlQueryDefinitionImpl.Builder<>( queryName )\n\t\t\t\t.setHqlString( queryString )\n\t\t\t\t.setResultClass( (Class<Object>) namedQuery.resultClass() )\n\t\t\t\t.setCacheable( hints.getCacheability() )\n\t\t\t\t.setCacheMode( hints.getCacheMode() )\n\t\t\t\t.setCacheRegion( hints.getString( HibernateHints.HINT_CACHE_REGION ) )\n\t\t\t\t.setTimeout( hints.getTimeout() )\n\t\t\t\t.setFetchSize( hints.getInteger( HibernateHints.HINT_FETCH_SIZE ) )\n\t\t\t\t.setFlushMode( hints.getFlushMode() )\n\t\t\t\t.setReadOnly( hints.getBooleanWrapper( HibernateHints.HINT_READ_ONLY ) )\n\t\t\t\t.setLockOptions( hints.determineLockOptions( namedQuery ) )\n\t\t\t\t.setComment( hints.getString( HibernateHints.HINT_COMMENT ) )\n\t\t\t\t.build();\n\n\t\tif ( isDefault ) {\n\t\t\tcontext.getMetadataCollector().addDefaultQuery( queryMapping );\n\t\t}\n\t\telse {\n\t\t\tcontext.getMetadataCollector().addNamedQuery( queryMapping );\n\t\t}\n\t}\n\n\tprivate static Class<Object> loadClass(ClassDetails classDetails, MetadataBuildingContext context) {\n\t\treturn ClassDetails.VOID_CLASS_DETAILS == classDetails\n\t\t\t\t? null\n\t\t\t\t: context.getBootstrapContext()\n\t\t\t\t\t\t.getServiceRegistry()\n\t\t\t\t\t\t.requireService( ClassLoaderService.class )\n\t\t\t\t\t\t.classForName( classDetails.getName() );\n\t}\n\n\tpublic static void bindNativeQuery(\n\t\t\tNamedNativeQuery namedNativeQuery,\n\t\t\tMetadataBuildingContext context,\n\t\t\tboolean isDefault) {\n\t\tif ( namedNativeQuery == null ) {\n\t\t\treturn;\n\t\t}\n\n\t\tfinal String registrationName = namedNativeQuery.name();\n\t\tfinal String queryString = namedNativeQuery.query();\n\n\t\tif ( registrationName.isEmpty() ) {\n\t\t\tthrow new AnnotationException( \"Class or package level '@NamedNativeQuery' annotation must specify a 'name'\" );\n\t\t}\n\n\t\tfinal QueryHintDefinition hints = new QueryHintDefinition( registrationName, namedNativeQuery.hints() );\n\n\t\tfinal String resultSetMappingName = namedNativeQuery.resultSetMapping();\n\t\tfinal Class<?> resultClassDetails = namedNativeQuery.resultClass();\n\t\tfinal Class<Object> resultClass = void.class == resultClassDetails\n\t\t\t\t? null\n\t\t\t\t: (Class<Object>) resultClassDetails;\n\n\t\tfinal NamedNativeQueryDefinition.Builder<?> builder = new NamedNativeQueryDefinition.Builder<>( registrationName )\n\t\t\t\t.setSqlString( queryString )\n\t\t\t\t.setResultClass( resultClass )\n\t\t\t\t.setResultSetMappingName( resultSetMappingName )\n\t\t\t\t.setQuerySpaces( null )\n\t\t\t\t.setCacheable( hints.getCacheability() )\n\t\t\t\t.setCacheMode( hints.getCacheMode() )\n\t\t\t\t.setCacheRegion( hints.getString( HibernateHints.HINT_CACHE_REGION ) )\n\t\t\t\t.setTimeout( hints.getTimeout() )\n\t\t\t\t.setFetchSize( hints.getInteger( HibernateHints.HINT_FETCH_SIZE ) )\n\t\t\t\t.setFlushMode( hints.getFlushMode() )\n\t\t\t\t.setReadOnly( hints.getBooleanWrapper( HibernateHints.HINT_READ_ONLY ) )\n\t\t\t\t.setComment( hints.getString( HibernateHints.HINT_COMMENT ) )\n\t\t\t\t.addHints( hints.getHintsMap() );\n\n\t\tfinal NamedNativeQueryDefinition<?> queryDefinition = builder.build();\n\n\t\tif ( LOG.isDebugEnabled() ) {\n\t\t\tLOG.debugf( \"Binding named native query: %s => %s\", queryDefinition.getRegistrationName(), queryDefinition.getSqlQueryString() );\n\t\t}\n\n\t\tif ( isDefault ) {\n\t\t\tcontext.getMetadataCollector().addDefaultNamedNativeQuery( queryDefinition );\n\t\t}\n\t\telse {\n\t\t\tcontext.getMetadataCollector().addNamedNativeQuery( queryDefinition );\n\t\t}\n\t}\n\n\tpublic static void bindNativeQuery(\n\t\t\tString name,\n\t\t\tSQLSelect sqlSelect,\n\t\t\tClassDetails annotatedClass,\n\t\t\tMetadataBuildingContext context) {\n\t\tfinal NamedNativeQueryDefinition.Builder<?> builder = new NamedNativeQueryDefinition.Builder<>( name )\n\t\t\t\t.setFlushMode( FlushMode.MANUAL )\n\t\t\t\t.setSqlString( sqlSelect.sql() )\n\t\t\t\t.setQuerySpaces( setOf( sqlSelect.querySpaces() ) );\n\n\t\tif ( annotatedClass != null ) {\n\t\t\tbuilder.setResultClass(\n\t\t\t\t\tcontext.getBootstrapContext().getServiceRegistry().requireService( ClassLoaderService.class )\n\t\t\t\t\t\t\t.classForName( annotatedClass.getClassName() )\n\t\t\t);\n\t\t}\n\n\t\tfinal SqlResultSetMapping resultSetMapping = sqlSelect.resultSetMapping();\n\t\tif ( !ArrayHelper.isEmpty( resultSetMapping.columns() )\n\t\t\t\t|| !ArrayHelper.isEmpty( resultSetMapping.entities() )\n\t\t\t\t|| !ArrayHelper.isEmpty( resultSetMapping.classes() ) ) {\n\t\t\tcontext.getMetadataCollector().addResultSetMapping( SqlResultSetMappingDescriptor.from( resultSetMapping, name ) );\n\t\t\tbuilder.setResultSetMappingName( name );\n\t\t}\n\n\t\tcontext.getMetadataCollector().addNamedNativeQuery( builder.build() );\n\t}\n\n\tpublic static void bindNativeQuery(\n\t\t\torg.hibernate.annotations.NamedNativeQuery namedNativeQuery,\n\t\t\tMetadataBuildingContext context) {\n\t\tif ( namedNativeQuery == null ) {\n\t\t\treturn;\n\t\t}\n\n\t\tfinal String registrationName = namedNativeQuery.name();\n\n\t\t//ResultSetMappingDefinition mappingDefinition = mappings.getJdbcValuesMappingProducer( queryAnn.resultSetMapping() );\n\t\tif ( registrationName.isEmpty() ) {\n\t\t\tthrow new AnnotationException( \"Class or package level '@NamedNativeQuery' annotation must specify a 'name'\" );\n\t\t}\n\n\t\tfinal String resultSetMappingName = namedNativeQuery.resultSetMapping();\n\t\tfinal Class<?> resultClassDetails = namedNativeQuery.resultClass();\n\t\tfinal Class<Object> resultClass = resultClassDetails == void.class\n\t\t\t\t? null\n\t\t\t\t: (Class<Object>) resultClassDetails;\n\n\t\tfinal Integer timeout = namedNativeQuery.timeout();\n\t\tfinal Integer fetchSize = namedNativeQuery.fetchSize();\n\n\t\tfinal String[] querySpacesList = namedNativeQuery.querySpaces();\n\t\tfinal HashSet<String> querySpaces = new HashSet<>( determineProperSizing( querySpacesList.length ) );\n\t\tCollections.addAll( querySpaces, querySpacesList );\n\n\t\tfinal NamedNativeQueryDefinition.Builder<?> builder = new NamedNativeQueryDefinition.Builder<>( registrationName )\n\t\t\t\t.setSqlString( namedNativeQuery.query() )\n\t\t\t\t.setResultSetMappingName( resultSetMappingName )\n\t\t\t\t.setResultClass( resultClass )\n\t\t\t\t.setCacheable( namedNativeQuery.cacheable() )\n\t\t\t\t.setCacheRegion( nullIfEmpty( namedNativeQuery.cacheRegion() ) )\n\t\t\t\t.setCacheMode( getCacheMode( namedNativeQuery.cacheRetrieveMode(), namedNativeQuery.cacheStoreMode() ) )\n\t\t\t\t.setTimeout( timeout < 0 ? null : timeout )\n\t\t\t\t.setFetchSize( fetchSize < 0 ? null : fetchSize )\n\t\t\t\t.setFlushMode( getFlushMode( namedNativeQuery.flushMode() ) )\n\t\t\t\t.setReadOnly( namedNativeQuery.readOnly() )\n\t\t\t\t.setQuerySpaces( querySpaces )\n\t\t\t\t.setComment( nullIfEmpty( namedNativeQuery.comment() ) );\n\n\t\tif ( TRUE == namedNativeQuery.callable() ) {\n\t\t\tfinal NamedProcedureCallDefinition definition =\n\t\t\t\t\tcreateStoredProcedure( builder, context, () -> illegalCallSyntax( namedNativeQuery ) );\n\t\t\tcontext.getMetadataCollector().addNamedProcedureCallDefinition( definition );\n\t\t\tDeprecationLogger.DEPRECATION_LOGGER.warn(\n\t\t\t\t\t\"Marking named native queries as callable is no longer supported; use '@jakarta.persistence.NamedStoredProcedureQuery' instead. Ignoring.\"\n\t\t\t);\n\t\t}\n\t\telse {\n\t\t\tfinal NamedNativeQueryDefinition<?> queryDefinition = builder.build();\n\n\t\t\tif ( LOG.isDebugEnabled() ) {\n\t\t\t\tLOG.debugf(\n\t\t\t\t\t\t\"Binding named native query: %s => %s\",\n\t\t\t\t\t\tqueryDefinition.getRegistrationName(),\n\t\t\t\t\t\tqueryDefinition.getSqlQueryString()\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tcontext.getMetadataCollector().addNamedNativeQuery( queryDefinition );\n\t\t}\n\t}\n\n\t/**\n\t * Handles legacy cases where a named native query was used to specify a procedure call\n\t *\n\t * @deprecated User should use {@linkplain NamedStoredProcedureQuery} instead\n\t */\n\t@Deprecated\n\tpublic static NamedProcedureCallDefinition createStoredProcedure(\n\t\t\tNamedNativeQueryDefinition.Builder<?> builder,\n\t\t\tMetadataBuildingContext context,\n\t\t\tSupplier<RuntimeException> exceptionProducer) {\n\t\tfinal String sqlString = builder.getSqlString().trim();\n\t\tif ( !sqlString.startsWith( \"{\" ) || !sqlString.endsWith( \"}\" ) ) {\n\t\t\tthrow exceptionProducer.get();\n\t\t}\n\t\tfinal JdbcCall jdbcCall = parseJdbcCall( sqlString, exceptionProducer );\n\n\t\tfinal SourceModelBuildingContext sourceModelBuildingContext = context.getMetadataCollector()\n\t\t\t\t.getSourceModelBuildingContext();\n\t\tfinal NamedStoredProcedureQueryJpaAnnotation nameStoredProcedureQueryAnn = JpaAnnotations.NAMED_STORED_PROCEDURE_QUERY.createUsage( sourceModelBuildingContext );\n\t\tnameStoredProcedureQueryAnn.name( builder.getName() );\n\t\tnameStoredProcedureQueryAnn.procedureName( jdbcCall.callableName );\n\n\t\tfinal StoredProcedureParameter[] parameters = new StoredProcedureParameter[jdbcCall.parameters.size()];\n\t\tnameStoredProcedureQueryAnn.parameters( parameters );\n\n\t\tfor ( int i = 0; i < jdbcCall.parameters.size(); i++ ) {\n\t\t\tfinal StoredProcedureParameterJpaAnnotation param = JpaAnnotations.STORED_PROCEDURE_PARAMETER.createUsage( sourceModelBuildingContext );\n\t\t\tparameters[i] = param;\n\n\t\t\tfinal String paramName = jdbcCall.parameters.get( i );\n\t\t\tparam.name( paramName );\n\t\t\tparam.mode( ParameterMode.IN );\n\n\t\t\tfinal String typeName = builder.getParameterTypes().get( paramName );\n\t\t\tfinal ClassDetails classDetails;\n\t\t\tif ( StringHelper.isEmpty( typeName ) ) {\n\t\t\t\tclassDetails = ClassDetails.VOID_CLASS_DETAILS;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfinal BasicType<Object> registeredType = context.getBootstrapContext()\n\t\t\t\t\t\t.getTypeConfiguration()\n\t\t\t\t\t\t.getBasicTypeRegistry()\n\t\t\t\t\t\t.getRegisteredType( typeName );\n\t\t\t\tclassDetails = context.getMetadataCollector().getClassDetailsRegistry().getClassDetails( registeredType.getJavaType().getName() );\n\t\t\t}\n\t\t\tparam.type( classDetails.toJavaClass() );\n\t\t}\n\n\t\tif ( builder.getResultSetMappingName() != null ) {\n\t\t\tnameStoredProcedureQueryAnn.resultSetMappings( new String[] { builder.getResultSetMappingName() } );\n\t\t}\n\n\t\tfinal Class<?> resultClass = builder.getResultClass();\n\t\tif ( resultClass != null ) {\n\t\t\tnameStoredProcedureQueryAnn.resultClasses( new Class[]{ builder.getResultClass() } );\n\t\t}\n\n\t\tfinal List<QueryHintJpaAnnotation> hints = new ArrayList<>();\n\n\t\tif ( builder.getQuerySpaces() != null ) {\n\t\t\tfinal QueryHintJpaAnnotation hint = JpaAnnotations.QUERY_HINT.createUsage( sourceModelBuildingContext );\n\t\t\thint.name( HibernateHints.HINT_NATIVE_SPACES );\n\t\t\thint.value( String.join( \" \", builder.getQuerySpaces() ) );\n\t\t\thints.add( hint );\n\t\t}\n\n\t\tif ( jdbcCall.resultParameter ) {\n\t\t\t// Mark native queries that have a result parameter as callable functions\n\t\t\tfinal QueryHintJpaAnnotation hint = JpaAnnotations.QUERY_HINT.createUsage( sourceModelBuildingContext );\n\t\t\thint.name( HibernateHints.HINT_CALLABLE_FUNCTION );\n\t\t\thint.value( \"true\" );\n\t\t\thints.add( hint );\n\t\t}\n\n\t\tnameStoredProcedureQueryAnn.hints( hints.toArray(QueryHint[]::new) );\n\n\t\treturn new NamedProcedureCallDefinitionImpl( nameStoredProcedureQueryAnn );\n\t}\n\n\tpublic static void bindQuery(\n\t\t\tString name,\n\t\t\tHQLSelect hqlSelect,\n\t\t\tMetadataBuildingContext context) {\n\t\tfinal NamedHqlQueryDefinition<?> hqlQueryDefinition = new NamedHqlQueryDefinition.Builder<>( name )\n\t\t\t\t.setFlushMode( FlushMode.MANUAL )\n\t\t\t\t.setHqlString( hqlSelect.query() )\n\t\t\t\t.build();\n\n\t\tcontext.getMetadataCollector().addNamedQuery( hqlQueryDefinition );\n\t}\n\n\tpublic static void bindQuery(\n\t\t\torg.hibernate.annotations.NamedQuery namedQuery,\n\t\t\tMetadataBuildingContext context) {\n\t\tif ( namedQuery == null ) {\n\t\t\treturn;\n\t\t}\n\n\t\tfinal String registrationName = namedQuery.name();\n\n\t\t//ResultSetMappingDefinition mappingDefinition = mappings.getJdbcValuesMappingProducer( namedQuery.resultSetMapping() );\n\t\tif ( registrationName.isEmpty() ) {\n\t\t\tthrow new AnnotationException( \"Class or package level '@NamedQuery' annotation must specify a 'name'\" );\n\t\t}\n\n\t\tfinal int timeout = namedQuery.timeout();\n\t\tfinal int fetchSize = namedQuery.fetchSize();\n\n\t\tfinal NamedHqlQueryDefinition.Builder<?> builder = new NamedHqlQueryDefinition.Builder<>( registrationName )\n\t\t\t\t.setHqlString( namedQuery.query() )\n\t\t\t\t.setResultClass( (Class<Object>) namedQuery.resultClass() )\n\t\t\t\t.setCacheable( namedQuery.cacheable() )\n\t\t\t\t.setCacheRegion( nullIfEmpty( namedQuery.cacheRegion() ) )\n\t\t\t\t.setCacheMode( getCacheMode( namedQuery.cacheRetrieveMode(), namedQuery.cacheStoreMode() ) )\n\t\t\t\t.setTimeout( timeout < 0 ? null : timeout )\n\t\t\t\t.setFetchSize( fetchSize < 0 ? null : fetchSize )\n\t\t\t\t.setFlushMode( getFlushMode( namedQuery.flushMode() ) )\n\t\t\t\t.setReadOnly( namedQuery.readOnly() )\n\t\t\t\t.setComment( nullIfEmpty( namedQuery.comment() ) );\n\n\t\tfinal NamedHqlQueryDefinitionImpl<?> hqlQueryDefinition = builder.build();\n\n\t\tif ( LOG.isDebugEnabled() ) {\n\t\t\tLOG.debugf( \"Binding named query: %s => %s\", hqlQueryDefinition.getRegistrationName(), hqlQueryDefinition.getHqlString() );\n\t\t}\n\n\t\tcontext.getMetadataCollector().addNamedQuery( hqlQueryDefinition );\n\t}\n\n\tprivate static CacheMode getCacheMode(CacheRetrieveMode cacheRetrieveMode, CacheStoreMode cacheStoreMode) {\n\t\tfinal CacheMode cacheMode = CacheMode.fromJpaModes( cacheRetrieveMode, cacheStoreMode );\n\t\treturn cacheMode == null ? CacheMode.NORMAL : cacheMode;\n\t}\n\n\tprivate static FlushMode getFlushMode(FlushModeType flushModeType) {\n\t\treturn switch ( flushModeType ) {\n\t\t\tcase ALWAYS -> FlushMode.ALWAYS;\n\t\t\tcase AUTO -> FlushMode.AUTO;\n\t\t\tcase COMMIT -> FlushMode.COMMIT;\n\t\t\tcase MANUAL -> FlushMode.MANUAL;\n\t\t\tcase PERSISTENCE_CONTEXT -> null;\n\t\t};\n\t}\n\n\tpublic static void bindNamedStoredProcedureQuery(\n\t\t\tNamedStoredProcedureQuery namedStoredProcedureQuery,\n\t\t\tMetadataBuildingContext context,\n\t\t\tboolean isDefault) {\n\t\tif ( namedStoredProcedureQuery != null ) {\n\t\t\tif ( namedStoredProcedureQuery.name().isEmpty() ) {\n\t\t\t\tthrow new AnnotationException( \"Class or package level '@NamedStoredProcedureQuery' annotation must specify a 'name'\" );\n\t\t\t}\n\n\t\t\tfinal NamedProcedureCallDefinitionImpl definition = new NamedProcedureCallDefinitionImpl( namedStoredProcedureQuery );\n\t\t\tif ( isDefault ) {\n\t\t\t\tcontext.getMetadataCollector().addDefaultNamedProcedureCall( definition );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcontext.getMetadataCollector().addNamedProcedureCallDefinition( definition );\n\t\t\t}\n\t\t\tLOG.debugf( \"Bound named stored procedure query : %s => %s\", definition.getRegistrationName(), definition.getProcedureName() );\n\t\t}\n\t}\n\n\tpublic static void bindSqlResultSetMapping(\n\t\t\tSqlResultSetMapping resultSetMappingAnn,\n\t\t\tMetadataBuildingContext context,\n\t\t\tboolean isDefault) {\n\t\t//no need to handle inSecondPass\n\t\tcontext.getMetadataCollector().addSecondPass( new ResultSetMappingSecondPass( resultSetMappingAnn, context, isDefault ) );\n\t}\n\n\tprivate static class JdbcCall {\n\t\tprivate final String callableName;\n\t\tprivate final boolean resultParameter;\n\t\tprivate final ArrayList<String> parameters;\n\n\t\tpublic JdbcCall(String callableName, boolean resultParameter, ArrayList<String> parameters) {\n\t\t\tthis.callableName = callableName;\n\t\t\tthis.resultParameter = resultParameter;\n\t\t\tthis.parameters = parameters;\n\t\t}\n\t}\n\n\tprivate static JdbcCall parseJdbcCall(String sqlString, Supplier<RuntimeException> exceptionProducer) {\n\t\tString callableName = null;\n\t\tboolean resultParameter = false;\n\t\tint index = skipWhitespace( sqlString, 1 );\n\t\t// Parse the out param `?=` part\n\t\tif ( sqlString.charAt( index ) == '?' ) {\n\t\t\tresultParameter = true;\n\t\t\tindex++;\n\t\t\tindex = skipWhitespace( sqlString, index );\n\t\t\tif ( sqlString.charAt( index ) != '=' ) {\n\t\t\t\tthrow exceptionProducer.get();\n\t\t\t}\n\t\t\tindex++;\n\t\t\tindex = skipWhitespace( sqlString, index );\n\t\t}\n\t\t// Parse the call keyword\n\t\tif ( !sqlString.regionMatches( true, index, \"call\", 0, 4 ) ) {\n\t\t\tthrow exceptionProducer.get();\n\t\t}\n\t\tindex += 4;\n\t\tindex = skipWhitespace( sqlString, index );\n\n\t\t// Parse the procedure name\n\t\tfinal int procedureStart = index;\n\t\tfor ( ; index < sqlString.length(); index++ ) {\n\t\t\tfinal char c = sqlString.charAt( index );\n\t\t\tif ( c == '(' || Character.isWhitespace( c ) ) {\n\t\t\t\tcallableName = sqlString.substring( procedureStart, index );\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tindex = skipWhitespace( sqlString, index );\n\t\tfinal ArrayList<String> parameters = new ArrayList<>();\n\t\tParameterParser.parse(\n\t\t\t\tsqlString.substring( index, sqlString.length() - 1 ),\n\t\t\t\tnew ParameterRecognizer() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void ordinalParameter(int sourcePosition) {\n\t\t\t\t\t\tparameters.add( \"\" );\n\t\t\t\t\t}\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void namedParameter(String name, int sourcePosition) {\n\t\t\t\t\t\tparameters.add( name );\n\t\t\t\t\t}\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void jpaPositionalParameter(int label, int sourcePosition) {\n\t\t\t\t\t\tparameters.add( \"\" );\n\t\t\t\t\t}\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void other(char character) {\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t);\n\t\treturn new JdbcCall( callableName, resultParameter, parameters );\n\t}\n\n\tprivate static int skipWhitespace(String sqlString, int i) {\n\t\twhile ( i < sqlString.length() ) {\n\t\t\tif ( !Character.isWhitespace( sqlString.charAt( i ) ) ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\treturn i;\n\t}\n\n\tprivate static AnnotationException illegalCallSyntax(org.hibernate.annotations.NamedNativeQuery queryAnn) {\n\t\treturn new AnnotationException( \"Callable 'NamedNativeQuery' named '\" + queryAnn.name()\n\t\t\t\t+ \"' does not use the JDBC call syntax\" );\n\t}\n}\n",
        "filePathAfter": "hibernate-core/src/main/java/org/hibernate/boot/model/internal/QueryBinder.java",
        "sourceCodeAfterForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n * See the lgpl.txt file in the root directory or http://www.gnu.org/licenses/lgpl-2.1.html.\n */\npackage org.hibernate.boot.model.internal;\n\nimport java.lang.invoke.MethodHandles;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.function.Supplier;\n\nimport org.hibernate.AnnotationException;\nimport org.hibernate.CacheMode;\nimport org.hibernate.FlushMode;\nimport org.hibernate.LockOptions;\nimport org.hibernate.annotations.FlushModeType;\nimport org.hibernate.annotations.HQLSelect;\nimport org.hibernate.annotations.SQLSelect;\nimport org.hibernate.boot.internal.NamedHqlQueryDefinitionImpl;\nimport org.hibernate.boot.internal.NamedProcedureCallDefinitionImpl;\nimport org.hibernate.boot.models.JpaAnnotations;\nimport org.hibernate.boot.models.annotations.internal.NamedStoredProcedureQueryJpaAnnotation;\nimport org.hibernate.boot.models.annotations.internal.QueryHintJpaAnnotation;\nimport org.hibernate.boot.models.annotations.internal.StoredProcedureParameterJpaAnnotation;\nimport org.hibernate.boot.query.NamedHqlQueryDefinition;\nimport org.hibernate.boot.query.NamedNativeQueryDefinition;\nimport org.hibernate.boot.query.NamedProcedureCallDefinition;\nimport org.hibernate.boot.query.SqlResultSetMappingDescriptor;\nimport org.hibernate.boot.registry.classloading.spi.ClassLoaderService;\nimport org.hibernate.boot.spi.MetadataBuildingContext;\nimport org.hibernate.internal.CoreMessageLogger;\nimport org.hibernate.internal.log.DeprecationLogger;\nimport org.hibernate.jpa.HibernateHints;\nimport org.hibernate.models.internal.util.StringHelper;\nimport org.hibernate.models.spi.ClassDetails;\nimport org.hibernate.models.spi.SourceModelBuildingContext;\nimport org.hibernate.query.sql.internal.ParameterParser;\nimport org.hibernate.query.sql.spi.ParameterRecognizer;\nimport org.hibernate.type.BasicType;\n\nimport org.jboss.logging.Logger;\n\nimport jakarta.persistence.CacheRetrieveMode;\nimport jakarta.persistence.CacheStoreMode;\nimport jakarta.persistence.NamedNativeQuery;\nimport jakarta.persistence.NamedQuery;\nimport jakarta.persistence.NamedStoredProcedureQuery;\nimport jakarta.persistence.ParameterMode;\nimport jakarta.persistence.QueryHint;\nimport jakarta.persistence.SqlResultSetMapping;\nimport jakarta.persistence.StoredProcedureParameter;\n\nimport static java.lang.Boolean.TRUE;\nimport static org.hibernate.internal.util.StringHelper.nullIfEmpty;\nimport static org.hibernate.internal.util.collections.ArrayHelper.isEmpty;\nimport static org.hibernate.internal.util.collections.CollectionHelper.determineProperSizing;\nimport static org.hibernate.internal.util.collections.CollectionHelper.setOf;\n\n/**\n * Responsible for reading named queries defined in annotations and registering\n * {@link org.hibernate.boot.query.NamedQueryDefinition} objects.\n *\n * @implNote This class is stateless, unlike most of the other \"binders\".\n *\n * @author Emmanuel Bernard\n */\npublic abstract class QueryBinder {\n\tprivate static final CoreMessageLogger LOG = Logger.getMessageLogger( MethodHandles.lookup(), CoreMessageLogger.class, QueryBinder.class.getName() );\n\n\tpublic static void bindQuery(\n\t\t\tNamedQuery namedQuery,\n\t\t\tMetadataBuildingContext context,\n\t\t\tboolean isDefault) {\n\t\tif ( namedQuery == null ) {\n\t\t\treturn;\n\t\t}\n\n\t\tfinal String queryName = namedQuery.name();\n\t\tfinal String queryString = namedQuery.query();\n\t\tfinal Class<?> resultClass = namedQuery.resultClass();\n\n\t\tif ( queryName.isEmpty() ) {\n\t\t\tthrow new AnnotationException( \"Class or package level '@NamedQuery' annotation must specify a 'name'\" );\n\t\t}\n\n\t\tif ( LOG.isDebugEnabled() ) {\n\t\t\tLOG.debugf( \"Binding named query: %s => %s\", queryName, queryString );\n\t\t}\n\n\t\tfinal QueryHintDefinition hints = new QueryHintDefinition( queryName, namedQuery.hints() );\n\t\tfinal NamedHqlQueryDefinition<?> queryMapping =\n\t\t\t\tcreateNamedQueryDefinition( queryName, queryString, resultClass,\n\t\t\t\t\t\thints.determineLockOptions( namedQuery ), hints );\n\t\tif ( isDefault ) {\n\t\t\tcontext.getMetadataCollector().addDefaultQuery( queryMapping );\n\t\t}\n\t\telse {\n\t\t\tcontext.getMetadataCollector().addNamedQuery( queryMapping );\n\t\t}\n\t}\n\n\tprivate static <T> NamedHqlQueryDefinitionImpl<T> createNamedQueryDefinition(\n\t\t\tString queryName, String queryString, Class<T> resultClass, LockOptions lockOptions,\n\t\t\tQueryHintDefinition hints) {\n\t\treturn new NamedHqlQueryDefinitionImpl.Builder<T>(queryName)\n\t\t\t\t.setHqlString(queryString)\n\t\t\t\t.setResultClass(resultClass)\n\t\t\t\t.setCacheable(hints.getCacheability())\n\t\t\t\t.setCacheMode(hints.getCacheMode())\n\t\t\t\t.setCacheRegion(hints.getString(HibernateHints.HINT_CACHE_REGION))\n\t\t\t\t.setTimeout(hints.getTimeout())\n\t\t\t\t.setFetchSize(hints.getInteger(HibernateHints.HINT_FETCH_SIZE))\n\t\t\t\t.setFlushMode(hints.getFlushMode())\n\t\t\t\t.setReadOnly(hints.getBooleanWrapper(HibernateHints.HINT_READ_ONLY))\n\t\t\t\t.setLockOptions(lockOptions)\n\t\t\t\t.setComment(hints.getString(HibernateHints.HINT_COMMENT))\n\t\t\t\t.build();\n\t}\n\n\tpublic static void bindNativeQuery(\n\t\t\tNamedNativeQuery namedNativeQuery,\n\t\t\tMetadataBuildingContext context,\n\t\t\tboolean isDefault) {\n\t\tif ( namedNativeQuery == null ) {\n\t\t\treturn;\n\t\t}\n\n\t\tfinal String registrationName = namedNativeQuery.name();\n\t\tfinal String queryString = namedNativeQuery.query();\n\n\t\tif ( registrationName.isEmpty() ) {\n\t\t\tthrow new AnnotationException( \"Class or package level '@NamedNativeQuery' annotation must specify a 'name'\" );\n\t\t}\n\n\t\tfinal QueryHintDefinition hints = new QueryHintDefinition( registrationName, namedNativeQuery.hints() );\n\n\t\tfinal String resultSetMappingName = namedNativeQuery.resultSetMapping();\n\t\tfinal Class<?> resultClassDetails = namedNativeQuery.resultClass();\n\t\tfinal Class<?> resultClass = void.class == resultClassDetails ? null : resultClassDetails;\n\n\t\tfinal NamedNativeQueryDefinition<?> queryDefinition =\n\t\t\t\tcreateNamedQueryDefinition( registrationName, queryString, resultClass, resultSetMappingName, hints );\n\n\t\tif ( LOG.isDebugEnabled() ) {\n\t\t\tLOG.debugf( \"Binding named native query: %s => %s\",\n\t\t\t\t\tqueryDefinition.getRegistrationName(), queryDefinition.getSqlQueryString() );\n\t\t}\n\n\t\tif ( isDefault ) {\n\t\t\tcontext.getMetadataCollector().addDefaultNamedNativeQuery( queryDefinition );\n\t\t}\n\t\telse {\n\t\t\tcontext.getMetadataCollector().addNamedNativeQuery( queryDefinition );\n\t\t}\n\t}\n\n\tprivate static <T> NamedNativeQueryDefinition<T> createNamedQueryDefinition(\n\t\t\tString registrationName, String queryString,\n\t\t\tClass<T> resultClass, String resultSetMappingName,\n\t\t\tQueryHintDefinition hints) {\n\t\treturn new NamedNativeQueryDefinition.Builder<T>(registrationName)\n\t\t\t\t.setSqlString(queryString)\n\t\t\t\t.setResultClass(resultClass)\n\t\t\t\t.setResultSetMappingName(resultSetMappingName)\n\t\t\t\t.setQuerySpaces(null)\n\t\t\t\t.setCacheable(hints.getCacheability())\n\t\t\t\t.setCacheMode(hints.getCacheMode())\n\t\t\t\t.setCacheRegion(hints.getString(HibernateHints.HINT_CACHE_REGION))\n\t\t\t\t.setTimeout(hints.getTimeout())\n\t\t\t\t.setFetchSize(hints.getInteger(HibernateHints.HINT_FETCH_SIZE))\n\t\t\t\t.setFlushMode(hints.getFlushMode())\n\t\t\t\t.setReadOnly(hints.getBooleanWrapper(HibernateHints.HINT_READ_ONLY))\n\t\t\t\t.setComment(hints.getString(HibernateHints.HINT_COMMENT))\n\t\t\t\t.addHints(hints.getHintsMap())\n\t\t\t\t.build();\n\t}\n\n\tpublic static void bindNativeQuery(\n\t\t\tString name,\n\t\t\tSQLSelect sqlSelect,\n\t\t\tClassDetails annotatedClass,\n\t\t\tMetadataBuildingContext context) {\n\t\tfinal NamedNativeQueryDefinition.Builder<?> builder = new NamedNativeQueryDefinition.Builder<>( name )\n\t\t\t\t.setFlushMode( FlushMode.MANUAL )\n\t\t\t\t.setSqlString( sqlSelect.sql() )\n\t\t\t\t.setQuerySpaces( setOf( sqlSelect.querySpaces() ) );\n\n\t\tif ( annotatedClass != null ) {\n\t\t\tbuilder.setResultClass(\n\t\t\t\t\tcontext.getBootstrapContext().getServiceRegistry().requireService( ClassLoaderService.class )\n\t\t\t\t\t\t\t.classForName( annotatedClass.getClassName() )\n\t\t\t);\n\t\t}\n\n\t\tfinal SqlResultSetMapping resultSetMapping = sqlSelect.resultSetMapping();\n\t\tif ( !isEmpty( resultSetMapping.columns() )\n\t\t\t\t|| !isEmpty( resultSetMapping.entities() )\n\t\t\t\t|| !isEmpty( resultSetMapping.classes() ) ) {\n\t\t\tcontext.getMetadataCollector()\n\t\t\t\t\t.addResultSetMapping( SqlResultSetMappingDescriptor.from( resultSetMapping, name ) );\n\t\t\tbuilder.setResultSetMappingName( name );\n\t\t}\n\n\t\tcontext.getMetadataCollector().addNamedNativeQuery( builder.build() );\n\t}\n\n\tpublic static void bindNativeQuery(\n\t\t\torg.hibernate.annotations.NamedNativeQuery namedNativeQuery,\n\t\t\tMetadataBuildingContext context) {\n\t\tif ( namedNativeQuery == null ) {\n\t\t\treturn;\n\t\t}\n\n\t\tfinal String registrationName = namedNativeQuery.name();\n\n\t\tif ( registrationName.isEmpty() ) {\n\t\t\tthrow new AnnotationException( \"Class or package level '@NamedNativeQuery' annotation must specify a 'name'\" );\n\t\t}\n\n\t\tfinal String resultSetMappingName = namedNativeQuery.resultSetMapping();\n\t\tfinal Class<?> resultClassDetails = namedNativeQuery.resultClass();\n\t\tfinal Class<?> resultClass = resultClassDetails == void.class ? null : resultClassDetails;\n\n\t\tfinal String[] querySpacesList = namedNativeQuery.querySpaces();\n\t\tfinal HashSet<String> querySpaces = new HashSet<>( determineProperSizing( querySpacesList.length ) );\n\t\tCollections.addAll( querySpaces, querySpacesList );\n\n\t\tfinal NamedNativeQueryDefinition.Builder<?> builder =\n\t\t\t\tcreateQueryDefinition( namedNativeQuery, registrationName, resultSetMappingName, resultClass,\n\t\t\t\t\t\tnamedNativeQuery.timeout(), namedNativeQuery.fetchSize(), querySpaces );\n\n\t\tif ( TRUE == namedNativeQuery.callable() ) {\n\t\t\tfinal NamedProcedureCallDefinition definition =\n\t\t\t\t\tcreateStoredProcedure( builder, context, () -> illegalCallSyntax( namedNativeQuery ) );\n\t\t\tcontext.getMetadataCollector().addNamedProcedureCallDefinition( definition );\n\t\t\tDeprecationLogger.DEPRECATION_LOGGER.warn(\n\t\t\t\t\t\"Marking named native queries as callable is no longer supported; use '@jakarta.persistence.NamedStoredProcedureQuery' instead. Ignoring.\"\n\t\t\t);\n\t\t}\n\t\telse {\n\t\t\tfinal NamedNativeQueryDefinition<?> queryDefinition = builder.build();\n\n\t\t\tif ( LOG.isDebugEnabled() ) {\n\t\t\t\tLOG.debugf(\n\t\t\t\t\t\t\"Binding named native query: %s => %s\",\n\t\t\t\t\t\tqueryDefinition.getRegistrationName(),\n\t\t\t\t\t\tqueryDefinition.getSqlQueryString()\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tcontext.getMetadataCollector().addNamedNativeQuery( queryDefinition );\n\t\t}\n\t}\n\n\tprivate static <T> NamedNativeQueryDefinition.Builder<T> createQueryDefinition(\n\t\t\torg.hibernate.annotations.NamedNativeQuery namedNativeQuery,\n\t\t\tString registrationName, String resultSetMappingName,\n\t\t\tClass<T> resultClass,\n\t\t\tint timeout, int fetchSize,\n\t\t\tHashSet<String> querySpaces) {\n\t\treturn new NamedNativeQueryDefinition.Builder<T>(registrationName)\n\t\t\t\t.setSqlString(namedNativeQuery.query())\n\t\t\t\t.setResultSetMappingName(resultSetMappingName)\n\t\t\t\t.setResultClass(resultClass)\n\t\t\t\t.setCacheable(namedNativeQuery.cacheable())\n\t\t\t\t.setCacheRegion(nullIfEmpty(namedNativeQuery.cacheRegion()))\n\t\t\t\t.setCacheMode(getCacheMode(namedNativeQuery.cacheRetrieveMode(), namedNativeQuery.cacheStoreMode()))\n\t\t\t\t.setTimeout(timeout < 0 ? null : timeout)\n\t\t\t\t.setFetchSize(fetchSize < 0 ? null : fetchSize)\n\t\t\t\t.setFlushMode(getFlushMode(namedNativeQuery.flushMode()))\n\t\t\t\t.setReadOnly(namedNativeQuery.readOnly())\n\t\t\t\t.setQuerySpaces(querySpaces)\n\t\t\t\t.setComment(nullIfEmpty(namedNativeQuery.comment()));\n\t}\n\n\t/**\n\t * Handles legacy cases where a named native query was used to specify a procedure call\n\t *\n\t * @deprecated User should use {@linkplain NamedStoredProcedureQuery} instead\n\t */\n\t@Deprecated\n\tpublic static NamedProcedureCallDefinition createStoredProcedure(\n\t\t\tNamedNativeQueryDefinition.Builder<?> builder,\n\t\t\tMetadataBuildingContext context,\n\t\t\tSupplier<RuntimeException> exceptionProducer) {\n\t\tfinal String sqlString = builder.getSqlString().trim();\n\t\tif ( !sqlString.startsWith( \"{\" ) || !sqlString.endsWith( \"}\" ) ) {\n\t\t\tthrow exceptionProducer.get();\n\t\t}\n\t\tfinal JdbcCall jdbcCall = parseJdbcCall( sqlString, exceptionProducer );\n\n\t\tfinal SourceModelBuildingContext sourceModelBuildingContext = context.getMetadataCollector()\n\t\t\t\t.getSourceModelBuildingContext();\n\t\tfinal NamedStoredProcedureQueryJpaAnnotation nameStoredProcedureQueryAnn =\n\t\t\t\tJpaAnnotations.NAMED_STORED_PROCEDURE_QUERY.createUsage( sourceModelBuildingContext );\n\t\tnameStoredProcedureQueryAnn.name( builder.getName() );\n\t\tnameStoredProcedureQueryAnn.procedureName( jdbcCall.callableName );\n\n\t\tfinal StoredProcedureParameter[] parameters = new StoredProcedureParameter[jdbcCall.parameters.size()];\n\t\tnameStoredProcedureQueryAnn.parameters( parameters );\n\n\t\tfor ( int i = 0; i < jdbcCall.parameters.size(); i++ ) {\n\t\t\tfinal StoredProcedureParameterJpaAnnotation param =\n\t\t\t\t\tJpaAnnotations.STORED_PROCEDURE_PARAMETER.createUsage( sourceModelBuildingContext );\n\t\t\tparameters[i] = param;\n\n\t\t\tfinal String paramName = jdbcCall.parameters.get( i );\n\t\t\tparam.name( paramName );\n\t\t\tparam.mode( ParameterMode.IN );\n\n\t\t\tfinal String typeName = builder.getParameterTypes().get( paramName );\n\t\t\tfinal ClassDetails classDetails;\n\t\t\tif ( StringHelper.isEmpty( typeName ) ) {\n\t\t\t\tclassDetails = ClassDetails.VOID_CLASS_DETAILS;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfinal BasicType<Object> registeredType = context.getBootstrapContext()\n\t\t\t\t\t\t.getTypeConfiguration()\n\t\t\t\t\t\t.getBasicTypeRegistry()\n\t\t\t\t\t\t.getRegisteredType( typeName );\n\t\t\t\tclassDetails = context.getMetadataCollector().getClassDetailsRegistry()\n\t\t\t\t\t\t.getClassDetails( registeredType.getJavaType().getName() );\n\t\t\t}\n\t\t\tparam.type( classDetails.toJavaClass() );\n\t\t}\n\n\t\tif ( builder.getResultSetMappingName() != null ) {\n\t\t\tnameStoredProcedureQueryAnn.resultSetMappings( new String[] { builder.getResultSetMappingName() } );\n\t\t}\n\n\t\tfinal Class<?> resultClass = builder.getResultClass();\n\t\tif ( resultClass != null ) {\n\t\t\tnameStoredProcedureQueryAnn.resultClasses( new Class[]{ builder.getResultClass() } );\n\t\t}\n\n\t\tfinal List<QueryHintJpaAnnotation> hints = new ArrayList<>();\n\n\t\tif ( builder.getQuerySpaces() != null ) {\n\t\t\tfinal QueryHintJpaAnnotation hint =\n\t\t\t\t\tJpaAnnotations.QUERY_HINT.createUsage( sourceModelBuildingContext );\n\t\t\thint.name( HibernateHints.HINT_NATIVE_SPACES );\n\t\t\thint.value( String.join( \" \", builder.getQuerySpaces() ) );\n\t\t\thints.add( hint );\n\t\t}\n\n\t\tif ( jdbcCall.resultParameter ) {\n\t\t\t// Mark native queries that have a result parameter as callable functions\n\t\t\tfinal QueryHintJpaAnnotation hint =\n\t\t\t\t\tJpaAnnotations.QUERY_HINT.createUsage( sourceModelBuildingContext );\n\t\t\thint.name( HibernateHints.HINT_CALLABLE_FUNCTION );\n\t\t\thint.value( \"true\" );\n\t\t\thints.add( hint );\n\t\t}\n\n\t\tnameStoredProcedureQueryAnn.hints( hints.toArray(QueryHint[]::new) );\n\n\t\treturn new NamedProcedureCallDefinitionImpl( nameStoredProcedureQueryAnn );\n\t}\n\n\tpublic static void bindQuery(\n\t\t\tString name,\n\t\t\tHQLSelect hqlSelect,\n\t\t\tMetadataBuildingContext context) {\n\t\tfinal NamedHqlQueryDefinition<?> hqlQueryDefinition = new NamedHqlQueryDefinition.Builder<>( name )\n\t\t\t\t.setFlushMode( FlushMode.MANUAL )\n\t\t\t\t.setHqlString( hqlSelect.query() )\n\t\t\t\t.build();\n\n\t\tcontext.getMetadataCollector().addNamedQuery( hqlQueryDefinition );\n\t}\n\n\tpublic static void bindQuery(\n\t\t\torg.hibernate.annotations.NamedQuery namedQuery,\n\t\t\tMetadataBuildingContext context) {\n\t\tif ( namedQuery == null ) {\n\t\t\treturn;\n\t\t}\n\n\t\tfinal String registrationName = namedQuery.name();\n\t\tfinal Class<?> resultClass = namedQuery.resultClass();\n\n\t\tif ( registrationName.isEmpty() ) {\n\t\t\tthrow new AnnotationException( \"Class or package level '@NamedQuery' annotation must specify a 'name'\" );\n\t\t}\n\n\t\tfinal NamedHqlQueryDefinition.Builder<?> builder =\n\t\t\t\tcreateQueryDefinition( namedQuery, registrationName, resultClass,\n\t\t\t\t\t\tnamedQuery.timeout(), namedQuery.fetchSize() ) ;\n\n\t\tfinal NamedHqlQueryDefinitionImpl<?> hqlQueryDefinition = builder.build();\n\n\t\tif ( LOG.isDebugEnabled() ) {\n\t\t\tLOG.debugf( \"Binding named query: %s => %s\",\n\t\t\t\t\thqlQueryDefinition.getRegistrationName(), hqlQueryDefinition.getHqlString() );\n\t\t}\n\n\t\tcontext.getMetadataCollector().addNamedQuery( hqlQueryDefinition );\n\t}\n\n\tprivate static <T> NamedHqlQueryDefinition.Builder<T> createQueryDefinition(\n\t\t\torg.hibernate.annotations.NamedQuery namedQuery,\n\t\t\tString registrationName, Class<T> resultClass, int timeout, int fetchSize) {\n\t\treturn new NamedHqlQueryDefinition.Builder<T>(registrationName)\n\t\t\t\t.setHqlString(namedQuery.query())\n\t\t\t\t.setResultClass(resultClass)\n\t\t\t\t.setCacheable(namedQuery.cacheable())\n\t\t\t\t.setCacheRegion(nullIfEmpty(namedQuery.cacheRegion()))\n\t\t\t\t.setCacheMode(getCacheMode(namedQuery.cacheRetrieveMode(), namedQuery.cacheStoreMode()))\n\t\t\t\t.setTimeout(timeout < 0 ? null : timeout)\n\t\t\t\t.setFetchSize(fetchSize < 0 ? null : fetchSize)\n\t\t\t\t.setFlushMode(getFlushMode(namedQuery.flushMode()))\n\t\t\t\t.setReadOnly(namedQuery.readOnly())\n\t\t\t\t.setComment(nullIfEmpty(namedQuery.comment()));\n\t}\n\n\tprivate static CacheMode getCacheMode(CacheRetrieveMode cacheRetrieveMode, CacheStoreMode cacheStoreMode) {\n\t\tfinal CacheMode cacheMode = CacheMode.fromJpaModes( cacheRetrieveMode, cacheStoreMode );\n\t\treturn cacheMode == null ? CacheMode.NORMAL : cacheMode;\n\t}\n\n\tprivate static FlushMode getFlushMode(FlushModeType flushModeType) {\n\t\treturn switch ( flushModeType ) {\n\t\t\tcase ALWAYS -> FlushMode.ALWAYS;\n\t\t\tcase AUTO -> FlushMode.AUTO;\n\t\t\tcase COMMIT -> FlushMode.COMMIT;\n\t\t\tcase MANUAL -> FlushMode.MANUAL;\n\t\t\tcase PERSISTENCE_CONTEXT -> null;\n\t\t};\n\t}\n\n\tpublic static void bindNamedStoredProcedureQuery(\n\t\t\tNamedStoredProcedureQuery namedStoredProcedureQuery,\n\t\t\tMetadataBuildingContext context,\n\t\t\tboolean isDefault) {\n\t\tif ( namedStoredProcedureQuery != null ) {\n\t\t\tif ( namedStoredProcedureQuery.name().isEmpty() ) {\n\t\t\t\tthrow new AnnotationException( \"Class or package level '@NamedStoredProcedureQuery' annotation must specify a 'name'\" );\n\t\t\t}\n\n\t\t\tfinal NamedProcedureCallDefinitionImpl definition =\n\t\t\t\t\tnew NamedProcedureCallDefinitionImpl( namedStoredProcedureQuery );\n\t\t\tif ( isDefault ) {\n\t\t\t\tcontext.getMetadataCollector().addDefaultNamedProcedureCall( definition );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcontext.getMetadataCollector().addNamedProcedureCallDefinition( definition );\n\t\t\t}\n\t\t\tLOG.debugf( \"Bound named stored procedure query : %s => %s\",\n\t\t\t\t\tdefinition.getRegistrationName(), definition.getProcedureName() );\n\t\t}\n\t}\n\n\tpublic static void bindSqlResultSetMapping(\n\t\t\tSqlResultSetMapping resultSetMappingAnn,\n\t\t\tMetadataBuildingContext context,\n\t\t\tboolean isDefault) {\n\t\t//no need to handle inSecondPass\n\t\tcontext.getMetadataCollector()\n\t\t\t\t.addSecondPass( new ResultSetMappingSecondPass( resultSetMappingAnn, context, isDefault ) );\n\t}\n\n\tprivate static class JdbcCall {\n\t\tprivate final String callableName;\n\t\tprivate final boolean resultParameter;\n\t\tprivate final ArrayList<String> parameters;\n\n\t\tpublic JdbcCall(String callableName, boolean resultParameter, ArrayList<String> parameters) {\n\t\t\tthis.callableName = callableName;\n\t\t\tthis.resultParameter = resultParameter;\n\t\t\tthis.parameters = parameters;\n\t\t}\n\t}\n\n\tprivate static JdbcCall parseJdbcCall(String sqlString, Supplier<RuntimeException> exceptionProducer) {\n\t\tString callableName = null;\n\t\tboolean resultParameter = false;\n\t\tint index = skipWhitespace( sqlString, 1 );\n\t\t// Parse the out param `?=` part\n\t\tif ( sqlString.charAt( index ) == '?' ) {\n\t\t\tresultParameter = true;\n\t\t\tindex++;\n\t\t\tindex = skipWhitespace( sqlString, index );\n\t\t\tif ( sqlString.charAt( index ) != '=' ) {\n\t\t\t\tthrow exceptionProducer.get();\n\t\t\t}\n\t\t\tindex++;\n\t\t\tindex = skipWhitespace( sqlString, index );\n\t\t}\n\t\t// Parse the call keyword\n\t\tif ( !sqlString.regionMatches( true, index, \"call\", 0, 4 ) ) {\n\t\t\tthrow exceptionProducer.get();\n\t\t}\n\t\tindex += 4;\n\t\tindex = skipWhitespace( sqlString, index );\n\n\t\t// Parse the procedure name\n\t\tfinal int procedureStart = index;\n\t\tfor ( ; index < sqlString.length(); index++ ) {\n\t\t\tfinal char c = sqlString.charAt( index );\n\t\t\tif ( c == '(' || Character.isWhitespace( c ) ) {\n\t\t\t\tcallableName = sqlString.substring( procedureStart, index );\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tindex = skipWhitespace( sqlString, index );\n\t\tfinal ArrayList<String> parameters = new ArrayList<>();\n\t\tParameterParser.parse(\n\t\t\t\tsqlString.substring( index, sqlString.length() - 1 ),\n\t\t\t\tnew ParameterRecognizer() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void ordinalParameter(int sourcePosition) {\n\t\t\t\t\t\tparameters.add( \"\" );\n\t\t\t\t\t}\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void namedParameter(String name, int sourcePosition) {\n\t\t\t\t\t\tparameters.add( name );\n\t\t\t\t\t}\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void jpaPositionalParameter(int label, int sourcePosition) {\n\t\t\t\t\t\tparameters.add( \"\" );\n\t\t\t\t\t}\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void other(char character) {\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t);\n\t\treturn new JdbcCall( callableName, resultParameter, parameters );\n\t}\n\n\tprivate static int skipWhitespace(String sqlString, int i) {\n\t\twhile ( i < sqlString.length() ) {\n\t\t\tif ( !Character.isWhitespace( sqlString.charAt( i ) ) ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\treturn i;\n\t}\n\n\tprivate static AnnotationException illegalCallSyntax(org.hibernate.annotations.NamedNativeQuery queryAnn) {\n\t\treturn new AnnotationException( \"Callable 'NamedNativeQuery' named '\" + queryAnn.name()\n\t\t\t\t+ \"' does not use the JDBC call syntax\" );\n\t}\n}\n",
        "diffSourceCodeSet": [
            "private static <T> NamedHqlQueryDefinitionImpl<T> createNamedQueryDefinition(\n\t\t\tString queryName, String queryString, Class<T> resultClass, LockOptions lockOptions,\n\t\t\tQueryHintDefinition hints) {\n\t\treturn new NamedHqlQueryDefinitionImpl.Builder<T>(queryName)\n\t\t\t\t.setHqlString(queryString)\n\t\t\t\t.setResultClass(resultClass)\n\t\t\t\t.setCacheable(hints.getCacheability())\n\t\t\t\t.setCacheMode(hints.getCacheMode())\n\t\t\t\t.setCacheRegion(hints.getString(HibernateHints.HINT_CACHE_REGION))\n\t\t\t\t.setTimeout(hints.getTimeout())\n\t\t\t\t.setFetchSize(hints.getInteger(HibernateHints.HINT_FETCH_SIZE))\n\t\t\t\t.setFlushMode(hints.getFlushMode())\n\t\t\t\t.setReadOnly(hints.getBooleanWrapper(HibernateHints.HINT_READ_ONLY))\n\t\t\t\t.setLockOptions(lockOptions)\n\t\t\t\t.setComment(hints.getString(HibernateHints.HINT_COMMENT))\n\t\t\t\t.build();\n\t}"
        ],
        "invokedMethodSet": [
            "methodSignature: org.hibernate.boot.model.internal.QueryBinder#getCacheMode\n methodBody: private static CacheMode getCacheMode(CacheRetrieveMode cacheRetrieveMode, CacheStoreMode cacheStoreMode) {\nfinal CacheMode cacheMode=CacheMode.fromJpaModes(cacheRetrieveMode,cacheStoreMode);\nreturn cacheMode == null ? CacheMode.NORMAL : cacheMode;\n}",
            "methodSignature: org.hibernate.boot.model.internal.QueryBinder#getFlushMode\n methodBody: private static FlushMode getFlushMode(FlushModeType flushModeType) {\nreturn switch (flushModeType) {\ncase ALWAYS ->  yield FlushMode.ALWAYS;\ncase AUTO ->yield FlushMode.AUTO;\ncase COMMIT ->yield FlushMode.COMMIT;\ncase MANUAL ->yield FlushMode.MANUAL;\ncase PERSISTENCE_CONTEXT ->yield null;\n}\n;\n}"
        ],
        "sourceCodeAfterRefactoring": "public static void bindQuery(\n\t\t\tNamedQuery namedQuery,\n\t\t\tMetadataBuildingContext context,\n\t\t\tboolean isDefault) {\n\t\tif ( namedQuery == null ) {\n\t\t\treturn;\n\t\t}\n\n\t\tfinal String queryName = namedQuery.name();\n\t\tfinal String queryString = namedQuery.query();\n\t\tfinal Class<?> resultClass = namedQuery.resultClass();\n\n\t\tif ( queryName.isEmpty() ) {\n\t\t\tthrow new AnnotationException( \"Class or package level '@NamedQuery' annotation must specify a 'name'\" );\n\t\t}\n\n\t\tif ( LOG.isDebugEnabled() ) {\n\t\t\tLOG.debugf( \"Binding named query: %s => %s\", queryName, queryString );\n\t\t}\n\n\t\tfinal QueryHintDefinition hints = new QueryHintDefinition( queryName, namedQuery.hints() );\n\t\tfinal NamedHqlQueryDefinition<?> queryMapping =\n\t\t\t\tcreateNamedQueryDefinition( queryName, queryString, resultClass,\n\t\t\t\t\t\thints.determineLockOptions( namedQuery ), hints );\n\t\tif ( isDefault ) {\n\t\t\tcontext.getMetadataCollector().addDefaultQuery( queryMapping );\n\t\t}\n\t\telse {\n\t\t\tcontext.getMetadataCollector().addNamedQuery( queryMapping );\n\t\t}\n\t}\nprivate static <T> NamedHqlQueryDefinitionImpl<T> createNamedQueryDefinition(\n\t\t\tString queryName, String queryString, Class<T> resultClass, LockOptions lockOptions,\n\t\t\tQueryHintDefinition hints) {\n\t\treturn new NamedHqlQueryDefinitionImpl.Builder<T>(queryName)\n\t\t\t\t.setHqlString(queryString)\n\t\t\t\t.setResultClass(resultClass)\n\t\t\t\t.setCacheable(hints.getCacheability())\n\t\t\t\t.setCacheMode(hints.getCacheMode())\n\t\t\t\t.setCacheRegion(hints.getString(HibernateHints.HINT_CACHE_REGION))\n\t\t\t\t.setTimeout(hints.getTimeout())\n\t\t\t\t.setFetchSize(hints.getInteger(HibernateHints.HINT_FETCH_SIZE))\n\t\t\t\t.setFlushMode(hints.getFlushMode())\n\t\t\t\t.setReadOnly(hints.getBooleanWrapper(HibernateHints.HINT_READ_ONLY))\n\t\t\t\t.setLockOptions(lockOptions)\n\t\t\t\t.setComment(hints.getString(HibernateHints.HINT_COMMENT))\n\t\t\t\t.build();\n\t}",
        "diffSourceCode": "-   73: \tpublic static void bindQuery(\n-   74: \t\t\tNamedQuery namedQuery,\n-   75: \t\t\tMetadataBuildingContext context,\n-   76: \t\t\tboolean isDefault) {\n-   77: \t\tif ( namedQuery == null ) {\n-   78: \t\t\treturn;\n-   79: \t\t}\n-   80: \n-   81: \t\tfinal String queryName = namedQuery.name();\n-   82: \t\tfinal String queryString = namedQuery.query();\n-   83: \n-   84: \t\tif ( queryName.isEmpty() ) {\n-   85: \t\t\tthrow new AnnotationException( \"Class or package level '@NamedQuery' annotation must specify a 'name'\" );\n-   86: \t\t}\n-   87: \n-   88: \t\tif ( LOG.isDebugEnabled() ) {\n-   89: \t\t\tLOG.debugf( \"Binding named query: %s => %s\", queryName, queryString );\n-   90: \t\t}\n-   91: \n-   92: \t\tfinal QueryHintDefinition hints = new QueryHintDefinition( queryName, namedQuery.hints() );\n+   73: \n+   74: \tpublic static void bindQuery(\n+   75: \t\t\tNamedQuery namedQuery,\n+   76: \t\t\tMetadataBuildingContext context,\n+   77: \t\t\tboolean isDefault) {\n+   78: \t\tif ( namedQuery == null ) {\n+   79: \t\t\treturn;\n+   80: \t\t}\n+   81: \n+   82: \t\tfinal String queryName = namedQuery.name();\n+   83: \t\tfinal String queryString = namedQuery.query();\n+   84: \t\tfinal Class<?> resultClass = namedQuery.resultClass();\n+   85: \n+   86: \t\tif ( queryName.isEmpty() ) {\n+   87: \t\t\tthrow new AnnotationException( \"Class or package level '@NamedQuery' annotation must specify a 'name'\" );\n+   88: \t\t}\n+   89: \n+   90: \t\tif ( LOG.isDebugEnabled() ) {\n+   91: \t\t\tLOG.debugf( \"Binding named query: %s => %s\", queryName, queryString );\n+   92: \t\t}\n    93: \n-   94: \t\tfinal NamedHqlQueryDefinition<?> queryMapping = new NamedHqlQueryDefinitionImpl.Builder<>( queryName )\n-   95: \t\t\t\t.setHqlString( queryString )\n-   96: \t\t\t\t.setResultClass( (Class<Object>) namedQuery.resultClass() )\n-   97: \t\t\t\t.setCacheable( hints.getCacheability() )\n-   98: \t\t\t\t.setCacheMode( hints.getCacheMode() )\n-   99: \t\t\t\t.setCacheRegion( hints.getString( HibernateHints.HINT_CACHE_REGION ) )\n-  100: \t\t\t\t.setTimeout( hints.getTimeout() )\n-  101: \t\t\t\t.setFetchSize( hints.getInteger( HibernateHints.HINT_FETCH_SIZE ) )\n-  102: \t\t\t\t.setFlushMode( hints.getFlushMode() )\n-  103: \t\t\t\t.setReadOnly( hints.getBooleanWrapper( HibernateHints.HINT_READ_ONLY ) )\n-  104: \t\t\t\t.setLockOptions( hints.determineLockOptions( namedQuery ) )\n-  105: \t\t\t\t.setComment( hints.getString( HibernateHints.HINT_COMMENT ) )\n-  106: \t\t\t\t.build();\n-  107: \n-  108: \t\tif ( isDefault ) {\n-  109: \t\t\tcontext.getMetadataCollector().addDefaultQuery( queryMapping );\n-  110: \t\t}\n-  111: \t\telse {\n-  112: \t\t\tcontext.getMetadataCollector().addNamedQuery( queryMapping );\n-  113: \t\t}\n-  114: \t}\n-  115: \n-  116: \tprivate static Class<Object> loadClass(ClassDetails classDetails, MetadataBuildingContext context) {\n-  117: \t\treturn ClassDetails.VOID_CLASS_DETAILS == classDetails\n-  118: \t\t\t\t? null\n-  119: \t\t\t\t: context.getBootstrapContext()\n-  120: \t\t\t\t\t\t.getServiceRegistry()\n-  121: \t\t\t\t\t\t.requireService( ClassLoaderService.class )\n-  122: \t\t\t\t\t\t.classForName( classDetails.getName() );\n+   94: \t\tfinal QueryHintDefinition hints = new QueryHintDefinition( queryName, namedQuery.hints() );\n+   95: \t\tfinal NamedHqlQueryDefinition<?> queryMapping =\n+   96: \t\t\t\tcreateNamedQueryDefinition( queryName, queryString, resultClass,\n+   97: \t\t\t\t\t\thints.determineLockOptions( namedQuery ), hints );\n+   98: \t\tif ( isDefault ) {\n+   99: \t\t\tcontext.getMetadataCollector().addDefaultQuery( queryMapping );\n+  100: \t\t}\n+  101: \t\telse {\n+  102: \t\t\tcontext.getMetadataCollector().addNamedQuery( queryMapping );\n+  103: \t\t}\n+  104: \t}\n+  105: \n+  106: \tprivate static <T> NamedHqlQueryDefinitionImpl<T> createNamedQueryDefinition(\n+  107: \t\t\tString queryName, String queryString, Class<T> resultClass, LockOptions lockOptions,\n+  108: \t\t\tQueryHintDefinition hints) {\n+  109: \t\treturn new NamedHqlQueryDefinitionImpl.Builder<T>(queryName)\n+  110: \t\t\t\t.setHqlString(queryString)\n+  111: \t\t\t\t.setResultClass(resultClass)\n+  112: \t\t\t\t.setCacheable(hints.getCacheability())\n+  113: \t\t\t\t.setCacheMode(hints.getCacheMode())\n+  114: \t\t\t\t.setCacheRegion(hints.getString(HibernateHints.HINT_CACHE_REGION))\n+  115: \t\t\t\t.setTimeout(hints.getTimeout())\n+  116: \t\t\t\t.setFetchSize(hints.getInteger(HibernateHints.HINT_FETCH_SIZE))\n+  117: \t\t\t\t.setFlushMode(hints.getFlushMode())\n+  118: \t\t\t\t.setReadOnly(hints.getBooleanWrapper(HibernateHints.HINT_READ_ONLY))\n+  119: \t\t\t\t.setLockOptions(lockOptions)\n+  120: \t\t\t\t.setComment(hints.getString(HibernateHints.HINT_COMMENT))\n+  121: \t\t\t\t.build();\n+  122: \t}\n",
        "uniqueId": "b53728f7278c40ef41e22326f917ca5c718ce6e7_73_114_106_122_74_104",
        "moveFileExist": true,
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 21,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 13,
                "covered": 31
            },
            "BRANCH": {
                "missed": 3,
                "covered": 3
            },
            "LINE": {
                "missed": 4,
                "covered": 11
            },
            "COMPLEXITY": {
                "missed": 3,
                "covered": 1
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        }
    },
    {
        "type": "Extract And Move Method",
        "description": "Extract And Move Method\tpublic getNamingStrategy(params Properties, serviceRegistry ServiceRegistry) : ImplicitDatabaseObjectNamingStrategy extracted from private determineImplicitName(catalog Identifier, schema Identifier, params Properties, serviceRegistry ServiceRegistry) : QualifiedName in class org.hibernate.id.enhanced.SequenceStyleGenerator & moved to class org.hibernate.id.IdentifierGeneratorHelper",
        "diffLocations": [
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/id/enhanced/SequenceStyleGenerator.java",
                "startLine": 353,
                "endLine": 385,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/id/enhanced/SequenceStyleGenerator.java",
                "startLine": 335,
                "endLine": 353,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/id/enhanced/SequenceStyleGenerator.java",
                "startLine": 638,
                "endLine": 661,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "private QualifiedName determineImplicitName(\n\t\t\tIdentifier catalog,\n\t\t\tIdentifier schema,\n\t\t\tProperties params,\n\t\t\tServiceRegistry serviceRegistry) {\n\t\tfinal StrategySelector strategySelector = serviceRegistry.requireService( StrategySelector.class );\n\n\t\tfinal String namingStrategySetting = coalesceSuppliedValues(\n\t\t\t\t() -> {\n\t\t\t\t\tfinal String localSetting = getString( ID_DB_STRUCTURE_NAMING_STRATEGY, params );\n\t\t\t\t\tif ( localSetting != null ) {\n\t\t\t\t\t\tINCUBATION_LOGGER.incubatingSetting( ID_DB_STRUCTURE_NAMING_STRATEGY );\n\t\t\t\t\t}\n\t\t\t\t\treturn localSetting;\n\t\t\t\t},\n\t\t\t\t() -> {\n\t\t\t\t\tfinal ConfigurationService configurationService = serviceRegistry.requireService( ConfigurationService.class );\n\t\t\t\t\tfinal String globalSetting = getString( ID_DB_STRUCTURE_NAMING_STRATEGY, configurationService.getSettings() );\n\t\t\t\t\tif ( globalSetting != null ) {\n\t\t\t\t\t\tINCUBATION_LOGGER.incubatingSetting( ID_DB_STRUCTURE_NAMING_STRATEGY );\n\t\t\t\t\t}\n\t\t\t\t\treturn globalSetting;\n\t\t\t\t},\n\t\t\t\tStandardNamingStrategy.class::getName\n\t\t);\n\n\t\tfinal ImplicitDatabaseObjectNamingStrategy namingStrategy = strategySelector.resolveStrategy(\n\t\t\t\tImplicitDatabaseObjectNamingStrategy.class,\n\t\t\t\tnamingStrategySetting\n\t\t);\n\n\t\treturn namingStrategy.determineSequenceName( catalog, schema, params, serviceRegistry );\n\t}",
        "filePathBefore": "hibernate-core/src/main/java/org/hibernate/id/enhanced/SequenceStyleGenerator.java",
        "isPureRefactoring": true,
        "commitId": "5dcbdf64f11dfdcf25fd5a4a571f978b5ade2a8e",
        "packageNameBefore": "org.hibernate.id.enhanced",
        "classNameBefore": "org.hibernate.id.enhanced.SequenceStyleGenerator",
        "methodNameBefore": "org.hibernate.id.enhanced.SequenceStyleGenerator#determineImplicitName",
        "invokedMethod": "methodSignature: org.hibernate.id.enhanced.SequenceStyleGenerator#determineSequenceName\n methodBody: protected QualifiedName determineSequenceName(\n\t\t\tProperties params,\n\t\t\tDialect dialect,\n\t\t\tJdbcEnvironment jdbcEnv,\n\t\t\tServiceRegistry serviceRegistry) {\nfinal IdentifierHelper identifierHelper=jdbcEnv.getIdentifierHelper();\nfinal Identifier catalog=identifierHelper.toIdentifier(getString(CATALOG,params));\nfinal Identifier schema=identifierHelper.toIdentifier(getString(SCHEMA,params));\nfinal String sequenceName=getString(SEQUENCE_PARAM,params,() -> getString(ALT_SEQUENCE_PARAM,params));\nif(StringHelper.isNotEmpty(sequenceName)){if(sequenceName.contains(\".\")){return QualifiedNameParser.INSTANCE.parse(sequenceName);\n}{return new QualifiedNameParser.NameParts(catalog,schema,identifierHelper.toIdentifier(sequenceName));\n}}return determineImplicitName(catalog,schema,params,serviceRegistry);\n}",
        "classSignatureBefore": "public class SequenceStyleGenerator\n\t\timplements PersistentIdentifierGenerator, BulkInsertionCapableIdentifierGenerator ",
        "methodNameBeforeSet": [
            "org.hibernate.id.enhanced.SequenceStyleGenerator#determineImplicitName"
        ],
        "classNameBeforeSet": [
            "org.hibernate.id.enhanced.SequenceStyleGenerator"
        ],
        "classSignatureBeforeSet": [
            "public class SequenceStyleGenerator\n\t\timplements PersistentIdentifierGenerator, BulkInsertionCapableIdentifierGenerator "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.\n */\npackage org.hibernate.id.enhanced;\n\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.Objects;\nimport java.util.Properties;\nimport java.util.Set;\n\nimport org.hibernate.HibernateException;\nimport org.hibernate.MappingException;\nimport org.hibernate.boot.model.naming.Identifier;\nimport org.hibernate.boot.model.relational.Database;\nimport org.hibernate.boot.model.relational.QualifiedName;\nimport org.hibernate.boot.model.relational.QualifiedNameParser;\nimport org.hibernate.boot.model.relational.QualifiedSequenceName;\nimport org.hibernate.boot.model.relational.SqlStringGenerationContext;\nimport org.hibernate.boot.registry.selector.spi.StrategySelector;\nimport org.hibernate.cfg.AvailableSettings;\nimport org.hibernate.dialect.Dialect;\nimport org.hibernate.engine.config.spi.ConfigurationService;\nimport org.hibernate.engine.jdbc.env.spi.IdentifierHelper;\nimport org.hibernate.engine.jdbc.env.spi.JdbcEnvironment;\nimport org.hibernate.engine.spi.SharedSessionContractImplementor;\nimport org.hibernate.id.BulkInsertionCapableIdentifierGenerator;\nimport org.hibernate.id.IdentifierGenerator;\nimport org.hibernate.id.PersistentIdentifierGenerator;\nimport org.hibernate.id.SequenceMismatchStrategy;\nimport org.hibernate.internal.CoreMessageLogger;\nimport org.hibernate.internal.util.StringHelper;\nimport org.hibernate.service.ServiceRegistry;\nimport org.hibernate.tool.schema.Action;\nimport org.hibernate.tool.schema.extract.spi.SequenceInformation;\nimport org.hibernate.tool.schema.spi.SchemaManagementToolCoordinator.ActionGrouping;\nimport org.hibernate.type.Type;\n\nimport org.jboss.logging.Logger;\n\nimport static org.hibernate.cfg.AvailableSettings.ID_DB_STRUCTURE_NAMING_STRATEGY;\nimport static org.hibernate.id.enhanced.OptimizerFactory.determineImplicitOptimizerName;\nimport static org.hibernate.internal.log.IncubationLogger.INCUBATION_LOGGER;\nimport static org.hibernate.internal.util.NullnessHelper.coalesceSuppliedValues;\nimport static org.hibernate.internal.util.config.ConfigurationHelper.getBoolean;\nimport static org.hibernate.internal.util.config.ConfigurationHelper.getInt;\nimport static org.hibernate.internal.util.config.ConfigurationHelper.getString;\n\n/**\n * Generates identifier values based on a sequence-style database structure.\n * Variations range from actually using a sequence to using a table to mimic\n * a sequence.  These variations are encapsulated by the {@link DatabaseStructure}\n * interface internally.\n * <p>\n * <table>\n * <caption>General configuration parameters</caption>\n * \t <tr>\n *     <td><b>Parameter name</b></td>\n *     <td><b>Default value</b></td>\n *     <td><b>Interpretation</b></td>\n *   </tr>\n *   <tr>\n *     <td>{@value #SEQUENCE_PARAM}</td>\n *     <td></td>\n *     <td>The name of the sequence/table to use to store/retrieve values</td>\n *   </tr>\n *   <tr>\n *     <td>{@value #INITIAL_PARAM}</td>\n *     <td>{@value #DEFAULT_INITIAL_VALUE}</td>\n *     <td>The initial value to be stored for the given segment;\n *         the effect in terms of storage varies based on {@link Optimizer}\n *         and {@link DatabaseStructure}</td>\n *   </tr>\n *   <tr>\n *     <td>{@value #INCREMENT_PARAM}</td>\n *     <td>{@value #DEFAULT_INCREMENT_SIZE}</td>\n *     <td>The increment size for the underlying segment;\n *         the effect in terms of storage varies based on {@link Optimizer}\n *         and {@link DatabaseStructure}</td>\n *   </tr>\n *   <tr>\n *     <td>{@value #OPT_PARAM}</td>\n *     <td><em>depends on defined increment size</em></td>\n *     <td>Allows explicit definition of which optimization strategy to use</td>\n *   </tr>\n *   <tr>\n *     <td>{@value #FORCE_TBL_PARAM}</td>\n *     <td>{@code false}</td>\n *     <td>Allows explicit definition of which optimization strategy to use</td>\n *   </tr>\n * </table>\n * <p>\n * Configuration parameters used specifically when the underlying structure is a table:\n * <table>\n * <caption>Table configuration parameters</caption>\n * \t <tr>\n *     <td><b>Parameter name</b></td>\n *     <td><b>Default value</b></td>\n *     <td><b>Interpretation</b></td>\n *   </tr>\n *   <tr>\n *     <td>{@value #VALUE_COLUMN_PARAM}</td>\n *     <td>{@value #DEF_VALUE_COLUMN}</td>\n *     <td>The name of column which holds the sequence value for the given segment</td>\n *   </tr>\n * </table>\n *\n * @author Steve Ebersole\n * @author Lukasz Antoniak\n */\npublic class SequenceStyleGenerator\n\t\timplements PersistentIdentifierGenerator, BulkInsertionCapableIdentifierGenerator {\n\n\tprivate static final CoreMessageLogger LOG = Logger.getMessageLogger(\n\t\t\tCoreMessageLogger.class,\n\t\t\tSequenceStyleGenerator.class.getName()\n\t);\n\n\n\t// general purpose parameters ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n\t/**\n\t * Indicates the name of the sequence (or table) to use.  The implicit value is\n\t * based on the entity / collection-role name\n\t */\n\tpublic static final String SEQUENCE_PARAM = \"sequence_name\";\n\tpublic static final String ALT_SEQUENCE_PARAM = \"sequence\";\n\n\t/**\n\t * Specifies the suffix to use for an implicit sequence name - appended to the entity-name / collection-role\n\t */\n\tpublic static final String CONFIG_SEQUENCE_PER_ENTITY_SUFFIX = \"sequence_per_entity_suffix\";\n\n\t/**\n\t * The default value for {@link #CONFIG_SEQUENCE_PER_ENTITY_SUFFIX}\n\t */\n\tpublic static final String DEF_SEQUENCE_SUFFIX = \"_SEQ\";\n\n\t/**\n\t * A flag to force using a table as the underlying structure rather than a sequence.\n\t */\n\tpublic static final String FORCE_TBL_PARAM = \"force_table_use\";\n\n\n\t// table-specific parameters ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n\t/**\n\t * Indicates the name of the column holding the identifier values.\n\t * The default value is {@value #DEF_VALUE_COLUMN}\n\t */\n\tpublic static final String VALUE_COLUMN_PARAM = \"value_column\";\n\n\t/**\n\t * The default value for {@link #VALUE_COLUMN_PARAM}\n\t */\n\tpublic static final String DEF_VALUE_COLUMN = \"next_val\";\n\n\n\t// state ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\tprivate DatabaseStructure databaseStructure;\n\tprivate Optimizer optimizer;\n\tprivate Type identifierType;\n\tprivate String options;\n\n\t/**\n\t * Getter for property 'databaseStructure'.\n\t *\n\t * @return Value for property 'databaseStructure'.\n\t */\n\tpublic DatabaseStructure getDatabaseStructure() {\n\t\treturn databaseStructure;\n\t}\n\n\t/**\n\t * Getter for property 'optimizer'.\n\t *\n\t * @return Value for property 'optimizer'.\n\t */\n\t@Override\n\tpublic Optimizer getOptimizer() {\n\t\treturn optimizer;\n\t}\n\n\t/**\n\t * Getter for property 'identifierType'.\n\t *\n\t * @return Value for property 'identifierType'.\n\t */\n\tpublic Type getIdentifierType() {\n\t\treturn identifierType;\n\t}\n\n\n\t// Configurable implementation ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n\t@Override\n\tpublic void configure(Type type, Properties parameters, ServiceRegistry serviceRegistry) throws MappingException {\n\t\tfinal JdbcEnvironment jdbcEnvironment = serviceRegistry.requireService( JdbcEnvironment.class );\n\t\tfinal Dialect dialect = jdbcEnvironment.getDialect();\n\n\t\tthis.identifierType = type;\n\n\t\tfinal QualifiedName sequenceName = determineSequenceName( parameters, dialect, jdbcEnvironment, serviceRegistry );\n\t\tfinal int initialValue = determineInitialValue( parameters );\n\t\tint incrementSize = determineIncrementSize( parameters );\n\t\tfinal OptimizerDescriptor optimizationStrategy = determineOptimizationStrategy( parameters, incrementSize );\n\n\t\tboolean forceTableUse = getBoolean( FORCE_TBL_PARAM, parameters );\n\t\tfinal boolean physicalSequence = isPhysicalSequence( jdbcEnvironment, forceTableUse );\n\n\t\tincrementSize = adjustIncrementSize(\n\t\t\t\tjdbcEnvironment,\n\t\t\t\tsequenceName,\n\t\t\t\tincrementSize,\n\t\t\t\tphysicalSequence,\n\t\t\t\toptimizationStrategy,\n\t\t\t\tserviceRegistry,\n\t\t\t\tdetermineContributor( parameters )\n\t\t);\n\n\t\tif ( physicalSequence\n\t\t\t\t&& optimizationStrategy.isPooled()\n\t\t\t\t&& !dialect.getSequenceSupport().supportsPooledSequences() ) {\n\t\t\tforceTableUse = true;\n\t\t\tLOG.forcingTableUse();\n\t\t}\n\n\t\tthis.databaseStructure = buildDatabaseStructure(\n\t\t\t\ttype,\n\t\t\t\tparameters,\n\t\t\t\tjdbcEnvironment,\n\t\t\t\tforceTableUse,\n\t\t\t\tsequenceName,\n\t\t\t\tinitialValue,\n\t\t\t\tincrementSize\n\t\t);\n\t\tthis.optimizer = OptimizerFactory.buildOptimizer(\n\t\t\t\toptimizationStrategy,\n\t\t\t\tidentifierType.getReturnedClass(),\n\t\t\t\tincrementSize,\n\t\t\t\tgetInt( INITIAL_PARAM, parameters, -1 )\n\t\t);\n\t\tthis.databaseStructure.configure( optimizer );\n\n\t\tthis.options = parameters.getProperty( OPTIONS );\n\t}\n\n\tprivate int adjustIncrementSize(\n\t\t\tJdbcEnvironment jdbcEnvironment,\n\t\t\tQualifiedName sequenceName,\n\t\t\tint incrementSize,\n\t\t\tboolean physicalSequence,\n\t\t\tOptimizerDescriptor optimizationStrategy,\n\t\t\tServiceRegistry serviceRegistry,\n\t\t\tString contributor) {\n\t\tfinal ConfigurationService configurationService = serviceRegistry.requireService( ConfigurationService.class );\n\t\tfinal SequenceMismatchStrategy sequenceMismatchStrategy = configurationService.getSetting(\n\t\t\t\tAvailableSettings.SEQUENCE_INCREMENT_SIZE_MISMATCH_STRATEGY,\n\t\t\t\tSequenceMismatchStrategy::interpret,\n\t\t\t\tSequenceMismatchStrategy.EXCEPTION\n\t\t);\n\n\t\tif ( sequenceMismatchStrategy != SequenceMismatchStrategy.NONE\n\t\t\t\t&& optimizationStrategy.isPooled()\n\t\t\t\t&& physicalSequence ) {\n\t\t\tfinal String databaseSequenceName = sequenceName.getObjectName().getText();\n\t\t\tfinal Number databaseIncrementValue = isSchemaToBeRecreated( contributor, configurationService ) ? null : getSequenceIncrementValue( jdbcEnvironment, databaseSequenceName );\n\t\t\tif ( databaseIncrementValue != null && databaseIncrementValue.intValue() != incrementSize) {\n\t\t\t\tfinal int dbIncrementValue = databaseIncrementValue.intValue();\n\t\t\t\tswitch ( sequenceMismatchStrategy ) {\n\t\t\t\t\tcase EXCEPTION:\n\t\t\t\t\t\tthrow new MappingException(\n\t\t\t\t\t\t\t\tString.format(\n\t\t\t\t\t\t\t\t\t\t\"The increment size of the [%s] sequence is set to [%d] in the entity mapping \"\n\t\t\t\t\t\t\t\t\t\t\t\t+ \"while the associated database sequence increment size is [%d].\",\n\t\t\t\t\t\t\t\t\t\tdatabaseSequenceName, incrementSize, dbIncrementValue\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t);\n\t\t\t\t\tcase FIX:\n\t\t\t\t\t\tincrementSize = dbIncrementValue;\n\t\t\t\t\tcase LOG:\n\t\t\t\t\t\t//TODO: the log message is correct for the case of FIX, but wrong for LOG\n\t\t\t\t\t\tLOG.sequenceIncrementSizeMismatch( databaseSequenceName, incrementSize, dbIncrementValue );\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn determineAdjustedIncrementSize( optimizationStrategy, incrementSize );\n\t}\n\n\tprivate boolean isSchemaToBeRecreated(String contributor, ConfigurationService configurationService) {\n\t\tfinal Set<ActionGrouping> actions = ActionGrouping.interpret( Collections.singleton(contributor), configurationService.getSettings() );\n\t\t// We know this will only contain at most 1 action\n\t\tfinal Iterator<ActionGrouping> it = actions.iterator();\n\t\tfinal Action dbAction = it.hasNext() ? it.next().getDatabaseAction() : null;\n\t\treturn dbAction == Action.CREATE || dbAction == Action.CREATE_DROP;\n\t}\n\n\t@Override\n\tpublic void registerExportables(Database database) {\n\t\tdatabaseStructure.registerExportables( database );\n\t}\n\n\t@Override\n\tpublic void initialize(SqlStringGenerationContext context) {\n\t\tthis.databaseStructure.initialize( context );\n\t}\n\n\t/**\n\t * Determine the name of the sequence (or table if this resolves to a physical table)\n\t * to use.\n\t * <p>\n\t * Called during {@linkplain #configure configuration}.\n\t *\n\t * @param params The params supplied in the generator config (plus some standard useful extras).\n\t * @param dialect The dialect in effect\n\t * @param jdbcEnv The JdbcEnvironment\n\t * @return The sequence name\n\t */\n\t@SuppressWarnings(\"UnusedParameters\")\n\tprotected QualifiedName determineSequenceName(\n\t\t\tProperties params,\n\t\t\tDialect dialect,\n\t\t\tJdbcEnvironment jdbcEnv,\n\t\t\tServiceRegistry serviceRegistry) {\n\t\tfinal IdentifierHelper identifierHelper = jdbcEnv.getIdentifierHelper();\n\n\t\tfinal Identifier catalog = identifierHelper.toIdentifier( getString( CATALOG, params ) );\n\t\tfinal Identifier schema =  identifierHelper.toIdentifier( getString( SCHEMA, params ) );\n\n\t\tfinal String sequenceName = getString( SEQUENCE_PARAM, params, () -> getString( ALT_SEQUENCE_PARAM, params ) );\n\t\tif ( StringHelper.isNotEmpty( sequenceName ) ) {\n\t\t\t// we have an explicit name, use it\n\t\t\tif ( sequenceName.contains( \".\" ) ) {\n\t\t\t\treturn QualifiedNameParser.INSTANCE.parse( sequenceName );\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn new QualifiedNameParser.NameParts(\n\t\t\t\t\t\tcatalog,\n\t\t\t\t\t\tschema,\n\t\t\t\t\t\tidentifierHelper.toIdentifier( sequenceName )\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\t// otherwise, determine an implicit name to use\n\t\treturn determineImplicitName( catalog, schema, params, serviceRegistry );\n\t}\n\n\tprivate QualifiedName determineImplicitName(\n\t\t\tIdentifier catalog,\n\t\t\tIdentifier schema,\n\t\t\tProperties params,\n\t\t\tServiceRegistry serviceRegistry) {\n\t\tfinal StrategySelector strategySelector = serviceRegistry.requireService( StrategySelector.class );\n\n\t\tfinal String namingStrategySetting = coalesceSuppliedValues(\n\t\t\t\t() -> {\n\t\t\t\t\tfinal String localSetting = getString( ID_DB_STRUCTURE_NAMING_STRATEGY, params );\n\t\t\t\t\tif ( localSetting != null ) {\n\t\t\t\t\t\tINCUBATION_LOGGER.incubatingSetting( ID_DB_STRUCTURE_NAMING_STRATEGY );\n\t\t\t\t\t}\n\t\t\t\t\treturn localSetting;\n\t\t\t\t},\n\t\t\t\t() -> {\n\t\t\t\t\tfinal ConfigurationService configurationService = serviceRegistry.requireService( ConfigurationService.class );\n\t\t\t\t\tfinal String globalSetting = getString( ID_DB_STRUCTURE_NAMING_STRATEGY, configurationService.getSettings() );\n\t\t\t\t\tif ( globalSetting != null ) {\n\t\t\t\t\t\tINCUBATION_LOGGER.incubatingSetting( ID_DB_STRUCTURE_NAMING_STRATEGY );\n\t\t\t\t\t}\n\t\t\t\t\treturn globalSetting;\n\t\t\t\t},\n\t\t\t\tStandardNamingStrategy.class::getName\n\t\t);\n\n\t\tfinal ImplicitDatabaseObjectNamingStrategy namingStrategy = strategySelector.resolveStrategy(\n\t\t\t\tImplicitDatabaseObjectNamingStrategy.class,\n\t\t\t\tnamingStrategySetting\n\t\t);\n\n\t\treturn namingStrategy.determineSequenceName( catalog, schema, params, serviceRegistry );\n\t}\n\n\t/**\n\t * Determine the name of the column used to store the generator value in\n\t * the db.\n\t * <p>\n\t * Called during {@linkplain #configure configuration} <b>when resolving to a\n\t * physical table</b>.\n\t *\n\t * @param params The params supplied in the generator config (plus some standard useful extras).\n\t * @param jdbcEnvironment The JDBC environment\n\t * @return The value column name\n\t */\n\tprotected Identifier determineValueColumnName(Properties params, JdbcEnvironment jdbcEnvironment) {\n\t\tfinal String name = getString( VALUE_COLUMN_PARAM, params, DEF_VALUE_COLUMN );\n\t\treturn jdbcEnvironment.getIdentifierHelper().toIdentifier( name );\n\t}\n\n\t/**\n\t * Determine the initial sequence value to use.  This value is used when\n\t * initializing the {@link #getDatabaseStructure() database structure}\n\t * (i.e. sequence/table).\n\t * <p>\n\t * Called during {@linkplain #configure configuration}.\n\t *\n\t * @param params The params supplied in the generator config (plus some standard useful extras).\n\t * @return The initial value\n\t */\n\tprotected int determineInitialValue(Properties params) {\n\t\treturn getInt( INITIAL_PARAM, params, DEFAULT_INITIAL_VALUE );\n\t}\n\n\t/**\n\t * Determine the increment size to be applied.  The exact implications of\n\t * this value depends on the {@linkplain #getOptimizer() optimizer} being used.\n\t * <p>\n\t * Called during {@linkplain #configure configuration}.\n\t *\n\t * @param params The params supplied in the generator config (plus some standard useful extras).\n\t * @return The increment size\n\t */\n\tprotected int determineIncrementSize(Properties params) {\n\t\treturn getInt( INCREMENT_PARAM, params, DEFAULT_INCREMENT_SIZE );\n\t}\n\n\t/**\n\t * Determine the optimizer to use.\n\t * <p>\n\t * Called during {@linkplain #configure configuration}.\n\t *\n\t * @param params        The params supplied in the generator config (plus some standard useful extras).\n\t * @param incrementSize The {@link #determineIncrementSize determined increment size}\n\t * @return The optimizer strategy (name)\n\t */\n\tprotected OptimizerDescriptor determineOptimizationStrategy(Properties params, int incrementSize) {\n\t\treturn StandardOptimizerDescriptor.fromExternalName(\n\t\t\t\tgetString( OPT_PARAM, params, determineImplicitOptimizerName( incrementSize, params ) )\n\t\t);\n\t}\n\n\t/**\n\t * In certain cases we need to adjust the increment size based on the\n\t * selected optimizer.  This is the hook to achieve that.\n\t *\n\t * @param optimizationStrategy The optimizer strategy (name)\n\t * @param incrementSize The {@link #determineIncrementSize determined increment size}\n\t * @return The adjusted increment size.\n\t */\n\tprotected int determineAdjustedIncrementSize(OptimizerDescriptor optimizationStrategy, int incrementSize) {\n\t\tif ( optimizationStrategy == StandardOptimizerDescriptor.NONE  ) {\n\t\t\tif ( incrementSize < -1 ) {\n\t\t\t\tLOG.honoringOptimizerSetting(\n\t\t\t\t\t\tStandardOptimizerDescriptor.NONE.getExternalName(),\n\t\t\t\t\t\tINCREMENT_PARAM,\n\t\t\t\t\t\tincrementSize,\n\t\t\t\t\t\t\"negative\",\n\t\t\t\t\t\t-1\n\t\t\t\t);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\telse if ( incrementSize > 1 ) {\n\t\t\t\tLOG.honoringOptimizerSetting(\n\t\t\t\t\t\tStandardOptimizerDescriptor.NONE.getExternalName(),\n\t\t\t\t\t\tINCREMENT_PARAM,\n\t\t\t\t\t\tincrementSize,\n\t\t\t\t\t\t\"positive\",\n\t\t\t\t\t\t1\n\t\t\t\t);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn incrementSize;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\treturn incrementSize;\n\t\t}\n\t}\n\n\t/**\n\t * Build the database structure.\n\t *\n\t * @param type The Hibernate type of the identifier property\n\t * @param params The params supplied in the generator config (plus some standard useful extras).\n\t * @param jdbcEnvironment The JDBC environment in which the sequence will be used.\n\t * @param forceTableUse Should a table be used even if the dialect supports sequences?\n\t * @param sequenceName The name to use for the sequence or table.\n\t * @param initialValue The initial value.\n\t * @param incrementSize the increment size to use (after any adjustments).\n\t *\n\t * @return An abstraction for the actual database structure in use (table vs. sequence).\n\t */\n\tprotected DatabaseStructure buildDatabaseStructure(\n\t\t\tType type,\n\t\t\tProperties params,\n\t\t\tJdbcEnvironment jdbcEnvironment,\n\t\t\tboolean forceTableUse,\n\t\t\tQualifiedName sequenceName,\n\t\t\tint initialValue,\n\t\t\tint incrementSize) {\n\t\tif ( isPhysicalSequence( jdbcEnvironment, forceTableUse ) ) {\n\t\t\treturn buildSequenceStructure( type, params, jdbcEnvironment, sequenceName, initialValue, incrementSize );\n\t\t}\n\t\telse {\n\t\t\treturn buildTableStructure( type, params, jdbcEnvironment, sequenceName, initialValue, incrementSize );\n\t\t}\n\t}\n\n\tprotected boolean isPhysicalSequence(JdbcEnvironment jdbcEnvironment, boolean forceTableUse) {\n\t\treturn jdbcEnvironment.getDialect().getSequenceSupport().supportsSequences()\n\t\t\t&& !forceTableUse;\n\t}\n\n\tprotected DatabaseStructure buildSequenceStructure(\n\t\t\tType type,\n\t\t\tProperties params,\n\t\t\tJdbcEnvironment jdbcEnvironment,\n\t\t\tQualifiedName sequenceName,\n\t\t\tint initialValue,\n\t\t\tint incrementSize) {\n\t\treturn new SequenceStructure(\n\t\t\t\tjdbcEnvironment,\n\t\t\t\tdetermineContributor( params ),\n\t\t\t\tsequenceName,\n\t\t\t\tinitialValue,\n\t\t\t\tincrementSize,\n\t\t\t\tparams.getProperty( OPTIONS ),\n\t\t\t\ttype.getReturnedClass()\n\t\t);\n\t}\n\n\tprotected DatabaseStructure buildTableStructure(\n\t\t\tType type,\n\t\t\tProperties params,\n\t\t\tJdbcEnvironment jdbcEnvironment,\n\t\t\tQualifiedName sequenceName,\n\t\t\tint initialValue,\n\t\t\tint incrementSize) {\n\t\tfinal Identifier valueColumnName = determineValueColumnName( params, jdbcEnvironment );\n\t\tfinal String contributor = determineContributor( params );\n\n\t\treturn new TableStructure(\n\t\t\t\tjdbcEnvironment,\n\t\t\t\tcontributor,\n\t\t\t\tsequenceName,\n\t\t\t\tvalueColumnName,\n\t\t\t\tinitialValue,\n\t\t\t\tincrementSize,\n\t\t\t\tparams.getProperty( OPTIONS ),\n\t\t\t\ttype.getReturnedClass()\n\t\t);\n\t}\n\n\tprivate String determineContributor(Properties params) {\n\t\tfinal String contributor = params.getProperty( IdentifierGenerator.CONTRIBUTOR_NAME );\n\t\treturn contributor == null ? \"orm\" : contributor;\n\t}\n\n\n\t// IdentifierGenerator implementation ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n\t@Override\n\tpublic Object generate(SharedSessionContractImplementor session, Object object) throws HibernateException {\n\t\treturn optimizer.generate( databaseStructure.buildCallback( session ) );\n\t}\n\n\t// BulkInsertionCapableIdentifierGenerator implementation ~~~~~~~~~~~~~~~~~\n\n\t@Override\n\tpublic boolean supportsBulkInsertionIdentifierGeneration() {\n\t\t// it does, as long as the underlying structure is a sequence\n\t\treturn getDatabaseStructure().isPhysicalSequence();\n\t}\n\n\t@Override\n\tpublic String determineBulkInsertionIdentifierGenerationSelectFragment(SqlStringGenerationContext context) {\n\t\treturn context.getDialect().getSequenceSupport()\n\t\t\t\t.getSelectSequenceNextValString( context.format( getDatabaseStructure().getPhysicalName() ) );\n\t}\n\n\t/**\n\t * Get the database sequence increment value from the associated {@link SequenceInformation} object.\n\t *\n\t * @param jdbcEnvironment the current JdbcEnvironment\n\t * @param sequenceName sequence name\n\t *\n\t * @return sequence increment value\n\t */\n\tprivate Number getSequenceIncrementValue(JdbcEnvironment jdbcEnvironment, String sequenceName) {\n\t\treturn jdbcEnvironment.getExtractedDatabaseMetaData().getSequenceInformationList()\n\t\t\t\t.stream()\n\t\t\t\t.filter(\n\t\t\t\t\tsequenceInformation -> {\n\t\t\t\t\t\tQualifiedSequenceName name = sequenceInformation.getSequenceName();\n\t\t\t\t\t\tIdentifier catalog = name.getCatalogName();\n\t\t\t\t\t\tIdentifier schema = name.getSchemaName();\n\t\t\t\t\t\treturn sequenceName.equalsIgnoreCase( name.getSequenceName().getText() )\n\t\t\t\t\t\t\t&& ( catalog == null || catalog.equals( jdbcEnvironment.getCurrentCatalog() ) )\n\t\t\t\t\t\t\t&& ( schema == null || schema.equals( jdbcEnvironment.getCurrentSchema() ) );\n\t\t\t\t\t}\n\t\t\t\t)\n\t\t\t\t.map( SequenceInformation::getIncrementValue )\n\t\t\t\t.filter( Objects::nonNull )\n\t\t\t\t.findFirst()\n\t\t\t\t.orElse( null );\n\t}\n}\n",
        "filePathAfter": "hibernate-core/src/main/java/org/hibernate/id/enhanced/SequenceStyleGenerator.java",
        "sourceCodeAfterForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.\n */\npackage org.hibernate.id.enhanced;\n\nimport java.util.Iterator;\nimport java.util.Properties;\nimport java.util.Set;\n\nimport org.hibernate.HibernateException;\nimport org.hibernate.MappingException;\nimport org.hibernate.boot.model.naming.Identifier;\nimport org.hibernate.boot.model.relational.Database;\nimport org.hibernate.boot.model.relational.QualifiedName;\nimport org.hibernate.boot.model.relational.QualifiedNameParser;\nimport org.hibernate.boot.model.relational.QualifiedSequenceName;\nimport org.hibernate.boot.model.relational.SqlStringGenerationContext;\nimport org.hibernate.cfg.AvailableSettings;\nimport org.hibernate.dialect.Dialect;\nimport org.hibernate.engine.config.spi.ConfigurationService;\nimport org.hibernate.engine.jdbc.env.spi.IdentifierHelper;\nimport org.hibernate.engine.jdbc.env.spi.JdbcEnvironment;\nimport org.hibernate.engine.spi.SharedSessionContractImplementor;\nimport org.hibernate.id.BulkInsertionCapableIdentifierGenerator;\nimport org.hibernate.id.IdentifierGenerator;\nimport org.hibernate.id.PersistentIdentifierGenerator;\nimport org.hibernate.id.SequenceMismatchStrategy;\nimport org.hibernate.internal.CoreMessageLogger;\nimport org.hibernate.service.ServiceRegistry;\nimport org.hibernate.tool.schema.Action;\nimport org.hibernate.tool.schema.extract.spi.SequenceInformation;\nimport org.hibernate.tool.schema.spi.SchemaManagementToolCoordinator.ActionGrouping;\nimport org.hibernate.type.Type;\n\nimport org.jboss.logging.Logger;\n\nimport static java.util.Collections.singleton;\nimport static org.hibernate.id.IdentifierGeneratorHelper.getNamingStrategy;\nimport static org.hibernate.id.enhanced.OptimizerFactory.determineImplicitOptimizerName;\nimport static org.hibernate.internal.util.StringHelper.isNotEmpty;\nimport static org.hibernate.internal.util.config.ConfigurationHelper.getBoolean;\nimport static org.hibernate.internal.util.config.ConfigurationHelper.getInt;\nimport static org.hibernate.internal.util.config.ConfigurationHelper.getString;\n\n/**\n * Generates identifier values based on a sequence-style database structure.\n * Variations range from actually using a sequence to using a table to mimic\n * a sequence.  These variations are encapsulated by the {@link DatabaseStructure}\n * interface internally.\n * <p>\n * <table>\n * <caption>General configuration parameters</caption>\n * \t <tr>\n *     <td><b>Parameter name</b></td>\n *     <td><b>Default value</b></td>\n *     <td><b>Interpretation</b></td>\n *   </tr>\n *   <tr>\n *     <td>{@value #SEQUENCE_PARAM}</td>\n *     <td></td>\n *     <td>The name of the sequence/table to use to store/retrieve values</td>\n *   </tr>\n *   <tr>\n *     <td>{@value #INITIAL_PARAM}</td>\n *     <td>{@value #DEFAULT_INITIAL_VALUE}</td>\n *     <td>The initial value to be stored for the given segment;\n *         the effect in terms of storage varies based on {@link Optimizer}\n *         and {@link DatabaseStructure}</td>\n *   </tr>\n *   <tr>\n *     <td>{@value #INCREMENT_PARAM}</td>\n *     <td>{@value #DEFAULT_INCREMENT_SIZE}</td>\n *     <td>The increment size for the underlying segment;\n *         the effect in terms of storage varies based on {@link Optimizer}\n *         and {@link DatabaseStructure}</td>\n *   </tr>\n *   <tr>\n *     <td>{@value #OPT_PARAM}</td>\n *     <td><em>depends on defined increment size</em></td>\n *     <td>Allows explicit definition of which optimization strategy to use</td>\n *   </tr>\n *   <tr>\n *     <td>{@value #FORCE_TBL_PARAM}</td>\n *     <td>{@code false}</td>\n *     <td>Allows explicit definition of which optimization strategy to use</td>\n *   </tr>\n * </table>\n * <p>\n * Configuration parameters used specifically when the underlying structure is a table:\n * <table>\n * <caption>Table configuration parameters</caption>\n * \t <tr>\n *     <td><b>Parameter name</b></td>\n *     <td><b>Default value</b></td>\n *     <td><b>Interpretation</b></td>\n *   </tr>\n *   <tr>\n *     <td>{@value #VALUE_COLUMN_PARAM}</td>\n *     <td>{@value #DEF_VALUE_COLUMN}</td>\n *     <td>The name of column which holds the sequence value for the given segment</td>\n *   </tr>\n * </table>\n *\n * @author Steve Ebersole\n * @author Lukasz Antoniak\n */\npublic class SequenceStyleGenerator\n\t\timplements PersistentIdentifierGenerator, BulkInsertionCapableIdentifierGenerator {\n\n\tprivate static final CoreMessageLogger LOG = Logger.getMessageLogger(\n\t\t\tCoreMessageLogger.class,\n\t\t\tSequenceStyleGenerator.class.getName()\n\t);\n\n\n\t// general purpose parameters ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n\t/**\n\t * Indicates the name of the sequence (or table) to use.  The implicit value is\n\t * based on the entity / collection-role name\n\t */\n\tpublic static final String SEQUENCE_PARAM = \"sequence_name\";\n\tpublic static final String ALT_SEQUENCE_PARAM = \"sequence\";\n\n\t/**\n\t * Specifies the suffix to use for an implicit sequence name - appended to the entity-name / collection-role\n\t */\n\tpublic static final String CONFIG_SEQUENCE_PER_ENTITY_SUFFIX = \"sequence_per_entity_suffix\";\n\n\t/**\n\t * The default value for {@link #CONFIG_SEQUENCE_PER_ENTITY_SUFFIX}\n\t */\n\tpublic static final String DEF_SEQUENCE_SUFFIX = \"_SEQ\";\n\n\t/**\n\t * A flag to force using a table as the underlying structure rather than a sequence.\n\t */\n\tpublic static final String FORCE_TBL_PARAM = \"force_table_use\";\n\n\n\t// table-specific parameters ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n\t/**\n\t * Indicates the name of the column holding the identifier values.\n\t * The default value is {@value #DEF_VALUE_COLUMN}\n\t */\n\tpublic static final String VALUE_COLUMN_PARAM = \"value_column\";\n\n\t/**\n\t * The default value for {@link #VALUE_COLUMN_PARAM}\n\t */\n\tpublic static final String DEF_VALUE_COLUMN = \"next_val\";\n\n\n\t// state ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\tprivate DatabaseStructure databaseStructure;\n\tprivate Optimizer optimizer;\n\tprivate Type identifierType;\n\tprivate String options;\n\n\t/**\n\t * Getter for property 'databaseStructure'.\n\t *\n\t * @return Value for property 'databaseStructure'.\n\t */\n\tpublic DatabaseStructure getDatabaseStructure() {\n\t\treturn databaseStructure;\n\t}\n\n\t/**\n\t * Getter for property 'optimizer'.\n\t *\n\t * @return Value for property 'optimizer'.\n\t */\n\t@Override\n\tpublic Optimizer getOptimizer() {\n\t\treturn optimizer;\n\t}\n\n\t/**\n\t * Getter for property 'identifierType'.\n\t *\n\t * @return Value for property 'identifierType'.\n\t */\n\tpublic Type getIdentifierType() {\n\t\treturn identifierType;\n\t}\n\n\n\t// Configurable implementation ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n\t@Override\n\tpublic void configure(Type type, Properties parameters, ServiceRegistry serviceRegistry) throws MappingException {\n\t\tfinal JdbcEnvironment jdbcEnvironment = serviceRegistry.requireService( JdbcEnvironment.class );\n\t\tfinal Dialect dialect = jdbcEnvironment.getDialect();\n\n\t\tidentifierType = type;\n\n\t\tfinal QualifiedName sequenceName = determineSequenceName( parameters, dialect, jdbcEnvironment, serviceRegistry );\n\t\tfinal int initialValue = determineInitialValue( parameters );\n\t\tint incrementSize = determineIncrementSize( parameters );\n\t\tfinal OptimizerDescriptor optimizationStrategy = determineOptimizationStrategy( parameters, incrementSize );\n\n\t\tboolean forceTableUse = getBoolean( FORCE_TBL_PARAM, parameters );\n\t\tfinal boolean physicalSequence = isPhysicalSequence( jdbcEnvironment, forceTableUse );\n\n\t\tincrementSize = adjustIncrementSize(\n\t\t\t\tjdbcEnvironment,\n\t\t\t\tsequenceName,\n\t\t\t\tincrementSize,\n\t\t\t\tphysicalSequence,\n\t\t\t\toptimizationStrategy,\n\t\t\t\tserviceRegistry,\n\t\t\t\tdetermineContributor( parameters )\n\t\t);\n\n\t\tif ( physicalSequence\n\t\t\t\t&& optimizationStrategy.isPooled()\n\t\t\t\t&& !dialect.getSequenceSupport().supportsPooledSequences() ) {\n\t\t\tforceTableUse = true;\n\t\t\tLOG.forcingTableUse();\n\t\t}\n\n\t\tdatabaseStructure = buildDatabaseStructure(\n\t\t\t\ttype,\n\t\t\t\tparameters,\n\t\t\t\tjdbcEnvironment,\n\t\t\t\tforceTableUse,\n\t\t\t\tsequenceName,\n\t\t\t\tinitialValue,\n\t\t\t\tincrementSize\n\t\t);\n\t\toptimizer = OptimizerFactory.buildOptimizer(\n\t\t\t\toptimizationStrategy,\n\t\t\t\tidentifierType.getReturnedClass(),\n\t\t\t\tincrementSize,\n\t\t\t\tgetInt( INITIAL_PARAM, parameters, -1 )\n\t\t);\n\t\tdatabaseStructure.configure( optimizer );\n\n\t\toptions = parameters.getProperty( OPTIONS );\n\t}\n\n\tprivate int adjustIncrementSize(\n\t\t\tJdbcEnvironment jdbcEnvironment,\n\t\t\tQualifiedName sequenceName,\n\t\t\tint incrementSize,\n\t\t\tboolean physicalSequence,\n\t\t\tOptimizerDescriptor optimizationStrategy,\n\t\t\tServiceRegistry serviceRegistry,\n\t\t\tString contributor) {\n\t\tfinal ConfigurationService configurationService = serviceRegistry.requireService( ConfigurationService.class );\n\t\tfinal SequenceMismatchStrategy sequenceMismatchStrategy = configurationService.getSetting(\n\t\t\t\tAvailableSettings.SEQUENCE_INCREMENT_SIZE_MISMATCH_STRATEGY,\n\t\t\t\tSequenceMismatchStrategy::interpret,\n\t\t\t\tSequenceMismatchStrategy.EXCEPTION\n\t\t);\n\n\t\tif ( sequenceMismatchStrategy != SequenceMismatchStrategy.NONE\n\t\t\t\t&& optimizationStrategy.isPooled()\n\t\t\t\t&& physicalSequence ) {\n\t\t\tfinal String databaseSequenceName = sequenceName.getObjectName().getText();\n\t\t\tfinal Number databaseIncrementValue =\n\t\t\t\t\tisSchemaToBeRecreated( contributor, configurationService ) ? null\n\t\t\t\t\t\t\t: getSequenceIncrementValue( jdbcEnvironment, databaseSequenceName );\n\t\t\tif ( databaseIncrementValue != null && databaseIncrementValue.intValue() != incrementSize) {\n\t\t\t\tfinal int dbIncrementValue = databaseIncrementValue.intValue();\n\t\t\t\tswitch ( sequenceMismatchStrategy ) {\n\t\t\t\t\tcase EXCEPTION:\n\t\t\t\t\t\tthrow new MappingException(\n\t\t\t\t\t\t\t\tString.format(\n\t\t\t\t\t\t\t\t\t\t\"The increment size of the [%s] sequence is set to [%d] in the entity mapping \"\n\t\t\t\t\t\t\t\t\t\t\t\t+ \"while the associated database sequence increment size is [%d].\",\n\t\t\t\t\t\t\t\t\t\tdatabaseSequenceName, incrementSize, dbIncrementValue\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t);\n\t\t\t\t\tcase FIX:\n\t\t\t\t\t\tincrementSize = dbIncrementValue;\n\t\t\t\t\tcase LOG:\n\t\t\t\t\t\t//TODO: the log message is correct for the case of FIX, but wrong for LOG\n\t\t\t\t\t\tLOG.sequenceIncrementSizeMismatch( databaseSequenceName, incrementSize, dbIncrementValue );\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn determineAdjustedIncrementSize( optimizationStrategy, incrementSize );\n\t}\n\n\tprivate boolean isSchemaToBeRecreated(String contributor, ConfigurationService configurationService) {\n\t\tfinal Set<ActionGrouping> actions =\n\t\t\t\tActionGrouping.interpret( singleton( contributor ), configurationService.getSettings() );\n\t\t// We know this will only contain at most 1 action\n\t\tfinal Iterator<ActionGrouping> it = actions.iterator();\n\t\tfinal Action dbAction = it.hasNext() ? it.next().getDatabaseAction() : null;\n\t\treturn dbAction == Action.CREATE || dbAction == Action.CREATE_DROP;\n\t}\n\n\t@Override\n\tpublic void registerExportables(Database database) {\n\t\tdatabaseStructure.registerExportables( database );\n\t}\n\n\t@Override\n\tpublic void initialize(SqlStringGenerationContext context) {\n\t\tdatabaseStructure.initialize( context );\n\t}\n\n\t/**\n\t * Determine the name of the sequence (or table if this resolves to a physical table)\n\t * to use.\n\t * <p>\n\t * Called during {@linkplain #configure configuration}.\n\t *\n\t * @param params The params supplied in the generator config (plus some standard useful extras).\n\t * @param dialect The dialect in effect\n\t * @param jdbcEnv The JdbcEnvironment\n\t * @return The sequence name\n\t */\n\t@SuppressWarnings(\"UnusedParameters\")\n\tprotected QualifiedName determineSequenceName(\n\t\t\tProperties params,\n\t\t\tDialect dialect,\n\t\t\tJdbcEnvironment jdbcEnv,\n\t\t\tServiceRegistry serviceRegistry) {\n\t\tfinal IdentifierHelper identifierHelper = jdbcEnv.getIdentifierHelper();\n\t\tfinal Identifier catalog = identifierHelper.toIdentifier( getString( CATALOG, params ) );\n\t\tfinal Identifier schema =  identifierHelper.toIdentifier( getString( SCHEMA, params ) );\n\t\tfinal String sequenceName = getString( SEQUENCE_PARAM, params, () -> getString( ALT_SEQUENCE_PARAM, params ) );\n\t\treturn sequenceName( params, serviceRegistry, sequenceName, catalog, schema, identifierHelper );\n\t}\n\n\tprivate static QualifiedName sequenceName(\n\t\t\tProperties params,\n\t\t\tServiceRegistry serviceRegistry,\n\t\t\tString explicitSequenceName,\n\t\t\tIdentifier catalog, Identifier schema,\n\t\t\tIdentifierHelper identifierHelper) {\n\t\tif ( isNotEmpty( explicitSequenceName ) ) {\n\t\t\t// we have an explicit name, use it\n\t\t\treturn explicitSequenceName.contains(\".\")\n\t\t\t\t\t? QualifiedNameParser.INSTANCE.parse( explicitSequenceName )\n\t\t\t\t\t: new QualifiedNameParser.NameParts( catalog, schema,\n\t\t\t\t\t\t\tidentifierHelper.toIdentifier( explicitSequenceName ) );\n\t\t}\n\t\telse {\n\t\t\t// otherwise, determine an implicit name to use\n\t\t\treturn getNamingStrategy( params, serviceRegistry )\n\t\t\t\t\t.determineSequenceName( catalog, schema, params, serviceRegistry );\n\t\t}\n\t}\n\n\n\t/**\n\t * Determine the name of the column used to store the generator value in\n\t * the db.\n\t * <p>\n\t * Called during {@linkplain #configure configuration} <b>when resolving to a\n\t * physical table</b>.\n\t *\n\t * @param params The params supplied in the generator config (plus some standard useful extras).\n\t * @param jdbcEnvironment The JDBC environment\n\t * @return The value column name\n\t */\n\tprotected Identifier determineValueColumnName(Properties params, JdbcEnvironment jdbcEnvironment) {\n\t\tfinal String name = getString( VALUE_COLUMN_PARAM, params, DEF_VALUE_COLUMN );\n\t\treturn jdbcEnvironment.getIdentifierHelper().toIdentifier( name );\n\t}\n\n\t/**\n\t * Determine the initial sequence value to use.  This value is used when\n\t * initializing the {@link #getDatabaseStructure() database structure}\n\t * (i.e. sequence/table).\n\t * <p>\n\t * Called during {@linkplain #configure configuration}.\n\t *\n\t * @param params The params supplied in the generator config (plus some standard useful extras).\n\t * @return The initial value\n\t */\n\tprotected int determineInitialValue(Properties params) {\n\t\treturn getInt( INITIAL_PARAM, params, DEFAULT_INITIAL_VALUE );\n\t}\n\n\t/**\n\t * Determine the increment size to be applied.  The exact implications of\n\t * this value depends on the {@linkplain #getOptimizer() optimizer} being used.\n\t * <p>\n\t * Called during {@linkplain #configure configuration}.\n\t *\n\t * @param params The params supplied in the generator config (plus some standard useful extras).\n\t * @return The increment size\n\t */\n\tprotected int determineIncrementSize(Properties params) {\n\t\treturn getInt( INCREMENT_PARAM, params, DEFAULT_INCREMENT_SIZE );\n\t}\n\n\t/**\n\t * Determine the optimizer to use.\n\t * <p>\n\t * Called during {@linkplain #configure configuration}.\n\t *\n\t * @param params        The params supplied in the generator config (plus some standard useful extras).\n\t * @param incrementSize The {@link #determineIncrementSize determined increment size}\n\t * @return The optimizer strategy (name)\n\t */\n\tprotected OptimizerDescriptor determineOptimizationStrategy(Properties params, int incrementSize) {\n\t\treturn StandardOptimizerDescriptor.fromExternalName(\n\t\t\t\tgetString( OPT_PARAM, params, determineImplicitOptimizerName( incrementSize, params ) )\n\t\t);\n\t}\n\n\t/**\n\t * In certain cases we need to adjust the increment size based on the\n\t * selected optimizer.  This is the hook to achieve that.\n\t *\n\t * @param optimizationStrategy The optimizer strategy (name)\n\t * @param incrementSize The {@link #determineIncrementSize determined increment size}\n\t * @return The adjusted increment size.\n\t */\n\tprotected int determineAdjustedIncrementSize(OptimizerDescriptor optimizationStrategy, int incrementSize) {\n\t\tif ( optimizationStrategy == StandardOptimizerDescriptor.NONE  ) {\n\t\t\tif ( incrementSize < -1 ) {\n\t\t\t\tLOG.honoringOptimizerSetting(\n\t\t\t\t\t\tStandardOptimizerDescriptor.NONE.getExternalName(),\n\t\t\t\t\t\tINCREMENT_PARAM,\n\t\t\t\t\t\tincrementSize,\n\t\t\t\t\t\t\"negative\",\n\t\t\t\t\t\t-1\n\t\t\t\t);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\telse if ( incrementSize > 1 ) {\n\t\t\t\tLOG.honoringOptimizerSetting(\n\t\t\t\t\t\tStandardOptimizerDescriptor.NONE.getExternalName(),\n\t\t\t\t\t\tINCREMENT_PARAM,\n\t\t\t\t\t\tincrementSize,\n\t\t\t\t\t\t\"positive\",\n\t\t\t\t\t\t1\n\t\t\t\t);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn incrementSize;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\treturn incrementSize;\n\t\t}\n\t}\n\n\t/**\n\t * Build the database structure.\n\t *\n\t * @param type The Hibernate type of the identifier property\n\t * @param params The params supplied in the generator config (plus some standard useful extras).\n\t * @param jdbcEnvironment The JDBC environment in which the sequence will be used.\n\t * @param forceTableUse Should a table be used even if the dialect supports sequences?\n\t * @param sequenceName The name to use for the sequence or table.\n\t * @param initialValue The initial value.\n\t * @param incrementSize the increment size to use (after any adjustments).\n\t *\n\t * @return An abstraction for the actual database structure in use (table vs. sequence).\n\t */\n\tprotected DatabaseStructure buildDatabaseStructure(\n\t\t\tType type,\n\t\t\tProperties params,\n\t\t\tJdbcEnvironment jdbcEnvironment,\n\t\t\tboolean forceTableUse,\n\t\t\tQualifiedName sequenceName,\n\t\t\tint initialValue,\n\t\t\tint incrementSize) {\n\t\treturn isPhysicalSequence( jdbcEnvironment, forceTableUse )\n\t\t\t\t? buildSequenceStructure( type, params, jdbcEnvironment, sequenceName, initialValue, incrementSize )\n\t\t\t\t: buildTableStructure( type, params, jdbcEnvironment, sequenceName, initialValue, incrementSize );\n\t}\n\n\tprotected boolean isPhysicalSequence(JdbcEnvironment jdbcEnvironment, boolean forceTableUse) {\n\t\treturn jdbcEnvironment.getDialect().getSequenceSupport().supportsSequences()\n\t\t\t&& !forceTableUse;\n\t}\n\n\tprotected DatabaseStructure buildSequenceStructure(\n\t\t\tType type,\n\t\t\tProperties params,\n\t\t\tJdbcEnvironment jdbcEnvironment,\n\t\t\tQualifiedName sequenceName,\n\t\t\tint initialValue,\n\t\t\tint incrementSize) {\n\t\treturn new SequenceStructure(\n\t\t\t\tdetermineContributor( params ),\n\t\t\t\tsequenceName,\n\t\t\t\tinitialValue,\n\t\t\t\tincrementSize,\n\t\t\t\tparams.getProperty( OPTIONS ),\n\t\t\t\ttype.getReturnedClass()\n\t\t);\n\t}\n\n\tprotected DatabaseStructure buildTableStructure(\n\t\t\tType type,\n\t\t\tProperties params,\n\t\t\tJdbcEnvironment jdbcEnvironment,\n\t\t\tQualifiedName sequenceName,\n\t\t\tint initialValue,\n\t\t\tint incrementSize) {\n\n\t\treturn new TableStructure(\n\t\t\t\tdetermineContributor( params ),\n\t\t\t\tsequenceName,\n\t\t\t\tdetermineValueColumnName( params, jdbcEnvironment ),\n\t\t\t\tinitialValue,\n\t\t\t\tincrementSize,\n\t\t\t\tparams.getProperty( OPTIONS ),\n\t\t\t\ttype.getReturnedClass()\n\t\t);\n\t}\n\n\tprivate String determineContributor(Properties params) {\n\t\tfinal String contributor = params.getProperty( IdentifierGenerator.CONTRIBUTOR_NAME );\n\t\treturn contributor == null ? \"orm\" : contributor;\n\t}\n\n\n\t// IdentifierGenerator implementation ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n\t@Override\n\tpublic Object generate(SharedSessionContractImplementor session, Object object) throws HibernateException {\n\t\treturn optimizer.generate( databaseStructure.buildCallback( session ) );\n\t}\n\n\t// BulkInsertionCapableIdentifierGenerator implementation ~~~~~~~~~~~~~~~~~\n\n\t@Override\n\tpublic boolean supportsBulkInsertionIdentifierGeneration() {\n\t\t// it does, as long as the underlying structure is a sequence\n\t\treturn getDatabaseStructure().isPhysicalSequence();\n\t}\n\n\t@Override\n\tpublic String determineBulkInsertionIdentifierGenerationSelectFragment(SqlStringGenerationContext context) {\n\t\treturn context.getDialect().getSequenceSupport()\n\t\t\t\t.getSelectSequenceNextValString( context.format( getDatabaseStructure().getPhysicalName() ) );\n\t}\n\n\t/**\n\t * Get the database sequence increment value from the associated {@link SequenceInformation} object.\n\t *\n\t * @param jdbcEnvironment the current JdbcEnvironment\n\t * @param sequenceName sequence name\n\t *\n\t * @return sequence increment value\n\t */\n\tprivate Number getSequenceIncrementValue(JdbcEnvironment jdbcEnvironment, String sequenceName) {\n\t\tfor ( SequenceInformation information :\n\t\t\t\tjdbcEnvironment.getExtractedDatabaseMetaData().getSequenceInformationList() ) {\n\t\t\tfinal QualifiedSequenceName name = information.getSequenceName();\n\t\t\tif ( sequenceName.equalsIgnoreCase( name.getSequenceName().getText() )\n\t\t\t\t\t&& isDefaultSchema( jdbcEnvironment, name.getCatalogName(), name.getSchemaName() ) ) {\n\t\t\t\tfinal Number incrementValue = information.getIncrementValue();\n\t\t\t\tif ( incrementValue != null ) {\n\t\t\t\t\treturn incrementValue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tprivate static boolean isDefaultSchema(JdbcEnvironment jdbcEnvironment, Identifier catalog, Identifier schema) {\n\t\treturn ( catalog == null || catalog.equals( jdbcEnvironment.getCurrentCatalog() ) )\n\t\t\t&& ( schema == null || schema.equals( jdbcEnvironment.getCurrentSchema() ) );\n\t}\n}\n",
        "diffSourceCodeSet": [
            ""
        ],
        "invokedMethodSet": [
            "methodSignature: org.hibernate.id.enhanced.SequenceStyleGenerator#determineSequenceName\n methodBody: protected QualifiedName determineSequenceName(\n\t\t\tProperties params,\n\t\t\tDialect dialect,\n\t\t\tJdbcEnvironment jdbcEnv,\n\t\t\tServiceRegistry serviceRegistry) {\nfinal IdentifierHelper identifierHelper=jdbcEnv.getIdentifierHelper();\nfinal Identifier catalog=identifierHelper.toIdentifier(getString(CATALOG,params));\nfinal Identifier schema=identifierHelper.toIdentifier(getString(SCHEMA,params));\nfinal String sequenceName=getString(SEQUENCE_PARAM,params,() -> getString(ALT_SEQUENCE_PARAM,params));\nif(StringHelper.isNotEmpty(sequenceName)){if(sequenceName.contains(\".\")){return QualifiedNameParser.INSTANCE.parse(sequenceName);\n}{return new QualifiedNameParser.NameParts(catalog,schema,identifierHelper.toIdentifier(sequenceName));\n}}return determineImplicitName(catalog,schema,params,serviceRegistry);\n}"
        ],
        "sourceCodeAfterRefactoring": "private static QualifiedName sequenceName(\n\t\t\tProperties params,\n\t\t\tServiceRegistry serviceRegistry,\n\t\t\tString explicitSequenceName,\n\t\t\tIdentifier catalog, Identifier schema,\n\t\t\tIdentifierHelper identifierHelper) {\n\t\tif ( isNotEmpty( explicitSequenceName ) ) {\n\t\t\t// we have an explicit name, use it\n\t\t\treturn explicitSequenceName.contains(\".\")\n\t\t\t\t\t? QualifiedNameParser.INSTANCE.parse( explicitSequenceName )\n\t\t\t\t\t: new QualifiedNameParser.NameParts( catalog, schema,\n\t\t\t\t\t\t\tidentifierHelper.toIdentifier( explicitSequenceName ) );\n\t\t}\n\t\telse {\n\t\t\t// otherwise, determine an implicit name to use\n\t\t\treturn getNamingStrategy( params, serviceRegistry )\n\t\t\t\t\t.determineSequenceName( catalog, schema, params, serviceRegistry );\n\t\t}\n\t}\n",
        "diffSourceCode": "-  335: \t\tif ( StringHelper.isNotEmpty( sequenceName ) ) {\n-  336: \t\t\t// we have an explicit name, use it\n-  337: \t\t\tif ( sequenceName.contains( \".\" ) ) {\n-  338: \t\t\t\treturn QualifiedNameParser.INSTANCE.parse( sequenceName );\n-  339: \t\t\t}\n-  340: \t\t\telse {\n-  341: \t\t\t\treturn new QualifiedNameParser.NameParts(\n-  342: \t\t\t\t\t\tcatalog,\n-  343: \t\t\t\t\t\tschema,\n-  344: \t\t\t\t\t\tidentifierHelper.toIdentifier( sequenceName )\n-  345: \t\t\t\t);\n-  346: \t\t\t}\n+  335: \tprivate static QualifiedName sequenceName(\n+  336: \t\t\tProperties params,\n+  337: \t\t\tServiceRegistry serviceRegistry,\n+  338: \t\t\tString explicitSequenceName,\n+  339: \t\t\tIdentifier catalog, Identifier schema,\n+  340: \t\t\tIdentifierHelper identifierHelper) {\n+  341: \t\tif ( isNotEmpty( explicitSequenceName ) ) {\n+  342: \t\t\t// we have an explicit name, use it\n+  343: \t\t\treturn explicitSequenceName.contains(\".\")\n+  344: \t\t\t\t\t? QualifiedNameParser.INSTANCE.parse( explicitSequenceName )\n+  345: \t\t\t\t\t: new QualifiedNameParser.NameParts( catalog, schema,\n+  346: \t\t\t\t\t\t\tidentifierHelper.toIdentifier( explicitSequenceName ) );\n   347: \t\t}\n-  348: \n-  349: \t\t// otherwise, determine an implicit name to use\n-  350: \t\treturn determineImplicitName( catalog, schema, params, serviceRegistry );\n-  351: \t}\n-  352: \n-  353: \tprivate QualifiedName determineImplicitName(\n-  354: \t\t\tIdentifier catalog,\n-  355: \t\t\tIdentifier schema,\n-  356: \t\t\tProperties params,\n-  357: \t\t\tServiceRegistry serviceRegistry) {\n-  358: \t\tfinal StrategySelector strategySelector = serviceRegistry.requireService( StrategySelector.class );\n-  359: \n-  360: \t\tfinal String namingStrategySetting = coalesceSuppliedValues(\n-  361: \t\t\t\t() -> {\n-  362: \t\t\t\t\tfinal String localSetting = getString( ID_DB_STRUCTURE_NAMING_STRATEGY, params );\n-  363: \t\t\t\t\tif ( localSetting != null ) {\n-  364: \t\t\t\t\t\tINCUBATION_LOGGER.incubatingSetting( ID_DB_STRUCTURE_NAMING_STRATEGY );\n-  365: \t\t\t\t\t}\n-  366: \t\t\t\t\treturn localSetting;\n-  367: \t\t\t\t},\n-  368: \t\t\t\t() -> {\n-  369: \t\t\t\t\tfinal ConfigurationService configurationService = serviceRegistry.requireService( ConfigurationService.class );\n-  370: \t\t\t\t\tfinal String globalSetting = getString( ID_DB_STRUCTURE_NAMING_STRATEGY, configurationService.getSettings() );\n-  371: \t\t\t\t\tif ( globalSetting != null ) {\n-  372: \t\t\t\t\t\tINCUBATION_LOGGER.incubatingSetting( ID_DB_STRUCTURE_NAMING_STRATEGY );\n-  373: \t\t\t\t\t}\n-  374: \t\t\t\t\treturn globalSetting;\n-  375: \t\t\t\t},\n-  376: \t\t\t\tStandardNamingStrategy.class::getName\n-  377: \t\t);\n-  378: \n-  379: \t\tfinal ImplicitDatabaseObjectNamingStrategy namingStrategy = strategySelector.resolveStrategy(\n-  380: \t\t\t\tImplicitDatabaseObjectNamingStrategy.class,\n-  381: \t\t\t\tnamingStrategySetting\n-  382: \t\t);\n-  383: \n-  384: \t\treturn namingStrategy.determineSequenceName( catalog, schema, params, serviceRegistry );\n-  385: \t}\n+  348: \t\telse {\n+  349: \t\t\t// otherwise, determine an implicit name to use\n+  350: \t\t\treturn getNamingStrategy( params, serviceRegistry )\n+  351: \t\t\t\t\t.determineSequenceName( catalog, schema, params, serviceRegistry );\n+  352: \t\t}\n+  353: \t}\n+  354: \n+  355: \n+  356: \t/**\n+  357: \t * Determine the name of the column used to store the generator value in\n+  358: \t * the db.\n+  359: \t * <p>\n+  360: \t * Called during {@linkplain #configure configuration} <b>when resolving to a\n+  361: \t * physical table</b>.\n+  362: \t *\n+  363: \t * @param params The params supplied in the generator config (plus some standard useful extras).\n+  364: \t * @param jdbcEnvironment The JDBC environment\n+  365: \t * @return The value column name\n+  366: \t */\n+  367: \tprotected Identifier determineValueColumnName(Properties params, JdbcEnvironment jdbcEnvironment) {\n+  368: \t\tfinal String name = getString( VALUE_COLUMN_PARAM, params, DEF_VALUE_COLUMN );\n+  369: \t\treturn jdbcEnvironment.getIdentifierHelper().toIdentifier( name );\n+  370: \t}\n+  371: \n+  372: \t/**\n+  373: \t * Determine the initial sequence value to use.  This value is used when\n+  374: \t * initializing the {@link #getDatabaseStructure() database structure}\n+  375: \t * (i.e. sequence/table).\n+  376: \t * <p>\n+  377: \t * Called during {@linkplain #configure configuration}.\n+  378: \t *\n+  379: \t * @param params The params supplied in the generator config (plus some standard useful extras).\n+  380: \t * @return The initial value\n+  381: \t */\n+  382: \tprotected int determineInitialValue(Properties params) {\n+  383: \t\treturn getInt( INITIAL_PARAM, params, DEFAULT_INITIAL_VALUE );\n+  384: \t}\n+  385: \n",
        "uniqueId": "5dcbdf64f11dfdcf25fd5a4a571f978b5ade2a8e_353_385_638_661_335_353",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 0,
                "covered": 41
            },
            "LINE": {
                "missed": 0,
                "covered": 5
            },
            "COMPLEXITY": {
                "missed": 0,
                "covered": 1
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 21
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprivate getCompositeCascadeStyle(compositeType ComponentType, cascade String) : CascadeStyle extracted from private getCompositeCascadeStyle(compositeType CompositeType, cascade String) : CascadeStyle in class org.hibernate.mapping.Property",
        "diffLocations": [
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/mapping/Property.java",
                "startLine": 151,
                "endLine": 162,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/mapping/Property.java",
                "startLine": 157,
                "endLine": 164,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/mapping/Property.java",
                "startLine": 166,
                "endLine": 174,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "private static CascadeStyle getCompositeCascadeStyle(CompositeType compositeType, String cascade) {\n\t\tif ( compositeType.isAnyType() ) {\n\t\t\treturn getCascadeStyle( cascade );\n\t\t}\n\t\tfinal int length = compositeType.getSubtypes().length;\n\t\tfor ( int i=0; i<length; i++ ) {\n\t\t\tif ( compositeType.getCascadeStyle(i) != CascadeStyles.NONE ) {\n\t\t\t\treturn CascadeStyles.ALL;\n\t\t\t}\n\t\t}\n\t\treturn getCascadeStyle( cascade );\n\t}",
        "filePathBefore": "hibernate-core/src/main/java/org/hibernate/mapping/Property.java",
        "isPureRefactoring": true,
        "commitId": "94b444b4d8e0ac7ec5817642ca711f626ee327f3",
        "packageNameBefore": "org.hibernate.mapping",
        "classNameBefore": "org.hibernate.mapping.Property",
        "methodNameBefore": "org.hibernate.mapping.Property#getCompositeCascadeStyle",
        "invokedMethod": "methodSignature: org.hibernate.type.AbstractType#isAnyType\n methodBody: public boolean isAnyType() {\nreturn false;\n}\nmethodSignature: org.hibernate.mapping.Property#getCascadeStyle\n methodBody: private static CascadeStyle getCascadeStyle(String cascade) {\nif(cascade == null || cascade.equals(\"none\")){return CascadeStyles.NONE;\n}{final StringTokenizer tokens=new StringTokenizer(cascade,\", \");\nfinal CascadeStyle[] styles=new CascadeStyle[tokens.countTokens()];\nint i=0;\nwhile(tokens.hasMoreTokens()){styles[i++]=CascadeStyles.getCascadeStyle(tokens.nextToken());\n}return new CascadeStyles.MultipleCascadeStyle(styles);\n}}",
        "classSignatureBefore": "public class Property implements Serializable, MetaAttributable ",
        "methodNameBeforeSet": [
            "org.hibernate.mapping.Property#getCompositeCascadeStyle"
        ],
        "classNameBeforeSet": [
            "org.hibernate.mapping.Property"
        ],
        "classSignatureBeforeSet": [
            "public class Property implements Serializable, MetaAttributable "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.\n */\npackage org.hibernate.mapping;\n\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.util.StringTokenizer;\n\nimport org.hibernate.HibernateException;\nimport org.hibernate.Internal;\nimport org.hibernate.MappingException;\nimport org.hibernate.boot.model.relational.Database;\nimport org.hibernate.bytecode.enhance.spi.interceptor.EnhancementHelper;\nimport org.hibernate.cfg.AvailableSettings;\nimport org.hibernate.engine.spi.CascadeStyle;\nimport org.hibernate.engine.spi.CascadeStyles;\nimport org.hibernate.engine.spi.Mapping;\nimport org.hibernate.jpa.event.spi.CallbackDefinition;\nimport org.hibernate.metamodel.RepresentationMode;\nimport org.hibernate.metamodel.spi.RuntimeModelCreationContext;\nimport org.hibernate.property.access.spi.Getter;\nimport org.hibernate.property.access.spi.PropertyAccessStrategy;\nimport org.hibernate.property.access.spi.PropertyAccessStrategyResolver;\nimport org.hibernate.property.access.spi.Setter;\nimport org.hibernate.service.ServiceRegistry;\nimport org.hibernate.generator.Generator;\nimport org.hibernate.generator.GeneratorCreationContext;\nimport org.hibernate.type.CompositeType;\nimport org.hibernate.type.Type;\nimport org.hibernate.type.WrapperArrayHandling;\n\nimport static java.util.Collections.emptyList;\nimport static java.util.Collections.unmodifiableList;\n\n/**\n * A mapping model object representing a property or field of an {@linkplain PersistentClass entity}\n * or {@linkplain Component embeddable class}.\n *\n * @author Gavin King\n */\npublic class Property implements Serializable, MetaAttributable {\n\tprivate String name;\n\tprivate Value value;\n\tprivate String cascade;\n\tprivate boolean updateable = true;\n\tprivate boolean insertable = true;\n\tprivate boolean selectable = true;\n\tprivate boolean optimisticLocked = true;\n\tprivate GeneratorCreator generatorCreator;\n\tprivate String propertyAccessorName;\n\tprivate PropertyAccessStrategy propertyAccessStrategy;\n\tprivate boolean lazy;\n\tprivate String lazyGroup;\n\tprivate boolean optional;\n\tprivate java.util.Map<String,MetaAttribute> metaAttributes;\n\tprivate PersistentClass persistentClass;\n\tprivate boolean naturalIdentifier;\n\tprivate boolean isGeneric;\n\tprivate boolean lob;\n\tprivate java.util.List<CallbackDefinition> callbackDefinitions;\n\tprivate String returnedClassName;\n\n\tpublic boolean isBackRef() {\n\t\treturn false;\n\t}\n\n\t/**\n\t * Does this property represent a synthetic property?  A synthetic property is one we create during\n\t * metamodel binding to represent a collection of columns but which does not represent a property\n\t * physically available on the entity.\n\t *\n\t * @return True if synthetic; false otherwise.\n\t */\n\tpublic boolean isSynthetic() {\n\t\treturn false;\n\t}\n\n\tpublic Type getType() throws MappingException {\n\t\treturn value.getType();\n\t}\n\t\n\tpublic int getColumnSpan() {\n\t\treturn value.getColumnSpan();\n\t}\n\n\t/**\n\t * Delegates to {@link Value#getSelectables()}.\n\t */\n\tpublic java.util.List<Selectable> getSelectables() {\n\t\treturn value.getSelectables();\n\t}\n\n\t/**\n\t * Delegates to {@link Value#getColumns()}.\n\t *\n\t * @throws org.hibernate.AssertionFailure if the mapping involves formulas\n\t */\n\tpublic java.util.List<Column> getColumns() {\n\t\treturn value.getColumns();\n\t}\n\t\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\t\n\tpublic boolean isComposite() {\n\t\treturn value instanceof Component;\n\t}\n\n\tpublic Value getValue() {\n\t\treturn value;\n\t}\n\n\tpublic void resetUpdateable(boolean updateable) {\n\t\tsetUpdateable( updateable );\n\t\tboolean[] columnUpdateability = getValue().getColumnUpdateability();\n\t\tfor (int i=0; i<getColumnSpan(); i++ ) {\n\t\t\tcolumnUpdateability[i] = updateable;\n\t\t}\n\t}\n\n\tpublic void resetOptional(boolean optional) {\n\t\tsetOptional( optional );\n\t\tfor ( Selectable selectable: getValue().getSelectables() ) {\n\t\t\tif (selectable instanceof Column) {\n\t\t\t\tfinal Column column = (Column) selectable;\n\t\t\t\tcolumn.setNullable( optional );\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic CascadeStyle getCascadeStyle() throws MappingException {\n\t\tfinal Type type = value.getType();\n\t\tif ( type.isComponentType() ) {\n\t\t\treturn getCompositeCascadeStyle( (CompositeType) type, cascade );\n\t\t}\n\t\telse if ( type.isCollectionType() ) {\n\t\t\tfinal Collection collection = (Collection) value;\n\t\t\treturn getCollectionCascadeStyle( collection.getElement().getType(), cascade );\n\t\t}\n\t\telse {\n\t\t\treturn getCascadeStyle( cascade );\t\t\t\n\t\t}\n\t}\n\n\tprivate static CascadeStyle getCompositeCascadeStyle(CompositeType compositeType, String cascade) {\n\t\tif ( compositeType.isAnyType() ) {\n\t\t\treturn getCascadeStyle( cascade );\n\t\t}\n\t\tfinal int length = compositeType.getSubtypes().length;\n\t\tfor ( int i=0; i<length; i++ ) {\n\t\t\tif ( compositeType.getCascadeStyle(i) != CascadeStyles.NONE ) {\n\t\t\t\treturn CascadeStyles.ALL;\n\t\t\t}\n\t\t}\n\t\treturn getCascadeStyle( cascade );\n\t}\n\n\tprivate static CascadeStyle getCollectionCascadeStyle(Type elementType, String cascade) {\n\t\treturn elementType.isComponentType()\n\t\t\t\t? getCompositeCascadeStyle( (CompositeType) elementType, cascade )\n\t\t\t\t: getCascadeStyle( cascade );\n\t}\n\t\n\tprivate static CascadeStyle getCascadeStyle(String cascade) {\n\t\tif ( cascade==null || cascade.equals(\"none\") ) {\n\t\t\treturn CascadeStyles.NONE;\n\t\t}\n\t\telse {\n\t\t\tfinal StringTokenizer tokens = new StringTokenizer(cascade, \", \");\n\t\t\tfinal CascadeStyle[] styles = new CascadeStyle[ tokens.countTokens() ] ;\n\t\t\tint i=0;\n\t\t\twhile ( tokens.hasMoreTokens() ) {\n\t\t\t\tstyles[i++] = CascadeStyles.getCascadeStyle( tokens.nextToken() );\n\t\t\t}\n\t\t\treturn new CascadeStyles.MultipleCascadeStyle(styles);\n\t\t}\t\t\n\t}\n\t\n\tpublic String getCascade() {\n\t\treturn cascade;\n\t}\n\n\tpublic void setCascade(String cascade) {\n\t\tthis.cascade = cascade;\n\t}\n\n\tpublic void setName(String name) {\n\t\tthis.name = name==null ? null : name.intern();\n\t}\n\n\tpublic void setValue(Value value) {\n\t\tthis.value = value;\n\t}\n\n\tpublic boolean isUpdateable() {\n\t\t// if the property mapping consists of all formulas,\n\t\t// make it non-updatable\n\t\treturn updateable && value.hasAnyUpdatableColumns();\n\t}\n\n\tpublic boolean isInsertable() {\n\t\t// if the property mapping consists of all formulas, \n\t\t// make it non-insertable\n\t\treturn insertable && value.hasAnyInsertableColumns();\n\t}\n\n\t@Internal\n\tpublic GeneratorCreator getValueGeneratorCreator() {\n\t\treturn generatorCreator;\n\t}\n\n\t@Internal\n\tpublic void setValueGeneratorCreator(GeneratorCreator generator) {\n\t\tthis.generatorCreator = generator;\n\t}\n\n\tpublic void setUpdateable(boolean mutable) {\n\t\tthis.updateable = mutable;\n\t}\n\n\tpublic void setInsertable(boolean insertable) {\n\t\tthis.insertable = insertable;\n\t}\n\n\tpublic String getPropertyAccessorName() {\n\t\treturn propertyAccessorName;\n\t}\n\n\tpublic void setPropertyAccessorName(String string) {\n\t\tpropertyAccessorName = string;\n\t}\n\n\tpublic PropertyAccessStrategy getPropertyAccessStrategy() {\n\t\treturn propertyAccessStrategy;\n\t}\n\n\tpublic void setPropertyAccessStrategy(PropertyAccessStrategy propertyAccessStrategy) {\n\t\tthis.propertyAccessStrategy = propertyAccessStrategy;\n\t}\n\n\tpublic boolean isBasicPropertyAccessor() {\n\t\treturn propertyAccessorName==null || \"property\".equals( propertyAccessorName );\n\t}\n\n\tpublic Map<String, MetaAttribute> getMetaAttributes() {\n\t\treturn metaAttributes;\n\t}\n\n\tpublic MetaAttribute getMetaAttribute(String attributeName) {\n\t\treturn metaAttributes==null ? null : metaAttributes.get(attributeName);\n\t}\n\n\tpublic void setMetaAttributes(Map<String, MetaAttribute> metas) {\n\t\tthis.metaAttributes = metas;\n\t}\n\n\tpublic boolean isValid(Mapping mapping) throws MappingException {\n\t\tfinal Value value = getValue();\n\t\tif ( value instanceof BasicValue && ( (BasicValue) value ).isDisallowedWrapperArray() ) {\n\t\t\tthrow new MappingException(\n\t\t\t\t\t\"The property \" + persistentClass.getEntityName() + \"#\" + name +\n\t\t\t\t\t\t\t\" uses a wrapper type Byte[]/Character[] which indicates an issue in your domain model. \" +\n\t\t\t\t\t\t\t\"These types have been treated like byte[]/char[] until Hibernate 6.2 which meant that \" +\n\t\t\t\t\t\t\t\"null elements were not allowed, but on JDBC were processed like VARBINARY or VARCHAR. \" +\n\t\t\t\t\t\t\t\"If you don't use nulls in your arrays, change the type of the property to byte[]/char[]. \" +\n\t\t\t\t\t\t\t\"To allow explicit uses of the wrapper types Byte[]/Character[] which allows null element \" +\n\t\t\t\t\t\t\t\"but has a different serialization format than before Hibernate 6.2, configure the \" +\n\t\t\t\t\t\t\t\"setting \" + AvailableSettings.WRAPPER_ARRAY_HANDLING + \" to the value \" + WrapperArrayHandling.ALLOW + \". \" +\n\t\t\t\t\t\t\t\"To revert to the legacy treatment of these types, configure the value to \" + WrapperArrayHandling.LEGACY + \". \" +\n\t\t\t\t\t\t\t\"For more information on this matter, consult the migration guide of Hibernate 6.2 \" +\n\t\t\t\t\t\t\t\"and the Javadoc of the org.hibernate.cfg.AvailableSettings.WRAPPER_ARRAY_HANDLING field.\"\n\t\t\t);\n\t\t}\n\t\treturn value.isValid( mapping );\n\t}\n\n\tpublic String toString() {\n\t\treturn getClass().getSimpleName() + '(' + name + ')';\n\t}\n\t\n\tpublic void setLazy(boolean lazy) {\n\t\tthis.lazy=lazy;\n\t}\n\n\t/**\n\t * Is this property lazy in the \"bytecode\" sense?\n\t * <p>\n\t * Lazy here means whether we initialize this field of the entity\n\t * instance in its \"base fetch group\". It affects whether we list\n\t * this property's columns in the SQL select for the owning entity\n\t * when we load its \"base fetch group\". The actual value that is set\n\t * varies based on the nature (basic, etc) of the property.\n\t *\n\t * @apiNote This method reports whether the property is considered\n\t * part of the base fetch group based solely on the information in\n\t * the mapping but {@link EnhancementHelper#includeInBaseFetchGroup}\n\t * is also accounts for other details.\n\t */\n\tpublic boolean isLazy() {\n\t\tif ( value instanceof ToOne ) {\n\t\t\t// For a many-to-one, this is always false. Whether the\n\t\t\t// association is EAGER, PROXY or NO-PROXY we always want\n\t\t\t// to select the foreign key\n\t\t\treturn false;\n\t\t}\n\t\telse {\n\t\t\treturn lazy;\n\t\t}\n\t}\n\n\tpublic String getLazyGroup() {\n\t\treturn lazyGroup;\n\t}\n\n\tpublic void setLazyGroup(String lazyGroup) {\n\t\tthis.lazyGroup = lazyGroup;\n\t}\n\n\tpublic boolean isOptimisticLocked() {\n\t\treturn optimisticLocked;\n\t}\n\n\tpublic void setOptimisticLocked(boolean optimisticLocked) {\n\t\tthis.optimisticLocked = optimisticLocked;\n\t}\n\t\n\tpublic boolean isOptional() {\n\t\treturn optional;\n\t}\n\t\n\tpublic void setOptional(boolean optional) {\n\t\tthis.optional = optional;\n\t}\n\n\tpublic PersistentClass getPersistentClass() {\n\t\treturn persistentClass;\n\t}\n\n\tpublic void setPersistentClass(PersistentClass persistentClass) {\n\t\tthis.persistentClass = persistentClass;\n\t}\n\n\tpublic boolean isSelectable() {\n\t\treturn selectable;\n\t}\n\t\n\tpublic void setSelectable(boolean selectable) {\n\t\tthis.selectable = selectable;\n\t}\n\n\t// todo : remove\n\t@Internal\n\tpublic Getter getGetter(Class clazz) throws MappingException {\n\t\treturn getPropertyAccessStrategy( clazz ).buildPropertyAccess( clazz, name, true ).getGetter();\n\t}\n\n\t// todo : remove\n\t@Internal\n\tpublic Setter getSetter(Class clazz) throws MappingException {\n\t\treturn getPropertyAccessStrategy( clazz ).buildPropertyAccess( clazz, name, true ).getSetter();\n\t}\n\n\t// todo : remove\n\t@Internal\n\tpublic PropertyAccessStrategy getPropertyAccessStrategy(Class clazz) throws MappingException {\n\t\tfinal PropertyAccessStrategy propertyAccessStrategy = getPropertyAccessStrategy();\n\t\tif ( propertyAccessStrategy != null ) {\n\t\t\treturn propertyAccessStrategy;\n\t\t}\n\t\tString accessName = getPropertyAccessorName();\n\t\tif ( accessName == null ) {\n\t\t\tif ( clazz == null || java.util.Map.class.equals( clazz ) ) {\n\t\t\t\taccessName = \"map\";\n\t\t\t}\n\t\t\telse {\n\t\t\t\taccessName = \"property\";\n\t\t\t}\n\t\t}\n\n\t\tfinal RepresentationMode representationMode = clazz == null || java.util.Map.class.equals( clazz )\n\t\t\t\t? RepresentationMode.MAP\n\t\t\t\t: RepresentationMode.POJO;\n\n\t\treturn resolveServiceRegistry()\n\t\t\t\t.requireService( PropertyAccessStrategyResolver.class )\n\t\t\t\t.resolvePropertyAccessStrategy( clazz, accessName, representationMode );\n\t}\n\n\tServiceRegistry resolveServiceRegistry() {\n\t\tif ( getPersistentClass() != null ) {\n\t\t\treturn getPersistentClass().getServiceRegistry();\n\t\t}\n\t\tif ( getValue() != null ) {\n\t\t\treturn getValue().getServiceRegistry();\n\t\t}\n\t\tthrow new HibernateException( \"Could not resolve ServiceRegistry\" );\n\t}\n\n\tpublic boolean isNaturalIdentifier() {\n\t\treturn naturalIdentifier;\n\t}\n\n\tpublic void setNaturalIdentifier(boolean naturalIdentifier) {\n\t\tthis.naturalIdentifier = naturalIdentifier;\n\t}\n\n\tpublic boolean isGeneric() {\n\t\treturn isGeneric;\n\t}\n\n\tpublic void setGeneric(boolean generic) {\n\t\tthis.isGeneric = generic;\n\t}\n\n\tpublic boolean isLob() {\n\t\treturn lob;\n\t}\n\n\tpublic void setLob(boolean lob) {\n\t\tthis.lob = lob;\n\t}\n\n\tpublic void addCallbackDefinitions(java.util.List<CallbackDefinition> callbackDefinitions) {\n\t\tif ( callbackDefinitions != null && !callbackDefinitions.isEmpty() ) {\n\t\t\tif ( this.callbackDefinitions == null ) {\n\t\t\t\tthis.callbackDefinitions = new ArrayList<>();\n\t\t\t}\n\t\t\tthis.callbackDefinitions.addAll( callbackDefinitions );\n\t\t}\n\t}\n\n\tpublic java.util.List<CallbackDefinition> getCallbackDefinitions() {\n\t\treturn callbackDefinitions == null ? emptyList() : unmodifiableList( callbackDefinitions );\n\t}\n\n\tpublic String getReturnedClassName() {\n\t\treturn returnedClassName;\n\t}\n\n\tpublic void setReturnedClassName(String returnedClassName) {\n\t\tthis.returnedClassName = returnedClassName;\n\t}\n\n\tpublic Generator createGenerator(RuntimeModelCreationContext context) {\n\t\treturn generatorCreator == null ? null :\n\t\t\t\tgeneratorCreator.createGenerator( new PropertyGeneratorCreationContext( context ) );\n\t}\n\n\tpublic Property copy() {\n\t\tfinal Property property = new Property();\n\t\tproperty.setName( getName() );\n\t\tproperty.setValue( getValue() );\n\t\tproperty.setCascade( getCascade() );\n\t\tproperty.setUpdateable( isUpdateable() );\n\t\tproperty.setInsertable( isInsertable() );\n\t\tproperty.setSelectable( isSelectable() );\n\t\tproperty.setOptimisticLocked( isOptimisticLocked() );\n\t\tproperty.setValueGeneratorCreator( getValueGeneratorCreator() );\n\t\tproperty.setPropertyAccessorName( getPropertyAccessorName() );\n\t\tproperty.setPropertyAccessStrategy( getPropertyAccessStrategy() );\n\t\tproperty.setLazy( isLazy() );\n\t\tproperty.setLazyGroup( getLazyGroup() );\n\t\tproperty.setOptional( isOptional() );\n\t\tproperty.setMetaAttributes( getMetaAttributes() );\n\t\tproperty.setPersistentClass( getPersistentClass() );\n\t\tproperty.setNaturalIdentifier( isNaturalIdentifier() );\n\t\tproperty.setGeneric( isGeneric() );\n\t\tproperty.setLob( isLob() );\n\t\tproperty.addCallbackDefinitions( getCallbackDefinitions() );\n\t\tproperty.setReturnedClassName( getReturnedClassName() );\n\t\treturn property;\n\t}\n\n\tprivate class PropertyGeneratorCreationContext implements GeneratorCreationContext {\n\t\tprivate final RuntimeModelCreationContext context;\n\n\t\tpublic PropertyGeneratorCreationContext(RuntimeModelCreationContext context) {\n\t\t\tthis.context = context;\n\t\t}\n\n\t\t@Override\n\t\tpublic Database getDatabase() {\n\t\t\treturn context.getMetadata().getDatabase();\n\t\t}\n\n\t\t@Override\n\t\tpublic ServiceRegistry getServiceRegistry() {\n\t\t\treturn context.getBootstrapContext().getServiceRegistry();\n\t\t}\n\n\t\t@Override\n\t\tpublic String getDefaultCatalog() {\n\t\t\treturn context.getSessionFactoryOptions().getDefaultCatalog();\n\t\t}\n\n\t\t@Override\n\t\tpublic String getDefaultSchema() {\n\t\t\treturn context.getSessionFactoryOptions().getDefaultSchema();\n\t\t}\n\n\t\t@Override\n\t\tpublic PersistentClass getPersistentClass() {\n\t\t\treturn persistentClass;\n\t\t}\n\n\t\t@Override\n\t\tpublic RootClass getRootClass() {\n\t\t\treturn persistentClass.getRootClass();\n\t\t}\n\n\t\t@Override\n\t\tpublic Property getProperty() {\n\t\t\treturn Property.this;\n\t\t}\n\t}\n}\n",
        "filePathAfter": "hibernate-core/src/main/java/org/hibernate/mapping/Property.java",
        "sourceCodeAfterForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.\n */\npackage org.hibernate.mapping;\n\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.util.StringTokenizer;\n\nimport org.hibernate.HibernateException;\nimport org.hibernate.Internal;\nimport org.hibernate.MappingException;\nimport org.hibernate.boot.model.relational.Database;\nimport org.hibernate.bytecode.enhance.spi.interceptor.EnhancementHelper;\nimport org.hibernate.cfg.AvailableSettings;\nimport org.hibernate.engine.spi.CascadeStyle;\nimport org.hibernate.engine.spi.CascadeStyles;\nimport org.hibernate.engine.spi.Mapping;\nimport org.hibernate.jpa.event.spi.CallbackDefinition;\nimport org.hibernate.metamodel.RepresentationMode;\nimport org.hibernate.metamodel.spi.RuntimeModelCreationContext;\nimport org.hibernate.property.access.spi.Getter;\nimport org.hibernate.property.access.spi.PropertyAccessStrategy;\nimport org.hibernate.property.access.spi.PropertyAccessStrategyResolver;\nimport org.hibernate.property.access.spi.Setter;\nimport org.hibernate.service.ServiceRegistry;\nimport org.hibernate.generator.Generator;\nimport org.hibernate.generator.GeneratorCreationContext;\nimport org.hibernate.type.AnyType;\nimport org.hibernate.type.CollectionType;\nimport org.hibernate.type.ComponentType;\nimport org.hibernate.type.CompositeType;\nimport org.hibernate.type.Type;\nimport org.hibernate.type.WrapperArrayHandling;\n\nimport static java.util.Collections.emptyList;\nimport static java.util.Collections.unmodifiableList;\n\n/**\n * A mapping model object representing a property or field of an {@linkplain PersistentClass entity}\n * or {@linkplain Component embeddable class}.\n *\n * @author Gavin King\n */\npublic class Property implements Serializable, MetaAttributable {\n\tprivate String name;\n\tprivate Value value;\n\tprivate String cascade;\n\tprivate boolean updateable = true;\n\tprivate boolean insertable = true;\n\tprivate boolean selectable = true;\n\tprivate boolean optimisticLocked = true;\n\tprivate GeneratorCreator generatorCreator;\n\tprivate String propertyAccessorName;\n\tprivate PropertyAccessStrategy propertyAccessStrategy;\n\tprivate boolean lazy;\n\tprivate String lazyGroup;\n\tprivate boolean optional;\n\tprivate java.util.Map<String,MetaAttribute> metaAttributes;\n\tprivate PersistentClass persistentClass;\n\tprivate boolean naturalIdentifier;\n\tprivate boolean isGeneric;\n\tprivate boolean lob;\n\tprivate java.util.List<CallbackDefinition> callbackDefinitions;\n\tprivate String returnedClassName;\n\n\tpublic boolean isBackRef() {\n\t\treturn false;\n\t}\n\n\t/**\n\t * Does this property represent a synthetic property?  A synthetic property is one we create during\n\t * metamodel binding to represent a collection of columns but which does not represent a property\n\t * physically available on the entity.\n\t *\n\t * @return True if synthetic; false otherwise.\n\t */\n\tpublic boolean isSynthetic() {\n\t\treturn false;\n\t}\n\n\tpublic Type getType() throws MappingException {\n\t\treturn value.getType();\n\t}\n\t\n\tpublic int getColumnSpan() {\n\t\treturn value.getColumnSpan();\n\t}\n\n\t/**\n\t * Delegates to {@link Value#getSelectables()}.\n\t */\n\tpublic java.util.List<Selectable> getSelectables() {\n\t\treturn value.getSelectables();\n\t}\n\n\t/**\n\t * Delegates to {@link Value#getColumns()}.\n\t *\n\t * @throws org.hibernate.AssertionFailure if the mapping involves formulas\n\t */\n\tpublic java.util.List<Column> getColumns() {\n\t\treturn value.getColumns();\n\t}\n\t\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\t\n\tpublic boolean isComposite() {\n\t\treturn value instanceof Component;\n\t}\n\n\tpublic Value getValue() {\n\t\treturn value;\n\t}\n\n\tpublic void resetUpdateable(boolean updateable) {\n\t\tsetUpdateable( updateable );\n\t\tboolean[] columnUpdateability = getValue().getColumnUpdateability();\n\t\tfor (int i=0; i<getColumnSpan(); i++ ) {\n\t\t\tcolumnUpdateability[i] = updateable;\n\t\t}\n\t}\n\n\tpublic void resetOptional(boolean optional) {\n\t\tsetOptional( optional );\n\t\tfor ( Selectable selectable: getValue().getSelectables() ) {\n\t\t\tif (selectable instanceof Column) {\n\t\t\t\tfinal Column column = (Column) selectable;\n\t\t\t\tcolumn.setNullable( optional );\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic CascadeStyle getCascadeStyle() throws MappingException {\n\t\tfinal Type type = value.getType();\n\t\tif ( type instanceof AnyType ) {\n\t\t\treturn getCascadeStyle( cascade );\n\t\t}\n\t\tif ( type instanceof ComponentType ) {\n\t\t\treturn getCompositeCascadeStyle( (ComponentType) type, cascade );\n\t\t}\n\t\telse if ( type instanceof CollectionType ) {\n\t\t\tfinal Collection collection = (Collection) value;\n\t\t\treturn getCollectionCascadeStyle( collection.getElement().getType(), cascade );\n\t\t}\n\t\telse {\n\t\t\treturn getCascadeStyle( cascade );\t\t\t\n\t\t}\n\t}\n\n\tprivate static CascadeStyle getCompositeCascadeStyle(CompositeType compositeType, String cascade) {\n\t\tif ( compositeType instanceof AnyType ) {\n\t\t\treturn getCascadeStyle( cascade );\n\t\t}\n\t\telse {\n\t\t\treturn getCompositeCascadeStyle( (ComponentType) compositeType, cascade );\n\t\t}\n\t}\n\n\tprivate static CascadeStyle getCompositeCascadeStyle(ComponentType compositeType, String cascade) {\n\t\tfinal int length = compositeType.getSubtypes().length;\n\t\tfor ( int i=0; i<length; i++ ) {\n\t\t\tif ( compositeType.getCascadeStyle(i) != CascadeStyles.NONE ) {\n\t\t\t\treturn CascadeStyles.ALL;\n\t\t\t}\n\t\t}\n\t\treturn getCascadeStyle( cascade );\n\t}\n\n\tprivate static CascadeStyle getCollectionCascadeStyle(Type elementType, String cascade) {\n\t\tif ( elementType instanceof AnyType ) {\n\t\t\treturn getCascadeStyle( cascade );\n\t\t}\n\t\telse if ( elementType instanceof ComponentType ) {\n\t\t\treturn getCompositeCascadeStyle( (ComponentType) elementType, cascade );\n\t\t}\n\t\telse {\n\t\t\treturn getCascadeStyle( cascade );\n\t\t}\n\t}\n\t\n\tprivate static CascadeStyle getCascadeStyle(String cascade) {\n\t\tif ( cascade==null || cascade.equals(\"none\") ) {\n\t\t\treturn CascadeStyles.NONE;\n\t\t}\n\t\telse {\n\t\t\tfinal StringTokenizer tokens = new StringTokenizer(cascade, \", \");\n\t\t\tfinal CascadeStyle[] styles = new CascadeStyle[ tokens.countTokens() ] ;\n\t\t\tint i=0;\n\t\t\twhile ( tokens.hasMoreTokens() ) {\n\t\t\t\tstyles[i++] = CascadeStyles.getCascadeStyle( tokens.nextToken() );\n\t\t\t}\n\t\t\treturn new CascadeStyles.MultipleCascadeStyle(styles);\n\t\t}\t\t\n\t}\n\t\n\tpublic String getCascade() {\n\t\treturn cascade;\n\t}\n\n\tpublic void setCascade(String cascade) {\n\t\tthis.cascade = cascade;\n\t}\n\n\tpublic void setName(String name) {\n\t\tthis.name = name==null ? null : name.intern();\n\t}\n\n\tpublic void setValue(Value value) {\n\t\tthis.value = value;\n\t}\n\n\tpublic boolean isUpdateable() {\n\t\t// if the property mapping consists of all formulas,\n\t\t// make it non-updatable\n\t\treturn updateable && value.hasAnyUpdatableColumns();\n\t}\n\n\tpublic boolean isInsertable() {\n\t\t// if the property mapping consists of all formulas, \n\t\t// make it non-insertable\n\t\treturn insertable && value.hasAnyInsertableColumns();\n\t}\n\n\t@Internal\n\tpublic GeneratorCreator getValueGeneratorCreator() {\n\t\treturn generatorCreator;\n\t}\n\n\t@Internal\n\tpublic void setValueGeneratorCreator(GeneratorCreator generator) {\n\t\tthis.generatorCreator = generator;\n\t}\n\n\tpublic void setUpdateable(boolean mutable) {\n\t\tthis.updateable = mutable;\n\t}\n\n\tpublic void setInsertable(boolean insertable) {\n\t\tthis.insertable = insertable;\n\t}\n\n\tpublic String getPropertyAccessorName() {\n\t\treturn propertyAccessorName;\n\t}\n\n\tpublic void setPropertyAccessorName(String string) {\n\t\tpropertyAccessorName = string;\n\t}\n\n\tpublic PropertyAccessStrategy getPropertyAccessStrategy() {\n\t\treturn propertyAccessStrategy;\n\t}\n\n\tpublic void setPropertyAccessStrategy(PropertyAccessStrategy propertyAccessStrategy) {\n\t\tthis.propertyAccessStrategy = propertyAccessStrategy;\n\t}\n\n\tpublic boolean isBasicPropertyAccessor() {\n\t\treturn propertyAccessorName==null || \"property\".equals( propertyAccessorName );\n\t}\n\n\tpublic Map<String, MetaAttribute> getMetaAttributes() {\n\t\treturn metaAttributes;\n\t}\n\n\tpublic MetaAttribute getMetaAttribute(String attributeName) {\n\t\treturn metaAttributes==null ? null : metaAttributes.get(attributeName);\n\t}\n\n\tpublic void setMetaAttributes(Map<String, MetaAttribute> metas) {\n\t\tthis.metaAttributes = metas;\n\t}\n\n\tpublic boolean isValid(Mapping mapping) throws MappingException {\n\t\tfinal Value value = getValue();\n\t\tif ( value instanceof BasicValue && ( (BasicValue) value ).isDisallowedWrapperArray() ) {\n\t\t\tthrow new MappingException(\n\t\t\t\t\t\"The property \" + persistentClass.getEntityName() + \"#\" + name +\n\t\t\t\t\t\t\t\" uses a wrapper type Byte[]/Character[] which indicates an issue in your domain model. \" +\n\t\t\t\t\t\t\t\"These types have been treated like byte[]/char[] until Hibernate 6.2 which meant that \" +\n\t\t\t\t\t\t\t\"null elements were not allowed, but on JDBC were processed like VARBINARY or VARCHAR. \" +\n\t\t\t\t\t\t\t\"If you don't use nulls in your arrays, change the type of the property to byte[]/char[]. \" +\n\t\t\t\t\t\t\t\"To allow explicit uses of the wrapper types Byte[]/Character[] which allows null element \" +\n\t\t\t\t\t\t\t\"but has a different serialization format than before Hibernate 6.2, configure the \" +\n\t\t\t\t\t\t\t\"setting \" + AvailableSettings.WRAPPER_ARRAY_HANDLING + \" to the value \" + WrapperArrayHandling.ALLOW + \". \" +\n\t\t\t\t\t\t\t\"To revert to the legacy treatment of these types, configure the value to \" + WrapperArrayHandling.LEGACY + \". \" +\n\t\t\t\t\t\t\t\"For more information on this matter, consult the migration guide of Hibernate 6.2 \" +\n\t\t\t\t\t\t\t\"and the Javadoc of the org.hibernate.cfg.AvailableSettings.WRAPPER_ARRAY_HANDLING field.\"\n\t\t\t);\n\t\t}\n\t\treturn value.isValid( mapping );\n\t}\n\n\tpublic String toString() {\n\t\treturn getClass().getSimpleName() + '(' + name + ')';\n\t}\n\t\n\tpublic void setLazy(boolean lazy) {\n\t\tthis.lazy=lazy;\n\t}\n\n\t/**\n\t * Is this property lazy in the \"bytecode\" sense?\n\t * <p>\n\t * Lazy here means whether we initialize this field of the entity\n\t * instance in its \"base fetch group\". It affects whether we list\n\t * this property's columns in the SQL select for the owning entity\n\t * when we load its \"base fetch group\". The actual value that is set\n\t * varies based on the nature (basic, etc) of the property.\n\t *\n\t * @apiNote This method reports whether the property is considered\n\t * part of the base fetch group based solely on the information in\n\t * the mapping but {@link EnhancementHelper#includeInBaseFetchGroup}\n\t * is also accounts for other details.\n\t */\n\tpublic boolean isLazy() {\n\t\tif ( value instanceof ToOne ) {\n\t\t\t// For a many-to-one, this is always false. Whether the\n\t\t\t// association is EAGER, PROXY or NO-PROXY we always want\n\t\t\t// to select the foreign key\n\t\t\treturn false;\n\t\t}\n\t\telse {\n\t\t\treturn lazy;\n\t\t}\n\t}\n\n\tpublic String getLazyGroup() {\n\t\treturn lazyGroup;\n\t}\n\n\tpublic void setLazyGroup(String lazyGroup) {\n\t\tthis.lazyGroup = lazyGroup;\n\t}\n\n\tpublic boolean isOptimisticLocked() {\n\t\treturn optimisticLocked;\n\t}\n\n\tpublic void setOptimisticLocked(boolean optimisticLocked) {\n\t\tthis.optimisticLocked = optimisticLocked;\n\t}\n\t\n\tpublic boolean isOptional() {\n\t\treturn optional;\n\t}\n\t\n\tpublic void setOptional(boolean optional) {\n\t\tthis.optional = optional;\n\t}\n\n\tpublic PersistentClass getPersistentClass() {\n\t\treturn persistentClass;\n\t}\n\n\tpublic void setPersistentClass(PersistentClass persistentClass) {\n\t\tthis.persistentClass = persistentClass;\n\t}\n\n\tpublic boolean isSelectable() {\n\t\treturn selectable;\n\t}\n\t\n\tpublic void setSelectable(boolean selectable) {\n\t\tthis.selectable = selectable;\n\t}\n\n\t// todo : remove\n\t@Internal\n\tpublic Getter getGetter(Class clazz) throws MappingException {\n\t\treturn getPropertyAccessStrategy( clazz ).buildPropertyAccess( clazz, name, true ).getGetter();\n\t}\n\n\t// todo : remove\n\t@Internal\n\tpublic Setter getSetter(Class clazz) throws MappingException {\n\t\treturn getPropertyAccessStrategy( clazz ).buildPropertyAccess( clazz, name, true ).getSetter();\n\t}\n\n\t// todo : remove\n\t@Internal\n\tpublic PropertyAccessStrategy getPropertyAccessStrategy(Class clazz) throws MappingException {\n\t\tfinal PropertyAccessStrategy propertyAccessStrategy = getPropertyAccessStrategy();\n\t\tif ( propertyAccessStrategy != null ) {\n\t\t\treturn propertyAccessStrategy;\n\t\t}\n\t\tString accessName = getPropertyAccessorName();\n\t\tif ( accessName == null ) {\n\t\t\tif ( clazz == null || java.util.Map.class.equals( clazz ) ) {\n\t\t\t\taccessName = \"map\";\n\t\t\t}\n\t\t\telse {\n\t\t\t\taccessName = \"property\";\n\t\t\t}\n\t\t}\n\n\t\tfinal RepresentationMode representationMode = clazz == null || java.util.Map.class.equals( clazz )\n\t\t\t\t? RepresentationMode.MAP\n\t\t\t\t: RepresentationMode.POJO;\n\n\t\treturn resolveServiceRegistry()\n\t\t\t\t.requireService( PropertyAccessStrategyResolver.class )\n\t\t\t\t.resolvePropertyAccessStrategy( clazz, accessName, representationMode );\n\t}\n\n\tServiceRegistry resolveServiceRegistry() {\n\t\tif ( getPersistentClass() != null ) {\n\t\t\treturn getPersistentClass().getServiceRegistry();\n\t\t}\n\t\tif ( getValue() != null ) {\n\t\t\treturn getValue().getServiceRegistry();\n\t\t}\n\t\tthrow new HibernateException( \"Could not resolve ServiceRegistry\" );\n\t}\n\n\tpublic boolean isNaturalIdentifier() {\n\t\treturn naturalIdentifier;\n\t}\n\n\tpublic void setNaturalIdentifier(boolean naturalIdentifier) {\n\t\tthis.naturalIdentifier = naturalIdentifier;\n\t}\n\n\tpublic boolean isGeneric() {\n\t\treturn isGeneric;\n\t}\n\n\tpublic void setGeneric(boolean generic) {\n\t\tthis.isGeneric = generic;\n\t}\n\n\tpublic boolean isLob() {\n\t\treturn lob;\n\t}\n\n\tpublic void setLob(boolean lob) {\n\t\tthis.lob = lob;\n\t}\n\n\tpublic void addCallbackDefinitions(java.util.List<CallbackDefinition> callbackDefinitions) {\n\t\tif ( callbackDefinitions != null && !callbackDefinitions.isEmpty() ) {\n\t\t\tif ( this.callbackDefinitions == null ) {\n\t\t\t\tthis.callbackDefinitions = new ArrayList<>();\n\t\t\t}\n\t\t\tthis.callbackDefinitions.addAll( callbackDefinitions );\n\t\t}\n\t}\n\n\tpublic java.util.List<CallbackDefinition> getCallbackDefinitions() {\n\t\treturn callbackDefinitions == null ? emptyList() : unmodifiableList( callbackDefinitions );\n\t}\n\n\tpublic String getReturnedClassName() {\n\t\treturn returnedClassName;\n\t}\n\n\tpublic void setReturnedClassName(String returnedClassName) {\n\t\tthis.returnedClassName = returnedClassName;\n\t}\n\n\tpublic Generator createGenerator(RuntimeModelCreationContext context) {\n\t\treturn generatorCreator == null ? null :\n\t\t\t\tgeneratorCreator.createGenerator( new PropertyGeneratorCreationContext( context ) );\n\t}\n\n\tpublic Property copy() {\n\t\tfinal Property property = new Property();\n\t\tproperty.setName( getName() );\n\t\tproperty.setValue( getValue() );\n\t\tproperty.setCascade( getCascade() );\n\t\tproperty.setUpdateable( isUpdateable() );\n\t\tproperty.setInsertable( isInsertable() );\n\t\tproperty.setSelectable( isSelectable() );\n\t\tproperty.setOptimisticLocked( isOptimisticLocked() );\n\t\tproperty.setValueGeneratorCreator( getValueGeneratorCreator() );\n\t\tproperty.setPropertyAccessorName( getPropertyAccessorName() );\n\t\tproperty.setPropertyAccessStrategy( getPropertyAccessStrategy() );\n\t\tproperty.setLazy( isLazy() );\n\t\tproperty.setLazyGroup( getLazyGroup() );\n\t\tproperty.setOptional( isOptional() );\n\t\tproperty.setMetaAttributes( getMetaAttributes() );\n\t\tproperty.setPersistentClass( getPersistentClass() );\n\t\tproperty.setNaturalIdentifier( isNaturalIdentifier() );\n\t\tproperty.setGeneric( isGeneric() );\n\t\tproperty.setLob( isLob() );\n\t\tproperty.addCallbackDefinitions( getCallbackDefinitions() );\n\t\tproperty.setReturnedClassName( getReturnedClassName() );\n\t\treturn property;\n\t}\n\n\tprivate class PropertyGeneratorCreationContext implements GeneratorCreationContext {\n\t\tprivate final RuntimeModelCreationContext context;\n\n\t\tpublic PropertyGeneratorCreationContext(RuntimeModelCreationContext context) {\n\t\t\tthis.context = context;\n\t\t}\n\n\t\t@Override\n\t\tpublic Database getDatabase() {\n\t\t\treturn context.getMetadata().getDatabase();\n\t\t}\n\n\t\t@Override\n\t\tpublic ServiceRegistry getServiceRegistry() {\n\t\t\treturn context.getBootstrapContext().getServiceRegistry();\n\t\t}\n\n\t\t@Override\n\t\tpublic String getDefaultCatalog() {\n\t\t\treturn context.getSessionFactoryOptions().getDefaultCatalog();\n\t\t}\n\n\t\t@Override\n\t\tpublic String getDefaultSchema() {\n\t\t\treturn context.getSessionFactoryOptions().getDefaultSchema();\n\t\t}\n\n\t\t@Override\n\t\tpublic PersistentClass getPersistentClass() {\n\t\t\treturn persistentClass;\n\t\t}\n\n\t\t@Override\n\t\tpublic RootClass getRootClass() {\n\t\t\treturn persistentClass.getRootClass();\n\t\t}\n\n\t\t@Override\n\t\tpublic Property getProperty() {\n\t\t\treturn Property.this;\n\t\t}\n\t}\n}\n",
        "diffSourceCodeSet": [
            "private static CascadeStyle getCompositeCascadeStyle(ComponentType compositeType, String cascade) {\n\t\tfinal int length = compositeType.getSubtypes().length;\n\t\tfor ( int i=0; i<length; i++ ) {\n\t\t\tif ( compositeType.getCascadeStyle(i) != CascadeStyles.NONE ) {\n\t\t\t\treturn CascadeStyles.ALL;\n\t\t\t}\n\t\t}\n\t\treturn getCascadeStyle( cascade );\n\t}"
        ],
        "invokedMethodSet": [
            "methodSignature: org.hibernate.type.AbstractType#isAnyType\n methodBody: public boolean isAnyType() {\nreturn false;\n}",
            "methodSignature: org.hibernate.mapping.Property#getCascadeStyle\n methodBody: private static CascadeStyle getCascadeStyle(String cascade) {\nif(cascade == null || cascade.equals(\"none\")){return CascadeStyles.NONE;\n}{final StringTokenizer tokens=new StringTokenizer(cascade,\", \");\nfinal CascadeStyle[] styles=new CascadeStyle[tokens.countTokens()];\nint i=0;\nwhile(tokens.hasMoreTokens()){styles[i++]=CascadeStyles.getCascadeStyle(tokens.nextToken());\n}return new CascadeStyles.MultipleCascadeStyle(styles);\n}}"
        ],
        "sourceCodeAfterRefactoring": "private static CascadeStyle getCompositeCascadeStyle(CompositeType compositeType, String cascade) {\n\t\tif ( compositeType instanceof AnyType ) {\n\t\t\treturn getCascadeStyle( cascade );\n\t\t}\n\t\telse {\n\t\t\treturn getCompositeCascadeStyle( (ComponentType) compositeType, cascade );\n\t\t}\n\t}\nprivate static CascadeStyle getCompositeCascadeStyle(ComponentType compositeType, String cascade) {\n\t\tfinal int length = compositeType.getSubtypes().length;\n\t\tfor ( int i=0; i<length; i++ ) {\n\t\t\tif ( compositeType.getCascadeStyle(i) != CascadeStyles.NONE ) {\n\t\t\t\treturn CascadeStyles.ALL;\n\t\t\t}\n\t\t}\n\t\treturn getCascadeStyle( cascade );\n\t}",
        "diffSourceCode": "-  151: \tprivate static CascadeStyle getCompositeCascadeStyle(CompositeType compositeType, String cascade) {\n-  152: \t\tif ( compositeType.isAnyType() ) {\n-  153: \t\t\treturn getCascadeStyle( cascade );\n+  151: \t\t}\n+  152: \t\telse {\n+  153: \t\t\treturn getCascadeStyle( cascade );\t\t\t\n   154: \t\t}\n-  155: \t\tfinal int length = compositeType.getSubtypes().length;\n-  156: \t\tfor ( int i=0; i<length; i++ ) {\n-  157: \t\t\tif ( compositeType.getCascadeStyle(i) != CascadeStyles.NONE ) {\n-  158: \t\t\t\treturn CascadeStyles.ALL;\n-  159: \t\t\t}\n+  155: \t}\n+  156: \n+  157: \tprivate static CascadeStyle getCompositeCascadeStyle(CompositeType compositeType, String cascade) {\n+  158: \t\tif ( compositeType instanceof AnyType ) {\n+  159: \t\t\treturn getCascadeStyle( cascade );\n   160: \t\t}\n-  161: \t\treturn getCascadeStyle( cascade );\n-  162: \t}\n-  163: \n-  164: \tprivate static CascadeStyle getCollectionCascadeStyle(Type elementType, String cascade) {\n-  166: \t\t\t\t? getCompositeCascadeStyle( (CompositeType) elementType, cascade )\n-  167: \t\t\t\t: getCascadeStyle( cascade );\n-  168: \t}\n-  169: \t\n-  170: \tprivate static CascadeStyle getCascadeStyle(String cascade) {\n-  171: \t\tif ( cascade==null || cascade.equals(\"none\") ) {\n-  172: \t\t\treturn CascadeStyles.NONE;\n-  173: \t\t}\n-  174: \t\telse {\n+  161: \t\telse {\n+  162: \t\t\treturn getCompositeCascadeStyle( (ComponentType) compositeType, cascade );\n+  163: \t\t}\n+  164: \t}\n+  166: \tprivate static CascadeStyle getCompositeCascadeStyle(ComponentType compositeType, String cascade) {\n+  167: \t\tfinal int length = compositeType.getSubtypes().length;\n+  168: \t\tfor ( int i=0; i<length; i++ ) {\n+  169: \t\t\tif ( compositeType.getCascadeStyle(i) != CascadeStyles.NONE ) {\n+  170: \t\t\t\treturn CascadeStyles.ALL;\n+  171: \t\t\t}\n+  172: \t\t}\n+  173: \t\treturn getCascadeStyle( cascade );\n+  174: \t}\n",
        "uniqueId": "94b444b4d8e0ac7ec5817642ca711f626ee327f3_151_162_166_174_157_164",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 0,
                "covered": 27
            },
            "BRANCH": {
                "missed": 0,
                "covered": 6
            },
            "LINE": {
                "missed": 0,
                "covered": 7
            },
            "COMPLEXITY": {
                "missed": 0,
                "covered": 4
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 21
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprivate queryCacheLayout(entityQueryCacheLayout CacheLayout, options SessionFactoryOptions) : CacheLayout extracted from private shouldStoreDiscriminatorInShallowQueryCacheLayout(entityQueryCacheLayout CacheLayout, options SessionFactoryOptions) : boolean in class org.hibernate.persister.entity.AbstractEntityPersister",
        "diffLocations": [
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/persister/entity/AbstractEntityPersister.java",
                "startLine": 920,
                "endLine": 929,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/persister/entity/AbstractEntityPersister.java",
                "startLine": 923,
                "endLine": 926,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/persister/entity/AbstractEntityPersister.java",
                "startLine": 907,
                "endLine": 909,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "private boolean shouldStoreDiscriminatorInShallowQueryCacheLayout(CacheLayout entityQueryCacheLayout, SessionFactoryOptions options) {\n\t\tfinal CacheLayout queryCacheLayout;\n\t\tif ( entityQueryCacheLayout == null ) {\n\t\t\tqueryCacheLayout = options.getQueryCacheLayout();\n\t\t}\n\t\telse {\n\t\t\tqueryCacheLayout = entityQueryCacheLayout;\n\t\t}\n\t\treturn queryCacheLayout == CacheLayout.SHALLOW_WITH_DISCRIMINATOR;\n\t}",
        "filePathBefore": "hibernate-core/src/main/java/org/hibernate/persister/entity/AbstractEntityPersister.java",
        "isPureRefactoring": true,
        "commitId": "afca93158edb43fe886cb68059040f43675e6ec2",
        "packageNameBefore": "org.hibernate.persister.entity",
        "classNameBefore": "org.hibernate.persister.entity.AbstractEntityPersister",
        "methodNameBefore": "org.hibernate.persister.entity.AbstractEntityPersister#shouldStoreDiscriminatorInShallowQueryCacheLayout",
        "classSignatureBefore": "public abstract class AbstractEntityPersister\n\t\timplements EntityPersister, InFlightEntityMappingType, EntityMutationTarget, LazyPropertyInitializer, FetchProfileAffectee, Joinable ",
        "methodNameBeforeSet": [
            "org.hibernate.persister.entity.AbstractEntityPersister#shouldStoreDiscriminatorInShallowQueryCacheLayout"
        ],
        "classNameBeforeSet": [
            "org.hibernate.persister.entity.AbstractEntityPersister"
        ],
        "classSignatureBeforeSet": [
            "public abstract class AbstractEntityPersister\n\t\timplements EntityPersister, InFlightEntityMappingType, EntityMutationTarget, LazyPropertyInitializer, FetchProfileAffectee, Joinable "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Tolerable changes in the body\n",
                "description": "All replacements have been justified - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.\n */\npackage org.hibernate.persister.entity;\n\nimport java.io.Serializable;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.BitSet;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Set;\nimport java.util.SortedMap;\nimport java.util.TreeMap;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.function.BiConsumer;\nimport java.util.function.Consumer;\nimport java.util.function.Supplier;\n\nimport org.hibernate.AssertionFailure;\nimport org.hibernate.FetchMode;\nimport org.hibernate.Filter;\nimport org.hibernate.HibernateException;\nimport org.hibernate.Internal;\nimport org.hibernate.JDBCException;\nimport org.hibernate.LazyInitializationException;\nimport org.hibernate.LockMode;\nimport org.hibernate.LockOptions;\nimport org.hibernate.MappingException;\nimport org.hibernate.PropertyValueException;\nimport org.hibernate.QueryException;\nimport org.hibernate.StaleObjectStateException;\nimport org.hibernate.StaleStateException;\nimport org.hibernate.annotations.CacheLayout;\nimport org.hibernate.boot.Metadata;\nimport org.hibernate.boot.model.internal.SoftDeleteHelper;\nimport org.hibernate.boot.model.relational.SqlStringGenerationContext;\nimport org.hibernate.boot.spi.MetadataImplementor;\nimport org.hibernate.boot.spi.SessionFactoryOptions;\nimport org.hibernate.bytecode.enhance.spi.LazyPropertyInitializer;\nimport org.hibernate.bytecode.enhance.spi.interceptor.BytecodeLazyAttributeInterceptor;\nimport org.hibernate.bytecode.enhance.spi.interceptor.EnhancementAsProxyLazinessInterceptor;\nimport org.hibernate.bytecode.enhance.spi.interceptor.EnhancementHelper;\nimport org.hibernate.bytecode.enhance.spi.interceptor.LazyAttributeDescriptor;\nimport org.hibernate.bytecode.enhance.spi.interceptor.LazyAttributeLoadingInterceptor;\nimport org.hibernate.bytecode.enhance.spi.interceptor.LazyAttributesMetadata;\nimport org.hibernate.bytecode.spi.BytecodeEnhancementMetadata;\nimport org.hibernate.bytecode.spi.ReflectionOptimizer;\nimport org.hibernate.cache.spi.access.EntityDataAccess;\nimport org.hibernate.cache.spi.access.NaturalIdDataAccess;\nimport org.hibernate.cache.spi.entry.CacheEntry;\nimport org.hibernate.cache.spi.entry.CacheEntryStructure;\nimport org.hibernate.cache.spi.entry.ReferenceCacheEntryImpl;\nimport org.hibernate.cache.spi.entry.StandardCacheEntryImpl;\nimport org.hibernate.cache.spi.entry.StructuredCacheEntry;\nimport org.hibernate.cache.spi.entry.UnstructuredCacheEntry;\nimport org.hibernate.classic.Lifecycle;\nimport org.hibernate.collection.spi.PersistentCollection;\nimport org.hibernate.dialect.Dialect;\nimport org.hibernate.dialect.lock.LockingStrategy;\nimport org.hibernate.engine.FetchTiming;\nimport org.hibernate.engine.OptimisticLockStyle;\nimport org.hibernate.engine.internal.CacheHelper;\nimport org.hibernate.engine.internal.ImmutableEntityEntryFactory;\nimport org.hibernate.engine.internal.MutableEntityEntryFactory;\nimport org.hibernate.engine.internal.StatefulPersistenceContext;\nimport org.hibernate.engine.jdbc.spi.JdbcCoordinator;\nimport org.hibernate.engine.profile.internal.FetchProfileAffectee;\nimport org.hibernate.engine.spi.CachedNaturalIdValueSource;\nimport org.hibernate.engine.spi.CascadeStyle;\nimport org.hibernate.engine.spi.CollectionKey;\nimport org.hibernate.engine.spi.EntityEntry;\nimport org.hibernate.engine.spi.EntityEntryFactory;\nimport org.hibernate.engine.spi.EntityHolder;\nimport org.hibernate.engine.spi.EntityKey;\nimport org.hibernate.engine.spi.LoadQueryInfluencers;\nimport org.hibernate.engine.spi.ManagedEntity;\nimport org.hibernate.engine.spi.NaturalIdResolutions;\nimport org.hibernate.engine.spi.PersistenceContext;\nimport org.hibernate.engine.spi.PersistentAttributeInterceptable;\nimport org.hibernate.engine.spi.PersistentAttributeInterceptor;\nimport org.hibernate.engine.spi.SelfDirtinessTracker;\nimport org.hibernate.engine.spi.SessionFactoryImplementor;\nimport org.hibernate.engine.spi.SessionImplementor;\nimport org.hibernate.engine.spi.SharedSessionContractImplementor;\nimport org.hibernate.event.spi.EventSource;\nimport org.hibernate.event.spi.LoadEvent;\nimport org.hibernate.generator.BeforeExecutionGenerator;\nimport org.hibernate.generator.EventType;\nimport org.hibernate.generator.Generator;\nimport org.hibernate.generator.OnExecutionGenerator;\nimport org.hibernate.generator.internal.VersionGeneration;\nimport org.hibernate.generator.values.GeneratedValues;\nimport org.hibernate.generator.values.internal.GeneratedValuesHelper;\nimport org.hibernate.generator.values.GeneratedValuesMutationDelegate;\nimport org.hibernate.graph.spi.RootGraphImplementor;\nimport org.hibernate.id.BulkInsertionCapableIdentifierGenerator;\nimport org.hibernate.id.IdentifierGenerator;\nimport org.hibernate.id.OptimizableGenerator;\nimport org.hibernate.id.enhanced.Optimizer;\nimport org.hibernate.internal.CoreLogging;\nimport org.hibernate.internal.CoreMessageLogger;\nimport org.hibernate.internal.FilterAliasGenerator;\nimport org.hibernate.internal.FilterHelper;\nimport org.hibernate.internal.util.IndexedConsumer;\nimport org.hibernate.internal.util.LazyValue;\nimport org.hibernate.internal.util.StringHelper;\nimport org.hibernate.internal.util.collections.ArrayHelper;\nimport org.hibernate.internal.util.collections.CollectionHelper;\nimport org.hibernate.internal.util.collections.LockModeEnumMap;\nimport org.hibernate.jdbc.Expectation;\nimport org.hibernate.jdbc.TooManyRowsAffectedException;\nimport org.hibernate.loader.ast.internal.CacheEntityLoaderHelper;\nimport org.hibernate.loader.ast.internal.LoaderSelectBuilder;\nimport org.hibernate.loader.ast.internal.LoaderSqlAstCreationState;\nimport org.hibernate.loader.ast.internal.MultiIdEntityLoaderArrayParam;\nimport org.hibernate.loader.ast.internal.MultiIdEntityLoaderStandard;\nimport org.hibernate.loader.ast.internal.SingleIdArrayLoadPlan;\nimport org.hibernate.loader.ast.internal.SingleIdEntityLoaderProvidedQueryImpl;\nimport org.hibernate.loader.ast.internal.SingleIdEntityLoaderStandardImpl;\nimport org.hibernate.loader.ast.internal.SingleUniqueKeyEntityLoaderStandard;\nimport org.hibernate.loader.ast.spi.BatchLoaderFactory;\nimport org.hibernate.loader.ast.spi.MultiIdEntityLoader;\nimport org.hibernate.loader.ast.spi.MultiIdLoadOptions;\nimport org.hibernate.loader.ast.spi.MultiNaturalIdLoader;\nimport org.hibernate.loader.ast.spi.NaturalIdLoader;\nimport org.hibernate.loader.ast.spi.SingleIdEntityLoader;\nimport org.hibernate.loader.ast.spi.SingleUniqueKeyEntityLoader;\nimport org.hibernate.mapping.Any;\nimport org.hibernate.mapping.BasicValue;\nimport org.hibernate.mapping.Column;\nimport org.hibernate.mapping.Component;\nimport org.hibernate.mapping.DependantValue;\nimport org.hibernate.mapping.Formula;\nimport org.hibernate.mapping.Join;\nimport org.hibernate.mapping.PersistentClass;\nimport org.hibernate.mapping.Property;\nimport org.hibernate.mapping.RootClass;\nimport org.hibernate.mapping.Selectable;\nimport org.hibernate.mapping.Subclass;\nimport org.hibernate.mapping.Table;\nimport org.hibernate.mapping.Value;\nimport org.hibernate.metamodel.UnsupportedMappingException;\nimport org.hibernate.metamodel.mapping.Association;\nimport org.hibernate.metamodel.mapping.AttributeMapping;\nimport org.hibernate.metamodel.mapping.AttributeMappingsList;\nimport org.hibernate.metamodel.mapping.AttributeMappingsMap;\nimport org.hibernate.metamodel.mapping.AttributeMetadata;\nimport org.hibernate.metamodel.mapping.DiscriminatorConverter;\nimport org.hibernate.metamodel.mapping.DiscriminatorType;\nimport org.hibernate.metamodel.mapping.EmbeddableValuedModelPart;\nimport org.hibernate.metamodel.mapping.EntityDiscriminatorMapping;\nimport org.hibernate.metamodel.mapping.EntityIdentifierMapping;\nimport org.hibernate.metamodel.mapping.EntityMappingType;\nimport org.hibernate.metamodel.mapping.EntityRowIdMapping;\nimport org.hibernate.metamodel.mapping.EntityVersionMapping;\nimport org.hibernate.metamodel.mapping.ForeignKeyDescriptor;\nimport org.hibernate.metamodel.mapping.JdbcMapping;\nimport org.hibernate.metamodel.mapping.ManagedMappingType;\nimport org.hibernate.metamodel.mapping.MappedDiscriminatorConverter;\nimport org.hibernate.metamodel.mapping.MappingModelHelper;\nimport org.hibernate.metamodel.mapping.ModelPart;\nimport org.hibernate.metamodel.mapping.NaturalIdMapping;\nimport org.hibernate.metamodel.mapping.NonAggregatedIdentifierMapping;\nimport org.hibernate.metamodel.mapping.PluralAttributeMapping;\nimport org.hibernate.metamodel.mapping.SelectableConsumer;\nimport org.hibernate.metamodel.mapping.SelectableMapping;\nimport org.hibernate.metamodel.mapping.SingularAttributeMapping;\nimport org.hibernate.metamodel.mapping.SoftDeleteMapping;\nimport org.hibernate.metamodel.mapping.VirtualModelPart;\nimport org.hibernate.metamodel.mapping.internal.BasicEntityIdentifierMappingImpl;\nimport org.hibernate.metamodel.mapping.internal.CompoundNaturalIdMapping;\nimport org.hibernate.metamodel.mapping.internal.DiscriminatedAssociationAttributeMapping;\nimport org.hibernate.metamodel.mapping.internal.DiscriminatorTypeImpl;\nimport org.hibernate.metamodel.mapping.internal.EmbeddedAttributeMapping;\nimport org.hibernate.loader.ast.internal.EntityConcreteTypeLoader;\nimport org.hibernate.metamodel.mapping.internal.EntityRowIdMappingImpl;\nimport org.hibernate.metamodel.mapping.internal.EntityVersionMappingImpl;\nimport org.hibernate.metamodel.mapping.internal.ExplicitColumnDiscriminatorMappingImpl;\nimport org.hibernate.metamodel.mapping.internal.GeneratedValuesProcessor;\nimport org.hibernate.metamodel.mapping.internal.ImmutableAttributeMappingList;\nimport org.hibernate.metamodel.mapping.internal.InFlightEntityMappingType;\nimport org.hibernate.metamodel.mapping.internal.MappingModelCreationHelper;\nimport org.hibernate.metamodel.mapping.internal.MappingModelCreationProcess;\nimport org.hibernate.metamodel.mapping.internal.SimpleAttributeMetadata;\nimport org.hibernate.metamodel.mapping.internal.SimpleNaturalIdMapping;\nimport org.hibernate.metamodel.model.domain.NavigableRole;\nimport org.hibernate.metamodel.spi.EntityInstantiator;\nimport org.hibernate.metamodel.spi.EntityRepresentationStrategy;\nimport org.hibernate.metamodel.spi.MappingMetamodelImplementor;\nimport org.hibernate.metamodel.spi.RuntimeModelCreationContext;\nimport org.hibernate.persister.collection.CollectionPersister;\nimport org.hibernate.persister.entity.mutation.DeleteCoordinator;\nimport org.hibernate.persister.entity.mutation.DeleteCoordinatorSoft;\nimport org.hibernate.persister.entity.mutation.DeleteCoordinatorStandard;\nimport org.hibernate.persister.entity.mutation.EntityMutationTarget;\nimport org.hibernate.persister.entity.mutation.EntityTableMapping;\nimport org.hibernate.persister.entity.mutation.InsertCoordinator;\nimport org.hibernate.persister.entity.mutation.InsertCoordinatorStandard;\nimport org.hibernate.persister.entity.mutation.MergeCoordinator;\nimport org.hibernate.persister.entity.mutation.UpdateCoordinator;\nimport org.hibernate.persister.entity.mutation.UpdateCoordinatorNoOp;\nimport org.hibernate.persister.entity.mutation.UpdateCoordinatorStandard;\nimport org.hibernate.persister.internal.SqlFragmentPredicate;\nimport org.hibernate.property.access.spi.Getter;\nimport org.hibernate.property.access.spi.PropertyAccess;\nimport org.hibernate.property.access.spi.Setter;\nimport org.hibernate.query.PathException;\nimport org.hibernate.query.named.NamedQueryMemento;\nimport org.hibernate.query.spi.QueryOptions;\nimport org.hibernate.query.sql.internal.SQLQueryParser;\nimport org.hibernate.query.sqm.ComparisonOperator;\nimport org.hibernate.query.sqm.function.SqmFunctionRegistry;\nimport org.hibernate.query.sqm.mutation.spi.SqmMultiTableInsertStrategy;\nimport org.hibernate.query.sqm.mutation.spi.SqmMultiTableMutationStrategy;\nimport org.hibernate.query.sqm.mutation.spi.SqmMultiTableMutationStrategyProvider;\nimport org.hibernate.service.ServiceRegistry;\nimport org.hibernate.spi.NavigablePath;\nimport org.hibernate.sql.Alias;\nimport org.hibernate.sql.InFragment;\nimport org.hibernate.sql.SimpleSelect;\nimport org.hibernate.sql.Template;\nimport org.hibernate.sql.ast.spi.SimpleFromClauseAccessImpl;\nimport org.hibernate.sql.ast.spi.SqlAliasBase;\nimport org.hibernate.sql.ast.spi.SqlAliasBaseConstant;\nimport org.hibernate.sql.ast.spi.SqlAliasBaseManager;\nimport org.hibernate.sql.ast.spi.SqlAliasStemHelper;\nimport org.hibernate.sql.ast.spi.SqlAstCreationState;\nimport org.hibernate.sql.ast.spi.SqlExpressionResolver;\nimport org.hibernate.sql.ast.spi.SqlSelection;\nimport org.hibernate.sql.ast.tree.expression.AliasedExpression;\nimport org.hibernate.sql.ast.tree.expression.ColumnReference;\nimport org.hibernate.sql.ast.tree.expression.Expression;\nimport org.hibernate.sql.ast.tree.expression.QueryLiteral;\nimport org.hibernate.sql.ast.tree.from.NamedTableReference;\nimport org.hibernate.sql.ast.tree.from.StandardTableGroup;\nimport org.hibernate.sql.ast.tree.from.TableGroup;\nimport org.hibernate.sql.ast.tree.from.TableReference;\nimport org.hibernate.sql.ast.tree.from.TableReferenceJoin;\nimport org.hibernate.sql.ast.tree.predicate.ComparisonPredicate;\nimport org.hibernate.sql.ast.tree.predicate.InListPredicate;\nimport org.hibernate.sql.ast.tree.predicate.Junction;\nimport org.hibernate.sql.ast.tree.predicate.NegatedPredicate;\nimport org.hibernate.sql.ast.tree.predicate.NullnessPredicate;\nimport org.hibernate.sql.ast.tree.predicate.Predicate;\nimport org.hibernate.sql.ast.tree.select.QuerySpec;\nimport org.hibernate.sql.ast.tree.select.SelectClause;\nimport org.hibernate.sql.ast.tree.select.SelectStatement;\nimport org.hibernate.sql.exec.spi.JdbcOperation;\nimport org.hibernate.sql.exec.spi.JdbcParametersList;\nimport org.hibernate.sql.model.MutationOperation;\nimport org.hibernate.sql.model.MutationOperationGroup;\nimport org.hibernate.sql.model.ast.builder.MutationGroupBuilder;\nimport org.hibernate.sql.model.ast.builder.TableInsertBuilder;\nimport org.hibernate.sql.results.graph.DomainResult;\nimport org.hibernate.sql.results.graph.DomainResultCreationState;\nimport org.hibernate.sql.results.graph.Fetch;\nimport org.hibernate.sql.results.graph.FetchParent;\nimport org.hibernate.sql.results.graph.Fetchable;\nimport org.hibernate.sql.results.graph.FetchableContainer;\nimport org.hibernate.sql.results.graph.entity.internal.EntityResultImpl;\nimport org.hibernate.sql.results.graph.internal.ImmutableFetchList;\nimport org.hibernate.sql.results.internal.SqlSelectionImpl;\nimport org.hibernate.stat.spi.StatisticsImplementor;\nimport org.hibernate.tuple.NonIdentifierAttribute;\nimport org.hibernate.tuple.entity.EntityMetamodel;\nimport org.hibernate.type.AnyType;\nimport org.hibernate.type.AssociationType;\nimport org.hibernate.type.BasicType;\nimport org.hibernate.type.CollectionType;\nimport org.hibernate.type.CompositeType;\nimport org.hibernate.type.EntityType;\nimport org.hibernate.type.Type;\nimport org.hibernate.type.descriptor.java.JavaType;\nimport org.hibernate.type.descriptor.java.MutabilityPlan;\nimport org.hibernate.type.descriptor.java.spi.JavaTypeRegistry;\nimport org.hibernate.type.spi.TypeConfiguration;\n\nimport org.checkerframework.checker.nullness.qual.Nullable;\n\nimport static java.util.Collections.emptyList;\nimport static java.util.Collections.emptyMap;\nimport static java.util.Collections.emptySet;\nimport static org.hibernate.engine.internal.ManagedTypeHelper.asPersistentAttributeInterceptable;\nimport static org.hibernate.engine.internal.ManagedTypeHelper.isPersistentAttributeInterceptable;\nimport static org.hibernate.engine.internal.ManagedTypeHelper.processIfManagedEntity;\nimport static org.hibernate.engine.internal.ManagedTypeHelper.processIfPersistentAttributeInterceptable;\nimport static org.hibernate.engine.internal.ManagedTypeHelper.processIfSelfDirtinessTracker;\nimport static org.hibernate.generator.EventType.INSERT;\nimport static org.hibernate.generator.EventType.UPDATE;\nimport static org.hibernate.internal.util.ReflectHelper.isAbstractClass;\nimport static org.hibernate.internal.util.StringHelper.isEmpty;\nimport static org.hibernate.internal.util.StringHelper.qualifyConditionally;\nimport static org.hibernate.internal.util.collections.ArrayHelper.contains;\nimport static org.hibernate.internal.util.collections.ArrayHelper.to2DStringArray;\nimport static org.hibernate.internal.util.collections.ArrayHelper.toIntArray;\nimport static org.hibernate.internal.util.collections.ArrayHelper.toObjectArray;\nimport static org.hibernate.internal.util.collections.ArrayHelper.toStringArray;\nimport static org.hibernate.internal.util.collections.ArrayHelper.toTypeArray;\nimport static org.hibernate.internal.util.collections.CollectionHelper.combine;\nimport static org.hibernate.internal.util.collections.CollectionHelper.isNotEmpty;\nimport static org.hibernate.internal.util.collections.CollectionHelper.setOfSize;\nimport static org.hibernate.loader.ast.internal.MultiKeyLoadHelper.supportsSqlArrayType;\nimport static org.hibernate.metamodel.RepresentationMode.POJO;\nimport static org.hibernate.persister.entity.DiscriminatorHelper.NOT_NULL_DISCRIMINATOR;\nimport static org.hibernate.persister.entity.DiscriminatorHelper.NULL_DISCRIMINATOR;\nimport static org.hibernate.pretty.MessageHelper.infoString;\nimport static org.hibernate.sql.ast.spi.SqlExpressionResolver.createColumnReferenceKey;\n\n/**\n * Basic functionality for persisting an entity via JDBC, using either generated or custom SQL.\n *\n * @author Gavin King\n */\n@Internal\n@SuppressWarnings(\"deprecation\")\npublic abstract class AbstractEntityPersister\n\t\timplements EntityPersister, InFlightEntityMappingType, EntityMutationTarget, LazyPropertyInitializer, FetchProfileAffectee, Joinable {\n\n\tprivate static final CoreMessageLogger LOG = CoreLogging.messageLogger( AbstractEntityPersister.class );\n\n\tpublic static final String ENTITY_CLASS = \"class\";\n\tpublic static final String VERSION_COLUMN_ALIAS = \"version_\";\n\tpublic static final String ROWID_ALIAS = \"rowid_\";\n\n\tprivate final NavigableRole navigableRole;\n\tprivate final SessionFactoryImplementor factory;\n\tprivate final EntityEntryFactory entityEntryFactory;\n\n\tprivate final String sqlAliasStem;\n\n\tprivate SingleIdEntityLoader<?> singleIdLoader;\n\tprivate MultiIdEntityLoader<?> multiIdLoader;\n\tprivate NaturalIdLoader<?> naturalIdLoader;\n\tprivate MultiNaturalIdLoader<?> multiNaturalIdLoader;\n\n\tprivate final String[] rootTableKeyColumnNames;\n\tprivate final String[] rootTableKeyColumnReaders;\n\tprivate final String[] rootTableKeyColumnReaderTemplates;\n\tprivate final String[] identifierAliases;\n\tprivate final int identifierColumnSpan;\n\tprivate final String versionColumnName;\n\tprivate final boolean hasFormulaProperties;\n\tprotected final int batchSize;\n\tprivate final boolean hasSubselectLoadableCollections;\n\tprivate final boolean hasPartitionedSelectionMapping;\n\tprivate final boolean hasCollectionNotReferencingPK;\n\tprotected final String rowIdName;\n\n\t// The optional SQL string defined in the where attribute\n\tprivate final String sqlWhereStringTableExpression;\n\tprivate final String sqlWhereStringTemplate;\n\n\t//information about properties of this class,\n\t//including inherited properties\n\t//(only really needed for updatable/insertable properties)\n\tprivate final String[][] propertyColumnAliases;\n\tprivate final String[][] propertyColumnNames;\n\tprivate final String[][] propertyColumnFormulaTemplates;\n\tprivate final boolean[][] propertyColumnUpdateable;\n\tprivate final boolean[][] propertyColumnInsertable;\n\tprivate final Set<String> sharedColumnNames;\n\n\t//information about lazy properties of this class\n\tprivate final String[] lazyPropertyNames;\n\tprivate final int[] lazyPropertyNumbers;\n\tprivate final Type[] lazyPropertyTypes;\n\n\t//information about all properties in class hierarchy\n\tprivate final String[] subclassPropertyNameClosure;\n\tprivate final Type[] subclassPropertyTypeClosure;\n\tprivate final String[][] subclassPropertyFormulaTemplateClosure;\n\tprivate final String[][] subclassPropertyColumnNameClosure;\n\tprivate final String[][] subclassPropertyColumnReaderClosure;\n\tprivate final String[][] subclassPropertyColumnReaderTemplateClosure;\n\tprivate final FetchMode[] subclassPropertyFetchModeClosure;\n\n\tprivate Map<String, SingleIdArrayLoadPlan> lazyLoadPlanByFetchGroup;\n\tprivate final LockModeEnumMap<LockingStrategy> lockers = new LockModeEnumMap<>();\n\tprivate String sqlVersionSelectString;\n\n\tprivate EntityTableMapping[] tableMappings;\n\tprivate InsertCoordinator insertCoordinator;\n\tprivate UpdateCoordinator updateCoordinator;\n\tprivate DeleteCoordinator deleteCoordinator;\n\tprivate UpdateCoordinator mergeCoordinator;\n\n\tprivate SqmMultiTableMutationStrategy sqmMultiTableMutationStrategy;\n\tprivate SqmMultiTableInsertStrategy sqmMultiTableInsertStrategy;\n\n\tprivate final EntityDataAccess cacheAccessStrategy;\n\tprivate final NaturalIdDataAccess naturalIdRegionAccessStrategy;\n\tprivate final CacheEntryHelper cacheEntryHelper;\n\tprivate final boolean canReadFromCache;\n\tprivate final boolean canWriteToCache;\n\tprivate final boolean invalidateCache;\n\tprivate final boolean isLazyPropertiesCacheable;\n\tprivate final boolean useReferenceCacheEntries;\n\tprivate final boolean useShallowQueryCacheLayout;\n\tprivate final boolean storeDiscriminatorInShallowQueryCacheLayout;\n\n\t// dynamic filters attached to the class-level\n\tprivate final FilterHelper filterHelper;\n\tprivate volatile Set<String> affectingFetchProfileNames;\n\n\tprotected List<? extends ModelPart> insertGeneratedProperties;\n\tprotected List<? extends ModelPart> updateGeneratedProperties;\n\tprivate GeneratedValuesProcessor insertGeneratedValuesProcessor;\n\tprivate GeneratedValuesProcessor updateGeneratedValuesProcessor;\n\n\tprivate GeneratedValuesMutationDelegate insertDelegate;\n\tprivate GeneratedValuesMutationDelegate updateDelegate;\n\tprivate String identitySelectString;\n\n\tprivate final JavaType<?> javaType;\n\tprivate final EntityRepresentationStrategy representationStrategy;\n\n\tprivate EntityMappingType superMappingType;\n\tprivate SortedMap<String, EntityMappingType> subclassMappingTypes;\n\tprivate final boolean concreteProxy;\n\tprivate EntityConcreteTypeLoader concreteTypeLoader;\n\n\tprivate EntityIdentifierMapping identifierMapping;\n\tprivate NaturalIdMapping naturalIdMapping;\n\tprivate EntityVersionMapping versionMapping;\n\tprivate EntityRowIdMapping rowIdMapping;\n\tprivate EntityDiscriminatorMapping discriminatorMapping;\n\tprivate SoftDeleteMapping softDeleteMapping;\n\n\tprivate AttributeMappingsList attributeMappings;\n\tprotected AttributeMappingsMap declaredAttributeMappings = AttributeMappingsMap.builder().build();\n\tprotected AttributeMappingsList staticFetchableList;\n\t// We build a cache for getters and setters to avoid megamorphic calls\n\tprivate Getter[] getterCache;\n\tprivate Setter[] setterCache;\n\n\tprivate final String queryLoaderName;\n\n\tprivate BeforeExecutionGenerator versionGenerator;\n\n\tprotected ReflectionOptimizer.AccessOptimizer accessOptimizer;\n\n\tprotected final String[] fullDiscriminatorSQLValues;\n\tprivate final Object[] fullDiscriminatorValues;\n\n\t/**\n\t * Warning:\n\t * When there are duplicated property names in the subclasses\n\t * then propertyMapping will only contain one of those properties.\n\t * To ensure correct results, propertyMapping should only be used\n\t * for the concrete EntityPersister (since the concrete EntityPersister\n\t * cannot have duplicated property names).\n\t */\n\tprivate final EntityPropertyMapping propertyMapping;\n\n\tprivate final boolean implementsLifecycle;\n\n\tprivate List<UniqueKeyEntry> uniqueKeyEntries = null; //lazily initialized\n\n\tpublic AbstractEntityPersister(\n\t\t\tfinal PersistentClass persistentClass,\n\t\t\tfinal EntityDataAccess cacheAccessStrategy,\n\t\t\tfinal NaturalIdDataAccess naturalIdRegionAccessStrategy,\n\t\t\tfinal RuntimeModelCreationContext creationContext) throws HibernateException {\n\n\t\t//set it here, but don't call it, since it's still uninitialized!\n\t\tfactory = creationContext.getSessionFactory();\n\n\t\tsqlAliasStem = SqlAliasStemHelper.INSTANCE.generateStemFromEntityName( persistentClass.getEntityName() );\n\n\t\tnavigableRole = new NavigableRole( persistentClass.getEntityName() );\n\n\t\tfinal SessionFactoryOptions sessionFactoryOptions = creationContext.getSessionFactoryOptions();\n\n\t\tif ( sessionFactoryOptions.isSecondLevelCacheEnabled() ) {\n\t\t\tthis.cacheAccessStrategy = cacheAccessStrategy;\n\t\t\tthis.naturalIdRegionAccessStrategy = naturalIdRegionAccessStrategy;\n\t\t\tcanWriteToCache = determineCanWriteToCache( persistentClass, cacheAccessStrategy );\n\t\t\tcanReadFromCache = determineCanReadFromCache( persistentClass, cacheAccessStrategy );\n\t\t\tisLazyPropertiesCacheable = persistentClass.getRootClass().isLazyPropertiesCacheable();\n\t\t}\n\t\telse {\n\t\t\tthis.cacheAccessStrategy = null;\n\t\t\tthis.naturalIdRegionAccessStrategy = null;\n\t\t\tcanWriteToCache = false;\n\t\t\tcanReadFromCache = false;\n\t\t\tisLazyPropertiesCacheable = true;\n\t\t}\n\n\t\tentityMetamodel = new EntityMetamodel( persistentClass, this, creationContext );\n\n\t\tentityEntryFactory = entityMetamodel.isMutable()\n\t\t\t\t? MutableEntityEntryFactory.INSTANCE\n\t\t\t\t: ImmutableEntityEntryFactory.INSTANCE;\n\n\t\t// Handle any filters applied to the class level\n\t\tfilterHelper = isNotEmpty( persistentClass.getFilters() ) ? new FilterHelper(\n\t\t\t\tpersistentClass.getFilters(),\n\t\t\t\tgetEntityNameByTableNameMap(\n\t\t\t\t\t\tpersistentClass,\n\t\t\t\t\t\tfactory.getSqlStringGenerationContext()\n\t\t\t\t),\n\t\t\t\tfactory\n\t\t) : null;\n\n\t\t// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n\t\trepresentationStrategy = creationContext.getBootstrapContext().getRepresentationStrategySelector()\n\t\t\t\t.resolveStrategy( persistentClass, this, creationContext );\n\n\t\tjavaType = representationStrategy.getLoadJavaType();\n\t\tassert javaType != null;\n\t\tthis.implementsLifecycle = Lifecycle.class.isAssignableFrom( javaType.getJavaTypeClass() );\n\n\t\tconcreteProxy = entityMetamodel.isPolymorphic()\n\t\t\t\t&& ( getBytecodeEnhancementMetadata().isEnhancedForLazyLoading() || hasProxy() )\n\t\t\t\t&& persistentClass.isConcreteProxy();\n\n\t\tfinal Dialect dialect = creationContext.getDialect();\n\n\t\tbatchSize = persistentClass.getBatchSize() < 0\n\t\t\t\t? factory.getSessionFactoryOptions().getDefaultBatchFetchSize()\n\t\t\t\t: persistentClass.getBatchSize();\n\t\thasSubselectLoadableCollections = persistentClass.hasSubselectLoadableCollections();\n\t\thasPartitionedSelectionMapping = persistentClass.hasPartitionedSelectionMapping();\n\t\thasCollectionNotReferencingPK = persistentClass.hasCollectionNotReferencingPK();\n\n\t\tpropertyMapping = new EntityPropertyMapping( this );\n\n\t\t// IDENTIFIER\n\n\t\tidentifierColumnSpan = persistentClass.getIdentifier().getColumnSpan();\n\t\trootTableKeyColumnNames = new String[identifierColumnSpan];\n\t\trootTableKeyColumnReaders = new String[identifierColumnSpan];\n\t\trootTableKeyColumnReaderTemplates = new String[identifierColumnSpan];\n\t\tidentifierAliases = new String[identifierColumnSpan];\n\n\t\tfinal String rowId = persistentClass.getRootTable().getRowId();\n\t\trowIdName = rowId == null ? null : dialect.rowId( rowId );\n\n\t\tqueryLoaderName = persistentClass.getLoaderName();\n\n\t\tfinal TypeConfiguration typeConfiguration = creationContext.getTypeConfiguration();\n\t\tfinal SqmFunctionRegistry functionRegistry = creationContext.getFunctionRegistry();\n\n\t\tList<Column> columns = persistentClass.getIdentifier().getColumns();\n\t\tfor (int i = 0; i < columns.size(); i++ ) {\n\t\t\tColumn column = columns.get(i);\n\t\t\trootTableKeyColumnNames[i] = column.getQuotedName( dialect );\n\t\t\trootTableKeyColumnReaders[i] = column.getReadExpr( dialect );\n\t\t\trootTableKeyColumnReaderTemplates[i] = column.getTemplate(\n\t\t\t\t\tdialect,\n\t\t\t\t\ttypeConfiguration,\n\t\t\t\t\tfunctionRegistry\n\t\t\t);\n\t\t\tidentifierAliases[i] = column.getAlias( dialect, persistentClass.getRootTable() );\n\t\t}\n\n\t\t// VERSION\n\n\t\tversionColumnName = persistentClass.isVersioned()\n\t\t\t\t? persistentClass.getVersion().getColumns().get(0).getQuotedName( dialect )\n\t\t\t\t: null;\n\n\t\t//WHERE STRING\n\n\t\tif ( isEmpty( persistentClass.getWhere() ) ) {\n\t\t\tsqlWhereStringTableExpression = null;\n\t\t\tsqlWhereStringTemplate = null;\n\t\t}\n\t\telse {\n\t\t\tPersistentClass containingClass = persistentClass;\n\t\t\twhile ( containingClass.getSuperclass() != null ) {\n\t\t\t\tfinal PersistentClass superclass = containingClass.getSuperclass();\n\t\t\t\tif ( !Objects.equals( persistentClass.getWhere(), superclass.getWhere() ) ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcontainingClass = superclass;\n\t\t\t}\n\t\t\tsqlWhereStringTableExpression = determineTableName( containingClass.getTable() );\n\t\t\tsqlWhereStringTemplate = Template.renderWhereStringTemplate(\n\t\t\t\t\t\"(\" + persistentClass.getWhere() + \")\",\n\t\t\t\t\tdialect,\n\t\t\t\t\ttypeConfiguration,\n\t\t\t\t\tfunctionRegistry\n\t\t\t);\n\t\t}\n\n\t\t// PROPERTIES\n\t\tfinal int hydrateSpan = entityMetamodel.getPropertySpan();\n\t\tpropertyColumnAliases = new String[hydrateSpan][];\n\t\tpropertyColumnNames = new String[hydrateSpan][];\n\t\tpropertyColumnFormulaTemplates = new String[hydrateSpan][];\n\t\tpropertyColumnUpdateable = new boolean[hydrateSpan][];\n\t\tpropertyColumnInsertable = new boolean[hydrateSpan][];\n\t\tsharedColumnNames = new HashSet<>();\n\n\t\tfinal HashSet<Property> thisClassProperties = new HashSet<>();\n\t\tfinal ArrayList<String> lazyNames = new ArrayList<>();\n\t\tfinal ArrayList<Integer> lazyNumbers = new ArrayList<>();\n\t\tfinal ArrayList<Type> lazyTypes = new ArrayList<>();\n\n\t\tfinal List<Property> propertyClosure = persistentClass.getPropertyClosure();\n\t\tboolean foundFormula = false;\n\t\tfor ( int i = 0; i < propertyClosure.size(); i++ ) {\n\t\t\tfinal Property prop = propertyClosure.get(i);\n\t\t\tthisClassProperties.add( prop );\n\n\t\t\tfinal int span = prop.getColumnSpan();\n\t\t\tfinal String[] colNames = new String[span];\n\t\t\tfinal String[] colAliases = new String[span];\n\t\t\tfinal String[] formulaTemplates = new String[span];\n\t\t\tfinal List<Selectable> selectables = prop.getSelectables();\n\t\t\tfor ( int k = 0; k < selectables.size(); k++ ) {\n\t\t\t\tfinal Selectable selectable = selectables.get(k);\n\t\t\t\tcolAliases[k] = selectable.getAlias( dialect, prop.getValue().getTable() );\n\t\t\t\tif ( selectable.isFormula() ) {\n\t\t\t\t\tfoundFormula = true;\n\t\t\t\t\tfinal Formula formula = (Formula) selectable;\n\t\t\t\t\tformula.setFormula( substituteBrackets( formula.getFormula() ) );\n\t\t\t\t\tformulaTemplates[k] = selectable.getTemplate(\n\t\t\t\t\t\t\tdialect,\n\t\t\t\t\t\t\ttypeConfiguration,\n\t\t\t\t\t\t\tfunctionRegistry\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tfinal Column column = (Column) selectable;\n\t\t\t\t\tcolNames[k] = column.getQuotedName( dialect );\n\t\t\t\t}\n\t\t\t}\n\t\t\tpropertyColumnNames[i] = colNames;\n\t\t\tpropertyColumnFormulaTemplates[i] = formulaTemplates;\n\t\t\tpropertyColumnAliases[i] = colAliases;\n\n\t\t\tfinal boolean lazy = !EnhancementHelper.includeInBaseFetchGroup(\n\t\t\t\t\tprop,\n\t\t\t\t\tentityMetamodel.isInstrumented(),\n\t\t\t\t\tentityName -> {\n\t\t\t\t\t\tfinal PersistentClass entityBinding = creationContext\n\t\t\t\t\t\t\t\t.getMetadata()\n\t\t\t\t\t\t\t\t.getEntityBinding( entityName );\n\t\t\t\t\t\tassert entityBinding != null;\n\t\t\t\t\t\treturn entityBinding.hasSubclasses();\n\t\t\t\t\t},\n\t\t\t\t\tsessionFactoryOptions.isCollectionsInDefaultFetchGroupEnabled()\n\t\t\t);\n\n\t\t\tif ( lazy ) {\n\t\t\t\tlazyNames.add( prop.getName() );\n\t\t\t\tlazyNumbers.add( i );\n\t\t\t\tlazyTypes.add( prop.getValue().getType() );\n\t\t\t}\n\n\t\t\tpropertyColumnUpdateable[i] = prop.getValue().getColumnUpdateability();\n\t\t\tpropertyColumnInsertable[i] = prop.getValue().getColumnInsertability();\n\t\t}\n\t\thasFormulaProperties = foundFormula;\n\t\tlazyPropertyNames = toStringArray( lazyNames );\n\t\tlazyPropertyNumbers = toIntArray( lazyNumbers );\n\t\tlazyPropertyTypes = toTypeArray( lazyTypes );\n\n\t\t// SUBCLASS PROPERTY CLOSURE\n\t\tfinal ArrayList<String> aliases = new ArrayList<>();\n\t\tfinal ArrayList<String> formulaAliases = new ArrayList<>();\n\t\tfinal ArrayList<Type> types = new ArrayList<>();\n\t\tfinal ArrayList<String> names = new ArrayList<>();\n\t\tfinal ArrayList<String[]> templates = new ArrayList<>();\n\t\tfinal ArrayList<String[]> propColumns = new ArrayList<>();\n\t\tfinal ArrayList<String[]> propColumnReaders = new ArrayList<>();\n\t\tfinal ArrayList<String[]> propColumnReaderTemplates = new ArrayList<>();\n\t\tfinal ArrayList<FetchMode> joinedFetchesList = new ArrayList<>();\n\n\t\tfor ( Property prop : persistentClass.getSubclassPropertyClosure() ) {\n\t\t\tnames.add( prop.getName() );\n\t\t\ttypes.add( prop.getType() );\n\n\t\t\tfinal String[] cols = new String[ prop.getColumnSpan() ];\n\t\t\tfinal String[] readers = new String[ prop.getColumnSpan() ];\n\t\t\tfinal String[] readerTemplates = new String[ prop.getColumnSpan() ];\n\t\t\tfinal String[] forms = new String[ prop.getColumnSpan() ];\n\n\t\t\tfinal List<Selectable> selectables = prop.getSelectables();\n\t\t\tfor ( int i = 0; i < selectables.size(); i++ ) {\n\t\t\t\tfinal Selectable selectable = selectables.get(i);\n\t\t\t\tif ( selectable.isFormula() ) {\n\t\t\t\t\tfinal String template = selectable.getTemplate(\n\t\t\t\t\t\t\tdialect,\n\t\t\t\t\t\t\ttypeConfiguration,\n\t\t\t\t\t\t\tfunctionRegistry\n\t\t\t\t\t);\n\t\t\t\t\tforms[i] = template;\n\t\t\t\t\tfinal String formulaAlias = selectable.getAlias( dialect );\n\t\t\t\t\tif ( prop.isSelectable() && !formulaAliases.contains( formulaAlias ) ) {\n\t\t\t\t\t\tformulaAliases.add( formulaAlias );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tfinal Column column = (Column) selectable;\n\t\t\t\t\tfinal String colName = column.getQuotedName(dialect);\n\t\t\t\t\tcols[i] = colName;\n\t\t\t\t\tfinal String columnAlias = selectable.getAlias( dialect, prop.getValue().getTable() );\n\t\t\t\t\tif ( prop.isSelectable() && !aliases.contains( columnAlias ) ) {\n\t\t\t\t\t\taliases.add( columnAlias );\n\t\t\t\t\t}\n\n\t\t\t\t\treaders[i] = column.getReadExpr( dialect );\n\t\t\t\t\treaderTemplates[i] = column.getTemplate(\n\t\t\t\t\t\t\tdialect,\n\t\t\t\t\t\t\ttypeConfiguration,\n\t\t\t\t\t\t\tfunctionRegistry\n\t\t\t\t\t);\n\t\t\t\t\tif ( thisClassProperties.contains( prop )\n\t\t\t\t\t\t\t? persistentClass.hasSubclasses()\n\t\t\t\t\t\t\t: persistentClass.isDefinedOnMultipleSubclasses( column ) ) {\n\t\t\t\t\t\tsharedColumnNames.add( colName );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tpropColumns.add( cols );\n\t\t\tpropColumnReaders.add( readers );\n\t\t\tpropColumnReaderTemplates.add( readerTemplates );\n\t\t\ttemplates.add( forms );\n\n\t\t\tjoinedFetchesList.add( prop.getValue().getFetchMode() );\n\t\t}\n\t\tsubclassColumnAliasClosure = toStringArray( aliases );\n\t\tsubclassFormulaAliasClosure = toStringArray( formulaAliases );\n\n\t\tsubclassPropertyNameClosure = toStringArray( names );\n\t\tsubclassPropertyTypeClosure = toTypeArray( types );\n\t\tsubclassPropertyFormulaTemplateClosure = to2DStringArray( templates );\n\t\tsubclassPropertyColumnNameClosure = to2DStringArray( propColumns );\n\t\tsubclassPropertyColumnReaderClosure = to2DStringArray( propColumnReaders );\n\t\tsubclassPropertyColumnReaderTemplateClosure = to2DStringArray( propColumnReaderTemplates );\n\n\t\tsubclassPropertyFetchModeClosure = new FetchMode[joinedFetchesList.size()];\n\t\tint j = 0;\n\t\tfor (FetchMode fetchMode : joinedFetchesList) {\n\t\t\tsubclassPropertyFetchModeClosure[j++] = fetchMode;\n\t\t}\n\n\t\tuseReferenceCacheEntries = shouldUseReferenceCacheEntries( creationContext.getSessionFactoryOptions() );\n\t\tuseShallowQueryCacheLayout = shouldUseShallowCacheLayout(\n\t\t\t\tpersistentClass.getQueryCacheLayout(),\n\t\t\t\tcreationContext.getSessionFactoryOptions()\n\t\t);\n\t\tstoreDiscriminatorInShallowQueryCacheLayout = shouldStoreDiscriminatorInShallowQueryCacheLayout(\n\t\t\t\tpersistentClass.getQueryCacheLayout(),\n\t\t\t\tcreationContext.getSessionFactoryOptions()\n\t\t);\n\t\tcacheEntryHelper = buildCacheEntryHelper( creationContext.getSessionFactoryOptions() );\n\t\tinvalidateCache = sessionFactoryOptions.isSecondLevelCacheEnabled()\n\t\t\t\t&& canWriteToCache\n\t\t\t\t&& shouldInvalidateCache( persistentClass, creationContext );\n\n\t\tfinal List<Object> values = new ArrayList<>();\n\t\tfinal List<String> sqlValues = new ArrayList<>();\n\n\t\tif ( persistentClass.isPolymorphic() && persistentClass.getDiscriminator() != null ) {\n\t\t\tif ( !getEntityMetamodel().isAbstract() ) {\n\t\t\t\tvalues.add( DiscriminatorHelper.getDiscriminatorValue( persistentClass ) );\n\t\t\t\tsqlValues.add( DiscriminatorHelper.getDiscriminatorSQLValue( persistentClass, dialect ) );\n\t\t\t}\n\n\t\t\tfinal List<Subclass> subclasses = persistentClass.getSubclasses();\n\t\t\tfor ( int k = 0; k < subclasses.size(); k++ ) {\n\t\t\t\tfinal Subclass subclass = subclasses.get( k );\n\t\t\t\t//copy/paste from EntityMetamodel:\n\t\t\t\tif ( !isAbstract( subclass ) ) {\n\t\t\t\t\tvalues.add( DiscriminatorHelper.getDiscriminatorValue( subclass ) );\n\t\t\t\t\tsqlValues.add( DiscriminatorHelper.getDiscriminatorSQLValue( subclass, dialect ) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfullDiscriminatorSQLValues = toStringArray( sqlValues );\n\t\tfullDiscriminatorValues = toObjectArray( values );\n\n\t\tif ( hasNamedQueryLoader() ) {\n\t\t\tgetNamedQueryMemento( creationContext.getBootModel() );\n\t\t}\n\t}\n\n\tprivate NamedQueryMemento<?> getNamedQueryMemento(MetadataImplementor bootModel) {\n\t\tfinal NamedQueryMemento<?> memento =\n\t\t\t\tfactory.getQueryEngine().getNamedObjectRepository()\n\t\t\t\t\t\t.resolve( factory, bootModel, queryLoaderName );\n\t\tif ( memento == null ) {\n\t\t\tthrow new IllegalArgumentException( \"Could not resolve named query '\" + queryLoaderName\n\t\t\t\t\t+ \"' for loading entity '\" + getEntityName() + \"'\" );\n\t\t}\n\t\treturn memento;\n\t}\n\n\t/**\n\t * For Hibernate Reactive\n\t */\n\tprotected SingleIdEntityLoader<?> buildSingleIdEntityLoader() {\n\t\tif ( hasNamedQueryLoader() ) {\n\t\t\t// We must resolve the named query on-demand through the boot model because it isn't initialized yet\n\t\t\tfinal NamedQueryMemento<?> memento = getNamedQueryMemento( null );\n\t\t\treturn new SingleIdEntityLoaderProvidedQueryImpl<>( this, memento );\n\t\t}\n\t\treturn buildSingleIdEntityLoader( new LoadQueryInfluencers( factory ) );\n\t}\n\n\tprivate SingleIdEntityLoader<?> buildSingleIdEntityLoader(LoadQueryInfluencers loadQueryInfluencers) {\n\t\tif ( loadQueryInfluencers.effectivelyBatchLoadable( this ) ) {\n\t\t\tfinal int batchSize = loadQueryInfluencers.effectiveBatchSize( this );\n\t\t\treturn factory.getServiceRegistry()\n\t\t\t\t\t.requireService( BatchLoaderFactory.class )\n\t\t\t\t\t.createEntityBatchLoader( batchSize, this, loadQueryInfluencers );\n\t\t}\n\t\telse {\n\t\t\treturn new SingleIdEntityLoaderStandardImpl<>( this, loadQueryInfluencers );\n\t\t}\n\t}\n\n\tpublic static Map<String, String> getEntityNameByTableNameMap(\n\t\t\tPersistentClass persistentClass,\n\t\t\tSqlStringGenerationContext stringGenerationContext) {\n\t\tfinal Map<String, String> entityNameByTableNameMap = new HashMap<>();\n\t\tPersistentClass superType = persistentClass.getSuperPersistentClass();\n\t\twhile ( superType != null ) {\n\t\t\tentityNameByTableNameMap.put( superType.getTable().getQualifiedName( stringGenerationContext ), superType.getEntityName() );\n\t\t\tfor ( Join join : superType.getJoins() ) {\n\t\t\t\tentityNameByTableNameMap.put( join.getTable().getQualifiedName( stringGenerationContext ), superType.getEntityName() );\n\t\t\t}\n\t\t\tsuperType = superType.getSuperPersistentClass();\n\t\t}\n\t\tfor ( PersistentClass subclass : persistentClass.getSubclassClosure() ) {\n\t\t\tentityNameByTableNameMap.put( subclass.getTable().getQualifiedName( stringGenerationContext ), subclass.getEntityName() );\n\t\t\tfor ( Join join : subclass.getJoins() ) {\n\t\t\t\tentityNameByTableNameMap.put( join.getTable().getQualifiedName( stringGenerationContext ), subclass.getEntityName() );\n\t\t\t}\n\t\t}\n\t\treturn entityNameByTableNameMap;\n\t}\n\n\tprotected MultiIdEntityLoader<Object> buildMultiIdLoader() {\n\t\tif ( getIdentifierType() instanceof BasicType\n\t\t\t\t&& supportsSqlArrayType( factory.getJdbcServices().getDialect() ) ) {\n\t\t\treturn new MultiIdEntityLoaderArrayParam<>( this, factory );\n\t\t}\n\t\telse {\n\t\t\treturn new MultiIdEntityLoaderStandard<>( this, identifierColumnSpan, factory );\n\t\t}\n\t}\n\n\tprivate String getIdentitySelectString(Dialect dialect) {\n\t\ttry {\n\t\t\treturn dialect.getIdentityColumnSupport()\n\t\t\t\t\t.getIdentitySelectString(\n\t\t\t\t\t\t\tgetTableName(0),\n\t\t\t\t\t\t\tgetKeyColumns(0)[0],\n\t\t\t\t\t\t\t( (BasicType<?>) getIdentifierType() ).getJdbcType().getDdlTypeCode()\n\t\t\t\t\t);\n\t\t}\n\t\tcatch (MappingException ex) {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tstatic boolean isAbstract(PersistentClass subclass) {\n\t\tfinal Boolean knownAbstract = subclass.isAbstract();\n\t\treturn knownAbstract == null\n\t\t\t\t? subclass.hasPojoRepresentation() && isAbstractClass( subclass.getMappedClass() )\n\t\t\t\t: knownAbstract;\n\t}\n\n\tprivate boolean shouldUseReferenceCacheEntries(SessionFactoryOptions options) {\n\t\t// Check if we can use Reference Cached entities in 2lc\n\t\t// todo : should really validate that the cache access type is read-only\n\t\tif ( !options.isDirectReferenceCacheEntriesEnabled() ) {\n\t\t\treturn false;\n\t\t}\n\t\t// for now, limit this to just entities that:\n\t\telse if ( entityMetamodel.isMutable() ) {\n\t\t\t// 1) are immutable\n\t\t\treturn false;\n\t\t}\n\t\telse {\n\t\t\t// 2) have no associations.\n\t\t\t// Eventually we want to be a little more lenient with associations.\n\t\t\tfor ( Type type : getSubclassPropertyTypeClosure() ) {\n\t\t\t\tif ( type.isAssociationType() ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tprivate boolean shouldUseShallowCacheLayout(CacheLayout entityQueryCacheLayout, SessionFactoryOptions options) {\n\t\tfinal CacheLayout queryCacheLayout;\n\t\tif ( entityQueryCacheLayout == null ) {\n\t\t\tqueryCacheLayout = options.getQueryCacheLayout();\n\t\t}\n\t\telse {\n\t\t\tqueryCacheLayout = entityQueryCacheLayout;\n\t\t}\n\t\treturn queryCacheLayout == CacheLayout.SHALLOW || queryCacheLayout == CacheLayout.SHALLOW_WITH_DISCRIMINATOR\n\t\t\t\t|| queryCacheLayout == CacheLayout.AUTO && ( canUseReferenceCacheEntries() || canReadFromCache() );\n\t}\n\n\tprivate boolean shouldStoreDiscriminatorInShallowQueryCacheLayout(CacheLayout entityQueryCacheLayout, SessionFactoryOptions options) {\n\t\tfinal CacheLayout queryCacheLayout;\n\t\tif ( entityQueryCacheLayout == null ) {\n\t\t\tqueryCacheLayout = options.getQueryCacheLayout();\n\t\t}\n\t\telse {\n\t\t\tqueryCacheLayout = entityQueryCacheLayout;\n\t\t}\n\t\treturn queryCacheLayout == CacheLayout.SHALLOW_WITH_DISCRIMINATOR;\n\t}\n\n\tprotected abstract String[] getSubclassTableNames();\n\n\tprotected abstract String[] getSubclassTableKeyColumns(int j);\n\n\tprotected abstract boolean isClassOrSuperclassTable(int j);\n\n\tprotected boolean isClassOrSuperclassJoin(int j) {\n\t\t// TODO:\n\t\t// SingleTableEntityPersister incorrectly used isClassOrSuperclassJoin == isClassOrSuperclassTable,\n\t\t// this caused HHH-12895, as this resulted in the subclass tables always being joined, even if no\n\t\t// property on these tables was accessed.\n\t\t//\n\t\t// JoinedTableEntityPersister does not use isClassOrSuperclassJoin at all, probably incorrectly so.\n\t\t// I however haven't been able to reproduce any quirks regarding <join>s, secondary tables or\n\t\t// @JoinTable's.\n\t\t//\n\t\t// Probably this method needs to be properly implemented for the various entity persisters,\n\t\t// but this at least fixes the SingleTableEntityPersister, while maintaining the previous\n\t\t// behaviour for other persisters.\n\t\treturn isClassOrSuperclassTable( j );\n\t}\n\n\tpublic abstract boolean isPropertyOfTable(int property, int j);\n\n\tprotected abstract int[] getPropertyTableNumbers();\n\n\tprivate static final String DISCRIMINATOR_ALIAS = \"clazz_\";\n\n\t@Override\n\tpublic String getDiscriminatorColumnName() {\n\t\treturn DISCRIMINATOR_ALIAS;\n\t}\n\n\tpublic String getDiscriminatorColumnReaders() {\n\t\treturn DISCRIMINATOR_ALIAS;\n\t}\n\n\tpublic String getDiscriminatorColumnReaderTemplate() {\n\t\treturn getSubclassEntityNames().size() == 1\n\t\t\t\t? getDiscriminatorSQLValue()\n\t\t\t\t: Template.TEMPLATE + \".\" + DISCRIMINATOR_ALIAS;\n\t}\n\n\tpublic String getDiscriminatorFormulaTemplate() {\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic boolean isInverseTable(int j) {\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic boolean isNullableTable(int j) {\n\t\treturn false;\n\t}\n\n\tprotected boolean isNullableSubclassTable(int j) {\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic boolean isSubclassEntityName(String entityName) {\n\t\treturn entityMetamodel.getSubclassEntityNames().contains( entityName );\n\t}\n\n\t@Override\n\tpublic boolean isSharedColumn(String columnExpression) {\n\t\treturn sharedColumnNames.contains( columnExpression );\n\t}\n\n\t@Override\n\tpublic String[] getRootTableKeyColumnNames() {\n\t\treturn rootTableKeyColumnNames;\n\t}\n\n\tSingleIdArrayLoadPlan getSQLLazySelectLoadPlan(String fetchGroup) {\n\t\treturn lazyLoadPlanByFetchGroup.get( fetchGroup );\n\t}\n\n\t@Override\n\tpublic InsertCoordinator getInsertCoordinator() {\n\t\treturn insertCoordinator;\n\t}\n\n\t@Override\n\tpublic UpdateCoordinator getUpdateCoordinator() {\n\t\treturn updateCoordinator;\n\t}\n\n\t@Override\n\tpublic DeleteCoordinator getDeleteCoordinator() {\n\t\treturn deleteCoordinator;\n\t}\n\n\t@Override\n\tpublic UpdateCoordinator getMergeCoordinator() {\n\t\treturn mergeCoordinator;\n\t}\n\n\tpublic String getVersionSelectString() {\n\t\treturn sqlVersionSelectString;\n\t}\n\n\t@Internal // called by Hibernate Reactive\n\t@SuppressWarnings(\"unused\")\n\tpublic GeneratedValuesProcessor getInsertGeneratedValuesProcessor() {\n\t\treturn insertGeneratedValuesProcessor;\n\t}\n\n\t@Internal // called by Hibernate Reactive\n\t@SuppressWarnings(\"unused\")\n\tpublic GeneratedValuesProcessor getUpdateGeneratedValuesProcessor() {\n\t\treturn updateGeneratedValuesProcessor;\n\t}\n\n\t@Override\n\tpublic boolean hasRowId() {\n\t\treturn rowIdName != null;\n\t}\n\n\t@Override\n\tpublic String[] getTableNames() {\n\t\tfinal String[] tableNames = new String[getTableSpan()];\n\t\tfor ( int i = 0; i < tableNames.length; i++ ) {\n\t\t\ttableNames[i] = getTableName( i );\n\t\t}\n\t\treturn tableNames;\n\t}\n\n\t/**\n\t * We might need to use cache invalidation if we have formulas,\n\t * dynamic update, or secondary tables.\n\t *\n\t * @see #isCacheInvalidationRequired()\n\t */\n\tprivate boolean shouldInvalidateCache(\n\t\t\tPersistentClass persistentClass,\n\t\t\tRuntimeModelCreationContext creationContext) {\n\t\tif ( hasFormulaProperties() ) {\n\t\t\t// we need to evaluate formulas in the database\n\t\t\treturn true;\n\t\t}\n\t\telse if ( isVersioned() ) {\n\t\t\t// we don't need to be \"careful\" in the case of\n\t\t\t// versioned entities\n\t\t\treturn false;\n\t\t}\n\t\telse if ( entityMetamodel.isDynamicUpdate() ) {\n\t\t\t// if the unversioned entity has dynamic updates\n\t\t\t// there is a risk of concurrent updates\n\t\t\treturn true;\n\t\t}\n\t\telse if ( isCacheComplianceEnabled( creationContext ) ) {\n\t\t\t// The JPA TCK (inadvertently, but still...)\n\t\t\t// requires that we cache entities with secondary\n\t\t\t// tables instead of being more careful and just\n\t\t\t// invalidating them\n\t\t\treturn false;\n\t\t}\n\t\telse {\n\t\t\t// if the unversioned entity has second tables\n\t\t\t// there is a risk of concurrent updates\n\t\t\t// todo : this should really consider optionality of the secondary tables\n\t\t\t//        in count so non-optional tables do not cause this bypass\n\t\t\treturn persistentClass.getJoinClosureSpan() >= 1;\n\t\t}\n\t}\n\n\tprivate boolean isCacheComplianceEnabled(RuntimeModelCreationContext creationContext) {\n\t\treturn creationContext.getSessionFactoryOptions()\n\t\t\t\t.getJpaCompliance()\n\t\t\t\t.isJpaCacheComplianceEnabled();\n\t}\n\n\tprivate boolean determineCanWriteToCache(PersistentClass persistentClass, EntityDataAccess cacheAccessStrategy) {\n\t\treturn cacheAccessStrategy != null && persistentClass.isCached();\n\t}\n\n\tprivate boolean determineCanReadFromCache(PersistentClass persistentClass, EntityDataAccess cacheAccessStrategy) {\n\t\tif ( cacheAccessStrategy == null ) {\n\t\t\treturn false;\n\t\t}\n\t\telse if ( persistentClass.isCached() ) {\n\t\t\treturn true;\n\t\t}\n\t\telse {\n\t\t\tfor ( Subclass subclass : persistentClass.getSubclasses() ) {\n\t\t\t\tif ( subclass.isCached() ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tprotected CacheEntryHelper buildCacheEntryHelper(SessionFactoryOptions options) {\n\t\tif ( cacheAccessStrategy == null ) {\n\t\t\t// the entity defined no caching...\n\t\t\treturn NoopCacheEntryHelper.INSTANCE;\n\t\t}\n\t\telse if ( canUseReferenceCacheEntries() ) {\n\t\t\tentityMetamodel.setLazy( false );\n\t\t\t// todo : do we also need to unset proxy factory?\n\t\t\treturn new ReferenceCacheEntryHelper( this );\n\t\t}\n\t\telse {\n\t\t\treturn options.isStructuredCacheEntriesEnabled()\n\t\t\t\t\t? new StructuredCacheEntryHelper( this )\n\t\t\t\t\t: new StandardCacheEntryHelper( this );\n\t\t}\n\t}\n\n\t@Override\n\tpublic boolean canUseReferenceCacheEntries() {\n\t\treturn useReferenceCacheEntries;\n\t}\n\n\t@Override\n\tpublic boolean useShallowQueryCacheLayout() {\n\t\treturn useShallowQueryCacheLayout;\n\t}\n\n\t@Override\n\tpublic boolean storeDiscriminatorInShallowQueryCacheLayout() {\n\t\treturn storeDiscriminatorInShallowQueryCacheLayout;\n\t}\n\n\t@Override\n\tpublic boolean hasFilterForLoadByKey() {\n\t\tif ( filterHelper != null ) {\n\t\t\tfor ( String filterName : filterHelper.getFilterNames() ) {\n\t\t\t\tif ( factory.getFilterDefinition( filterName ).isAppliedToLoadByKey() ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic Iterable<UniqueKeyEntry> uniqueKeyEntries() {\n\t\tif ( this.uniqueKeyEntries == null ) {\n\t\t\tthis.uniqueKeyEntries = initUniqueKeyEntries( this );\n\t\t}\n\t\treturn this.uniqueKeyEntries;\n\t}\n\n\tprivate static List<UniqueKeyEntry> initUniqueKeyEntries(final AbstractEntityPersister aep) {\n\t\tfinal ArrayList<UniqueKeyEntry> uniqueKeys = new ArrayList<>();\n\t\tfor ( Type propertyType : aep.getPropertyTypes() ) {\n\t\t\tif ( propertyType instanceof AssociationType ) {\n\t\t\t\tfinal AssociationType associationType = (AssociationType) propertyType;\n\t\t\t\tfinal String ukName = associationType.getLHSPropertyName();\n\t\t\t\tif ( ukName != null ) {\n\t\t\t\t\tfinal AttributeMapping attributeMapping = aep.findAttributeMapping( ukName );\n\t\t\t\t\tif ( attributeMapping != null ) {\n\t\t\t\t\t\tfinal int index = attributeMapping.getStateArrayPosition();\n\t\t\t\t\t\tfinal Type type = aep.getPropertyTypes()[index];\n\t\t\t\t\t\tuniqueKeys.add( new UniqueKeyEntry( ukName, index, type ) );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn CollectionHelper.toSmallList( uniqueKeys );\n\t}\n\n\tprotected Map<String, SingleIdArrayLoadPlan> getLazyLoadPlanByFetchGroup() {\n\t\tfinal BytecodeEnhancementMetadata metadata = entityMetamodel.getBytecodeEnhancementMetadata();\n\t\treturn metadata.isEnhancedForLazyLoading() && metadata.getLazyAttributesMetadata().hasLazyAttributes()\n\t\t\t\t? createLazyLoadPlanByFetchGroup( metadata )\n\t\t\t\t: emptyMap();\n\t}\n\n\tprivate Map<String, SingleIdArrayLoadPlan> createLazyLoadPlanByFetchGroup(BytecodeEnhancementMetadata metadata) {\n\t\tfinal Map<String, SingleIdArrayLoadPlan> result = new HashMap<>();\n\t\tfinal LazyAttributesMetadata attributesMetadata = metadata.getLazyAttributesMetadata();\n\t\tfor ( String groupName : attributesMetadata.getFetchGroupNames() ) {\n\t\t\tfinal SingleIdArrayLoadPlan loadPlan =\n\t\t\t\t\tcreateLazyLoadPlan( attributesMetadata.getFetchGroupAttributeDescriptors( groupName ) );\n\t\t\tif ( loadPlan != null ) {\n\t\t\t\tresult.put( groupName, loadPlan );\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\tprivate SingleIdArrayLoadPlan createLazyLoadPlan(List<LazyAttributeDescriptor> fetchGroupAttributeDescriptors) {\n\t\tfinal List<ModelPart> partsToSelect = new ArrayList<>( fetchGroupAttributeDescriptors.size() );\n\t\tfor ( LazyAttributeDescriptor lazyAttributeDescriptor : fetchGroupAttributeDescriptors ) {\n\t\t\t// all this only really needs to consider properties\n\t\t\t// of this class, not its subclasses, but since we\n\t\t\t// are reusing code used for sequential selects, we\n\t\t\t// use the subclass closure\n\t\t\tpartsToSelect.add( getAttributeMapping( getSubclassPropertyIndex( lazyAttributeDescriptor.getName() ) ) );\n\t\t}\n\n\t\tif ( partsToSelect.isEmpty() ) {\n\t\t\t// only one-to-one is lazily fetched\n\t\t\treturn null;\n\t\t}\n\t\telse {\n\t\t\tJdbcParametersList.Builder jdbcParametersBuilder = JdbcParametersList.newBuilder();\n\t\t\tfinal SelectStatement select = LoaderSelectBuilder.createSelect(\n\t\t\t\t\tthis,\n\t\t\t\t\tpartsToSelect,\n\t\t\t\t\tgetIdentifierMapping(),\n\t\t\t\t\tnull,\n\t\t\t\t\t1,\n\t\t\t\t\tnew LoadQueryInfluencers( factory ),\n\t\t\t\t\tLockOptions.NONE,\n\t\t\t\t\tjdbcParametersBuilder::add,\n\t\t\t\t\tfactory\n\t\t\t);\n\t\t\tJdbcParametersList jdbcParameters = jdbcParametersBuilder.build();\n\t\t\treturn new SingleIdArrayLoadPlan(\n\t\t\t\t\tthis,\n\t\t\t\t\tgetIdentifierMapping(),\n\t\t\t\t\tselect,\n\t\t\t\t\tjdbcParameters,\n\t\t\t\t\tLockOptions.NONE,\n\t\t\t\t\tfactory\n\t\t\t);\n\t\t}\n\t}\n\n\t@Override\n\tpublic String getSqlAliasStem() {\n\t\treturn sqlAliasStem;\n\t}\n\n\t@Override\n\tpublic boolean containsTableReference(String tableExpression) {\n\t\treturn contains( getSubclassTableNames(), tableExpression );\n\t}\n\n\t@Override\n\tpublic String getPartName() {\n\t\treturn getEntityName();\n\t}\n\n\t@Override\n\tpublic <T> DomainResult<T> createDomainResult(\n\t\t\tNavigablePath navigablePath,\n\t\t\tTableGroup tableGroup,\n\t\t\tString resultVariable,\n\t\t\tDomainResultCreationState creationState) {\n\t\tfinal EntityResultImpl entityResult = new EntityResultImpl(\n\t\t\t\tnavigablePath,\n\t\t\t\tthis,\n\t\t\t\ttableGroup,\n\t\t\t\tresultVariable\n\t\t);\n\t\tentityResult.afterInitialize( entityResult, creationState );\n\t\t//noinspection unchecked\n\t\treturn entityResult;\n\t}\n\n\t@Override\n\tpublic void applySqlSelections(\n\t\t\tNavigablePath navigablePath,\n\t\t\tTableGroup tableGroup,\n\t\t\tDomainResultCreationState creationState) {\n\t\tidentifierMapping.applySqlSelections(\n\t\t\t\tnavigablePath.append( identifierMapping.getPartName() ),\n\t\t\t\ttableGroup,\n\t\t\t\tcreationState\n\t\t);\n\t}\n\n\t@Override\n\tpublic void applySqlSelections(\n\t\t\tNavigablePath navigablePath,\n\t\t\tTableGroup tableGroup,\n\t\t\tDomainResultCreationState creationState,\n\t\t\tBiConsumer<SqlSelection, JdbcMapping> selectionConsumer) {\n\t\tidentifierMapping.applySqlSelections(\n\t\t\t\tnavigablePath.append( identifierMapping.getPartName() ),\n\t\t\t\ttableGroup,\n\t\t\t\tcreationState,\n\t\t\t\tselectionConsumer\n\t\t);\n\t}\n\n\t@Override\n\tpublic NaturalIdMapping getNaturalIdMapping() {\n\t\treturn naturalIdMapping;\n\t}\n\n\t@Override\n\tpublic TableReference createPrimaryTableReference(\n\t\t\tSqlAliasBase sqlAliasBase,\n\t\t\tSqlAstCreationState sqlAstCreationState) {\n\t\treturn new NamedTableReference( getTableName(), sqlAliasBase.generateNewAlias() );\n\t}\n\n\t@Override\n\tpublic TableReferenceJoin createTableReferenceJoin(\n\t\t\tString joinTableExpression,\n\t\t\tSqlAliasBase sqlAliasBase,\n\t\t\tTableReference lhs,\n\t\t\tSqlAstCreationState creationState) {\n\t\tfor ( int i = 1; i < getSubclassTableSpan(); i++ ) {\n\t\t\tfinal String subclassTableName = getSubclassTableName( i );\n\t\t\tif ( subclassTableName.equals( joinTableExpression ) ) {\n\t\t\t\treturn generateTableReferenceJoin(\n\t\t\t\t\t\tlhs,\n\t\t\t\t\t\tjoinTableExpression,\n\t\t\t\t\t\tsqlAliasBase,\n\t\t\t\t\t\tshouldInnerJoinSubclassTable( i, emptySet() ),\n\t\t\t\t\t\tgetSubclassTableKeyColumns( i ),\n\t\t\t\t\t\tcreationState\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tprotected TableReferenceJoin generateTableReferenceJoin(\n\t\t\tTableReference lhs,\n\t\t\tString joinTableExpression,\n\t\t\tSqlAliasBase sqlAliasBase,\n\t\t\tboolean innerJoin,\n\t\t\tString[] targetColumns,\n\t\t\tSqlAstCreationState creationState) {\n\t\tfinal NamedTableReference joinedTableReference = new NamedTableReference(\n\t\t\t\tjoinTableExpression,\n\t\t\t\tsqlAliasBase.generateNewAlias(),\n\t\t\t\t!innerJoin\n\t\t);\n\n\t\treturn new TableReferenceJoin(\n\t\t\t\tinnerJoin,\n\t\t\t\tjoinedTableReference,\n\t\t\t\tgenerateJoinPredicate(\n\t\t\t\t\t\tlhs,\n\t\t\t\t\t\tjoinedTableReference,\n\t\t\t\t\t\tgetIdentifierColumnNames(),\n\t\t\t\t\t\ttargetColumns,\n\t\t\t\t\t\tcreationState\n\t\t\t\t)\n\t\t);\n\t}\n\n\tprotected Predicate generateJoinPredicate(\n\t\t\tTableReference rootTableReference,\n\t\t\tTableReference joinedTableReference,\n\t\t\tString[] pkColumnNames,\n\t\t\tString[] fkColumnNames,\n\t\t\tSqlAstCreationState creationState) {\n\t\tfinal EntityIdentifierMapping identifierMapping = getIdentifierMapping();\n\n\t\tfinal Junction conjunction = new Junction( Junction.Nature.CONJUNCTION );\n\n\t\tassert pkColumnNames.length == fkColumnNames.length;\n\t\tassert pkColumnNames.length == identifierMapping.getJdbcTypeCount();\n\n\t\tidentifierMapping.forEachSelectable(\n\t\t\t\t(columnIndex, selection) -> {\n\t\t\t\t\tfinal String rootPkColumnName = pkColumnNames[ columnIndex ];\n\t\t\t\t\tfinal Expression pkColumnExpression = creationState.getSqlExpressionResolver().resolveSqlExpression(\n\t\t\t\t\t\t\tcreateColumnReferenceKey(\n\t\t\t\t\t\t\t\t\trootTableReference,\n\t\t\t\t\t\t\t\t\trootPkColumnName,\n\t\t\t\t\t\t\t\t\tselection.getJdbcMapping()\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\tsqlAstProcessingState -> new ColumnReference(\n\t\t\t\t\t\t\t\t\trootTableReference.getIdentificationVariable(),\n\t\t\t\t\t\t\t\t\trootPkColumnName,\n\t\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\t\tnull,\n\t\t\t\t\t\t\t\t\tselection.getJdbcMapping()\n\t\t\t\t\t\t\t)\n\t\t\t\t\t);\n\n\t\t\t\t\tfinal String fkColumnName = fkColumnNames[ columnIndex ];\n\t\t\t\t\tfinal Expression fkColumnExpression = creationState.getSqlExpressionResolver().resolveSqlExpression(\n\t\t\t\t\t\t\tcreateColumnReferenceKey(\n\t\t\t\t\t\t\t\t\tjoinedTableReference,\n\t\t\t\t\t\t\t\t\tfkColumnName,\n\t\t\t\t\t\t\t\t\tselection.getJdbcMapping()\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\tsqlAstProcessingState -> new ColumnReference(\n\t\t\t\t\t\t\t\t\tjoinedTableReference.getIdentificationVariable(),\n\t\t\t\t\t\t\t\t\tfkColumnName,\n\t\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\t\tnull,\n\t\t\t\t\t\t\t\t\tselection.getJdbcMapping()\n\t\t\t\t\t\t\t)\n\t\t\t\t\t);\n\n\t\t\t\t\tconjunction.add( new ComparisonPredicate( pkColumnExpression, ComparisonOperator.EQUAL, fkColumnExpression ) );\n\t\t\t\t}\n\t\t);\n\n\t\treturn conjunction;\n\t}\n\n\t@Override\n\tpublic Object initializeLazyProperty(String fieldName, Object entity, SharedSessionContractImplementor session) {\n\t\tfinal PersistenceContext persistenceContext = session.getPersistenceContextInternal();\n\t\tfinal EntityEntry entry = persistenceContext.getEntry( entity );\n\t\tfinal PersistentAttributeInterceptor interceptor = asPersistentAttributeInterceptable( entity ).$$_hibernate_getInterceptor();\n\t\tassert interceptor != null : \"Expecting bytecode interceptor to be non-null\";\n\n\t\tif ( hasCollections() ) {\n\t\t\tfinal Type type = getPropertyType( fieldName );\n\t\t\tif ( type.isCollectionType() ) {\n\t\t\t\t// we have a condition where a collection attribute is being access via enhancement:\n\t\t\t\t// \t\twe can circumvent all the rest and just return the PersistentCollection\n\t\t\t\tfinal CollectionType collectionType = (CollectionType) type;\n\t\t\t\tfinal CollectionPersister persister = factory.getRuntimeMetamodels()\n\t\t\t\t\t\t.getMappingMetamodel()\n\t\t\t\t\t\t.getCollectionDescriptor( collectionType.getRole() );\n\n\t\t\t\t// Get/create the collection, and make sure it is initialized!  This initialized part is\n\t\t\t\t// different from proxy-based scenarios where we have to create the PersistentCollection\n\t\t\t\t// reference \"ahead of time\" to add as a reference to the proxy.  For bytecode solutions\n\t\t\t\t// we are not creating the PersistentCollection ahead of time, but instead we are creating\n\t\t\t\t// it on first request through the enhanced entity.\n\n\t\t\t\t// see if there is already a collection instance associated with the session\n\t\t\t\t// \t\tNOTE : can this ever happen?\n\t\t\t\tfinal Object key = getCollectionKey( persister, entity, entry, session );\n\t\t\t\tassert key != null;\n\t\t\t\tPersistentCollection<?> collection = persistenceContext.getCollection( new CollectionKey( persister, key ) );\n\t\t\t\tif ( collection == null ) {\n\t\t\t\t\tcollection = collectionType.instantiate( session, persister, key );\n\t\t\t\t\tcollection.setOwner( entity );\n\t\t\t\t\tpersistenceContext.addUninitializedCollection( persister, collection, key );\n\t\t\t\t}\n\n\t\t\t\tinterceptor.attributeInitialized( fieldName );\n\n\t\t\t\tif ( collectionType.isArrayType() ) {\n\t\t\t\t\tpersistenceContext.addCollectionHolder( collection );\n\t\t\t\t}\n\n\t\t\t\t// update the \"state\" of the entity's EntityEntry to over-write UNFETCHED_PROPERTY reference\n\t\t\t\t// for the collection to the just loaded collection\n\t\t\t\tfinal EntityEntry ownerEntry = persistenceContext.getEntry( entity );\n\t\t\t\tif ( ownerEntry == null ) {\n\t\t\t\t\t// the entity is not in the session; it was probably deleted,\n\t\t\t\t\t// so we cannot load the collection anymore.\n\t\t\t\t\tthrow new LazyInitializationException(\n\t\t\t\t\t\t\t\"Could not locate EntityEntry for the collection owner in the PersistenceContext\"\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\townerEntry.overwriteLoadedStateCollectionValue( fieldName, collection );\n\n\t\t\t\t// EARLY EXIT!!!\n\t\t\t\treturn collection;\n\t\t\t}\n\t\t}\n\n\t\tfinal Object id = session.getContextEntityIdentifier( entity );\n\t\tif ( entry == null ) {\n\t\t\tthrow new HibernateException( \"entity is not associated with the session: \" + id );\n\t\t}\n\n\t\tif ( LOG.isTraceEnabled() ) {\n\t\t\tLOG.tracev(\n\t\t\t\t\t\"Initializing lazy properties of: {0}, field access: {1}\",\n\t\t\t\t\tinfoString( this, id, getFactory() ),\n\t\t\t\t\tfieldName\n\t\t\t);\n\t\t}\n\n\t\tif ( session.getCacheMode().isGetEnabled() && canReadFromCache() && isLazyPropertiesCacheable() ) {\n\t\t\tfinal EntityDataAccess cacheAccess = getCacheAccessStrategy();\n\t\t\tfinal Object cacheKey = cacheAccess.generateCacheKey(id, this, session.getFactory(), session.getTenantIdentifier() );\n\t\t\tfinal Object ce = CacheHelper.fromSharedCache( session, cacheKey, this, cacheAccess );\n\t\t\tif ( ce != null ) {\n\t\t\t\tfinal CacheEntry cacheEntry = (CacheEntry) getCacheEntryStructure().destructure( ce, factory );\n\t\t\t\tfinal Object initializedValue = initializeLazyPropertiesFromCache( fieldName, entity, session, entry, cacheEntry );\n\t\t\t\tif (initializedValue != LazyPropertyInitializer.UNFETCHED_PROPERTY) {\n\t\t\t\t\t// The following should be redundant, since the setter should have set this already.\n\t\t\t\t\t// interceptor.attributeInitialized(fieldName);\n\n\t\t\t\t\t// NOTE EARLY EXIT!!!\n\t\t\t\t\treturn initializedValue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn initializeLazyPropertiesFromDatastore( entity, id, entry, fieldName, session );\n\n\t}\n\n\tpublic @Nullable static Object getCollectionKey(\n\t\t\tCollectionPersister persister,\n\t\t\tObject owner,\n\t\t\tEntityEntry ownerEntry,\n\t\t\tSharedSessionContractImplementor session) {\n\t\tfinal CollectionType collectionType = persister.getCollectionType();\n\n\t\tif ( ownerEntry != null ) {\n\t\t\t// this call only works when the owner is associated with the Session, which is not always the case\n\t\t\treturn collectionType.getKeyOfOwner( owner, session );\n\t\t}\n\n\t\tfinal EntityPersister ownerPersister = persister.getOwnerEntityPersister();\n\t\tif ( collectionType.getLHSPropertyName() == null ) {\n\t\t\t// collection key is defined by the owning entity identifier\n\t\t\treturn ownerPersister.getIdentifier( owner, session );\n\t\t}\n\t\telse {\n\t\t\treturn ownerPersister.getPropertyValue( owner, collectionType.getLHSPropertyName() );\n\t\t}\n\t}\n\n\tprotected Object initializeLazyPropertiesFromDatastore(\n\t\t\tfinal Object entity,\n\t\t\tfinal Object id,\n\t\t\tfinal EntityEntry entry,\n\t\t\tfinal String fieldName,\n\t\t\tfinal SharedSessionContractImplementor session) {\n\n\t\tif ( !hasLazyProperties() ) {\n\t\t\tthrow new AssertionFailure( \"no lazy properties\" );\n\t\t}\n\n\t\tfinal PersistentAttributeInterceptor interceptor = asPersistentAttributeInterceptable( entity ).$$_hibernate_getInterceptor();\n\t\tassert interceptor != null : \"Expecting bytecode interceptor to be non-null\";\n\n\t\tLOG.tracef( \"Initializing lazy properties from datastore (triggered for `%s`)\", fieldName );\n\n\t\tfinal String fetchGroup = getEntityMetamodel().getBytecodeEnhancementMetadata()\n\t\t\t\t.getLazyAttributesMetadata()\n\t\t\t\t.getFetchGroupName( fieldName );\n\t\tfinal List<LazyAttributeDescriptor> fetchGroupAttributeDescriptors = getEntityMetamodel().getBytecodeEnhancementMetadata()\n\t\t\t\t.getLazyAttributesMetadata()\n\t\t\t\t.getFetchGroupAttributeDescriptors( fetchGroup );\n\n\t\tfinal Set<String> initializedLazyAttributeNames = interceptor.getInitializedLazyAttributeNames();\n\n\t\tfinal SingleIdArrayLoadPlan lazySelect = getSQLLazySelectLoadPlan( fetchGroup );\n\n\t\ttry {\n\t\t\tObject result = null;\n\t\t\tfinal Object[] values = lazySelect.load( id, session );\n\t\t\tint i = 0;\n\t\t\tfor ( LazyAttributeDescriptor fetchGroupAttributeDescriptor : fetchGroupAttributeDescriptors ) {\n\t\t\t\tfinal boolean previousInitialized = initializedLazyAttributeNames.contains( fetchGroupAttributeDescriptor.getName() );\n\n\t\t\t\tif ( previousInitialized ) {\n\t\t\t\t\t// todo : one thing we should consider here is potentially un-marking an attribute as dirty based on the selected value\n\t\t\t\t\t// \t\twe know the current value - getPropertyValue( entity, fetchGroupAttributeDescriptor.getAttributeIndex() );\n\t\t\t\t\t// \t\twe know the selected value (see selectedValue below)\n\t\t\t\t\t//\t\twe can use the attribute Type to tell us if they are the same\n\t\t\t\t\t//\n\t\t\t\t\t//\t\tassuming entity is a SelfDirtinessTracker we can also know if the attribute is\n\t\t\t\t\t//\t\t\tcurrently considered dirty, and if really not dirty we would do the un-marking\n\t\t\t\t\t//\n\t\t\t\t\t//\t\tof course that would mean a new method on SelfDirtinessTracker to allow un-marking\n\n\t\t\t\t\t// its already been initialized (e.g. by a write) so we don't want to overwrite\n\t\t\t\t\ti++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tfinal Object selectedValue = values[i++];\n\t\t\t\tfinal boolean set = initializeLazyProperty(\n\t\t\t\t\t\tfieldName,\n\t\t\t\t\t\tentity,\n\t\t\t\t\t\tentry,\n\t\t\t\t\t\tfetchGroupAttributeDescriptor.getLazyIndex(),\n\t\t\t\t\t\tselectedValue\n\t\t\t\t);\n\t\t\t\tif ( set ) {\n\t\t\t\t\tresult = selectedValue;\n\t\t\t\t\tinterceptor.attributeInitialized( fetchGroupAttributeDescriptor.getName() );\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tLOG.trace( \"Done initializing lazy properties\" );\n\n\t\t\treturn result;\n\t\t}\n\t\tcatch ( JDBCException ex ) {\n\t\t\tthrow session.getJdbcServices().getSqlExceptionHelper().convert(\n\t\t\t\t\tex.getSQLException(),\n\t\t\t\t\t\"could not initialize lazy properties: \" + infoString( this, id, getFactory() ),\n\t\t\t\t\tlazySelect.getJdbcSelect().getSqlString()\n\t\t\t);\n\t\t}\n\t}\n\n\tprotected Object initializeLazyPropertiesFromCache(\n\t\t\tfinal String fieldName,\n\t\t\tfinal Object entity,\n\t\t\tfinal SharedSessionContractImplementor session,\n\t\t\tfinal EntityEntry entry,\n\t\t\tfinal CacheEntry cacheEntry) {\n\n\t\tLOG.trace( \"Initializing lazy properties from second-level cache\" );\n\n\t\tObject result = null;\n\t\tSerializable[] disassembledValues = cacheEntry.getDisassembledState();\n\t\tfor ( int j = 0; j < lazyPropertyNames.length; j++ ) {\n\t\t\tfinal Serializable cachedValue = disassembledValues[lazyPropertyNumbers[j]];\n\t\t\tfinal Type lazyPropertyType = lazyPropertyTypes[j];\n\t\t\tfinal String propertyName = lazyPropertyNames[j];\n\t\t\tif ( cachedValue == LazyPropertyInitializer.UNFETCHED_PROPERTY ) {\n\t\t\t\tif ( fieldName.equals(propertyName) ) {\n\t\t\t\t\tresult = LazyPropertyInitializer.UNFETCHED_PROPERTY;\n\t\t\t\t}\n\t\t\t\t// don't try to initialize the unfetched property\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfinal Object propValue = lazyPropertyType.assemble( cachedValue, session, entity );\n\t\t\t\tif ( initializeLazyProperty( fieldName, entity, entry, j, propValue ) ) {\n\t\t\t\t\tresult = propValue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tLOG.trace( \"Done initializing lazy properties\" );\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Called by Hibernate Reactive\n\t */\n\tprotected boolean initializeLazyProperty(\n\t\t\tfinal String fieldName,\n\t\t\tfinal Object entity,\n\t\t\tfinal EntityEntry entry,\n\t\t\tfinal int index,\n\t\t\tfinal Object propValue) {\n\t\tsetPropertyValue( entity, lazyPropertyNumbers[index], propValue );\n\t\tif ( entry.getLoadedState() != null ) {\n\t\t\t// object have been loaded with setReadOnly(true); HHH-2236\n\t\t\tentry.getLoadedState()[lazyPropertyNumbers[index]] = lazyPropertyTypes[index].deepCopy( propValue, factory );\n\t\t}\n\t\t// If the entity has deleted state, then update that as well\n\t\tif ( entry.getDeletedState() != null ) {\n\t\t\tentry.getDeletedState()[lazyPropertyNumbers[index]] = lazyPropertyTypes[index].deepCopy( propValue, factory );\n\t\t}\n\t\treturn fieldName.equals( lazyPropertyNames[index] );\n\t}\n\n\t@Override\n\tpublic NavigableRole getNavigableRole() {\n\t\treturn navigableRole;\n\t}\n\n\t@Override\n\tpublic Serializable[] getQuerySpaces() {\n\t\treturn getPropertySpaces();\n\t}\n\n\t@Override\n\tpublic boolean isBatchLoadable() {\n\t\treturn batchSize > 1;\n\t}\n\n\t@Override\n\tpublic int getBatchSize() {\n\t\treturn batchSize;\n\t}\n\n\t@Override\n\tpublic String[] getIdentifierColumnNames() {\n\t\treturn rootTableKeyColumnNames;\n\t}\n\n\tpublic String[] getIdentifierColumnReaders() {\n\t\treturn rootTableKeyColumnReaders;\n\t}\n\n\tpublic String[] getIdentifierColumnReaderTemplates() {\n\t\treturn rootTableKeyColumnReaderTemplates;\n\t}\n\n\tpublic int getIdentifierColumnSpan() {\n\t\treturn identifierColumnSpan;\n\t}\n\n\tpublic String[] getIdentifierAliases() {\n\t\treturn identifierAliases;\n\t}\n\n\t@Override\n\tpublic String getVersionColumnName() {\n\t\treturn versionColumnName;\n\t}\n\n\tpublic String getVersionedTableName() {\n\t\treturn getTableName( 0 );\n\t}\n\n\t/**\n\t * We can't immediately add to the cache if we have formulas\n\t * which must be evaluated, or if we have the possibility of\n\t * two concurrent updates to the same item being merged on\n\t * the database. This second case can happen if:\n\t * <ol>\n\t * <li> the item is not versioned, and either\n\t * <li>we have dynamic update enabled, or\n\t * <li>the state of the item spans multiple tables.\n\t * </ol>\n\t * Therefore, we're careful, and just invalidate the cache in\n\t * these cases (the item will be readded when it's read again\n\t * fresh from the database).\n\t */\n\t@Override\n\tpublic boolean isCacheInvalidationRequired() {\n\t\treturn invalidateCache;\n\t}\n\n\t@Override\n\tpublic boolean isLazyPropertiesCacheable() {\n\t\treturn isLazyPropertiesCacheable;\n\t}\n\n\t@Override\n\tpublic String selectFragment(String alias, String suffix) {\n\t\tfinal QuerySpec rootQuerySpec = new QuerySpec( true );\n\t\tfinal LoaderSqlAstCreationState sqlAstCreationState = new LoaderSqlAstCreationState(\n\t\t\t\trootQuerySpec,\n\t\t\t\tnew SqlAliasBaseManager(),\n\t\t\t\tnew SimpleFromClauseAccessImpl(),\n\t\t\t\tLockOptions.NONE,\n\t\t\t\tthis::fetchProcessor,\n\t\t\t\ttrue,\n\t\t\t\tnew LoadQueryInfluencers( factory ),\n\t\t\t\tfactory\n\t\t);\n\n\t\tfinal NavigablePath entityPath = new NavigablePath( getRootPathName() );\n\t\tfinal TableGroup rootTableGroup = createRootTableGroup(\n\t\t\t\ttrue,\n\t\t\t\tentityPath,\n\t\t\t\tnull,\n\t\t\t\tnew SqlAliasBaseConstant( alias ),\n\t\t\t\t() -> p -> {},\n\t\t\t\tsqlAstCreationState\n\t\t);\n\n\t\trootQuerySpec.getFromClause().addRoot( rootTableGroup );\n\t\tsqlAstCreationState.getFromClauseAccess().registerTableGroup( entityPath, rootTableGroup );\n\n\t\tcreateDomainResult( entityPath, rootTableGroup, null, sqlAstCreationState );\n\n\t\t// Wrap expressions with aliases\n\t\tfinal SelectClause selectClause = rootQuerySpec.getSelectClause();\n\t\tfinal List<SqlSelection> sqlSelections = selectClause.getSqlSelections();\n\t\tint i = 0;\n\t\tint columnIndex = 0;\n\t\tfinal String[] columnAliases = getSubclassColumnAliasClosure();\n\t\tfinal int columnAliasesSize = columnAliases.length;\n\t\tfor ( String identifierAlias : identifierAliases ) {\n\t\t\tsqlSelections.set(\n\t\t\t\t\ti,\n\t\t\t\t\tnew SqlSelectionImpl(\n\t\t\t\t\t\t\ti,\n\t\t\t\t\t\t\tnew AliasedExpression( sqlSelections.get( i ).getExpression(), identifierAlias + suffix )\n\t\t\t\t\t)\n\t\t\t);\n\t\t\tif ( i < columnAliasesSize && columnAliases[i].equals( identifierAlias ) ) {\n\t\t\t\tcolumnIndex++;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\n\t\tif ( entityMetamodel.hasSubclasses() ) {\n\t\t\tsqlSelections.set(\n\t\t\t\t\ti,\n\t\t\t\t\tnew SqlSelectionImpl(\n\t\t\t\t\t\t\ti,\n\t\t\t\t\t\t\tnew AliasedExpression( sqlSelections.get( i ).getExpression(), getDiscriminatorAlias() + suffix )\n\t\t\t\t\t)\n\t\t\t);\n\t\t\ti++;\n\t\t}\n\n\t\tif ( hasRowId() ) {\n\t\t\tsqlSelections.set(\n\t\t\t\t\ti,\n\t\t\t\t\tnew SqlSelectionImpl(\n\t\t\t\t\t\t\ti,\n\t\t\t\t\t\t\tnew AliasedExpression( sqlSelections.get( i ).getExpression(), ROWID_ALIAS + suffix )\n\t\t\t\t\t)\n\t\t\t);\n\t\t\ti++;\n\t\t}\n\n\t\tfinal String[] formulaAliases = getSubclassFormulaAliasClosure();\n\t\tint formulaIndex = 0;\n\t\tfor ( ; i < sqlSelections.size(); i++ ) {\n\t\t\tfinal SqlSelection sqlSelection = sqlSelections.get( i );\n\t\t\tfinal ColumnReference columnReference = (ColumnReference) sqlSelection.getExpression();\n\t\t\tfinal String selectAlias = !columnReference.isColumnExpressionFormula()\n\t\t\t\t\t? columnAliases[columnIndex++] + suffix\n\t\t\t\t\t: formulaAliases[formulaIndex++] + suffix;\n\t\t\tsqlSelections.set(\n\t\t\t\t\ti,\n\t\t\t\t\tnew SqlSelectionImpl(\n\t\t\t\t\t\t\tsqlSelection.getValuesArrayPosition(),\n\t\t\t\t\t\t\tnew AliasedExpression( sqlSelection.getExpression(), selectAlias )\n\t\t\t\t\t)\n\t\t\t);\n\t\t}\n\n\t\tfinal String sql = getFactory().getJdbcServices()\n\t\t\t\t.getDialect()\n\t\t\t\t.getSqlAstTranslatorFactory()\n\t\t\t\t.buildSelectTranslator( getFactory(), new SelectStatement( rootQuerySpec ) )\n\t\t\t\t.translate( null, QueryOptions.NONE )\n\t\t\t\t.getSqlString();\n\t\tfinal int fromIndex = sql.lastIndexOf( \" from\" );\n\t\tfinal String expression;\n\t\tif ( fromIndex != -1 ) {\n\t\t\texpression = sql.substring( \"select \".length(), fromIndex );\n\t\t}\n\t\telse {\n\t\t\texpression = sql.substring( \"select \".length() );\n\t\t}\n\t\treturn expression;\n\t}\n\n\tprivate ImmutableFetchList fetchProcessor(FetchParent fetchParent, LoaderSqlAstCreationState creationState) {\n\t\tfinal FetchableContainer fetchableContainer = fetchParent.getReferencedMappingContainer();\n\t\tfinal int size = fetchableContainer.getNumberOfFetchables();\n\t\tfinal ImmutableFetchList.Builder fetches = new ImmutableFetchList.Builder( fetchableContainer );\n\n\t\tfor ( int i = 0; i < size; i++ ) {\n\t\t\tfinal Fetchable fetchable = fetchableContainer.getFetchable( i );\n\t\t\t// Ignore plural attributes\n\t\t\tif ( !( fetchable instanceof PluralAttributeMapping ) ) {\n\t\t\t\tfinal FetchTiming fetchTiming = fetchable.getMappedFetchOptions().getTiming();\n\t\t\t\tif ( fetchable.asBasicValuedModelPart() != null ) {\n\t\t\t\t\t// Ignore lazy basic columns\n\t\t\t\t\tif ( fetchTiming == FetchTiming.DELAYED ) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if ( fetchable instanceof Association ) {\n\t\t\t\t\tfinal Association association = (Association) fetchable;\n\t\t\t\t\t// Ignore the fetchable if the FK is on the other side\n\t\t\t\t\tif ( association.getSideNature() == ForeignKeyDescriptor.Nature.TARGET ) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t// Ensure the FK comes from the root table\n\t\t\t\t\tif ( !getRootTableName().equals( association.getForeignKeyDescriptor().getKeyTable() ) ) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif ( fetchTiming == null ) {\n\t\t\t\t\tthrow new AssertionFailure(\"fetchTiming was null\");\n\t\t\t\t}\n\n\t\t\t\tif ( fetchable.isSelectable() ) {\n\t\t\t\t\tfinal Fetch fetch = fetchParent.generateFetchableFetch(\n\t\t\t\t\t\t\tfetchable,\n\t\t\t\t\t\t\tfetchParent.resolveNavigablePath( fetchable ),\n\t\t\t\t\t\t\tfetchTiming,\n\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\tnull,\n\t\t\t\t\t\t\tcreationState\n\t\t\t\t\t);\n\t\t\t\t\tfetches.add( fetch );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn fetches.build();\n\t}\n\n\t@Override\n\tpublic String[] getIdentifierAliases(String suffix) {\n\t\t// NOTE: this assumes something about how propertySelectFragment is implemented by the subclass!\n\t\t// was toUnquotedAliasStrings( getIdentifierColumnNames() ) before - now tried\n\t\t// to remove that unquoting and missing aliases\n\t\treturn new Alias( suffix ).toAliasStrings( getIdentifierAliases() );\n\t}\n\n\t@Override\n\tpublic String[] getPropertyAliases(String suffix, int i) {\n\t\t// NOTE: this assumes something about how propertySelectFragment is implemented by the subclass!\n\t\treturn new Alias( suffix ).toUnquotedAliasStrings( propertyColumnAliases[i] );\n\t}\n\n\t@Override\n\tpublic String getDiscriminatorAlias(String suffix) {\n\t\t// NOTE: this assumes something about how propertySelectFragment is implemented by the subclass!\n\t\t// toUnquotedAliasStrings( getDiscriminatorColumnName() ) before - now tried\n\t\t// to remove that unquoting and missing aliases\n\t\treturn entityMetamodel.hasSubclasses()\n\t\t\t\t? new Alias( suffix ).toAliasString( getDiscriminatorAlias() )\n\t\t\t\t: null;\n\t}\n\n\t@Override\n\tpublic Object[] getDatabaseSnapshot(Object id, SharedSessionContractImplementor session) throws HibernateException {\n\t\treturn singleIdLoader.loadDatabaseSnapshot( id, session );\n\t}\n\n\t@Override\n\tpublic Object getIdByUniqueKey(Object key, String uniquePropertyName, SharedSessionContractImplementor session) {\n\t\tif ( LOG.isTraceEnabled() ) {\n\t\t\tLOG.tracef(\n\t\t\t\t\t\"resolving unique key [%s] to identifier for entity [%s]\",\n\t\t\t\t\tkey,\n\t\t\t\t\tgetEntityName()\n\t\t\t);\n\t\t}\n\n\t\treturn getUniqueKeyLoader( uniquePropertyName, session ).resolveId( key, session );\n\t}\n\n\n\t/**\n\t * Generate the SQL that selects the version number by id\n\t */\n\tpublic String generateSelectVersionString() {\n\t\tfinal SimpleSelect select = new SimpleSelect( getFactory() ).setTableName( getVersionedTableName() );\n\t\tif ( isVersioned() ) {\n\t\t\tselect.addColumn( getVersionColumnName(), VERSION_COLUMN_ALIAS );\n\t\t}\n\t\telse {\n\t\t\tselect.addColumns( rootTableKeyColumnNames );\n\t\t}\n\t\tif ( getFactory().getSessionFactoryOptions().isCommentsEnabled() ) {\n\t\t\tselect.setComment( \"get version \" + getEntityName() );\n\t\t}\n\t\treturn select.addRestriction( rootTableKeyColumnNames ).toStatementString();\n\t}\n\n\tprotected GeneratedValuesProcessor createGeneratedValuesProcessor(\n\t\t\tEventType timing,\n\t\t\tList<AttributeMapping> generatedAttributes) {\n\t\treturn new GeneratedValuesProcessor( this, generatedAttributes, timing, getFactory() );\n\t}\n\n\t@Override\n\tpublic Object forceVersionIncrement(Object id, Object currentVersion, SharedSessionContractImplementor session) {\n\t\tassert getMappedTableDetails().getTableName().equals( getVersionedTableName() );\n\t\tfinal Object nextVersion = calculateNextVersion( id, currentVersion, session );\n\t\tupdateCoordinator.forceVersionIncrement( id, currentVersion, nextVersion, session );\n\t\treturn nextVersion;\n\t}\n\n\t@Override\n\tpublic Object forceVersionIncrement(\n\t\t\tObject id,\n\t\t\tObject currentVersion,\n\t\t\tboolean batching,\n\t\t\tSharedSessionContractImplementor session) throws HibernateException {\n\t\tassert getMappedTableDetails().getTableName().equals( getVersionedTableName() );\n\t\tfinal Object nextVersion = calculateNextVersion( id, currentVersion, session );\n\t\tupdateCoordinator.forceVersionIncrement( id, currentVersion, nextVersion, batching, session );\n\t\treturn nextVersion;\n\t}\n\n\tprivate Object calculateNextVersion(Object id, Object currentVersion, SharedSessionContractImplementor session) {\n\t\tif ( !isVersioned() ) {\n\t\t\tthrow new AssertionFailure( \"cannot force version increment on non-versioned entity\" );\n\t\t}\n\n\t\tif ( isVersionGeneratedOnExecution() ) {\n\t\t\t// the difficulty here is exactly what we update in order to\n\t\t\t// force the version to be incremented in the db...\n\t\t\tthrow new HibernateException( \"LockMode.FORCE is currently not supported for generated version properties\" );\n\n\t\t}\n\n\t\tfinal EntityVersionMapping versionMapping = getVersionMapping();\n\t\tfinal Object nextVersion = getVersionJavaType().next(\n\t\t\t\tcurrentVersion,\n\t\t\t\tversionMapping.getLength(),\n\t\t\t\tversionMapping.getTemporalPrecision() != null\n\t\t\t\t\t\t? versionMapping.getTemporalPrecision()\n\t\t\t\t\t\t: versionMapping.getPrecision(),\n\t\t\t\tversionMapping.getScale(),\n\t\t\t\tsession\n\t\t);\n\t\tif ( LOG.isTraceEnabled() ) {\n\t\t\tLOG.trace(\n\t\t\t\t\t\"Forcing version increment [\" + infoString( this, id, getFactory() ) + \"; \"\n\t\t\t\t\t\t\t+ getVersionType().toLoggableString( currentVersion, getFactory() ) + \" -> \"\n\t\t\t\t\t\t\t+ getVersionType().toLoggableString( nextVersion, getFactory() ) + \"]\"\n\t\t\t);\n\t\t}\n\t\treturn nextVersion;\n\t}\n\n\t/**\n\t * Retrieve the version number\n\t */\n\t@Override\n\tpublic Object getCurrentVersion(Object id, SharedSessionContractImplementor session) throws HibernateException {\n\n\t\tif ( LOG.isTraceEnabled() ) {\n\t\t\tLOG.tracev( \"Getting version: {0}\", infoString( this, id, getFactory() ) );\n\t\t}\n\t\tfinal String versionSelectString = getVersionSelectString();\n\t\ttry {\n\t\t\tfinal JdbcCoordinator jdbcCoordinator = session.getJdbcCoordinator();\n\t\t\tfinal PreparedStatement st = jdbcCoordinator.getStatementPreparer().prepareStatement( versionSelectString );\n\t\t\ttry {\n\t\t\t\tgetIdentifierType().nullSafeSet( st, id, 1, session );\n\t\t\t\tfinal ResultSet rs = jdbcCoordinator.getResultSetReturn().extract( st, versionSelectString );\n\t\t\t\ttry {\n\t\t\t\t\tif ( !rs.next() ) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\tif ( !isVersioned() ) {\n\t\t\t\t\t\treturn this;\n\t\t\t\t\t}\n\t\t\t\t\treturn getVersionMapping().getJdbcMapping().getJdbcValueExtractor().extract( rs, 1, session );\n\t\t\t\t}\n\t\t\t\tfinally {\n\t\t\t\t\tjdbcCoordinator.getLogicalConnection().getResourceRegistry().release( rs, st );\n\t\t\t\t}\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tjdbcCoordinator.getLogicalConnection().getResourceRegistry().release( st );\n\t\t\t\tjdbcCoordinator.afterStatementExecution();\n\t\t\t}\n\t\t}\n\t\tcatch ( SQLException e ) {\n\t\t\tthrow session.getJdbcServices().getSqlExceptionHelper().convert(\n\t\t\t\t\te,\n\t\t\t\t\t\"could not retrieve version: \" + infoString( this, id, getFactory() ),\n\t\t\t\t\tversionSelectString\n\t\t\t);\n\t\t}\n\t}\n\n\t@Override\n\tpublic JdbcMapping getJdbcMapping(int index) {\n\t\treturn getIdentifierMapping().getJdbcMapping( index );\n\t}\n\n\tprotected LockingStrategy generateLocker(LockMode lockMode) {\n\t\treturn factory.getJdbcServices().getDialect().getLockingStrategy( this, lockMode );\n\t}\n\n\tprivate LockingStrategy getLocker(LockMode lockMode) {\n\t\treturn lockers.computeIfAbsent( lockMode, this::generateLocker );\n\t}\n\n\t@Override\n\tpublic void lock(\n\t\t\tObject id,\n\t\t\tObject version,\n\t\t\tObject object,\n\t\t\tLockMode lockMode,\n\t\t\tEventSource session) throws HibernateException {\n\t\tgetLocker( lockMode ).lock( id, version, object, LockOptions.WAIT_FOREVER, session );\n\t}\n\n\t@Override\n\tpublic void lock(\n\t\t\tObject id,\n\t\t\tObject version,\n\t\t\tObject object,\n\t\t\tLockOptions lockOptions,\n\t\t\tEventSource session) throws HibernateException {\n\t\tgetLocker( lockOptions.getLockMode() ).lock( id, version, object, lockOptions.getTimeOut(), session );\n\t}\n\n\t@Override\n\tpublic String getRootTableName() {\n\t\treturn getSubclassTableName( 0 );\n\t}\n\n\t@Override\n\tpublic String[] getRootTableIdentifierColumnNames() {\n\t\treturn getRootTableKeyColumnNames();\n\t}\n\n\t/**\n\t * {@inheritDoc}\n\t *\n\t * Warning:\n\t * When there are duplicated property names in the subclasses\n\t * then this method may return the wrong results.\n\t * To ensure correct results, this method should only be used when\n\t * {@literal this} is the concrete EntityPersister (since the\n\t * concrete EntityPersister cannot have duplicated property names).\n\t */\n\t@Override\n\tpublic String[] toColumns(String propertyName) throws QueryException {\n\t\treturn propertyMapping.getColumnNames( propertyName );\n\t}\n\n\t/**\n\t * {@inheritDoc}\n\t *\n\t * Warning:\n\t * When there are duplicated property names in the subclasses\n\t * then this method may return the wrong results.\n\t * To ensure correct results, this method should only be used when\n\t * {@literal this} is the concrete EntityPersister (since the\n\t * concrete EntityPersister cannot have duplicated property names).\n\t */\n\t@Override\n\tpublic String[] getPropertyColumnNames(String propertyName) {\n\t\treturn propertyMapping.getColumnNames( propertyName );\n\t}\n\n\t/**\n\t * Warning:\n\t * When there are duplicated property names in the subclasses\n\t * of the class, this method may return the wrong table\n\t * number for the duplicated subclass property. Note that\n\t * SingleTableEntityPersister defines an overloaded form\n\t * which takes the entity name.\n\t */\n\tpublic int getSubclassPropertyTableNumber(String propertyPath) {\n\t\tthrow new UnsupportedOperationException();\n//\t\tString rootPropertyName = StringHelper.root( propertyPath );\n//\t\tType type = propertyMapping.toType( rootPropertyName );\n//\t\tif ( type.isAssociationType() ) {\n//\t\t\tAssociationType assocType = (AssociationType) type;\n//\t\t\tif ( assocType.useLHSPrimaryKey() ) {\n//\t\t\t\t// performance op to avoid the array search\n//\t\t\t\treturn 0;\n//\t\t\t}\n//\t\t\telse if ( type.isCollectionType() ) {\n//\t\t\t\t// properly handle property-ref-based associations\n//\t\t\t\trootPropertyName = assocType.getLHSPropertyName();\n//\t\t\t}\n//\t\t}\n//\t\t//Enable for HHH-440, which we don't like:\n//\t\t/*if ( type.isComponentType() && !propertyName.equals(rootPropertyName) ) {\n//\t\t\tString unrooted = StringHelper.unroot(propertyName);\n//\t\t\tint idx = ArrayHelper.indexOf( getSubclassColumnClosure(), unrooted );\n//\t\t\tif ( idx != -1 ) {\n//\t\t\t\treturn getSubclassColumnTableNumberClosure()[idx];\n//\t\t\t}\n//\t\t}*/\n//\t\tint index = ArrayHelper.indexOf( getSubclassPropertyNameClosure(), rootPropertyName ); //TODO: optimize this better!\n//\t\treturn index == -1 ? 0 : getSubclassPropertyTableNumber( index );\n\t}\n\n\tprivate DiscriminatorType<?> discriminatorType;\n\n\tprotected DiscriminatorType<?> resolveDiscriminatorType() {\n\t\tif ( discriminatorType == null ) {\n\t\t\tdiscriminatorType = buildDiscriminatorType();\n\t\t}\n\t\treturn discriminatorType;\n\t}\n\n\tprivate DiscriminatorType<?> buildDiscriminatorType() {\n\t\tfinal BasicType<?> underlingJdbcMapping = getDiscriminatorType();\n\t\tif ( underlingJdbcMapping == null ) {\n\t\t\treturn null;\n\t\t}\n\n\t\tfinal JavaTypeRegistry javaTypeRegistry = factory.getTypeConfiguration().getJavaTypeRegistry();\n\n\t\tfinal JavaType<Object> domainJavaType;\n\t\tif ( representationStrategy.getMode() == POJO\n\t\t\t\t&& getEntityName().equals( getJavaType().getJavaTypeClass().getName() ) ) {\n\t\t\tdomainJavaType = javaTypeRegistry.resolveDescriptor( Class.class );\n\t\t}\n\t\telse {\n\t\t\tdomainJavaType = javaTypeRegistry.resolveDescriptor( String.class );\n\t\t}\n\n\t\t//noinspection rawtypes\n\t\tfinal DiscriminatorConverter converter = MappedDiscriminatorConverter.fromValueMappings(\n\t\t\t\tgetNavigableRole().append( EntityDiscriminatorMapping.DISCRIMINATOR_ROLE_NAME ),\n\t\t\t\tdomainJavaType,\n\t\t\t\tunderlingJdbcMapping,\n\t\t\t\tgetSubclassByDiscriminatorValue(),\n\t\t\t\tfactory.getMappingMetamodel()\n\t\t);\n\n\t\t//noinspection unchecked,rawtypes\n\t\treturn new DiscriminatorTypeImpl( underlingJdbcMapping, converter );\n\t}\n\n\t@Override\n\tpublic DiscriminatorMetadata getTypeDiscriminatorMetadata() {\n\t\treturn this::buildDiscriminatorType;\n\t}\n\n\tpublic static String generateTableAlias(String rootAlias, int tableNumber) {\n\t\tif ( tableNumber == 0 ) {\n\t\t\treturn rootAlias;\n\t\t}\n\t\tfinal StringBuilder alias = new StringBuilder().append( rootAlias );\n\t\tif ( !rootAlias.endsWith( \"_\" ) ) {\n\t\t\talias.append( '_' );\n\t\t}\n\t\treturn alias.append( tableNumber ).append( '_' ).toString();\n\t}\n\n\tprivate int getSubclassPropertyIndex(String propertyName) {\n\t\treturn ArrayHelper.indexOf( subclassPropertyNameClosure, propertyName );\n\t}\n\n\tpublic String[] getPropertyColumnNames(int i) {\n\t\treturn propertyColumnNames[i];\n\t}\n\n\tpublic boolean hasFormulaProperties() {\n\t\treturn hasFormulaProperties;\n\t}\n\n\tpublic FetchMode getFetchMode(int i) {\n\t\treturn subclassPropertyFetchModeClosure[i];\n\t}\n\n\tpublic Type getSubclassPropertyType(int i) {\n\t\treturn subclassPropertyTypeClosure[i];\n\t}\n\n\t@Override\n\tpublic int countSubclassProperties() {\n\t\treturn subclassPropertyTypeClosure.length;\n\t}\n\n\t@Override\n\tpublic String[] getSubclassPropertyColumnNames(int i) {\n\t\treturn subclassPropertyColumnNameClosure[i];\n\t}\n\n\tpublic String[][] getSubclassPropertyFormulaTemplateClosure() {\n\t\treturn subclassPropertyFormulaTemplateClosure;\n\t}\n\n\tprotected Type[] getSubclassPropertyTypeClosure() {\n\t\treturn subclassPropertyTypeClosure;\n\t}\n\n\tprotected String[][] getSubclassPropertyColumnNameClosure() {\n\t\treturn subclassPropertyColumnNameClosure;\n\t}\n\n\tpublic String[][] getSubclassPropertyColumnReaderClosure() {\n\t\treturn subclassPropertyColumnReaderClosure;\n\t}\n\n\tpublic String[][] getSubclassPropertyColumnReaderTemplateClosure() {\n\t\treturn subclassPropertyColumnReaderTemplateClosure;\n\t}\n\n\tprotected String[] getSubclassPropertyNameClosure() {\n\t\treturn subclassPropertyNameClosure;\n\t}\n\n\tprivate static boolean isPrefix(final AttributeMapping attributeMapping, final String currentAttributeName) {\n\t\tfinal String attributeName = attributeMapping.getAttributeName();\n\t\tfinal int nameLength = attributeName.length();\n\t\treturn currentAttributeName.startsWith( attributeName )\n\t\t\t&& ( currentAttributeName.length() == nameLength || currentAttributeName.charAt(nameLength) == '.' );\n\t}\n\n\t@Override\n\tpublic int[] resolveAttributeIndexes(String[] attributeNames) {\n\t\tif ( attributeNames == null || attributeNames.length == 0 ) {\n\t\t\treturn ArrayHelper.EMPTY_INT_ARRAY;\n\t\t}\n\t\tfinal List<Integer> fields = new ArrayList<>( attributeNames.length );\n\n\t\t// Sort attribute names so that we can traverse mappings efficiently\n\t\tArrays.sort( attributeNames );\n\n\t\tint index = 0;\n\t\tfor ( int i = 0; i < attributeMappings.size(); i++ ) {\n\t\t\tfinal AttributeMapping attributeMapping = attributeMappings.get( i );\n\t\t\tif ( isPrefix( attributeMapping, attributeNames[index] ) ) {\n\t\t\t\tfields.add( attributeMapping.getStateArrayPosition() );\n\t\t\t\tindex++;\n\t\t\t\tif ( index < attributeNames.length ) {\n\t\t\t\t\t// Skip duplicates\n\t\t\t\t\tdo {\n\t\t\t\t\t\tif ( attributeNames[index].equals( attributeMapping.getAttributeName() ) ) {\n\t\t\t\t\t\t\tindex++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t} while ( index < attributeNames.length );\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn toIntArray( fields );\n\t}\n\n\t@Override\n\tpublic int[] resolveDirtyAttributeIndexes(\n\t\t\tfinal Object[] currentState,\n\t\t\tfinal Object[] previousState,\n\t\t\tfinal String[] attributeNames,\n\t\t\tfinal SessionImplementor session) {\n\t\tfinal BitSet mutablePropertiesIndexes = entityMetamodel.getMutablePropertiesIndexes();\n\t\tfinal int estimatedSize = attributeNames == null ? 0 : attributeNames.length + mutablePropertiesIndexes.cardinality();\n\t\tfinal List<Integer> fields = new ArrayList<>( estimatedSize );\n\t\tif ( estimatedSize == 0 ) {\n\t\t\treturn ArrayHelper.EMPTY_INT_ARRAY;\n\t\t}\n\t\tif ( !mutablePropertiesIndexes.isEmpty() ) {\n\t\t\t// We have to check the state for \"mutable\" properties as dirty tracking isn't aware of mutable types\n\t\t\tfinal Type[] propertyTypes = entityMetamodel.getPropertyTypes();\n\t\t\tfinal boolean[] propertyCheckability = entityMetamodel.getPropertyCheckability();\n\t\t\tfor ( int i = mutablePropertiesIndexes.nextSetBit(0); i >= 0;\n\t\t\t\t\ti = mutablePropertiesIndexes.nextSetBit(i + 1) ) {\n\t\t\t\t// This is kindly borrowed from org.hibernate.type.TypeHelper.findDirty\n\t\t\t\tif ( isDirty( currentState, previousState, propertyTypes, propertyCheckability, i, session ) ) {\n\t\t\t\t\tfields.add( i );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ( attributeNames.length != 0 ) {\n\t\t\tfinal boolean[] propertyUpdateability = entityMetamodel.getPropertyUpdateability();\n\t\t\tif ( superMappingType == null ) {\n\t\t\t\t/*\n\t\t\t\t\t\tSort attribute names so that we can traverse mappings efficiently\n\t\t\t\t\t\twe cannot do this when there is a supertype because given:\n\n\t\t\t\t\t\tclass SuperEntity {\n\t\t\t\t\t\t\tprivate String bSuper;\n\t\t\t\t\t\t\tprivate String aSuper;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tclass ChildEntity extends SuperEntity {\n\t\t\t\t\t\t\tprivate String aChild;\n\t\t\t\t\t\t\tprivate String bChild;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t`attributeMappings` contains { aSuper, bSuper, aChild, bChild\t}\n\t\t\t\t\t\twhile the sorted `attributeNames` { aChild, aSuper, bChild, bSuper }\n\t\t\t\t */\n\n\t\t\t\tArrays.sort( attributeNames );\n\t\t\t\tint index = 0;\n\t\t\t\tfor ( int i = 0; i < attributeMappings.size(); i++ ) {\n\t\t\t\t\tfinal AttributeMapping attributeMapping = attributeMappings.get( i );\n\t\t\t\t\tfinal String attributeName = attributeMapping.getAttributeName();\n\t\t\t\t\tif ( isPrefix( attributeMapping, attributeNames[index] ) ) {\n\t\t\t\t\t\tfinal int position = attributeMapping.getStateArrayPosition();\n\t\t\t\t\t\tif ( propertyUpdateability[position] && !fields.contains( position ) ) {\n\t\t\t\t\t\t\tfields.add( position );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tindex++;\n\t\t\t\t\t\tif ( index < attributeNames.length ) {\n\t\t\t\t\t\t\t// Skip duplicates\n\t\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\t\tif ( attributeNames[index].equals( attributeName ) ) {\n\t\t\t\t\t\t\t\t\tindex++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} while ( index < attributeNames.length );\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor ( String attributeName : attributeNames ) {\n\t\t\t\t\tfinal Integer index = entityMetamodel.getPropertyIndexOrNull( attributeName );\n\t\t\t\t\tif ( index != null && propertyUpdateability[index] && !fields.contains( index ) ) {\n\t\t\t\t\t\tfields.add( index );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn toIntArray( fields );\n\t}\n\n\tprivate boolean isDirty(\n\t\t\tObject[] currentState,\n\t\t\tObject[] previousState,\n\t\t\tType[] propertyTypes,\n\t\t\tboolean[] propertyCheckability,\n\t\t\tint i,\n\t\t\tSessionImplementor session) {\n\t\treturn currentState[i] != LazyPropertyInitializer.UNFETCHED_PROPERTY\n\t\t\t\t// Consider mutable properties as dirty if we don't have a previous state\n\t\t\t\t&& ( previousState == null\n\t\t\t\t\t\t|| previousState[i] == LazyPropertyInitializer.UNFETCHED_PROPERTY\n\t\t\t\t\t\t|| propertyCheckability[i]\n\t\t\t\t\t\t\t\t&& propertyTypes[i].isDirty(\n\t\t\t\t\t\t\t\t\t\tpreviousState[i],\n\t\t\t\t\t\t\t\t\t\tcurrentState[i],\n\t\t\t\t\t\t\t\t\t\tpropertyColumnUpdateable[i],\n\t\t\t\t\t\t\t\t\t\tsession\n\t\t\t\t\t\t\t\t)\n\t\t\t\t);\n\t}\n\n\t@Override\n\tpublic Object loadByUniqueKey(\n\t\t\tString propertyName,\n\t\t\tObject uniqueKey,\n\t\t\tSharedSessionContractImplementor session) throws HibernateException {\n\t\treturn loadByUniqueKey( propertyName, uniqueKey, null, session );\n\t}\n\n\tpublic Object loadByUniqueKey(\n\t\t\tString propertyName,\n\t\t\tObject uniqueKey,\n\t\t\tBoolean readOnly,\n\t\t\tSharedSessionContractImplementor session) throws HibernateException {\n\t\treturn getUniqueKeyLoader( propertyName, session ).load( uniqueKey, LockOptions.NONE, readOnly, session );\n\t}\n\n\tprivate Map<SingularAttributeMapping, SingleUniqueKeyEntityLoader<?>> uniqueKeyLoadersNew;\n\n\tprotected SingleUniqueKeyEntityLoader<?> getUniqueKeyLoader(String attributeName, SharedSessionContractImplementor session) {\n\t\tfinal SingularAttributeMapping attribute = (SingularAttributeMapping) findByPath( attributeName );\n\t\tfinal LoadQueryInfluencers influencers = session.getLoadQueryInfluencers();\n\t\t// no subselect fetching for entities for now\n\t\tif ( isAffectedByInfluencers( influencers, true ) ) {\n\t\t\treturn new SingleUniqueKeyEntityLoaderStandard<>(\n\t\t\t\t\tthis,\n\t\t\t\t\tattribute,\n\t\t\t\t\tinfluencers\n\t\t\t);\n\t\t}\n\t\tfinal SingleUniqueKeyEntityLoader<?> existing;\n\t\tif ( uniqueKeyLoadersNew == null ) {\n\t\t\tuniqueKeyLoadersNew = new ConcurrentHashMap<>();\n\t\t\texisting = null;\n\t\t}\n\t\telse {\n\t\t\texisting = uniqueKeyLoadersNew.get( attribute );\n\t\t}\n\n\t\tif ( existing != null ) {\n\t\t\treturn existing;\n\t\t}\n\t\telse {\n\t\t\tfinal SingleUniqueKeyEntityLoader<?> loader =\n\t\t\t\t\tnew SingleUniqueKeyEntityLoaderStandard<>( this, attribute, new LoadQueryInfluencers( factory ) );\n\t\t\tuniqueKeyLoadersNew.put( attribute, loader );\n\t\t\treturn loader;\n\t\t}\n\t}\n\n\t@Override\n\tpublic int getPropertyIndex(String propertyName) {\n\t\treturn entityMetamodel.getPropertyIndex( propertyName );\n\t}\n\n\tprivate void initOrdinaryPropertyPaths(Metadata mapping) throws MappingException {\n\t\tfor ( int i = 0; i < getSubclassPropertyNameClosure().length; i++ ) {\n\t\t\tpropertyMapping.initPropertyPaths(\n\t\t\t\t\tgetSubclassPropertyNameClosure()[i],\n\t\t\t\t\tgetSubclassPropertyTypeClosure()[i],\n\t\t\t\t\tgetSubclassPropertyColumnNameClosure()[i],\n\t\t\t\t\tgetSubclassPropertyColumnReaderClosure()[i],\n\t\t\t\t\tgetSubclassPropertyColumnReaderTemplateClosure()[i],\n\t\t\t\t\tgetSubclassPropertyFormulaTemplateClosure()[i],\n\t\t\t\t\tmapping\n\t\t\t);\n\t\t}\n\t}\n\n\tprivate void initIdentifierPropertyPaths(Metadata mapping) throws MappingException {\n\t\tString idProp = getIdentifierPropertyName();\n\t\tif ( idProp != null ) {\n\t\t\tpropertyMapping.initPropertyPaths(\n\t\t\t\t\tidProp, getIdentifierType(), getIdentifierColumnNames(),\n\t\t\t\t\tgetIdentifierColumnReaders(), getIdentifierColumnReaderTemplates(), null, mapping\n\t\t\t);\n\t\t}\n\t\tif ( entityMetamodel.getIdentifierProperty().isEmbedded() ) {\n\t\t\tpropertyMapping.initPropertyPaths(\n\t\t\t\t\tnull, getIdentifierType(), getIdentifierColumnNames(),\n\t\t\t\t\tgetIdentifierColumnReaders(), getIdentifierColumnReaderTemplates(), null, mapping\n\t\t\t);\n\t\t}\n\t\tif ( !entityMetamodel.hasNonIdentifierPropertyNamedId() ) {\n\t\t\tpropertyMapping.initPropertyPaths(\n\t\t\t\t\tENTITY_ID, getIdentifierType(), getIdentifierColumnNames(),\n\t\t\t\t\tgetIdentifierColumnReaders(), getIdentifierColumnReaderTemplates(), null, mapping\n\t\t\t);\n\t\t}\n\t}\n\n\tprivate void initDiscriminatorPropertyPath(Metadata mapping) {\n\t\tpropertyMapping.initPropertyPaths(\n\t\t\t\tENTITY_CLASS,\n\t\t\t\tgetDiscriminatorType(),\n\t\t\t\tnew String[] {getDiscriminatorColumnName()},\n\t\t\t\tnew String[] {getDiscriminatorColumnReaders()},\n\t\t\t\tnew String[] {getDiscriminatorColumnReaderTemplate()},\n\t\t\t\tnew String[] {getDiscriminatorFormulaTemplate()},\n\t\t\t\tmapping\n\t\t);\n\t}\n\n\tprotected void initPropertyPaths(Metadata mapping) throws MappingException {\n\t\tinitOrdinaryPropertyPaths( mapping );\n\t\tinitOrdinaryPropertyPaths( mapping ); //do two passes, for collection property-ref!\n\t\tinitIdentifierPropertyPaths( mapping );\n\t\tif ( entityMetamodel.isPolymorphic() ) {\n\t\t\tinitDiscriminatorPropertyPath( mapping );\n\t\t}\n\t}\n\n\tprotected boolean check(\n\t\t\tint rows,\n\t\t\tObject id,\n\t\t\tint tableNumber,\n\t\t\tExpectation expectation,\n\t\t\tPreparedStatement statement,\n\t\t\tString statementSQL) throws HibernateException {\n\t\ttry {\n\t\t\texpectation.verifyOutcome( rows, statement, -1, statementSQL );\n\t\t}\n\t\tcatch ( StaleStateException e ) {\n\t\t\tif ( !isNullableTable( tableNumber ) ) {\n\t\t\t\tfinal StatisticsImplementor statistics = getFactory().getStatistics();\n\t\t\t\tif ( statistics.isStatisticsEnabled() ) {\n\t\t\t\t\tstatistics.optimisticFailure( getEntityName() );\n\t\t\t\t}\n\t\t\t\tthrow new StaleObjectStateException( getEntityName(), id );\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\tcatch ( TooManyRowsAffectedException e ) {\n\t\t\tthrow new HibernateException(\n\t\t\t\t\t\"Duplicate identifier in table for: \" +\n\t\t\t\t\t\t\tinfoString( this, id, getFactory() )\n\t\t\t);\n\t\t}\n\t\tcatch ( Throwable t ) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\tpublic final boolean checkVersion(final boolean[] includeProperty) {\n\t\treturn includeProperty[getVersionProperty()] || isVersionGeneratedOnExecution();\n\t}\n\n\t@Override\n\tpublic String getIdentitySelectString() {\n\t\treturn identitySelectString;\n\t}\n\n\t@Override\n\tpublic String getSelectByUniqueKeyString(String propertyName) {\n\t\treturn getSelectByUniqueKeyString( new String[] { propertyName } );\n\t}\n\n\t@Override\n\tpublic String getSelectByUniqueKeyString(String[] propertyNames) {\n\t\tfinal SimpleSelect select = new SimpleSelect( getFactory() )\n\t\t\t\t.setTableName( getTableName(0) )\n\t\t\t\t.addColumns( getKeyColumns(0) );\n\t\tfor ( int i = 0; i < propertyNames.length; i++ ) {\n\t\t\tselect.addRestriction( getPropertyColumnNames( propertyNames[i] ) );\n\t\t}\n\t\treturn select.toStatementString();\n\t}\n\n\t@Override\n\tpublic String getSelectByUniqueKeyString(String[] propertyNames, String[] columnNames) {\n\t\tfinal SimpleSelect select = new SimpleSelect( getFactory() )\n\t\t\t\t.setTableName( getTableName( 0 ) )\n\t\t\t\t.addColumns( columnNames );\n\t\tfor ( final String propertyName : propertyNames ) {\n\t\t\tselect.addRestriction( getPropertyColumnNames( propertyName ) );\n\t\t}\n\t\treturn select.toStatementString();\n\t}\n\n\t@Override\n\tpublic GeneratedValuesMutationDelegate getInsertDelegate() {\n\t\treturn insertDelegate;\n\t}\n\n\t@Override\n\tpublic GeneratedValuesMutationDelegate getUpdateDelegate() {\n\t\treturn updateDelegate;\n\t}\n\n\t@Override\n\tpublic EntityTableMapping[] getTableMappings() {\n\t\treturn tableMappings;\n\t}\n\n\tprotected EntityTableMapping getTableMapping(int i) {\n\t\treturn tableMappings[i];\n\t}\n\n\t/**\n\t * Unfortunately we cannot directly use `SelectableMapping#getContainingTableExpression()`\n\t * as that blows up for attributes declared on super-type for union-subclass mappings\n\t */\n\t@Override\n\tpublic String physicalTableNameForMutation(SelectableMapping selectableMapping) {\n\t\tassert !selectableMapping.isFormula();\n\t\treturn selectableMapping.getContainingTableExpression();\n\t}\n\n\t@Override\n\tpublic EntityMappingType getTargetPart() {\n\t\treturn this;\n\t}\n\n\t@Override\n\tpublic void forEachMutableTable(Consumer<EntityTableMapping> consumer) {\n\t\tfor ( int i = 0; i < tableMappings.length; i++ ) {\n\t\t\t// inverse tables are not mutable from this mapping\n\t\t\tif ( !tableMappings[i].isInverse() ) {\n\t\t\t\tconsumer.accept( tableMappings[i] );\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic void forEachMutableTableReverse(Consumer<EntityTableMapping> consumer) {\n\t\tfor ( int i = tableMappings.length - 1; i >= 0; i-- ) {\n\t\t\t// inverse tables are not mutable from this mapping\n\t\t\tif ( !tableMappings[i].isInverse() ) {\n\t\t\t\tconsumer.accept( tableMappings[i] );\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic String getIdentifierTableName() {\n\t\treturn getTableName( 0 );\n\t}\n\n\t@Override\n\tpublic EntityTableMapping getIdentifierTableMapping() {\n\t\treturn tableMappings[0];\n\t}\n\n\t@Override\n\tpublic ModelPart getIdentifierDescriptor() {\n\t\treturn identifierMapping;\n\t}\n\n\t@Override\n\tpublic boolean hasSkippableTables() {\n\t\treturn false;\n\t}\n\n\tprotected boolean hasAnySkippableTables(boolean[] optionalTables, boolean[] inverseTables) {\n\t\t// todo (6.x) : cache this?\n\t\tfor ( int i = 0; i < optionalTables.length; i++ ) {\n\t\t\tif ( optionalTables[i] ) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\tfor ( int i = 0; i < inverseTables.length; i++ ) {\n\t\t\tif ( inverseTables[i] ) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tprotected void logStaticSQL() {\n\t\tif ( LOG.isDebugEnabled() ) {\n\t\t\tLOG.debugf( \"Static SQL for entity: %s\", getEntityName() );\n\t\t\tfor ( Map.Entry<String, SingleIdArrayLoadPlan> entry : lazyLoadPlanByFetchGroup.entrySet() ) {\n\t\t\t\tLOG.debugf( \" Lazy select (%s) : %s\", entry.getKey(), entry.getValue().getJdbcSelect().getSqlString() );\n\t\t\t}\n\t\t\tif ( sqlVersionSelectString != null ) {\n\t\t\t\tLOG.debugf( \" Version select: %s\", sqlVersionSelectString );\n\t\t\t}\n\n\t\t\t{\n\t\t\t\tfinal MutationOperationGroup staticInsertGroup = insertCoordinator.getStaticMutationOperationGroup();\n\t\t\t\tif ( staticInsertGroup != null ) {\n\t\t\t\t\tfor ( int i = 0; i < staticInsertGroup.getNumberOfOperations(); i++ ) {\n\t\t\t\t\t\tfinal MutationOperation mutation = staticInsertGroup.getOperation( i );\n\t\t\t\t\t\tif ( mutation instanceof JdbcOperation ) {\n\t\t\t\t\t\t\tLOG.debugf( \" Insert (%s): %s\", i, ( (JdbcOperation) mutation ).getSqlString() );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t{\n\t\t\t\tfinal MutationOperationGroup staticUpdateGroup = updateCoordinator.getStaticMutationOperationGroup();\n\t\t\t\tif ( staticUpdateGroup != null ) {\n\t\t\t\t\tfor ( int i = 0; i < staticUpdateGroup.getNumberOfOperations(); i++ ) {\n\t\t\t\t\t\tfinal MutationOperation mutation = staticUpdateGroup.getOperation( i );\n\t\t\t\t\t\tif ( mutation instanceof JdbcOperation ) {\n\t\t\t\t\t\t\tLOG.debugf( \" Update (%s): %s\", i, ( (JdbcOperation) mutation ).getSqlString() );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t{\n\t\t\t\tfinal MutationOperationGroup staticDeleteGroup = deleteCoordinator.getStaticMutationOperationGroup();\n\t\t\t\tif ( staticDeleteGroup != null ) {\n\t\t\t\t\tfor ( int i = 0; i < staticDeleteGroup.getNumberOfOperations(); i++ ) {\n\t\t\t\t\t\tfinal MutationOperation mutation = staticDeleteGroup.getOperation( i );\n\t\t\t\t\t\tif ( mutation instanceof JdbcOperation ) {\n\t\t\t\t\t\t\tLOG.debugf( \" Delete (%s): %s\", i, ( (JdbcOperation) mutation ).getSqlString() );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic abstract Map<Object, String> getSubclassByDiscriminatorValue();\n\n\tpublic abstract String[] getConstraintOrderedTableNameClosure();\n\n\tpublic abstract boolean needsDiscriminator();\n\n\tprotected boolean isDiscriminatorFormula() {\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic TableGroup createRootTableGroup(\n\t\t\tboolean canUseInnerJoins,\n\t\t\tNavigablePath navigablePath,\n\t\t\tString explicitSourceAlias,\n\t\t\tSqlAliasBase explicitSqlAliasBase,\n\t\t\tSupplier<Consumer<Predicate>> additionalPredicateCollectorAccess,\n\t\t\tSqlAstCreationState creationState) {\n\t\tfinal SqlAliasBase sqlAliasBase = SqlAliasBase.from(\n\t\t\t\texplicitSqlAliasBase,\n\t\t\t\texplicitSourceAlias,\n\t\t\t\tthis,\n\t\t\t\tcreationState.getSqlAliasBaseGenerator()\n\t\t);\n\t\tfinal TableReference rootTableReference = new NamedTableReference(\n\t\t\t\tneedsDiscriminator() ? getRootTableName() : getTableName(),\n\t\t\t\tsqlAliasBase.generateNewAlias()\n\t\t);\n\n\t\tfinal TableGroup tableGroup = new StandardTableGroup(\n\t\t\t\tcanUseInnerJoins,\n\t\t\t\tnavigablePath,\n\t\t\t\tthis,\n\t\t\t\texplicitSourceAlias,\n\t\t\t\trootTableReference,\n\t\t\t\ttrue,\n\t\t\t\tsqlAliasBase,\n\t\t\t\tgetRootEntityDescriptor()::containsTableReference,\n\t\t\t\t(tableExpression, tg) -> {\n\t\t\t\t\tfinal String[] subclassTableNames = getSubclassTableNames();\n\t\t\t\t\tfor ( int i = 0; i < subclassTableNames.length; i++ ) {\n\t\t\t\t\t\tif ( tableExpression.equals( subclassTableNames[ i ] ) ) {\n\t\t\t\t\t\t\tfinal NamedTableReference joinedTableReference = new NamedTableReference(\n\t\t\t\t\t\t\t\t\ttableExpression,\n\t\t\t\t\t\t\t\t\tsqlAliasBase.generateNewAlias(),\n\t\t\t\t\t\t\t\t\tisNullableSubclassTable( i )\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\treturn new TableReferenceJoin(\n\t\t\t\t\t\t\t\t\tshouldInnerJoinSubclassTable( i, emptySet() ),\n\t\t\t\t\t\t\t\t\tjoinedTableReference,\n\t\t\t\t\t\t\t\t\tadditionalPredicateCollectorAccess == null\n\t\t\t\t\t\t\t\t\t\t\t? null\n\t\t\t\t\t\t\t\t\t\t\t: generateJoinPredicate(\n\t\t\t\t\t\t\t\t\t\t\t\t\trootTableReference,\n\t\t\t\t\t\t\t\t\t\t\t\t\tjoinedTableReference,\n\t\t\t\t\t\t\t\t\t\t\t\t\tneedsDiscriminator()\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t? getRootTableKeyColumnNames()\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t: getIdentifierColumnNames(),\n\t\t\t\t\t\t\t\t\t\t\t\t\tgetSubclassTableKeyColumns( i ),\n\t\t\t\t\t\t\t\t\t\t\t\t\tcreationState\n\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn null;\n\t\t\t\t},\n\t\t\t\tgetFactory()\n\t\t);\n\n\t\tif ( additionalPredicateCollectorAccess != null ) {\n\t\t\tif ( needsDiscriminator() ) {\n\t\t\t\tfinal String alias = tableGroup.getPrimaryTableReference().getIdentificationVariable();\n\t\t\t\tfinal Predicate discriminatorPredicate = createDiscriminatorPredicate( alias, tableGroup, creationState );\n\t\t\t\tadditionalPredicateCollectorAccess.get().accept( discriminatorPredicate );\n\t\t\t}\n\n\t\t\tif ( softDeleteMapping != null ) {\n\t\t\t\tfinal TableReference tableReference = tableGroup.resolveTableReference( getSoftDeleteTableDetails().getTableName() );\n\t\t\t\tfinal Predicate softDeletePredicate = SoftDeleteHelper.createNonSoftDeletedRestriction(\n\t\t\t\t\t\ttableReference,\n\t\t\t\t\t\tsoftDeleteMapping,\n\t\t\t\t\t\tcreationState.getSqlExpressionResolver()\n\t\t\t\t);\n\t\t\t\tadditionalPredicateCollectorAccess.get().accept( softDeletePredicate );\n\t\t\t\tif ( tableReference != rootTableReference && creationState.supportsEntityNameUsage() ) {\n\t\t\t\t\t// Register entity name usage for the hierarchy root table to avoid pruning\n\t\t\t\t\tcreationState.registerEntityNameUsage( tableGroup, EntityNameUse.EXPRESSION, getRootEntityName() );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn tableGroup;\n\t}\n\n\t@Override\n\tpublic void applyDiscriminator(\n\t\t\tConsumer<Predicate> predicateConsumer,\n\t\t\tString alias,\n\t\t\tTableGroup tableGroup,\n\t\t\tSqlAstCreationState creationState) {\n\t\tif ( needsDiscriminator() ) {\n\t\t\tassert !creationState.supportsEntityNameUsage() : \"Entity name usage should have been used instead\";\n\t\t\tfinal Map<String, EntityNameUse> entityNameUseMap;\n\t\t\tfinal Collection<EntityMappingType> subMappingTypes = getSubMappingTypes();\n\t\t\tentityNameUseMap = new HashMap<>( 1 + subMappingTypes.size() + ( isInherited() ? 1 : 0 ) );\n\t\t\tif ( subMappingTypes.isEmpty() ) {\n\t\t\t\tentityNameUseMap.put( getEntityName(), EntityNameUse.TREAT );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tentityNameUseMap.put( getEntityName(), EntityNameUse.TREAT );\n\t\t\t\t// We need to register TREAT uses for all subtypes when pruning\n\t\t\t\tfor ( EntityMappingType subMappingType : subMappingTypes ) {\n\t\t\t\t\tentityNameUseMap.put( subMappingType.getEntityName(), EntityNameUse.TREAT );\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( isInherited() ) {\n\t\t\t\t// Make sure the table group includes the root table when needed for TREAT\n\t\t\t\ttableGroup.resolveTableReference( getRootTableName() );\n\t\t\t\tentityNameUseMap.put( getRootEntityName(), EntityNameUse.EXPRESSION );\n\t\t\t}\n\t\t\tpruneForSubclasses( tableGroup, entityNameUseMap );\n\t\t}\n\t}\n\n\tprivate Predicate createDiscriminatorPredicate(\n\t\t\tString alias,\n\t\t\tTableGroup tableGroup,\n\t\t\tSqlAstCreationState creationState) {\n\t\tfinal SqlExpressionResolver.ColumnReferenceKey columnReferenceKey;\n\t\tfinal String discriminatorExpression;\n\t\tif ( isDiscriminatorFormula() ) {\n\t\t\tdiscriminatorExpression = getDiscriminatorFormulaTemplate();\n\t\t\tcolumnReferenceKey = createColumnReferenceKey(\n\t\t\t\t\ttableGroup.getPrimaryTableReference(),\n\t\t\t\t\tgetDiscriminatorFormulaTemplate(),\n\t\t\t\t\tgetDiscriminatorType()\n\t\t\t);\n\t\t}\n\t\telse {\n\t\t\tdiscriminatorExpression = getDiscriminatorColumnName();\n\t\t\tcolumnReferenceKey = createColumnReferenceKey(\n\t\t\t\t\ttableGroup.getPrimaryTableReference(),\n\t\t\t\t\tgetDiscriminatorColumnName(),\n\t\t\t\t\tgetDiscriminatorType()\n\t\t\t);\n\t\t}\n\n\t\tfinal BasicType<?> discriminatorType = (BasicType<?>) getDiscriminatorMapping().getJdbcMapping();\n\t\tfinal Expression sqlExpression = creationState.getSqlExpressionResolver().resolveSqlExpression(\n\t\t\t\tcolumnReferenceKey,\n\t\t\t\tsqlAstProcessingState -> new ColumnReference(\n\t\t\t\t\t\talias,\n\t\t\t\t\t\tdiscriminatorExpression,\n\t\t\t\t\t\tisDiscriminatorFormula(),\n\t\t\t\t\t\tnull,\n\t\t\t\t\t\tdiscriminatorType.getJdbcMapping()\n\t\t\t\t)\n\t\t);\n\n\t\treturn createDisciminatorPredicate( discriminatorType, sqlExpression );\n\t}\n\n\tprivate Predicate createDisciminatorPredicate(BasicType<?> discriminatorType, Expression sqlExpression) {\n\t\tif ( hasSubclasses() ) {\n\t\t\treturn createInListPredicate( discriminatorType, sqlExpression );\n\t\t}\n\t\telse {\n\t\t\tfinal Object value = getDiscriminatorValue();\n\t\t\tif ( value == NULL_DISCRIMINATOR ) {\n\t\t\t\treturn new NullnessPredicate( sqlExpression );\n\t\t\t}\n\t\t\telse if ( value == NOT_NULL_DISCRIMINATOR ) {\n\t\t\t\treturn new NegatedPredicate( new NullnessPredicate( sqlExpression ) );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfinal QueryLiteral<Object> literal = new QueryLiteral<>( value, discriminatorType );\n\t\t\t\treturn new ComparisonPredicate( sqlExpression, ComparisonOperator.EQUAL, literal );\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate Predicate createInListPredicate(BasicType<?> discriminatorType, Expression sqlExpression) {\n\t\tfinal List<Expression> values = new ArrayList<>( fullDiscriminatorValues.length );\n\t\tboolean hasNull = false, hasNonNull = false;\n\t\tfor ( Object discriminatorValue : fullDiscriminatorValues ) {\n\t\t\tif ( discriminatorValue == NULL_DISCRIMINATOR ) {\n\t\t\t\thasNull = true;\n\t\t\t}\n\t\t\telse if ( discriminatorValue == NOT_NULL_DISCRIMINATOR ) {\n\t\t\t\thasNonNull = true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tvalues.add( new QueryLiteral<>( discriminatorValue, discriminatorType) );\n\t\t\t}\n\t\t}\n\t\tfinal Predicate predicate = new InListPredicate( sqlExpression, values );\n\t\tif ( hasNull || hasNonNull ) {\n\t\t\tfinal Junction junction = new Junction( Junction.Nature.DISJUNCTION );\n\n\t\t\tif ( hasNull && hasNonNull ) {\n\t\t\t\t// This means we need to select everything, we don't need a predicate at all\n\t\t\t\t// Return an empty Junction\n\t\t\t\treturn junction;\n\t\t\t}\n\n\t\t\tif ( hasNonNull ) {\n\t\t\t\treturn new NullnessPredicate( sqlExpression, true );\n\t\t\t}\n\t\t\telse if ( hasNull ) {\n\t\t\t\tjunction.add( new NullnessPredicate( sqlExpression ) );\t\t\t\t\n\t\t\t}\n\n\t\t\tjunction.add( predicate );\n\t\t\treturn junction;\n\t\t}\n\t\treturn predicate;\n\t}\n\n\tprotected String getPrunedDiscriminatorPredicate(\n\t\t\tMap<String, EntityNameUse> entityNameUses,\n\t\t\tMappingMetamodelImplementor mappingMetamodel,\n\t\t\tString alias) {\n\t\tfinal InFragment frag = new InFragment();\n\t\tif ( isDiscriminatorFormula() ) {\n\t\t\tfrag.setFormula( alias, getDiscriminatorFormulaTemplate() );\n\t\t}\n\t\telse {\n\t\t\tfrag.setColumn( alias, getDiscriminatorColumnName() );\n\t\t}\n\t\tboolean containsNotNull = false;\n\t\tfor ( Map.Entry<String, EntityNameUse> entry : entityNameUses.entrySet() ) {\n\t\t\tfinal EntityNameUse.UseKind useKind = entry.getValue().getKind();\n\t\t\tif ( useKind == EntityNameUse.UseKind.PROJECTION || useKind == EntityNameUse.UseKind.EXPRESSION ) {\n\t\t\t\t// We only care about treat and filter uses which allow to reduce the amount of rows to select\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfinal EntityPersister persister = mappingMetamodel.getEntityDescriptor( entry.getKey() );\n\t\t\t// Filtering for abstract entities makes no sense, so ignore that\n\t\t\t// Also, it makes no sense to filter for any of the super types,\n\t\t\t// as the query will contain a filter for that already anyway\n\t\t\tif ( !persister.isAbstract() && ( this == persister || !isTypeOrSuperType( persister ) ) ) {\n\t\t\t\tcontainsNotNull = containsNotNull || InFragment.NOT_NULL.equals( persister.getDiscriminatorSQLValue() );\n\t\t\t\tfrag.addValue( persister.getDiscriminatorSQLValue() );\n\t\t\t}\n\t\t}\n\t\tfinal List<String> discriminatorSQLValues = Arrays.asList( ( (AbstractEntityPersister) getRootEntityDescriptor() ).fullDiscriminatorSQLValues );\n\t\tif ( frag.getValues().size() == discriminatorSQLValues.size() ) {\n\t\t\t// Nothing to prune if we filter for all subtypes\n\t\t\treturn null;\n\t\t}\n\n\t\tif ( containsNotNull ) {\n\t\t\tfinal String lhs;\n\t\t\tif ( isDiscriminatorFormula() ) {\n\t\t\t\tlhs = StringHelper.replace( getDiscriminatorFormulaTemplate(), Template.TEMPLATE, alias );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlhs = qualifyConditionally( alias, getDiscriminatorColumnName() );\n\t\t\t}\n\t\t\tfinal List<String> actualDiscriminatorSQLValues = new ArrayList<>( discriminatorSQLValues.size() );\n\t\t\tfor ( String value : discriminatorSQLValues ) {\n\t\t\t\tif ( !frag.getValues().contains( value ) && !InFragment.NULL.equals( value ) ) {\n\t\t\t\t\tactualDiscriminatorSQLValues.add( value );\n\t\t\t\t}\n\t\t\t}\n\t\t\tfinal StringBuilder sb = new StringBuilder( 70 + actualDiscriminatorSQLValues.size() * 10 ).append( \" or \" );\n\t\t\tif ( !actualDiscriminatorSQLValues.isEmpty() ) {\n\t\t\t\tsb.append( lhs ).append( \" is not in (\" );\n\t\t\t\tsb.append( String.join( \",\", actualDiscriminatorSQLValues ) );\n\t\t\t\tsb.append( \") and \" );\n\t\t\t}\n\t\t\tsb.append( lhs ).append( \" is not null\" );\n\t\t\tfrag.getValues().remove( InFragment.NOT_NULL );\n\t\t\treturn frag.toFragmentString() + sb;\n\t\t}\n\t\telse {\n\t\t\treturn frag.toFragmentString();\n\t\t}\n\t}\n\n\t@Override\n\tpublic void applyFilterRestrictions(\n\t\t\tConsumer<Predicate> predicateConsumer,\n\t\t\tTableGroup tableGroup,\n\t\t\tboolean useQualifier,\n\t\t\tMap<String, Filter> enabledFilters,\n\t\t\tboolean onlyApplyLoadByKeyFilters,\n\t\t\tSqlAstCreationState creationState) {\n\t\tif ( filterHelper != null ) {\n\t\t\tfinal FilterAliasGenerator filterAliasGenerator = useQualifier && tableGroup != null\n\t\t\t\t\t? getFilterAliasGenerator( tableGroup )\n\t\t\t\t\t: null;\n\t\t\tfilterHelper.applyEnabledFilters(\n\t\t\t\t\tpredicateConsumer,\n\t\t\t\t\tfilterAliasGenerator,\n\t\t\t\t\tenabledFilters,\n\t\t\t\t\tonlyApplyLoadByKeyFilters,\n\t\t\t\t\ttableGroup,\n\t\t\t\t\tcreationState\n\t\t\t);\n\t\t}\n\t}\n\n\t@Override\n\tpublic void applyBaseRestrictions(\n\t\t\tConsumer<Predicate> predicateConsumer,\n\t\t\tTableGroup tableGroup, boolean useQualifier,\n\t\t\tMap<String, Filter> enabledFilters,\n\t\t\tboolean onlyApplyLoadByKeyFilters,\n\t\t\tSet<String> treatAsDeclarations,\n\t\t\tSqlAstCreationState creationState) {\n\t\tapplyFilterRestrictions(\n\t\t\t\tpredicateConsumer,\n\t\t\t\ttableGroup,\n\t\t\t\tuseQualifier,\n\t\t\t\tenabledFilters,\n\t\t\t\tonlyApplyLoadByKeyFilters,\n\t\t\t\tcreationState\n\t\t);\n\t\tapplyWhereRestrictions( predicateConsumer, tableGroup, useQualifier, creationState );\n\t}\n\n\t@Override\n\tpublic boolean hasWhereRestrictions() {\n\t\treturn sqlWhereStringTemplate != null;\n\t}\n\n\t@Override\n\tpublic void applyWhereRestrictions(\n\t\t\tConsumer<Predicate> predicateConsumer,\n\t\t\tTableGroup tableGroup,\n\t\t\tboolean useQualifier,\n\t\t\tSqlAstCreationState creationState) {\n\t\tif ( sqlWhereStringTemplate != null ) {\n\t\t\tfinal String alias = getAliasInWhere( tableGroup, useQualifier );\n\t\t\tfinal String fragment = StringHelper.replace( sqlWhereStringTemplate, Template.TEMPLATE, alias );\n\t\t\tpredicateConsumer.accept( new SqlFragmentPredicate( fragment ) );\n\t\t}\n\t}\n\n\tprivate String getAliasInWhere(TableGroup tableGroup, boolean useQualifier) {\n\t\tif ( tableGroup == null ) {\n\t\t\treturn null;\n\t\t}\n\t\telse {\n\t\t\tfinal TableReference tableReference = tableGroup.resolveTableReference( sqlWhereStringTableExpression );\n\t\t\tif ( tableReference == null ) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn useQualifier && tableReference.getIdentificationVariable() != null\n\t\t\t\t\t\t? tableReference.getIdentificationVariable()\n\t\t\t\t\t\t: tableReference.getTableId();\n\t\t\t}\n\t\t}\n\t}\n\n\tprotected boolean shouldInnerJoinSubclassTable(int subclassTableNumber, Set<String> treatAsDeclarations) {\n\t\tif ( isClassOrSuperclassJoin( subclassTableNumber ) ) {\n\t\t\t// the table is either this persister's driving table or (one of) its superclass persister's driving\n\t\t\t// tables which can be inner joined as long as the `shouldInnerJoin` condition resolves to true\n\t\t\treturn !isInverseTable( subclassTableNumber )\n\t\t\t\t&& !isNullableTable( subclassTableNumber );\n\t\t}\n\n\t\t// otherwise we have a subclass table and need to look a little deeper...\n\n\t\t// IMPL NOTE : By default includeSubclasses indicates that all subclasses should be joined and that each\n\t\t// subclass ought to be joined by outer-join.  However, TREAT-AS always requires that an inner-join be used\n\t\t// so we give TREAT-AS higher precedence...\n\n\t\treturn isSubclassTableIndicatedByTreatAsDeclarations( subclassTableNumber, treatAsDeclarations );\n\t}\n\n\tprotected boolean isSubclassTableIndicatedByTreatAsDeclarations(int subclassTableNumber, Set<String> treatAsDeclarations) {\n\t\treturn false;\n\t}\n\n\t/**\n\t * Post-construct is a callback for AbstractEntityPersister subclasses to call after they are all done with their\n\t * constructor processing.  It allows AbstractEntityPersister to extend its construction after all subclass-specific\n\t * details have been handled.\n\t *\n\t * @param mapping The mapping\n\t *\n\t * @throws MappingException Indicates a problem accessing the Mapping\n\t */\n\tprotected void postConstruct(Metadata mapping) throws MappingException {\n\t\tinitPropertyPaths( mapping );\n\t}\n\n\t@Override\n\tpublic void prepareLoaders() {\n\t\t// Hibernate Reactive needs to override the loaders\n\t\tsingleIdLoader = buildSingleIdEntityLoader();\n\t\tmultiIdLoader = buildMultiIdLoader();\n\n\t\tlazyLoadPlanByFetchGroup = getLazyLoadPlanByFetchGroup();\n\n\t\tlogStaticSQL();\n\t}\n\n\tprivate void doLateInit() {\n\t\ttableMappings = buildTableMappings();\n\n\t\tfinal List<AttributeMapping> insertGeneratedAttributes = hasInsertGeneratedProperties() ?\n\t\t\t\tGeneratedValuesProcessor.getGeneratedAttributes( this, INSERT )\n\t\t\t\t: Collections.emptyList();\n\t\tfinal List<AttributeMapping> updateGeneratedAttributes = hasUpdateGeneratedProperties() ?\n\t\t\t\tGeneratedValuesProcessor.getGeneratedAttributes( this, UPDATE )\n\t\t\t\t: Collections.emptyList();\n\n\t\tinsertGeneratedProperties = initInsertGeneratedProperties( insertGeneratedAttributes );\n\t\tupdateGeneratedProperties = initUpdateGeneratedProperties( updateGeneratedAttributes );\n\n\t\tinsertDelegate = createInsertDelegate();\n\t\tupdateDelegate = createUpdateDelegate();\n\n\t\tif ( isIdentifierAssignedByInsert() ) {\n\t\t\tidentitySelectString = getIdentitySelectString( factory.getJdbcServices().getDialect() );\n\t\t}\n\n\t\tif ( hasInsertGeneratedProperties() ) {\n\t\t\tinsertGeneratedValuesProcessor = createGeneratedValuesProcessor( INSERT, insertGeneratedAttributes );\n\t\t}\n\t\tif ( hasUpdateGeneratedProperties() ) {\n\t\t\tupdateGeneratedValuesProcessor = createGeneratedValuesProcessor( UPDATE, updateGeneratedAttributes );\n\t\t}\n\n\t\tinsertCoordinator = buildInsertCoordinator();\n\t\tupdateCoordinator = buildUpdateCoordinator();\n\t\tdeleteCoordinator = buildDeleteCoordinator();\n\t\tmergeCoordinator = buildMergeCoordinator();\n\n\t\t//select SQL\n\t\tsqlVersionSelectString = generateSelectVersionString();\n\t}\n\n\tprotected GeneratedValuesMutationDelegate createInsertDelegate() {\n\t\tif ( isIdentifierAssignedByInsert() ) {\n\t\t\tfinal OnExecutionGenerator generator = (OnExecutionGenerator) getGenerator();\n\t\t\treturn generator.getGeneratedIdentifierDelegate( this );\n\t\t}\n\t\treturn GeneratedValuesHelper.getGeneratedValuesDelegate( this, INSERT );\n\t}\n\n\tprotected GeneratedValuesMutationDelegate createUpdateDelegate() {\n\t\treturn GeneratedValuesHelper.getGeneratedValuesDelegate( this, UPDATE );\n\t}\n\n\tprivate static class TableMappingBuilder {\n\t\tprivate final String tableName;\n\t\tprivate final int relativePosition;\n\t\tprivate final EntityTableMapping.KeyMapping keyMapping;\n\t\tprivate final boolean isOptional;\n\t\tprivate final boolean isInverse;\n\t\tprivate final boolean isIdentifierTable;\n\n\t\tprivate final Expectation insertExpectation;\n\t\tprivate final String customInsertSql;\n\t\tprivate final boolean insertCallable;\n\n\t\tprivate final Expectation updateExpectation;\n\t\tprivate final String customUpdateSql;\n\t\tprivate final boolean updateCallable;\n\n\t\tprivate final boolean cascadeDeleteEnabled;\n\t\tprivate final Expectation deleteExpectation;\n\t\tprivate final String customDeleteSql;\n\t\tprivate final boolean deleteCallable;\n\t\tprivate final boolean dynamicUpdate;\n\t\tprivate final boolean dynamicInsert;\n\n\t\tprivate final List<Integer> attributeIndexes = new ArrayList<>();\n\n\t\tpublic TableMappingBuilder(\n\t\t\t\tString tableName,\n\t\t\t\tint relativePosition,\n\t\t\t\tEntityTableMapping.KeyMapping keyMapping,\n\t\t\t\tboolean isOptional,\n\t\t\t\tboolean isInverse,\n\t\t\t\tboolean isIdentifierTable,\n\t\t\t\tExpectation insertExpectation,\n\t\t\t\tString customInsertSql,\n\t\t\t\tboolean insertCallable,\n\t\t\t\tExpectation updateExpectation,\n\t\t\t\tString customUpdateSql,\n\t\t\t\tboolean updateCallable,\n\t\t\t\tboolean cascadeDeleteEnabled,\n\t\t\t\tExpectation deleteExpectation,\n\t\t\t\tString customDeleteSql,\n\t\t\t\tboolean deleteCallable,\n\t\t\t\tboolean dynamicUpdate,\n\t\t\t\tboolean dynamicInsert) {\n\t\t\tthis.tableName = tableName;\n\t\t\tthis.relativePosition = relativePosition;\n\t\t\tthis.keyMapping = keyMapping;\n\t\t\tthis.isOptional = isOptional;\n\t\t\tthis.isInverse = isInverse;\n\t\t\tthis.isIdentifierTable = isIdentifierTable;\n\t\t\tthis.insertExpectation = insertExpectation;\n\t\t\tthis.customInsertSql = customInsertSql;\n\t\t\tthis.insertCallable = insertCallable;\n\t\t\tthis.updateExpectation = updateExpectation;\n\t\t\tthis.customUpdateSql = customUpdateSql;\n\t\t\tthis.updateCallable = updateCallable;\n\t\t\tthis.cascadeDeleteEnabled = cascadeDeleteEnabled;\n\t\t\tthis.deleteExpectation = deleteExpectation;\n\t\t\tthis.customDeleteSql = customDeleteSql;\n\t\t\tthis.deleteCallable = deleteCallable;\n\t\t\tthis.dynamicUpdate = dynamicUpdate;\n\t\t\tthis.dynamicInsert = dynamicInsert;\n\t\t}\n\n\t\tprivate EntityTableMapping build() {\n\t\t\treturn new EntityTableMapping(\n\t\t\t\t\ttableName,\n\t\t\t\t\trelativePosition,\n\t\t\t\t\tkeyMapping,\n\t\t\t\t\tisOptional,\n\t\t\t\t\tisInverse,\n\t\t\t\t\tisIdentifierTable,\n\t\t\t\t\ttoIntArray( attributeIndexes ),\n\t\t\t\t\tinsertExpectation,\n\t\t\t\t\tcustomInsertSql,\n\t\t\t\t\tinsertCallable,\n\t\t\t\t\tupdateExpectation,\n\t\t\t\t\tcustomUpdateSql,\n\t\t\t\t\tupdateCallable,\n\t\t\t\t\tcascadeDeleteEnabled,\n\t\t\t\t\tdeleteExpectation,\n\t\t\t\t\tcustomDeleteSql,\n\t\t\t\t\tdeleteCallable,\n\t\t\t\t\tdynamicUpdate,\n\t\t\t\t\tdynamicInsert\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * Builds the EntityTableMapping descriptors for the tables mapped by this entity.\n\t *\n\t * @see #visitMutabilityOrderedTables\n\t */\n\tprotected EntityTableMapping[] buildTableMappings() {\n\t\tfinal LinkedHashMap<String, TableMappingBuilder> tableBuilderMap = new LinkedHashMap<>();\n\t\tvisitMutabilityOrderedTables( (tableExpression, relativePosition, tableKeyColumnVisitationSupplier) -> {\n\t\t\tfinal TableMappingBuilder tableMappingBuilder;\n\n\t\t\tfinal TableMappingBuilder existing = tableBuilderMap.get( tableExpression );\n\n\t\t\tfinal boolean inverseTable = isInverseTable( relativePosition );\n\t\t\tif ( existing == null ) {\n\t\t\t\tfinal Consumer<SelectableConsumer> selectableConsumerConsumer = tableKeyColumnVisitationSupplier.get();\n\t\t\t\tfinal List<EntityTableMapping.KeyColumn> keyColumns = new ArrayList<>();\n\t\t\t\tselectableConsumerConsumer.accept( (selectionIndex, selectableMapping) -> {\n\t\t\t\t\tkeyColumns.add( new EntityTableMapping.KeyColumn(\n\t\t\t\t\t\t\ttableExpression,\n\t\t\t\t\t\t\tselectableMapping.getSelectionExpression(),\n\t\t\t\t\t\t\tselectableMapping.getWriteExpression(),\n\t\t\t\t\t\t\tselectableMapping.isFormula(),\n\t\t\t\t\t\t\tselectableMapping.getJdbcMapping()\n\t\t\t\t\t) );\n\t\t\t\t} );\n\n\t\t\t\tfinal boolean isIdentifierTable = isIdentifierTable( tableExpression );\n\n\t\t\t\tfinal String customInsertSql = customSQLInsert[ relativePosition ] == null\n\t\t\t\t\t\t? null\n\t\t\t\t\t\t: substituteBrackets( customSQLInsert[ relativePosition ] );\n\t\t\t\tfinal String customUpdateSql = customSQLUpdate[ relativePosition ] == null\n\t\t\t\t\t\t? null\n\t\t\t\t\t\t: substituteBrackets( customSQLUpdate[ relativePosition ] );\n\t\t\t\tfinal String customDeleteSql = customSQLDelete[ relativePosition ] == null\n\t\t\t\t\t\t? null\n\t\t\t\t\t\t: substituteBrackets( customSQLDelete[ relativePosition ] );\n\n\t\t\t\ttableMappingBuilder = new TableMappingBuilder(\n\t\t\t\t\t\ttableExpression,\n\t\t\t\t\t\trelativePosition,\n\t\t\t\t\t\tnew EntityTableMapping.KeyMapping( keyColumns, identifierMapping ),\n\t\t\t\t\t\t!isIdentifierTable && isNullableTable( relativePosition ),\n\t\t\t\t\t\tinverseTable,\n\t\t\t\t\t\tisIdentifierTable,\n\t\t\t\t\t\tinsertExpectations[ relativePosition ],\n\t\t\t\t\t\tcustomInsertSql,\n\t\t\t\t\t\tinsertCallable[ relativePosition ],\n\t\t\t\t\t\tupdateExpectations[ relativePosition ],\n\t\t\t\t\t\tcustomUpdateSql,\n\t\t\t\t\t\tupdateCallable[ relativePosition ],\n\t\t\t\t\t\tisTableCascadeDeleteEnabled( relativePosition ),\n\t\t\t\t\t\tdeleteExpectations[ relativePosition ],\n\t\t\t\t\t\tcustomDeleteSql,\n\t\t\t\t\t\tdeleteCallable[ relativePosition ],\n\t\t\t\t\t\tentityMetamodel.isDynamicUpdate(),\n\t\t\t\t\t\tentityMetamodel.isDynamicInsert()\n\t\t\t\t);\n\n\t\t\t\ttableBuilderMap.put( tableExpression, tableMappingBuilder );\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttableMappingBuilder = existing;\n\t\t\t}\n\n\t\t\tif ( !inverseTable ) {\n\t\t\t\tcollectAttributesIndexesForTable( relativePosition, tableMappingBuilder.attributeIndexes::add );\n\t\t\t}\n\t\t} );\n\n\t\tfinal EntityTableMapping[] list = new EntityTableMapping[tableBuilderMap.size()];\n\t\tint i = 0;\n\t\tfor ( Map.Entry<String, TableMappingBuilder> entry : tableBuilderMap.entrySet() ) {\n\t\t\tlist[i++] = entry.getValue().build();\n\t\t}\n\t\treturn list;\n\t}\n\n\t/**\n\t * Visit details about each table for this entity, using \"mutability ordering\".\n\t * When inserting rows, the order we go through the tables to avoid foreign key\n\t * problems among the entity's group of tables.\n\t * <p>\n\t * Used while {@linkplain #buildTableMappings building} the\n\t * {@linkplain EntityTableMapping table mapping} descriptors for each table.\n\t *\n\t * @see #forEachMutableTable\n\t * @see #forEachMutableTableReverse\n\t */\n\tprotected abstract void visitMutabilityOrderedTables(MutabilityOrderedTableConsumer consumer);\n\n\t/**\n\t * Consumer for processing table details.  Used while {@linkplain #buildTableMappings() building}\n\t * the {@link EntityTableMapping} descriptors.\n\t */\n\tinterface MutabilityOrderedTableConsumer {\n\t\tvoid consume(\n\t\t\t\tString tableExpression,\n\t\t\t\tint relativePosition,\n\t\t\t\tSupplier<Consumer<SelectableConsumer>> tableKeyColumnVisitationSupplier);\n\t}\n\n\tprivate void collectAttributesIndexesForTable(int naturalTableIndex, Consumer<Integer> indexConsumer) {\n\t\tforEachAttributeMapping( (attributeIndex, attributeMapping) -> {\n\t\t\tif ( isPropertyOfTable( attributeIndex, naturalTableIndex ) ) {\n\t\t\t\tindexConsumer.accept( attributeIndex );\n\t\t\t}\n\t\t} );\n\t}\n\n\tprotected abstract boolean isIdentifierTable(String tableExpression);\n\n\tprotected InsertCoordinator buildInsertCoordinator() {\n\t\treturn new InsertCoordinatorStandard( this, factory );\n\t}\n\n\tprotected UpdateCoordinator buildUpdateCoordinator() {\n\t\t// we only have updates to issue for entities with one or more singular attributes\n\t\tfor ( int i = 0; i < attributeMappings.size(); i++ ) {\n\t\t\tfinal AttributeMapping attributeMapping = attributeMappings.get( i );\n\t\t\tif ( attributeMapping instanceof SingularAttributeMapping ) {\n\t\t\t\treturn new UpdateCoordinatorStandard( this, factory );\n\t\t\t}\n\t\t}\n\t\t// otherwise, nothing to update\n\t\treturn new UpdateCoordinatorNoOp( this );\n\t}\n\n\tprotected UpdateCoordinator buildMergeCoordinator() {\n\t\t// we only have updates to issue for entities with one or more singular attributes\n\t\tfor ( int i = 0; i < attributeMappings.size(); i++ ) {\n\t\t\tfinal AttributeMapping attributeMapping = attributeMappings.get( i );\n\t\t\tif ( attributeMapping instanceof SingularAttributeMapping ) {\n\t\t\t\treturn new MergeCoordinator( this, factory );\n\t\t\t}\n\t\t}\n\t\t// otherwise, nothing to update\n\t\treturn new UpdateCoordinatorNoOp( this );\n\t}\n\n\tprotected DeleteCoordinator buildDeleteCoordinator() {\n\t\tif ( softDeleteMapping == null ) {\n\t\t\treturn new DeleteCoordinatorStandard( this, factory );\n\t\t}\n\t\telse {\n\t\t\treturn new DeleteCoordinatorSoft( this, factory );\n\t\t}\n\t}\n\n\t@Override\n\tpublic void addDiscriminatorToInsertGroup(MutationGroupBuilder insertGroupBuilder) {\n\t}\n\n\t@Override\n\tpublic void addSoftDeleteToInsertGroup(MutationGroupBuilder insertGroupBuilder) {\n\t\tif ( softDeleteMapping != null ) {\n\t\t\tfinal TableInsertBuilder insertBuilder = insertGroupBuilder.getTableDetailsBuilder( getIdentifierTableName() );\n\t\t\tinsertBuilder.addValueColumn( softDeleteMapping );\n\t\t}\n\t}\n\n\tprotected String substituteBrackets(String sql) {\n\t\treturn new SQLQueryParser( sql, null, getFactory() ).process();\n\t}\n\n\t@Override\n\tpublic final void postInstantiate() throws MappingException {\n\t\tdoLateInit();\n\t}\n\n\t/**\n\t * Load an instance using either the {@code forUpdateLoader} or the outer joining {@code loader},\n\t * depending upon the value of the {@code lock} parameter\n\t */\n\t@Override\n\tpublic Object load(Object id, Object optionalObject, LockMode lockMode, SharedSessionContractImplementor session) {\n\t\treturn load( id, optionalObject, lockMode.toLockOptions(), session );\n\t}\n\n\t/**\n\t * Load an instance using either the {@code forUpdateLoader} or the outer joining {@code loader},\n\t * depending upon the value of the {@code lock} parameter\n\t */\n\t@Override\n\tpublic Object load(Object id, Object optionalObject, LockOptions lockOptions, SharedSessionContractImplementor session)\n\t\t\tthrows HibernateException {\n\t\treturn doLoad( id, optionalObject, lockOptions, null, session );\n\t}\n\n\t@Override\n\tpublic Object load(Object id, Object optionalObject, LockOptions lockOptions, SharedSessionContractImplementor session, Boolean readOnly)\n\t\t\tthrows HibernateException {\n\t\treturn doLoad( id, optionalObject, lockOptions, readOnly, session );\n\t}\n\n\tprivate Object doLoad(Object id, Object optionalObject, LockOptions lockOptions, Boolean readOnly, SharedSessionContractImplementor session)\n\t\t\tthrows HibernateException {\n\t\tif ( LOG.isTraceEnabled() ) {\n\t\t\tLOG.tracev( \"Fetching entity: {0}\", infoString( this, id, getFactory() ) );\n\t\t}\n\n\t\tfinal SingleIdEntityLoader<?> loader = determineLoaderToUse( session );\n\t\treturn optionalObject == null\n\t\t\t\t? loader.load( id, lockOptions, readOnly, session )\n\t\t\t\t: loader.load( id, optionalObject, lockOptions, readOnly, session );\n\t}\n\n\tprotected SingleIdEntityLoader<?> determineLoaderToUse(SharedSessionContractImplementor session) {\n\t\tif ( hasNamedQueryLoader() ) {\n\t\t\treturn getSingleIdLoader();\n\t\t}\n\t\telse {\n\t\t\tfinal LoadQueryInfluencers influencers = session.getLoadQueryInfluencers();\n\t\t\t// no subselect fetching for entities for now\n\t\t\treturn isAffectedByInfluencers( influencers, true )\n\t\t\t\t\t? buildSingleIdEntityLoader( influencers )\n\t\t\t\t\t: getSingleIdLoader();\n\t\t}\n\t}\n\n\tprivate boolean hasNamedQueryLoader() {\n\t\treturn queryLoaderName != null;\n\t}\n\n\tpublic SingleIdEntityLoader<?> getSingleIdLoader() {\n\t\treturn singleIdLoader;\n\t}\n\n\t@Override\n\tpublic Object initializeEnhancedEntityUsedAsProxy(\n\t\t\tObject entity,\n\t\t\tString nameOfAttributeBeingAccessed,\n\t\t\tSharedSessionContractImplementor session) {\n\t\tfinal BytecodeEnhancementMetadata enhancementMetadata = getEntityMetamodel().getBytecodeEnhancementMetadata();\n\t\tfinal BytecodeLazyAttributeInterceptor currentInterceptor = enhancementMetadata.extractLazyInterceptor( entity );\n\t\tif ( currentInterceptor instanceof EnhancementAsProxyLazinessInterceptor ) {\n\t\t\tfinal EnhancementAsProxyLazinessInterceptor proxyInterceptor = (EnhancementAsProxyLazinessInterceptor) currentInterceptor;\n\n\t\t\tfinal EntityKey entityKey = proxyInterceptor.getEntityKey();\n\t\t\tfinal Object identifier = entityKey.getIdentifier();\n\n\t\t\tObject loaded = null;\n\t\t\tif ( canReadFromCache && session.isEventSource() ) {\n\t\t\t\tLoadEvent loadEvent = new LoadEvent( identifier, entity, session.asEventSource(), false );\n\t\t\t\tloaded = CacheEntityLoaderHelper.INSTANCE.loadFromSecondLevelCache( loadEvent, this, entityKey );\n\t\t\t}\n\t\t\tif ( loaded == null ) {\n\t\t\t\tloaded = determineLoaderToUse( session ).load( identifier, entity, LockOptions.NONE, session );\n\t\t\t}\n\n\t\t\tif ( loaded == null ) {\n\t\t\t\tfinal PersistenceContext persistenceContext = session.getPersistenceContext();\n\t\t\t\tpersistenceContext.removeEntry( entity );\n\t\t\t\tpersistenceContext.removeEntity( entityKey );\n\t\t\t\tfactory.getEntityNotFoundDelegate().handleEntityNotFound( entityKey.getEntityName(), identifier );\n\t\t\t}\n\n\t\t\tfinal LazyAttributeLoadingInterceptor interceptor =\n\t\t\t\t\tenhancementMetadata.injectInterceptor( entity, identifier, session );\n\n\t\t\tfinal Object value;\n\t\t\tif ( nameOfAttributeBeingAccessed == null ) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\telse if ( interceptor.isAttributeLoaded( nameOfAttributeBeingAccessed ) ) {\n\t\t\t\tvalue = getPropertyValue( entity, nameOfAttributeBeingAccessed );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tvalue = initializeLazyProperty( nameOfAttributeBeingAccessed, entity, session );\n\t\t\t}\n\n\t\t\treturn interceptor.readObject( entity, nameOfAttributeBeingAccessed, value );\n\t\t}\n\n\t\tthrow new IllegalStateException();\n\t}\n\n\t@Override\n\tpublic List<?> multiLoad(Object[] ids, EventSource session, MultiIdLoadOptions loadOptions) {\n\t\treturn multiIdLoader.load( ids, loadOptions, session );\n\t}\n\n\t@Override\n\tpublic void registerAffectingFetchProfile(String fetchProfileName) {\n\t\tif ( affectingFetchProfileNames == null ) {\n\t\t\taffectingFetchProfileNames = new HashSet<>();\n\t\t}\n\t\taffectingFetchProfileNames.add( fetchProfileName );\n\t}\n\n\t@Override\n\tpublic boolean isAffectedByEntityGraph(LoadQueryInfluencers loadQueryInfluencers) {\n\t\tfinal RootGraphImplementor<?> graph = loadQueryInfluencers.getEffectiveEntityGraph().getGraph();\n\t\treturn graph != null\n\t\t\t&& graph.appliesTo( getFactory().getJpaMetamodel().entity( getEntityName() ) );\n\t}\n\n\t@Override\n\tpublic boolean isAffectedByEnabledFetchProfiles(LoadQueryInfluencers loadQueryInfluencers) {\n\t\tif ( affectingFetchProfileNames != null && loadQueryInfluencers.hasEnabledFetchProfiles() ) {\n\t\t\tfor ( String profileName : loadQueryInfluencers.getEnabledFetchProfileNames() ) {\n\t\t\t\tif ( affectingFetchProfileNames.contains( profileName ) ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic boolean isAffectedByEnabledFilters(\n\t\t\tLoadQueryInfluencers loadQueryInfluencers,\n\t\t\tboolean onlyApplyForLoadByKeyFilters) {\n\t\tif ( filterHelper != null && loadQueryInfluencers.hasEnabledFilters() ) {\n\t\t\tif ( filterHelper.isAffectedBy( loadQueryInfluencers.getEnabledFilters(), onlyApplyForLoadByKeyFilters ) ) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\treturn isAffectedByEnabledFilters( new HashSet<>(), loadQueryInfluencers, onlyApplyForLoadByKeyFilters );\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Locate the property-indices of all properties considered to be dirty.\n\t *\n\t * @param currentState The current state of the entity (the state to be checked).\n\t * @param previousState The previous state of the entity (the state to be checked against).\n\t * @param entity The entity for which we are checking state dirtiness.\n\t * @param session The session in which the check is occurring.\n\t *\n\t * @return {@code null} or the indices of the dirty properties\n\t *\n\t */\n\t@Override\n\tpublic int[] findDirty(Object[] currentState, Object[] previousState, Object entity, SharedSessionContractImplementor session)\n\t\t\tthrows HibernateException {\n\t\tint[] props = DirtyHelper.findDirty(\n\t\t\t\tentityMetamodel.getProperties(),\n\t\t\t\tcurrentState,\n\t\t\t\tpreviousState,\n\t\t\t\tpropertyColumnUpdateable,\n\t\t\t\tsession\n\t\t);\n\t\tif ( props == null ) {\n\t\t\treturn null;\n\t\t}\n\t\telse {\n\t\t\tlogDirtyProperties( props );\n\t\t\treturn props;\n\t\t}\n\t}\n\n\t/**\n\t * Locate the property-indices of all properties considered to be dirty.\n\t *\n\t * @param old The old state of the entity.\n\t * @param current The current state of the entity.\n\t * @param entity The entity for which we are checking state modification.\n\t * @param session The session in which the check is occurring.\n\t *\n\t * @return {@code null} or the indices of the modified properties\n\t *\n\t */\n\t@Override\n\tpublic int[] findModified(Object[] old, Object[] current, Object entity, SharedSessionContractImplementor session)\n\t\t\tthrows HibernateException {\n\t\tint[] props = DirtyHelper.findModified(\n\t\t\t\tentityMetamodel.getProperties(),\n\t\t\t\tcurrent,\n\t\t\t\told,\n\t\t\t\tpropertyColumnUpdateable,\n\t\t\t\tgetPropertyUpdateability(),\n\t\t\t\tsession\n\t\t);\n\t\tif ( props == null ) {\n\t\t\treturn null;\n\t\t}\n\t\telse {\n\t\t\tlogDirtyProperties( props );\n\t\t\treturn props;\n\t\t}\n\t}\n\n\t/**\n\t * Which properties appear in the SQL update?\n\t * (Initialized, updateable ones!)\n\t */\n\tpublic boolean[] getPropertyUpdateability(Object entity) {\n\t\treturn hasUninitializedLazyProperties( entity )\n\t\t\t\t? getNonLazyPropertyUpdateability()\n\t\t\t\t: getPropertyUpdateability();\n\t}\n\n\tprivate void logDirtyProperties(int[] props) {\n\t\tif ( LOG.isTraceEnabled() ) {\n\t\t\tfor ( int prop : props ) {\n\t\t\t\tfinal String propertyName = getAttributeMapping( prop ).getAttributeName();\n\t\t\t\tLOG.trace( StringHelper.qualify( getEntityName(), propertyName ) + \" is dirty\" );\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic SessionFactoryImplementor getFactory() {\n\t\treturn factory;\n\t}\n\n\t@Override\n\tpublic EntityMetamodel getEntityMetamodel() {\n\t\treturn entityMetamodel;\n\t}\n\n\t@Override\n\tpublic boolean canReadFromCache() {\n\t\treturn canReadFromCache;\n\t}\n\n\t@Override\n\tpublic boolean canWriteToCache() {\n\t\treturn canWriteToCache;\n\t}\n\n\t@Override\n\tpublic boolean hasCache() {\n\t\treturn canWriteToCache;\n\t}\n\n\t@Override\n\tpublic EntityDataAccess getCacheAccessStrategy() {\n\t\treturn cacheAccessStrategy;\n\t}\n\n\t@Override\n\tpublic CacheEntryStructure getCacheEntryStructure() {\n\t\treturn cacheEntryHelper.getCacheEntryStructure();\n\t}\n\n\t@Override\n\tpublic CacheEntry buildCacheEntry(Object entity, Object[] state, Object version, SharedSessionContractImplementor session) {\n\t\treturn cacheEntryHelper.buildCacheEntry( entity, state, version, session );\n\t}\n\n\t@Override\n\tpublic boolean hasNaturalIdCache() {\n\t\treturn naturalIdRegionAccessStrategy != null;\n\t}\n\n\t@Override\n\tpublic NaturalIdDataAccess getNaturalIdCacheAccessStrategy() {\n\t\treturn naturalIdRegionAccessStrategy;\n\t}\n\n\n\t// temporary ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\t@Override\n\tpublic final String getEntityName() {\n\t\treturn entityMetamodel.getName();\n\t}\n\n\t@Override\n\tpublic boolean isInherited() {\n\t\treturn entityMetamodel.isInherited();\n\t}\n\n\t@Override\n\tpublic boolean hasCascades() {\n\t\treturn entityMetamodel.hasCascades();\n\t}\n\n\t@Override\n\tpublic boolean hasCascadeDelete() {\n\t\treturn entityMetamodel.hasCascadeDelete();\n\t}\n\n\t@Override\n\tpublic boolean hasOwnedCollections() {\n\t\treturn entityMetamodel.hasOwnedCollections();\n\t}\n\n\t@Override\n\tpublic boolean hasIdentifierProperty() {\n\t\treturn !entityMetamodel.getIdentifierProperty().isVirtual();\n\t}\n\n\t@Override\n\tpublic BasicType<?> getVersionType() {\n\t\treturn entityMetamodel.getVersionProperty() == null\n\t\t\t\t? null\n\t\t\t\t: (BasicType<?>) entityMetamodel.getVersionProperty().getType();\n\t}\n\n\t@Override\n\tpublic int getVersionProperty() {\n\t\treturn entityMetamodel.getVersionPropertyIndex();\n\t}\n\n\t@Override\n\tpublic boolean isVersioned() {\n\t\treturn entityMetamodel.isVersioned();\n\t}\n\n\t@Override\n\tpublic boolean isIdentifierAssignedByInsert() {\n\t\treturn entityMetamodel.getIdentifierProperty().isIdentifierAssignedByInsert();\n\t}\n\n\t@Override\n\tpublic boolean hasLazyProperties() {\n\t\treturn entityMetamodel.hasLazyProperties();\n\t}\n\n\t@Override\n\tpublic void afterReassociate(Object entity, SharedSessionContractImplementor session) {\n\t\tfinal BytecodeEnhancementMetadata metadata = getEntityMetamodel().getBytecodeEnhancementMetadata();\n\t\tif ( metadata.isEnhancedForLazyLoading() ) {\n\t\t\tfinal BytecodeLazyAttributeInterceptor interceptor = metadata.extractLazyInterceptor( entity );\n\t\t\tif ( interceptor == null ) {\n\t\t\t\tmetadata.injectInterceptor( entity, getIdentifier( entity, session ), session );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tinterceptor.setSession( session );\n\t\t\t}\n\t\t}\n\t\thandleNaturalIdReattachment( entity, session );\n\t}\n\n\tprivate void handleNaturalIdReattachment(Object entity, SharedSessionContractImplementor session) {\n\t\tif ( naturalIdMapping == null ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( ! naturalIdMapping.isMutable() ) {\n\t\t\t// we assume there were no changes to natural id during detachment for now, that is validated later\n\t\t\t// during flush.\n\t\t\treturn;\n\t\t}\n\n\t\tfinal PersistenceContext persistenceContext = session.getPersistenceContextInternal();\n\t\tfinal NaturalIdResolutions naturalIdResolutions = persistenceContext.getNaturalIdResolutions();\n\t\tfinal Object id = getIdentifier( entity, session );\n\n\t\t// for reattachment of mutable natural-ids, we absolutely positively have to grab the snapshot from the\n\t\t// database, because we have no other way to know if the state changed while detached.\n\t\tfinal Object[] entitySnapshot = persistenceContext.getDatabaseSnapshot( id, this );\n\t\tfinal Object naturalIdSnapshot = entitySnapshot == StatefulPersistenceContext.NO_ROW\n\t\t\t\t? null\n\t\t\t\t: naturalIdMapping.extractNaturalIdFromEntityState( entitySnapshot );\n\n\t\tnaturalIdResolutions.removeSharedResolution( id, naturalIdSnapshot, this, false );\n\t\tfinal Object naturalId = naturalIdMapping.extractNaturalIdFromEntity( entity );\n\t\tnaturalIdResolutions.manageLocalResolution( id, naturalId, this, CachedNaturalIdValueSource.UPDATE );\n\t}\n\n\t@Override\n\tpublic Boolean isTransient(Object entity, SharedSessionContractImplementor session) throws HibernateException {\n\t\tfinal Object id = getIdentifier( entity, session );\n\t\t// we *always* assume an instance with a null\n\t\t// identifier or no identifier property is unsaved!\n\t\tif ( id == null ) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// check the version unsaved-value, if appropriate\n\t\tif ( isVersioned() ) {\n\t\t\t// let this take precedence if defined, since it works for\n\t\t\t// assigned identifiers\n\t\t\tfinal Object version = getVersion( entity );\n\t\t\tfinal Boolean isUnsaved = versionMapping.getUnsavedStrategy().isUnsaved( version );\n\t\t\tif ( isUnsaved != null ) {\n\t\t\t\tif ( isUnsaved ) {\n\t\t\t\t\tfinal PersistenceContext persistenceContext;\n\t\t\t\t\tif ( version == null\n\t\t\t\t\t\t\t&& ( persistenceContext = session.getPersistenceContext() ).hasLoadContext()\n\t\t\t\t\t\t\t\t\t&& !persistenceContext.getLoadContexts().isLoadingFinished() ) {\n\t\t\t\t\t\t// check if we're currently loading this entity instance, the version\n\t\t\t\t\t\t// will be null but the entity cannot be considered transient\n\t\t\t\t\t\tfinal EntityHolder holder =\n\t\t\t\t\t\t\t\tpersistenceContext.getEntityHolder( new EntityKey( id, this ) );\n\t\t\t\t\t\tif ( holder != null && holder.isEventuallyInitialized() && holder.getEntity() == entity ) {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfinal Generator identifierGenerator = getGenerator();\n\t\t\t\t\tif ( identifierGenerator != null ) {\n\t\t\t\t\t\tfinal Boolean unsaved = identifierMapping.getUnsavedStrategy().isUnsaved( id );\n\t\t\t\t\t\tif ( unsaved != null && !unsaved ) {\n\t\t\t\t\t\t\tthrow new PropertyValueException(\n\t\t\t\t\t\t\t\t\t\"Detached entity with generated id '\" + id\n\t\t\t\t\t\t\t\t\t\t\t+ \"' has an uninitialized version value '\" + version + \"'\",\n\t\t\t\t\t\t\t\t\tgetEntityName(),\n\t\t\t\t\t\t\t\t\tgetVersionColumnName()\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn isUnsaved;\n\t\t\t}\n\t\t}\n\n\t\t// check the id unsaved-value\n\t\tfinal Boolean result = identifierMapping.getUnsavedStrategy().isUnsaved( id );\n\t\tif ( result != null ) {\n\t\t\treturn result;\n\t\t}\n\n\t\t// check to see if it is in the second-level cache\n\t\tif ( session.getCacheMode().isGetEnabled() && canReadFromCache() ) {\n\t\t\tfinal EntityDataAccess cache = getCacheAccessStrategy();\n\t\t\tfinal Object ck = cache.generateCacheKey( id, this, session.getFactory(), session.getTenantIdentifier() );\n\t\t\tfinal Object ce = CacheHelper.fromSharedCache( session, ck, this, getCacheAccessStrategy() );\n\t\t\tif ( ce != null ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic boolean hasCollections() {\n\t\treturn entityMetamodel.hasCollections();\n\t}\n\n\t@Override\n\tpublic boolean hasMutableProperties() {\n\t\treturn entityMetamodel.hasMutableProperties();\n\t}\n\n\t@Override\n\tpublic boolean isMutable() {\n\t\treturn entityMetamodel.isMutable();\n\t}\n\n\t@Override\n\tpublic boolean isAbstract() {\n\t\treturn entityMetamodel.isAbstract();\n\t}\n\n\t@Override\n\tpublic boolean hasSubclasses() {\n\t\treturn entityMetamodel.hasSubclasses();\n\t}\n\n\t@Override\n\tpublic boolean hasProxy() {\n\t\t// skip proxy instantiation if entity is bytecode enhanced\n\t\treturn entityMetamodel.isLazy() && !entityMetamodel.getBytecodeEnhancementMetadata().isEnhancedForLazyLoading();\n\t}\n\n\t@Override @Deprecated\n\tpublic IdentifierGenerator getIdentifierGenerator() throws HibernateException {\n\t\treturn entityMetamodel.getIdentifierProperty().getIdentifierGenerator();\n\t}\n\n\t@Override\n\tpublic Generator getGenerator() {\n\t\treturn entityMetamodel.getIdentifierProperty().getGenerator();\n\t}\n\n\t@Override\n\tpublic BeforeExecutionGenerator getVersionGenerator() {\n\t\treturn versionGenerator;\n\t}\n\n\t@Override\n\tpublic String getRootEntityName() {\n\t\treturn entityMetamodel.getRootName();\n\t}\n\n\t@Override\n\tpublic String getMappedSuperclass() {\n\t\treturn entityMetamodel.getSuperclass();\n\t}\n\n\t@Override\n\tpublic boolean isExplicitPolymorphism() {\n\t\treturn entityMetamodel.isExplicitPolymorphism();\n\t}\n\n\t@Override\n\tpublic boolean isConcreteProxy() {\n\t\treturn concreteProxy;\n\t}\n\n\t@Override\n\tpublic EntityMappingType resolveConcreteProxyTypeForId(Object id, SharedSessionContractImplementor session) {\n\t\tif ( !concreteProxy ) {\n\t\t\treturn this;\n\t\t}\n\n\t\tEntityConcreteTypeLoader concreteTypeLoader = this.concreteTypeLoader;\n\t\tif ( concreteTypeLoader == null ) {\n\t\t\tthis.concreteTypeLoader = concreteTypeLoader = new EntityConcreteTypeLoader( this, session.getFactory() );\n\t\t}\n\t\treturn concreteTypeLoader.getConcreteType( id, session );\n\t}\n\n\t/**\n\t * {@inheritDoc}\n\t *\n\t * Warning:\n\t * When there are duplicated property names in the subclasses\n\t * then this method may return the wrong results.\n\t * To ensure correct results, this method should only be used when\n\t * {@literal this} is the concrete EntityPersister (since the\n\t * concrete EntityPersister cannot have duplicated property names).\n\t *\n\t * @deprecated by the supertypes\n\t */\n\t@Override @Deprecated\n\tpublic Type getPropertyType(String propertyName) throws MappingException {\n\t\t// todo (PropertyMapping) : caller also deprecated (aka, easy to remove)\n\t\treturn propertyMapping.toType( propertyName );\n\t}\n\n\t@Override\n\tpublic boolean isSelectBeforeUpdateRequired() {\n\t\treturn entityMetamodel.isSelectBeforeUpdate();\n\t}\n\n\tpublic final OptimisticLockStyle optimisticLockStyle() {\n\t\treturn entityMetamodel.getOptimisticLockStyle();\n\t}\n\n\t@Override\n\tpublic Object createProxy(Object id, SharedSessionContractImplementor session) throws HibernateException {\n\t\treturn representationStrategy.getProxyFactory().getProxy( id, session );\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn StringHelper.unqualify( getClass().getName() )\n\t\t\t\t+ '(' + entityMetamodel.getName() + ')';\n\t}\n\n\t@Override\n\tpublic boolean isInstrumented() {\n\t\treturn entityMetamodel.getBytecodeEnhancementMetadata().isEnhancedForLazyLoading();\n\t}\n\n\t@Override\n\tpublic boolean hasInsertGeneratedProperties() {\n\t\treturn entityMetamodel.hasInsertGeneratedValues();\n\t}\n\n\t@Override\n\tpublic boolean hasUpdateGeneratedProperties() {\n\t\treturn entityMetamodel.hasUpdateGeneratedValues();\n\t}\n\n\t@Override\n\tpublic boolean isVersionPropertyGenerated() {\n\t\treturn isVersioned()\n\t\t\t&& ( isVersionGeneratedOnExecution() || isVersionGeneratedBeforeExecution() );\n\t}\n\n\tpublic boolean isVersionGeneratedOnExecution() {\n\t\tfinal Generator strategy = getEntityMetamodel().getGenerators()[ getVersionProperty() ];\n\t\treturn strategy != null && strategy.generatesSometimes() && strategy.generatedOnExecution();\n\t}\n\n\tpublic boolean isVersionGeneratedBeforeExecution() {\n\t\tfinal Generator strategy = getEntityMetamodel().getGenerators()[ getVersionProperty() ];\n\t\treturn strategy != null && strategy.generatesSometimes() && !strategy.generatedOnExecution();\n\t}\n\n\t@Override\n\tpublic void afterInitialize(Object entity, SharedSessionContractImplementor session) {\n\t\tif ( isPersistentAttributeInterceptable( entity ) && getRepresentationStrategy().getMode() == POJO ) {\n\t\t\tfinal BytecodeLazyAttributeInterceptor interceptor = getEntityMetamodel().getBytecodeEnhancementMetadata()\n\t\t\t\t\t.extractLazyInterceptor( entity );\n\t\t\tassert interceptor != null;\n\t\t\tif ( interceptor.getLinkedSession() == null ) {\n\t\t\t\tinterceptor.setSession( session );\n\t\t\t}\n\t\t}\n\n\t\t// clear the fields that are marked as dirty in the dirtiness tracker\n\t\tprocessIfSelfDirtinessTracker( entity, AbstractEntityPersister::clearDirtyAttributes );\n\t\tprocessIfManagedEntity( entity, AbstractEntityPersister::useTracker );\n\t}\n\n\tprivate static void clearDirtyAttributes(final SelfDirtinessTracker entity) {\n\t\tentity.$$_hibernate_clearDirtyAttributes();\n\t}\n\n\tprivate static void useTracker(final ManagedEntity entity) {\n\t\tentity.$$_hibernate_setUseTracker( true );\n\t}\n\n\t@Override\n\tpublic String[] getPropertyNames() {\n\t\treturn entityMetamodel.getPropertyNames();\n\t}\n\n\t@Override\n\tpublic Type[] getPropertyTypes() {\n\t\treturn entityMetamodel.getPropertyTypes();\n\t}\n\n\t@Override\n\tpublic boolean[] getPropertyLaziness() {\n\t\treturn entityMetamodel.getPropertyLaziness();\n\t}\n\n\t@Override\n\tpublic boolean[] getPropertyUpdateability() {\n\t\treturn entityMetamodel.getPropertyUpdateability();\n\t}\n\n\t@Override\n\tpublic boolean[] getPropertyCheckability() {\n\t\treturn entityMetamodel.getPropertyCheckability();\n\t}\n\n\t@Override\n\tpublic boolean[] getNonLazyPropertyUpdateability() {\n\t\treturn entityMetamodel.getNonlazyPropertyUpdateability();\n\t}\n\n\t@Override\n\tpublic boolean[] getPropertyInsertability() {\n\t\treturn entityMetamodel.getPropertyInsertability();\n\t}\n\n\t@Override\n\tpublic boolean[] getPropertyNullability() {\n\t\treturn entityMetamodel.getPropertyNullability();\n\t}\n\n\t@Override\n\tpublic boolean[] getPropertyVersionability() {\n\t\treturn entityMetamodel.getPropertyVersionability();\n\t}\n\n\t@Override\n\tpublic CascadeStyle[] getPropertyCascadeStyles() {\n\t\treturn entityMetamodel.getCascadeStyles();\n\t}\n\n\t@Override\n\tpublic boolean isPropertySelectable(int propertyNumber) {\n\t\treturn getAttributeMapping( propertyNumber ).getAttributeMetadata().isSelectable();\n\t}\n\n\t@Override\n\tpublic final Class<?> getMappedClass() {\n\t\treturn this.getMappedJavaType().getJavaTypeClass();\n\t}\n\n\t@Override\n\tpublic boolean implementsLifecycle() {\n\t\treturn this.implementsLifecycle;\n\t}\n\n\t@Override\n\tpublic Class<?> getConcreteProxyClass() {\n\t\tfinal JavaType<?> proxyJavaType = getRepresentationStrategy().getProxyJavaType();\n\t\treturn proxyJavaType != null ? proxyJavaType.getJavaTypeClass() : javaType.getJavaTypeClass();\n\t}\n\n\t@Override\n\tpublic void setPropertyValues(Object object, Object[] values) {\n\t\tif ( accessOptimizer != null ) {\n\t\t\taccessOptimizer.setPropertyValues( object, values );\n\t\t}\n\t\telse {\n\t\t\tfinal BytecodeEnhancementMetadata enhancementMetadata = entityMetamodel.getBytecodeEnhancementMetadata();\n\t\t\tfinal AttributeMappingsList attributeMappings = getAttributeMappings();\n\t\t\tif ( enhancementMetadata.isEnhancedForLazyLoading() ) {\n\t\t\t\tfor ( int i = 0; i < attributeMappings.size(); i++ ) {\n\t\t\t\t\tfinal Object value = values[i];\n\t\t\t\t\tif ( value != UNFETCHED_PROPERTY ) {\n\t\t\t\t\t\tsetterCache[i].set( object, value );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor ( int i = 0; i < attributeMappings.size(); i++ ) {\n\t\t\t\t\tsetterCache[i].set( object, values[i] );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic void setPropertyValue(Object object, int i, Object value) {\n\t\tsetterCache[i].set( object, value );\n\t}\n\n\t@Override\n\tpublic Object[] getPropertyValues(Object object) {\n\t\tif ( accessOptimizer != null ) {\n\t\t\treturn accessOptimizer.getPropertyValues( object );\n\t\t}\n\t\telse {\n\t\t\tfinal BytecodeEnhancementMetadata enhancementMetadata = entityMetamodel.getBytecodeEnhancementMetadata();\n\t\t\tfinal AttributeMappingsList attributeMappings = getAttributeMappings();\n\t\t\tfinal Object[] values = new Object[attributeMappings.size()];\n\t\t\tif ( enhancementMetadata.isEnhancedForLazyLoading() ) {\n\t\t\t\tfinal LazyAttributesMetadata lazyAttributesMetadata = enhancementMetadata.getLazyAttributesMetadata();\n\t\t\t\tfor ( int i = 0; i < attributeMappings.size(); i++ ) {\n\t\t\t\t\tfinal AttributeMapping attributeMapping = attributeMappings.get( i );\n\t\t\t\t\tif ( !lazyAttributesMetadata.isLazyAttribute( attributeMapping.getAttributeName() )\n\t\t\t\t\t\t\t|| enhancementMetadata.isAttributeLoaded( object, attributeMapping.getAttributeName() ) ) {\n\t\t\t\t\t\tvalues[i] = getterCache[i].get( object );\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tvalues[i] = LazyPropertyInitializer.UNFETCHED_PROPERTY;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor ( int i = 0; i < attributeMappings.size(); i++ ) {\n\t\t\t\t\tvalues[i] = getterCache[i].get( object );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn values;\n\t\t}\n\t}\n\n\t@Override\n\tpublic Object getPropertyValue(Object object, int i) {\n\t\treturn getterCache[i].get( object );\n\t}\n\n\t@Override\n\tpublic Object getPropertyValue(Object object, String propertyName) {\n\t\tfinal int dotIndex = propertyName.indexOf( '.' );\n\t\tfinal String basePropertyName = dotIndex == -1\n\t\t\t\t? propertyName\n\t\t\t\t: propertyName.substring( 0, dotIndex );\n\t\tfinal AttributeMapping attributeMapping = findAttributeMapping( basePropertyName );\n\t\tManagedMappingType baseValueType = null;\n\t\tObject baseValue = null;\n\t\tif ( attributeMapping != null ) {\n\t\t\tbaseValue = getterCache[attributeMapping.getStateArrayPosition()].get( object );\n\t\t\tif ( dotIndex != -1 ) {\n\t\t\t\tbaseValueType = (ManagedMappingType) attributeMapping.getMappedType();\n\t\t\t}\n\t\t}\n\t\telse if ( identifierMapping instanceof NonAggregatedIdentifierMapping ) {\n\t\t\tfinal AttributeMapping mapping = ( (NonAggregatedIdentifierMapping) identifierMapping ).findSubPart(\n\t\t\t\t\tpropertyName,\n\t\t\t\t\tnull\n\t\t\t).asAttributeMapping();\n\t\t\tif ( mapping != null ) {\n\t\t\t\tbaseValue = mapping.getValue( object );\n\t\t\t\tif ( dotIndex != -1 ) {\n\t\t\t\t\tbaseValueType = (ManagedMappingType) mapping.getMappedType();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn getPropertyValue( baseValue, baseValueType, propertyName, dotIndex );\n\t}\n\n\tprivate Object getPropertyValue(\n\t\t\tObject baseValue,\n\t\t\tManagedMappingType baseValueType,\n\t\t\tString propertyName,\n\t\t\tint dotIndex) {\n\t\tif ( baseValueType == null ) {\n\t\t\treturn baseValue;\n\t\t}\n\t\telse {\n\t\t\tfinal int nextDotIndex = propertyName.indexOf( '.', dotIndex + 1 );\n\t\t\tfinal int endIndex = nextDotIndex == -1 ? propertyName.length() : nextDotIndex;\n\t\t\tfinal AttributeMapping attributeMapping =\n\t\t\t\t\tbaseValueType.findAttributeMapping( propertyName.substring( dotIndex + 1, endIndex ) );\n\t\t\tbaseValue = attributeMapping.getValue( baseValue );\n\t\t\tbaseValueType = nextDotIndex == -1 ? null : (ManagedMappingType) attributeMapping.getMappedType();\n\t\t\treturn getPropertyValue( baseValue, baseValueType, propertyName, nextDotIndex );\n\t\t}\n\t}\n\n\t@Override\n\tpublic Object getIdentifier(Object entity, SharedSessionContractImplementor session) {\n\t\treturn identifierMapping.getIdentifier( entity );\n\t}\n\n\t@Override\n\tpublic void setIdentifier(Object entity, Object id, SharedSessionContractImplementor session) {\n\t\tidentifierMapping.setIdentifier( entity, id, session );\n\t}\n\n\t@Override\n\tpublic Object getVersion(Object object) {\n\t\treturn getVersionMapping() == null ? null\n\t\t\t\t: getVersionMapping().getVersionAttribute().getPropertyAccess().getGetter().get( object );\n\t}\n\n\t@Override\n\tpublic Object instantiate(Object id, SharedSessionContractImplementor session) {\n\t\tfinal Object instance = getRepresentationStrategy().getInstantiator().instantiate( session.getFactory() );\n\t\tlinkToSession( instance, session );\n\t\tif ( id != null ) {\n\t\t\tsetIdentifier( instance, id, session );\n\t\t}\n\t\treturn instance;\n\t}\n\n\tprotected void linkToSession(Object entity, SharedSessionContractImplementor session) {\n\t\tif ( session != null ) {\n\t\t\tprocessIfPersistentAttributeInterceptable( entity, this::setSession, session );\n\t\t}\n\t}\n\n\tprivate void setSession(PersistentAttributeInterceptable entity, SharedSessionContractImplementor session) {\n\t\tfinal BytecodeLazyAttributeInterceptor interceptor =\n\t\t\t\tgetEntityMetamodel().getBytecodeEnhancementMetadata()\n\t\t\t\t\t\t.extractLazyInterceptor( entity );\n\t\tif ( interceptor != null ) {\n\t\t\tinterceptor.setSession( session );\n\t\t}\n\t}\n\n\t@Override\n\tpublic boolean isInstance(Object object) {\n\t\treturn getRepresentationStrategy().getInstantiator().isInstance( object, getFactory() );\n\t}\n\n\t@Override\n\tpublic boolean hasUninitializedLazyProperties(Object object) {\n\t\treturn entityMetamodel.getBytecodeEnhancementMetadata().hasUnFetchedAttributes( object );\n\t}\n\n\t@Override\n\tpublic void resetIdentifier(\n\t\t\tObject entity,\n\t\t\tObject currentId,\n\t\t\tObject currentVersion,\n\t\t\tSharedSessionContractImplementor session) {\n\t\tif ( entityMetamodel.getIdentifierProperty().getGenerator().allowAssignedIdentifiers() ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// reset the identifier\n\t\tfinal Object defaultIdentifier = identifierMapping.getUnsavedStrategy().getDefaultValue( currentId );\n\t\tsetIdentifier( entity, defaultIdentifier, session );\n\n\t\t// reset the version\n\t\tif ( versionMapping != null ) {\n\t\t\tfinal Object defaultVersion = versionMapping.getUnsavedStrategy().getDefaultValue( currentVersion );\n\t\t\tversionMapping.getVersionAttribute().getPropertyAccess().getSetter().set( entity, defaultVersion );\n\t\t}\n\t}\n\n\t@Override\n\tpublic EntityPersister getSubclassEntityPersister(Object instance, SessionFactoryImplementor factory) {\n\t\tif ( instance != null\n\t\t\t\t&& hasSubclasses()\n\t\t\t\t&& !getRepresentationStrategy().getInstantiator().isSameClass( instance, factory ) ) {\n\t\t\t// todo (6.0) : this previously used `org.hibernate.tuple.entity.EntityTuplizer#determineConcreteSubclassEntityName`\n\t\t\t//\t\t- we may need something similar here...\n\t\t\tfor ( EntityMappingType subclassMappingType : subclassMappingTypes.values() ) {\n\t\t\t\tif ( subclassMappingType.getEntityPersister().getRepresentationStrategy()\n\t\t\t\t\t\t.getInstantiator().isSameClass(instance, factory) ) {\n\t\t\t\t\treturn subclassMappingType.getEntityPersister();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t@Override\n\tpublic boolean hasMultipleTables() {\n\t\treturn false;\n\t}\n\n\tpublic int getPropertySpan() {\n\t\treturn entityMetamodel.getPropertySpan();\n\t}\n\n\t@Override\n\tpublic Object[] getPropertyValuesToInsert(\n\t\t\tObject entity,\n\t\t\tMap<Object,Object> mergeMap,\n\t\t\tSharedSessionContractImplementor session)\n\t\t\tthrows HibernateException {\n\t\tif ( shouldGetAllProperties( entity ) && accessOptimizer != null ) {\n\t\t\treturn accessOptimizer.getPropertyValues( entity );\n\t\t}\n\n\t\tfinal Object[] result = new Object[attributeMappings.size()];\n\t\tfor ( int i = 0; i < attributeMappings.size(); i++ ) {\n\t\t\tresult[i] = getterCache[i].getForInsert( entity, mergeMap, session );\n\t\t}\n\t\treturn result;\n\t}\n\n\tprotected boolean shouldGetAllProperties(Object entity) {\n\t\tfinal BytecodeEnhancementMetadata metadata = getEntityMetamodel().getBytecodeEnhancementMetadata();\n\t\treturn !metadata.isEnhancedForLazyLoading()\n\t\t\t|| !metadata.hasUnFetchedAttributes( entity );\n\t}\n\n\t@Override\n\tpublic void processInsertGeneratedProperties(\n\t\t\tObject id,\n\t\t\tObject entity,\n\t\t\tObject[] state,\n\t\t\tGeneratedValues generatedValues,\n\t\t\tSharedSessionContractImplementor session) {\n\t\tif ( insertGeneratedValuesProcessor == null ) {\n\t\t\tthrow new UnsupportedOperationException( \"Entity has no insert-generated properties - `\" + getEntityName() + \"`\" );\n\t\t}\n\t\tinsertGeneratedValuesProcessor.processGeneratedValues( entity, id, state, generatedValues, session );\n\t}\n\n\tprotected List<? extends ModelPart> initInsertGeneratedProperties(List<AttributeMapping> generatedAttributes) {\n\t\tfinal int originalSize = generatedAttributes.size();\n\t\tfinal List<ModelPart> generatedBasicAttributes = new ArrayList<>( originalSize );\n\t\tfor ( AttributeMapping generatedAttribute : generatedAttributes ) {\n\t\t\t// todo (7.0) : support non selectable mappings? Component, ToOneAttributeMapping, ...\n\t\t\tif ( generatedAttribute.asBasicValuedModelPart() != null\n\t\t\t\t\t&& generatedAttribute.getContainingTableExpression().equals( getRootTableName() ) ) {\n\t\t\t\tgeneratedBasicAttributes.add( generatedAttribute );\n\t\t\t}\n\t\t}\n\n\t\tfinal List<ModelPart> identifierList = isIdentifierAssignedByInsert() ?\n\t\t\t\tList.of( getIdentifierMapping() ) :\n\t\t\t\tCollections.emptyList();\n\t\tif ( originalSize > 0 && generatedBasicAttributes.size() == originalSize ) {\n\t\t\treturn Collections.unmodifiableList( combine( identifierList, generatedBasicAttributes ) );\n\t\t}\n\t\telse  {\n\t\t\treturn identifierList;\n\t\t}\n\t}\n\n\t@Override\n\tpublic List<? extends ModelPart> getInsertGeneratedProperties() {\n\t\treturn insertGeneratedProperties;\n\t}\n\n\t@Override\n\tpublic void processUpdateGeneratedProperties(\n\t\t\tObject id,\n\t\t\tObject entity,\n\t\t\tObject[] state,\n\t\t\tGeneratedValues generatedValues,\n\t\t\tSharedSessionContractImplementor session) {\n\t\tif ( updateGeneratedValuesProcessor == null ) {\n\t\t\tthrow new AssertionFailure( \"Entity has no update-generated properties - `\" + getEntityName() + \"`\" );\n\t\t}\n\t\tupdateGeneratedValuesProcessor.processGeneratedValues( entity, id, state, generatedValues, session );\n\t}\n\n\tprotected List<? extends ModelPart> initUpdateGeneratedProperties(List<AttributeMapping> generatedAttributes) {\n\t\tfinal int originalSize = generatedAttributes.size();\n\t\tfinal List<ModelPart> generatedBasicAttributes = new ArrayList<>( originalSize );\n\t\tfor ( AttributeMapping generatedAttribute : generatedAttributes ) {\n\t\t\tif ( generatedAttribute instanceof SelectableMapping\n\t\t\t\t\t&& ( (SelectableMapping) generatedAttribute ).getContainingTableExpression().equals( getSubclassTableName( 0 ) ) ) {\n\t\t\t\tgeneratedBasicAttributes.add( generatedAttribute );\n\t\t\t}\n\t\t}\n\n\t\tif ( generatedBasicAttributes.size() == originalSize ) {\n\t\t\treturn Collections.unmodifiableList( generatedBasicAttributes );\n\t\t}\n\t\telse  {\n\t\t\treturn Collections.emptyList();\n\t\t}\n\t}\n\n\t@Override\n\tpublic List<? extends ModelPart> getUpdateGeneratedProperties() {\n\t\treturn updateGeneratedProperties;\n\t}\n\n\t@Override\n\tpublic String getIdentifierPropertyName() {\n\t\treturn entityMetamodel.getIdentifierProperty().getName();\n\t}\n\n\t@Override\n\tpublic Type getIdentifierType() {\n\t\treturn entityMetamodel.getIdentifierProperty().getType();\n\t}\n\n\t@Override\n\tpublic boolean hasSubselectLoadableCollections() {\n\t\treturn hasSubselectLoadableCollections;\n\t}\n\n\t@Override\n\tpublic boolean hasCollectionNotReferencingPK() {\n\t\treturn hasCollectionNotReferencingPK;\n\t}\n\n\t@Override\n\tpublic int[] getNaturalIdentifierProperties() {\n\t\treturn entityMetamodel.getNaturalIdentifierProperties();\n\t}\n\n\tprotected void verifyHasNaturalId() {\n\t\tif ( ! hasNaturalIdentifier() ) {\n\t\t\tthrow new HibernateException( \"Entity does not define a natural id : \" + getEntityName() );\n\t\t}\n\t}\n\n\t@Override\n\tpublic Object getNaturalIdentifierSnapshot(Object id, SharedSessionContractImplementor session) {\n\t\tverifyHasNaturalId();\n\t\tif ( LOG.isTraceEnabled() ) {\n\t\t\tLOG.tracef(\n\t\t\t\t\t\"Getting current natural-id snapshot state for `%s#%s\",\n\t\t\t\t\tgetEntityName(),\n\t\t\t\t\tid\n\t\t\t);\n\t\t}\n\t\treturn getNaturalIdLoader().resolveIdToNaturalId( id, session );\n\t}\n\n\n\t@Override\n\tpublic NaturalIdLoader<?> getNaturalIdLoader() {\n\t\tverifyHasNaturalId();\n\t\tif ( naturalIdLoader == null ) {\n\t\t\tnaturalIdLoader = naturalIdMapping.makeLoader( this );\n\t\t}\n\t\treturn naturalIdLoader;\n\t}\n\n\t@Override\n\tpublic MultiNaturalIdLoader<?> getMultiNaturalIdLoader() {\n\t\tverifyHasNaturalId();\n\t\tif ( multiNaturalIdLoader == null ) {\n\t\t\tmultiNaturalIdLoader = naturalIdMapping.makeMultiLoader( this );\n\t\t}\n\t\treturn multiNaturalIdLoader;\n\t}\n\n\t@Override\n\tpublic Object loadEntityIdByNaturalId(\n\t\t\tObject[] naturalIdValues,\n\t\t\tLockOptions lockOptions,\n\t\t\tSharedSessionContractImplementor session) {\n\t\tverifyHasNaturalId();\n\t\tif ( LOG.isTraceEnabled() ) {\n\t\t\tLOG.tracef(\n\t\t\t\t\t\"Resolving natural-id [%s] to id : %s \",\n\t\t\t\t\tArrays.asList( naturalIdValues ),\n\t\t\t\t\tinfoString( this )\n\t\t\t);\n\t\t}\n\t\treturn getNaturalIdLoader().resolveNaturalIdToId( naturalIdValues, session );\n\t}\n\n\t@Override\n\tpublic boolean hasNaturalIdentifier() {\n\t\treturn entityMetamodel.hasNaturalIdentifier();\n\t}\n\n\tprivate void setPropertyValue(Object object, String propertyName, Object value) {\n\t\tfinal AttributeMapping attributeMapping = findSubPart( propertyName, this ).asAttributeMapping();\n\t\tsetterCache[attributeMapping.getStateArrayPosition()].set( object, value );\n\t}\n\n\tpublic static int getTableId(String tableName, String[] tables) {\n\t\tfor ( int j = 0; j < tables.length; j++ ) {\n\t\t\tif ( tableName.equalsIgnoreCase( tables[j] ) ) {\n\t\t\t\treturn j;\n\t\t\t}\n\t\t}\n\t\tthrow new AssertionFailure( \"Table \" + tableName + \" not found\" );\n\t}\n\n\t@Override\n\tpublic EntityRepresentationStrategy getRepresentationStrategy() {\n\t\treturn representationStrategy;\n\t}\n\n\t@Override\n\tpublic BytecodeEnhancementMetadata getInstrumentationMetadata() {\n\t\treturn getBytecodeEnhancementMetadata();\n\t}\n\n\t@Override\n\tpublic BytecodeEnhancementMetadata getBytecodeEnhancementMetadata() {\n\t\treturn entityMetamodel.getBytecodeEnhancementMetadata();\n\t}\n\n\t@Override\n\tpublic String getTableNameForColumn(String columnName) {\n\t\treturn getTableName( determineTableNumberForColumn( columnName ) );\n\t}\n\n\tprotected int determineTableNumberForColumn(String columnName) {\n\t\treturn 0;\n\t}\n\n\tprotected String determineTableName(Table table) {\n\t\treturn MappingModelCreationHelper.getTableIdentifierExpression( table, factory );\n\t}\n\n\t@Override\n\tpublic EntityEntryFactory getEntityEntryFactory() {\n\t\treturn this.entityEntryFactory;\n\t}\n\n\t/**\n\t * Consolidated these onto a single helper because the 2 pieces work in tandem.\n\t */\n\tpublic interface CacheEntryHelper {\n\t\tCacheEntryStructure getCacheEntryStructure();\n\n\t\tCacheEntry buildCacheEntry(Object entity, Object[] state, Object version, SharedSessionContractImplementor session);\n\t}\n\n\tprivate static class StandardCacheEntryHelper implements CacheEntryHelper {\n\t\tprivate final EntityPersister persister;\n\n\t\tprivate StandardCacheEntryHelper(EntityPersister persister) {\n\t\t\tthis.persister = persister;\n\t\t}\n\n\t\t@Override\n\t\tpublic CacheEntryStructure getCacheEntryStructure() {\n\t\t\treturn UnstructuredCacheEntry.INSTANCE;\n\t\t}\n\n\t\t@Override\n\t\tpublic CacheEntry buildCacheEntry(Object entity, Object[] state, Object version, SharedSessionContractImplementor session) {\n\t\t\treturn new StandardCacheEntryImpl( state, persister, version, session, entity );\n\t\t}\n\t}\n\n\tprivate static class ReferenceCacheEntryHelper implements CacheEntryHelper {\n\t\tprivate final EntityPersister persister;\n\n\t\tprivate ReferenceCacheEntryHelper(EntityPersister persister) {\n\t\t\tthis.persister = persister;\n\t\t}\n\n\t\t@Override\n\t\tpublic CacheEntryStructure getCacheEntryStructure() {\n\t\t\treturn UnstructuredCacheEntry.INSTANCE;\n\t\t}\n\n\t\t@Override\n\t\tpublic CacheEntry buildCacheEntry(Object entity, Object[] state, Object version, SharedSessionContractImplementor session) {\n\t\t\treturn new ReferenceCacheEntryImpl( entity, persister );\n\t\t}\n\t}\n\n\tprivate static class StructuredCacheEntryHelper implements CacheEntryHelper {\n\t\tprivate final EntityPersister persister;\n\t\tprivate final StructuredCacheEntry structure;\n\n\t\tprivate StructuredCacheEntryHelper(EntityPersister persister) {\n\t\t\tthis.persister = persister;\n\t\t\tthis.structure = new StructuredCacheEntry( persister );\n\t\t}\n\n\t\t@Override\n\t\tpublic CacheEntryStructure getCacheEntryStructure() {\n\t\t\treturn structure;\n\t\t}\n\n\t\t@Override\n\t\tpublic CacheEntry buildCacheEntry(Object entity, Object[] state, Object version, SharedSessionContractImplementor session) {\n\t\t\treturn new StandardCacheEntryImpl( state, persister, version, session, entity );\n\t\t}\n\t}\n\n\tprivate static class NoopCacheEntryHelper implements CacheEntryHelper {\n\t\tpublic static final NoopCacheEntryHelper INSTANCE = new NoopCacheEntryHelper();\n\n\t\t@Override\n\t\tpublic CacheEntryStructure getCacheEntryStructure() {\n\t\t\treturn UnstructuredCacheEntry.INSTANCE;\n\t\t}\n\n\t\t@Override\n\t\tpublic CacheEntry buildCacheEntry(Object entity, Object[] state, Object version, SharedSessionContractImplementor session) {\n\t\t\tthrow new HibernateException( \"Illegal attempt to build cache entry for non-cached entity\" );\n\t\t}\n\t}\n\n\n\t// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\t// org.hibernate.metamodel.mapping.EntityMappingType\n\n\t@Override\n\tpublic void forEachAttributeMapping(Consumer<? super AttributeMapping> action) {\n\t\tthis.attributeMappings.forEach( action );\n\t}\n\n\t@Override\n\tpublic void forEachAttributeMapping(final IndexedConsumer<? super AttributeMapping> consumer) {\n\t\tattributeMappings.indexedForEach( consumer );\n\t}\n\n\t@Override\n\tpublic void prepareMappingModel(MappingModelCreationProcess creationProcess) {\n\t\tif ( identifierMapping != null ) {\n\t\t\treturn;\n\t\t}\n\n\t\tfinal RuntimeModelCreationContext creationContext = creationProcess.getCreationContext();\n\n\t\tfinal PersistentClass bootEntityDescriptor = creationContext\n\t\t\t\t.getBootModel()\n\t\t\t\t.getEntityBinding( getEntityName() );\n\n//\t\tEntityMappingType rootEntityDescriptor;\n\t\tif ( superMappingType != null ) {\n\t\t\t( (InFlightEntityMappingType) superMappingType ).prepareMappingModel( creationProcess );\n\t\t\tif ( shouldProcessSuperMapping() ) {\n\t\t\t\tdiscriminatorMapping = superMappingType.getDiscriminatorMapping();\n\t\t\t\tidentifierMapping = superMappingType.getIdentifierMapping();\n\t\t\t\tnaturalIdMapping = superMappingType.getNaturalIdMapping();\n\t\t\t\tversionMapping = superMappingType.getVersionMapping();\n\t\t\t\trowIdMapping = superMappingType.getRowIdMapping();\n\t\t\t\tsoftDeleteMapping = superMappingType.getSoftDeleteMapping();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tprepareMappingModel( creationProcess, bootEntityDescriptor );\n\t\t\t}\n//\t\t\trootEntityDescriptor = superMappingType.getRootEntityDescriptor();\n\t\t}\n\t\telse {\n\t\t\tprepareMappingModel( creationProcess, bootEntityDescriptor );\n//\t\t\trootEntityDescriptor = this;\n\t\t}\n\n\t\tfinal EntityMetamodel currentEntityMetamodel = getEntityMetamodel();\n\n\t\tif ( currentEntityMetamodel.isVersioned() ) {\n\t\t\tfinal BeforeExecutionGenerator generator = currentEntityMetamodel.getVersionGenerator();\n\t\t\t// need to do this here because EntityMetamodel doesn't have the EntityVersionMapping :-(\n\t\t\tversionGenerator = generator == null ? new VersionGeneration( versionMapping ) : generator;\n\t\t}\n\n\t\tint stateArrayPosition = getStateArrayInitialPosition( creationProcess );\n\n\t\tfinal NonIdentifierAttribute[] properties = currentEntityMetamodel.getProperties();\n\t\tAttributeMappingsMap.Builder mappingsBuilder = AttributeMappingsMap.builder();\n\t\tint fetchableIndex = getFetchableIndexOffset();\n\t\tfor ( int i = 0; i < currentEntityMetamodel.getPropertySpan(); i++ ) {\n\t\t\tfinal NonIdentifierAttribute runtimeAttrDefinition = properties[i];\n\t\t\tfinal Property bootProperty = bootEntityDescriptor.getProperty( runtimeAttrDefinition.getName() );\n\n\t\t\tif ( superMappingType == null\n\t\t\t\t\t|| superMappingType.findAttributeMapping( bootProperty.getName() ) == null ) {\n\t\t\t\tmappingsBuilder.put(\n\t\t\t\t\t\truntimeAttrDefinition.getName(),\n\t\t\t\t\t\tgenerateNonIdAttributeMapping(\n\t\t\t\t\t\t\t\truntimeAttrDefinition,\n\t\t\t\t\t\t\t\tbootProperty,\n\t\t\t\t\t\t\t\tstateArrayPosition++,\n\t\t\t\t\t\t\t\tfetchableIndex++,\n\t\t\t\t\t\t\t\tcreationProcess\n\t\t\t\t\t\t)\n\t\t\t\t);\n\t\t\t}\n\t\t\tdeclaredAttributeMappings = mappingsBuilder.build();\n//\t\t\telse {\n\t\t\t\t// its defined on the supertype, skip it here\n//\t\t\t}\n\t\t}\n\n\t\tgetAttributeMappings();\n\n\t\tpostProcessAttributeMappings( creationProcess, bootEntityDescriptor );\n\n\t\tfinal ReflectionOptimizer reflectionOptimizer = representationStrategy.getReflectionOptimizer();\n\t\taccessOptimizer = reflectionOptimizer != null ? reflectionOptimizer.getAccessOptimizer() : null;\n\n\t\t// register a callback for after all `#prepareMappingModel` calls have finished.  here we want to delay the\n\t\t// generation of `staticFetchableList` because we need to wait until after all subclasses have had their\n\t\t// `#prepareMappingModel` called (and their declared attribute mappings resolved)\n\t\tcreationProcess.registerInitializationCallback(\n\t\t\t\t\"Entity(\" + getEntityName() + \") `staticFetchableList` generator\",\n\t\t\t\t() -> {\n\t\t\t\t\tfinal ImmutableAttributeMappingList.Builder builder =\n\t\t\t\t\t\t\tnew ImmutableAttributeMappingList.Builder( attributeMappings.size() );\n\t\t\t\t\tvisitSubTypeAttributeMappings( builder::add );\n\t\t\t\t\tassert superMappingType != null || builder.assertFetchableIndexes();\n\t\t\t\t\tstaticFetchableList = builder.build();\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t);\n\n\t\tboolean needsMultiTableInsert = hasMultipleTables();\n\t\tif ( needsMultiTableInsert ) {\n\t\t\tcreationProcess.registerInitializationCallback(\n\t\t\t\t\t\"Entity(\" + getEntityName() + \") `sqmMultiTableMutationStrategy` interpretation\",\n\t\t\t\t\t() -> {\n\t\t\t\t\t\tsqmMultiTableMutationStrategy =\n\t\t\t\t\t\t\t\tinterpretSqmMultiTableStrategy( this, creationProcess );\n\t\t\t\t\t\tif ( sqmMultiTableMutationStrategy == null ) {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tsqmMultiTableMutationStrategy.prepare(\n\t\t\t\t\t\t\t\t\tcreationProcess,\n\t\t\t\t\t\t\t\t\tcreationContext.getJdbcServices().getBootstrapJdbcConnectionAccess()\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t);\n\n\t\t}\n\t\telse {\n\t\t\tsqmMultiTableMutationStrategy = null;\n\t\t}\n\n\t\tif ( !needsMultiTableInsert && getGenerator() instanceof BulkInsertionCapableIdentifierGenerator ) {\n\t\t\tif ( getGenerator() instanceof OptimizableGenerator ) {\n\t\t\t\tfinal Optimizer optimizer = ( (OptimizableGenerator) getGenerator() ).getOptimizer();\n\t\t\t\tneedsMultiTableInsert = optimizer != null && optimizer.getIncrementSize() > 1;\n\t\t\t}\n\t\t}\n\n\t\tif ( needsMultiTableInsert ) {\n\t\t\tcreationProcess.registerInitializationCallback(\n\t\t\t\t\t\"Entity(\" + getEntityName() + \") `sqmMultiTableInsertStrategy` interpretation\",\n\t\t\t\t\t() -> {\n\t\t\t\t\t\tsqmMultiTableInsertStrategy =\n\t\t\t\t\t\t\t\tinterpretSqmMultiTableInsertStrategy( this, creationProcess );\n\t\t\t\t\t\tif ( sqmMultiTableInsertStrategy == null ) {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tsqmMultiTableInsertStrategy.prepare(\n\t\t\t\t\t\t\t\t\tcreationProcess,\n\t\t\t\t\t\t\t\t\tcreationContext.getJdbcServices().getBootstrapJdbcConnectionAccess()\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t);\n\n\t\t}\n\t\telse {\n\t\t\tsqmMultiTableInsertStrategy = null;\n\t\t}\n\t}\n\n\tprivate int getFetchableIndexOffset() {\n\t\tif ( superMappingType != null ) {\n\t\t\tfinal EntityMappingType rootEntityDescriptor = getRootEntityDescriptor();\n\t\t\tint offset = rootEntityDescriptor.getNumberOfDeclaredAttributeMappings();\n\t\t\tfor ( EntityMappingType subMappingType : rootEntityDescriptor.getSubMappingTypes() ) {\n\t\t\t\tif ( subMappingType == this ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t// Determining the number of attribute mappings unfortunately has to be done this way,\n\t\t\t\t// because calling `subMappingType.getNumberOfDeclaredAttributeMappings()` at this point\n\t\t\t\t// may produce wrong results because subMappingType might not have completed prepareMappingModel yet\n\t\t\t\tfinal int propertySpan = subMappingType.getEntityPersister().getEntityMetamodel().getPropertySpan();\n\t\t\t\tfinal int superPropertySpan = subMappingType.getSuperMappingType()\n\t\t\t\t\t\t.getEntityPersister()\n\t\t\t\t\t\t.getEntityMetamodel()\n\t\t\t\t\t\t.getPropertySpan();\n\t\t\t\tfinal int numberOfDeclaredAttributeMappings = propertySpan - superPropertySpan;\n\t\t\t\toffset += numberOfDeclaredAttributeMappings;\n\t\t\t}\n\t\t\treturn offset;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tprivate void prepareMappingModel(MappingModelCreationProcess creationProcess, PersistentClass bootEntityDescriptor) {\n\t\tfinal EntityInstantiator instantiator = getRepresentationStrategy().getInstantiator();\n\t\tfinal Supplier<?> templateInstanceCreator;\n\t\tif ( ! instantiator.canBeInstantiated() ) {\n\t\t\ttemplateInstanceCreator = null;\n\t\t}\n\t\telse {\n\t\t\tfinal SessionFactoryImplementor sessionFactory = creationProcess.getCreationContext().getSessionFactory();\n\t\t\ttemplateInstanceCreator = new LazyValue<>( () -> instantiator.instantiate( sessionFactory ) )::getValue;\n\t\t}\n\n\t\tidentifierMapping = creationProcess.processSubPart(\n\t\t\t\tEntityIdentifierMapping.ID_ROLE_NAME,\n\t\t\t\t(role, process) -> generateIdentifierMapping( templateInstanceCreator, bootEntityDescriptor, process )\n\t\t);\n\n\t\tversionMapping = generateVersionMapping( templateInstanceCreator, bootEntityDescriptor, creationProcess );\n\n\t\tif ( rowIdName == null ) {\n\t\t\trowIdMapping = null;\n\t\t}\n\t\telse {\n\t\t\trowIdMapping = creationProcess.processSubPart(\n\t\t\t\t\trowIdName,\n\t\t\t\t\t(role, process) -> new EntityRowIdMappingImpl( rowIdName, getTableName(), this )\n\t\t\t);\n\t\t}\n\n\t\tdiscriminatorMapping = generateDiscriminatorMapping( bootEntityDescriptor );\n\t\tsoftDeleteMapping = resolveSoftDeleteMapping( this, bootEntityDescriptor, getIdentifierTableName(), creationProcess );\n\n\t\tif ( softDeleteMapping != null ) {\n\t\t\tif ( bootEntityDescriptor.getRootClass().getCustomSQLDelete() != null ) {\n\t\t\t\tthrow new UnsupportedMappingException( \"Entity may not define both @SoftDelete and @SQLDelete\" );\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate static SoftDeleteMapping resolveSoftDeleteMapping(\n\t\t\tAbstractEntityPersister persister,\n\t\t\tPersistentClass bootEntityDescriptor,\n\t\t\tString identifierTableName,\n\t\t\tMappingModelCreationProcess creationProcess) {\n\t\tfinal RootClass rootClass = bootEntityDescriptor.getRootClass();\n\t\treturn SoftDeleteHelper.resolveSoftDeleteMapping(\n\t\t\t\tpersister,\n\t\t\t\trootClass,\n\t\t\t\tidentifierTableName,\n\t\t\t\tcreationProcess.getCreationContext().getJdbcServices().getDialect()\n\t\t);\n\t}\n\n\tprivate void postProcessAttributeMappings(MappingModelCreationProcess creationProcess, PersistentClass bootEntityDescriptor) {\n\t\tif ( superMappingType != null ) {\n\t\t\tnaturalIdMapping = superMappingType.getNaturalIdMapping();\n\t\t}\n\t\telse if ( bootEntityDescriptor.hasNaturalId() ) {\n\t\t\tnaturalIdMapping = generateNaturalIdMapping( creationProcess, bootEntityDescriptor );\n\t\t}\n\t\telse {\n\t\t\tnaturalIdMapping = null;\n\t\t}\n\t}\n\n\tprotected NaturalIdMapping generateNaturalIdMapping(MappingModelCreationProcess creationProcess, PersistentClass bootEntityDescriptor) {\n\t\t//noinspection AssertWithSideEffects\n\t\tassert bootEntityDescriptor.hasNaturalId();\n\n\t\tfinal int[] naturalIdAttributeIndexes = entityMetamodel.getNaturalIdentifierProperties();\n\t\tassert naturalIdAttributeIndexes.length > 0;\n\n\t\tif ( naturalIdAttributeIndexes.length == 1 ) {\n\t\t\tfinal String propertyName = entityMetamodel.getPropertyNames()[ naturalIdAttributeIndexes[ 0 ] ];\n\t\t\tfinal AttributeMapping attributeMapping = findAttributeMapping( propertyName );\n\t\t\tfinal SingularAttributeMapping singularAttributeMapping = (SingularAttributeMapping) attributeMapping;\n\t\t\treturn new SimpleNaturalIdMapping( singularAttributeMapping, this, creationProcess );\n\t\t}\n\n\t\t// collect the names of the attributes making up the natural-id.\n\t\tfinal Set<String> attributeNames = setOfSize( naturalIdAttributeIndexes.length );\n\t\tfor ( int naturalIdAttributeIndex : naturalIdAttributeIndexes ) {\n\t\t\tattributeNames.add( this.getPropertyNames()[ naturalIdAttributeIndex ] );\n\t\t}\n\n\t\t// then iterate over the attribute mappings finding the ones having names\n\t\t// in the collected names.  iterate here because it is already alphabetical\n\n\t\tfinal List<SingularAttributeMapping> collectedAttrMappings = new ArrayList<>();\n\t\tfor ( int i = 0; i < attributeMappings.size(); i++ ) {\n\t\t\tfinal AttributeMapping attributeMapping = attributeMappings.get( i );\n\t\t\tif ( attributeNames.contains( attributeMapping.getAttributeName() ) ) {\n\t\t\t\tcollectedAttrMappings.add( (SingularAttributeMapping) attributeMapping );\n\t\t\t}\n\t\t}\n\n\t\tif ( collectedAttrMappings.size() <= 1 ) {\n\t\t\tthrow new MappingException( \"Expected multiple natural-id attributes, but found only one: \" + getEntityName() );\n\t\t}\n\n\t\treturn new CompoundNaturalIdMapping(this, collectedAttrMappings, creationProcess );\n\t}\n\n\tprotected static SqmMultiTableMutationStrategy interpretSqmMultiTableStrategy(\n\t\t\tAbstractEntityPersister entityMappingDescriptor,\n\t\t\tMappingModelCreationProcess creationProcess) {\n\t\tassert entityMappingDescriptor.hasMultipleTables();\n\n\t\tfinal EntityMappingType superMappingType = entityMappingDescriptor.getSuperMappingType();\n\t\tif ( superMappingType != null ) {\n\t\t\tfinal SqmMultiTableMutationStrategy sqmMultiTableMutationStrategy =\n\t\t\t\t\tsuperMappingType.getSqmMultiTableMutationStrategy();\n\t\t\tif ( sqmMultiTableMutationStrategy != null ) {\n\t\t\t\treturn sqmMultiTableMutationStrategy;\n\t\t\t}\n\t\t}\n\n\t\tfinal ServiceRegistry serviceRegistry = creationProcess.getCreationContext().getServiceRegistry();\n\t\treturn serviceRegistry.requireService( SqmMultiTableMutationStrategyProvider.class )\n\t\t\t\t.createMutationStrategy( entityMappingDescriptor, creationProcess );\n\t}\n\n\tprotected static SqmMultiTableInsertStrategy interpretSqmMultiTableInsertStrategy(\n\t\t\tAbstractEntityPersister entityMappingDescriptor,\n\t\t\tMappingModelCreationProcess creationProcess) {\n\t\tfinal ServiceRegistry serviceRegistry = creationProcess.getCreationContext().getServiceRegistry();\n\t\treturn serviceRegistry.requireService( SqmMultiTableMutationStrategyProvider.class )\n\t\t\t\t.createInsertStrategy( entityMappingDescriptor, creationProcess );\n\t}\n\n\t@Override\n\tpublic SqmMultiTableMutationStrategy getSqmMultiTableMutationStrategy() {\n\t\treturn sqmMultiTableMutationStrategy;\n\t}\n\n\t@Override\n\tpublic SqmMultiTableInsertStrategy getSqmMultiTableInsertStrategy() {\n\t\treturn sqmMultiTableInsertStrategy;\n\t}\n\n\tprotected int getStateArrayInitialPosition(MappingModelCreationProcess creationProcess) {\n\t\t// todo (6.0) not sure this is correct in case of SingleTable Inheritance\n\t\t//            and for Table per class when the selection is the root\n\t\tif ( superMappingType == null ) {\n\t\t\treturn 0;\n\t\t}\n\t\telse {\n\t\t\t( (InFlightEntityMappingType) superMappingType ).prepareMappingModel( creationProcess );\n\t\t\treturn superMappingType.getNumberOfAttributeMappings();\n\t\t}\n\t}\n\n\tprotected boolean isPhysicalDiscriminator() {\n\t\treturn getDiscriminatorFormulaTemplate() == null;\n\t}\n\n\tprotected EntityDiscriminatorMapping generateDiscriminatorMapping(PersistentClass bootEntityDescriptor) {\n\t\tif ( getDiscriminatorType() == null ) {\n\t\t\treturn null;\n\t\t}\n\t\telse {\n\t\t\tfinal String discriminatorColumnExpression;\n\t\t\tfinal String columnDefinition;\n\t\t\tfinal Long length;\n\t\t\tfinal Integer precision;\n\t\t\tfinal Integer scale;\n\t\t\tif ( getDiscriminatorFormulaTemplate() == null ) {\n\t\t\t\tfinal Column column = bootEntityDescriptor.getDiscriminator() == null\n\t\t\t\t\t\t? null\n\t\t\t\t\t\t: bootEntityDescriptor.getDiscriminator().getColumns().get( 0 );\n\t\t\t\tdiscriminatorColumnExpression = getDiscriminatorColumnReaders();\n\t\t\t\tif ( column == null ) {\n\t\t\t\t\tcolumnDefinition = null;\n\t\t\t\t\tlength = null;\n\t\t\t\t\tprecision = null;\n\t\t\t\t\tscale = null;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcolumnDefinition = column.getSqlType();\n\t\t\t\t\tlength = column.getLength();\n\t\t\t\t\tprecision = column.getPrecision();\n\t\t\t\t\tscale = column.getScale();\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdiscriminatorColumnExpression = getDiscriminatorFormulaTemplate();\n\t\t\t\tcolumnDefinition = null;\n\t\t\t\tlength = null;\n\t\t\t\tprecision = null;\n\t\t\t\tscale = null;\n\t\t\t}\n\t\t\treturn new ExplicitColumnDiscriminatorMappingImpl(\n\t\t\t\t\tthis,\n\t\t\t\t\tdiscriminatorColumnExpression,\n\t\t\t\t\tgetTableName(),\n\t\t\t\t\tdiscriminatorColumnExpression,\n\t\t\t\t\tgetDiscriminatorFormulaTemplate() != null,\n\t\t\t\t\tisPhysicalDiscriminator(),\n\t\t\t\t\tfalse,\n\t\t\t\t\tcolumnDefinition,\n\t\t\t\t\tnull,\n\t\t\t\t\tlength,\n\t\t\t\t\tprecision,\n\t\t\t\t\tscale,\n\t\t\t\t\t(DiscriminatorType<?>) getTypeDiscriminatorMetadata().getResolutionType()\n\t\t\t);\n\t\t}\n\t}\n\n\t@Override\n\tpublic abstract BasicType<?> getDiscriminatorType();\n\n\tprotected EntityVersionMapping generateVersionMapping(\n\t\t\tSupplier<?> templateInstanceCreator,\n\t\t\tPersistentClass bootEntityDescriptor,\n\t\t\tMappingModelCreationProcess creationProcess) {\n\t\tif ( getVersionType() == null ) {\n\t\t\treturn null;\n\t\t}\n\t\telse {\n\t\t\treturn creationProcess.processSubPart(\n\t\t\t\t\tgetPropertyNames()[getVersionProperty()],\n\t\t\t\t\t(role, process) -> generateVersionMapping(\n\t\t\t\t\t\t\tthis,\n\t\t\t\t\t\t\ttemplateInstanceCreator,\n\t\t\t\t\t\t\tbootEntityDescriptor,\n\t\t\t\t\t\t\tcreationProcess\n\t\t\t\t\t)\n\t\t\t);\n\t\t}\n\t}\n\n\tprotected boolean shouldProcessSuperMapping(){\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic void linkWithSuperType(MappingModelCreationProcess creationProcess) {\n\t\tif ( getMappedSuperclass() != null ) {\n\t\t\tsuperMappingType = creationProcess.getEntityPersister( getMappedSuperclass() );\n\t\t\tfinal InFlightEntityMappingType inFlightEntityMappingType = (InFlightEntityMappingType) superMappingType;\n\t\t\tinFlightEntityMappingType.linkWithSubType(this, creationProcess);\n\t\t\tif ( subclassMappingTypes != null ) {\n\t\t\t\tsubclassMappingTypes.values()\n\t\t\t\t\t\t.forEach( sub -> inFlightEntityMappingType.linkWithSubType(sub, creationProcess) );\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic void linkWithSubType(EntityMappingType sub, MappingModelCreationProcess creationProcess) {\n\t\tif ( subclassMappingTypes == null ) {\n\t\t\tsubclassMappingTypes = new TreeMap<>();\n\t\t}\n\t\tsubclassMappingTypes.put( sub.getEntityName(), sub );\n\t\tif ( superMappingType != null ) {\n\t\t\t( (InFlightEntityMappingType) superMappingType ).linkWithSubType( sub, creationProcess );\n\t\t}\n\t}\n\n\t@Override\n\tpublic int getNumberOfAttributeMappings() {\n\t\tif ( attributeMappings == null ) {\n\t\t\t// force calculation of `attributeMappings`\n\t\t\tgetAttributeMappings();\n\t\t}\n\t\treturn attributeMappings.size();\n\t}\n\n\t@Override\n\tpublic AttributeMapping getAttributeMapping(int position) {\n\t\treturn attributeMappings.get( position );\n\t}\n\n\t@Override\n\tpublic int getNumberOfDeclaredAttributeMappings() {\n\t\treturn declaredAttributeMappings.size();\n\t}\n\n\t@Override\n\tpublic AttributeMappingsMap getDeclaredAttributeMappings() {\n\t\treturn declaredAttributeMappings;\n\t}\n\n\t@Override\n\tpublic void visitDeclaredAttributeMappings(Consumer<? super AttributeMapping> action) {\n\t\tdeclaredAttributeMappings.forEachValue( action );\n\t}\n\n\t@Override\n\tpublic EntityMappingType getSuperMappingType() {\n\t\treturn superMappingType;\n\t}\n\n\t@Override\n\tpublic Collection<EntityMappingType> getSubMappingTypes() {\n\t\treturn subclassMappingTypes == null ? emptyList() : subclassMappingTypes.values();\n\t}\n\n\t@Override\n\tpublic boolean isTypeOrSuperType(EntityMappingType targetType) {\n\t\tif ( targetType == null ) {\n\t\t\t// todo (6.0) : need to think through what this ought to indicate (if we allow it at all)\n\t\t\t//\t\t- see `org.hibernate.metamodel.mapping.internal.AbstractManagedMappingType#isTypeOrSuperType`\n\t\t\treturn true;\n\t\t}\n\t\telse if ( targetType == this ) {\n\t\t\treturn true;\n\t\t}\n\t\telse if ( superMappingType != null ) {\n\t\t\treturn superMappingType.isTypeOrSuperType( targetType );\n\t\t}\n\t\telse {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\n\tprotected EntityIdentifierMapping generateIdentifierMapping(\n\t\t\tSupplier<?> templateInstanceCreator,\n\t\t\tPersistentClass bootEntityDescriptor,\n\t\t\tMappingModelCreationProcess creationProcess) {\n\t\tfinal Type idType = getIdentifierType();\n\n\t\tif ( idType instanceof CompositeType ) {\n\t\t\tfinal CompositeType cidType = (CompositeType) idType;\n\n\t\t\t// NOTE: the term `isEmbedded` here uses Hibernate's older (pre-JPA) naming for its \"non-aggregated\"\n\t\t\t// composite-id support.  It unfortunately conflicts with the JPA usage of \"embedded\".  Here we normalize\n\t\t\t// the legacy naming to the more descriptive encapsulated versus non-encapsulated phrasing\n\n\t\t\tfinal boolean encapsulated = !cidType.isEmbedded();\n\t\t\tif ( encapsulated ) {\n\t\t\t\t// we have an `@EmbeddedId`\n\t\t\t\treturn MappingModelCreationHelper.buildEncapsulatedCompositeIdentifierMapping(\n\t\t\t\t\t\tthis,\n\t\t\t\t\t\tbootEntityDescriptor.getIdentifierProperty(),\n\t\t\t\t\t\tbootEntityDescriptor.getIdentifierProperty().getName(),\n\t\t\t\t\t\tgetTableName(),\n\t\t\t\t\t\trootTableKeyColumnNames,\n\t\t\t\t\t\tcidType,\n\t\t\t\t\t\tcreationProcess\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// otherwise we have a non-encapsulated composite-identifier\n\t\t\treturn generateNonEncapsulatedCompositeIdentifierMapping( creationProcess, bootEntityDescriptor );\n\t\t}\n\t\tfinal String columnDefinition;\n\t\tfinal Long length;\n\t\tfinal Integer precision;\n\t\tfinal Integer scale;\n\t\tif ( bootEntityDescriptor.getIdentifier() == null ) {\n\t\t\tcolumnDefinition = null;\n\t\t\tlength = null;\n\t\t\tprecision = null;\n\t\t\tscale = null;\n\t\t}\n\t\telse {\n\t\t\tColumn column = bootEntityDescriptor.getIdentifier().getColumns().get( 0 );\n\t\t\tcolumnDefinition = column.getSqlType();\n\t\t\tlength = column.getLength();\n\t\t\tprecision = column.getPrecision();\n\t\t\tscale = column.getScale();\n\t\t}\n\n\t\tfinal Value value = bootEntityDescriptor.getIdentifierProperty().getValue();\n\t\treturn new BasicEntityIdentifierMappingImpl(\n\t\t\t\tthis,\n\t\t\t\ttemplateInstanceCreator,\n\t\t\t\tbootEntityDescriptor.getIdentifierProperty().getName(),\n\t\t\t\tgetTableName(),\n\t\t\t\trootTableKeyColumnNames[0],\n\t\t\t\tcolumnDefinition,\n\t\t\t\tlength,\n\t\t\t\tprecision,\n\t\t\t\tscale,\n\t\t\t\tvalue.isColumnInsertable( 0 ),\n\t\t\t\tvalue.isColumnUpdateable( 0 ),\n\t\t\t\t(BasicType<?>) idType,\n\t\t\t\tcreationProcess\n\t\t);\n\t}\n\n\tprotected EntityIdentifierMapping generateNonEncapsulatedCompositeIdentifierMapping(\n\t\t\tMappingModelCreationProcess creationProcess,\n\t\t\tPersistentClass bootEntityDescriptor) {\n\t\treturn MappingModelCreationHelper.buildNonEncapsulatedCompositeIdentifierMapping(\n\t\t\t\tthis,\n\t\t\t\tgetTableName(),\n\t\t\t\tgetRootTableKeyColumnNames(),\n\t\t\t\tbootEntityDescriptor,\n\t\t\t\tcreationProcess\n\t\t);\n\t}\n\n\t/**\n\t * @param entityPersister The AbstractEntityPersister being constructed - still initializing\n\t * @param bootModelRootEntityDescriptor The boot-time entity descriptor for the \"root entity\" in the hierarchy\n\t * @param creationProcess The SF creation process - access to useful things\n\t */\n\tprotected static EntityVersionMapping generateVersionMapping(\n\t\t\tAbstractEntityPersister entityPersister,\n\t\t\tSupplier<?> templateInstanceCreator,\n\t\t\tPersistentClass bootModelRootEntityDescriptor,\n\t\t\tMappingModelCreationProcess creationProcess) {\n\t\tfinal Property versionProperty = bootModelRootEntityDescriptor.getVersion();\n\t\tfinal BasicValue bootModelVersionValue = (BasicValue) versionProperty.getValue();\n\t\tfinal BasicValue.Resolution<?> basicTypeResolution = bootModelVersionValue.resolve();\n\n\t\tfinal Column column = (Column) bootModelVersionValue.getColumn();\n\t\tfinal Dialect dialect = creationProcess.getCreationContext().getDialect();\n\n\t\treturn new EntityVersionMappingImpl(\n\t\t\t\tbootModelRootEntityDescriptor.getRootClass(),\n\t\t\t\ttemplateInstanceCreator,\n\t\t\t\tbootModelRootEntityDescriptor.getVersion().getName(),\n\t\t\t\tentityPersister.getTableName(),\n\t\t\t\tcolumn.getText( dialect ),\n\t\t\t\tcolumn.getSqlType(),\n\t\t\t\tcolumn.getLength(),\n\t\t\t\tcolumn.getPrecision(),\n\t\t\t\tcolumn.getScale(),\n\t\t\t\tcolumn.getTemporalPrecision(),\n\t\t\t\tbasicTypeResolution.getLegacyResolvedBasicType(),\n\t\t\t\tentityPersister,\n\t\t\t\tcreationProcess\n\t\t);\n\t}\n\n\tprotected AttributeMapping generateNonIdAttributeMapping(\n\t\t\tNonIdentifierAttribute tupleAttrDefinition,\n\t\t\tProperty bootProperty,\n\t\t\tint stateArrayPosition,\n\t\t\tint fetchableIndex,\n\t\t\tMappingModelCreationProcess creationProcess) {\n\t\tfinal RuntimeModelCreationContext creationContext = creationProcess.getCreationContext();\n\n\t\tfinal String attrName = tupleAttrDefinition.getName();\n\t\tfinal Type attrType = tupleAttrDefinition.getType();\n\n\t\tfinal int propertyIndex = getPropertyIndex( bootProperty.getName() );\n\n\t\tfinal String tableExpression = getTableName( getPropertyTableNumbers()[propertyIndex] );\n\t\tfinal String[] attrColumnNames = getPropertyColumnNames( propertyIndex );\n\n\t\tfinal PropertyAccess propertyAccess = getRepresentationStrategy().resolvePropertyAccess( bootProperty );\n\n\t\tfinal Value value = bootProperty.getValue();\n\t\tif ( propertyIndex == getVersionProperty() ) {\n\t\t\tColumn column = value.getColumns().get( 0 );\n\t\t\treturn MappingModelCreationHelper.buildBasicAttributeMapping(\n\t\t\t\t\tattrName,\n\t\t\t\t\tgetNavigableRole().append( bootProperty.getName() ),\n\t\t\t\t\tstateArrayPosition,\n\t\t\t\t\tfetchableIndex,\n\t\t\t\t\tbootProperty,\n\t\t\t\t\tthis,\n\t\t\t\t\t(BasicType<?>) attrType,\n\t\t\t\t\ttableExpression,\n\t\t\t\t\tattrColumnNames[0],\n\t\t\t\t\tnull,\n\t\t\t\t\tfalse,\n\t\t\t\t\tnull,\n\t\t\t\t\t\"?\",\n\t\t\t\t\tcolumn.getSqlType(),\n\t\t\t\t\tcolumn.getLength(),\n\t\t\t\t\tcolumn.getPrecision(),\n\t\t\t\t\tcolumn.getScale(),\n\t\t\t\t\tcolumn.getTemporalPrecision(),\n\t\t\t\t\tcolumn.isSqlTypeLob( creationProcess.getCreationContext().getMetadata() ),\n\t\t\t\t\tcolumn.isNullable(),\n\t\t\t\t\tvalue.isColumnInsertable( 0 ),\n\t\t\t\t\tvalue.isColumnUpdateable( 0 ),\n\t\t\t\t\tpropertyAccess,\n\t\t\t\t\ttupleAttrDefinition.getCascadeStyle(),\n\t\t\t\t\tcreationProcess\n\t\t\t);\n\t\t}\n\n\t\tif ( attrType instanceof BasicType ) {\n\t\t\tfinal NavigableRole role = getNavigableRole().append( bootProperty.getName() );\n\t\t\tfinal String attrColumnExpression;\n\t\t\tfinal boolean isAttrColumnExpressionFormula;\n\t\t\tfinal String customReadExpr;\n\t\t\tfinal String customWriteExpr;\n\t\t\tfinal String columnDefinition;\n\t\t\tfinal Long length;\n\t\t\tfinal Integer precision;\n\t\t\tfinal Integer scale;\n\t\t\tfinal Integer temporalPrecision;\n\t\t\tfinal boolean isLob;\n\t\t\tfinal boolean nullable;\n\n\t\t\tif ( value instanceof DependantValue ) {\n\t\t\t\tattrColumnExpression = attrColumnNames[0];\n\t\t\t\tisAttrColumnExpressionFormula = false;\n\t\t\t\tcustomReadExpr = null;\n\t\t\t\tcustomWriteExpr = \"?\";\n\t\t\t\tColumn column = value.getColumns().get( 0 );\n\t\t\t\tcolumnDefinition = column.getSqlType();\n\t\t\t\tlength = column.getLength();\n\t\t\t\tprecision = column.getPrecision();\n\t\t\t\ttemporalPrecision = column.getTemporalPrecision();\n\t\t\t\tscale = column.getScale();\n\t\t\t\tisLob = column.isSqlTypeLob( creationProcess.getCreationContext().getMetadata() );\n\t\t\t\tnullable = column.isNullable();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfinal BasicValue basicBootValue = (BasicValue) value;\n\n\t\t\t\tif ( attrColumnNames[ 0 ] != null ) {\n\t\t\t\t\tattrColumnExpression = attrColumnNames[ 0 ];\n\t\t\t\t\tisAttrColumnExpressionFormula = false;\n\n\t\t\t\t\tfinal List<Selectable> selectables = basicBootValue.getSelectables();\n\t\t\t\t\tassert !selectables.isEmpty();\n\t\t\t\t\tfinal Selectable selectable = selectables.get(0);\n\n\t\t\t\t\tassert attrColumnExpression.equals( selectable.getText( creationContext.getDialect() ) );\n\n\t\t\t\t\tcustomReadExpr = selectable.getTemplate(\n\t\t\t\t\t\t\tcreationContext.getDialect(),\n\t\t\t\t\t\t\tcreationContext.getTypeConfiguration(),\n\t\t\t\t\t\t\tcreationContext.getFunctionRegistry()\n\t\t\t\t\t);\n\t\t\t\t\tcustomWriteExpr = selectable.getWriteExpr( (JdbcMapping) attrType, creationContext.getDialect() );\n\t\t\t\t\tColumn column = value.getColumns().get( 0 );\n\t\t\t\t\tcolumnDefinition = column.getSqlType();\n\t\t\t\t\tlength = column.getLength();\n\t\t\t\t\tprecision = column.getPrecision();\n\t\t\t\t\ttemporalPrecision = column.getTemporalPrecision();\n\t\t\t\t\tscale = column.getScale();\n\t\t\t\t\tnullable = column.isNullable();\n\t\t\t\t\tisLob = column.isSqlTypeLob( creationContext.getMetadata() );\n\t\t\t\t\tMappingModelCreationHelper.resolveAggregateColumnBasicType( creationProcess, role, column );\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tfinal String[] attrColumnFormulaTemplate = propertyColumnFormulaTemplates[ propertyIndex ];\n\t\t\t\t\tattrColumnExpression = attrColumnFormulaTemplate[ 0 ];\n\t\t\t\t\tisAttrColumnExpressionFormula = true;\n\t\t\t\t\tcustomReadExpr = null;\n\t\t\t\t\tcustomWriteExpr = null;\n\t\t\t\t\tcolumnDefinition = null;\n\t\t\t\t\tlength = null;\n\t\t\t\t\tprecision = null;\n\t\t\t\t\ttemporalPrecision = null;\n\t\t\t\t\tscale = null;\n\t\t\t\t\tnullable = true;\n\t\t\t\t\tisLob = false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn MappingModelCreationHelper.buildBasicAttributeMapping(\n\t\t\t\t\tattrName,\n\t\t\t\t\trole,\n\t\t\t\t\tstateArrayPosition,\n\t\t\t\t\tfetchableIndex,\n\t\t\t\t\tbootProperty,\n\t\t\t\t\tthis,\n\t\t\t\t\t(BasicType<?>) value.getType(),\n\t\t\t\t\ttableExpression,\n\t\t\t\t\tattrColumnExpression,\n\t\t\t\t\tnull,\n\t\t\t\t\tisAttrColumnExpressionFormula,\n\t\t\t\t\tcustomReadExpr,\n\t\t\t\t\tcustomWriteExpr,\n\t\t\t\t\tcolumnDefinition,\n\t\t\t\t\tlength,\n\t\t\t\t\tprecision,\n\t\t\t\t\tscale,\n\t\t\t\t\ttemporalPrecision,\n\t\t\t\t\tisLob,\n\t\t\t\t\tnullable,\n\t\t\t\t\tvalue.isColumnInsertable( 0 ),\n\t\t\t\t\tvalue.isColumnUpdateable( 0 ),\n\t\t\t\t\tpropertyAccess,\n\t\t\t\t\ttupleAttrDefinition.getCascadeStyle(),\n\t\t\t\t\tcreationProcess\n\t\t\t);\n\t\t}\n\t\telse if ( attrType instanceof AnyType ) {\n\t\t\tfinal JavaType<Object> baseAssociationJtd =\n\t\t\t\t\tcreationContext.getTypeConfiguration().getJavaTypeRegistry()\n\t\t\t\t\t\t\t.getDescriptor( Object.class );\n\n\t\t\tfinal AnyType anyType = (AnyType) attrType;\n\n\t\t\tfinal MutabilityPlan<?> mutabilityPlan = new DiscriminatedAssociationAttributeMapping.MutabilityPlanImpl( anyType );\n\t\t\tfinal SimpleAttributeMetadata attributeMetadataAccess = new SimpleAttributeMetadata(\n\t\t\t\t\tpropertyAccess,\n\t\t\t\t\tmutabilityPlan,\n\t\t\t\t\tbootProperty.isOptional(),\n\t\t\t\t\tbootProperty.isInsertable(),\n\t\t\t\t\tbootProperty.isUpdateable(),\n\t\t\t\t\tbootProperty.isOptimisticLocked(),\n\t\t\t\t\tbootProperty.isSelectable()\n\t\t\t);\n\n\t\t\treturn new DiscriminatedAssociationAttributeMapping(\n\t\t\t\t\tnavigableRole.append( bootProperty.getName() ),\n\t\t\t\t\tbaseAssociationJtd,\n\t\t\t\t\tthis,\n\t\t\t\t\tstateArrayPosition,\n\t\t\t\t\tfetchableIndex,\n\t\t\t\t\tattributeMetadataAccess,\n\t\t\t\t\tbootProperty.isLazy() ? FetchTiming.DELAYED : FetchTiming.IMMEDIATE,\n\t\t\t\t\tpropertyAccess,\n\t\t\t\t\tbootProperty,\n\t\t\t\t\t(AnyType) attrType,\n\t\t\t\t\t(Any) value,\n\t\t\t\t\tcreationProcess\n\t\t\t);\n\t\t}\n\t\telse if ( attrType instanceof CompositeType ) {\n\t\t\tDependantValue dependantValue = null;\n\t\t\tif ( bootProperty.getValue() instanceof DependantValue ) {\n\t\t\t\tdependantValue = ( (DependantValue) bootProperty.getValue() );\n\t\t\t}\n\n\t\t\treturn buildEmbeddedAttributeMapping(\n\t\t\t\t\tattrName,\n\t\t\t\t\tstateArrayPosition,\n\t\t\t\t\tfetchableIndex,\n\t\t\t\t\tbootProperty,\n\t\t\t\t\tdependantValue,\n\t\t\t\t\t0,\n\t\t\t\t\tthis,\n\t\t\t\t\t(CompositeType) attrType,\n\t\t\t\t\ttableExpression,\n\t\t\t\t\tnull,\n\t\t\t\t\tpropertyAccess,\n\t\t\t\t\ttupleAttrDefinition.getCascadeStyle(),\n\t\t\t\t\tcreationProcess\n\t\t\t);\n\t\t}\n\t\telse if ( attrType instanceof CollectionType ) {\n\t\t\treturn buildPluralAttributeMapping(\n\t\t\t\t\tattrName,\n\t\t\t\t\tstateArrayPosition,\n\t\t\t\t\tfetchableIndex,\n\t\t\t\t\tbootProperty,\n\t\t\t\t\tthis,\n\t\t\t\t\tpropertyAccess,\n\t\t\t\t\ttupleAttrDefinition.getCascadeStyle(),\n\t\t\t\t\tgetFetchMode( stateArrayPosition ),\n\t\t\t\t\tcreationProcess\n\t\t\t);\n\t\t}\n\t\telse if ( attrType instanceof EntityType ) {\n\t\t\treturn buildSingularAssociationAttributeMapping(\n\t\t\t\t\tattrName,\n\t\t\t\t\tgetNavigableRole().append( attrName ),\n\t\t\t\t\tstateArrayPosition,\n\t\t\t\t\tfetchableIndex,\n\t\t\t\t\tbootProperty,\n\t\t\t\t\tthis,\n\t\t\t\t\tthis,\n\t\t\t\t\t(EntityType) attrType,\n\t\t\t\t\tpropertyAccess,\n\t\t\t\t\ttupleAttrDefinition.getCascadeStyle(),\n\t\t\t\t\tcreationProcess\n\t\t\t);\n\t\t}\n\n\t\t// todo (6.0) : for now ignore any non basic-typed attributes\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * For Hibernate Reactive\n\t */\n\tprotected EmbeddedAttributeMapping buildEmbeddedAttributeMapping(\n\t\t\tString attrName,\n\t\t\tint stateArrayPosition,\n\t\t\tint fetchableIndex,\n\t\t\tProperty bootProperty,\n\t\t\tDependantValue dependantValue,\n\t\t\tint dependantColumnIndex,\n\t\t\tManagedMappingType declaringType,\n\t\t\tCompositeType attrType,\n\t\t\tString tableExpression,\n\t\t\tString[] rootTableKeyColumnNames,\n\t\t\tPropertyAccess propertyAccess,\n\t\t\tCascadeStyle cascadeStyle,\n\t\t\tMappingModelCreationProcess creationProcess) {\n\t\treturn MappingModelCreationHelper.buildEmbeddedAttributeMapping(\n\t\t\t\tattrName,\n\t\t\t\tstateArrayPosition,\n\t\t\t\tfetchableIndex,\n\t\t\t\tbootProperty,\n\t\t\t\tdependantValue,\n\t\t\t\tdependantColumnIndex,\n\t\t\t\tdeclaringType,\n\t\t\t\tattrType,\n\t\t\t\ttableExpression,\n\t\t\t\trootTableKeyColumnNames,\n\t\t\t\tpropertyAccess,\n\t\t\t\tcascadeStyle,\n\t\t\t\tcreationProcess\n\t\t);\n\t}\n\n\t/**\n\t * For Hibernate Reactive\n\t */\n\tprotected AttributeMapping buildSingularAssociationAttributeMapping(\n\t\t\tString attrName,\n\t\t\tNavigableRole navigableRole,\n\t\t\tint stateArrayPosition,\n\t\t\tint fetchableIndex,\n\t\t\tProperty bootProperty,\n\t\t\tManagedMappingType declaringType,\n\t\t\tEntityPersister declaringEntityPersister,\n\t\t\tEntityType attrType,\n\t\t\tPropertyAccess propertyAccess,\n\t\t\tCascadeStyle cascadeStyle,\n\t\t\tMappingModelCreationProcess creationProcess) {\n\t\treturn MappingModelCreationHelper.buildSingularAssociationAttributeMapping(\n\t\t\t\tattrName,\n\t\t\t\tnavigableRole,\n\t\t\t\tstateArrayPosition,\n\t\t\t\tfetchableIndex,\n\t\t\t\tbootProperty,\n\t\t\t\tdeclaringType,\n\t\t\t\tdeclaringEntityPersister,\n\t\t\t\tattrType,\n\t\t\t\tpropertyAccess,\n\t\t\t\tcascadeStyle,\n\t\t\t\tcreationProcess\n\t\t);\n\t}\n\n\t/**\n\t * For Hibernate Reactive\n\t */\n\tprotected AttributeMapping buildPluralAttributeMapping(\n\t\t\tString attrName,\n\t\t\tint stateArrayPosition,\n\t\t\tint fetchableIndex,\n\t\t\tProperty bootProperty,\n\t\t\tManagedMappingType declaringType,\n\t\t\tPropertyAccess propertyAccess,\n\t\t\tCascadeStyle cascadeStyle,\n\t\t\tFetchMode fetchMode,\n\t\t\tMappingModelCreationProcess creationProcess) {\n\t\treturn MappingModelCreationHelper.buildPluralAttributeMapping(\n\t\t\t\tattrName,\n\t\t\t\tstateArrayPosition,\n\t\t\t\tfetchableIndex,\n\t\t\t\tbootProperty,\n\t\t\t\tdeclaringType,\n\t\t\t\tpropertyAccess,\n\t\t\t\tcascadeStyle,\n\t\t\t\tfetchMode,\n\t\t\t\tcreationProcess\n\t\t);\n\t}\n\n\t@Override\n\tpublic JavaType<?> getMappedJavaType() {\n\t\treturn javaType;\n\t}\n\n\t@Override\n\tpublic EntityPersister getEntityPersister() {\n\t\treturn this;\n\t}\n\n\t@Override\n\tpublic EntityIdentifierMapping getIdentifierMapping() {\n\t\treturn identifierMapping;\n\t}\n\n\t@Override\n\tpublic EntityVersionMapping getVersionMapping() {\n\t\treturn versionMapping;\n\t}\n\n\t@Override\n\tpublic EntityRowIdMapping getRowIdMapping() {\n\t\treturn rowIdMapping;\n\t}\n\n\t@Override\n\tpublic EntityDiscriminatorMapping getDiscriminatorMapping() {\n\t\treturn discriminatorMapping;\n\t}\n\n\t@Override\n\tpublic SoftDeleteMapping getSoftDeleteMapping() {\n\t\treturn softDeleteMapping;\n\t}\n\n\t@Override\n\tpublic AttributeMappingsList getAttributeMappings() {\n\t\tif ( attributeMappings == null ) {\n\t\t\tint sizeHint = declaredAttributeMappings.size();\n\t\t\tsizeHint += (superMappingType == null ? 0 : superMappingType.getAttributeMappings().size() );\n\t\t\tImmutableAttributeMappingList.Builder builder = new ImmutableAttributeMappingList.Builder( sizeHint );\n\n\t\t\tif ( superMappingType != null ) {\n\t\t\t\tsuperMappingType.forEachAttributeMapping( builder::add );\n\t\t\t}\n\n\t\t\tfor ( AttributeMapping am : declaredAttributeMappings.valueIterator() ) {\n\t\t\t\tbuilder.add( am );\n\t\t\t}\n\t\t\tthis.attributeMappings = builder.build();\n\t\t\tfinal Getter[] getters = new Getter[attributeMappings.size()];\n\t\t\tfinal Setter[] setters = new Setter[attributeMappings.size()];\n\t\t\tfor ( int i = 0; i < attributeMappings.size(); i++ ) {\n\t\t\t\tfinal PropertyAccess propertyAccess = attributeMappings.get( i ).getAttributeMetadata().getPropertyAccess();\n\t\t\t\tgetters[i] = propertyAccess.getGetter();\n\t\t\t\tsetters[i] = propertyAccess.getSetter();\n\t\t\t}\n\t\t\tthis.getterCache = getters;\n\t\t\tthis.setterCache = setters;\n\t\t\t// subclasses?  it depends on the usage\n\t\t}\n\n\t\treturn attributeMappings;\n\t}\n\n\t@Override\n\tpublic AttributeMapping findDeclaredAttributeMapping(String name) {\n\t\treturn declaredAttributeMappings.get( name );\n\t}\n\n\t@Override\n\tpublic AttributeMapping findAttributeMapping(String name) {\n\t\tfinal AttributeMapping declaredAttribute = declaredAttributeMappings.get( name );\n\t\tif ( declaredAttribute != null ) {\n\t\t\treturn declaredAttribute;\n\t\t}\n\n\t\tif ( superMappingType != null ) {\n\t\t\treturn superMappingType.findAttributeMapping( name );\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic ModelPart findSubPart(String name, EntityMappingType treatTargetType) {\n\t\tLOG.tracef( \"#findSubPart(`%s`)\", name );\n\n\t\tif ( EntityDiscriminatorMapping.matchesRoleName( name ) ) {\n\t\t\treturn discriminatorMapping;\n\t\t}\n\n\t\tfinal AttributeMapping declaredAttribute = declaredAttributeMappings.get( name );\n\t\tif ( declaredAttribute != null ) {\n\t\t\treturn declaredAttribute;\n\t\t}\n\n\t\tif ( superMappingType != null ) {\n\t\t\tfinal ModelPart superDefinedAttribute = superMappingType.findSubPart( name, superMappingType );\n\t\t\tif ( superDefinedAttribute != null ) {\n\t\t\t\t// Prefer the identifier mapping of the concrete class\n\t\t\t\tif ( superDefinedAttribute.isEntityIdentifierMapping() ) {\n\t\t\t\t\tfinal ModelPart identifierModelPart = getIdentifierModelPart( name, treatTargetType );\n\t\t\t\t\tif ( identifierModelPart != null ) {\n\t\t\t\t\t\treturn identifierModelPart;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn superDefinedAttribute;\n\t\t\t}\n\t\t}\n\n\t\tif ( treatTargetType != null ) {\n\t\t\tif ( ! treatTargetType.isTypeOrSuperType( this ) ) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tif ( subclassMappingTypes != null && !subclassMappingTypes.isEmpty() ) {\n\t\t\t\tfor ( EntityMappingType subMappingType : subclassMappingTypes.values() ) {\n\t\t\t\t\tif ( ! treatTargetType.isTypeOrSuperType( subMappingType ) ) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tfinal ModelPart subDefinedAttribute = subMappingType.findSubTypesSubPart( name, treatTargetType );\n\n\t\t\t\t\tif ( subDefinedAttribute != null ) {\n\t\t\t\t\t\treturn subDefinedAttribute;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif ( subclassMappingTypes != null && !subclassMappingTypes.isEmpty() ) {\n\t\t\t\tModelPart attribute = null;\n\t\t\t\tfor ( EntityMappingType subMappingType : subclassMappingTypes.values() ) {\n\t\t\t\t\tfinal ModelPart subDefinedAttribute = subMappingType.findSubTypesSubPart( name, treatTargetType );\n\t\t\t\t\tif ( subDefinedAttribute != null ) {\n\t\t\t\t\t\tif ( attribute != null && !MappingModelHelper.isCompatibleModelPart( attribute, subDefinedAttribute ) ) {\n\t\t\t\t\t\t\tthrow new PathException(\n\t\t\t\t\t\t\t\t\tString.format(\n\t\t\t\t\t\t\t\t\t\t\tLocale.ROOT,\n\t\t\t\t\t\t\t\t\t\t\t\"Could not resolve attribute '%s' of '%s' due to the attribute being declared in multiple subtypes '%s' and '%s'\",\n\t\t\t\t\t\t\t\t\t\t\tname,\n\t\t\t\t\t\t\t\t\t\t\tgetJavaType().getTypeName(),\n\t\t\t\t\t\t\t\t\t\t\tattribute.asAttributeMapping().getDeclaringType()\n\t\t\t\t\t\t\t\t\t\t\t\t\t.getJavaType().getTypeName(),\n\t\t\t\t\t\t\t\t\t\t\tsubDefinedAttribute.asAttributeMapping().getDeclaringType()\n\t\t\t\t\t\t\t\t\t\t\t\t\t.getJavaType().getTypeName()\n\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tattribute = subDefinedAttribute;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif ( attribute != null ) {\n\t\t\t\t\treturn attribute;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfinal ModelPart identifierModelPart = getIdentifierModelPart( name, treatTargetType );\n\t\tif ( identifierModelPart != null ) {\n\t\t\treturn identifierModelPart;\n\t\t}\n\t\telse {\n\t\t\tfor ( AttributeMapping attribute : declaredAttributeMappings.valueIterator() ) {\n\t\t\t\tif ( attribute instanceof EmbeddableValuedModelPart && attribute instanceof VirtualModelPart ) {\n\t\t\t\t\tEmbeddableValuedModelPart part = (EmbeddableValuedModelPart) attribute;\n\t\t\t\t\tfinal ModelPart subPart = part.findSubPart( name, null );\n\t\t\t\t\tif ( subPart != null ) {\n\t\t\t\t\t\treturn subPart;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t@Override\n\tpublic ModelPart findSubTypesSubPart(String name, EntityMappingType treatTargetType) {\n\t\tfinal AttributeMapping declaredAttribute = declaredAttributeMappings.get( name );\n\t\tif ( declaredAttribute != null ) {\n\t\t\treturn declaredAttribute;\n\t\t}\n\t\telse {\n\t\t\tif ( subclassMappingTypes != null && !subclassMappingTypes.isEmpty() ) {\n\t\t\t\tfor ( EntityMappingType subMappingType : subclassMappingTypes.values() ) {\n\t\t\t\t\tfinal ModelPart subDefinedAttribute = subMappingType.findSubTypesSubPart( name, treatTargetType );\n\t\t\t\t\tif ( subDefinedAttribute != null ) {\n\t\t\t\t\t\treturn subDefinedAttribute;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tprivate ModelPart getIdentifierModelPart(String name, EntityMappingType treatTargetType) {\n\t\tfinal EntityIdentifierMapping identifierMapping = getIdentifierMappingForJoin();\n\t\tif ( identifierMapping instanceof NonAggregatedIdentifierMapping ) {\n\t\t\tNonAggregatedIdentifierMapping mapping = (NonAggregatedIdentifierMapping) identifierMapping;\n\t\t\tfinal ModelPart subPart = mapping.findSubPart( name, treatTargetType );\n\t\t\tif ( subPart != null ) {\n\t\t\t\treturn subPart;\n\t\t\t}\n\t\t}\n\n\t\tif ( isIdentifierReference( name ) ) {\n\t\t\treturn identifierMapping;\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tprivate boolean isIdentifierReference(String name) {\n\t\treturn EntityIdentifierMapping.ID_ROLE_NAME.equals( name )\n\t\t\t|| hasIdentifierProperty() && getIdentifierPropertyName().equals( name )\n\t\t\t|| !entityMetamodel.hasNonIdentifierPropertyNamedId() && \"id\".equals( name );\n\t}\n\n\t@Override\n\tpublic void visitSubParts(\n\t\t\tConsumer<ModelPart> consumer,\n\t\t\tEntityMappingType treatTargetType) {\n\t\tconsumer.accept( identifierMapping );\n\t\tdeclaredAttributeMappings.forEachValue( consumer );\n\t}\n\n\t@Override\n\tpublic void visitKeyFetchables(Consumer<? super Fetchable> fetchableConsumer, EntityMappingType treatTargetType) {\n\t\t// No-op\n\t}\n\n\t@Override\n\tpublic void visitKeyFetchables(IndexedConsumer<? super Fetchable> fetchableConsumer, EntityMappingType treatTargetType) {\n\t\t// No-op\n\t}\n\n\t@Override\n\tpublic int getNumberOfFetchables() {\n\t\treturn getStaticFetchableList().size();\n\t}\n\n\t@Override\n\tpublic int getNumberOfFetchableKeys() {\n\t\treturn superMappingType == null ? getNumberOfFetchables() : getRootEntityDescriptor().getNumberOfFetchables();\n\t}\n\n\t@Override\n\tpublic Fetchable getKeyFetchable(int position) {\n\t\tthrow new IndexOutOfBoundsException( position );\n\t}\n\n\t@Override\n\tpublic Fetchable getFetchable(int position) {\n\t\treturn getStaticFetchableList().get( position );\n\t}\n\n\t@Override\n\tpublic void visitFetchables(Consumer<? super Fetchable> fetchableConsumer, EntityMappingType treatTargetType) {\n\t\tif ( treatTargetType == null ) {\n\t\t\tgetStaticFetchableList().forEach( fetchableConsumer );\n//\t\t\tstaticFetchableList.forEach( fetchableConsumer );\n\t\t}\n\t\telse {\n\t\t\tif ( treatTargetType.isTypeOrSuperType( this ) ) {\n\t\t\t\tvisitSubTypeAttributeMappings( fetchableConsumer );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tattributeMappings.forEach( fetchableConsumer );\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic void visitFetchables(IndexedConsumer<? super Fetchable> fetchableConsumer, EntityMappingType treatTargetType) {\n\t\tif ( treatTargetType == null ) {\n\t\t\tgetStaticFetchableList().indexedForEach( fetchableConsumer );\n\t\t}\n\t\telse {\n\t\t\tattributeMappings.indexedForEach( fetchableConsumer );\n\t\t\tif ( treatTargetType.isTypeOrSuperType( this ) ) {\n\t\t\t\tif ( subclassMappingTypes != null ) {\n\t\t\t\t\tint offset = attributeMappings.size();\n\t\t\t\t\tfor ( EntityMappingType subtype : subclassMappingTypes.values() ) {\n\t\t\t\t\t\tfinal AttributeMappingsMap declaredAttributeMappings = subtype.getDeclaredAttributeMappings();\n\t\t\t\t\t\tfor ( AttributeMapping declaredAttributeMapping : declaredAttributeMappings.valueIterator() ) {\n\t\t\t\t\t\t\tfetchableConsumer.accept( offset++, declaredAttributeMapping );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprotected AttributeMappingsList getStaticFetchableList() {\n\t\treturn staticFetchableList;\n\t}\n\n\t@Override\n\tpublic void visitAttributeMappings(Consumer<? super AttributeMapping> action) {\n\t\tattributeMappings.forEach( action );\n\t}\n\n\t@Override\n\tpublic void visitSuperTypeAttributeMappings(Consumer<? super AttributeMapping> action) {\n\t\tif ( superMappingType != null ) {\n\t\t\tsuperMappingType.visitSuperTypeAttributeMappings( action );\n\t\t}\n\t}\n\n\t@Override\n\tpublic int forEachSelectable(int offset, SelectableConsumer selectableConsumer) {\n\t\tint span = 0;\n\t\tfor ( int i = 0; i < attributeMappings.size(); i++ ) {\n\t\t\tfinal AttributeMapping attributeMapping = attributeMappings.get( i );\n\t\t\tspan += attributeMapping.forEachSelectable( span + offset, selectableConsumer );\n\t\t}\n\t\treturn span;\n\t}\n\n\t@Override\n\tpublic void visitSubTypeAttributeMappings(Consumer<? super AttributeMapping> action) {\n\t\tforEachAttributeMapping( action );\n\t\tif ( subclassMappingTypes != null ) {\n\t\t\tfor ( EntityMappingType subType : subclassMappingTypes.values() ) {\n\t\t\t\tsubType.visitDeclaredAttributeMappings( action );\n\t\t\t}\n\t\t}\n\t}\n\n\t// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\t// EntityDefinition impl (walking model - deprecated)\n\n\t@Override\n\tpublic int getJdbcTypeCount() {\n\t\treturn getIdentifierMapping().getJdbcTypeCount();\n\t}\n\n\t@Override\n\tpublic int forEachJdbcType(int offset, IndexedConsumer<JdbcMapping> action) {\n\t\treturn getIdentifierMapping().forEachJdbcType( offset, action );\n\t}\n\n\t@Override\n\tpublic Object disassemble(Object value, SharedSessionContractImplementor session) {\n\t\tif ( value == null ) {\n\t\t\treturn null;\n\t\t}\n\t\tfinal EntityIdentifierMapping identifierMapping = getIdentifierMapping();\n\t\tfinal Object identifier = identifierMapping.getIdentifier( value );\n\t\treturn identifierMapping.disassemble( identifier, session );\n\t}\n\n\t@Override\n\tpublic <X, Y> int forEachDisassembledJdbcValue(\n\t\t\tObject value,\n\t\t\tint offset,\n\t\t\tX x,\n\t\t\tY y,\n\t\t\tJdbcValuesBiConsumer<X, Y> valuesConsumer,\n\t\t\tSharedSessionContractImplementor session) {\n\t\treturn getIdentifierMapping()\n\t\t\t\t.forEachDisassembledJdbcValue( value, offset, x, y, valuesConsumer, session );\n\t}\n\n\t@Override\n\tpublic <X, Y> int forEachJdbcValue(\n\t\t\tObject value,\n\t\t\tint offset,\n\t\t\tX x,\n\t\t\tY y,\n\t\t\tJdbcValuesBiConsumer<X, Y> consumer,\n\t\t\tSharedSessionContractImplementor session) {\n\t\tfinal EntityIdentifierMapping identifierMapping = getIdentifierMapping();\n\t\tfinal Object identifier = value == null ? null\n\t\t\t\t: identifierMapping.disassemble( identifierMapping.getIdentifier( value ), session );\n\t\treturn identifierMapping.forEachDisassembledJdbcValue( identifier, offset, x, y, consumer, session );\n\t}\n\n\t@Override\n\tpublic boolean hasPartitionedSelectionMapping() {\n\t\treturn hasPartitionedSelectionMapping;\n\t}\n\n\tpublic abstract boolean isTableCascadeDeleteEnabled(int j);\n\n\n\t// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\t// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\t// State built and stored here during instantiation, and only used in other\n\t// phases of initialization\n\t//\t\t- postConstruct\n\t//\t\t- postInstantiate\n\t//\t\t- prepareMappingModel\n\t//\t\t- ...\n\t//\n\t// This is effectively bootstrap state that is kept around during runtime.\n\t//\n\t// Would be better to encapsulate and store this state relative to the\n\t// `PersisterCreationContext` so it can get released after bootstrap\n\t// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\t// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n\t@Deprecated protected Expectation[] insertExpectations;\n\t@Deprecated protected Expectation[] updateExpectations;\n\t@Deprecated protected Expectation[] deleteExpectations;\n\n\t@Deprecated protected boolean[] insertCallable;\n\t@Deprecated protected boolean[] updateCallable;\n\t@Deprecated protected boolean[] deleteCallable;\n\n\t@Deprecated protected String[] customSQLInsert;\n\t@Deprecated protected String[] customSQLUpdate;\n\t@Deprecated protected String[] customSQLDelete;\n\n\n\n\t// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\t// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\t// State related to this we handle differently in 6+.  In other words, state\n\t// that is no longer needed\n\t// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\t// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n\t@Deprecated private final EntityMetamodel entityMetamodel;\n\n\t@Deprecated private final String[] subclassColumnAliasClosure;\n\t@Deprecated private final String[] subclassFormulaAliasClosure;\n\t@Deprecated private final Map<String,String[]> subclassPropertyAliases = new HashMap<>();\n\n\t/**\n\t * @deprecated Hibernate no longer uses aliases to read from result sets\n\t */\n\t@Deprecated\tprotected String[] getSubclassColumnAliasClosure() {\n\t\treturn subclassColumnAliasClosure;\n\t}\n\n\t/**\n\t * @deprecated Hibernate no longer uses aliases to read from result sets\n\t */\n\t@Deprecated\tprotected String[] getSubclassFormulaAliasClosure() {\n\t\treturn subclassFormulaAliasClosure;\n\t}\n\n\t/**\n\t * @deprecated Hibernate no longer uses aliases to read from result sets\n\t */\n\t@Deprecated\t@Override\n\tpublic String[] getSubclassPropertyColumnAliases(String propertyName, String suffix) {\n\t\tfinal String[] rawAliases = subclassPropertyAliases.get( propertyName );\n\t\tif ( rawAliases == null ) {\n\t\t\treturn null;\n\t\t}\n\t\telse {\n\t\t\tfinal String[] result = new String[rawAliases.length];\n\t\t\tfor ( int i = 0; i < rawAliases.length; i++ ) {\n\t\t\t\tresult[i] = new Alias( suffix ).toUnquotedAliasString( rawAliases[i] );\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t}\n\n\t/**\n\t * Must be called by subclasses, at the end of their constructors\n\t *\n\t * @deprecated Hibernate no longer uses aliases to read from result sets\n\t */\n\t@Deprecated\tprotected void initSubclassPropertyAliasesMap(PersistentClass model) throws MappingException {\n\n\t\t// ALIASES\n\t\tinternalInitSubclassPropertyAliasesMap( null, model.getSubclassPropertyClosure() );\n\n\t\t// aliases for identifier ( alias.id ); skip if the entity defines a non-id property named 'id'\n\t\tif ( !entityMetamodel.hasNonIdentifierPropertyNamedId() ) {\n\t\t\tsubclassPropertyAliases.put( ENTITY_ID, getIdentifierAliases() );\n\t\t}\n\n\t\t// aliases named identifier ( alias.idname )\n\t\tif ( hasIdentifierProperty() ) {\n\t\t\tsubclassPropertyAliases.put( getIdentifierPropertyName(), getIdentifierAliases() );\n\t\t}\n\n\t\t// aliases for composite-id's\n\t\tif ( getIdentifierType().isComponentType() ) {\n\t\t\t// Fetch embedded identifiers property names from the \"virtual\" identifier component\n\t\t\tfinal CompositeType componentId = (CompositeType) getIdentifierType();\n\t\t\tfinal String[] idPropertyNames = componentId.getPropertyNames();\n\t\t\tfinal String[] idAliases = getIdentifierAliases();\n\n\t\t\tfor ( int i = 0; i < idPropertyNames.length; i++ ) {\n\t\t\t\tif ( entityMetamodel.hasNonIdentifierPropertyNamedId() ) {\n\t\t\t\t\tsubclassPropertyAliases.put(\n\t\t\t\t\t\t\tENTITY_ID + \".\" + idPropertyNames[i],\n\t\t\t\t\t\t\tnew String[] {idAliases[i]}\n\t\t\t\t\t);\n\t\t\t\t}\n//\t\t\t\tif (hasIdentifierProperty() && !ENTITY_ID.equals( getIdentifierPropertyNames() ) ) {\n\t\t\t\tif ( hasIdentifierProperty() ) {\n\t\t\t\t\tsubclassPropertyAliases.put(\n\t\t\t\t\t\t\tgetIdentifierPropertyName() + \".\" + idPropertyNames[i],\n\t\t\t\t\t\t\tnew String[] {idAliases[i]}\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// embedded composite ids ( alias.idName1, alias.idName2 )\n\t\t\t\t\tsubclassPropertyAliases.put( idPropertyNames[i], new String[] {idAliases[i]} );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ( entityMetamodel.isPolymorphic() ) {\n\t\t\tsubclassPropertyAliases.put( ENTITY_CLASS, new String[] {getDiscriminatorAlias()} );\n\t\t}\n\n\t}\n\n\tprivate void internalInitSubclassPropertyAliasesMap(String path, List<Property> properties) {\n\t\tfor (Property property : properties) {\n\t\t\tfinal String name = path == null ? property.getName() : path + \".\" + property.getName();\n\t\t\tif ( property.isComposite() ) {\n\t\t\t\tComponent component = (Component) property.getValue();\n\t\t\t\tinternalInitSubclassPropertyAliasesMap( name, component.getProperties() );\n\t\t\t}\n\n\t\t\tString[] aliases = new String[property.getColumnSpan()];\n\t\t\tint l = 0;\n\t\t\tfor ( Selectable selectable: property.getSelectables() ) {\n\t\t\t\tDialect dialect = getFactory().getJdbcServices().getDialect();\n\t\t\t\taliases[l] = selectable.getAlias( dialect, property.getValue().getTable() );\n\t\t\t\tl++;\n\t\t\t}\n\n\t\t\tsubclassPropertyAliases.put( name, aliases );\n\t\t}\n\n\t}\n\n\tpublic String getDiscriminatorAlias() {\n\t\treturn DISCRIMINATOR_ALIAS;\n\t}\n\n\tprotected String getSqlWhereStringTableExpression(){\n\t\treturn sqlWhereStringTableExpression;\n\t}\n}\n",
        "filePathAfter": "hibernate-core/src/main/java/org/hibernate/persister/entity/AbstractEntityPersister.java",
        "sourceCodeAfterForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.\n */\npackage org.hibernate.persister.entity;\n\nimport java.io.Serializable;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.BitSet;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Set;\nimport java.util.SortedMap;\nimport java.util.TreeMap;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.function.BiConsumer;\nimport java.util.function.Consumer;\nimport java.util.function.Supplier;\n\nimport org.hibernate.AssertionFailure;\nimport org.hibernate.FetchMode;\nimport org.hibernate.Filter;\nimport org.hibernate.HibernateException;\nimport org.hibernate.Internal;\nimport org.hibernate.JDBCException;\nimport org.hibernate.LazyInitializationException;\nimport org.hibernate.LockMode;\nimport org.hibernate.LockOptions;\nimport org.hibernate.MappingException;\nimport org.hibernate.PropertyValueException;\nimport org.hibernate.QueryException;\nimport org.hibernate.StaleObjectStateException;\nimport org.hibernate.StaleStateException;\nimport org.hibernate.annotations.CacheLayout;\nimport org.hibernate.boot.Metadata;\nimport org.hibernate.boot.model.internal.SoftDeleteHelper;\nimport org.hibernate.boot.model.relational.SqlStringGenerationContext;\nimport org.hibernate.boot.spi.MetadataImplementor;\nimport org.hibernate.boot.spi.SessionFactoryOptions;\nimport org.hibernate.bytecode.enhance.spi.LazyPropertyInitializer;\nimport org.hibernate.bytecode.enhance.spi.interceptor.BytecodeLazyAttributeInterceptor;\nimport org.hibernate.bytecode.enhance.spi.interceptor.EnhancementAsProxyLazinessInterceptor;\nimport org.hibernate.bytecode.enhance.spi.interceptor.EnhancementHelper;\nimport org.hibernate.bytecode.enhance.spi.interceptor.LazyAttributeDescriptor;\nimport org.hibernate.bytecode.enhance.spi.interceptor.LazyAttributeLoadingInterceptor;\nimport org.hibernate.bytecode.enhance.spi.interceptor.LazyAttributesMetadata;\nimport org.hibernate.bytecode.spi.BytecodeEnhancementMetadata;\nimport org.hibernate.bytecode.spi.ReflectionOptimizer;\nimport org.hibernate.cache.spi.access.EntityDataAccess;\nimport org.hibernate.cache.spi.access.NaturalIdDataAccess;\nimport org.hibernate.cache.spi.entry.CacheEntry;\nimport org.hibernate.cache.spi.entry.CacheEntryStructure;\nimport org.hibernate.cache.spi.entry.ReferenceCacheEntryImpl;\nimport org.hibernate.cache.spi.entry.StandardCacheEntryImpl;\nimport org.hibernate.cache.spi.entry.StructuredCacheEntry;\nimport org.hibernate.cache.spi.entry.UnstructuredCacheEntry;\nimport org.hibernate.classic.Lifecycle;\nimport org.hibernate.collection.spi.PersistentCollection;\nimport org.hibernate.dialect.Dialect;\nimport org.hibernate.dialect.lock.LockingStrategy;\nimport org.hibernate.engine.FetchTiming;\nimport org.hibernate.engine.OptimisticLockStyle;\nimport org.hibernate.engine.internal.CacheHelper;\nimport org.hibernate.engine.internal.ImmutableEntityEntryFactory;\nimport org.hibernate.engine.internal.MutableEntityEntryFactory;\nimport org.hibernate.engine.internal.StatefulPersistenceContext;\nimport org.hibernate.engine.jdbc.spi.JdbcCoordinator;\nimport org.hibernate.engine.profile.internal.FetchProfileAffectee;\nimport org.hibernate.engine.spi.CachedNaturalIdValueSource;\nimport org.hibernate.engine.spi.CascadeStyle;\nimport org.hibernate.engine.spi.CollectionKey;\nimport org.hibernate.engine.spi.EntityEntry;\nimport org.hibernate.engine.spi.EntityEntryFactory;\nimport org.hibernate.engine.spi.EntityHolder;\nimport org.hibernate.engine.spi.EntityKey;\nimport org.hibernate.engine.spi.LoadQueryInfluencers;\nimport org.hibernate.engine.spi.ManagedEntity;\nimport org.hibernate.engine.spi.NaturalIdResolutions;\nimport org.hibernate.engine.spi.PersistenceContext;\nimport org.hibernate.engine.spi.PersistentAttributeInterceptable;\nimport org.hibernate.engine.spi.PersistentAttributeInterceptor;\nimport org.hibernate.engine.spi.SelfDirtinessTracker;\nimport org.hibernate.engine.spi.SessionFactoryImplementor;\nimport org.hibernate.engine.spi.SessionImplementor;\nimport org.hibernate.engine.spi.SharedSessionContractImplementor;\nimport org.hibernate.event.spi.EventSource;\nimport org.hibernate.event.spi.LoadEvent;\nimport org.hibernate.generator.BeforeExecutionGenerator;\nimport org.hibernate.generator.EventType;\nimport org.hibernate.generator.Generator;\nimport org.hibernate.generator.OnExecutionGenerator;\nimport org.hibernate.generator.internal.VersionGeneration;\nimport org.hibernate.generator.values.GeneratedValues;\nimport org.hibernate.generator.values.internal.GeneratedValuesHelper;\nimport org.hibernate.generator.values.GeneratedValuesMutationDelegate;\nimport org.hibernate.graph.spi.RootGraphImplementor;\nimport org.hibernate.id.BulkInsertionCapableIdentifierGenerator;\nimport org.hibernate.id.IdentifierGenerator;\nimport org.hibernate.id.OptimizableGenerator;\nimport org.hibernate.id.enhanced.Optimizer;\nimport org.hibernate.internal.CoreLogging;\nimport org.hibernate.internal.CoreMessageLogger;\nimport org.hibernate.internal.FilterAliasGenerator;\nimport org.hibernate.internal.FilterHelper;\nimport org.hibernate.internal.util.IndexedConsumer;\nimport org.hibernate.internal.util.LazyValue;\nimport org.hibernate.internal.util.MarkerObject;\nimport org.hibernate.internal.util.StringHelper;\nimport org.hibernate.internal.util.collections.ArrayHelper;\nimport org.hibernate.internal.util.collections.LockModeEnumMap;\nimport org.hibernate.jdbc.Expectation;\nimport org.hibernate.jdbc.TooManyRowsAffectedException;\nimport org.hibernate.loader.ast.internal.CacheEntityLoaderHelper;\nimport org.hibernate.loader.ast.internal.LoaderSelectBuilder;\nimport org.hibernate.loader.ast.internal.LoaderSqlAstCreationState;\nimport org.hibernate.loader.ast.internal.MultiIdEntityLoaderArrayParam;\nimport org.hibernate.loader.ast.internal.MultiIdEntityLoaderStandard;\nimport org.hibernate.loader.ast.internal.SingleIdArrayLoadPlan;\nimport org.hibernate.loader.ast.internal.SingleIdEntityLoaderProvidedQueryImpl;\nimport org.hibernate.loader.ast.internal.SingleIdEntityLoaderStandardImpl;\nimport org.hibernate.loader.ast.internal.SingleUniqueKeyEntityLoaderStandard;\nimport org.hibernate.loader.ast.spi.BatchLoaderFactory;\nimport org.hibernate.loader.ast.spi.MultiIdEntityLoader;\nimport org.hibernate.loader.ast.spi.MultiIdLoadOptions;\nimport org.hibernate.loader.ast.spi.MultiNaturalIdLoader;\nimport org.hibernate.loader.ast.spi.NaturalIdLoader;\nimport org.hibernate.loader.ast.spi.SingleIdEntityLoader;\nimport org.hibernate.loader.ast.spi.SingleUniqueKeyEntityLoader;\nimport org.hibernate.mapping.Any;\nimport org.hibernate.mapping.BasicValue;\nimport org.hibernate.mapping.Column;\nimport org.hibernate.mapping.Component;\nimport org.hibernate.mapping.DependantValue;\nimport org.hibernate.mapping.Formula;\nimport org.hibernate.mapping.Join;\nimport org.hibernate.mapping.PersistentClass;\nimport org.hibernate.mapping.Property;\nimport org.hibernate.mapping.RootClass;\nimport org.hibernate.mapping.Selectable;\nimport org.hibernate.mapping.Subclass;\nimport org.hibernate.mapping.Table;\nimport org.hibernate.mapping.Value;\nimport org.hibernate.metamodel.UnsupportedMappingException;\nimport org.hibernate.metamodel.mapping.Association;\nimport org.hibernate.metamodel.mapping.AttributeMapping;\nimport org.hibernate.metamodel.mapping.AttributeMappingsList;\nimport org.hibernate.metamodel.mapping.AttributeMappingsMap;\nimport org.hibernate.metamodel.mapping.DiscriminatorConverter;\nimport org.hibernate.metamodel.mapping.DiscriminatorType;\nimport org.hibernate.metamodel.mapping.EmbeddableValuedModelPart;\nimport org.hibernate.metamodel.mapping.EntityDiscriminatorMapping;\nimport org.hibernate.metamodel.mapping.EntityIdentifierMapping;\nimport org.hibernate.metamodel.mapping.EntityMappingType;\nimport org.hibernate.metamodel.mapping.EntityRowIdMapping;\nimport org.hibernate.metamodel.mapping.EntityVersionMapping;\nimport org.hibernate.metamodel.mapping.ForeignKeyDescriptor;\nimport org.hibernate.metamodel.mapping.JdbcMapping;\nimport org.hibernate.metamodel.mapping.ManagedMappingType;\nimport org.hibernate.metamodel.mapping.MappedDiscriminatorConverter;\nimport org.hibernate.metamodel.mapping.MappingModelHelper;\nimport org.hibernate.metamodel.mapping.ModelPart;\nimport org.hibernate.metamodel.mapping.NaturalIdMapping;\nimport org.hibernate.metamodel.mapping.NonAggregatedIdentifierMapping;\nimport org.hibernate.metamodel.mapping.PluralAttributeMapping;\nimport org.hibernate.metamodel.mapping.SelectableConsumer;\nimport org.hibernate.metamodel.mapping.SelectableMapping;\nimport org.hibernate.metamodel.mapping.SingularAttributeMapping;\nimport org.hibernate.metamodel.mapping.SoftDeleteMapping;\nimport org.hibernate.metamodel.mapping.VirtualModelPart;\nimport org.hibernate.metamodel.mapping.internal.BasicEntityIdentifierMappingImpl;\nimport org.hibernate.metamodel.mapping.internal.CompoundNaturalIdMapping;\nimport org.hibernate.metamodel.mapping.internal.DiscriminatedAssociationAttributeMapping;\nimport org.hibernate.metamodel.mapping.internal.DiscriminatorTypeImpl;\nimport org.hibernate.metamodel.mapping.internal.EmbeddedAttributeMapping;\nimport org.hibernate.loader.ast.internal.EntityConcreteTypeLoader;\nimport org.hibernate.metamodel.mapping.internal.EntityRowIdMappingImpl;\nimport org.hibernate.metamodel.mapping.internal.EntityVersionMappingImpl;\nimport org.hibernate.metamodel.mapping.internal.ExplicitColumnDiscriminatorMappingImpl;\nimport org.hibernate.metamodel.mapping.internal.GeneratedValuesProcessor;\nimport org.hibernate.metamodel.mapping.internal.ImmutableAttributeMappingList;\nimport org.hibernate.metamodel.mapping.internal.InFlightEntityMappingType;\nimport org.hibernate.metamodel.mapping.internal.MappingModelCreationHelper;\nimport org.hibernate.metamodel.mapping.internal.MappingModelCreationProcess;\nimport org.hibernate.metamodel.mapping.internal.SimpleAttributeMetadata;\nimport org.hibernate.metamodel.mapping.internal.SimpleNaturalIdMapping;\nimport org.hibernate.metamodel.model.domain.NavigableRole;\nimport org.hibernate.metamodel.spi.EntityInstantiator;\nimport org.hibernate.metamodel.spi.EntityRepresentationStrategy;\nimport org.hibernate.metamodel.spi.MappingMetamodelImplementor;\nimport org.hibernate.metamodel.spi.RuntimeModelCreationContext;\nimport org.hibernate.persister.collection.CollectionPersister;\nimport org.hibernate.persister.entity.mutation.DeleteCoordinator;\nimport org.hibernate.persister.entity.mutation.DeleteCoordinatorSoft;\nimport org.hibernate.persister.entity.mutation.DeleteCoordinatorStandard;\nimport org.hibernate.persister.entity.mutation.EntityMutationTarget;\nimport org.hibernate.persister.entity.mutation.EntityTableMapping;\nimport org.hibernate.persister.entity.mutation.InsertCoordinator;\nimport org.hibernate.persister.entity.mutation.InsertCoordinatorStandard;\nimport org.hibernate.persister.entity.mutation.MergeCoordinator;\nimport org.hibernate.persister.entity.mutation.UpdateCoordinator;\nimport org.hibernate.persister.entity.mutation.UpdateCoordinatorNoOp;\nimport org.hibernate.persister.entity.mutation.UpdateCoordinatorStandard;\nimport org.hibernate.persister.internal.SqlFragmentPredicate;\nimport org.hibernate.property.access.spi.Getter;\nimport org.hibernate.property.access.spi.PropertyAccess;\nimport org.hibernate.property.access.spi.Setter;\nimport org.hibernate.query.PathException;\nimport org.hibernate.query.named.NamedQueryMemento;\nimport org.hibernate.query.spi.QueryOptions;\nimport org.hibernate.query.sql.internal.SQLQueryParser;\nimport org.hibernate.query.sqm.ComparisonOperator;\nimport org.hibernate.query.sqm.function.SqmFunctionRegistry;\nimport org.hibernate.query.sqm.mutation.spi.SqmMultiTableInsertStrategy;\nimport org.hibernate.query.sqm.mutation.spi.SqmMultiTableMutationStrategy;\nimport org.hibernate.query.sqm.mutation.spi.SqmMultiTableMutationStrategyProvider;\nimport org.hibernate.service.ServiceRegistry;\nimport org.hibernate.spi.NavigablePath;\nimport org.hibernate.sql.Alias;\nimport org.hibernate.sql.InFragment;\nimport org.hibernate.sql.SimpleSelect;\nimport org.hibernate.sql.Template;\nimport org.hibernate.sql.ast.spi.SimpleFromClauseAccessImpl;\nimport org.hibernate.sql.ast.spi.SqlAliasBase;\nimport org.hibernate.sql.ast.spi.SqlAliasBaseConstant;\nimport org.hibernate.sql.ast.spi.SqlAliasBaseManager;\nimport org.hibernate.sql.ast.spi.SqlAliasStemHelper;\nimport org.hibernate.sql.ast.spi.SqlAstCreationState;\nimport org.hibernate.sql.ast.spi.SqlExpressionResolver;\nimport org.hibernate.sql.ast.spi.SqlSelection;\nimport org.hibernate.sql.ast.tree.expression.AliasedExpression;\nimport org.hibernate.sql.ast.tree.expression.ColumnReference;\nimport org.hibernate.sql.ast.tree.expression.Expression;\nimport org.hibernate.sql.ast.tree.expression.QueryLiteral;\nimport org.hibernate.sql.ast.tree.from.NamedTableReference;\nimport org.hibernate.sql.ast.tree.from.StandardTableGroup;\nimport org.hibernate.sql.ast.tree.from.TableGroup;\nimport org.hibernate.sql.ast.tree.from.TableReference;\nimport org.hibernate.sql.ast.tree.from.TableReferenceJoin;\nimport org.hibernate.sql.ast.tree.predicate.ComparisonPredicate;\nimport org.hibernate.sql.ast.tree.predicate.InListPredicate;\nimport org.hibernate.sql.ast.tree.predicate.Junction;\nimport org.hibernate.sql.ast.tree.predicate.NullnessPredicate;\nimport org.hibernate.sql.ast.tree.predicate.Predicate;\nimport org.hibernate.sql.ast.tree.select.QuerySpec;\nimport org.hibernate.sql.ast.tree.select.SelectClause;\nimport org.hibernate.sql.ast.tree.select.SelectStatement;\nimport org.hibernate.sql.exec.spi.JdbcOperation;\nimport org.hibernate.sql.exec.spi.JdbcParametersList;\nimport org.hibernate.sql.model.MutationOperation;\nimport org.hibernate.sql.model.MutationOperationGroup;\nimport org.hibernate.sql.model.ast.builder.MutationGroupBuilder;\nimport org.hibernate.sql.model.ast.builder.TableInsertBuilder;\nimport org.hibernate.sql.results.graph.DomainResult;\nimport org.hibernate.sql.results.graph.DomainResultCreationState;\nimport org.hibernate.sql.results.graph.Fetch;\nimport org.hibernate.sql.results.graph.FetchParent;\nimport org.hibernate.sql.results.graph.Fetchable;\nimport org.hibernate.sql.results.graph.FetchableContainer;\nimport org.hibernate.sql.results.graph.entity.internal.EntityResultImpl;\nimport org.hibernate.sql.results.graph.internal.ImmutableFetchList;\nimport org.hibernate.sql.results.internal.SqlSelectionImpl;\nimport org.hibernate.stat.spi.StatisticsImplementor;\nimport org.hibernate.tuple.NonIdentifierAttribute;\nimport org.hibernate.tuple.entity.EntityMetamodel;\nimport org.hibernate.type.AnyType;\nimport org.hibernate.type.AssociationType;\nimport org.hibernate.type.BasicType;\nimport org.hibernate.type.CollectionType;\nimport org.hibernate.type.CompositeType;\nimport org.hibernate.type.EntityType;\nimport org.hibernate.type.Type;\nimport org.hibernate.type.descriptor.java.JavaType;\nimport org.hibernate.type.descriptor.java.MutabilityPlan;\nimport org.hibernate.type.descriptor.java.spi.JavaTypeRegistry;\nimport org.hibernate.type.spi.TypeConfiguration;\n\nimport org.checkerframework.checker.nullness.qual.Nullable;\n\nimport static java.util.Collections.emptyList;\nimport static java.util.Collections.emptyMap;\nimport static java.util.Collections.emptySet;\nimport static org.hibernate.engine.internal.ManagedTypeHelper.asPersistentAttributeInterceptable;\nimport static org.hibernate.engine.internal.ManagedTypeHelper.isPersistentAttributeInterceptable;\nimport static org.hibernate.engine.internal.ManagedTypeHelper.processIfManagedEntity;\nimport static org.hibernate.engine.internal.ManagedTypeHelper.processIfPersistentAttributeInterceptable;\nimport static org.hibernate.engine.internal.ManagedTypeHelper.processIfSelfDirtinessTracker;\nimport static org.hibernate.generator.EventType.INSERT;\nimport static org.hibernate.generator.EventType.UPDATE;\nimport static org.hibernate.internal.util.ReflectHelper.isAbstractClass;\nimport static org.hibernate.internal.util.StringHelper.isEmpty;\nimport static org.hibernate.internal.util.StringHelper.qualifyConditionally;\nimport static org.hibernate.internal.util.collections.ArrayHelper.contains;\nimport static org.hibernate.internal.util.collections.ArrayHelper.to2DStringArray;\nimport static org.hibernate.internal.util.collections.ArrayHelper.toIntArray;\nimport static org.hibernate.internal.util.collections.ArrayHelper.toObjectArray;\nimport static org.hibernate.internal.util.collections.ArrayHelper.toStringArray;\nimport static org.hibernate.internal.util.collections.ArrayHelper.toTypeArray;\nimport static org.hibernate.internal.util.collections.CollectionHelper.combine;\nimport static org.hibernate.internal.util.collections.CollectionHelper.isNotEmpty;\nimport static org.hibernate.internal.util.collections.CollectionHelper.setOfSize;\nimport static org.hibernate.internal.util.collections.CollectionHelper.toSmallList;\nimport static org.hibernate.loader.ast.internal.MultiKeyLoadHelper.supportsSqlArrayType;\nimport static org.hibernate.metamodel.RepresentationMode.POJO;\nimport static org.hibernate.persister.entity.DiscriminatorHelper.NOT_NULL_DISCRIMINATOR;\nimport static org.hibernate.persister.entity.DiscriminatorHelper.NULL_DISCRIMINATOR;\nimport static org.hibernate.pretty.MessageHelper.infoString;\nimport static org.hibernate.sql.ast.spi.SqlExpressionResolver.createColumnReferenceKey;\n\n/**\n * Basic functionality for persisting an entity via JDBC, using either generated or custom SQL.\n *\n * @author Gavin King\n */\n@Internal\n@SuppressWarnings(\"deprecation\")\npublic abstract class AbstractEntityPersister\n\t\timplements EntityPersister, InFlightEntityMappingType, EntityMutationTarget, LazyPropertyInitializer, FetchProfileAffectee, Joinable {\n\n\tprivate static final CoreMessageLogger LOG = CoreLogging.messageLogger( AbstractEntityPersister.class );\n\n\tpublic static final String ENTITY_CLASS = \"class\";\n\tpublic static final String VERSION_COLUMN_ALIAS = \"version_\";\n\tpublic static final String ROWID_ALIAS = \"rowid_\";\n\n\tprivate final NavigableRole navigableRole;\n\tprivate final SessionFactoryImplementor factory;\n\tprivate final EntityEntryFactory entityEntryFactory;\n\n\tprivate final String sqlAliasStem;\n\n\tprivate SingleIdEntityLoader<?> singleIdLoader;\n\tprivate MultiIdEntityLoader<?> multiIdLoader;\n\tprivate NaturalIdLoader<?> naturalIdLoader;\n\tprivate MultiNaturalIdLoader<?> multiNaturalIdLoader;\n\n\tprivate final String[] rootTableKeyColumnNames;\n\tprivate final String[] rootTableKeyColumnReaders;\n\tprivate final String[] rootTableKeyColumnReaderTemplates;\n\tprivate final String[] identifierAliases;\n\tprivate final int identifierColumnSpan;\n\tprivate final String versionColumnName;\n\tprivate final boolean hasFormulaProperties;\n\tprotected final int batchSize;\n\tprivate final boolean hasSubselectLoadableCollections;\n\tprivate final boolean hasPartitionedSelectionMapping;\n\tprivate final boolean hasCollectionNotReferencingPK;\n\tprotected final String rowIdName;\n\n\t// The optional SQL string defined in the where attribute\n\tprivate final String sqlWhereStringTableExpression;\n\tprivate final String sqlWhereStringTemplate;\n\n\t//information about properties of this class,\n\t//including inherited properties\n\t//(only really needed for updatable/insertable properties)\n\tprivate final String[][] propertyColumnAliases;\n\tprivate final String[][] propertyColumnNames;\n\tprivate final String[][] propertyColumnFormulaTemplates;\n\tprivate final boolean[][] propertyColumnUpdateable;\n\tprivate final boolean[][] propertyColumnInsertable;\n\tprivate final Set<String> sharedColumnNames;\n\n\t//information about lazy properties of this class\n\tprivate final String[] lazyPropertyNames;\n\tprivate final int[] lazyPropertyNumbers;\n\tprivate final Type[] lazyPropertyTypes;\n\n\t//information about all properties in class hierarchy\n\tprivate final String[] subclassPropertyNameClosure;\n\tprivate final Type[] subclassPropertyTypeClosure;\n\tprivate final String[][] subclassPropertyFormulaTemplateClosure;\n\tprivate final String[][] subclassPropertyColumnNameClosure;\n\tprivate final String[][] subclassPropertyColumnReaderClosure;\n\tprivate final String[][] subclassPropertyColumnReaderTemplateClosure;\n\tprivate final FetchMode[] subclassPropertyFetchModeClosure;\n\n\tprivate Map<String, SingleIdArrayLoadPlan> lazyLoadPlanByFetchGroup;\n\tprivate final LockModeEnumMap<LockingStrategy> lockers = new LockModeEnumMap<>();\n\tprivate String sqlVersionSelectString;\n\n\tprivate EntityTableMapping[] tableMappings;\n\tprivate InsertCoordinator insertCoordinator;\n\tprivate UpdateCoordinator updateCoordinator;\n\tprivate DeleteCoordinator deleteCoordinator;\n\tprivate UpdateCoordinator mergeCoordinator;\n\n\tprivate SqmMultiTableMutationStrategy sqmMultiTableMutationStrategy;\n\tprivate SqmMultiTableInsertStrategy sqmMultiTableInsertStrategy;\n\n\tprivate final EntityDataAccess cacheAccessStrategy;\n\tprivate final NaturalIdDataAccess naturalIdRegionAccessStrategy;\n\tprivate final CacheEntryHelper cacheEntryHelper;\n\tprivate final boolean canReadFromCache;\n\tprivate final boolean canWriteToCache;\n\tprivate final boolean invalidateCache;\n\tprivate final boolean isLazyPropertiesCacheable;\n\tprivate final boolean useReferenceCacheEntries;\n\tprivate final boolean useShallowQueryCacheLayout;\n\tprivate final boolean storeDiscriminatorInShallowQueryCacheLayout;\n\n\t// dynamic filters attached to the class-level\n\tprivate final FilterHelper filterHelper;\n\tprivate volatile Set<String> affectingFetchProfileNames;\n\n\tprotected List<? extends ModelPart> insertGeneratedProperties;\n\tprotected List<? extends ModelPart> updateGeneratedProperties;\n\tprivate GeneratedValuesProcessor insertGeneratedValuesProcessor;\n\tprivate GeneratedValuesProcessor updateGeneratedValuesProcessor;\n\n\tprivate GeneratedValuesMutationDelegate insertDelegate;\n\tprivate GeneratedValuesMutationDelegate updateDelegate;\n\tprivate String identitySelectString;\n\n\tprivate final JavaType<?> javaType;\n\tprivate final EntityRepresentationStrategy representationStrategy;\n\n\tprivate EntityMappingType superMappingType;\n\tprivate SortedMap<String, EntityMappingType> subclassMappingTypes;\n\tprivate final boolean concreteProxy;\n\tprivate EntityConcreteTypeLoader concreteTypeLoader;\n\n\tprivate EntityIdentifierMapping identifierMapping;\n\tprivate NaturalIdMapping naturalIdMapping;\n\tprivate EntityVersionMapping versionMapping;\n\tprivate EntityRowIdMapping rowIdMapping;\n\tprivate EntityDiscriminatorMapping discriminatorMapping;\n\tprivate SoftDeleteMapping softDeleteMapping;\n\n\tprivate AttributeMappingsList attributeMappings;\n\tprotected AttributeMappingsMap declaredAttributeMappings = AttributeMappingsMap.builder().build();\n\tprotected AttributeMappingsList staticFetchableList;\n\t// We build a cache for getters and setters to avoid megamorphic calls\n\tprivate Getter[] getterCache;\n\tprivate Setter[] setterCache;\n\n\tprivate final String queryLoaderName;\n\n\tprivate BeforeExecutionGenerator versionGenerator;\n\n\tprotected ReflectionOptimizer.AccessOptimizer accessOptimizer;\n\n\tprotected final String[] fullDiscriminatorSQLValues;\n\tprivate final Object[] fullDiscriminatorValues;\n\n\t/**\n\t * Warning:\n\t * When there are duplicated property names in the subclasses\n\t * then propertyMapping will only contain one of those properties.\n\t * To ensure correct results, propertyMapping should only be used\n\t * for the concrete EntityPersister (since the concrete EntityPersister\n\t * cannot have duplicated property names).\n\t */\n\tprivate final EntityPropertyMapping propertyMapping;\n\n\tprivate final boolean implementsLifecycle;\n\n\tprivate List<UniqueKeyEntry> uniqueKeyEntries = null; //lazily initialized\n\n\tpublic AbstractEntityPersister(\n\t\t\tfinal PersistentClass persistentClass,\n\t\t\tfinal EntityDataAccess cacheAccessStrategy,\n\t\t\tfinal NaturalIdDataAccess naturalIdRegionAccessStrategy,\n\t\t\tfinal RuntimeModelCreationContext creationContext) throws HibernateException {\n\n\t\t//set it here, but don't call it, since it's still uninitialized!\n\t\tfactory = creationContext.getSessionFactory();\n\n\t\tsqlAliasStem = SqlAliasStemHelper.INSTANCE.generateStemFromEntityName( persistentClass.getEntityName() );\n\n\t\tnavigableRole = new NavigableRole( persistentClass.getEntityName() );\n\n\t\tfinal SessionFactoryOptions sessionFactoryOptions = creationContext.getSessionFactoryOptions();\n\n\t\tif ( sessionFactoryOptions.isSecondLevelCacheEnabled() ) {\n\t\t\tthis.cacheAccessStrategy = cacheAccessStrategy;\n\t\t\tthis.naturalIdRegionAccessStrategy = naturalIdRegionAccessStrategy;\n\t\t\tcanWriteToCache = determineCanWriteToCache( persistentClass, cacheAccessStrategy );\n\t\t\tcanReadFromCache = determineCanReadFromCache( persistentClass, cacheAccessStrategy );\n\t\t\tisLazyPropertiesCacheable = persistentClass.getRootClass().isLazyPropertiesCacheable();\n\t\t}\n\t\telse {\n\t\t\tthis.cacheAccessStrategy = null;\n\t\t\tthis.naturalIdRegionAccessStrategy = null;\n\t\t\tcanWriteToCache = false;\n\t\t\tcanReadFromCache = false;\n\t\t\tisLazyPropertiesCacheable = true;\n\t\t}\n\n\t\tentityMetamodel = new EntityMetamodel( persistentClass, this, creationContext );\n\n\t\tentityEntryFactory = entityMetamodel.isMutable()\n\t\t\t\t? MutableEntityEntryFactory.INSTANCE\n\t\t\t\t: ImmutableEntityEntryFactory.INSTANCE;\n\n\t\t// Handle any filters applied to the class level\n\t\tfilterHelper = isNotEmpty( persistentClass.getFilters() ) ? new FilterHelper(\n\t\t\t\tpersistentClass.getFilters(),\n\t\t\t\tgetEntityNameByTableNameMap(\n\t\t\t\t\t\tpersistentClass,\n\t\t\t\t\t\tfactory.getSqlStringGenerationContext()\n\t\t\t\t),\n\t\t\t\tfactory\n\t\t) : null;\n\n\t\t// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n\t\trepresentationStrategy = creationContext.getBootstrapContext().getRepresentationStrategySelector()\n\t\t\t\t.resolveStrategy( persistentClass, this, creationContext );\n\n\t\tjavaType = representationStrategy.getLoadJavaType();\n\t\tassert javaType != null;\n\t\tthis.implementsLifecycle = Lifecycle.class.isAssignableFrom( javaType.getJavaTypeClass() );\n\n\t\tconcreteProxy = entityMetamodel.isPolymorphic()\n\t\t\t\t&& ( getBytecodeEnhancementMetadata().isEnhancedForLazyLoading() || hasProxy() )\n\t\t\t\t&& persistentClass.isConcreteProxy();\n\n\t\tfinal Dialect dialect = creationContext.getDialect();\n\n\t\tbatchSize = persistentClass.getBatchSize() < 0\n\t\t\t\t? factory.getSessionFactoryOptions().getDefaultBatchFetchSize()\n\t\t\t\t: persistentClass.getBatchSize();\n\t\thasSubselectLoadableCollections = persistentClass.hasSubselectLoadableCollections();\n\t\thasPartitionedSelectionMapping = persistentClass.hasPartitionedSelectionMapping();\n\t\thasCollectionNotReferencingPK = persistentClass.hasCollectionNotReferencingPK();\n\n\t\tpropertyMapping = new EntityPropertyMapping( this );\n\n\t\t// IDENTIFIER\n\n\t\tidentifierColumnSpan = persistentClass.getIdentifier().getColumnSpan();\n\t\trootTableKeyColumnNames = new String[identifierColumnSpan];\n\t\trootTableKeyColumnReaders = new String[identifierColumnSpan];\n\t\trootTableKeyColumnReaderTemplates = new String[identifierColumnSpan];\n\t\tidentifierAliases = new String[identifierColumnSpan];\n\n\t\tfinal String rowId = persistentClass.getRootTable().getRowId();\n\t\trowIdName = rowId == null ? null : dialect.rowId( rowId );\n\n\t\tqueryLoaderName = persistentClass.getLoaderName();\n\n\t\tfinal TypeConfiguration typeConfiguration = creationContext.getTypeConfiguration();\n\t\tfinal SqmFunctionRegistry functionRegistry = creationContext.getFunctionRegistry();\n\n\t\tList<Column> columns = persistentClass.getIdentifier().getColumns();\n\t\tfor (int i = 0; i < columns.size(); i++ ) {\n\t\t\tColumn column = columns.get(i);\n\t\t\trootTableKeyColumnNames[i] = column.getQuotedName( dialect );\n\t\t\trootTableKeyColumnReaders[i] = column.getReadExpr( dialect );\n\t\t\trootTableKeyColumnReaderTemplates[i] = column.getTemplate(\n\t\t\t\t\tdialect,\n\t\t\t\t\ttypeConfiguration,\n\t\t\t\t\tfunctionRegistry\n\t\t\t);\n\t\t\tidentifierAliases[i] = column.getAlias( dialect, persistentClass.getRootTable() );\n\t\t}\n\n\t\t// VERSION\n\n\t\tversionColumnName = persistentClass.isVersioned()\n\t\t\t\t? persistentClass.getVersion().getColumns().get(0).getQuotedName( dialect )\n\t\t\t\t: null;\n\n\t\t//WHERE STRING\n\n\t\tif ( isEmpty( persistentClass.getWhere() ) ) {\n\t\t\tsqlWhereStringTableExpression = null;\n\t\t\tsqlWhereStringTemplate = null;\n\t\t}\n\t\telse {\n\t\t\tPersistentClass containingClass = persistentClass;\n\t\t\twhile ( containingClass.getSuperclass() != null ) {\n\t\t\t\tfinal PersistentClass superclass = containingClass.getSuperclass();\n\t\t\t\tif ( !Objects.equals( persistentClass.getWhere(), superclass.getWhere() ) ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcontainingClass = superclass;\n\t\t\t}\n\t\t\tsqlWhereStringTableExpression = determineTableName( containingClass.getTable() );\n\t\t\tsqlWhereStringTemplate = Template.renderWhereStringTemplate(\n\t\t\t\t\t\"(\" + persistentClass.getWhere() + \")\",\n\t\t\t\t\tdialect,\n\t\t\t\t\ttypeConfiguration,\n\t\t\t\t\tfunctionRegistry\n\t\t\t);\n\t\t}\n\n\t\t// PROPERTIES\n\t\tfinal int hydrateSpan = entityMetamodel.getPropertySpan();\n\t\tpropertyColumnAliases = new String[hydrateSpan][];\n\t\tpropertyColumnNames = new String[hydrateSpan][];\n\t\tpropertyColumnFormulaTemplates = new String[hydrateSpan][];\n\t\tpropertyColumnUpdateable = new boolean[hydrateSpan][];\n\t\tpropertyColumnInsertable = new boolean[hydrateSpan][];\n\t\tsharedColumnNames = new HashSet<>();\n\n\t\tfinal HashSet<Property> thisClassProperties = new HashSet<>();\n\t\tfinal ArrayList<String> lazyNames = new ArrayList<>();\n\t\tfinal ArrayList<Integer> lazyNumbers = new ArrayList<>();\n\t\tfinal ArrayList<Type> lazyTypes = new ArrayList<>();\n\n\t\tfinal List<Property> propertyClosure = persistentClass.getPropertyClosure();\n\t\tboolean foundFormula = false;\n\t\tfor ( int i = 0; i < propertyClosure.size(); i++ ) {\n\t\t\tfinal Property prop = propertyClosure.get(i);\n\t\t\tthisClassProperties.add( prop );\n\n\t\t\tfinal int span = prop.getColumnSpan();\n\t\t\tfinal String[] colNames = new String[span];\n\t\t\tfinal String[] colAliases = new String[span];\n\t\t\tfinal String[] formulaTemplates = new String[span];\n\t\t\tfinal List<Selectable> selectables = prop.getSelectables();\n\t\t\tfor ( int k = 0; k < selectables.size(); k++ ) {\n\t\t\t\tfinal Selectable selectable = selectables.get(k);\n\t\t\t\tcolAliases[k] = selectable.getAlias( dialect, prop.getValue().getTable() );\n\t\t\t\tif ( selectable.isFormula() ) {\n\t\t\t\t\tfoundFormula = true;\n\t\t\t\t\tfinal Formula formula = (Formula) selectable;\n\t\t\t\t\tformula.setFormula( substituteBrackets( formula.getFormula() ) );\n\t\t\t\t\tformulaTemplates[k] = selectable.getTemplate(\n\t\t\t\t\t\t\tdialect,\n\t\t\t\t\t\t\ttypeConfiguration,\n\t\t\t\t\t\t\tfunctionRegistry\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tfinal Column column = (Column) selectable;\n\t\t\t\t\tcolNames[k] = column.getQuotedName( dialect );\n\t\t\t\t}\n\t\t\t}\n\t\t\tpropertyColumnNames[i] = colNames;\n\t\t\tpropertyColumnFormulaTemplates[i] = formulaTemplates;\n\t\t\tpropertyColumnAliases[i] = colAliases;\n\n\t\t\tfinal boolean lazy = !EnhancementHelper.includeInBaseFetchGroup(\n\t\t\t\t\tprop,\n\t\t\t\t\tentityMetamodel.isInstrumented(),\n\t\t\t\t\tentityName -> {\n\t\t\t\t\t\tfinal PersistentClass entityBinding = creationContext\n\t\t\t\t\t\t\t\t.getMetadata()\n\t\t\t\t\t\t\t\t.getEntityBinding( entityName );\n\t\t\t\t\t\tassert entityBinding != null;\n\t\t\t\t\t\treturn entityBinding.hasSubclasses();\n\t\t\t\t\t},\n\t\t\t\t\tsessionFactoryOptions.isCollectionsInDefaultFetchGroupEnabled()\n\t\t\t);\n\n\t\t\tif ( lazy ) {\n\t\t\t\tlazyNames.add( prop.getName() );\n\t\t\t\tlazyNumbers.add( i );\n\t\t\t\tlazyTypes.add( prop.getValue().getType() );\n\t\t\t}\n\n\t\t\tpropertyColumnUpdateable[i] = prop.getValue().getColumnUpdateability();\n\t\t\tpropertyColumnInsertable[i] = prop.getValue().getColumnInsertability();\n\t\t}\n\t\thasFormulaProperties = foundFormula;\n\t\tlazyPropertyNames = toStringArray( lazyNames );\n\t\tlazyPropertyNumbers = toIntArray( lazyNumbers );\n\t\tlazyPropertyTypes = toTypeArray( lazyTypes );\n\n\t\t// SUBCLASS PROPERTY CLOSURE\n\t\tfinal ArrayList<String> aliases = new ArrayList<>();\n\t\tfinal ArrayList<String> formulaAliases = new ArrayList<>();\n\t\tfinal ArrayList<Type> types = new ArrayList<>();\n\t\tfinal ArrayList<String> names = new ArrayList<>();\n\t\tfinal ArrayList<String[]> templates = new ArrayList<>();\n\t\tfinal ArrayList<String[]> propColumns = new ArrayList<>();\n\t\tfinal ArrayList<String[]> propColumnReaders = new ArrayList<>();\n\t\tfinal ArrayList<String[]> propColumnReaderTemplates = new ArrayList<>();\n\t\tfinal ArrayList<FetchMode> joinedFetchesList = new ArrayList<>();\n\n\t\tfor ( Property prop : persistentClass.getSubclassPropertyClosure() ) {\n\t\t\tnames.add( prop.getName() );\n\t\t\ttypes.add( prop.getType() );\n\n\t\t\tfinal String[] cols = new String[ prop.getColumnSpan() ];\n\t\t\tfinal String[] readers = new String[ prop.getColumnSpan() ];\n\t\t\tfinal String[] readerTemplates = new String[ prop.getColumnSpan() ];\n\t\t\tfinal String[] forms = new String[ prop.getColumnSpan() ];\n\n\t\t\tfinal List<Selectable> selectables = prop.getSelectables();\n\t\t\tfor ( int i = 0; i < selectables.size(); i++ ) {\n\t\t\t\tfinal Selectable selectable = selectables.get(i);\n\t\t\t\tif ( selectable.isFormula() ) {\n\t\t\t\t\tfinal String template = selectable.getTemplate(\n\t\t\t\t\t\t\tdialect,\n\t\t\t\t\t\t\ttypeConfiguration,\n\t\t\t\t\t\t\tfunctionRegistry\n\t\t\t\t\t);\n\t\t\t\t\tforms[i] = template;\n\t\t\t\t\tfinal String formulaAlias = selectable.getAlias( dialect );\n\t\t\t\t\tif ( prop.isSelectable() && !formulaAliases.contains( formulaAlias ) ) {\n\t\t\t\t\t\tformulaAliases.add( formulaAlias );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tfinal Column column = (Column) selectable;\n\t\t\t\t\tfinal String colName = column.getQuotedName(dialect);\n\t\t\t\t\tcols[i] = colName;\n\t\t\t\t\tfinal String columnAlias = selectable.getAlias( dialect, prop.getValue().getTable() );\n\t\t\t\t\tif ( prop.isSelectable() && !aliases.contains( columnAlias ) ) {\n\t\t\t\t\t\taliases.add( columnAlias );\n\t\t\t\t\t}\n\n\t\t\t\t\treaders[i] = column.getReadExpr( dialect );\n\t\t\t\t\treaderTemplates[i] = column.getTemplate(\n\t\t\t\t\t\t\tdialect,\n\t\t\t\t\t\t\ttypeConfiguration,\n\t\t\t\t\t\t\tfunctionRegistry\n\t\t\t\t\t);\n\t\t\t\t\tif ( thisClassProperties.contains( prop )\n\t\t\t\t\t\t\t? persistentClass.hasSubclasses()\n\t\t\t\t\t\t\t: persistentClass.isDefinedOnMultipleSubclasses( column ) ) {\n\t\t\t\t\t\tsharedColumnNames.add( colName );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tpropColumns.add( cols );\n\t\t\tpropColumnReaders.add( readers );\n\t\t\tpropColumnReaderTemplates.add( readerTemplates );\n\t\t\ttemplates.add( forms );\n\n\t\t\tjoinedFetchesList.add( prop.getValue().getFetchMode() );\n\t\t}\n\t\tsubclassColumnAliasClosure = toStringArray( aliases );\n\t\tsubclassFormulaAliasClosure = toStringArray( formulaAliases );\n\n\t\tsubclassPropertyNameClosure = toStringArray( names );\n\t\tsubclassPropertyTypeClosure = toTypeArray( types );\n\t\tsubclassPropertyFormulaTemplateClosure = to2DStringArray( templates );\n\t\tsubclassPropertyColumnNameClosure = to2DStringArray( propColumns );\n\t\tsubclassPropertyColumnReaderClosure = to2DStringArray( propColumnReaders );\n\t\tsubclassPropertyColumnReaderTemplateClosure = to2DStringArray( propColumnReaderTemplates );\n\n\t\tsubclassPropertyFetchModeClosure = new FetchMode[joinedFetchesList.size()];\n\t\tint j = 0;\n\t\tfor (FetchMode fetchMode : joinedFetchesList) {\n\t\t\tsubclassPropertyFetchModeClosure[j++] = fetchMode;\n\t\t}\n\n\t\tuseReferenceCacheEntries = shouldUseReferenceCacheEntries( creationContext.getSessionFactoryOptions() );\n\t\tuseShallowQueryCacheLayout = shouldUseShallowCacheLayout(\n\t\t\t\tpersistentClass.getQueryCacheLayout(),\n\t\t\t\tcreationContext.getSessionFactoryOptions()\n\t\t);\n\t\tstoreDiscriminatorInShallowQueryCacheLayout = shouldStoreDiscriminatorInShallowQueryCacheLayout(\n\t\t\t\tpersistentClass.getQueryCacheLayout(),\n\t\t\t\tcreationContext.getSessionFactoryOptions()\n\t\t);\n\t\tcacheEntryHelper = buildCacheEntryHelper( creationContext.getSessionFactoryOptions() );\n\t\tinvalidateCache = sessionFactoryOptions.isSecondLevelCacheEnabled()\n\t\t\t\t&& canWriteToCache\n\t\t\t\t&& shouldInvalidateCache( persistentClass, creationContext );\n\n\t\tfinal List<Object> values = new ArrayList<>();\n\t\tfinal List<String> sqlValues = new ArrayList<>();\n\n\t\tif ( persistentClass.isPolymorphic() && persistentClass.getDiscriminator() != null ) {\n\t\t\tif ( !getEntityMetamodel().isAbstract() ) {\n\t\t\t\tvalues.add( DiscriminatorHelper.getDiscriminatorValue( persistentClass ) );\n\t\t\t\tsqlValues.add( DiscriminatorHelper.getDiscriminatorSQLValue( persistentClass, dialect ) );\n\t\t\t}\n\n\t\t\tfinal List<Subclass> subclasses = persistentClass.getSubclasses();\n\t\t\tfor ( int k = 0; k < subclasses.size(); k++ ) {\n\t\t\t\tfinal Subclass subclass = subclasses.get( k );\n\t\t\t\t//copy/paste from EntityMetamodel:\n\t\t\t\tif ( !isAbstract( subclass ) ) {\n\t\t\t\t\tvalues.add( DiscriminatorHelper.getDiscriminatorValue( subclass ) );\n\t\t\t\t\tsqlValues.add( DiscriminatorHelper.getDiscriminatorSQLValue( subclass, dialect ) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfullDiscriminatorSQLValues = toStringArray( sqlValues );\n\t\tfullDiscriminatorValues = toObjectArray( values );\n\n\t\tif ( hasNamedQueryLoader() ) {\n\t\t\tgetNamedQueryMemento( creationContext.getBootModel() );\n\t\t}\n\t}\n\n\tprivate NamedQueryMemento<?> getNamedQueryMemento(MetadataImplementor bootModel) {\n\t\tfinal NamedQueryMemento<?> memento =\n\t\t\t\tfactory.getQueryEngine().getNamedObjectRepository()\n\t\t\t\t\t\t.resolve( factory, bootModel, queryLoaderName );\n\t\tif ( memento == null ) {\n\t\t\tthrow new IllegalArgumentException( \"Could not resolve named query '\" + queryLoaderName\n\t\t\t\t\t+ \"' for loading entity '\" + getEntityName() + \"'\" );\n\t\t}\n\t\treturn memento;\n\t}\n\n\t/**\n\t * For Hibernate Reactive\n\t */\n\tprotected SingleIdEntityLoader<?> buildSingleIdEntityLoader() {\n\t\tif ( hasNamedQueryLoader() ) {\n\t\t\t// We must resolve the named query on-demand through the boot model because it isn't initialized yet\n\t\t\tfinal NamedQueryMemento<?> memento = getNamedQueryMemento( null );\n\t\t\treturn new SingleIdEntityLoaderProvidedQueryImpl<>( this, memento );\n\t\t}\n\t\treturn buildSingleIdEntityLoader( new LoadQueryInfluencers( factory ) );\n\t}\n\n\tprivate SingleIdEntityLoader<?> buildSingleIdEntityLoader(LoadQueryInfluencers loadQueryInfluencers) {\n\t\tif ( loadQueryInfluencers.effectivelyBatchLoadable( this ) ) {\n\t\t\tfinal int batchSize = loadQueryInfluencers.effectiveBatchSize( this );\n\t\t\treturn factory.getServiceRegistry()\n\t\t\t\t\t.requireService( BatchLoaderFactory.class )\n\t\t\t\t\t.createEntityBatchLoader( batchSize, this, loadQueryInfluencers );\n\t\t}\n\t\telse {\n\t\t\treturn new SingleIdEntityLoaderStandardImpl<>( this, loadQueryInfluencers );\n\t\t}\n\t}\n\n\tpublic static Map<String, String> getEntityNameByTableNameMap(\n\t\t\tPersistentClass persistentClass,\n\t\t\tSqlStringGenerationContext stringGenerationContext) {\n\t\tfinal Map<String, String> entityNameByTableNameMap = new HashMap<>();\n\t\tPersistentClass superType = persistentClass.getSuperPersistentClass();\n\t\twhile ( superType != null ) {\n\t\t\tentityNameByTableNameMap.put( superType.getTable().getQualifiedName( stringGenerationContext ), superType.getEntityName() );\n\t\t\tfor ( Join join : superType.getJoins() ) {\n\t\t\t\tentityNameByTableNameMap.put( join.getTable().getQualifiedName( stringGenerationContext ), superType.getEntityName() );\n\t\t\t}\n\t\t\tsuperType = superType.getSuperPersistentClass();\n\t\t}\n\t\tfor ( PersistentClass subclass : persistentClass.getSubclassClosure() ) {\n\t\t\tentityNameByTableNameMap.put( subclass.getTable().getQualifiedName( stringGenerationContext ), subclass.getEntityName() );\n\t\t\tfor ( Join join : subclass.getJoins() ) {\n\t\t\t\tentityNameByTableNameMap.put( join.getTable().getQualifiedName( stringGenerationContext ), subclass.getEntityName() );\n\t\t\t}\n\t\t}\n\t\treturn entityNameByTableNameMap;\n\t}\n\n\tprotected MultiIdEntityLoader<Object> buildMultiIdLoader() {\n\t\tif ( getIdentifierType() instanceof BasicType\n\t\t\t\t&& supportsSqlArrayType( factory.getJdbcServices().getDialect() ) ) {\n\t\t\treturn new MultiIdEntityLoaderArrayParam<>( this, factory );\n\t\t}\n\t\telse {\n\t\t\treturn new MultiIdEntityLoaderStandard<>( this, identifierColumnSpan, factory );\n\t\t}\n\t}\n\n\tprivate String getIdentitySelectString(Dialect dialect) {\n\t\ttry {\n\t\t\treturn dialect.getIdentityColumnSupport()\n\t\t\t\t\t.getIdentitySelectString(\n\t\t\t\t\t\t\tgetTableName(0),\n\t\t\t\t\t\t\tgetKeyColumns(0)[0],\n\t\t\t\t\t\t\t( (BasicType<?>) getIdentifierType() ).getJdbcType().getDdlTypeCode()\n\t\t\t\t\t);\n\t\t}\n\t\tcatch (MappingException ex) {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tstatic boolean isAbstract(PersistentClass subclass) {\n\t\tfinal Boolean knownAbstract = subclass.isAbstract();\n\t\treturn knownAbstract == null\n\t\t\t\t? subclass.hasPojoRepresentation() && isAbstractClass( subclass.getMappedClass() )\n\t\t\t\t: knownAbstract;\n\t}\n\n\tprivate boolean shouldUseReferenceCacheEntries(SessionFactoryOptions options) {\n\t\t// Check if we can use Reference Cached entities in 2lc\n\t\t// todo : should really validate that the cache access type is read-only\n\t\tif ( !options.isDirectReferenceCacheEntriesEnabled() ) {\n\t\t\treturn false;\n\t\t}\n\t\t// for now, limit this to just entities that:\n\t\telse if ( entityMetamodel.isMutable() ) {\n\t\t\t// 1) are immutable\n\t\t\treturn false;\n\t\t}\n\t\telse {\n\t\t\t// 2) have no associations.\n\t\t\t// Eventually we want to be a little more lenient with associations.\n\t\t\tfor ( Type type : getSubclassPropertyTypeClosure() ) {\n\t\t\t\tif ( type.isAssociationType() ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tprivate static CacheLayout queryCacheLayout(CacheLayout entityQueryCacheLayout, SessionFactoryOptions options) {\n\t\treturn entityQueryCacheLayout == null ? options.getQueryCacheLayout() : entityQueryCacheLayout;\n\t}\n\n\tprivate boolean shouldUseShallowCacheLayout(CacheLayout entityQueryCacheLayout, SessionFactoryOptions options) {\n\t\tswitch ( queryCacheLayout( entityQueryCacheLayout, options ) ) {\n\t\t\tcase FULL:\n\t\t\t\treturn false;\n\t\t\tcase AUTO:\n\t\t\t\treturn canUseReferenceCacheEntries()\n\t\t\t\t\t|| canReadFromCache();\n\t\t\tdefault:\n\t\t\t\treturn true;\n\t\t}\n\t}\n\n\tprivate static boolean shouldStoreDiscriminatorInShallowQueryCacheLayout(\n\t\t\tCacheLayout entityQueryCacheLayout, SessionFactoryOptions options) {\n\t\treturn queryCacheLayout( entityQueryCacheLayout, options ) == CacheLayout.SHALLOW_WITH_DISCRIMINATOR;\n\t}\n\n\tprotected abstract String[] getSubclassTableNames();\n\n\tprotected abstract String[] getSubclassTableKeyColumns(int j);\n\n\tprotected abstract boolean isClassOrSuperclassTable(int j);\n\n\tprotected boolean isClassOrSuperclassJoin(int j) {\n\t\t// TODO:\n\t\t// SingleTableEntityPersister incorrectly used isClassOrSuperclassJoin == isClassOrSuperclassTable,\n\t\t// this caused HHH-12895, as this resulted in the subclass tables always being joined, even if no\n\t\t// property on these tables was accessed.\n\t\t//\n\t\t// JoinedTableEntityPersister does not use isClassOrSuperclassJoin at all, probably incorrectly so.\n\t\t// I however haven't been able to reproduce any quirks regarding <join>s, secondary tables or\n\t\t// @JoinTable's.\n\t\t//\n\t\t// Probably this method needs to be properly implemented for the various entity persisters,\n\t\t// but this at least fixes the SingleTableEntityPersister, while maintaining the previous\n\t\t// behaviour for other persisters.\n\t\treturn isClassOrSuperclassTable( j );\n\t}\n\n\tpublic abstract boolean isPropertyOfTable(int property, int j);\n\n\tprotected abstract int[] getPropertyTableNumbers();\n\n\tprivate static final String DISCRIMINATOR_ALIAS = \"clazz_\";\n\n\t@Override\n\tpublic String getDiscriminatorColumnName() {\n\t\treturn DISCRIMINATOR_ALIAS;\n\t}\n\n\tpublic String getDiscriminatorColumnReaders() {\n\t\treturn DISCRIMINATOR_ALIAS;\n\t}\n\n\tpublic String getDiscriminatorColumnReaderTemplate() {\n\t\treturn getSubclassEntityNames().size() == 1\n\t\t\t\t? getDiscriminatorSQLValue()\n\t\t\t\t: Template.TEMPLATE + \".\" + DISCRIMINATOR_ALIAS;\n\t}\n\n\tpublic String getDiscriminatorFormulaTemplate() {\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic boolean isInverseTable(int j) {\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic boolean isNullableTable(int j) {\n\t\treturn false;\n\t}\n\n\tprotected boolean isNullableSubclassTable(int j) {\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic boolean isSubclassEntityName(String entityName) {\n\t\treturn entityMetamodel.getSubclassEntityNames().contains( entityName );\n\t}\n\n\t@Override\n\tpublic boolean isSharedColumn(String columnExpression) {\n\t\treturn sharedColumnNames.contains( columnExpression );\n\t}\n\n\t@Override\n\tpublic String[] getRootTableKeyColumnNames() {\n\t\treturn rootTableKeyColumnNames;\n\t}\n\n\tSingleIdArrayLoadPlan getSQLLazySelectLoadPlan(String fetchGroup) {\n\t\treturn lazyLoadPlanByFetchGroup.get( fetchGroup );\n\t}\n\n\t@Override\n\tpublic InsertCoordinator getInsertCoordinator() {\n\t\treturn insertCoordinator;\n\t}\n\n\t@Override\n\tpublic UpdateCoordinator getUpdateCoordinator() {\n\t\treturn updateCoordinator;\n\t}\n\n\t@Override\n\tpublic DeleteCoordinator getDeleteCoordinator() {\n\t\treturn deleteCoordinator;\n\t}\n\n\t@Override\n\tpublic UpdateCoordinator getMergeCoordinator() {\n\t\treturn mergeCoordinator;\n\t}\n\n\tpublic String getVersionSelectString() {\n\t\treturn sqlVersionSelectString;\n\t}\n\n\t@Internal // called by Hibernate Reactive\n\t@SuppressWarnings(\"unused\")\n\tpublic GeneratedValuesProcessor getInsertGeneratedValuesProcessor() {\n\t\treturn insertGeneratedValuesProcessor;\n\t}\n\n\t@Internal // called by Hibernate Reactive\n\t@SuppressWarnings(\"unused\")\n\tpublic GeneratedValuesProcessor getUpdateGeneratedValuesProcessor() {\n\t\treturn updateGeneratedValuesProcessor;\n\t}\n\n\t@Override\n\tpublic boolean hasRowId() {\n\t\treturn rowIdName != null;\n\t}\n\n\t@Override\n\tpublic String[] getTableNames() {\n\t\tfinal String[] tableNames = new String[getTableSpan()];\n\t\tfor ( int i = 0; i < tableNames.length; i++ ) {\n\t\t\ttableNames[i] = getTableName( i );\n\t\t}\n\t\treturn tableNames;\n\t}\n\n\t/**\n\t * We might need to use cache invalidation if we have formulas,\n\t * dynamic update, or secondary tables.\n\t *\n\t * @see #isCacheInvalidationRequired()\n\t */\n\tprivate boolean shouldInvalidateCache(\n\t\t\tPersistentClass persistentClass,\n\t\t\tRuntimeModelCreationContext creationContext) {\n\t\tif ( hasFormulaProperties() ) {\n\t\t\t// we need to evaluate formulas in the database\n\t\t\treturn true;\n\t\t}\n\t\telse if ( isVersioned() ) {\n\t\t\t// we don't need to be \"careful\" in the case of\n\t\t\t// versioned entities\n\t\t\treturn false;\n\t\t}\n\t\telse if ( entityMetamodel.isDynamicUpdate() ) {\n\t\t\t// if the unversioned entity has dynamic updates\n\t\t\t// there is a risk of concurrent updates\n\t\t\treturn true;\n\t\t}\n\t\telse if ( isCacheComplianceEnabled( creationContext ) ) {\n\t\t\t// The JPA TCK (inadvertently, but still...)\n\t\t\t// requires that we cache entities with secondary\n\t\t\t// tables instead of being more careful and just\n\t\t\t// invalidating them\n\t\t\treturn false;\n\t\t}\n\t\telse {\n\t\t\t// if the unversioned entity has second tables\n\t\t\t// there is a risk of concurrent updates\n\t\t\t// todo : this should really consider optionality of the secondary tables\n\t\t\t//        in count so non-optional tables do not cause this bypass\n\t\t\treturn persistentClass.getJoinClosureSpan() >= 1;\n\t\t}\n\t}\n\n\tprivate boolean isCacheComplianceEnabled(RuntimeModelCreationContext creationContext) {\n\t\treturn creationContext.getSessionFactoryOptions()\n\t\t\t\t.getJpaCompliance()\n\t\t\t\t.isJpaCacheComplianceEnabled();\n\t}\n\n\tprivate boolean determineCanWriteToCache(PersistentClass persistentClass, EntityDataAccess cacheAccessStrategy) {\n\t\treturn cacheAccessStrategy != null && persistentClass.isCached();\n\t}\n\n\tprivate boolean determineCanReadFromCache(PersistentClass persistentClass, EntityDataAccess cacheAccessStrategy) {\n\t\tif ( cacheAccessStrategy == null ) {\n\t\t\treturn false;\n\t\t}\n\t\telse if ( persistentClass.isCached() ) {\n\t\t\treturn true;\n\t\t}\n\t\telse {\n\t\t\tfor ( Subclass subclass : persistentClass.getSubclasses() ) {\n\t\t\t\tif ( subclass.isCached() ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tprotected CacheEntryHelper buildCacheEntryHelper(SessionFactoryOptions options) {\n\t\tif ( cacheAccessStrategy == null ) {\n\t\t\t// the entity defined no caching...\n\t\t\treturn NoopCacheEntryHelper.INSTANCE;\n\t\t}\n\t\telse if ( canUseReferenceCacheEntries() ) {\n\t\t\tentityMetamodel.setLazy( false );\n\t\t\t// todo : do we also need to unset proxy factory?\n\t\t\treturn new ReferenceCacheEntryHelper( this );\n\t\t}\n\t\telse {\n\t\t\treturn options.isStructuredCacheEntriesEnabled()\n\t\t\t\t\t? new StructuredCacheEntryHelper( this )\n\t\t\t\t\t: new StandardCacheEntryHelper( this );\n\t\t}\n\t}\n\n\t@Override\n\tpublic boolean canUseReferenceCacheEntries() {\n\t\treturn useReferenceCacheEntries;\n\t}\n\n\t@Override\n\tpublic boolean useShallowQueryCacheLayout() {\n\t\treturn useShallowQueryCacheLayout;\n\t}\n\n\t@Override\n\tpublic boolean storeDiscriminatorInShallowQueryCacheLayout() {\n\t\treturn storeDiscriminatorInShallowQueryCacheLayout;\n\t}\n\n\t@Override\n\tpublic boolean hasFilterForLoadByKey() {\n\t\tif ( filterHelper != null ) {\n\t\t\tfor ( String filterName : filterHelper.getFilterNames() ) {\n\t\t\t\tif ( factory.getFilterDefinition( filterName ).isAppliedToLoadByKey() ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic Iterable<UniqueKeyEntry> uniqueKeyEntries() {\n\t\tif ( uniqueKeyEntries == null ) {\n\t\t\tuniqueKeyEntries = initUniqueKeyEntries( this );\n\t\t}\n\t\treturn uniqueKeyEntries;\n\t}\n\n\tprivate static List<UniqueKeyEntry> initUniqueKeyEntries(final AbstractEntityPersister aep) {\n\t\tfinal ArrayList<UniqueKeyEntry> uniqueKeys = new ArrayList<>();\n\t\tfor ( Type propertyType : aep.getPropertyTypes() ) {\n\t\t\tif ( propertyType instanceof AssociationType ) {\n\t\t\t\tfinal AssociationType associationType = (AssociationType) propertyType;\n\t\t\t\tfinal String ukName = associationType.getLHSPropertyName();\n\t\t\t\tif ( ukName != null ) {\n\t\t\t\t\tfinal AttributeMapping attributeMapping = aep.findAttributeMapping( ukName );\n\t\t\t\t\tif ( attributeMapping != null ) {\n\t\t\t\t\t\tfinal int index = attributeMapping.getStateArrayPosition();\n\t\t\t\t\t\tfinal Type type = aep.getPropertyTypes()[index];\n\t\t\t\t\t\tuniqueKeys.add( new UniqueKeyEntry( ukName, index, type ) );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn toSmallList( uniqueKeys );\n\t}\n\n\tprotected Map<String, SingleIdArrayLoadPlan> getLazyLoadPlanByFetchGroup() {\n\t\tfinal BytecodeEnhancementMetadata metadata = entityMetamodel.getBytecodeEnhancementMetadata();\n\t\treturn metadata.isEnhancedForLazyLoading() && metadata.getLazyAttributesMetadata().hasLazyAttributes()\n\t\t\t\t? createLazyLoadPlanByFetchGroup( metadata )\n\t\t\t\t: emptyMap();\n\t}\n\n\tprivate Map<String, SingleIdArrayLoadPlan> createLazyLoadPlanByFetchGroup(BytecodeEnhancementMetadata metadata) {\n\t\tfinal Map<String, SingleIdArrayLoadPlan> result = new HashMap<>();\n\t\tfinal LazyAttributesMetadata attributesMetadata = metadata.getLazyAttributesMetadata();\n\t\tfor ( String groupName : attributesMetadata.getFetchGroupNames() ) {\n\t\t\tfinal SingleIdArrayLoadPlan loadPlan =\n\t\t\t\t\tcreateLazyLoadPlan( attributesMetadata.getFetchGroupAttributeDescriptors( groupName ) );\n\t\t\tif ( loadPlan != null ) {\n\t\t\t\tresult.put( groupName, loadPlan );\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\tprivate SingleIdArrayLoadPlan createLazyLoadPlan(List<LazyAttributeDescriptor> fetchGroupAttributeDescriptors) {\n\t\tfinal List<ModelPart> partsToSelect = new ArrayList<>( fetchGroupAttributeDescriptors.size() );\n\t\tfor ( LazyAttributeDescriptor lazyAttributeDescriptor : fetchGroupAttributeDescriptors ) {\n\t\t\t// all this only really needs to consider properties\n\t\t\t// of this class, not its subclasses, but since we\n\t\t\t// are reusing code used for sequential selects, we\n\t\t\t// use the subclass closure\n\t\t\tpartsToSelect.add( getAttributeMapping( getSubclassPropertyIndex( lazyAttributeDescriptor.getName() ) ) );\n\t\t}\n\n\t\tif ( partsToSelect.isEmpty() ) {\n\t\t\t// only one-to-one is lazily fetched\n\t\t\treturn null;\n\t\t}\n\t\telse {\n\t\t\tfinal JdbcParametersList.Builder jdbcParametersBuilder = JdbcParametersList.newBuilder();\n\t\t\tfinal SelectStatement select = LoaderSelectBuilder.createSelect(\n\t\t\t\t\tthis,\n\t\t\t\t\tpartsToSelect,\n\t\t\t\t\tgetIdentifierMapping(),\n\t\t\t\t\tnull,\n\t\t\t\t\t1,\n\t\t\t\t\tnew LoadQueryInfluencers( factory ),\n\t\t\t\t\tLockOptions.NONE,\n\t\t\t\t\tjdbcParametersBuilder::add,\n\t\t\t\t\tfactory\n\t\t\t);\n\t\t\treturn new SingleIdArrayLoadPlan(\n\t\t\t\t\tthis,\n\t\t\t\t\tgetIdentifierMapping(),\n\t\t\t\t\tselect,\n\t\t\t\t\tjdbcParametersBuilder.build(),\n\t\t\t\t\tLockOptions.NONE,\n\t\t\t\t\tfactory\n\t\t\t);\n\t\t}\n\t}\n\n\t@Override\n\tpublic String getSqlAliasStem() {\n\t\treturn sqlAliasStem;\n\t}\n\n\t@Override\n\tpublic boolean containsTableReference(String tableExpression) {\n\t\treturn contains( getSubclassTableNames(), tableExpression );\n\t}\n\n\t@Override\n\tpublic String getPartName() {\n\t\treturn getEntityName();\n\t}\n\n\t@Override\n\tpublic <T> DomainResult<T> createDomainResult(\n\t\t\tNavigablePath navigablePath,\n\t\t\tTableGroup tableGroup,\n\t\t\tString resultVariable,\n\t\t\tDomainResultCreationState creationState) {\n\t\tfinal EntityResultImpl entityResult = new EntityResultImpl(\n\t\t\t\tnavigablePath,\n\t\t\t\tthis,\n\t\t\t\ttableGroup,\n\t\t\t\tresultVariable\n\t\t);\n\t\tentityResult.afterInitialize( entityResult, creationState );\n\t\t//noinspection unchecked\n\t\treturn entityResult;\n\t}\n\n\t@Override\n\tpublic void applySqlSelections(\n\t\t\tNavigablePath navigablePath,\n\t\t\tTableGroup tableGroup,\n\t\t\tDomainResultCreationState creationState) {\n\t\tidentifierMapping.applySqlSelections(\n\t\t\t\tnavigablePath.append( identifierMapping.getPartName() ),\n\t\t\t\ttableGroup,\n\t\t\t\tcreationState\n\t\t);\n\t}\n\n\t@Override\n\tpublic void applySqlSelections(\n\t\t\tNavigablePath navigablePath,\n\t\t\tTableGroup tableGroup,\n\t\t\tDomainResultCreationState creationState,\n\t\t\tBiConsumer<SqlSelection, JdbcMapping> selectionConsumer) {\n\t\tidentifierMapping.applySqlSelections(\n\t\t\t\tnavigablePath.append( identifierMapping.getPartName() ),\n\t\t\t\ttableGroup,\n\t\t\t\tcreationState,\n\t\t\t\tselectionConsumer\n\t\t);\n\t}\n\n\t@Override\n\tpublic NaturalIdMapping getNaturalIdMapping() {\n\t\treturn naturalIdMapping;\n\t}\n\n\t@Override\n\tpublic TableReference createPrimaryTableReference(\n\t\t\tSqlAliasBase sqlAliasBase,\n\t\t\tSqlAstCreationState sqlAstCreationState) {\n\t\treturn new NamedTableReference( getTableName(), sqlAliasBase.generateNewAlias() );\n\t}\n\n\t@Override\n\tpublic TableReferenceJoin createTableReferenceJoin(\n\t\t\tString joinTableExpression,\n\t\t\tSqlAliasBase sqlAliasBase,\n\t\t\tTableReference lhs,\n\t\t\tSqlAstCreationState creationState) {\n\t\tfor ( int i = 1; i < getSubclassTableSpan(); i++ ) {\n\t\t\tfinal String subclassTableName = getSubclassTableName( i );\n\t\t\tif ( subclassTableName.equals( joinTableExpression ) ) {\n\t\t\t\treturn generateTableReferenceJoin(\n\t\t\t\t\t\tlhs,\n\t\t\t\t\t\tjoinTableExpression,\n\t\t\t\t\t\tsqlAliasBase,\n\t\t\t\t\t\tshouldInnerJoinSubclassTable( i, emptySet() ),\n\t\t\t\t\t\tgetSubclassTableKeyColumns( i ),\n\t\t\t\t\t\tcreationState\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tprotected TableReferenceJoin generateTableReferenceJoin(\n\t\t\tTableReference lhs,\n\t\t\tString joinTableExpression,\n\t\t\tSqlAliasBase sqlAliasBase,\n\t\t\tboolean innerJoin,\n\t\t\tString[] targetColumns,\n\t\t\tSqlAstCreationState creationState) {\n\t\tfinal NamedTableReference joinedTableReference = new NamedTableReference(\n\t\t\t\tjoinTableExpression,\n\t\t\t\tsqlAliasBase.generateNewAlias(),\n\t\t\t\t!innerJoin\n\t\t);\n\n\t\treturn new TableReferenceJoin(\n\t\t\t\tinnerJoin,\n\t\t\t\tjoinedTableReference,\n\t\t\t\tgenerateJoinPredicate(\n\t\t\t\t\t\tlhs,\n\t\t\t\t\t\tjoinedTableReference,\n\t\t\t\t\t\tgetIdentifierColumnNames(),\n\t\t\t\t\t\ttargetColumns,\n\t\t\t\t\t\tcreationState\n\t\t\t\t)\n\t\t);\n\t}\n\n\tprotected Predicate generateJoinPredicate(\n\t\t\tTableReference rootTableReference,\n\t\t\tTableReference joinedTableReference,\n\t\t\tString[] pkColumnNames,\n\t\t\tString[] fkColumnNames,\n\t\t\tSqlAstCreationState creationState) {\n\t\tfinal EntityIdentifierMapping identifierMapping = getIdentifierMapping();\n\n\t\tfinal Junction conjunction = new Junction( Junction.Nature.CONJUNCTION );\n\n\t\tassert pkColumnNames.length == fkColumnNames.length;\n\t\tassert pkColumnNames.length == identifierMapping.getJdbcTypeCount();\n\n\t\tidentifierMapping.forEachSelectable(\n\t\t\t\t(columnIndex, selection) -> {\n\t\t\t\t\tfinal String rootPkColumnName = pkColumnNames[ columnIndex ];\n\t\t\t\t\tfinal Expression pkColumnExpression = creationState.getSqlExpressionResolver().resolveSqlExpression(\n\t\t\t\t\t\t\tcreateColumnReferenceKey(\n\t\t\t\t\t\t\t\t\trootTableReference,\n\t\t\t\t\t\t\t\t\trootPkColumnName,\n\t\t\t\t\t\t\t\t\tselection.getJdbcMapping()\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\tsqlAstProcessingState -> new ColumnReference(\n\t\t\t\t\t\t\t\t\trootTableReference.getIdentificationVariable(),\n\t\t\t\t\t\t\t\t\trootPkColumnName,\n\t\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\t\tnull,\n\t\t\t\t\t\t\t\t\tselection.getJdbcMapping()\n\t\t\t\t\t\t\t)\n\t\t\t\t\t);\n\n\t\t\t\t\tfinal String fkColumnName = fkColumnNames[ columnIndex ];\n\t\t\t\t\tfinal Expression fkColumnExpression = creationState.getSqlExpressionResolver().resolveSqlExpression(\n\t\t\t\t\t\t\tcreateColumnReferenceKey(\n\t\t\t\t\t\t\t\t\tjoinedTableReference,\n\t\t\t\t\t\t\t\t\tfkColumnName,\n\t\t\t\t\t\t\t\t\tselection.getJdbcMapping()\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\tsqlAstProcessingState -> new ColumnReference(\n\t\t\t\t\t\t\t\t\tjoinedTableReference.getIdentificationVariable(),\n\t\t\t\t\t\t\t\t\tfkColumnName,\n\t\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\t\tnull,\n\t\t\t\t\t\t\t\t\tselection.getJdbcMapping()\n\t\t\t\t\t\t\t)\n\t\t\t\t\t);\n\n\t\t\t\t\tconjunction.add( new ComparisonPredicate( pkColumnExpression, ComparisonOperator.EQUAL, fkColumnExpression ) );\n\t\t\t\t}\n\t\t);\n\n\t\treturn conjunction;\n\t}\n\n\t@Override\n\tpublic Object initializeLazyProperty(String fieldName, Object entity, SharedSessionContractImplementor session) {\n\t\tfinal PersistenceContext persistenceContext = session.getPersistenceContextInternal();\n\t\tfinal EntityEntry entry = persistenceContext.getEntry( entity );\n\t\tfinal PersistentAttributeInterceptor interceptor = asPersistentAttributeInterceptable( entity ).$$_hibernate_getInterceptor();\n\t\tassert interceptor != null : \"Expecting bytecode interceptor to be non-null\";\n\n\t\tif ( hasCollections() ) {\n\t\t\tfinal Type type = getPropertyType( fieldName );\n\t\t\tif ( type.isCollectionType() ) {\n\t\t\t\t// we have a condition where a collection attribute is being access via enhancement:\n\t\t\t\t// \t\twe can circumvent all the rest and just return the PersistentCollection\n\t\t\t\tfinal CollectionType collectionType = (CollectionType) type;\n\t\t\t\tfinal CollectionPersister persister = factory.getRuntimeMetamodels()\n\t\t\t\t\t\t.getMappingMetamodel()\n\t\t\t\t\t\t.getCollectionDescriptor( collectionType.getRole() );\n\n\t\t\t\t// Get/create the collection, and make sure it is initialized!  This initialized part is\n\t\t\t\t// different from proxy-based scenarios where we have to create the PersistentCollection\n\t\t\t\t// reference \"ahead of time\" to add as a reference to the proxy.  For bytecode solutions\n\t\t\t\t// we are not creating the PersistentCollection ahead of time, but instead we are creating\n\t\t\t\t// it on first request through the enhanced entity.\n\n\t\t\t\t// see if there is already a collection instance associated with the session\n\t\t\t\t// \t\tNOTE : can this ever happen?\n\t\t\t\tfinal Object key = getCollectionKey( persister, entity, entry, session );\n\t\t\t\tassert key != null;\n\t\t\t\tPersistentCollection<?> collection = persistenceContext.getCollection( new CollectionKey( persister, key ) );\n\t\t\t\tif ( collection == null ) {\n\t\t\t\t\tcollection = collectionType.instantiate( session, persister, key );\n\t\t\t\t\tcollection.setOwner( entity );\n\t\t\t\t\tpersistenceContext.addUninitializedCollection( persister, collection, key );\n\t\t\t\t}\n\n\t\t\t\tinterceptor.attributeInitialized( fieldName );\n\n\t\t\t\tif ( collectionType.isArrayType() ) {\n\t\t\t\t\tpersistenceContext.addCollectionHolder( collection );\n\t\t\t\t}\n\n\t\t\t\t// update the \"state\" of the entity's EntityEntry to over-write UNFETCHED_PROPERTY reference\n\t\t\t\t// for the collection to the just loaded collection\n\t\t\t\tfinal EntityEntry ownerEntry = persistenceContext.getEntry( entity );\n\t\t\t\tif ( ownerEntry == null ) {\n\t\t\t\t\t// the entity is not in the session; it was probably deleted,\n\t\t\t\t\t// so we cannot load the collection anymore.\n\t\t\t\t\tthrow new LazyInitializationException(\n\t\t\t\t\t\t\t\"Could not locate EntityEntry for the collection owner in the PersistenceContext\"\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\townerEntry.overwriteLoadedStateCollectionValue( fieldName, collection );\n\n\t\t\t\t// EARLY EXIT!!!\n\t\t\t\treturn collection;\n\t\t\t}\n\t\t}\n\n\t\tfinal Object id = session.getContextEntityIdentifier( entity );\n\t\tif ( entry == null ) {\n\t\t\tthrow new HibernateException( \"entity is not associated with the session: \" + id );\n\t\t}\n\n\t\tif ( LOG.isTraceEnabled() ) {\n\t\t\tLOG.tracev(\n\t\t\t\t\t\"Initializing lazy properties of: {0}, field access: {1}\",\n\t\t\t\t\tinfoString( this, id, getFactory() ),\n\t\t\t\t\tfieldName\n\t\t\t);\n\t\t}\n\n\t\tif ( session.getCacheMode().isGetEnabled() && canReadFromCache() && isLazyPropertiesCacheable() ) {\n\t\t\tfinal EntityDataAccess cacheAccess = getCacheAccessStrategy();\n\t\t\tfinal Object cacheKey = cacheAccess.generateCacheKey(id, this, session.getFactory(), session.getTenantIdentifier() );\n\t\t\tfinal Object ce = CacheHelper.fromSharedCache( session, cacheKey, this, cacheAccess );\n\t\t\tif ( ce != null ) {\n\t\t\t\tfinal CacheEntry cacheEntry = (CacheEntry) getCacheEntryStructure().destructure( ce, factory );\n\t\t\t\tfinal Object initializedValue = initializeLazyPropertiesFromCache( fieldName, entity, session, entry, cacheEntry );\n\t\t\t\tif (initializedValue != LazyPropertyInitializer.UNFETCHED_PROPERTY) {\n\t\t\t\t\t// The following should be redundant, since the setter should have set this already.\n\t\t\t\t\t// interceptor.attributeInitialized(fieldName);\n\n\t\t\t\t\t// NOTE EARLY EXIT!!!\n\t\t\t\t\treturn initializedValue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn initializeLazyPropertiesFromDatastore( entity, id, entry, fieldName, session );\n\n\t}\n\n\tpublic @Nullable static Object getCollectionKey(\n\t\t\tCollectionPersister persister,\n\t\t\tObject owner,\n\t\t\tEntityEntry ownerEntry,\n\t\t\tSharedSessionContractImplementor session) {\n\t\tfinal CollectionType collectionType = persister.getCollectionType();\n\n\t\tif ( ownerEntry != null ) {\n\t\t\t// this call only works when the owner is associated with the Session, which is not always the case\n\t\t\treturn collectionType.getKeyOfOwner( owner, session );\n\t\t}\n\n\t\tfinal EntityPersister ownerPersister = persister.getOwnerEntityPersister();\n\t\tif ( collectionType.getLHSPropertyName() == null ) {\n\t\t\t// collection key is defined by the owning entity identifier\n\t\t\treturn ownerPersister.getIdentifier( owner, session );\n\t\t}\n\t\telse {\n\t\t\treturn ownerPersister.getPropertyValue( owner, collectionType.getLHSPropertyName() );\n\t\t}\n\t}\n\n\tprotected Object initializeLazyPropertiesFromDatastore(\n\t\t\tfinal Object entity,\n\t\t\tfinal Object id,\n\t\t\tfinal EntityEntry entry,\n\t\t\tfinal String fieldName,\n\t\t\tfinal SharedSessionContractImplementor session) {\n\n\t\tif ( !hasLazyProperties() ) {\n\t\t\tthrow new AssertionFailure( \"no lazy properties\" );\n\t\t}\n\n\t\tfinal PersistentAttributeInterceptor interceptor = asPersistentAttributeInterceptable( entity ).$$_hibernate_getInterceptor();\n\t\tassert interceptor != null : \"Expecting bytecode interceptor to be non-null\";\n\n\t\tLOG.tracef( \"Initializing lazy properties from datastore (triggered for `%s`)\", fieldName );\n\n\t\tfinal String fetchGroup = getEntityMetamodel().getBytecodeEnhancementMetadata()\n\t\t\t\t.getLazyAttributesMetadata()\n\t\t\t\t.getFetchGroupName( fieldName );\n\t\tfinal List<LazyAttributeDescriptor> fetchGroupAttributeDescriptors = getEntityMetamodel().getBytecodeEnhancementMetadata()\n\t\t\t\t.getLazyAttributesMetadata()\n\t\t\t\t.getFetchGroupAttributeDescriptors( fetchGroup );\n\n\t\tfinal Set<String> initializedLazyAttributeNames = interceptor.getInitializedLazyAttributeNames();\n\n\t\tfinal SingleIdArrayLoadPlan lazySelect = getSQLLazySelectLoadPlan( fetchGroup );\n\n\t\ttry {\n\t\t\tObject result = null;\n\t\t\tfinal Object[] values = lazySelect.load( id, session );\n\t\t\tint i = 0;\n\t\t\tfor ( LazyAttributeDescriptor fetchGroupAttributeDescriptor : fetchGroupAttributeDescriptors ) {\n\t\t\t\tfinal boolean previousInitialized = initializedLazyAttributeNames.contains( fetchGroupAttributeDescriptor.getName() );\n\n\t\t\t\tif ( previousInitialized ) {\n\t\t\t\t\t// todo : one thing we should consider here is potentially un-marking an attribute as dirty based on the selected value\n\t\t\t\t\t// \t\twe know the current value - getPropertyValue( entity, fetchGroupAttributeDescriptor.getAttributeIndex() );\n\t\t\t\t\t// \t\twe know the selected value (see selectedValue below)\n\t\t\t\t\t//\t\twe can use the attribute Type to tell us if they are the same\n\t\t\t\t\t//\n\t\t\t\t\t//\t\tassuming entity is a SelfDirtinessTracker we can also know if the attribute is\n\t\t\t\t\t//\t\t\tcurrently considered dirty, and if really not dirty we would do the un-marking\n\t\t\t\t\t//\n\t\t\t\t\t//\t\tof course that would mean a new method on SelfDirtinessTracker to allow un-marking\n\n\t\t\t\t\t// its already been initialized (e.g. by a write) so we don't want to overwrite\n\t\t\t\t\ti++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tfinal Object selectedValue = values[i++];\n\t\t\t\tfinal boolean set = initializeLazyProperty(\n\t\t\t\t\t\tfieldName,\n\t\t\t\t\t\tentity,\n\t\t\t\t\t\tentry,\n\t\t\t\t\t\tfetchGroupAttributeDescriptor.getLazyIndex(),\n\t\t\t\t\t\tselectedValue\n\t\t\t\t);\n\t\t\t\tif ( set ) {\n\t\t\t\t\tresult = selectedValue;\n\t\t\t\t\tinterceptor.attributeInitialized( fetchGroupAttributeDescriptor.getName() );\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tLOG.trace( \"Done initializing lazy properties\" );\n\n\t\t\treturn result;\n\t\t}\n\t\tcatch ( JDBCException ex ) {\n\t\t\tthrow session.getJdbcServices().getSqlExceptionHelper().convert(\n\t\t\t\t\tex.getSQLException(),\n\t\t\t\t\t\"could not initialize lazy properties: \" + infoString( this, id, getFactory() ),\n\t\t\t\t\tlazySelect.getJdbcSelect().getSqlString()\n\t\t\t);\n\t\t}\n\t}\n\n\tprotected Object initializeLazyPropertiesFromCache(\n\t\t\tfinal String fieldName,\n\t\t\tfinal Object entity,\n\t\t\tfinal SharedSessionContractImplementor session,\n\t\t\tfinal EntityEntry entry,\n\t\t\tfinal CacheEntry cacheEntry) {\n\n\t\tLOG.trace( \"Initializing lazy properties from second-level cache\" );\n\n\t\tObject result = null;\n\t\tSerializable[] disassembledValues = cacheEntry.getDisassembledState();\n\t\tfor ( int j = 0; j < lazyPropertyNames.length; j++ ) {\n\t\t\tfinal Serializable cachedValue = disassembledValues[lazyPropertyNumbers[j]];\n\t\t\tfinal Type lazyPropertyType = lazyPropertyTypes[j];\n\t\t\tfinal String propertyName = lazyPropertyNames[j];\n\t\t\tif ( cachedValue == LazyPropertyInitializer.UNFETCHED_PROPERTY ) {\n\t\t\t\tif ( fieldName.equals(propertyName) ) {\n\t\t\t\t\tresult = LazyPropertyInitializer.UNFETCHED_PROPERTY;\n\t\t\t\t}\n\t\t\t\t// don't try to initialize the unfetched property\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfinal Object propValue = lazyPropertyType.assemble( cachedValue, session, entity );\n\t\t\t\tif ( initializeLazyProperty( fieldName, entity, entry, j, propValue ) ) {\n\t\t\t\t\tresult = propValue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tLOG.trace( \"Done initializing lazy properties\" );\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Called by Hibernate Reactive\n\t */\n\tprotected boolean initializeLazyProperty(\n\t\t\tfinal String fieldName,\n\t\t\tfinal Object entity,\n\t\t\tfinal EntityEntry entry,\n\t\t\tfinal int index,\n\t\t\tfinal Object propValue) {\n\t\tsetPropertyValue( entity, lazyPropertyNumbers[index], propValue );\n\t\tif ( entry.getLoadedState() != null ) {\n\t\t\t// object have been loaded with setReadOnly(true); HHH-2236\n\t\t\tentry.getLoadedState()[lazyPropertyNumbers[index]] = lazyPropertyTypes[index].deepCopy( propValue, factory );\n\t\t}\n\t\t// If the entity has deleted state, then update that as well\n\t\tif ( entry.getDeletedState() != null ) {\n\t\t\tentry.getDeletedState()[lazyPropertyNumbers[index]] = lazyPropertyTypes[index].deepCopy( propValue, factory );\n\t\t}\n\t\treturn fieldName.equals( lazyPropertyNames[index] );\n\t}\n\n\t@Override\n\tpublic NavigableRole getNavigableRole() {\n\t\treturn navigableRole;\n\t}\n\n\t@Override\n\tpublic Serializable[] getQuerySpaces() {\n\t\treturn getPropertySpaces();\n\t}\n\n\t@Override\n\tpublic boolean isBatchLoadable() {\n\t\treturn batchSize > 1;\n\t}\n\n\t@Override\n\tpublic int getBatchSize() {\n\t\treturn batchSize;\n\t}\n\n\t@Override\n\tpublic String[] getIdentifierColumnNames() {\n\t\treturn rootTableKeyColumnNames;\n\t}\n\n\tpublic String[] getIdentifierColumnReaders() {\n\t\treturn rootTableKeyColumnReaders;\n\t}\n\n\tpublic String[] getIdentifierColumnReaderTemplates() {\n\t\treturn rootTableKeyColumnReaderTemplates;\n\t}\n\n\tpublic int getIdentifierColumnSpan() {\n\t\treturn identifierColumnSpan;\n\t}\n\n\tpublic String[] getIdentifierAliases() {\n\t\treturn identifierAliases;\n\t}\n\n\t@Override\n\tpublic String getVersionColumnName() {\n\t\treturn versionColumnName;\n\t}\n\n\tpublic String getVersionedTableName() {\n\t\treturn getTableName( 0 );\n\t}\n\n\t/**\n\t * We can't immediately add to the cache if we have formulas\n\t * which must be evaluated, or if we have the possibility of\n\t * two concurrent updates to the same item being merged on\n\t * the database. This second case can happen if:\n\t * <ol>\n\t * <li> the item is not versioned, and either\n\t * <li>we have dynamic update enabled, or\n\t * <li>the state of the item spans multiple tables.\n\t * </ol>\n\t * Therefore, we're careful, and just invalidate the cache in\n\t * these cases (the item will be readded when it's read again\n\t * fresh from the database).\n\t */\n\t@Override\n\tpublic boolean isCacheInvalidationRequired() {\n\t\treturn invalidateCache;\n\t}\n\n\t@Override\n\tpublic boolean isLazyPropertiesCacheable() {\n\t\treturn isLazyPropertiesCacheable;\n\t}\n\n\t@Override\n\tpublic String selectFragment(String alias, String suffix) {\n\t\tfinal QuerySpec rootQuerySpec = new QuerySpec( true );\n\t\tfinal LoaderSqlAstCreationState sqlAstCreationState = new LoaderSqlAstCreationState(\n\t\t\t\trootQuerySpec,\n\t\t\t\tnew SqlAliasBaseManager(),\n\t\t\t\tnew SimpleFromClauseAccessImpl(),\n\t\t\t\tLockOptions.NONE,\n\t\t\t\tthis::fetchProcessor,\n\t\t\t\ttrue,\n\t\t\t\tnew LoadQueryInfluencers( factory ),\n\t\t\t\tfactory\n\t\t);\n\n\t\tfinal NavigablePath entityPath = new NavigablePath( getRootPathName() );\n\t\tfinal TableGroup rootTableGroup = createRootTableGroup(\n\t\t\t\ttrue,\n\t\t\t\tentityPath,\n\t\t\t\tnull,\n\t\t\t\tnew SqlAliasBaseConstant( alias ),\n\t\t\t\t() -> p -> {},\n\t\t\t\tsqlAstCreationState\n\t\t);\n\n\t\trootQuerySpec.getFromClause().addRoot( rootTableGroup );\n\t\tsqlAstCreationState.getFromClauseAccess().registerTableGroup( entityPath, rootTableGroup );\n\n\t\tcreateDomainResult( entityPath, rootTableGroup, null, sqlAstCreationState );\n\n\t\t// Wrap expressions with aliases\n\t\tfinal SelectClause selectClause = rootQuerySpec.getSelectClause();\n\t\tfinal List<SqlSelection> sqlSelections = selectClause.getSqlSelections();\n\t\tint i = 0;\n\t\tint columnIndex = 0;\n\t\tfinal String[] columnAliases = getSubclassColumnAliasClosure();\n\t\tfinal int columnAliasesSize = columnAliases.length;\n\t\tfor ( String identifierAlias : identifierAliases ) {\n\t\t\tsqlSelections.set(\n\t\t\t\t\ti,\n\t\t\t\t\tnew SqlSelectionImpl(\n\t\t\t\t\t\t\ti,\n\t\t\t\t\t\t\tnew AliasedExpression( sqlSelections.get( i ).getExpression(), identifierAlias + suffix )\n\t\t\t\t\t)\n\t\t\t);\n\t\t\tif ( i < columnAliasesSize && columnAliases[i].equals( identifierAlias ) ) {\n\t\t\t\tcolumnIndex++;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\n\t\tif ( entityMetamodel.hasSubclasses() ) {\n\t\t\tsqlSelections.set(\n\t\t\t\t\ti,\n\t\t\t\t\tnew SqlSelectionImpl(\n\t\t\t\t\t\t\ti,\n\t\t\t\t\t\t\tnew AliasedExpression( sqlSelections.get( i ).getExpression(), getDiscriminatorAlias() + suffix )\n\t\t\t\t\t)\n\t\t\t);\n\t\t\ti++;\n\t\t}\n\n\t\tif ( hasRowId() ) {\n\t\t\tsqlSelections.set(\n\t\t\t\t\ti,\n\t\t\t\t\tnew SqlSelectionImpl(\n\t\t\t\t\t\t\ti,\n\t\t\t\t\t\t\tnew AliasedExpression( sqlSelections.get( i ).getExpression(), ROWID_ALIAS + suffix )\n\t\t\t\t\t)\n\t\t\t);\n\t\t\ti++;\n\t\t}\n\n\t\tfinal String[] formulaAliases = getSubclassFormulaAliasClosure();\n\t\tint formulaIndex = 0;\n\t\tfor ( ; i < sqlSelections.size(); i++ ) {\n\t\t\tfinal SqlSelection sqlSelection = sqlSelections.get( i );\n\t\t\tfinal ColumnReference columnReference = (ColumnReference) sqlSelection.getExpression();\n\t\t\tfinal String selectAlias = !columnReference.isColumnExpressionFormula()\n\t\t\t\t\t? columnAliases[columnIndex++] + suffix\n\t\t\t\t\t: formulaAliases[formulaIndex++] + suffix;\n\t\t\tsqlSelections.set(\n\t\t\t\t\ti,\n\t\t\t\t\tnew SqlSelectionImpl(\n\t\t\t\t\t\t\tsqlSelection.getValuesArrayPosition(),\n\t\t\t\t\t\t\tnew AliasedExpression( sqlSelection.getExpression(), selectAlias )\n\t\t\t\t\t)\n\t\t\t);\n\t\t}\n\n\t\tfinal String sql = getFactory().getJdbcServices()\n\t\t\t\t.getDialect()\n\t\t\t\t.getSqlAstTranslatorFactory()\n\t\t\t\t.buildSelectTranslator( getFactory(), new SelectStatement( rootQuerySpec ) )\n\t\t\t\t.translate( null, QueryOptions.NONE )\n\t\t\t\t.getSqlString();\n\t\tfinal int fromIndex = sql.lastIndexOf( \" from\" );\n\t\tfinal String expression;\n\t\tif ( fromIndex != -1 ) {\n\t\t\texpression = sql.substring( \"select \".length(), fromIndex );\n\t\t}\n\t\telse {\n\t\t\texpression = sql.substring( \"select \".length() );\n\t\t}\n\t\treturn expression;\n\t}\n\n\tprivate ImmutableFetchList fetchProcessor(FetchParent fetchParent, LoaderSqlAstCreationState creationState) {\n\t\tfinal FetchableContainer fetchableContainer = fetchParent.getReferencedMappingContainer();\n\t\tfinal int size = fetchableContainer.getNumberOfFetchables();\n\t\tfinal ImmutableFetchList.Builder fetches = new ImmutableFetchList.Builder( fetchableContainer );\n\n\t\tfor ( int i = 0; i < size; i++ ) {\n\t\t\tfinal Fetchable fetchable = fetchableContainer.getFetchable( i );\n\t\t\t// Ignore plural attributes\n\t\t\tif ( !( fetchable instanceof PluralAttributeMapping ) ) {\n\t\t\t\tfinal FetchTiming fetchTiming = fetchable.getMappedFetchOptions().getTiming();\n\t\t\t\tif ( fetchable.asBasicValuedModelPart() != null ) {\n\t\t\t\t\t// Ignore lazy basic columns\n\t\t\t\t\tif ( fetchTiming == FetchTiming.DELAYED ) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if ( fetchable instanceof Association ) {\n\t\t\t\t\tfinal Association association = (Association) fetchable;\n\t\t\t\t\t// Ignore the fetchable if the FK is on the other side\n\t\t\t\t\tif ( association.getSideNature() == ForeignKeyDescriptor.Nature.TARGET ) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t// Ensure the FK comes from the root table\n\t\t\t\t\tif ( !getRootTableName().equals( association.getForeignKeyDescriptor().getKeyTable() ) ) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif ( fetchTiming == null ) {\n\t\t\t\t\tthrow new AssertionFailure(\"fetchTiming was null\");\n\t\t\t\t}\n\n\t\t\t\tif ( fetchable.isSelectable() ) {\n\t\t\t\t\tfinal Fetch fetch = fetchParent.generateFetchableFetch(\n\t\t\t\t\t\t\tfetchable,\n\t\t\t\t\t\t\tfetchParent.resolveNavigablePath( fetchable ),\n\t\t\t\t\t\t\tfetchTiming,\n\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\tnull,\n\t\t\t\t\t\t\tcreationState\n\t\t\t\t\t);\n\t\t\t\t\tfetches.add( fetch );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn fetches.build();\n\t}\n\n\t@Override\n\tpublic String[] getIdentifierAliases(String suffix) {\n\t\t// NOTE: this assumes something about how propertySelectFragment is implemented by the subclass!\n\t\t// was toUnquotedAliasStrings( getIdentifierColumnNames() ) before - now tried\n\t\t// to remove that unquoting and missing aliases\n\t\treturn new Alias( suffix ).toAliasStrings( getIdentifierAliases() );\n\t}\n\n\t@Override\n\tpublic String[] getPropertyAliases(String suffix, int i) {\n\t\t// NOTE: this assumes something about how propertySelectFragment is implemented by the subclass!\n\t\treturn new Alias( suffix ).toUnquotedAliasStrings( propertyColumnAliases[i] );\n\t}\n\n\t@Override\n\tpublic String getDiscriminatorAlias(String suffix) {\n\t\t// NOTE: this assumes something about how propertySelectFragment is implemented by the subclass!\n\t\t// toUnquotedAliasStrings( getDiscriminatorColumnName() ) before - now tried\n\t\t// to remove that unquoting and missing aliases\n\t\treturn entityMetamodel.hasSubclasses()\n\t\t\t\t? new Alias( suffix ).toAliasString( getDiscriminatorAlias() )\n\t\t\t\t: null;\n\t}\n\n\t@Override\n\tpublic Object[] getDatabaseSnapshot(Object id, SharedSessionContractImplementor session) throws HibernateException {\n\t\treturn singleIdLoader.loadDatabaseSnapshot( id, session );\n\t}\n\n\t@Override\n\tpublic Object getIdByUniqueKey(Object key, String uniquePropertyName, SharedSessionContractImplementor session) {\n\t\tif ( LOG.isTraceEnabled() ) {\n\t\t\tLOG.tracef(\n\t\t\t\t\t\"resolving unique key [%s] to identifier for entity [%s]\",\n\t\t\t\t\tkey,\n\t\t\t\t\tgetEntityName()\n\t\t\t);\n\t\t}\n\n\t\treturn getUniqueKeyLoader( uniquePropertyName, session ).resolveId( key, session );\n\t}\n\n\n\t/**\n\t * Generate the SQL that selects the version number by id\n\t */\n\tpublic String generateSelectVersionString() {\n\t\tfinal SimpleSelect select = new SimpleSelect( getFactory() ).setTableName( getVersionedTableName() );\n\t\tif ( isVersioned() ) {\n\t\t\tselect.addColumn( getVersionColumnName(), VERSION_COLUMN_ALIAS );\n\t\t}\n\t\telse {\n\t\t\tselect.addColumns( rootTableKeyColumnNames );\n\t\t}\n\t\tif ( getFactory().getSessionFactoryOptions().isCommentsEnabled() ) {\n\t\t\tselect.setComment( \"get version \" + getEntityName() );\n\t\t}\n\t\treturn select.addRestriction( rootTableKeyColumnNames ).toStatementString();\n\t}\n\n\tprotected GeneratedValuesProcessor createGeneratedValuesProcessor(\n\t\t\tEventType timing,\n\t\t\tList<AttributeMapping> generatedAttributes) {\n\t\treturn new GeneratedValuesProcessor( this, generatedAttributes, timing, getFactory() );\n\t}\n\n\t@Override\n\tpublic Object forceVersionIncrement(Object id, Object currentVersion, SharedSessionContractImplementor session) {\n\t\tassert getMappedTableDetails().getTableName().equals( getVersionedTableName() );\n\t\tfinal Object nextVersion = calculateNextVersion( id, currentVersion, session );\n\t\tupdateCoordinator.forceVersionIncrement( id, currentVersion, nextVersion, session );\n\t\treturn nextVersion;\n\t}\n\n\t@Override\n\tpublic Object forceVersionIncrement(\n\t\t\tObject id,\n\t\t\tObject currentVersion,\n\t\t\tboolean batching,\n\t\t\tSharedSessionContractImplementor session) throws HibernateException {\n\t\tassert getMappedTableDetails().getTableName().equals( getVersionedTableName() );\n\t\tfinal Object nextVersion = calculateNextVersion( id, currentVersion, session );\n\t\tupdateCoordinator.forceVersionIncrement( id, currentVersion, nextVersion, batching, session );\n\t\treturn nextVersion;\n\t}\n\n\tprivate Object calculateNextVersion(Object id, Object currentVersion, SharedSessionContractImplementor session) {\n\t\tif ( !isVersioned() ) {\n\t\t\tthrow new AssertionFailure( \"cannot force version increment on non-versioned entity\" );\n\t\t}\n\n\t\tif ( isVersionGeneratedOnExecution() ) {\n\t\t\t// the difficulty here is exactly what we update in order to\n\t\t\t// force the version to be incremented in the db...\n\t\t\tthrow new HibernateException( \"LockMode.FORCE is currently not supported for generated version properties\" );\n\n\t\t}\n\n\t\tfinal EntityVersionMapping versionMapping = getVersionMapping();\n\t\tfinal Object nextVersion = getVersionJavaType().next(\n\t\t\t\tcurrentVersion,\n\t\t\t\tversionMapping.getLength(),\n\t\t\t\tversionMapping.getTemporalPrecision() != null\n\t\t\t\t\t\t? versionMapping.getTemporalPrecision()\n\t\t\t\t\t\t: versionMapping.getPrecision(),\n\t\t\t\tversionMapping.getScale(),\n\t\t\t\tsession\n\t\t);\n\t\tif ( LOG.isTraceEnabled() ) {\n\t\t\tLOG.trace(\n\t\t\t\t\t\"Forcing version increment [\" + infoString( this, id, getFactory() ) + \"; \"\n\t\t\t\t\t\t\t+ getVersionType().toLoggableString( currentVersion, getFactory() ) + \" -> \"\n\t\t\t\t\t\t\t+ getVersionType().toLoggableString( nextVersion, getFactory() ) + \"]\"\n\t\t\t);\n\t\t}\n\t\treturn nextVersion;\n\t}\n\n\t/**\n\t * Retrieve the version number\n\t */\n\t@Override\n\tpublic Object getCurrentVersion(Object id, SharedSessionContractImplementor session) throws HibernateException {\n\n\t\tif ( LOG.isTraceEnabled() ) {\n\t\t\tLOG.tracev( \"Getting version: {0}\", infoString( this, id, getFactory() ) );\n\t\t}\n\t\tfinal String versionSelectString = getVersionSelectString();\n\t\ttry {\n\t\t\tfinal JdbcCoordinator jdbcCoordinator = session.getJdbcCoordinator();\n\t\t\tfinal PreparedStatement st = jdbcCoordinator.getStatementPreparer().prepareStatement( versionSelectString );\n\t\t\ttry {\n\t\t\t\tgetIdentifierType().nullSafeSet( st, id, 1, session );\n\t\t\t\tfinal ResultSet rs = jdbcCoordinator.getResultSetReturn().extract( st, versionSelectString );\n\t\t\t\ttry {\n\t\t\t\t\tif ( !rs.next() ) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\tif ( !isVersioned() ) {\n\t\t\t\t\t\treturn this;\n\t\t\t\t\t}\n\t\t\t\t\treturn getVersionMapping().getJdbcMapping().getJdbcValueExtractor().extract( rs, 1, session );\n\t\t\t\t}\n\t\t\t\tfinally {\n\t\t\t\t\tjdbcCoordinator.getLogicalConnection().getResourceRegistry().release( rs, st );\n\t\t\t\t}\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tjdbcCoordinator.getLogicalConnection().getResourceRegistry().release( st );\n\t\t\t\tjdbcCoordinator.afterStatementExecution();\n\t\t\t}\n\t\t}\n\t\tcatch ( SQLException e ) {\n\t\t\tthrow session.getJdbcServices().getSqlExceptionHelper().convert(\n\t\t\t\t\te,\n\t\t\t\t\t\"could not retrieve version: \" + infoString( this, id, getFactory() ),\n\t\t\t\t\tversionSelectString\n\t\t\t);\n\t\t}\n\t}\n\n\t@Override\n\tpublic JdbcMapping getJdbcMapping(int index) {\n\t\treturn getIdentifierMapping().getJdbcMapping( index );\n\t}\n\n\tprotected LockingStrategy generateLocker(LockMode lockMode) {\n\t\treturn factory.getJdbcServices().getDialect().getLockingStrategy( this, lockMode );\n\t}\n\n\tprivate LockingStrategy getLocker(LockMode lockMode) {\n\t\treturn lockers.computeIfAbsent( lockMode, this::generateLocker );\n\t}\n\n\t@Override\n\tpublic void lock(\n\t\t\tObject id,\n\t\t\tObject version,\n\t\t\tObject object,\n\t\t\tLockMode lockMode,\n\t\t\tEventSource session) throws HibernateException {\n\t\tgetLocker( lockMode ).lock( id, version, object, LockOptions.WAIT_FOREVER, session );\n\t}\n\n\t@Override\n\tpublic void lock(\n\t\t\tObject id,\n\t\t\tObject version,\n\t\t\tObject object,\n\t\t\tLockOptions lockOptions,\n\t\t\tEventSource session) throws HibernateException {\n\t\tgetLocker( lockOptions.getLockMode() ).lock( id, version, object, lockOptions.getTimeOut(), session );\n\t}\n\n\t@Override\n\tpublic String getRootTableName() {\n\t\treturn getSubclassTableName( 0 );\n\t}\n\n\t@Override\n\tpublic String[] getRootTableIdentifierColumnNames() {\n\t\treturn getRootTableKeyColumnNames();\n\t}\n\n\t/**\n\t * {@inheritDoc}\n\t *\n\t * Warning:\n\t * When there are duplicated property names in the subclasses\n\t * then this method may return the wrong results.\n\t * To ensure correct results, this method should only be used when\n\t * {@literal this} is the concrete EntityPersister (since the\n\t * concrete EntityPersister cannot have duplicated property names).\n\t */\n\t@Override\n\tpublic String[] toColumns(String propertyName) throws QueryException {\n\t\treturn propertyMapping.getColumnNames( propertyName );\n\t}\n\n\t/**\n\t * {@inheritDoc}\n\t *\n\t * Warning:\n\t * When there are duplicated property names in the subclasses\n\t * then this method may return the wrong results.\n\t * To ensure correct results, this method should only be used when\n\t * {@literal this} is the concrete EntityPersister (since the\n\t * concrete EntityPersister cannot have duplicated property names).\n\t */\n\t@Override\n\tpublic String[] getPropertyColumnNames(String propertyName) {\n\t\treturn propertyMapping.getColumnNames( propertyName );\n\t}\n\n\t/**\n\t * Warning:\n\t * When there are duplicated property names in the subclasses\n\t * of the class, this method may return the wrong table\n\t * number for the duplicated subclass property. Note that\n\t * SingleTableEntityPersister defines an overloaded form\n\t * which takes the entity name.\n\t */\n\tpublic int getSubclassPropertyTableNumber(String propertyPath) {\n\t\tthrow new UnsupportedOperationException();\n//\t\tString rootPropertyName = StringHelper.root( propertyPath );\n//\t\tType type = propertyMapping.toType( rootPropertyName );\n//\t\tif ( type.isAssociationType() ) {\n//\t\t\tAssociationType assocType = (AssociationType) type;\n//\t\t\tif ( assocType.useLHSPrimaryKey() ) {\n//\t\t\t\t// performance op to avoid the array search\n//\t\t\t\treturn 0;\n//\t\t\t}\n//\t\t\telse if ( type.isCollectionType() ) {\n//\t\t\t\t// properly handle property-ref-based associations\n//\t\t\t\trootPropertyName = assocType.getLHSPropertyName();\n//\t\t\t}\n//\t\t}\n//\t\t//Enable for HHH-440, which we don't like:\n//\t\t/*if ( type.isComponentType() && !propertyName.equals(rootPropertyName) ) {\n//\t\t\tString unrooted = StringHelper.unroot(propertyName);\n//\t\t\tint idx = ArrayHelper.indexOf( getSubclassColumnClosure(), unrooted );\n//\t\t\tif ( idx != -1 ) {\n//\t\t\t\treturn getSubclassColumnTableNumberClosure()[idx];\n//\t\t\t}\n//\t\t}*/\n//\t\tint index = ArrayHelper.indexOf( getSubclassPropertyNameClosure(), rootPropertyName ); //TODO: optimize this better!\n//\t\treturn index == -1 ? 0 : getSubclassPropertyTableNumber( index );\n\t}\n\n\tprivate DiscriminatorType<?> discriminatorType;\n\n\tprotected DiscriminatorType<?> resolveDiscriminatorType() {\n\t\tif ( discriminatorType == null ) {\n\t\t\tdiscriminatorType = buildDiscriminatorType();\n\t\t}\n\t\treturn discriminatorType;\n\t}\n\n\tprivate DiscriminatorType<?> buildDiscriminatorType() {\n\t\tfinal BasicType<?> underlingJdbcMapping = getDiscriminatorType();\n\t\tif ( underlingJdbcMapping == null ) {\n\t\t\treturn null;\n\t\t}\n\n\t\tfinal JavaTypeRegistry javaTypeRegistry = factory.getTypeConfiguration().getJavaTypeRegistry();\n\n\t\tfinal JavaType<Object> domainJavaType;\n\t\tif ( representationStrategy.getMode() == POJO\n\t\t\t\t&& getEntityName().equals( getJavaType().getJavaTypeClass().getName() ) ) {\n\t\t\tdomainJavaType = javaTypeRegistry.resolveDescriptor( Class.class );\n\t\t}\n\t\telse {\n\t\t\tdomainJavaType = javaTypeRegistry.resolveDescriptor( String.class );\n\t\t}\n\n\t\t//noinspection rawtypes\n\t\tfinal DiscriminatorConverter converter = MappedDiscriminatorConverter.fromValueMappings(\n\t\t\t\tgetNavigableRole().append( EntityDiscriminatorMapping.DISCRIMINATOR_ROLE_NAME ),\n\t\t\t\tdomainJavaType,\n\t\t\t\tunderlingJdbcMapping,\n\t\t\t\tgetSubclassByDiscriminatorValue(),\n\t\t\t\tfactory.getMappingMetamodel()\n\t\t);\n\n\t\t//noinspection unchecked,rawtypes\n\t\treturn new DiscriminatorTypeImpl( underlingJdbcMapping, converter );\n\t}\n\n\t@Override\n\tpublic DiscriminatorMetadata getTypeDiscriminatorMetadata() {\n\t\treturn this::buildDiscriminatorType;\n\t}\n\n\tpublic static String generateTableAlias(String rootAlias, int tableNumber) {\n\t\tif ( tableNumber == 0 ) {\n\t\t\treturn rootAlias;\n\t\t}\n\t\tfinal StringBuilder alias = new StringBuilder().append( rootAlias );\n\t\tif ( !rootAlias.endsWith( \"_\" ) ) {\n\t\t\talias.append( '_' );\n\t\t}\n\t\treturn alias.append( tableNumber ).append( '_' ).toString();\n\t}\n\n\tprivate int getSubclassPropertyIndex(String propertyName) {\n\t\treturn ArrayHelper.indexOf( subclassPropertyNameClosure, propertyName );\n\t}\n\n\tpublic String[] getPropertyColumnNames(int i) {\n\t\treturn propertyColumnNames[i];\n\t}\n\n\tpublic boolean hasFormulaProperties() {\n\t\treturn hasFormulaProperties;\n\t}\n\n\tpublic FetchMode getFetchMode(int i) {\n\t\treturn subclassPropertyFetchModeClosure[i];\n\t}\n\n\tpublic Type getSubclassPropertyType(int i) {\n\t\treturn subclassPropertyTypeClosure[i];\n\t}\n\n\t@Override\n\tpublic int countSubclassProperties() {\n\t\treturn subclassPropertyTypeClosure.length;\n\t}\n\n\t@Override\n\tpublic String[] getSubclassPropertyColumnNames(int i) {\n\t\treturn subclassPropertyColumnNameClosure[i];\n\t}\n\n\tpublic String[][] getSubclassPropertyFormulaTemplateClosure() {\n\t\treturn subclassPropertyFormulaTemplateClosure;\n\t}\n\n\tprotected Type[] getSubclassPropertyTypeClosure() {\n\t\treturn subclassPropertyTypeClosure;\n\t}\n\n\tprotected String[][] getSubclassPropertyColumnNameClosure() {\n\t\treturn subclassPropertyColumnNameClosure;\n\t}\n\n\tpublic String[][] getSubclassPropertyColumnReaderClosure() {\n\t\treturn subclassPropertyColumnReaderClosure;\n\t}\n\n\tpublic String[][] getSubclassPropertyColumnReaderTemplateClosure() {\n\t\treturn subclassPropertyColumnReaderTemplateClosure;\n\t}\n\n\tprotected String[] getSubclassPropertyNameClosure() {\n\t\treturn subclassPropertyNameClosure;\n\t}\n\n\tprivate static boolean isPrefix(final AttributeMapping attributeMapping, final String currentAttributeName) {\n\t\tfinal String attributeName = attributeMapping.getAttributeName();\n\t\tfinal int nameLength = attributeName.length();\n\t\treturn currentAttributeName.startsWith( attributeName )\n\t\t\t&& ( currentAttributeName.length() == nameLength || currentAttributeName.charAt(nameLength) == '.' );\n\t}\n\n\t@Override\n\tpublic int[] resolveAttributeIndexes(String[] attributeNames) {\n\t\tif ( attributeNames == null || attributeNames.length == 0 ) {\n\t\t\treturn ArrayHelper.EMPTY_INT_ARRAY;\n\t\t}\n\t\tfinal List<Integer> fields = new ArrayList<>( attributeNames.length );\n\n\t\t// Sort attribute names so that we can traverse mappings efficiently\n\t\tArrays.sort( attributeNames );\n\n\t\tint index = 0;\n\t\tfor ( int i = 0; i < attributeMappings.size(); i++ ) {\n\t\t\tfinal AttributeMapping attributeMapping = attributeMappings.get( i );\n\t\t\tif ( isPrefix( attributeMapping, attributeNames[index] ) ) {\n\t\t\t\tfields.add( attributeMapping.getStateArrayPosition() );\n\t\t\t\tindex++;\n\t\t\t\tif ( index < attributeNames.length ) {\n\t\t\t\t\t// Skip duplicates\n\t\t\t\t\tdo {\n\t\t\t\t\t\tif ( attributeNames[index].equals( attributeMapping.getAttributeName() ) ) {\n\t\t\t\t\t\t\tindex++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t} while ( index < attributeNames.length );\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn toIntArray( fields );\n\t}\n\n\t@Override\n\tpublic int[] resolveDirtyAttributeIndexes(\n\t\t\tfinal Object[] currentState,\n\t\t\tfinal Object[] previousState,\n\t\t\tfinal String[] attributeNames,\n\t\t\tfinal SessionImplementor session) {\n\t\tfinal BitSet mutablePropertiesIndexes = entityMetamodel.getMutablePropertiesIndexes();\n\t\tfinal int estimatedSize = attributeNames == null ? 0 : attributeNames.length + mutablePropertiesIndexes.cardinality();\n\t\tfinal List<Integer> fields = new ArrayList<>( estimatedSize );\n\t\tif ( estimatedSize == 0 ) {\n\t\t\treturn ArrayHelper.EMPTY_INT_ARRAY;\n\t\t}\n\t\tif ( !mutablePropertiesIndexes.isEmpty() ) {\n\t\t\t// We have to check the state for \"mutable\" properties as dirty tracking isn't aware of mutable types\n\t\t\tfinal Type[] propertyTypes = entityMetamodel.getPropertyTypes();\n\t\t\tfinal boolean[] propertyCheckability = entityMetamodel.getPropertyCheckability();\n\t\t\tfor ( int i = mutablePropertiesIndexes.nextSetBit(0); i >= 0;\n\t\t\t\t\ti = mutablePropertiesIndexes.nextSetBit(i + 1) ) {\n\t\t\t\t// This is kindly borrowed from org.hibernate.type.TypeHelper.findDirty\n\t\t\t\tif ( isDirty( currentState, previousState, propertyTypes, propertyCheckability, i, session ) ) {\n\t\t\t\t\tfields.add( i );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ( attributeNames.length != 0 ) {\n\t\t\tfinal boolean[] propertyUpdateability = entityMetamodel.getPropertyUpdateability();\n\t\t\tif ( superMappingType == null ) {\n\t\t\t\t/*\n\t\t\t\t\t\tSort attribute names so that we can traverse mappings efficiently\n\t\t\t\t\t\twe cannot do this when there is a supertype because given:\n\n\t\t\t\t\t\tclass SuperEntity {\n\t\t\t\t\t\t\tprivate String bSuper;\n\t\t\t\t\t\t\tprivate String aSuper;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tclass ChildEntity extends SuperEntity {\n\t\t\t\t\t\t\tprivate String aChild;\n\t\t\t\t\t\t\tprivate String bChild;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t`attributeMappings` contains { aSuper, bSuper, aChild, bChild\t}\n\t\t\t\t\t\twhile the sorted `attributeNames` { aChild, aSuper, bChild, bSuper }\n\t\t\t\t */\n\n\t\t\t\tArrays.sort( attributeNames );\n\t\t\t\tint index = 0;\n\t\t\t\tfor ( int i = 0; i < attributeMappings.size(); i++ ) {\n\t\t\t\t\tfinal AttributeMapping attributeMapping = attributeMappings.get( i );\n\t\t\t\t\tfinal String attributeName = attributeMapping.getAttributeName();\n\t\t\t\t\tif ( isPrefix( attributeMapping, attributeNames[index] ) ) {\n\t\t\t\t\t\tfinal int position = attributeMapping.getStateArrayPosition();\n\t\t\t\t\t\tif ( propertyUpdateability[position] && !fields.contains( position ) ) {\n\t\t\t\t\t\t\tfields.add( position );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tindex++;\n\t\t\t\t\t\tif ( index < attributeNames.length ) {\n\t\t\t\t\t\t\t// Skip duplicates\n\t\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\t\tif ( attributeNames[index].equals( attributeName ) ) {\n\t\t\t\t\t\t\t\t\tindex++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} while ( index < attributeNames.length );\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor ( String attributeName : attributeNames ) {\n\t\t\t\t\tfinal Integer index = entityMetamodel.getPropertyIndexOrNull( attributeName );\n\t\t\t\t\tif ( index != null && propertyUpdateability[index] && !fields.contains( index ) ) {\n\t\t\t\t\t\tfields.add( index );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn toIntArray( fields );\n\t}\n\n\tprivate boolean isDirty(\n\t\t\tObject[] currentState,\n\t\t\tObject[] previousState,\n\t\t\tType[] propertyTypes,\n\t\t\tboolean[] propertyCheckability,\n\t\t\tint i,\n\t\t\tSessionImplementor session) {\n\t\treturn currentState[i] != LazyPropertyInitializer.UNFETCHED_PROPERTY\n\t\t\t\t// Consider mutable properties as dirty if we don't have a previous state\n\t\t\t\t&& ( previousState == null\n\t\t\t\t\t\t|| previousState[i] == LazyPropertyInitializer.UNFETCHED_PROPERTY\n\t\t\t\t\t\t|| propertyCheckability[i]\n\t\t\t\t\t\t\t\t&& propertyTypes[i].isDirty(\n\t\t\t\t\t\t\t\t\t\tpreviousState[i],\n\t\t\t\t\t\t\t\t\t\tcurrentState[i],\n\t\t\t\t\t\t\t\t\t\tpropertyColumnUpdateable[i],\n\t\t\t\t\t\t\t\t\t\tsession\n\t\t\t\t\t\t\t\t)\n\t\t\t\t);\n\t}\n\n\t@Override\n\tpublic Object loadByUniqueKey(\n\t\t\tString propertyName,\n\t\t\tObject uniqueKey,\n\t\t\tSharedSessionContractImplementor session) throws HibernateException {\n\t\treturn loadByUniqueKey( propertyName, uniqueKey, null, session );\n\t}\n\n\tpublic Object loadByUniqueKey(\n\t\t\tString propertyName,\n\t\t\tObject uniqueKey,\n\t\t\tBoolean readOnly,\n\t\t\tSharedSessionContractImplementor session) throws HibernateException {\n\t\treturn getUniqueKeyLoader( propertyName, session ).load( uniqueKey, LockOptions.NONE, readOnly, session );\n\t}\n\n\tprivate Map<SingularAttributeMapping, SingleUniqueKeyEntityLoader<?>> uniqueKeyLoadersNew;\n\n\tprotected SingleUniqueKeyEntityLoader<?> getUniqueKeyLoader(String attributeName, SharedSessionContractImplementor session) {\n\t\tfinal SingularAttributeMapping attribute = (SingularAttributeMapping) findByPath( attributeName );\n\t\tfinal LoadQueryInfluencers influencers = session.getLoadQueryInfluencers();\n\t\t// no subselect fetching for entities for now\n\t\tif ( isAffectedByInfluencers( influencers, true ) ) {\n\t\t\treturn new SingleUniqueKeyEntityLoaderStandard<>(\n\t\t\t\t\tthis,\n\t\t\t\t\tattribute,\n\t\t\t\t\tinfluencers\n\t\t\t);\n\t\t}\n\t\tfinal SingleUniqueKeyEntityLoader<?> existing;\n\t\tif ( uniqueKeyLoadersNew == null ) {\n\t\t\tuniqueKeyLoadersNew = new ConcurrentHashMap<>();\n\t\t\texisting = null;\n\t\t}\n\t\telse {\n\t\t\texisting = uniqueKeyLoadersNew.get( attribute );\n\t\t}\n\n\t\tif ( existing != null ) {\n\t\t\treturn existing;\n\t\t}\n\t\telse {\n\t\t\tfinal SingleUniqueKeyEntityLoader<?> loader =\n\t\t\t\t\tnew SingleUniqueKeyEntityLoaderStandard<>( this, attribute, new LoadQueryInfluencers( factory ) );\n\t\t\tuniqueKeyLoadersNew.put( attribute, loader );\n\t\t\treturn loader;\n\t\t}\n\t}\n\n\t@Override\n\tpublic int getPropertyIndex(String propertyName) {\n\t\treturn entityMetamodel.getPropertyIndex( propertyName );\n\t}\n\n\tprivate void initOrdinaryPropertyPaths(Metadata mapping) throws MappingException {\n\t\tfor ( int i = 0; i < getSubclassPropertyNameClosure().length; i++ ) {\n\t\t\tpropertyMapping.initPropertyPaths(\n\t\t\t\t\tgetSubclassPropertyNameClosure()[i],\n\t\t\t\t\tgetSubclassPropertyTypeClosure()[i],\n\t\t\t\t\tgetSubclassPropertyColumnNameClosure()[i],\n\t\t\t\t\tgetSubclassPropertyColumnReaderClosure()[i],\n\t\t\t\t\tgetSubclassPropertyColumnReaderTemplateClosure()[i],\n\t\t\t\t\tgetSubclassPropertyFormulaTemplateClosure()[i],\n\t\t\t\t\tmapping\n\t\t\t);\n\t\t}\n\t}\n\n\tprivate void initIdentifierPropertyPaths(Metadata mapping) throws MappingException {\n\t\tString idProp = getIdentifierPropertyName();\n\t\tif ( idProp != null ) {\n\t\t\tpropertyMapping.initPropertyPaths(\n\t\t\t\t\tidProp, getIdentifierType(), getIdentifierColumnNames(),\n\t\t\t\t\tgetIdentifierColumnReaders(), getIdentifierColumnReaderTemplates(), null, mapping\n\t\t\t);\n\t\t}\n\t\tif ( entityMetamodel.getIdentifierProperty().isEmbedded() ) {\n\t\t\tpropertyMapping.initPropertyPaths(\n\t\t\t\t\tnull, getIdentifierType(), getIdentifierColumnNames(),\n\t\t\t\t\tgetIdentifierColumnReaders(), getIdentifierColumnReaderTemplates(), null, mapping\n\t\t\t);\n\t\t}\n\t\tif ( !entityMetamodel.hasNonIdentifierPropertyNamedId() ) {\n\t\t\tpropertyMapping.initPropertyPaths(\n\t\t\t\t\tENTITY_ID, getIdentifierType(), getIdentifierColumnNames(),\n\t\t\t\t\tgetIdentifierColumnReaders(), getIdentifierColumnReaderTemplates(), null, mapping\n\t\t\t);\n\t\t}\n\t}\n\n\tprivate void initDiscriminatorPropertyPath(Metadata mapping) {\n\t\tpropertyMapping.initPropertyPaths(\n\t\t\t\tENTITY_CLASS,\n\t\t\t\tgetDiscriminatorType(),\n\t\t\t\tnew String[] {getDiscriminatorColumnName()},\n\t\t\t\tnew String[] {getDiscriminatorColumnReaders()},\n\t\t\t\tnew String[] {getDiscriminatorColumnReaderTemplate()},\n\t\t\t\tnew String[] {getDiscriminatorFormulaTemplate()},\n\t\t\t\tmapping\n\t\t);\n\t}\n\n\tprotected void initPropertyPaths(Metadata mapping) throws MappingException {\n\t\tinitOrdinaryPropertyPaths( mapping );\n\t\tinitOrdinaryPropertyPaths( mapping ); //do two passes, for collection property-ref!\n\t\tinitIdentifierPropertyPaths( mapping );\n\t\tif ( entityMetamodel.isPolymorphic() ) {\n\t\t\tinitDiscriminatorPropertyPath( mapping );\n\t\t}\n\t}\n\n\tprotected boolean check(\n\t\t\tint rows,\n\t\t\tObject id,\n\t\t\tint tableNumber,\n\t\t\tExpectation expectation,\n\t\t\tPreparedStatement statement,\n\t\t\tString statementSQL) throws HibernateException {\n\t\ttry {\n\t\t\texpectation.verifyOutcome( rows, statement, -1, statementSQL );\n\t\t}\n\t\tcatch ( StaleStateException e ) {\n\t\t\tif ( !isNullableTable( tableNumber ) ) {\n\t\t\t\tfinal StatisticsImplementor statistics = getFactory().getStatistics();\n\t\t\t\tif ( statistics.isStatisticsEnabled() ) {\n\t\t\t\t\tstatistics.optimisticFailure( getEntityName() );\n\t\t\t\t}\n\t\t\t\tthrow new StaleObjectStateException( getEntityName(), id );\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\tcatch ( TooManyRowsAffectedException e ) {\n\t\t\tthrow new HibernateException(\n\t\t\t\t\t\"Duplicate identifier in table for: \" +\n\t\t\t\t\t\t\tinfoString( this, id, getFactory() )\n\t\t\t);\n\t\t}\n\t\tcatch ( Throwable t ) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\tpublic final boolean checkVersion(final boolean[] includeProperty) {\n\t\treturn includeProperty[getVersionProperty()] || isVersionGeneratedOnExecution();\n\t}\n\n\t@Override\n\tpublic String getIdentitySelectString() {\n\t\treturn identitySelectString;\n\t}\n\n\t@Override\n\tpublic String getSelectByUniqueKeyString(String propertyName) {\n\t\treturn getSelectByUniqueKeyString( new String[] { propertyName } );\n\t}\n\n\t@Override\n\tpublic String getSelectByUniqueKeyString(String[] propertyNames) {\n\t\tfinal SimpleSelect select = new SimpleSelect( getFactory() )\n\t\t\t\t.setTableName( getTableName(0) )\n\t\t\t\t.addColumns( getKeyColumns(0) );\n\t\tfor ( int i = 0; i < propertyNames.length; i++ ) {\n\t\t\tselect.addRestriction( getPropertyColumnNames( propertyNames[i] ) );\n\t\t}\n\t\treturn select.toStatementString();\n\t}\n\n\t@Override\n\tpublic String getSelectByUniqueKeyString(String[] propertyNames, String[] columnNames) {\n\t\tfinal SimpleSelect select = new SimpleSelect( getFactory() )\n\t\t\t\t.setTableName( getTableName( 0 ) )\n\t\t\t\t.addColumns( columnNames );\n\t\tfor ( final String propertyName : propertyNames ) {\n\t\t\tselect.addRestriction( getPropertyColumnNames( propertyName ) );\n\t\t}\n\t\treturn select.toStatementString();\n\t}\n\n\t@Override\n\tpublic GeneratedValuesMutationDelegate getInsertDelegate() {\n\t\treturn insertDelegate;\n\t}\n\n\t@Override\n\tpublic GeneratedValuesMutationDelegate getUpdateDelegate() {\n\t\treturn updateDelegate;\n\t}\n\n\t@Override\n\tpublic EntityTableMapping[] getTableMappings() {\n\t\treturn tableMappings;\n\t}\n\n\tprotected EntityTableMapping getTableMapping(int i) {\n\t\treturn tableMappings[i];\n\t}\n\n\t/**\n\t * Unfortunately we cannot directly use `SelectableMapping#getContainingTableExpression()`\n\t * as that blows up for attributes declared on super-type for union-subclass mappings\n\t */\n\t@Override\n\tpublic String physicalTableNameForMutation(SelectableMapping selectableMapping) {\n\t\tassert !selectableMapping.isFormula();\n\t\treturn selectableMapping.getContainingTableExpression();\n\t}\n\n\t@Override\n\tpublic EntityMappingType getTargetPart() {\n\t\treturn this;\n\t}\n\n\t@Override\n\tpublic void forEachMutableTable(Consumer<EntityTableMapping> consumer) {\n\t\tfor ( int i = 0; i < tableMappings.length; i++ ) {\n\t\t\t// inverse tables are not mutable from this mapping\n\t\t\tif ( !tableMappings[i].isInverse() ) {\n\t\t\t\tconsumer.accept( tableMappings[i] );\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic void forEachMutableTableReverse(Consumer<EntityTableMapping> consumer) {\n\t\tfor ( int i = tableMappings.length - 1; i >= 0; i-- ) {\n\t\t\t// inverse tables are not mutable from this mapping\n\t\t\tif ( !tableMappings[i].isInverse() ) {\n\t\t\t\tconsumer.accept( tableMappings[i] );\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic String getIdentifierTableName() {\n\t\treturn getTableName( 0 );\n\t}\n\n\t@Override\n\tpublic EntityTableMapping getIdentifierTableMapping() {\n\t\treturn tableMappings[0];\n\t}\n\n\t@Override\n\tpublic ModelPart getIdentifierDescriptor() {\n\t\treturn identifierMapping;\n\t}\n\n\t@Override\n\tpublic boolean hasSkippableTables() {\n\t\treturn false;\n\t}\n\n\tprotected boolean hasAnySkippableTables(boolean[] optionalTables, boolean[] inverseTables) {\n\t\t// todo (6.x) : cache this?\n\t\tfor ( int i = 0; i < optionalTables.length; i++ ) {\n\t\t\tif ( optionalTables[i] ) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\tfor ( int i = 0; i < inverseTables.length; i++ ) {\n\t\t\tif ( inverseTables[i] ) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tprotected void logStaticSQL() {\n\t\tif ( LOG.isDebugEnabled() ) {\n\t\t\tLOG.debugf( \"Static SQL for entity: %s\", getEntityName() );\n\t\t\tfor ( Map.Entry<String, SingleIdArrayLoadPlan> entry : lazyLoadPlanByFetchGroup.entrySet() ) {\n\t\t\t\tLOG.debugf( \" Lazy select (%s) : %s\", entry.getKey(), entry.getValue().getJdbcSelect().getSqlString() );\n\t\t\t}\n\t\t\tif ( sqlVersionSelectString != null ) {\n\t\t\t\tLOG.debugf( \" Version select: %s\", sqlVersionSelectString );\n\t\t\t}\n\n\t\t\t{\n\t\t\t\tfinal MutationOperationGroup staticInsertGroup = insertCoordinator.getStaticMutationOperationGroup();\n\t\t\t\tif ( staticInsertGroup != null ) {\n\t\t\t\t\tfor ( int i = 0; i < staticInsertGroup.getNumberOfOperations(); i++ ) {\n\t\t\t\t\t\tfinal MutationOperation mutation = staticInsertGroup.getOperation( i );\n\t\t\t\t\t\tif ( mutation instanceof JdbcOperation ) {\n\t\t\t\t\t\t\tLOG.debugf( \" Insert (%s): %s\", i, ( (JdbcOperation) mutation ).getSqlString() );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t{\n\t\t\t\tfinal MutationOperationGroup staticUpdateGroup = updateCoordinator.getStaticMutationOperationGroup();\n\t\t\t\tif ( staticUpdateGroup != null ) {\n\t\t\t\t\tfor ( int i = 0; i < staticUpdateGroup.getNumberOfOperations(); i++ ) {\n\t\t\t\t\t\tfinal MutationOperation mutation = staticUpdateGroup.getOperation( i );\n\t\t\t\t\t\tif ( mutation instanceof JdbcOperation ) {\n\t\t\t\t\t\t\tLOG.debugf( \" Update (%s): %s\", i, ( (JdbcOperation) mutation ).getSqlString() );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t{\n\t\t\t\tfinal MutationOperationGroup staticDeleteGroup = deleteCoordinator.getStaticMutationOperationGroup();\n\t\t\t\tif ( staticDeleteGroup != null ) {\n\t\t\t\t\tfor ( int i = 0; i < staticDeleteGroup.getNumberOfOperations(); i++ ) {\n\t\t\t\t\t\tfinal MutationOperation mutation = staticDeleteGroup.getOperation( i );\n\t\t\t\t\t\tif ( mutation instanceof JdbcOperation ) {\n\t\t\t\t\t\t\tLOG.debugf( \" Delete (%s): %s\", i, ( (JdbcOperation) mutation ).getSqlString() );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic abstract Map<Object, String> getSubclassByDiscriminatorValue();\n\n\tpublic abstract String[] getConstraintOrderedTableNameClosure();\n\n\tpublic abstract boolean needsDiscriminator();\n\n\tprotected boolean isDiscriminatorFormula() {\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic TableGroup createRootTableGroup(\n\t\t\tboolean canUseInnerJoins,\n\t\t\tNavigablePath navigablePath,\n\t\t\tString explicitSourceAlias,\n\t\t\tSqlAliasBase explicitSqlAliasBase,\n\t\t\tSupplier<Consumer<Predicate>> additionalPredicateCollectorAccess,\n\t\t\tSqlAstCreationState creationState) {\n\t\tfinal SqlAliasBase sqlAliasBase = SqlAliasBase.from(\n\t\t\t\texplicitSqlAliasBase,\n\t\t\t\texplicitSourceAlias,\n\t\t\t\tthis,\n\t\t\t\tcreationState.getSqlAliasBaseGenerator()\n\t\t);\n\t\tfinal TableReference rootTableReference = new NamedTableReference(\n\t\t\t\tneedsDiscriminator() ? getRootTableName() : getTableName(),\n\t\t\t\tsqlAliasBase.generateNewAlias()\n\t\t);\n\n\t\tfinal TableGroup tableGroup = new StandardTableGroup(\n\t\t\t\tcanUseInnerJoins,\n\t\t\t\tnavigablePath,\n\t\t\t\tthis,\n\t\t\t\texplicitSourceAlias,\n\t\t\t\trootTableReference,\n\t\t\t\ttrue,\n\t\t\t\tsqlAliasBase,\n\t\t\t\tgetRootEntityDescriptor()::containsTableReference,\n\t\t\t\t(tableExpression, tg) -> {\n\t\t\t\t\tfinal String[] subclassTableNames = getSubclassTableNames();\n\t\t\t\t\tfor ( int i = 0; i < subclassTableNames.length; i++ ) {\n\t\t\t\t\t\tif ( tableExpression.equals( subclassTableNames[ i ] ) ) {\n\t\t\t\t\t\t\tfinal NamedTableReference joinedTableReference = new NamedTableReference(\n\t\t\t\t\t\t\t\t\ttableExpression,\n\t\t\t\t\t\t\t\t\tsqlAliasBase.generateNewAlias(),\n\t\t\t\t\t\t\t\t\tisNullableSubclassTable( i )\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\treturn new TableReferenceJoin(\n\t\t\t\t\t\t\t\t\tshouldInnerJoinSubclassTable( i, emptySet() ),\n\t\t\t\t\t\t\t\t\tjoinedTableReference,\n\t\t\t\t\t\t\t\t\tadditionalPredicateCollectorAccess == null\n\t\t\t\t\t\t\t\t\t\t\t? null\n\t\t\t\t\t\t\t\t\t\t\t: generateJoinPredicate(\n\t\t\t\t\t\t\t\t\t\t\t\t\trootTableReference,\n\t\t\t\t\t\t\t\t\t\t\t\t\tjoinedTableReference,\n\t\t\t\t\t\t\t\t\t\t\t\t\tneedsDiscriminator()\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t? getRootTableKeyColumnNames()\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t: getIdentifierColumnNames(),\n\t\t\t\t\t\t\t\t\t\t\t\t\tgetSubclassTableKeyColumns( i ),\n\t\t\t\t\t\t\t\t\t\t\t\t\tcreationState\n\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn null;\n\t\t\t\t},\n\t\t\t\tgetFactory()\n\t\t);\n\n\t\tif ( additionalPredicateCollectorAccess != null ) {\n\t\t\tif ( needsDiscriminator() ) {\n\t\t\t\tfinal String alias = tableGroup.getPrimaryTableReference().getIdentificationVariable();\n\t\t\t\tfinal Predicate discriminatorPredicate = createDiscriminatorPredicate( alias, tableGroup, creationState );\n\t\t\t\tadditionalPredicateCollectorAccess.get().accept( discriminatorPredicate );\n\t\t\t}\n\n\t\t\tif ( softDeleteMapping != null ) {\n\t\t\t\tfinal TableReference tableReference = tableGroup.resolveTableReference( getSoftDeleteTableDetails().getTableName() );\n\t\t\t\tfinal Predicate softDeletePredicate = SoftDeleteHelper.createNonSoftDeletedRestriction(\n\t\t\t\t\t\ttableReference,\n\t\t\t\t\t\tsoftDeleteMapping,\n\t\t\t\t\t\tcreationState.getSqlExpressionResolver()\n\t\t\t\t);\n\t\t\t\tadditionalPredicateCollectorAccess.get().accept( softDeletePredicate );\n\t\t\t\tif ( tableReference != rootTableReference && creationState.supportsEntityNameUsage() ) {\n\t\t\t\t\t// Register entity name usage for the hierarchy root table to avoid pruning\n\t\t\t\t\tcreationState.registerEntityNameUsage( tableGroup, EntityNameUse.EXPRESSION, getRootEntityName() );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn tableGroup;\n\t}\n\n\t@Override\n\tpublic void applyDiscriminator(\n\t\t\tConsumer<Predicate> predicateConsumer,\n\t\t\tString alias,\n\t\t\tTableGroup tableGroup,\n\t\t\tSqlAstCreationState creationState) {\n\t\tif ( needsDiscriminator() ) {\n\t\t\tassert !creationState.supportsEntityNameUsage() : \"Entity name usage should have been used instead\";\n\t\t\tfinal Map<String, EntityNameUse> entityNameUseMap;\n\t\t\tfinal Collection<EntityMappingType> subMappingTypes = getSubMappingTypes();\n\t\t\tentityNameUseMap = new HashMap<>( 1 + subMappingTypes.size() + ( isInherited() ? 1 : 0 ) );\n\t\t\tif ( subMappingTypes.isEmpty() ) {\n\t\t\t\tentityNameUseMap.put( getEntityName(), EntityNameUse.TREAT );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tentityNameUseMap.put( getEntityName(), EntityNameUse.TREAT );\n\t\t\t\t// We need to register TREAT uses for all subtypes when pruning\n\t\t\t\tfor ( EntityMappingType subMappingType : subMappingTypes ) {\n\t\t\t\t\tentityNameUseMap.put( subMappingType.getEntityName(), EntityNameUse.TREAT );\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( isInherited() ) {\n\t\t\t\t// Make sure the table group includes the root table when needed for TREAT\n\t\t\t\ttableGroup.resolveTableReference( getRootTableName() );\n\t\t\t\tentityNameUseMap.put( getRootEntityName(), EntityNameUse.EXPRESSION );\n\t\t\t}\n\t\t\tpruneForSubclasses( tableGroup, entityNameUseMap );\n\t\t}\n\t}\n\n\tprivate Predicate createDiscriminatorPredicate(\n\t\t\tString alias,\n\t\t\tTableGroup tableGroup,\n\t\t\tSqlAstCreationState creationState) {\n\t\tfinal SqlExpressionResolver.ColumnReferenceKey columnReferenceKey;\n\t\tfinal String discriminatorExpression;\n\t\tif ( isDiscriminatorFormula() ) {\n\t\t\tdiscriminatorExpression = getDiscriminatorFormulaTemplate();\n\t\t\tcolumnReferenceKey = createColumnReferenceKey(\n\t\t\t\t\ttableGroup.getPrimaryTableReference(),\n\t\t\t\t\tgetDiscriminatorFormulaTemplate(),\n\t\t\t\t\tgetDiscriminatorType()\n\t\t\t);\n\t\t}\n\t\telse {\n\t\t\tdiscriminatorExpression = getDiscriminatorColumnName();\n\t\t\tcolumnReferenceKey = createColumnReferenceKey(\n\t\t\t\t\ttableGroup.getPrimaryTableReference(),\n\t\t\t\t\tgetDiscriminatorColumnName(),\n\t\t\t\t\tgetDiscriminatorType()\n\t\t\t);\n\t\t}\n\n\t\tfinal BasicType<?> discriminatorType = (BasicType<?>) getDiscriminatorMapping().getJdbcMapping();\n\t\tfinal Expression sqlExpression = creationState.getSqlExpressionResolver().resolveSqlExpression(\n\t\t\t\tcolumnReferenceKey,\n\t\t\t\tsqlAstProcessingState -> new ColumnReference(\n\t\t\t\t\t\talias,\n\t\t\t\t\t\tdiscriminatorExpression,\n\t\t\t\t\t\tisDiscriminatorFormula(),\n\t\t\t\t\t\tnull,\n\t\t\t\t\t\tdiscriminatorType.getJdbcMapping()\n\t\t\t\t)\n\t\t);\n\n\t\treturn createDisciminatorPredicate( discriminatorType, sqlExpression );\n\t}\n\n\tprivate Predicate createDisciminatorPredicate(BasicType<?> discriminatorType, Expression sqlExpression) {\n\t\tif ( hasSubclasses() ) {\n\t\t\treturn createInListPredicate( discriminatorType, sqlExpression );\n\t\t}\n\t\telse {\n\t\t\tfinal Object value = getDiscriminatorValue();\n\t\t\tif ( value == NULL_DISCRIMINATOR ) {\n\t\t\t\treturn new NullnessPredicate( sqlExpression );\n\t\t\t}\n\t\t\telse if ( value == NOT_NULL_DISCRIMINATOR ) {\n\t\t\t\treturn new NullnessPredicate( sqlExpression, true );\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn new ComparisonPredicate( sqlExpression, ComparisonOperator.EQUAL,\n\t\t\t\t\t\tnew QueryLiteral<>( value, discriminatorType ) );\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate Predicate createInListPredicate(BasicType<?> discriminatorType, Expression sqlExpression) {\n\t\tboolean hasNull = false, hasNonNull = false;\n\t\tfor ( Object discriminatorValue : fullDiscriminatorValues ) {\n\t\t\tif ( discriminatorValue == NULL_DISCRIMINATOR ) {\n\t\t\t\thasNull = true;\n\t\t\t}\n\t\t\telse if ( discriminatorValue == NOT_NULL_DISCRIMINATOR ) {\n\t\t\t\thasNonNull = true;\n\t\t\t}\n\t\t}\n\t\tif ( hasNull && hasNonNull ) {\n\t\t\t// This means we need to select all rows,\n\t\t\t// and so we don't need a predicate at all\n\t\t\t// Just return an empty Junction\n\t\t\treturn new Junction( Junction.Nature.DISJUNCTION );\n\t\t}\n\t\telse if ( hasNonNull ) {\n\t\t\t// we need every row with a non-null discriminator\n\t\t\treturn new NullnessPredicate( sqlExpression, true );\n\t\t}\n\t\telse if ( hasNull ) {\n\t\t\tfinal Junction junction = new Junction( Junction.Nature.DISJUNCTION );\n\t\t\tjunction.add( new NullnessPredicate( sqlExpression ) );\n\t\t\tjunction.add( discriminatorValuesPredicate( discriminatorType, sqlExpression ) );\n\t\t\treturn junction;\n\t\t}\n\t\telse {\n\t\t\treturn discriminatorValuesPredicate( discriminatorType, sqlExpression );\n\t\t}\n\t}\n\n\tprivate InListPredicate discriminatorValuesPredicate(BasicType<?> discriminatorType, Expression sqlExpression) {\n\t\tfinal List<Expression> values = new ArrayList<>( fullDiscriminatorValues.length );\n\t\tfor ( Object discriminatorValue : fullDiscriminatorValues ) {\n\t\t\tif ( !(discriminatorValue instanceof MarkerObject) ) {\n\t\t\t\tvalues.add( new QueryLiteral<>( discriminatorValue, discriminatorType) );\n\t\t\t}\n\t\t}\n\t\treturn new InListPredicate( sqlExpression, values);\n\t}\n\n\tprotected String getPrunedDiscriminatorPredicate(\n\t\t\tMap<String, EntityNameUse> entityNameUses,\n\t\t\tMappingMetamodelImplementor mappingMetamodel,\n\t\t\tString alias) {\n\t\tfinal InFragment fragment = new InFragment();\n\t\tif ( isDiscriminatorFormula() ) {\n\t\t\tfragment.setFormula( alias, getDiscriminatorFormulaTemplate() );\n\t\t}\n\t\telse {\n\t\t\tfragment.setColumn( alias, getDiscriminatorColumnName() );\n\t\t}\n\t\tboolean containsNotNull = false;\n\t\tfor ( Map.Entry<String, EntityNameUse> entry : entityNameUses.entrySet() ) {\n\t\t\tfinal EntityNameUse.UseKind useKind = entry.getValue().getKind();\n\t\t\tif ( useKind == EntityNameUse.UseKind.PROJECTION || useKind == EntityNameUse.UseKind.EXPRESSION ) {\n\t\t\t\t// We only care about treat and filter uses which allow to reduce the amount of rows to select\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfinal EntityPersister persister = mappingMetamodel.getEntityDescriptor( entry.getKey() );\n\t\t\t// Filtering for abstract entities makes no sense, so ignore that\n\t\t\t// Also, it makes no sense to filter for any of the super types,\n\t\t\t// as the query will contain a filter for that already anyway\n\t\t\tif ( !persister.isAbstract() && ( this == persister || !isTypeOrSuperType( persister ) ) ) {\n\t\t\t\tcontainsNotNull = containsNotNull || InFragment.NOT_NULL.equals( persister.getDiscriminatorSQLValue() );\n\t\t\t\tfragment.addValue( persister.getDiscriminatorSQLValue() );\n\t\t\t}\n\t\t}\n\t\tfinal AbstractEntityPersister rootEntityDescriptor = (AbstractEntityPersister) getRootEntityDescriptor();\n\t\tfinal List<String> discriminatorSQLValues = Arrays.asList( rootEntityDescriptor.fullDiscriminatorSQLValues );\n\t\tif ( fragment.getValues().size() == discriminatorSQLValues.size() ) {\n\t\t\t// Nothing to prune if we filter for all subtypes\n\t\t\treturn null;\n\t\t}\n\n\t\tif ( containsNotNull ) {\n\t\t\tfinal String lhs;\n\t\t\tif ( isDiscriminatorFormula() ) {\n\t\t\t\tlhs = StringHelper.replace( getDiscriminatorFormulaTemplate(), Template.TEMPLATE, alias );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlhs = qualifyConditionally( alias, getDiscriminatorColumnName() );\n\t\t\t}\n\t\t\tfinal List<String> actualDiscriminatorSQLValues = new ArrayList<>( discriminatorSQLValues.size() );\n\t\t\tfor ( String value : discriminatorSQLValues ) {\n\t\t\t\tif ( !fragment.getValues().contains( value ) && !InFragment.NULL.equals( value ) ) {\n\t\t\t\t\tactualDiscriminatorSQLValues.add( value );\n\t\t\t\t}\n\t\t\t}\n\t\t\tfinal StringBuilder sb = new StringBuilder( 70 + actualDiscriminatorSQLValues.size() * 10 ).append( \" or \" );\n\t\t\tif ( !actualDiscriminatorSQLValues.isEmpty() ) {\n\t\t\t\tsb.append( lhs ).append( \" is not in (\" );\n\t\t\t\tsb.append( String.join( \",\", actualDiscriminatorSQLValues ) );\n\t\t\t\tsb.append( \") and \" );\n\t\t\t}\n\t\t\tsb.append( lhs ).append( \" is not null\" );\n\t\t\tfragment.getValues().remove( InFragment.NOT_NULL );\n\t\t\treturn fragment.toFragmentString() + sb;\n\t\t}\n\t\telse {\n\t\t\treturn fragment.toFragmentString();\n\t\t}\n\t}\n\n\t@Override\n\tpublic void applyFilterRestrictions(\n\t\t\tConsumer<Predicate> predicateConsumer,\n\t\t\tTableGroup tableGroup,\n\t\t\tboolean useQualifier,\n\t\t\tMap<String, Filter> enabledFilters,\n\t\t\tboolean onlyApplyLoadByKeyFilters,\n\t\t\tSqlAstCreationState creationState) {\n\t\tif ( filterHelper != null ) {\n\t\t\tfinal FilterAliasGenerator filterAliasGenerator = useQualifier && tableGroup != null\n\t\t\t\t\t? getFilterAliasGenerator( tableGroup )\n\t\t\t\t\t: null;\n\t\t\tfilterHelper.applyEnabledFilters(\n\t\t\t\t\tpredicateConsumer,\n\t\t\t\t\tfilterAliasGenerator,\n\t\t\t\t\tenabledFilters,\n\t\t\t\t\tonlyApplyLoadByKeyFilters,\n\t\t\t\t\ttableGroup,\n\t\t\t\t\tcreationState\n\t\t\t);\n\t\t}\n\t}\n\n\t@Override\n\tpublic void applyBaseRestrictions(\n\t\t\tConsumer<Predicate> predicateConsumer,\n\t\t\tTableGroup tableGroup, boolean useQualifier,\n\t\t\tMap<String, Filter> enabledFilters,\n\t\t\tboolean onlyApplyLoadByKeyFilters,\n\t\t\tSet<String> treatAsDeclarations,\n\t\t\tSqlAstCreationState creationState) {\n\t\tapplyFilterRestrictions(\n\t\t\t\tpredicateConsumer,\n\t\t\t\ttableGroup,\n\t\t\t\tuseQualifier,\n\t\t\t\tenabledFilters,\n\t\t\t\tonlyApplyLoadByKeyFilters,\n\t\t\t\tcreationState\n\t\t);\n\t\tapplyWhereRestrictions( predicateConsumer, tableGroup, useQualifier, creationState );\n\t}\n\n\t@Override\n\tpublic boolean hasWhereRestrictions() {\n\t\treturn sqlWhereStringTemplate != null;\n\t}\n\n\t@Override\n\tpublic void applyWhereRestrictions(\n\t\t\tConsumer<Predicate> predicateConsumer,\n\t\t\tTableGroup tableGroup,\n\t\t\tboolean useQualifier,\n\t\t\tSqlAstCreationState creationState) {\n\t\tif ( sqlWhereStringTemplate != null ) {\n\t\t\tfinal String alias = getAliasInWhere( tableGroup, useQualifier );\n\t\t\tfinal String fragment = StringHelper.replace( sqlWhereStringTemplate, Template.TEMPLATE, alias );\n\t\t\tpredicateConsumer.accept( new SqlFragmentPredicate( fragment ) );\n\t\t}\n\t}\n\n\tprivate String getAliasInWhere(TableGroup tableGroup, boolean useQualifier) {\n\t\tif ( tableGroup == null ) {\n\t\t\treturn null;\n\t\t}\n\t\telse {\n\t\t\tfinal TableReference tableReference = tableGroup.resolveTableReference( sqlWhereStringTableExpression );\n\t\t\tif ( tableReference == null ) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn useQualifier && tableReference.getIdentificationVariable() != null\n\t\t\t\t\t\t? tableReference.getIdentificationVariable()\n\t\t\t\t\t\t: tableReference.getTableId();\n\t\t\t}\n\t\t}\n\t}\n\n\tprotected boolean shouldInnerJoinSubclassTable(int subclassTableNumber, Set<String> treatAsDeclarations) {\n\t\tif ( isClassOrSuperclassJoin( subclassTableNumber ) ) {\n\t\t\t// the table is either this persister's driving table or (one of) its superclass persister's driving\n\t\t\t// tables which can be inner joined as long as the `shouldInnerJoin` condition resolves to true\n\t\t\treturn !isInverseTable( subclassTableNumber )\n\t\t\t\t&& !isNullableTable( subclassTableNumber );\n\t\t}\n\n\t\t// otherwise we have a subclass table and need to look a little deeper...\n\n\t\t// IMPL NOTE : By default includeSubclasses indicates that all subclasses should be joined and that each\n\t\t// subclass ought to be joined by outer-join.  However, TREAT-AS always requires that an inner-join be used\n\t\t// so we give TREAT-AS higher precedence...\n\n\t\treturn isSubclassTableIndicatedByTreatAsDeclarations( subclassTableNumber, treatAsDeclarations );\n\t}\n\n\tprotected boolean isSubclassTableIndicatedByTreatAsDeclarations(int subclassTableNumber, Set<String> treatAsDeclarations) {\n\t\treturn false;\n\t}\n\n\t/**\n\t * Post-construct is a callback for AbstractEntityPersister subclasses to call after they are all done with their\n\t * constructor processing.  It allows AbstractEntityPersister to extend its construction after all subclass-specific\n\t * details have been handled.\n\t *\n\t * @param mapping The mapping\n\t *\n\t * @throws MappingException Indicates a problem accessing the Mapping\n\t */\n\tprotected void postConstruct(Metadata mapping) throws MappingException {\n\t\tinitPropertyPaths( mapping );\n\t}\n\n\t@Override\n\tpublic void prepareLoaders() {\n\t\t// Hibernate Reactive needs to override the loaders\n\t\tsingleIdLoader = buildSingleIdEntityLoader();\n\t\tmultiIdLoader = buildMultiIdLoader();\n\n\t\tlazyLoadPlanByFetchGroup = getLazyLoadPlanByFetchGroup();\n\n\t\tlogStaticSQL();\n\t}\n\n\tprivate void doLateInit() {\n\t\ttableMappings = buildTableMappings();\n\n\t\tfinal List<AttributeMapping> insertGeneratedAttributes = hasInsertGeneratedProperties() ?\n\t\t\t\tGeneratedValuesProcessor.getGeneratedAttributes( this, INSERT )\n\t\t\t\t: Collections.emptyList();\n\t\tfinal List<AttributeMapping> updateGeneratedAttributes = hasUpdateGeneratedProperties() ?\n\t\t\t\tGeneratedValuesProcessor.getGeneratedAttributes( this, UPDATE )\n\t\t\t\t: Collections.emptyList();\n\n\t\tinsertGeneratedProperties = initInsertGeneratedProperties( insertGeneratedAttributes );\n\t\tupdateGeneratedProperties = initUpdateGeneratedProperties( updateGeneratedAttributes );\n\n\t\tinsertDelegate = createInsertDelegate();\n\t\tupdateDelegate = createUpdateDelegate();\n\n\t\tif ( isIdentifierAssignedByInsert() ) {\n\t\t\tidentitySelectString = getIdentitySelectString( factory.getJdbcServices().getDialect() );\n\t\t}\n\n\t\tif ( hasInsertGeneratedProperties() ) {\n\t\t\tinsertGeneratedValuesProcessor = createGeneratedValuesProcessor( INSERT, insertGeneratedAttributes );\n\t\t}\n\t\tif ( hasUpdateGeneratedProperties() ) {\n\t\t\tupdateGeneratedValuesProcessor = createGeneratedValuesProcessor( UPDATE, updateGeneratedAttributes );\n\t\t}\n\n\t\tinsertCoordinator = buildInsertCoordinator();\n\t\tupdateCoordinator = buildUpdateCoordinator();\n\t\tdeleteCoordinator = buildDeleteCoordinator();\n\t\tmergeCoordinator = buildMergeCoordinator();\n\n\t\t//select SQL\n\t\tsqlVersionSelectString = generateSelectVersionString();\n\t}\n\n\tprotected GeneratedValuesMutationDelegate createInsertDelegate() {\n\t\tif ( isIdentifierAssignedByInsert() ) {\n\t\t\tfinal OnExecutionGenerator generator = (OnExecutionGenerator) getGenerator();\n\t\t\treturn generator.getGeneratedIdentifierDelegate( this );\n\t\t}\n\t\treturn GeneratedValuesHelper.getGeneratedValuesDelegate( this, INSERT );\n\t}\n\n\tprotected GeneratedValuesMutationDelegate createUpdateDelegate() {\n\t\treturn GeneratedValuesHelper.getGeneratedValuesDelegate( this, UPDATE );\n\t}\n\n\tprivate static class TableMappingBuilder {\n\t\tprivate final String tableName;\n\t\tprivate final int relativePosition;\n\t\tprivate final EntityTableMapping.KeyMapping keyMapping;\n\t\tprivate final boolean isOptional;\n\t\tprivate final boolean isInverse;\n\t\tprivate final boolean isIdentifierTable;\n\n\t\tprivate final Expectation insertExpectation;\n\t\tprivate final String customInsertSql;\n\t\tprivate final boolean insertCallable;\n\n\t\tprivate final Expectation updateExpectation;\n\t\tprivate final String customUpdateSql;\n\t\tprivate final boolean updateCallable;\n\n\t\tprivate final boolean cascadeDeleteEnabled;\n\t\tprivate final Expectation deleteExpectation;\n\t\tprivate final String customDeleteSql;\n\t\tprivate final boolean deleteCallable;\n\t\tprivate final boolean dynamicUpdate;\n\t\tprivate final boolean dynamicInsert;\n\n\t\tprivate final List<Integer> attributeIndexes = new ArrayList<>();\n\n\t\tpublic TableMappingBuilder(\n\t\t\t\tString tableName,\n\t\t\t\tint relativePosition,\n\t\t\t\tEntityTableMapping.KeyMapping keyMapping,\n\t\t\t\tboolean isOptional,\n\t\t\t\tboolean isInverse,\n\t\t\t\tboolean isIdentifierTable,\n\t\t\t\tExpectation insertExpectation,\n\t\t\t\tString customInsertSql,\n\t\t\t\tboolean insertCallable,\n\t\t\t\tExpectation updateExpectation,\n\t\t\t\tString customUpdateSql,\n\t\t\t\tboolean updateCallable,\n\t\t\t\tboolean cascadeDeleteEnabled,\n\t\t\t\tExpectation deleteExpectation,\n\t\t\t\tString customDeleteSql,\n\t\t\t\tboolean deleteCallable,\n\t\t\t\tboolean dynamicUpdate,\n\t\t\t\tboolean dynamicInsert) {\n\t\t\tthis.tableName = tableName;\n\t\t\tthis.relativePosition = relativePosition;\n\t\t\tthis.keyMapping = keyMapping;\n\t\t\tthis.isOptional = isOptional;\n\t\t\tthis.isInverse = isInverse;\n\t\t\tthis.isIdentifierTable = isIdentifierTable;\n\t\t\tthis.insertExpectation = insertExpectation;\n\t\t\tthis.customInsertSql = customInsertSql;\n\t\t\tthis.insertCallable = insertCallable;\n\t\t\tthis.updateExpectation = updateExpectation;\n\t\t\tthis.customUpdateSql = customUpdateSql;\n\t\t\tthis.updateCallable = updateCallable;\n\t\t\tthis.cascadeDeleteEnabled = cascadeDeleteEnabled;\n\t\t\tthis.deleteExpectation = deleteExpectation;\n\t\t\tthis.customDeleteSql = customDeleteSql;\n\t\t\tthis.deleteCallable = deleteCallable;\n\t\t\tthis.dynamicUpdate = dynamicUpdate;\n\t\t\tthis.dynamicInsert = dynamicInsert;\n\t\t}\n\n\t\tprivate EntityTableMapping build() {\n\t\t\treturn new EntityTableMapping(\n\t\t\t\t\ttableName,\n\t\t\t\t\trelativePosition,\n\t\t\t\t\tkeyMapping,\n\t\t\t\t\tisOptional,\n\t\t\t\t\tisInverse,\n\t\t\t\t\tisIdentifierTable,\n\t\t\t\t\ttoIntArray( attributeIndexes ),\n\t\t\t\t\tinsertExpectation,\n\t\t\t\t\tcustomInsertSql,\n\t\t\t\t\tinsertCallable,\n\t\t\t\t\tupdateExpectation,\n\t\t\t\t\tcustomUpdateSql,\n\t\t\t\t\tupdateCallable,\n\t\t\t\t\tcascadeDeleteEnabled,\n\t\t\t\t\tdeleteExpectation,\n\t\t\t\t\tcustomDeleteSql,\n\t\t\t\t\tdeleteCallable,\n\t\t\t\t\tdynamicUpdate,\n\t\t\t\t\tdynamicInsert\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * Builds the EntityTableMapping descriptors for the tables mapped by this entity.\n\t *\n\t * @see #visitMutabilityOrderedTables\n\t */\n\tprotected EntityTableMapping[] buildTableMappings() {\n\t\tfinal LinkedHashMap<String, TableMappingBuilder> tableBuilderMap = new LinkedHashMap<>();\n\t\tvisitMutabilityOrderedTables( (tableExpression, relativePosition, tableKeyColumnVisitationSupplier) -> {\n\t\t\tfinal TableMappingBuilder tableMappingBuilder;\n\n\t\t\tfinal TableMappingBuilder existing = tableBuilderMap.get( tableExpression );\n\n\t\t\tfinal boolean inverseTable = isInverseTable( relativePosition );\n\t\t\tif ( existing == null ) {\n\t\t\t\tfinal Consumer<SelectableConsumer> selectableConsumerConsumer = tableKeyColumnVisitationSupplier.get();\n\t\t\t\tfinal List<EntityTableMapping.KeyColumn> keyColumns = new ArrayList<>();\n\t\t\t\tselectableConsumerConsumer.accept( (selectionIndex, selectableMapping) -> {\n\t\t\t\t\tkeyColumns.add( new EntityTableMapping.KeyColumn(\n\t\t\t\t\t\t\ttableExpression,\n\t\t\t\t\t\t\tselectableMapping.getSelectionExpression(),\n\t\t\t\t\t\t\tselectableMapping.getWriteExpression(),\n\t\t\t\t\t\t\tselectableMapping.isFormula(),\n\t\t\t\t\t\t\tselectableMapping.getJdbcMapping()\n\t\t\t\t\t) );\n\t\t\t\t} );\n\n\t\t\t\tfinal boolean isIdentifierTable = isIdentifierTable( tableExpression );\n\n\t\t\t\tfinal String customInsertSql = customSQLInsert[ relativePosition ] == null\n\t\t\t\t\t\t? null\n\t\t\t\t\t\t: substituteBrackets( customSQLInsert[ relativePosition ] );\n\t\t\t\tfinal String customUpdateSql = customSQLUpdate[ relativePosition ] == null\n\t\t\t\t\t\t? null\n\t\t\t\t\t\t: substituteBrackets( customSQLUpdate[ relativePosition ] );\n\t\t\t\tfinal String customDeleteSql = customSQLDelete[ relativePosition ] == null\n\t\t\t\t\t\t? null\n\t\t\t\t\t\t: substituteBrackets( customSQLDelete[ relativePosition ] );\n\n\t\t\t\ttableMappingBuilder = new TableMappingBuilder(\n\t\t\t\t\t\ttableExpression,\n\t\t\t\t\t\trelativePosition,\n\t\t\t\t\t\tnew EntityTableMapping.KeyMapping( keyColumns, identifierMapping ),\n\t\t\t\t\t\t!isIdentifierTable && isNullableTable( relativePosition ),\n\t\t\t\t\t\tinverseTable,\n\t\t\t\t\t\tisIdentifierTable,\n\t\t\t\t\t\tinsertExpectations[ relativePosition ],\n\t\t\t\t\t\tcustomInsertSql,\n\t\t\t\t\t\tinsertCallable[ relativePosition ],\n\t\t\t\t\t\tupdateExpectations[ relativePosition ],\n\t\t\t\t\t\tcustomUpdateSql,\n\t\t\t\t\t\tupdateCallable[ relativePosition ],\n\t\t\t\t\t\tisTableCascadeDeleteEnabled( relativePosition ),\n\t\t\t\t\t\tdeleteExpectations[ relativePosition ],\n\t\t\t\t\t\tcustomDeleteSql,\n\t\t\t\t\t\tdeleteCallable[ relativePosition ],\n\t\t\t\t\t\tentityMetamodel.isDynamicUpdate(),\n\t\t\t\t\t\tentityMetamodel.isDynamicInsert()\n\t\t\t\t);\n\n\t\t\t\ttableBuilderMap.put( tableExpression, tableMappingBuilder );\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttableMappingBuilder = existing;\n\t\t\t}\n\n\t\t\tif ( !inverseTable ) {\n\t\t\t\tcollectAttributesIndexesForTable( relativePosition, tableMappingBuilder.attributeIndexes::add );\n\t\t\t}\n\t\t} );\n\n\t\tfinal EntityTableMapping[] list = new EntityTableMapping[tableBuilderMap.size()];\n\t\tint i = 0;\n\t\tfor ( Map.Entry<String, TableMappingBuilder> entry : tableBuilderMap.entrySet() ) {\n\t\t\tlist[i++] = entry.getValue().build();\n\t\t}\n\t\treturn list;\n\t}\n\n\t/**\n\t * Visit details about each table for this entity, using \"mutability ordering\".\n\t * When inserting rows, the order we go through the tables to avoid foreign key\n\t * problems among the entity's group of tables.\n\t * <p>\n\t * Used while {@linkplain #buildTableMappings building} the\n\t * {@linkplain EntityTableMapping table mapping} descriptors for each table.\n\t *\n\t * @see #forEachMutableTable\n\t * @see #forEachMutableTableReverse\n\t */\n\tprotected abstract void visitMutabilityOrderedTables(MutabilityOrderedTableConsumer consumer);\n\n\t/**\n\t * Consumer for processing table details.  Used while {@linkplain #buildTableMappings() building}\n\t * the {@link EntityTableMapping} descriptors.\n\t */\n\tinterface MutabilityOrderedTableConsumer {\n\t\tvoid consume(\n\t\t\t\tString tableExpression,\n\t\t\t\tint relativePosition,\n\t\t\t\tSupplier<Consumer<SelectableConsumer>> tableKeyColumnVisitationSupplier);\n\t}\n\n\tprivate void collectAttributesIndexesForTable(int naturalTableIndex, Consumer<Integer> indexConsumer) {\n\t\tforEachAttributeMapping( (attributeIndex, attributeMapping) -> {\n\t\t\tif ( isPropertyOfTable( attributeIndex, naturalTableIndex ) ) {\n\t\t\t\tindexConsumer.accept( attributeIndex );\n\t\t\t}\n\t\t} );\n\t}\n\n\tprotected abstract boolean isIdentifierTable(String tableExpression);\n\n\tprotected InsertCoordinator buildInsertCoordinator() {\n\t\treturn new InsertCoordinatorStandard( this, factory );\n\t}\n\n\tprotected UpdateCoordinator buildUpdateCoordinator() {\n\t\t// we only have updates to issue for entities with one or more singular attributes\n\t\tfor ( int i = 0; i < attributeMappings.size(); i++ ) {\n\t\t\tfinal AttributeMapping attributeMapping = attributeMappings.get( i );\n\t\t\tif ( attributeMapping instanceof SingularAttributeMapping ) {\n\t\t\t\treturn new UpdateCoordinatorStandard( this, factory );\n\t\t\t}\n\t\t}\n\t\t// otherwise, nothing to update\n\t\treturn new UpdateCoordinatorNoOp( this );\n\t}\n\n\tprotected UpdateCoordinator buildMergeCoordinator() {\n\t\t// we only have updates to issue for entities with one or more singular attributes\n\t\tfor ( int i = 0; i < attributeMappings.size(); i++ ) {\n\t\t\tfinal AttributeMapping attributeMapping = attributeMappings.get( i );\n\t\t\tif ( attributeMapping instanceof SingularAttributeMapping ) {\n\t\t\t\treturn new MergeCoordinator( this, factory );\n\t\t\t}\n\t\t}\n\t\t// otherwise, nothing to update\n\t\treturn new UpdateCoordinatorNoOp( this );\n\t}\n\n\tprotected DeleteCoordinator buildDeleteCoordinator() {\n\t\tif ( softDeleteMapping == null ) {\n\t\t\treturn new DeleteCoordinatorStandard( this, factory );\n\t\t}\n\t\telse {\n\t\t\treturn new DeleteCoordinatorSoft( this, factory );\n\t\t}\n\t}\n\n\t@Override\n\tpublic void addDiscriminatorToInsertGroup(MutationGroupBuilder insertGroupBuilder) {\n\t}\n\n\t@Override\n\tpublic void addSoftDeleteToInsertGroup(MutationGroupBuilder insertGroupBuilder) {\n\t\tif ( softDeleteMapping != null ) {\n\t\t\tfinal TableInsertBuilder insertBuilder = insertGroupBuilder.getTableDetailsBuilder( getIdentifierTableName() );\n\t\t\tinsertBuilder.addValueColumn( softDeleteMapping );\n\t\t}\n\t}\n\n\tprotected String substituteBrackets(String sql) {\n\t\treturn new SQLQueryParser( sql, null, getFactory() ).process();\n\t}\n\n\t@Override\n\tpublic final void postInstantiate() throws MappingException {\n\t\tdoLateInit();\n\t}\n\n\t/**\n\t * Load an instance using either the {@code forUpdateLoader} or the outer joining {@code loader},\n\t * depending upon the value of the {@code lock} parameter\n\t */\n\t@Override\n\tpublic Object load(Object id, Object optionalObject, LockMode lockMode, SharedSessionContractImplementor session) {\n\t\treturn load( id, optionalObject, lockMode.toLockOptions(), session );\n\t}\n\n\t/**\n\t * Load an instance using either the {@code forUpdateLoader} or the outer joining {@code loader},\n\t * depending upon the value of the {@code lock} parameter\n\t */\n\t@Override\n\tpublic Object load(Object id, Object optionalObject, LockOptions lockOptions, SharedSessionContractImplementor session)\n\t\t\tthrows HibernateException {\n\t\treturn doLoad( id, optionalObject, lockOptions, null, session );\n\t}\n\n\t@Override\n\tpublic Object load(Object id, Object optionalObject, LockOptions lockOptions, SharedSessionContractImplementor session, Boolean readOnly)\n\t\t\tthrows HibernateException {\n\t\treturn doLoad( id, optionalObject, lockOptions, readOnly, session );\n\t}\n\n\tprivate Object doLoad(Object id, Object optionalObject, LockOptions lockOptions, Boolean readOnly, SharedSessionContractImplementor session)\n\t\t\tthrows HibernateException {\n\t\tif ( LOG.isTraceEnabled() ) {\n\t\t\tLOG.tracev( \"Fetching entity: {0}\", infoString( this, id, getFactory() ) );\n\t\t}\n\n\t\tfinal SingleIdEntityLoader<?> loader = determineLoaderToUse( session );\n\t\treturn optionalObject == null\n\t\t\t\t? loader.load( id, lockOptions, readOnly, session )\n\t\t\t\t: loader.load( id, optionalObject, lockOptions, readOnly, session );\n\t}\n\n\tprotected SingleIdEntityLoader<?> determineLoaderToUse(SharedSessionContractImplementor session) {\n\t\tif ( hasNamedQueryLoader() ) {\n\t\t\treturn getSingleIdLoader();\n\t\t}\n\t\telse {\n\t\t\tfinal LoadQueryInfluencers influencers = session.getLoadQueryInfluencers();\n\t\t\t// no subselect fetching for entities for now\n\t\t\treturn isAffectedByInfluencers( influencers, true )\n\t\t\t\t\t? buildSingleIdEntityLoader( influencers )\n\t\t\t\t\t: getSingleIdLoader();\n\t\t}\n\t}\n\n\tprivate boolean hasNamedQueryLoader() {\n\t\treturn queryLoaderName != null;\n\t}\n\n\tpublic SingleIdEntityLoader<?> getSingleIdLoader() {\n\t\treturn singleIdLoader;\n\t}\n\n\t@Override\n\tpublic Object initializeEnhancedEntityUsedAsProxy(\n\t\t\tObject entity,\n\t\t\tString nameOfAttributeBeingAccessed,\n\t\t\tSharedSessionContractImplementor session) {\n\t\tfinal BytecodeEnhancementMetadata enhancementMetadata = getEntityMetamodel().getBytecodeEnhancementMetadata();\n\t\tfinal BytecodeLazyAttributeInterceptor currentInterceptor = enhancementMetadata.extractLazyInterceptor( entity );\n\t\tif ( currentInterceptor instanceof EnhancementAsProxyLazinessInterceptor ) {\n\t\t\tfinal EnhancementAsProxyLazinessInterceptor proxyInterceptor = (EnhancementAsProxyLazinessInterceptor) currentInterceptor;\n\n\t\t\tfinal EntityKey entityKey = proxyInterceptor.getEntityKey();\n\t\t\tfinal Object identifier = entityKey.getIdentifier();\n\n\t\t\tObject loaded = null;\n\t\t\tif ( canReadFromCache && session.isEventSource() ) {\n\t\t\t\tLoadEvent loadEvent = new LoadEvent( identifier, entity, session.asEventSource(), false );\n\t\t\t\tloaded = CacheEntityLoaderHelper.INSTANCE.loadFromSecondLevelCache( loadEvent, this, entityKey );\n\t\t\t}\n\t\t\tif ( loaded == null ) {\n\t\t\t\tloaded = determineLoaderToUse( session ).load( identifier, entity, LockOptions.NONE, session );\n\t\t\t}\n\n\t\t\tif ( loaded == null ) {\n\t\t\t\tfinal PersistenceContext persistenceContext = session.getPersistenceContext();\n\t\t\t\tpersistenceContext.removeEntry( entity );\n\t\t\t\tpersistenceContext.removeEntity( entityKey );\n\t\t\t\tfactory.getEntityNotFoundDelegate().handleEntityNotFound( entityKey.getEntityName(), identifier );\n\t\t\t}\n\n\t\t\tfinal LazyAttributeLoadingInterceptor interceptor =\n\t\t\t\t\tenhancementMetadata.injectInterceptor( entity, identifier, session );\n\n\t\t\tfinal Object value;\n\t\t\tif ( nameOfAttributeBeingAccessed == null ) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\telse if ( interceptor.isAttributeLoaded( nameOfAttributeBeingAccessed ) ) {\n\t\t\t\tvalue = getPropertyValue( entity, nameOfAttributeBeingAccessed );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tvalue = initializeLazyProperty( nameOfAttributeBeingAccessed, entity, session );\n\t\t\t}\n\n\t\t\treturn interceptor.readObject( entity, nameOfAttributeBeingAccessed, value );\n\t\t}\n\n\t\tthrow new IllegalStateException();\n\t}\n\n\t@Override\n\tpublic List<?> multiLoad(Object[] ids, EventSource session, MultiIdLoadOptions loadOptions) {\n\t\treturn multiIdLoader.load( ids, loadOptions, session );\n\t}\n\n\t@Override\n\tpublic void registerAffectingFetchProfile(String fetchProfileName) {\n\t\tif ( affectingFetchProfileNames == null ) {\n\t\t\taffectingFetchProfileNames = new HashSet<>();\n\t\t}\n\t\taffectingFetchProfileNames.add( fetchProfileName );\n\t}\n\n\t@Override\n\tpublic boolean isAffectedByEntityGraph(LoadQueryInfluencers loadQueryInfluencers) {\n\t\tfinal RootGraphImplementor<?> graph = loadQueryInfluencers.getEffectiveEntityGraph().getGraph();\n\t\treturn graph != null\n\t\t\t&& graph.appliesTo( getFactory().getJpaMetamodel().entity( getEntityName() ) );\n\t}\n\n\t@Override\n\tpublic boolean isAffectedByEnabledFetchProfiles(LoadQueryInfluencers loadQueryInfluencers) {\n\t\tif ( affectingFetchProfileNames != null && loadQueryInfluencers.hasEnabledFetchProfiles() ) {\n\t\t\tfor ( String profileName : loadQueryInfluencers.getEnabledFetchProfileNames() ) {\n\t\t\t\tif ( affectingFetchProfileNames.contains( profileName ) ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic boolean isAffectedByEnabledFilters(\n\t\t\tLoadQueryInfluencers loadQueryInfluencers,\n\t\t\tboolean onlyApplyForLoadByKeyFilters) {\n\t\tif ( filterHelper != null && loadQueryInfluencers.hasEnabledFilters() ) {\n\t\t\tif ( filterHelper.isAffectedBy( loadQueryInfluencers.getEnabledFilters(), onlyApplyForLoadByKeyFilters ) ) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\treturn isAffectedByEnabledFilters( new HashSet<>(), loadQueryInfluencers, onlyApplyForLoadByKeyFilters );\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Locate the property-indices of all properties considered to be dirty.\n\t *\n\t * @param currentState The current state of the entity (the state to be checked).\n\t * @param previousState The previous state of the entity (the state to be checked against).\n\t * @param entity The entity for which we are checking state dirtiness.\n\t * @param session The session in which the check is occurring.\n\t *\n\t * @return {@code null} or the indices of the dirty properties\n\t *\n\t */\n\t@Override\n\tpublic int[] findDirty(Object[] currentState, Object[] previousState, Object entity, SharedSessionContractImplementor session)\n\t\t\tthrows HibernateException {\n\t\tint[] props = DirtyHelper.findDirty(\n\t\t\t\tentityMetamodel.getProperties(),\n\t\t\t\tcurrentState,\n\t\t\t\tpreviousState,\n\t\t\t\tpropertyColumnUpdateable,\n\t\t\t\tsession\n\t\t);\n\t\tif ( props == null ) {\n\t\t\treturn null;\n\t\t}\n\t\telse {\n\t\t\tlogDirtyProperties( props );\n\t\t\treturn props;\n\t\t}\n\t}\n\n\t/**\n\t * Locate the property-indices of all properties considered to be dirty.\n\t *\n\t * @param old The old state of the entity.\n\t * @param current The current state of the entity.\n\t * @param entity The entity for which we are checking state modification.\n\t * @param session The session in which the check is occurring.\n\t *\n\t * @return {@code null} or the indices of the modified properties\n\t *\n\t */\n\t@Override\n\tpublic int[] findModified(Object[] old, Object[] current, Object entity, SharedSessionContractImplementor session)\n\t\t\tthrows HibernateException {\n\t\tint[] props = DirtyHelper.findModified(\n\t\t\t\tentityMetamodel.getProperties(),\n\t\t\t\tcurrent,\n\t\t\t\told,\n\t\t\t\tpropertyColumnUpdateable,\n\t\t\t\tgetPropertyUpdateability(),\n\t\t\t\tsession\n\t\t);\n\t\tif ( props == null ) {\n\t\t\treturn null;\n\t\t}\n\t\telse {\n\t\t\tlogDirtyProperties( props );\n\t\t\treturn props;\n\t\t}\n\t}\n\n\t/**\n\t * Which properties appear in the SQL update?\n\t * (Initialized, updateable ones!)\n\t */\n\tpublic boolean[] getPropertyUpdateability(Object entity) {\n\t\treturn hasUninitializedLazyProperties( entity )\n\t\t\t\t? getNonLazyPropertyUpdateability()\n\t\t\t\t: getPropertyUpdateability();\n\t}\n\n\tprivate void logDirtyProperties(int[] props) {\n\t\tif ( LOG.isTraceEnabled() ) {\n\t\t\tfor ( int prop : props ) {\n\t\t\t\tfinal String propertyName = getAttributeMapping( prop ).getAttributeName();\n\t\t\t\tLOG.trace( StringHelper.qualify( getEntityName(), propertyName ) + \" is dirty\" );\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic SessionFactoryImplementor getFactory() {\n\t\treturn factory;\n\t}\n\n\t@Override\n\tpublic EntityMetamodel getEntityMetamodel() {\n\t\treturn entityMetamodel;\n\t}\n\n\t@Override\n\tpublic boolean canReadFromCache() {\n\t\treturn canReadFromCache;\n\t}\n\n\t@Override\n\tpublic boolean canWriteToCache() {\n\t\treturn canWriteToCache;\n\t}\n\n\t@Override\n\tpublic boolean hasCache() {\n\t\treturn canWriteToCache;\n\t}\n\n\t@Override\n\tpublic EntityDataAccess getCacheAccessStrategy() {\n\t\treturn cacheAccessStrategy;\n\t}\n\n\t@Override\n\tpublic CacheEntryStructure getCacheEntryStructure() {\n\t\treturn cacheEntryHelper.getCacheEntryStructure();\n\t}\n\n\t@Override\n\tpublic CacheEntry buildCacheEntry(Object entity, Object[] state, Object version, SharedSessionContractImplementor session) {\n\t\treturn cacheEntryHelper.buildCacheEntry( entity, state, version, session );\n\t}\n\n\t@Override\n\tpublic boolean hasNaturalIdCache() {\n\t\treturn naturalIdRegionAccessStrategy != null;\n\t}\n\n\t@Override\n\tpublic NaturalIdDataAccess getNaturalIdCacheAccessStrategy() {\n\t\treturn naturalIdRegionAccessStrategy;\n\t}\n\n\n\t// temporary ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\t@Override\n\tpublic final String getEntityName() {\n\t\treturn entityMetamodel.getName();\n\t}\n\n\t@Override\n\tpublic boolean isInherited() {\n\t\treturn entityMetamodel.isInherited();\n\t}\n\n\t@Override\n\tpublic boolean hasCascades() {\n\t\treturn entityMetamodel.hasCascades();\n\t}\n\n\t@Override\n\tpublic boolean hasCascadeDelete() {\n\t\treturn entityMetamodel.hasCascadeDelete();\n\t}\n\n\t@Override\n\tpublic boolean hasOwnedCollections() {\n\t\treturn entityMetamodel.hasOwnedCollections();\n\t}\n\n\t@Override\n\tpublic boolean hasIdentifierProperty() {\n\t\treturn !entityMetamodel.getIdentifierProperty().isVirtual();\n\t}\n\n\t@Override\n\tpublic BasicType<?> getVersionType() {\n\t\treturn entityMetamodel.getVersionProperty() == null\n\t\t\t\t? null\n\t\t\t\t: (BasicType<?>) entityMetamodel.getVersionProperty().getType();\n\t}\n\n\t@Override\n\tpublic int getVersionProperty() {\n\t\treturn entityMetamodel.getVersionPropertyIndex();\n\t}\n\n\t@Override\n\tpublic boolean isVersioned() {\n\t\treturn entityMetamodel.isVersioned();\n\t}\n\n\t@Override\n\tpublic boolean isIdentifierAssignedByInsert() {\n\t\treturn entityMetamodel.getIdentifierProperty().isIdentifierAssignedByInsert();\n\t}\n\n\t@Override\n\tpublic boolean hasLazyProperties() {\n\t\treturn entityMetamodel.hasLazyProperties();\n\t}\n\n\t@Override\n\tpublic void afterReassociate(Object entity, SharedSessionContractImplementor session) {\n\t\tfinal BytecodeEnhancementMetadata metadata = getEntityMetamodel().getBytecodeEnhancementMetadata();\n\t\tif ( metadata.isEnhancedForLazyLoading() ) {\n\t\t\tfinal BytecodeLazyAttributeInterceptor interceptor = metadata.extractLazyInterceptor( entity );\n\t\t\tif ( interceptor == null ) {\n\t\t\t\tmetadata.injectInterceptor( entity, getIdentifier( entity, session ), session );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tinterceptor.setSession( session );\n\t\t\t}\n\t\t}\n\t\thandleNaturalIdReattachment( entity, session );\n\t}\n\n\tprivate void handleNaturalIdReattachment(Object entity, SharedSessionContractImplementor session) {\n\t\tif ( naturalIdMapping == null ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( ! naturalIdMapping.isMutable() ) {\n\t\t\t// we assume there were no changes to natural id during detachment for now, that is validated later\n\t\t\t// during flush.\n\t\t\treturn;\n\t\t}\n\n\t\tfinal PersistenceContext persistenceContext = session.getPersistenceContextInternal();\n\t\tfinal NaturalIdResolutions naturalIdResolutions = persistenceContext.getNaturalIdResolutions();\n\t\tfinal Object id = getIdentifier( entity, session );\n\n\t\t// for reattachment of mutable natural-ids, we absolutely positively have to grab the snapshot from the\n\t\t// database, because we have no other way to know if the state changed while detached.\n\t\tfinal Object[] entitySnapshot = persistenceContext.getDatabaseSnapshot( id, this );\n\t\tfinal Object naturalIdSnapshot = entitySnapshot == StatefulPersistenceContext.NO_ROW\n\t\t\t\t? null\n\t\t\t\t: naturalIdMapping.extractNaturalIdFromEntityState( entitySnapshot );\n\n\t\tnaturalIdResolutions.removeSharedResolution( id, naturalIdSnapshot, this, false );\n\t\tfinal Object naturalId = naturalIdMapping.extractNaturalIdFromEntity( entity );\n\t\tnaturalIdResolutions.manageLocalResolution( id, naturalId, this, CachedNaturalIdValueSource.UPDATE );\n\t}\n\n\t@Override\n\tpublic Boolean isTransient(Object entity, SharedSessionContractImplementor session) throws HibernateException {\n\t\tfinal Object id = getIdentifier( entity, session );\n\t\t// we *always* assume an instance with a null\n\t\t// identifier or no identifier property is unsaved!\n\t\tif ( id == null ) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// check the version unsaved-value, if appropriate\n\t\tif ( isVersioned() ) {\n\t\t\t// let this take precedence if defined, since it works for\n\t\t\t// assigned identifiers\n\t\t\tfinal Object version = getVersion( entity );\n\t\t\tfinal Boolean isUnsaved = versionMapping.getUnsavedStrategy().isUnsaved( version );\n\t\t\tif ( isUnsaved != null ) {\n\t\t\t\tif ( isUnsaved ) {\n\t\t\t\t\tfinal PersistenceContext persistenceContext;\n\t\t\t\t\tif ( version == null\n\t\t\t\t\t\t\t&& ( persistenceContext = session.getPersistenceContext() ).hasLoadContext()\n\t\t\t\t\t\t\t\t\t&& !persistenceContext.getLoadContexts().isLoadingFinished() ) {\n\t\t\t\t\t\t// check if we're currently loading this entity instance, the version\n\t\t\t\t\t\t// will be null but the entity cannot be considered transient\n\t\t\t\t\t\tfinal EntityHolder holder =\n\t\t\t\t\t\t\t\tpersistenceContext.getEntityHolder( new EntityKey( id, this ) );\n\t\t\t\t\t\tif ( holder != null && holder.isEventuallyInitialized() && holder.getEntity() == entity ) {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfinal Generator identifierGenerator = getGenerator();\n\t\t\t\t\tif ( identifierGenerator != null ) {\n\t\t\t\t\t\tfinal Boolean unsaved = identifierMapping.getUnsavedStrategy().isUnsaved( id );\n\t\t\t\t\t\tif ( unsaved != null && !unsaved ) {\n\t\t\t\t\t\t\tthrow new PropertyValueException(\n\t\t\t\t\t\t\t\t\t\"Detached entity with generated id '\" + id\n\t\t\t\t\t\t\t\t\t\t\t+ \"' has an uninitialized version value '\" + version + \"'\",\n\t\t\t\t\t\t\t\t\tgetEntityName(),\n\t\t\t\t\t\t\t\t\tgetVersionColumnName()\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn isUnsaved;\n\t\t\t}\n\t\t}\n\n\t\t// check the id unsaved-value\n\t\tfinal Boolean result = identifierMapping.getUnsavedStrategy().isUnsaved( id );\n\t\tif ( result != null ) {\n\t\t\treturn result;\n\t\t}\n\n\t\t// check to see if it is in the second-level cache\n\t\tif ( session.getCacheMode().isGetEnabled() && canReadFromCache() ) {\n\t\t\tfinal EntityDataAccess cache = getCacheAccessStrategy();\n\t\t\tfinal Object ck = cache.generateCacheKey( id, this, session.getFactory(), session.getTenantIdentifier() );\n\t\t\tfinal Object ce = CacheHelper.fromSharedCache( session, ck, this, getCacheAccessStrategy() );\n\t\t\tif ( ce != null ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic boolean hasCollections() {\n\t\treturn entityMetamodel.hasCollections();\n\t}\n\n\t@Override\n\tpublic boolean hasMutableProperties() {\n\t\treturn entityMetamodel.hasMutableProperties();\n\t}\n\n\t@Override\n\tpublic boolean isMutable() {\n\t\treturn entityMetamodel.isMutable();\n\t}\n\n\t@Override\n\tpublic boolean isAbstract() {\n\t\treturn entityMetamodel.isAbstract();\n\t}\n\n\t@Override\n\tpublic boolean hasSubclasses() {\n\t\treturn entityMetamodel.hasSubclasses();\n\t}\n\n\t@Override\n\tpublic boolean hasProxy() {\n\t\t// skip proxy instantiation if entity is bytecode enhanced\n\t\treturn entityMetamodel.isLazy() && !entityMetamodel.getBytecodeEnhancementMetadata().isEnhancedForLazyLoading();\n\t}\n\n\t@Override @Deprecated\n\tpublic IdentifierGenerator getIdentifierGenerator() throws HibernateException {\n\t\treturn entityMetamodel.getIdentifierProperty().getIdentifierGenerator();\n\t}\n\n\t@Override\n\tpublic Generator getGenerator() {\n\t\treturn entityMetamodel.getIdentifierProperty().getGenerator();\n\t}\n\n\t@Override\n\tpublic BeforeExecutionGenerator getVersionGenerator() {\n\t\treturn versionGenerator;\n\t}\n\n\t@Override\n\tpublic String getRootEntityName() {\n\t\treturn entityMetamodel.getRootName();\n\t}\n\n\t@Override\n\tpublic String getMappedSuperclass() {\n\t\treturn entityMetamodel.getSuperclass();\n\t}\n\n\t@Override\n\tpublic boolean isExplicitPolymorphism() {\n\t\treturn entityMetamodel.isExplicitPolymorphism();\n\t}\n\n\t@Override\n\tpublic boolean isConcreteProxy() {\n\t\treturn concreteProxy;\n\t}\n\n\t@Override\n\tpublic EntityMappingType resolveConcreteProxyTypeForId(Object id, SharedSessionContractImplementor session) {\n\t\tif ( !concreteProxy ) {\n\t\t\treturn this;\n\t\t}\n\n\t\tEntityConcreteTypeLoader concreteTypeLoader = this.concreteTypeLoader;\n\t\tif ( concreteTypeLoader == null ) {\n\t\t\tthis.concreteTypeLoader = concreteTypeLoader = new EntityConcreteTypeLoader( this, session.getFactory() );\n\t\t}\n\t\treturn concreteTypeLoader.getConcreteType( id, session );\n\t}\n\n\t/**\n\t * {@inheritDoc}\n\t *\n\t * Warning:\n\t * When there are duplicated property names in the subclasses\n\t * then this method may return the wrong results.\n\t * To ensure correct results, this method should only be used when\n\t * {@literal this} is the concrete EntityPersister (since the\n\t * concrete EntityPersister cannot have duplicated property names).\n\t *\n\t * @deprecated by the supertypes\n\t */\n\t@Override @Deprecated\n\tpublic Type getPropertyType(String propertyName) throws MappingException {\n\t\t// todo (PropertyMapping) : caller also deprecated (aka, easy to remove)\n\t\treturn propertyMapping.toType( propertyName );\n\t}\n\n\t@Override\n\tpublic boolean isSelectBeforeUpdateRequired() {\n\t\treturn entityMetamodel.isSelectBeforeUpdate();\n\t}\n\n\tpublic final OptimisticLockStyle optimisticLockStyle() {\n\t\treturn entityMetamodel.getOptimisticLockStyle();\n\t}\n\n\t@Override\n\tpublic Object createProxy(Object id, SharedSessionContractImplementor session) throws HibernateException {\n\t\treturn representationStrategy.getProxyFactory().getProxy( id, session );\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn StringHelper.unqualify( getClass().getName() )\n\t\t\t\t+ '(' + entityMetamodel.getName() + ')';\n\t}\n\n\t@Override\n\tpublic boolean isInstrumented() {\n\t\treturn entityMetamodel.getBytecodeEnhancementMetadata().isEnhancedForLazyLoading();\n\t}\n\n\t@Override\n\tpublic boolean hasInsertGeneratedProperties() {\n\t\treturn entityMetamodel.hasInsertGeneratedValues();\n\t}\n\n\t@Override\n\tpublic boolean hasUpdateGeneratedProperties() {\n\t\treturn entityMetamodel.hasUpdateGeneratedValues();\n\t}\n\n\t@Override\n\tpublic boolean isVersionPropertyGenerated() {\n\t\treturn isVersioned()\n\t\t\t&& ( isVersionGeneratedOnExecution() || isVersionGeneratedBeforeExecution() );\n\t}\n\n\tpublic boolean isVersionGeneratedOnExecution() {\n\t\tfinal Generator strategy = getEntityMetamodel().getGenerators()[ getVersionProperty() ];\n\t\treturn strategy != null && strategy.generatesSometimes() && strategy.generatedOnExecution();\n\t}\n\n\tpublic boolean isVersionGeneratedBeforeExecution() {\n\t\tfinal Generator strategy = getEntityMetamodel().getGenerators()[ getVersionProperty() ];\n\t\treturn strategy != null && strategy.generatesSometimes() && !strategy.generatedOnExecution();\n\t}\n\n\t@Override\n\tpublic void afterInitialize(Object entity, SharedSessionContractImplementor session) {\n\t\tif ( isPersistentAttributeInterceptable( entity ) && getRepresentationStrategy().getMode() == POJO ) {\n\t\t\tfinal BytecodeLazyAttributeInterceptor interceptor = getEntityMetamodel().getBytecodeEnhancementMetadata()\n\t\t\t\t\t.extractLazyInterceptor( entity );\n\t\t\tassert interceptor != null;\n\t\t\tif ( interceptor.getLinkedSession() == null ) {\n\t\t\t\tinterceptor.setSession( session );\n\t\t\t}\n\t\t}\n\n\t\t// clear the fields that are marked as dirty in the dirtiness tracker\n\t\tprocessIfSelfDirtinessTracker( entity, AbstractEntityPersister::clearDirtyAttributes );\n\t\tprocessIfManagedEntity( entity, AbstractEntityPersister::useTracker );\n\t}\n\n\tprivate static void clearDirtyAttributes(final SelfDirtinessTracker entity) {\n\t\tentity.$$_hibernate_clearDirtyAttributes();\n\t}\n\n\tprivate static void useTracker(final ManagedEntity entity) {\n\t\tentity.$$_hibernate_setUseTracker( true );\n\t}\n\n\t@Override\n\tpublic String[] getPropertyNames() {\n\t\treturn entityMetamodel.getPropertyNames();\n\t}\n\n\t@Override\n\tpublic Type[] getPropertyTypes() {\n\t\treturn entityMetamodel.getPropertyTypes();\n\t}\n\n\t@Override\n\tpublic boolean[] getPropertyLaziness() {\n\t\treturn entityMetamodel.getPropertyLaziness();\n\t}\n\n\t@Override\n\tpublic boolean[] getPropertyUpdateability() {\n\t\treturn entityMetamodel.getPropertyUpdateability();\n\t}\n\n\t@Override\n\tpublic boolean[] getPropertyCheckability() {\n\t\treturn entityMetamodel.getPropertyCheckability();\n\t}\n\n\t@Override\n\tpublic boolean[] getNonLazyPropertyUpdateability() {\n\t\treturn entityMetamodel.getNonlazyPropertyUpdateability();\n\t}\n\n\t@Override\n\tpublic boolean[] getPropertyInsertability() {\n\t\treturn entityMetamodel.getPropertyInsertability();\n\t}\n\n\t@Override\n\tpublic boolean[] getPropertyNullability() {\n\t\treturn entityMetamodel.getPropertyNullability();\n\t}\n\n\t@Override\n\tpublic boolean[] getPropertyVersionability() {\n\t\treturn entityMetamodel.getPropertyVersionability();\n\t}\n\n\t@Override\n\tpublic CascadeStyle[] getPropertyCascadeStyles() {\n\t\treturn entityMetamodel.getCascadeStyles();\n\t}\n\n\t@Override\n\tpublic boolean isPropertySelectable(int propertyNumber) {\n\t\treturn getAttributeMapping( propertyNumber ).getAttributeMetadata().isSelectable();\n\t}\n\n\t@Override\n\tpublic final Class<?> getMappedClass() {\n\t\treturn this.getMappedJavaType().getJavaTypeClass();\n\t}\n\n\t@Override\n\tpublic boolean implementsLifecycle() {\n\t\treturn this.implementsLifecycle;\n\t}\n\n\t@Override\n\tpublic Class<?> getConcreteProxyClass() {\n\t\tfinal JavaType<?> proxyJavaType = getRepresentationStrategy().getProxyJavaType();\n\t\treturn proxyJavaType != null ? proxyJavaType.getJavaTypeClass() : javaType.getJavaTypeClass();\n\t}\n\n\t@Override\n\tpublic void setPropertyValues(Object object, Object[] values) {\n\t\tif ( accessOptimizer != null ) {\n\t\t\taccessOptimizer.setPropertyValues( object, values );\n\t\t}\n\t\telse {\n\t\t\tfinal BytecodeEnhancementMetadata enhancementMetadata = entityMetamodel.getBytecodeEnhancementMetadata();\n\t\t\tfinal AttributeMappingsList attributeMappings = getAttributeMappings();\n\t\t\tif ( enhancementMetadata.isEnhancedForLazyLoading() ) {\n\t\t\t\tfor ( int i = 0; i < attributeMappings.size(); i++ ) {\n\t\t\t\t\tfinal Object value = values[i];\n\t\t\t\t\tif ( value != UNFETCHED_PROPERTY ) {\n\t\t\t\t\t\tsetterCache[i].set( object, value );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor ( int i = 0; i < attributeMappings.size(); i++ ) {\n\t\t\t\t\tsetterCache[i].set( object, values[i] );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic void setPropertyValue(Object object, int i, Object value) {\n\t\tsetterCache[i].set( object, value );\n\t}\n\n\t@Override\n\tpublic Object[] getPropertyValues(Object object) {\n\t\tif ( accessOptimizer != null ) {\n\t\t\treturn accessOptimizer.getPropertyValues( object );\n\t\t}\n\t\telse {\n\t\t\tfinal BytecodeEnhancementMetadata enhancementMetadata = entityMetamodel.getBytecodeEnhancementMetadata();\n\t\t\tfinal AttributeMappingsList attributeMappings = getAttributeMappings();\n\t\t\tfinal Object[] values = new Object[attributeMappings.size()];\n\t\t\tif ( enhancementMetadata.isEnhancedForLazyLoading() ) {\n\t\t\t\tfinal LazyAttributesMetadata lazyAttributesMetadata = enhancementMetadata.getLazyAttributesMetadata();\n\t\t\t\tfor ( int i = 0; i < attributeMappings.size(); i++ ) {\n\t\t\t\t\tfinal AttributeMapping attributeMapping = attributeMappings.get( i );\n\t\t\t\t\tif ( !lazyAttributesMetadata.isLazyAttribute( attributeMapping.getAttributeName() )\n\t\t\t\t\t\t\t|| enhancementMetadata.isAttributeLoaded( object, attributeMapping.getAttributeName() ) ) {\n\t\t\t\t\t\tvalues[i] = getterCache[i].get( object );\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tvalues[i] = LazyPropertyInitializer.UNFETCHED_PROPERTY;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor ( int i = 0; i < attributeMappings.size(); i++ ) {\n\t\t\t\t\tvalues[i] = getterCache[i].get( object );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn values;\n\t\t}\n\t}\n\n\t@Override\n\tpublic Object getPropertyValue(Object object, int i) {\n\t\treturn getterCache[i].get( object );\n\t}\n\n\t@Override\n\tpublic Object getPropertyValue(Object object, String propertyName) {\n\t\tfinal int dotIndex = propertyName.indexOf( '.' );\n\t\tfinal String basePropertyName = dotIndex == -1\n\t\t\t\t? propertyName\n\t\t\t\t: propertyName.substring( 0, dotIndex );\n\t\tfinal AttributeMapping attributeMapping = findAttributeMapping( basePropertyName );\n\t\tManagedMappingType baseValueType = null;\n\t\tObject baseValue = null;\n\t\tif ( attributeMapping != null ) {\n\t\t\tbaseValue = getterCache[attributeMapping.getStateArrayPosition()].get( object );\n\t\t\tif ( dotIndex != -1 ) {\n\t\t\t\tbaseValueType = (ManagedMappingType) attributeMapping.getMappedType();\n\t\t\t}\n\t\t}\n\t\telse if ( identifierMapping instanceof NonAggregatedIdentifierMapping ) {\n\t\t\tfinal AttributeMapping mapping = ( (NonAggregatedIdentifierMapping) identifierMapping ).findSubPart(\n\t\t\t\t\tpropertyName,\n\t\t\t\t\tnull\n\t\t\t).asAttributeMapping();\n\t\t\tif ( mapping != null ) {\n\t\t\t\tbaseValue = mapping.getValue( object );\n\t\t\t\tif ( dotIndex != -1 ) {\n\t\t\t\t\tbaseValueType = (ManagedMappingType) mapping.getMappedType();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn getPropertyValue( baseValue, baseValueType, propertyName, dotIndex );\n\t}\n\n\tprivate Object getPropertyValue(\n\t\t\tObject baseValue,\n\t\t\tManagedMappingType baseValueType,\n\t\t\tString propertyName,\n\t\t\tint dotIndex) {\n\t\tif ( baseValueType == null ) {\n\t\t\treturn baseValue;\n\t\t}\n\t\telse {\n\t\t\tfinal int nextDotIndex = propertyName.indexOf( '.', dotIndex + 1 );\n\t\t\tfinal int endIndex = nextDotIndex == -1 ? propertyName.length() : nextDotIndex;\n\t\t\tfinal AttributeMapping attributeMapping =\n\t\t\t\t\tbaseValueType.findAttributeMapping( propertyName.substring( dotIndex + 1, endIndex ) );\n\t\t\tbaseValue = attributeMapping.getValue( baseValue );\n\t\t\tbaseValueType = nextDotIndex == -1 ? null : (ManagedMappingType) attributeMapping.getMappedType();\n\t\t\treturn getPropertyValue( baseValue, baseValueType, propertyName, nextDotIndex );\n\t\t}\n\t}\n\n\t@Override\n\tpublic Object getIdentifier(Object entity, SharedSessionContractImplementor session) {\n\t\treturn identifierMapping.getIdentifier( entity );\n\t}\n\n\t@Override\n\tpublic void setIdentifier(Object entity, Object id, SharedSessionContractImplementor session) {\n\t\tidentifierMapping.setIdentifier( entity, id, session );\n\t}\n\n\t@Override\n\tpublic Object getVersion(Object object) {\n\t\treturn getVersionMapping() == null ? null\n\t\t\t\t: getVersionMapping().getVersionAttribute().getPropertyAccess().getGetter().get( object );\n\t}\n\n\t@Override\n\tpublic Object instantiate(Object id, SharedSessionContractImplementor session) {\n\t\tfinal Object instance = getRepresentationStrategy().getInstantiator().instantiate( session.getFactory() );\n\t\tlinkToSession( instance, session );\n\t\tif ( id != null ) {\n\t\t\tsetIdentifier( instance, id, session );\n\t\t}\n\t\treturn instance;\n\t}\n\n\tprotected void linkToSession(Object entity, SharedSessionContractImplementor session) {\n\t\tif ( session != null ) {\n\t\t\tprocessIfPersistentAttributeInterceptable( entity, this::setSession, session );\n\t\t}\n\t}\n\n\tprivate void setSession(PersistentAttributeInterceptable entity, SharedSessionContractImplementor session) {\n\t\tfinal BytecodeLazyAttributeInterceptor interceptor =\n\t\t\t\tgetEntityMetamodel().getBytecodeEnhancementMetadata()\n\t\t\t\t\t\t.extractLazyInterceptor( entity );\n\t\tif ( interceptor != null ) {\n\t\t\tinterceptor.setSession( session );\n\t\t}\n\t}\n\n\t@Override\n\tpublic boolean isInstance(Object object) {\n\t\treturn getRepresentationStrategy().getInstantiator().isInstance( object, getFactory() );\n\t}\n\n\t@Override\n\tpublic boolean hasUninitializedLazyProperties(Object object) {\n\t\treturn entityMetamodel.getBytecodeEnhancementMetadata().hasUnFetchedAttributes( object );\n\t}\n\n\t@Override\n\tpublic void resetIdentifier(\n\t\t\tObject entity,\n\t\t\tObject currentId,\n\t\t\tObject currentVersion,\n\t\t\tSharedSessionContractImplementor session) {\n\t\tif ( entityMetamodel.getIdentifierProperty().getGenerator().allowAssignedIdentifiers() ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// reset the identifier\n\t\tfinal Object defaultIdentifier = identifierMapping.getUnsavedStrategy().getDefaultValue( currentId );\n\t\tsetIdentifier( entity, defaultIdentifier, session );\n\n\t\t// reset the version\n\t\tif ( versionMapping != null ) {\n\t\t\tfinal Object defaultVersion = versionMapping.getUnsavedStrategy().getDefaultValue( currentVersion );\n\t\t\tversionMapping.getVersionAttribute().getPropertyAccess().getSetter().set( entity, defaultVersion );\n\t\t}\n\t}\n\n\t@Override\n\tpublic EntityPersister getSubclassEntityPersister(Object instance, SessionFactoryImplementor factory) {\n\t\tif ( instance != null\n\t\t\t\t&& hasSubclasses()\n\t\t\t\t&& !getRepresentationStrategy().getInstantiator().isSameClass( instance, factory ) ) {\n\t\t\t// todo (6.0) : this previously used `org.hibernate.tuple.entity.EntityTuplizer#determineConcreteSubclassEntityName`\n\t\t\t//\t\t- we may need something similar here...\n\t\t\tfor ( EntityMappingType subclassMappingType : subclassMappingTypes.values() ) {\n\t\t\t\tif ( subclassMappingType.getEntityPersister().getRepresentationStrategy()\n\t\t\t\t\t\t.getInstantiator().isSameClass(instance, factory) ) {\n\t\t\t\t\treturn subclassMappingType.getEntityPersister();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t@Override\n\tpublic boolean hasMultipleTables() {\n\t\treturn false;\n\t}\n\n\tpublic int getPropertySpan() {\n\t\treturn entityMetamodel.getPropertySpan();\n\t}\n\n\t@Override\n\tpublic Object[] getPropertyValuesToInsert(\n\t\t\tObject entity,\n\t\t\tMap<Object,Object> mergeMap,\n\t\t\tSharedSessionContractImplementor session)\n\t\t\tthrows HibernateException {\n\t\tif ( shouldGetAllProperties( entity ) && accessOptimizer != null ) {\n\t\t\treturn accessOptimizer.getPropertyValues( entity );\n\t\t}\n\n\t\tfinal Object[] result = new Object[attributeMappings.size()];\n\t\tfor ( int i = 0; i < attributeMappings.size(); i++ ) {\n\t\t\tresult[i] = getterCache[i].getForInsert( entity, mergeMap, session );\n\t\t}\n\t\treturn result;\n\t}\n\n\tprotected boolean shouldGetAllProperties(Object entity) {\n\t\tfinal BytecodeEnhancementMetadata metadata = getEntityMetamodel().getBytecodeEnhancementMetadata();\n\t\treturn !metadata.isEnhancedForLazyLoading()\n\t\t\t|| !metadata.hasUnFetchedAttributes( entity );\n\t}\n\n\t@Override\n\tpublic void processInsertGeneratedProperties(\n\t\t\tObject id,\n\t\t\tObject entity,\n\t\t\tObject[] state,\n\t\t\tGeneratedValues generatedValues,\n\t\t\tSharedSessionContractImplementor session) {\n\t\tif ( insertGeneratedValuesProcessor == null ) {\n\t\t\tthrow new UnsupportedOperationException( \"Entity has no insert-generated properties - `\" + getEntityName() + \"`\" );\n\t\t}\n\t\tinsertGeneratedValuesProcessor.processGeneratedValues( entity, id, state, generatedValues, session );\n\t}\n\n\tprotected List<? extends ModelPart> initInsertGeneratedProperties(List<AttributeMapping> generatedAttributes) {\n\t\tfinal int originalSize = generatedAttributes.size();\n\t\tfinal List<ModelPart> generatedBasicAttributes = new ArrayList<>( originalSize );\n\t\tfor ( AttributeMapping generatedAttribute : generatedAttributes ) {\n\t\t\t// todo (7.0) : support non selectable mappings? Component, ToOneAttributeMapping, ...\n\t\t\tif ( generatedAttribute.asBasicValuedModelPart() != null\n\t\t\t\t\t&& generatedAttribute.getContainingTableExpression().equals( getRootTableName() ) ) {\n\t\t\t\tgeneratedBasicAttributes.add( generatedAttribute );\n\t\t\t}\n\t\t}\n\n\t\tfinal List<ModelPart> identifierList = isIdentifierAssignedByInsert() ?\n\t\t\t\tList.of( getIdentifierMapping() ) :\n\t\t\t\tCollections.emptyList();\n\t\tif ( originalSize > 0 && generatedBasicAttributes.size() == originalSize ) {\n\t\t\treturn Collections.unmodifiableList( combine( identifierList, generatedBasicAttributes ) );\n\t\t}\n\t\telse  {\n\t\t\treturn identifierList;\n\t\t}\n\t}\n\n\t@Override\n\tpublic List<? extends ModelPart> getInsertGeneratedProperties() {\n\t\treturn insertGeneratedProperties;\n\t}\n\n\t@Override\n\tpublic void processUpdateGeneratedProperties(\n\t\t\tObject id,\n\t\t\tObject entity,\n\t\t\tObject[] state,\n\t\t\tGeneratedValues generatedValues,\n\t\t\tSharedSessionContractImplementor session) {\n\t\tif ( updateGeneratedValuesProcessor == null ) {\n\t\t\tthrow new AssertionFailure( \"Entity has no update-generated properties - `\" + getEntityName() + \"`\" );\n\t\t}\n\t\tupdateGeneratedValuesProcessor.processGeneratedValues( entity, id, state, generatedValues, session );\n\t}\n\n\tprotected List<? extends ModelPart> initUpdateGeneratedProperties(List<AttributeMapping> generatedAttributes) {\n\t\tfinal int originalSize = generatedAttributes.size();\n\t\tfinal List<ModelPart> generatedBasicAttributes = new ArrayList<>( originalSize );\n\t\tfor ( AttributeMapping generatedAttribute : generatedAttributes ) {\n\t\t\tif ( generatedAttribute instanceof SelectableMapping\n\t\t\t\t\t&& ( (SelectableMapping) generatedAttribute ).getContainingTableExpression().equals( getSubclassTableName( 0 ) ) ) {\n\t\t\t\tgeneratedBasicAttributes.add( generatedAttribute );\n\t\t\t}\n\t\t}\n\n\t\tif ( generatedBasicAttributes.size() == originalSize ) {\n\t\t\treturn Collections.unmodifiableList( generatedBasicAttributes );\n\t\t}\n\t\telse  {\n\t\t\treturn Collections.emptyList();\n\t\t}\n\t}\n\n\t@Override\n\tpublic List<? extends ModelPart> getUpdateGeneratedProperties() {\n\t\treturn updateGeneratedProperties;\n\t}\n\n\t@Override\n\tpublic String getIdentifierPropertyName() {\n\t\treturn entityMetamodel.getIdentifierProperty().getName();\n\t}\n\n\t@Override\n\tpublic Type getIdentifierType() {\n\t\treturn entityMetamodel.getIdentifierProperty().getType();\n\t}\n\n\t@Override\n\tpublic boolean hasSubselectLoadableCollections() {\n\t\treturn hasSubselectLoadableCollections;\n\t}\n\n\t@Override\n\tpublic boolean hasCollectionNotReferencingPK() {\n\t\treturn hasCollectionNotReferencingPK;\n\t}\n\n\t@Override\n\tpublic int[] getNaturalIdentifierProperties() {\n\t\treturn entityMetamodel.getNaturalIdentifierProperties();\n\t}\n\n\tprotected void verifyHasNaturalId() {\n\t\tif ( ! hasNaturalIdentifier() ) {\n\t\t\tthrow new HibernateException( \"Entity does not define a natural id : \" + getEntityName() );\n\t\t}\n\t}\n\n\t@Override\n\tpublic Object getNaturalIdentifierSnapshot(Object id, SharedSessionContractImplementor session) {\n\t\tverifyHasNaturalId();\n\t\tif ( LOG.isTraceEnabled() ) {\n\t\t\tLOG.tracef(\n\t\t\t\t\t\"Getting current natural-id snapshot state for `%s#%s\",\n\t\t\t\t\tgetEntityName(),\n\t\t\t\t\tid\n\t\t\t);\n\t\t}\n\t\treturn getNaturalIdLoader().resolveIdToNaturalId( id, session );\n\t}\n\n\n\t@Override\n\tpublic NaturalIdLoader<?> getNaturalIdLoader() {\n\t\tverifyHasNaturalId();\n\t\tif ( naturalIdLoader == null ) {\n\t\t\tnaturalIdLoader = naturalIdMapping.makeLoader( this );\n\t\t}\n\t\treturn naturalIdLoader;\n\t}\n\n\t@Override\n\tpublic MultiNaturalIdLoader<?> getMultiNaturalIdLoader() {\n\t\tverifyHasNaturalId();\n\t\tif ( multiNaturalIdLoader == null ) {\n\t\t\tmultiNaturalIdLoader = naturalIdMapping.makeMultiLoader( this );\n\t\t}\n\t\treturn multiNaturalIdLoader;\n\t}\n\n\t@Override\n\tpublic Object loadEntityIdByNaturalId(\n\t\t\tObject[] naturalIdValues,\n\t\t\tLockOptions lockOptions,\n\t\t\tSharedSessionContractImplementor session) {\n\t\tverifyHasNaturalId();\n\t\tif ( LOG.isTraceEnabled() ) {\n\t\t\tLOG.tracef(\n\t\t\t\t\t\"Resolving natural-id [%s] to id : %s \",\n\t\t\t\t\tArrays.asList( naturalIdValues ),\n\t\t\t\t\tinfoString( this )\n\t\t\t);\n\t\t}\n\t\treturn getNaturalIdLoader().resolveNaturalIdToId( naturalIdValues, session );\n\t}\n\n\t@Override\n\tpublic boolean hasNaturalIdentifier() {\n\t\treturn entityMetamodel.hasNaturalIdentifier();\n\t}\n\n\tprivate void setPropertyValue(Object object, String propertyName, Object value) {\n\t\tfinal AttributeMapping attributeMapping = findSubPart( propertyName, this ).asAttributeMapping();\n\t\tsetterCache[attributeMapping.getStateArrayPosition()].set( object, value );\n\t}\n\n\tpublic static int getTableId(String tableName, String[] tables) {\n\t\tfor ( int j = 0; j < tables.length; j++ ) {\n\t\t\tif ( tableName.equalsIgnoreCase( tables[j] ) ) {\n\t\t\t\treturn j;\n\t\t\t}\n\t\t}\n\t\tthrow new AssertionFailure( \"Table \" + tableName + \" not found\" );\n\t}\n\n\t@Override\n\tpublic EntityRepresentationStrategy getRepresentationStrategy() {\n\t\treturn representationStrategy;\n\t}\n\n\t@Override\n\tpublic BytecodeEnhancementMetadata getInstrumentationMetadata() {\n\t\treturn getBytecodeEnhancementMetadata();\n\t}\n\n\t@Override\n\tpublic BytecodeEnhancementMetadata getBytecodeEnhancementMetadata() {\n\t\treturn entityMetamodel.getBytecodeEnhancementMetadata();\n\t}\n\n\t@Override\n\tpublic String getTableNameForColumn(String columnName) {\n\t\treturn getTableName( determineTableNumberForColumn( columnName ) );\n\t}\n\n\tprotected int determineTableNumberForColumn(String columnName) {\n\t\treturn 0;\n\t}\n\n\tprotected String determineTableName(Table table) {\n\t\treturn MappingModelCreationHelper.getTableIdentifierExpression( table, factory );\n\t}\n\n\t@Override\n\tpublic EntityEntryFactory getEntityEntryFactory() {\n\t\treturn this.entityEntryFactory;\n\t}\n\n\t/**\n\t * Consolidated these onto a single helper because the 2 pieces work in tandem.\n\t */\n\tpublic interface CacheEntryHelper {\n\t\tCacheEntryStructure getCacheEntryStructure();\n\n\t\tCacheEntry buildCacheEntry(Object entity, Object[] state, Object version, SharedSessionContractImplementor session);\n\t}\n\n\tprivate static class StandardCacheEntryHelper implements CacheEntryHelper {\n\t\tprivate final EntityPersister persister;\n\n\t\tprivate StandardCacheEntryHelper(EntityPersister persister) {\n\t\t\tthis.persister = persister;\n\t\t}\n\n\t\t@Override\n\t\tpublic CacheEntryStructure getCacheEntryStructure() {\n\t\t\treturn UnstructuredCacheEntry.INSTANCE;\n\t\t}\n\n\t\t@Override\n\t\tpublic CacheEntry buildCacheEntry(Object entity, Object[] state, Object version, SharedSessionContractImplementor session) {\n\t\t\treturn new StandardCacheEntryImpl( state, persister, version, session, entity );\n\t\t}\n\t}\n\n\tprivate static class ReferenceCacheEntryHelper implements CacheEntryHelper {\n\t\tprivate final EntityPersister persister;\n\n\t\tprivate ReferenceCacheEntryHelper(EntityPersister persister) {\n\t\t\tthis.persister = persister;\n\t\t}\n\n\t\t@Override\n\t\tpublic CacheEntryStructure getCacheEntryStructure() {\n\t\t\treturn UnstructuredCacheEntry.INSTANCE;\n\t\t}\n\n\t\t@Override\n\t\tpublic CacheEntry buildCacheEntry(Object entity, Object[] state, Object version, SharedSessionContractImplementor session) {\n\t\t\treturn new ReferenceCacheEntryImpl( entity, persister );\n\t\t}\n\t}\n\n\tprivate static class StructuredCacheEntryHelper implements CacheEntryHelper {\n\t\tprivate final EntityPersister persister;\n\t\tprivate final StructuredCacheEntry structure;\n\n\t\tprivate StructuredCacheEntryHelper(EntityPersister persister) {\n\t\t\tthis.persister = persister;\n\t\t\tthis.structure = new StructuredCacheEntry( persister );\n\t\t}\n\n\t\t@Override\n\t\tpublic CacheEntryStructure getCacheEntryStructure() {\n\t\t\treturn structure;\n\t\t}\n\n\t\t@Override\n\t\tpublic CacheEntry buildCacheEntry(Object entity, Object[] state, Object version, SharedSessionContractImplementor session) {\n\t\t\treturn new StandardCacheEntryImpl( state, persister, version, session, entity );\n\t\t}\n\t}\n\n\tprivate static class NoopCacheEntryHelper implements CacheEntryHelper {\n\t\tpublic static final NoopCacheEntryHelper INSTANCE = new NoopCacheEntryHelper();\n\n\t\t@Override\n\t\tpublic CacheEntryStructure getCacheEntryStructure() {\n\t\t\treturn UnstructuredCacheEntry.INSTANCE;\n\t\t}\n\n\t\t@Override\n\t\tpublic CacheEntry buildCacheEntry(Object entity, Object[] state, Object version, SharedSessionContractImplementor session) {\n\t\t\tthrow new HibernateException( \"Illegal attempt to build cache entry for non-cached entity\" );\n\t\t}\n\t}\n\n\n\t// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\t// org.hibernate.metamodel.mapping.EntityMappingType\n\n\t@Override\n\tpublic void forEachAttributeMapping(Consumer<? super AttributeMapping> action) {\n\t\tthis.attributeMappings.forEach( action );\n\t}\n\n\t@Override\n\tpublic void forEachAttributeMapping(final IndexedConsumer<? super AttributeMapping> consumer) {\n\t\tattributeMappings.indexedForEach( consumer );\n\t}\n\n\t@Override\n\tpublic void prepareMappingModel(MappingModelCreationProcess creationProcess) {\n\t\tif ( identifierMapping != null ) {\n\t\t\treturn;\n\t\t}\n\n\t\tfinal RuntimeModelCreationContext creationContext = creationProcess.getCreationContext();\n\n\t\tfinal PersistentClass bootEntityDescriptor = creationContext\n\t\t\t\t.getBootModel()\n\t\t\t\t.getEntityBinding( getEntityName() );\n\n//\t\tEntityMappingType rootEntityDescriptor;\n\t\tif ( superMappingType != null ) {\n\t\t\t( (InFlightEntityMappingType) superMappingType ).prepareMappingModel( creationProcess );\n\t\t\tif ( shouldProcessSuperMapping() ) {\n\t\t\t\tdiscriminatorMapping = superMappingType.getDiscriminatorMapping();\n\t\t\t\tidentifierMapping = superMappingType.getIdentifierMapping();\n\t\t\t\tnaturalIdMapping = superMappingType.getNaturalIdMapping();\n\t\t\t\tversionMapping = superMappingType.getVersionMapping();\n\t\t\t\trowIdMapping = superMappingType.getRowIdMapping();\n\t\t\t\tsoftDeleteMapping = superMappingType.getSoftDeleteMapping();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tprepareMappingModel( creationProcess, bootEntityDescriptor );\n\t\t\t}\n//\t\t\trootEntityDescriptor = superMappingType.getRootEntityDescriptor();\n\t\t}\n\t\telse {\n\t\t\tprepareMappingModel( creationProcess, bootEntityDescriptor );\n//\t\t\trootEntityDescriptor = this;\n\t\t}\n\n\t\tfinal EntityMetamodel currentEntityMetamodel = getEntityMetamodel();\n\n\t\tif ( currentEntityMetamodel.isVersioned() ) {\n\t\t\tfinal BeforeExecutionGenerator generator = currentEntityMetamodel.getVersionGenerator();\n\t\t\t// need to do this here because EntityMetamodel doesn't have the EntityVersionMapping :-(\n\t\t\tversionGenerator = generator == null ? new VersionGeneration( versionMapping ) : generator;\n\t\t}\n\n\t\tint stateArrayPosition = getStateArrayInitialPosition( creationProcess );\n\n\t\tfinal NonIdentifierAttribute[] properties = currentEntityMetamodel.getProperties();\n\t\tAttributeMappingsMap.Builder mappingsBuilder = AttributeMappingsMap.builder();\n\t\tint fetchableIndex = getFetchableIndexOffset();\n\t\tfor ( int i = 0; i < currentEntityMetamodel.getPropertySpan(); i++ ) {\n\t\t\tfinal NonIdentifierAttribute runtimeAttrDefinition = properties[i];\n\t\t\tfinal Property bootProperty = bootEntityDescriptor.getProperty( runtimeAttrDefinition.getName() );\n\n\t\t\tif ( superMappingType == null\n\t\t\t\t\t|| superMappingType.findAttributeMapping( bootProperty.getName() ) == null ) {\n\t\t\t\tmappingsBuilder.put(\n\t\t\t\t\t\truntimeAttrDefinition.getName(),\n\t\t\t\t\t\tgenerateNonIdAttributeMapping(\n\t\t\t\t\t\t\t\truntimeAttrDefinition,\n\t\t\t\t\t\t\t\tbootProperty,\n\t\t\t\t\t\t\t\tstateArrayPosition++,\n\t\t\t\t\t\t\t\tfetchableIndex++,\n\t\t\t\t\t\t\t\tcreationProcess\n\t\t\t\t\t\t)\n\t\t\t\t);\n\t\t\t}\n\t\t\tdeclaredAttributeMappings = mappingsBuilder.build();\n//\t\t\telse {\n\t\t\t\t// its defined on the supertype, skip it here\n//\t\t\t}\n\t\t}\n\n\t\tgetAttributeMappings();\n\n\t\tpostProcessAttributeMappings( creationProcess, bootEntityDescriptor );\n\n\t\tfinal ReflectionOptimizer reflectionOptimizer = representationStrategy.getReflectionOptimizer();\n\t\taccessOptimizer = reflectionOptimizer != null ? reflectionOptimizer.getAccessOptimizer() : null;\n\n\t\t// register a callback for after all `#prepareMappingModel` calls have finished.  here we want to delay the\n\t\t// generation of `staticFetchableList` because we need to wait until after all subclasses have had their\n\t\t// `#prepareMappingModel` called (and their declared attribute mappings resolved)\n\t\tcreationProcess.registerInitializationCallback(\n\t\t\t\t\"Entity(\" + getEntityName() + \") `staticFetchableList` generator\",\n\t\t\t\t() -> {\n\t\t\t\t\tfinal ImmutableAttributeMappingList.Builder builder =\n\t\t\t\t\t\t\tnew ImmutableAttributeMappingList.Builder( attributeMappings.size() );\n\t\t\t\t\tvisitSubTypeAttributeMappings( builder::add );\n\t\t\t\t\tassert superMappingType != null || builder.assertFetchableIndexes();\n\t\t\t\t\tstaticFetchableList = builder.build();\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t);\n\n\t\tboolean needsMultiTableInsert = hasMultipleTables();\n\t\tif ( needsMultiTableInsert ) {\n\t\t\tcreationProcess.registerInitializationCallback(\n\t\t\t\t\t\"Entity(\" + getEntityName() + \") `sqmMultiTableMutationStrategy` interpretation\",\n\t\t\t\t\t() -> {\n\t\t\t\t\t\tsqmMultiTableMutationStrategy =\n\t\t\t\t\t\t\t\tinterpretSqmMultiTableStrategy( this, creationProcess );\n\t\t\t\t\t\tif ( sqmMultiTableMutationStrategy == null ) {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tsqmMultiTableMutationStrategy.prepare(\n\t\t\t\t\t\t\t\t\tcreationProcess,\n\t\t\t\t\t\t\t\t\tcreationContext.getJdbcServices().getBootstrapJdbcConnectionAccess()\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t);\n\n\t\t}\n\t\telse {\n\t\t\tsqmMultiTableMutationStrategy = null;\n\t\t}\n\n\t\tif ( !needsMultiTableInsert && getGenerator() instanceof BulkInsertionCapableIdentifierGenerator ) {\n\t\t\tif ( getGenerator() instanceof OptimizableGenerator ) {\n\t\t\t\tfinal Optimizer optimizer = ( (OptimizableGenerator) getGenerator() ).getOptimizer();\n\t\t\t\tneedsMultiTableInsert = optimizer != null && optimizer.getIncrementSize() > 1;\n\t\t\t}\n\t\t}\n\n\t\tif ( needsMultiTableInsert ) {\n\t\t\tcreationProcess.registerInitializationCallback(\n\t\t\t\t\t\"Entity(\" + getEntityName() + \") `sqmMultiTableInsertStrategy` interpretation\",\n\t\t\t\t\t() -> {\n\t\t\t\t\t\tsqmMultiTableInsertStrategy =\n\t\t\t\t\t\t\t\tinterpretSqmMultiTableInsertStrategy( this, creationProcess );\n\t\t\t\t\t\tif ( sqmMultiTableInsertStrategy == null ) {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tsqmMultiTableInsertStrategy.prepare(\n\t\t\t\t\t\t\t\t\tcreationProcess,\n\t\t\t\t\t\t\t\t\tcreationContext.getJdbcServices().getBootstrapJdbcConnectionAccess()\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t);\n\n\t\t}\n\t\telse {\n\t\t\tsqmMultiTableInsertStrategy = null;\n\t\t}\n\t}\n\n\tprivate int getFetchableIndexOffset() {\n\t\tif ( superMappingType != null ) {\n\t\t\tfinal EntityMappingType rootEntityDescriptor = getRootEntityDescriptor();\n\t\t\tint offset = rootEntityDescriptor.getNumberOfDeclaredAttributeMappings();\n\t\t\tfor ( EntityMappingType subMappingType : rootEntityDescriptor.getSubMappingTypes() ) {\n\t\t\t\tif ( subMappingType == this ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t// Determining the number of attribute mappings unfortunately has to be done this way,\n\t\t\t\t// because calling `subMappingType.getNumberOfDeclaredAttributeMappings()` at this point\n\t\t\t\t// may produce wrong results because subMappingType might not have completed prepareMappingModel yet\n\t\t\t\tfinal int propertySpan = subMappingType.getEntityPersister().getEntityMetamodel().getPropertySpan();\n\t\t\t\tfinal int superPropertySpan = subMappingType.getSuperMappingType()\n\t\t\t\t\t\t.getEntityPersister()\n\t\t\t\t\t\t.getEntityMetamodel()\n\t\t\t\t\t\t.getPropertySpan();\n\t\t\t\tfinal int numberOfDeclaredAttributeMappings = propertySpan - superPropertySpan;\n\t\t\t\toffset += numberOfDeclaredAttributeMappings;\n\t\t\t}\n\t\t\treturn offset;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tprivate void prepareMappingModel(MappingModelCreationProcess creationProcess, PersistentClass bootEntityDescriptor) {\n\t\tfinal EntityInstantiator instantiator = getRepresentationStrategy().getInstantiator();\n\t\tfinal Supplier<?> templateInstanceCreator;\n\t\tif ( ! instantiator.canBeInstantiated() ) {\n\t\t\ttemplateInstanceCreator = null;\n\t\t}\n\t\telse {\n\t\t\tfinal SessionFactoryImplementor sessionFactory = creationProcess.getCreationContext().getSessionFactory();\n\t\t\ttemplateInstanceCreator = new LazyValue<>( () -> instantiator.instantiate( sessionFactory ) )::getValue;\n\t\t}\n\n\t\tidentifierMapping = creationProcess.processSubPart(\n\t\t\t\tEntityIdentifierMapping.ID_ROLE_NAME,\n\t\t\t\t(role, process) -> generateIdentifierMapping( templateInstanceCreator, bootEntityDescriptor, process )\n\t\t);\n\n\t\tversionMapping = generateVersionMapping( templateInstanceCreator, bootEntityDescriptor, creationProcess );\n\n\t\tif ( rowIdName == null ) {\n\t\t\trowIdMapping = null;\n\t\t}\n\t\telse {\n\t\t\trowIdMapping = creationProcess.processSubPart(\n\t\t\t\t\trowIdName,\n\t\t\t\t\t(role, process) -> new EntityRowIdMappingImpl( rowIdName, getTableName(), this )\n\t\t\t);\n\t\t}\n\n\t\tdiscriminatorMapping = generateDiscriminatorMapping( bootEntityDescriptor );\n\t\tsoftDeleteMapping = resolveSoftDeleteMapping( this, bootEntityDescriptor, getIdentifierTableName(), creationProcess );\n\n\t\tif ( softDeleteMapping != null ) {\n\t\t\tif ( bootEntityDescriptor.getRootClass().getCustomSQLDelete() != null ) {\n\t\t\t\tthrow new UnsupportedMappingException( \"Entity may not define both @SoftDelete and @SQLDelete\" );\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate static SoftDeleteMapping resolveSoftDeleteMapping(\n\t\t\tAbstractEntityPersister persister,\n\t\t\tPersistentClass bootEntityDescriptor,\n\t\t\tString identifierTableName,\n\t\t\tMappingModelCreationProcess creationProcess) {\n\t\tfinal RootClass rootClass = bootEntityDescriptor.getRootClass();\n\t\treturn SoftDeleteHelper.resolveSoftDeleteMapping(\n\t\t\t\tpersister,\n\t\t\t\trootClass,\n\t\t\t\tidentifierTableName,\n\t\t\t\tcreationProcess.getCreationContext().getJdbcServices().getDialect()\n\t\t);\n\t}\n\n\tprivate void postProcessAttributeMappings(MappingModelCreationProcess creationProcess, PersistentClass bootEntityDescriptor) {\n\t\tif ( superMappingType != null ) {\n\t\t\tnaturalIdMapping = superMappingType.getNaturalIdMapping();\n\t\t}\n\t\telse if ( bootEntityDescriptor.hasNaturalId() ) {\n\t\t\tnaturalIdMapping = generateNaturalIdMapping( creationProcess, bootEntityDescriptor );\n\t\t}\n\t\telse {\n\t\t\tnaturalIdMapping = null;\n\t\t}\n\t}\n\n\tprotected NaturalIdMapping generateNaturalIdMapping(MappingModelCreationProcess creationProcess, PersistentClass bootEntityDescriptor) {\n\t\t//noinspection AssertWithSideEffects\n\t\tassert bootEntityDescriptor.hasNaturalId();\n\n\t\tfinal int[] naturalIdAttributeIndexes = entityMetamodel.getNaturalIdentifierProperties();\n\t\tassert naturalIdAttributeIndexes.length > 0;\n\n\t\tif ( naturalIdAttributeIndexes.length == 1 ) {\n\t\t\tfinal String propertyName = entityMetamodel.getPropertyNames()[ naturalIdAttributeIndexes[ 0 ] ];\n\t\t\tfinal AttributeMapping attributeMapping = findAttributeMapping( propertyName );\n\t\t\tfinal SingularAttributeMapping singularAttributeMapping = (SingularAttributeMapping) attributeMapping;\n\t\t\treturn new SimpleNaturalIdMapping( singularAttributeMapping, this, creationProcess );\n\t\t}\n\n\t\t// collect the names of the attributes making up the natural-id.\n\t\tfinal Set<String> attributeNames = setOfSize( naturalIdAttributeIndexes.length );\n\t\tfor ( int naturalIdAttributeIndex : naturalIdAttributeIndexes ) {\n\t\t\tattributeNames.add( this.getPropertyNames()[ naturalIdAttributeIndex ] );\n\t\t}\n\n\t\t// then iterate over the attribute mappings finding the ones having names\n\t\t// in the collected names.  iterate here because it is already alphabetical\n\n\t\tfinal List<SingularAttributeMapping> collectedAttrMappings = new ArrayList<>();\n\t\tfor ( int i = 0; i < attributeMappings.size(); i++ ) {\n\t\t\tfinal AttributeMapping attributeMapping = attributeMappings.get( i );\n\t\t\tif ( attributeNames.contains( attributeMapping.getAttributeName() ) ) {\n\t\t\t\tcollectedAttrMappings.add( (SingularAttributeMapping) attributeMapping );\n\t\t\t}\n\t\t}\n\n\t\tif ( collectedAttrMappings.size() <= 1 ) {\n\t\t\tthrow new MappingException( \"Expected multiple natural-id attributes, but found only one: \" + getEntityName() );\n\t\t}\n\n\t\treturn new CompoundNaturalIdMapping(this, collectedAttrMappings, creationProcess );\n\t}\n\n\tprotected static SqmMultiTableMutationStrategy interpretSqmMultiTableStrategy(\n\t\t\tAbstractEntityPersister entityMappingDescriptor,\n\t\t\tMappingModelCreationProcess creationProcess) {\n\t\tassert entityMappingDescriptor.hasMultipleTables();\n\n\t\tfinal EntityMappingType superMappingType = entityMappingDescriptor.getSuperMappingType();\n\t\tif ( superMappingType != null ) {\n\t\t\tfinal SqmMultiTableMutationStrategy sqmMultiTableMutationStrategy =\n\t\t\t\t\tsuperMappingType.getSqmMultiTableMutationStrategy();\n\t\t\tif ( sqmMultiTableMutationStrategy != null ) {\n\t\t\t\treturn sqmMultiTableMutationStrategy;\n\t\t\t}\n\t\t}\n\n\t\tfinal ServiceRegistry serviceRegistry = creationProcess.getCreationContext().getServiceRegistry();\n\t\treturn serviceRegistry.requireService( SqmMultiTableMutationStrategyProvider.class )\n\t\t\t\t.createMutationStrategy( entityMappingDescriptor, creationProcess );\n\t}\n\n\tprotected static SqmMultiTableInsertStrategy interpretSqmMultiTableInsertStrategy(\n\t\t\tAbstractEntityPersister entityMappingDescriptor,\n\t\t\tMappingModelCreationProcess creationProcess) {\n\t\tfinal ServiceRegistry serviceRegistry = creationProcess.getCreationContext().getServiceRegistry();\n\t\treturn serviceRegistry.requireService( SqmMultiTableMutationStrategyProvider.class )\n\t\t\t\t.createInsertStrategy( entityMappingDescriptor, creationProcess );\n\t}\n\n\t@Override\n\tpublic SqmMultiTableMutationStrategy getSqmMultiTableMutationStrategy() {\n\t\treturn sqmMultiTableMutationStrategy;\n\t}\n\n\t@Override\n\tpublic SqmMultiTableInsertStrategy getSqmMultiTableInsertStrategy() {\n\t\treturn sqmMultiTableInsertStrategy;\n\t}\n\n\tprotected int getStateArrayInitialPosition(MappingModelCreationProcess creationProcess) {\n\t\t// todo (6.0) not sure this is correct in case of SingleTable Inheritance\n\t\t//            and for Table per class when the selection is the root\n\t\tif ( superMappingType == null ) {\n\t\t\treturn 0;\n\t\t}\n\t\telse {\n\t\t\t( (InFlightEntityMappingType) superMappingType ).prepareMappingModel( creationProcess );\n\t\t\treturn superMappingType.getNumberOfAttributeMappings();\n\t\t}\n\t}\n\n\tprotected boolean isPhysicalDiscriminator() {\n\t\treturn getDiscriminatorFormulaTemplate() == null;\n\t}\n\n\tprotected EntityDiscriminatorMapping generateDiscriminatorMapping(PersistentClass bootEntityDescriptor) {\n\t\tif ( getDiscriminatorType() == null ) {\n\t\t\treturn null;\n\t\t}\n\t\telse {\n\t\t\tfinal String discriminatorColumnExpression;\n\t\t\tfinal String columnDefinition;\n\t\t\tfinal Long length;\n\t\t\tfinal Integer precision;\n\t\t\tfinal Integer scale;\n\t\t\tif ( getDiscriminatorFormulaTemplate() == null ) {\n\t\t\t\tfinal Column column = bootEntityDescriptor.getDiscriminator() == null\n\t\t\t\t\t\t? null\n\t\t\t\t\t\t: bootEntityDescriptor.getDiscriminator().getColumns().get( 0 );\n\t\t\t\tdiscriminatorColumnExpression = getDiscriminatorColumnReaders();\n\t\t\t\tif ( column == null ) {\n\t\t\t\t\tcolumnDefinition = null;\n\t\t\t\t\tlength = null;\n\t\t\t\t\tprecision = null;\n\t\t\t\t\tscale = null;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcolumnDefinition = column.getSqlType();\n\t\t\t\t\tlength = column.getLength();\n\t\t\t\t\tprecision = column.getPrecision();\n\t\t\t\t\tscale = column.getScale();\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdiscriminatorColumnExpression = getDiscriminatorFormulaTemplate();\n\t\t\t\tcolumnDefinition = null;\n\t\t\t\tlength = null;\n\t\t\t\tprecision = null;\n\t\t\t\tscale = null;\n\t\t\t}\n\t\t\treturn new ExplicitColumnDiscriminatorMappingImpl(\n\t\t\t\t\tthis,\n\t\t\t\t\tdiscriminatorColumnExpression,\n\t\t\t\t\tgetTableName(),\n\t\t\t\t\tdiscriminatorColumnExpression,\n\t\t\t\t\tgetDiscriminatorFormulaTemplate() != null,\n\t\t\t\t\tisPhysicalDiscriminator(),\n\t\t\t\t\tfalse,\n\t\t\t\t\tcolumnDefinition,\n\t\t\t\t\tnull,\n\t\t\t\t\tlength,\n\t\t\t\t\tprecision,\n\t\t\t\t\tscale,\n\t\t\t\t\t(DiscriminatorType<?>) getTypeDiscriminatorMetadata().getResolutionType()\n\t\t\t);\n\t\t}\n\t}\n\n\t@Override\n\tpublic abstract BasicType<?> getDiscriminatorType();\n\n\tprotected EntityVersionMapping generateVersionMapping(\n\t\t\tSupplier<?> templateInstanceCreator,\n\t\t\tPersistentClass bootEntityDescriptor,\n\t\t\tMappingModelCreationProcess creationProcess) {\n\t\tif ( getVersionType() == null ) {\n\t\t\treturn null;\n\t\t}\n\t\telse {\n\t\t\treturn creationProcess.processSubPart(\n\t\t\t\t\tgetPropertyNames()[getVersionProperty()],\n\t\t\t\t\t(role, process) -> generateVersionMapping(\n\t\t\t\t\t\t\tthis,\n\t\t\t\t\t\t\ttemplateInstanceCreator,\n\t\t\t\t\t\t\tbootEntityDescriptor,\n\t\t\t\t\t\t\tcreationProcess\n\t\t\t\t\t)\n\t\t\t);\n\t\t}\n\t}\n\n\tprotected boolean shouldProcessSuperMapping(){\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic void linkWithSuperType(MappingModelCreationProcess creationProcess) {\n\t\tif ( getMappedSuperclass() != null ) {\n\t\t\tsuperMappingType = creationProcess.getEntityPersister( getMappedSuperclass() );\n\t\t\tfinal InFlightEntityMappingType inFlightEntityMappingType = (InFlightEntityMappingType) superMappingType;\n\t\t\tinFlightEntityMappingType.linkWithSubType(this, creationProcess);\n\t\t\tif ( subclassMappingTypes != null ) {\n\t\t\t\tsubclassMappingTypes.values()\n\t\t\t\t\t\t.forEach( sub -> inFlightEntityMappingType.linkWithSubType(sub, creationProcess) );\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic void linkWithSubType(EntityMappingType sub, MappingModelCreationProcess creationProcess) {\n\t\tif ( subclassMappingTypes == null ) {\n\t\t\tsubclassMappingTypes = new TreeMap<>();\n\t\t}\n\t\tsubclassMappingTypes.put( sub.getEntityName(), sub );\n\t\tif ( superMappingType != null ) {\n\t\t\t( (InFlightEntityMappingType) superMappingType ).linkWithSubType( sub, creationProcess );\n\t\t}\n\t}\n\n\t@Override\n\tpublic int getNumberOfAttributeMappings() {\n\t\tif ( attributeMappings == null ) {\n\t\t\t// force calculation of `attributeMappings`\n\t\t\tgetAttributeMappings();\n\t\t}\n\t\treturn attributeMappings.size();\n\t}\n\n\t@Override\n\tpublic AttributeMapping getAttributeMapping(int position) {\n\t\treturn attributeMappings.get( position );\n\t}\n\n\t@Override\n\tpublic int getNumberOfDeclaredAttributeMappings() {\n\t\treturn declaredAttributeMappings.size();\n\t}\n\n\t@Override\n\tpublic AttributeMappingsMap getDeclaredAttributeMappings() {\n\t\treturn declaredAttributeMappings;\n\t}\n\n\t@Override\n\tpublic void visitDeclaredAttributeMappings(Consumer<? super AttributeMapping> action) {\n\t\tdeclaredAttributeMappings.forEachValue( action );\n\t}\n\n\t@Override\n\tpublic EntityMappingType getSuperMappingType() {\n\t\treturn superMappingType;\n\t}\n\n\t@Override\n\tpublic Collection<EntityMappingType> getSubMappingTypes() {\n\t\treturn subclassMappingTypes == null ? emptyList() : subclassMappingTypes.values();\n\t}\n\n\t@Override\n\tpublic boolean isTypeOrSuperType(EntityMappingType targetType) {\n\t\tif ( targetType == null ) {\n\t\t\t// todo (6.0) : need to think through what this ought to indicate (if we allow it at all)\n\t\t\t//\t\t- see `org.hibernate.metamodel.mapping.internal.AbstractManagedMappingType#isTypeOrSuperType`\n\t\t\treturn true;\n\t\t}\n\t\telse if ( targetType == this ) {\n\t\t\treturn true;\n\t\t}\n\t\telse if ( superMappingType != null ) {\n\t\t\treturn superMappingType.isTypeOrSuperType( targetType );\n\t\t}\n\t\telse {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\n\tprotected EntityIdentifierMapping generateIdentifierMapping(\n\t\t\tSupplier<?> templateInstanceCreator,\n\t\t\tPersistentClass bootEntityDescriptor,\n\t\t\tMappingModelCreationProcess creationProcess) {\n\t\tfinal Type idType = getIdentifierType();\n\n\t\tif ( idType instanceof CompositeType ) {\n\t\t\tfinal CompositeType cidType = (CompositeType) idType;\n\n\t\t\t// NOTE: the term `isEmbedded` here uses Hibernate's older (pre-JPA) naming for its \"non-aggregated\"\n\t\t\t// composite-id support.  It unfortunately conflicts with the JPA usage of \"embedded\".  Here we normalize\n\t\t\t// the legacy naming to the more descriptive encapsulated versus non-encapsulated phrasing\n\n\t\t\tfinal boolean encapsulated = !cidType.isEmbedded();\n\t\t\tif ( encapsulated ) {\n\t\t\t\t// we have an `@EmbeddedId`\n\t\t\t\treturn MappingModelCreationHelper.buildEncapsulatedCompositeIdentifierMapping(\n\t\t\t\t\t\tthis,\n\t\t\t\t\t\tbootEntityDescriptor.getIdentifierProperty(),\n\t\t\t\t\t\tbootEntityDescriptor.getIdentifierProperty().getName(),\n\t\t\t\t\t\tgetTableName(),\n\t\t\t\t\t\trootTableKeyColumnNames,\n\t\t\t\t\t\tcidType,\n\t\t\t\t\t\tcreationProcess\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// otherwise we have a non-encapsulated composite-identifier\n\t\t\treturn generateNonEncapsulatedCompositeIdentifierMapping( creationProcess, bootEntityDescriptor );\n\t\t}\n\t\tfinal String columnDefinition;\n\t\tfinal Long length;\n\t\tfinal Integer precision;\n\t\tfinal Integer scale;\n\t\tif ( bootEntityDescriptor.getIdentifier() == null ) {\n\t\t\tcolumnDefinition = null;\n\t\t\tlength = null;\n\t\t\tprecision = null;\n\t\t\tscale = null;\n\t\t}\n\t\telse {\n\t\t\tColumn column = bootEntityDescriptor.getIdentifier().getColumns().get( 0 );\n\t\t\tcolumnDefinition = column.getSqlType();\n\t\t\tlength = column.getLength();\n\t\t\tprecision = column.getPrecision();\n\t\t\tscale = column.getScale();\n\t\t}\n\n\t\tfinal Value value = bootEntityDescriptor.getIdentifierProperty().getValue();\n\t\treturn new BasicEntityIdentifierMappingImpl(\n\t\t\t\tthis,\n\t\t\t\ttemplateInstanceCreator,\n\t\t\t\tbootEntityDescriptor.getIdentifierProperty().getName(),\n\t\t\t\tgetTableName(),\n\t\t\t\trootTableKeyColumnNames[0],\n\t\t\t\tcolumnDefinition,\n\t\t\t\tlength,\n\t\t\t\tprecision,\n\t\t\t\tscale,\n\t\t\t\tvalue.isColumnInsertable( 0 ),\n\t\t\t\tvalue.isColumnUpdateable( 0 ),\n\t\t\t\t(BasicType<?>) idType,\n\t\t\t\tcreationProcess\n\t\t);\n\t}\n\n\tprotected EntityIdentifierMapping generateNonEncapsulatedCompositeIdentifierMapping(\n\t\t\tMappingModelCreationProcess creationProcess,\n\t\t\tPersistentClass bootEntityDescriptor) {\n\t\treturn MappingModelCreationHelper.buildNonEncapsulatedCompositeIdentifierMapping(\n\t\t\t\tthis,\n\t\t\t\tgetTableName(),\n\t\t\t\tgetRootTableKeyColumnNames(),\n\t\t\t\tbootEntityDescriptor,\n\t\t\t\tcreationProcess\n\t\t);\n\t}\n\n\t/**\n\t * @param entityPersister The AbstractEntityPersister being constructed - still initializing\n\t * @param bootModelRootEntityDescriptor The boot-time entity descriptor for the \"root entity\" in the hierarchy\n\t * @param creationProcess The SF creation process - access to useful things\n\t */\n\tprotected static EntityVersionMapping generateVersionMapping(\n\t\t\tAbstractEntityPersister entityPersister,\n\t\t\tSupplier<?> templateInstanceCreator,\n\t\t\tPersistentClass bootModelRootEntityDescriptor,\n\t\t\tMappingModelCreationProcess creationProcess) {\n\t\tfinal Property versionProperty = bootModelRootEntityDescriptor.getVersion();\n\t\tfinal BasicValue bootModelVersionValue = (BasicValue) versionProperty.getValue();\n\t\tfinal BasicValue.Resolution<?> basicTypeResolution = bootModelVersionValue.resolve();\n\n\t\tfinal Column column = (Column) bootModelVersionValue.getColumn();\n\t\tfinal Dialect dialect = creationProcess.getCreationContext().getDialect();\n\n\t\treturn new EntityVersionMappingImpl(\n\t\t\t\tbootModelRootEntityDescriptor.getRootClass(),\n\t\t\t\ttemplateInstanceCreator,\n\t\t\t\tbootModelRootEntityDescriptor.getVersion().getName(),\n\t\t\t\tentityPersister.getTableName(),\n\t\t\t\tcolumn.getText( dialect ),\n\t\t\t\tcolumn.getSqlType(),\n\t\t\t\tcolumn.getLength(),\n\t\t\t\tcolumn.getPrecision(),\n\t\t\t\tcolumn.getScale(),\n\t\t\t\tcolumn.getTemporalPrecision(),\n\t\t\t\tbasicTypeResolution.getLegacyResolvedBasicType(),\n\t\t\t\tentityPersister,\n\t\t\t\tcreationProcess\n\t\t);\n\t}\n\n\tprotected AttributeMapping generateNonIdAttributeMapping(\n\t\t\tNonIdentifierAttribute tupleAttrDefinition,\n\t\t\tProperty bootProperty,\n\t\t\tint stateArrayPosition,\n\t\t\tint fetchableIndex,\n\t\t\tMappingModelCreationProcess creationProcess) {\n\t\tfinal RuntimeModelCreationContext creationContext = creationProcess.getCreationContext();\n\n\t\tfinal String attrName = tupleAttrDefinition.getName();\n\t\tfinal Type attrType = tupleAttrDefinition.getType();\n\n\t\tfinal int propertyIndex = getPropertyIndex( bootProperty.getName() );\n\n\t\tfinal String tableExpression = getTableName( getPropertyTableNumbers()[propertyIndex] );\n\t\tfinal String[] attrColumnNames = getPropertyColumnNames( propertyIndex );\n\n\t\tfinal PropertyAccess propertyAccess = getRepresentationStrategy().resolvePropertyAccess( bootProperty );\n\n\t\tfinal Value value = bootProperty.getValue();\n\t\tif ( propertyIndex == getVersionProperty() ) {\n\t\t\tColumn column = value.getColumns().get( 0 );\n\t\t\treturn MappingModelCreationHelper.buildBasicAttributeMapping(\n\t\t\t\t\tattrName,\n\t\t\t\t\tgetNavigableRole().append( bootProperty.getName() ),\n\t\t\t\t\tstateArrayPosition,\n\t\t\t\t\tfetchableIndex,\n\t\t\t\t\tbootProperty,\n\t\t\t\t\tthis,\n\t\t\t\t\t(BasicType<?>) attrType,\n\t\t\t\t\ttableExpression,\n\t\t\t\t\tattrColumnNames[0],\n\t\t\t\t\tnull,\n\t\t\t\t\tfalse,\n\t\t\t\t\tnull,\n\t\t\t\t\t\"?\",\n\t\t\t\t\tcolumn.getSqlType(),\n\t\t\t\t\tcolumn.getLength(),\n\t\t\t\t\tcolumn.getPrecision(),\n\t\t\t\t\tcolumn.getScale(),\n\t\t\t\t\tcolumn.getTemporalPrecision(),\n\t\t\t\t\tcolumn.isSqlTypeLob( creationProcess.getCreationContext().getMetadata() ),\n\t\t\t\t\tcolumn.isNullable(),\n\t\t\t\t\tvalue.isColumnInsertable( 0 ),\n\t\t\t\t\tvalue.isColumnUpdateable( 0 ),\n\t\t\t\t\tpropertyAccess,\n\t\t\t\t\ttupleAttrDefinition.getCascadeStyle(),\n\t\t\t\t\tcreationProcess\n\t\t\t);\n\t\t}\n\n\t\tif ( attrType instanceof BasicType ) {\n\t\t\tfinal NavigableRole role = getNavigableRole().append( bootProperty.getName() );\n\t\t\tfinal String attrColumnExpression;\n\t\t\tfinal boolean isAttrColumnExpressionFormula;\n\t\t\tfinal String customReadExpr;\n\t\t\tfinal String customWriteExpr;\n\t\t\tfinal String columnDefinition;\n\t\t\tfinal Long length;\n\t\t\tfinal Integer precision;\n\t\t\tfinal Integer scale;\n\t\t\tfinal Integer temporalPrecision;\n\t\t\tfinal boolean isLob;\n\t\t\tfinal boolean nullable;\n\n\t\t\tif ( value instanceof DependantValue ) {\n\t\t\t\tattrColumnExpression = attrColumnNames[0];\n\t\t\t\tisAttrColumnExpressionFormula = false;\n\t\t\t\tcustomReadExpr = null;\n\t\t\t\tcustomWriteExpr = \"?\";\n\t\t\t\tColumn column = value.getColumns().get( 0 );\n\t\t\t\tcolumnDefinition = column.getSqlType();\n\t\t\t\tlength = column.getLength();\n\t\t\t\tprecision = column.getPrecision();\n\t\t\t\ttemporalPrecision = column.getTemporalPrecision();\n\t\t\t\tscale = column.getScale();\n\t\t\t\tisLob = column.isSqlTypeLob( creationProcess.getCreationContext().getMetadata() );\n\t\t\t\tnullable = column.isNullable();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfinal BasicValue basicBootValue = (BasicValue) value;\n\n\t\t\t\tif ( attrColumnNames[ 0 ] != null ) {\n\t\t\t\t\tattrColumnExpression = attrColumnNames[ 0 ];\n\t\t\t\t\tisAttrColumnExpressionFormula = false;\n\n\t\t\t\t\tfinal List<Selectable> selectables = basicBootValue.getSelectables();\n\t\t\t\t\tassert !selectables.isEmpty();\n\t\t\t\t\tfinal Selectable selectable = selectables.get(0);\n\n\t\t\t\t\tassert attrColumnExpression.equals( selectable.getText( creationContext.getDialect() ) );\n\n\t\t\t\t\tcustomReadExpr = selectable.getTemplate(\n\t\t\t\t\t\t\tcreationContext.getDialect(),\n\t\t\t\t\t\t\tcreationContext.getTypeConfiguration(),\n\t\t\t\t\t\t\tcreationContext.getFunctionRegistry()\n\t\t\t\t\t);\n\t\t\t\t\tcustomWriteExpr = selectable.getWriteExpr( (JdbcMapping) attrType, creationContext.getDialect() );\n\t\t\t\t\tColumn column = value.getColumns().get( 0 );\n\t\t\t\t\tcolumnDefinition = column.getSqlType();\n\t\t\t\t\tlength = column.getLength();\n\t\t\t\t\tprecision = column.getPrecision();\n\t\t\t\t\ttemporalPrecision = column.getTemporalPrecision();\n\t\t\t\t\tscale = column.getScale();\n\t\t\t\t\tnullable = column.isNullable();\n\t\t\t\t\tisLob = column.isSqlTypeLob( creationContext.getMetadata() );\n\t\t\t\t\tMappingModelCreationHelper.resolveAggregateColumnBasicType( creationProcess, role, column );\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tfinal String[] attrColumnFormulaTemplate = propertyColumnFormulaTemplates[ propertyIndex ];\n\t\t\t\t\tattrColumnExpression = attrColumnFormulaTemplate[ 0 ];\n\t\t\t\t\tisAttrColumnExpressionFormula = true;\n\t\t\t\t\tcustomReadExpr = null;\n\t\t\t\t\tcustomWriteExpr = null;\n\t\t\t\t\tcolumnDefinition = null;\n\t\t\t\t\tlength = null;\n\t\t\t\t\tprecision = null;\n\t\t\t\t\ttemporalPrecision = null;\n\t\t\t\t\tscale = null;\n\t\t\t\t\tnullable = true;\n\t\t\t\t\tisLob = false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn MappingModelCreationHelper.buildBasicAttributeMapping(\n\t\t\t\t\tattrName,\n\t\t\t\t\trole,\n\t\t\t\t\tstateArrayPosition,\n\t\t\t\t\tfetchableIndex,\n\t\t\t\t\tbootProperty,\n\t\t\t\t\tthis,\n\t\t\t\t\t(BasicType<?>) value.getType(),\n\t\t\t\t\ttableExpression,\n\t\t\t\t\tattrColumnExpression,\n\t\t\t\t\tnull,\n\t\t\t\t\tisAttrColumnExpressionFormula,\n\t\t\t\t\tcustomReadExpr,\n\t\t\t\t\tcustomWriteExpr,\n\t\t\t\t\tcolumnDefinition,\n\t\t\t\t\tlength,\n\t\t\t\t\tprecision,\n\t\t\t\t\tscale,\n\t\t\t\t\ttemporalPrecision,\n\t\t\t\t\tisLob,\n\t\t\t\t\tnullable,\n\t\t\t\t\tvalue.isColumnInsertable( 0 ),\n\t\t\t\t\tvalue.isColumnUpdateable( 0 ),\n\t\t\t\t\tpropertyAccess,\n\t\t\t\t\ttupleAttrDefinition.getCascadeStyle(),\n\t\t\t\t\tcreationProcess\n\t\t\t);\n\t\t}\n\t\telse if ( attrType instanceof AnyType ) {\n\t\t\tfinal JavaType<Object> baseAssociationJtd =\n\t\t\t\t\tcreationContext.getTypeConfiguration().getJavaTypeRegistry()\n\t\t\t\t\t\t\t.getDescriptor( Object.class );\n\n\t\t\tfinal AnyType anyType = (AnyType) attrType;\n\n\t\t\tfinal MutabilityPlan<?> mutabilityPlan = new DiscriminatedAssociationAttributeMapping.MutabilityPlanImpl( anyType );\n\t\t\tfinal SimpleAttributeMetadata attributeMetadataAccess = new SimpleAttributeMetadata(\n\t\t\t\t\tpropertyAccess,\n\t\t\t\t\tmutabilityPlan,\n\t\t\t\t\tbootProperty.isOptional(),\n\t\t\t\t\tbootProperty.isInsertable(),\n\t\t\t\t\tbootProperty.isUpdateable(),\n\t\t\t\t\tbootProperty.isOptimisticLocked(),\n\t\t\t\t\tbootProperty.isSelectable()\n\t\t\t);\n\n\t\t\treturn new DiscriminatedAssociationAttributeMapping(\n\t\t\t\t\tnavigableRole.append( bootProperty.getName() ),\n\t\t\t\t\tbaseAssociationJtd,\n\t\t\t\t\tthis,\n\t\t\t\t\tstateArrayPosition,\n\t\t\t\t\tfetchableIndex,\n\t\t\t\t\tattributeMetadataAccess,\n\t\t\t\t\tbootProperty.isLazy() ? FetchTiming.DELAYED : FetchTiming.IMMEDIATE,\n\t\t\t\t\tpropertyAccess,\n\t\t\t\t\tbootProperty,\n\t\t\t\t\t(AnyType) attrType,\n\t\t\t\t\t(Any) value,\n\t\t\t\t\tcreationProcess\n\t\t\t);\n\t\t}\n\t\telse if ( attrType instanceof CompositeType ) {\n\t\t\tDependantValue dependantValue = null;\n\t\t\tif ( bootProperty.getValue() instanceof DependantValue ) {\n\t\t\t\tdependantValue = ( (DependantValue) bootProperty.getValue() );\n\t\t\t}\n\n\t\t\treturn buildEmbeddedAttributeMapping(\n\t\t\t\t\tattrName,\n\t\t\t\t\tstateArrayPosition,\n\t\t\t\t\tfetchableIndex,\n\t\t\t\t\tbootProperty,\n\t\t\t\t\tdependantValue,\n\t\t\t\t\t0,\n\t\t\t\t\tthis,\n\t\t\t\t\t(CompositeType) attrType,\n\t\t\t\t\ttableExpression,\n\t\t\t\t\tnull,\n\t\t\t\t\tpropertyAccess,\n\t\t\t\t\ttupleAttrDefinition.getCascadeStyle(),\n\t\t\t\t\tcreationProcess\n\t\t\t);\n\t\t}\n\t\telse if ( attrType instanceof CollectionType ) {\n\t\t\treturn buildPluralAttributeMapping(\n\t\t\t\t\tattrName,\n\t\t\t\t\tstateArrayPosition,\n\t\t\t\t\tfetchableIndex,\n\t\t\t\t\tbootProperty,\n\t\t\t\t\tthis,\n\t\t\t\t\tpropertyAccess,\n\t\t\t\t\ttupleAttrDefinition.getCascadeStyle(),\n\t\t\t\t\tgetFetchMode( stateArrayPosition ),\n\t\t\t\t\tcreationProcess\n\t\t\t);\n\t\t}\n\t\telse if ( attrType instanceof EntityType ) {\n\t\t\treturn buildSingularAssociationAttributeMapping(\n\t\t\t\t\tattrName,\n\t\t\t\t\tgetNavigableRole().append( attrName ),\n\t\t\t\t\tstateArrayPosition,\n\t\t\t\t\tfetchableIndex,\n\t\t\t\t\tbootProperty,\n\t\t\t\t\tthis,\n\t\t\t\t\tthis,\n\t\t\t\t\t(EntityType) attrType,\n\t\t\t\t\tpropertyAccess,\n\t\t\t\t\ttupleAttrDefinition.getCascadeStyle(),\n\t\t\t\t\tcreationProcess\n\t\t\t);\n\t\t}\n\n\t\t// todo (6.0) : for now ignore any non basic-typed attributes\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * For Hibernate Reactive\n\t */\n\tprotected EmbeddedAttributeMapping buildEmbeddedAttributeMapping(\n\t\t\tString attrName,\n\t\t\tint stateArrayPosition,\n\t\t\tint fetchableIndex,\n\t\t\tProperty bootProperty,\n\t\t\tDependantValue dependantValue,\n\t\t\tint dependantColumnIndex,\n\t\t\tManagedMappingType declaringType,\n\t\t\tCompositeType attrType,\n\t\t\tString tableExpression,\n\t\t\tString[] rootTableKeyColumnNames,\n\t\t\tPropertyAccess propertyAccess,\n\t\t\tCascadeStyle cascadeStyle,\n\t\t\tMappingModelCreationProcess creationProcess) {\n\t\treturn MappingModelCreationHelper.buildEmbeddedAttributeMapping(\n\t\t\t\tattrName,\n\t\t\t\tstateArrayPosition,\n\t\t\t\tfetchableIndex,\n\t\t\t\tbootProperty,\n\t\t\t\tdependantValue,\n\t\t\t\tdependantColumnIndex,\n\t\t\t\tdeclaringType,\n\t\t\t\tattrType,\n\t\t\t\ttableExpression,\n\t\t\t\trootTableKeyColumnNames,\n\t\t\t\tpropertyAccess,\n\t\t\t\tcascadeStyle,\n\t\t\t\tcreationProcess\n\t\t);\n\t}\n\n\t/**\n\t * For Hibernate Reactive\n\t */\n\tprotected AttributeMapping buildSingularAssociationAttributeMapping(\n\t\t\tString attrName,\n\t\t\tNavigableRole navigableRole,\n\t\t\tint stateArrayPosition,\n\t\t\tint fetchableIndex,\n\t\t\tProperty bootProperty,\n\t\t\tManagedMappingType declaringType,\n\t\t\tEntityPersister declaringEntityPersister,\n\t\t\tEntityType attrType,\n\t\t\tPropertyAccess propertyAccess,\n\t\t\tCascadeStyle cascadeStyle,\n\t\t\tMappingModelCreationProcess creationProcess) {\n\t\treturn MappingModelCreationHelper.buildSingularAssociationAttributeMapping(\n\t\t\t\tattrName,\n\t\t\t\tnavigableRole,\n\t\t\t\tstateArrayPosition,\n\t\t\t\tfetchableIndex,\n\t\t\t\tbootProperty,\n\t\t\t\tdeclaringType,\n\t\t\t\tdeclaringEntityPersister,\n\t\t\t\tattrType,\n\t\t\t\tpropertyAccess,\n\t\t\t\tcascadeStyle,\n\t\t\t\tcreationProcess\n\t\t);\n\t}\n\n\t/**\n\t * For Hibernate Reactive\n\t */\n\tprotected AttributeMapping buildPluralAttributeMapping(\n\t\t\tString attrName,\n\t\t\tint stateArrayPosition,\n\t\t\tint fetchableIndex,\n\t\t\tProperty bootProperty,\n\t\t\tManagedMappingType declaringType,\n\t\t\tPropertyAccess propertyAccess,\n\t\t\tCascadeStyle cascadeStyle,\n\t\t\tFetchMode fetchMode,\n\t\t\tMappingModelCreationProcess creationProcess) {\n\t\treturn MappingModelCreationHelper.buildPluralAttributeMapping(\n\t\t\t\tattrName,\n\t\t\t\tstateArrayPosition,\n\t\t\t\tfetchableIndex,\n\t\t\t\tbootProperty,\n\t\t\t\tdeclaringType,\n\t\t\t\tpropertyAccess,\n\t\t\t\tcascadeStyle,\n\t\t\t\tfetchMode,\n\t\t\t\tcreationProcess\n\t\t);\n\t}\n\n\t@Override\n\tpublic JavaType<?> getMappedJavaType() {\n\t\treturn javaType;\n\t}\n\n\t@Override\n\tpublic EntityPersister getEntityPersister() {\n\t\treturn this;\n\t}\n\n\t@Override\n\tpublic EntityIdentifierMapping getIdentifierMapping() {\n\t\treturn identifierMapping;\n\t}\n\n\t@Override\n\tpublic EntityVersionMapping getVersionMapping() {\n\t\treturn versionMapping;\n\t}\n\n\t@Override\n\tpublic EntityRowIdMapping getRowIdMapping() {\n\t\treturn rowIdMapping;\n\t}\n\n\t@Override\n\tpublic EntityDiscriminatorMapping getDiscriminatorMapping() {\n\t\treturn discriminatorMapping;\n\t}\n\n\t@Override\n\tpublic SoftDeleteMapping getSoftDeleteMapping() {\n\t\treturn softDeleteMapping;\n\t}\n\n\t@Override\n\tpublic AttributeMappingsList getAttributeMappings() {\n\t\tif ( attributeMappings == null ) {\n\t\t\tint sizeHint = declaredAttributeMappings.size();\n\t\t\tsizeHint += (superMappingType == null ? 0 : superMappingType.getAttributeMappings().size() );\n\t\t\tImmutableAttributeMappingList.Builder builder = new ImmutableAttributeMappingList.Builder( sizeHint );\n\n\t\t\tif ( superMappingType != null ) {\n\t\t\t\tsuperMappingType.forEachAttributeMapping( builder::add );\n\t\t\t}\n\n\t\t\tfor ( AttributeMapping am : declaredAttributeMappings.valueIterator() ) {\n\t\t\t\tbuilder.add( am );\n\t\t\t}\n\t\t\tthis.attributeMappings = builder.build();\n\t\t\tfinal Getter[] getters = new Getter[attributeMappings.size()];\n\t\t\tfinal Setter[] setters = new Setter[attributeMappings.size()];\n\t\t\tfor ( int i = 0; i < attributeMappings.size(); i++ ) {\n\t\t\t\tfinal PropertyAccess propertyAccess = attributeMappings.get( i ).getAttributeMetadata().getPropertyAccess();\n\t\t\t\tgetters[i] = propertyAccess.getGetter();\n\t\t\t\tsetters[i] = propertyAccess.getSetter();\n\t\t\t}\n\t\t\tthis.getterCache = getters;\n\t\t\tthis.setterCache = setters;\n\t\t\t// subclasses?  it depends on the usage\n\t\t}\n\n\t\treturn attributeMappings;\n\t}\n\n\t@Override\n\tpublic AttributeMapping findDeclaredAttributeMapping(String name) {\n\t\treturn declaredAttributeMappings.get( name );\n\t}\n\n\t@Override\n\tpublic AttributeMapping findAttributeMapping(String name) {\n\t\tfinal AttributeMapping declaredAttribute = declaredAttributeMappings.get( name );\n\t\tif ( declaredAttribute != null ) {\n\t\t\treturn declaredAttribute;\n\t\t}\n\n\t\tif ( superMappingType != null ) {\n\t\t\treturn superMappingType.findAttributeMapping( name );\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic ModelPart findSubPart(String name, EntityMappingType treatTargetType) {\n\t\tLOG.tracef( \"#findSubPart(`%s`)\", name );\n\n\t\tif ( EntityDiscriminatorMapping.matchesRoleName( name ) ) {\n\t\t\treturn discriminatorMapping;\n\t\t}\n\n\t\tfinal AttributeMapping declaredAttribute = declaredAttributeMappings.get( name );\n\t\tif ( declaredAttribute != null ) {\n\t\t\treturn declaredAttribute;\n\t\t}\n\n\t\tif ( superMappingType != null ) {\n\t\t\tfinal ModelPart superDefinedAttribute = superMappingType.findSubPart( name, superMappingType );\n\t\t\tif ( superDefinedAttribute != null ) {\n\t\t\t\t// Prefer the identifier mapping of the concrete class\n\t\t\t\tif ( superDefinedAttribute.isEntityIdentifierMapping() ) {\n\t\t\t\t\tfinal ModelPart identifierModelPart = getIdentifierModelPart( name, treatTargetType );\n\t\t\t\t\tif ( identifierModelPart != null ) {\n\t\t\t\t\t\treturn identifierModelPart;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn superDefinedAttribute;\n\t\t\t}\n\t\t}\n\n\t\tif ( treatTargetType != null ) {\n\t\t\tif ( ! treatTargetType.isTypeOrSuperType( this ) ) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tif ( subclassMappingTypes != null && !subclassMappingTypes.isEmpty() ) {\n\t\t\t\tfor ( EntityMappingType subMappingType : subclassMappingTypes.values() ) {\n\t\t\t\t\tif ( ! treatTargetType.isTypeOrSuperType( subMappingType ) ) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tfinal ModelPart subDefinedAttribute = subMappingType.findSubTypesSubPart( name, treatTargetType );\n\n\t\t\t\t\tif ( subDefinedAttribute != null ) {\n\t\t\t\t\t\treturn subDefinedAttribute;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif ( subclassMappingTypes != null && !subclassMappingTypes.isEmpty() ) {\n\t\t\t\tModelPart attribute = null;\n\t\t\t\tfor ( EntityMappingType subMappingType : subclassMappingTypes.values() ) {\n\t\t\t\t\tfinal ModelPart subDefinedAttribute = subMappingType.findSubTypesSubPart( name, treatTargetType );\n\t\t\t\t\tif ( subDefinedAttribute != null ) {\n\t\t\t\t\t\tif ( attribute != null && !MappingModelHelper.isCompatibleModelPart( attribute, subDefinedAttribute ) ) {\n\t\t\t\t\t\t\tthrow new PathException(\n\t\t\t\t\t\t\t\t\tString.format(\n\t\t\t\t\t\t\t\t\t\t\tLocale.ROOT,\n\t\t\t\t\t\t\t\t\t\t\t\"Could not resolve attribute '%s' of '%s' due to the attribute being declared in multiple subtypes '%s' and '%s'\",\n\t\t\t\t\t\t\t\t\t\t\tname,\n\t\t\t\t\t\t\t\t\t\t\tgetJavaType().getTypeName(),\n\t\t\t\t\t\t\t\t\t\t\tattribute.asAttributeMapping().getDeclaringType()\n\t\t\t\t\t\t\t\t\t\t\t\t\t.getJavaType().getTypeName(),\n\t\t\t\t\t\t\t\t\t\t\tsubDefinedAttribute.asAttributeMapping().getDeclaringType()\n\t\t\t\t\t\t\t\t\t\t\t\t\t.getJavaType().getTypeName()\n\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tattribute = subDefinedAttribute;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif ( attribute != null ) {\n\t\t\t\t\treturn attribute;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfinal ModelPart identifierModelPart = getIdentifierModelPart( name, treatTargetType );\n\t\tif ( identifierModelPart != null ) {\n\t\t\treturn identifierModelPart;\n\t\t}\n\t\telse {\n\t\t\tfor ( AttributeMapping attribute : declaredAttributeMappings.valueIterator() ) {\n\t\t\t\tif ( attribute instanceof EmbeddableValuedModelPart && attribute instanceof VirtualModelPart ) {\n\t\t\t\t\tEmbeddableValuedModelPart part = (EmbeddableValuedModelPart) attribute;\n\t\t\t\t\tfinal ModelPart subPart = part.findSubPart( name, null );\n\t\t\t\t\tif ( subPart != null ) {\n\t\t\t\t\t\treturn subPart;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t@Override\n\tpublic ModelPart findSubTypesSubPart(String name, EntityMappingType treatTargetType) {\n\t\tfinal AttributeMapping declaredAttribute = declaredAttributeMappings.get( name );\n\t\tif ( declaredAttribute != null ) {\n\t\t\treturn declaredAttribute;\n\t\t}\n\t\telse {\n\t\t\tif ( subclassMappingTypes != null && !subclassMappingTypes.isEmpty() ) {\n\t\t\t\tfor ( EntityMappingType subMappingType : subclassMappingTypes.values() ) {\n\t\t\t\t\tfinal ModelPart subDefinedAttribute = subMappingType.findSubTypesSubPart( name, treatTargetType );\n\t\t\t\t\tif ( subDefinedAttribute != null ) {\n\t\t\t\t\t\treturn subDefinedAttribute;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tprivate ModelPart getIdentifierModelPart(String name, EntityMappingType treatTargetType) {\n\t\tfinal EntityIdentifierMapping identifierMapping = getIdentifierMappingForJoin();\n\t\tif ( identifierMapping instanceof NonAggregatedIdentifierMapping ) {\n\t\t\tNonAggregatedIdentifierMapping mapping = (NonAggregatedIdentifierMapping) identifierMapping;\n\t\t\tfinal ModelPart subPart = mapping.findSubPart( name, treatTargetType );\n\t\t\tif ( subPart != null ) {\n\t\t\t\treturn subPart;\n\t\t\t}\n\t\t}\n\n\t\tif ( isIdentifierReference( name ) ) {\n\t\t\treturn identifierMapping;\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tprivate boolean isIdentifierReference(String name) {\n\t\treturn EntityIdentifierMapping.ID_ROLE_NAME.equals( name )\n\t\t\t|| hasIdentifierProperty() && getIdentifierPropertyName().equals( name )\n\t\t\t|| !entityMetamodel.hasNonIdentifierPropertyNamedId() && \"id\".equals( name );\n\t}\n\n\t@Override\n\tpublic void visitSubParts(\n\t\t\tConsumer<ModelPart> consumer,\n\t\t\tEntityMappingType treatTargetType) {\n\t\tconsumer.accept( identifierMapping );\n\t\tdeclaredAttributeMappings.forEachValue( consumer );\n\t}\n\n\t@Override\n\tpublic void visitKeyFetchables(Consumer<? super Fetchable> fetchableConsumer, EntityMappingType treatTargetType) {\n\t\t// No-op\n\t}\n\n\t@Override\n\tpublic void visitKeyFetchables(IndexedConsumer<? super Fetchable> fetchableConsumer, EntityMappingType treatTargetType) {\n\t\t// No-op\n\t}\n\n\t@Override\n\tpublic int getNumberOfFetchables() {\n\t\treturn getStaticFetchableList().size();\n\t}\n\n\t@Override\n\tpublic int getNumberOfFetchableKeys() {\n\t\treturn superMappingType == null ? getNumberOfFetchables() : getRootEntityDescriptor().getNumberOfFetchables();\n\t}\n\n\t@Override\n\tpublic Fetchable getKeyFetchable(int position) {\n\t\tthrow new IndexOutOfBoundsException( position );\n\t}\n\n\t@Override\n\tpublic Fetchable getFetchable(int position) {\n\t\treturn getStaticFetchableList().get( position );\n\t}\n\n\t@Override\n\tpublic void visitFetchables(Consumer<? super Fetchable> fetchableConsumer, EntityMappingType treatTargetType) {\n\t\tif ( treatTargetType == null ) {\n\t\t\tgetStaticFetchableList().forEach( fetchableConsumer );\n//\t\t\tstaticFetchableList.forEach( fetchableConsumer );\n\t\t}\n\t\telse {\n\t\t\tif ( treatTargetType.isTypeOrSuperType( this ) ) {\n\t\t\t\tvisitSubTypeAttributeMappings( fetchableConsumer );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tattributeMappings.forEach( fetchableConsumer );\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic void visitFetchables(IndexedConsumer<? super Fetchable> fetchableConsumer, EntityMappingType treatTargetType) {\n\t\tif ( treatTargetType == null ) {\n\t\t\tgetStaticFetchableList().indexedForEach( fetchableConsumer );\n\t\t}\n\t\telse {\n\t\t\tattributeMappings.indexedForEach( fetchableConsumer );\n\t\t\tif ( treatTargetType.isTypeOrSuperType( this ) ) {\n\t\t\t\tif ( subclassMappingTypes != null ) {\n\t\t\t\t\tint offset = attributeMappings.size();\n\t\t\t\t\tfor ( EntityMappingType subtype : subclassMappingTypes.values() ) {\n\t\t\t\t\t\tfinal AttributeMappingsMap declaredAttributeMappings = subtype.getDeclaredAttributeMappings();\n\t\t\t\t\t\tfor ( AttributeMapping declaredAttributeMapping : declaredAttributeMappings.valueIterator() ) {\n\t\t\t\t\t\t\tfetchableConsumer.accept( offset++, declaredAttributeMapping );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprotected AttributeMappingsList getStaticFetchableList() {\n\t\treturn staticFetchableList;\n\t}\n\n\t@Override\n\tpublic void visitAttributeMappings(Consumer<? super AttributeMapping> action) {\n\t\tattributeMappings.forEach( action );\n\t}\n\n\t@Override\n\tpublic void visitSuperTypeAttributeMappings(Consumer<? super AttributeMapping> action) {\n\t\tif ( superMappingType != null ) {\n\t\t\tsuperMappingType.visitSuperTypeAttributeMappings( action );\n\t\t}\n\t}\n\n\t@Override\n\tpublic int forEachSelectable(int offset, SelectableConsumer selectableConsumer) {\n\t\tint span = 0;\n\t\tfor ( int i = 0; i < attributeMappings.size(); i++ ) {\n\t\t\tfinal AttributeMapping attributeMapping = attributeMappings.get( i );\n\t\t\tspan += attributeMapping.forEachSelectable( span + offset, selectableConsumer );\n\t\t}\n\t\treturn span;\n\t}\n\n\t@Override\n\tpublic void visitSubTypeAttributeMappings(Consumer<? super AttributeMapping> action) {\n\t\tforEachAttributeMapping( action );\n\t\tif ( subclassMappingTypes != null ) {\n\t\t\tfor ( EntityMappingType subType : subclassMappingTypes.values() ) {\n\t\t\t\tsubType.visitDeclaredAttributeMappings( action );\n\t\t\t}\n\t\t}\n\t}\n\n\t// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\t// EntityDefinition impl (walking model - deprecated)\n\n\t@Override\n\tpublic int getJdbcTypeCount() {\n\t\treturn getIdentifierMapping().getJdbcTypeCount();\n\t}\n\n\t@Override\n\tpublic int forEachJdbcType(int offset, IndexedConsumer<JdbcMapping> action) {\n\t\treturn getIdentifierMapping().forEachJdbcType( offset, action );\n\t}\n\n\t@Override\n\tpublic Object disassemble(Object value, SharedSessionContractImplementor session) {\n\t\tif ( value == null ) {\n\t\t\treturn null;\n\t\t}\n\t\tfinal EntityIdentifierMapping identifierMapping = getIdentifierMapping();\n\t\tfinal Object identifier = identifierMapping.getIdentifier( value );\n\t\treturn identifierMapping.disassemble( identifier, session );\n\t}\n\n\t@Override\n\tpublic <X, Y> int forEachDisassembledJdbcValue(\n\t\t\tObject value,\n\t\t\tint offset,\n\t\t\tX x,\n\t\t\tY y,\n\t\t\tJdbcValuesBiConsumer<X, Y> valuesConsumer,\n\t\t\tSharedSessionContractImplementor session) {\n\t\treturn getIdentifierMapping()\n\t\t\t\t.forEachDisassembledJdbcValue( value, offset, x, y, valuesConsumer, session );\n\t}\n\n\t@Override\n\tpublic <X, Y> int forEachJdbcValue(\n\t\t\tObject value,\n\t\t\tint offset,\n\t\t\tX x,\n\t\t\tY y,\n\t\t\tJdbcValuesBiConsumer<X, Y> consumer,\n\t\t\tSharedSessionContractImplementor session) {\n\t\tfinal EntityIdentifierMapping identifierMapping = getIdentifierMapping();\n\t\tfinal Object identifier = value == null ? null\n\t\t\t\t: identifierMapping.disassemble( identifierMapping.getIdentifier( value ), session );\n\t\treturn identifierMapping.forEachDisassembledJdbcValue( identifier, offset, x, y, consumer, session );\n\t}\n\n\t@Override\n\tpublic boolean hasPartitionedSelectionMapping() {\n\t\treturn hasPartitionedSelectionMapping;\n\t}\n\n\tpublic abstract boolean isTableCascadeDeleteEnabled(int j);\n\n\n\t// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\t// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\t// State built and stored here during instantiation, and only used in other\n\t// phases of initialization\n\t//\t\t- postConstruct\n\t//\t\t- postInstantiate\n\t//\t\t- prepareMappingModel\n\t//\t\t- ...\n\t//\n\t// This is effectively bootstrap state that is kept around during runtime.\n\t//\n\t// Would be better to encapsulate and store this state relative to the\n\t// `PersisterCreationContext` so it can get released after bootstrap\n\t// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\t// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n\t@Deprecated protected Expectation[] insertExpectations;\n\t@Deprecated protected Expectation[] updateExpectations;\n\t@Deprecated protected Expectation[] deleteExpectations;\n\n\t@Deprecated protected boolean[] insertCallable;\n\t@Deprecated protected boolean[] updateCallable;\n\t@Deprecated protected boolean[] deleteCallable;\n\n\t@Deprecated protected String[] customSQLInsert;\n\t@Deprecated protected String[] customSQLUpdate;\n\t@Deprecated protected String[] customSQLDelete;\n\n\n\n\t// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\t// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\t// State related to this we handle differently in 6+.  In other words, state\n\t// that is no longer needed\n\t// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\t// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n\t@Deprecated private final EntityMetamodel entityMetamodel;\n\n\t@Deprecated private final String[] subclassColumnAliasClosure;\n\t@Deprecated private final String[] subclassFormulaAliasClosure;\n\t@Deprecated private final Map<String,String[]> subclassPropertyAliases = new HashMap<>();\n\n\t/**\n\t * @deprecated Hibernate no longer uses aliases to read from result sets\n\t */\n\t@Deprecated\tprotected String[] getSubclassColumnAliasClosure() {\n\t\treturn subclassColumnAliasClosure;\n\t}\n\n\t/**\n\t * @deprecated Hibernate no longer uses aliases to read from result sets\n\t */\n\t@Deprecated\tprotected String[] getSubclassFormulaAliasClosure() {\n\t\treturn subclassFormulaAliasClosure;\n\t}\n\n\t/**\n\t * @deprecated Hibernate no longer uses aliases to read from result sets\n\t */\n\t@Deprecated\t@Override\n\tpublic String[] getSubclassPropertyColumnAliases(String propertyName, String suffix) {\n\t\tfinal String[] rawAliases = subclassPropertyAliases.get( propertyName );\n\t\tif ( rawAliases == null ) {\n\t\t\treturn null;\n\t\t}\n\t\telse {\n\t\t\tfinal String[] result = new String[rawAliases.length];\n\t\t\tfor ( int i = 0; i < rawAliases.length; i++ ) {\n\t\t\t\tresult[i] = new Alias( suffix ).toUnquotedAliasString( rawAliases[i] );\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t}\n\n\t/**\n\t * Must be called by subclasses, at the end of their constructors\n\t *\n\t * @deprecated Hibernate no longer uses aliases to read from result sets\n\t */\n\t@Deprecated\tprotected void initSubclassPropertyAliasesMap(PersistentClass model) throws MappingException {\n\n\t\t// ALIASES\n\t\tinternalInitSubclassPropertyAliasesMap( null, model.getSubclassPropertyClosure() );\n\n\t\t// aliases for identifier ( alias.id ); skip if the entity defines a non-id property named 'id'\n\t\tif ( !entityMetamodel.hasNonIdentifierPropertyNamedId() ) {\n\t\t\tsubclassPropertyAliases.put( ENTITY_ID, getIdentifierAliases() );\n\t\t}\n\n\t\t// aliases named identifier ( alias.idname )\n\t\tif ( hasIdentifierProperty() ) {\n\t\t\tsubclassPropertyAliases.put( getIdentifierPropertyName(), getIdentifierAliases() );\n\t\t}\n\n\t\t// aliases for composite-id's\n\t\tif ( getIdentifierType().isComponentType() ) {\n\t\t\t// Fetch embedded identifiers property names from the \"virtual\" identifier component\n\t\t\tfinal CompositeType componentId = (CompositeType) getIdentifierType();\n\t\t\tfinal String[] idPropertyNames = componentId.getPropertyNames();\n\t\t\tfinal String[] idAliases = getIdentifierAliases();\n\n\t\t\tfor ( int i = 0; i < idPropertyNames.length; i++ ) {\n\t\t\t\tif ( entityMetamodel.hasNonIdentifierPropertyNamedId() ) {\n\t\t\t\t\tsubclassPropertyAliases.put(\n\t\t\t\t\t\t\tENTITY_ID + \".\" + idPropertyNames[i],\n\t\t\t\t\t\t\tnew String[] {idAliases[i]}\n\t\t\t\t\t);\n\t\t\t\t}\n//\t\t\t\tif (hasIdentifierProperty() && !ENTITY_ID.equals( getIdentifierPropertyNames() ) ) {\n\t\t\t\tif ( hasIdentifierProperty() ) {\n\t\t\t\t\tsubclassPropertyAliases.put(\n\t\t\t\t\t\t\tgetIdentifierPropertyName() + \".\" + idPropertyNames[i],\n\t\t\t\t\t\t\tnew String[] {idAliases[i]}\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// embedded composite ids ( alias.idName1, alias.idName2 )\n\t\t\t\t\tsubclassPropertyAliases.put( idPropertyNames[i], new String[] {idAliases[i]} );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ( entityMetamodel.isPolymorphic() ) {\n\t\t\tsubclassPropertyAliases.put( ENTITY_CLASS, new String[] {getDiscriminatorAlias()} );\n\t\t}\n\n\t}\n\n\tprivate void internalInitSubclassPropertyAliasesMap(String path, List<Property> properties) {\n\t\tfor (Property property : properties) {\n\t\t\tfinal String name = path == null ? property.getName() : path + \".\" + property.getName();\n\t\t\tif ( property.isComposite() ) {\n\t\t\t\tComponent component = (Component) property.getValue();\n\t\t\t\tinternalInitSubclassPropertyAliasesMap( name, component.getProperties() );\n\t\t\t}\n\n\t\t\tString[] aliases = new String[property.getColumnSpan()];\n\t\t\tint l = 0;\n\t\t\tfor ( Selectable selectable: property.getSelectables() ) {\n\t\t\t\tDialect dialect = getFactory().getJdbcServices().getDialect();\n\t\t\t\taliases[l] = selectable.getAlias( dialect, property.getValue().getTable() );\n\t\t\t\tl++;\n\t\t\t}\n\n\t\t\tsubclassPropertyAliases.put( name, aliases );\n\t\t}\n\n\t}\n\n\tpublic String getDiscriminatorAlias() {\n\t\treturn DISCRIMINATOR_ALIAS;\n\t}\n\n\tprotected String getSqlWhereStringTableExpression(){\n\t\treturn sqlWhereStringTableExpression;\n\t}\n}\n",
        "diffSourceCodeSet": [
            "private static CacheLayout queryCacheLayout(CacheLayout entityQueryCacheLayout, SessionFactoryOptions options) {\n\t\treturn entityQueryCacheLayout == null ? options.getQueryCacheLayout() : entityQueryCacheLayout;\n\t}"
        ],
        "invokedMethodSet": [],
        "sourceCodeAfterRefactoring": "private static boolean shouldStoreDiscriminatorInShallowQueryCacheLayout(\n\t\t\tCacheLayout entityQueryCacheLayout, SessionFactoryOptions options) {\n\t\treturn queryCacheLayout( entityQueryCacheLayout, options ) == CacheLayout.SHALLOW_WITH_DISCRIMINATOR;\n\t}\nprivate static CacheLayout queryCacheLayout(CacheLayout entityQueryCacheLayout, SessionFactoryOptions options) {\n\t\treturn entityQueryCacheLayout == null ? options.getQueryCacheLayout() : entityQueryCacheLayout;\n\t}",
        "diffSourceCode": "-  907: \n-  908: \tprivate boolean shouldUseShallowCacheLayout(CacheLayout entityQueryCacheLayout, SessionFactoryOptions options) {\n-  909: \t\tfinal CacheLayout queryCacheLayout;\n-  920: \tprivate boolean shouldStoreDiscriminatorInShallowQueryCacheLayout(CacheLayout entityQueryCacheLayout, SessionFactoryOptions options) {\n-  921: \t\tfinal CacheLayout queryCacheLayout;\n-  922: \t\tif ( entityQueryCacheLayout == null ) {\n-  923: \t\t\tqueryCacheLayout = options.getQueryCacheLayout();\n-  924: \t\t}\n-  925: \t\telse {\n-  926: \t\t\tqueryCacheLayout = entityQueryCacheLayout;\n-  927: \t\t}\n-  928: \t\treturn queryCacheLayout == CacheLayout.SHALLOW_WITH_DISCRIMINATOR;\n-  929: \t}\n+  907: \tprivate static CacheLayout queryCacheLayout(CacheLayout entityQueryCacheLayout, SessionFactoryOptions options) {\n+  908: \t\treturn entityQueryCacheLayout == null ? options.getQueryCacheLayout() : entityQueryCacheLayout;\n+  909: \t}\n+  920: \t\t}\n+  921: \t}\n+  922: \n+  923: \tprivate static boolean shouldStoreDiscriminatorInShallowQueryCacheLayout(\n+  924: \t\t\tCacheLayout entityQueryCacheLayout, SessionFactoryOptions options) {\n+  925: \t\treturn queryCacheLayout( entityQueryCacheLayout, options ) == CacheLayout.SHALLOW_WITH_DISCRIMINATOR;\n+  926: \t}\n+  927: \n+  928: \tprotected abstract String[] getSubclassTableNames();\n+  929: \n",
        "uniqueId": "afca93158edb43fe886cb68059040f43675e6ec2_920_929_907_909_923_926",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 0,
                "covered": 15
            },
            "BRANCH": {
                "missed": 0,
                "covered": 4
            },
            "LINE": {
                "missed": 0,
                "covered": 4
            },
            "COMPLEXITY": {
                "missed": 0,
                "covered": 3
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 21
    },
    {
        "type": "Inline Method",
        "description": "Inline Method\tprotected createAssemblers(parent InitializerParent<?>, resultDescriptor EmbeddableResultGraphNode, creationState AssemblerCreationState, embeddableTypeDescriptor EmbeddableMappingType, fetchConverter Function<Fetch,Fetch>) : DomainResultAssembler<?>[] inlined to protected NonAggregatedIdentifierMappingInitializer(resultDescriptor EmbeddableResultGraphNode, parent InitializerParent<?>, creationState AssemblerCreationState, isResultInitializer boolean, fetchConverter Function<Fetch,Fetch>) in class org.hibernate.sql.results.graph.embeddable.internal.NonAggregatedIdentifierMappingInitializer",
        "diffLocations": [
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/sql/results/graph/embeddable/internal/NonAggregatedIdentifierMappingInitializer.java",
                "startLine": 109,
                "endLine": 160,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/sql/results/graph/embeddable/internal/NonAggregatedIdentifierMappingInitializer.java",
                "startLine": 112,
                "endLine": 189,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/sql/results/graph/embeddable/internal/NonAggregatedIdentifierMappingInitializer.java",
                "startLine": 162,
                "endLine": 181,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "protected static DomainResultAssembler<?>[] createAssemblers(\n\t\t\tInitializerParent<?> parent,\n\t\t\tEmbeddableResultGraphNode resultDescriptor,\n\t\t\tAssemblerCreationState creationState,\n\t\t\tEmbeddableMappingType embeddableTypeDescriptor,\n\t\t\tFunction<Fetch, Fetch> fetchConverter) {\n\t\tfinal int size = embeddableTypeDescriptor.getNumberOfFetchables();\n\t\tfinal DomainResultAssembler<?>[] assemblers = new DomainResultAssembler[size];\n\t\tfor ( int i = 0; i < size; i++ ) {\n\t\t\tfinal Fetchable stateArrayContributor = embeddableTypeDescriptor.getFetchable( i );\n\t\t\tfinal Fetch fetch = fetchConverter.apply( resultDescriptor.findFetch( stateArrayContributor ) );\n\n\t\t\tfinal DomainResultAssembler<?> stateAssembler = fetch == null\n\t\t\t\t\t? new NullValueAssembler<>( stateArrayContributor.getJavaType() )\n\t\t\t\t\t: fetch.createAssembler( parent, creationState );\n\n\t\t\tassemblers[i] = stateAssembler;\n\t\t}\n\t\treturn assemblers;\n\t}",
        "filePathBefore": "hibernate-core/src/main/java/org/hibernate/sql/results/graph/embeddable/internal/NonAggregatedIdentifierMappingInitializer.java",
        "isPureRefactoring": true,
        "commitId": "f8a6106ea20df36dc5c07827948a04b77243c1a6",
        "packageNameBefore": "org.hibernate.sql.results.graph.embeddable.internal",
        "classNameBefore": "org.hibernate.sql.results.graph.embeddable.internal.NonAggregatedIdentifierMappingInitializer",
        "methodNameBefore": "org.hibernate.sql.results.graph.embeddable.internal.NonAggregatedIdentifierMappingInitializer#createAssemblers",
        "invokedMethod": "methodSignature: org.hibernate.metamodel.mapping.internal.AbstractEmbeddableMapping#getFetchable\n methodBody: public Fetchable getFetchable(int position) {\nreturn getAttributeMappings().get(position);\n}\nmethodSignature: org.hibernate.metamodel.mapping.internal.AbstractEmbeddableMapping#getNumberOfFetchables\n methodBody: public int getNumberOfFetchables() {\nreturn getAttributeMappings().size();\n}",
        "classSignatureBefore": "public class NonAggregatedIdentifierMappingInitializer extends AbstractInitializer<NonAggregatedIdentifierMappingInitializer.NonAggregatedIdentifierMappingInitializerData>\n\t\timplements EmbeddableInitializer<NonAggregatedIdentifierMappingInitializer.NonAggregatedIdentifierMappingInitializerData> ",
        "methodNameBeforeSet": [
            "org.hibernate.sql.results.graph.embeddable.internal.NonAggregatedIdentifierMappingInitializer#createAssemblers"
        ],
        "classNameBeforeSet": [
            "org.hibernate.sql.results.graph.embeddable.internal.NonAggregatedIdentifierMappingInitializer"
        ],
        "classSignatureBeforeSet": [
            "public class NonAggregatedIdentifierMappingInitializer extends AbstractInitializer<NonAggregatedIdentifierMappingInitializer.NonAggregatedIdentifierMappingInitializerData>\n\t\timplements EmbeddableInitializer<NonAggregatedIdentifierMappingInitializer.NonAggregatedIdentifierMappingInitializerData> "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later\n * See the lgpl.txt file in the root directory or http://www.gnu.org/licenses/lgpl-2.1.html\n */\npackage org.hibernate.sql.results.graph.embeddable.internal;\n\nimport java.util.function.BiConsumer;\nimport java.util.function.Function;\n\nimport org.hibernate.bytecode.enhance.spi.LazyPropertyInitializer;\nimport org.hibernate.engine.spi.SessionFactoryImplementor;\nimport org.hibernate.metamodel.mapping.AttributeMapping;\nimport org.hibernate.metamodel.mapping.EmbeddableMappingType;\nimport org.hibernate.metamodel.mapping.EmbeddableValuedModelPart;\nimport org.hibernate.metamodel.mapping.ForeignKeyDescriptor;\nimport org.hibernate.metamodel.mapping.NonAggregatedIdentifierMapping;\nimport org.hibernate.metamodel.mapping.internal.ToOneAttributeMapping;\nimport org.hibernate.metamodel.spi.EmbeddableInstantiator;\nimport org.hibernate.metamodel.spi.ValueAccess;\nimport org.hibernate.proxy.HibernateProxy;\nimport org.hibernate.proxy.LazyInitializer;\nimport org.hibernate.spi.EntityIdentifierNavigablePath;\nimport org.hibernate.spi.NavigablePath;\nimport org.hibernate.sql.results.graph.AssemblerCreationState;\nimport org.hibernate.sql.results.graph.DomainResultAssembler;\nimport org.hibernate.sql.results.graph.Fetch;\nimport org.hibernate.sql.results.graph.Fetchable;\nimport org.hibernate.sql.results.graph.Initializer;\nimport org.hibernate.sql.results.graph.InitializerData;\nimport org.hibernate.sql.results.graph.InitializerParent;\nimport org.hibernate.sql.results.graph.embeddable.EmbeddableInitializer;\nimport org.hibernate.sql.results.graph.embeddable.EmbeddableResultGraphNode;\nimport org.hibernate.sql.results.graph.internal.AbstractInitializer;\nimport org.hibernate.sql.results.internal.NullValueAssembler;\nimport org.hibernate.sql.results.jdbc.spi.RowProcessingState;\n\nimport org.checkerframework.checker.nullness.qual.Nullable;\n\nimport static org.hibernate.sql.results.graph.entity.internal.BatchEntityInsideEmbeddableSelectFetchInitializer.BATCH_PROPERTY;\n\n/**\n * @author Steve Ebersole\n */\npublic class NonAggregatedIdentifierMappingInitializer extends AbstractInitializer<NonAggregatedIdentifierMappingInitializer.NonAggregatedIdentifierMappingInitializerData>\n\t\timplements EmbeddableInitializer<NonAggregatedIdentifierMappingInitializer.NonAggregatedIdentifierMappingInitializerData> {\n\n\tprivate final NavigablePath navigablePath;\n\tprivate final NonAggregatedIdentifierMapping embedded;\n\tprivate final EmbeddableMappingType virtualIdEmbeddable;\n\tprivate final EmbeddableMappingType representationEmbeddable;\n\tprivate final EmbeddableInstantiator embeddableInstantiator;\n\tprivate final @Nullable InitializerParent<?> parent;\n\tprivate final SessionFactoryImplementor sessionFactory;\n\tprivate final boolean isResultInitializer;\n\n\tprivate final DomainResultAssembler<?>[] assemblers;\n\tprivate final @Nullable Initializer<InitializerData>[] initializers;\n\tprivate final @Nullable Initializer<InitializerData>[] subInitializersForResolveFromInitialized;\n\tprivate final boolean lazyCapable;\n\tprivate final boolean hasLazySubInitializer;\n\tprivate final boolean hasIdClass;\n\n\tpublic static class NonAggregatedIdentifierMappingInitializerData extends InitializerData implements ValueAccess {\n\t\tprotected final boolean isFindByIdLookup;\n\t\tprotected final InitializerData parentData;\n\t\tprotected final Object[] virtualIdState;\n\t\tprotected final Object[] idClassState;\n\n\t\tpublic NonAggregatedIdentifierMappingInitializerData(NonAggregatedIdentifierMappingInitializer initializer, RowProcessingState rowProcessingState) {\n\t\t\tsuper( rowProcessingState );\n\t\t\tthis.isFindByIdLookup = !initializer.hasIdClass && rowProcessingState.getEntityId() != null\n\t\t\t\t\t&& initializer.navigablePath.getParent().getParent() == null\n\t\t\t\t\t&& initializer.navigablePath instanceof EntityIdentifierNavigablePath;\n\t\t\tthis.parentData = initializer.parent == null ? null : initializer.parent.getData( rowProcessingState );\n\t\t\tfinal EmbeddableMappingType virtualIdEmbeddable = initializer.embedded.getEmbeddableTypeDescriptor();\n\t\t\tfinal int size = virtualIdEmbeddable.getNumberOfFetchables();\n\t\t\tthis.virtualIdState = new Object[ size ];\n\t\t\tthis.idClassState = new Object[ size ];\n\t\t}\n\n\t\t@Override\n\t\tpublic Object[] getValues() {\n\t\t\tassert getState() == State.RESOLVED;\n\t\t\treturn idClassState;\n\t\t}\n\n\t\t@Override\n\t\tpublic <T> T getValue(int i, Class<T> clazz) {\n\t\t\tassert getState() == State.RESOLVED;\n\t\t\treturn clazz.cast( idClassState[i] );\n\t\t}\n\n\t\t@Override\n\t\tpublic Object getOwner() {\n\t\t\treturn parentData == null ? null : parentData.getInstance();\n\t\t}\n\t}\n\n\tpublic NonAggregatedIdentifierMappingInitializer(\n\t\t\tEmbeddableResultGraphNode resultDescriptor,\n\t\t\tInitializerParent<?> parent,\n\t\t\tAssemblerCreationState creationState,\n\t\t\tboolean isResultInitializer) {\n\t\tthis( resultDescriptor, parent, creationState, isResultInitializer, Function.identity() );\n\t}\n\n\tprotected NonAggregatedIdentifierMappingInitializer(\n\t\t\tEmbeddableResultGraphNode resultDescriptor,\n\t\t\tInitializerParent<?> parent,\n\t\t\tAssemblerCreationState creationState,\n\t\t\tboolean isResultInitializer,\n\t\t\tFunction<Fetch, Fetch> fetchConverter) {\n\t\tsuper( creationState );\n\t\tthis.navigablePath = resultDescriptor.getNavigablePath();\n\t\tthis.embedded = (NonAggregatedIdentifierMapping) resultDescriptor.getReferencedMappingContainer();\n\t\tthis.parent = parent;\n\t\tthis.isResultInitializer = isResultInitializer;\n\n\t\tthis.virtualIdEmbeddable = embedded.getEmbeddableTypeDescriptor();\n\t\tthis.representationEmbeddable = embedded.getMappedIdEmbeddableTypeDescriptor();\n\t\tthis.embeddableInstantiator = representationEmbeddable.getRepresentationStrategy().getInstantiator();\n\t\tthis.hasIdClass = embedded.hasContainingClass() && virtualIdEmbeddable != representationEmbeddable;\n\n\t\tthis.sessionFactory = creationState.getSqlAstCreationContext().getSessionFactory();\n\t\tthis.assemblers = createAssemblers( this, resultDescriptor, creationState, virtualIdEmbeddable, fetchConverter );\n\t\tfinal Initializer<?>[] initializers = new Initializer[assemblers.length];\n\t\tfinal Initializer<?>[] eagerSubInitializers = new Initializer[assemblers.length];\n\t\tboolean empty = true;\n\t\tboolean emptyEager = true;\n\t\tboolean lazyCapable = false;\n\t\tboolean hasLazySubInitializers = false;\n\t\tfor ( int i = 0; i < assemblers.length; i++ ) {\n\t\t\tfinal Initializer<?> initializer = assemblers[i].getInitializer();\n\t\t\tif ( initializer != null ) {\n\t\t\t\tif ( initializer.isEager() ) {\n\t\t\t\t\teagerSubInitializers[i] = initializer;\n\t\t\t\t\thasLazySubInitializers = hasLazySubInitializers || initializer.hasLazySubInitializers();\n\t\t\t\t\temptyEager = false;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\thasLazySubInitializers = true;\n\t\t\t\t}\n\t\t\t\tlazyCapable = lazyCapable || initializer.isLazyCapable();\n\t\t\t\tinitializers[i] = initializer;\n\t\t\t\tempty = false;\n\t\t\t}\n\t\t}\n\t\t//noinspection unchecked\n\t\tthis.initializers = (Initializer<InitializerData>[]) (\n\t\t\t\tempty ? Initializer.EMPTY_ARRAY : initializers\n\t\t);\n\t\t// No need to think about bytecode enhancement here, since ids can't contain lazy basic attributes\n\t\tthis.subInitializersForResolveFromInitialized = (Initializer<InitializerData>[]) (\n\t\t\t\temptyEager ? Initializer.EMPTY_ARRAY : initializers\n\t\t);\n\t\tthis.lazyCapable = lazyCapable;\n\t\tthis.hasLazySubInitializer = hasLazySubInitializers;\n\t}\n\n\tprotected static DomainResultAssembler<?>[] createAssemblers(\n\t\t\tInitializerParent<?> parent,\n\t\t\tEmbeddableResultGraphNode resultDescriptor,\n\t\t\tAssemblerCreationState creationState,\n\t\t\tEmbeddableMappingType embeddableTypeDescriptor,\n\t\t\tFunction<Fetch, Fetch> fetchConverter) {\n\t\tfinal int size = embeddableTypeDescriptor.getNumberOfFetchables();\n\t\tfinal DomainResultAssembler<?>[] assemblers = new DomainResultAssembler[size];\n\t\tfor ( int i = 0; i < size; i++ ) {\n\t\t\tfinal Fetchable stateArrayContributor = embeddableTypeDescriptor.getFetchable( i );\n\t\t\tfinal Fetch fetch = fetchConverter.apply( resultDescriptor.findFetch( stateArrayContributor ) );\n\n\t\t\tfinal DomainResultAssembler<?> stateAssembler = fetch == null\n\t\t\t\t\t? new NullValueAssembler<>( stateArrayContributor.getJavaType() )\n\t\t\t\t\t: fetch.createAssembler( parent, creationState );\n\n\t\t\tassemblers[i] = stateAssembler;\n\t\t}\n\t\treturn assemblers;\n\t}\n\n\t@Override\n\tpublic EmbeddableValuedModelPart getInitializedPart() {\n\t\treturn embedded;\n\t}\n\n\t@Override\n\tpublic @Nullable InitializerParent<?> getParent() {\n\t\treturn parent;\n\t}\n\n\t@Override\n\tpublic NavigablePath getNavigablePath() {\n\t\treturn navigablePath;\n\t}\n\n\t@Override\n\tpublic boolean isResultInitializer() {\n\t\treturn isResultInitializer;\n\t}\n\n\t@Override\n\tprotected InitializerData createInitializerData(RowProcessingState rowProcessingState) {\n\t\treturn new NonAggregatedIdentifierMappingInitializerData( this, rowProcessingState );\n\t}\n\n\t@Override\n\tpublic void resolveKey(NonAggregatedIdentifierMappingInitializerData data) {\n\t\tif ( data.getState() != State.UNINITIALIZED ) {\n\t\t\treturn;\n\t\t}\n\t\t// We need to possibly wrap the processing state if the embeddable is within an aggregate\n\t\tdata.setInstance( null );\n\t\tdata.setState( State.KEY_RESOLVED );\n\t\tif ( initializers.length == 0 ) {\n\t\t\t// Resolve the component early to know if the key is missing or not\n\t\t\tresolveInstance( data );\n\t\t}\n\t\telse {\n\t\t\tfinal RowProcessingState rowProcessingState = data.getRowProcessingState();\n\t\t\tfor ( Initializer<InitializerData> initializer : initializers ) {\n\t\t\t\tif ( initializer != null ) {\n\t\t\t\t\tfinal InitializerData subData = initializer.getData( rowProcessingState );\n\t\t\t\t\tinitializer.resolveKey( subData );\n\t\t\t\t\tif ( subData.getState() == State.MISSING ) {\n\t\t\t\t\t\tdata.setState( State.MISSING );\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic void resolveInstance(NonAggregatedIdentifierMappingInitializerData data) {\n\t\tif ( data.getState() != State.KEY_RESOLVED ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// If we don't have an id class and this is a find by id lookup, we just use that instance\n\t\tif ( data.isFindByIdLookup ) {\n\t\t\tdata.setInstance( data.getRowProcessingState().getEntityId() );\n\t\t\tdata.setState( State.INITIALIZED );\n\t\t\treturn;\n\t\t}\n\t\tdata.setState( State.RESOLVED );\n\t\t// We need to possibly wrap the processing state if the embeddable is within an aggregate\n\t\textractRowState( data );\n\t\tif ( data.getState() == State.MISSING ) {\n\t\t\tdata.setInstance( null );\n\t\t}\n\t\telse {\n\t\t\tdata.setInstance( embeddableInstantiator.instantiate( data, sessionFactory ) );\n\t\t}\n\t}\n\n\t@Override\n\tpublic void resolveInstance(@Nullable Object instance, NonAggregatedIdentifierMappingInitializerData data) {\n\t\tif ( instance == null ) {\n\t\t\tdata.setState( State.MISSING );\n\t\t\tdata.setInstance( null );\n\t\t}\n\t\telse {\n\t\t\tdata.setState( State.INITIALIZED );\n\t\t\tdata.setInstance( instance );\n\t\t\tfinal RowProcessingState rowProcessingState = data.getRowProcessingState();\n\t\t\tresolveInstanceSubInitializers( instance, rowProcessingState );\n\t\t\tif ( rowProcessingState.needsResolveState() ) {\n\t\t\t\tfor ( DomainResultAssembler<?> assembler : assemblers ) {\n\t\t\t\t\tassembler.resolveState( rowProcessingState );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate void resolveInstanceSubInitializers(Object instance, RowProcessingState rowProcessingState) {\n\t\tfor ( int i = 0; i < subInitializersForResolveFromInitialized.length; i++ ) {\n\t\t\tfinal Initializer<InitializerData> initializer = subInitializersForResolveFromInitialized[i];\n\t\t\tif ( initializer != null ) {\n\t\t\t\tfinal Object subInstance = virtualIdEmbeddable.getValue( instance, i );\n\t\t\t\tif ( subInstance == LazyPropertyInitializer.UNFETCHED_PROPERTY ) {\n\t\t\t\t\t// Go through the normal initializer process\n\t\t\t\t\tinitializer.resolveKey( rowProcessingState );\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tinitializer.resolveInstance( subInstance, rowProcessingState );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic void initializeInstance(NonAggregatedIdentifierMappingInitializerData data) {\n\t\tif ( data.getState() != State.RESOLVED ) {\n\t\t\treturn;\n\t\t}\n\t\tdata.setState( State.INITIALIZED );\n\n\t\tif ( parent != null ) {\n\t\t\tassert parent.isEntityInitializer();\n\t\t\tfinal Object parentInstance = parent.getResolvedInstance( data.getRowProcessingState() );\n\t\t\tassert parentInstance != null;\n\t\t\tfinal LazyInitializer lazyInitializer = HibernateProxy.extractLazyInitializer( parentInstance );\n\t\t\t// If the composite instance has a lazy initializer attached, this means that the embeddable is actually virtual\n\t\t\t// and the compositeInstance == entity, so we have to inject the row state into the entity when it finishes resolution\n\t\t\tif ( lazyInitializer != null ) {\n\t\t\t\tvirtualIdEmbeddable.setValues( lazyInitializer.getImplementation(), data.virtualIdState );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tvirtualIdEmbeddable.setValues( parentInstance, data.virtualIdState );\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tprotected void forEachSubInitializer(BiConsumer<Initializer<?>, RowProcessingState> consumer, InitializerData data) {\n\t\tfinal RowProcessingState rowProcessingState = data.getRowProcessingState();\n\t\tfor ( Initializer<?> initializer : initializers ) {\n\t\t\tif ( initializer != null ) {\n\t\t\t\tconsumer.accept( initializer, rowProcessingState );\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate void extractRowState(NonAggregatedIdentifierMappingInitializerData data) {\n\t\tfinal RowProcessingState rowProcessingState = data.getRowProcessingState();\n\t\tfor ( int i = 0; i < assemblers.length; i++ ) {\n\t\t\tfinal Object contributorValue = assemblers[i].assemble( rowProcessingState );\n\n\t\t\tif ( contributorValue == null ) {\n\t\t\t\t// This is a key and there is a null part, the whole thing has to be turned into null\n\t\t\t\tdata.setState( State.MISSING );\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif ( contributorValue == BATCH_PROPERTY ) {\n\t\t\t\tdata.virtualIdState[i] = null;\n\t\t\t\tdata.idClassState[i] = null;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdata.virtualIdState[i] = contributorValue;\n\t\t\t\tdata.idClassState[i] = contributorValue;\n\t\t\t\tif ( hasIdClass ) {\n\t\t\t\t\tfinal AttributeMapping virtualIdAttribute = virtualIdEmbeddable.getAttributeMapping( i );\n\t\t\t\t\tfinal AttributeMapping mappedIdAttribute = representationEmbeddable.getAttributeMapping( i );\n\t\t\t\t\tif ( virtualIdAttribute instanceof ToOneAttributeMapping\n\t\t\t\t\t\t\t&& !( mappedIdAttribute instanceof ToOneAttributeMapping ) ) {\n\t\t\t\t\t\tfinal ToOneAttributeMapping toOneAttributeMapping = (ToOneAttributeMapping) virtualIdAttribute;\n\t\t\t\t\t\tfinal ForeignKeyDescriptor fkDescriptor = toOneAttributeMapping.getForeignKeyDescriptor();\n\t\t\t\t\t\tfinal Object associationKey = fkDescriptor.getAssociationKeyFromSide(\n\t\t\t\t\t\t\t\tdata.virtualIdState[i],\n\t\t\t\t\t\t\t\ttoOneAttributeMapping.getSideNature().inverse(),\n\t\t\t\t\t\t\t\trowProcessingState.getSession()\n\t\t\t\t\t\t);\n\t\t\t\t\t\tdata.idClassState[i] = associationKey;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic void resolveState(NonAggregatedIdentifierMappingInitializerData data) {\n\t\tif ( !data.isFindByIdLookup ) {\n\t\t\tfinal RowProcessingState rowProcessingState = data.getRowProcessingState();\n\t\t\tfor ( final DomainResultAssembler<?> assembler : assemblers ) {\n\t\t\t\tassembler.resolveState( rowProcessingState );\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic boolean isPartOfKey() {\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean isEager() {\n\t\t// Embeddables are never lazy\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean isLazyCapable() {\n\t\treturn lazyCapable;\n\t}\n\n\t@Override\n\tpublic boolean hasLazySubInitializers() {\n\t\treturn hasLazySubInitializer;\n\t}\n\n\t/*\n\t * Used by Hibernate Reactive\n\t */\n\tprotected @Nullable Initializer<InitializerData>[] getInitializers() {\n\t\treturn initializers;\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn \"NonAggregatedIdentifierMappingInitializer(\" + navigablePath + \") : `\" + getInitializedPart().getJavaType().getJavaTypeClass() + \"`\";\n\t}\n}\n",
        "filePathAfter": "hibernate-core/src/main/java/org/hibernate/sql/results/graph/embeddable/internal/NonAggregatedIdentifierMappingInitializer.java",
        "sourceCodeAfterForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later\n * See the lgpl.txt file in the root directory or http://www.gnu.org/licenses/lgpl-2.1.html\n */\npackage org.hibernate.sql.results.graph.embeddable.internal;\n\nimport java.util.function.BiConsumer;\nimport java.util.function.Function;\n\nimport org.hibernate.bytecode.enhance.spi.LazyPropertyInitializer;\nimport org.hibernate.engine.spi.SessionFactoryImplementor;\nimport org.hibernate.metamodel.mapping.AttributeMapping;\nimport org.hibernate.metamodel.mapping.EmbeddableMappingType;\nimport org.hibernate.metamodel.mapping.EmbeddableValuedModelPart;\nimport org.hibernate.metamodel.mapping.ForeignKeyDescriptor;\nimport org.hibernate.metamodel.mapping.NonAggregatedIdentifierMapping;\nimport org.hibernate.metamodel.mapping.internal.ToOneAttributeMapping;\nimport org.hibernate.metamodel.spi.EmbeddableInstantiator;\nimport org.hibernate.metamodel.spi.ValueAccess;\nimport org.hibernate.proxy.HibernateProxy;\nimport org.hibernate.proxy.LazyInitializer;\nimport org.hibernate.spi.EntityIdentifierNavigablePath;\nimport org.hibernate.spi.NavigablePath;\nimport org.hibernate.sql.results.graph.AssemblerCreationState;\nimport org.hibernate.sql.results.graph.DomainResultAssembler;\nimport org.hibernate.sql.results.graph.Fetch;\nimport org.hibernate.sql.results.graph.FetchParent;\nimport org.hibernate.sql.results.graph.Fetchable;\nimport org.hibernate.sql.results.graph.Initializer;\nimport org.hibernate.sql.results.graph.InitializerData;\nimport org.hibernate.sql.results.graph.InitializerParent;\nimport org.hibernate.sql.results.graph.embeddable.EmbeddableInitializer;\nimport org.hibernate.sql.results.graph.embeddable.EmbeddableResultGraphNode;\nimport org.hibernate.sql.results.graph.entity.EntityInitializer;\nimport org.hibernate.sql.results.graph.internal.AbstractInitializer;\nimport org.hibernate.sql.results.internal.NullValueAssembler;\nimport org.hibernate.sql.results.jdbc.spi.RowProcessingState;\n\nimport org.checkerframework.checker.nullness.qual.Nullable;\n\nimport static org.hibernate.sql.results.graph.entity.internal.BatchEntityInsideEmbeddableSelectFetchInitializer.BATCH_PROPERTY;\n\n/**\n * @author Steve Ebersole\n */\npublic class NonAggregatedIdentifierMappingInitializer extends AbstractInitializer<NonAggregatedIdentifierMappingInitializer.NonAggregatedIdentifierMappingInitializerData>\n\t\timplements EmbeddableInitializer<NonAggregatedIdentifierMappingInitializer.NonAggregatedIdentifierMappingInitializerData> {\n\n\tprivate final NavigablePath navigablePath;\n\tprivate final NonAggregatedIdentifierMapping embedded;\n\tprivate final EmbeddableMappingType virtualIdEmbeddable;\n\tprivate final EmbeddableMappingType representationEmbeddable;\n\tprivate final EmbeddableInstantiator embeddableInstantiator;\n\tprivate final @Nullable InitializerParent<?> parent;\n\tprivate final SessionFactoryImplementor sessionFactory;\n\tprivate final boolean isResultInitializer;\n\n\tprivate final DomainResultAssembler<?>[] assemblers;\n\tprivate final @Nullable Initializer<InitializerData>[] initializers;\n\tprivate final @Nullable Initializer<InitializerData>[] subInitializersForResolveFromInitialized;\n\tprivate final @Nullable Initializer<InitializerData>[] collectionContainingSubInitializers;\n\tprivate final boolean lazyCapable;\n\tprivate final boolean hasLazySubInitializer;\n\tprivate final boolean hasIdClass;\n\n\tpublic static class NonAggregatedIdentifierMappingInitializerData extends InitializerData implements ValueAccess {\n\t\tprotected final boolean isFindByIdLookup;\n\t\tprotected final InitializerData parentData;\n\t\tprotected final Object[] virtualIdState;\n\t\tprotected final Object[] idClassState;\n\n\t\tpublic NonAggregatedIdentifierMappingInitializerData(NonAggregatedIdentifierMappingInitializer initializer, RowProcessingState rowProcessingState) {\n\t\t\tsuper( rowProcessingState );\n\t\t\tthis.isFindByIdLookup = !initializer.hasIdClass && rowProcessingState.getEntityId() != null\n\t\t\t\t\t&& initializer.navigablePath.getParent().getParent() == null\n\t\t\t\t\t&& initializer.navigablePath instanceof EntityIdentifierNavigablePath;\n\t\t\tthis.parentData = initializer.parent == null ? null : initializer.parent.getData( rowProcessingState );\n\t\t\tfinal EmbeddableMappingType virtualIdEmbeddable = initializer.embedded.getEmbeddableTypeDescriptor();\n\t\t\tfinal int size = virtualIdEmbeddable.getNumberOfFetchables();\n\t\t\tthis.virtualIdState = new Object[ size ];\n\t\t\tthis.idClassState = new Object[ size ];\n\t\t}\n\n\t\t@Override\n\t\tpublic Object[] getValues() {\n\t\t\tassert getState() == State.RESOLVED;\n\t\t\treturn idClassState;\n\t\t}\n\n\t\t@Override\n\t\tpublic <T> T getValue(int i, Class<T> clazz) {\n\t\t\tassert getState() == State.RESOLVED;\n\t\t\treturn clazz.cast( idClassState[i] );\n\t\t}\n\n\t\t@Override\n\t\tpublic Object getOwner() {\n\t\t\treturn parentData == null ? null : parentData.getInstance();\n\t\t}\n\t}\n\n\tpublic NonAggregatedIdentifierMappingInitializer(\n\t\t\tEmbeddableResultGraphNode resultDescriptor,\n\t\t\tInitializerParent<?> parent,\n\t\t\tAssemblerCreationState creationState,\n\t\t\tboolean isResultInitializer) {\n\t\tthis( resultDescriptor, parent, creationState, isResultInitializer, Function.identity() );\n\t}\n\n\tprotected NonAggregatedIdentifierMappingInitializer(\n\t\t\tEmbeddableResultGraphNode resultDescriptor,\n\t\t\tInitializerParent<?> parent,\n\t\t\tAssemblerCreationState creationState,\n\t\t\tboolean isResultInitializer,\n\t\t\tFunction<Fetch, Fetch> fetchConverter) {\n\t\tsuper( creationState );\n\t\tthis.navigablePath = resultDescriptor.getNavigablePath();\n\t\tthis.embedded = (NonAggregatedIdentifierMapping) resultDescriptor.getReferencedMappingContainer();\n\t\tthis.parent = parent;\n\t\tthis.isResultInitializer = isResultInitializer;\n\n\t\tthis.virtualIdEmbeddable = embedded.getEmbeddableTypeDescriptor();\n\t\tthis.representationEmbeddable = embedded.getMappedIdEmbeddableTypeDescriptor();\n\t\tthis.embeddableInstantiator = representationEmbeddable.getRepresentationStrategy().getInstantiator();\n\t\tthis.hasIdClass = embedded.hasContainingClass() && virtualIdEmbeddable != representationEmbeddable;\n\n\t\tthis.sessionFactory = creationState.getSqlAstCreationContext().getSessionFactory();\n\n\t\tfinal int size = virtualIdEmbeddable.getNumberOfFetchables();\n\t\tfinal DomainResultAssembler<?>[] assemblers = new DomainResultAssembler[size];\n\t\tthis.assemblers = assemblers;\n\t\tfinal Initializer<?>[] initializers = new Initializer[assemblers.length];\n\t\tfinal Initializer<?>[] eagerSubInitializers = new Initializer[assemblers.length];\n\t\tfinal Initializer<?>[] collectionContainingSubInitializers = new Initializer[assemblers.length];\n\t\tboolean empty = true;\n\t\tboolean emptyEager = true;\n\t\tboolean emptyCollectionInitializers = true;\n\t\tboolean lazyCapable = false;\n\t\tboolean hasLazySubInitializers = false;\n\t\tfor ( int i = 0; i < size; i++ ) {\n\t\t\tfinal Fetchable stateArrayContributor = virtualIdEmbeddable.getFetchable( i );\n\t\t\tfinal Fetch fetch = fetchConverter.apply( resultDescriptor.findFetch( stateArrayContributor ) );\n\n\t\t\tfinal DomainResultAssembler<?> stateAssembler = fetch == null\n\t\t\t\t\t? new NullValueAssembler<>( stateArrayContributor.getJavaType() )\n\t\t\t\t\t: fetch.createAssembler( this, creationState );\n\n\t\t\tassemblers[i] = stateAssembler;\n\n\t\t\tfinal Initializer<?> initializer = stateAssembler.getInitializer();\n\t\t\tif ( initializer != null ) {\n\t\t\t\tif ( initializer.isEager() ) {\n\t\t\t\t\teagerSubInitializers[i] = initializer;\n\t\t\t\t\thasLazySubInitializers = hasLazySubInitializers || initializer.hasLazySubInitializers();\n\t\t\t\t\temptyEager = false;\n\t\t\t\t\tassert fetch != null;\n\t\t\t\t\tfinal FetchParent fetchParent;\n\t\t\t\t\tif ( ( fetchParent = fetch.asFetchParent() ) != null && fetchParent.containsCollectionFetches()\n\t\t\t\t\t\t\t|| initializer.isCollectionInitializer() ) {\n\t\t\t\t\t\tcollectionContainingSubInitializers[i] = initializer;\n\t\t\t\t\t\temptyCollectionInitializers = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\thasLazySubInitializers = true;\n\t\t\t\t}\n\t\t\t\tlazyCapable = lazyCapable || initializer.isLazyCapable();\n\t\t\t\tinitializers[i] = initializer;\n\t\t\t\tempty = false;\n\t\t\t}\n\t\t}\n\t\t//noinspection unchecked\n\t\tthis.initializers = (Initializer<InitializerData>[]) (\n\t\t\t\tempty ? Initializer.EMPTY_ARRAY : initializers\n\t\t);\n\t\t// No need to think about bytecode enhancement here, since ids can't contain lazy basic attributes\n\t\t//noinspection unchecked\n\t\tthis.subInitializersForResolveFromInitialized = (Initializer<InitializerData>[]) (\n\t\t\t\temptyEager ? Initializer.EMPTY_ARRAY : initializers\n\t\t);\n\t\t//noinspection unchecked\n\t\tthis.collectionContainingSubInitializers = (Initializer<InitializerData>[]) (\n\t\t\t\temptyCollectionInitializers ? Initializer.EMPTY_ARRAY : collectionContainingSubInitializers\n\t\t);\n\t\tthis.lazyCapable = lazyCapable;\n\t\tthis.hasLazySubInitializer = hasLazySubInitializers;\n\t}\n\n\t@Override\n\tpublic EmbeddableValuedModelPart getInitializedPart() {\n\t\treturn embedded;\n\t}\n\n\t@Override\n\tpublic @Nullable InitializerParent<?> getParent() {\n\t\treturn parent;\n\t}\n\n\t@Override\n\tpublic NavigablePath getNavigablePath() {\n\t\treturn navigablePath;\n\t}\n\n\t@Override\n\tpublic boolean isResultInitializer() {\n\t\treturn isResultInitializer;\n\t}\n\n\t@Override\n\tprotected InitializerData createInitializerData(RowProcessingState rowProcessingState) {\n\t\treturn new NonAggregatedIdentifierMappingInitializerData( this, rowProcessingState );\n\t}\n\n\t@Override\n\tpublic void resolveKey(NonAggregatedIdentifierMappingInitializerData data) {\n\t\tif ( data.getState() != State.UNINITIALIZED ) {\n\t\t\treturn;\n\t\t}\n\t\tdata.setInstance( null );\n\t\tdata.setState( State.KEY_RESOLVED );\n\t\tif ( initializers.length == 0 ) {\n\t\t\t// Resolve the component early to know if the key is missing or not\n\t\t\tresolveInstance( data );\n\t\t}\n\t\telse {\n\t\t\tfinal RowProcessingState rowProcessingState = data.getRowProcessingState();\n\t\t\tfor ( Initializer<InitializerData> initializer : initializers ) {\n\t\t\t\tif ( initializer != null ) {\n\t\t\t\t\tfinal InitializerData subData = initializer.getData( rowProcessingState );\n\t\t\t\t\tinitializer.resolveKey( subData );\n\t\t\t\t\tif ( subData.getState() == State.MISSING ) {\n\t\t\t\t\t\tdata.setState( State.MISSING );\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic void resetResolvedEntityRegistrations(RowProcessingState rowProcessingState) {\n\t\tfinal NonAggregatedIdentifierMappingInitializerData data = getData( rowProcessingState );\n\t\tfor ( Initializer<InitializerData> initializer : initializers ) {\n\t\t\tif ( initializer != null ) {\n\t\t\t\tfinal EntityInitializer<?> entityInitializer = initializer.asEntityInitializer();\n\t\t\t\tfinal EmbeddableInitializer<?> embeddableInitializer;\n\t\t\t\tif ( entityInitializer != null ) {\n\t\t\t\t\tentityInitializer.resetResolvedEntityRegistrations( rowProcessingState );\n\t\t\t\t}\n\t\t\t\telse if ( ( embeddableInitializer = initializer.asEmbeddableInitializer() ) != null ) {\n\t\t\t\t\tembeddableInitializer.resetResolvedEntityRegistrations( rowProcessingState );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic void resolveFromPreviousRow(NonAggregatedIdentifierMappingInitializerData data) {\n\t\tif ( data.getState() == State.UNINITIALIZED ) {\n\t\t\tif ( data.getInstance() == null ) {\n\t\t\t\tdata.setState( State.MISSING );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfinal RowProcessingState rowProcessingState = data.getRowProcessingState();\n\t\t\t\t// When a previous row initialized this entity already, we only need to process collections\n\t\t\t\tfor ( Initializer<InitializerData> initializer : collectionContainingSubInitializers ) {\n\t\t\t\t\tif ( initializer != null ) {\n\t\t\t\t\t\tinitializer.resolveFromPreviousRow( rowProcessingState );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdata.setState( State.INITIALIZED );\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic void resolveInstance(NonAggregatedIdentifierMappingInitializerData data) {\n\t\tif ( data.getState() != State.KEY_RESOLVED ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// If we don't have an id class and this is a find by id lookup, we just use that instance\n\t\tif ( data.isFindByIdLookup ) {\n\t\t\tdata.setInstance( data.getRowProcessingState().getEntityId() );\n\t\t\tdata.setState( State.INITIALIZED );\n\t\t\treturn;\n\t\t}\n\t\tdata.setState( State.RESOLVED );\n\t\t// We need to possibly wrap the processing state if the embeddable is within an aggregate\n\t\textractRowState( data );\n\t\tif ( data.getState() == State.MISSING ) {\n\t\t\tdata.setInstance( null );\n\t\t}\n\t\telse {\n\t\t\tdata.setInstance( embeddableInstantiator.instantiate( data, sessionFactory ) );\n\t\t}\n\t\tif ( parent == null ) {\n\t\t\tdata.setState( State.INITIALIZED );\n\t\t}\n\t}\n\n\t@Override\n\tpublic void resolveInstance(@Nullable Object instance, NonAggregatedIdentifierMappingInitializerData data) {\n\t\tif ( instance == null ) {\n\t\t\tdata.setState( State.MISSING );\n\t\t\tdata.setInstance( null );\n\t\t}\n\t\telse {\n\t\t\tdata.setState( State.INITIALIZED );\n\t\t\tdata.setInstance( instance );\n\t\t\tfinal RowProcessingState rowProcessingState = data.getRowProcessingState();\n\t\t\tresolveInstanceSubInitializers( instance, rowProcessingState );\n\t\t\tif ( rowProcessingState.needsResolveState() ) {\n\t\t\t\tfor ( DomainResultAssembler<?> assembler : assemblers ) {\n\t\t\t\t\tassembler.resolveState( rowProcessingState );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate void resolveInstanceSubInitializers(Object instance, RowProcessingState rowProcessingState) {\n\t\tfor ( int i = 0; i < subInitializersForResolveFromInitialized.length; i++ ) {\n\t\t\tfinal Initializer<InitializerData> initializer = subInitializersForResolveFromInitialized[i];\n\t\t\tif ( initializer != null ) {\n\t\t\t\tfinal Object subInstance = virtualIdEmbeddable.getValue( instance, i );\n\t\t\t\tif ( subInstance == LazyPropertyInitializer.UNFETCHED_PROPERTY ) {\n\t\t\t\t\t// Go through the normal initializer process\n\t\t\t\t\tinitializer.resolveKey( rowProcessingState );\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tinitializer.resolveInstance( subInstance, rowProcessingState );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic void initializeInstance(NonAggregatedIdentifierMappingInitializerData data) {\n\t\tif ( data.getState() != State.RESOLVED ) {\n\t\t\treturn;\n\t\t}\n\t\tdata.setState( State.INITIALIZED );\n\n\t\tif ( parent != null ) {\n\t\t\tassert parent.isEntityInitializer();\n\t\t\tfinal Object parentInstance = parent.getResolvedInstance( data.getRowProcessingState() );\n\t\t\tassert parentInstance != null;\n\t\t\tfinal LazyInitializer lazyInitializer = HibernateProxy.extractLazyInitializer( parentInstance );\n\t\t\t// If the composite instance has a lazy initializer attached, this means that the embeddable is actually virtual\n\t\t\t// and the compositeInstance == entity, so we have to inject the row state into the entity when it finishes resolution\n\t\t\tif ( lazyInitializer != null ) {\n\t\t\t\tvirtualIdEmbeddable.setValues( lazyInitializer.getImplementation(), data.virtualIdState );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tvirtualIdEmbeddable.setValues( parentInstance, data.virtualIdState );\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tprotected void forEachSubInitializer(BiConsumer<Initializer<?>, RowProcessingState> consumer, InitializerData data) {\n\t\tfinal RowProcessingState rowProcessingState = data.getRowProcessingState();\n\t\tfor ( Initializer<?> initializer : initializers ) {\n\t\t\tif ( initializer != null ) {\n\t\t\t\tconsumer.accept( initializer, rowProcessingState );\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate void extractRowState(NonAggregatedIdentifierMappingInitializerData data) {\n\t\tfinal RowProcessingState rowProcessingState = data.getRowProcessingState();\n\t\tfor ( int i = 0; i < assemblers.length; i++ ) {\n\t\t\tfinal Object contributorValue = assemblers[i].assemble( rowProcessingState );\n\n\t\t\tif ( contributorValue == null ) {\n\t\t\t\t// This is a key and there is a null part, the whole thing has to be turned into null\n\t\t\t\tdata.setState( State.MISSING );\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif ( contributorValue == BATCH_PROPERTY ) {\n\t\t\t\tdata.virtualIdState[i] = null;\n\t\t\t\tdata.idClassState[i] = null;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdata.virtualIdState[i] = contributorValue;\n\t\t\t\tdata.idClassState[i] = contributorValue;\n\t\t\t\tif ( hasIdClass ) {\n\t\t\t\t\tfinal AttributeMapping virtualIdAttribute = virtualIdEmbeddable.getAttributeMapping( i );\n\t\t\t\t\tfinal AttributeMapping mappedIdAttribute = representationEmbeddable.getAttributeMapping( i );\n\t\t\t\t\tif ( virtualIdAttribute instanceof ToOneAttributeMapping\n\t\t\t\t\t\t\t&& !( mappedIdAttribute instanceof ToOneAttributeMapping ) ) {\n\t\t\t\t\t\tfinal ToOneAttributeMapping toOneAttributeMapping = (ToOneAttributeMapping) virtualIdAttribute;\n\t\t\t\t\t\tfinal ForeignKeyDescriptor fkDescriptor = toOneAttributeMapping.getForeignKeyDescriptor();\n\t\t\t\t\t\tfinal Object associationKey = fkDescriptor.getAssociationKeyFromSide(\n\t\t\t\t\t\t\t\tdata.virtualIdState[i],\n\t\t\t\t\t\t\t\ttoOneAttributeMapping.getSideNature().inverse(),\n\t\t\t\t\t\t\t\trowProcessingState.getSession()\n\t\t\t\t\t\t);\n\t\t\t\t\t\tdata.idClassState[i] = associationKey;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic void resolveState(NonAggregatedIdentifierMappingInitializerData data) {\n\t\tif ( !data.isFindByIdLookup ) {\n\t\t\tfinal RowProcessingState rowProcessingState = data.getRowProcessingState();\n\t\t\tfor ( final DomainResultAssembler<?> assembler : assemblers ) {\n\t\t\t\tassembler.resolveState( rowProcessingState );\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic boolean isPartOfKey() {\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean isEager() {\n\t\t// Embeddables are never lazy\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean isLazyCapable() {\n\t\treturn lazyCapable;\n\t}\n\n\t@Override\n\tpublic boolean hasLazySubInitializers() {\n\t\treturn hasLazySubInitializer;\n\t}\n\n\t/*\n\t * Used by Hibernate Reactive\n\t */\n\tprotected @Nullable Initializer<InitializerData>[] getInitializers() {\n\t\treturn initializers;\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn \"NonAggregatedIdentifierMappingInitializer(\" + navigablePath + \") : `\" + getInitializedPart().getJavaType().getJavaTypeClass() + \"`\";\n\t}\n}\n",
        "diffSourceCodeSet": [],
        "invokedMethodSet": [
            "methodSignature: org.hibernate.metamodel.mapping.internal.AbstractEmbeddableMapping#getFetchable\n methodBody: public Fetchable getFetchable(int position) {\nreturn getAttributeMappings().get(position);\n}",
            "methodSignature: org.hibernate.metamodel.mapping.internal.AbstractEmbeddableMapping#getNumberOfFetchables\n methodBody: public int getNumberOfFetchables() {\nreturn getAttributeMappings().size();\n}"
        ],
        "sourceCodeAfterRefactoring": "protected NonAggregatedIdentifierMappingInitializer(\n\t\t\tEmbeddableResultGraphNode resultDescriptor,\n\t\t\tInitializerParent<?> parent,\n\t\t\tAssemblerCreationState creationState,\n\t\t\tboolean isResultInitializer,\n\t\t\tFunction<Fetch, Fetch> fetchConverter) {\n\t\tsuper( creationState );\n\t\tthis.navigablePath = resultDescriptor.getNavigablePath();\n\t\tthis.embedded = (NonAggregatedIdentifierMapping) resultDescriptor.getReferencedMappingContainer();\n\t\tthis.parent = parent;\n\t\tthis.isResultInitializer = isResultInitializer;\n\n\t\tthis.virtualIdEmbeddable = embedded.getEmbeddableTypeDescriptor();\n\t\tthis.representationEmbeddable = embedded.getMappedIdEmbeddableTypeDescriptor();\n\t\tthis.embeddableInstantiator = representationEmbeddable.getRepresentationStrategy().getInstantiator();\n\t\tthis.hasIdClass = embedded.hasContainingClass() && virtualIdEmbeddable != representationEmbeddable;\n\n\t\tthis.sessionFactory = creationState.getSqlAstCreationContext().getSessionFactory();\n\n\t\tfinal int size = virtualIdEmbeddable.getNumberOfFetchables();\n\t\tfinal DomainResultAssembler<?>[] assemblers = new DomainResultAssembler[size];\n\t\tthis.assemblers = assemblers;\n\t\tfinal Initializer<?>[] initializers = new Initializer[assemblers.length];\n\t\tfinal Initializer<?>[] eagerSubInitializers = new Initializer[assemblers.length];\n\t\tfinal Initializer<?>[] collectionContainingSubInitializers = new Initializer[assemblers.length];\n\t\tboolean empty = true;\n\t\tboolean emptyEager = true;\n\t\tboolean emptyCollectionInitializers = true;\n\t\tboolean lazyCapable = false;\n\t\tboolean hasLazySubInitializers = false;\n\t\tfor ( int i = 0; i < size; i++ ) {\n\t\t\tfinal Fetchable stateArrayContributor = virtualIdEmbeddable.getFetchable( i );\n\t\t\tfinal Fetch fetch = fetchConverter.apply( resultDescriptor.findFetch( stateArrayContributor ) );\n\n\t\t\tfinal DomainResultAssembler<?> stateAssembler = fetch == null\n\t\t\t\t\t? new NullValueAssembler<>( stateArrayContributor.getJavaType() )\n\t\t\t\t\t: fetch.createAssembler( this, creationState );\n\n\t\t\tassemblers[i] = stateAssembler;\n\n\t\t\tfinal Initializer<?> initializer = stateAssembler.getInitializer();\n\t\t\tif ( initializer != null ) {\n\t\t\t\tif ( initializer.isEager() ) {\n\t\t\t\t\teagerSubInitializers[i] = initializer;\n\t\t\t\t\thasLazySubInitializers = hasLazySubInitializers || initializer.hasLazySubInitializers();\n\t\t\t\t\temptyEager = false;\n\t\t\t\t\tassert fetch != null;\n\t\t\t\t\tfinal FetchParent fetchParent;\n\t\t\t\t\tif ( ( fetchParent = fetch.asFetchParent() ) != null && fetchParent.containsCollectionFetches()\n\t\t\t\t\t\t\t|| initializer.isCollectionInitializer() ) {\n\t\t\t\t\t\tcollectionContainingSubInitializers[i] = initializer;\n\t\t\t\t\t\temptyCollectionInitializers = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\thasLazySubInitializers = true;\n\t\t\t\t}\n\t\t\t\tlazyCapable = lazyCapable || initializer.isLazyCapable();\n\t\t\t\tinitializers[i] = initializer;\n\t\t\t\tempty = false;\n\t\t\t}\n\t\t}\n\t\t//noinspection unchecked\n\t\tthis.initializers = (Initializer<InitializerData>[]) (\n\t\t\t\tempty ? Initializer.EMPTY_ARRAY : initializers\n\t\t);\n\t\t// No need to think about bytecode enhancement here, since ids can't contain lazy basic attributes\n\t\t//noinspection unchecked\n\t\tthis.subInitializersForResolveFromInitialized = (Initializer<InitializerData>[]) (\n\t\t\t\temptyEager ? Initializer.EMPTY_ARRAY : initializers\n\t\t);\n\t\t//noinspection unchecked\n\t\tthis.collectionContainingSubInitializers = (Initializer<InitializerData>[]) (\n\t\t\t\temptyCollectionInitializers ? Initializer.EMPTY_ARRAY : collectionContainingSubInitializers\n\t\t);\n\t\tthis.lazyCapable = lazyCapable;\n\t\tthis.hasLazySubInitializer = hasLazySubInitializers;\n\t}",
        "diffSourceCode": "-  109: \tprotected NonAggregatedIdentifierMappingInitializer(\n-  110: \t\t\tEmbeddableResultGraphNode resultDescriptor,\n-  111: \t\t\tInitializerParent<?> parent,\n-  112: \t\t\tAssemblerCreationState creationState,\n-  113: \t\t\tboolean isResultInitializer,\n-  114: \t\t\tFunction<Fetch, Fetch> fetchConverter) {\n-  115: \t\tsuper( creationState );\n-  116: \t\tthis.navigablePath = resultDescriptor.getNavigablePath();\n-  117: \t\tthis.embedded = (NonAggregatedIdentifierMapping) resultDescriptor.getReferencedMappingContainer();\n-  118: \t\tthis.parent = parent;\n-  119: \t\tthis.isResultInitializer = isResultInitializer;\n-  120: \n-  121: \t\tthis.virtualIdEmbeddable = embedded.getEmbeddableTypeDescriptor();\n-  122: \t\tthis.representationEmbeddable = embedded.getMappedIdEmbeddableTypeDescriptor();\n-  123: \t\tthis.embeddableInstantiator = representationEmbeddable.getRepresentationStrategy().getInstantiator();\n-  124: \t\tthis.hasIdClass = embedded.hasContainingClass() && virtualIdEmbeddable != representationEmbeddable;\n-  125: \n-  126: \t\tthis.sessionFactory = creationState.getSqlAstCreationContext().getSessionFactory();\n-  127: \t\tthis.assemblers = createAssemblers( this, resultDescriptor, creationState, virtualIdEmbeddable, fetchConverter );\n-  128: \t\tfinal Initializer<?>[] initializers = new Initializer[assemblers.length];\n-  129: \t\tfinal Initializer<?>[] eagerSubInitializers = new Initializer[assemblers.length];\n-  130: \t\tboolean empty = true;\n-  131: \t\tboolean emptyEager = true;\n-  132: \t\tboolean lazyCapable = false;\n-  133: \t\tboolean hasLazySubInitializers = false;\n-  134: \t\tfor ( int i = 0; i < assemblers.length; i++ ) {\n-  135: \t\t\tfinal Initializer<?> initializer = assemblers[i].getInitializer();\n-  136: \t\t\tif ( initializer != null ) {\n-  137: \t\t\t\tif ( initializer.isEager() ) {\n-  138: \t\t\t\t\teagerSubInitializers[i] = initializer;\n-  139: \t\t\t\t\thasLazySubInitializers = hasLazySubInitializers || initializer.hasLazySubInitializers();\n-  140: \t\t\t\t\temptyEager = false;\n-  141: \t\t\t\t}\n-  142: \t\t\t\telse {\n-  143: \t\t\t\t\thasLazySubInitializers = true;\n-  144: \t\t\t\t}\n-  145: \t\t\t\tlazyCapable = lazyCapable || initializer.isLazyCapable();\n-  146: \t\t\t\tinitializers[i] = initializer;\n-  147: \t\t\t\tempty = false;\n-  148: \t\t\t}\n-  149: \t\t}\n-  150: \t\t//noinspection unchecked\n-  151: \t\tthis.initializers = (Initializer<InitializerData>[]) (\n-  152: \t\t\t\tempty ? Initializer.EMPTY_ARRAY : initializers\n-  153: \t\t);\n-  154: \t\t// No need to think about bytecode enhancement here, since ids can't contain lazy basic attributes\n-  155: \t\tthis.subInitializersForResolveFromInitialized = (Initializer<InitializerData>[]) (\n-  156: \t\t\t\temptyEager ? Initializer.EMPTY_ARRAY : initializers\n-  157: \t\t);\n-  158: \t\tthis.lazyCapable = lazyCapable;\n-  159: \t\tthis.hasLazySubInitializer = hasLazySubInitializers;\n-  160: \t}\n-  161: \n-  162: \tprotected static DomainResultAssembler<?>[] createAssemblers(\n-  163: \t\t\tInitializerParent<?> parent,\n-  164: \t\t\tEmbeddableResultGraphNode resultDescriptor,\n-  165: \t\t\tAssemblerCreationState creationState,\n-  166: \t\t\tEmbeddableMappingType embeddableTypeDescriptor,\n-  167: \t\t\tFunction<Fetch, Fetch> fetchConverter) {\n-  168: \t\tfinal int size = embeddableTypeDescriptor.getNumberOfFetchables();\n-  169: \t\tfinal DomainResultAssembler<?>[] assemblers = new DomainResultAssembler[size];\n-  170: \t\tfor ( int i = 0; i < size; i++ ) {\n-  171: \t\t\tfinal Fetchable stateArrayContributor = embeddableTypeDescriptor.getFetchable( i );\n-  172: \t\t\tfinal Fetch fetch = fetchConverter.apply( resultDescriptor.findFetch( stateArrayContributor ) );\n-  173: \n-  174: \t\t\tfinal DomainResultAssembler<?> stateAssembler = fetch == null\n-  175: \t\t\t\t\t? new NullValueAssembler<>( stateArrayContributor.getJavaType() )\n-  176: \t\t\t\t\t: fetch.createAssembler( parent, creationState );\n-  177: \n-  178: \t\t\tassemblers[i] = stateAssembler;\n-  179: \t\t}\n-  180: \t\treturn assemblers;\n-  181: \t}\n-  182: \n-  183: \t@Override\n-  184: \tpublic EmbeddableValuedModelPart getInitializedPart() {\n-  185: \t\treturn embedded;\n-  186: \t}\n-  187: \n-  188: \t@Override\n-  189: \tpublic @Nullable InitializerParent<?> getParent() {\n+  109: \t\tthis( resultDescriptor, parent, creationState, isResultInitializer, Function.identity() );\n+  110: \t}\n+  111: \n+  112: \tprotected NonAggregatedIdentifierMappingInitializer(\n+  113: \t\t\tEmbeddableResultGraphNode resultDescriptor,\n+  114: \t\t\tInitializerParent<?> parent,\n+  115: \t\t\tAssemblerCreationState creationState,\n+  116: \t\t\tboolean isResultInitializer,\n+  117: \t\t\tFunction<Fetch, Fetch> fetchConverter) {\n+  118: \t\tsuper( creationState );\n+  119: \t\tthis.navigablePath = resultDescriptor.getNavigablePath();\n+  120: \t\tthis.embedded = (NonAggregatedIdentifierMapping) resultDescriptor.getReferencedMappingContainer();\n+  121: \t\tthis.parent = parent;\n+  122: \t\tthis.isResultInitializer = isResultInitializer;\n+  123: \n+  124: \t\tthis.virtualIdEmbeddable = embedded.getEmbeddableTypeDescriptor();\n+  125: \t\tthis.representationEmbeddable = embedded.getMappedIdEmbeddableTypeDescriptor();\n+  126: \t\tthis.embeddableInstantiator = representationEmbeddable.getRepresentationStrategy().getInstantiator();\n+  127: \t\tthis.hasIdClass = embedded.hasContainingClass() && virtualIdEmbeddable != representationEmbeddable;\n+  128: \n+  129: \t\tthis.sessionFactory = creationState.getSqlAstCreationContext().getSessionFactory();\n+  130: \n+  131: \t\tfinal int size = virtualIdEmbeddable.getNumberOfFetchables();\n+  132: \t\tfinal DomainResultAssembler<?>[] assemblers = new DomainResultAssembler[size];\n+  133: \t\tthis.assemblers = assemblers;\n+  134: \t\tfinal Initializer<?>[] initializers = new Initializer[assemblers.length];\n+  135: \t\tfinal Initializer<?>[] eagerSubInitializers = new Initializer[assemblers.length];\n+  136: \t\tfinal Initializer<?>[] collectionContainingSubInitializers = new Initializer[assemblers.length];\n+  137: \t\tboolean empty = true;\n+  138: \t\tboolean emptyEager = true;\n+  139: \t\tboolean emptyCollectionInitializers = true;\n+  140: \t\tboolean lazyCapable = false;\n+  141: \t\tboolean hasLazySubInitializers = false;\n+  142: \t\tfor ( int i = 0; i < size; i++ ) {\n+  143: \t\t\tfinal Fetchable stateArrayContributor = virtualIdEmbeddable.getFetchable( i );\n+  144: \t\t\tfinal Fetch fetch = fetchConverter.apply( resultDescriptor.findFetch( stateArrayContributor ) );\n+  145: \n+  146: \t\t\tfinal DomainResultAssembler<?> stateAssembler = fetch == null\n+  147: \t\t\t\t\t? new NullValueAssembler<>( stateArrayContributor.getJavaType() )\n+  148: \t\t\t\t\t: fetch.createAssembler( this, creationState );\n+  149: \n+  150: \t\t\tassemblers[i] = stateAssembler;\n+  151: \n+  152: \t\t\tfinal Initializer<?> initializer = stateAssembler.getInitializer();\n+  153: \t\t\tif ( initializer != null ) {\n+  154: \t\t\t\tif ( initializer.isEager() ) {\n+  155: \t\t\t\t\teagerSubInitializers[i] = initializer;\n+  156: \t\t\t\t\thasLazySubInitializers = hasLazySubInitializers || initializer.hasLazySubInitializers();\n+  157: \t\t\t\t\temptyEager = false;\n+  158: \t\t\t\t\tassert fetch != null;\n+  159: \t\t\t\t\tfinal FetchParent fetchParent;\n+  160: \t\t\t\t\tif ( ( fetchParent = fetch.asFetchParent() ) != null && fetchParent.containsCollectionFetches()\n+  161: \t\t\t\t\t\t\t|| initializer.isCollectionInitializer() ) {\n+  162: \t\t\t\t\t\tcollectionContainingSubInitializers[i] = initializer;\n+  163: \t\t\t\t\t\temptyCollectionInitializers = false;\n+  164: \t\t\t\t\t}\n+  165: \t\t\t\t}\n+  166: \t\t\t\telse {\n+  167: \t\t\t\t\thasLazySubInitializers = true;\n+  168: \t\t\t\t}\n+  169: \t\t\t\tlazyCapable = lazyCapable || initializer.isLazyCapable();\n+  170: \t\t\t\tinitializers[i] = initializer;\n+  171: \t\t\t\tempty = false;\n+  172: \t\t\t}\n+  173: \t\t}\n+  174: \t\t//noinspection unchecked\n+  175: \t\tthis.initializers = (Initializer<InitializerData>[]) (\n+  176: \t\t\t\tempty ? Initializer.EMPTY_ARRAY : initializers\n+  177: \t\t);\n+  178: \t\t// No need to think about bytecode enhancement here, since ids can't contain lazy basic attributes\n+  179: \t\t//noinspection unchecked\n+  180: \t\tthis.subInitializersForResolveFromInitialized = (Initializer<InitializerData>[]) (\n+  181: \t\t\t\temptyEager ? Initializer.EMPTY_ARRAY : initializers\n+  182: \t\t);\n+  183: \t\t//noinspection unchecked\n+  184: \t\tthis.collectionContainingSubInitializers = (Initializer<InitializerData>[]) (\n+  185: \t\t\t\temptyCollectionInitializers ? Initializer.EMPTY_ARRAY : collectionContainingSubInitializers\n+  186: \t\t);\n+  187: \t\tthis.lazyCapable = lazyCapable;\n+  188: \t\tthis.hasLazySubInitializer = hasLazySubInitializers;\n+  189: \t}\n",
        "uniqueId": "f8a6106ea20df36dc5c07827948a04b77243c1a6_109_160__112_189_162_181",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 6,
                "covered": 37
            },
            "BRANCH": {
                "missed": 1,
                "covered": 3
            },
            "LINE": {
                "missed": 1,
                "covered": 9
            },
            "COMPLEXITY": {
                "missed": 1,
                "covered": 2
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 11
    },
    {
        "type": "Move And Inline Method",
        "description": "Move And Inline Method\tpublic getEntityInstance(data Data) : Object moved from class org.hibernate.sql.results.graph.entity.internal.AbstractBatchEntitySelectFetchInitializer to class org.hibernate.sql.results.graph.entity.internal.EntityInitializerImpl & inlined to public resolveInstance(data EntityInitializerData) : void",
        "diffLocations": [
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/sql/results/graph/entity/internal/EntityInitializerImpl.java",
                "startLine": 820,
                "endLine": 877,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/sql/results/graph/entity/internal/EntityInitializerImpl.java",
                "startLine": 895,
                "endLine": 952,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/sql/results/graph/entity/internal/EntityInitializerImpl.java",
                "startLine": 231,
                "endLine": 234,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "}\n\n\t\trowIdAssembler = rowIdResult != null\n\t\t\t\t? rowIdResult.createResultAssembler( this, creationState )",
        "filePathBefore": "hibernate-core/src/main/java/org/hibernate/sql/results/graph/entity/internal/EntityInitializerImpl.java",
        "isPureRefactoring": true,
        "commitId": "72e2da2da84fae761f14ceeb822bd3e946690c78",
        "packageNameBefore": "org.hibernate.sql.results.graph.entity.internal",
        "classNameBefore": "org.hibernate.sql.results.graph.entity.internal.AbstractBatchEntitySelectFetchInitializer",
        "methodNameBefore": "org.hibernate.sql.results.graph.entity.internal.AbstractBatchEntitySelectFetchInitializer#getEntityInstance",
        "invokedMethod": "methodSignature: org.hibernate.action.internal.EntityUpdateAction#getState\n methodBody: protected Object[] getState() {\nreturn state;\n}",
        "classSignatureBefore": "public abstract class AbstractBatchEntitySelectFetchInitializer<Data extends AbstractBatchEntitySelectFetchInitializer.AbstractBatchEntitySelectFetchInitializerData>\n\t\textends EntitySelectFetchInitializer<Data> implements EntityInitializer<Data> ",
        "methodNameBeforeSet": [
            "org.hibernate.sql.results.graph.entity.internal.AbstractBatchEntitySelectFetchInitializer#getEntityInstance"
        ],
        "classNameBeforeSet": [
            "org.hibernate.sql.results.graph.entity.internal.AbstractBatchEntitySelectFetchInitializer"
        ],
        "classSignatureBeforeSet": [
            "public abstract class AbstractBatchEntitySelectFetchInitializer<Data extends AbstractBatchEntitySelectFetchInitializer.AbstractBatchEntitySelectFetchInitializerData>\n\t\textends EntitySelectFetchInitializer<Data> implements EntityInitializer<Data> "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Tolerable changes in the body\n",
                "description": "All replacements have been justified - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later\n * See the lgpl.txt file in the root directory or http://www.gnu.org/licenses/lgpl-2.1.html\n */\npackage org.hibernate.sql.results.graph.entity.internal;\n\nimport java.util.Collection;\nimport java.util.function.BiConsumer;\n\nimport org.hibernate.EntityFilterException;\nimport org.hibernate.FetchNotFoundException;\nimport org.hibernate.Hibernate;\nimport org.hibernate.HibernateException;\nimport org.hibernate.LockMode;\nimport org.hibernate.StaleObjectStateException;\nimport org.hibernate.WrongClassException;\nimport org.hibernate.annotations.NotFoundAction;\nimport org.hibernate.bytecode.enhance.spi.LazyPropertyInitializer;\nimport org.hibernate.bytecode.enhance.spi.interceptor.EnhancementAsProxyLazinessInterceptor;\nimport org.hibernate.cache.spi.access.EntityDataAccess;\nimport org.hibernate.cache.spi.entry.CacheEntry;\nimport org.hibernate.engine.spi.EntityEntry;\nimport org.hibernate.engine.spi.EntityHolder;\nimport org.hibernate.engine.spi.EntityKey;\nimport org.hibernate.engine.spi.EntityUniqueKey;\nimport org.hibernate.engine.spi.PersistenceContext;\nimport org.hibernate.engine.spi.PersistentAttributeInterceptor;\nimport org.hibernate.engine.spi.SessionEventListenerManager;\nimport org.hibernate.engine.spi.SessionFactoryImplementor;\nimport org.hibernate.engine.spi.SharedSessionContractImplementor;\nimport org.hibernate.engine.spi.Status;\nimport org.hibernate.event.spi.EventManager;\nimport org.hibernate.event.spi.HibernateMonitoringEvent;\nimport org.hibernate.event.spi.PreLoadEvent;\nimport org.hibernate.event.spi.PreLoadEventListener;\nimport org.hibernate.internal.log.LoggingHelper;\nimport org.hibernate.loader.ast.internal.CacheEntityLoaderHelper;\nimport org.hibernate.metamodel.mapping.AttributeMapping;\nimport org.hibernate.metamodel.mapping.AttributeMetadata;\nimport org.hibernate.metamodel.mapping.CompositeIdentifierMapping;\nimport org.hibernate.metamodel.mapping.DiscriminatorValueDetails;\nimport org.hibernate.metamodel.mapping.EntityDiscriminatorMapping;\nimport org.hibernate.metamodel.mapping.EntityMappingType;\nimport org.hibernate.metamodel.mapping.EntityValuedModelPart;\nimport org.hibernate.metamodel.mapping.EntityVersionMapping;\nimport org.hibernate.metamodel.mapping.ManagedMappingType;\nimport org.hibernate.metamodel.mapping.ModelPart;\nimport org.hibernate.metamodel.mapping.internal.ToOneAttributeMapping;\nimport org.hibernate.persister.entity.EntityPersister;\nimport org.hibernate.persister.entity.UniqueKeyEntry;\nimport org.hibernate.property.access.internal.PropertyAccessStrategyBackRefImpl;\nimport org.hibernate.proxy.LazyInitializer;\nimport org.hibernate.proxy.map.MapProxy;\nimport org.hibernate.spi.NavigablePath;\nimport org.hibernate.sql.exec.spi.ExecutionContext;\nimport org.hibernate.sql.results.graph.AssemblerCreationState;\nimport org.hibernate.sql.results.graph.DomainResult;\nimport org.hibernate.sql.results.graph.DomainResultAssembler;\nimport org.hibernate.sql.results.graph.Fetch;\nimport org.hibernate.sql.results.graph.Initializer;\nimport org.hibernate.sql.results.graph.InitializerData;\nimport org.hibernate.sql.results.graph.InitializerParent;\nimport org.hibernate.sql.results.graph.basic.BasicResultAssembler;\nimport org.hibernate.sql.results.graph.collection.internal.AbstractImmediateCollectionInitializer;\nimport org.hibernate.sql.results.graph.entity.EntityInitializer;\nimport org.hibernate.sql.results.graph.entity.EntityResultGraphNode;\nimport org.hibernate.sql.results.graph.internal.AbstractInitializer;\nimport org.hibernate.sql.results.internal.NullValueAssembler;\nimport org.hibernate.sql.results.jdbc.spi.JdbcValuesSourceProcessingOptions;\nimport org.hibernate.sql.results.jdbc.spi.RowProcessingState;\nimport org.hibernate.stat.spi.StatisticsImplementor;\nimport org.hibernate.type.Type;\nimport org.hibernate.type.descriptor.java.MutabilityPlan;\n\nimport org.checkerframework.checker.nullness.qual.EnsuresNonNull;\nimport org.checkerframework.checker.nullness.qual.Nullable;\n\nimport static org.hibernate.bytecode.enhance.spi.LazyPropertyInitializer.UNFETCHED_PROPERTY;\nimport static org.hibernate.engine.internal.ManagedTypeHelper.asPersistentAttributeInterceptable;\nimport static org.hibernate.engine.internal.ManagedTypeHelper.isPersistentAttributeInterceptable;\nimport static org.hibernate.internal.log.LoggingHelper.toLoggableString;\nimport static org.hibernate.metamodel.mapping.ForeignKeyDescriptor.Nature.TARGET;\nimport static org.hibernate.proxy.HibernateProxy.extractLazyInitializer;\n\n/**\n * @author Andrea Boriero\n */\npublic class EntityInitializerImpl extends AbstractInitializer<EntityInitializerImpl.EntityInitializerData>\n\t\timplements EntityInitializer<EntityInitializerImpl.EntityInitializerData> {\n\n\t// NOTE : even though we only keep the EntityDescriptor here, rather than EntityResultGraphNode\n\t//\t\tthe \"scope\" of this initializer is a specific EntityReference.\n\t//\n\t//\t\tThe full EntityResultGraphNode is simply not needed here, and so we just keep\n\t//\t\tthe EntityDescriptor here to avoid chicken/egg issues in the creation of\n\t// \t\tthese\n\n\tprivate final EntityValuedModelPart referencedModelPart;\n\tprivate final EntityPersister entityDescriptor;\n\tprivate final EntityPersister rootEntityDescriptor;\n\tprivate final NavigablePath navigablePath;\n\tprivate final String sourceAlias;\n\tprivate final @Nullable InitializerParent<?> parent;\n\tprivate final NotFoundAction notFoundAction;\n\tprivate final boolean affectedByFilter;\n\tprivate final boolean isPartOfKey;\n\tprivate final boolean isResultInitializer;\n\tprivate final boolean hasKeyManyToOne;\n\t/**\n\t * Indicates whether there is a high chance of the previous row to have the same entity key as the current row\n\t * and hence enable a check in the {@link #resolveKey(RowProcessingState)} phase which compare the previously read\n\t * identifier with the current row identifier. If it matches, the state from the previous row processing can be reused.\n\t * In addition to that, all direct sub-initializers can be informed about the reuse by calling {@link Initializer#resolveFromPreviousRow(RowProcessingState)},\n\t * so that these initializers can avoid unnecessary processing as well.\n\t */\n\tprivate final boolean previousRowReuse;\n\n\tprivate final @Nullable DomainResultAssembler<?> keyAssembler;\n\tprivate final @Nullable DomainResultAssembler<?> identifierAssembler;\n\tprivate final @Nullable BasicResultAssembler<?> discriminatorAssembler;\n\tprivate final @Nullable DomainResultAssembler<?> versionAssembler;\n\tprivate final @Nullable DomainResultAssembler<Object> rowIdAssembler;\n\n\tprivate final DomainResultAssembler<?>[][] assemblers;\n\tprivate final Initializer<?>[][] subInitializers;\n\tprivate final MutabilityPlan<Object>[][] updatableAttributeMutabilityPlans;\n\n\tpublic static class EntityInitializerData extends InitializerData {\n\n\t\tprotected boolean shallowCached;\n\t\tprotected LockMode lockMode;\n\t\tprotected String uniqueKeyAttributePath;\n\t\tprotected Type[] uniqueKeyPropertyTypes;\n\t\tprotected boolean canUseEmbeddedIdentifierInstanceAsEntity;\n\t\tprotected boolean hasCallbackActions;\n\n\t\t// per-row state\n\t\tprotected @Nullable EntityPersister concreteDescriptor;\n\t\tprotected @Nullable EntityKey entityKey;\n\t\tprotected @Nullable Object entityInstanceForNotify;\n\t\tprotected @Nullable EntityHolder entityHolder;\n\n\t\tpublic EntityInitializerData(RowProcessingState rowProcessingState) {\n\t\t\tsuper( rowProcessingState );\n\t\t}\n\n\t\t/*\n\t\t * Used by Hibernate Reactive\n\t\t */\n\t\tpublic EntityInitializerData(EntityInitializerData original) {\n\t\t\tsuper( original );\n\t\t\tthis.shallowCached = original.shallowCached;\n\t\t\tthis.lockMode = original.lockMode;\n\t\t\tthis.uniqueKeyAttributePath = original.uniqueKeyAttributePath;\n\t\t\tthis.uniqueKeyPropertyTypes = original.uniqueKeyPropertyTypes;\n\t\t\tthis.canUseEmbeddedIdentifierInstanceAsEntity = original.canUseEmbeddedIdentifierInstanceAsEntity;\n\t\t\tthis.hasCallbackActions = original.hasCallbackActions;\n\t\t\tthis.concreteDescriptor = original.concreteDescriptor;\n\t\t\tthis.entityKey = original.entityKey;\n\t\t\tthis.entityInstanceForNotify = original.entityInstanceForNotify;\n\t\t\tthis.entityHolder = original.entityHolder;\n\t\t}\n\t}\n\n\tpublic EntityInitializerImpl(\n\t\t\tEntityResultGraphNode resultDescriptor,\n\t\t\tString sourceAlias,\n\t\t\t@Nullable Fetch identifierFetch,\n\t\t\t@Nullable Fetch discriminatorFetch,\n\t\t\t@Nullable DomainResult<?> keyResult,\n\t\t\t@Nullable DomainResult<Object> rowIdResult,\n\t\t\tNotFoundAction notFoundAction,\n\t\t\tboolean affectedByFilter,\n\t\t\t@Nullable InitializerParent<?> parent,\n\t\t\tboolean isResultInitializer,\n\t\t\tAssemblerCreationState creationState) {\n\t\tsuper( creationState );\n\n\t\treferencedModelPart = resultDescriptor.getEntityValuedModelPart();\n\t\tentityDescriptor = (EntityPersister) referencedModelPart.getEntityMappingType();\n\n\t\tfinal String rootEntityName = entityDescriptor.getRootEntityName();\n\t\trootEntityDescriptor = rootEntityName == null || rootEntityName.equals( entityDescriptor.getEntityName() )\n\t\t\t\t? entityDescriptor\n\t\t\t\t: entityDescriptor.getRootEntityDescriptor().getEntityPersister();\n\n\t\tthis.navigablePath = resultDescriptor.getNavigablePath();\n\t\tthis.sourceAlias = sourceAlias;\n\t\tthis.parent = parent;\n\t\tthis.isResultInitializer = isResultInitializer;\n\t\tthis.isPartOfKey = Initializer.isPartOfKey( navigablePath, parent );\n\t\t// If the parent already has previous row reuse enabled, we can skip that here\n\t\tthis.previousRowReuse = !isPreviousRowReuse( parent ) && (\n\t\t\t\t// If this entity domain result contains a collection join fetch, this usually means that the entity data is\n\t\t\t\t// duplicate in the result data for every collection element. Since collections usually have more than one element,\n\t\t\t\t// optimizing the resolving of the entity data is very beneficial.\n\t\t\t\tresultDescriptor.containsCollectionFetches()\n\t\t\t\t\t\t// Result duplication generally also happens if more than one collection is join fetched,\n\t\t\t\t\t\t|| creationState.containsMultipleCollectionFetches()\n\t\t);\n\n\t\tassert identifierFetch != null || isResultInitializer : \"Identifier must be fetched, unless this is a result initializer\";\n\t\tif ( identifierFetch == null ) {\n\t\t\tidentifierAssembler = null;\n\t\t\thasKeyManyToOne = false;\n\t\t}\n\t\telse {\n\t\t\tidentifierAssembler = identifierFetch.createAssembler( this, creationState );\n\t\t\tfinal Initializer<?> initializer = identifierAssembler.getInitializer();\n\t\t\t// For now, assume key many to ones if the identifier has an initializer\n\t\t\t// todo: improve this\n\t\t\thasKeyManyToOne = initializer != null;\n\t\t}\n\n\t\tassert entityDescriptor.hasSubclasses() == (discriminatorFetch != null) : \"Discriminator should only be fetched if the entity has subclasses\";\n\t\tdiscriminatorAssembler = discriminatorFetch != null\n\t\t\t\t? (BasicResultAssembler<?>) discriminatorFetch.createAssembler( this, creationState )\n\t\t\t\t: null;\n\n\t\tfinal EntityVersionMapping versionMapping = entityDescriptor.getVersionMapping();\n\t\tif ( versionMapping != null ) {\n\t\t\tfinal Fetch versionFetch = resultDescriptor.findFetch( versionMapping );\n\t\t\t// If there is a version mapping, there must be a fetch for it\n\t\t\tassert versionFetch != null;\n\t\t\tversionAssembler = versionFetch.createAssembler( this, creationState );\n\t\t}\n\t\telse {\n\t\t\tversionAssembler = null;\n\t\t}\n\n\t\trowIdAssembler = rowIdResult != null\n\t\t\t\t? rowIdResult.createResultAssembler( this, creationState )\n\t\t\t\t: null;\n\n\t\tfinal Collection<EntityMappingType> subMappingTypes = rootEntityDescriptor.getSubMappingTypes();\n\t\tfinal DomainResultAssembler<?>[][] assemblers = new DomainResultAssembler[subMappingTypes.size() + 1][];\n\t\tfinal Initializer<?>[][] subInitializers = new Initializer<?>[subMappingTypes.size() + 1][];\n\t\tfinal MutabilityPlan[][] updatableAttributeMutabilityPlans = new MutabilityPlan[subMappingTypes.size() + 1][];\n\t\tassemblers[rootEntityDescriptor.getSubclassId()] = new DomainResultAssembler[rootEntityDescriptor.getNumberOfFetchables()];\n\t\tupdatableAttributeMutabilityPlans[rootEntityDescriptor.getSubclassId()] = new MutabilityPlan[rootEntityDescriptor.getNumberOfAttributeMappings()];\n\n\t\tfor ( EntityMappingType subMappingType : subMappingTypes ) {\n\t\t\tassemblers[subMappingType.getSubclassId()] = new DomainResultAssembler[subMappingType.getNumberOfFetchables()];\n\t\t\tupdatableAttributeMutabilityPlans[subMappingType.getSubclassId()] = new MutabilityPlan[subMappingType.getNumberOfAttributeMappings()];\n\t\t}\n\n\t\tfinal int size = entityDescriptor.getNumberOfFetchables();\n\t\tfor ( int i = 0; i < size; i++ ) {\n\t\t\tfinal AttributeMapping attributeMapping = entityDescriptor.getFetchable( i ).asAttributeMapping();\n\t\t\tfinal Fetch fetch = resultDescriptor.findFetch( attributeMapping );\n\t\t\tfinal DomainResultAssembler<?> stateAssembler = fetch == null\n\t\t\t\t\t? new NullValueAssembler<>( attributeMapping.getMappedType().getMappedJavaType() )\n\t\t\t\t\t: fetch.createAssembler( this, creationState );\n\n\t\t\tfinal int stateArrayPosition = attributeMapping.getStateArrayPosition();\n\t\t\tfinal EntityMappingType declaringType = attributeMapping.getDeclaringType().asEntityMappingType();\n\t\t\tfinal int subclassId = declaringType.getSubclassId();\n\n\t\t\tfinal Initializer<?> subInitializer = stateAssembler.getInitializer();\n\t\t\tif ( subInitializer != null ) {\n\t\t\t\tif ( subInitializers[subclassId] == null ) {\n\t\t\t\t\tsubInitializers[subclassId] = new Initializer<?>[size];\n\t\t\t\t}\n\t\t\t\tsubInitializers[subclassId][stateArrayPosition] = subInitializer;\n\t\t\t}\n\n\t\t\tassemblers[subclassId][stateArrayPosition] = stateAssembler;\n\t\t\tfinal AttributeMetadata attributeMetadata = attributeMapping.getAttributeMetadata();\n\t\t\tif ( attributeMetadata.isUpdatable() ) {\n\t\t\t\tupdatableAttributeMutabilityPlans[subclassId][stateArrayPosition] = attributeMetadata.getMutabilityPlan();\n\t\t\t}\n\t\t\tfor ( EntityMappingType subMappingType : declaringType.getSubMappingTypes() ) {\n\t\t\t\tassemblers[subMappingType.getSubclassId()][stateArrayPosition] = stateAssembler;\n\t\t\t\tupdatableAttributeMutabilityPlans[subMappingType.getSubclassId()][stateArrayPosition] = updatableAttributeMutabilityPlans[subclassId][stateArrayPosition];\n\t\t\t\tif ( subInitializer != null ) {\n\t\t\t\t\tif ( subInitializers[subMappingType.getSubclassId()] == null ) {\n\t\t\t\t\t\tsubInitializers[subMappingType.getSubclassId()] = new Initializer<?>[size];\n\t\t\t\t\t}\n\t\t\t\t\tsubInitializers[subMappingType.getSubclassId()][stateArrayPosition] = subInitializer;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tOUTER: for ( int i = 0; i < subInitializers.length; i++ ) {\n\t\t\tif ( subInitializers[i] != null ) {\n\t\t\t\tfor ( Initializer<?> initializer : subInitializers[i] ) {\n\t\t\t\t\tif ( initializer != null ) {\n\t\t\t\t\t\tcontinue OUTER;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tsubInitializers[i] = Initializer.EMPTY_ARRAY;\n\t\t}\n\n\t\tthis.assemblers = assemblers;\n\t\tthis.subInitializers = subInitializers;\n\t\tthis.updatableAttributeMutabilityPlans = updatableAttributeMutabilityPlans;\n\t\tthis.notFoundAction = notFoundAction;\n\n\t\tthis.keyAssembler = keyResult == null ? null : keyResult.createResultAssembler( this, creationState );\n\t\tthis.affectedByFilter = affectedByFilter;\n\t}\n\n\tprivate static boolean isPreviousRowReuse(@Nullable InitializerParent<?> parent) {\n\t\t// Traverse up the parents to find out if one of our parents has row reuse enabled\n\t\twhile ( parent != null ) {\n\t\t\tif ( parent instanceof EntityInitializerImpl ) {\n\t\t\t\treturn ( (EntityInitializerImpl) parent ).isPreviousRowReuse();\n\t\t\t}\n\t\t\t// Immediate collections don't reuse previous rows for elements, so we can safely assume false\n\t\t\tif ( parent instanceof AbstractImmediateCollectionInitializer<?> ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tparent = parent.getParent();\n\t\t}\n\t\treturn false;\n\t}\n\n\t@Override\n\tprotected EntityInitializerData createInitializerData(RowProcessingState rowProcessingState) {\n\t\treturn new EntityInitializerData( rowProcessingState );\n\t}\n\n\t@Override\n\tpublic void resolveKey(EntityInitializerData data) {\n\t\tresolveKey( data, false );\n\t}\n\n\t@Override\n\tpublic @Nullable Object getEntityIdentifier(EntityInitializerData data) {\n\t\treturn data.entityKey == null ? null : data.entityKey.getIdentifier();\n\t}\n\n\t@Override\n\tpublic @Nullable EntityKey resolveEntityKeyOnly(RowProcessingState rowProcessingState) {\n\t\tfinal EntityInitializerData data = getData( rowProcessingState );\n\t\tresolveKey( data, true );\n\t\tif ( data.getState() == State.MISSING ) {\n\t\t\treturn null;\n\t\t}\n\t\tif ( data.entityKey == null ) {\n\t\t\tassert identifierAssembler != null;\n\t\t\tfinal Object id = identifierAssembler.assemble( rowProcessingState );\n\t\t\tif ( id == null ) {\n\t\t\t\tsetMissing( data );\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tresolveEntityKey( data, id );\n\t\t}\n\t\treturn data.entityKey;\n\t}\n\n\tprotected void resolveKey(EntityInitializerData data, boolean entityKeyOnly) {\n\t\t// todo (6.0) : atm we do not handle sequential selects\n\t\t// \t\t- see AbstractEntityPersister#hasSequentialSelect and\n\t\t//\t\t\tAbstractEntityPersister#getSequentialSelect in 5.2\n\t\tif ( data.getState() != State.UNINITIALIZED ) {\n\t\t\treturn;\n\t\t}\n\t\tdata.setState( State.KEY_RESOLVED );\n\n\t\tfinal EntityKey oldEntityKey = data.entityKey;\n\t\tfinal Object oldEntityInstance = data.getInstance();\n\t\tfinal Object oldEntityInstanceForNotify = data.entityInstanceForNotify;\n\t\tfinal EntityHolder oldEntityHolder = data.entityHolder;\n\t\t// reset row state\n\t\tdata.concreteDescriptor = null;\n\t\tdata.entityKey = null;\n\t\tdata.setInstance( null );\n\t\tdata.entityInstanceForNotify = null;\n\t\tdata.entityHolder = null;\n\n\t\tfinal RowProcessingState rowProcessingState = data.getRowProcessingState();\n\t\tfinal Object id;\n\t\tif ( identifierAssembler == null ) {\n\t\t\tid = rowProcessingState.getEntityId();\n\t\t\tassert id != null : \"Initializer requires a not null id for loading\";\n\t\t}\n\t\telse {\n\t\t\t//noinspection unchecked\n\t\t\tfinal Initializer<InitializerData> initializer = (Initializer<InitializerData>) identifierAssembler.getInitializer();\n\t\t\tif ( initializer != null ) {\n\t\t\t\tfinal InitializerData subData = initializer.getData( rowProcessingState );\n\t\t\t\tinitializer.resolveKey( subData );\n\t\t\t\tif ( subData.getState() == State.MISSING ) {\n\t\t\t\t\tsetMissing( data );\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdata.concreteDescriptor = determineConcreteEntityDescriptor(\n\t\t\t\t\t\t\trowProcessingState,\n\t\t\t\t\t\t\tdiscriminatorAssembler,\n\t\t\t\t\t\t\tentityDescriptor\n\t\t\t\t\t);\n\t\t\t\t\tassert data.concreteDescriptor != null;\n\t\t\t\t\tif ( hasKeyManyToOne ) {\n\t\t\t\t\t\tif ( !data.shallowCached && !entityKeyOnly ) {\n\t\t\t\t\t\t\tresolveKeySubInitializers( data );\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tid = identifierAssembler.assemble( rowProcessingState );\n\t\t\tif ( id == null ) {\n\t\t\t\tsetMissing( data );\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tif ( oldEntityKey != null && previousRowReuse && oldEntityInstance != null\n\t\t\t\t&& entityDescriptor.getIdentifierType().isEqual( oldEntityKey.getIdentifier(), id ) ) {\n\t\t\t// The row we read previously referred to this entity already, so we can safely assume it's initialized.\n\t\t\t// Unfortunately we can't set the state to INITIALIZED though, as that has other implications,\n\t\t\t// but RESOLVED is fine, since the EntityEntry is marked as initialized which skips instance initialization\n\t\t\tdata.setState( State.RESOLVED );\n\t\t\tdata.entityKey = oldEntityKey;\n\t\t\tdata.setInstance( oldEntityInstance );\n\t\t\tdata.entityInstanceForNotify = oldEntityInstanceForNotify;\n\t\t\tdata.concreteDescriptor = oldEntityKey.getPersister();\n\t\t\tdata.entityHolder = oldEntityHolder;\n\t\t\tnotifySubInitializersToReusePreviousRowInstance( data );\n\t\t\treturn;\n\t\t}\n\t\tresolveEntityKey( data, id );\n\t\tif ( !entityKeyOnly ) {\n\t\t\t// Resolve the entity instance early as we have no key many-to-one\n\t\t\tresolveInstance( data );\n\t\t\tif ( !data.shallowCached ) {\n\t\t\t\tif ( data.getState() == State.INITIALIZED ) {\n\t\t\t\t\tif ( data.entityHolder.getEntityInitializer() == null ) {\n\t\t\t\t\t\t// The entity is already part of the persistence context,\n\t\t\t\t\t\t// so let's figure out the loaded state and only run sub-initializers if necessary\n\t\t\t\t\t\tresolveInstanceSubInitializers( data );\n\t\t\t\t\t}\n\t\t\t\t\t// If the entity is initialized and getEntityInitializer() == this,\n\t\t\t\t\t// we already processed a row for this entity before,\n\t\t\t\t\t// but we still have to call resolveKeySubInitializers to activate sub-initializers,\n\t\t\t\t\t// because a row might contain data that sub-initializers want to consume\n\t\t\t\t\telse {\n\t\t\t\t\t\t// todo: try to diff the eagerness of the sub-initializers to avoid further processing\n\t\t\t\t\t\tresolveKeySubInitializers( data );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tresolveKeySubInitializers( data );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprotected void resolveInstanceSubInitializers(EntityInitializerData data) {\n\t\tfinal Initializer<?>[] initializers = subInitializers[data.concreteDescriptor.getSubclassId()];\n\t\tif ( initializers.length == 0 ) {\n\t\t\treturn;\n\t\t}\n\t\tfinal EntityEntry entityEntry = data.entityHolder.getEntityEntry();\n\t\tfinal RowProcessingState rowProcessingState = data.getRowProcessingState();\n\t\tassert entityEntry == rowProcessingState.getSession()\n\t\t\t\t.getPersistenceContextInternal()\n\t\t\t\t.getEntry( data.entityInstanceForNotify );\n\t\tfinal Object[] loadedState = entityEntry.getLoadedState();\n\t\tfinal Object[] state;\n\t\tif ( loadedState == null ) {\n\t\t\tif ( entityEntry.getStatus() == Status.READ_ONLY ) {\n\t\t\t\tstate = data.concreteDescriptor.getValues( data.entityInstanceForNotify );\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// This branch is entered when a load happens while a cache entry is assembling.\n\t\t\t\t// The EntityEntry has the LOADING state, but the loaded state is still empty.\n\t\t\t\tassert entityEntry.getStatus() == Status.LOADING;\n\t\t\t\t// Just skip any initialization in this case as the cache entry assembling will take care of it\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tstate = loadedState;\n\t\t}\n\t\tfor ( int i = 0; i < initializers.length; i++ ) {\n\t\t\tfinal Initializer<?> initializer = initializers[i];\n\t\t\tif ( initializer != null ) {\n\t\t\t\tfinal Object subInstance = state[i];\n\t\t\t\tif ( subInstance == UNFETCHED_PROPERTY ) {\n\t\t\t\t\t// Go through the normal initializer process\n\t\t\t\t\tinitializer.resolveKey( rowProcessingState );\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tinitializer.resolveInstance( subInstance, rowProcessingState );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate void notifySubInitializersToReusePreviousRowInstance(EntityInitializerData data) {\n\t\tfinal RowProcessingState rowProcessingState = data.getRowProcessingState();\n\t\tfor ( Initializer<?> initializer : subInitializers[data.concreteDescriptor.getSubclassId()] ) {\n\t\t\tif ( initializer != null ) {\n\t\t\t\tinitializer.resolveFromPreviousRow( rowProcessingState );\n\t\t\t}\n\t\t}\n\t}\n\n\tprotected void resolveKeySubInitializers(EntityInitializerData data) {\n\t\tfinal RowProcessingState rowProcessingState = data.getRowProcessingState();\n\t\tfor ( Initializer<?> initializer : subInitializers[data.concreteDescriptor.getSubclassId()] ) {\n\t\t\tif ( initializer != null ) {\n\t\t\t\tinitializer.resolveKey( rowProcessingState );\n\t\t\t}\n\t\t}\n\t}\n\n\t@EnsuresNonNull( \"entityKey\" )\n\tprotected void resolveEntityKey(EntityInitializerData data, Object id) {\n\t\tif ( data.concreteDescriptor == null ) {\n\t\t\tdata.concreteDescriptor = determineConcreteEntityDescriptor(\n\t\t\t\t\tdata.getRowProcessingState(),\n\t\t\t\t\tdiscriminatorAssembler,\n\t\t\t\t\tentityDescriptor\n\t\t\t);\n\t\t\tassert data.concreteDescriptor != null;\n\t\t}\n\t\tdata.entityKey = new EntityKey( id, data.concreteDescriptor );\n\t}\n\n\tprotected void setMissing(EntityInitializerData data) {\n\t\tdata.entityKey = null;\n\t\tdata.concreteDescriptor = null;\n\t\tdata.setInstance( null );\n\t\tdata.entityInstanceForNotify = null;\n\t\tdata.entityHolder = null;\n\t\tdata.setState( State.MISSING );\n\n\t\t// super processes the foreign-key target column.  here we\n\t\t// need to also look at the foreign-key value column to check\n\t\t// for a dangling foreign-key\n\n\t\tif ( keyAssembler != null ) {\n\t\t\tfinal Object fkKeyValue = keyAssembler.assemble( data.getRowProcessingState() );\n\t\t\tif ( fkKeyValue != null ) {\n\t\t\t\tif ( notFoundAction != NotFoundAction.IGNORE ) {\n\t\t\t\t\tif ( affectedByFilter ) {\n\t\t\t\t\t\tthrow new EntityFilterException(\n\t\t\t\t\t\t\t\tgetEntityDescriptor().getEntityName(),\n\t\t\t\t\t\t\t\tfkKeyValue,\n\t\t\t\t\t\t\t\treferencedModelPart.getNavigableRole().getFullPath()\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\tthrow new FetchNotFoundException(\n\t\t\t\t\t\t\tgetEntityDescriptor().getEntityName(),\n\t\t\t\t\t\t\tfkKeyValue\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic void resolveFromPreviousRow(EntityInitializerData data) {\n\t\tif ( data.getState() == State.UNINITIALIZED ) {\n\t\t\tfinal EntityKey entityKey = data.entityKey;\n\t\t\tif ( entityKey == null ) {\n\t\t\t\tsetMissing( data );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdata.setState( State.RESOLVED );\n\t\t\t\tnotifySubInitializersToReusePreviousRowInstance( data );\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic void initializeInstanceFromParent(Object parentInstance, EntityInitializerData data) {\n\t\tfinal AttributeMapping attributeMapping = getInitializedPart().asAttributeMapping();\n\t\tfinal Object instance = attributeMapping != null\n\t\t\t\t? attributeMapping.getValue( parentInstance )\n\t\t\t\t: parentInstance;\n\t\tfinal SharedSessionContractImplementor session = data.getRowProcessingState().getSession();\n\t\tif ( instance == null ) {\n\t\t\tsetMissing( data );\n\t\t}\n\t\telse {\n\t\t\tdata.setInstance( instance );\n\t\t\tdata.entityInstanceForNotify = Hibernate.unproxy( instance );\n\t\t\tdata.concreteDescriptor = session.getEntityPersister( null, data.entityInstanceForNotify );\n\t\t\tresolveEntityKey(\n\t\t\t\t\tdata,\n\t\t\t\t\tdata.concreteDescriptor.getIdentifier( data.entityInstanceForNotify, session )\n\t\t\t);\n\t\t\tdata.entityHolder = session.getPersistenceContextInternal().getEntityHolder( data.entityKey );\n\t\t\tdata.setState( State.INITIALIZED );\n\t\t\tinitializeSubInstancesFromParent( data );\n\t\t}\n\t}\n\n\tprotected String getSimpleConcreteImplName() {\n\t\treturn \"EntityInitializerImpl\";\n\t}\n\n\t@Override\n\tpublic boolean isResultInitializer() {\n\t\treturn isResultInitializer;\n\t}\n\n\tprivate void deepCopy(EntityPersister containerDescriptor, Object[] source, Object[] target) {\n\t\tfinal MutabilityPlan<Object>[] updatableAttributeMutabilityPlan = updatableAttributeMutabilityPlans[containerDescriptor.getSubclassId()];\n\t\tfor ( int i = 0; i < updatableAttributeMutabilityPlan.length; i++ ) {\n\t\t\tfinal Object sourceValue = source[i];\n\t\t\tif ( updatableAttributeMutabilityPlan[i] != null\n\t\t\t\t\t&& sourceValue != LazyPropertyInitializer.UNFETCHED_PROPERTY\n\t\t\t\t\t&& sourceValue != PropertyAccessStrategyBackRefImpl.UNKNOWN ) {\n\t\t\t\ttarget[i] = updatableAttributeMutabilityPlan[i].deepCopy( source[i] );\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic ModelPart getInitializedPart() {\n\t\treturn referencedModelPart;\n\t}\n\n\t@Override\n\tpublic NavigablePath getNavigablePath() {\n\t\treturn navigablePath;\n\t}\n\n\tprotected DomainResultAssembler<?> getIdentifierAssembler() {\n\t\treturn identifierAssembler;\n\t}\n\n\t@Override\n\tpublic EntityPersister getEntityDescriptor() {\n\t\treturn entityDescriptor;\n\t}\n\n\t@Override\n\tpublic Object getEntityInstance(EntityInitializerData data) {\n\t\treturn data.getInstance();\n\t}\n\n\t@Override\n\tpublic Object getTargetInstance(EntityInitializerData data) {\n\t\treturn data.entityInstanceForNotify;\n\t}\n\n\t@Override\n\tpublic @Nullable InitializerParent<?> getParent() {\n\t\treturn parent;\n\t}\n\n\t@Override\n\tpublic void startLoading(RowProcessingState rowProcessingState) {\n\t\tfinal EntityInitializerData data = createInitializerData( rowProcessingState );\n\t\trowProcessingState.setInitializerData( initializerId, data );\n\t\tif ( rowProcessingState.isQueryCacheHit() && entityDescriptor.useShallowQueryCacheLayout() ) {\n\t\t\tdata.shallowCached = true;\n\t\t}\n\t\tdata.lockMode = rowProcessingState.determineEffectiveLockMode( sourceAlias );\n\t\tif ( isResultInitializer() ) {\n\t\t\tdata.uniqueKeyAttributePath = rowProcessingState.getEntityUniqueKeyAttributePath();\n\t\t\tif ( data.uniqueKeyAttributePath != null ) {\n\t\t\t\tdata.uniqueKeyPropertyTypes = getParentEntityAttributeTypes( data.uniqueKeyAttributePath );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdata.uniqueKeyPropertyTypes = null;\n\t\t\t}\n\t\t\tdata.canUseEmbeddedIdentifierInstanceAsEntity = data.getRowProcessingState().getEntityId() != null\n\t\t\t\t\t// The id can only be the entity instance if this is a non-aggregated id that has no containing class\n\t\t\t\t\t&& entityDescriptor.getIdentifierMapping() instanceof CompositeIdentifierMapping\n\t\t\t\t\t&& !( (CompositeIdentifierMapping) entityDescriptor.getIdentifierMapping() ).hasContainingClass();\n\t\t}\n\t\telse {\n\t\t\tdata.uniqueKeyAttributePath = null;\n\t\t\tdata.uniqueKeyPropertyTypes = null;\n\t\t\tdata.canUseEmbeddedIdentifierInstanceAsEntity = false;\n\t\t}\n\t\tdata.hasCallbackActions = rowProcessingState.hasCallbackActions();\n\t\tforEachSubInitializer( Initializer::startLoading, data );\n\t}\n\n\tprotected Type[] getParentEntityAttributeTypes(String attributeName) {\n\t\tfinal Type[] attributeTypes = new Type[\n\t\t\t\tentityDescriptor.getRootEntityDescriptor()\n\t\t\t\t\t\t.getSubclassEntityNames()\n\t\t\t\t\t\t.size()\n\t\t\t\t];\n\t\tinitializeAttributeType( attributeTypes, entityDescriptor, attributeName );\n\t\tfor ( EntityMappingType subMappingType : entityDescriptor.getSubMappingTypes() ) {\n\t\t\tinitializeAttributeType( attributeTypes, subMappingType.getEntityPersister(), attributeName );\n\t\t}\n\t\treturn attributeTypes;\n\t}\n\n\tprotected void initializeAttributeType(Type[] attributeTypes, EntityPersister entityDescriptor, String attributeName) {\n\t\tif ( entityDescriptor.findByPath( attributeName ) != null ) {\n\t\t\tattributeTypes[entityDescriptor.getSubclassId()] = entityDescriptor.getPropertyType( attributeName );\n\t\t}\n\t}\n\n\tpublic static @Nullable EntityPersister determineConcreteEntityDescriptor(\n\t\t\tRowProcessingState rowProcessingState,\n\t\t\tBasicResultAssembler<?> discriminatorAssembler,\n\t\t\tEntityPersister entityDescriptor)\n\t\t\tthrows WrongClassException {\n\t\tif ( discriminatorAssembler == null\n\t\t\t\t|| rowProcessingState.isQueryCacheHit() && entityDescriptor.useShallowQueryCacheLayout() && !entityDescriptor.storeDiscriminatorInShallowQueryCacheLayout() ) {\n\t\t\treturn entityDescriptor;\n\t\t}\n\t\telse {\n\t\t\tassert entityDescriptor.hasSubclasses() : \"Reading a discriminator from a result set should only happen if the entity has subclasses\";\n\t\t\tfinal EntityDiscriminatorMapping discriminatorMapping = entityDescriptor.getDiscriminatorMapping();\n\t\t\tassert discriminatorMapping != null;\n\t\t\tfinal Object discriminator = discriminatorAssembler.extractRawValue( rowProcessingState );\n\t\t\tfinal DiscriminatorValueDetails discriminatorDetails =\n\t\t\t\t\tdiscriminatorMapping.resolveDiscriminatorValue( discriminator );\n\t\t\tif ( discriminatorDetails == null ) {\n\t\t\t\tassert discriminator == null : \"Discriminator details should only be null for null values\";\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfinal EntityMappingType indicatedEntity = discriminatorDetails.getIndicatedEntity();\n\t\t\t\tif ( indicatedEntity.isTypeOrSuperType( entityDescriptor ) ) {\n\t\t\t\t\treturn indicatedEntity.getEntityPersister();\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow new WrongClassException(\n\t\t\t\t\t\t\tindicatedEntity.getEntityName(),\n\t\t\t\t\t\t\tnull,\n\t\t\t\t\t\t\tentityDescriptor.getEntityName(),\n\t\t\t\t\t\t\tdiscriminator\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprotected boolean useEmbeddedIdentifierInstanceAsEntity(EntityInitializerData data) {\n\t\treturn data.canUseEmbeddedIdentifierInstanceAsEntity\n\t\t\t\t&& ( data.concreteDescriptor = determineConcreteEntityDescriptor( data.getRowProcessingState(), discriminatorAssembler, entityDescriptor ) ) != null\n\t\t\t\t&& data.concreteDescriptor.isInstance( data.getRowProcessingState().getEntityId() );\n\t}\n\n\t@Override\n\tpublic void resolveInstance(Object instance, EntityInitializerData data) {\n\t\tif ( instance == null ) {\n\t\t\tsetMissing( data );\n\t\t\treturn;\n\t\t}\n\t\tdata.setInstance( instance );\n\t\tfinal LazyInitializer lazyInitializer = extractLazyInitializer( data.getInstance() );\n\t\tfinal RowProcessingState rowProcessingState = data.getRowProcessingState();\n\t\tfinal SharedSessionContractImplementor session = rowProcessingState.getSession();\n\t\tif ( lazyInitializer == null ) {\n\t\t\t// Entity is most probably initialized\n\t\t\tdata.entityInstanceForNotify = data.getInstance();\n\t\t\tdata.concreteDescriptor = session.getEntityPersister( null, data.getInstance() );\n\t\t\tresolveEntityKey(\n\t\t\t\t\tdata,\n\t\t\t\t\tdata.concreteDescriptor.getIdentifier( data.getInstance(), session )\n\t\t\t);\n\t\t\tdata.entityHolder = session.getPersistenceContextInternal().getEntityHolder( data.entityKey );\n\t\t\tif ( data.entityHolder == null ) {\n\t\t\t\t// Entity was most probably removed in the same session without setting the reference to null\n\t\t\t\tresolveKey( data );\n\t\t\t\tassert data.getState() == State.MISSING;\n\t\t\t\tassert referencedModelPart instanceof ToOneAttributeMapping\n\t\t\t\t\t\t&& ( (ToOneAttributeMapping) referencedModelPart ).getSideNature() == TARGET;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// If the entity initializer is null, we know the entity is fully initialized,\n\t\t\t// otherwise it will be initialized by some other initializer\n\t\t\tdata.setState( data.entityHolder.getEntityInitializer() == null ? State.INITIALIZED : State.RESOLVED );\n\t\t}\n\t\telse if ( lazyInitializer.isUninitialized() ) {\n\t\t\tdata.setState( State.RESOLVED );\n\t\t\t// Read the discriminator from the result set if necessary\n\t\t\tdata.concreteDescriptor = discriminatorAssembler == null\n\t\t\t\t\t? entityDescriptor\n\t\t\t\t\t: determineConcreteEntityDescriptor( rowProcessingState, discriminatorAssembler, entityDescriptor );\n\t\t\tassert data.concreteDescriptor != null;\n\t\t\tresolveEntityKey( data, lazyInitializer.getIdentifier() );\n\t\t\tdata.entityHolder = session.getPersistenceContextInternal().claimEntityHolderIfPossible(\n\t\t\t\t\tdata.entityKey,\n\t\t\t\t\tnull,\n\t\t\t\t\trowProcessingState.getJdbcValuesSourceProcessingState(),\n\t\t\t\t\tthis\n\t\t\t);\n\t\t\t// Resolve and potentially create the entity instance\n\t\t\tdata.entityInstanceForNotify = resolveEntityInstance( data );\n\t\t\tlazyInitializer.setImplementation( data.entityInstanceForNotify );\n\t\t\tregisterLoadingEntity( data, data.entityInstanceForNotify );\n\t\t}\n\t\telse {\n\t\t\tdata.setState( State.INITIALIZED );\n\t\t\tdata.entityInstanceForNotify = lazyInitializer.getImplementation();\n\t\t\tdata.concreteDescriptor = session.getEntityPersister( null, data.entityInstanceForNotify );\n\t\t\tresolveEntityKey( data, lazyInitializer.getIdentifier() );\n\t\t\tdata.entityHolder = session.getPersistenceContextInternal().getEntityHolder( data.entityKey );\n\t\t}\n\t\tif ( identifierAssembler != null ) {\n\t\t\tfinal Initializer<?> initializer = identifierAssembler.getInitializer();\n\t\t\tif ( initializer != null ) {\n\t\t\t\tinitializer.resolveInstance( data.entityKey.getIdentifier(), rowProcessingState );\n\t\t\t}\n\t\t}\n\t\tupgradeLockMode( data );\n\t\tif ( data.getState() == State.INITIALIZED ) {\n\t\t\tregisterReloadedEntity( data );\n\t\t\tresolveInstanceSubInitializers( data );\n\t\t\tif ( rowProcessingState.needsResolveState() ) {\n\t\t\t\t// We need to read result set values to correctly populate the query cache\n\t\t\t\tresolveState( data );\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tresolveKeySubInitializers( data );\n\t\t}\n\t}\n\n\t@Override\n\tpublic void resolveInstance(EntityInitializerData data) {\n\t\tif ( data.getState() != State.KEY_RESOLVED ) {\n\t\t\treturn;\n\t\t}\n\t\tfinal RowProcessingState rowProcessingState = data.getRowProcessingState();\n\t\tdata.setState( State.RESOLVED );\n\t\tif ( data.entityKey == null ) {\n\t\t\tassert identifierAssembler != null;\n\t\t\tfinal Object id = identifierAssembler.assemble( rowProcessingState );\n\t\t\tif ( id == null ) {\n\t\t\t\tsetMissing( data );\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresolveEntityKey( data, id );\n\t\t}\n\t\tfinal PersistenceContext persistenceContext = rowProcessingState.getSession()\n\t\t\t\t.getPersistenceContextInternal();\n\t\tdata.entityHolder = persistenceContext.claimEntityHolderIfPossible(\n\t\t\t\tdata.entityKey,\n\t\t\t\tnull,\n\t\t\t\trowProcessingState.getJdbcValuesSourceProcessingState(),\n\t\t\t\tthis\n\t\t);\n\n\t\tif ( useEmbeddedIdentifierInstanceAsEntity( data ) ) {\n\t\t\tdata.setInstance( data.entityInstanceForNotify = rowProcessingState.getEntityId() );\n\t\t}\n\t\telse {\n\t\t\tresolveEntityInstance1( data );\n\t\t\tif ( data.uniqueKeyAttributePath != null ) {\n\t\t\t\tfinal SharedSessionContractImplementor session = rowProcessingState.getSession();\n\t\t\t\tfinal EntityPersister concreteDescriptor = getConcreteDescriptor( data );\n\t\t\t\tfinal EntityUniqueKey euk = new EntityUniqueKey(\n\t\t\t\t\t\tconcreteDescriptor.getEntityName(),\n\t\t\t\t\t\tdata.uniqueKeyAttributePath,\n\t\t\t\t\t\trowProcessingState.getEntityUniqueKey(),\n\t\t\t\t\t\tdata.uniqueKeyPropertyTypes[concreteDescriptor.getSubclassId()],\n\t\t\t\t\t\tsession.getFactory()\n\t\t\t\t);\n\t\t\t\tsession.getPersistenceContextInternal().addEntity( euk, getEntityInstance( data ) );\n\t\t\t}\n\t\t}\n\n\t\tif ( data.getInstance() != null ) {\n\t\t\tupgradeLockMode( data );\n\t\t\tif ( data.getState() == State.INITIALIZED ) {\n\t\t\t\tregisterReloadedEntity( data );\n\t\t\t\tif ( rowProcessingState.needsResolveState() ) {\n\t\t\t\t\t// We need to read result set values to correctly populate the query cache\n\t\t\t\t\tresolveState( data );\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( data.shallowCached ) {\n\t\t\t\tinitializeSubInstancesFromParent( data );\n\t\t\t}\n\t\t}\n\t}\n\n\tprotected void resolveEntityInstance1(EntityInitializerData data) {\n\t\tfinal Object proxy = data.entityHolder.getProxy();\n\t\tfinal boolean unwrapProxy = proxy != null && referencedModelPart instanceof ToOneAttributeMapping\n\t\t\t\t&& ( (ToOneAttributeMapping) referencedModelPart ).isUnwrapProxy()\n\t\t\t\t&& getConcreteDescriptor( data ).getBytecodeEnhancementMetadata().isEnhancedForLazyLoading();\n\t\tfinal Object entityFromExecutionContext;\n\t\tif ( !unwrapProxy && isProxyInstance( proxy ) ) {\n\t\t\tif ( ( entityFromExecutionContext = getEntityFromExecutionContext( data ) ) != null ) {\n\t\t\t\tdata.setInstance( data.entityInstanceForNotify = entityFromExecutionContext );\n\t\t\t\t// If the entity comes from the execution context, it is treated as not initialized\n\t\t\t\t// so that we can refresh the data as requested\n\t\t\t\tregisterReloadedEntity( data );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdata.setInstance( proxy );\n\t\t\t\tif ( Hibernate.isInitialized( data.getInstance() ) ) {\n\t\t\t\t\tdata.setState( State.INITIALIZED );\n\t\t\t\t\tdata.entityInstanceForNotify = Hibernate.unproxy( data.getInstance() );\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tfinal LazyInitializer lazyInitializer = extractLazyInitializer( data.getInstance() );\n\t\t\t\t\tassert lazyInitializer != null;\n\t\t\t\t\tdata.entityInstanceForNotify = resolveEntityInstance2( data );\n\t\t\t\t\tlazyInitializer.setImplementation( data.entityInstanceForNotify );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tfinal Object existingEntity = data.entityHolder.getEntity();\n\t\t\tif ( existingEntity != null ) {\n\t\t\t\tdata.setInstance( data.entityInstanceForNotify = existingEntity );\n\t\t\t\tif ( data.entityHolder.getEntityInitializer() == null ) {\n\t\t\t\t\tassert data.entityHolder.isInitialized() == isExistingEntityInitialized( existingEntity );\n\t\t\t\t\tif ( data.entityHolder.isInitialized() ) {\n\t\t\t\t\t\tdata.setState( State.INITIALIZED );\n\t\t\t\t\t}\n\t\t\t\t\telse if ( isResultInitializer() ) {\n\t\t\t\t\t\tregisterLoadingEntity( data, data.getInstance() );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if ( data.entityHolder.getEntityInitializer() != this ) {\n\t\t\t\t\tdata.setState( State.INITIALIZED );\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if ( ( entityFromExecutionContext = getEntityFromExecutionContext( data ) ) != null ) {\n\t\t\t\t// This is the entity to refresh, so don't set the state to initialized\n\t\t\t\tdata.setInstance( data.entityInstanceForNotify = entityFromExecutionContext );\n\t\t\t\tif ( isResultInitializer() ) {\n\t\t\t\t\tregisterLoadingEntity( data, data.getInstance() );\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tassert data.entityHolder.getEntityInitializer() == this;\n\t\t\t\t// look to see if another initializer from a parent load context or an earlier\n\t\t\t\t// initializer is already loading the entity\n\t\t\t\tdata.setInstance( data.entityInstanceForNotify = resolveEntityInstance2( data ) );\n\t\t\t\tfinal Initializer<?> idInitializer;\n\t\t\t\tif ( data.entityHolder.getEntityInitializer() == this && data.getState() != State.INITIALIZED\n\t\t\t\t\t\t&& identifierAssembler != null\n\t\t\t\t\t\t&& ( idInitializer = identifierAssembler.getInitializer() ) != null ) {\n\t\t\t\t\t// If this is the owning initializer and the returned object is not initialized,\n\t\t\t\t\t// this means that the entity instance was just instantiated.\n\t\t\t\t\t// In this case, we want to call \"assemble\" and hence \"initializeInstance\" on the initializer\n\t\t\t\t\t// for possibly non-aggregated identifier mappings, so inject the virtual id representation\n\t\t\t\t\tidInitializer.initializeInstance( data.getRowProcessingState() );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// todo: ensure we initialize the entity\n\t\tassert !data.shallowCached || data.getState() == State.INITIALIZED : \"Forgot to initialize the entity\";\n\t}\n\n\tprotected Object getEntityFromExecutionContext(EntityInitializerData data) {\n\t\tfinal RowProcessingState rowProcessingState = data.getRowProcessingState();\n\t\tfinal ExecutionContext executionContext = rowProcessingState.getJdbcValuesSourceProcessingState()\n\t\t\t\t.getExecutionContext();\n\t\tif ( rootEntityDescriptor == executionContext.getRootEntityDescriptor()\n\t\t\t\t&& data.entityKey.getIdentifier().equals( executionContext.getEntityId() ) ) {\n\t\t\treturn executionContext.getEntityInstance();\n\t\t}\n\t\treturn null;\n\t}\n\n\tprotected void upgradeLockMode(EntityInitializerData data) {\n\t\tfinal RowProcessingState rowProcessingState = data.getRowProcessingState();\n\t\tif ( data.lockMode != LockMode.NONE && rowProcessingState.upgradeLocks() ) {\n\t\t\tfinal EntityEntry entry = data.entityHolder.getEntityEntry();\n\t\t\tassert entry == rowProcessingState.getSession().getPersistenceContextInternal()\n\t\t\t\t\t\t\t.getEntry( data.entityInstanceForNotify );\n\t\t\tif ( entry != null && entry.getLockMode().lessThan( data.lockMode ) ) {\n\t\t\t\t//we only check the version when _upgrading_ lock modes\n\t\t\t\tif ( versionAssembler != null && entry.getLockMode() != LockMode.NONE ) {\n\t\t\t\t\tcheckVersion( data, entry, rowProcessingState );\n\t\t\t\t}\n\t\t\t\t//we need to upgrade the lock mode to the mode requested\n\t\t\t\tentry.setLockMode( data.lockMode );\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate boolean isProxyInstance(Object proxy) {\n\t\treturn proxy != null\n\t\t\t\t&& ( proxy instanceof MapProxy || entityDescriptor.getJavaType().getJavaTypeClass().isInstance( proxy ) );\n\t}\n\n\tprivate boolean isExistingEntityInitialized(Object existingEntity) {\n\t\treturn Hibernate.isInitialized( existingEntity );\n\t}\n\n\t/**\n\t * Check the version of the object in the {@code RowProcessingState} against\n\t * the object version in the session cache, throwing an exception\n\t * if the version numbers are different\n\t */\n\tprivate void checkVersion(\n\t\t\tEntityInitializerData data,\n\t\t\tEntityEntry entry,\n\t\t\tfinal RowProcessingState rowProcessingState) throws HibernateException {\n\t\tfinal Object version = entry.getVersion();\n\t\tif ( version != null ) {\n\t\t\t// null version means the object is in the process of being loaded somewhere else in the ResultSet\n\t\t\tfinal Object currentVersion = versionAssembler.assemble( rowProcessingState );\n\t\t\tif ( !data.concreteDescriptor.getVersionType().isEqual( version, currentVersion ) ) {\n\t\t\t\tfinal StatisticsImplementor statistics = rowProcessingState.getSession().getFactory().getStatistics();\n\t\t\t\tif ( statistics.isStatisticsEnabled() ) {\n\t\t\t\t\tstatistics.optimisticFailure( data.concreteDescriptor.getEntityName() );\n\t\t\t\t}\n\t\t\t\tthrow new StaleObjectStateException( data.concreteDescriptor.getEntityName(), entry.getId() );\n\t\t\t}\n\t\t}\n\n\t}\n\n\t/**\n\t * Used by Hibernate Reactive\n\t */\n\tprotected Object resolveEntityInstance2(EntityInitializerData data) {\n\t\tif ( data.entityHolder.getEntityInitializer() == this ) {\n\t\t\tassert data.entityHolder.getEntity() == null;\n\t\t\treturn resolveEntityInstance( data );\n\t\t}\n\t\telse {\n\t\t\t// the entity is already being loaded elsewhere\n\t\t\treturn data.entityHolder.getEntity();\n\t\t}\n\t}\n\n\tprotected Object resolveEntityInstance(EntityInitializerData data) {\n\t\tfinal RowProcessingState rowProcessingState = data.getRowProcessingState();\n\t\tfinal Object resolved = resolveToOptionalInstance( data );\n\t\tif ( resolved != null ) {\n\t\t\tregisterLoadingEntity( data, resolved );\n\t\t\treturn resolved;\n\t\t}\n\t\telse {\n\t\t\tif ( rowProcessingState.isQueryCacheHit() && entityDescriptor.useShallowQueryCacheLayout() ) {\n\t\t\t\t// We must load the entity this way, because the query cache entry contains only the primary key\n\t\t\t\tdata.setState( State.INITIALIZED );\n\t\t\t\tfinal SharedSessionContractImplementor session = rowProcessingState.getSession();\n\t\t\t\tassert data.entityHolder.getEntityInitializer() == this;\n\t\t\t\t// If this initializer owns the entity, we have to remove the entity holder,\n\t\t\t\t// because the subsequent loading process will claim the entity\n\t\t\t\trowProcessingState.getJdbcValuesSourceProcessingState().getLoadingEntityHolders().remove( data.entityHolder );\n\t\t\t\tsession.getPersistenceContextInternal().removeEntityHolder( data.entityKey );\n\t\t\t\treturn session.internalLoad(\n\t\t\t\t\t\tdata.concreteDescriptor.getEntityName(),\n\t\t\t\t\t\tdata.entityKey.getIdentifier(),\n\t\t\t\t\t\ttrue,\n\t\t\t\t\t\tfalse\n\t\t\t\t);\n\t\t\t}\n\t\t\t// We have to query the second level cache if reference cache entries are used\n\t\t\telse if ( entityDescriptor.canUseReferenceCacheEntries() ) {\n\t\t\t\tfinal Object cached = resolveInstanceFromCache( data );\n\t\t\t\tif ( cached != null ) {\n\t\t\t\t\t// EARLY EXIT!!!\n\t\t\t\t\t// because the second level cache has reference cache entries, the entity is initialized\n\t\t\t\t\tdata.setState( State.INITIALIZED );\n\t\t\t\t\treturn cached;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfinal Object instance = instantiateEntity( data );\n\t\t\tregisterLoadingEntity( data, instance );\n\t\t\treturn instance;\n\t\t}\n\t}\n\n\tprotected Object instantiateEntity(EntityInitializerData data) {\n\t\tfinal Object instance = data.getRowProcessingState().getSession()\n\t\t\t\t.instantiate( data.concreteDescriptor, data.entityKey.getIdentifier() );\n\t\treturn instance;\n\t}\n\n\tprivate Object resolveToOptionalInstance(EntityInitializerData data) {\n\t\tif ( isResultInitializer() ) {\n\t\t\t// this isEntityReturn bit is just for entity loaders, not hql/criteria\n\t\t\tfinal JdbcValuesSourceProcessingOptions processingOptions =\n\t\t\t\t\tdata.getRowProcessingState().getJdbcValuesSourceProcessingState().getProcessingOptions();\n\t\t\treturn matchesOptionalInstance( data, processingOptions ) ? processingOptions.getEffectiveOptionalObject() : null;\n\t\t}\n\t\telse {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tprivate boolean matchesOptionalInstance(\n\t\t\tEntityInitializerData data,\n\t\t\tJdbcValuesSourceProcessingOptions processingOptions) {\n\t\tfinal Object optionalEntityInstance = processingOptions.getEffectiveOptionalObject();\n\t\tfinal Object requestedEntityId = processingOptions.getEffectiveOptionalId();\n\t\treturn requestedEntityId != null\n\t\t\t\t&& optionalEntityInstance != null\n\t\t\t\t&& requestedEntityId.equals( data.entityKey.getIdentifier() );\n\t}\n\n\tprivate Object resolveInstanceFromCache(EntityInitializerData data) {\n\t\treturn CacheEntityLoaderHelper.INSTANCE.loadFromSecondLevelCache(\n\t\t\t\tdata.getRowProcessingState().getSession().asEventSource(),\n\t\t\t\tnull,\n\t\t\t\tdata.lockMode,\n\t\t\t\tentityDescriptor,\n\t\t\t\tdata.entityKey\n\t\t);\n\t}\n\n\tprotected void registerLoadingEntity(EntityInitializerData data, Object instance) {\n\t\tdata.getRowProcessingState().getSession().getPersistenceContextInternal().claimEntityHolderIfPossible(\n\t\t\t\tdata.entityKey,\n\t\t\t\tinstance,\n\t\t\t\tdata.getRowProcessingState().getJdbcValuesSourceProcessingState(),\n\t\t\t\tthis\n\t\t);\n\t}\n\n\tprotected void registerReloadedEntity(EntityInitializerData data) {\n\t\tif ( data.hasCallbackActions ) {\n\t\t\t// This is only needed for follow-on locking, so skip registering the entity if there is no callback\n\t\t\tdata.entityHolder.markAsReloaded( data.getRowProcessingState().getJdbcValuesSourceProcessingState() );\n\t\t}\n\t}\n\n\t@Override\n\tpublic void initializeInstance(EntityInitializerData data) {\n\t\tif ( data.getState() != State.RESOLVED ) {\n\t\t\treturn;\n\t\t}\n\t\tif ( !skipInitialization( data ) ) {\n\t\t\tassert consistentInstance( data );\n\t\t\tinitializeEntityInstance( data );\n\t\t}\n\t\tdata.setState( State.INITIALIZED );\n\t}\n\n\tprotected boolean consistentInstance(EntityInitializerData data) {\n\t\tfinal PersistenceContext persistenceContextInternal =\n\t\t\t\tdata.getRowProcessingState().getSession().getPersistenceContextInternal();\n\t\t// Only call PersistenceContext#getEntity within the assert expression, as it is costly\n\t\tfinal Object entity = persistenceContextInternal.getEntity( data.entityKey );\n\t\treturn entity == null || entity == data.entityInstanceForNotify;\n\t}\n\n\tprotected void initializeEntityInstance(EntityInitializerData data) {\n\t\tfinal RowProcessingState rowProcessingState = data.getRowProcessingState();\n\t\tfinal Object entityIdentifier = data.entityKey.getIdentifier();\n\t\tfinal SharedSessionContractImplementor session = rowProcessingState.getSession();\n\t\tfinal PersistenceContext persistenceContext = session.getPersistenceContextInternal();\n\n\t\tfinal Object[] resolvedEntityState = extractConcreteTypeStateValues( data );\n\n\t\tpreLoad( data, resolvedEntityState );\n\n\t\tif ( isPersistentAttributeInterceptable( data.entityInstanceForNotify ) ) {\n\t\t\tfinal PersistentAttributeInterceptor persistentAttributeInterceptor =\n\t\t\t\t\tasPersistentAttributeInterceptable( data.entityInstanceForNotify ).$$_hibernate_getInterceptor();\n\t\t\tif ( persistentAttributeInterceptor == null\n\t\t\t\t\t|| persistentAttributeInterceptor instanceof EnhancementAsProxyLazinessInterceptor ) {\n\t\t\t\t// if we do this after the entity has been initialized the\n\t\t\t\t// BytecodeLazyAttributeInterceptor#isAttributeLoaded(String fieldName) would return false;\n\t\t\t\tdata.concreteDescriptor.getBytecodeEnhancementMetadata()\n\t\t\t\t\t\t.injectInterceptor( data.entityInstanceForNotify, entityIdentifier, session );\n\t\t\t}\n\t\t}\n\t\tdata.concreteDescriptor.setPropertyValues( data.entityInstanceForNotify, resolvedEntityState );\n\n\t\tpersistenceContext.addEntity( data.entityKey, data.entityInstanceForNotify );\n\n\t\t// Also register possible unique key entries\n\t\tregisterPossibleUniqueKeyEntries( data, resolvedEntityState, session );\n\n\t\tfinal Object version = versionAssembler != null ? versionAssembler.assemble( rowProcessingState ) : null;\n\t\tfinal Object rowId = rowIdAssembler != null ? rowIdAssembler.assemble( rowProcessingState ) : null;\n\n\t\t// from the perspective of Hibernate, an entity is read locked as soon as it is read\n\t\t// so regardless of the requested lock mode, we upgrade to at least the read level\n\t\tfinal LockMode lockModeToAcquire = data.lockMode == LockMode.NONE ? LockMode.READ : data.lockMode;\n\n\t\tfinal EntityEntry entityEntry = persistenceContext.addEntry(\n\t\t\t\tdata.entityInstanceForNotify,\n\t\t\t\tStatus.LOADING,\n\t\t\t\tresolvedEntityState,\n\t\t\t\trowId,\n\t\t\t\tdata.entityKey.getIdentifier(),\n\t\t\t\tversion,\n\t\t\t\tlockModeToAcquire,\n\t\t\t\ttrue,\n\t\t\t\tdata.concreteDescriptor,\n\t\t\t\tfalse\n\t\t);\n\t\tdata.entityHolder.setEntityEntry( entityEntry );\n\n\t\tregisterNaturalIdResolution( data, persistenceContext, resolvedEntityState );\n\n\t\ttakeSnapshot( data, session, persistenceContext, entityEntry, resolvedEntityState );\n\n\t\tdata.concreteDescriptor.afterInitialize( data.entityInstanceForNotify, session );\n\n\t\tassert data.concreteDescriptor.getIdentifier( data.entityInstanceForNotify, session ) != null;\n\n\t\tfinal StatisticsImplementor statistics = session.getFactory().getStatistics();\n\t\tif ( statistics.isStatisticsEnabled() ) {\n\t\t\tif ( !rowProcessingState.isQueryCacheHit() ) {\n\t\t\t\tstatistics.loadEntity( data.concreteDescriptor.getEntityName() );\n\t\t\t}\n\t\t}\n\t\tupdateCaches(\n\t\t\t\tdata,\n\t\t\t\tsession,\n\t\t\t\tsession.getPersistenceContextInternal(),\n\t\t\t\tresolvedEntityState,\n\t\t\t\tversion\n\t\t);\n\t}\n\n\tprotected void updateCaches(\n\t\t\tEntityInitializerData data,\n\t\t\tSharedSessionContractImplementor session,\n\t\t\tPersistenceContext persistenceContext,\n\t\t\tObject[] resolvedEntityState,\n\t\t\tObject version) {\n\t\tif ( data.concreteDescriptor.canWriteToCache()\n\t\t\t\t// No need to put into the entity cache if this is coming from the query cache already\n\t\t\t\t&& !data.getRowProcessingState().isQueryCacheHit()\n\t\t\t\t&& session.getCacheMode().isPutEnabled() ) {\n\t\t\tfinal EntityDataAccess cacheAccess = data.concreteDescriptor.getCacheAccessStrategy();\n\t\t\tif ( cacheAccess != null  ) {\n\t\t\t\tputInCache( data, session, persistenceContext, resolvedEntityState, version, cacheAccess );\n\t\t\t}\n\t\t}\n\t}\n\n\tprotected void registerNaturalIdResolution(\n\t\t\tEntityInitializerData data,\n\t\t\tPersistenceContext persistenceContext,\n\t\t\tObject[] resolvedEntityState) {\n\t\tif ( entityDescriptor.getNaturalIdMapping() != null ) {\n\t\t\tfinal Object naturalId =\n\t\t\t\t\tentityDescriptor.getNaturalIdMapping().extractNaturalIdFromEntityState( resolvedEntityState );\n\t\t\tpersistenceContext.getNaturalIdResolutions()\n\t\t\t\t\t.cacheResolutionFromLoad( data.entityKey.getIdentifier(), naturalId, entityDescriptor );\n\t\t}\n\t}\n\n\tprotected void takeSnapshot(\n\t\t\tEntityInitializerData data,\n\t\t\tSharedSessionContractImplementor session,\n\t\t\tPersistenceContext persistenceContext,\n\t\t\tEntityEntry entityEntry,\n\t\t\tObject[] resolvedEntityState) {\n\t\tif ( isReallyReadOnly( data, session ) ) {\n\t\t\t//no need to take a snapshot - this is a\n\t\t\t//performance optimization, but not really\n\t\t\t//important, except for entities with huge\n\t\t\t//mutable property values\n\t\t\tpersistenceContext.setEntryStatus( entityEntry, Status.READ_ONLY );\n\t\t}\n\t\telse {\n\t\t\t//take a snapshot\n\t\t\tdeepCopy( data.concreteDescriptor, resolvedEntityState, resolvedEntityState );\n\t\t\tpersistenceContext.setEntryStatus( entityEntry, Status.MANAGED );\n\t\t}\n\t}\n\n\tprivate boolean isReallyReadOnly(EntityInitializerData data, SharedSessionContractImplementor session) {\n\t\tif ( !data.concreteDescriptor.isMutable() ) {\n\t\t\treturn true;\n\t\t}\n\t\telse {\n\t\t\tfinal LazyInitializer lazyInitializer = extractLazyInitializer( data.getInstance() );\n\t\t\tif ( lazyInitializer != null ) {\n\t\t\t\t// there is already a proxy for this impl\n\t\t\t\t// only set the status to read-only if the proxy is read-only\n\t\t\t\treturn lazyInitializer.isReadOnly();\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn isReadOnly( data.getRowProcessingState(), session );\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate void putInCache(\n\t\t\tEntityInitializerData data,\n\t\t\tSharedSessionContractImplementor session,\n\t\t\tPersistenceContext persistenceContext,\n\t\t\tObject[] resolvedEntityState,\n\t\t\tObject version,\n\t\t\tEntityDataAccess cacheAccess) {\n\t\tfinal SessionFactoryImplementor factory = session.getFactory();\n\n\t\tfinal CacheEntry cacheEntry = data.concreteDescriptor.buildCacheEntry(\n\t\t\t\tdata.entityInstanceForNotify,\n\t\t\t\tresolvedEntityState,\n\t\t\t\tversion,\n\t\t\t\tsession\n\t\t);\n\t\tfinal Object cacheKey = cacheAccess.generateCacheKey(\n\t\t\t\tdata.entityKey.getIdentifier(),\n\t\t\t\trootEntityDescriptor,\n\t\t\t\tfactory,\n\t\t\t\tsession.getTenantIdentifier()\n\t\t);\n\n\t\t// explicit handling of caching for rows just inserted and then somehow forced to be read\n\t\t// from the database *within the same transaction*.  usually this is done by\n\t\t// \t\t1) Session#refresh, or\n\t\t// \t\t2) Session#clear + some form of load\n\t\t//\n\t\t// we need to be careful not to clobber the lock here in the cache so that it can be rolled back if need be\n\t\tfinal EventManager eventManager = session.getEventManager();\n\t\tif ( persistenceContext.wasInsertedDuringTransaction( data.concreteDescriptor, data.entityKey.getIdentifier() ) ) {\n\t\t\tboolean update = false;\n\t\t\tfinal HibernateMonitoringEvent cachePutEvent = eventManager.beginCachePutEvent();\n\t\t\ttry {\n\t\t\t\tupdate = cacheAccess.update(\n\t\t\t\t\t\tsession,\n\t\t\t\t\t\tcacheKey,\n\t\t\t\t\t\tdata.concreteDescriptor.getCacheEntryStructure().structure( cacheEntry ),\n\t\t\t\t\t\tversion,\n\t\t\t\t\t\tversion\n\t\t\t\t);\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeCachePutEvent(\n\t\t\t\t\t\tcachePutEvent,\n\t\t\t\t\t\tsession,\n\t\t\t\t\t\tcacheAccess,\n\t\t\t\t\t\tdata.concreteDescriptor,\n\t\t\t\t\t\tupdate,\n\t\t\t\t\t\tEventManager.CacheActionDescription.ENTITY_UPDATE\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tfinal SessionEventListenerManager eventListenerManager = session.getEventListenerManager();\n\t\t\tboolean put = false;\n\t\t\tfinal HibernateMonitoringEvent cachePutEvent = eventManager.beginCachePutEvent();\n\t\t\ttry {\n\t\t\t\teventListenerManager.cachePutStart();\n\t\t\t\tput = cacheAccess.putFromLoad(\n\t\t\t\t\t\tsession,\n\t\t\t\t\t\tcacheKey,\n\t\t\t\t\t\tdata.concreteDescriptor.getCacheEntryStructure().structure( cacheEntry ),\n\t\t\t\t\t\tversion,\n\t\t\t\t\t\t//useMinimalPuts( session, entityEntry )\n\t\t\t\t\t\tfalse\n\t\t\t\t);\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeCachePutEvent(\n\t\t\t\t\t\tcachePutEvent,\n\t\t\t\t\t\tsession,\n\t\t\t\t\t\tcacheAccess,\n\t\t\t\t\t\tdata.concreteDescriptor,\n\t\t\t\t\t\tput,\n\t\t\t\t\t\tEventManager.CacheActionDescription.ENTITY_LOAD\n\t\t\t\t);\n\t\t\t\tfinal StatisticsImplementor statistics = factory.getStatistics();\n\t\t\t\tif ( put && statistics.isStatisticsEnabled() ) {\n\t\t\t\t\tstatistics.entityCachePut( rootEntityDescriptor.getNavigableRole(), cacheAccess.getRegion().getName() );\n\t\t\t\t}\n\t\t\t\teventListenerManager.cachePutEnd();\n\t\t\t}\n\t\t}\n\t}\n\n\tprotected void registerPossibleUniqueKeyEntries(\n\t\t\tEntityInitializerData data,\n\t\t\tObject[] resolvedEntityState,\n\t\t\tfinal SharedSessionContractImplementor session) {\n\t\tfor ( UniqueKeyEntry entry : data.concreteDescriptor.uniqueKeyEntries() ) {\n\t\t\tfinal String ukName = entry.getUniqueKeyName();\n\t\t\tfinal int index = entry.getStateArrayPosition();\n\t\t\tfinal Type type = entry.getPropertyType();\n\n\t\t\t// polymorphism not really handled completely correctly,\n\t\t\t// perhaps...well, actually its ok, assuming that the\n\t\t\t// entity name used in the lookup is the same as the\n\t\t\t// one used here, which it will be\n\n\t\t\tif ( resolvedEntityState[index] != null ) {\n\t\t\t\tfinal EntityUniqueKey entityUniqueKey = new EntityUniqueKey(\n\t\t\t\t\t\tdata.concreteDescriptor.getRootEntityDescriptor().getEntityName(),\n\t\t\t\t\t\t//polymorphism comment above\n\t\t\t\t\t\tukName,\n\t\t\t\t\t\tresolvedEntityState[index],\n\t\t\t\t\t\ttype,\n\t\t\t\t\t\tsession.getFactory()\n\t\t\t\t);\n\t\t\t\tsession.getPersistenceContextInternal().addEntity( entityUniqueKey, data.entityInstanceForNotify );\n\t\t\t}\n\t\t}\n\t}\n\n\tprotected Object[] extractConcreteTypeStateValues(EntityInitializerData data) {\n\t\tfinal RowProcessingState rowProcessingState = data.getRowProcessingState();\n\t\tfinal Object[] values = new Object[data.concreteDescriptor.getNumberOfAttributeMappings()];\n\t\tfinal DomainResultAssembler<?>[] concreteAssemblers = assemblers[data.concreteDescriptor.getSubclassId()];\n\t\tfor ( int i = 0; i < values.length; i++ ) {\n\t\t\tfinal DomainResultAssembler<?> assembler = concreteAssemblers[i];\n\t\t\tvalues[i] = assembler == null ? UNFETCHED_PROPERTY : assembler.assemble( rowProcessingState );\n\t\t}\n\t\treturn values;\n\t}\n\n\tprotected void resolveState(EntityInitializerData data) {\n\t\tfinal RowProcessingState rowProcessingState = data.getRowProcessingState();\n\t\tfor ( final DomainResultAssembler<?> assembler : assemblers[data.concreteDescriptor.getSubclassId()] ) {\n\t\t\tif ( assembler != null ) {\n\t\t\t\tassembler.resolveState( rowProcessingState );\n\t\t\t}\n\t\t}\n\t}\n\n\tprotected boolean skipInitialization(EntityInitializerData data) {\n\t\tif ( data.entityHolder.getEntityInitializer() != this ) {\n\t\t\treturn true;\n\t\t}\n\t\tfinal RowProcessingState rowProcessingState = data.getRowProcessingState();\n\t\tfinal EntityEntry entry = data.entityHolder.getEntityEntry();\n\t\tassert entry == rowProcessingState.getSession().getPersistenceContextInternal().getEntry( data.entityInstanceForNotify );\n\t\tif ( entry == null ) {\n\t\t\treturn false;\n\t\t}\n\t\t// todo (6.0): do we really need this check ?\n\t\telse if ( entry.getStatus().isDeletedOrGone() ) {\n\t\t\treturn true;\n\t\t}\n\t\telse {\n\t\t\tif ( isPersistentAttributeInterceptable( data.entityInstanceForNotify ) ) {\n\t\t\t\tfinal PersistentAttributeInterceptor interceptor =\n\t\t\t\t\t\tasPersistentAttributeInterceptable( data.entityInstanceForNotify ).$$_hibernate_getInterceptor();\n\t\t\t\tif ( interceptor instanceof EnhancementAsProxyLazinessInterceptor ) {\n\t\t\t\t\t// Avoid loading the same entity proxy twice for the same result set: it could lead to errors,\n\t\t\t\t\t// because some code writes to its input (ID in hydrated state replaced by the loaded entity, in particular).\n\t\t\t\t\treturn entry.getStatus() == Status.LOADING;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If the instance to initialize is the main entity, we can't skip this.\n\t\t\t// This can happen if we initialize an enhanced proxy.\n\t\t\tif ( entry.getStatus() != Status.LOADING ) {\n\t\t\t\t// If the instance to initialize is the main entity, we can't skip this.\n\t\t\t\t// This can happen if we initialize an enhanced proxy.\n\t\t\t\treturn rowProcessingState.getJdbcValuesSourceProcessingState().getProcessingOptions()\n\t\t\t\t\t\t.getEffectiveOptionalObject() != data.entityInstanceForNotify;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate boolean isReadOnly(RowProcessingState rowProcessingState, SharedSessionContractImplementor persistenceContext) {\n\t\tfinal Boolean readOnly = rowProcessingState.getQueryOptions().isReadOnly();\n\t\treturn readOnly == null ? persistenceContext.isDefaultReadOnly() : readOnly;\n\t}\n\n\tprotected void preLoad(EntityInitializerData data, Object[] resolvedEntityState) {\n\t\tfinal RowProcessingState rowProcessingState = data.getRowProcessingState();\n\t\tfinal SharedSessionContractImplementor session = rowProcessingState.getSession();\n\t\tif ( session.isEventSource() ) {\n\t\t\tfinal PreLoadEvent preLoadEvent = rowProcessingState.getJdbcValuesSourceProcessingState().getPreLoadEvent();\n\t\t\tassert preLoadEvent != null;\n\n\t\t\tpreLoadEvent.reset();\n\n\t\t\tpreLoadEvent.setEntity( data.getInstance() )\n\t\t\t\t\t.setState( resolvedEntityState )\n\t\t\t\t\t.setId( data.entityKey.getIdentifier() )\n\t\t\t\t\t.setPersister( data.concreteDescriptor );\n\n\t\t\tsession.getFactory()\n\t\t\t\t\t.getFastSessionServices()\n\t\t\t\t\t.eventListenerGroup_PRE_LOAD\n\t\t\t\t\t.fireEventOnEachListener( preLoadEvent, PreLoadEventListener::onPreLoad );\n\t\t}\n\t}\n\n\t@Override\n\tpublic boolean isPartOfKey() {\n\t\treturn isPartOfKey;\n\t}\n\n\tpublic boolean isPreviousRowReuse() {\n\t\treturn previousRowReuse;\n\t}\n\n\t@Override\n\tpublic EntityPersister getConcreteDescriptor(EntityInitializerData data) {\n\t\tassert data.getState() != State.UNINITIALIZED;\n\t\treturn data.concreteDescriptor == null ? entityDescriptor : data.concreteDescriptor;\n\t}\n\n\tprotected void initializeSubInstancesFromParent(EntityInitializerData data) {\n\t\tif ( data.entityInstanceForNotify != null ) {\n\t\t\tfor ( Initializer<?> initializer : subInitializers[data.concreteDescriptor.getSubclassId()] ) {\n\t\t\t\tif (initializer != null) {\n\t\t\t\t\tinitializer.initializeInstanceFromParent( data.entityInstanceForNotify, data.getRowProcessingState() );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tprotected void forEachSubInitializer(BiConsumer<Initializer<?>, RowProcessingState> consumer, InitializerData data) {\n\t\tfinal RowProcessingState rowProcessingState = data.getRowProcessingState();\n\t\tif ( keyAssembler != null ) {\n\t\t\tfinal Initializer<?> initializer = keyAssembler.getInitializer();\n\t\t\tif ( initializer != null ) {\n\t\t\t\tconsumer.accept( initializer, rowProcessingState );\n\t\t\t}\n\t\t}\n\t\tif ( identifierAssembler != null ) {\n\t\t\tfinal Initializer<?> initializer = identifierAssembler.getInitializer();\n\t\t\tif ( initializer != null ) {\n\t\t\t\tconsumer.accept( initializer, rowProcessingState );\n\t\t\t}\n\t\t}\n\t\tfinal EntityInitializerData entityInitializerData = (EntityInitializerData) data;\n\t\tif ( entityInitializerData.concreteDescriptor == null ) {\n\t\t\tfor ( Initializer<?>[] initializers : subInitializers ) {\n\t\t\t\tfor ( Initializer<?> initializer : initializers ) {\n\t\t\t\t\tif ( initializer != null ) {\n\t\t\t\t\t\tconsumer.accept( initializer, rowProcessingState );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tfor ( Initializer<?> initializer : subInitializers[entityInitializerData.concreteDescriptor.getSubclassId()] ) {\n\t\t\t\tif ( initializer != null ) {\n\t\t\t\t\tconsumer.accept( initializer, rowProcessingState );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic void endLoading(EntityInitializerData data) {\n\t\tsuper.endLoading( data );\n\t\tdata.shallowCached = false;\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn \"EntityJoinedFetchInitializer(\" + LoggingHelper.toLoggableString( getNavigablePath() ) + \")\";\n\t}\n\n\t//#########################\n\t// For Hibernate Reactive\n\t//#########################\n\n\tprotected @Nullable DomainResultAssembler<?> getVersionAssembler() {\n\t\treturn versionAssembler;\n\t}\n\n\tprotected @Nullable DomainResultAssembler<Object> getRowIdAssembler() {\n\t\treturn rowIdAssembler;\n\t}\n\n\tprotected @Nullable DomainResultAssembler<?>[][] getAssemblers() {\n\t\treturn assemblers;\n\t}\n\n\tprotected @Nullable BasicResultAssembler<?> getDiscriminatorAssembler() {\n\t\treturn discriminatorAssembler;\n\t}\n\n\tprotected boolean isKeyManyToOne() {\n\t\treturn hasKeyManyToOne;\n\t}\n\n\tprotected Initializer<?>[][] getSubInitializers() {\n\t\treturn subInitializers;\n\t}\n\n\tpublic @Nullable DomainResultAssembler<?> getKeyAssembler() {\n\t\treturn keyAssembler;\n\t}\n}\n",
        "filePathAfter": "hibernate-core/src/main/java/org/hibernate/sql/results/graph/entity/internal/EntityInitializerImpl.java",
        "sourceCodeAfterForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later\n * See the lgpl.txt file in the root directory or http://www.gnu.org/licenses/lgpl-2.1.html\n */\npackage org.hibernate.sql.results.graph.entity.internal;\n\nimport java.util.Arrays;\nimport java.util.BitSet;\nimport java.util.Collection;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.function.BiConsumer;\n\nimport org.hibernate.EntityFilterException;\nimport org.hibernate.FetchNotFoundException;\nimport org.hibernate.Hibernate;\nimport org.hibernate.HibernateException;\nimport org.hibernate.LockMode;\nimport org.hibernate.StaleObjectStateException;\nimport org.hibernate.WrongClassException;\nimport org.hibernate.annotations.NotFoundAction;\nimport org.hibernate.bytecode.enhance.spi.LazyPropertyInitializer;\nimport org.hibernate.bytecode.enhance.spi.interceptor.EnhancementAsProxyLazinessInterceptor;\nimport org.hibernate.cache.spi.access.EntityDataAccess;\nimport org.hibernate.cache.spi.entry.CacheEntry;\nimport org.hibernate.engine.spi.EntityEntry;\nimport org.hibernate.engine.spi.EntityHolder;\nimport org.hibernate.engine.spi.EntityKey;\nimport org.hibernate.engine.spi.EntityUniqueKey;\nimport org.hibernate.engine.spi.PersistenceContext;\nimport org.hibernate.engine.spi.PersistentAttributeInterceptor;\nimport org.hibernate.engine.spi.SessionEventListenerManager;\nimport org.hibernate.engine.spi.SessionFactoryImplementor;\nimport org.hibernate.engine.spi.SharedSessionContractImplementor;\nimport org.hibernate.engine.spi.Status;\nimport org.hibernate.event.spi.EventManager;\nimport org.hibernate.event.spi.HibernateMonitoringEvent;\nimport org.hibernate.event.spi.PreLoadEvent;\nimport org.hibernate.event.spi.PreLoadEventListener;\nimport org.hibernate.internal.log.LoggingHelper;\nimport org.hibernate.internal.util.ImmutableBitSet;\nimport org.hibernate.loader.ast.internal.CacheEntityLoaderHelper;\nimport org.hibernate.metamodel.mapping.AttributeMapping;\nimport org.hibernate.metamodel.mapping.AttributeMetadata;\nimport org.hibernate.metamodel.mapping.CompositeIdentifierMapping;\nimport org.hibernate.metamodel.mapping.DiscriminatorValueDetails;\nimport org.hibernate.metamodel.mapping.EntityDiscriminatorMapping;\nimport org.hibernate.metamodel.mapping.EntityMappingType;\nimport org.hibernate.metamodel.mapping.EntityValuedModelPart;\nimport org.hibernate.metamodel.mapping.EntityVersionMapping;\nimport org.hibernate.metamodel.mapping.ModelPart;\nimport org.hibernate.metamodel.mapping.internal.ToOneAttributeMapping;\nimport org.hibernate.persister.entity.EntityPersister;\nimport org.hibernate.persister.entity.UniqueKeyEntry;\nimport org.hibernate.property.access.internal.PropertyAccessStrategyBackRefImpl;\nimport org.hibernate.proxy.LazyInitializer;\nimport org.hibernate.proxy.map.MapProxy;\nimport org.hibernate.spi.NavigablePath;\nimport org.hibernate.sql.exec.spi.ExecutionContext;\nimport org.hibernate.sql.results.graph.AssemblerCreationState;\nimport org.hibernate.sql.results.graph.DomainResult;\nimport org.hibernate.sql.results.graph.DomainResultAssembler;\nimport org.hibernate.sql.results.graph.Fetch;\nimport org.hibernate.sql.results.graph.Initializer;\nimport org.hibernate.sql.results.graph.InitializerData;\nimport org.hibernate.sql.results.graph.InitializerParent;\nimport org.hibernate.sql.results.graph.basic.BasicResultAssembler;\nimport org.hibernate.sql.results.graph.collection.internal.AbstractImmediateCollectionInitializer;\nimport org.hibernate.sql.results.graph.entity.EntityInitializer;\nimport org.hibernate.sql.results.graph.entity.EntityResultGraphNode;\nimport org.hibernate.sql.results.graph.internal.AbstractInitializer;\nimport org.hibernate.sql.results.internal.NullValueAssembler;\nimport org.hibernate.sql.results.jdbc.spi.JdbcValuesSourceProcessingOptions;\nimport org.hibernate.sql.results.jdbc.spi.RowProcessingState;\nimport org.hibernate.stat.spi.StatisticsImplementor;\nimport org.hibernate.type.Type;\nimport org.hibernate.type.descriptor.java.MutabilityPlan;\n\nimport org.checkerframework.checker.nullness.qual.EnsuresNonNull;\nimport org.checkerframework.checker.nullness.qual.Nullable;\n\nimport static org.hibernate.bytecode.enhance.spi.LazyPropertyInitializer.UNFETCHED_PROPERTY;\nimport static org.hibernate.engine.internal.ManagedTypeHelper.asPersistentAttributeInterceptable;\nimport static org.hibernate.engine.internal.ManagedTypeHelper.isPersistentAttributeInterceptable;\nimport static org.hibernate.internal.log.LoggingHelper.toLoggableString;\nimport static org.hibernate.metamodel.mapping.ForeignKeyDescriptor.Nature.TARGET;\nimport static org.hibernate.proxy.HibernateProxy.extractLazyInitializer;\n\n/**\n * @author Andrea Boriero\n */\npublic class EntityInitializerImpl extends AbstractInitializer<EntityInitializerImpl.EntityInitializerData>\n\t\timplements EntityInitializer<EntityInitializerImpl.EntityInitializerData> {\n\n\t// NOTE : even though we only keep the EntityDescriptor here, rather than EntityResultGraphNode\n\t//\t\tthe \"scope\" of this initializer is a specific EntityReference.\n\t//\n\t//\t\tThe full EntityResultGraphNode is simply not needed here, and so we just keep\n\t//\t\tthe EntityDescriptor here to avoid chicken/egg issues in the creation of\n\t// \t\tthese\n\n\tprivate final EntityValuedModelPart referencedModelPart;\n\tprivate final EntityPersister entityDescriptor;\n\tprivate final EntityPersister rootEntityDescriptor;\n\tprivate final @Nullable Type keyTypeForEqualsHashCode;\n\tprivate final NavigablePath navigablePath;\n\tprivate final String sourceAlias;\n\tprivate final @Nullable InitializerParent<?> parent;\n\tprivate final NotFoundAction notFoundAction;\n\tprivate final boolean affectedByFilter;\n\tprivate final boolean isPartOfKey;\n\tprivate final boolean isResultInitializer;\n\tprivate final boolean hasKeyManyToOne;\n\t/**\n\t * Indicates whether there is a high chance of the previous row to have the same entity key as the current row\n\t * and hence enable a check in the {@link #resolveKey(RowProcessingState)} phase which compare the previously read\n\t * identifier with the current row identifier. If it matches, the state from the previous row processing can be reused.\n\t * In addition to that, all direct sub-initializers can be informed about the reuse by calling {@link Initializer#resolveFromPreviousRow(RowProcessingState)},\n\t * so that these initializers can avoid unnecessary processing as well.\n\t */\n\tprivate final boolean previousRowReuse;\n\tprivate final boolean couldUseEmbeddedIdentifierInstanceAsEntity;\n\n\tprivate final @Nullable DomainResultAssembler<?> keyAssembler;\n\tprivate final @Nullable DomainResultAssembler<?> identifierAssembler;\n\tprivate final @Nullable BasicResultAssembler<?> discriminatorAssembler;\n\tprivate final @Nullable DomainResultAssembler<?> versionAssembler;\n\tprivate final @Nullable DomainResultAssembler<Object> rowIdAssembler;\n\n\tprivate final DomainResultAssembler<?>[][] assemblers;\n\tprivate final Initializer<?>[][] subInitializers;\n\tprivate final Initializer<?>[][] subInitializersForResolveFromInitialized;\n\tprivate final MutabilityPlan<Object>[][] updatableAttributeMutabilityPlans;\n\tprivate final ImmutableBitSet[] lazySubInitializers;\n\tprivate final ImmutableBitSet[] maybeLazySets;\n\tprivate final boolean hasEagerSubInitializers;\n\n\tpublic static class EntityInitializerData extends InitializerData {\n\n\t\tprotected final boolean shallowCached;\n\t\tprotected final LockMode lockMode;\n\t\tprotected final String uniqueKeyAttributePath;\n\t\tprotected final Type[] uniqueKeyPropertyTypes;\n\t\tprotected final boolean canUseEmbeddedIdentifierInstanceAsEntity;\n\t\tprotected final boolean hasCallbackActions;\n\t\tprotected final @Nullable EntityPersister defaultConcreteDescriptor;\n\n\t\t// per-row state\n\t\tprotected @Nullable EntityPersister concreteDescriptor;\n\t\tprotected @Nullable EntityKey entityKey;\n\t\tprotected @Nullable Object entityInstanceForNotify;\n\t\tprotected @Nullable EntityHolder entityHolder;\n\n\t\tpublic EntityInitializerData(EntityInitializerImpl initializer, RowProcessingState rowProcessingState) {\n\t\t\tsuper( rowProcessingState );\n\t\t\tfinal EntityPersister entityDescriptor = initializer.entityDescriptor;\n\t\t\tshallowCached = rowProcessingState.isQueryCacheHit() && entityDescriptor.useShallowQueryCacheLayout();\n\t\t\tlockMode = rowProcessingState.determineEffectiveLockMode( initializer.sourceAlias );\n\t\t\tif ( initializer.isResultInitializer() ) {\n\t\t\t\tuniqueKeyAttributePath = rowProcessingState.getEntityUniqueKeyAttributePath();\n\t\t\t\tif ( uniqueKeyAttributePath != null ) {\n\t\t\t\t\tuniqueKeyPropertyTypes = initializer.getParentEntityAttributeTypes( uniqueKeyAttributePath );\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tuniqueKeyPropertyTypes = null;\n\t\t\t\t}\n\t\t\t\tcanUseEmbeddedIdentifierInstanceAsEntity = rowProcessingState.getEntityId() != null\n\t\t\t\t\t\t&& initializer.couldUseEmbeddedIdentifierInstanceAsEntity;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tuniqueKeyAttributePath = null;\n\t\t\t\tuniqueKeyPropertyTypes = null;\n\t\t\t\tcanUseEmbeddedIdentifierInstanceAsEntity = false;\n\t\t\t}\n\t\t\thasCallbackActions = rowProcessingState.hasCallbackActions();\n\t\t\tif ( initializer.discriminatorAssembler == null\n\t\t\t\t\t|| rowProcessingState.isQueryCacheHit() && entityDescriptor.useShallowQueryCacheLayout() && !entityDescriptor.storeDiscriminatorInShallowQueryCacheLayout() ) {\n\t\t\t\tdefaultConcreteDescriptor = entityDescriptor;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdefaultConcreteDescriptor = null;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Used by Hibernate Reactive\n\t\t */\n\t\tpublic EntityInitializerData(EntityInitializerData original) {\n\t\t\tsuper( original );\n\t\t\tthis.shallowCached = original.shallowCached;\n\t\t\tthis.lockMode = original.lockMode;\n\t\t\tthis.uniqueKeyAttributePath = original.uniqueKeyAttributePath;\n\t\t\tthis.uniqueKeyPropertyTypes = original.uniqueKeyPropertyTypes;\n\t\t\tthis.canUseEmbeddedIdentifierInstanceAsEntity = original.canUseEmbeddedIdentifierInstanceAsEntity;\n\t\t\tthis.hasCallbackActions = original.hasCallbackActions;\n\t\t\tthis.defaultConcreteDescriptor = original.defaultConcreteDescriptor;\n\t\t\tthis.concreteDescriptor = original.concreteDescriptor;\n\t\t\tthis.entityKey = original.entityKey;\n\t\t\tthis.entityInstanceForNotify = original.entityInstanceForNotify;\n\t\t\tthis.entityHolder = original.entityHolder;\n\t\t}\n\t}\n\n\tpublic EntityInitializerImpl(\n\t\t\tEntityResultGraphNode resultDescriptor,\n\t\t\tString sourceAlias,\n\t\t\t@Nullable Fetch identifierFetch,\n\t\t\t@Nullable Fetch discriminatorFetch,\n\t\t\t@Nullable DomainResult<?> keyResult,\n\t\t\t@Nullable DomainResult<Object> rowIdResult,\n\t\t\tNotFoundAction notFoundAction,\n\t\t\tboolean affectedByFilter,\n\t\t\t@Nullable InitializerParent<?> parent,\n\t\t\tboolean isResultInitializer,\n\t\t\tAssemblerCreationState creationState) {\n\t\tsuper( creationState );\n\n\t\treferencedModelPart = resultDescriptor.getEntityValuedModelPart();\n\t\tentityDescriptor = (EntityPersister) referencedModelPart.getEntityMappingType();\n\n\t\tfinal String rootEntityName = entityDescriptor.getRootEntityName();\n\t\trootEntityDescriptor = rootEntityName == null || rootEntityName.equals( entityDescriptor.getEntityName() )\n\t\t\t\t? entityDescriptor\n\t\t\t\t: entityDescriptor.getRootEntityDescriptor().getEntityPersister();\n\t\tkeyTypeForEqualsHashCode = entityDescriptor.getIdentifierType().getTypeForEqualsHashCode();\n\t\t// The id can only be the entity instance if this is a non-aggregated id that has no containing class\n\t\tcouldUseEmbeddedIdentifierInstanceAsEntity = entityDescriptor.getIdentifierMapping() instanceof CompositeIdentifierMapping\n\t\t\t\t&& !( (CompositeIdentifierMapping) entityDescriptor.getIdentifierMapping() ).hasContainingClass();\n\n\t\tthis.navigablePath = resultDescriptor.getNavigablePath();\n\t\tthis.sourceAlias = sourceAlias;\n\t\tthis.parent = parent;\n\t\tthis.isResultInitializer = isResultInitializer;\n\t\tthis.isPartOfKey = Initializer.isPartOfKey( navigablePath, parent );\n\t\t// If the parent already has previous row reuse enabled, we can skip that here\n\t\tthis.previousRowReuse = !isPreviousRowReuse( parent ) && (\n\t\t\t\t// If this entity domain result contains a collection join fetch, this usually means that the entity data is\n\t\t\t\t// duplicate in the result data for every collection element. Since collections usually have more than one element,\n\t\t\t\t// optimizing the resolving of the entity data is very beneficial.\n\t\t\t\tresultDescriptor.containsCollectionFetches()\n\t\t\t\t\t\t// Result duplication generally also happens if more than one collection is join fetched,\n\t\t\t\t\t\t|| creationState.containsMultipleCollectionFetches()\n\t\t);\n\n\t\tassert identifierFetch != null || isResultInitializer : \"Identifier must be fetched, unless this is a result initializer\";\n\t\tif ( identifierFetch == null ) {\n\t\t\tidentifierAssembler = null;\n\t\t\thasKeyManyToOne = false;\n\t\t}\n\t\telse {\n\t\t\tidentifierAssembler = identifierFetch.createAssembler( this, creationState );\n\t\t\tfinal Initializer<?> initializer = identifierAssembler.getInitializer();\n\t\t\t// For now, assume key many to ones if the identifier has an initializer\n\t\t\t// todo: improve this\n\t\t\thasKeyManyToOne = initializer != null;\n\t\t}\n\n\t\tassert entityDescriptor.hasSubclasses() == (discriminatorFetch != null) : \"Discriminator should only be fetched if the entity has subclasses\";\n\t\tdiscriminatorAssembler = discriminatorFetch != null\n\t\t\t\t? (BasicResultAssembler<?>) discriminatorFetch.createAssembler( this, creationState )\n\t\t\t\t: null;\n\n\t\tfinal EntityVersionMapping versionMapping = entityDescriptor.getVersionMapping();\n\t\tif ( versionMapping != null ) {\n\t\t\tfinal Fetch versionFetch = resultDescriptor.findFetch( versionMapping );\n\t\t\t// If there is a version mapping, there must be a fetch for it\n\t\t\tassert versionFetch != null;\n\t\t\tversionAssembler = versionFetch.createAssembler( this, creationState );\n\t\t}\n\t\telse {\n\t\t\tversionAssembler = null;\n\t\t}\n\n\t\trowIdAssembler = rowIdResult != null\n\t\t\t\t? rowIdResult.createResultAssembler( this, creationState )\n\t\t\t\t: null;\n\n\t\tfinal Collection<EntityMappingType> subMappingTypes = rootEntityDescriptor.getSubMappingTypes();\n\t\tfinal DomainResultAssembler<?>[][] assemblers = new DomainResultAssembler[subMappingTypes.size() + 1][];\n\t\tfinal Initializer<?>[][] subInitializers = new Initializer<?>[subMappingTypes.size() + 1][];\n\t\tfinal Initializer<?>[][] eagerSubInitializers = new Initializer<?>[subMappingTypes.size() + 1][];\n\t\tfinal BitSet[] lazySubInitializers = new BitSet[subMappingTypes.size() + 1];\n\t\tfinal BitSet[] maybeLazySets = new BitSet[subMappingTypes.size() + 1];\n\t\tfinal MutabilityPlan[][] updatableAttributeMutabilityPlans = new MutabilityPlan[subMappingTypes.size() + 1][];\n\t\tassemblers[rootEntityDescriptor.getSubclassId()] = new DomainResultAssembler[rootEntityDescriptor.getNumberOfFetchables()];\n\t\tupdatableAttributeMutabilityPlans[rootEntityDescriptor.getSubclassId()] = new MutabilityPlan[rootEntityDescriptor.getNumberOfAttributeMappings()];\n\n\t\tfor ( EntityMappingType subMappingType : subMappingTypes ) {\n\t\t\tassemblers[subMappingType.getSubclassId()] = new DomainResultAssembler[subMappingType.getNumberOfFetchables()];\n\t\t\tupdatableAttributeMutabilityPlans[subMappingType.getSubclassId()] = new MutabilityPlan[subMappingType.getNumberOfAttributeMappings()];\n\t\t}\n\n\t\tboolean hasEagerSubInitializers = false;\n\t\tfinal int size = entityDescriptor.getNumberOfFetchables();\n\t\tfor ( int i = 0; i < size; i++ ) {\n\t\t\tfinal AttributeMapping attributeMapping = entityDescriptor.getFetchable( i ).asAttributeMapping();\n\t\t\tfinal Fetch fetch = resultDescriptor.findFetch( attributeMapping );\n\t\t\tfinal DomainResultAssembler<?> stateAssembler = fetch == null\n\t\t\t\t\t? new NullValueAssembler<>( attributeMapping.getMappedType().getMappedJavaType() )\n\t\t\t\t\t: fetch.createAssembler( this, creationState );\n\n\t\t\tfinal int stateArrayPosition = attributeMapping.getStateArrayPosition();\n\t\t\tfinal EntityMappingType declaringType = attributeMapping.getDeclaringType().asEntityMappingType();\n\t\t\tfinal int subclassId = declaringType.getSubclassId();\n\n\t\t\tfinal Initializer<?> subInitializer = stateAssembler.getInitializer();\n\t\t\tif ( subInitializer != null ) {\n\t\t\t\tif ( subInitializers[subclassId] == null ) {\n\t\t\t\t\tsubInitializers[subclassId] = new Initializer<?>[size];\n\t\t\t\t\teagerSubInitializers[subclassId] = new Initializer<?>[size];\n\t\t\t\t\tlazySubInitializers[subclassId] = new BitSet(size);\n\t\t\t\t\tmaybeLazySets[subclassId] = new BitSet(size);\n\t\t\t\t}\n\t\t\t\tsubInitializers[subclassId][stateArrayPosition] = subInitializer;\n\t\t\t\tif ( subInitializer.isEager() ) {\n\t\t\t\t\thasEagerSubInitializers = true;\n\t\t\t\t\teagerSubInitializers[subclassId][stateArrayPosition] = subInitializer;\n\t\t\t\t\tif ( subInitializer.hasEagerSubInitializers() ) {\n\t\t\t\t\t\tmaybeLazySets[subclassId].set( stateArrayPosition );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tlazySubInitializers[subclassId].set( stateArrayPosition );\n\t\t\t\t\tmaybeLazySets[subclassId].set( stateArrayPosition );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tassemblers[subclassId][stateArrayPosition] = stateAssembler;\n\t\t\tfinal AttributeMetadata attributeMetadata = attributeMapping.getAttributeMetadata();\n\t\t\tif ( attributeMetadata.isUpdatable() ) {\n\t\t\t\tupdatableAttributeMutabilityPlans[subclassId][stateArrayPosition] = attributeMetadata.getMutabilityPlan();\n\t\t\t}\n\t\t\tfor ( EntityMappingType subMappingType : declaringType.getSubMappingTypes() ) {\n\t\t\t\tassemblers[subMappingType.getSubclassId()][stateArrayPosition] = stateAssembler;\n\t\t\t\tupdatableAttributeMutabilityPlans[subMappingType.getSubclassId()][stateArrayPosition] = updatableAttributeMutabilityPlans[subclassId][stateArrayPosition];\n\t\t\t\tif ( subInitializer != null ) {\n\t\t\t\t\tif ( subInitializers[subMappingType.getSubclassId()] == null ) {\n\t\t\t\t\t\tsubInitializers[subMappingType.getSubclassId()] = new Initializer<?>[size];\n\t\t\t\t\t\teagerSubInitializers[subMappingType.getSubclassId()] = new Initializer<?>[size];\n\t\t\t\t\t\tlazySubInitializers[subMappingType.getSubclassId()] = new BitSet(size);\n\t\t\t\t\t\tmaybeLazySets[subMappingType.getSubclassId()] = new BitSet(size);\n\t\t\t\t\t}\n\t\t\t\t\tsubInitializers[subMappingType.getSubclassId()][stateArrayPosition] = subInitializer;\n\t\t\t\t\tif ( subInitializer.isEager() ) {\n\t\t\t\t\t\thasEagerSubInitializers = true;\n\t\t\t\t\t\teagerSubInitializers[subMappingType.getSubclassId()][stateArrayPosition] = subInitializer;\n\t\t\t\t\t\tif ( subInitializer.hasEagerSubInitializers() ) {\n\t\t\t\t\t\t\tmaybeLazySets[subMappingType.getSubclassId()].set( stateArrayPosition );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tlazySubInitializers[subMappingType.getSubclassId()].set( stateArrayPosition );\n\t\t\t\t\t\tmaybeLazySets[subMappingType.getSubclassId()].set( stateArrayPosition );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfinal BitSet emptyBitSet = new BitSet();\n\t\tOUTER: for ( int i = 0; i < subInitializers.length; i++ ) {\n\t\t\tif ( subInitializers[i] != null ) {\n\t\t\t\tfor ( Initializer<?> initializer : subInitializers[i] ) {\n\t\t\t\t\tif ( initializer != null ) {\n\t\t\t\t\t\tcontinue OUTER;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tsubInitializers[i] = Initializer.EMPTY_ARRAY;\n\t\t\tlazySubInitializers[i] = emptyBitSet;\n\t\t\tmaybeLazySets[i] = emptyBitSet;\n\t\t}\n\t\tOUTER: for ( int i = 0; i < eagerSubInitializers.length; i++ ) {\n\t\t\tif ( eagerSubInitializers[i] != null ) {\n\t\t\t\tfor ( Initializer<?> initializer : eagerSubInitializers[i] ) {\n\t\t\t\t\tif ( initializer != null ) {\n\t\t\t\t\t\tcontinue OUTER;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\teagerSubInitializers[i] = Initializer.EMPTY_ARRAY;\n\t\t}\n\n\t\tthis.assemblers = assemblers;\n\t\tthis.subInitializers = subInitializers;\n\t\tthis.subInitializersForResolveFromInitialized = rootEntityDescriptor.getBytecodeEnhancementMetadata().isEnhancedForLazyLoading()\n\t\t\t\t? subInitializers\n\t\t\t\t: eagerSubInitializers;\n\t\tthis.lazySubInitializers = Arrays.stream(lazySubInitializers).map( ImmutableBitSet::valueOf ).toArray(ImmutableBitSet[]::new);\n\t\tthis.maybeLazySets = Arrays.stream(maybeLazySets).map( ImmutableBitSet::valueOf ).toArray(ImmutableBitSet[]::new);\n\t\tthis.hasEagerSubInitializers = hasEagerSubInitializers;\n\t\tthis.updatableAttributeMutabilityPlans = updatableAttributeMutabilityPlans;\n\t\tthis.notFoundAction = notFoundAction;\n\n\t\tthis.keyAssembler = keyResult == null ? null : keyResult.createResultAssembler( this, creationState );\n\t\tthis.affectedByFilter = affectedByFilter;\n\t}\n\n\tprivate static boolean isPreviousRowReuse(@Nullable InitializerParent<?> parent) {\n\t\t// Traverse up the parents to find out if one of our parents has row reuse enabled\n\t\twhile ( parent != null ) {\n\t\t\tif ( parent instanceof EntityInitializerImpl ) {\n\t\t\t\treturn ( (EntityInitializerImpl) parent ).isPreviousRowReuse();\n\t\t\t}\n\t\t\t// Immediate collections don't reuse previous rows for elements, so we can safely assume false\n\t\t\tif ( parent instanceof AbstractImmediateCollectionInitializer<?> ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tparent = parent.getParent();\n\t\t}\n\t\treturn false;\n\t}\n\n\t@Override\n\tprotected EntityInitializerData createInitializerData(RowProcessingState rowProcessingState) {\n\t\treturn new EntityInitializerData( this, rowProcessingState );\n\t}\n\n\t@Override\n\tpublic void resolveKey(EntityInitializerData data) {\n\t\tresolveKey( data, false );\n\t}\n\n\t@Override\n\tpublic @Nullable Object getEntityIdentifier(EntityInitializerData data) {\n\t\treturn data.entityKey == null ? null : data.entityKey.getIdentifier();\n\t}\n\n\t@Override\n\tpublic @Nullable EntityKey resolveEntityKeyOnly(RowProcessingState rowProcessingState) {\n\t\tfinal EntityInitializerData data = getData( rowProcessingState );\n\t\tresolveKey( data, true );\n\t\tif ( data.getState() == State.MISSING ) {\n\t\t\treturn null;\n\t\t}\n\t\tif ( data.entityKey == null ) {\n\t\t\tassert identifierAssembler != null;\n\t\t\tfinal Object id = identifierAssembler.assemble( rowProcessingState );\n\t\t\tif ( id == null ) {\n\t\t\t\tsetMissing( data );\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tresolveEntityKey( data, id );\n\t\t}\n\t\treturn data.entityKey;\n\t}\n\n\tprotected void resolveKey(EntityInitializerData data, boolean entityKeyOnly) {\n\t\t// todo (6.0) : atm we do not handle sequential selects\n\t\t// \t\t- see AbstractEntityPersister#hasSequentialSelect and\n\t\t//\t\t\tAbstractEntityPersister#getSequentialSelect in 5.2\n\t\tif ( data.getState() != State.UNINITIALIZED ) {\n\t\t\treturn;\n\t\t}\n\t\tdata.setState( State.KEY_RESOLVED );\n\n\t\tfinal EntityKey oldEntityKey = data.entityKey;\n\t\tfinal Object oldEntityInstance = data.getInstance();\n\t\tfinal Object oldEntityInstanceForNotify = data.entityInstanceForNotify;\n\t\tfinal EntityHolder oldEntityHolder = data.entityHolder;\n\t\t// reset row state\n\t\tfinal EntityPersister concreteDescriptor = data.concreteDescriptor = data.defaultConcreteDescriptor;\n\t\tdata.entityKey = null;\n\t\tdata.setInstance( null );\n\t\tdata.entityInstanceForNotify = null;\n\t\tdata.entityHolder = null;\n\n\t\tfinal RowProcessingState rowProcessingState = data.getRowProcessingState();\n\t\tfinal Object id;\n\t\tif ( identifierAssembler == null ) {\n\t\t\tid = rowProcessingState.getEntityId();\n\t\t\tassert id != null : \"Initializer requires a not null id for loading\";\n\t\t}\n\t\telse {\n\t\t\t//noinspection unchecked\n\t\t\tfinal Initializer<InitializerData> initializer = (Initializer<InitializerData>) identifierAssembler.getInitializer();\n\t\t\tif ( initializer != null ) {\n\t\t\t\tfinal InitializerData subData = initializer.getData( rowProcessingState );\n\t\t\t\tinitializer.resolveKey( subData );\n\t\t\t\tif ( subData.getState() == State.MISSING ) {\n\t\t\t\t\tsetMissing( data );\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif ( concreteDescriptor == null ) {\n\t\t\t\t\t\tdata.concreteDescriptor = determineConcreteEntityDescriptor(\n\t\t\t\t\t\t\t\trowProcessingState,\n\t\t\t\t\t\t\t\tdiscriminatorAssembler,\n\t\t\t\t\t\t\t\tentityDescriptor\n\t\t\t\t\t\t);\n\t\t\t\t\t\tassert data.concreteDescriptor != null;\n\t\t\t\t\t}\n\t\t\t\t\tif ( hasKeyManyToOne ) {\n\t\t\t\t\t\tif ( !data.shallowCached && !entityKeyOnly ) {\n\t\t\t\t\t\t\tresolveKeySubInitializers( data );\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tid = identifierAssembler.assemble( rowProcessingState );\n\t\t\tif ( id == null ) {\n\t\t\t\tsetMissing( data );\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tif ( oldEntityKey != null && previousRowReuse && oldEntityInstance != null\n\t\t\t\t&& areKeysEqual( oldEntityKey.getIdentifier(), id ) ) {\n\t\t\t// The row we read previously referred to this entity already, so we can safely assume it's initialized.\n\t\t\t// Unfortunately we can't set the state to INITIALIZED though, as that has other implications,\n\t\t\t// but RESOLVED is fine, since the EntityEntry is marked as initialized which skips instance initialization\n\t\t\tdata.setState( State.RESOLVED );\n\t\t\tdata.entityKey = oldEntityKey;\n\t\t\tdata.setInstance( oldEntityInstance );\n\t\t\tdata.entityInstanceForNotify = oldEntityInstanceForNotify;\n\t\t\tdata.concreteDescriptor = oldEntityKey.getPersister();\n\t\t\tdata.entityHolder = oldEntityHolder;\n\t\t\tnotifySubInitializersToReusePreviousRowInstance( data );\n\t\t\treturn;\n\t\t}\n\t\tresolveEntityKey( data, id );\n\t\tif ( !entityKeyOnly ) {\n\t\t\t// Resolve the entity instance early as we have no key many-to-one\n\t\t\tresolveInstance( data );\n\t\t\tif ( !data.shallowCached ) {\n\t\t\t\tif ( data.getState() == State.INITIALIZED ) {\n\t\t\t\t\tif ( data.entityHolder.getEntityInitializer() == null ) {\n\t\t\t\t\t\t// The entity is already part of the persistence context,\n\t\t\t\t\t\t// so let's figure out the loaded state and only run sub-initializers if necessary\n\t\t\t\t\t\tresolveInstanceSubInitializers( data );\n\t\t\t\t\t}\n\t\t\t\t\t// If the entity is initialized and getEntityInitializer() == this,\n\t\t\t\t\t// we already processed a row for this entity before,\n\t\t\t\t\t// but we still have to call resolveKeySubInitializers to activate sub-initializers,\n\t\t\t\t\t// because a row might contain data that sub-initializers want to consume\n\t\t\t\t\telse {\n\t\t\t\t\t\t// todo: try to diff the eagerness of the sub-initializers to avoid further processing\n\t\t\t\t\t\tresolveKeySubInitializers( data );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tresolveKeySubInitializers( data );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate boolean areKeysEqual(Object key1, Object key2) {\n\t\treturn keyTypeForEqualsHashCode == null ? key1.equals( key2 ) : keyTypeForEqualsHashCode.isEqual( key1, key2 );\n\t}\n\n\tprotected void resolveInstanceSubInitializers(EntityInitializerData data) {\n\t\tfinal int subclassId = data.concreteDescriptor.getSubclassId();\n\t\tfinal Initializer<?>[] initializers = subInitializersForResolveFromInitialized[subclassId];\n\t\tfinal EntityEntry entityEntry;\n\t\tfinal ImmutableBitSet maybeLazySet;\n\t\t// Skip resolving if this initializer has no sub-initializers\n\t\tif ( initializers.length == 0\n\t\t\t\t// or the entity entry has a lazy set available\n\t\t\t\t|| ( maybeLazySet = ( entityEntry = data.entityHolder.getEntityEntry() ).getMaybeLazySet() ) != null\n\t\t\t\t// which is contained in the lazy sub-initializers\n\t\t\t\t&& lazySubInitializers[subclassId].contains( maybeLazySet ) ) {\n\t\t\treturn;\n\t\t}\n\t\tfinal RowProcessingState rowProcessingState = data.getRowProcessingState();\n\t\tassert entityEntry == rowProcessingState.getSession()\n\t\t\t\t.getPersistenceContextInternal()\n\t\t\t\t.getEntry( data.entityInstanceForNotify );\n\t\tfinal Object[] loadedState = entityEntry.getLoadedState();\n\t\tfinal Object[] state;\n\t\tif ( loadedState == null ) {\n\t\t\tif ( entityEntry.getStatus() == Status.READ_ONLY ) {\n\t\t\t\tstate = data.concreteDescriptor.getValues( data.entityInstanceForNotify );\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// This branch is entered when a load happens while a cache entry is assembling.\n\t\t\t\t// The EntityEntry has the LOADING state, but the loaded state is still empty.\n\t\t\t\tassert entityEntry.getStatus() == Status.LOADING;\n\t\t\t\t// Just skip any initialization in this case as the cache entry assembling will take care of it\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tstate = loadedState;\n\t\t}\n\t\tfor ( int i = 0; i < initializers.length; i++ ) {\n\t\t\tfinal Initializer<?> initializer = initializers[i];\n\t\t\tif ( initializer != null && ( maybeLazySet == null || maybeLazySet.get( i ) ) ) {\n\t\t\t\tfinal Object subInstance = state[i];\n\t\t\t\tif ( subInstance == UNFETCHED_PROPERTY ) {\n\t\t\t\t\t// Go through the normal initializer process\n\t\t\t\t\tinitializer.resolveKey( rowProcessingState );\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tinitializer.resolveInstance( subInstance, rowProcessingState );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate void notifySubInitializersToReusePreviousRowInstance(EntityInitializerData data) {\n\t\tfinal RowProcessingState rowProcessingState = data.getRowProcessingState();\n\t\tfor ( Initializer<?> initializer : subInitializers[data.concreteDescriptor.getSubclassId()] ) {\n\t\t\tif ( initializer != null ) {\n\t\t\t\tinitializer.resolveFromPreviousRow( rowProcessingState );\n\t\t\t}\n\t\t}\n\t}\n\n\tprotected void resolveKeySubInitializers(EntityInitializerData data) {\n\t\tfinal RowProcessingState rowProcessingState = data.getRowProcessingState();\n\t\tfor ( Initializer<?> initializer : subInitializers[data.concreteDescriptor.getSubclassId()] ) {\n\t\t\tif ( initializer != null ) {\n\t\t\t\tinitializer.resolveKey( rowProcessingState );\n\t\t\t}\n\t\t}\n\t}\n\n\t@EnsuresNonNull( \"data.entityKey\" )\n\tprotected void resolveEntityKey(EntityInitializerData data, Object id) {\n\t\tEntityPersister concreteDescriptor = data.concreteDescriptor;\n\t\tif ( concreteDescriptor == null ) {\n\t\t\tconcreteDescriptor = data.concreteDescriptor = determineConcreteEntityDescriptor(\n\t\t\t\t\tdata.getRowProcessingState(),\n\t\t\t\t\tdiscriminatorAssembler,\n\t\t\t\t\tentityDescriptor\n\t\t\t);\n\t\t\tassert concreteDescriptor != null;\n\t\t}\n\t\tdata.entityKey = new EntityKey( id, concreteDescriptor );\n\t}\n\n\tprotected void setMissing(EntityInitializerData data) {\n\t\tdata.entityKey = null;\n\t\tdata.concreteDescriptor = null;\n\t\tdata.setInstance( null );\n\t\tdata.entityInstanceForNotify = null;\n\t\tdata.entityHolder = null;\n\t\tdata.setState( State.MISSING );\n\n\t\t// super processes the foreign-key target column.  here we\n\t\t// need to also look at the foreign-key value column to check\n\t\t// for a dangling foreign-key\n\n\t\tif ( keyAssembler != null ) {\n\t\t\tfinal Object fkKeyValue = keyAssembler.assemble( data.getRowProcessingState() );\n\t\t\tif ( fkKeyValue != null ) {\n\t\t\t\tif ( notFoundAction != NotFoundAction.IGNORE ) {\n\t\t\t\t\tif ( affectedByFilter ) {\n\t\t\t\t\t\tthrow new EntityFilterException(\n\t\t\t\t\t\t\t\tgetEntityDescriptor().getEntityName(),\n\t\t\t\t\t\t\t\tfkKeyValue,\n\t\t\t\t\t\t\t\treferencedModelPart.getNavigableRole().getFullPath()\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\tthrow new FetchNotFoundException(\n\t\t\t\t\t\t\tgetEntityDescriptor().getEntityName(),\n\t\t\t\t\t\t\tfkKeyValue\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic void resolveFromPreviousRow(EntityInitializerData data) {\n\t\tif ( data.getState() == State.UNINITIALIZED ) {\n\t\t\tfinal EntityKey entityKey = data.entityKey;\n\t\t\tif ( entityKey == null ) {\n\t\t\t\tsetMissing( data );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdata.setState( State.RESOLVED );\n\t\t\t\tnotifySubInitializersToReusePreviousRowInstance( data );\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic void initializeInstanceFromParent(Object parentInstance, EntityInitializerData data) {\n\t\tfinal AttributeMapping attributeMapping = getInitializedPart().asAttributeMapping();\n\t\tfinal Object instance = attributeMapping != null\n\t\t\t\t? attributeMapping.getValue( parentInstance )\n\t\t\t\t: parentInstance;\n\t\tfinal SharedSessionContractImplementor session = data.getRowProcessingState().getSession();\n\t\tif ( instance == null ) {\n\t\t\tsetMissing( data );\n\t\t}\n\t\telse {\n\t\t\tdata.setInstance( instance );\n\t\t\tfinal Object entityInstanceForNotify = data.entityInstanceForNotify = Hibernate.unproxy( instance );\n\t\t\tdata.concreteDescriptor = session.getEntityPersister( null, entityInstanceForNotify );\n\t\t\tresolveEntityKey(\n\t\t\t\t\tdata,\n\t\t\t\t\tdata.concreteDescriptor.getIdentifier( entityInstanceForNotify, session )\n\t\t\t);\n\t\t\tdata.entityHolder = session.getPersistenceContextInternal().getEntityHolder( data.entityKey );\n\t\t\tdata.setState( State.INITIALIZED );\n\t\t\tinitializeSubInstancesFromParent( data );\n\t\t}\n\t}\n\n\t@Override\n\tpublic boolean isResultInitializer() {\n\t\treturn isResultInitializer;\n\t}\n\n\tprivate void deepCopy(EntityPersister containerDescriptor, Object[] source, Object[] target) {\n\t\tfinal MutabilityPlan<Object>[] updatableAttributeMutabilityPlan = updatableAttributeMutabilityPlans[containerDescriptor.getSubclassId()];\n\t\tfor ( int i = 0; i < updatableAttributeMutabilityPlan.length; i++ ) {\n\t\t\tfinal Object sourceValue = source[i];\n\t\t\tif ( updatableAttributeMutabilityPlan[i] != null\n\t\t\t\t\t&& sourceValue != LazyPropertyInitializer.UNFETCHED_PROPERTY\n\t\t\t\t\t&& sourceValue != PropertyAccessStrategyBackRefImpl.UNKNOWN ) {\n\t\t\t\ttarget[i] = updatableAttributeMutabilityPlan[i].deepCopy( source[i] );\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic ModelPart getInitializedPart() {\n\t\treturn referencedModelPart;\n\t}\n\n\t@Override\n\tpublic NavigablePath getNavigablePath() {\n\t\treturn navigablePath;\n\t}\n\n\tprotected DomainResultAssembler<?> getIdentifierAssembler() {\n\t\treturn identifierAssembler;\n\t}\n\n\t@Override\n\tpublic EntityPersister getEntityDescriptor() {\n\t\treturn entityDescriptor;\n\t}\n\n\t@Override\n\tpublic Object getTargetInstance(EntityInitializerData data) {\n\t\treturn data.entityInstanceForNotify;\n\t}\n\n\t@Override\n\tpublic @Nullable InitializerParent<?> getParent() {\n\t\treturn parent;\n\t}\n\n\tprivate final ConcurrentHashMap<String, Type[]> parentEntityAttributeTypes = new ConcurrentHashMap<>();\n\n\tprotected Type[] getParentEntityAttributeTypes(String attributeName) {\n\t\tType[] types = parentEntityAttributeTypes.get( attributeName );\n\t\tif ( types == null ) {\n\t\t\ttypes = new Type[\n\t\t\t\t\tentityDescriptor.getRootEntityDescriptor()\n\t\t\t\t\t\t\t.getSubclassEntityNames()\n\t\t\t\t\t\t\t.size()\n\t\t\t\t\t];\n\t\t\tinitializeAttributeType( types, entityDescriptor, attributeName );\n\t\t\tfor ( EntityMappingType subMappingType : entityDescriptor.getSubMappingTypes() ) {\n\t\t\t\tinitializeAttributeType( types, subMappingType.getEntityPersister(), attributeName );\n\t\t\t}\n\t\t\tparentEntityAttributeTypes.putIfAbsent( attributeName, types );\n\t\t}\n\t\treturn types;\n\t}\n\n\tprotected void initializeAttributeType(Type[] attributeTypes, EntityPersister entityDescriptor, String attributeName) {\n\t\tif ( entityDescriptor.findByPath( attributeName ) != null ) {\n\t\t\tattributeTypes[entityDescriptor.getSubclassId()] = entityDescriptor.getPropertyType( attributeName );\n\t\t}\n\t}\n\n\tpublic static @Nullable EntityPersister determineConcreteEntityDescriptor(\n\t\t\tRowProcessingState rowProcessingState,\n\t\t\t@Nullable BasicResultAssembler<?> discriminatorAssembler,\n\t\t\tEntityPersister entityDescriptor)\n\t\t\tthrows WrongClassException {\n\t\tif ( discriminatorAssembler == null\n\t\t\t\t|| rowProcessingState.isQueryCacheHit() && entityDescriptor.useShallowQueryCacheLayout() && !entityDescriptor.storeDiscriminatorInShallowQueryCacheLayout() ) {\n\t\t\treturn entityDescriptor;\n\t\t}\n\t\telse {\n\t\t\tassert entityDescriptor.hasSubclasses() : \"Reading a discriminator from a result set should only happen if the entity has subclasses\";\n\t\t\tfinal EntityDiscriminatorMapping discriminatorMapping = entityDescriptor.getDiscriminatorMapping();\n\t\t\tassert discriminatorMapping != null;\n\t\t\tfinal Object discriminator = discriminatorAssembler.extractRawValue( rowProcessingState );\n\t\t\tfinal DiscriminatorValueDetails discriminatorDetails =\n\t\t\t\t\tdiscriminatorMapping.resolveDiscriminatorValue( discriminator );\n\t\t\tif ( discriminatorDetails == null ) {\n\t\t\t\tassert discriminator == null : \"Discriminator details should only be null for null values\";\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfinal EntityMappingType indicatedEntity = discriminatorDetails.getIndicatedEntity();\n\t\t\t\tif ( indicatedEntity.isTypeOrSuperType( entityDescriptor ) ) {\n\t\t\t\t\treturn indicatedEntity.getEntityPersister();\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow new WrongClassException(\n\t\t\t\t\t\t\tindicatedEntity.getEntityName(),\n\t\t\t\t\t\t\tnull,\n\t\t\t\t\t\t\tentityDescriptor.getEntityName(),\n\t\t\t\t\t\t\tdiscriminator\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprotected boolean useEmbeddedIdentifierInstanceAsEntity(EntityInitializerData data) {\n\t\treturn data.canUseEmbeddedIdentifierInstanceAsEntity\n\t\t\t\t&& ( data.concreteDescriptor = determineConcreteEntityDescriptor( data.getRowProcessingState(), discriminatorAssembler, entityDescriptor ) ) != null\n\t\t\t\t&& data.concreteDescriptor.isInstance( data.getRowProcessingState().getEntityId() );\n\t}\n\n\t@Override\n\tpublic void resolveInstance(Object instance, EntityInitializerData data) {\n\t\tif ( instance == null ) {\n\t\t\tsetMissing( data );\n\t\t\treturn;\n\t\t}\n\t\tdata.setInstance( instance );\n\t\tfinal LazyInitializer lazyInitializer = extractLazyInitializer( instance );\n\t\tfinal RowProcessingState rowProcessingState = data.getRowProcessingState();\n\t\tfinal SharedSessionContractImplementor session = rowProcessingState.getSession();\n\t\tfinal PersistenceContext persistenceContext = session.getPersistenceContextInternal();\n\t\tif ( lazyInitializer == null ) {\n\t\t\t// Entity is most probably initialized\n\t\t\tdata.entityInstanceForNotify = instance;\n\t\t\tdata.concreteDescriptor = session.getEntityPersister( null, instance );\n\t\t\tresolveEntityKey(\n\t\t\t\t\tdata,\n\t\t\t\t\tdata.concreteDescriptor.getIdentifier( instance, session )\n\t\t\t);\n\t\t\tdata.entityHolder = persistenceContext.getEntityHolder( data.entityKey );\n\t\t\tif ( data.entityHolder == null ) {\n\t\t\t\t// Entity was most probably removed in the same session without setting the reference to null\n\t\t\t\tresolveKey( data );\n\t\t\t\tassert data.getState() == State.MISSING;\n\t\t\t\tassert referencedModelPart instanceof ToOneAttributeMapping\n\t\t\t\t\t\t&& ( (ToOneAttributeMapping) referencedModelPart ).getSideNature() == TARGET;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// If the entity initializer is null, we know the entity is fully initialized,\n\t\t\t// otherwise it will be initialized by some other initializer\n\t\t\tdata.setState( data.entityHolder.getEntityInitializer() == null ? State.INITIALIZED : State.RESOLVED );\n\t\t}\n\t\telse if ( lazyInitializer.isUninitialized() ) {\n\t\t\tdata.setState( State.RESOLVED );\n\t\t\t// Read the discriminator from the result set if necessary\n\t\t\tdata.concreteDescriptor = discriminatorAssembler == null\n\t\t\t\t\t? entityDescriptor\n\t\t\t\t\t: determineConcreteEntityDescriptor( rowProcessingState, discriminatorAssembler, entityDescriptor );\n\t\t\tassert data.concreteDescriptor != null;\n\t\t\tresolveEntityKey( data, lazyInitializer.getIdentifier() );\n\t\t\tdata.entityHolder = persistenceContext.claimEntityHolderIfPossible(\n\t\t\t\t\tdata.entityKey,\n\t\t\t\t\tnull,\n\t\t\t\t\trowProcessingState.getJdbcValuesSourceProcessingState(),\n\t\t\t\t\tthis\n\t\t\t);\n\t\t\t// Resolve and potentially create the entity instance\n\t\t\tdata.entityInstanceForNotify = resolveEntityInstance( data );\n\t\t\tlazyInitializer.setImplementation( data.entityInstanceForNotify );\n\t\t\tregisterLoadingEntity( data, data.entityInstanceForNotify );\n\t\t}\n\t\telse {\n\t\t\tdata.setState( State.INITIALIZED );\n\t\t\tdata.entityInstanceForNotify = lazyInitializer.getImplementation();\n\t\t\tdata.concreteDescriptor = session.getEntityPersister( null, data.entityInstanceForNotify );\n\t\t\tresolveEntityKey( data, lazyInitializer.getIdentifier() );\n\t\t\tdata.entityHolder = persistenceContext.getEntityHolder( data.entityKey );\n\t\t}\n\t\tif ( identifierAssembler != null ) {\n\t\t\tfinal Initializer<?> initializer = identifierAssembler.getInitializer();\n\t\t\tif ( initializer != null ) {\n\t\t\t\tinitializer.resolveInstance( data.entityKey.getIdentifier(), rowProcessingState );\n\t\t\t}\n\t\t}\n\t\tupgradeLockMode( data );\n\t\tif ( data.getState() == State.INITIALIZED ) {\n\t\t\tregisterReloadedEntity( data );\n\t\t\tresolveInstanceSubInitializers( data );\n\t\t\tif ( rowProcessingState.needsResolveState() ) {\n\t\t\t\t// We need to read result set values to correctly populate the query cache\n\t\t\t\tresolveEntityState( data );\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tresolveKeySubInitializers( data );\n\t\t}\n\t}\n\n\t@Override\n\tpublic void resolveInstance(EntityInitializerData data) {\n\t\tif ( data.getState() != State.KEY_RESOLVED ) {\n\t\t\treturn;\n\t\t}\n\t\tfinal RowProcessingState rowProcessingState = data.getRowProcessingState();\n\t\tdata.setState( State.RESOLVED );\n\t\tif ( data.entityKey == null ) {\n\t\t\tassert identifierAssembler != null;\n\t\t\tfinal Object id = identifierAssembler.assemble( rowProcessingState );\n\t\t\tif ( id == null ) {\n\t\t\t\tsetMissing( data );\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresolveEntityKey( data, id );\n\t\t}\n\t\tfinal PersistenceContext persistenceContext = rowProcessingState.getSession()\n\t\t\t\t.getPersistenceContextInternal();\n\t\tdata.entityHolder = persistenceContext.claimEntityHolderIfPossible(\n\t\t\t\tdata.entityKey,\n\t\t\t\tnull,\n\t\t\t\trowProcessingState.getJdbcValuesSourceProcessingState(),\n\t\t\t\tthis\n\t\t);\n\n\t\tif ( useEmbeddedIdentifierInstanceAsEntity( data ) ) {\n\t\t\tdata.setInstance( data.entityInstanceForNotify = rowProcessingState.getEntityId() );\n\t\t}\n\t\telse {\n\t\t\tresolveEntityInstance1( data );\n\t\t\tif ( data.uniqueKeyAttributePath != null ) {\n\t\t\t\tfinal SharedSessionContractImplementor session = rowProcessingState.getSession();\n\t\t\t\tfinal EntityPersister concreteDescriptor = getConcreteDescriptor( data );\n\t\t\t\tfinal EntityUniqueKey euk = new EntityUniqueKey(\n\t\t\t\t\t\tconcreteDescriptor.getEntityName(),\n\t\t\t\t\t\tdata.uniqueKeyAttributePath,\n\t\t\t\t\t\trowProcessingState.getEntityUniqueKey(),\n\t\t\t\t\t\tdata.uniqueKeyPropertyTypes[concreteDescriptor.getSubclassId()],\n\t\t\t\t\t\tsession.getFactory()\n\t\t\t\t);\n\t\t\t\tsession.getPersistenceContextInternal().addEntity( euk, data.getInstance() );\n\t\t\t}\n\t\t}\n\n\t\tif ( data.getInstance() != null ) {\n\t\t\tupgradeLockMode( data );\n\t\t\tif ( data.getState() == State.INITIALIZED ) {\n\t\t\t\tregisterReloadedEntity( data );\n\t\t\t\tif ( rowProcessingState.needsResolveState() ) {\n\t\t\t\t\t// We need to read result set values to correctly populate the query cache\n\t\t\t\t\tresolveEntityState( data );\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( data.shallowCached ) {\n\t\t\t\tinitializeSubInstancesFromParent( data );\n\t\t\t}\n\t\t}\n\t}\n\n\tprotected void resolveEntityInstance1(EntityInitializerData data) {\n\t\tfinal Object proxy = data.entityHolder.getProxy();\n\t\tfinal boolean unwrapProxy = proxy != null && referencedModelPart instanceof ToOneAttributeMapping\n\t\t\t\t&& ( (ToOneAttributeMapping) referencedModelPart ).isUnwrapProxy()\n\t\t\t\t&& getConcreteDescriptor( data ).getBytecodeEnhancementMetadata().isEnhancedForLazyLoading();\n\t\tfinal Object entityFromExecutionContext;\n\t\tif ( !unwrapProxy && isProxyInstance( proxy ) ) {\n\t\t\tif ( ( entityFromExecutionContext = getEntityFromExecutionContext( data ) ) != null ) {\n\t\t\t\tdata.setInstance( data.entityInstanceForNotify = entityFromExecutionContext );\n\t\t\t\t// If the entity comes from the execution context, it is treated as not initialized\n\t\t\t\t// so that we can refresh the data as requested\n\t\t\t\tregisterReloadedEntity( data );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdata.setInstance( proxy );\n\t\t\t\tif ( Hibernate.isInitialized( proxy ) ) {\n\t\t\t\t\tdata.setState( State.INITIALIZED );\n\t\t\t\t\tdata.entityInstanceForNotify = Hibernate.unproxy( proxy );\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tfinal LazyInitializer lazyInitializer = extractLazyInitializer( proxy );\n\t\t\t\t\tassert lazyInitializer != null;\n\t\t\t\t\tdata.entityInstanceForNotify = resolveEntityInstance2( data );\n\t\t\t\t\tlazyInitializer.setImplementation( data.entityInstanceForNotify );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tfinal Object existingEntity = data.entityHolder.getEntity();\n\t\t\tif ( existingEntity != null ) {\n\t\t\t\tdata.setInstance( data.entityInstanceForNotify = existingEntity );\n\t\t\t\tif ( data.entityHolder.getEntityInitializer() == null ) {\n\t\t\t\t\tassert data.entityHolder.isInitialized() == isExistingEntityInitialized( existingEntity );\n\t\t\t\t\tif ( data.entityHolder.isInitialized() ) {\n\t\t\t\t\t\tdata.setState( State.INITIALIZED );\n\t\t\t\t\t}\n\t\t\t\t\telse if ( isResultInitializer() ) {\n\t\t\t\t\t\tregisterLoadingEntity( data, existingEntity );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if ( data.entityHolder.getEntityInitializer() != this ) {\n\t\t\t\t\tdata.setState( State.INITIALIZED );\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if ( ( entityFromExecutionContext = getEntityFromExecutionContext( data ) ) != null ) {\n\t\t\t\t// This is the entity to refresh, so don't set the state to initialized\n\t\t\t\tdata.setInstance( data.entityInstanceForNotify = entityFromExecutionContext );\n\t\t\t\tif ( isResultInitializer() ) {\n\t\t\t\t\tregisterLoadingEntity( data, entityFromExecutionContext );\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tassert data.entityHolder.getEntityInitializer() == this;\n\t\t\t\t// look to see if another initializer from a parent load context or an earlier\n\t\t\t\t// initializer is already loading the entity\n\t\t\t\tdata.setInstance( data.entityInstanceForNotify = resolveEntityInstance2( data ) );\n\t\t\t\tfinal Initializer<?> idInitializer;\n\t\t\t\tif ( data.entityHolder.getEntityInitializer() == this && data.getState() != State.INITIALIZED\n\t\t\t\t\t\t&& identifierAssembler != null\n\t\t\t\t\t\t&& ( idInitializer = identifierAssembler.getInitializer() ) != null ) {\n\t\t\t\t\t// If this is the owning initializer and the returned object is not initialized,\n\t\t\t\t\t// this means that the entity instance was just instantiated.\n\t\t\t\t\t// In this case, we want to call \"assemble\" and hence \"initializeInstance\" on the initializer\n\t\t\t\t\t// for possibly non-aggregated identifier mappings, so inject the virtual id representation\n\t\t\t\t\tidInitializer.initializeInstance( data.getRowProcessingState() );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// todo: ensure we initialize the entity\n\t\tassert !data.shallowCached || data.getState() == State.INITIALIZED : \"Forgot to initialize the entity\";\n\t}\n\n\tprotected Object getEntityFromExecutionContext(EntityInitializerData data) {\n\t\tfinal RowProcessingState rowProcessingState = data.getRowProcessingState();\n\t\tfinal ExecutionContext executionContext = rowProcessingState.getJdbcValuesSourceProcessingState()\n\t\t\t\t.getExecutionContext();\n\t\tif ( rootEntityDescriptor == executionContext.getRootEntityDescriptor()\n\t\t\t\t&& areKeysEqual( data.entityKey.getIdentifier(), executionContext.getEntityId() ) ) {\n\t\t\treturn executionContext.getEntityInstance();\n\t\t}\n\t\treturn null;\n\t}\n\n\tprotected void upgradeLockMode(EntityInitializerData data) {\n\t\tfinal RowProcessingState rowProcessingState = data.getRowProcessingState();\n\t\tif ( data.lockMode != LockMode.NONE && rowProcessingState.upgradeLocks() ) {\n\t\t\tfinal EntityEntry entry = data.entityHolder.getEntityEntry();\n\t\t\tassert entry == rowProcessingState.getSession().getPersistenceContextInternal()\n\t\t\t\t\t\t\t.getEntry( data.entityInstanceForNotify );\n\t\t\tif ( entry != null && entry.getLockMode().lessThan( data.lockMode ) ) {\n\t\t\t\t//we only check the version when _upgrading_ lock modes\n\t\t\t\tif ( versionAssembler != null && entry.getLockMode() != LockMode.NONE ) {\n\t\t\t\t\tcheckVersion( data, entry, rowProcessingState );\n\t\t\t\t}\n\t\t\t\t//we need to upgrade the lock mode to the mode requested\n\t\t\t\tentry.setLockMode( data.lockMode );\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate boolean isProxyInstance(Object proxy) {\n\t\treturn proxy != null\n\t\t\t\t&& ( proxy instanceof MapProxy || entityDescriptor.getJavaType().getJavaTypeClass().isInstance( proxy ) );\n\t}\n\n\tprivate boolean isExistingEntityInitialized(Object existingEntity) {\n\t\treturn Hibernate.isInitialized( existingEntity );\n\t}\n\n\t/**\n\t * Check the version of the object in the {@code RowProcessingState} against\n\t * the object version in the session cache, throwing an exception\n\t * if the version numbers are different\n\t */\n\tprivate void checkVersion(\n\t\t\tEntityInitializerData data,\n\t\t\tEntityEntry entry,\n\t\t\tfinal RowProcessingState rowProcessingState) throws HibernateException {\n\t\tfinal Object version = entry.getVersion();\n\t\tif ( version != null ) {\n\t\t\t// null version means the object is in the process of being loaded somewhere else in the ResultSet\n\t\t\tfinal Object currentVersion = versionAssembler.assemble( rowProcessingState );\n\t\t\tif ( !data.concreteDescriptor.getVersionType().isEqual( version, currentVersion ) ) {\n\t\t\t\tfinal StatisticsImplementor statistics = rowProcessingState.getSession().getFactory().getStatistics();\n\t\t\t\tif ( statistics.isStatisticsEnabled() ) {\n\t\t\t\t\tstatistics.optimisticFailure( data.concreteDescriptor.getEntityName() );\n\t\t\t\t}\n\t\t\t\tthrow new StaleObjectStateException( data.concreteDescriptor.getEntityName(), entry.getId() );\n\t\t\t}\n\t\t}\n\n\t}\n\n\t/**\n\t * Used by Hibernate Reactive\n\t */\n\tprotected Object resolveEntityInstance2(EntityInitializerData data) {\n\t\tif ( data.entityHolder.getEntityInitializer() == this ) {\n\t\t\tassert data.entityHolder.getEntity() == null;\n\t\t\treturn resolveEntityInstance( data );\n\t\t}\n\t\telse {\n\t\t\t// the entity is already being loaded elsewhere\n\t\t\treturn data.entityHolder.getEntity();\n\t\t}\n\t}\n\n\tprotected Object resolveEntityInstance(EntityInitializerData data) {\n\t\tfinal RowProcessingState rowProcessingState = data.getRowProcessingState();\n\t\tfinal Object resolved = resolveToOptionalInstance( data );\n\t\tif ( resolved != null ) {\n\t\t\tregisterLoadingEntity( data, resolved );\n\t\t\treturn resolved;\n\t\t}\n\t\telse {\n\t\t\tif ( rowProcessingState.isQueryCacheHit() && entityDescriptor.useShallowQueryCacheLayout() ) {\n\t\t\t\t// We must load the entity this way, because the query cache entry contains only the primary key\n\t\t\t\tdata.setState( State.INITIALIZED );\n\t\t\t\tfinal SharedSessionContractImplementor session = rowProcessingState.getSession();\n\t\t\t\tassert data.entityHolder.getEntityInitializer() == this;\n\t\t\t\t// If this initializer owns the entity, we have to remove the entity holder,\n\t\t\t\t// because the subsequent loading process will claim the entity\n\t\t\t\trowProcessingState.getJdbcValuesSourceProcessingState().getLoadingEntityHolders().remove( data.entityHolder );\n\t\t\t\tsession.getPersistenceContextInternal().removeEntityHolder( data.entityKey );\n\t\t\t\treturn session.internalLoad(\n\t\t\t\t\t\tdata.concreteDescriptor.getEntityName(),\n\t\t\t\t\t\tdata.entityKey.getIdentifier(),\n\t\t\t\t\t\ttrue,\n\t\t\t\t\t\tfalse\n\t\t\t\t);\n\t\t\t}\n\t\t\t// We have to query the second level cache if reference cache entries are used\n\t\t\telse if ( entityDescriptor.canUseReferenceCacheEntries() ) {\n\t\t\t\tfinal Object cached = resolveInstanceFromCache( data );\n\t\t\t\tif ( cached != null ) {\n\t\t\t\t\t// EARLY EXIT!!!\n\t\t\t\t\t// because the second level cache has reference cache entries, the entity is initialized\n\t\t\t\t\tdata.setState( State.INITIALIZED );\n\t\t\t\t\treturn cached;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfinal Object instance = instantiateEntity( data );\n\t\t\tregisterLoadingEntity( data, instance );\n\t\t\treturn instance;\n\t\t}\n\t}\n\n\tprotected Object instantiateEntity(EntityInitializerData data) {\n\t\treturn data.getRowProcessingState().getSession().instantiate(\n\t\t\t\tdata.concreteDescriptor,\n\t\t\t\tdata.entityKey.getIdentifier()\n\t\t);\n\t}\n\n\tprivate Object resolveToOptionalInstance(EntityInitializerData data) {\n\t\tif ( isResultInitializer() ) {\n\t\t\t// this isEntityReturn bit is just for entity loaders, not hql/criteria\n\t\t\tfinal JdbcValuesSourceProcessingOptions processingOptions =\n\t\t\t\t\tdata.getRowProcessingState().getJdbcValuesSourceProcessingState().getProcessingOptions();\n\t\t\treturn matchesOptionalInstance( data, processingOptions ) ? processingOptions.getEffectiveOptionalObject() : null;\n\t\t}\n\t\telse {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tprivate boolean matchesOptionalInstance(\n\t\t\tEntityInitializerData data,\n\t\t\tJdbcValuesSourceProcessingOptions processingOptions) {\n\t\tfinal Object optionalEntityInstance = processingOptions.getEffectiveOptionalObject();\n\t\tfinal Object requestedEntityId = processingOptions.getEffectiveOptionalId();\n\t\treturn requestedEntityId != null\n\t\t\t\t&& optionalEntityInstance != null\n\t\t\t\t&& areKeysEqual( requestedEntityId, data.entityKey.getIdentifier() );\n\t}\n\n\tprivate Object resolveInstanceFromCache(EntityInitializerData data) {\n\t\treturn CacheEntityLoaderHelper.INSTANCE.loadFromSecondLevelCache(\n\t\t\t\tdata.getRowProcessingState().getSession().asEventSource(),\n\t\t\t\tnull,\n\t\t\t\tdata.lockMode,\n\t\t\t\tentityDescriptor,\n\t\t\t\tdata.entityKey\n\t\t);\n\t}\n\n\tprotected void registerLoadingEntity(EntityInitializerData data, Object instance) {\n\t\tfinal RowProcessingState rowProcessingState = data.getRowProcessingState();\n\t\trowProcessingState.getSession().getPersistenceContextInternal().claimEntityHolderIfPossible(\n\t\t\t\tdata.entityKey,\n\t\t\t\tinstance,\n\t\t\t\trowProcessingState.getJdbcValuesSourceProcessingState(),\n\t\t\t\tthis\n\t\t);\n\t}\n\n\tprotected void registerReloadedEntity(EntityInitializerData data) {\n\t\tif ( data.hasCallbackActions ) {\n\t\t\t// This is only needed for follow-on locking, so skip registering the entity if there is no callback\n\t\t\tdata.entityHolder.markAsReloaded( data.getRowProcessingState().getJdbcValuesSourceProcessingState() );\n\t\t}\n\t}\n\n\t@Override\n\tpublic void initializeInstance(EntityInitializerData data) {\n\t\tif ( data.getState() != State.RESOLVED ) {\n\t\t\treturn;\n\t\t}\n\t\tif ( !skipInitialization( data ) ) {\n\t\t\tassert consistentInstance( data );\n\t\t\tinitializeEntityInstance( data );\n\t\t}\n\t\tdata.setState( State.INITIALIZED );\n\t}\n\n\tprotected boolean consistentInstance(EntityInitializerData data) {\n\t\tfinal PersistenceContext persistenceContextInternal =\n\t\t\t\tdata.getRowProcessingState().getSession().getPersistenceContextInternal();\n\t\t// Only call PersistenceContext#getEntity within the assert expression, as it is costly\n\t\tfinal Object entity = persistenceContextInternal.getEntity( data.entityKey );\n\t\treturn entity == null || entity == data.entityInstanceForNotify;\n\t}\n\n\tprotected void initializeEntityInstance(EntityInitializerData data) {\n\t\tfinal RowProcessingState rowProcessingState = data.getRowProcessingState();\n\t\tfinal SharedSessionContractImplementor session = rowProcessingState.getSession();\n\t\tfinal PersistenceContext persistenceContext = session.getPersistenceContextInternal();\n\t\tfinal EntityKey entityKey = data.entityKey;\n\t\tassert entityKey != null;\n\n\t\tfinal Object entityIdentifier = entityKey.getIdentifier();\n\t\tfinal Object[] resolvedEntityState = extractConcreteTypeStateValues( data );\n\n\t\tpreLoad( data, resolvedEntityState );\n\n\t\tfinal Object entityInstanceForNotify = data.entityInstanceForNotify;\n\t\tif ( isPersistentAttributeInterceptable( entityInstanceForNotify ) ) {\n\t\t\tfinal PersistentAttributeInterceptor persistentAttributeInterceptor =\n\t\t\t\t\tasPersistentAttributeInterceptable( entityInstanceForNotify ).$$_hibernate_getInterceptor();\n\t\t\tif ( persistentAttributeInterceptor == null\n\t\t\t\t\t|| persistentAttributeInterceptor instanceof EnhancementAsProxyLazinessInterceptor ) {\n\t\t\t\t// if we do this after the entity has been initialized the\n\t\t\t\t// BytecodeLazyAttributeInterceptor#isAttributeLoaded(String fieldName) would return false;\n\t\t\t\tdata.concreteDescriptor.getBytecodeEnhancementMetadata()\n\t\t\t\t\t\t.injectInterceptor( entityInstanceForNotify, entityIdentifier, session );\n\t\t\t}\n\t\t}\n\t\tdata.concreteDescriptor.setPropertyValues( entityInstanceForNotify, resolvedEntityState );\n\n\t\tpersistenceContext.addEntity( entityKey, entityInstanceForNotify );\n\n\t\t// Also register possible unique key entries\n\t\tregisterPossibleUniqueKeyEntries( data, resolvedEntityState, session );\n\n\t\tfinal Object version = versionAssembler != null ? versionAssembler.assemble( rowProcessingState ) : null;\n\t\tfinal Object rowId = rowIdAssembler != null ? rowIdAssembler.assemble( rowProcessingState ) : null;\n\n\t\t// from the perspective of Hibernate, an entity is read locked as soon as it is read\n\t\t// so regardless of the requested lock mode, we upgrade to at least the read level\n\t\tfinal LockMode lockModeToAcquire = data.lockMode == LockMode.NONE ? LockMode.READ : data.lockMode;\n\n\t\tfinal EntityEntry entityEntry = persistenceContext.addEntry(\n\t\t\t\tentityInstanceForNotify,\n\t\t\t\tStatus.LOADING,\n\t\t\t\tresolvedEntityState,\n\t\t\t\trowId,\n\t\t\t\tentityIdentifier,\n\t\t\t\tversion,\n\t\t\t\tlockModeToAcquire,\n\t\t\t\ttrue,\n\t\t\t\tdata.concreteDescriptor,\n\t\t\t\tfalse\n\t\t);\n\t\tentityEntry.setMaybeLazySet( maybeLazySets[data.concreteDescriptor.getSubclassId()] );\n\t\tdata.entityHolder.setEntityEntry( entityEntry );\n\n\t\tregisterNaturalIdResolution( data, persistenceContext, resolvedEntityState );\n\n\t\ttakeSnapshot( data, session, persistenceContext, entityEntry, resolvedEntityState );\n\n\t\tdata.concreteDescriptor.afterInitialize( entityInstanceForNotify, session );\n\n\t\tassert data.concreteDescriptor.getIdentifier( entityInstanceForNotify, session ) != null;\n\n\t\tfinal StatisticsImplementor statistics = session.getFactory().getStatistics();\n\t\tif ( statistics.isStatisticsEnabled() ) {\n\t\t\tif ( !rowProcessingState.isQueryCacheHit() ) {\n\t\t\t\tstatistics.loadEntity( data.concreteDescriptor.getEntityName() );\n\t\t\t}\n\t\t}\n\t\tupdateCaches(\n\t\t\t\tdata,\n\t\t\t\tsession,\n\t\t\t\tsession.getPersistenceContextInternal(),\n\t\t\t\tresolvedEntityState,\n\t\t\t\tversion\n\t\t);\n\t}\n\n\tprotected void updateCaches(\n\t\t\tEntityInitializerData data,\n\t\t\tSharedSessionContractImplementor session,\n\t\t\tPersistenceContext persistenceContext,\n\t\t\tObject[] resolvedEntityState,\n\t\t\tObject version) {\n\t\tif ( data.concreteDescriptor.canWriteToCache()\n\t\t\t\t// No need to put into the entity cache if this is coming from the query cache already\n\t\t\t\t&& !data.getRowProcessingState().isQueryCacheHit()\n\t\t\t\t&& session.getCacheMode().isPutEnabled() ) {\n\t\t\tfinal EntityDataAccess cacheAccess = data.concreteDescriptor.getCacheAccessStrategy();\n\t\t\tif ( cacheAccess != null  ) {\n\t\t\t\tputInCache( data, session, persistenceContext, resolvedEntityState, version, cacheAccess );\n\t\t\t}\n\t\t}\n\t}\n\n\tprotected void registerNaturalIdResolution(\n\t\t\tEntityInitializerData data,\n\t\t\tPersistenceContext persistenceContext,\n\t\t\tObject[] resolvedEntityState) {\n\t\tif ( entityDescriptor.getNaturalIdMapping() != null ) {\n\t\t\tfinal Object naturalId =\n\t\t\t\t\tentityDescriptor.getNaturalIdMapping().extractNaturalIdFromEntityState( resolvedEntityState );\n\t\t\tpersistenceContext.getNaturalIdResolutions()\n\t\t\t\t\t.cacheResolutionFromLoad( data.entityKey.getIdentifier(), naturalId, entityDescriptor );\n\t\t}\n\t}\n\n\tprotected void takeSnapshot(\n\t\t\tEntityInitializerData data,\n\t\t\tSharedSessionContractImplementor session,\n\t\t\tPersistenceContext persistenceContext,\n\t\t\tEntityEntry entityEntry,\n\t\t\tObject[] resolvedEntityState) {\n\t\tif ( isReallyReadOnly( data, session ) ) {\n\t\t\t//no need to take a snapshot - this is a\n\t\t\t//performance optimization, but not really\n\t\t\t//important, except for entities with huge\n\t\t\t//mutable property values\n\t\t\tpersistenceContext.setEntryStatus( entityEntry, Status.READ_ONLY );\n\t\t}\n\t\telse {\n\t\t\t//take a snapshot\n\t\t\tdeepCopy( data.concreteDescriptor, resolvedEntityState, resolvedEntityState );\n\t\t\tpersistenceContext.setEntryStatus( entityEntry, Status.MANAGED );\n\t\t}\n\t}\n\n\tprivate boolean isReallyReadOnly(EntityInitializerData data, SharedSessionContractImplementor session) {\n\t\tif ( !data.concreteDescriptor.isMutable() ) {\n\t\t\treturn true;\n\t\t}\n\t\telse {\n\t\t\tfinal LazyInitializer lazyInitializer = extractLazyInitializer( data.getInstance() );\n\t\t\tif ( lazyInitializer != null ) {\n\t\t\t\t// there is already a proxy for this impl\n\t\t\t\t// only set the status to read-only if the proxy is read-only\n\t\t\t\treturn lazyInitializer.isReadOnly();\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn isReadOnly( data.getRowProcessingState(), session );\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate void putInCache(\n\t\t\tEntityInitializerData data,\n\t\t\tSharedSessionContractImplementor session,\n\t\t\tPersistenceContext persistenceContext,\n\t\t\tObject[] resolvedEntityState,\n\t\t\tObject version,\n\t\t\tEntityDataAccess cacheAccess) {\n\t\tfinal SessionFactoryImplementor factory = session.getFactory();\n\n\t\tfinal CacheEntry cacheEntry = data.concreteDescriptor.buildCacheEntry(\n\t\t\t\tdata.entityInstanceForNotify,\n\t\t\t\tresolvedEntityState,\n\t\t\t\tversion,\n\t\t\t\tsession\n\t\t);\n\t\tfinal Object cacheKey = cacheAccess.generateCacheKey(\n\t\t\t\tdata.entityKey.getIdentifier(),\n\t\t\t\trootEntityDescriptor,\n\t\t\t\tfactory,\n\t\t\t\tsession.getTenantIdentifier()\n\t\t);\n\n\t\t// explicit handling of caching for rows just inserted and then somehow forced to be read\n\t\t// from the database *within the same transaction*.  usually this is done by\n\t\t// \t\t1) Session#refresh, or\n\t\t// \t\t2) Session#clear + some form of load\n\t\t//\n\t\t// we need to be careful not to clobber the lock here in the cache so that it can be rolled back if need be\n\t\tfinal EventManager eventManager = session.getEventManager();\n\t\tif ( persistenceContext.wasInsertedDuringTransaction( data.concreteDescriptor, data.entityKey.getIdentifier() ) ) {\n\t\t\tboolean update = false;\n\t\t\tfinal HibernateMonitoringEvent cachePutEvent = eventManager.beginCachePutEvent();\n\t\t\ttry {\n\t\t\t\tupdate = cacheAccess.update(\n\t\t\t\t\t\tsession,\n\t\t\t\t\t\tcacheKey,\n\t\t\t\t\t\tdata.concreteDescriptor.getCacheEntryStructure().structure( cacheEntry ),\n\t\t\t\t\t\tversion,\n\t\t\t\t\t\tversion\n\t\t\t\t);\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeCachePutEvent(\n\t\t\t\t\t\tcachePutEvent,\n\t\t\t\t\t\tsession,\n\t\t\t\t\t\tcacheAccess,\n\t\t\t\t\t\tdata.concreteDescriptor,\n\t\t\t\t\t\tupdate,\n\t\t\t\t\t\tEventManager.CacheActionDescription.ENTITY_UPDATE\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tfinal SessionEventListenerManager eventListenerManager = session.getEventListenerManager();\n\t\t\tboolean put = false;\n\t\t\tfinal HibernateMonitoringEvent cachePutEvent = eventManager.beginCachePutEvent();\n\t\t\ttry {\n\t\t\t\teventListenerManager.cachePutStart();\n\t\t\t\tput = cacheAccess.putFromLoad(\n\t\t\t\t\t\tsession,\n\t\t\t\t\t\tcacheKey,\n\t\t\t\t\t\tdata.concreteDescriptor.getCacheEntryStructure().structure( cacheEntry ),\n\t\t\t\t\t\tversion,\n\t\t\t\t\t\t//useMinimalPuts( session, entityEntry )\n\t\t\t\t\t\tfalse\n\t\t\t\t);\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeCachePutEvent(\n\t\t\t\t\t\tcachePutEvent,\n\t\t\t\t\t\tsession,\n\t\t\t\t\t\tcacheAccess,\n\t\t\t\t\t\tdata.concreteDescriptor,\n\t\t\t\t\t\tput,\n\t\t\t\t\t\tEventManager.CacheActionDescription.ENTITY_LOAD\n\t\t\t\t);\n\t\t\t\tfinal StatisticsImplementor statistics = factory.getStatistics();\n\t\t\t\tif ( put && statistics.isStatisticsEnabled() ) {\n\t\t\t\t\tstatistics.entityCachePut( rootEntityDescriptor.getNavigableRole(), cacheAccess.getRegion().getName() );\n\t\t\t\t}\n\t\t\t\teventListenerManager.cachePutEnd();\n\t\t\t}\n\t\t}\n\t}\n\n\tprotected void registerPossibleUniqueKeyEntries(\n\t\t\tEntityInitializerData data,\n\t\t\tObject[] resolvedEntityState,\n\t\t\tfinal SharedSessionContractImplementor session) {\n\t\tfor ( UniqueKeyEntry entry : data.concreteDescriptor.uniqueKeyEntries() ) {\n\t\t\tfinal String ukName = entry.getUniqueKeyName();\n\t\t\tfinal int index = entry.getStateArrayPosition();\n\t\t\tfinal Type type = entry.getPropertyType();\n\n\t\t\t// polymorphism not really handled completely correctly,\n\t\t\t// perhaps...well, actually its ok, assuming that the\n\t\t\t// entity name used in the lookup is the same as the\n\t\t\t// one used here, which it will be\n\n\t\t\tif ( resolvedEntityState[index] != null ) {\n\t\t\t\tfinal EntityUniqueKey entityUniqueKey = new EntityUniqueKey(\n\t\t\t\t\t\tdata.concreteDescriptor.getRootEntityDescriptor().getEntityName(),\n\t\t\t\t\t\t//polymorphism comment above\n\t\t\t\t\t\tukName,\n\t\t\t\t\t\tresolvedEntityState[index],\n\t\t\t\t\t\ttype,\n\t\t\t\t\t\tsession.getFactory()\n\t\t\t\t);\n\t\t\t\tsession.getPersistenceContextInternal().addEntity( entityUniqueKey, data.entityInstanceForNotify );\n\t\t\t}\n\t\t}\n\t}\n\n\tprotected Object[] extractConcreteTypeStateValues(EntityInitializerData data) {\n\t\tfinal RowProcessingState rowProcessingState = data.getRowProcessingState();\n\t\tfinal Object[] values = new Object[data.concreteDescriptor.getNumberOfAttributeMappings()];\n\t\tfinal DomainResultAssembler<?>[] concreteAssemblers = assemblers[data.concreteDescriptor.getSubclassId()];\n\t\tfor ( int i = 0; i < values.length; i++ ) {\n\t\t\tfinal DomainResultAssembler<?> assembler = concreteAssemblers[i];\n\t\t\tvalues[i] = assembler == null ? UNFETCHED_PROPERTY : assembler.assemble( rowProcessingState );\n\t\t}\n\t\treturn values;\n\t}\n\n\t@Override\n\tpublic void resolveState(EntityInitializerData data) {\n\t\tif ( identifierAssembler != null ) {\n\t\t\tidentifierAssembler.resolveState( data.getRowProcessingState() );\n\t\t}\n\t\tif ( discriminatorAssembler != null ) {\n\t\t\tdiscriminatorAssembler.resolveState( data.getRowProcessingState() );\n\t\t}\n\t\tif ( keyAssembler != null ) {\n\t\t\tkeyAssembler.resolveState( data.getRowProcessingState() );\n\t\t}\n\t\tif ( versionAssembler != null ) {\n\t\t\tversionAssembler.resolveState( data.getRowProcessingState() );\n\t\t}\n\t\tif ( rowIdAssembler != null ) {\n\t\t\trowIdAssembler.resolveState( data.getRowProcessingState() );\n\t\t}\n\t\tresolveEntityState( data );\n\t}\n\n\tprotected void resolveEntityState(EntityInitializerData data) {\n\t\tfinal RowProcessingState rowProcessingState = data.getRowProcessingState();\n\t\tfor ( final DomainResultAssembler<?> assembler : assemblers[data.concreteDescriptor.getSubclassId()] ) {\n\t\t\tif ( assembler != null ) {\n\t\t\t\tassembler.resolveState( rowProcessingState );\n\t\t\t}\n\t\t}\n\t}\n\n\tprotected boolean skipInitialization(EntityInitializerData data) {\n\t\tif ( data.entityHolder.getEntityInitializer() != this ) {\n\t\t\treturn true;\n\t\t}\n\t\tfinal RowProcessingState rowProcessingState = data.getRowProcessingState();\n\t\tfinal EntityEntry entry = data.entityHolder.getEntityEntry();\n\t\tassert entry == rowProcessingState.getSession().getPersistenceContextInternal().getEntry( data.entityInstanceForNotify );\n\t\tif ( entry == null ) {\n\t\t\treturn false;\n\t\t}\n\t\t// todo (6.0): do we really need this check ?\n\t\telse if ( entry.getStatus().isDeletedOrGone() ) {\n\t\t\treturn true;\n\t\t}\n\t\telse {\n\t\t\tif ( isPersistentAttributeInterceptable( data.entityInstanceForNotify ) ) {\n\t\t\t\tfinal PersistentAttributeInterceptor interceptor =\n\t\t\t\t\t\tasPersistentAttributeInterceptable( data.entityInstanceForNotify ).$$_hibernate_getInterceptor();\n\t\t\t\tif ( interceptor instanceof EnhancementAsProxyLazinessInterceptor ) {\n\t\t\t\t\t// Avoid loading the same entity proxy twice for the same result set: it could lead to errors,\n\t\t\t\t\t// because some code writes to its input (ID in hydrated state replaced by the loaded entity, in particular).\n\t\t\t\t\treturn entry.getStatus() == Status.LOADING;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If the instance to initialize is the main entity, we can't skip this.\n\t\t\t// This can happen if we initialize an enhanced proxy.\n\t\t\tif ( entry.getStatus() != Status.LOADING ) {\n\t\t\t\t// If the instance to initialize is the main entity, we can't skip this.\n\t\t\t\t// This can happen if we initialize an enhanced proxy.\n\t\t\t\treturn rowProcessingState.getJdbcValuesSourceProcessingState().getProcessingOptions()\n\t\t\t\t\t\t.getEffectiveOptionalObject() != data.entityInstanceForNotify;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate boolean isReadOnly(RowProcessingState rowProcessingState, SharedSessionContractImplementor persistenceContext) {\n\t\tfinal Boolean readOnly = rowProcessingState.getQueryOptions().isReadOnly();\n\t\treturn readOnly == null ? persistenceContext.isDefaultReadOnly() : readOnly;\n\t}\n\n\tprotected void preLoad(EntityInitializerData data, Object[] resolvedEntityState) {\n\t\tfinal RowProcessingState rowProcessingState = data.getRowProcessingState();\n\t\tfinal SharedSessionContractImplementor session = rowProcessingState.getSession();\n\t\tif ( session.isEventSource() ) {\n\t\t\tfinal PreLoadEvent preLoadEvent = rowProcessingState.getJdbcValuesSourceProcessingState().getPreLoadEvent();\n\t\t\tassert preLoadEvent != null;\n\n\t\t\tpreLoadEvent.reset();\n\n\t\t\tpreLoadEvent.setEntity( data.getInstance() )\n\t\t\t\t\t.setState( resolvedEntityState )\n\t\t\t\t\t.setId( data.entityKey.getIdentifier() )\n\t\t\t\t\t.setPersister( data.concreteDescriptor );\n\n\t\t\tsession.getFactory()\n\t\t\t\t\t.getFastSessionServices()\n\t\t\t\t\t.eventListenerGroup_PRE_LOAD\n\t\t\t\t\t.fireEventOnEachListener( preLoadEvent, PreLoadEventListener::onPreLoad );\n\t\t}\n\t}\n\n\t@Override\n\tpublic boolean isPartOfKey() {\n\t\treturn isPartOfKey;\n\t}\n\n\t@Override\n\tpublic boolean isEager() {\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean hasEagerSubInitializers() {\n\t\treturn hasEagerSubInitializers;\n\t}\n\n\tpublic boolean isPreviousRowReuse() {\n\t\treturn previousRowReuse;\n\t}\n\n\t@Override\n\tpublic EntityPersister getConcreteDescriptor(EntityInitializerData data) {\n\t\tassert data.getState() != State.UNINITIALIZED;\n\t\treturn data.concreteDescriptor == null ? entityDescriptor : data.concreteDescriptor;\n\t}\n\n\tprotected void initializeSubInstancesFromParent(EntityInitializerData data) {\n\t\tif ( data.entityInstanceForNotify != null ) {\n\t\t\tfor ( Initializer<?> initializer : subInitializers[data.concreteDescriptor.getSubclassId()] ) {\n\t\t\t\tif (initializer != null) {\n\t\t\t\t\tinitializer.initializeInstanceFromParent( data.entityInstanceForNotify, data.getRowProcessingState() );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tprotected void forEachSubInitializer(BiConsumer<Initializer<?>, RowProcessingState> consumer, InitializerData data) {\n\t\tfinal RowProcessingState rowProcessingState = data.getRowProcessingState();\n\t\tif ( keyAssembler != null ) {\n\t\t\tfinal Initializer<?> initializer = keyAssembler.getInitializer();\n\t\t\tif ( initializer != null ) {\n\t\t\t\tconsumer.accept( initializer, rowProcessingState );\n\t\t\t}\n\t\t}\n\t\tif ( identifierAssembler != null ) {\n\t\t\tfinal Initializer<?> initializer = identifierAssembler.getInitializer();\n\t\t\tif ( initializer != null ) {\n\t\t\t\tconsumer.accept( initializer, rowProcessingState );\n\t\t\t}\n\t\t}\n\t\tfinal EntityInitializerData entityInitializerData = (EntityInitializerData) data;\n\t\tif ( entityInitializerData.concreteDescriptor == null ) {\n\t\t\tfor ( Initializer<?>[] initializers : subInitializers ) {\n\t\t\t\tfor ( Initializer<?> initializer : initializers ) {\n\t\t\t\t\tif ( initializer != null ) {\n\t\t\t\t\t\tconsumer.accept( initializer, rowProcessingState );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tfor ( Initializer<?> initializer : subInitializers[entityInitializerData.concreteDescriptor.getSubclassId()] ) {\n\t\t\t\tif ( initializer != null ) {\n\t\t\t\t\tconsumer.accept( initializer, rowProcessingState );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn \"EntityJoinedFetchInitializer(\" + LoggingHelper.toLoggableString( getNavigablePath() ) + \")\";\n\t}\n\n\t//#########################\n\t// For Hibernate Reactive\n\t//#########################\n\n\tprotected @Nullable DomainResultAssembler<?> getVersionAssembler() {\n\t\treturn versionAssembler;\n\t}\n\n\tprotected @Nullable DomainResultAssembler<Object> getRowIdAssembler() {\n\t\treturn rowIdAssembler;\n\t}\n\n\tprotected @Nullable DomainResultAssembler<?>[][] getAssemblers() {\n\t\treturn assemblers;\n\t}\n\n\tprotected @Nullable BasicResultAssembler<?> getDiscriminatorAssembler() {\n\t\treturn discriminatorAssembler;\n\t}\n\n\tprotected boolean isKeyManyToOne() {\n\t\treturn hasKeyManyToOne;\n\t}\n\n\tprotected Initializer<?>[][] getSubInitializers() {\n\t\treturn subInitializers;\n\t}\n\n\tpublic @Nullable DomainResultAssembler<?> getKeyAssembler() {\n\t\treturn keyAssembler;\n\t}\n}\n",
        "diffSourceCodeSet": [],
        "invokedMethodSet": [
            "methodSignature: org.hibernate.action.internal.EntityUpdateAction#getState\n methodBody: protected Object[] getState() {\nreturn state;\n}"
        ],
        "sourceCodeAfterRefactoring": "@Override\n\tpublic void resolveInstance(EntityInitializerData data) {\n\t\tif ( data.getState() != State.KEY_RESOLVED ) {\n\t\t\treturn;\n\t\t}\n\t\tfinal RowProcessingState rowProcessingState = data.getRowProcessingState();\n\t\tdata.setState( State.RESOLVED );\n\t\tif ( data.entityKey == null ) {\n\t\t\tassert identifierAssembler != null;\n\t\t\tfinal Object id = identifierAssembler.assemble( rowProcessingState );\n\t\t\tif ( id == null ) {\n\t\t\t\tsetMissing( data );\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresolveEntityKey( data, id );\n\t\t}\n\t\tfinal PersistenceContext persistenceContext = rowProcessingState.getSession()\n\t\t\t\t.getPersistenceContextInternal();\n\t\tdata.entityHolder = persistenceContext.claimEntityHolderIfPossible(\n\t\t\t\tdata.entityKey,\n\t\t\t\tnull,\n\t\t\t\trowProcessingState.getJdbcValuesSourceProcessingState(),\n\t\t\t\tthis\n\t\t);\n\n\t\tif ( useEmbeddedIdentifierInstanceAsEntity( data ) ) {\n\t\t\tdata.setInstance( data.entityInstanceForNotify = rowProcessingState.getEntityId() );\n\t\t}\n\t\telse {\n\t\t\tresolveEntityInstance1( data );\n\t\t\tif ( data.uniqueKeyAttributePath != null ) {\n\t\t\t\tfinal SharedSessionContractImplementor session = rowProcessingState.getSession();\n\t\t\t\tfinal EntityPersister concreteDescriptor = getConcreteDescriptor( data );\n\t\t\t\tfinal EntityUniqueKey euk = new EntityUniqueKey(\n\t\t\t\t\t\tconcreteDescriptor.getEntityName(),\n\t\t\t\t\t\tdata.uniqueKeyAttributePath,\n\t\t\t\t\t\trowProcessingState.getEntityUniqueKey(),\n\t\t\t\t\t\tdata.uniqueKeyPropertyTypes[concreteDescriptor.getSubclassId()],\n\t\t\t\t\t\tsession.getFactory()\n\t\t\t\t);\n\t\t\t\tsession.getPersistenceContextInternal().addEntity( euk, data.getInstance() );\n\t\t\t}\n\t\t}\n\n\t\tif ( data.getInstance() != null ) {\n\t\t\tupgradeLockMode( data );\n\t\t\tif ( data.getState() == State.INITIALIZED ) {\n\t\t\t\tregisterReloadedEntity( data );\n\t\t\t\tif ( rowProcessingState.needsResolveState() ) {\n\t\t\t\t\t// We need to read result set values to correctly populate the query cache\n\t\t\t\t\tresolveEntityState( data );\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( data.shallowCached ) {\n\t\t\t\tinitializeSubInstancesFromParent( data );\n\t\t\t}\n\t\t}\n\t}",
        "diffSourceCode": "-  231: \t\t}\n-  232: \n-  233: \t\trowIdAssembler = rowIdResult != null\n-  234: \t\t\t\t? rowIdResult.createResultAssembler( this, creationState )\n-  820: \t@Override\n-  821: \tpublic void resolveInstance(EntityInitializerData data) {\n-  822: \t\tif ( data.getState() != State.KEY_RESOLVED ) {\n-  823: \t\t\treturn;\n-  824: \t\t}\n+  231: \t\tthis.navigablePath = resultDescriptor.getNavigablePath();\n+  232: \t\tthis.sourceAlias = sourceAlias;\n+  233: \t\tthis.parent = parent;\n+  234: \t\tthis.isResultInitializer = isResultInitializer;\n+  820: \t\t\tsetMissing( data );\n+  821: \t\t\treturn;\n+  822: \t\t}\n+  823: \t\tdata.setInstance( instance );\n+  824: \t\tfinal LazyInitializer lazyInitializer = extractLazyInitializer( instance );\n   825: \t\tfinal RowProcessingState rowProcessingState = data.getRowProcessingState();\n-  826: \t\tdata.setState( State.RESOLVED );\n-  827: \t\tif ( data.entityKey == null ) {\n-  828: \t\t\tassert identifierAssembler != null;\n-  829: \t\t\tfinal Object id = identifierAssembler.assemble( rowProcessingState );\n-  830: \t\t\tif ( id == null ) {\n-  831: \t\t\t\tsetMissing( data );\n-  832: \t\t\t\treturn;\n-  833: \t\t\t}\n-  834: \t\t\tresolveEntityKey( data, id );\n-  835: \t\t}\n-  836: \t\tfinal PersistenceContext persistenceContext = rowProcessingState.getSession()\n-  837: \t\t\t\t.getPersistenceContextInternal();\n-  838: \t\tdata.entityHolder = persistenceContext.claimEntityHolderIfPossible(\n-  839: \t\t\t\tdata.entityKey,\n-  840: \t\t\t\tnull,\n-  841: \t\t\t\trowProcessingState.getJdbcValuesSourceProcessingState(),\n-  842: \t\t\t\tthis\n-  843: \t\t);\n-  844: \n-  845: \t\tif ( useEmbeddedIdentifierInstanceAsEntity( data ) ) {\n-  846: \t\t\tdata.setInstance( data.entityInstanceForNotify = rowProcessingState.getEntityId() );\n-  847: \t\t}\n-  848: \t\telse {\n-  849: \t\t\tresolveEntityInstance1( data );\n-  850: \t\t\tif ( data.uniqueKeyAttributePath != null ) {\n-  851: \t\t\t\tfinal SharedSessionContractImplementor session = rowProcessingState.getSession();\n-  852: \t\t\t\tfinal EntityPersister concreteDescriptor = getConcreteDescriptor( data );\n-  853: \t\t\t\tfinal EntityUniqueKey euk = new EntityUniqueKey(\n-  854: \t\t\t\t\t\tconcreteDescriptor.getEntityName(),\n-  855: \t\t\t\t\t\tdata.uniqueKeyAttributePath,\n-  856: \t\t\t\t\t\trowProcessingState.getEntityUniqueKey(),\n-  857: \t\t\t\t\t\tdata.uniqueKeyPropertyTypes[concreteDescriptor.getSubclassId()],\n-  858: \t\t\t\t\t\tsession.getFactory()\n-  859: \t\t\t\t);\n-  860: \t\t\t\tsession.getPersistenceContextInternal().addEntity( euk, getEntityInstance( data ) );\n-  861: \t\t\t}\n-  862: \t\t}\n-  863: \n-  864: \t\tif ( data.getInstance() != null ) {\n-  865: \t\t\tupgradeLockMode( data );\n-  866: \t\t\tif ( data.getState() == State.INITIALIZED ) {\n-  867: \t\t\t\tregisterReloadedEntity( data );\n-  868: \t\t\t\tif ( rowProcessingState.needsResolveState() ) {\n-  869: \t\t\t\t\t// We need to read result set values to correctly populate the query cache\n-  870: \t\t\t\t\tresolveState( data );\n-  871: \t\t\t\t}\n-  872: \t\t\t}\n-  873: \t\t\tif ( data.shallowCached ) {\n-  874: \t\t\t\tinitializeSubInstancesFromParent( data );\n-  875: \t\t\t}\n-  876: \t\t}\n-  877: \t}\n-  895: \t\t\t\t\tdata.setState( State.INITIALIZED );\n-  896: \t\t\t\t\tdata.entityInstanceForNotify = Hibernate.unproxy( data.getInstance() );\n-  897: \t\t\t\t}\n-  898: \t\t\t\telse {\n-  899: \t\t\t\t\tfinal LazyInitializer lazyInitializer = extractLazyInitializer( data.getInstance() );\n-  900: \t\t\t\t\tassert lazyInitializer != null;\n-  901: \t\t\t\t\tdata.entityInstanceForNotify = resolveEntityInstance2( data );\n-  902: \t\t\t\t\tlazyInitializer.setImplementation( data.entityInstanceForNotify );\n-  903: \t\t\t\t}\n-  904: \t\t\t}\n-  905: \t\t}\n-  906: \t\telse {\n-  907: \t\t\tfinal Object existingEntity = data.entityHolder.getEntity();\n-  908: \t\t\tif ( existingEntity != null ) {\n-  909: \t\t\t\tdata.setInstance( data.entityInstanceForNotify = existingEntity );\n-  910: \t\t\t\tif ( data.entityHolder.getEntityInitializer() == null ) {\n-  911: \t\t\t\t\tassert data.entityHolder.isInitialized() == isExistingEntityInitialized( existingEntity );\n-  912: \t\t\t\t\tif ( data.entityHolder.isInitialized() ) {\n-  913: \t\t\t\t\t\tdata.setState( State.INITIALIZED );\n-  914: \t\t\t\t\t}\n-  915: \t\t\t\t\telse if ( isResultInitializer() ) {\n-  916: \t\t\t\t\t\tregisterLoadingEntity( data, data.getInstance() );\n-  917: \t\t\t\t\t}\n-  918: \t\t\t\t}\n-  919: \t\t\t\telse if ( data.entityHolder.getEntityInitializer() != this ) {\n-  920: \t\t\t\t\tdata.setState( State.INITIALIZED );\n-  921: \t\t\t\t}\n-  922: \t\t\t}\n-  923: \t\t\telse if ( ( entityFromExecutionContext = getEntityFromExecutionContext( data ) ) != null ) {\n-  924: \t\t\t\t// This is the entity to refresh, so don't set the state to initialized\n-  925: \t\t\t\tdata.setInstance( data.entityInstanceForNotify = entityFromExecutionContext );\n-  926: \t\t\t\tif ( isResultInitializer() ) {\n-  927: \t\t\t\t\tregisterLoadingEntity( data, data.getInstance() );\n-  928: \t\t\t\t}\n-  929: \t\t\t}\n-  930: \t\t\telse {\n-  931: \t\t\t\tassert data.entityHolder.getEntityInitializer() == this;\n-  932: \t\t\t\t// look to see if another initializer from a parent load context or an earlier\n-  933: \t\t\t\t// initializer is already loading the entity\n-  934: \t\t\t\tdata.setInstance( data.entityInstanceForNotify = resolveEntityInstance2( data ) );\n-  935: \t\t\t\tfinal Initializer<?> idInitializer;\n-  936: \t\t\t\tif ( data.entityHolder.getEntityInitializer() == this && data.getState() != State.INITIALIZED\n-  937: \t\t\t\t\t\t&& identifierAssembler != null\n-  938: \t\t\t\t\t\t&& ( idInitializer = identifierAssembler.getInitializer() ) != null ) {\n-  939: \t\t\t\t\t// If this is the owning initializer and the returned object is not initialized,\n-  940: \t\t\t\t\t// this means that the entity instance was just instantiated.\n-  941: \t\t\t\t\t// In this case, we want to call \"assemble\" and hence \"initializeInstance\" on the initializer\n-  942: \t\t\t\t\t// for possibly non-aggregated identifier mappings, so inject the virtual id representation\n-  943: \t\t\t\t\tidInitializer.initializeInstance( data.getRowProcessingState() );\n-  944: \t\t\t\t}\n-  945: \t\t\t}\n-  946: \t\t}\n-  947: \t\t// todo: ensure we initialize the entity\n-  948: \t\tassert !data.shallowCached || data.getState() == State.INITIALIZED : \"Forgot to initialize the entity\";\n-  949: \t}\n-  950: \n-  951: \tprotected Object getEntityFromExecutionContext(EntityInitializerData data) {\n-  952: \t\tfinal RowProcessingState rowProcessingState = data.getRowProcessingState();\n+  826: \t\tfinal SharedSessionContractImplementor session = rowProcessingState.getSession();\n+  827: \t\tfinal PersistenceContext persistenceContext = session.getPersistenceContextInternal();\n+  828: \t\tif ( lazyInitializer == null ) {\n+  829: \t\t\t// Entity is most probably initialized\n+  830: \t\t\tdata.entityInstanceForNotify = instance;\n+  831: \t\t\tdata.concreteDescriptor = session.getEntityPersister( null, instance );\n+  832: \t\t\tresolveEntityKey(\n+  833: \t\t\t\t\tdata,\n+  834: \t\t\t\t\tdata.concreteDescriptor.getIdentifier( instance, session )\n+  835: \t\t\t);\n+  836: \t\t\tdata.entityHolder = persistenceContext.getEntityHolder( data.entityKey );\n+  837: \t\t\tif ( data.entityHolder == null ) {\n+  838: \t\t\t\t// Entity was most probably removed in the same session without setting the reference to null\n+  839: \t\t\t\tresolveKey( data );\n+  840: \t\t\t\tassert data.getState() == State.MISSING;\n+  841: \t\t\t\tassert referencedModelPart instanceof ToOneAttributeMapping\n+  842: \t\t\t\t\t\t&& ( (ToOneAttributeMapping) referencedModelPart ).getSideNature() == TARGET;\n+  843: \t\t\t\treturn;\n+  844: \t\t\t}\n+  845: \t\t\t// If the entity initializer is null, we know the entity is fully initialized,\n+  846: \t\t\t// otherwise it will be initialized by some other initializer\n+  847: \t\t\tdata.setState( data.entityHolder.getEntityInitializer() == null ? State.INITIALIZED : State.RESOLVED );\n+  848: \t\t}\n+  849: \t\telse if ( lazyInitializer.isUninitialized() ) {\n+  850: \t\t\tdata.setState( State.RESOLVED );\n+  851: \t\t\t// Read the discriminator from the result set if necessary\n+  852: \t\t\tdata.concreteDescriptor = discriminatorAssembler == null\n+  853: \t\t\t\t\t? entityDescriptor\n+  854: \t\t\t\t\t: determineConcreteEntityDescriptor( rowProcessingState, discriminatorAssembler, entityDescriptor );\n+  855: \t\t\tassert data.concreteDescriptor != null;\n+  856: \t\t\tresolveEntityKey( data, lazyInitializer.getIdentifier() );\n+  857: \t\t\tdata.entityHolder = persistenceContext.claimEntityHolderIfPossible(\n+  858: \t\t\t\t\tdata.entityKey,\n+  859: \t\t\t\t\tnull,\n+  860: \t\t\t\t\trowProcessingState.getJdbcValuesSourceProcessingState(),\n+  861: \t\t\t\t\tthis\n+  862: \t\t\t);\n+  863: \t\t\t// Resolve and potentially create the entity instance\n+  864: \t\t\tdata.entityInstanceForNotify = resolveEntityInstance( data );\n+  865: \t\t\tlazyInitializer.setImplementation( data.entityInstanceForNotify );\n+  866: \t\t\tregisterLoadingEntity( data, data.entityInstanceForNotify );\n+  867: \t\t}\n+  868: \t\telse {\n+  869: \t\t\tdata.setState( State.INITIALIZED );\n+  870: \t\t\tdata.entityInstanceForNotify = lazyInitializer.getImplementation();\n+  871: \t\t\tdata.concreteDescriptor = session.getEntityPersister( null, data.entityInstanceForNotify );\n+  872: \t\t\tresolveEntityKey( data, lazyInitializer.getIdentifier() );\n+  873: \t\t\tdata.entityHolder = persistenceContext.getEntityHolder( data.entityKey );\n+  874: \t\t}\n+  875: \t\tif ( identifierAssembler != null ) {\n+  876: \t\t\tfinal Initializer<?> initializer = identifierAssembler.getInitializer();\n+  877: \t\t\tif ( initializer != null ) {\n+  895: \t@Override\n+  896: \tpublic void resolveInstance(EntityInitializerData data) {\n+  897: \t\tif ( data.getState() != State.KEY_RESOLVED ) {\n+  898: \t\t\treturn;\n+  899: \t\t}\n+  900: \t\tfinal RowProcessingState rowProcessingState = data.getRowProcessingState();\n+  901: \t\tdata.setState( State.RESOLVED );\n+  902: \t\tif ( data.entityKey == null ) {\n+  903: \t\t\tassert identifierAssembler != null;\n+  904: \t\t\tfinal Object id = identifierAssembler.assemble( rowProcessingState );\n+  905: \t\t\tif ( id == null ) {\n+  906: \t\t\t\tsetMissing( data );\n+  907: \t\t\t\treturn;\n+  908: \t\t\t}\n+  909: \t\t\tresolveEntityKey( data, id );\n+  910: \t\t}\n+  911: \t\tfinal PersistenceContext persistenceContext = rowProcessingState.getSession()\n+  912: \t\t\t\t.getPersistenceContextInternal();\n+  913: \t\tdata.entityHolder = persistenceContext.claimEntityHolderIfPossible(\n+  914: \t\t\t\tdata.entityKey,\n+  915: \t\t\t\tnull,\n+  916: \t\t\t\trowProcessingState.getJdbcValuesSourceProcessingState(),\n+  917: \t\t\t\tthis\n+  918: \t\t);\n+  919: \n+  920: \t\tif ( useEmbeddedIdentifierInstanceAsEntity( data ) ) {\n+  921: \t\t\tdata.setInstance( data.entityInstanceForNotify = rowProcessingState.getEntityId() );\n+  922: \t\t}\n+  923: \t\telse {\n+  924: \t\t\tresolveEntityInstance1( data );\n+  925: \t\t\tif ( data.uniqueKeyAttributePath != null ) {\n+  926: \t\t\t\tfinal SharedSessionContractImplementor session = rowProcessingState.getSession();\n+  927: \t\t\t\tfinal EntityPersister concreteDescriptor = getConcreteDescriptor( data );\n+  928: \t\t\t\tfinal EntityUniqueKey euk = new EntityUniqueKey(\n+  929: \t\t\t\t\t\tconcreteDescriptor.getEntityName(),\n+  930: \t\t\t\t\t\tdata.uniqueKeyAttributePath,\n+  931: \t\t\t\t\t\trowProcessingState.getEntityUniqueKey(),\n+  932: \t\t\t\t\t\tdata.uniqueKeyPropertyTypes[concreteDescriptor.getSubclassId()],\n+  933: \t\t\t\t\t\tsession.getFactory()\n+  934: \t\t\t\t);\n+  935: \t\t\t\tsession.getPersistenceContextInternal().addEntity( euk, data.getInstance() );\n+  936: \t\t\t}\n+  937: \t\t}\n+  938: \n+  939: \t\tif ( data.getInstance() != null ) {\n+  940: \t\t\tupgradeLockMode( data );\n+  941: \t\t\tif ( data.getState() == State.INITIALIZED ) {\n+  942: \t\t\t\tregisterReloadedEntity( data );\n+  943: \t\t\t\tif ( rowProcessingState.needsResolveState() ) {\n+  944: \t\t\t\t\t// We need to read result set values to correctly populate the query cache\n+  945: \t\t\t\t\tresolveEntityState( data );\n+  946: \t\t\t\t}\n+  947: \t\t\t}\n+  948: \t\t\tif ( data.shallowCached ) {\n+  949: \t\t\t\tinitializeSubInstancesFromParent( data );\n+  950: \t\t\t}\n+  951: \t\t}\n+  952: \t}\n",
        "uniqueId": "72e2da2da84fae761f14ceeb822bd3e946690c78_820_877__895_952_231_234",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 0,
                "covered": 13
            },
            "BRANCH": {
                "missed": 0,
                "covered": 4
            },
            "LINE": {
                "missed": 0,
                "covered": 1
            },
            "COMPLEXITY": {
                "missed": 0,
                "covered": 3
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 11
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tpublic needsResolve() : boolean extracted from public resolve(jdbcResultsMetadata JdbcValuesMetadata, sessionFactory SessionFactoryImplementor) : SqlSelection in class org.hibernate.sql.results.internal.SqlSelectionImpl",
        "diffLocations": [
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/sql/results/internal/SqlSelectionImpl.java",
                "startLine": 152,
                "endLine": 168,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/sql/results/internal/SqlSelectionImpl.java",
                "startLine": 156,
                "endLine": 172,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/sql/results/internal/SqlSelectionImpl.java",
                "startLine": 152,
                "endLine": 154,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "@Override\n\tpublic SqlSelection resolve(JdbcValuesMetadata jdbcResultsMetadata, SessionFactoryImplementor sessionFactory) {\n\t\tif ( sqlExpression.getExpressionType() instanceof JavaObjectType ) {\n\t\t\tfinal BasicType<Object> resolvedType = jdbcResultsMetadata.resolveType(\n\t\t\t\t\tjdbcPosition,\n\t\t\t\t\tnull,\n\t\t\t\t\tsessionFactory\n\t\t\t);\n\t\t\treturn new ResolvedSqlSelection(\n\t\t\t\t\tjdbcPosition,\n\t\t\t\t\tvaluesArrayPosition,\n\t\t\t\t\tsqlExpression,\n\t\t\t\t\tresolvedType\n\t\t\t);\n\t\t}\n\t\treturn this;\n\t}",
        "filePathBefore": "hibernate-core/src/main/java/org/hibernate/sql/results/internal/SqlSelectionImpl.java",
        "isPureRefactoring": true,
        "commitId": "e9513b1db5553cec8e8bfb3a095fc3d903a747b5",
        "packageNameBefore": "org.hibernate.sql.results.internal",
        "classNameBefore": "org.hibernate.sql.results.internal.SqlSelectionImpl",
        "methodNameBefore": "org.hibernate.sql.results.internal.SqlSelectionImpl#resolve",
        "invokedMethod": "methodSignature: org.hibernate.sql.exec.internal.JdbcSelectExecutorStandardImpl.CachedJdbcValuesMetadata#resolveType\n methodBody: public <J> BasicType<J> resolveType(\n\t\t\t\tint position,\n\t\t\t\tJavaType<J> explicitJavaType,\n\t\t\t\tTypeConfiguration typeConfiguration) {\nfinal BasicType<?> type=types[position - 1];\nif(type == null){throw new IllegalStateException(\"Unexpected resolving of unavailable column at position: \" + position);\n}if(explicitJavaType == null || type.getJavaTypeDescriptor() == explicitJavaType){return (BasicType<J>)type;\n}{return typeConfiguration.getBasicTypeRegistry().resolve(explicitJavaType,type.getJdbcType());\n}}\nmethodSignature: org.hibernate.sql.exec.internal.JdbcSelectExecutorStandardImpl.CapturingJdbcValuesMetadata#resolveType\n methodBody: public <J> BasicType<J> resolveType(\n\t\t\t\tint position,\n\t\t\t\tJavaType<J> explicitJavaType,\n\t\t\t\tTypeConfiguration typeConfiguration) {\nif(columnNames == null){initializeArrays();\n}final BasicType<J> basicType=resultSetAccess.resolveType(position,explicitJavaType,typeConfiguration);\ntypes[position - 1]=basicType;\nreturn basicType;\n}\nmethodSignature: org.hibernate.sql.results.internal.SqlSelectionImpl#getExpressionType\n methodBody: public JdbcMappingContainer getExpressionType() {\nreturn getExpression().getExpressionType();\n}",
        "classSignatureBefore": "public class SqlSelectionImpl implements SqlSelection, SqlExpressionAccess ",
        "methodNameBeforeSet": [
            "org.hibernate.sql.results.internal.SqlSelectionImpl#resolve"
        ],
        "classNameBeforeSet": [
            "org.hibernate.sql.results.internal.SqlSelectionImpl"
        ],
        "classSignatureBeforeSet": [
            "public class SqlSelectionImpl implements SqlSelection, SqlExpressionAccess "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later\n * See the lgpl.txt file in the root directory or http://www.gnu.org/licenses/lgpl-2.1.html\n */\npackage org.hibernate.sql.results.internal;\n\nimport java.util.Objects;\n\nimport org.hibernate.engine.spi.SessionFactoryImplementor;\nimport org.hibernate.metamodel.mapping.JdbcMapping;\nimport org.hibernate.metamodel.mapping.JdbcMappingContainer;\nimport org.hibernate.sql.ast.SqlAstWalker;\nimport org.hibernate.sql.ast.spi.SqlExpressionAccess;\nimport org.hibernate.sql.ast.spi.SqlSelection;\nimport org.hibernate.sql.ast.tree.expression.Expression;\nimport org.hibernate.sql.results.jdbc.spi.JdbcValuesMetadata;\nimport org.hibernate.type.BasicType;\nimport org.hibernate.type.JavaObjectType;\nimport org.hibernate.type.descriptor.ValueExtractor;\nimport org.hibernate.type.descriptor.java.JavaType;\n\n/**\n * @asciidoc\n *\n * ```\n * @Entity\n * class MyEntity {\n *     ...\n *     @Column ( name = \"the_column\", ... )\n *     public String getTheColumn() { ... }\n *\n *     @Convert ( ... )\n *     @Column ( name = \"the_column\", ... )\n *     ConvertedType getTheConvertedColumn() { ... }\n *\n * }\n * ```\n *\n * @author Steve Ebersole\n */\npublic class SqlSelectionImpl implements SqlSelection, SqlExpressionAccess {\n\tprivate final int jdbcPosition;\n\tprivate final int valuesArrayPosition;\n\tprivate final Expression sqlExpression;\n\tprivate final JavaType<?> jdbcJavaType;\n\tprivate final boolean virtual;\n\tprivate transient ValueExtractor valueExtractor;\n\n\tpublic SqlSelectionImpl(Expression sqlExpression) {\n\t\tthis( 0, -1, null, sqlExpression, false );\n\t}\n\n\tpublic SqlSelectionImpl(int valuesArrayPosition, Expression sqlExpression) {\n\t\tthis( valuesArrayPosition + 1, valuesArrayPosition, null, sqlExpression, false );\n\t}\n\n\tpublic SqlSelectionImpl(int jdbcPosition, int valuesArrayPosition, Expression sqlExpression, boolean virtual) {\n\t\tthis( jdbcPosition, valuesArrayPosition, null, sqlExpression, virtual );\n\t}\n\n\tpublic SqlSelectionImpl(\n\t\t\tint jdbcPosition,\n\t\t\tint valuesArrayPosition,\n\t\t\tJavaType<?> jdbcJavaType,\n\t\t\tExpression sqlExpression,\n\t\t\tboolean virtual) {\n\t\tthis(\n\t\t\t\tjdbcPosition,\n\t\t\t\tvaluesArrayPosition,\n\t\t\t\tsqlExpression,\n\t\t\t\tjdbcJavaType,\n\t\t\t\tvirtual,\n\t\t\t\tnull\n\t\t);\n\t}\n\n\tprotected SqlSelectionImpl(\n\t\t\tint jdbcPosition,\n\t\t\tint valuesArrayPosition,\n\t\t\tExpression sqlExpression,\n\t\t\tJavaType<?> jdbcJavaType,\n\t\t\tboolean virtual,\n\t\t\tValueExtractor valueExtractor) {\n\t\tthis.jdbcPosition = jdbcPosition;\n\t\tthis.valuesArrayPosition = valuesArrayPosition;\n\t\tthis.sqlExpression = sqlExpression;\n\t\tthis.jdbcJavaType = jdbcJavaType;\n\t\tthis.virtual = virtual;\n\t\tthis.valueExtractor = valueExtractor;\n\t}\n\n\tprivate static ValueExtractor determineValueExtractor(Expression sqlExpression, JavaType<?> jdbcJavaType) {\n\t\tfinal JdbcMappingContainer expressionType = sqlExpression.getExpressionType();\n\t\tfinal JdbcMapping jdbcMapping = expressionType == null\n\t\t\t\t? JavaObjectType.INSTANCE\n\t\t\t\t: expressionType.getSingleJdbcMapping();\n\t\tif ( jdbcJavaType == null || jdbcMapping.getMappedJavaType() == jdbcJavaType ) {\n\t\t\treturn jdbcMapping.getJdbcValueExtractor();\n\t\t}\n\t\telse {\n\t\t\treturn jdbcMapping.getJdbcType().getExtractor( jdbcJavaType );\n\t\t}\n\t}\n\n\n\t@Override\n\tpublic Expression getExpression() {\n\t\treturn sqlExpression;\n\t}\n\n\t@Override\n\tpublic ValueExtractor getJdbcValueExtractor() {\n\t\tValueExtractor extractor = valueExtractor;\n\t\tif ( extractor == null ) {\n\t\t\tvalueExtractor = extractor = determineValueExtractor( sqlExpression, jdbcJavaType );\n\t\t}\n\t\treturn extractor;\n\t}\n\n\t@Override\n\tpublic int getJdbcResultSetIndex() {\n\t\treturn jdbcPosition;\n\t}\n\n\t@Override\n\tpublic int getValuesArrayPosition() {\n\t\treturn valuesArrayPosition;\n\t}\n\n\t@Override\n\tpublic JdbcMappingContainer getExpressionType() {\n\t\treturn getExpression().getExpressionType();\n\t}\n\n\t@Override\n\tpublic boolean isVirtual() {\n\t\treturn virtual;\n\t}\n\n\t@Override\n\tpublic Expression getSqlExpression() {\n\t\treturn sqlExpression;\n\t}\n\n\t@Override\n\tpublic void accept(SqlAstWalker interpreter) {\n\t\tsqlExpression.accept( interpreter );\n\t}\n\n\t@Override\n\tpublic SqlSelection resolve(JdbcValuesMetadata jdbcResultsMetadata, SessionFactoryImplementor sessionFactory) {\n\t\tif ( sqlExpression.getExpressionType() instanceof JavaObjectType ) {\n\t\t\tfinal BasicType<Object> resolvedType = jdbcResultsMetadata.resolveType(\n\t\t\t\t\tjdbcPosition,\n\t\t\t\t\tnull,\n\t\t\t\t\tsessionFactory\n\t\t\t);\n\t\t\treturn new ResolvedSqlSelection(\n\t\t\t\t\tjdbcPosition,\n\t\t\t\t\tvaluesArrayPosition,\n\t\t\t\t\tsqlExpression,\n\t\t\t\t\tresolvedType\n\t\t\t);\n\t\t}\n\t\treturn this;\n\t}\n\n\t@Override\n\tpublic boolean equals(Object o) {\n\t\tif ( this == o ) {\n\t\t\treturn true;\n\t\t}\n\t\tif ( o == null || getClass() != o.getClass() ) {\n\t\t\treturn false;\n\t\t}\n\t\tfinal SqlSelection that = (SqlSelection) o;\n\t\treturn jdbcPosition == that.getJdbcResultSetIndex() &&\n\t\t\t\tvaluesArrayPosition == that.getValuesArrayPosition() &&\n\t\t\t\tObjects.equals( sqlExpression, that.getExpression() ) &&\n\t\t\t\tvirtual == that.isVirtual();\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\treturn Objects.hash( jdbcPosition, valuesArrayPosition, sqlExpression, virtual );\n\t}\n}\n",
        "filePathAfter": "hibernate-core/src/main/java/org/hibernate/sql/results/internal/SqlSelectionImpl.java",
        "sourceCodeAfterForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later\n * See the lgpl.txt file in the root directory or http://www.gnu.org/licenses/lgpl-2.1.html\n */\npackage org.hibernate.sql.results.internal;\n\nimport java.util.Objects;\n\nimport org.hibernate.engine.spi.SessionFactoryImplementor;\nimport org.hibernate.metamodel.mapping.JdbcMapping;\nimport org.hibernate.metamodel.mapping.JdbcMappingContainer;\nimport org.hibernate.sql.ast.SqlAstWalker;\nimport org.hibernate.sql.ast.spi.SqlExpressionAccess;\nimport org.hibernate.sql.ast.spi.SqlSelection;\nimport org.hibernate.sql.ast.tree.expression.Expression;\nimport org.hibernate.sql.results.jdbc.spi.JdbcValuesMetadata;\nimport org.hibernate.type.BasicType;\nimport org.hibernate.type.JavaObjectType;\nimport org.hibernate.type.descriptor.ValueExtractor;\nimport org.hibernate.type.descriptor.java.JavaType;\n\n/**\n * @asciidoc\n *\n * ```\n * @Entity\n * class MyEntity {\n *     ...\n *     @Column ( name = \"the_column\", ... )\n *     public String getTheColumn() { ... }\n *\n *     @Convert ( ... )\n *     @Column ( name = \"the_column\", ... )\n *     ConvertedType getTheConvertedColumn() { ... }\n *\n * }\n * ```\n *\n * @author Steve Ebersole\n */\npublic class SqlSelectionImpl implements SqlSelection, SqlExpressionAccess {\n\tprivate final int jdbcPosition;\n\tprivate final int valuesArrayPosition;\n\tprivate final Expression sqlExpression;\n\tprivate final JavaType<?> jdbcJavaType;\n\tprivate final boolean virtual;\n\tprivate transient ValueExtractor valueExtractor;\n\n\tpublic SqlSelectionImpl(Expression sqlExpression) {\n\t\tthis( 0, -1, null, sqlExpression, false );\n\t}\n\n\tpublic SqlSelectionImpl(int valuesArrayPosition, Expression sqlExpression) {\n\t\tthis( valuesArrayPosition + 1, valuesArrayPosition, null, sqlExpression, false );\n\t}\n\n\tpublic SqlSelectionImpl(int jdbcPosition, int valuesArrayPosition, Expression sqlExpression, boolean virtual) {\n\t\tthis( jdbcPosition, valuesArrayPosition, null, sqlExpression, virtual );\n\t}\n\n\tpublic SqlSelectionImpl(\n\t\t\tint jdbcPosition,\n\t\t\tint valuesArrayPosition,\n\t\t\tJavaType<?> jdbcJavaType,\n\t\t\tExpression sqlExpression,\n\t\t\tboolean virtual) {\n\t\tthis(\n\t\t\t\tjdbcPosition,\n\t\t\t\tvaluesArrayPosition,\n\t\t\t\tsqlExpression,\n\t\t\t\tjdbcJavaType,\n\t\t\t\tvirtual,\n\t\t\t\tnull\n\t\t);\n\t}\n\n\tprotected SqlSelectionImpl(\n\t\t\tint jdbcPosition,\n\t\t\tint valuesArrayPosition,\n\t\t\tExpression sqlExpression,\n\t\t\tJavaType<?> jdbcJavaType,\n\t\t\tboolean virtual,\n\t\t\tValueExtractor valueExtractor) {\n\t\tthis.jdbcPosition = jdbcPosition;\n\t\tthis.valuesArrayPosition = valuesArrayPosition;\n\t\tthis.sqlExpression = sqlExpression;\n\t\tthis.jdbcJavaType = jdbcJavaType;\n\t\tthis.virtual = virtual;\n\t\tthis.valueExtractor = valueExtractor;\n\t}\n\n\tprivate static ValueExtractor determineValueExtractor(Expression sqlExpression, JavaType<?> jdbcJavaType) {\n\t\tfinal JdbcMappingContainer expressionType = sqlExpression.getExpressionType();\n\t\tfinal JdbcMapping jdbcMapping = expressionType == null\n\t\t\t\t? JavaObjectType.INSTANCE\n\t\t\t\t: expressionType.getSingleJdbcMapping();\n\t\tif ( jdbcJavaType == null || jdbcMapping.getMappedJavaType() == jdbcJavaType ) {\n\t\t\treturn jdbcMapping.getJdbcValueExtractor();\n\t\t}\n\t\telse {\n\t\t\treturn jdbcMapping.getJdbcType().getExtractor( jdbcJavaType );\n\t\t}\n\t}\n\n\n\t@Override\n\tpublic Expression getExpression() {\n\t\treturn sqlExpression;\n\t}\n\n\t@Override\n\tpublic ValueExtractor getJdbcValueExtractor() {\n\t\tValueExtractor extractor = valueExtractor;\n\t\tif ( extractor == null ) {\n\t\t\tvalueExtractor = extractor = determineValueExtractor( sqlExpression, jdbcJavaType );\n\t\t}\n\t\treturn extractor;\n\t}\n\n\t@Override\n\tpublic int getJdbcResultSetIndex() {\n\t\treturn jdbcPosition;\n\t}\n\n\t@Override\n\tpublic int getValuesArrayPosition() {\n\t\treturn valuesArrayPosition;\n\t}\n\n\t@Override\n\tpublic JdbcMappingContainer getExpressionType() {\n\t\treturn getExpression().getExpressionType();\n\t}\n\n\t@Override\n\tpublic boolean isVirtual() {\n\t\treturn virtual;\n\t}\n\n\t@Override\n\tpublic Expression getSqlExpression() {\n\t\treturn sqlExpression;\n\t}\n\n\t@Override\n\tpublic void accept(SqlAstWalker interpreter) {\n\t\tsqlExpression.accept( interpreter );\n\t}\n\n\tpublic boolean needsResolve() {\n\t\treturn sqlExpression.getExpressionType() instanceof JavaObjectType;\n\t}\n\n\t@Override\n\tpublic SqlSelection resolve(JdbcValuesMetadata jdbcResultsMetadata, SessionFactoryImplementor sessionFactory) {\n\t\tif ( needsResolve() ) {\n\t\t\tfinal BasicType<Object> resolvedType = jdbcResultsMetadata.resolveType(\n\t\t\t\t\tjdbcPosition,\n\t\t\t\t\tnull,\n\t\t\t\t\tsessionFactory\n\t\t\t);\n\t\t\treturn new ResolvedSqlSelection(\n\t\t\t\t\tjdbcPosition,\n\t\t\t\t\tvaluesArrayPosition,\n\t\t\t\t\tsqlExpression,\n\t\t\t\t\tresolvedType\n\t\t\t);\n\t\t}\n\t\treturn this;\n\t}\n\n\t@Override\n\tpublic boolean equals(Object o) {\n\t\tif ( this == o ) {\n\t\t\treturn true;\n\t\t}\n\t\tif ( o == null || getClass() != o.getClass() ) {\n\t\t\treturn false;\n\t\t}\n\t\tfinal SqlSelection that = (SqlSelection) o;\n\t\treturn jdbcPosition == that.getJdbcResultSetIndex() &&\n\t\t\t\tvaluesArrayPosition == that.getValuesArrayPosition() &&\n\t\t\t\tObjects.equals( sqlExpression, that.getExpression() ) &&\n\t\t\t\tvirtual == that.isVirtual();\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\treturn Objects.hash( jdbcPosition, valuesArrayPosition, sqlExpression, virtual );\n\t}\n}\n",
        "diffSourceCodeSet": [
            "public boolean needsResolve() {\n\t\treturn sqlExpression.getExpressionType() instanceof JavaObjectType;\n\t}"
        ],
        "invokedMethodSet": [
            "methodSignature: org.hibernate.sql.exec.internal.JdbcSelectExecutorStandardImpl.CachedJdbcValuesMetadata#resolveType\n methodBody: public <J> BasicType<J> resolveType(\n\t\t\t\tint position,\n\t\t\t\tJavaType<J> explicitJavaType,\n\t\t\t\tTypeConfiguration typeConfiguration) {\nfinal BasicType<?> type=types[position - 1];\nif(type == null){throw new IllegalStateException(\"Unexpected resolving of unavailable column at position: \" + position);\n}if(explicitJavaType == null || type.getJavaTypeDescriptor() == explicitJavaType){return (BasicType<J>)type;\n}{return typeConfiguration.getBasicTypeRegistry().resolve(explicitJavaType,type.getJdbcType());\n}}",
            "methodSignature: org.hibernate.sql.exec.internal.JdbcSelectExecutorStandardImpl.CapturingJdbcValuesMetadata#resolveType\n methodBody: public <J> BasicType<J> resolveType(\n\t\t\t\tint position,\n\t\t\t\tJavaType<J> explicitJavaType,\n\t\t\t\tTypeConfiguration typeConfiguration) {\nif(columnNames == null){initializeArrays();\n}final BasicType<J> basicType=resultSetAccess.resolveType(position,explicitJavaType,typeConfiguration);\ntypes[position - 1]=basicType;\nreturn basicType;\n}",
            "methodSignature: org.hibernate.sql.results.internal.SqlSelectionImpl#getExpressionType\n methodBody: public JdbcMappingContainer getExpressionType() {\nreturn getExpression().getExpressionType();\n}"
        ],
        "sourceCodeAfterRefactoring": "@Override\n\tpublic SqlSelection resolve(JdbcValuesMetadata jdbcResultsMetadata, SessionFactoryImplementor sessionFactory) {\n\t\tif ( needsResolve() ) {\n\t\t\tfinal BasicType<Object> resolvedType = jdbcResultsMetadata.resolveType(\n\t\t\t\t\tjdbcPosition,\n\t\t\t\t\tnull,\n\t\t\t\t\tsessionFactory\n\t\t\t);\n\t\t\treturn new ResolvedSqlSelection(\n\t\t\t\t\tjdbcPosition,\n\t\t\t\t\tvaluesArrayPosition,\n\t\t\t\t\tsqlExpression,\n\t\t\t\t\tresolvedType\n\t\t\t);\n\t\t}\n\t\treturn this;\n\t}\npublic boolean needsResolve() {\n\t\treturn sqlExpression.getExpressionType() instanceof JavaObjectType;\n\t}",
        "diffSourceCode": "-  152: \t@Override\n-  153: \tpublic SqlSelection resolve(JdbcValuesMetadata jdbcResultsMetadata, SessionFactoryImplementor sessionFactory) {\n-  154: \t\tif ( sqlExpression.getExpressionType() instanceof JavaObjectType ) {\n-  155: \t\t\tfinal BasicType<Object> resolvedType = jdbcResultsMetadata.resolveType(\n-  156: \t\t\t\t\tjdbcPosition,\n-  157: \t\t\t\t\tnull,\n-  158: \t\t\t\t\tsessionFactory\n-  159: \t\t\t);\n-  160: \t\t\treturn new ResolvedSqlSelection(\n-  161: \t\t\t\t\tjdbcPosition,\n-  162: \t\t\t\t\tvaluesArrayPosition,\n-  163: \t\t\t\t\tsqlExpression,\n-  164: \t\t\t\t\tresolvedType\n-  165: \t\t\t);\n-  166: \t\t}\n-  167: \t\treturn this;\n-  168: \t}\n-  169: \n-  170: \t@Override\n-  171: \tpublic boolean equals(Object o) {\n-  172: \t\tif ( this == o ) {\n+  152: \tpublic boolean needsResolve() {\n+  153: \t\treturn sqlExpression.getExpressionType() instanceof JavaObjectType;\n+  154: \t}\n+  155: \n+  156: \t@Override\n+  157: \tpublic SqlSelection resolve(JdbcValuesMetadata jdbcResultsMetadata, SessionFactoryImplementor sessionFactory) {\n+  158: \t\tif ( needsResolve() ) {\n+  159: \t\t\tfinal BasicType<Object> resolvedType = jdbcResultsMetadata.resolveType(\n+  160: \t\t\t\t\tjdbcPosition,\n+  161: \t\t\t\t\tnull,\n+  162: \t\t\t\t\tsessionFactory\n+  163: \t\t\t);\n+  164: \t\t\treturn new ResolvedSqlSelection(\n+  165: \t\t\t\t\tjdbcPosition,\n+  166: \t\t\t\t\tvaluesArrayPosition,\n+  167: \t\t\t\t\tsqlExpression,\n+  168: \t\t\t\t\tresolvedType\n+  169: \t\t\t);\n+  170: \t\t}\n+  171: \t\treturn this;\n+  172: \t}\n",
        "uniqueId": "e9513b1db5553cec8e8bfb3a095fc3d903a747b5_152_168_152_154_156_172",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 0,
                "covered": 25
            },
            "BRANCH": {
                "missed": 0,
                "covered": 2
            },
            "LINE": {
                "missed": 0,
                "covered": 4
            },
            "COMPLEXITY": {
                "missed": 0,
                "covered": 2
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 21
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprivate beginSlowQueryLogging() : long extracted from public execute(statement Statement, sql String) : ResultSet in class org.hibernate.engine.jdbc.internal.ResultSetReturnImpl",
        "diffLocations": [
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/engine/jdbc/internal/ResultSetReturnImpl.java",
                "startLine": 149,
                "endLine": 180,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/engine/jdbc/internal/ResultSetReturnImpl.java",
                "startLine": 152,
                "endLine": 181,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/engine/jdbc/internal/ResultSetReturnImpl.java",
                "startLine": 229,
                "endLine": 231,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "@Override\n\tpublic ResultSet execute(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\tif ( !statement.execute( sql ) ) {\n\t\t\t\t\twhile ( !statement.getMoreResults() && statement.getUpdateCount() != -1 ) {\n\t\t\t\t\t\t// do nothing until we hit the resultset\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trs = statement.getResultSet();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t}",
        "filePathBefore": "hibernate-core/src/main/java/org/hibernate/engine/jdbc/internal/ResultSetReturnImpl.java",
        "isPureRefactoring": true,
        "commitId": "7b8c403df746e127f38d3f5f3efb45b941c36af2",
        "packageNameBefore": "org.hibernate.engine.jdbc.internal",
        "classNameBefore": "org.hibernate.engine.jdbc.internal.ResultSetReturnImpl",
        "methodNameBefore": "org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#execute",
        "invokedMethod": "methodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#jdbcExecuteStatementStart\n methodBody: private void jdbcExecuteStatementStart() {\njdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getEventHandler().jdbcExecuteStatementStart();\n}\nmethodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#context\n methodBody: private JdbcSessionContext context() {\nreturn jdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext();\n}\nmethodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#jdbcExecuteStatementEnd\n methodBody: private void jdbcExecuteStatementEnd() {\njdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getEventHandler().jdbcExecuteStatementEnd();\n}\nmethodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#postExtract\n methodBody: private void postExtract(ResultSet rs, Statement st) {\nif(rs != null){jdbcCoordinator.getLogicalConnection().getResourceRegistry().register(rs,st);\n}}\nmethodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#execute\n methodBody: public ResultSet execute(Statement statement, String sql) {\nsqlStatementLogger.logStatement(sql);\nlong executeStartNanos=0;\nif(this.sqlStatementLogger.getLogSlowQuery() > 0){executeStartNanos=System.nanoTime();\n}tryfinal ResultSet rs;\nfinal EventManager eventManager=jdbcCoordinator.getJdbcSessionOwner().getEventManager();\nfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent=eventManager.beginJdbcPreparedStatementExecutionEvent();\ntryjdbcExecuteStatementStart();\nif(!statement.execute(sql)){while(!statement.getMoreResults() && statement.getUpdateCount() != -1){}}rs=statement.getResultSet();\nfinallyeventManager.completeJdbcPreparedStatementExecutionEvent(jdbcPreparedStatementExecutionEvent,sql);\njdbcExecuteStatementEnd();\nsqlStatementLogger.logSlowQuery(sql,executeStartNanos,context());\npostExtract(rs,statement);\nreturn rs;\ncatch(SQLException e)throw sqlExceptionHelper.convert(e,\"could not execute statement\",sql);\n}",
        "classSignatureBefore": "public class ResultSetReturnImpl implements ResultSetReturn ",
        "methodNameBeforeSet": [
            "org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#execute"
        ],
        "classNameBeforeSet": [
            "org.hibernate.engine.jdbc.internal.ResultSetReturnImpl"
        ],
        "classSignatureBeforeSet": [
            "public class ResultSetReturnImpl implements ResultSetReturn "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Tolerable changes in the body\n",
                "description": "All replacements have been justified - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.\n */\npackage org.hibernate.engine.jdbc.internal;\n\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\nimport org.hibernate.dialect.Dialect;\nimport org.hibernate.engine.jdbc.spi.JdbcCoordinator;\nimport org.hibernate.engine.jdbc.spi.JdbcServices;\nimport org.hibernate.engine.jdbc.spi.ResultSetReturn;\nimport org.hibernate.engine.jdbc.spi.SqlExceptionHelper;\nimport org.hibernate.engine.jdbc.spi.SqlStatementLogger;\nimport org.hibernate.event.spi.EventManager;\nimport org.hibernate.event.spi.HibernateMonitoringEvent;\nimport org.hibernate.resource.jdbc.spi.JdbcSessionContext;\n\n/**\n * Standard implementation of the ResultSetReturn contract\n *\n * @author Brett Meyer\n */\npublic class ResultSetReturnImpl implements ResultSetReturn {\n\tprivate final JdbcCoordinator jdbcCoordinator;\n\n\tprivate final Dialect dialect;\n\tprivate final SqlStatementLogger sqlStatementLogger;\n\tprivate final SqlExceptionHelper sqlExceptionHelper;\n\n\t/**\n\t * Constructs a ResultSetReturnImpl\n\t *\n\t * @param jdbcCoordinator The JdbcCoordinator\n\t */\n\tpublic ResultSetReturnImpl(JdbcCoordinator jdbcCoordinator, JdbcServices jdbcServices) {\n\t\tthis.jdbcCoordinator = jdbcCoordinator;\n\t\tthis.dialect = jdbcServices.getDialect();\n\t\tthis.sqlStatementLogger = jdbcServices.getSqlStatementLogger();\n\t\tthis.sqlExceptionHelper = jdbcServices.getSqlExceptionHelper();\n\t}\n\n\t@Override\n\tpublic ResultSet extract(PreparedStatement statement, String sql) {\n\t\t// IMPL NOTE : SQL logged by caller\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\trs = statement.executeQuery();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not extract ResultSet\", sql );\n\t\t}\n\t}\n\n\tprivate JdbcSessionContext context() {\n\t\treturn jdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext();\n\t}\n\n\tprivate void jdbcExecuteStatementEnd() {\n\t\tjdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getEventHandler().jdbcExecuteStatementEnd();\n\t}\n\n\tprivate void jdbcExecuteStatementStart() {\n\t\tjdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getEventHandler().jdbcExecuteStatementStart();\n\t}\n\n\t@Override\n\tpublic ResultSet extract(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\trs = statement.executeQuery( sql );\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not extract ResultSet\", sql );\n\t\t}\n\t}\n\n\t@Override\n\tpublic ResultSet execute(PreparedStatement statement, String sql) {\n\t\t// sql logged by StatementPreparerImpl\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\tif ( !statement.execute() ) {\n\t\t\t\t\twhile ( !statement.getMoreResults() && statement.getUpdateCount() != -1 ) {\n\t\t\t\t\t\t// do nothing until we hit the resultset\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trs = statement.getResultSet();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t}\n\n\t@Override\n\tpublic ResultSet execute(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\tif ( !statement.execute( sql ) ) {\n\t\t\t\t\twhile ( !statement.getMoreResults() && statement.getUpdateCount() != -1 ) {\n\t\t\t\t\t\t// do nothing until we hit the resultset\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trs = statement.getResultSet();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t}\n\n\t@Override\n\tpublic int executeUpdate(PreparedStatement statement, String sql) {\n\t\tassert statement != null;\n\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\ttry {\n\t\t\tjdbcExecuteStatementStart();\n\t\t\treturn statement.executeUpdate();\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t\tfinally {\n\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\tjdbcExecuteStatementEnd();\n\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t}\n\t}\n\n\t@Override\n\tpublic int executeUpdate(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\ttry {\n\t\t\tjdbcExecuteStatementStart();\n\t\t\treturn statement.executeUpdate( sql );\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t\tfinally {\n\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\tjdbcExecuteStatementEnd();\n\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t}\n\t}\n\n\tprivate void postExtract(ResultSet rs, Statement st) {\n\t\tif ( rs != null ) {\n\t\t\tjdbcCoordinator.getLogicalConnection().getResourceRegistry().register( rs, st );\n\t\t}\n\t}\n\n}\n",
        "filePathAfter": "hibernate-core/src/main/java/org/hibernate/engine/jdbc/internal/ResultSetReturnImpl.java",
        "sourceCodeAfterForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.\n */\npackage org.hibernate.engine.jdbc.internal;\n\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\nimport org.hibernate.engine.jdbc.spi.JdbcCoordinator;\nimport org.hibernate.engine.jdbc.spi.JdbcServices;\nimport org.hibernate.engine.jdbc.spi.ResultSetReturn;\nimport org.hibernate.engine.jdbc.spi.SqlExceptionHelper;\nimport org.hibernate.engine.jdbc.spi.SqlStatementLogger;\nimport org.hibernate.event.spi.EventManager;\nimport org.hibernate.event.spi.HibernateMonitoringEvent;\nimport org.hibernate.resource.jdbc.spi.JdbcEventHandler;\nimport org.hibernate.resource.jdbc.spi.JdbcSessionContext;\n\n/**\n * Standard implementation of the ResultSetReturn contract\n *\n * @author Brett Meyer\n */\npublic class ResultSetReturnImpl implements ResultSetReturn {\n\tprivate final JdbcCoordinator jdbcCoordinator;\n\n\tprivate final SqlStatementLogger sqlStatementLogger;\n\tprivate final SqlExceptionHelper sqlExceptionHelper;\n\n\t/**\n\t * Constructs a ResultSetReturnImpl\n\t *\n\t * @param jdbcCoordinator The JdbcCoordinator\n\t */\n\tpublic ResultSetReturnImpl(JdbcCoordinator jdbcCoordinator, JdbcServices jdbcServices) {\n\t\tthis.jdbcCoordinator = jdbcCoordinator;\n\t\tthis.sqlStatementLogger = jdbcServices.getSqlStatementLogger();\n\t\tthis.sqlExceptionHelper = jdbcServices.getSqlExceptionHelper();\n\t}\n\n\t@Override\n\tpublic ResultSet extract(PreparedStatement statement, String sql) {\n\t\t// IMPL NOTE : SQL logged by caller\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = getEventManager();\n\t\t\tfinal HibernateMonitoringEvent executionEvent =\n\t\t\t\t\teventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\trs = statement.executeQuery();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( executionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tendSlowQueryLogging(sql, executeStartNanos);\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not extract ResultSet\", sql );\n\t\t}\n\t}\n\n\tprivate EventManager getEventManager() {\n\t\treturn jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t}\n\n\tprivate JdbcEventHandler getEventHandler() {\n\t\treturn jdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getEventHandler();\n\t}\n\n\tprivate JdbcSessionContext context() {\n\t\treturn jdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext();\n\t}\n\n\tprivate void jdbcExecuteStatementEnd() {\n\t\tgetEventHandler().jdbcExecuteStatementEnd();\n\t}\n\n\tprivate void jdbcExecuteStatementStart() {\n\t\tgetEventHandler().jdbcExecuteStatementStart();\n\t}\n\n\t@Override\n\tpublic ResultSet extract(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = beginSlowQueryLogging();\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = getEventManager();\n\t\t\tfinal HibernateMonitoringEvent executionEvent =\n\t\t\t\t\teventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\trs = statement.executeQuery( sql );\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( executionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tendSlowQueryLogging( sql, executeStartNanos );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not extract ResultSet\", sql );\n\t\t}\n\t}\n\n\t@Override\n\tpublic ResultSet execute(PreparedStatement statement, String sql) {\n\t\t// sql logged by StatementPreparerImpl\n\t\tlong executeStartNanos = beginSlowQueryLogging();\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = getEventManager();\n\t\t\tfinal HibernateMonitoringEvent executionEvent =\n\t\t\t\t\teventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\tif ( !statement.execute() ) {\n\t\t\t\t\twhile ( !statement.getMoreResults() && statement.getUpdateCount() != -1 ) {\n\t\t\t\t\t\t// do nothing until we hit the resultset\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trs = statement.getResultSet();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( executionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tendSlowQueryLogging( sql, executeStartNanos );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t}\n\n\t@Override\n\tpublic ResultSet execute(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = beginSlowQueryLogging();\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = getEventManager();\n\t\t\tfinal HibernateMonitoringEvent executionEvent =\n\t\t\t\t\teventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\tif ( !statement.execute( sql ) ) {\n\t\t\t\t\twhile ( !statement.getMoreResults() && statement.getUpdateCount() != -1 ) {\n\t\t\t\t\t\t// do nothing until we hit the resultset\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trs = statement.getResultSet();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( executionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tendSlowQueryLogging( sql, executeStartNanos );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t}\n\n\t@Override\n\tpublic int executeUpdate(PreparedStatement statement, String sql) {\n\t\tassert statement != null;\n\t\tlong executeStartNanos = beginSlowQueryLogging();\n\t\tfinal EventManager eventManager = getEventManager();\n\t\tfinal HibernateMonitoringEvent executionEvent =\n\t\t\t\teventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\ttry {\n\t\t\tjdbcExecuteStatementStart();\n\t\t\treturn statement.executeUpdate();\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t\tfinally {\n\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( executionEvent, sql );\n\t\t\tjdbcExecuteStatementEnd();\n\t\t\tendSlowQueryLogging( sql, executeStartNanos );\n\t\t}\n\t}\n\n\t@Override\n\tpublic int executeUpdate(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = beginSlowQueryLogging();\n\t\tfinal EventManager eventManager = getEventManager();\n\t\tfinal HibernateMonitoringEvent executionEvent =\n\t\t\t\teventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\ttry {\n\t\t\tjdbcExecuteStatementStart();\n\t\t\treturn statement.executeUpdate( sql );\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t\tfinally {\n\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( executionEvent, sql );\n\t\t\tjdbcExecuteStatementEnd();\n\t\t\tendSlowQueryLogging( sql, executeStartNanos );\n\t\t}\n\t}\n\n\tprivate void endSlowQueryLogging(String sql, long executeStartNanos) {\n\t\tsqlStatementLogger.logSlowQuery(sql, executeStartNanos, context() );\n\t}\n\n\tprivate long beginSlowQueryLogging() {\n\t\treturn sqlStatementLogger.getLogSlowQuery() > 0 ? System.nanoTime() : 0;\n\t}\n\n\tprivate void postExtract(ResultSet rs, Statement st) {\n\t\tif ( rs != null ) {\n\t\t\tjdbcCoordinator.getLogicalConnection().getResourceRegistry().register( rs, st );\n\t\t}\n\t}\n\n}\n",
        "diffSourceCodeSet": [
            "private long beginSlowQueryLogging() {\n\t\treturn sqlStatementLogger.getLogSlowQuery() > 0 ? System.nanoTime() : 0;\n\t}"
        ],
        "invokedMethodSet": [
            "methodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#jdbcExecuteStatementStart\n methodBody: private void jdbcExecuteStatementStart() {\njdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getEventHandler().jdbcExecuteStatementStart();\n}",
            "methodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#context\n methodBody: private JdbcSessionContext context() {\nreturn jdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext();\n}",
            "methodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#jdbcExecuteStatementEnd\n methodBody: private void jdbcExecuteStatementEnd() {\njdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getEventHandler().jdbcExecuteStatementEnd();\n}",
            "methodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#postExtract\n methodBody: private void postExtract(ResultSet rs, Statement st) {\nif(rs != null){jdbcCoordinator.getLogicalConnection().getResourceRegistry().register(rs,st);\n}}",
            "methodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#execute\n methodBody: public ResultSet execute(Statement statement, String sql) {\nsqlStatementLogger.logStatement(sql);\nlong executeStartNanos=0;\nif(this.sqlStatementLogger.getLogSlowQuery() > 0){executeStartNanos=System.nanoTime();\n}tryfinal ResultSet rs;\nfinal EventManager eventManager=jdbcCoordinator.getJdbcSessionOwner().getEventManager();\nfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent=eventManager.beginJdbcPreparedStatementExecutionEvent();\ntryjdbcExecuteStatementStart();\nif(!statement.execute(sql)){while(!statement.getMoreResults() && statement.getUpdateCount() != -1){}}rs=statement.getResultSet();\nfinallyeventManager.completeJdbcPreparedStatementExecutionEvent(jdbcPreparedStatementExecutionEvent,sql);\njdbcExecuteStatementEnd();\nsqlStatementLogger.logSlowQuery(sql,executeStartNanos,context());\npostExtract(rs,statement);\nreturn rs;\ncatch(SQLException e)throw sqlExceptionHelper.convert(e,\"could not execute statement\",sql);\n}"
        ],
        "sourceCodeAfterRefactoring": "@Override\n\tpublic ResultSet execute(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = beginSlowQueryLogging();\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = getEventManager();\n\t\t\tfinal HibernateMonitoringEvent executionEvent =\n\t\t\t\t\teventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\tif ( !statement.execute( sql ) ) {\n\t\t\t\t\twhile ( !statement.getMoreResults() && statement.getUpdateCount() != -1 ) {\n\t\t\t\t\t\t// do nothing until we hit the resultset\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trs = statement.getResultSet();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( executionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tendSlowQueryLogging( sql, executeStartNanos );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t}\nprivate long beginSlowQueryLogging() {\n\t\treturn sqlStatementLogger.getLogSlowQuery() > 0 ? System.nanoTime() : 0;\n\t}",
        "diffSourceCode": "-  149: \t@Override\n-  150: \tpublic ResultSet execute(Statement statement, String sql) {\n-  151: \t\tsqlStatementLogger.logStatement( sql );\n-  152: \t\tlong executeStartNanos = 0;\n-  153: \t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n-  154: \t\t\texecuteStartNanos = System.nanoTime();\n-  155: \t\t}\n+  149: \t\t}\n+  150: \t}\n+  151: \n+  152: \t@Override\n+  153: \tpublic ResultSet execute(Statement statement, String sql) {\n+  154: \t\tsqlStatementLogger.logStatement( sql );\n+  155: \t\tlong executeStartNanos = beginSlowQueryLogging();\n   156: \t\ttry {\n   157: \t\t\tfinal ResultSet rs;\n-  158: \t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n-  159: \t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n-  160: \t\t\ttry {\n-  161: \t\t\t\tjdbcExecuteStatementStart();\n-  162: \t\t\t\tif ( !statement.execute( sql ) ) {\n-  163: \t\t\t\t\twhile ( !statement.getMoreResults() && statement.getUpdateCount() != -1 ) {\n-  164: \t\t\t\t\t\t// do nothing until we hit the resultset\n-  165: \t\t\t\t\t}\n-  166: \t\t\t\t}\n-  167: \t\t\t\trs = statement.getResultSet();\n-  168: \t\t\t}\n-  169: \t\t\tfinally {\n-  170: \t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n-  171: \t\t\t\tjdbcExecuteStatementEnd();\n-  172: \t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n-  173: \t\t\t}\n-  174: \t\t\tpostExtract( rs, statement );\n-  175: \t\t\treturn rs;\n-  176: \t\t}\n-  177: \t\tcatch (SQLException e) {\n-  178: \t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n-  179: \t\t}\n-  180: \t}\n-  181: \n-  229: \tprivate void postExtract(ResultSet rs, Statement st) {\n-  230: \t\tif ( rs != null ) {\n-  231: \t\t\tjdbcCoordinator.getLogicalConnection().getResourceRegistry().register( rs, st );\n+  158: \t\t\tfinal EventManager eventManager = getEventManager();\n+  159: \t\t\tfinal HibernateMonitoringEvent executionEvent =\n+  160: \t\t\t\t\teventManager.beginJdbcPreparedStatementExecutionEvent();\n+  161: \t\t\ttry {\n+  162: \t\t\t\tjdbcExecuteStatementStart();\n+  163: \t\t\t\tif ( !statement.execute( sql ) ) {\n+  164: \t\t\t\t\twhile ( !statement.getMoreResults() && statement.getUpdateCount() != -1 ) {\n+  165: \t\t\t\t\t\t// do nothing until we hit the resultset\n+  166: \t\t\t\t\t}\n+  167: \t\t\t\t}\n+  168: \t\t\t\trs = statement.getResultSet();\n+  169: \t\t\t}\n+  170: \t\t\tfinally {\n+  171: \t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( executionEvent, sql );\n+  172: \t\t\t\tjdbcExecuteStatementEnd();\n+  173: \t\t\t\tendSlowQueryLogging( sql, executeStartNanos );\n+  174: \t\t\t}\n+  175: \t\t\tpostExtract( rs, statement );\n+  176: \t\t\treturn rs;\n+  177: \t\t}\n+  178: \t\tcatch (SQLException e) {\n+  179: \t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n+  180: \t\t}\n+  181: \t}\n+  229: \tprivate long beginSlowQueryLogging() {\n+  230: \t\treturn sqlStatementLogger.getLogSlowQuery() > 0 ? System.nanoTime() : 0;\n+  231: \t}\n",
        "uniqueId": "7b8c403df746e127f38d3f5f3efb45b941c36af2_149_180_229_231_152_181",
        "moveFileExist": true,
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 21,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 9,
                "covered": 45
            },
            "BRANCH": {
                "missed": 3,
                "covered": 3
            },
            "LINE": {
                "missed": 2,
                "covered": 14
            },
            "COMPLEXITY": {
                "missed": 3,
                "covered": 1
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        }
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprivate endSlowQueryLogging(sql String, executeStartNanos long) : void extracted from public execute(statement Statement, sql String) : ResultSet in class org.hibernate.engine.jdbc.internal.ResultSetReturnImpl",
        "diffLocations": [
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/engine/jdbc/internal/ResultSetReturnImpl.java",
                "startLine": 149,
                "endLine": 180,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/engine/jdbc/internal/ResultSetReturnImpl.java",
                "startLine": 152,
                "endLine": 181,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/engine/jdbc/internal/ResultSetReturnImpl.java",
                "startLine": 225,
                "endLine": 227,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "@Override\n\tpublic ResultSet execute(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\tif ( !statement.execute( sql ) ) {\n\t\t\t\t\twhile ( !statement.getMoreResults() && statement.getUpdateCount() != -1 ) {\n\t\t\t\t\t\t// do nothing until we hit the resultset\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trs = statement.getResultSet();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t}",
        "filePathBefore": "hibernate-core/src/main/java/org/hibernate/engine/jdbc/internal/ResultSetReturnImpl.java",
        "isPureRefactoring": true,
        "commitId": "7b8c403df746e127f38d3f5f3efb45b941c36af2",
        "packageNameBefore": "org.hibernate.engine.jdbc.internal",
        "classNameBefore": "org.hibernate.engine.jdbc.internal.ResultSetReturnImpl",
        "methodNameBefore": "org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#execute",
        "invokedMethod": "methodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#jdbcExecuteStatementStart\n methodBody: private void jdbcExecuteStatementStart() {\njdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getEventHandler().jdbcExecuteStatementStart();\n}\nmethodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#context\n methodBody: private JdbcSessionContext context() {\nreturn jdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext();\n}\nmethodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#jdbcExecuteStatementEnd\n methodBody: private void jdbcExecuteStatementEnd() {\njdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getEventHandler().jdbcExecuteStatementEnd();\n}\nmethodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#postExtract\n methodBody: private void postExtract(ResultSet rs, Statement st) {\nif(rs != null){jdbcCoordinator.getLogicalConnection().getResourceRegistry().register(rs,st);\n}}\nmethodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#execute\n methodBody: public ResultSet execute(Statement statement, String sql) {\nsqlStatementLogger.logStatement(sql);\nlong executeStartNanos=0;\nif(this.sqlStatementLogger.getLogSlowQuery() > 0){executeStartNanos=System.nanoTime();\n}tryfinal ResultSet rs;\nfinal EventManager eventManager=jdbcCoordinator.getJdbcSessionOwner().getEventManager();\nfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent=eventManager.beginJdbcPreparedStatementExecutionEvent();\ntryjdbcExecuteStatementStart();\nif(!statement.execute(sql)){while(!statement.getMoreResults() && statement.getUpdateCount() != -1){}}rs=statement.getResultSet();\nfinallyeventManager.completeJdbcPreparedStatementExecutionEvent(jdbcPreparedStatementExecutionEvent,sql);\njdbcExecuteStatementEnd();\nsqlStatementLogger.logSlowQuery(sql,executeStartNanos,context());\npostExtract(rs,statement);\nreturn rs;\ncatch(SQLException e)throw sqlExceptionHelper.convert(e,\"could not execute statement\",sql);\n}",
        "classSignatureBefore": "public class ResultSetReturnImpl implements ResultSetReturn ",
        "methodNameBeforeSet": [
            "org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#execute"
        ],
        "classNameBeforeSet": [
            "org.hibernate.engine.jdbc.internal.ResultSetReturnImpl"
        ],
        "classSignatureBeforeSet": [
            "public class ResultSetReturnImpl implements ResultSetReturn "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.\n */\npackage org.hibernate.engine.jdbc.internal;\n\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\nimport org.hibernate.dialect.Dialect;\nimport org.hibernate.engine.jdbc.spi.JdbcCoordinator;\nimport org.hibernate.engine.jdbc.spi.JdbcServices;\nimport org.hibernate.engine.jdbc.spi.ResultSetReturn;\nimport org.hibernate.engine.jdbc.spi.SqlExceptionHelper;\nimport org.hibernate.engine.jdbc.spi.SqlStatementLogger;\nimport org.hibernate.event.spi.EventManager;\nimport org.hibernate.event.spi.HibernateMonitoringEvent;\nimport org.hibernate.resource.jdbc.spi.JdbcSessionContext;\n\n/**\n * Standard implementation of the ResultSetReturn contract\n *\n * @author Brett Meyer\n */\npublic class ResultSetReturnImpl implements ResultSetReturn {\n\tprivate final JdbcCoordinator jdbcCoordinator;\n\n\tprivate final Dialect dialect;\n\tprivate final SqlStatementLogger sqlStatementLogger;\n\tprivate final SqlExceptionHelper sqlExceptionHelper;\n\n\t/**\n\t * Constructs a ResultSetReturnImpl\n\t *\n\t * @param jdbcCoordinator The JdbcCoordinator\n\t */\n\tpublic ResultSetReturnImpl(JdbcCoordinator jdbcCoordinator, JdbcServices jdbcServices) {\n\t\tthis.jdbcCoordinator = jdbcCoordinator;\n\t\tthis.dialect = jdbcServices.getDialect();\n\t\tthis.sqlStatementLogger = jdbcServices.getSqlStatementLogger();\n\t\tthis.sqlExceptionHelper = jdbcServices.getSqlExceptionHelper();\n\t}\n\n\t@Override\n\tpublic ResultSet extract(PreparedStatement statement, String sql) {\n\t\t// IMPL NOTE : SQL logged by caller\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\trs = statement.executeQuery();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not extract ResultSet\", sql );\n\t\t}\n\t}\n\n\tprivate JdbcSessionContext context() {\n\t\treturn jdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext();\n\t}\n\n\tprivate void jdbcExecuteStatementEnd() {\n\t\tjdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getEventHandler().jdbcExecuteStatementEnd();\n\t}\n\n\tprivate void jdbcExecuteStatementStart() {\n\t\tjdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getEventHandler().jdbcExecuteStatementStart();\n\t}\n\n\t@Override\n\tpublic ResultSet extract(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\trs = statement.executeQuery( sql );\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not extract ResultSet\", sql );\n\t\t}\n\t}\n\n\t@Override\n\tpublic ResultSet execute(PreparedStatement statement, String sql) {\n\t\t// sql logged by StatementPreparerImpl\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\tif ( !statement.execute() ) {\n\t\t\t\t\twhile ( !statement.getMoreResults() && statement.getUpdateCount() != -1 ) {\n\t\t\t\t\t\t// do nothing until we hit the resultset\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trs = statement.getResultSet();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t}\n\n\t@Override\n\tpublic ResultSet execute(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\tif ( !statement.execute( sql ) ) {\n\t\t\t\t\twhile ( !statement.getMoreResults() && statement.getUpdateCount() != -1 ) {\n\t\t\t\t\t\t// do nothing until we hit the resultset\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trs = statement.getResultSet();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t}\n\n\t@Override\n\tpublic int executeUpdate(PreparedStatement statement, String sql) {\n\t\tassert statement != null;\n\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\ttry {\n\t\t\tjdbcExecuteStatementStart();\n\t\t\treturn statement.executeUpdate();\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t\tfinally {\n\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\tjdbcExecuteStatementEnd();\n\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t}\n\t}\n\n\t@Override\n\tpublic int executeUpdate(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\ttry {\n\t\t\tjdbcExecuteStatementStart();\n\t\t\treturn statement.executeUpdate( sql );\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t\tfinally {\n\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\tjdbcExecuteStatementEnd();\n\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t}\n\t}\n\n\tprivate void postExtract(ResultSet rs, Statement st) {\n\t\tif ( rs != null ) {\n\t\t\tjdbcCoordinator.getLogicalConnection().getResourceRegistry().register( rs, st );\n\t\t}\n\t}\n\n}\n",
        "filePathAfter": "hibernate-core/src/main/java/org/hibernate/engine/jdbc/internal/ResultSetReturnImpl.java",
        "sourceCodeAfterForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.\n */\npackage org.hibernate.engine.jdbc.internal;\n\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\nimport org.hibernate.engine.jdbc.spi.JdbcCoordinator;\nimport org.hibernate.engine.jdbc.spi.JdbcServices;\nimport org.hibernate.engine.jdbc.spi.ResultSetReturn;\nimport org.hibernate.engine.jdbc.spi.SqlExceptionHelper;\nimport org.hibernate.engine.jdbc.spi.SqlStatementLogger;\nimport org.hibernate.event.spi.EventManager;\nimport org.hibernate.event.spi.HibernateMonitoringEvent;\nimport org.hibernate.resource.jdbc.spi.JdbcEventHandler;\nimport org.hibernate.resource.jdbc.spi.JdbcSessionContext;\n\n/**\n * Standard implementation of the ResultSetReturn contract\n *\n * @author Brett Meyer\n */\npublic class ResultSetReturnImpl implements ResultSetReturn {\n\tprivate final JdbcCoordinator jdbcCoordinator;\n\n\tprivate final SqlStatementLogger sqlStatementLogger;\n\tprivate final SqlExceptionHelper sqlExceptionHelper;\n\n\t/**\n\t * Constructs a ResultSetReturnImpl\n\t *\n\t * @param jdbcCoordinator The JdbcCoordinator\n\t */\n\tpublic ResultSetReturnImpl(JdbcCoordinator jdbcCoordinator, JdbcServices jdbcServices) {\n\t\tthis.jdbcCoordinator = jdbcCoordinator;\n\t\tthis.sqlStatementLogger = jdbcServices.getSqlStatementLogger();\n\t\tthis.sqlExceptionHelper = jdbcServices.getSqlExceptionHelper();\n\t}\n\n\t@Override\n\tpublic ResultSet extract(PreparedStatement statement, String sql) {\n\t\t// IMPL NOTE : SQL logged by caller\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = getEventManager();\n\t\t\tfinal HibernateMonitoringEvent executionEvent =\n\t\t\t\t\teventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\trs = statement.executeQuery();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( executionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tendSlowQueryLogging(sql, executeStartNanos);\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not extract ResultSet\", sql );\n\t\t}\n\t}\n\n\tprivate EventManager getEventManager() {\n\t\treturn jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t}\n\n\tprivate JdbcEventHandler getEventHandler() {\n\t\treturn jdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getEventHandler();\n\t}\n\n\tprivate JdbcSessionContext context() {\n\t\treturn jdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext();\n\t}\n\n\tprivate void jdbcExecuteStatementEnd() {\n\t\tgetEventHandler().jdbcExecuteStatementEnd();\n\t}\n\n\tprivate void jdbcExecuteStatementStart() {\n\t\tgetEventHandler().jdbcExecuteStatementStart();\n\t}\n\n\t@Override\n\tpublic ResultSet extract(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = beginSlowQueryLogging();\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = getEventManager();\n\t\t\tfinal HibernateMonitoringEvent executionEvent =\n\t\t\t\t\teventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\trs = statement.executeQuery( sql );\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( executionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tendSlowQueryLogging( sql, executeStartNanos );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not extract ResultSet\", sql );\n\t\t}\n\t}\n\n\t@Override\n\tpublic ResultSet execute(PreparedStatement statement, String sql) {\n\t\t// sql logged by StatementPreparerImpl\n\t\tlong executeStartNanos = beginSlowQueryLogging();\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = getEventManager();\n\t\t\tfinal HibernateMonitoringEvent executionEvent =\n\t\t\t\t\teventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\tif ( !statement.execute() ) {\n\t\t\t\t\twhile ( !statement.getMoreResults() && statement.getUpdateCount() != -1 ) {\n\t\t\t\t\t\t// do nothing until we hit the resultset\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trs = statement.getResultSet();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( executionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tendSlowQueryLogging( sql, executeStartNanos );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t}\n\n\t@Override\n\tpublic ResultSet execute(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = beginSlowQueryLogging();\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = getEventManager();\n\t\t\tfinal HibernateMonitoringEvent executionEvent =\n\t\t\t\t\teventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\tif ( !statement.execute( sql ) ) {\n\t\t\t\t\twhile ( !statement.getMoreResults() && statement.getUpdateCount() != -1 ) {\n\t\t\t\t\t\t// do nothing until we hit the resultset\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trs = statement.getResultSet();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( executionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tendSlowQueryLogging( sql, executeStartNanos );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t}\n\n\t@Override\n\tpublic int executeUpdate(PreparedStatement statement, String sql) {\n\t\tassert statement != null;\n\t\tlong executeStartNanos = beginSlowQueryLogging();\n\t\tfinal EventManager eventManager = getEventManager();\n\t\tfinal HibernateMonitoringEvent executionEvent =\n\t\t\t\teventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\ttry {\n\t\t\tjdbcExecuteStatementStart();\n\t\t\treturn statement.executeUpdate();\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t\tfinally {\n\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( executionEvent, sql );\n\t\t\tjdbcExecuteStatementEnd();\n\t\t\tendSlowQueryLogging( sql, executeStartNanos );\n\t\t}\n\t}\n\n\t@Override\n\tpublic int executeUpdate(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = beginSlowQueryLogging();\n\t\tfinal EventManager eventManager = getEventManager();\n\t\tfinal HibernateMonitoringEvent executionEvent =\n\t\t\t\teventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\ttry {\n\t\t\tjdbcExecuteStatementStart();\n\t\t\treturn statement.executeUpdate( sql );\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t\tfinally {\n\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( executionEvent, sql );\n\t\t\tjdbcExecuteStatementEnd();\n\t\t\tendSlowQueryLogging( sql, executeStartNanos );\n\t\t}\n\t}\n\n\tprivate void endSlowQueryLogging(String sql, long executeStartNanos) {\n\t\tsqlStatementLogger.logSlowQuery(sql, executeStartNanos, context() );\n\t}\n\n\tprivate long beginSlowQueryLogging() {\n\t\treturn sqlStatementLogger.getLogSlowQuery() > 0 ? System.nanoTime() : 0;\n\t}\n\n\tprivate void postExtract(ResultSet rs, Statement st) {\n\t\tif ( rs != null ) {\n\t\t\tjdbcCoordinator.getLogicalConnection().getResourceRegistry().register( rs, st );\n\t\t}\n\t}\n\n}\n",
        "diffSourceCodeSet": [
            "private void endSlowQueryLogging(String sql, long executeStartNanos) {\n\t\tsqlStatementLogger.logSlowQuery(sql, executeStartNanos, context() );\n\t}"
        ],
        "invokedMethodSet": [
            "methodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#jdbcExecuteStatementStart\n methodBody: private void jdbcExecuteStatementStart() {\njdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getEventHandler().jdbcExecuteStatementStart();\n}",
            "methodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#context\n methodBody: private JdbcSessionContext context() {\nreturn jdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext();\n}",
            "methodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#jdbcExecuteStatementEnd\n methodBody: private void jdbcExecuteStatementEnd() {\njdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getEventHandler().jdbcExecuteStatementEnd();\n}",
            "methodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#postExtract\n methodBody: private void postExtract(ResultSet rs, Statement st) {\nif(rs != null){jdbcCoordinator.getLogicalConnection().getResourceRegistry().register(rs,st);\n}}",
            "methodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#execute\n methodBody: public ResultSet execute(Statement statement, String sql) {\nsqlStatementLogger.logStatement(sql);\nlong executeStartNanos=0;\nif(this.sqlStatementLogger.getLogSlowQuery() > 0){executeStartNanos=System.nanoTime();\n}tryfinal ResultSet rs;\nfinal EventManager eventManager=jdbcCoordinator.getJdbcSessionOwner().getEventManager();\nfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent=eventManager.beginJdbcPreparedStatementExecutionEvent();\ntryjdbcExecuteStatementStart();\nif(!statement.execute(sql)){while(!statement.getMoreResults() && statement.getUpdateCount() != -1){}}rs=statement.getResultSet();\nfinallyeventManager.completeJdbcPreparedStatementExecutionEvent(jdbcPreparedStatementExecutionEvent,sql);\njdbcExecuteStatementEnd();\nsqlStatementLogger.logSlowQuery(sql,executeStartNanos,context());\npostExtract(rs,statement);\nreturn rs;\ncatch(SQLException e)throw sqlExceptionHelper.convert(e,\"could not execute statement\",sql);\n}"
        ],
        "sourceCodeAfterRefactoring": "@Override\n\tpublic ResultSet execute(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = beginSlowQueryLogging();\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = getEventManager();\n\t\t\tfinal HibernateMonitoringEvent executionEvent =\n\t\t\t\t\teventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\tif ( !statement.execute( sql ) ) {\n\t\t\t\t\twhile ( !statement.getMoreResults() && statement.getUpdateCount() != -1 ) {\n\t\t\t\t\t\t// do nothing until we hit the resultset\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trs = statement.getResultSet();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( executionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tendSlowQueryLogging( sql, executeStartNanos );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t}\nprivate void endSlowQueryLogging(String sql, long executeStartNanos) {\n\t\tsqlStatementLogger.logSlowQuery(sql, executeStartNanos, context() );\n\t}",
        "diffSourceCode": "-  149: \t@Override\n-  150: \tpublic ResultSet execute(Statement statement, String sql) {\n-  151: \t\tsqlStatementLogger.logStatement( sql );\n-  152: \t\tlong executeStartNanos = 0;\n-  153: \t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n-  154: \t\t\texecuteStartNanos = System.nanoTime();\n-  155: \t\t}\n+  149: \t\t}\n+  150: \t}\n+  151: \n+  152: \t@Override\n+  153: \tpublic ResultSet execute(Statement statement, String sql) {\n+  154: \t\tsqlStatementLogger.logStatement( sql );\n+  155: \t\tlong executeStartNanos = beginSlowQueryLogging();\n   156: \t\ttry {\n   157: \t\t\tfinal ResultSet rs;\n-  158: \t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n-  159: \t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n-  160: \t\t\ttry {\n-  161: \t\t\t\tjdbcExecuteStatementStart();\n-  162: \t\t\t\tif ( !statement.execute( sql ) ) {\n-  163: \t\t\t\t\twhile ( !statement.getMoreResults() && statement.getUpdateCount() != -1 ) {\n-  164: \t\t\t\t\t\t// do nothing until we hit the resultset\n-  165: \t\t\t\t\t}\n-  166: \t\t\t\t}\n-  167: \t\t\t\trs = statement.getResultSet();\n-  168: \t\t\t}\n-  169: \t\t\tfinally {\n-  170: \t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n-  171: \t\t\t\tjdbcExecuteStatementEnd();\n-  172: \t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n-  173: \t\t\t}\n-  174: \t\t\tpostExtract( rs, statement );\n-  175: \t\t\treturn rs;\n-  176: \t\t}\n-  177: \t\tcatch (SQLException e) {\n-  178: \t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n-  179: \t\t}\n-  180: \t}\n-  181: \n-  225: \t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n-  226: \t\t}\n+  158: \t\t\tfinal EventManager eventManager = getEventManager();\n+  159: \t\t\tfinal HibernateMonitoringEvent executionEvent =\n+  160: \t\t\t\t\teventManager.beginJdbcPreparedStatementExecutionEvent();\n+  161: \t\t\ttry {\n+  162: \t\t\t\tjdbcExecuteStatementStart();\n+  163: \t\t\t\tif ( !statement.execute( sql ) ) {\n+  164: \t\t\t\t\twhile ( !statement.getMoreResults() && statement.getUpdateCount() != -1 ) {\n+  165: \t\t\t\t\t\t// do nothing until we hit the resultset\n+  166: \t\t\t\t\t}\n+  167: \t\t\t\t}\n+  168: \t\t\t\trs = statement.getResultSet();\n+  169: \t\t\t}\n+  170: \t\t\tfinally {\n+  171: \t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( executionEvent, sql );\n+  172: \t\t\t\tjdbcExecuteStatementEnd();\n+  173: \t\t\t\tendSlowQueryLogging( sql, executeStartNanos );\n+  174: \t\t\t}\n+  175: \t\t\tpostExtract( rs, statement );\n+  176: \t\t\treturn rs;\n+  177: \t\t}\n+  178: \t\tcatch (SQLException e) {\n+  179: \t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n+  180: \t\t}\n+  181: \t}\n+  225: \tprivate void endSlowQueryLogging(String sql, long executeStartNanos) {\n+  226: \t\tsqlStatementLogger.logSlowQuery(sql, executeStartNanos, context() );\n   227: \t}\n",
        "uniqueId": "7b8c403df746e127f38d3f5f3efb45b941c36af2_149_180_225_227_152_181",
        "moveFileExist": true,
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 21,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 9,
                "covered": 45
            },
            "BRANCH": {
                "missed": 3,
                "covered": 3
            },
            "LINE": {
                "missed": 2,
                "covered": 14
            },
            "COMPLEXITY": {
                "missed": 3,
                "covered": 1
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        }
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprivate getEventManager() : EventManager extracted from public execute(statement Statement, sql String) : ResultSet in class org.hibernate.engine.jdbc.internal.ResultSetReturnImpl",
        "diffLocations": [
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/engine/jdbc/internal/ResultSetReturnImpl.java",
                "startLine": 149,
                "endLine": 180,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/engine/jdbc/internal/ResultSetReturnImpl.java",
                "startLine": 152,
                "endLine": 181,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/engine/jdbc/internal/ResultSetReturnImpl.java",
                "startLine": 75,
                "endLine": 77,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "@Override\n\tpublic ResultSet execute(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\tif ( !statement.execute( sql ) ) {\n\t\t\t\t\twhile ( !statement.getMoreResults() && statement.getUpdateCount() != -1 ) {\n\t\t\t\t\t\t// do nothing until we hit the resultset\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trs = statement.getResultSet();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t}",
        "filePathBefore": "hibernate-core/src/main/java/org/hibernate/engine/jdbc/internal/ResultSetReturnImpl.java",
        "isPureRefactoring": true,
        "commitId": "7b8c403df746e127f38d3f5f3efb45b941c36af2",
        "packageNameBefore": "org.hibernate.engine.jdbc.internal",
        "classNameBefore": "org.hibernate.engine.jdbc.internal.ResultSetReturnImpl",
        "methodNameBefore": "org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#execute",
        "invokedMethod": "methodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#jdbcExecuteStatementStart\n methodBody: private void jdbcExecuteStatementStart() {\njdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getEventHandler().jdbcExecuteStatementStart();\n}\nmethodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#context\n methodBody: private JdbcSessionContext context() {\nreturn jdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext();\n}\nmethodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#jdbcExecuteStatementEnd\n methodBody: private void jdbcExecuteStatementEnd() {\njdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getEventHandler().jdbcExecuteStatementEnd();\n}\nmethodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#postExtract\n methodBody: private void postExtract(ResultSet rs, Statement st) {\nif(rs != null){jdbcCoordinator.getLogicalConnection().getResourceRegistry().register(rs,st);\n}}\nmethodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#execute\n methodBody: public ResultSet execute(Statement statement, String sql) {\nsqlStatementLogger.logStatement(sql);\nlong executeStartNanos=0;\nif(this.sqlStatementLogger.getLogSlowQuery() > 0){executeStartNanos=System.nanoTime();\n}tryfinal ResultSet rs;\nfinal EventManager eventManager=jdbcCoordinator.getJdbcSessionOwner().getEventManager();\nfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent=eventManager.beginJdbcPreparedStatementExecutionEvent();\ntryjdbcExecuteStatementStart();\nif(!statement.execute(sql)){while(!statement.getMoreResults() && statement.getUpdateCount() != -1){}}rs=statement.getResultSet();\nfinallyeventManager.completeJdbcPreparedStatementExecutionEvent(jdbcPreparedStatementExecutionEvent,sql);\njdbcExecuteStatementEnd();\nsqlStatementLogger.logSlowQuery(sql,executeStartNanos,context());\npostExtract(rs,statement);\nreturn rs;\ncatch(SQLException e)throw sqlExceptionHelper.convert(e,\"could not execute statement\",sql);\n}",
        "classSignatureBefore": "public class ResultSetReturnImpl implements ResultSetReturn ",
        "methodNameBeforeSet": [
            "org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#execute"
        ],
        "classNameBeforeSet": [
            "org.hibernate.engine.jdbc.internal.ResultSetReturnImpl"
        ],
        "classSignatureBeforeSet": [
            "public class ResultSetReturnImpl implements ResultSetReturn "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.\n */\npackage org.hibernate.engine.jdbc.internal;\n\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\nimport org.hibernate.dialect.Dialect;\nimport org.hibernate.engine.jdbc.spi.JdbcCoordinator;\nimport org.hibernate.engine.jdbc.spi.JdbcServices;\nimport org.hibernate.engine.jdbc.spi.ResultSetReturn;\nimport org.hibernate.engine.jdbc.spi.SqlExceptionHelper;\nimport org.hibernate.engine.jdbc.spi.SqlStatementLogger;\nimport org.hibernate.event.spi.EventManager;\nimport org.hibernate.event.spi.HibernateMonitoringEvent;\nimport org.hibernate.resource.jdbc.spi.JdbcSessionContext;\n\n/**\n * Standard implementation of the ResultSetReturn contract\n *\n * @author Brett Meyer\n */\npublic class ResultSetReturnImpl implements ResultSetReturn {\n\tprivate final JdbcCoordinator jdbcCoordinator;\n\n\tprivate final Dialect dialect;\n\tprivate final SqlStatementLogger sqlStatementLogger;\n\tprivate final SqlExceptionHelper sqlExceptionHelper;\n\n\t/**\n\t * Constructs a ResultSetReturnImpl\n\t *\n\t * @param jdbcCoordinator The JdbcCoordinator\n\t */\n\tpublic ResultSetReturnImpl(JdbcCoordinator jdbcCoordinator, JdbcServices jdbcServices) {\n\t\tthis.jdbcCoordinator = jdbcCoordinator;\n\t\tthis.dialect = jdbcServices.getDialect();\n\t\tthis.sqlStatementLogger = jdbcServices.getSqlStatementLogger();\n\t\tthis.sqlExceptionHelper = jdbcServices.getSqlExceptionHelper();\n\t}\n\n\t@Override\n\tpublic ResultSet extract(PreparedStatement statement, String sql) {\n\t\t// IMPL NOTE : SQL logged by caller\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\trs = statement.executeQuery();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not extract ResultSet\", sql );\n\t\t}\n\t}\n\n\tprivate JdbcSessionContext context() {\n\t\treturn jdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext();\n\t}\n\n\tprivate void jdbcExecuteStatementEnd() {\n\t\tjdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getEventHandler().jdbcExecuteStatementEnd();\n\t}\n\n\tprivate void jdbcExecuteStatementStart() {\n\t\tjdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getEventHandler().jdbcExecuteStatementStart();\n\t}\n\n\t@Override\n\tpublic ResultSet extract(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\trs = statement.executeQuery( sql );\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not extract ResultSet\", sql );\n\t\t}\n\t}\n\n\t@Override\n\tpublic ResultSet execute(PreparedStatement statement, String sql) {\n\t\t// sql logged by StatementPreparerImpl\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\tif ( !statement.execute() ) {\n\t\t\t\t\twhile ( !statement.getMoreResults() && statement.getUpdateCount() != -1 ) {\n\t\t\t\t\t\t// do nothing until we hit the resultset\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trs = statement.getResultSet();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t}\n\n\t@Override\n\tpublic ResultSet execute(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\tif ( !statement.execute( sql ) ) {\n\t\t\t\t\twhile ( !statement.getMoreResults() && statement.getUpdateCount() != -1 ) {\n\t\t\t\t\t\t// do nothing until we hit the resultset\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trs = statement.getResultSet();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t}\n\n\t@Override\n\tpublic int executeUpdate(PreparedStatement statement, String sql) {\n\t\tassert statement != null;\n\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\ttry {\n\t\t\tjdbcExecuteStatementStart();\n\t\t\treturn statement.executeUpdate();\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t\tfinally {\n\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\tjdbcExecuteStatementEnd();\n\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t}\n\t}\n\n\t@Override\n\tpublic int executeUpdate(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\ttry {\n\t\t\tjdbcExecuteStatementStart();\n\t\t\treturn statement.executeUpdate( sql );\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t\tfinally {\n\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\tjdbcExecuteStatementEnd();\n\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t}\n\t}\n\n\tprivate void postExtract(ResultSet rs, Statement st) {\n\t\tif ( rs != null ) {\n\t\t\tjdbcCoordinator.getLogicalConnection().getResourceRegistry().register( rs, st );\n\t\t}\n\t}\n\n}\n",
        "filePathAfter": "hibernate-core/src/main/java/org/hibernate/engine/jdbc/internal/ResultSetReturnImpl.java",
        "sourceCodeAfterForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.\n */\npackage org.hibernate.engine.jdbc.internal;\n\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\nimport org.hibernate.engine.jdbc.spi.JdbcCoordinator;\nimport org.hibernate.engine.jdbc.spi.JdbcServices;\nimport org.hibernate.engine.jdbc.spi.ResultSetReturn;\nimport org.hibernate.engine.jdbc.spi.SqlExceptionHelper;\nimport org.hibernate.engine.jdbc.spi.SqlStatementLogger;\nimport org.hibernate.event.spi.EventManager;\nimport org.hibernate.event.spi.HibernateMonitoringEvent;\nimport org.hibernate.resource.jdbc.spi.JdbcEventHandler;\nimport org.hibernate.resource.jdbc.spi.JdbcSessionContext;\n\n/**\n * Standard implementation of the ResultSetReturn contract\n *\n * @author Brett Meyer\n */\npublic class ResultSetReturnImpl implements ResultSetReturn {\n\tprivate final JdbcCoordinator jdbcCoordinator;\n\n\tprivate final SqlStatementLogger sqlStatementLogger;\n\tprivate final SqlExceptionHelper sqlExceptionHelper;\n\n\t/**\n\t * Constructs a ResultSetReturnImpl\n\t *\n\t * @param jdbcCoordinator The JdbcCoordinator\n\t */\n\tpublic ResultSetReturnImpl(JdbcCoordinator jdbcCoordinator, JdbcServices jdbcServices) {\n\t\tthis.jdbcCoordinator = jdbcCoordinator;\n\t\tthis.sqlStatementLogger = jdbcServices.getSqlStatementLogger();\n\t\tthis.sqlExceptionHelper = jdbcServices.getSqlExceptionHelper();\n\t}\n\n\t@Override\n\tpublic ResultSet extract(PreparedStatement statement, String sql) {\n\t\t// IMPL NOTE : SQL logged by caller\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = getEventManager();\n\t\t\tfinal HibernateMonitoringEvent executionEvent =\n\t\t\t\t\teventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\trs = statement.executeQuery();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( executionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tendSlowQueryLogging(sql, executeStartNanos);\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not extract ResultSet\", sql );\n\t\t}\n\t}\n\n\tprivate EventManager getEventManager() {\n\t\treturn jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t}\n\n\tprivate JdbcEventHandler getEventHandler() {\n\t\treturn jdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getEventHandler();\n\t}\n\n\tprivate JdbcSessionContext context() {\n\t\treturn jdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext();\n\t}\n\n\tprivate void jdbcExecuteStatementEnd() {\n\t\tgetEventHandler().jdbcExecuteStatementEnd();\n\t}\n\n\tprivate void jdbcExecuteStatementStart() {\n\t\tgetEventHandler().jdbcExecuteStatementStart();\n\t}\n\n\t@Override\n\tpublic ResultSet extract(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = beginSlowQueryLogging();\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = getEventManager();\n\t\t\tfinal HibernateMonitoringEvent executionEvent =\n\t\t\t\t\teventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\trs = statement.executeQuery( sql );\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( executionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tendSlowQueryLogging( sql, executeStartNanos );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not extract ResultSet\", sql );\n\t\t}\n\t}\n\n\t@Override\n\tpublic ResultSet execute(PreparedStatement statement, String sql) {\n\t\t// sql logged by StatementPreparerImpl\n\t\tlong executeStartNanos = beginSlowQueryLogging();\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = getEventManager();\n\t\t\tfinal HibernateMonitoringEvent executionEvent =\n\t\t\t\t\teventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\tif ( !statement.execute() ) {\n\t\t\t\t\twhile ( !statement.getMoreResults() && statement.getUpdateCount() != -1 ) {\n\t\t\t\t\t\t// do nothing until we hit the resultset\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trs = statement.getResultSet();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( executionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tendSlowQueryLogging( sql, executeStartNanos );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t}\n\n\t@Override\n\tpublic ResultSet execute(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = beginSlowQueryLogging();\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = getEventManager();\n\t\t\tfinal HibernateMonitoringEvent executionEvent =\n\t\t\t\t\teventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\tif ( !statement.execute( sql ) ) {\n\t\t\t\t\twhile ( !statement.getMoreResults() && statement.getUpdateCount() != -1 ) {\n\t\t\t\t\t\t// do nothing until we hit the resultset\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trs = statement.getResultSet();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( executionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tendSlowQueryLogging( sql, executeStartNanos );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t}\n\n\t@Override\n\tpublic int executeUpdate(PreparedStatement statement, String sql) {\n\t\tassert statement != null;\n\t\tlong executeStartNanos = beginSlowQueryLogging();\n\t\tfinal EventManager eventManager = getEventManager();\n\t\tfinal HibernateMonitoringEvent executionEvent =\n\t\t\t\teventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\ttry {\n\t\t\tjdbcExecuteStatementStart();\n\t\t\treturn statement.executeUpdate();\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t\tfinally {\n\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( executionEvent, sql );\n\t\t\tjdbcExecuteStatementEnd();\n\t\t\tendSlowQueryLogging( sql, executeStartNanos );\n\t\t}\n\t}\n\n\t@Override\n\tpublic int executeUpdate(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = beginSlowQueryLogging();\n\t\tfinal EventManager eventManager = getEventManager();\n\t\tfinal HibernateMonitoringEvent executionEvent =\n\t\t\t\teventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\ttry {\n\t\t\tjdbcExecuteStatementStart();\n\t\t\treturn statement.executeUpdate( sql );\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t\tfinally {\n\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( executionEvent, sql );\n\t\t\tjdbcExecuteStatementEnd();\n\t\t\tendSlowQueryLogging( sql, executeStartNanos );\n\t\t}\n\t}\n\n\tprivate void endSlowQueryLogging(String sql, long executeStartNanos) {\n\t\tsqlStatementLogger.logSlowQuery(sql, executeStartNanos, context() );\n\t}\n\n\tprivate long beginSlowQueryLogging() {\n\t\treturn sqlStatementLogger.getLogSlowQuery() > 0 ? System.nanoTime() : 0;\n\t}\n\n\tprivate void postExtract(ResultSet rs, Statement st) {\n\t\tif ( rs != null ) {\n\t\t\tjdbcCoordinator.getLogicalConnection().getResourceRegistry().register( rs, st );\n\t\t}\n\t}\n\n}\n",
        "diffSourceCodeSet": [
            "private EventManager getEventManager() {\n\t\treturn jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t}"
        ],
        "invokedMethodSet": [
            "methodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#jdbcExecuteStatementStart\n methodBody: private void jdbcExecuteStatementStart() {\njdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getEventHandler().jdbcExecuteStatementStart();\n}",
            "methodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#context\n methodBody: private JdbcSessionContext context() {\nreturn jdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext();\n}",
            "methodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#jdbcExecuteStatementEnd\n methodBody: private void jdbcExecuteStatementEnd() {\njdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getEventHandler().jdbcExecuteStatementEnd();\n}",
            "methodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#postExtract\n methodBody: private void postExtract(ResultSet rs, Statement st) {\nif(rs != null){jdbcCoordinator.getLogicalConnection().getResourceRegistry().register(rs,st);\n}}",
            "methodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#execute\n methodBody: public ResultSet execute(Statement statement, String sql) {\nsqlStatementLogger.logStatement(sql);\nlong executeStartNanos=0;\nif(this.sqlStatementLogger.getLogSlowQuery() > 0){executeStartNanos=System.nanoTime();\n}tryfinal ResultSet rs;\nfinal EventManager eventManager=jdbcCoordinator.getJdbcSessionOwner().getEventManager();\nfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent=eventManager.beginJdbcPreparedStatementExecutionEvent();\ntryjdbcExecuteStatementStart();\nif(!statement.execute(sql)){while(!statement.getMoreResults() && statement.getUpdateCount() != -1){}}rs=statement.getResultSet();\nfinallyeventManager.completeJdbcPreparedStatementExecutionEvent(jdbcPreparedStatementExecutionEvent,sql);\njdbcExecuteStatementEnd();\nsqlStatementLogger.logSlowQuery(sql,executeStartNanos,context());\npostExtract(rs,statement);\nreturn rs;\ncatch(SQLException e)throw sqlExceptionHelper.convert(e,\"could not execute statement\",sql);\n}"
        ],
        "sourceCodeAfterRefactoring": "@Override\n\tpublic ResultSet execute(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = beginSlowQueryLogging();\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = getEventManager();\n\t\t\tfinal HibernateMonitoringEvent executionEvent =\n\t\t\t\t\teventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\tif ( !statement.execute( sql ) ) {\n\t\t\t\t\twhile ( !statement.getMoreResults() && statement.getUpdateCount() != -1 ) {\n\t\t\t\t\t\t// do nothing until we hit the resultset\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trs = statement.getResultSet();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( executionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tendSlowQueryLogging( sql, executeStartNanos );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t}\nprivate EventManager getEventManager() {\n\t\treturn jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t}",
        "diffSourceCode": "-   75: \n-   76: \tprivate JdbcSessionContext context() {\n-   77: \t\treturn jdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext();\n-  149: \t@Override\n-  150: \tpublic ResultSet execute(Statement statement, String sql) {\n-  151: \t\tsqlStatementLogger.logStatement( sql );\n-  152: \t\tlong executeStartNanos = 0;\n-  153: \t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n-  154: \t\t\texecuteStartNanos = System.nanoTime();\n-  155: \t\t}\n+   75: \tprivate EventManager getEventManager() {\n+   76: \t\treturn jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n+   77: \t}\n+  149: \t\t}\n+  150: \t}\n+  151: \n+  152: \t@Override\n+  153: \tpublic ResultSet execute(Statement statement, String sql) {\n+  154: \t\tsqlStatementLogger.logStatement( sql );\n+  155: \t\tlong executeStartNanos = beginSlowQueryLogging();\n   156: \t\ttry {\n   157: \t\t\tfinal ResultSet rs;\n-  158: \t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n-  159: \t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n-  160: \t\t\ttry {\n-  161: \t\t\t\tjdbcExecuteStatementStart();\n-  162: \t\t\t\tif ( !statement.execute( sql ) ) {\n-  163: \t\t\t\t\twhile ( !statement.getMoreResults() && statement.getUpdateCount() != -1 ) {\n-  164: \t\t\t\t\t\t// do nothing until we hit the resultset\n-  165: \t\t\t\t\t}\n-  166: \t\t\t\t}\n-  167: \t\t\t\trs = statement.getResultSet();\n-  168: \t\t\t}\n-  169: \t\t\tfinally {\n-  170: \t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n-  171: \t\t\t\tjdbcExecuteStatementEnd();\n-  172: \t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n-  173: \t\t\t}\n-  174: \t\t\tpostExtract( rs, statement );\n-  175: \t\t\treturn rs;\n-  176: \t\t}\n-  177: \t\tcatch (SQLException e) {\n-  178: \t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n-  179: \t\t}\n-  180: \t}\n-  181: \n+  158: \t\t\tfinal EventManager eventManager = getEventManager();\n+  159: \t\t\tfinal HibernateMonitoringEvent executionEvent =\n+  160: \t\t\t\t\teventManager.beginJdbcPreparedStatementExecutionEvent();\n+  161: \t\t\ttry {\n+  162: \t\t\t\tjdbcExecuteStatementStart();\n+  163: \t\t\t\tif ( !statement.execute( sql ) ) {\n+  164: \t\t\t\t\twhile ( !statement.getMoreResults() && statement.getUpdateCount() != -1 ) {\n+  165: \t\t\t\t\t\t// do nothing until we hit the resultset\n+  166: \t\t\t\t\t}\n+  167: \t\t\t\t}\n+  168: \t\t\t\trs = statement.getResultSet();\n+  169: \t\t\t}\n+  170: \t\t\tfinally {\n+  171: \t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( executionEvent, sql );\n+  172: \t\t\t\tjdbcExecuteStatementEnd();\n+  173: \t\t\t\tendSlowQueryLogging( sql, executeStartNanos );\n+  174: \t\t\t}\n+  175: \t\t\tpostExtract( rs, statement );\n+  176: \t\t\treturn rs;\n+  177: \t\t}\n+  178: \t\tcatch (SQLException e) {\n+  179: \t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n+  180: \t\t}\n+  181: \t}\n",
        "uniqueId": "7b8c403df746e127f38d3f5f3efb45b941c36af2_149_180_75_77_152_181",
        "moveFileExist": true,
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 21,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 9,
                "covered": 45
            },
            "BRANCH": {
                "missed": 3,
                "covered": 3
            },
            "LINE": {
                "missed": 2,
                "covered": 14
            },
            "COMPLEXITY": {
                "missed": 3,
                "covered": 1
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        }
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprivate beginSlowQueryLogging() : long extracted from public execute(statement PreparedStatement, sql String) : ResultSet in class org.hibernate.engine.jdbc.internal.ResultSetReturnImpl",
        "diffLocations": [
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/engine/jdbc/internal/ResultSetReturnImpl.java",
                "startLine": 116,
                "endLine": 147,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/engine/jdbc/internal/ResultSetReturnImpl.java",
                "startLine": 121,
                "endLine": 150,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/engine/jdbc/internal/ResultSetReturnImpl.java",
                "startLine": 229,
                "endLine": 231,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "@Override\n\tpublic ResultSet execute(PreparedStatement statement, String sql) {\n\t\t// sql logged by StatementPreparerImpl\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\tif ( !statement.execute() ) {\n\t\t\t\t\twhile ( !statement.getMoreResults() && statement.getUpdateCount() != -1 ) {\n\t\t\t\t\t\t// do nothing until we hit the resultset\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trs = statement.getResultSet();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t}",
        "filePathBefore": "hibernate-core/src/main/java/org/hibernate/engine/jdbc/internal/ResultSetReturnImpl.java",
        "isPureRefactoring": true,
        "commitId": "7b8c403df746e127f38d3f5f3efb45b941c36af2",
        "packageNameBefore": "org.hibernate.engine.jdbc.internal",
        "classNameBefore": "org.hibernate.engine.jdbc.internal.ResultSetReturnImpl",
        "methodNameBefore": "org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#execute",
        "invokedMethod": "methodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#jdbcExecuteStatementStart\n methodBody: private void jdbcExecuteStatementStart() {\njdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getEventHandler().jdbcExecuteStatementStart();\n}\nmethodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#context\n methodBody: private JdbcSessionContext context() {\nreturn jdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext();\n}\nmethodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#jdbcExecuteStatementEnd\n methodBody: private void jdbcExecuteStatementEnd() {\njdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getEventHandler().jdbcExecuteStatementEnd();\n}\nmethodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#postExtract\n methodBody: private void postExtract(ResultSet rs, Statement st) {\nif(rs != null){jdbcCoordinator.getLogicalConnection().getResourceRegistry().register(rs,st);\n}}\nmethodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#execute\n methodBody: public ResultSet execute(Statement statement, String sql) {\nsqlStatementLogger.logStatement(sql);\nlong executeStartNanos=0;\nif(this.sqlStatementLogger.getLogSlowQuery() > 0){executeStartNanos=System.nanoTime();\n}tryfinal ResultSet rs;\nfinal EventManager eventManager=jdbcCoordinator.getJdbcSessionOwner().getEventManager();\nfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent=eventManager.beginJdbcPreparedStatementExecutionEvent();\ntryjdbcExecuteStatementStart();\nif(!statement.execute(sql)){while(!statement.getMoreResults() && statement.getUpdateCount() != -1){}}rs=statement.getResultSet();\nfinallyeventManager.completeJdbcPreparedStatementExecutionEvent(jdbcPreparedStatementExecutionEvent,sql);\njdbcExecuteStatementEnd();\nsqlStatementLogger.logSlowQuery(sql,executeStartNanos,context());\npostExtract(rs,statement);\nreturn rs;\ncatch(SQLException e)throw sqlExceptionHelper.convert(e,\"could not execute statement\",sql);\n}",
        "classSignatureBefore": "public class ResultSetReturnImpl implements ResultSetReturn ",
        "methodNameBeforeSet": [
            "org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#execute"
        ],
        "classNameBeforeSet": [
            "org.hibernate.engine.jdbc.internal.ResultSetReturnImpl"
        ],
        "classSignatureBeforeSet": [
            "public class ResultSetReturnImpl implements ResultSetReturn "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Tolerable changes in the body\n",
                "description": "All replacements have been justified - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.\n */\npackage org.hibernate.engine.jdbc.internal;\n\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\nimport org.hibernate.dialect.Dialect;\nimport org.hibernate.engine.jdbc.spi.JdbcCoordinator;\nimport org.hibernate.engine.jdbc.spi.JdbcServices;\nimport org.hibernate.engine.jdbc.spi.ResultSetReturn;\nimport org.hibernate.engine.jdbc.spi.SqlExceptionHelper;\nimport org.hibernate.engine.jdbc.spi.SqlStatementLogger;\nimport org.hibernate.event.spi.EventManager;\nimport org.hibernate.event.spi.HibernateMonitoringEvent;\nimport org.hibernate.resource.jdbc.spi.JdbcSessionContext;\n\n/**\n * Standard implementation of the ResultSetReturn contract\n *\n * @author Brett Meyer\n */\npublic class ResultSetReturnImpl implements ResultSetReturn {\n\tprivate final JdbcCoordinator jdbcCoordinator;\n\n\tprivate final Dialect dialect;\n\tprivate final SqlStatementLogger sqlStatementLogger;\n\tprivate final SqlExceptionHelper sqlExceptionHelper;\n\n\t/**\n\t * Constructs a ResultSetReturnImpl\n\t *\n\t * @param jdbcCoordinator The JdbcCoordinator\n\t */\n\tpublic ResultSetReturnImpl(JdbcCoordinator jdbcCoordinator, JdbcServices jdbcServices) {\n\t\tthis.jdbcCoordinator = jdbcCoordinator;\n\t\tthis.dialect = jdbcServices.getDialect();\n\t\tthis.sqlStatementLogger = jdbcServices.getSqlStatementLogger();\n\t\tthis.sqlExceptionHelper = jdbcServices.getSqlExceptionHelper();\n\t}\n\n\t@Override\n\tpublic ResultSet extract(PreparedStatement statement, String sql) {\n\t\t// IMPL NOTE : SQL logged by caller\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\trs = statement.executeQuery();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not extract ResultSet\", sql );\n\t\t}\n\t}\n\n\tprivate JdbcSessionContext context() {\n\t\treturn jdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext();\n\t}\n\n\tprivate void jdbcExecuteStatementEnd() {\n\t\tjdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getEventHandler().jdbcExecuteStatementEnd();\n\t}\n\n\tprivate void jdbcExecuteStatementStart() {\n\t\tjdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getEventHandler().jdbcExecuteStatementStart();\n\t}\n\n\t@Override\n\tpublic ResultSet extract(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\trs = statement.executeQuery( sql );\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not extract ResultSet\", sql );\n\t\t}\n\t}\n\n\t@Override\n\tpublic ResultSet execute(PreparedStatement statement, String sql) {\n\t\t// sql logged by StatementPreparerImpl\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\tif ( !statement.execute() ) {\n\t\t\t\t\twhile ( !statement.getMoreResults() && statement.getUpdateCount() != -1 ) {\n\t\t\t\t\t\t// do nothing until we hit the resultset\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trs = statement.getResultSet();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t}\n\n\t@Override\n\tpublic ResultSet execute(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\tif ( !statement.execute( sql ) ) {\n\t\t\t\t\twhile ( !statement.getMoreResults() && statement.getUpdateCount() != -1 ) {\n\t\t\t\t\t\t// do nothing until we hit the resultset\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trs = statement.getResultSet();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t}\n\n\t@Override\n\tpublic int executeUpdate(PreparedStatement statement, String sql) {\n\t\tassert statement != null;\n\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\ttry {\n\t\t\tjdbcExecuteStatementStart();\n\t\t\treturn statement.executeUpdate();\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t\tfinally {\n\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\tjdbcExecuteStatementEnd();\n\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t}\n\t}\n\n\t@Override\n\tpublic int executeUpdate(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\ttry {\n\t\t\tjdbcExecuteStatementStart();\n\t\t\treturn statement.executeUpdate( sql );\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t\tfinally {\n\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\tjdbcExecuteStatementEnd();\n\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t}\n\t}\n\n\tprivate void postExtract(ResultSet rs, Statement st) {\n\t\tif ( rs != null ) {\n\t\t\tjdbcCoordinator.getLogicalConnection().getResourceRegistry().register( rs, st );\n\t\t}\n\t}\n\n}\n",
        "filePathAfter": "hibernate-core/src/main/java/org/hibernate/engine/jdbc/internal/ResultSetReturnImpl.java",
        "sourceCodeAfterForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.\n */\npackage org.hibernate.engine.jdbc.internal;\n\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\nimport org.hibernate.engine.jdbc.spi.JdbcCoordinator;\nimport org.hibernate.engine.jdbc.spi.JdbcServices;\nimport org.hibernate.engine.jdbc.spi.ResultSetReturn;\nimport org.hibernate.engine.jdbc.spi.SqlExceptionHelper;\nimport org.hibernate.engine.jdbc.spi.SqlStatementLogger;\nimport org.hibernate.event.spi.EventManager;\nimport org.hibernate.event.spi.HibernateMonitoringEvent;\nimport org.hibernate.resource.jdbc.spi.JdbcEventHandler;\nimport org.hibernate.resource.jdbc.spi.JdbcSessionContext;\n\n/**\n * Standard implementation of the ResultSetReturn contract\n *\n * @author Brett Meyer\n */\npublic class ResultSetReturnImpl implements ResultSetReturn {\n\tprivate final JdbcCoordinator jdbcCoordinator;\n\n\tprivate final SqlStatementLogger sqlStatementLogger;\n\tprivate final SqlExceptionHelper sqlExceptionHelper;\n\n\t/**\n\t * Constructs a ResultSetReturnImpl\n\t *\n\t * @param jdbcCoordinator The JdbcCoordinator\n\t */\n\tpublic ResultSetReturnImpl(JdbcCoordinator jdbcCoordinator, JdbcServices jdbcServices) {\n\t\tthis.jdbcCoordinator = jdbcCoordinator;\n\t\tthis.sqlStatementLogger = jdbcServices.getSqlStatementLogger();\n\t\tthis.sqlExceptionHelper = jdbcServices.getSqlExceptionHelper();\n\t}\n\n\t@Override\n\tpublic ResultSet extract(PreparedStatement statement, String sql) {\n\t\t// IMPL NOTE : SQL logged by caller\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = getEventManager();\n\t\t\tfinal HibernateMonitoringEvent executionEvent =\n\t\t\t\t\teventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\trs = statement.executeQuery();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( executionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tendSlowQueryLogging(sql, executeStartNanos);\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not extract ResultSet\", sql );\n\t\t}\n\t}\n\n\tprivate EventManager getEventManager() {\n\t\treturn jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t}\n\n\tprivate JdbcEventHandler getEventHandler() {\n\t\treturn jdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getEventHandler();\n\t}\n\n\tprivate JdbcSessionContext context() {\n\t\treturn jdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext();\n\t}\n\n\tprivate void jdbcExecuteStatementEnd() {\n\t\tgetEventHandler().jdbcExecuteStatementEnd();\n\t}\n\n\tprivate void jdbcExecuteStatementStart() {\n\t\tgetEventHandler().jdbcExecuteStatementStart();\n\t}\n\n\t@Override\n\tpublic ResultSet extract(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = beginSlowQueryLogging();\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = getEventManager();\n\t\t\tfinal HibernateMonitoringEvent executionEvent =\n\t\t\t\t\teventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\trs = statement.executeQuery( sql );\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( executionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tendSlowQueryLogging( sql, executeStartNanos );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not extract ResultSet\", sql );\n\t\t}\n\t}\n\n\t@Override\n\tpublic ResultSet execute(PreparedStatement statement, String sql) {\n\t\t// sql logged by StatementPreparerImpl\n\t\tlong executeStartNanos = beginSlowQueryLogging();\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = getEventManager();\n\t\t\tfinal HibernateMonitoringEvent executionEvent =\n\t\t\t\t\teventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\tif ( !statement.execute() ) {\n\t\t\t\t\twhile ( !statement.getMoreResults() && statement.getUpdateCount() != -1 ) {\n\t\t\t\t\t\t// do nothing until we hit the resultset\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trs = statement.getResultSet();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( executionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tendSlowQueryLogging( sql, executeStartNanos );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t}\n\n\t@Override\n\tpublic ResultSet execute(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = beginSlowQueryLogging();\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = getEventManager();\n\t\t\tfinal HibernateMonitoringEvent executionEvent =\n\t\t\t\t\teventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\tif ( !statement.execute( sql ) ) {\n\t\t\t\t\twhile ( !statement.getMoreResults() && statement.getUpdateCount() != -1 ) {\n\t\t\t\t\t\t// do nothing until we hit the resultset\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trs = statement.getResultSet();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( executionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tendSlowQueryLogging( sql, executeStartNanos );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t}\n\n\t@Override\n\tpublic int executeUpdate(PreparedStatement statement, String sql) {\n\t\tassert statement != null;\n\t\tlong executeStartNanos = beginSlowQueryLogging();\n\t\tfinal EventManager eventManager = getEventManager();\n\t\tfinal HibernateMonitoringEvent executionEvent =\n\t\t\t\teventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\ttry {\n\t\t\tjdbcExecuteStatementStart();\n\t\t\treturn statement.executeUpdate();\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t\tfinally {\n\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( executionEvent, sql );\n\t\t\tjdbcExecuteStatementEnd();\n\t\t\tendSlowQueryLogging( sql, executeStartNanos );\n\t\t}\n\t}\n\n\t@Override\n\tpublic int executeUpdate(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = beginSlowQueryLogging();\n\t\tfinal EventManager eventManager = getEventManager();\n\t\tfinal HibernateMonitoringEvent executionEvent =\n\t\t\t\teventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\ttry {\n\t\t\tjdbcExecuteStatementStart();\n\t\t\treturn statement.executeUpdate( sql );\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t\tfinally {\n\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( executionEvent, sql );\n\t\t\tjdbcExecuteStatementEnd();\n\t\t\tendSlowQueryLogging( sql, executeStartNanos );\n\t\t}\n\t}\n\n\tprivate void endSlowQueryLogging(String sql, long executeStartNanos) {\n\t\tsqlStatementLogger.logSlowQuery(sql, executeStartNanos, context() );\n\t}\n\n\tprivate long beginSlowQueryLogging() {\n\t\treturn sqlStatementLogger.getLogSlowQuery() > 0 ? System.nanoTime() : 0;\n\t}\n\n\tprivate void postExtract(ResultSet rs, Statement st) {\n\t\tif ( rs != null ) {\n\t\t\tjdbcCoordinator.getLogicalConnection().getResourceRegistry().register( rs, st );\n\t\t}\n\t}\n\n}\n",
        "diffSourceCodeSet": [
            "private long beginSlowQueryLogging() {\n\t\treturn sqlStatementLogger.getLogSlowQuery() > 0 ? System.nanoTime() : 0;\n\t}"
        ],
        "invokedMethodSet": [
            "methodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#jdbcExecuteStatementStart\n methodBody: private void jdbcExecuteStatementStart() {\njdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getEventHandler().jdbcExecuteStatementStart();\n}",
            "methodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#context\n methodBody: private JdbcSessionContext context() {\nreturn jdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext();\n}",
            "methodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#jdbcExecuteStatementEnd\n methodBody: private void jdbcExecuteStatementEnd() {\njdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getEventHandler().jdbcExecuteStatementEnd();\n}",
            "methodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#postExtract\n methodBody: private void postExtract(ResultSet rs, Statement st) {\nif(rs != null){jdbcCoordinator.getLogicalConnection().getResourceRegistry().register(rs,st);\n}}",
            "methodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#execute\n methodBody: public ResultSet execute(Statement statement, String sql) {\nsqlStatementLogger.logStatement(sql);\nlong executeStartNanos=0;\nif(this.sqlStatementLogger.getLogSlowQuery() > 0){executeStartNanos=System.nanoTime();\n}tryfinal ResultSet rs;\nfinal EventManager eventManager=jdbcCoordinator.getJdbcSessionOwner().getEventManager();\nfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent=eventManager.beginJdbcPreparedStatementExecutionEvent();\ntryjdbcExecuteStatementStart();\nif(!statement.execute(sql)){while(!statement.getMoreResults() && statement.getUpdateCount() != -1){}}rs=statement.getResultSet();\nfinallyeventManager.completeJdbcPreparedStatementExecutionEvent(jdbcPreparedStatementExecutionEvent,sql);\njdbcExecuteStatementEnd();\nsqlStatementLogger.logSlowQuery(sql,executeStartNanos,context());\npostExtract(rs,statement);\nreturn rs;\ncatch(SQLException e)throw sqlExceptionHelper.convert(e,\"could not execute statement\",sql);\n}"
        ],
        "sourceCodeAfterRefactoring": "@Override\n\tpublic ResultSet execute(PreparedStatement statement, String sql) {\n\t\t// sql logged by StatementPreparerImpl\n\t\tlong executeStartNanos = beginSlowQueryLogging();\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = getEventManager();\n\t\t\tfinal HibernateMonitoringEvent executionEvent =\n\t\t\t\t\teventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\tif ( !statement.execute() ) {\n\t\t\t\t\twhile ( !statement.getMoreResults() && statement.getUpdateCount() != -1 ) {\n\t\t\t\t\t\t// do nothing until we hit the resultset\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trs = statement.getResultSet();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( executionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tendSlowQueryLogging( sql, executeStartNanos );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t}\nprivate long beginSlowQueryLogging() {\n\t\treturn sqlStatementLogger.getLogSlowQuery() > 0 ? System.nanoTime() : 0;\n\t}",
        "diffSourceCode": "-  116: \t@Override\n-  117: \tpublic ResultSet execute(PreparedStatement statement, String sql) {\n-  118: \t\t// sql logged by StatementPreparerImpl\n-  119: \t\tlong executeStartNanos = 0;\n-  120: \t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n-  121: \t\t\texecuteStartNanos = System.nanoTime();\n-  122: \t\t}\n-  123: \t\ttry {\n-  124: \t\t\tfinal ResultSet rs;\n-  125: \t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n-  126: \t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n-  127: \t\t\ttry {\n-  128: \t\t\t\tjdbcExecuteStatementStart();\n-  129: \t\t\t\tif ( !statement.execute() ) {\n-  130: \t\t\t\t\twhile ( !statement.getMoreResults() && statement.getUpdateCount() != -1 ) {\n-  131: \t\t\t\t\t\t// do nothing until we hit the resultset\n-  132: \t\t\t\t\t}\n-  133: \t\t\t\t}\n-  134: \t\t\t\trs = statement.getResultSet();\n-  135: \t\t\t}\n-  136: \t\t\tfinally {\n-  137: \t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n-  138: \t\t\t\tjdbcExecuteStatementEnd();\n-  139: \t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n-  140: \t\t\t}\n-  141: \t\t\tpostExtract( rs, statement );\n-  142: \t\t\treturn rs;\n-  143: \t\t}\n-  144: \t\tcatch (SQLException e) {\n-  145: \t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n+  116: \t\tcatch (SQLException e) {\n+  117: \t\t\tthrow sqlExceptionHelper.convert( e, \"could not extract ResultSet\", sql );\n+  118: \t\t}\n+  119: \t}\n+  120: \n+  121: \t@Override\n+  122: \tpublic ResultSet execute(PreparedStatement statement, String sql) {\n+  123: \t\t// sql logged by StatementPreparerImpl\n+  124: \t\tlong executeStartNanos = beginSlowQueryLogging();\n+  125: \t\ttry {\n+  126: \t\t\tfinal ResultSet rs;\n+  127: \t\t\tfinal EventManager eventManager = getEventManager();\n+  128: \t\t\tfinal HibernateMonitoringEvent executionEvent =\n+  129: \t\t\t\t\teventManager.beginJdbcPreparedStatementExecutionEvent();\n+  130: \t\t\ttry {\n+  131: \t\t\t\tjdbcExecuteStatementStart();\n+  132: \t\t\t\tif ( !statement.execute() ) {\n+  133: \t\t\t\t\twhile ( !statement.getMoreResults() && statement.getUpdateCount() != -1 ) {\n+  134: \t\t\t\t\t\t// do nothing until we hit the resultset\n+  135: \t\t\t\t\t}\n+  136: \t\t\t\t}\n+  137: \t\t\t\trs = statement.getResultSet();\n+  138: \t\t\t}\n+  139: \t\t\tfinally {\n+  140: \t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( executionEvent, sql );\n+  141: \t\t\t\tjdbcExecuteStatementEnd();\n+  142: \t\t\t\tendSlowQueryLogging( sql, executeStartNanos );\n+  143: \t\t\t}\n+  144: \t\t\tpostExtract( rs, statement );\n+  145: \t\t\treturn rs;\n   146: \t\t}\n-  147: \t}\n-  148: \n-  149: \t@Override\n-  150: \tpublic ResultSet execute(Statement statement, String sql) {\n-  229: \tprivate void postExtract(ResultSet rs, Statement st) {\n-  230: \t\tif ( rs != null ) {\n-  231: \t\t\tjdbcCoordinator.getLogicalConnection().getResourceRegistry().register( rs, st );\n+  147: \t\tcatch (SQLException e) {\n+  148: \t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n+  149: \t\t}\n+  150: \t}\n+  229: \tprivate long beginSlowQueryLogging() {\n+  230: \t\treturn sqlStatementLogger.getLogSlowQuery() > 0 ? System.nanoTime() : 0;\n+  231: \t}\n",
        "uniqueId": "7b8c403df746e127f38d3f5f3efb45b941c36af2_116_147_229_231_121_150",
        "moveFileExist": true,
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 21,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 9,
                "covered": 45
            },
            "BRANCH": {
                "missed": 3,
                "covered": 3
            },
            "LINE": {
                "missed": 2,
                "covered": 14
            },
            "COMPLEXITY": {
                "missed": 3,
                "covered": 1
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        }
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprivate endSlowQueryLogging(sql String, executeStartNanos long) : void extracted from public execute(statement PreparedStatement, sql String) : ResultSet in class org.hibernate.engine.jdbc.internal.ResultSetReturnImpl",
        "diffLocations": [
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/engine/jdbc/internal/ResultSetReturnImpl.java",
                "startLine": 116,
                "endLine": 147,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/engine/jdbc/internal/ResultSetReturnImpl.java",
                "startLine": 121,
                "endLine": 150,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/engine/jdbc/internal/ResultSetReturnImpl.java",
                "startLine": 225,
                "endLine": 227,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "@Override\n\tpublic ResultSet execute(PreparedStatement statement, String sql) {\n\t\t// sql logged by StatementPreparerImpl\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\tif ( !statement.execute() ) {\n\t\t\t\t\twhile ( !statement.getMoreResults() && statement.getUpdateCount() != -1 ) {\n\t\t\t\t\t\t// do nothing until we hit the resultset\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trs = statement.getResultSet();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t}",
        "filePathBefore": "hibernate-core/src/main/java/org/hibernate/engine/jdbc/internal/ResultSetReturnImpl.java",
        "isPureRefactoring": true,
        "commitId": "7b8c403df746e127f38d3f5f3efb45b941c36af2",
        "packageNameBefore": "org.hibernate.engine.jdbc.internal",
        "classNameBefore": "org.hibernate.engine.jdbc.internal.ResultSetReturnImpl",
        "methodNameBefore": "org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#execute",
        "invokedMethod": "methodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#jdbcExecuteStatementStart\n methodBody: private void jdbcExecuteStatementStart() {\njdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getEventHandler().jdbcExecuteStatementStart();\n}\nmethodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#context\n methodBody: private JdbcSessionContext context() {\nreturn jdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext();\n}\nmethodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#jdbcExecuteStatementEnd\n methodBody: private void jdbcExecuteStatementEnd() {\njdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getEventHandler().jdbcExecuteStatementEnd();\n}\nmethodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#postExtract\n methodBody: private void postExtract(ResultSet rs, Statement st) {\nif(rs != null){jdbcCoordinator.getLogicalConnection().getResourceRegistry().register(rs,st);\n}}\nmethodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#execute\n methodBody: public ResultSet execute(Statement statement, String sql) {\nsqlStatementLogger.logStatement(sql);\nlong executeStartNanos=0;\nif(this.sqlStatementLogger.getLogSlowQuery() > 0){executeStartNanos=System.nanoTime();\n}tryfinal ResultSet rs;\nfinal EventManager eventManager=jdbcCoordinator.getJdbcSessionOwner().getEventManager();\nfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent=eventManager.beginJdbcPreparedStatementExecutionEvent();\ntryjdbcExecuteStatementStart();\nif(!statement.execute(sql)){while(!statement.getMoreResults() && statement.getUpdateCount() != -1){}}rs=statement.getResultSet();\nfinallyeventManager.completeJdbcPreparedStatementExecutionEvent(jdbcPreparedStatementExecutionEvent,sql);\njdbcExecuteStatementEnd();\nsqlStatementLogger.logSlowQuery(sql,executeStartNanos,context());\npostExtract(rs,statement);\nreturn rs;\ncatch(SQLException e)throw sqlExceptionHelper.convert(e,\"could not execute statement\",sql);\n}",
        "classSignatureBefore": "public class ResultSetReturnImpl implements ResultSetReturn ",
        "methodNameBeforeSet": [
            "org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#execute"
        ],
        "classNameBeforeSet": [
            "org.hibernate.engine.jdbc.internal.ResultSetReturnImpl"
        ],
        "classSignatureBeforeSet": [
            "public class ResultSetReturnImpl implements ResultSetReturn "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.\n */\npackage org.hibernate.engine.jdbc.internal;\n\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\nimport org.hibernate.dialect.Dialect;\nimport org.hibernate.engine.jdbc.spi.JdbcCoordinator;\nimport org.hibernate.engine.jdbc.spi.JdbcServices;\nimport org.hibernate.engine.jdbc.spi.ResultSetReturn;\nimport org.hibernate.engine.jdbc.spi.SqlExceptionHelper;\nimport org.hibernate.engine.jdbc.spi.SqlStatementLogger;\nimport org.hibernate.event.spi.EventManager;\nimport org.hibernate.event.spi.HibernateMonitoringEvent;\nimport org.hibernate.resource.jdbc.spi.JdbcSessionContext;\n\n/**\n * Standard implementation of the ResultSetReturn contract\n *\n * @author Brett Meyer\n */\npublic class ResultSetReturnImpl implements ResultSetReturn {\n\tprivate final JdbcCoordinator jdbcCoordinator;\n\n\tprivate final Dialect dialect;\n\tprivate final SqlStatementLogger sqlStatementLogger;\n\tprivate final SqlExceptionHelper sqlExceptionHelper;\n\n\t/**\n\t * Constructs a ResultSetReturnImpl\n\t *\n\t * @param jdbcCoordinator The JdbcCoordinator\n\t */\n\tpublic ResultSetReturnImpl(JdbcCoordinator jdbcCoordinator, JdbcServices jdbcServices) {\n\t\tthis.jdbcCoordinator = jdbcCoordinator;\n\t\tthis.dialect = jdbcServices.getDialect();\n\t\tthis.sqlStatementLogger = jdbcServices.getSqlStatementLogger();\n\t\tthis.sqlExceptionHelper = jdbcServices.getSqlExceptionHelper();\n\t}\n\n\t@Override\n\tpublic ResultSet extract(PreparedStatement statement, String sql) {\n\t\t// IMPL NOTE : SQL logged by caller\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\trs = statement.executeQuery();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not extract ResultSet\", sql );\n\t\t}\n\t}\n\n\tprivate JdbcSessionContext context() {\n\t\treturn jdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext();\n\t}\n\n\tprivate void jdbcExecuteStatementEnd() {\n\t\tjdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getEventHandler().jdbcExecuteStatementEnd();\n\t}\n\n\tprivate void jdbcExecuteStatementStart() {\n\t\tjdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getEventHandler().jdbcExecuteStatementStart();\n\t}\n\n\t@Override\n\tpublic ResultSet extract(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\trs = statement.executeQuery( sql );\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not extract ResultSet\", sql );\n\t\t}\n\t}\n\n\t@Override\n\tpublic ResultSet execute(PreparedStatement statement, String sql) {\n\t\t// sql logged by StatementPreparerImpl\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\tif ( !statement.execute() ) {\n\t\t\t\t\twhile ( !statement.getMoreResults() && statement.getUpdateCount() != -1 ) {\n\t\t\t\t\t\t// do nothing until we hit the resultset\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trs = statement.getResultSet();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t}\n\n\t@Override\n\tpublic ResultSet execute(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\tif ( !statement.execute( sql ) ) {\n\t\t\t\t\twhile ( !statement.getMoreResults() && statement.getUpdateCount() != -1 ) {\n\t\t\t\t\t\t// do nothing until we hit the resultset\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trs = statement.getResultSet();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t}\n\n\t@Override\n\tpublic int executeUpdate(PreparedStatement statement, String sql) {\n\t\tassert statement != null;\n\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\ttry {\n\t\t\tjdbcExecuteStatementStart();\n\t\t\treturn statement.executeUpdate();\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t\tfinally {\n\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\tjdbcExecuteStatementEnd();\n\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t}\n\t}\n\n\t@Override\n\tpublic int executeUpdate(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\ttry {\n\t\t\tjdbcExecuteStatementStart();\n\t\t\treturn statement.executeUpdate( sql );\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t\tfinally {\n\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\tjdbcExecuteStatementEnd();\n\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t}\n\t}\n\n\tprivate void postExtract(ResultSet rs, Statement st) {\n\t\tif ( rs != null ) {\n\t\t\tjdbcCoordinator.getLogicalConnection().getResourceRegistry().register( rs, st );\n\t\t}\n\t}\n\n}\n",
        "filePathAfter": "hibernate-core/src/main/java/org/hibernate/engine/jdbc/internal/ResultSetReturnImpl.java",
        "sourceCodeAfterForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.\n */\npackage org.hibernate.engine.jdbc.internal;\n\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\nimport org.hibernate.engine.jdbc.spi.JdbcCoordinator;\nimport org.hibernate.engine.jdbc.spi.JdbcServices;\nimport org.hibernate.engine.jdbc.spi.ResultSetReturn;\nimport org.hibernate.engine.jdbc.spi.SqlExceptionHelper;\nimport org.hibernate.engine.jdbc.spi.SqlStatementLogger;\nimport org.hibernate.event.spi.EventManager;\nimport org.hibernate.event.spi.HibernateMonitoringEvent;\nimport org.hibernate.resource.jdbc.spi.JdbcEventHandler;\nimport org.hibernate.resource.jdbc.spi.JdbcSessionContext;\n\n/**\n * Standard implementation of the ResultSetReturn contract\n *\n * @author Brett Meyer\n */\npublic class ResultSetReturnImpl implements ResultSetReturn {\n\tprivate final JdbcCoordinator jdbcCoordinator;\n\n\tprivate final SqlStatementLogger sqlStatementLogger;\n\tprivate final SqlExceptionHelper sqlExceptionHelper;\n\n\t/**\n\t * Constructs a ResultSetReturnImpl\n\t *\n\t * @param jdbcCoordinator The JdbcCoordinator\n\t */\n\tpublic ResultSetReturnImpl(JdbcCoordinator jdbcCoordinator, JdbcServices jdbcServices) {\n\t\tthis.jdbcCoordinator = jdbcCoordinator;\n\t\tthis.sqlStatementLogger = jdbcServices.getSqlStatementLogger();\n\t\tthis.sqlExceptionHelper = jdbcServices.getSqlExceptionHelper();\n\t}\n\n\t@Override\n\tpublic ResultSet extract(PreparedStatement statement, String sql) {\n\t\t// IMPL NOTE : SQL logged by caller\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = getEventManager();\n\t\t\tfinal HibernateMonitoringEvent executionEvent =\n\t\t\t\t\teventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\trs = statement.executeQuery();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( executionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tendSlowQueryLogging(sql, executeStartNanos);\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not extract ResultSet\", sql );\n\t\t}\n\t}\n\n\tprivate EventManager getEventManager() {\n\t\treturn jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t}\n\n\tprivate JdbcEventHandler getEventHandler() {\n\t\treturn jdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getEventHandler();\n\t}\n\n\tprivate JdbcSessionContext context() {\n\t\treturn jdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext();\n\t}\n\n\tprivate void jdbcExecuteStatementEnd() {\n\t\tgetEventHandler().jdbcExecuteStatementEnd();\n\t}\n\n\tprivate void jdbcExecuteStatementStart() {\n\t\tgetEventHandler().jdbcExecuteStatementStart();\n\t}\n\n\t@Override\n\tpublic ResultSet extract(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = beginSlowQueryLogging();\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = getEventManager();\n\t\t\tfinal HibernateMonitoringEvent executionEvent =\n\t\t\t\t\teventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\trs = statement.executeQuery( sql );\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( executionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tendSlowQueryLogging( sql, executeStartNanos );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not extract ResultSet\", sql );\n\t\t}\n\t}\n\n\t@Override\n\tpublic ResultSet execute(PreparedStatement statement, String sql) {\n\t\t// sql logged by StatementPreparerImpl\n\t\tlong executeStartNanos = beginSlowQueryLogging();\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = getEventManager();\n\t\t\tfinal HibernateMonitoringEvent executionEvent =\n\t\t\t\t\teventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\tif ( !statement.execute() ) {\n\t\t\t\t\twhile ( !statement.getMoreResults() && statement.getUpdateCount() != -1 ) {\n\t\t\t\t\t\t// do nothing until we hit the resultset\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trs = statement.getResultSet();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( executionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tendSlowQueryLogging( sql, executeStartNanos );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t}\n\n\t@Override\n\tpublic ResultSet execute(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = beginSlowQueryLogging();\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = getEventManager();\n\t\t\tfinal HibernateMonitoringEvent executionEvent =\n\t\t\t\t\teventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\tif ( !statement.execute( sql ) ) {\n\t\t\t\t\twhile ( !statement.getMoreResults() && statement.getUpdateCount() != -1 ) {\n\t\t\t\t\t\t// do nothing until we hit the resultset\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trs = statement.getResultSet();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( executionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tendSlowQueryLogging( sql, executeStartNanos );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t}\n\n\t@Override\n\tpublic int executeUpdate(PreparedStatement statement, String sql) {\n\t\tassert statement != null;\n\t\tlong executeStartNanos = beginSlowQueryLogging();\n\t\tfinal EventManager eventManager = getEventManager();\n\t\tfinal HibernateMonitoringEvent executionEvent =\n\t\t\t\teventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\ttry {\n\t\t\tjdbcExecuteStatementStart();\n\t\t\treturn statement.executeUpdate();\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t\tfinally {\n\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( executionEvent, sql );\n\t\t\tjdbcExecuteStatementEnd();\n\t\t\tendSlowQueryLogging( sql, executeStartNanos );\n\t\t}\n\t}\n\n\t@Override\n\tpublic int executeUpdate(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = beginSlowQueryLogging();\n\t\tfinal EventManager eventManager = getEventManager();\n\t\tfinal HibernateMonitoringEvent executionEvent =\n\t\t\t\teventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\ttry {\n\t\t\tjdbcExecuteStatementStart();\n\t\t\treturn statement.executeUpdate( sql );\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t\tfinally {\n\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( executionEvent, sql );\n\t\t\tjdbcExecuteStatementEnd();\n\t\t\tendSlowQueryLogging( sql, executeStartNanos );\n\t\t}\n\t}\n\n\tprivate void endSlowQueryLogging(String sql, long executeStartNanos) {\n\t\tsqlStatementLogger.logSlowQuery(sql, executeStartNanos, context() );\n\t}\n\n\tprivate long beginSlowQueryLogging() {\n\t\treturn sqlStatementLogger.getLogSlowQuery() > 0 ? System.nanoTime() : 0;\n\t}\n\n\tprivate void postExtract(ResultSet rs, Statement st) {\n\t\tif ( rs != null ) {\n\t\t\tjdbcCoordinator.getLogicalConnection().getResourceRegistry().register( rs, st );\n\t\t}\n\t}\n\n}\n",
        "diffSourceCodeSet": [
            "private void endSlowQueryLogging(String sql, long executeStartNanos) {\n\t\tsqlStatementLogger.logSlowQuery(sql, executeStartNanos, context() );\n\t}"
        ],
        "invokedMethodSet": [
            "methodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#jdbcExecuteStatementStart\n methodBody: private void jdbcExecuteStatementStart() {\njdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getEventHandler().jdbcExecuteStatementStart();\n}",
            "methodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#context\n methodBody: private JdbcSessionContext context() {\nreturn jdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext();\n}",
            "methodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#jdbcExecuteStatementEnd\n methodBody: private void jdbcExecuteStatementEnd() {\njdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getEventHandler().jdbcExecuteStatementEnd();\n}",
            "methodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#postExtract\n methodBody: private void postExtract(ResultSet rs, Statement st) {\nif(rs != null){jdbcCoordinator.getLogicalConnection().getResourceRegistry().register(rs,st);\n}}",
            "methodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#execute\n methodBody: public ResultSet execute(Statement statement, String sql) {\nsqlStatementLogger.logStatement(sql);\nlong executeStartNanos=0;\nif(this.sqlStatementLogger.getLogSlowQuery() > 0){executeStartNanos=System.nanoTime();\n}tryfinal ResultSet rs;\nfinal EventManager eventManager=jdbcCoordinator.getJdbcSessionOwner().getEventManager();\nfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent=eventManager.beginJdbcPreparedStatementExecutionEvent();\ntryjdbcExecuteStatementStart();\nif(!statement.execute(sql)){while(!statement.getMoreResults() && statement.getUpdateCount() != -1){}}rs=statement.getResultSet();\nfinallyeventManager.completeJdbcPreparedStatementExecutionEvent(jdbcPreparedStatementExecutionEvent,sql);\njdbcExecuteStatementEnd();\nsqlStatementLogger.logSlowQuery(sql,executeStartNanos,context());\npostExtract(rs,statement);\nreturn rs;\ncatch(SQLException e)throw sqlExceptionHelper.convert(e,\"could not execute statement\",sql);\n}"
        ],
        "sourceCodeAfterRefactoring": "@Override\n\tpublic ResultSet execute(PreparedStatement statement, String sql) {\n\t\t// sql logged by StatementPreparerImpl\n\t\tlong executeStartNanos = beginSlowQueryLogging();\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = getEventManager();\n\t\t\tfinal HibernateMonitoringEvent executionEvent =\n\t\t\t\t\teventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\tif ( !statement.execute() ) {\n\t\t\t\t\twhile ( !statement.getMoreResults() && statement.getUpdateCount() != -1 ) {\n\t\t\t\t\t\t// do nothing until we hit the resultset\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trs = statement.getResultSet();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( executionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tendSlowQueryLogging( sql, executeStartNanos );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t}\nprivate void endSlowQueryLogging(String sql, long executeStartNanos) {\n\t\tsqlStatementLogger.logSlowQuery(sql, executeStartNanos, context() );\n\t}",
        "diffSourceCode": "-  116: \t@Override\n-  117: \tpublic ResultSet execute(PreparedStatement statement, String sql) {\n-  118: \t\t// sql logged by StatementPreparerImpl\n-  119: \t\tlong executeStartNanos = 0;\n-  120: \t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n-  121: \t\t\texecuteStartNanos = System.nanoTime();\n-  122: \t\t}\n-  123: \t\ttry {\n-  124: \t\t\tfinal ResultSet rs;\n-  125: \t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n-  126: \t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n-  127: \t\t\ttry {\n-  128: \t\t\t\tjdbcExecuteStatementStart();\n-  129: \t\t\t\tif ( !statement.execute() ) {\n-  130: \t\t\t\t\twhile ( !statement.getMoreResults() && statement.getUpdateCount() != -1 ) {\n-  131: \t\t\t\t\t\t// do nothing until we hit the resultset\n-  132: \t\t\t\t\t}\n-  133: \t\t\t\t}\n-  134: \t\t\t\trs = statement.getResultSet();\n-  135: \t\t\t}\n-  136: \t\t\tfinally {\n-  137: \t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n-  138: \t\t\t\tjdbcExecuteStatementEnd();\n-  139: \t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n-  140: \t\t\t}\n-  141: \t\t\tpostExtract( rs, statement );\n-  142: \t\t\treturn rs;\n-  143: \t\t}\n-  144: \t\tcatch (SQLException e) {\n-  145: \t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n+  116: \t\tcatch (SQLException e) {\n+  117: \t\t\tthrow sqlExceptionHelper.convert( e, \"could not extract ResultSet\", sql );\n+  118: \t\t}\n+  119: \t}\n+  120: \n+  121: \t@Override\n+  122: \tpublic ResultSet execute(PreparedStatement statement, String sql) {\n+  123: \t\t// sql logged by StatementPreparerImpl\n+  124: \t\tlong executeStartNanos = beginSlowQueryLogging();\n+  125: \t\ttry {\n+  126: \t\t\tfinal ResultSet rs;\n+  127: \t\t\tfinal EventManager eventManager = getEventManager();\n+  128: \t\t\tfinal HibernateMonitoringEvent executionEvent =\n+  129: \t\t\t\t\teventManager.beginJdbcPreparedStatementExecutionEvent();\n+  130: \t\t\ttry {\n+  131: \t\t\t\tjdbcExecuteStatementStart();\n+  132: \t\t\t\tif ( !statement.execute() ) {\n+  133: \t\t\t\t\twhile ( !statement.getMoreResults() && statement.getUpdateCount() != -1 ) {\n+  134: \t\t\t\t\t\t// do nothing until we hit the resultset\n+  135: \t\t\t\t\t}\n+  136: \t\t\t\t}\n+  137: \t\t\t\trs = statement.getResultSet();\n+  138: \t\t\t}\n+  139: \t\t\tfinally {\n+  140: \t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( executionEvent, sql );\n+  141: \t\t\t\tjdbcExecuteStatementEnd();\n+  142: \t\t\t\tendSlowQueryLogging( sql, executeStartNanos );\n+  143: \t\t\t}\n+  144: \t\t\tpostExtract( rs, statement );\n+  145: \t\t\treturn rs;\n   146: \t\t}\n-  147: \t}\n-  148: \n-  149: \t@Override\n-  150: \tpublic ResultSet execute(Statement statement, String sql) {\n-  225: \t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n-  226: \t\t}\n+  147: \t\tcatch (SQLException e) {\n+  148: \t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n+  149: \t\t}\n+  150: \t}\n+  225: \tprivate void endSlowQueryLogging(String sql, long executeStartNanos) {\n+  226: \t\tsqlStatementLogger.logSlowQuery(sql, executeStartNanos, context() );\n   227: \t}\n",
        "uniqueId": "7b8c403df746e127f38d3f5f3efb45b941c36af2_116_147_225_227_121_150",
        "moveFileExist": true,
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 21,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 9,
                "covered": 45
            },
            "BRANCH": {
                "missed": 3,
                "covered": 3
            },
            "LINE": {
                "missed": 2,
                "covered": 14
            },
            "COMPLEXITY": {
                "missed": 3,
                "covered": 1
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        }
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprivate getEventManager() : EventManager extracted from public execute(statement PreparedStatement, sql String) : ResultSet in class org.hibernate.engine.jdbc.internal.ResultSetReturnImpl",
        "diffLocations": [
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/engine/jdbc/internal/ResultSetReturnImpl.java",
                "startLine": 116,
                "endLine": 147,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/engine/jdbc/internal/ResultSetReturnImpl.java",
                "startLine": 121,
                "endLine": 150,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/engine/jdbc/internal/ResultSetReturnImpl.java",
                "startLine": 75,
                "endLine": 77,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "@Override\n\tpublic ResultSet execute(PreparedStatement statement, String sql) {\n\t\t// sql logged by StatementPreparerImpl\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\tif ( !statement.execute() ) {\n\t\t\t\t\twhile ( !statement.getMoreResults() && statement.getUpdateCount() != -1 ) {\n\t\t\t\t\t\t// do nothing until we hit the resultset\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trs = statement.getResultSet();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t}",
        "filePathBefore": "hibernate-core/src/main/java/org/hibernate/engine/jdbc/internal/ResultSetReturnImpl.java",
        "isPureRefactoring": true,
        "commitId": "7b8c403df746e127f38d3f5f3efb45b941c36af2",
        "packageNameBefore": "org.hibernate.engine.jdbc.internal",
        "classNameBefore": "org.hibernate.engine.jdbc.internal.ResultSetReturnImpl",
        "methodNameBefore": "org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#execute",
        "invokedMethod": "methodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#jdbcExecuteStatementStart\n methodBody: private void jdbcExecuteStatementStart() {\njdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getEventHandler().jdbcExecuteStatementStart();\n}\nmethodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#context\n methodBody: private JdbcSessionContext context() {\nreturn jdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext();\n}\nmethodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#jdbcExecuteStatementEnd\n methodBody: private void jdbcExecuteStatementEnd() {\njdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getEventHandler().jdbcExecuteStatementEnd();\n}\nmethodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#postExtract\n methodBody: private void postExtract(ResultSet rs, Statement st) {\nif(rs != null){jdbcCoordinator.getLogicalConnection().getResourceRegistry().register(rs,st);\n}}\nmethodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#execute\n methodBody: public ResultSet execute(Statement statement, String sql) {\nsqlStatementLogger.logStatement(sql);\nlong executeStartNanos=0;\nif(this.sqlStatementLogger.getLogSlowQuery() > 0){executeStartNanos=System.nanoTime();\n}tryfinal ResultSet rs;\nfinal EventManager eventManager=jdbcCoordinator.getJdbcSessionOwner().getEventManager();\nfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent=eventManager.beginJdbcPreparedStatementExecutionEvent();\ntryjdbcExecuteStatementStart();\nif(!statement.execute(sql)){while(!statement.getMoreResults() && statement.getUpdateCount() != -1){}}rs=statement.getResultSet();\nfinallyeventManager.completeJdbcPreparedStatementExecutionEvent(jdbcPreparedStatementExecutionEvent,sql);\njdbcExecuteStatementEnd();\nsqlStatementLogger.logSlowQuery(sql,executeStartNanos,context());\npostExtract(rs,statement);\nreturn rs;\ncatch(SQLException e)throw sqlExceptionHelper.convert(e,\"could not execute statement\",sql);\n}",
        "classSignatureBefore": "public class ResultSetReturnImpl implements ResultSetReturn ",
        "methodNameBeforeSet": [
            "org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#execute"
        ],
        "classNameBeforeSet": [
            "org.hibernate.engine.jdbc.internal.ResultSetReturnImpl"
        ],
        "classSignatureBeforeSet": [
            "public class ResultSetReturnImpl implements ResultSetReturn "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.\n */\npackage org.hibernate.engine.jdbc.internal;\n\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\nimport org.hibernate.dialect.Dialect;\nimport org.hibernate.engine.jdbc.spi.JdbcCoordinator;\nimport org.hibernate.engine.jdbc.spi.JdbcServices;\nimport org.hibernate.engine.jdbc.spi.ResultSetReturn;\nimport org.hibernate.engine.jdbc.spi.SqlExceptionHelper;\nimport org.hibernate.engine.jdbc.spi.SqlStatementLogger;\nimport org.hibernate.event.spi.EventManager;\nimport org.hibernate.event.spi.HibernateMonitoringEvent;\nimport org.hibernate.resource.jdbc.spi.JdbcSessionContext;\n\n/**\n * Standard implementation of the ResultSetReturn contract\n *\n * @author Brett Meyer\n */\npublic class ResultSetReturnImpl implements ResultSetReturn {\n\tprivate final JdbcCoordinator jdbcCoordinator;\n\n\tprivate final Dialect dialect;\n\tprivate final SqlStatementLogger sqlStatementLogger;\n\tprivate final SqlExceptionHelper sqlExceptionHelper;\n\n\t/**\n\t * Constructs a ResultSetReturnImpl\n\t *\n\t * @param jdbcCoordinator The JdbcCoordinator\n\t */\n\tpublic ResultSetReturnImpl(JdbcCoordinator jdbcCoordinator, JdbcServices jdbcServices) {\n\t\tthis.jdbcCoordinator = jdbcCoordinator;\n\t\tthis.dialect = jdbcServices.getDialect();\n\t\tthis.sqlStatementLogger = jdbcServices.getSqlStatementLogger();\n\t\tthis.sqlExceptionHelper = jdbcServices.getSqlExceptionHelper();\n\t}\n\n\t@Override\n\tpublic ResultSet extract(PreparedStatement statement, String sql) {\n\t\t// IMPL NOTE : SQL logged by caller\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\trs = statement.executeQuery();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not extract ResultSet\", sql );\n\t\t}\n\t}\n\n\tprivate JdbcSessionContext context() {\n\t\treturn jdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext();\n\t}\n\n\tprivate void jdbcExecuteStatementEnd() {\n\t\tjdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getEventHandler().jdbcExecuteStatementEnd();\n\t}\n\n\tprivate void jdbcExecuteStatementStart() {\n\t\tjdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getEventHandler().jdbcExecuteStatementStart();\n\t}\n\n\t@Override\n\tpublic ResultSet extract(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\trs = statement.executeQuery( sql );\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not extract ResultSet\", sql );\n\t\t}\n\t}\n\n\t@Override\n\tpublic ResultSet execute(PreparedStatement statement, String sql) {\n\t\t// sql logged by StatementPreparerImpl\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\tif ( !statement.execute() ) {\n\t\t\t\t\twhile ( !statement.getMoreResults() && statement.getUpdateCount() != -1 ) {\n\t\t\t\t\t\t// do nothing until we hit the resultset\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trs = statement.getResultSet();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t}\n\n\t@Override\n\tpublic ResultSet execute(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\tif ( !statement.execute( sql ) ) {\n\t\t\t\t\twhile ( !statement.getMoreResults() && statement.getUpdateCount() != -1 ) {\n\t\t\t\t\t\t// do nothing until we hit the resultset\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trs = statement.getResultSet();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t}\n\n\t@Override\n\tpublic int executeUpdate(PreparedStatement statement, String sql) {\n\t\tassert statement != null;\n\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\ttry {\n\t\t\tjdbcExecuteStatementStart();\n\t\t\treturn statement.executeUpdate();\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t\tfinally {\n\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\tjdbcExecuteStatementEnd();\n\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t}\n\t}\n\n\t@Override\n\tpublic int executeUpdate(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\ttry {\n\t\t\tjdbcExecuteStatementStart();\n\t\t\treturn statement.executeUpdate( sql );\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t\tfinally {\n\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\tjdbcExecuteStatementEnd();\n\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t}\n\t}\n\n\tprivate void postExtract(ResultSet rs, Statement st) {\n\t\tif ( rs != null ) {\n\t\t\tjdbcCoordinator.getLogicalConnection().getResourceRegistry().register( rs, st );\n\t\t}\n\t}\n\n}\n",
        "filePathAfter": "hibernate-core/src/main/java/org/hibernate/engine/jdbc/internal/ResultSetReturnImpl.java",
        "sourceCodeAfterForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.\n */\npackage org.hibernate.engine.jdbc.internal;\n\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\nimport org.hibernate.engine.jdbc.spi.JdbcCoordinator;\nimport org.hibernate.engine.jdbc.spi.JdbcServices;\nimport org.hibernate.engine.jdbc.spi.ResultSetReturn;\nimport org.hibernate.engine.jdbc.spi.SqlExceptionHelper;\nimport org.hibernate.engine.jdbc.spi.SqlStatementLogger;\nimport org.hibernate.event.spi.EventManager;\nimport org.hibernate.event.spi.HibernateMonitoringEvent;\nimport org.hibernate.resource.jdbc.spi.JdbcEventHandler;\nimport org.hibernate.resource.jdbc.spi.JdbcSessionContext;\n\n/**\n * Standard implementation of the ResultSetReturn contract\n *\n * @author Brett Meyer\n */\npublic class ResultSetReturnImpl implements ResultSetReturn {\n\tprivate final JdbcCoordinator jdbcCoordinator;\n\n\tprivate final SqlStatementLogger sqlStatementLogger;\n\tprivate final SqlExceptionHelper sqlExceptionHelper;\n\n\t/**\n\t * Constructs a ResultSetReturnImpl\n\t *\n\t * @param jdbcCoordinator The JdbcCoordinator\n\t */\n\tpublic ResultSetReturnImpl(JdbcCoordinator jdbcCoordinator, JdbcServices jdbcServices) {\n\t\tthis.jdbcCoordinator = jdbcCoordinator;\n\t\tthis.sqlStatementLogger = jdbcServices.getSqlStatementLogger();\n\t\tthis.sqlExceptionHelper = jdbcServices.getSqlExceptionHelper();\n\t}\n\n\t@Override\n\tpublic ResultSet extract(PreparedStatement statement, String sql) {\n\t\t// IMPL NOTE : SQL logged by caller\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = getEventManager();\n\t\t\tfinal HibernateMonitoringEvent executionEvent =\n\t\t\t\t\teventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\trs = statement.executeQuery();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( executionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tendSlowQueryLogging(sql, executeStartNanos);\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not extract ResultSet\", sql );\n\t\t}\n\t}\n\n\tprivate EventManager getEventManager() {\n\t\treturn jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t}\n\n\tprivate JdbcEventHandler getEventHandler() {\n\t\treturn jdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getEventHandler();\n\t}\n\n\tprivate JdbcSessionContext context() {\n\t\treturn jdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext();\n\t}\n\n\tprivate void jdbcExecuteStatementEnd() {\n\t\tgetEventHandler().jdbcExecuteStatementEnd();\n\t}\n\n\tprivate void jdbcExecuteStatementStart() {\n\t\tgetEventHandler().jdbcExecuteStatementStart();\n\t}\n\n\t@Override\n\tpublic ResultSet extract(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = beginSlowQueryLogging();\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = getEventManager();\n\t\t\tfinal HibernateMonitoringEvent executionEvent =\n\t\t\t\t\teventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\trs = statement.executeQuery( sql );\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( executionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tendSlowQueryLogging( sql, executeStartNanos );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not extract ResultSet\", sql );\n\t\t}\n\t}\n\n\t@Override\n\tpublic ResultSet execute(PreparedStatement statement, String sql) {\n\t\t// sql logged by StatementPreparerImpl\n\t\tlong executeStartNanos = beginSlowQueryLogging();\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = getEventManager();\n\t\t\tfinal HibernateMonitoringEvent executionEvent =\n\t\t\t\t\teventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\tif ( !statement.execute() ) {\n\t\t\t\t\twhile ( !statement.getMoreResults() && statement.getUpdateCount() != -1 ) {\n\t\t\t\t\t\t// do nothing until we hit the resultset\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trs = statement.getResultSet();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( executionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tendSlowQueryLogging( sql, executeStartNanos );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t}\n\n\t@Override\n\tpublic ResultSet execute(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = beginSlowQueryLogging();\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = getEventManager();\n\t\t\tfinal HibernateMonitoringEvent executionEvent =\n\t\t\t\t\teventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\tif ( !statement.execute( sql ) ) {\n\t\t\t\t\twhile ( !statement.getMoreResults() && statement.getUpdateCount() != -1 ) {\n\t\t\t\t\t\t// do nothing until we hit the resultset\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trs = statement.getResultSet();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( executionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tendSlowQueryLogging( sql, executeStartNanos );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t}\n\n\t@Override\n\tpublic int executeUpdate(PreparedStatement statement, String sql) {\n\t\tassert statement != null;\n\t\tlong executeStartNanos = beginSlowQueryLogging();\n\t\tfinal EventManager eventManager = getEventManager();\n\t\tfinal HibernateMonitoringEvent executionEvent =\n\t\t\t\teventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\ttry {\n\t\t\tjdbcExecuteStatementStart();\n\t\t\treturn statement.executeUpdate();\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t\tfinally {\n\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( executionEvent, sql );\n\t\t\tjdbcExecuteStatementEnd();\n\t\t\tendSlowQueryLogging( sql, executeStartNanos );\n\t\t}\n\t}\n\n\t@Override\n\tpublic int executeUpdate(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = beginSlowQueryLogging();\n\t\tfinal EventManager eventManager = getEventManager();\n\t\tfinal HibernateMonitoringEvent executionEvent =\n\t\t\t\teventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\ttry {\n\t\t\tjdbcExecuteStatementStart();\n\t\t\treturn statement.executeUpdate( sql );\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t\tfinally {\n\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( executionEvent, sql );\n\t\t\tjdbcExecuteStatementEnd();\n\t\t\tendSlowQueryLogging( sql, executeStartNanos );\n\t\t}\n\t}\n\n\tprivate void endSlowQueryLogging(String sql, long executeStartNanos) {\n\t\tsqlStatementLogger.logSlowQuery(sql, executeStartNanos, context() );\n\t}\n\n\tprivate long beginSlowQueryLogging() {\n\t\treturn sqlStatementLogger.getLogSlowQuery() > 0 ? System.nanoTime() : 0;\n\t}\n\n\tprivate void postExtract(ResultSet rs, Statement st) {\n\t\tif ( rs != null ) {\n\t\t\tjdbcCoordinator.getLogicalConnection().getResourceRegistry().register( rs, st );\n\t\t}\n\t}\n\n}\n",
        "diffSourceCodeSet": [
            "private EventManager getEventManager() {\n\t\treturn jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t}"
        ],
        "invokedMethodSet": [
            "methodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#jdbcExecuteStatementStart\n methodBody: private void jdbcExecuteStatementStart() {\njdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getEventHandler().jdbcExecuteStatementStart();\n}",
            "methodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#context\n methodBody: private JdbcSessionContext context() {\nreturn jdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext();\n}",
            "methodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#jdbcExecuteStatementEnd\n methodBody: private void jdbcExecuteStatementEnd() {\njdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getEventHandler().jdbcExecuteStatementEnd();\n}",
            "methodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#postExtract\n methodBody: private void postExtract(ResultSet rs, Statement st) {\nif(rs != null){jdbcCoordinator.getLogicalConnection().getResourceRegistry().register(rs,st);\n}}",
            "methodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#execute\n methodBody: public ResultSet execute(Statement statement, String sql) {\nsqlStatementLogger.logStatement(sql);\nlong executeStartNanos=0;\nif(this.sqlStatementLogger.getLogSlowQuery() > 0){executeStartNanos=System.nanoTime();\n}tryfinal ResultSet rs;\nfinal EventManager eventManager=jdbcCoordinator.getJdbcSessionOwner().getEventManager();\nfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent=eventManager.beginJdbcPreparedStatementExecutionEvent();\ntryjdbcExecuteStatementStart();\nif(!statement.execute(sql)){while(!statement.getMoreResults() && statement.getUpdateCount() != -1){}}rs=statement.getResultSet();\nfinallyeventManager.completeJdbcPreparedStatementExecutionEvent(jdbcPreparedStatementExecutionEvent,sql);\njdbcExecuteStatementEnd();\nsqlStatementLogger.logSlowQuery(sql,executeStartNanos,context());\npostExtract(rs,statement);\nreturn rs;\ncatch(SQLException e)throw sqlExceptionHelper.convert(e,\"could not execute statement\",sql);\n}"
        ],
        "sourceCodeAfterRefactoring": "@Override\n\tpublic ResultSet execute(PreparedStatement statement, String sql) {\n\t\t// sql logged by StatementPreparerImpl\n\t\tlong executeStartNanos = beginSlowQueryLogging();\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = getEventManager();\n\t\t\tfinal HibernateMonitoringEvent executionEvent =\n\t\t\t\t\teventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\tif ( !statement.execute() ) {\n\t\t\t\t\twhile ( !statement.getMoreResults() && statement.getUpdateCount() != -1 ) {\n\t\t\t\t\t\t// do nothing until we hit the resultset\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trs = statement.getResultSet();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( executionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tendSlowQueryLogging( sql, executeStartNanos );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t}\nprivate EventManager getEventManager() {\n\t\treturn jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t}",
        "diffSourceCode": "-   75: \n-   76: \tprivate JdbcSessionContext context() {\n-   77: \t\treturn jdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext();\n-  116: \t@Override\n-  117: \tpublic ResultSet execute(PreparedStatement statement, String sql) {\n-  118: \t\t// sql logged by StatementPreparerImpl\n-  119: \t\tlong executeStartNanos = 0;\n-  120: \t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n-  121: \t\t\texecuteStartNanos = System.nanoTime();\n-  122: \t\t}\n-  123: \t\ttry {\n-  124: \t\t\tfinal ResultSet rs;\n-  125: \t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n-  126: \t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n-  127: \t\t\ttry {\n-  128: \t\t\t\tjdbcExecuteStatementStart();\n-  129: \t\t\t\tif ( !statement.execute() ) {\n-  130: \t\t\t\t\twhile ( !statement.getMoreResults() && statement.getUpdateCount() != -1 ) {\n-  131: \t\t\t\t\t\t// do nothing until we hit the resultset\n-  132: \t\t\t\t\t}\n-  133: \t\t\t\t}\n-  134: \t\t\t\trs = statement.getResultSet();\n-  135: \t\t\t}\n-  136: \t\t\tfinally {\n-  137: \t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n-  138: \t\t\t\tjdbcExecuteStatementEnd();\n-  139: \t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n-  140: \t\t\t}\n-  141: \t\t\tpostExtract( rs, statement );\n-  142: \t\t\treturn rs;\n-  143: \t\t}\n-  144: \t\tcatch (SQLException e) {\n-  145: \t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n+   75: \tprivate EventManager getEventManager() {\n+   76: \t\treturn jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n+   77: \t}\n+  116: \t\tcatch (SQLException e) {\n+  117: \t\t\tthrow sqlExceptionHelper.convert( e, \"could not extract ResultSet\", sql );\n+  118: \t\t}\n+  119: \t}\n+  120: \n+  121: \t@Override\n+  122: \tpublic ResultSet execute(PreparedStatement statement, String sql) {\n+  123: \t\t// sql logged by StatementPreparerImpl\n+  124: \t\tlong executeStartNanos = beginSlowQueryLogging();\n+  125: \t\ttry {\n+  126: \t\t\tfinal ResultSet rs;\n+  127: \t\t\tfinal EventManager eventManager = getEventManager();\n+  128: \t\t\tfinal HibernateMonitoringEvent executionEvent =\n+  129: \t\t\t\t\teventManager.beginJdbcPreparedStatementExecutionEvent();\n+  130: \t\t\ttry {\n+  131: \t\t\t\tjdbcExecuteStatementStart();\n+  132: \t\t\t\tif ( !statement.execute() ) {\n+  133: \t\t\t\t\twhile ( !statement.getMoreResults() && statement.getUpdateCount() != -1 ) {\n+  134: \t\t\t\t\t\t// do nothing until we hit the resultset\n+  135: \t\t\t\t\t}\n+  136: \t\t\t\t}\n+  137: \t\t\t\trs = statement.getResultSet();\n+  138: \t\t\t}\n+  139: \t\t\tfinally {\n+  140: \t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( executionEvent, sql );\n+  141: \t\t\t\tjdbcExecuteStatementEnd();\n+  142: \t\t\t\tendSlowQueryLogging( sql, executeStartNanos );\n+  143: \t\t\t}\n+  144: \t\t\tpostExtract( rs, statement );\n+  145: \t\t\treturn rs;\n   146: \t\t}\n-  147: \t}\n-  148: \n-  149: \t@Override\n-  150: \tpublic ResultSet execute(Statement statement, String sql) {\n+  147: \t\tcatch (SQLException e) {\n+  148: \t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n+  149: \t\t}\n+  150: \t}\n",
        "uniqueId": "7b8c403df746e127f38d3f5f3efb45b941c36af2_116_147_75_77_121_150",
        "moveFileExist": true,
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 21,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 9,
                "covered": 45
            },
            "BRANCH": {
                "missed": 3,
                "covered": 3
            },
            "LINE": {
                "missed": 2,
                "covered": 14
            },
            "COMPLEXITY": {
                "missed": 3,
                "covered": 1
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        }
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprivate beginSlowQueryLogging() : long extracted from public extract(statement Statement, sql String) : ResultSet in class org.hibernate.engine.jdbc.internal.ResultSetReturnImpl",
        "diffLocations": [
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/engine/jdbc/internal/ResultSetReturnImpl.java",
                "startLine": 88,
                "endLine": 114,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/engine/jdbc/internal/ResultSetReturnImpl.java",
                "startLine": 95,
                "endLine": 119,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/engine/jdbc/internal/ResultSetReturnImpl.java",
                "startLine": 229,
                "endLine": 231,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "@Override\n\tpublic ResultSet extract(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\trs = statement.executeQuery( sql );\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not extract ResultSet\", sql );\n\t\t}\n\t}",
        "filePathBefore": "hibernate-core/src/main/java/org/hibernate/engine/jdbc/internal/ResultSetReturnImpl.java",
        "isPureRefactoring": true,
        "commitId": "7b8c403df746e127f38d3f5f3efb45b941c36af2",
        "packageNameBefore": "org.hibernate.engine.jdbc.internal",
        "classNameBefore": "org.hibernate.engine.jdbc.internal.ResultSetReturnImpl",
        "methodNameBefore": "org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#extract",
        "invokedMethod": "methodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#jdbcExecuteStatementStart\n methodBody: private void jdbcExecuteStatementStart() {\njdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getEventHandler().jdbcExecuteStatementStart();\n}\nmethodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#context\n methodBody: private JdbcSessionContext context() {\nreturn jdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext();\n}\nmethodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#jdbcExecuteStatementEnd\n methodBody: private void jdbcExecuteStatementEnd() {\njdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getEventHandler().jdbcExecuteStatementEnd();\n}\nmethodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#postExtract\n methodBody: private void postExtract(ResultSet rs, Statement st) {\nif(rs != null){jdbcCoordinator.getLogicalConnection().getResourceRegistry().register(rs,st);\n}}",
        "classSignatureBefore": "public class ResultSetReturnImpl implements ResultSetReturn ",
        "methodNameBeforeSet": [
            "org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#extract"
        ],
        "classNameBeforeSet": [
            "org.hibernate.engine.jdbc.internal.ResultSetReturnImpl"
        ],
        "classSignatureBeforeSet": [
            "public class ResultSetReturnImpl implements ResultSetReturn "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Tolerable changes in the body\n",
                "description": "All replacements have been justified - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.\n */\npackage org.hibernate.engine.jdbc.internal;\n\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\nimport org.hibernate.dialect.Dialect;\nimport org.hibernate.engine.jdbc.spi.JdbcCoordinator;\nimport org.hibernate.engine.jdbc.spi.JdbcServices;\nimport org.hibernate.engine.jdbc.spi.ResultSetReturn;\nimport org.hibernate.engine.jdbc.spi.SqlExceptionHelper;\nimport org.hibernate.engine.jdbc.spi.SqlStatementLogger;\nimport org.hibernate.event.spi.EventManager;\nimport org.hibernate.event.spi.HibernateMonitoringEvent;\nimport org.hibernate.resource.jdbc.spi.JdbcSessionContext;\n\n/**\n * Standard implementation of the ResultSetReturn contract\n *\n * @author Brett Meyer\n */\npublic class ResultSetReturnImpl implements ResultSetReturn {\n\tprivate final JdbcCoordinator jdbcCoordinator;\n\n\tprivate final Dialect dialect;\n\tprivate final SqlStatementLogger sqlStatementLogger;\n\tprivate final SqlExceptionHelper sqlExceptionHelper;\n\n\t/**\n\t * Constructs a ResultSetReturnImpl\n\t *\n\t * @param jdbcCoordinator The JdbcCoordinator\n\t */\n\tpublic ResultSetReturnImpl(JdbcCoordinator jdbcCoordinator, JdbcServices jdbcServices) {\n\t\tthis.jdbcCoordinator = jdbcCoordinator;\n\t\tthis.dialect = jdbcServices.getDialect();\n\t\tthis.sqlStatementLogger = jdbcServices.getSqlStatementLogger();\n\t\tthis.sqlExceptionHelper = jdbcServices.getSqlExceptionHelper();\n\t}\n\n\t@Override\n\tpublic ResultSet extract(PreparedStatement statement, String sql) {\n\t\t// IMPL NOTE : SQL logged by caller\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\trs = statement.executeQuery();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not extract ResultSet\", sql );\n\t\t}\n\t}\n\n\tprivate JdbcSessionContext context() {\n\t\treturn jdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext();\n\t}\n\n\tprivate void jdbcExecuteStatementEnd() {\n\t\tjdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getEventHandler().jdbcExecuteStatementEnd();\n\t}\n\n\tprivate void jdbcExecuteStatementStart() {\n\t\tjdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getEventHandler().jdbcExecuteStatementStart();\n\t}\n\n\t@Override\n\tpublic ResultSet extract(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\trs = statement.executeQuery( sql );\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not extract ResultSet\", sql );\n\t\t}\n\t}\n\n\t@Override\n\tpublic ResultSet execute(PreparedStatement statement, String sql) {\n\t\t// sql logged by StatementPreparerImpl\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\tif ( !statement.execute() ) {\n\t\t\t\t\twhile ( !statement.getMoreResults() && statement.getUpdateCount() != -1 ) {\n\t\t\t\t\t\t// do nothing until we hit the resultset\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trs = statement.getResultSet();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t}\n\n\t@Override\n\tpublic ResultSet execute(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\tif ( !statement.execute( sql ) ) {\n\t\t\t\t\twhile ( !statement.getMoreResults() && statement.getUpdateCount() != -1 ) {\n\t\t\t\t\t\t// do nothing until we hit the resultset\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trs = statement.getResultSet();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t}\n\n\t@Override\n\tpublic int executeUpdate(PreparedStatement statement, String sql) {\n\t\tassert statement != null;\n\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\ttry {\n\t\t\tjdbcExecuteStatementStart();\n\t\t\treturn statement.executeUpdate();\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t\tfinally {\n\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\tjdbcExecuteStatementEnd();\n\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t}\n\t}\n\n\t@Override\n\tpublic int executeUpdate(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\ttry {\n\t\t\tjdbcExecuteStatementStart();\n\t\t\treturn statement.executeUpdate( sql );\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t\tfinally {\n\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\tjdbcExecuteStatementEnd();\n\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t}\n\t}\n\n\tprivate void postExtract(ResultSet rs, Statement st) {\n\t\tif ( rs != null ) {\n\t\t\tjdbcCoordinator.getLogicalConnection().getResourceRegistry().register( rs, st );\n\t\t}\n\t}\n\n}\n",
        "filePathAfter": "hibernate-core/src/main/java/org/hibernate/engine/jdbc/internal/ResultSetReturnImpl.java",
        "sourceCodeAfterForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.\n */\npackage org.hibernate.engine.jdbc.internal;\n\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\nimport org.hibernate.engine.jdbc.spi.JdbcCoordinator;\nimport org.hibernate.engine.jdbc.spi.JdbcServices;\nimport org.hibernate.engine.jdbc.spi.ResultSetReturn;\nimport org.hibernate.engine.jdbc.spi.SqlExceptionHelper;\nimport org.hibernate.engine.jdbc.spi.SqlStatementLogger;\nimport org.hibernate.event.spi.EventManager;\nimport org.hibernate.event.spi.HibernateMonitoringEvent;\nimport org.hibernate.resource.jdbc.spi.JdbcEventHandler;\nimport org.hibernate.resource.jdbc.spi.JdbcSessionContext;\n\n/**\n * Standard implementation of the ResultSetReturn contract\n *\n * @author Brett Meyer\n */\npublic class ResultSetReturnImpl implements ResultSetReturn {\n\tprivate final JdbcCoordinator jdbcCoordinator;\n\n\tprivate final SqlStatementLogger sqlStatementLogger;\n\tprivate final SqlExceptionHelper sqlExceptionHelper;\n\n\t/**\n\t * Constructs a ResultSetReturnImpl\n\t *\n\t * @param jdbcCoordinator The JdbcCoordinator\n\t */\n\tpublic ResultSetReturnImpl(JdbcCoordinator jdbcCoordinator, JdbcServices jdbcServices) {\n\t\tthis.jdbcCoordinator = jdbcCoordinator;\n\t\tthis.sqlStatementLogger = jdbcServices.getSqlStatementLogger();\n\t\tthis.sqlExceptionHelper = jdbcServices.getSqlExceptionHelper();\n\t}\n\n\t@Override\n\tpublic ResultSet extract(PreparedStatement statement, String sql) {\n\t\t// IMPL NOTE : SQL logged by caller\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = getEventManager();\n\t\t\tfinal HibernateMonitoringEvent executionEvent =\n\t\t\t\t\teventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\trs = statement.executeQuery();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( executionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tendSlowQueryLogging(sql, executeStartNanos);\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not extract ResultSet\", sql );\n\t\t}\n\t}\n\n\tprivate EventManager getEventManager() {\n\t\treturn jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t}\n\n\tprivate JdbcEventHandler getEventHandler() {\n\t\treturn jdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getEventHandler();\n\t}\n\n\tprivate JdbcSessionContext context() {\n\t\treturn jdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext();\n\t}\n\n\tprivate void jdbcExecuteStatementEnd() {\n\t\tgetEventHandler().jdbcExecuteStatementEnd();\n\t}\n\n\tprivate void jdbcExecuteStatementStart() {\n\t\tgetEventHandler().jdbcExecuteStatementStart();\n\t}\n\n\t@Override\n\tpublic ResultSet extract(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = beginSlowQueryLogging();\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = getEventManager();\n\t\t\tfinal HibernateMonitoringEvent executionEvent =\n\t\t\t\t\teventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\trs = statement.executeQuery( sql );\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( executionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tendSlowQueryLogging( sql, executeStartNanos );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not extract ResultSet\", sql );\n\t\t}\n\t}\n\n\t@Override\n\tpublic ResultSet execute(PreparedStatement statement, String sql) {\n\t\t// sql logged by StatementPreparerImpl\n\t\tlong executeStartNanos = beginSlowQueryLogging();\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = getEventManager();\n\t\t\tfinal HibernateMonitoringEvent executionEvent =\n\t\t\t\t\teventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\tif ( !statement.execute() ) {\n\t\t\t\t\twhile ( !statement.getMoreResults() && statement.getUpdateCount() != -1 ) {\n\t\t\t\t\t\t// do nothing until we hit the resultset\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trs = statement.getResultSet();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( executionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tendSlowQueryLogging( sql, executeStartNanos );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t}\n\n\t@Override\n\tpublic ResultSet execute(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = beginSlowQueryLogging();\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = getEventManager();\n\t\t\tfinal HibernateMonitoringEvent executionEvent =\n\t\t\t\t\teventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\tif ( !statement.execute( sql ) ) {\n\t\t\t\t\twhile ( !statement.getMoreResults() && statement.getUpdateCount() != -1 ) {\n\t\t\t\t\t\t// do nothing until we hit the resultset\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trs = statement.getResultSet();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( executionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tendSlowQueryLogging( sql, executeStartNanos );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t}\n\n\t@Override\n\tpublic int executeUpdate(PreparedStatement statement, String sql) {\n\t\tassert statement != null;\n\t\tlong executeStartNanos = beginSlowQueryLogging();\n\t\tfinal EventManager eventManager = getEventManager();\n\t\tfinal HibernateMonitoringEvent executionEvent =\n\t\t\t\teventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\ttry {\n\t\t\tjdbcExecuteStatementStart();\n\t\t\treturn statement.executeUpdate();\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t\tfinally {\n\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( executionEvent, sql );\n\t\t\tjdbcExecuteStatementEnd();\n\t\t\tendSlowQueryLogging( sql, executeStartNanos );\n\t\t}\n\t}\n\n\t@Override\n\tpublic int executeUpdate(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = beginSlowQueryLogging();\n\t\tfinal EventManager eventManager = getEventManager();\n\t\tfinal HibernateMonitoringEvent executionEvent =\n\t\t\t\teventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\ttry {\n\t\t\tjdbcExecuteStatementStart();\n\t\t\treturn statement.executeUpdate( sql );\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t\tfinally {\n\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( executionEvent, sql );\n\t\t\tjdbcExecuteStatementEnd();\n\t\t\tendSlowQueryLogging( sql, executeStartNanos );\n\t\t}\n\t}\n\n\tprivate void endSlowQueryLogging(String sql, long executeStartNanos) {\n\t\tsqlStatementLogger.logSlowQuery(sql, executeStartNanos, context() );\n\t}\n\n\tprivate long beginSlowQueryLogging() {\n\t\treturn sqlStatementLogger.getLogSlowQuery() > 0 ? System.nanoTime() : 0;\n\t}\n\n\tprivate void postExtract(ResultSet rs, Statement st) {\n\t\tif ( rs != null ) {\n\t\t\tjdbcCoordinator.getLogicalConnection().getResourceRegistry().register( rs, st );\n\t\t}\n\t}\n\n}\n",
        "diffSourceCodeSet": [
            "private long beginSlowQueryLogging() {\n\t\treturn sqlStatementLogger.getLogSlowQuery() > 0 ? System.nanoTime() : 0;\n\t}"
        ],
        "invokedMethodSet": [
            "methodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#jdbcExecuteStatementStart\n methodBody: private void jdbcExecuteStatementStart() {\njdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getEventHandler().jdbcExecuteStatementStart();\n}",
            "methodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#context\n methodBody: private JdbcSessionContext context() {\nreturn jdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext();\n}",
            "methodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#jdbcExecuteStatementEnd\n methodBody: private void jdbcExecuteStatementEnd() {\njdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getEventHandler().jdbcExecuteStatementEnd();\n}",
            "methodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#postExtract\n methodBody: private void postExtract(ResultSet rs, Statement st) {\nif(rs != null){jdbcCoordinator.getLogicalConnection().getResourceRegistry().register(rs,st);\n}}"
        ],
        "sourceCodeAfterRefactoring": "@Override\n\tpublic ResultSet extract(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = beginSlowQueryLogging();\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = getEventManager();\n\t\t\tfinal HibernateMonitoringEvent executionEvent =\n\t\t\t\t\teventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\trs = statement.executeQuery( sql );\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( executionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tendSlowQueryLogging( sql, executeStartNanos );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not extract ResultSet\", sql );\n\t\t}\n\t}\nprivate long beginSlowQueryLogging() {\n\t\treturn sqlStatementLogger.getLogSlowQuery() > 0 ? System.nanoTime() : 0;\n\t}",
        "diffSourceCode": "-   88: \t@Override\n-   89: \tpublic ResultSet extract(Statement statement, String sql) {\n-   90: \t\tsqlStatementLogger.logStatement( sql );\n-   91: \t\tlong executeStartNanos = 0;\n-   92: \t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n-   93: \t\t\texecuteStartNanos = System.nanoTime();\n-   94: \t\t}\n-   95: \t\ttry {\n-   96: \t\t\tfinal ResultSet rs;\n-   97: \t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n-   98: \t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n-   99: \t\t\ttry {\n-  100: \t\t\t\tjdbcExecuteStatementStart();\n-  101: \t\t\t\trs = statement.executeQuery( sql );\n-  102: \t\t\t}\n-  103: \t\t\tfinally {\n-  104: \t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n-  105: \t\t\t\tjdbcExecuteStatementEnd();\n-  106: \t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n+   88: \t\tgetEventHandler().jdbcExecuteStatementEnd();\n+   89: \t}\n+   90: \n+   91: \tprivate void jdbcExecuteStatementStart() {\n+   92: \t\tgetEventHandler().jdbcExecuteStatementStart();\n+   93: \t}\n+   94: \n+   95: \t@Override\n+   96: \tpublic ResultSet extract(Statement statement, String sql) {\n+   97: \t\tsqlStatementLogger.logStatement( sql );\n+   98: \t\tlong executeStartNanos = beginSlowQueryLogging();\n+   99: \t\ttry {\n+  100: \t\t\tfinal ResultSet rs;\n+  101: \t\t\tfinal EventManager eventManager = getEventManager();\n+  102: \t\t\tfinal HibernateMonitoringEvent executionEvent =\n+  103: \t\t\t\t\teventManager.beginJdbcPreparedStatementExecutionEvent();\n+  104: \t\t\ttry {\n+  105: \t\t\t\tjdbcExecuteStatementStart();\n+  106: \t\t\t\trs = statement.executeQuery( sql );\n   107: \t\t\t}\n-  108: \t\t\tpostExtract( rs, statement );\n-  109: \t\t\treturn rs;\n-  110: \t\t}\n-  111: \t\tcatch (SQLException e) {\n-  112: \t\t\tthrow sqlExceptionHelper.convert( e, \"could not extract ResultSet\", sql );\n-  113: \t\t}\n-  114: \t}\n-  115: \n-  116: \t@Override\n-  117: \tpublic ResultSet execute(PreparedStatement statement, String sql) {\n-  118: \t\t// sql logged by StatementPreparerImpl\n-  119: \t\tlong executeStartNanos = 0;\n-  229: \tprivate void postExtract(ResultSet rs, Statement st) {\n-  230: \t\tif ( rs != null ) {\n-  231: \t\t\tjdbcCoordinator.getLogicalConnection().getResourceRegistry().register( rs, st );\n+  108: \t\t\tfinally {\n+  109: \t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( executionEvent, sql );\n+  110: \t\t\t\tjdbcExecuteStatementEnd();\n+  111: \t\t\t\tendSlowQueryLogging( sql, executeStartNanos );\n+  112: \t\t\t}\n+  113: \t\t\tpostExtract( rs, statement );\n+  114: \t\t\treturn rs;\n+  115: \t\t}\n+  116: \t\tcatch (SQLException e) {\n+  117: \t\t\tthrow sqlExceptionHelper.convert( e, \"could not extract ResultSet\", sql );\n+  118: \t\t}\n+  119: \t}\n+  229: \tprivate long beginSlowQueryLogging() {\n+  230: \t\treturn sqlStatementLogger.getLogSlowQuery() > 0 ? System.nanoTime() : 0;\n+  231: \t}\n",
        "uniqueId": "7b8c403df746e127f38d3f5f3efb45b941c36af2_88_114_229_231_95_119",
        "moveFileExist": true,
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 21,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 0,
                "covered": 43
            },
            "LINE": {
                "missed": 0,
                "covered": 14
            },
            "COMPLEXITY": {
                "missed": 0,
                "covered": 1
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        }
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprivate getJdbcParamName(procedureCall ProcedureCallImplementor<?>, isNamed boolean, typeToUse OutputableType<T>, databaseMetaData ExtractedDatabaseMetaData) : String extracted from public toJdbcParameterRegistration(startIndex int, procedureCall ProcedureCallImplementor<?>) : JdbcCallParameterRegistration in class org.hibernate.procedure.internal.ProcedureParameterImpl",
        "diffLocations": [
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/procedure/internal/ProcedureParameterImpl.java",
                "startLine": 121,
                "endLine": 185,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/procedure/internal/ProcedureParameterImpl.java",
                "startLine": 122,
                "endLine": 188,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/procedure/internal/ProcedureParameterImpl.java",
                "startLine": 190,
                "endLine": 196,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "@Override\n\tpublic JdbcCallParameterRegistration toJdbcParameterRegistration(\n\t\t\tint startIndex,\n\t\t\tProcedureCallImplementor<?> procedureCall) {\n\t\tfinal QueryParameterBinding<T> binding = procedureCall.getParameterBindings().getBinding( this );\n\t\tfinal boolean isNamed = procedureCall.getParameterStrategy() == ParameterStrategy.NAMED && this.name != null;\n\n\t\tfinal BindableType<T> bindableType;\n\t\tif ( getHibernateType() != null ) {\n\t\t\tbindableType = getHibernateType();\n\t\t}\n\t\telse if ( binding != null ) {\n\t\t\t//noinspection unchecked\n\t\t\tbindableType = (BindableType<T>) binding.getBindType();\n\t\t}\n\t\telse {\n\t\t\tbindableType = null;\n\t\t}\n\n\t\tfinal OutputableType<T> typeToUse = (OutputableType<T>) BindingTypeHelper.INSTANCE.resolveTemporalPrecision(\n\t\t\t\tbinding == null ? null : binding.getExplicitTemporalPrecision(),\n\t\t\t\tbindableType,\n\t\t\t\tprocedureCall.getSession().getFactory()\n\t\t);\n\n\t\tfinal String jdbcParamName;\n\t\tif ( isNamed && canDoNameParameterBinding( typeToUse, procedureCall ) ) {\n\t\t\tjdbcParamName = this.name;\n\t\t}\n\t\telse {\n\t\t\tjdbcParamName = null;\n\t\t}\n\n\t\tfinal JdbcParameterBinder parameterBinder;\n\t\tfinal JdbcCallRefCursorExtractorImpl refCursorExtractor;\n\t\tfinal JdbcCallParameterExtractorImpl<T> parameterExtractor;\n\n\t\tswitch ( mode ) {\n\t\t\tcase REF_CURSOR:\n\t\t\t\trefCursorExtractor = new JdbcCallRefCursorExtractorImpl( jdbcParamName, startIndex );\n\t\t\t\tparameterBinder = null;\n\t\t\t\tparameterExtractor = null;\n\t\t\t\tbreak;\n\t\t\tcase IN:\n\t\t\t\tvalidateBindableType( typeToUse, startIndex );\n\t\t\t\tparameterBinder = getParameterBinder( typeToUse, jdbcParamName );\n\t\t\t\tparameterExtractor = null;\n\t\t\t\trefCursorExtractor = null;\n\t\t\t\tbreak;\n\t\t\tcase INOUT:\n\t\t\t\tvalidateBindableType( typeToUse, startIndex );\n\t\t\t\tparameterBinder = getParameterBinder( typeToUse, jdbcParamName );\n\t\t\t\tparameterExtractor = new JdbcCallParameterExtractorImpl<>( procedureCall.getProcedureName(), jdbcParamName, startIndex, typeToUse );\n\t\t\t\trefCursorExtractor = null;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tvalidateBindableType( typeToUse, startIndex );\n\t\t\t\tparameterBinder = null;\n\t\t\t\tparameterExtractor = new JdbcCallParameterExtractorImpl<>( procedureCall.getProcedureName(), jdbcParamName, startIndex, typeToUse );\n\t\t\t\trefCursorExtractor = null;\n\t\t\t\tbreak;\n\t\t}\n\n\t\treturn new JdbcCallParameterRegistrationImpl( jdbcParamName, startIndex, mode, typeToUse, parameterBinder, parameterExtractor, refCursorExtractor );\n\t}",
        "filePathBefore": "hibernate-core/src/main/java/org/hibernate/procedure/internal/ProcedureParameterImpl.java",
        "isPureRefactoring": true,
        "commitId": "8766a8e012cd08616847f26f3ccb3e0bd7441698",
        "packageNameBefore": "org.hibernate.procedure.internal",
        "classNameBefore": "org.hibernate.procedure.internal.ProcedureParameterImpl",
        "methodNameBefore": "org.hibernate.procedure.internal.ProcedureParameterImpl#toJdbcParameterRegistration",
        "invokedMethod": "methodSignature: org.hibernate.procedure.internal.ProcedureParameterImpl#canDoNameParameterBinding\n methodBody: private boolean canDoNameParameterBinding(\n\t\t\tBindableType<?> hibernateType,\n\t\t\tProcedureCallImplementor<?> procedureCall) {\nfinal ExtractedDatabaseMetaData databaseMetaData=procedureCall.getSession().getFactory().getJdbcServices().getJdbcEnvironment().getExtractedDatabaseMetaData();\nreturn procedureCall.getFunctionReturn() == null && databaseMetaData.supportsNamedParameters() && hibernateType instanceof ProcedureParameterNamedBinder && ((ProcedureParameterNamedBinder<?>)hibernateType).canDoSetting();\n}\nmethodSignature: org.hibernate.procedure.internal.ProcedureParameterImpl#getParameterBinder\n methodBody: private JdbcParameterBinder getParameterBinder(BindableType<T> typeToUse, String name) {\nif(typeToUse == null){throw new ParameterTypeException(String.format(Locale.ROOT,\"Cannot determine the bindable type for procedure parameter %s (%s)\",this.name != null ? this.name : this.position,name));\n}if(typeToUse instanceof BasicType<?>){if(name == null){return new JdbcParameterImpl((BasicType<T>)typeToUse);\n}{return new JdbcParameterImpl((BasicType<T>)typeToUse){\n  @Override protected void bindParameterValue(  JdbcMapping jdbcMapping,  PreparedStatement statement,  Object bindValue,  int startPosition,  ExecutionContext executionContext) throws SQLException {\n    jdbcMapping.getJdbcValueBinder().bind((CallableStatement)statement,bindValue,name,executionContext.getSession());\n  }\n  @Override public String toString(){\n    return \"JdbcParameter(\" + name + \")\";\n  }\n}\n;\n}}throw new UnsupportedOperationException();\n}\nmethodSignature: org.hibernate.procedure.internal.ProcedureParameterImpl#validateBindableType\n methodBody: private void validateBindableType(BindableType<T> bindableType, int startIndex) {\nif(bindableType == null){throw new ParameterTypeException(String.format(Locale.ROOT,\"Could not determine ProcedureCall parameter bind type - %s (%s)\",this.name != null ? this.name : this.position,startIndex));\n}}",
        "classSignatureBefore": "public class ProcedureParameterImpl<T> extends AbstractQueryParameter<T> implements ProcedureParameterImplementor<T> ",
        "methodNameBeforeSet": [
            "org.hibernate.procedure.internal.ProcedureParameterImpl#toJdbcParameterRegistration"
        ],
        "classNameBeforeSet": [
            "org.hibernate.procedure.internal.ProcedureParameterImpl"
        ],
        "classSignatureBeforeSet": [
            "public class ProcedureParameterImpl<T> extends AbstractQueryParameter<T> implements ProcedureParameterImplementor<T> "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Changes are within the Extract Method refactoring mechanics",
                "description": "All the mappings are matched! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later\n * See the lgpl.txt file in the root directory or http://www.gnu.org/licenses/lgpl-2.1.html\n */\npackage org.hibernate.procedure.internal;\n\nimport java.sql.CallableStatement;\nimport java.sql.PreparedStatement;\nimport java.sql.SQLException;\nimport java.util.Locale;\nimport java.util.Objects;\n\nimport org.hibernate.engine.jdbc.env.spi.ExtractedDatabaseMetaData;\nimport org.hibernate.metamodel.mapping.JdbcMapping;\nimport org.hibernate.procedure.ParameterTypeException;\nimport org.hibernate.procedure.spi.NamedCallableQueryMemento;\nimport org.hibernate.procedure.spi.ParameterStrategy;\nimport org.hibernate.procedure.spi.ProcedureCallImplementor;\nimport org.hibernate.procedure.spi.ProcedureParameterImplementor;\nimport org.hibernate.query.BindableType;\nimport org.hibernate.query.OutputableType;\nimport org.hibernate.query.internal.BindingTypeHelper;\nimport org.hibernate.query.spi.AbstractQueryParameter;\nimport org.hibernate.query.spi.QueryParameterBinding;\nimport org.hibernate.sql.exec.internal.JdbcCallParameterExtractorImpl;\nimport org.hibernate.sql.exec.internal.JdbcCallParameterRegistrationImpl;\nimport org.hibernate.sql.exec.internal.JdbcCallRefCursorExtractorImpl;\nimport org.hibernate.sql.exec.internal.JdbcParameterImpl;\nimport org.hibernate.sql.exec.spi.ExecutionContext;\nimport org.hibernate.sql.exec.spi.JdbcCallParameterRegistration;\nimport org.hibernate.sql.exec.spi.JdbcParameterBinder;\nimport org.hibernate.type.BasicType;\nimport org.hibernate.type.ProcedureParameterNamedBinder;\n\nimport jakarta.persistence.ParameterMode;\n\n/**\n * @author Steve Ebersole\n */\npublic class ProcedureParameterImpl<T> extends AbstractQueryParameter<T> implements ProcedureParameterImplementor<T> {\n\n\tprivate final String name;\n\tprivate final Integer position;\n\tprivate final ParameterMode mode;\n\tprivate final Class<T> javaType;\n\n\t/**\n\t * Used for named Query parameters\n\t */\n\tpublic ProcedureParameterImpl(\n\t\t\tString name,\n\t\t\tParameterMode mode,\n\t\t\tClass<T> javaType,\n\t\t\tBindableType<T> hibernateType) {\n\t\tsuper( false, hibernateType );\n\t\tthis.name = name;\n\t\tthis.position = null;\n\t\tthis.mode = mode;\n\t\tthis.javaType = javaType;\n\t}\n\n\t/**\n\t * Used for ordinal Query parameters\n\t */\n\tpublic ProcedureParameterImpl(\n\t\t\tInteger position,\n\t\t\tParameterMode mode,\n\t\t\tClass<T> javaType,\n\t\t\tBindableType<T> hibernateType) {\n\t\tsuper( false, hibernateType );\n\t\tthis.name = null;\n\t\tthis.position = position;\n\t\tthis.mode = mode;\n\t\tthis.javaType = javaType;\n\t}\n\n\t@Override\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\n\t@Override\n\tpublic Integer getPosition() {\n\t\treturn position;\n\t}\n\n\t@Override\n\tpublic ParameterMode getMode() {\n\t\treturn mode;\n\t}\n\n\t@Override\n\tpublic Class<T> getParameterType() {\n\t\treturn javaType;\n\t}\n\n\t@Override\n\tpublic NamedCallableQueryMemento.ParameterMemento toMemento() {\n\t\treturn session -> {\n\t\t\tif ( getName() != null ) {\n\t\t\t\treturn new ProcedureParameterImpl<>(\n\t\t\t\t\t\tgetName(),\n\t\t\t\t\t\tgetMode(),\n\t\t\t\t\t\tjavaType,\n\t\t\t\t\t\tgetHibernateType()\n\t\t\t\t);\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn new ProcedureParameterImpl<>(\n\t\t\t\t\t\tgetPosition(),\n\t\t\t\t\t\tgetMode(),\n\t\t\t\t\t\tjavaType,\n\t\t\t\t\t\tgetHibernateType()\n\t\t\t\t);\n\t\t\t}\n\t\t};\n\t}\n\n\t@Override\n\tpublic JdbcCallParameterRegistration toJdbcParameterRegistration(\n\t\t\tint startIndex,\n\t\t\tProcedureCallImplementor<?> procedureCall) {\n\t\tfinal QueryParameterBinding<T> binding = procedureCall.getParameterBindings().getBinding( this );\n\t\tfinal boolean isNamed = procedureCall.getParameterStrategy() == ParameterStrategy.NAMED && this.name != null;\n\n\t\tfinal BindableType<T> bindableType;\n\t\tif ( getHibernateType() != null ) {\n\t\t\tbindableType = getHibernateType();\n\t\t}\n\t\telse if ( binding != null ) {\n\t\t\t//noinspection unchecked\n\t\t\tbindableType = (BindableType<T>) binding.getBindType();\n\t\t}\n\t\telse {\n\t\t\tbindableType = null;\n\t\t}\n\n\t\tfinal OutputableType<T> typeToUse = (OutputableType<T>) BindingTypeHelper.INSTANCE.resolveTemporalPrecision(\n\t\t\t\tbinding == null ? null : binding.getExplicitTemporalPrecision(),\n\t\t\t\tbindableType,\n\t\t\t\tprocedureCall.getSession().getFactory()\n\t\t);\n\n\t\tfinal String jdbcParamName;\n\t\tif ( isNamed && canDoNameParameterBinding( typeToUse, procedureCall ) ) {\n\t\t\tjdbcParamName = this.name;\n\t\t}\n\t\telse {\n\t\t\tjdbcParamName = null;\n\t\t}\n\n\t\tfinal JdbcParameterBinder parameterBinder;\n\t\tfinal JdbcCallRefCursorExtractorImpl refCursorExtractor;\n\t\tfinal JdbcCallParameterExtractorImpl<T> parameterExtractor;\n\n\t\tswitch ( mode ) {\n\t\t\tcase REF_CURSOR:\n\t\t\t\trefCursorExtractor = new JdbcCallRefCursorExtractorImpl( jdbcParamName, startIndex );\n\t\t\t\tparameterBinder = null;\n\t\t\t\tparameterExtractor = null;\n\t\t\t\tbreak;\n\t\t\tcase IN:\n\t\t\t\tvalidateBindableType( typeToUse, startIndex );\n\t\t\t\tparameterBinder = getParameterBinder( typeToUse, jdbcParamName );\n\t\t\t\tparameterExtractor = null;\n\t\t\t\trefCursorExtractor = null;\n\t\t\t\tbreak;\n\t\t\tcase INOUT:\n\t\t\t\tvalidateBindableType( typeToUse, startIndex );\n\t\t\t\tparameterBinder = getParameterBinder( typeToUse, jdbcParamName );\n\t\t\t\tparameterExtractor = new JdbcCallParameterExtractorImpl<>( procedureCall.getProcedureName(), jdbcParamName, startIndex, typeToUse );\n\t\t\t\trefCursorExtractor = null;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tvalidateBindableType( typeToUse, startIndex );\n\t\t\t\tparameterBinder = null;\n\t\t\t\tparameterExtractor = new JdbcCallParameterExtractorImpl<>( procedureCall.getProcedureName(), jdbcParamName, startIndex, typeToUse );\n\t\t\t\trefCursorExtractor = null;\n\t\t\t\tbreak;\n\t\t}\n\n\t\treturn new JdbcCallParameterRegistrationImpl( jdbcParamName, startIndex, mode, typeToUse, parameterBinder, parameterExtractor, refCursorExtractor );\n\t}\n\n\tprivate void validateBindableType(BindableType<T> bindableType, int startIndex) {\n\t\tif ( bindableType == null ) {\n\t\t\tthrow new ParameterTypeException(\n\t\t\t\t\tString.format(\n\t\t\t\t\t\t\tLocale.ROOT,\n\t\t\t\t\t\t\t\"Could not determine ProcedureCall parameter bind type - %s (%s)\",\n\t\t\t\t\t\t\tthis.name != null ? this.name : this.position,\n\t\t\t\t\t\t\tstartIndex\n\t\t\t\t\t)\n\t\t\t);\n\t\t}\n\t}\n\n\tprivate JdbcParameterBinder getParameterBinder(BindableType<T> typeToUse, String name) {\n\t\tif ( typeToUse == null ) {\n\t\t\tthrow new ParameterTypeException(\n\t\t\t\t\tString.format(\n\t\t\t\t\t\t\tLocale.ROOT,\n\t\t\t\t\t\t\t\"Cannot determine the bindable type for procedure parameter %s (%s)\",\n\t\t\t\t\t\t\tthis.name != null ? this.name : this.position,\n\t\t\t\t\t\t\tname\n\t\t\t\t\t)\n\t\t\t);\n\t\t}\n\n\t\tif ( typeToUse instanceof BasicType<?> ) {\n\t\t\tif ( name == null ) {\n\t\t\t\treturn new JdbcParameterImpl( (BasicType<T>) typeToUse );\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn new JdbcParameterImpl( (BasicType<T>) typeToUse ) {\n\t\t\t\t\t@Override\n\t\t\t\t\tprotected void bindParameterValue(\n\t\t\t\t\t\t\tJdbcMapping jdbcMapping,\n\t\t\t\t\t\t\tPreparedStatement statement,\n\t\t\t\t\t\t\tObject bindValue,\n\t\t\t\t\t\t\tint startPosition,\n\t\t\t\t\t\t\tExecutionContext executionContext) throws SQLException {\n\t\t\t\t\t\tjdbcMapping.getJdbcValueBinder().bind(\n\t\t\t\t\t\t\t\t(CallableStatement) statement,\n\t\t\t\t\t\t\t\tbindValue,\n\t\t\t\t\t\t\t\tname,\n\t\t\t\t\t\t\t\texecutionContext.getSession()\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic String toString() {\n\t\t\t\t\t\treturn \"JdbcParameter(\" + name + \")\";\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t\tthrow new UnsupportedOperationException();\n\t}\n\n\tprivate boolean canDoNameParameterBinding(\n\t\t\tBindableType<?> hibernateType,\n\t\t\tProcedureCallImplementor<?> procedureCall) {\n\t\tfinal ExtractedDatabaseMetaData databaseMetaData = procedureCall.getSession()\n\t\t\t\t.getFactory()\n\t\t\t\t.getJdbcServices()\n\t\t\t\t.getJdbcEnvironment()\n\t\t\t\t.getExtractedDatabaseMetaData();\n\t\treturn procedureCall.getFunctionReturn() == null\n\t\t\t\t&& databaseMetaData.supportsNamedParameters()\n\t\t\t\t&& hibernateType instanceof ProcedureParameterNamedBinder\n\t\t\t\t&& ( (ProcedureParameterNamedBinder<?>) hibernateType ).canDoSetting();\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\treturn Objects.hash( name, position, mode );\n\t}\n\n\t@Override\n\tpublic boolean equals(Object o) {\n\t\tif ( this == o ) {\n\t\t\treturn true;\n\t\t}\n\t\tif ( o == null || getClass() != o.getClass() ) {\n\t\t\treturn false;\n\t\t}\n\t\tProcedureParameterImpl<?> that = (ProcedureParameterImpl<?>) o;\n\t\treturn Objects.equals( name, that.name ) &&\n\t\t\t\tObjects.equals( position, that.position ) &&\n\t\t\t\tmode == that.mode;\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\tif ( position == null ) {\n\t\t\treturn name;\n\t\t}\n\t\telse {\n\t\t\treturn position.toString();\n\t\t}\n\t}\n}\n",
        "filePathAfter": "hibernate-core/src/main/java/org/hibernate/procedure/internal/ProcedureParameterImpl.java",
        "sourceCodeAfterForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later\n * See the lgpl.txt file in the root directory or http://www.gnu.org/licenses/lgpl-2.1.html\n */\npackage org.hibernate.procedure.internal;\n\nimport java.sql.CallableStatement;\nimport java.sql.DatabaseMetaData;\nimport java.sql.PreparedStatement;\nimport java.sql.SQLException;\nimport java.util.Locale;\nimport java.util.Objects;\n\nimport org.hibernate.engine.jdbc.env.spi.ExtractedDatabaseMetaData;\nimport org.hibernate.metamodel.mapping.JdbcMapping;\nimport org.hibernate.procedure.ParameterTypeException;\nimport org.hibernate.procedure.spi.NamedCallableQueryMemento;\nimport org.hibernate.procedure.spi.ParameterStrategy;\nimport org.hibernate.procedure.spi.ProcedureCallImplementor;\nimport org.hibernate.procedure.spi.ProcedureParameterImplementor;\nimport org.hibernate.query.BindableType;\nimport org.hibernate.query.OutputableType;\nimport org.hibernate.query.internal.BindingTypeHelper;\nimport org.hibernate.query.spi.AbstractQueryParameter;\nimport org.hibernate.query.spi.QueryParameterBinding;\nimport org.hibernate.sql.exec.internal.JdbcCallParameterExtractorImpl;\nimport org.hibernate.sql.exec.internal.JdbcCallParameterRegistrationImpl;\nimport org.hibernate.sql.exec.internal.JdbcCallRefCursorExtractorImpl;\nimport org.hibernate.sql.exec.internal.JdbcParameterImpl;\nimport org.hibernate.sql.exec.spi.ExecutionContext;\nimport org.hibernate.sql.exec.spi.JdbcCallParameterRegistration;\nimport org.hibernate.sql.exec.spi.JdbcParameterBinder;\nimport org.hibernate.type.BasicType;\nimport org.hibernate.type.ProcedureParameterNamedBinder;\n\nimport jakarta.persistence.ParameterMode;\n\n/**\n * @author Steve Ebersole\n */\npublic class ProcedureParameterImpl<T> extends AbstractQueryParameter<T> implements ProcedureParameterImplementor<T> {\n\n\tprivate final String name;\n\tprivate final Integer position;\n\tprivate final ParameterMode mode;\n\tprivate final Class<T> javaType;\n\n\t/**\n\t * Used for named Query parameters\n\t */\n\tpublic ProcedureParameterImpl(\n\t\t\tString name,\n\t\t\tParameterMode mode,\n\t\t\tClass<T> javaType,\n\t\t\tBindableType<T> hibernateType) {\n\t\tsuper( false, hibernateType );\n\t\tthis.name = name;\n\t\tthis.position = null;\n\t\tthis.mode = mode;\n\t\tthis.javaType = javaType;\n\t}\n\n\t/**\n\t * Used for ordinal Query parameters\n\t */\n\tpublic ProcedureParameterImpl(\n\t\t\tInteger position,\n\t\t\tParameterMode mode,\n\t\t\tClass<T> javaType,\n\t\t\tBindableType<T> hibernateType) {\n\t\tsuper( false, hibernateType );\n\t\tthis.name = null;\n\t\tthis.position = position;\n\t\tthis.mode = mode;\n\t\tthis.javaType = javaType;\n\t}\n\n\t@Override\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\n\t@Override\n\tpublic Integer getPosition() {\n\t\treturn position;\n\t}\n\n\t@Override\n\tpublic ParameterMode getMode() {\n\t\treturn mode;\n\t}\n\n\t@Override\n\tpublic Class<T> getParameterType() {\n\t\treturn javaType;\n\t}\n\n\t@Override\n\tpublic NamedCallableQueryMemento.ParameterMemento toMemento() {\n\t\treturn session -> {\n\t\t\tif ( getName() != null ) {\n\t\t\t\treturn new ProcedureParameterImpl<>(\n\t\t\t\t\t\tgetName(),\n\t\t\t\t\t\tgetMode(),\n\t\t\t\t\t\tjavaType,\n\t\t\t\t\t\tgetHibernateType()\n\t\t\t\t);\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn new ProcedureParameterImpl<>(\n\t\t\t\t\t\tgetPosition(),\n\t\t\t\t\t\tgetMode(),\n\t\t\t\t\t\tjavaType,\n\t\t\t\t\t\tgetHibernateType()\n\t\t\t\t);\n\t\t\t}\n\t\t};\n\t}\n\n\t@Override\n\tpublic JdbcCallParameterRegistration toJdbcParameterRegistration(\n\t\t\tint startIndex,\n\t\t\tProcedureCallImplementor<?> procedureCall) {\n\t\tfinal QueryParameterBinding<T> binding = procedureCall.getParameterBindings().getBinding( this );\n\t\tfinal boolean isNamed = procedureCall.getParameterStrategy() == ParameterStrategy.NAMED && this.name != null;\n\n\t\tfinal BindableType<T> bindableType;\n\t\tif ( getHibernateType() != null ) {\n\t\t\tbindableType = getHibernateType();\n\t\t}\n\t\telse if ( binding != null ) {\n\t\t\t//noinspection unchecked\n\t\t\tbindableType = (BindableType<T>) binding.getBindType();\n\t\t}\n\t\telse {\n\t\t\tbindableType = null;\n\t\t}\n\n\t\tfinal OutputableType<T> typeToUse = (OutputableType<T>) BindingTypeHelper.INSTANCE.resolveTemporalPrecision(\n\t\t\t\tbinding == null ? null : binding.getExplicitTemporalPrecision(),\n\t\t\t\tbindableType,\n\t\t\t\tprocedureCall.getSession().getFactory()\n\t\t);\n\n\t\tfinal String jdbcParamName;\n\t\tfinal JdbcParameterBinder parameterBinder;\n\t\tfinal JdbcCallRefCursorExtractorImpl refCursorExtractor;\n\t\tfinal JdbcCallParameterExtractorImpl<T> parameterExtractor;\n\t\tfinal ExtractedDatabaseMetaData databaseMetaData = procedureCall.getSession()\n\t\t\t\t.getFactory()\n\t\t\t\t.getJdbcServices()\n\t\t\t\t.getJdbcEnvironment()\n\t\t\t\t.getExtractedDatabaseMetaData();\n\n\t\tswitch ( mode ) {\n\t\t\tcase REF_CURSOR:\n\t\t\t\tjdbcParamName = this.name != null && databaseMetaData.supportsNamedParameters() ? this.name : null;\n\t\t\t\trefCursorExtractor = new JdbcCallRefCursorExtractorImpl( jdbcParamName, startIndex );\n\t\t\t\tparameterBinder = null;\n\t\t\t\tparameterExtractor = null;\n\t\t\t\tbreak;\n\t\t\tcase IN:\n\t\t\t\tjdbcParamName = getJdbcParamName( procedureCall, isNamed, typeToUse, databaseMetaData );\n\t\t\t\tvalidateBindableType( typeToUse, startIndex );\n\t\t\t\tparameterBinder = getParameterBinder( typeToUse, jdbcParamName );\n\t\t\t\tparameterExtractor = null;\n\t\t\t\trefCursorExtractor = null;\n\t\t\t\tbreak;\n\t\t\tcase INOUT:\n\t\t\t\tjdbcParamName = getJdbcParamName( procedureCall, isNamed, typeToUse, databaseMetaData );\n\t\t\t\tvalidateBindableType( typeToUse, startIndex );\n\t\t\t\tparameterBinder = getParameterBinder( typeToUse, jdbcParamName );\n\t\t\t\tparameterExtractor = new JdbcCallParameterExtractorImpl<>( procedureCall.getProcedureName(), jdbcParamName, startIndex, typeToUse );\n\t\t\t\trefCursorExtractor = null;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tjdbcParamName = getJdbcParamName( procedureCall, isNamed, typeToUse, databaseMetaData );\n\t\t\t\tvalidateBindableType( typeToUse, startIndex );\n\t\t\t\tparameterBinder = null;\n\t\t\t\tparameterExtractor = new JdbcCallParameterExtractorImpl<>( procedureCall.getProcedureName(), jdbcParamName, startIndex, typeToUse );\n\t\t\t\trefCursorExtractor = null;\n\t\t\t\tbreak;\n\t\t}\n\n\t\treturn new JdbcCallParameterRegistrationImpl( jdbcParamName, startIndex, mode, typeToUse, parameterBinder, parameterExtractor, refCursorExtractor );\n\t}\n\n\tprivate String getJdbcParamName(\n\t\t\tProcedureCallImplementor<?> procedureCall,\n\t\t\tboolean isNamed,\n\t\t\tOutputableType<T> typeToUse,\n\t\t\tExtractedDatabaseMetaData databaseMetaData) {\n\t\treturn isNamed && canDoNameParameterBinding( typeToUse, procedureCall, databaseMetaData ) ? this.name : null;\n\t}\n\n\tprivate void validateBindableType(BindableType<T> bindableType, int startIndex) {\n\t\tif ( bindableType == null ) {\n\t\t\tthrow new ParameterTypeException(\n\t\t\t\t\tString.format(\n\t\t\t\t\t\t\tLocale.ROOT,\n\t\t\t\t\t\t\t\"Could not determine ProcedureCall parameter bind type - %s (%s)\",\n\t\t\t\t\t\t\tthis.name != null ? this.name : this.position,\n\t\t\t\t\t\t\tstartIndex\n\t\t\t\t\t)\n\t\t\t);\n\t\t}\n\t}\n\n\tprivate JdbcParameterBinder getParameterBinder(BindableType<T> typeToUse, String name) {\n\t\tif ( typeToUse == null ) {\n\t\t\tthrow new ParameterTypeException(\n\t\t\t\t\tString.format(\n\t\t\t\t\t\t\tLocale.ROOT,\n\t\t\t\t\t\t\t\"Cannot determine the bindable type for procedure parameter %s (%s)\",\n\t\t\t\t\t\t\tthis.name != null ? this.name : this.position,\n\t\t\t\t\t\t\tname\n\t\t\t\t\t)\n\t\t\t);\n\t\t}\n\n\t\tif ( typeToUse instanceof BasicType<?> ) {\n\t\t\tif ( name == null  ) {\n\t\t\t\treturn new JdbcParameterImpl( (BasicType<T>) typeToUse );\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn new JdbcParameterImpl( (BasicType<T>) typeToUse ) {\n\t\t\t\t\t@Override\n\t\t\t\t\tprotected void bindParameterValue(\n\t\t\t\t\t\t\tJdbcMapping jdbcMapping,\n\t\t\t\t\t\t\tPreparedStatement statement,\n\t\t\t\t\t\t\tObject bindValue,\n\t\t\t\t\t\t\tint startPosition,\n\t\t\t\t\t\t\tExecutionContext executionContext) throws SQLException {\n\t\t\t\t\t\tjdbcMapping.getJdbcValueBinder().bind(\n\t\t\t\t\t\t\t\t(CallableStatement) statement,\n\t\t\t\t\t\t\t\tbindValue,\n\t\t\t\t\t\t\t\tname,\n\t\t\t\t\t\t\t\texecutionContext.getSession()\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic String toString() {\n\t\t\t\t\t\treturn \"JdbcParameter(\" + name + \")\";\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t\tthrow new UnsupportedOperationException();\n\t}\n\n\tprivate boolean canDoNameParameterBinding(\n\t\t\tBindableType<?> hibernateType,\n\t\t\tProcedureCallImplementor<?> procedureCall,\n\t\t\tExtractedDatabaseMetaData databaseMetaData) {\n\t\treturn procedureCall.getFunctionReturn() == null\n\t\t\t\t&& databaseMetaData.supportsNamedParameters()\n\t\t\t\t&& hibernateType instanceof ProcedureParameterNamedBinder\n\t\t\t\t&& ( (ProcedureParameterNamedBinder<?>) hibernateType ).canDoSetting();\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\treturn Objects.hash( name, position, mode );\n\t}\n\n\t@Override\n\tpublic boolean equals(Object o) {\n\t\tif ( this == o ) {\n\t\t\treturn true;\n\t\t}\n\t\tif ( o == null || getClass() != o.getClass() ) {\n\t\t\treturn false;\n\t\t}\n\t\tProcedureParameterImpl<?> that = (ProcedureParameterImpl<?>) o;\n\t\treturn Objects.equals( name, that.name ) &&\n\t\t\t\tObjects.equals( position, that.position ) &&\n\t\t\t\tmode == that.mode;\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\tif ( position == null ) {\n\t\t\treturn name;\n\t\t}\n\t\telse {\n\t\t\treturn position.toString();\n\t\t}\n\t}\n}\n",
        "diffSourceCodeSet": [
            "private String getJdbcParamName(\n\t\t\tProcedureCallImplementor<?> procedureCall,\n\t\t\tboolean isNamed,\n\t\t\tOutputableType<T> typeToUse,\n\t\t\tExtractedDatabaseMetaData databaseMetaData) {\n\t\treturn isNamed && canDoNameParameterBinding( typeToUse, procedureCall, databaseMetaData ) ? this.name : null;\n\t}"
        ],
        "invokedMethodSet": [
            "methodSignature: org.hibernate.procedure.internal.ProcedureParameterImpl#canDoNameParameterBinding\n methodBody: private boolean canDoNameParameterBinding(\n\t\t\tBindableType<?> hibernateType,\n\t\t\tProcedureCallImplementor<?> procedureCall) {\nfinal ExtractedDatabaseMetaData databaseMetaData=procedureCall.getSession().getFactory().getJdbcServices().getJdbcEnvironment().getExtractedDatabaseMetaData();\nreturn procedureCall.getFunctionReturn() == null && databaseMetaData.supportsNamedParameters() && hibernateType instanceof ProcedureParameterNamedBinder && ((ProcedureParameterNamedBinder<?>)hibernateType).canDoSetting();\n}",
            "methodSignature: org.hibernate.procedure.internal.ProcedureParameterImpl#getParameterBinder\n methodBody: private JdbcParameterBinder getParameterBinder(BindableType<T> typeToUse, String name) {\nif(typeToUse == null){throw new ParameterTypeException(String.format(Locale.ROOT,\"Cannot determine the bindable type for procedure parameter %s (%s)\",this.name != null ? this.name : this.position,name));\n}if(typeToUse instanceof BasicType<?>){if(name == null){return new JdbcParameterImpl((BasicType<T>)typeToUse);\n}{return new JdbcParameterImpl((BasicType<T>)typeToUse){\n  @Override protected void bindParameterValue(  JdbcMapping jdbcMapping,  PreparedStatement statement,  Object bindValue,  int startPosition,  ExecutionContext executionContext) throws SQLException {\n    jdbcMapping.getJdbcValueBinder().bind((CallableStatement)statement,bindValue,name,executionContext.getSession());\n  }\n  @Override public String toString(){\n    return \"JdbcParameter(\" + name + \")\";\n  }\n}\n;\n}}throw new UnsupportedOperationException();\n}",
            "methodSignature: org.hibernate.procedure.internal.ProcedureParameterImpl#validateBindableType\n methodBody: private void validateBindableType(BindableType<T> bindableType, int startIndex) {\nif(bindableType == null){throw new ParameterTypeException(String.format(Locale.ROOT,\"Could not determine ProcedureCall parameter bind type - %s (%s)\",this.name != null ? this.name : this.position,startIndex));\n}}"
        ],
        "sourceCodeAfterRefactoring": "@Override\n\tpublic JdbcCallParameterRegistration toJdbcParameterRegistration(\n\t\t\tint startIndex,\n\t\t\tProcedureCallImplementor<?> procedureCall) {\n\t\tfinal QueryParameterBinding<T> binding = procedureCall.getParameterBindings().getBinding( this );\n\t\tfinal boolean isNamed = procedureCall.getParameterStrategy() == ParameterStrategy.NAMED && this.name != null;\n\n\t\tfinal BindableType<T> bindableType;\n\t\tif ( getHibernateType() != null ) {\n\t\t\tbindableType = getHibernateType();\n\t\t}\n\t\telse if ( binding != null ) {\n\t\t\t//noinspection unchecked\n\t\t\tbindableType = (BindableType<T>) binding.getBindType();\n\t\t}\n\t\telse {\n\t\t\tbindableType = null;\n\t\t}\n\n\t\tfinal OutputableType<T> typeToUse = (OutputableType<T>) BindingTypeHelper.INSTANCE.resolveTemporalPrecision(\n\t\t\t\tbinding == null ? null : binding.getExplicitTemporalPrecision(),\n\t\t\t\tbindableType,\n\t\t\t\tprocedureCall.getSession().getFactory()\n\t\t);\n\n\t\tfinal String jdbcParamName;\n\t\tfinal JdbcParameterBinder parameterBinder;\n\t\tfinal JdbcCallRefCursorExtractorImpl refCursorExtractor;\n\t\tfinal JdbcCallParameterExtractorImpl<T> parameterExtractor;\n\t\tfinal ExtractedDatabaseMetaData databaseMetaData = procedureCall.getSession()\n\t\t\t\t.getFactory()\n\t\t\t\t.getJdbcServices()\n\t\t\t\t.getJdbcEnvironment()\n\t\t\t\t.getExtractedDatabaseMetaData();\n\n\t\tswitch ( mode ) {\n\t\t\tcase REF_CURSOR:\n\t\t\t\tjdbcParamName = this.name != null && databaseMetaData.supportsNamedParameters() ? this.name : null;\n\t\t\t\trefCursorExtractor = new JdbcCallRefCursorExtractorImpl( jdbcParamName, startIndex );\n\t\t\t\tparameterBinder = null;\n\t\t\t\tparameterExtractor = null;\n\t\t\t\tbreak;\n\t\t\tcase IN:\n\t\t\t\tjdbcParamName = getJdbcParamName( procedureCall, isNamed, typeToUse, databaseMetaData );\n\t\t\t\tvalidateBindableType( typeToUse, startIndex );\n\t\t\t\tparameterBinder = getParameterBinder( typeToUse, jdbcParamName );\n\t\t\t\tparameterExtractor = null;\n\t\t\t\trefCursorExtractor = null;\n\t\t\t\tbreak;\n\t\t\tcase INOUT:\n\t\t\t\tjdbcParamName = getJdbcParamName( procedureCall, isNamed, typeToUse, databaseMetaData );\n\t\t\t\tvalidateBindableType( typeToUse, startIndex );\n\t\t\t\tparameterBinder = getParameterBinder( typeToUse, jdbcParamName );\n\t\t\t\tparameterExtractor = new JdbcCallParameterExtractorImpl<>( procedureCall.getProcedureName(), jdbcParamName, startIndex, typeToUse );\n\t\t\t\trefCursorExtractor = null;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tjdbcParamName = getJdbcParamName( procedureCall, isNamed, typeToUse, databaseMetaData );\n\t\t\t\tvalidateBindableType( typeToUse, startIndex );\n\t\t\t\tparameterBinder = null;\n\t\t\t\tparameterExtractor = new JdbcCallParameterExtractorImpl<>( procedureCall.getProcedureName(), jdbcParamName, startIndex, typeToUse );\n\t\t\t\trefCursorExtractor = null;\n\t\t\t\tbreak;\n\t\t}\n\n\t\treturn new JdbcCallParameterRegistrationImpl( jdbcParamName, startIndex, mode, typeToUse, parameterBinder, parameterExtractor, refCursorExtractor );\n\t}\nprivate String getJdbcParamName(\n\t\t\tProcedureCallImplementor<?> procedureCall,\n\t\t\tboolean isNamed,\n\t\t\tOutputableType<T> typeToUse,\n\t\t\tExtractedDatabaseMetaData databaseMetaData) {\n\t\treturn isNamed && canDoNameParameterBinding( typeToUse, procedureCall, databaseMetaData ) ? this.name : null;\n\t}",
        "diffSourceCode": "-  121: \t@Override\n-  122: \tpublic JdbcCallParameterRegistration toJdbcParameterRegistration(\n-  123: \t\t\tint startIndex,\n-  124: \t\t\tProcedureCallImplementor<?> procedureCall) {\n-  125: \t\tfinal QueryParameterBinding<T> binding = procedureCall.getParameterBindings().getBinding( this );\n-  126: \t\tfinal boolean isNamed = procedureCall.getParameterStrategy() == ParameterStrategy.NAMED && this.name != null;\n-  127: \n-  128: \t\tfinal BindableType<T> bindableType;\n-  129: \t\tif ( getHibernateType() != null ) {\n-  130: \t\t\tbindableType = getHibernateType();\n-  131: \t\t}\n-  132: \t\telse if ( binding != null ) {\n-  133: \t\t\t//noinspection unchecked\n-  134: \t\t\tbindableType = (BindableType<T>) binding.getBindType();\n-  135: \t\t}\n-  136: \t\telse {\n-  137: \t\t\tbindableType = null;\n-  138: \t\t}\n-  139: \n-  140: \t\tfinal OutputableType<T> typeToUse = (OutputableType<T>) BindingTypeHelper.INSTANCE.resolveTemporalPrecision(\n-  141: \t\t\t\tbinding == null ? null : binding.getExplicitTemporalPrecision(),\n-  142: \t\t\t\tbindableType,\n-  143: \t\t\t\tprocedureCall.getSession().getFactory()\n-  144: \t\t);\n-  145: \n-  146: \t\tfinal String jdbcParamName;\n-  147: \t\tif ( isNamed && canDoNameParameterBinding( typeToUse, procedureCall ) ) {\n-  148: \t\t\tjdbcParamName = this.name;\n-  149: \t\t}\n-  150: \t\telse {\n-  151: \t\t\tjdbcParamName = null;\n-  152: \t\t}\n-  153: \n-  154: \t\tfinal JdbcParameterBinder parameterBinder;\n-  155: \t\tfinal JdbcCallRefCursorExtractorImpl refCursorExtractor;\n-  156: \t\tfinal JdbcCallParameterExtractorImpl<T> parameterExtractor;\n-  157: \n-  158: \t\tswitch ( mode ) {\n-  159: \t\t\tcase REF_CURSOR:\n+  121: \n+  122: \t@Override\n+  123: \tpublic JdbcCallParameterRegistration toJdbcParameterRegistration(\n+  124: \t\t\tint startIndex,\n+  125: \t\t\tProcedureCallImplementor<?> procedureCall) {\n+  126: \t\tfinal QueryParameterBinding<T> binding = procedureCall.getParameterBindings().getBinding( this );\n+  127: \t\tfinal boolean isNamed = procedureCall.getParameterStrategy() == ParameterStrategy.NAMED && this.name != null;\n+  128: \n+  129: \t\tfinal BindableType<T> bindableType;\n+  130: \t\tif ( getHibernateType() != null ) {\n+  131: \t\t\tbindableType = getHibernateType();\n+  132: \t\t}\n+  133: \t\telse if ( binding != null ) {\n+  134: \t\t\t//noinspection unchecked\n+  135: \t\t\tbindableType = (BindableType<T>) binding.getBindType();\n+  136: \t\t}\n+  137: \t\telse {\n+  138: \t\t\tbindableType = null;\n+  139: \t\t}\n+  140: \n+  141: \t\tfinal OutputableType<T> typeToUse = (OutputableType<T>) BindingTypeHelper.INSTANCE.resolveTemporalPrecision(\n+  142: \t\t\t\tbinding == null ? null : binding.getExplicitTemporalPrecision(),\n+  143: \t\t\t\tbindableType,\n+  144: \t\t\t\tprocedureCall.getSession().getFactory()\n+  145: \t\t);\n+  146: \n+  147: \t\tfinal String jdbcParamName;\n+  148: \t\tfinal JdbcParameterBinder parameterBinder;\n+  149: \t\tfinal JdbcCallRefCursorExtractorImpl refCursorExtractor;\n+  150: \t\tfinal JdbcCallParameterExtractorImpl<T> parameterExtractor;\n+  151: \t\tfinal ExtractedDatabaseMetaData databaseMetaData = procedureCall.getSession()\n+  152: \t\t\t\t.getFactory()\n+  153: \t\t\t\t.getJdbcServices()\n+  154: \t\t\t\t.getJdbcEnvironment()\n+  155: \t\t\t\t.getExtractedDatabaseMetaData();\n+  156: \n+  157: \t\tswitch ( mode ) {\n+  158: \t\t\tcase REF_CURSOR:\n+  159: \t\t\t\tjdbcParamName = this.name != null && databaseMetaData.supportsNamedParameters() ? this.name : null;\n   160: \t\t\t\trefCursorExtractor = new JdbcCallRefCursorExtractorImpl( jdbcParamName, startIndex );\n   161: \t\t\t\tparameterBinder = null;\n   162: \t\t\t\tparameterExtractor = null;\n   163: \t\t\t\tbreak;\n   164: \t\t\tcase IN:\n-  165: \t\t\t\tvalidateBindableType( typeToUse, startIndex );\n-  166: \t\t\t\tparameterBinder = getParameterBinder( typeToUse, jdbcParamName );\n-  167: \t\t\t\tparameterExtractor = null;\n-  168: \t\t\t\trefCursorExtractor = null;\n-  169: \t\t\t\tbreak;\n-  170: \t\t\tcase INOUT:\n-  171: \t\t\t\tvalidateBindableType( typeToUse, startIndex );\n-  172: \t\t\t\tparameterBinder = getParameterBinder( typeToUse, jdbcParamName );\n-  173: \t\t\t\tparameterExtractor = new JdbcCallParameterExtractorImpl<>( procedureCall.getProcedureName(), jdbcParamName, startIndex, typeToUse );\n-  174: \t\t\t\trefCursorExtractor = null;\n-  175: \t\t\t\tbreak;\n-  176: \t\t\tdefault:\n-  177: \t\t\t\tvalidateBindableType( typeToUse, startIndex );\n-  178: \t\t\t\tparameterBinder = null;\n-  179: \t\t\t\tparameterExtractor = new JdbcCallParameterExtractorImpl<>( procedureCall.getProcedureName(), jdbcParamName, startIndex, typeToUse );\n-  180: \t\t\t\trefCursorExtractor = null;\n-  181: \t\t\t\tbreak;\n-  182: \t\t}\n-  183: \n-  184: \t\treturn new JdbcCallParameterRegistrationImpl( jdbcParamName, startIndex, mode, typeToUse, parameterBinder, parameterExtractor, refCursorExtractor );\n-  185: \t}\n+  165: \t\t\t\tjdbcParamName = getJdbcParamName( procedureCall, isNamed, typeToUse, databaseMetaData );\n+  166: \t\t\t\tvalidateBindableType( typeToUse, startIndex );\n+  167: \t\t\t\tparameterBinder = getParameterBinder( typeToUse, jdbcParamName );\n+  168: \t\t\t\tparameterExtractor = null;\n+  169: \t\t\t\trefCursorExtractor = null;\n+  170: \t\t\t\tbreak;\n+  171: \t\t\tcase INOUT:\n+  172: \t\t\t\tjdbcParamName = getJdbcParamName( procedureCall, isNamed, typeToUse, databaseMetaData );\n+  173: \t\t\t\tvalidateBindableType( typeToUse, startIndex );\n+  174: \t\t\t\tparameterBinder = getParameterBinder( typeToUse, jdbcParamName );\n+  175: \t\t\t\tparameterExtractor = new JdbcCallParameterExtractorImpl<>( procedureCall.getProcedureName(), jdbcParamName, startIndex, typeToUse );\n+  176: \t\t\t\trefCursorExtractor = null;\n+  177: \t\t\t\tbreak;\n+  178: \t\t\tdefault:\n+  179: \t\t\t\tjdbcParamName = getJdbcParamName( procedureCall, isNamed, typeToUse, databaseMetaData );\n+  180: \t\t\t\tvalidateBindableType( typeToUse, startIndex );\n+  181: \t\t\t\tparameterBinder = null;\n+  182: \t\t\t\tparameterExtractor = new JdbcCallParameterExtractorImpl<>( procedureCall.getProcedureName(), jdbcParamName, startIndex, typeToUse );\n+  183: \t\t\t\trefCursorExtractor = null;\n+  184: \t\t\t\tbreak;\n+  185: \t\t}\n   186: \n-  187: \tprivate void validateBindableType(BindableType<T> bindableType, int startIndex) {\n-  188: \t\tif ( bindableType == null ) {\n-  190: \t\t\t\t\tString.format(\n-  191: \t\t\t\t\t\t\tLocale.ROOT,\n-  192: \t\t\t\t\t\t\t\"Could not determine ProcedureCall parameter bind type - %s (%s)\",\n-  193: \t\t\t\t\t\t\tthis.name != null ? this.name : this.position,\n-  194: \t\t\t\t\t\t\tstartIndex\n-  195: \t\t\t\t\t)\n-  196: \t\t\t);\n+  187: \t\treturn new JdbcCallParameterRegistrationImpl( jdbcParamName, startIndex, mode, typeToUse, parameterBinder, parameterExtractor, refCursorExtractor );\n+  188: \t}\n+  190: \tprivate String getJdbcParamName(\n+  191: \t\t\tProcedureCallImplementor<?> procedureCall,\n+  192: \t\t\tboolean isNamed,\n+  193: \t\t\tOutputableType<T> typeToUse,\n+  194: \t\t\tExtractedDatabaseMetaData databaseMetaData) {\n+  195: \t\treturn isNamed && canDoNameParameterBinding( typeToUse, procedureCall, databaseMetaData ) ? this.name : null;\n+  196: \t}\n",
        "uniqueId": "8766a8e012cd08616847f26f3ccb3e0bd7441698_121_185_190_196_122_188",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 73,
                "covered": 66
            },
            "BRANCH": {
                "missed": 13,
                "covered": 5
            },
            "LINE": {
                "missed": 17,
                "covered": 16
            },
            "COMPLEXITY": {
                "missed": 10,
                "covered": 1
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 21
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprivate extractIsolationAsString(properties Map<String,Object>) : String extracted from private resolveIsolationSetting(properties Map<String,Object>, cf AgroalConnectionFactoryConfigurationSupplier) : void in class org.hibernate.agroal.internal.AgroalConnectionProvider",
        "diffLocations": [
            {
                "filePath": "hibernate-agroal/src/main/java/org/hibernate/agroal/internal/AgroalConnectionProvider.java",
                "startLine": 64,
                "endLine": 71,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-agroal/src/main/java/org/hibernate/agroal/internal/AgroalConnectionProvider.java",
                "startLine": 80,
                "endLine": 85,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-agroal/src/main/java/org/hibernate/agroal/internal/AgroalConnectionProvider.java",
                "startLine": 71,
                "endLine": 78,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "private static void resolveIsolationSetting(Map<String, Object> properties, AgroalConnectionFactoryConfigurationSupplier cf) {\n\t\tInteger isolation = ConnectionProviderInitiator.extractIsolation( properties );\n\t\tif ( isolation != null ) {\n\t\t\t// Agroal resolves transaction isolation from the 'nice' name\n\t\t\tString isolationString = ConnectionProviderInitiator.toIsolationNiceName( isolation );\n\t\t\tcf.jdbcTransactionIsolation( AgroalConnectionFactoryConfiguration.TransactionIsolation.valueOf( isolationString ) );\n\t\t}\n\t}",
        "filePathBefore": "hibernate-agroal/src/main/java/org/hibernate/agroal/internal/AgroalConnectionProvider.java",
        "isPureRefactoring": true,
        "commitId": "f556ba9e909d6258f4ab041bd61fb6fa8e1a57e0",
        "packageNameBefore": "org.hibernate.agroal.internal",
        "classNameBefore": "org.hibernate.agroal.internal.AgroalConnectionProvider",
        "methodNameBefore": "org.hibernate.agroal.internal.AgroalConnectionProvider#resolveIsolationSetting",
        "classSignatureBefore": "public class AgroalConnectionProvider implements ConnectionProvider, Configurable, Stoppable ",
        "methodNameBeforeSet": [
            "org.hibernate.agroal.internal.AgroalConnectionProvider#resolveIsolationSetting"
        ],
        "classNameBeforeSet": [
            "org.hibernate.agroal.internal.AgroalConnectionProvider"
        ],
        "classSignatureBeforeSet": [
            "public class AgroalConnectionProvider implements ConnectionProvider, Configurable, Stoppable "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Changes are within the Extract Method refactoring mechanics Severe changes",
                "description": "Return expression has been added within the Extract Method mechanics - with non-mapped leaves",
                "mappingState": 2
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.\n */\n\npackage org.hibernate.agroal.internal;\n\nimport io.agroal.api.AgroalDataSource;\nimport io.agroal.api.configuration.AgroalConnectionFactoryConfiguration;\nimport io.agroal.api.configuration.supplier.AgroalConnectionFactoryConfigurationSupplier;\nimport io.agroal.api.configuration.supplier.AgroalPropertiesReader;\nimport io.agroal.api.security.NamePrincipal;\nimport io.agroal.api.security.SimplePassword;\nimport org.hibernate.HibernateException;\nimport org.hibernate.cfg.AgroalSettings;\nimport org.hibernate.cfg.AvailableSettings;\nimport org.hibernate.engine.jdbc.connections.internal.ConnectionProviderInitiator;\nimport org.hibernate.engine.jdbc.connections.spi.ConnectionProvider;\nimport org.hibernate.service.UnknownUnwrapTypeException;\nimport org.hibernate.service.spi.Configurable;\nimport org.hibernate.service.spi.Stoppable;\nimport org.jboss.logging.Logger;\n\nimport javax.sql.DataSource;\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.Map;\nimport java.util.function.Consumer;\nimport java.util.function.Function;\n\n/**\n * ConnectionProvider based on Agroal connection pool\n * To use this ConnectionProvider set: <pre> hibernate.connection.provider_class AgroalConnectionProvider </pre>\n *\n * Usual hibernate properties are supported:\n * <pre>\n *     hibernate.connection.driver_class\n *     hibernate.connection.url\n *     hibernate.connection.username\n *     hibernate.connection.password\n *     hibernate.connection.autocommit\n *     hibernate.connection.isolation\n * </pre>\n *\n * Other configuration options are available, using the {@code hibernate.agroal} prefix\n *\n * @see AgroalSettings\n * @see AgroalPropertiesReader\n * @see AvailableSettings#CONNECTION_PROVIDER\n *\n * @author Luis Barreiro\n */\npublic class AgroalConnectionProvider implements ConnectionProvider, Configurable, Stoppable {\n\n\tpublic static final String CONFIG_PREFIX = AgroalSettings.AGROAL_CONFIG_PREFIX + \".\";\n\tprivate static final long serialVersionUID = 1L;\n\tprivate static final Logger LOGGER = Logger.getLogger( AgroalConnectionProvider.class );\n\tprivate AgroalDataSource agroalDataSource = null;\n\n\t// --- Configurable\n\n\tprivate static void resolveIsolationSetting(Map<String, Object> properties, AgroalConnectionFactoryConfigurationSupplier cf) {\n\t\tInteger isolation = ConnectionProviderInitiator.extractIsolation( properties );\n\t\tif ( isolation != null ) {\n\t\t\t// Agroal resolves transaction isolation from the 'nice' name\n\t\t\tString isolationString = ConnectionProviderInitiator.toIsolationNiceName( isolation );\n\t\t\tcf.jdbcTransactionIsolation( AgroalConnectionFactoryConfiguration.TransactionIsolation.valueOf( isolationString ) );\n\t\t}\n\t}\n\n\tprivate static <T> void copyProperty(Map<String, Object> properties, String key, Consumer<T> consumer, Function<String, T> converter) {\n\t\tObject value = properties.get( key );\n\t\tif ( value instanceof String ) {\n\t\t\tconsumer.accept( converter.apply( (String) value ) );\n\t\t}\n\t}\n\n\t@Override\n\tpublic void configure(Map<String, Object> props) throws HibernateException {\n\t\tLOGGER.debug( \"Configuring Agroal\" );\n\t\ttry {\n\t\t\tAgroalPropertiesReader agroalProperties = new AgroalPropertiesReader( CONFIG_PREFIX )\n\t\t\t\t\t.readProperties( (Map) props ); //TODO: this is a garbage cast\n\t\t\tagroalProperties.modify().connectionPoolConfiguration( cp -> cp.connectionFactoryConfiguration( cf -> {\n\t\t\t\tcopyProperty( props, AvailableSettings.DRIVER, cf::connectionProviderClassName, Function.identity() );\n\t\t\t\tcopyProperty( props, AvailableSettings.URL, cf::jdbcUrl, Function.identity() );\n\t\t\t\tcopyProperty( props, AvailableSettings.USER, cf::principal, NamePrincipal::new );\n\t\t\t\tcopyProperty( props, AvailableSettings.PASS, cf::credential, SimplePassword::new );\n\t\t\t\tcopyProperty( props, AvailableSettings.AUTOCOMMIT, cf::autoCommit, Boolean::valueOf );\n\t\t\t\tresolveIsolationSetting( props, cf );\n\t\t\t\treturn cf;\n\t\t\t} ) );\n\n\t\t\tagroalDataSource = AgroalDataSource.from( agroalProperties );\n\t\t}\n\t\tcatch ( Exception e ) {\n\t\t\tthrow new HibernateException( e );\n\t\t}\n\t\tLOGGER.debug( \"Agroal Configured\" );\n\t}\n\n\t// --- ConnectionProvider\n\n\t@Override\n\tpublic Connection getConnection() throws SQLException {\n\t\treturn agroalDataSource == null ? null : agroalDataSource.getConnection();\n\t}\n\n\t@Override\n\tpublic void closeConnection(Connection connection) throws SQLException {\n\t\tconnection.close();\n\t}\n\n\t@Override\n\tpublic boolean supportsAggressiveRelease() {\n\t\t// Agroal supports integration with Narayana as the JTA provider, that would enable aggressive release\n\t\t// That logic is similar with what Hibernate does (however with better performance since it's integrated in the pool)\n\t\t// and therefore that integration is not leveraged right now.\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic boolean isUnwrappableAs(Class<?> unwrapType) {\n\t\treturn ConnectionProvider.class.equals( unwrapType )\n\t\t\t|| AgroalConnectionProvider.class.isAssignableFrom( unwrapType )\n\t\t\t|| DataSource.class.isAssignableFrom( unwrapType );\n\t}\n\n\t@Override\n\t@SuppressWarnings( \"unchecked\" )\n\tpublic <T> T unwrap(Class<T> unwrapType) {\n\t\tif ( ConnectionProvider.class.equals( unwrapType )\n\t\t\t\t|| AgroalConnectionProvider.class.isAssignableFrom( unwrapType ) ) {\n\t\t\treturn (T) this;\n\t\t}\n\t\tif ( DataSource.class.isAssignableFrom( unwrapType ) ) {\n\t\t\treturn (T) agroalDataSource;\n\t\t}\n\t\tthrow new UnknownUnwrapTypeException( unwrapType );\n\t}\n\n\t// --- Stoppable\n\n\t@Override\n\tpublic void stop() {\n\t\tif ( agroalDataSource != null ) {\n\t\t\tagroalDataSource.close();\n\t\t}\n\t}\n}\n",
        "filePathAfter": "hibernate-agroal/src/main/java/org/hibernate/agroal/internal/AgroalConnectionProvider.java",
        "sourceCodeAfterForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.\n */\n\npackage org.hibernate.agroal.internal;\n\nimport io.agroal.api.AgroalDataSource;\nimport io.agroal.api.configuration.AgroalConnectionFactoryConfiguration;\nimport io.agroal.api.configuration.AgroalConnectionPoolConfiguration;\nimport io.agroal.api.configuration.supplier.AgroalConnectionFactoryConfigurationSupplier;\nimport io.agroal.api.configuration.supplier.AgroalPropertiesReader;\nimport io.agroal.api.security.NamePrincipal;\nimport io.agroal.api.security.SimplePassword;\nimport org.hibernate.HibernateException;\nimport org.hibernate.cfg.AgroalSettings;\nimport org.hibernate.cfg.AvailableSettings;\nimport org.hibernate.engine.jdbc.connections.internal.ConnectionProviderInitiator;\nimport org.hibernate.engine.jdbc.connections.internal.DatabaseConnectionInfoImpl;\nimport org.hibernate.engine.jdbc.connections.spi.ConnectionProvider;\nimport org.hibernate.engine.jdbc.connections.spi.DatabaseConnectionInfo;\nimport org.hibernate.service.UnknownUnwrapTypeException;\nimport org.hibernate.service.spi.Configurable;\nimport org.hibernate.service.spi.Stoppable;\n\nimport javax.sql.DataSource;\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.Map;\nimport java.util.function.Consumer;\nimport java.util.function.Function;\n\nimport org.jboss.logging.Logger;\n\nimport static org.hibernate.cfg.AgroalSettings.AGROAL_CONFIG_PREFIX;\n\n/**\n * ConnectionProvider based on Agroal connection pool\n * To use this ConnectionProvider set: <pre> hibernate.connection.provider_class AgroalConnectionProvider </pre>\n *\n * Usual hibernate properties are supported:\n * <pre>\n *     hibernate.connection.driver_class\n *     hibernate.connection.url\n *     hibernate.connection.username\n *     hibernate.connection.password\n *     hibernate.connection.autocommit\n *     hibernate.connection.isolation\n * </pre>\n *\n * Other configuration options are available, using the {@code hibernate.agroal} prefix\n *\n * @see AgroalSettings\n * @see AgroalPropertiesReader\n * @see AvailableSettings#CONNECTION_PROVIDER\n *\n * @author Luis Barreiro\n */\npublic class AgroalConnectionProvider implements ConnectionProvider, Configurable, Stoppable {\n\n\tpublic static final String CONFIG_PREFIX = AGROAL_CONFIG_PREFIX + \".\";\n\tprivate static final long serialVersionUID = 1L;\n\tprivate static final Logger LOGGER = Logger.getLogger( AgroalConnectionProvider.class );\n\tprivate AgroalDataSource agroalDataSource = null;\n\tprivate DatabaseConnectionInfo dbInfo;\n\n\t// --- Configurable\n\n\tprivate static String extractIsolationAsString(Map<String, Object> properties) {\n\t\tInteger isolation = ConnectionProviderInitiator.extractIsolation( properties );\n\t\tif ( isolation != null ) {\n\t\t\t// Agroal resolves transaction isolation from the 'nice' name\n\t\t\treturn ConnectionProviderInitiator.toIsolationNiceName( isolation );\n\t\t}\n\t\treturn null;\n\t}\n\n\tprivate static void resolveIsolationSetting(Map<String, Object> properties, AgroalConnectionFactoryConfigurationSupplier cf) {\n\t\tString isolationString = extractIsolationAsString( properties );\n\t\tif ( isolationString != null ) {\n\t\t\tcf.jdbcTransactionIsolation( AgroalConnectionFactoryConfiguration.TransactionIsolation.valueOf( isolationString ) );\n\t\t}\n\t}\n\n\tprivate static <T> void copyProperty(Map<String, Object> properties, String key, Consumer<T> consumer, Function<String, T> converter) {\n\t\tObject value = properties.get( key );\n\t\tif ( value instanceof String ) {\n\t\t\tconsumer.accept( converter.apply( (String) value ) );\n\t\t}\n\t}\n\n\t@Override\n\tpublic void configure(Map<String, Object> props) throws HibernateException {\n\t\tLOGGER.debug( \"Configuring Agroal\" );\n\t\ttry {\n\t\t\tAgroalPropertiesReader agroalProperties = new AgroalPropertiesReader( CONFIG_PREFIX )\n\t\t\t\t\t.readProperties( (Map) props ); //TODO: this is a garbage cast\n\t\t\tagroalProperties.modify().connectionPoolConfiguration( cp -> cp.connectionFactoryConfiguration( cf -> {\n\t\t\t\tcopyProperty( props, AvailableSettings.DRIVER, cf::connectionProviderClassName, Function.identity() );\n\t\t\t\tcopyProperty( props, AvailableSettings.URL, cf::jdbcUrl, Function.identity() );\n\t\t\t\tcopyProperty( props, AvailableSettings.USER, cf::principal, NamePrincipal::new );\n\t\t\t\tcopyProperty( props, AvailableSettings.PASS, cf::credential, SimplePassword::new );\n\t\t\t\tcopyProperty( props, AvailableSettings.AUTOCOMMIT, cf::autoCommit, Boolean::valueOf );\n\t\t\t\tresolveIsolationSetting( props, cf );\n\t\t\t\treturn cf;\n\t\t\t} ) );\n\n\t\t\tagroalDataSource = AgroalDataSource.from( agroalProperties );\n\n\t\t\t// For logging purposes\n\t\t\tAgroalConnectionPoolConfiguration acpc = agroalDataSource.getConfiguration().connectionPoolConfiguration();\n\t\t\tAgroalConnectionFactoryConfiguration acfc = acpc.connectionFactoryConfiguration();\n\t\t\tdbInfo = new DatabaseConnectionInfoImpl()\n\t\t\t\t\t.setDBUrl( acfc.jdbcUrl() )\n\t\t\t\t\t.setDBDriverName( acfc.connectionProviderClass().toString() )\n\t\t\t\t\t.setDBAutoCommitMode( Boolean.toString(acfc.autoCommit()) )\n\t\t\t\t\t.setDBIsolationLevel( acfc.jdbcTransactionIsolation() != null ?\n\t\t\t\t\t\t\tConnectionProviderInitiator.toIsolationNiceName( acfc.jdbcTransactionIsolation().level() ) : null )\n\t\t\t\t\t.setDBMinPoolSize( String.valueOf(acpc.minSize()) )\n\t\t\t\t\t.setDBMaxPoolSize( String.valueOf(acpc.maxSize()) );\n\t\t}\n\t\tcatch ( Exception e ) {\n\t\t\tthrow new HibernateException( e );\n\t\t}\n\t\tLOGGER.debug( \"Agroal Configured\" );\n\t}\n\n\t// --- ConnectionProvider\n\n\t@Override\n\tpublic Connection getConnection() throws SQLException {\n\t\treturn agroalDataSource == null ? null : agroalDataSource.getConnection();\n\t}\n\n\t@Override\n\tpublic void closeConnection(Connection connection) throws SQLException {\n\t\tconnection.close();\n\t}\n\n\t@Override\n\tpublic boolean supportsAggressiveRelease() {\n\t\t// Agroal supports integration with Narayana as the JTA provider, that would enable aggressive release\n\t\t// That logic is similar with what Hibernate does (however with better performance since it's integrated in the pool)\n\t\t// and therefore that integration is not leveraged right now.\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic DatabaseConnectionInfo getDatabaseConnectionInfo() {\n\t\treturn dbInfo;\n\t}\n\n\t@Override\n\tpublic boolean isUnwrappableAs(Class<?> unwrapType) {\n\t\treturn ConnectionProvider.class.equals( unwrapType )\n\t\t\t|| AgroalConnectionProvider.class.isAssignableFrom( unwrapType )\n\t\t\t|| DataSource.class.isAssignableFrom( unwrapType );\n\t}\n\n\t@Override\n\t@SuppressWarnings( \"unchecked\" )\n\tpublic <T> T unwrap(Class<T> unwrapType) {\n\t\tif ( ConnectionProvider.class.equals( unwrapType )\n\t\t\t\t|| AgroalConnectionProvider.class.isAssignableFrom( unwrapType ) ) {\n\t\t\treturn (T) this;\n\t\t}\n\t\tif ( DataSource.class.isAssignableFrom( unwrapType ) ) {\n\t\t\treturn (T) agroalDataSource;\n\t\t}\n\t\tthrow new UnknownUnwrapTypeException( unwrapType );\n\t}\n\n\t// --- Stoppable\n\n\t@Override\n\tpublic void stop() {\n\t\tif ( agroalDataSource != null ) {\n\t\t\tagroalDataSource.close();\n\t\t}\n\t}\n}\n",
        "diffSourceCodeSet": [
            "private static String extractIsolationAsString(Map<String, Object> properties) {\n\t\tInteger isolation = ConnectionProviderInitiator.extractIsolation( properties );\n\t\tif ( isolation != null ) {\n\t\t\t// Agroal resolves transaction isolation from the 'nice' name\n\t\t\treturn ConnectionProviderInitiator.toIsolationNiceName( isolation );\n\t\t}\n\t\treturn null;\n\t}"
        ],
        "invokedMethodSet": [],
        "sourceCodeAfterRefactoring": "private static void resolveIsolationSetting(Map<String, Object> properties, AgroalConnectionFactoryConfigurationSupplier cf) {\n\t\tString isolationString = extractIsolationAsString( properties );\n\t\tif ( isolationString != null ) {\n\t\t\tcf.jdbcTransactionIsolation( AgroalConnectionFactoryConfiguration.TransactionIsolation.valueOf( isolationString ) );\n\t\t}\n\t}\nprivate static String extractIsolationAsString(Map<String, Object> properties) {\n\t\tInteger isolation = ConnectionProviderInitiator.extractIsolation( properties );\n\t\tif ( isolation != null ) {\n\t\t\t// Agroal resolves transaction isolation from the 'nice' name\n\t\t\treturn ConnectionProviderInitiator.toIsolationNiceName( isolation );\n\t\t}\n\t\treturn null;\n\t}",
        "diffSourceCode": "-   64: \tprivate static void resolveIsolationSetting(Map<String, Object> properties, AgroalConnectionFactoryConfigurationSupplier cf) {\n-   65: \t\tInteger isolation = ConnectionProviderInitiator.extractIsolation( properties );\n-   66: \t\tif ( isolation != null ) {\n-   67: \t\t\t// Agroal resolves transaction isolation from the 'nice' name\n-   68: \t\t\tString isolationString = ConnectionProviderInitiator.toIsolationNiceName( isolation );\n-   69: \t\t\tcf.jdbcTransactionIsolation( AgroalConnectionFactoryConfiguration.TransactionIsolation.valueOf( isolationString ) );\n-   70: \t\t}\n-   71: \t}\n-   72: \n-   73: \tprivate static <T> void copyProperty(Map<String, Object> properties, String key, Consumer<T> consumer, Function<String, T> converter) {\n-   74: \t\tObject value = properties.get( key );\n-   75: \t\tif ( value instanceof String ) {\n-   76: \t\t\tconsumer.accept( converter.apply( (String) value ) );\n-   77: \t\t}\n+   64: \tprivate static final long serialVersionUID = 1L;\n+   65: \tprivate static final Logger LOGGER = Logger.getLogger( AgroalConnectionProvider.class );\n+   66: \tprivate AgroalDataSource agroalDataSource = null;\n+   67: \tprivate DatabaseConnectionInfo dbInfo;\n+   68: \n+   69: \t// --- Configurable\n+   70: \n+   71: \tprivate static String extractIsolationAsString(Map<String, Object> properties) {\n+   72: \t\tInteger isolation = ConnectionProviderInitiator.extractIsolation( properties );\n+   73: \t\tif ( isolation != null ) {\n+   74: \t\t\t// Agroal resolves transaction isolation from the 'nice' name\n+   75: \t\t\treturn ConnectionProviderInitiator.toIsolationNiceName( isolation );\n+   76: \t\t}\n+   77: \t\treturn null;\n    78: \t}\n-   80: \t@Override\n-   81: \tpublic void configure(Map<String, Object> props) throws HibernateException {\n-   82: \t\tLOGGER.debug( \"Configuring Agroal\" );\n-   83: \t\ttry {\n-   84: \t\t\tAgroalPropertiesReader agroalProperties = new AgroalPropertiesReader( CONFIG_PREFIX )\n-   85: \t\t\t\t\t.readProperties( (Map) props ); //TODO: this is a garbage cast\n+   80: \tprivate static void resolveIsolationSetting(Map<String, Object> properties, AgroalConnectionFactoryConfigurationSupplier cf) {\n+   81: \t\tString isolationString = extractIsolationAsString( properties );\n+   82: \t\tif ( isolationString != null ) {\n+   83: \t\t\tcf.jdbcTransactionIsolation( AgroalConnectionFactoryConfiguration.TransactionIsolation.valueOf( isolationString ) );\n+   84: \t\t}\n+   85: \t}\n",
        "uniqueId": "f556ba9e909d6258f4ab041bd61fb6fa8e1a57e0_64_71_71_78_80_85",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 0,
                "covered": 14
            },
            "BRANCH": {
                "missed": 0,
                "covered": 2
            },
            "LINE": {
                "missed": 0,
                "covered": 5
            },
            "COMPLEXITY": {
                "missed": 0,
                "covered": 2
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 21
    },
    {
        "type": "Extract And Move Method",
        "description": "Extract And Move Method\tpublic finishUp(resultCount int, session SharedSessionContractImplementor) : void extracted from public finishUp(session SharedSessionContractImplementor) : void in class org.hibernate.sql.results.jdbc.internal.JdbcValuesResultSetImpl & moved to class org.hibernate.sql.results.caching.QueryCachePutManager",
        "diffLocations": [
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/sql/results/jdbc/internal/JdbcValuesResultSetImpl.java",
                "startLine": 330,
                "endLine": 336,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/sql/results/jdbc/internal/JdbcValuesResultSetImpl.java",
                "startLine": 350,
                "endLine": 356,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/sql/results/jdbc/internal/JdbcValuesResultSetImpl.java",
                "startLine": 23,
                "endLine": 28,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "@Override\n\tpublic final void finishUp(SharedSessionContractImplementor session) {\n\t\tif ( queryCachePutManager != null ) {\n\t\t\tqueryCachePutManager.finishUp( session );\n\t\t}\n\t\tresultSetAccess.release();\n\t}",
        "filePathBefore": "hibernate-core/src/main/java/org/hibernate/sql/results/jdbc/internal/JdbcValuesResultSetImpl.java",
        "isPureRefactoring": true,
        "commitId": "ba05533a036e73ac119169392b0da49273dc2e5b",
        "packageNameBefore": "org.hibernate.sql.results.jdbc.internal",
        "classNameBefore": "org.hibernate.sql.results.jdbc.internal.JdbcValuesResultSetImpl",
        "methodNameBefore": "org.hibernate.sql.results.jdbc.internal.JdbcValuesResultSetImpl#finishUp",
        "invokedMethod": "methodSignature: org.hibernate.sql.results.jdbc.spi.JdbcValues#finishUp\n methodBody: void finishUp(SharedSessionContractImplementor session);\nmethodSignature: org.hibernate.sql.results.jdbc.internal.ResultSetAccess#release\n methodBody: void release();\nmethodSignature: org.hibernate.sql.results.caching.QueryCachePutManager#finishUp\n methodBody: void finishUp(SharedSessionContractImplementor session);\nmethodSignature: org.hibernate.sql.results.jdbc.internal.JdbcValuesCacheHit#finishUp\n methodBody: public void finishUp(SharedSessionContractImplementor session) {\ncachedResults=null;\n}\nmethodSignature: org.hibernate.sql.results.jdbc.internal.DeferredResultSetAccess#release\n methodBody: public void release() {\nfinal LogicalConnectionImplementor logicalConnection=getPersistenceContext().getJdbcCoordinator().getLogicalConnection();\nif(resultSet != null){logicalConnection.getResourceRegistry().release(resultSet,preparedStatement);\nresultSet=null;\n}if(preparedStatement != null){logicalConnection.getResourceRegistry().release(preparedStatement);\npreparedStatement=null;\n}logicalConnection.afterStatement();\n}\nmethodSignature: org.hibernate.sql.results.jdbc.internal.JdbcValuesResultSetImpl#finishUp\n methodBody: public final void finishUp(SharedSessionContractImplementor session) {\nif(queryCachePutManager != null){queryCachePutManager.finishUp(session);\n}resultSetAccess.release();\n}\nmethodSignature: org.hibernate.sql.results.caching.internal.QueryCachePutManagerEnabledImpl#finishUp\n methodBody: public void finishUp(SharedSessionContractImplementor session) {\nfinal boolean put=queryCache.put(queryKey,dataToCache,session);\nif(put && statistics.isStatisticsEnabled()){statistics.queryCachePut(queryIdentifier,queryCache.getRegion().getName());\n}}",
        "classSignatureBefore": "public class JdbcValuesResultSetImpl extends AbstractJdbcValues ",
        "methodNameBeforeSet": [
            "org.hibernate.sql.results.jdbc.internal.JdbcValuesResultSetImpl#finishUp"
        ],
        "classNameBeforeSet": [
            "org.hibernate.sql.results.jdbc.internal.JdbcValuesResultSetImpl"
        ],
        "classSignatureBeforeSet": [
            "public class JdbcValuesResultSetImpl extends AbstractJdbcValues "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later\n * See the lgpl.txt file in the root directory or http://www.gnu.org/licenses/lgpl-2.1.html\n */\npackage org.hibernate.sql.results.jdbc.internal;\n\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.Arrays;\nimport java.util.BitSet;\n\nimport org.hibernate.JDBCException;\nimport org.hibernate.QueryTimeoutException;\nimport org.hibernate.cache.spi.QueryKey;\nimport org.hibernate.cache.spi.QueryResultsCache;\nimport org.hibernate.engine.spi.SessionFactoryImplementor;\nimport org.hibernate.engine.spi.SharedSessionContractImplementor;\nimport org.hibernate.exception.DataException;\nimport org.hibernate.exception.LockTimeoutException;\nimport org.hibernate.query.spi.QueryOptions;\nimport org.hibernate.sql.ast.spi.SqlSelection;\nimport org.hibernate.sql.exec.ExecutionException;\nimport org.hibernate.sql.exec.spi.ExecutionContext;\nimport org.hibernate.sql.results.caching.QueryCachePutManager;\nimport org.hibernate.sql.results.caching.internal.QueryCachePutManagerEnabledImpl;\nimport org.hibernate.sql.results.graph.DomainResult;\nimport org.hibernate.sql.results.jdbc.spi.JdbcValuesMapping;\nimport org.hibernate.sql.results.jdbc.spi.JdbcValuesMetadata;\nimport org.hibernate.sql.results.jdbc.spi.RowProcessingState;\n\n/**\n * {@link AbstractJdbcValues} implementation for a JDBC {@link ResultSet} as the source\n *\n * @author Steve Ebersole\n */\npublic class JdbcValuesResultSetImpl extends AbstractJdbcValues {\n\n\tprivate final QueryCachePutManager queryCachePutManager;\n\tprivate final ResultSetAccess resultSetAccess;\n\tprivate final JdbcValuesMapping valuesMapping;\n\tprivate final ExecutionContext executionContext;\n\tprivate final boolean usesFollowOnLocking;\n\n\tprivate final SqlSelection[] sqlSelections;\n\tprivate final BitSet initializedIndexes;\n\tprivate final Object[] currentRowJdbcValues;\n\tprivate final int[] valueIndexesToCacheIndexes;\n\t// Is only meaningful if valueIndexesToCacheIndexes is not null\n\t// Contains the size of the row to cache, or if the value is negative,\n\t// represents the inverted index of the single value to cache\n\tprivate final int rowToCacheSize;\n\n\tpublic JdbcValuesResultSetImpl(\n\t\t\tResultSetAccess resultSetAccess,\n\t\t\tQueryKey queryCacheKey,\n\t\t\tString queryIdentifier,\n\t\t\tQueryOptions queryOptions,\n\t\t\tboolean usesFollowOnLocking,\n\t\t\tJdbcValuesMapping valuesMapping,\n\t\t\tJdbcValuesMetadata metadataForCache,\n\t\t\tExecutionContext executionContext) {\n\t\tthis.queryCachePutManager = resolveQueryCachePutManager(\n\t\t\t\texecutionContext,\n\t\t\t\tqueryOptions,\n\t\t\t\tqueryCacheKey,\n\t\t\t\tqueryIdentifier,\n\t\t\t\tmetadataForCache\n\t\t);\n\t\tthis.resultSetAccess = resultSetAccess;\n\t\tthis.valuesMapping = valuesMapping;\n\t\tthis.executionContext = executionContext;\n\t\tthis.usesFollowOnLocking = usesFollowOnLocking;\n\n\t\tfinal int rowSize = valuesMapping.getRowSize();\n\t\tthis.sqlSelections = new SqlSelection[rowSize];\n\t\tfor ( SqlSelection selection : valuesMapping.getSqlSelections() ) {\n\t\t\tthis.sqlSelections[selection.getValuesArrayPosition()] = selection;\n\t\t}\n\t\tthis.initializedIndexes = new BitSet( rowSize );\n\t\tthis.currentRowJdbcValues = new Object[rowSize];\n\t\tif ( queryCachePutManager == null ) {\n\t\t\tthis.valueIndexesToCacheIndexes = null;\n\t\t\tthis.rowToCacheSize = -1;\n\t\t}\n\t\telse {\n\t\t\tfinal BitSet valueIndexesToCache = new BitSet( rowSize );\n\t\t\tfor ( DomainResult<?> domainResult : valuesMapping.getDomainResults() ) {\n\t\t\t\tdomainResult.collectValueIndexesToCache( valueIndexesToCache );\n\t\t\t}\n\t\t\tif ( valueIndexesToCache.nextClearBit( 0 ) == -1 ) {\n\t\t\t\tthis.valueIndexesToCacheIndexes = null;\n\t\t\t\tthis.rowToCacheSize = -1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfinal int[] valueIndexesToCacheIndexes = new int[rowSize];\n\t\t\t\tint cacheIndex = 0;\n\t\t\t\tfor ( int i = 0; i < valueIndexesToCacheIndexes.length; i++ ) {\n\t\t\t\t\tif ( valueIndexesToCache.get( i ) ) {\n\t\t\t\t\t\tvalueIndexesToCacheIndexes[i] = cacheIndex++;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tvalueIndexesToCacheIndexes[i] = -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tthis.valueIndexesToCacheIndexes = valueIndexesToCacheIndexes;\n\t\t\t\tif ( cacheIndex == 1 ) {\n\t\t\t\t\t// Special case. Set the rowToCacheSize to the inverted index of the single element to cache\n\t\t\t\t\tfor ( int i = 0; i < valueIndexesToCacheIndexes.length; i++ ) {\n\t\t\t\t\t\tif ( valueIndexesToCacheIndexes[i] != -1 ) {\n\t\t\t\t\t\t\tcacheIndex = -i;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthis.rowToCacheSize = cacheIndex;\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate static QueryCachePutManager resolveQueryCachePutManager(\n\t\t\tExecutionContext executionContext,\n\t\t\tQueryOptions queryOptions,\n\t\t\tQueryKey queryCacheKey,\n\t\t\tString queryIdentifier,\n\t\t\tJdbcValuesMetadata metadataForCache) {\n\t\tif ( queryCacheKey != null ) {\n\t\t\tfinal SessionFactoryImplementor factory = executionContext.getSession().getFactory();\n\t\t\tfinal QueryResultsCache queryCache = factory.getCache()\n\t\t\t\t\t.getQueryResultsCache( queryOptions.getResultCacheRegionName() );\n\t\t\treturn new QueryCachePutManagerEnabledImpl(\n\t\t\t\t\tqueryCache,\n\t\t\t\t\tfactory.getStatistics(),\n\t\t\t\t\tqueryCacheKey,\n\t\t\t\t\tqueryIdentifier,\n\t\t\t\t\tmetadataForCache\n\t\t\t);\n\t\t}\n\t\telse {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t@Override\n\tprotected final boolean processNext(RowProcessingState rowProcessingState) {\n\t\treturn advance( advanceNext() );\n\t}\n\n\t@Override\n\tprotected boolean processPrevious(RowProcessingState rowProcessingState) {\n\t\treturn advance( advancePrevious() );\n\t}\n\n\t@Override\n\tprotected boolean processScroll(int numberOfRows, RowProcessingState rowProcessingState) {\n\t\treturn advance( scrollRows( numberOfRows ) );\n\t}\n\n\tprivate boolean scrollRows(final int numberOfRows) {\n\t\ttry {\n\t\t\treturn resultSetAccess.getResultSet().relative( numberOfRows );\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow makeExecutionException( \"Error advancing (scroll) ResultSet position\", e );\n\t\t}\n\t}\n\n\t@Override\n\tpublic int getPosition() {\n\t\ttry {\n\t\t\treturn resultSetAccess.getResultSet().getRow() - 1;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow makeExecutionException( \"Error calling ResultSet#getRow\", e );\n\t\t}\n\t}\n\n\t@Override\n\tprotected boolean processPosition(int position, RowProcessingState rowProcessingState) {\n\t\treturn advance( advanceToPosition( position ) );\n\t}\n\n\tprivate boolean advanceToPosition(final int position) {\n\t\ttry {\n\t\t\treturn resultSetAccess.getResultSet().absolute( position );\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow makeExecutionException( \"Error advancing (scroll) ResultSet position\", e );\n\t\t}\n\t}\n\n\t@Override\n\tpublic boolean isBeforeFirst(RowProcessingState rowProcessingState) {\n\t\ttry {\n\t\t\treturn resultSetAccess.getResultSet().isBeforeFirst();\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow makeExecutionException( \"Error calling ResultSet#isBeforeFirst()\", e );\n\t\t}\n\t}\n\n\t@Override\n\tpublic void beforeFirst(RowProcessingState rowProcessingState) {\n\t\ttry {\n\t\t\tresultSetAccess.getResultSet().beforeFirst();\n\t\t\tArrays.fill( currentRowJdbcValues, null );\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow makeExecutionException( \"Error calling ResultSet#beforeFirst()\", e );\n\t\t}\n\t}\n\n\t@Override\n\tpublic boolean isFirst(RowProcessingState rowProcessingState) {\n\t\ttry {\n\t\t\treturn resultSetAccess.getResultSet().isFirst();\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow makeExecutionException( \"Error calling ResultSet#isFirst()\", e );\n\t\t}\n\t}\n\n\t@Override\n\tpublic boolean first(RowProcessingState rowProcessingState) {\n\t\treturn advance( advanceToFirst() );\n\t}\n\n\t@Override\n\tpublic boolean isAfterLast(RowProcessingState rowProcessingState) {\n\t\ttry {\n\t\t\treturn resultSetAccess.getResultSet().isAfterLast();\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow makeExecutionException( \"Error calling ResultSet#isAfterLast()\", e );\n\t\t}\n\t}\n\n\t@Override\n\tpublic void afterLast(RowProcessingState rowProcessingState) {\n\t\ttry {\n\t\t\tresultSetAccess.getResultSet().afterLast();\n\t\t\tArrays.fill( currentRowJdbcValues, null );\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow makeExecutionException( \"Error calling ResultSet#afterLast()\", e );\n\t\t}\n\t}\n\n\t@Override\n\tpublic boolean isLast(RowProcessingState rowProcessingState) {\n\t\ttry {\n\t\t\treturn resultSetAccess.getResultSet().isLast();\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow makeExecutionException( \"Error calling ResultSet#isLast()\", e );\n\t\t}\n\t}\n\n\t@Override\n\tpublic boolean last(RowProcessingState rowProcessingState) {\n\t\treturn advance( advanceToLast() );\n\t}\n\n\tprivate boolean advanceNext() {\n\t\ttry {\n\t\t\treturn resultSetAccess.getResultSet().next();\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow makeExecutionException( \"Error advancing (next) ResultSet position\", e );\n\t\t}\n\t}\n\n\tprivate boolean advanceToLast() {\n\t\ttry {\n\t\t\treturn resultSetAccess.getResultSet().last();\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow makeExecutionException( \"Error advancing (last) ResultSet position\", e );\n\t\t}\n\t}\n\n\tprivate boolean advanceToFirst() {\n\t\ttry {\n\t\t\treturn resultSetAccess.getResultSet().first();\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow makeExecutionException( \"Error advancing (first) ResultSet position\", e );\n\t\t}\n\t}\n\n\tprivate boolean advancePrevious() {\n\t\ttry {\n\t\t\treturn resultSetAccess.getResultSet().previous();\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow makeExecutionException( \"Error advancing (previous) ResultSet position\", e );\n\t\t}\n\t}\n\n\tprivate boolean advance(final boolean hasResult) {\n\t\tif ( ! hasResult ) {\n\t\t\treturn false;\n\t\t}\n\n\t\treadCurrentRowValues();\n\t\treturn true;\n\t}\n\n\tprivate ExecutionException makeExecutionException(String message, SQLException cause) {\n\t\tfinal JDBCException jdbcException = executionContext.getSession().getJdbcServices().getSqlExceptionHelper().convert(\n\t\t\t\tcause,\n\t\t\t\tmessage\n\t\t);\n\t\tif ( jdbcException instanceof QueryTimeoutException\n\t\t\t\t|| jdbcException instanceof DataException\n\t\t\t\t|| jdbcException instanceof LockTimeoutException ) {\n\t\t\t// So far, the exception helper threw these exceptions more or less directly during conversion,\n\t\t\t// so to retain the same behavior, we throw that directly now as well instead of wrapping it\n\t\t\tthrow jdbcException;\n\t\t}\n\t\treturn new ExecutionException( message + \" [\" + cause.getMessage() + \"]\", jdbcException );\n\t}\n\n\tprivate void readCurrentRowValues() {\n\t\tinitializedIndexes.clear();\n\t}\n\n\t@Override\n\tpublic final void finishUp(SharedSessionContractImplementor session) {\n\t\tif ( queryCachePutManager != null ) {\n\t\t\tqueryCachePutManager.finishUp( session );\n\t\t}\n\t\tresultSetAccess.release();\n\t}\n\n\t@Override\n\tpublic JdbcValuesMapping getValuesMapping() {\n\t\treturn valuesMapping;\n\t}\n\n\t@Override\n\tpublic boolean usesFollowOnLocking() {\n\t\treturn usesFollowOnLocking;\n\t}\n\n\t@Override\n\tpublic void finishRowProcessing(RowProcessingState rowProcessingState, boolean wasAdded) {\n\t\tif ( queryCachePutManager != null ) {\n\t\t\tfinal Object objectToCache;\n\t\t\tif ( valueIndexesToCacheIndexes == null ) {\n\t\t\t\tobjectToCache = Arrays.copyOf( currentRowJdbcValues, currentRowJdbcValues.length );\n\t\t\t}\n\t\t\telse if ( rowToCacheSize < 1 ) {\n\t\t\t\tif ( !wasAdded ) {\n\t\t\t\t\t// skip adding duplicate objects\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tobjectToCache = currentRowJdbcValues[-rowToCacheSize];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfinal Object[] rowToCache = new Object[rowToCacheSize];\n\t\t\t\tfor ( int i = 0; i < currentRowJdbcValues.length; i++ ) {\n\t\t\t\t\tfinal int cacheIndex = valueIndexesToCacheIndexes[i];\n\t\t\t\t\tif ( cacheIndex != -1 ) {\n\t\t\t\t\t\trowToCache[cacheIndex] = initializedIndexes.get( i ) ? currentRowJdbcValues[i] : null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tobjectToCache = rowToCache;\n\t\t\t}\n\t\t\tqueryCachePutManager.registerJdbcRow( objectToCache );\n\t\t}\n\t}\n\n\t@Override\n\tpublic Object getCurrentRowValue(int valueIndex) {\n\t\tif ( !initializedIndexes.get( valueIndex ) ) {\n\t\t\tinitializedIndexes.set( valueIndex );\n\t\t\tfinal SqlSelection sqlSelection = sqlSelections[valueIndex];\n\t\t\ttry {\n\t\t\t\tcurrentRowJdbcValues[valueIndex] = sqlSelection.getJdbcValueExtractor().extract(\n\t\t\t\t\t\tresultSetAccess.getResultSet(),\n\t\t\t\t\t\tsqlSelection.getJdbcResultSetIndex(),\n\t\t\t\t\t\texecutionContext.getSession()\n\t\t\t\t);\n\t\t\t}\n\t\t\tcatch ( SQLException e ) {\n\t\t\t\t// do not want to wrap in ExecutionException here\n\t\t\t\tthrow executionContext.getSession().getJdbcServices().getSqlExceptionHelper().convert(\n\t\t\t\t\t\te,\n\t\t\t\t\t\t\"Could not extract column [\" + sqlSelection.getJdbcResultSetIndex() + \"] from JDBC ResultSet\"\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\treturn currentRowJdbcValues[valueIndex];\n\t}\n\n\t@Override\n\tpublic void setFetchSize(int fetchSize) {\n\t\ttry {\n\t\t\tresultSetAccess.getResultSet().setFetchSize( fetchSize );\n\t\t}\n\t\tcatch ( SQLException e ) {\n\t\t\tthrow makeExecutionException( \"Error calling ResultSet.setFetchSize()\", e );\n\t\t}\n\t}\n}\n",
        "filePathAfter": "hibernate-core/src/main/java/org/hibernate/sql/results/jdbc/internal/JdbcValuesResultSetImpl.java",
        "sourceCodeAfterForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later\n * See the lgpl.txt file in the root directory or http://www.gnu.org/licenses/lgpl-2.1.html\n */\npackage org.hibernate.sql.results.jdbc.internal;\n\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.Arrays;\nimport java.util.BitSet;\n\nimport org.hibernate.JDBCException;\nimport org.hibernate.QueryTimeoutException;\nimport org.hibernate.cache.spi.QueryKey;\nimport org.hibernate.cache.spi.QueryResultsCache;\nimport org.hibernate.engine.spi.SessionFactoryImplementor;\nimport org.hibernate.engine.spi.SharedSessionContractImplementor;\nimport org.hibernate.exception.DataException;\nimport org.hibernate.exception.LockTimeoutException;\nimport org.hibernate.query.spi.Limit;\nimport org.hibernate.query.spi.QueryOptions;\nimport org.hibernate.sql.ast.spi.SqlSelection;\nimport org.hibernate.sql.exec.ExecutionException;\nimport org.hibernate.sql.exec.spi.ExecutionContext;\nimport org.hibernate.sql.results.caching.QueryCachePutManager;\nimport org.hibernate.sql.results.caching.internal.QueryCachePutManagerEnabledImpl;\nimport org.hibernate.sql.results.graph.DomainResult;\nimport org.hibernate.sql.results.jdbc.spi.JdbcValuesMapping;\nimport org.hibernate.sql.results.jdbc.spi.JdbcValuesMetadata;\nimport org.hibernate.sql.results.jdbc.spi.RowProcessingState;\n\n/**\n * {@link AbstractJdbcValues} implementation for a JDBC {@link ResultSet} as the source\n *\n * @author Steve Ebersole\n */\npublic class JdbcValuesResultSetImpl extends AbstractJdbcValues {\n\n\tprivate final QueryCachePutManager queryCachePutManager;\n\tprivate final ResultSetAccess resultSetAccess;\n\tprivate final JdbcValuesMapping valuesMapping;\n\tprivate final ExecutionContext executionContext;\n\tprivate final boolean usesFollowOnLocking;\n\tprivate final int resultCountEstimate;\n\n\tprivate final SqlSelection[] sqlSelections;\n\tprivate final BitSet initializedIndexes;\n\tprivate final Object[] currentRowJdbcValues;\n\tprivate final int[] valueIndexesToCacheIndexes;\n\t// Is only meaningful if valueIndexesToCacheIndexes is not null\n\t// Contains the size of the row to cache, or if the value is negative,\n\t// represents the inverted index of the single value to cache\n\tprivate final int rowToCacheSize;\n\tprivate int resultCount;\n\n\tpublic JdbcValuesResultSetImpl(\n\t\t\tResultSetAccess resultSetAccess,\n\t\t\tQueryKey queryCacheKey,\n\t\t\tString queryIdentifier,\n\t\t\tQueryOptions queryOptions,\n\t\t\tboolean usesFollowOnLocking,\n\t\t\tJdbcValuesMapping valuesMapping,\n\t\t\tJdbcValuesMetadata metadataForCache,\n\t\t\tExecutionContext executionContext) {\n\t\tthis.queryCachePutManager = resolveQueryCachePutManager(\n\t\t\t\texecutionContext,\n\t\t\t\tqueryOptions,\n\t\t\t\tqueryCacheKey,\n\t\t\t\tqueryIdentifier,\n\t\t\t\tmetadataForCache\n\t\t);\n\t\tthis.resultSetAccess = resultSetAccess;\n\t\tthis.valuesMapping = valuesMapping;\n\t\tthis.executionContext = executionContext;\n\t\tthis.usesFollowOnLocking = usesFollowOnLocking;\n\t\tthis.resultCountEstimate = determineResultCountEstimate( resultSetAccess, queryOptions, executionContext );\n\n\t\tfinal int rowSize = valuesMapping.getRowSize();\n\t\tthis.sqlSelections = new SqlSelection[rowSize];\n\t\tfor ( SqlSelection selection : valuesMapping.getSqlSelections() ) {\n\t\t\tthis.sqlSelections[selection.getValuesArrayPosition()] = selection;\n\t\t}\n\t\tthis.initializedIndexes = new BitSet( rowSize );\n\t\tthis.currentRowJdbcValues = new Object[rowSize];\n\t\tif ( queryCachePutManager == null ) {\n\t\t\tthis.valueIndexesToCacheIndexes = null;\n\t\t\tthis.rowToCacheSize = -1;\n\t\t}\n\t\telse {\n\t\t\tfinal BitSet valueIndexesToCache = new BitSet( rowSize );\n\t\t\tfor ( DomainResult<?> domainResult : valuesMapping.getDomainResults() ) {\n\t\t\t\tdomainResult.collectValueIndexesToCache( valueIndexesToCache );\n\t\t\t}\n\t\t\tif ( valueIndexesToCache.nextClearBit( 0 ) == -1 ) {\n\t\t\t\tthis.valueIndexesToCacheIndexes = null;\n\t\t\t\tthis.rowToCacheSize = -1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfinal int[] valueIndexesToCacheIndexes = new int[rowSize];\n\t\t\t\tint cacheIndex = 0;\n\t\t\t\tfor ( int i = 0; i < valueIndexesToCacheIndexes.length; i++ ) {\n\t\t\t\t\tif ( valueIndexesToCache.get( i ) ) {\n\t\t\t\t\t\tvalueIndexesToCacheIndexes[i] = cacheIndex++;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tvalueIndexesToCacheIndexes[i] = -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tthis.valueIndexesToCacheIndexes = valueIndexesToCacheIndexes;\n\t\t\t\tif ( cacheIndex == 1 ) {\n\t\t\t\t\t// Special case. Set the rowToCacheSize to the inverted index of the single element to cache\n\t\t\t\t\tfor ( int i = 0; i < valueIndexesToCacheIndexes.length; i++ ) {\n\t\t\t\t\t\tif ( valueIndexesToCacheIndexes[i] != -1 ) {\n\t\t\t\t\t\t\tcacheIndex = -i;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthis.rowToCacheSize = cacheIndex;\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate int determineResultCountEstimate(\n\t\t\tResultSetAccess resultSetAccess,\n\t\t\tQueryOptions queryOptions,\n\t\t\tExecutionContext executionContext) {\n\t\tfinal Limit limit = queryOptions.getLimit();\n\t\tif ( limit != null && limit.getMaxRows() != null ) {\n\t\t\treturn limit.getMaxRows();\n\t\t}\n\n\t\tfinal int resultCountEstimate = resultSetAccess.getResultCountEstimate();\n\t\tif ( resultCountEstimate > 0 ) {\n\t\t\treturn resultCountEstimate;\n\t\t}\n\t\treturn -1;\n\t}\n\n\tprivate static QueryCachePutManager resolveQueryCachePutManager(\n\t\t\tExecutionContext executionContext,\n\t\t\tQueryOptions queryOptions,\n\t\t\tQueryKey queryCacheKey,\n\t\t\tString queryIdentifier,\n\t\t\tJdbcValuesMetadata metadataForCache) {\n\t\tif ( queryCacheKey != null ) {\n\t\t\tfinal SessionFactoryImplementor factory = executionContext.getSession().getFactory();\n\t\t\tfinal QueryResultsCache queryCache = factory.getCache()\n\t\t\t\t\t.getQueryResultsCache( queryOptions.getResultCacheRegionName() );\n\t\t\treturn new QueryCachePutManagerEnabledImpl(\n\t\t\t\t\tqueryCache,\n\t\t\t\t\tfactory.getStatistics(),\n\t\t\t\t\tqueryCacheKey,\n\t\t\t\t\tqueryIdentifier,\n\t\t\t\t\tmetadataForCache\n\t\t\t);\n\t\t}\n\t\telse {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t@Override\n\tprotected final boolean processNext(RowProcessingState rowProcessingState) {\n\t\treturn advance( advanceNext() );\n\t}\n\n\t@Override\n\tprotected boolean processPrevious(RowProcessingState rowProcessingState) {\n\t\treturn advance( advancePrevious() );\n\t}\n\n\t@Override\n\tprotected boolean processScroll(int numberOfRows, RowProcessingState rowProcessingState) {\n\t\treturn advance( scrollRows( numberOfRows ) );\n\t}\n\n\tprivate boolean scrollRows(final int numberOfRows) {\n\t\ttry {\n\t\t\treturn resultSetAccess.getResultSet().relative( numberOfRows );\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow makeExecutionException( \"Error advancing (scroll) ResultSet position\", e );\n\t\t}\n\t}\n\n\t@Override\n\tpublic int getPosition() {\n\t\ttry {\n\t\t\treturn resultSetAccess.getResultSet().getRow() - 1;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow makeExecutionException( \"Error calling ResultSet#getRow\", e );\n\t\t}\n\t}\n\n\t@Override\n\tprotected boolean processPosition(int position, RowProcessingState rowProcessingState) {\n\t\treturn advance( advanceToPosition( position ) );\n\t}\n\n\tprivate boolean advanceToPosition(final int position) {\n\t\ttry {\n\t\t\treturn resultSetAccess.getResultSet().absolute( position );\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow makeExecutionException( \"Error advancing (scroll) ResultSet position\", e );\n\t\t}\n\t}\n\n\t@Override\n\tpublic boolean isBeforeFirst(RowProcessingState rowProcessingState) {\n\t\ttry {\n\t\t\treturn resultSetAccess.getResultSet().isBeforeFirst();\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow makeExecutionException( \"Error calling ResultSet#isBeforeFirst()\", e );\n\t\t}\n\t}\n\n\t@Override\n\tpublic void beforeFirst(RowProcessingState rowProcessingState) {\n\t\ttry {\n\t\t\tresultSetAccess.getResultSet().beforeFirst();\n\t\t\tArrays.fill( currentRowJdbcValues, null );\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow makeExecutionException( \"Error calling ResultSet#beforeFirst()\", e );\n\t\t}\n\t}\n\n\t@Override\n\tpublic boolean isFirst(RowProcessingState rowProcessingState) {\n\t\ttry {\n\t\t\treturn resultSetAccess.getResultSet().isFirst();\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow makeExecutionException( \"Error calling ResultSet#isFirst()\", e );\n\t\t}\n\t}\n\n\t@Override\n\tpublic boolean first(RowProcessingState rowProcessingState) {\n\t\treturn advance( advanceToFirst() );\n\t}\n\n\t@Override\n\tpublic boolean isAfterLast(RowProcessingState rowProcessingState) {\n\t\ttry {\n\t\t\treturn resultSetAccess.getResultSet().isAfterLast();\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow makeExecutionException( \"Error calling ResultSet#isAfterLast()\", e );\n\t\t}\n\t}\n\n\t@Override\n\tpublic void afterLast(RowProcessingState rowProcessingState) {\n\t\ttry {\n\t\t\tresultSetAccess.getResultSet().afterLast();\n\t\t\tArrays.fill( currentRowJdbcValues, null );\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow makeExecutionException( \"Error calling ResultSet#afterLast()\", e );\n\t\t}\n\t}\n\n\t@Override\n\tpublic boolean isLast(RowProcessingState rowProcessingState) {\n\t\ttry {\n\t\t\treturn resultSetAccess.getResultSet().isLast();\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow makeExecutionException( \"Error calling ResultSet#isLast()\", e );\n\t\t}\n\t}\n\n\t@Override\n\tpublic boolean last(RowProcessingState rowProcessingState) {\n\t\treturn advance( advanceToLast() );\n\t}\n\n\tprivate boolean advanceNext() {\n\t\ttry {\n\t\t\treturn resultSetAccess.getResultSet().next();\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow makeExecutionException( \"Error advancing (next) ResultSet position\", e );\n\t\t}\n\t}\n\n\tprivate boolean advanceToLast() {\n\t\ttry {\n\t\t\treturn resultSetAccess.getResultSet().last();\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow makeExecutionException( \"Error advancing (last) ResultSet position\", e );\n\t\t}\n\t}\n\n\tprivate boolean advanceToFirst() {\n\t\ttry {\n\t\t\treturn resultSetAccess.getResultSet().first();\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow makeExecutionException( \"Error advancing (first) ResultSet position\", e );\n\t\t}\n\t}\n\n\tprivate boolean advancePrevious() {\n\t\ttry {\n\t\t\treturn resultSetAccess.getResultSet().previous();\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow makeExecutionException( \"Error advancing (previous) ResultSet position\", e );\n\t\t}\n\t}\n\n\tprivate boolean advance(final boolean hasResult) {\n\t\tif ( ! hasResult ) {\n\t\t\treturn false;\n\t\t}\n\n\t\treadCurrentRowValues();\n\t\treturn true;\n\t}\n\n\tprivate ExecutionException makeExecutionException(String message, SQLException cause) {\n\t\tfinal JDBCException jdbcException = executionContext.getSession().getJdbcServices().getSqlExceptionHelper().convert(\n\t\t\t\tcause,\n\t\t\t\tmessage\n\t\t);\n\t\tif ( jdbcException instanceof QueryTimeoutException\n\t\t\t\t|| jdbcException instanceof DataException\n\t\t\t\t|| jdbcException instanceof LockTimeoutException ) {\n\t\t\t// So far, the exception helper threw these exceptions more or less directly during conversion,\n\t\t\t// so to retain the same behavior, we throw that directly now as well instead of wrapping it\n\t\t\tthrow jdbcException;\n\t\t}\n\t\treturn new ExecutionException( message + \" [\" + cause.getMessage() + \"]\", jdbcException );\n\t}\n\n\tprivate void readCurrentRowValues() {\n\t\tinitializedIndexes.clear();\n\t}\n\n\t@Override\n\tpublic final void finishUp(SharedSessionContractImplementor session) {\n\t\tif ( queryCachePutManager != null ) {\n\t\t\tqueryCachePutManager.finishUp( resultCount, session );\n\t\t}\n\t\tresultSetAccess.release();\n\t}\n\n\t@Override\n\tpublic JdbcValuesMapping getValuesMapping() {\n\t\treturn valuesMapping;\n\t}\n\n\t@Override\n\tpublic boolean usesFollowOnLocking() {\n\t\treturn usesFollowOnLocking;\n\t}\n\n\t@Override\n\tpublic void finishRowProcessing(RowProcessingState rowProcessingState, boolean wasAdded) {\n\t\tif ( queryCachePutManager != null ) {\n\t\t\tif ( wasAdded ) {\n\t\t\t\tresultCount++;\n\t\t\t}\n\t\t\tfinal Object objectToCache;\n\t\t\tif ( valueIndexesToCacheIndexes == null ) {\n\t\t\t\tobjectToCache = Arrays.copyOf( currentRowJdbcValues, currentRowJdbcValues.length );\n\t\t\t}\n\t\t\telse if ( rowToCacheSize < 1 ) {\n\t\t\t\tif ( !wasAdded ) {\n\t\t\t\t\t// skip adding duplicate objects\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tobjectToCache = currentRowJdbcValues[-rowToCacheSize];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfinal Object[] rowToCache = new Object[rowToCacheSize];\n\t\t\t\tfor ( int i = 0; i < currentRowJdbcValues.length; i++ ) {\n\t\t\t\t\tfinal int cacheIndex = valueIndexesToCacheIndexes[i];\n\t\t\t\t\tif ( cacheIndex != -1 ) {\n\t\t\t\t\t\trowToCache[cacheIndex] = initializedIndexes.get( i ) ? currentRowJdbcValues[i] : null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tobjectToCache = rowToCache;\n\t\t\t}\n\t\t\tqueryCachePutManager.registerJdbcRow( objectToCache );\n\t\t}\n\t}\n\n\t@Override\n\tpublic Object getCurrentRowValue(int valueIndex) {\n\t\tif ( !initializedIndexes.get( valueIndex ) ) {\n\t\t\tinitializedIndexes.set( valueIndex );\n\t\t\tfinal SqlSelection sqlSelection = sqlSelections[valueIndex];\n\t\t\ttry {\n\t\t\t\tcurrentRowJdbcValues[valueIndex] = sqlSelection.getJdbcValueExtractor().extract(\n\t\t\t\t\t\tresultSetAccess.getResultSet(),\n\t\t\t\t\t\tsqlSelection.getJdbcResultSetIndex(),\n\t\t\t\t\t\texecutionContext.getSession()\n\t\t\t\t);\n\t\t\t}\n\t\t\tcatch ( SQLException e ) {\n\t\t\t\t// do not want to wrap in ExecutionException here\n\t\t\t\tthrow executionContext.getSession().getJdbcServices().getSqlExceptionHelper().convert(\n\t\t\t\t\t\te,\n\t\t\t\t\t\t\"Could not extract column [\" + sqlSelection.getJdbcResultSetIndex() + \"] from JDBC ResultSet\"\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\treturn currentRowJdbcValues[valueIndex];\n\t}\n\n\t@Override\n\tpublic void setFetchSize(int fetchSize) {\n\t\ttry {\n\t\t\tresultSetAccess.getResultSet().setFetchSize( fetchSize );\n\t\t}\n\t\tcatch ( SQLException e ) {\n\t\t\tthrow makeExecutionException( \"Error calling ResultSet.setFetchSize()\", e );\n\t\t}\n\t}\n\n\t@Override\n\tpublic int getResultCountEstimate() {\n\t\treturn resultCountEstimate;\n\t}\n}\n",
        "diffSourceCodeSet": [
            "import org.hibernate.query.spi.QueryOptions;\nimport org.hibernate.sql.ast.spi.SqlSelection;\nimport org.hibernate.sql.exec.ExecutionException;\nimport org.hibernate.sql.exec.spi.ExecutionContext;\nimport org.hibernate.sql.results.caching.QueryCachePutManager;\nimport org.hibernate.sql.results.caching.internal.QueryCachePutManagerEnabledImpl;"
        ],
        "invokedMethodSet": [
            "methodSignature: org.hibernate.sql.results.jdbc.spi.JdbcValues#finishUp\n methodBody: void finishUp(SharedSessionContractImplementor session);",
            "methodSignature: org.hibernate.sql.results.jdbc.internal.ResultSetAccess#release\n methodBody: void release();",
            "methodSignature: org.hibernate.sql.results.caching.QueryCachePutManager#finishUp\n methodBody: void finishUp(SharedSessionContractImplementor session);",
            "methodSignature: org.hibernate.sql.results.jdbc.internal.JdbcValuesCacheHit#finishUp\n methodBody: public void finishUp(SharedSessionContractImplementor session) {\ncachedResults=null;\n}",
            "methodSignature: org.hibernate.sql.results.jdbc.internal.DeferredResultSetAccess#release\n methodBody: public void release() {\nfinal LogicalConnectionImplementor logicalConnection=getPersistenceContext().getJdbcCoordinator().getLogicalConnection();\nif(resultSet != null){logicalConnection.getResourceRegistry().release(resultSet,preparedStatement);\nresultSet=null;\n}if(preparedStatement != null){logicalConnection.getResourceRegistry().release(preparedStatement);\npreparedStatement=null;\n}logicalConnection.afterStatement();\n}",
            "methodSignature: org.hibernate.sql.results.jdbc.internal.JdbcValuesResultSetImpl#finishUp\n methodBody: public final void finishUp(SharedSessionContractImplementor session) {\nif(queryCachePutManager != null){queryCachePutManager.finishUp(session);\n}resultSetAccess.release();\n}",
            "methodSignature: org.hibernate.sql.results.caching.internal.QueryCachePutManagerEnabledImpl#finishUp\n methodBody: public void finishUp(SharedSessionContractImplementor session) {\nfinal boolean put=queryCache.put(queryKey,dataToCache,session);\nif(put && statistics.isStatisticsEnabled()){statistics.queryCachePut(queryIdentifier,queryCache.getRegion().getName());\n}}"
        ],
        "sourceCodeAfterRefactoring": "@Override\n\tpublic final void finishUp(SharedSessionContractImplementor session) {\n\t\tif ( queryCachePutManager != null ) {\n\t\t\tqueryCachePutManager.finishUp( resultCount, session );\n\t\t}\n\t\tresultSetAccess.release();\n\t}\nimport org.hibernate.query.spi.QueryOptions;\nimport org.hibernate.sql.ast.spi.SqlSelection;\nimport org.hibernate.sql.exec.ExecutionException;\nimport org.hibernate.sql.exec.spi.ExecutionContext;\nimport org.hibernate.sql.results.caching.QueryCachePutManager;\nimport org.hibernate.sql.results.caching.internal.QueryCachePutManagerEnabledImpl;",
        "diffSourceCode": "-   23: import org.hibernate.sql.ast.spi.SqlSelection;\n-   24: import org.hibernate.sql.exec.ExecutionException;\n-   25: import org.hibernate.sql.exec.spi.ExecutionContext;\n-   26: import org.hibernate.sql.results.caching.QueryCachePutManager;\n-   27: import org.hibernate.sql.results.caching.internal.QueryCachePutManagerEnabledImpl;\n-   28: import org.hibernate.sql.results.graph.DomainResult;\n-  330: \t@Override\n-  331: \tpublic final void finishUp(SharedSessionContractImplementor session) {\n-  332: \t\tif ( queryCachePutManager != null ) {\n-  333: \t\t\tqueryCachePutManager.finishUp( session );\n-  334: \t\t}\n-  335: \t\tresultSetAccess.release();\n-  336: \t}\n-  350: \t\tif ( queryCachePutManager != null ) {\n-  351: \t\t\tfinal Object objectToCache;\n-  352: \t\t\tif ( valueIndexesToCacheIndexes == null ) {\n-  353: \t\t\t\tobjectToCache = Arrays.copyOf( currentRowJdbcValues, currentRowJdbcValues.length );\n-  354: \t\t\t}\n-  355: \t\t\telse if ( rowToCacheSize < 1 ) {\n-  356: \t\t\t\tif ( !wasAdded ) {\n+   23: import org.hibernate.query.spi.QueryOptions;\n+   24: import org.hibernate.sql.ast.spi.SqlSelection;\n+   25: import org.hibernate.sql.exec.ExecutionException;\n+   26: import org.hibernate.sql.exec.spi.ExecutionContext;\n+   27: import org.hibernate.sql.results.caching.QueryCachePutManager;\n+   28: import org.hibernate.sql.results.caching.internal.QueryCachePutManagerEnabledImpl;\n+  330: \n+  331: \tprivate ExecutionException makeExecutionException(String message, SQLException cause) {\n+  332: \t\tfinal JDBCException jdbcException = executionContext.getSession().getJdbcServices().getSqlExceptionHelper().convert(\n+  333: \t\t\t\tcause,\n+  334: \t\t\t\tmessage\n+  335: \t\t);\n+  336: \t\tif ( jdbcException instanceof QueryTimeoutException\n+  350: \t@Override\n+  351: \tpublic final void finishUp(SharedSessionContractImplementor session) {\n+  352: \t\tif ( queryCachePutManager != null ) {\n+  353: \t\t\tqueryCachePutManager.finishUp( resultCount, session );\n+  354: \t\t}\n+  355: \t\tresultSetAccess.release();\n+  356: \t}\n",
        "uniqueId": "ba05533a036e73ac119169392b0da49273dc2e5b_330_336_23_28_350_356",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 0,
                "covered": 11
            },
            "BRANCH": {
                "missed": 0,
                "covered": 2
            },
            "LINE": {
                "missed": 0,
                "covered": 4
            },
            "COMPLEXITY": {
                "missed": 0,
                "covered": 2
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 21
    },
    {
        "type": "Extract And Move Method",
        "description": "Extract And Move Method\tpublic getGenerator() : InMemoryGenerator extracted from public testNormalBoundary(scope SessionFactoryScope) : void in class org.hibernate.orm.test.idgen.enhanced.table.BasicTableTest & moved to class org.hibernate.persister.entity.EntityPersister",
        "diffLocations": [
            {
                "filePath": "hibernate-core/src/test/java/org/hibernate/orm/test/idgen/enhanced/table/BasicTableTest.java",
                "startLine": 27,
                "endLine": 49,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/test/java/org/hibernate/orm/test/idgen/enhanced/table/BasicTableTest.java",
                "startLine": 27,
                "endLine": 49,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/test/java/org/hibernate/orm/test/idgen/enhanced/table/BasicTableTest.java",
                "startLine": 461,
                "endLine": 463,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "@Test\n\tpublic void testNormalBoundary(SessionFactoryScope scope) {\n        final EntityPersister persister = scope.getSessionFactory()\n\t\t\t\t.getMappingMetamodel()\n\t\t\t\t.getEntityDescriptor(Entity.class.getName());\n\t\tassertThat( persister.getIdentifierGenerator(), instanceOf( TableGenerator.class ) );\n\n\t\tfinal TableGenerator generator = ( TableGenerator ) persister.getIdentifierGenerator();\n\n\t\tscope.inTransaction(\n\t\t\t\t(s) -> {\n\t\t\t\t\tint count = 5;\n\t\t\t\t\tfor ( int i = 0; i < count; i++ ) {\n\t\t\t\t\t\tfinal Entity entity = new Entity( \"\" + ( i + 1 ) );\n\t\t\t\t\t\ts.save( entity );\n\t\t\t\t\t\tlong expectedId = i + 1;\n\t\t\t\t\t\tassertEquals( expectedId, entity.getId().longValue() );\n\t\t\t\t\t\tassertEquals( expectedId, generator.getTableAccessCount() );\n\t\t\t\t\t\tassertEquals( expectedId, ( (BasicHolder) generator.getOptimizer().getLastSourceValue() ).getActualLongValue() );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t);\n\t}",
        "filePathBefore": "hibernate-core/src/test/java/org/hibernate/orm/test/idgen/enhanced/table/BasicTableTest.java",
        "isPureRefactoring": true,
        "commitId": "26e73937756de5781043f120905b71abe9398e5e",
        "packageNameBefore": "org.hibernate.orm.test.idgen.enhanced.table",
        "classNameBefore": "org.hibernate.orm.test.idgen.enhanced.table.BasicTableTest",
        "methodNameBefore": "org.hibernate.orm.test.idgen.enhanced.table.BasicTableTest#testNormalBoundary",
        "invokedMethod": "methodSignature: org.hibernate.boot.model.IdentifierGeneratorDefinition.Builder#getName\n methodBody: public String getName() {\nreturn name;\n}\nmethodSignature: org.hibernate.boot.internal.InFlightMetadataCollectorImpl#getIdentifierGenerator\n methodBody: public IdentifierGeneratorDefinition getIdentifierGenerator(String name) {\nif(name == null){throw new IllegalArgumentException(\"null is not a valid generator name\");\n}return idGeneratorDefinitionMap.get(name);\n}\nmethodSignature: org.hibernate.persister.collection.AbstractCollectionPersister#getIdentifierGenerator\n methodBody: public IdentifierGenerator getIdentifierGenerator() {\nreturn identifierGenerator;\n}\nmethodSignature: org.hibernate.tuple.entity.EntityMetamodel#getSessionFactory\n methodBody: public SessionFactoryImplementor getSessionFactory() {\nreturn sessionFactory;\n}\nmethodSignature: org.hibernate.engine.spi.SessionFactoryImplementor#getName\n methodBody: String getName();\nmethodSignature: org.hibernate.engine.spi.SessionFactoryImplementor#getIdentifierGenerator\n methodBody: IdentifierGenerator getIdentifierGenerator(String rootEntityName);\nmethodSignature: org.hibernate.engine.spi.SessionFactoryDelegatingImpl#getName\n methodBody: public String getName() {\nreturn delegate.getName();\n}\nmethodSignature: org.hibernate.persister.entity.AbstractEntityPersister#getIdentifierGenerator\n methodBody: public IdentifierGenerator getIdentifierGenerator() throws HibernateException {\nreturn entityMetamodel.getIdentifierProperty().getIdentifierGenerator();\n}\nmethodSignature: org.hibernate.query.sqm.mutation.internal.cte.CteInsertHandler#getEntityDescriptor\n methodBody: public EntityMappingType getEntityDescriptor() {\nreturn entityDescriptor;\n}\nmethodSignature: org.hibernate.persister.entity.AbstractEntityPersister#getName\n methodBody: public String getName() {\nreturn getEntityName();\n}\nmethodSignature: org.hibernate.engine.spi.SessionFactoryDelegatingImpl#getIdentifierGenerator\n methodBody: public IdentifierGenerator getIdentifierGenerator(String rootEntityName) {\nreturn delegate.getIdentifierGenerator(rootEntityName);\n}\nmethodSignature: org.hibernate.mapping.SimpleValue#getIdentifierGenerator\n methodBody: public IdentifierGenerator getIdentifierGenerator() {\nreturn identifierGenerator;\n}\nmethodSignature: org.hibernate.dialect.temptable.TemporaryTable#getEntityDescriptor\n methodBody: public EntityMappingType getEntityDescriptor() {\nreturn entityDescriptor;\n}\nmethodSignature: org.hibernate.engine.spi.SessionFactoryImplementor#getSessionFactory\n methodBody: default SessionFactoryImplementor getSessionFactory() {\nreturn this;\n}\nmethodSignature: org.hibernate.tuple.IdentifierAttribute#getIdentifierGenerator\n methodBody: IdentifierGenerator getIdentifierGenerator();\nmethodSignature: org.hibernate.internal.SessionFactoryImpl#getName\n methodBody: public String getName() {\nreturn name;\n}\nmethodSignature: org.hibernate.cfg.BinderHelper#getIdentifierGenerator\n methodBody: private static IdentifierGeneratorDefinition getIdentifierGenerator(\n\t\t\tString name,\n\t\t\tXProperty idXProperty,\n\t\t\tMap<String, IdentifierGeneratorDefinition> localGenerators,\n\t\t\tMetadataBuildingContext buildingContext) {\nif(localGenerators != null){final IdentifierGeneratorDefinition result=localGenerators.get(name);\nif(result != null){return result;\n}}final IdentifierGeneratorDefinition globalDefinition=buildingContext.getMetadataCollector().getIdentifierGenerator(name);\nif(globalDefinition != null){return globalDefinition;\n}log.debugf(\"Could not resolve explicit IdentifierGeneratorDefinition - using implicit interpretation (%s)\",name);\nfinal GeneratedValue generatedValueAnn=idXProperty.getAnnotation(GeneratedValue.class);\nif(generatedValueAnn == null){return new IdentifierGeneratorDefinition(\"assigned\",\"assigned\");\n}final IdGeneratorStrategyInterpreter generationInterpreter=buildingContext.getBuildingOptions().getIdGenerationTypeInterpreter();\nfinal GenerationType generationType=interpretGenerationType(generatedValueAnn);\nif(generationType == null || generationType == GenerationType.SEQUENCE){log.debugf(\"Building implicit sequence-based IdentifierGeneratorDefinition (%s)\",name);\nfinal IdentifierGeneratorDefinition.Builder builder=new IdentifierGeneratorDefinition.Builder();\ngenerationInterpreter.interpretSequenceGenerator(new SequenceGenerator(){\n  @Override public String name(){\n    return name;\n  }\n  @Override public String sequenceName(){\n    return \"\";\n  }\n  @Override public String catalog(){\n    return \"\";\n  }\n  @Override public String schema(){\n    return \"\";\n  }\n  @Override public int initialValue(){\n    return 1;\n  }\n  @Override public int allocationSize(){\n    return 50;\n  }\n  @Override public Class<? extends Annotation> annotationType(){\n    return SequenceGenerator.class;\n  }\n}\n,builder);\nreturn builder.build();\n}if(generationType == GenerationType.TABLE){log.debugf(\"Building implicit table-based IdentifierGeneratorDefinition (%s)\",name);\nfinal IdentifierGeneratorDefinition.Builder builder=new IdentifierGeneratorDefinition.Builder();\ngenerationInterpreter.interpretTableGenerator(new TableGenerator(){\n  @Override public String name(){\n    return name;\n  }\n  @Override public String table(){\n    return \"\";\n  }\n  @Override public int initialValue(){\n    return 0;\n  }\n  @Override public int allocationSize(){\n    return 50;\n  }\n  @Override public String catalog(){\n    return \"\";\n  }\n  @Override public String schema(){\n    return \"\";\n  }\n  @Override public String pkColumnName(){\n    return \"\";\n  }\n  @Override public String valueColumnName(){\n    return \"\";\n  }\n  @Override public String pkColumnValue(){\n    return \"\";\n  }\n  @Override public UniqueConstraint[] uniqueConstraints(){\n    return new UniqueConstraint[0];\n  }\n  @Override public Index[] indexes(){\n    return new Index[0];\n  }\n  @Override public Class<? extends Annotation> annotationType(){\n    return TableGenerator.class;\n  }\n}\n,builder);\nreturn builder.build();\n}final String strategyName;\nif(generationType == GenerationType.IDENTITY){strategyName=\"identity\";\n}{strategyName=generationInterpreter.determineGeneratorName(generationType,new GeneratorNameDeterminationContext(){\n  @Override public Class<?> getIdType(){\n    return buildingContext.getBootstrapContext().getReflectionManager().toClass(idXProperty.getType());\n  }\n  @Override public String getGeneratedValueGeneratorName(){\n    return generatedValueAnn.generator();\n  }\n}\n);\n}log.debugf(\"Building implicit generic IdentifierGeneratorDefinition (%s) : %s\",name,strategyName);\nreturn new IdentifierGeneratorDefinition(name,strategyName,Collections.singletonMap(IdentifierGenerator.GENERATOR_NAME,name));\n}\nmethodSignature: org.hibernate.persister.entity.EntityPersister#getIdentifierGenerator\n methodBody: IdentifierGenerator getIdentifierGenerator();\nmethodSignature: org.hibernate.tuple.entity.EntityMetamodel#getName\n methodBody: public String getName() {\nreturn name;\n}\nmethodSignature: org.hibernate.boot.model.IdentifierGeneratorDefinition#getName\n methodBody: public String getName() {\nreturn name;\n}\nmethodSignature: org.hibernate.engine.spi.SessionFactoryImplementor#getMappingMetamodel\n methodBody: default MappingMetamodelImplementor getMappingMetamodel() {\nreturn getRuntimeMetamodels().getMappingMetamodel();\n}\nmethodSignature: org.hibernate.tuple.IdentifierProperty#getIdentifierGenerator\n methodBody: public IdentifierGenerator getIdentifierGenerator() {\nreturn identifierGenerator;\n}\nmethodSignature: org.hibernate.persister.collection.AbstractCollectionPersister#getName\n methodBody: public String getName() {\nreturn getRole();\n}\nmethodSignature: org.hibernate.persister.collection.CollectionPersister#getIdentifierGenerator\n methodBody: IdentifierGenerator getIdentifierGenerator();\nmethodSignature: org.hibernate.internal.SessionFactoryImpl#getIdentifierGenerator\n methodBody: public IdentifierGenerator getIdentifierGenerator(String rootEntityName) {\nreturn identifierGenerators.get(rootEntityName);\n}",
        "classSignatureBefore": "public class BasicTableTest ",
        "methodNameBeforeSet": [
            "org.hibernate.orm.test.idgen.enhanced.table.BasicTableTest#testNormalBoundary"
        ],
        "classNameBeforeSet": [
            "org.hibernate.orm.test.idgen.enhanced.table.BasicTableTest"
        ],
        "classSignatureBeforeSet": [
            "public class BasicTableTest "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Changes are within the Move Method refactoring mechanics\n",
                "description": "Move Method specific changes - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later\n * See the lgpl.txt file in the root directory or http://www.gnu.org/licenses/lgpl-2.1.html\n */\npackage org.hibernate.orm.test.idgen.enhanced.table;\n\nimport org.hibernate.id.enhanced.TableGenerator;\nimport org.hibernate.persister.entity.EntityPersister;\n\nimport org.hibernate.testing.orm.junit.DomainModel;\nimport org.hibernate.testing.orm.junit.SessionFactory;\nimport org.hibernate.testing.orm.junit.SessionFactoryScope;\nimport org.junit.jupiter.api.AfterEach;\nimport org.junit.jupiter.api.Test;\n\nimport static org.hamcrest.Matchers.instanceOf;\nimport static org.hibernate.id.IdentifierGeneratorHelper.BasicHolder;\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertThat;\n\n@DomainModel( xmlMappings = \"org/hibernate/orm/test/idgen/enhanced/table/Basic.hbm.xml\" )\n@SessionFactory\npublic class BasicTableTest {\n\n\t@Test\n\tpublic void testNormalBoundary(SessionFactoryScope scope) {\n        final EntityPersister persister = scope.getSessionFactory()\n\t\t\t\t.getMappingMetamodel()\n\t\t\t\t.getEntityDescriptor(Entity.class.getName());\n\t\tassertThat( persister.getIdentifierGenerator(), instanceOf( TableGenerator.class ) );\n\n\t\tfinal TableGenerator generator = ( TableGenerator ) persister.getIdentifierGenerator();\n\n\t\tscope.inTransaction(\n\t\t\t\t(s) -> {\n\t\t\t\t\tint count = 5;\n\t\t\t\t\tfor ( int i = 0; i < count; i++ ) {\n\t\t\t\t\t\tfinal Entity entity = new Entity( \"\" + ( i + 1 ) );\n\t\t\t\t\t\ts.save( entity );\n\t\t\t\t\t\tlong expectedId = i + 1;\n\t\t\t\t\t\tassertEquals( expectedId, entity.getId().longValue() );\n\t\t\t\t\t\tassertEquals( expectedId, generator.getTableAccessCount() );\n\t\t\t\t\t\tassertEquals( expectedId, ( (BasicHolder) generator.getOptimizer().getLastSourceValue() ).getActualLongValue() );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t);\n\t}\n\n\t@AfterEach\n\tpublic void cleanTestData(SessionFactoryScope scope) {\n\t\tscope.inTransaction(\n\t\t\t\t(session) -> session.createQuery( \"delete Entity\" ).executeUpdate()\n\t\t);\n\t}\n}\n",
        "filePathAfter": "hibernate-core/src/test/java/org/hibernate/orm/test/idgen/enhanced/table/BasicTableTest.java",
        "sourceCodeAfterForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later\n * See the lgpl.txt file in the root directory or http://www.gnu.org/licenses/lgpl-2.1.html\n */\npackage org.hibernate.orm.test.idgen.enhanced.table;\n\nimport org.hibernate.id.enhanced.TableGenerator;\nimport org.hibernate.persister.entity.EntityPersister;\n\nimport org.hibernate.testing.orm.junit.DomainModel;\nimport org.hibernate.testing.orm.junit.SessionFactory;\nimport org.hibernate.testing.orm.junit.SessionFactoryScope;\nimport org.junit.jupiter.api.AfterEach;\nimport org.junit.jupiter.api.Test;\n\nimport static org.hamcrest.Matchers.instanceOf;\nimport static org.hibernate.id.IdentifierGeneratorHelper.BasicHolder;\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertThat;\n\n@DomainModel( xmlMappings = \"org/hibernate/orm/test/idgen/enhanced/table/Basic.hbm.xml\" )\n@SessionFactory\npublic class BasicTableTest {\n\n\t@Test\n\tpublic void testNormalBoundary(SessionFactoryScope scope) {\n        final EntityPersister persister = scope.getSessionFactory()\n\t\t\t\t.getMappingMetamodel()\n\t\t\t\t.getEntityDescriptor(Entity.class.getName());\n\t\tassertThat( persister.getGenerator(), instanceOf( TableGenerator.class ) );\n\n\t\tfinal TableGenerator generator = ( TableGenerator ) persister.getGenerator();\n\n\t\tscope.inTransaction(\n\t\t\t\t(s) -> {\n\t\t\t\t\tint count = 5;\n\t\t\t\t\tfor ( int i = 0; i < count; i++ ) {\n\t\t\t\t\t\tfinal Entity entity = new Entity( \"\" + ( i + 1 ) );\n\t\t\t\t\t\ts.save( entity );\n\t\t\t\t\t\tlong expectedId = i + 1;\n\t\t\t\t\t\tassertEquals( expectedId, entity.getId().longValue() );\n\t\t\t\t\t\tassertEquals( expectedId, generator.getTableAccessCount() );\n\t\t\t\t\t\tassertEquals( expectedId, ( (BasicHolder) generator.getOptimizer().getLastSourceValue() ).getActualLongValue() );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t);\n\t}\n\n\t@AfterEach\n\tpublic void cleanTestData(SessionFactoryScope scope) {\n\t\tscope.inTransaction(\n\t\t\t\t(session) -> session.createQuery( \"delete Entity\" ).executeUpdate()\n\t\t);\n\t}\n}\n",
        "diffSourceCodeSet": [
            ""
        ],
        "invokedMethodSet": [
            "methodSignature: org.hibernate.boot.model.IdentifierGeneratorDefinition.Builder#getName\n methodBody: public String getName() {\nreturn name;\n}",
            "methodSignature: org.hibernate.boot.internal.InFlightMetadataCollectorImpl#getIdentifierGenerator\n methodBody: public IdentifierGeneratorDefinition getIdentifierGenerator(String name) {\nif(name == null){throw new IllegalArgumentException(\"null is not a valid generator name\");\n}return idGeneratorDefinitionMap.get(name);\n}",
            "methodSignature: org.hibernate.persister.collection.AbstractCollectionPersister#getIdentifierGenerator\n methodBody: public IdentifierGenerator getIdentifierGenerator() {\nreturn identifierGenerator;\n}",
            "methodSignature: org.hibernate.tuple.entity.EntityMetamodel#getSessionFactory\n methodBody: public SessionFactoryImplementor getSessionFactory() {\nreturn sessionFactory;\n}",
            "methodSignature: org.hibernate.engine.spi.SessionFactoryImplementor#getName\n methodBody: String getName();",
            "methodSignature: org.hibernate.engine.spi.SessionFactoryImplementor#getIdentifierGenerator\n methodBody: IdentifierGenerator getIdentifierGenerator(String rootEntityName);",
            "methodSignature: org.hibernate.engine.spi.SessionFactoryDelegatingImpl#getName\n methodBody: public String getName() {\nreturn delegate.getName();\n}",
            "methodSignature: org.hibernate.persister.entity.AbstractEntityPersister#getIdentifierGenerator\n methodBody: public IdentifierGenerator getIdentifierGenerator() throws HibernateException {\nreturn entityMetamodel.getIdentifierProperty().getIdentifierGenerator();\n}",
            "methodSignature: org.hibernate.query.sqm.mutation.internal.cte.CteInsertHandler#getEntityDescriptor\n methodBody: public EntityMappingType getEntityDescriptor() {\nreturn entityDescriptor;\n}",
            "methodSignature: org.hibernate.persister.entity.AbstractEntityPersister#getName\n methodBody: public String getName() {\nreturn getEntityName();\n}",
            "methodSignature: org.hibernate.engine.spi.SessionFactoryDelegatingImpl#getIdentifierGenerator\n methodBody: public IdentifierGenerator getIdentifierGenerator(String rootEntityName) {\nreturn delegate.getIdentifierGenerator(rootEntityName);\n}",
            "methodSignature: org.hibernate.mapping.SimpleValue#getIdentifierGenerator\n methodBody: public IdentifierGenerator getIdentifierGenerator() {\nreturn identifierGenerator;\n}",
            "methodSignature: org.hibernate.dialect.temptable.TemporaryTable#getEntityDescriptor\n methodBody: public EntityMappingType getEntityDescriptor() {\nreturn entityDescriptor;\n}",
            "methodSignature: org.hibernate.engine.spi.SessionFactoryImplementor#getSessionFactory\n methodBody: default SessionFactoryImplementor getSessionFactory() {\nreturn this;\n}",
            "methodSignature: org.hibernate.tuple.IdentifierAttribute#getIdentifierGenerator\n methodBody: IdentifierGenerator getIdentifierGenerator();",
            "methodSignature: org.hibernate.internal.SessionFactoryImpl#getName\n methodBody: public String getName() {\nreturn name;\n}",
            "methodSignature: org.hibernate.cfg.BinderHelper#getIdentifierGenerator\n methodBody: private static IdentifierGeneratorDefinition getIdentifierGenerator(\n\t\t\tString name,\n\t\t\tXProperty idXProperty,\n\t\t\tMap<String, IdentifierGeneratorDefinition> localGenerators,\n\t\t\tMetadataBuildingContext buildingContext) {\nif(localGenerators != null){final IdentifierGeneratorDefinition result=localGenerators.get(name);\nif(result != null){return result;\n}}final IdentifierGeneratorDefinition globalDefinition=buildingContext.getMetadataCollector().getIdentifierGenerator(name);\nif(globalDefinition != null){return globalDefinition;\n}log.debugf(\"Could not resolve explicit IdentifierGeneratorDefinition - using implicit interpretation (%s)\",name);\nfinal GeneratedValue generatedValueAnn=idXProperty.getAnnotation(GeneratedValue.class);\nif(generatedValueAnn == null){return new IdentifierGeneratorDefinition(\"assigned\",\"assigned\");\n}final IdGeneratorStrategyInterpreter generationInterpreter=buildingContext.getBuildingOptions().getIdGenerationTypeInterpreter();\nfinal GenerationType generationType=interpretGenerationType(generatedValueAnn);\nif(generationType == null || generationType == GenerationType.SEQUENCE){log.debugf(\"Building implicit sequence-based IdentifierGeneratorDefinition (%s)\",name);\nfinal IdentifierGeneratorDefinition.Builder builder=new IdentifierGeneratorDefinition.Builder();\ngenerationInterpreter.interpretSequenceGenerator(new SequenceGenerator(){\n  @Override public String name(){\n    return name;\n  }\n  @Override public String sequenceName(){\n    return \"\";\n  }\n  @Override public String catalog(){\n    return \"\";\n  }\n  @Override public String schema(){\n    return \"\";\n  }\n  @Override public int initialValue(){\n    return 1;\n  }\n  @Override public int allocationSize(){\n    return 50;\n  }\n  @Override public Class<? extends Annotation> annotationType(){\n    return SequenceGenerator.class;\n  }\n}\n,builder);\nreturn builder.build();\n}if(generationType == GenerationType.TABLE){log.debugf(\"Building implicit table-based IdentifierGeneratorDefinition (%s)\",name);\nfinal IdentifierGeneratorDefinition.Builder builder=new IdentifierGeneratorDefinition.Builder();\ngenerationInterpreter.interpretTableGenerator(new TableGenerator(){\n  @Override public String name(){\n    return name;\n  }\n  @Override public String table(){\n    return \"\";\n  }\n  @Override public int initialValue(){\n    return 0;\n  }\n  @Override public int allocationSize(){\n    return 50;\n  }\n  @Override public String catalog(){\n    return \"\";\n  }\n  @Override public String schema(){\n    return \"\";\n  }\n  @Override public String pkColumnName(){\n    return \"\";\n  }\n  @Override public String valueColumnName(){\n    return \"\";\n  }\n  @Override public String pkColumnValue(){\n    return \"\";\n  }\n  @Override public UniqueConstraint[] uniqueConstraints(){\n    return new UniqueConstraint[0];\n  }\n  @Override public Index[] indexes(){\n    return new Index[0];\n  }\n  @Override public Class<? extends Annotation> annotationType(){\n    return TableGenerator.class;\n  }\n}\n,builder);\nreturn builder.build();\n}final String strategyName;\nif(generationType == GenerationType.IDENTITY){strategyName=\"identity\";\n}{strategyName=generationInterpreter.determineGeneratorName(generationType,new GeneratorNameDeterminationContext(){\n  @Override public Class<?> getIdType(){\n    return buildingContext.getBootstrapContext().getReflectionManager().toClass(idXProperty.getType());\n  }\n  @Override public String getGeneratedValueGeneratorName(){\n    return generatedValueAnn.generator();\n  }\n}\n);\n}log.debugf(\"Building implicit generic IdentifierGeneratorDefinition (%s) : %s\",name,strategyName);\nreturn new IdentifierGeneratorDefinition(name,strategyName,Collections.singletonMap(IdentifierGenerator.GENERATOR_NAME,name));\n}",
            "methodSignature: org.hibernate.persister.entity.EntityPersister#getIdentifierGenerator\n methodBody: IdentifierGenerator getIdentifierGenerator();",
            "methodSignature: org.hibernate.tuple.entity.EntityMetamodel#getName\n methodBody: public String getName() {\nreturn name;\n}",
            "methodSignature: org.hibernate.boot.model.IdentifierGeneratorDefinition#getName\n methodBody: public String getName() {\nreturn name;\n}",
            "methodSignature: org.hibernate.engine.spi.SessionFactoryImplementor#getMappingMetamodel\n methodBody: default MappingMetamodelImplementor getMappingMetamodel() {\nreturn getRuntimeMetamodels().getMappingMetamodel();\n}",
            "methodSignature: org.hibernate.tuple.IdentifierProperty#getIdentifierGenerator\n methodBody: public IdentifierGenerator getIdentifierGenerator() {\nreturn identifierGenerator;\n}",
            "methodSignature: org.hibernate.persister.collection.AbstractCollectionPersister#getName\n methodBody: public String getName() {\nreturn getRole();\n}",
            "methodSignature: org.hibernate.persister.collection.CollectionPersister#getIdentifierGenerator\n methodBody: IdentifierGenerator getIdentifierGenerator();",
            "methodSignature: org.hibernate.internal.SessionFactoryImpl#getIdentifierGenerator\n methodBody: public IdentifierGenerator getIdentifierGenerator(String rootEntityName) {\nreturn identifierGenerators.get(rootEntityName);\n}"
        ],
        "sourceCodeAfterRefactoring": "@Test\n\tpublic void testNormalBoundary(SessionFactoryScope scope) {\n        final EntityPersister persister = scope.getSessionFactory()\n\t\t\t\t.getMappingMetamodel()\n\t\t\t\t.getEntityDescriptor(Entity.class.getName());\n\t\tassertThat( persister.getGenerator(), instanceOf( TableGenerator.class ) );\n\n\t\tfinal TableGenerator generator = ( TableGenerator ) persister.getGenerator();\n\n\t\tscope.inTransaction(\n\t\t\t\t(s) -> {\n\t\t\t\t\tint count = 5;\n\t\t\t\t\tfor ( int i = 0; i < count; i++ ) {\n\t\t\t\t\t\tfinal Entity entity = new Entity( \"\" + ( i + 1 ) );\n\t\t\t\t\t\ts.save( entity );\n\t\t\t\t\t\tlong expectedId = i + 1;\n\t\t\t\t\t\tassertEquals( expectedId, entity.getId().longValue() );\n\t\t\t\t\t\tassertEquals( expectedId, generator.getTableAccessCount() );\n\t\t\t\t\t\tassertEquals( expectedId, ( (BasicHolder) generator.getOptimizer().getLastSourceValue() ).getActualLongValue() );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t);\n\t}\n",
        "diffSourceCode": "    27: \t@Test\n    28: \tpublic void testNormalBoundary(SessionFactoryScope scope) {\n    29:         final EntityPersister persister = scope.getSessionFactory()\n    30: \t\t\t\t.getMappingMetamodel()\n    31: \t\t\t\t.getEntityDescriptor(Entity.class.getName());\n-   32: \t\tassertThat( persister.getIdentifierGenerator(), instanceOf( TableGenerator.class ) );\n+   32: \t\tassertThat( persister.getGenerator(), instanceOf( TableGenerator.class ) );\n    33: \n-   34: \t\tfinal TableGenerator generator = ( TableGenerator ) persister.getIdentifierGenerator();\n+   34: \t\tfinal TableGenerator generator = ( TableGenerator ) persister.getGenerator();\n    35: \n    36: \t\tscope.inTransaction(\n    37: \t\t\t\t(s) -> {\n    38: \t\t\t\t\tint count = 5;\n    39: \t\t\t\t\tfor ( int i = 0; i < count; i++ ) {\n    40: \t\t\t\t\t\tfinal Entity entity = new Entity( \"\" + ( i + 1 ) );\n    41: \t\t\t\t\t\ts.save( entity );\n    42: \t\t\t\t\t\tlong expectedId = i + 1;\n    43: \t\t\t\t\t\tassertEquals( expectedId, entity.getId().longValue() );\n    44: \t\t\t\t\t\tassertEquals( expectedId, generator.getTableAccessCount() );\n    45: \t\t\t\t\t\tassertEquals( expectedId, ( (BasicHolder) generator.getOptimizer().getLastSourceValue() ).getActualLongValue() );\n    46: \t\t\t\t\t}\n    47: \t\t\t\t}\n    48: \t\t);\n    49: \t}\n",
        "uniqueId": "26e73937756de5781043f120905b71abe9398e5e_27_49_461_463_27_49",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "testMethod": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 11
    },
    {
        "type": "Extract And Move Method",
        "description": "Extract And Move Method\tpublic getGenerator() : InMemoryGenerator extracted from public testSequencePerEntity(scope SessionFactoryScope) : void in class org.hibernate.orm.test.idgen.enhanced.sequence.BasicSequenceTest & moved to class org.hibernate.persister.entity.EntityPersister",
        "diffLocations": [
            {
                "filePath": "hibernate-core/src/test/java/org/hibernate/orm/test/idgen/enhanced/sequence/BasicSequenceTest.java",
                "startLine": 66,
                "endLine": 91,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/test/java/org/hibernate/orm/test/idgen/enhanced/sequence/BasicSequenceTest.java",
                "startLine": 66,
                "endLine": 91,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/test/java/org/hibernate/orm/test/idgen/enhanced/sequence/BasicSequenceTest.java",
                "startLine": 461,
                "endLine": 463,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "@Test\n\t@TestForIssue(jiraKey = \"HHH-6790\")\n\tpublic void testSequencePerEntity(SessionFactoryScope scope) {\n\t\tfinal String overriddenEntityName = \"SpecialEntity\";\n\n        final EntityPersister persister = scope.getSessionFactory()\n\t\t\t\t.getMappingMetamodel()\n\t\t\t\t.getEntityDescriptor(overriddenEntityName);\n\t\tassertThat( persister.getIdentifierGenerator(), instanceOf( SequenceStyleGenerator.class ) );\n\n\t\tfinal SequenceStyleGenerator generator = (SequenceStyleGenerator) persister.getIdentifierGenerator();\n\t\tassertEquals( \"ID_SEQ_BSC_ENTITY\" + SequenceStyleGenerator.DEF_SEQUENCE_SUFFIX,\n\t\t\t\tgenerator.getDatabaseStructure().getPhysicalName().render() );\n\n\t\tscope.inTransaction(\n\t\t\t\t(s) -> {\n\t\t\t\t\tEntity entity1 = new Entity( \"1\" );\n\t\t\t\t\ts.save( overriddenEntityName, entity1 );\n\t\t\t\t\tEntity entity2 = new Entity( \"2\" );\n\t\t\t\t\ts.save( overriddenEntityName, entity2 );\n\n\t\t\t\t\tassertEquals( 1, entity1.getId().intValue() );\n\t\t\t\t\tassertEquals( 2, entity2.getId().intValue() );\n\t\t\t\t}\n\t\t);\n\t}",
        "filePathBefore": "hibernate-core/src/test/java/org/hibernate/orm/test/idgen/enhanced/sequence/BasicSequenceTest.java",
        "isPureRefactoring": true,
        "commitId": "26e73937756de5781043f120905b71abe9398e5e",
        "packageNameBefore": "org.hibernate.orm.test.idgen.enhanced.sequence",
        "classNameBefore": "org.hibernate.orm.test.idgen.enhanced.sequence.BasicSequenceTest",
        "methodNameBefore": "org.hibernate.orm.test.idgen.enhanced.sequence.BasicSequenceTest#testSequencePerEntity",
        "invokedMethod": "methodSignature: org.hibernate.engine.spi.SessionFactoryDelegatingImpl#getIdentifierGenerator\n methodBody: public IdentifierGenerator getIdentifierGenerator(String rootEntityName) {\nreturn delegate.getIdentifierGenerator(rootEntityName);\n}\nmethodSignature: org.hibernate.boot.internal.InFlightMetadataCollectorImpl#getIdentifierGenerator\n methodBody: public IdentifierGeneratorDefinition getIdentifierGenerator(String name) {\nif(name == null){throw new IllegalArgumentException(\"null is not a valid generator name\");\n}return idGeneratorDefinitionMap.get(name);\n}\nmethodSignature: org.hibernate.persister.collection.AbstractCollectionPersister#getIdentifierGenerator\n methodBody: public IdentifierGenerator getIdentifierGenerator() {\nreturn identifierGenerator;\n}\nmethodSignature: org.hibernate.tuple.entity.EntityMetamodel#getSessionFactory\n methodBody: public SessionFactoryImplementor getSessionFactory() {\nreturn sessionFactory;\n}\nmethodSignature: org.hibernate.mapping.SimpleValue#getIdentifierGenerator\n methodBody: public IdentifierGenerator getIdentifierGenerator() {\nreturn identifierGenerator;\n}\nmethodSignature: org.hibernate.dialect.temptable.TemporaryTable#getEntityDescriptor\n methodBody: public EntityMappingType getEntityDescriptor() {\nreturn entityDescriptor;\n}\nmethodSignature: org.hibernate.engine.spi.SessionFactoryImplementor#getSessionFactory\n methodBody: default SessionFactoryImplementor getSessionFactory() {\nreturn this;\n}\nmethodSignature: org.hibernate.tuple.IdentifierAttribute#getIdentifierGenerator\n methodBody: IdentifierGenerator getIdentifierGenerator();\nmethodSignature: org.hibernate.engine.spi.SessionFactoryImplementor#getIdentifierGenerator\n methodBody: IdentifierGenerator getIdentifierGenerator(String rootEntityName);\nmethodSignature: org.hibernate.cfg.BinderHelper#getIdentifierGenerator\n methodBody: private static IdentifierGeneratorDefinition getIdentifierGenerator(\n\t\t\tString name,\n\t\t\tXProperty idXProperty,\n\t\t\tMap<String, IdentifierGeneratorDefinition> localGenerators,\n\t\t\tMetadataBuildingContext buildingContext) {\nif(localGenerators != null){final IdentifierGeneratorDefinition result=localGenerators.get(name);\nif(result != null){return result;\n}}final IdentifierGeneratorDefinition globalDefinition=buildingContext.getMetadataCollector().getIdentifierGenerator(name);\nif(globalDefinition != null){return globalDefinition;\n}log.debugf(\"Could not resolve explicit IdentifierGeneratorDefinition - using implicit interpretation (%s)\",name);\nfinal GeneratedValue generatedValueAnn=idXProperty.getAnnotation(GeneratedValue.class);\nif(generatedValueAnn == null){return new IdentifierGeneratorDefinition(\"assigned\",\"assigned\");\n}final IdGeneratorStrategyInterpreter generationInterpreter=buildingContext.getBuildingOptions().getIdGenerationTypeInterpreter();\nfinal GenerationType generationType=interpretGenerationType(generatedValueAnn);\nif(generationType == null || generationType == GenerationType.SEQUENCE){log.debugf(\"Building implicit sequence-based IdentifierGeneratorDefinition (%s)\",name);\nfinal IdentifierGeneratorDefinition.Builder builder=new IdentifierGeneratorDefinition.Builder();\ngenerationInterpreter.interpretSequenceGenerator(new SequenceGenerator(){\n  @Override public String name(){\n    return name;\n  }\n  @Override public String sequenceName(){\n    return \"\";\n  }\n  @Override public String catalog(){\n    return \"\";\n  }\n  @Override public String schema(){\n    return \"\";\n  }\n  @Override public int initialValue(){\n    return 1;\n  }\n  @Override public int allocationSize(){\n    return 50;\n  }\n  @Override public Class<? extends Annotation> annotationType(){\n    return SequenceGenerator.class;\n  }\n}\n,builder);\nreturn builder.build();\n}if(generationType == GenerationType.TABLE){log.debugf(\"Building implicit table-based IdentifierGeneratorDefinition (%s)\",name);\nfinal IdentifierGeneratorDefinition.Builder builder=new IdentifierGeneratorDefinition.Builder();\ngenerationInterpreter.interpretTableGenerator(new TableGenerator(){\n  @Override public String name(){\n    return name;\n  }\n  @Override public String table(){\n    return \"\";\n  }\n  @Override public int initialValue(){\n    return 0;\n  }\n  @Override public int allocationSize(){\n    return 50;\n  }\n  @Override public String catalog(){\n    return \"\";\n  }\n  @Override public String schema(){\n    return \"\";\n  }\n  @Override public String pkColumnName(){\n    return \"\";\n  }\n  @Override public String valueColumnName(){\n    return \"\";\n  }\n  @Override public String pkColumnValue(){\n    return \"\";\n  }\n  @Override public UniqueConstraint[] uniqueConstraints(){\n    return new UniqueConstraint[0];\n  }\n  @Override public Index[] indexes(){\n    return new Index[0];\n  }\n  @Override public Class<? extends Annotation> annotationType(){\n    return TableGenerator.class;\n  }\n}\n,builder);\nreturn builder.build();\n}final String strategyName;\nif(generationType == GenerationType.IDENTITY){strategyName=\"identity\";\n}{strategyName=generationInterpreter.determineGeneratorName(generationType,new GeneratorNameDeterminationContext(){\n  @Override public Class<?> getIdType(){\n    return buildingContext.getBootstrapContext().getReflectionManager().toClass(idXProperty.getType());\n  }\n  @Override public String getGeneratedValueGeneratorName(){\n    return generatedValueAnn.generator();\n  }\n}\n);\n}log.debugf(\"Building implicit generic IdentifierGeneratorDefinition (%s) : %s\",name,strategyName);\nreturn new IdentifierGeneratorDefinition(name,strategyName,Collections.singletonMap(IdentifierGenerator.GENERATOR_NAME,name));\n}\nmethodSignature: org.hibernate.persister.entity.EntityPersister#getIdentifierGenerator\n methodBody: IdentifierGenerator getIdentifierGenerator();\nmethodSignature: org.hibernate.persister.entity.AbstractEntityPersister#getIdentifierGenerator\n methodBody: public IdentifierGenerator getIdentifierGenerator() throws HibernateException {\nreturn entityMetamodel.getIdentifierProperty().getIdentifierGenerator();\n}\nmethodSignature: org.hibernate.engine.spi.SessionFactoryImplementor#getMappingMetamodel\n methodBody: default MappingMetamodelImplementor getMappingMetamodel() {\nreturn getRuntimeMetamodels().getMappingMetamodel();\n}\nmethodSignature: org.hibernate.tuple.IdentifierProperty#getIdentifierGenerator\n methodBody: public IdentifierGenerator getIdentifierGenerator() {\nreturn identifierGenerator;\n}\nmethodSignature: org.hibernate.query.sqm.mutation.internal.cte.CteInsertHandler#getEntityDescriptor\n methodBody: public EntityMappingType getEntityDescriptor() {\nreturn entityDescriptor;\n}\nmethodSignature: org.hibernate.persister.collection.CollectionPersister#getIdentifierGenerator\n methodBody: IdentifierGenerator getIdentifierGenerator();\nmethodSignature: org.hibernate.internal.SessionFactoryImpl#getIdentifierGenerator\n methodBody: public IdentifierGenerator getIdentifierGenerator(String rootEntityName) {\nreturn identifierGenerators.get(rootEntityName);\n}",
        "classSignatureBefore": "public class BasicSequenceTest ",
        "methodNameBeforeSet": [
            "org.hibernate.orm.test.idgen.enhanced.sequence.BasicSequenceTest#testSequencePerEntity"
        ],
        "classNameBeforeSet": [
            "org.hibernate.orm.test.idgen.enhanced.sequence.BasicSequenceTest"
        ],
        "classSignatureBeforeSet": [
            "public class BasicSequenceTest "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Changes are within the Move Method refactoring mechanics\n",
                "description": "Move Method specific changes - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later\n * See the lgpl.txt file in the root directory or http://www.gnu.org/licenses/lgpl-2.1.html\n */\npackage org.hibernate.orm.test.idgen.enhanced.sequence;\n\nimport org.hibernate.id.IdentifierGeneratorHelper.BasicHolder;\nimport org.hibernate.id.enhanced.SequenceStyleGenerator;\nimport org.hibernate.persister.entity.EntityPersister;\n\nimport org.hibernate.testing.TestForIssue;\nimport org.hibernate.testing.orm.junit.DomainModel;\nimport org.hibernate.testing.orm.junit.SessionFactory;\nimport org.hibernate.testing.orm.junit.SessionFactoryScope;\n\nimport org.junit.jupiter.api.AfterEach;\nimport org.junit.jupiter.api.Test;\n\nimport static org.hamcrest.Matchers.instanceOf;\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertThat;\n\n/**\n * @author Steve Ebersole\n * @author Lukasz Antoniak (lukasz dot antoniak at gmail dot com)\n */\n@DomainModel(\n\t\txmlMappings = {\n\t\t\t\t\"org/hibernate/orm/test/idgen/enhanced/sequence/Basic.hbm.xml\",\n\t\t\t\t\"org/hibernate/orm/test/idgen/enhanced/sequence/Dedicated.hbm.xml\"\n\t\t}\n)\n@SessionFactory\npublic class BasicSequenceTest {\n\n\t@Test\n\tpublic void testNormalBoundary(SessionFactoryScope scope) {\n        final EntityPersister persister = scope.getSessionFactory()\n\t\t\t\t.getMappingMetamodel()\n\t\t\t\t.getEntityDescriptor(Entity.class.getName());\n\t\tassertThat( persister.getIdentifierGenerator(), instanceOf( SequenceStyleGenerator.class ) );\n\n\t\tfinal SequenceStyleGenerator generator = (SequenceStyleGenerator) persister.getIdentifierGenerator();\n\n\t\tfinal int count = 5;\n\n\t\tscope.inTransaction(\n\t\t\t\t(s) -> {\n\t\t\t\t\tfor ( int i = 0; i < count; i++ ) {\n\t\t\t\t\t\tfinal Entity entity = new Entity( \"\" + ( i + 1 ) );\n\t\t\t\t\t\ts.save( entity );\n\n\t\t\t\t\t\tlong expectedId = i + 1;\n\n\t\t\t\t\t\tassertEquals( expectedId, entity.getId().longValue() );\n\t\t\t\t\t\tassertEquals( expectedId, generator.getDatabaseStructure().getTimesAccessed() );\n\t\t\t\t\t\tassertEquals( expectedId, ( (BasicHolder) generator.getOptimizer()\n\t\t\t\t\t\t\t\t.getLastSourceValue() ).getActualLongValue() );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t);\n\t}\n\n\t@Test\n\t@TestForIssue(jiraKey = \"HHH-6790\")\n\tpublic void testSequencePerEntity(SessionFactoryScope scope) {\n\t\tfinal String overriddenEntityName = \"SpecialEntity\";\n\n        final EntityPersister persister = scope.getSessionFactory()\n\t\t\t\t.getMappingMetamodel()\n\t\t\t\t.getEntityDescriptor(overriddenEntityName);\n\t\tassertThat( persister.getIdentifierGenerator(), instanceOf( SequenceStyleGenerator.class ) );\n\n\t\tfinal SequenceStyleGenerator generator = (SequenceStyleGenerator) persister.getIdentifierGenerator();\n\t\tassertEquals( \"ID_SEQ_BSC_ENTITY\" + SequenceStyleGenerator.DEF_SEQUENCE_SUFFIX,\n\t\t\t\tgenerator.getDatabaseStructure().getPhysicalName().render() );\n\n\t\tscope.inTransaction(\n\t\t\t\t(s) -> {\n\t\t\t\t\tEntity entity1 = new Entity( \"1\" );\n\t\t\t\t\ts.save( overriddenEntityName, entity1 );\n\t\t\t\t\tEntity entity2 = new Entity( \"2\" );\n\t\t\t\t\ts.save( overriddenEntityName, entity2 );\n\n\t\t\t\t\tassertEquals( 1, entity1.getId().intValue() );\n\t\t\t\t\tassertEquals( 2, entity2.getId().intValue() );\n\t\t\t\t}\n\t\t);\n\t}\n\n\t@AfterEach\n\tpublic void dropTestData(SessionFactoryScope scope) {\n\t\tscope.inTransaction(\n\t\t\t\t(session) -> session.createQuery( \"delete Entity\" ).executeUpdate()\n\t\t);\n\t}\n}\n",
        "filePathAfter": "hibernate-core/src/test/java/org/hibernate/orm/test/idgen/enhanced/sequence/BasicSequenceTest.java",
        "sourceCodeAfterForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later\n * See the lgpl.txt file in the root directory or http://www.gnu.org/licenses/lgpl-2.1.html\n */\npackage org.hibernate.orm.test.idgen.enhanced.sequence;\n\nimport org.hibernate.id.IdentifierGeneratorHelper.BasicHolder;\nimport org.hibernate.id.enhanced.SequenceStyleGenerator;\nimport org.hibernate.persister.entity.EntityPersister;\n\nimport org.hibernate.testing.TestForIssue;\nimport org.hibernate.testing.orm.junit.DomainModel;\nimport org.hibernate.testing.orm.junit.SessionFactory;\nimport org.hibernate.testing.orm.junit.SessionFactoryScope;\n\nimport org.junit.jupiter.api.AfterEach;\nimport org.junit.jupiter.api.Test;\n\nimport static org.hamcrest.Matchers.instanceOf;\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertThat;\n\n/**\n * @author Steve Ebersole\n * @author Lukasz Antoniak (lukasz dot antoniak at gmail dot com)\n */\n@DomainModel(\n\t\txmlMappings = {\n\t\t\t\t\"org/hibernate/orm/test/idgen/enhanced/sequence/Basic.hbm.xml\",\n\t\t\t\t\"org/hibernate/orm/test/idgen/enhanced/sequence/Dedicated.hbm.xml\"\n\t\t}\n)\n@SessionFactory\npublic class BasicSequenceTest {\n\n\t@Test\n\tpublic void testNormalBoundary(SessionFactoryScope scope) {\n        final EntityPersister persister = scope.getSessionFactory()\n\t\t\t\t.getMappingMetamodel()\n\t\t\t\t.getEntityDescriptor(Entity.class.getName());\n\t\tassertThat( persister.getGenerator(), instanceOf( SequenceStyleGenerator.class ) );\n\n\t\tfinal SequenceStyleGenerator generator = (SequenceStyleGenerator) persister.getGenerator();\n\n\t\tfinal int count = 5;\n\n\t\tscope.inTransaction(\n\t\t\t\t(s) -> {\n\t\t\t\t\tfor ( int i = 0; i < count; i++ ) {\n\t\t\t\t\t\tfinal Entity entity = new Entity( \"\" + ( i + 1 ) );\n\t\t\t\t\t\ts.save( entity );\n\n\t\t\t\t\t\tlong expectedId = i + 1;\n\n\t\t\t\t\t\tassertEquals( expectedId, entity.getId().longValue() );\n\t\t\t\t\t\tassertEquals( expectedId, generator.getDatabaseStructure().getTimesAccessed() );\n\t\t\t\t\t\tassertEquals( expectedId, ( (BasicHolder) generator.getOptimizer()\n\t\t\t\t\t\t\t\t.getLastSourceValue() ).getActualLongValue() );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t);\n\t}\n\n\t@Test\n\t@TestForIssue(jiraKey = \"HHH-6790\")\n\tpublic void testSequencePerEntity(SessionFactoryScope scope) {\n\t\tfinal String overriddenEntityName = \"SpecialEntity\";\n\n        final EntityPersister persister = scope.getSessionFactory()\n\t\t\t\t.getMappingMetamodel()\n\t\t\t\t.getEntityDescriptor(overriddenEntityName);\n\t\tassertThat( persister.getGenerator(), instanceOf( SequenceStyleGenerator.class ) );\n\n\t\tfinal SequenceStyleGenerator generator = (SequenceStyleGenerator) persister.getGenerator();\n\t\tassertEquals( \"ID_SEQ_BSC_ENTITY\" + SequenceStyleGenerator.DEF_SEQUENCE_SUFFIX,\n\t\t\t\tgenerator.getDatabaseStructure().getPhysicalName().render() );\n\n\t\tscope.inTransaction(\n\t\t\t\t(s) -> {\n\t\t\t\t\tEntity entity1 = new Entity( \"1\" );\n\t\t\t\t\ts.save( overriddenEntityName, entity1 );\n\t\t\t\t\tEntity entity2 = new Entity( \"2\" );\n\t\t\t\t\ts.save( overriddenEntityName, entity2 );\n\n\t\t\t\t\tassertEquals( 1, entity1.getId().intValue() );\n\t\t\t\t\tassertEquals( 2, entity2.getId().intValue() );\n\t\t\t\t}\n\t\t);\n\t}\n\n\t@AfterEach\n\tpublic void dropTestData(SessionFactoryScope scope) {\n\t\tscope.inTransaction(\n\t\t\t\t(session) -> session.createQuery( \"delete Entity\" ).executeUpdate()\n\t\t);\n\t}\n}\n",
        "diffSourceCodeSet": [
            ""
        ],
        "invokedMethodSet": [
            "methodSignature: org.hibernate.engine.spi.SessionFactoryDelegatingImpl#getIdentifierGenerator\n methodBody: public IdentifierGenerator getIdentifierGenerator(String rootEntityName) {\nreturn delegate.getIdentifierGenerator(rootEntityName);\n}",
            "methodSignature: org.hibernate.boot.internal.InFlightMetadataCollectorImpl#getIdentifierGenerator\n methodBody: public IdentifierGeneratorDefinition getIdentifierGenerator(String name) {\nif(name == null){throw new IllegalArgumentException(\"null is not a valid generator name\");\n}return idGeneratorDefinitionMap.get(name);\n}",
            "methodSignature: org.hibernate.persister.collection.AbstractCollectionPersister#getIdentifierGenerator\n methodBody: public IdentifierGenerator getIdentifierGenerator() {\nreturn identifierGenerator;\n}",
            "methodSignature: org.hibernate.tuple.entity.EntityMetamodel#getSessionFactory\n methodBody: public SessionFactoryImplementor getSessionFactory() {\nreturn sessionFactory;\n}",
            "methodSignature: org.hibernate.mapping.SimpleValue#getIdentifierGenerator\n methodBody: public IdentifierGenerator getIdentifierGenerator() {\nreturn identifierGenerator;\n}",
            "methodSignature: org.hibernate.dialect.temptable.TemporaryTable#getEntityDescriptor\n methodBody: public EntityMappingType getEntityDescriptor() {\nreturn entityDescriptor;\n}",
            "methodSignature: org.hibernate.engine.spi.SessionFactoryImplementor#getSessionFactory\n methodBody: default SessionFactoryImplementor getSessionFactory() {\nreturn this;\n}",
            "methodSignature: org.hibernate.tuple.IdentifierAttribute#getIdentifierGenerator\n methodBody: IdentifierGenerator getIdentifierGenerator();",
            "methodSignature: org.hibernate.engine.spi.SessionFactoryImplementor#getIdentifierGenerator\n methodBody: IdentifierGenerator getIdentifierGenerator(String rootEntityName);",
            "methodSignature: org.hibernate.cfg.BinderHelper#getIdentifierGenerator\n methodBody: private static IdentifierGeneratorDefinition getIdentifierGenerator(\n\t\t\tString name,\n\t\t\tXProperty idXProperty,\n\t\t\tMap<String, IdentifierGeneratorDefinition> localGenerators,\n\t\t\tMetadataBuildingContext buildingContext) {\nif(localGenerators != null){final IdentifierGeneratorDefinition result=localGenerators.get(name);\nif(result != null){return result;\n}}final IdentifierGeneratorDefinition globalDefinition=buildingContext.getMetadataCollector().getIdentifierGenerator(name);\nif(globalDefinition != null){return globalDefinition;\n}log.debugf(\"Could not resolve explicit IdentifierGeneratorDefinition - using implicit interpretation (%s)\",name);\nfinal GeneratedValue generatedValueAnn=idXProperty.getAnnotation(GeneratedValue.class);\nif(generatedValueAnn == null){return new IdentifierGeneratorDefinition(\"assigned\",\"assigned\");\n}final IdGeneratorStrategyInterpreter generationInterpreter=buildingContext.getBuildingOptions().getIdGenerationTypeInterpreter();\nfinal GenerationType generationType=interpretGenerationType(generatedValueAnn);\nif(generationType == null || generationType == GenerationType.SEQUENCE){log.debugf(\"Building implicit sequence-based IdentifierGeneratorDefinition (%s)\",name);\nfinal IdentifierGeneratorDefinition.Builder builder=new IdentifierGeneratorDefinition.Builder();\ngenerationInterpreter.interpretSequenceGenerator(new SequenceGenerator(){\n  @Override public String name(){\n    return name;\n  }\n  @Override public String sequenceName(){\n    return \"\";\n  }\n  @Override public String catalog(){\n    return \"\";\n  }\n  @Override public String schema(){\n    return \"\";\n  }\n  @Override public int initialValue(){\n    return 1;\n  }\n  @Override public int allocationSize(){\n    return 50;\n  }\n  @Override public Class<? extends Annotation> annotationType(){\n    return SequenceGenerator.class;\n  }\n}\n,builder);\nreturn builder.build();\n}if(generationType == GenerationType.TABLE){log.debugf(\"Building implicit table-based IdentifierGeneratorDefinition (%s)\",name);\nfinal IdentifierGeneratorDefinition.Builder builder=new IdentifierGeneratorDefinition.Builder();\ngenerationInterpreter.interpretTableGenerator(new TableGenerator(){\n  @Override public String name(){\n    return name;\n  }\n  @Override public String table(){\n    return \"\";\n  }\n  @Override public int initialValue(){\n    return 0;\n  }\n  @Override public int allocationSize(){\n    return 50;\n  }\n  @Override public String catalog(){\n    return \"\";\n  }\n  @Override public String schema(){\n    return \"\";\n  }\n  @Override public String pkColumnName(){\n    return \"\";\n  }\n  @Override public String valueColumnName(){\n    return \"\";\n  }\n  @Override public String pkColumnValue(){\n    return \"\";\n  }\n  @Override public UniqueConstraint[] uniqueConstraints(){\n    return new UniqueConstraint[0];\n  }\n  @Override public Index[] indexes(){\n    return new Index[0];\n  }\n  @Override public Class<? extends Annotation> annotationType(){\n    return TableGenerator.class;\n  }\n}\n,builder);\nreturn builder.build();\n}final String strategyName;\nif(generationType == GenerationType.IDENTITY){strategyName=\"identity\";\n}{strategyName=generationInterpreter.determineGeneratorName(generationType,new GeneratorNameDeterminationContext(){\n  @Override public Class<?> getIdType(){\n    return buildingContext.getBootstrapContext().getReflectionManager().toClass(idXProperty.getType());\n  }\n  @Override public String getGeneratedValueGeneratorName(){\n    return generatedValueAnn.generator();\n  }\n}\n);\n}log.debugf(\"Building implicit generic IdentifierGeneratorDefinition (%s) : %s\",name,strategyName);\nreturn new IdentifierGeneratorDefinition(name,strategyName,Collections.singletonMap(IdentifierGenerator.GENERATOR_NAME,name));\n}",
            "methodSignature: org.hibernate.persister.entity.EntityPersister#getIdentifierGenerator\n methodBody: IdentifierGenerator getIdentifierGenerator();",
            "methodSignature: org.hibernate.persister.entity.AbstractEntityPersister#getIdentifierGenerator\n methodBody: public IdentifierGenerator getIdentifierGenerator() throws HibernateException {\nreturn entityMetamodel.getIdentifierProperty().getIdentifierGenerator();\n}",
            "methodSignature: org.hibernate.engine.spi.SessionFactoryImplementor#getMappingMetamodel\n methodBody: default MappingMetamodelImplementor getMappingMetamodel() {\nreturn getRuntimeMetamodels().getMappingMetamodel();\n}",
            "methodSignature: org.hibernate.tuple.IdentifierProperty#getIdentifierGenerator\n methodBody: public IdentifierGenerator getIdentifierGenerator() {\nreturn identifierGenerator;\n}",
            "methodSignature: org.hibernate.query.sqm.mutation.internal.cte.CteInsertHandler#getEntityDescriptor\n methodBody: public EntityMappingType getEntityDescriptor() {\nreturn entityDescriptor;\n}",
            "methodSignature: org.hibernate.persister.collection.CollectionPersister#getIdentifierGenerator\n methodBody: IdentifierGenerator getIdentifierGenerator();",
            "methodSignature: org.hibernate.internal.SessionFactoryImpl#getIdentifierGenerator\n methodBody: public IdentifierGenerator getIdentifierGenerator(String rootEntityName) {\nreturn identifierGenerators.get(rootEntityName);\n}"
        ],
        "sourceCodeAfterRefactoring": "@Test\n\t@TestForIssue(jiraKey = \"HHH-6790\")\n\tpublic void testSequencePerEntity(SessionFactoryScope scope) {\n\t\tfinal String overriddenEntityName = \"SpecialEntity\";\n\n        final EntityPersister persister = scope.getSessionFactory()\n\t\t\t\t.getMappingMetamodel()\n\t\t\t\t.getEntityDescriptor(overriddenEntityName);\n\t\tassertThat( persister.getGenerator(), instanceOf( SequenceStyleGenerator.class ) );\n\n\t\tfinal SequenceStyleGenerator generator = (SequenceStyleGenerator) persister.getGenerator();\n\t\tassertEquals( \"ID_SEQ_BSC_ENTITY\" + SequenceStyleGenerator.DEF_SEQUENCE_SUFFIX,\n\t\t\t\tgenerator.getDatabaseStructure().getPhysicalName().render() );\n\n\t\tscope.inTransaction(\n\t\t\t\t(s) -> {\n\t\t\t\t\tEntity entity1 = new Entity( \"1\" );\n\t\t\t\t\ts.save( overriddenEntityName, entity1 );\n\t\t\t\t\tEntity entity2 = new Entity( \"2\" );\n\t\t\t\t\ts.save( overriddenEntityName, entity2 );\n\n\t\t\t\t\tassertEquals( 1, entity1.getId().intValue() );\n\t\t\t\t\tassertEquals( 2, entity2.getId().intValue() );\n\t\t\t\t}\n\t\t);\n\t}\n",
        "diffSourceCode": "    66: \t@Test\n    67: \t@TestForIssue(jiraKey = \"HHH-6790\")\n    68: \tpublic void testSequencePerEntity(SessionFactoryScope scope) {\n    69: \t\tfinal String overriddenEntityName = \"SpecialEntity\";\n    70: \n    71:         final EntityPersister persister = scope.getSessionFactory()\n    72: \t\t\t\t.getMappingMetamodel()\n    73: \t\t\t\t.getEntityDescriptor(overriddenEntityName);\n-   74: \t\tassertThat( persister.getIdentifierGenerator(), instanceOf( SequenceStyleGenerator.class ) );\n+   74: \t\tassertThat( persister.getGenerator(), instanceOf( SequenceStyleGenerator.class ) );\n    75: \n-   76: \t\tfinal SequenceStyleGenerator generator = (SequenceStyleGenerator) persister.getIdentifierGenerator();\n+   76: \t\tfinal SequenceStyleGenerator generator = (SequenceStyleGenerator) persister.getGenerator();\n    77: \t\tassertEquals( \"ID_SEQ_BSC_ENTITY\" + SequenceStyleGenerator.DEF_SEQUENCE_SUFFIX,\n    78: \t\t\t\tgenerator.getDatabaseStructure().getPhysicalName().render() );\n    79: \n    80: \t\tscope.inTransaction(\n    81: \t\t\t\t(s) -> {\n    82: \t\t\t\t\tEntity entity1 = new Entity( \"1\" );\n    83: \t\t\t\t\ts.save( overriddenEntityName, entity1 );\n    84: \t\t\t\t\tEntity entity2 = new Entity( \"2\" );\n    85: \t\t\t\t\ts.save( overriddenEntityName, entity2 );\n    86: \n    87: \t\t\t\t\tassertEquals( 1, entity1.getId().intValue() );\n    88: \t\t\t\t\tassertEquals( 2, entity2.getId().intValue() );\n    89: \t\t\t\t}\n    90: \t\t);\n    91: \t}\n",
        "uniqueId": "26e73937756de5781043f120905b71abe9398e5e_66_91_461_463_66_91",
        "moveFileExist": true,
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 11,
        "testResult": true,
        "coverageInfo": {
            "testMethod": {
                "missed": 0,
                "covered": 1
            }
        }
    },
    {
        "type": "Extract And Move Method",
        "description": "Extract And Move Method\tpublic getGenerator() : InMemoryGenerator extracted from public testNormalBoundary(scope SessionFactoryScope) : void in class org.hibernate.orm.test.idgen.enhanced.sequence.BasicSequenceTest & moved to class org.hibernate.persister.entity.EntityPersister",
        "diffLocations": [
            {
                "filePath": "hibernate-core/src/test/java/org/hibernate/orm/test/idgen/enhanced/sequence/BasicSequenceTest.java",
                "startLine": 38,
                "endLine": 64,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/test/java/org/hibernate/orm/test/idgen/enhanced/sequence/BasicSequenceTest.java",
                "startLine": 38,
                "endLine": 64,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/test/java/org/hibernate/orm/test/idgen/enhanced/sequence/BasicSequenceTest.java",
                "startLine": 461,
                "endLine": 463,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "@Test\n\tpublic void testNormalBoundary(SessionFactoryScope scope) {\n        final EntityPersister persister = scope.getSessionFactory()\n\t\t\t\t.getMappingMetamodel()\n\t\t\t\t.getEntityDescriptor(Entity.class.getName());\n\t\tassertThat( persister.getIdentifierGenerator(), instanceOf( SequenceStyleGenerator.class ) );\n\n\t\tfinal SequenceStyleGenerator generator = (SequenceStyleGenerator) persister.getIdentifierGenerator();\n\n\t\tfinal int count = 5;\n\n\t\tscope.inTransaction(\n\t\t\t\t(s) -> {\n\t\t\t\t\tfor ( int i = 0; i < count; i++ ) {\n\t\t\t\t\t\tfinal Entity entity = new Entity( \"\" + ( i + 1 ) );\n\t\t\t\t\t\ts.save( entity );\n\n\t\t\t\t\t\tlong expectedId = i + 1;\n\n\t\t\t\t\t\tassertEquals( expectedId, entity.getId().longValue() );\n\t\t\t\t\t\tassertEquals( expectedId, generator.getDatabaseStructure().getTimesAccessed() );\n\t\t\t\t\t\tassertEquals( expectedId, ( (BasicHolder) generator.getOptimizer()\n\t\t\t\t\t\t\t\t.getLastSourceValue() ).getActualLongValue() );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t);\n\t}",
        "filePathBefore": "hibernate-core/src/test/java/org/hibernate/orm/test/idgen/enhanced/sequence/BasicSequenceTest.java",
        "isPureRefactoring": true,
        "commitId": "26e73937756de5781043f120905b71abe9398e5e",
        "packageNameBefore": "org.hibernate.orm.test.idgen.enhanced.sequence",
        "classNameBefore": "org.hibernate.orm.test.idgen.enhanced.sequence.BasicSequenceTest",
        "methodNameBefore": "org.hibernate.orm.test.idgen.enhanced.sequence.BasicSequenceTest#testNormalBoundary",
        "invokedMethod": "methodSignature: org.hibernate.boot.model.IdentifierGeneratorDefinition.Builder#getName\n methodBody: public String getName() {\nreturn name;\n}\nmethodSignature: org.hibernate.boot.internal.InFlightMetadataCollectorImpl#getIdentifierGenerator\n methodBody: public IdentifierGeneratorDefinition getIdentifierGenerator(String name) {\nif(name == null){throw new IllegalArgumentException(\"null is not a valid generator name\");\n}return idGeneratorDefinitionMap.get(name);\n}\nmethodSignature: org.hibernate.persister.collection.AbstractCollectionPersister#getIdentifierGenerator\n methodBody: public IdentifierGenerator getIdentifierGenerator() {\nreturn identifierGenerator;\n}\nmethodSignature: org.hibernate.tuple.entity.EntityMetamodel#getSessionFactory\n methodBody: public SessionFactoryImplementor getSessionFactory() {\nreturn sessionFactory;\n}\nmethodSignature: org.hibernate.engine.spi.SessionFactoryImplementor#getName\n methodBody: String getName();\nmethodSignature: org.hibernate.engine.spi.SessionFactoryImplementor#getIdentifierGenerator\n methodBody: IdentifierGenerator getIdentifierGenerator(String rootEntityName);\nmethodSignature: org.hibernate.engine.spi.SessionFactoryDelegatingImpl#getName\n methodBody: public String getName() {\nreturn delegate.getName();\n}\nmethodSignature: org.hibernate.persister.entity.AbstractEntityPersister#getIdentifierGenerator\n methodBody: public IdentifierGenerator getIdentifierGenerator() throws HibernateException {\nreturn entityMetamodel.getIdentifierProperty().getIdentifierGenerator();\n}\nmethodSignature: org.hibernate.query.sqm.mutation.internal.cte.CteInsertHandler#getEntityDescriptor\n methodBody: public EntityMappingType getEntityDescriptor() {\nreturn entityDescriptor;\n}\nmethodSignature: org.hibernate.persister.entity.AbstractEntityPersister#getName\n methodBody: public String getName() {\nreturn getEntityName();\n}\nmethodSignature: org.hibernate.engine.spi.SessionFactoryDelegatingImpl#getIdentifierGenerator\n methodBody: public IdentifierGenerator getIdentifierGenerator(String rootEntityName) {\nreturn delegate.getIdentifierGenerator(rootEntityName);\n}\nmethodSignature: org.hibernate.mapping.SimpleValue#getIdentifierGenerator\n methodBody: public IdentifierGenerator getIdentifierGenerator() {\nreturn identifierGenerator;\n}\nmethodSignature: org.hibernate.dialect.temptable.TemporaryTable#getEntityDescriptor\n methodBody: public EntityMappingType getEntityDescriptor() {\nreturn entityDescriptor;\n}\nmethodSignature: org.hibernate.engine.spi.SessionFactoryImplementor#getSessionFactory\n methodBody: default SessionFactoryImplementor getSessionFactory() {\nreturn this;\n}\nmethodSignature: org.hibernate.tuple.IdentifierAttribute#getIdentifierGenerator\n methodBody: IdentifierGenerator getIdentifierGenerator();\nmethodSignature: org.hibernate.internal.SessionFactoryImpl#getName\n methodBody: public String getName() {\nreturn name;\n}\nmethodSignature: org.hibernate.cfg.BinderHelper#getIdentifierGenerator\n methodBody: private static IdentifierGeneratorDefinition getIdentifierGenerator(\n\t\t\tString name,\n\t\t\tXProperty idXProperty,\n\t\t\tMap<String, IdentifierGeneratorDefinition> localGenerators,\n\t\t\tMetadataBuildingContext buildingContext) {\nif(localGenerators != null){final IdentifierGeneratorDefinition result=localGenerators.get(name);\nif(result != null){return result;\n}}final IdentifierGeneratorDefinition globalDefinition=buildingContext.getMetadataCollector().getIdentifierGenerator(name);\nif(globalDefinition != null){return globalDefinition;\n}log.debugf(\"Could not resolve explicit IdentifierGeneratorDefinition - using implicit interpretation (%s)\",name);\nfinal GeneratedValue generatedValueAnn=idXProperty.getAnnotation(GeneratedValue.class);\nif(generatedValueAnn == null){return new IdentifierGeneratorDefinition(\"assigned\",\"assigned\");\n}final IdGeneratorStrategyInterpreter generationInterpreter=buildingContext.getBuildingOptions().getIdGenerationTypeInterpreter();\nfinal GenerationType generationType=interpretGenerationType(generatedValueAnn);\nif(generationType == null || generationType == GenerationType.SEQUENCE){log.debugf(\"Building implicit sequence-based IdentifierGeneratorDefinition (%s)\",name);\nfinal IdentifierGeneratorDefinition.Builder builder=new IdentifierGeneratorDefinition.Builder();\ngenerationInterpreter.interpretSequenceGenerator(new SequenceGenerator(){\n  @Override public String name(){\n    return name;\n  }\n  @Override public String sequenceName(){\n    return \"\";\n  }\n  @Override public String catalog(){\n    return \"\";\n  }\n  @Override public String schema(){\n    return \"\";\n  }\n  @Override public int initialValue(){\n    return 1;\n  }\n  @Override public int allocationSize(){\n    return 50;\n  }\n  @Override public Class<? extends Annotation> annotationType(){\n    return SequenceGenerator.class;\n  }\n}\n,builder);\nreturn builder.build();\n}if(generationType == GenerationType.TABLE){log.debugf(\"Building implicit table-based IdentifierGeneratorDefinition (%s)\",name);\nfinal IdentifierGeneratorDefinition.Builder builder=new IdentifierGeneratorDefinition.Builder();\ngenerationInterpreter.interpretTableGenerator(new TableGenerator(){\n  @Override public String name(){\n    return name;\n  }\n  @Override public String table(){\n    return \"\";\n  }\n  @Override public int initialValue(){\n    return 0;\n  }\n  @Override public int allocationSize(){\n    return 50;\n  }\n  @Override public String catalog(){\n    return \"\";\n  }\n  @Override public String schema(){\n    return \"\";\n  }\n  @Override public String pkColumnName(){\n    return \"\";\n  }\n  @Override public String valueColumnName(){\n    return \"\";\n  }\n  @Override public String pkColumnValue(){\n    return \"\";\n  }\n  @Override public UniqueConstraint[] uniqueConstraints(){\n    return new UniqueConstraint[0];\n  }\n  @Override public Index[] indexes(){\n    return new Index[0];\n  }\n  @Override public Class<? extends Annotation> annotationType(){\n    return TableGenerator.class;\n  }\n}\n,builder);\nreturn builder.build();\n}final String strategyName;\nif(generationType == GenerationType.IDENTITY){strategyName=\"identity\";\n}{strategyName=generationInterpreter.determineGeneratorName(generationType,new GeneratorNameDeterminationContext(){\n  @Override public Class<?> getIdType(){\n    return buildingContext.getBootstrapContext().getReflectionManager().toClass(idXProperty.getType());\n  }\n  @Override public String getGeneratedValueGeneratorName(){\n    return generatedValueAnn.generator();\n  }\n}\n);\n}log.debugf(\"Building implicit generic IdentifierGeneratorDefinition (%s) : %s\",name,strategyName);\nreturn new IdentifierGeneratorDefinition(name,strategyName,Collections.singletonMap(IdentifierGenerator.GENERATOR_NAME,name));\n}\nmethodSignature: org.hibernate.persister.entity.EntityPersister#getIdentifierGenerator\n methodBody: IdentifierGenerator getIdentifierGenerator();\nmethodSignature: org.hibernate.tuple.entity.EntityMetamodel#getName\n methodBody: public String getName() {\nreturn name;\n}\nmethodSignature: org.hibernate.boot.model.IdentifierGeneratorDefinition#getName\n methodBody: public String getName() {\nreturn name;\n}\nmethodSignature: org.hibernate.engine.spi.SessionFactoryImplementor#getMappingMetamodel\n methodBody: default MappingMetamodelImplementor getMappingMetamodel() {\nreturn getRuntimeMetamodels().getMappingMetamodel();\n}\nmethodSignature: org.hibernate.tuple.IdentifierProperty#getIdentifierGenerator\n methodBody: public IdentifierGenerator getIdentifierGenerator() {\nreturn identifierGenerator;\n}\nmethodSignature: org.hibernate.persister.collection.AbstractCollectionPersister#getName\n methodBody: public String getName() {\nreturn getRole();\n}\nmethodSignature: org.hibernate.persister.collection.CollectionPersister#getIdentifierGenerator\n methodBody: IdentifierGenerator getIdentifierGenerator();\nmethodSignature: org.hibernate.internal.SessionFactoryImpl#getIdentifierGenerator\n methodBody: public IdentifierGenerator getIdentifierGenerator(String rootEntityName) {\nreturn identifierGenerators.get(rootEntityName);\n}",
        "classSignatureBefore": "public class BasicSequenceTest ",
        "methodNameBeforeSet": [
            "org.hibernate.orm.test.idgen.enhanced.sequence.BasicSequenceTest#testNormalBoundary"
        ],
        "classNameBeforeSet": [
            "org.hibernate.orm.test.idgen.enhanced.sequence.BasicSequenceTest"
        ],
        "classSignatureBeforeSet": [
            "public class BasicSequenceTest "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Changes are within the Move Method refactoring mechanics\n",
                "description": "Move Method specific changes - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later\n * See the lgpl.txt file in the root directory or http://www.gnu.org/licenses/lgpl-2.1.html\n */\npackage org.hibernate.orm.test.idgen.enhanced.sequence;\n\nimport org.hibernate.id.IdentifierGeneratorHelper.BasicHolder;\nimport org.hibernate.id.enhanced.SequenceStyleGenerator;\nimport org.hibernate.persister.entity.EntityPersister;\n\nimport org.hibernate.testing.TestForIssue;\nimport org.hibernate.testing.orm.junit.DomainModel;\nimport org.hibernate.testing.orm.junit.SessionFactory;\nimport org.hibernate.testing.orm.junit.SessionFactoryScope;\n\nimport org.junit.jupiter.api.AfterEach;\nimport org.junit.jupiter.api.Test;\n\nimport static org.hamcrest.Matchers.instanceOf;\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertThat;\n\n/**\n * @author Steve Ebersole\n * @author Lukasz Antoniak (lukasz dot antoniak at gmail dot com)\n */\n@DomainModel(\n\t\txmlMappings = {\n\t\t\t\t\"org/hibernate/orm/test/idgen/enhanced/sequence/Basic.hbm.xml\",\n\t\t\t\t\"org/hibernate/orm/test/idgen/enhanced/sequence/Dedicated.hbm.xml\"\n\t\t}\n)\n@SessionFactory\npublic class BasicSequenceTest {\n\n\t@Test\n\tpublic void testNormalBoundary(SessionFactoryScope scope) {\n        final EntityPersister persister = scope.getSessionFactory()\n\t\t\t\t.getMappingMetamodel()\n\t\t\t\t.getEntityDescriptor(Entity.class.getName());\n\t\tassertThat( persister.getIdentifierGenerator(), instanceOf( SequenceStyleGenerator.class ) );\n\n\t\tfinal SequenceStyleGenerator generator = (SequenceStyleGenerator) persister.getIdentifierGenerator();\n\n\t\tfinal int count = 5;\n\n\t\tscope.inTransaction(\n\t\t\t\t(s) -> {\n\t\t\t\t\tfor ( int i = 0; i < count; i++ ) {\n\t\t\t\t\t\tfinal Entity entity = new Entity( \"\" + ( i + 1 ) );\n\t\t\t\t\t\ts.save( entity );\n\n\t\t\t\t\t\tlong expectedId = i + 1;\n\n\t\t\t\t\t\tassertEquals( expectedId, entity.getId().longValue() );\n\t\t\t\t\t\tassertEquals( expectedId, generator.getDatabaseStructure().getTimesAccessed() );\n\t\t\t\t\t\tassertEquals( expectedId, ( (BasicHolder) generator.getOptimizer()\n\t\t\t\t\t\t\t\t.getLastSourceValue() ).getActualLongValue() );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t);\n\t}\n\n\t@Test\n\t@TestForIssue(jiraKey = \"HHH-6790\")\n\tpublic void testSequencePerEntity(SessionFactoryScope scope) {\n\t\tfinal String overriddenEntityName = \"SpecialEntity\";\n\n        final EntityPersister persister = scope.getSessionFactory()\n\t\t\t\t.getMappingMetamodel()\n\t\t\t\t.getEntityDescriptor(overriddenEntityName);\n\t\tassertThat( persister.getIdentifierGenerator(), instanceOf( SequenceStyleGenerator.class ) );\n\n\t\tfinal SequenceStyleGenerator generator = (SequenceStyleGenerator) persister.getIdentifierGenerator();\n\t\tassertEquals( \"ID_SEQ_BSC_ENTITY\" + SequenceStyleGenerator.DEF_SEQUENCE_SUFFIX,\n\t\t\t\tgenerator.getDatabaseStructure().getPhysicalName().render() );\n\n\t\tscope.inTransaction(\n\t\t\t\t(s) -> {\n\t\t\t\t\tEntity entity1 = new Entity( \"1\" );\n\t\t\t\t\ts.save( overriddenEntityName, entity1 );\n\t\t\t\t\tEntity entity2 = new Entity( \"2\" );\n\t\t\t\t\ts.save( overriddenEntityName, entity2 );\n\n\t\t\t\t\tassertEquals( 1, entity1.getId().intValue() );\n\t\t\t\t\tassertEquals( 2, entity2.getId().intValue() );\n\t\t\t\t}\n\t\t);\n\t}\n\n\t@AfterEach\n\tpublic void dropTestData(SessionFactoryScope scope) {\n\t\tscope.inTransaction(\n\t\t\t\t(session) -> session.createQuery( \"delete Entity\" ).executeUpdate()\n\t\t);\n\t}\n}\n",
        "filePathAfter": "hibernate-core/src/test/java/org/hibernate/orm/test/idgen/enhanced/sequence/BasicSequenceTest.java",
        "sourceCodeAfterForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later\n * See the lgpl.txt file in the root directory or http://www.gnu.org/licenses/lgpl-2.1.html\n */\npackage org.hibernate.orm.test.idgen.enhanced.sequence;\n\nimport org.hibernate.id.IdentifierGeneratorHelper.BasicHolder;\nimport org.hibernate.id.enhanced.SequenceStyleGenerator;\nimport org.hibernate.persister.entity.EntityPersister;\n\nimport org.hibernate.testing.TestForIssue;\nimport org.hibernate.testing.orm.junit.DomainModel;\nimport org.hibernate.testing.orm.junit.SessionFactory;\nimport org.hibernate.testing.orm.junit.SessionFactoryScope;\n\nimport org.junit.jupiter.api.AfterEach;\nimport org.junit.jupiter.api.Test;\n\nimport static org.hamcrest.Matchers.instanceOf;\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertThat;\n\n/**\n * @author Steve Ebersole\n * @author Lukasz Antoniak (lukasz dot antoniak at gmail dot com)\n */\n@DomainModel(\n\t\txmlMappings = {\n\t\t\t\t\"org/hibernate/orm/test/idgen/enhanced/sequence/Basic.hbm.xml\",\n\t\t\t\t\"org/hibernate/orm/test/idgen/enhanced/sequence/Dedicated.hbm.xml\"\n\t\t}\n)\n@SessionFactory\npublic class BasicSequenceTest {\n\n\t@Test\n\tpublic void testNormalBoundary(SessionFactoryScope scope) {\n        final EntityPersister persister = scope.getSessionFactory()\n\t\t\t\t.getMappingMetamodel()\n\t\t\t\t.getEntityDescriptor(Entity.class.getName());\n\t\tassertThat( persister.getGenerator(), instanceOf( SequenceStyleGenerator.class ) );\n\n\t\tfinal SequenceStyleGenerator generator = (SequenceStyleGenerator) persister.getGenerator();\n\n\t\tfinal int count = 5;\n\n\t\tscope.inTransaction(\n\t\t\t\t(s) -> {\n\t\t\t\t\tfor ( int i = 0; i < count; i++ ) {\n\t\t\t\t\t\tfinal Entity entity = new Entity( \"\" + ( i + 1 ) );\n\t\t\t\t\t\ts.save( entity );\n\n\t\t\t\t\t\tlong expectedId = i + 1;\n\n\t\t\t\t\t\tassertEquals( expectedId, entity.getId().longValue() );\n\t\t\t\t\t\tassertEquals( expectedId, generator.getDatabaseStructure().getTimesAccessed() );\n\t\t\t\t\t\tassertEquals( expectedId, ( (BasicHolder) generator.getOptimizer()\n\t\t\t\t\t\t\t\t.getLastSourceValue() ).getActualLongValue() );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t);\n\t}\n\n\t@Test\n\t@TestForIssue(jiraKey = \"HHH-6790\")\n\tpublic void testSequencePerEntity(SessionFactoryScope scope) {\n\t\tfinal String overriddenEntityName = \"SpecialEntity\";\n\n        final EntityPersister persister = scope.getSessionFactory()\n\t\t\t\t.getMappingMetamodel()\n\t\t\t\t.getEntityDescriptor(overriddenEntityName);\n\t\tassertThat( persister.getGenerator(), instanceOf( SequenceStyleGenerator.class ) );\n\n\t\tfinal SequenceStyleGenerator generator = (SequenceStyleGenerator) persister.getGenerator();\n\t\tassertEquals( \"ID_SEQ_BSC_ENTITY\" + SequenceStyleGenerator.DEF_SEQUENCE_SUFFIX,\n\t\t\t\tgenerator.getDatabaseStructure().getPhysicalName().render() );\n\n\t\tscope.inTransaction(\n\t\t\t\t(s) -> {\n\t\t\t\t\tEntity entity1 = new Entity( \"1\" );\n\t\t\t\t\ts.save( overriddenEntityName, entity1 );\n\t\t\t\t\tEntity entity2 = new Entity( \"2\" );\n\t\t\t\t\ts.save( overriddenEntityName, entity2 );\n\n\t\t\t\t\tassertEquals( 1, entity1.getId().intValue() );\n\t\t\t\t\tassertEquals( 2, entity2.getId().intValue() );\n\t\t\t\t}\n\t\t);\n\t}\n\n\t@AfterEach\n\tpublic void dropTestData(SessionFactoryScope scope) {\n\t\tscope.inTransaction(\n\t\t\t\t(session) -> session.createQuery( \"delete Entity\" ).executeUpdate()\n\t\t);\n\t}\n}\n",
        "diffSourceCodeSet": [
            ""
        ],
        "invokedMethodSet": [
            "methodSignature: org.hibernate.boot.model.IdentifierGeneratorDefinition.Builder#getName\n methodBody: public String getName() {\nreturn name;\n}",
            "methodSignature: org.hibernate.boot.internal.InFlightMetadataCollectorImpl#getIdentifierGenerator\n methodBody: public IdentifierGeneratorDefinition getIdentifierGenerator(String name) {\nif(name == null){throw new IllegalArgumentException(\"null is not a valid generator name\");\n}return idGeneratorDefinitionMap.get(name);\n}",
            "methodSignature: org.hibernate.persister.collection.AbstractCollectionPersister#getIdentifierGenerator\n methodBody: public IdentifierGenerator getIdentifierGenerator() {\nreturn identifierGenerator;\n}",
            "methodSignature: org.hibernate.tuple.entity.EntityMetamodel#getSessionFactory\n methodBody: public SessionFactoryImplementor getSessionFactory() {\nreturn sessionFactory;\n}",
            "methodSignature: org.hibernate.engine.spi.SessionFactoryImplementor#getName\n methodBody: String getName();",
            "methodSignature: org.hibernate.engine.spi.SessionFactoryImplementor#getIdentifierGenerator\n methodBody: IdentifierGenerator getIdentifierGenerator(String rootEntityName);",
            "methodSignature: org.hibernate.engine.spi.SessionFactoryDelegatingImpl#getName\n methodBody: public String getName() {\nreturn delegate.getName();\n}",
            "methodSignature: org.hibernate.persister.entity.AbstractEntityPersister#getIdentifierGenerator\n methodBody: public IdentifierGenerator getIdentifierGenerator() throws HibernateException {\nreturn entityMetamodel.getIdentifierProperty().getIdentifierGenerator();\n}",
            "methodSignature: org.hibernate.query.sqm.mutation.internal.cte.CteInsertHandler#getEntityDescriptor\n methodBody: public EntityMappingType getEntityDescriptor() {\nreturn entityDescriptor;\n}",
            "methodSignature: org.hibernate.persister.entity.AbstractEntityPersister#getName\n methodBody: public String getName() {\nreturn getEntityName();\n}",
            "methodSignature: org.hibernate.engine.spi.SessionFactoryDelegatingImpl#getIdentifierGenerator\n methodBody: public IdentifierGenerator getIdentifierGenerator(String rootEntityName) {\nreturn delegate.getIdentifierGenerator(rootEntityName);\n}",
            "methodSignature: org.hibernate.mapping.SimpleValue#getIdentifierGenerator\n methodBody: public IdentifierGenerator getIdentifierGenerator() {\nreturn identifierGenerator;\n}",
            "methodSignature: org.hibernate.dialect.temptable.TemporaryTable#getEntityDescriptor\n methodBody: public EntityMappingType getEntityDescriptor() {\nreturn entityDescriptor;\n}",
            "methodSignature: org.hibernate.engine.spi.SessionFactoryImplementor#getSessionFactory\n methodBody: default SessionFactoryImplementor getSessionFactory() {\nreturn this;\n}",
            "methodSignature: org.hibernate.tuple.IdentifierAttribute#getIdentifierGenerator\n methodBody: IdentifierGenerator getIdentifierGenerator();",
            "methodSignature: org.hibernate.internal.SessionFactoryImpl#getName\n methodBody: public String getName() {\nreturn name;\n}",
            "methodSignature: org.hibernate.cfg.BinderHelper#getIdentifierGenerator\n methodBody: private static IdentifierGeneratorDefinition getIdentifierGenerator(\n\t\t\tString name,\n\t\t\tXProperty idXProperty,\n\t\t\tMap<String, IdentifierGeneratorDefinition> localGenerators,\n\t\t\tMetadataBuildingContext buildingContext) {\nif(localGenerators != null){final IdentifierGeneratorDefinition result=localGenerators.get(name);\nif(result != null){return result;\n}}final IdentifierGeneratorDefinition globalDefinition=buildingContext.getMetadataCollector().getIdentifierGenerator(name);\nif(globalDefinition != null){return globalDefinition;\n}log.debugf(\"Could not resolve explicit IdentifierGeneratorDefinition - using implicit interpretation (%s)\",name);\nfinal GeneratedValue generatedValueAnn=idXProperty.getAnnotation(GeneratedValue.class);\nif(generatedValueAnn == null){return new IdentifierGeneratorDefinition(\"assigned\",\"assigned\");\n}final IdGeneratorStrategyInterpreter generationInterpreter=buildingContext.getBuildingOptions().getIdGenerationTypeInterpreter();\nfinal GenerationType generationType=interpretGenerationType(generatedValueAnn);\nif(generationType == null || generationType == GenerationType.SEQUENCE){log.debugf(\"Building implicit sequence-based IdentifierGeneratorDefinition (%s)\",name);\nfinal IdentifierGeneratorDefinition.Builder builder=new IdentifierGeneratorDefinition.Builder();\ngenerationInterpreter.interpretSequenceGenerator(new SequenceGenerator(){\n  @Override public String name(){\n    return name;\n  }\n  @Override public String sequenceName(){\n    return \"\";\n  }\n  @Override public String catalog(){\n    return \"\";\n  }\n  @Override public String schema(){\n    return \"\";\n  }\n  @Override public int initialValue(){\n    return 1;\n  }\n  @Override public int allocationSize(){\n    return 50;\n  }\n  @Override public Class<? extends Annotation> annotationType(){\n    return SequenceGenerator.class;\n  }\n}\n,builder);\nreturn builder.build();\n}if(generationType == GenerationType.TABLE){log.debugf(\"Building implicit table-based IdentifierGeneratorDefinition (%s)\",name);\nfinal IdentifierGeneratorDefinition.Builder builder=new IdentifierGeneratorDefinition.Builder();\ngenerationInterpreter.interpretTableGenerator(new TableGenerator(){\n  @Override public String name(){\n    return name;\n  }\n  @Override public String table(){\n    return \"\";\n  }\n  @Override public int initialValue(){\n    return 0;\n  }\n  @Override public int allocationSize(){\n    return 50;\n  }\n  @Override public String catalog(){\n    return \"\";\n  }\n  @Override public String schema(){\n    return \"\";\n  }\n  @Override public String pkColumnName(){\n    return \"\";\n  }\n  @Override public String valueColumnName(){\n    return \"\";\n  }\n  @Override public String pkColumnValue(){\n    return \"\";\n  }\n  @Override public UniqueConstraint[] uniqueConstraints(){\n    return new UniqueConstraint[0];\n  }\n  @Override public Index[] indexes(){\n    return new Index[0];\n  }\n  @Override public Class<? extends Annotation> annotationType(){\n    return TableGenerator.class;\n  }\n}\n,builder);\nreturn builder.build();\n}final String strategyName;\nif(generationType == GenerationType.IDENTITY){strategyName=\"identity\";\n}{strategyName=generationInterpreter.determineGeneratorName(generationType,new GeneratorNameDeterminationContext(){\n  @Override public Class<?> getIdType(){\n    return buildingContext.getBootstrapContext().getReflectionManager().toClass(idXProperty.getType());\n  }\n  @Override public String getGeneratedValueGeneratorName(){\n    return generatedValueAnn.generator();\n  }\n}\n);\n}log.debugf(\"Building implicit generic IdentifierGeneratorDefinition (%s) : %s\",name,strategyName);\nreturn new IdentifierGeneratorDefinition(name,strategyName,Collections.singletonMap(IdentifierGenerator.GENERATOR_NAME,name));\n}",
            "methodSignature: org.hibernate.persister.entity.EntityPersister#getIdentifierGenerator\n methodBody: IdentifierGenerator getIdentifierGenerator();",
            "methodSignature: org.hibernate.tuple.entity.EntityMetamodel#getName\n methodBody: public String getName() {\nreturn name;\n}",
            "methodSignature: org.hibernate.boot.model.IdentifierGeneratorDefinition#getName\n methodBody: public String getName() {\nreturn name;\n}",
            "methodSignature: org.hibernate.engine.spi.SessionFactoryImplementor#getMappingMetamodel\n methodBody: default MappingMetamodelImplementor getMappingMetamodel() {\nreturn getRuntimeMetamodels().getMappingMetamodel();\n}",
            "methodSignature: org.hibernate.tuple.IdentifierProperty#getIdentifierGenerator\n methodBody: public IdentifierGenerator getIdentifierGenerator() {\nreturn identifierGenerator;\n}",
            "methodSignature: org.hibernate.persister.collection.AbstractCollectionPersister#getName\n methodBody: public String getName() {\nreturn getRole();\n}",
            "methodSignature: org.hibernate.persister.collection.CollectionPersister#getIdentifierGenerator\n methodBody: IdentifierGenerator getIdentifierGenerator();",
            "methodSignature: org.hibernate.internal.SessionFactoryImpl#getIdentifierGenerator\n methodBody: public IdentifierGenerator getIdentifierGenerator(String rootEntityName) {\nreturn identifierGenerators.get(rootEntityName);\n}"
        ],
        "sourceCodeAfterRefactoring": "@Test\n\tpublic void testNormalBoundary(SessionFactoryScope scope) {\n        final EntityPersister persister = scope.getSessionFactory()\n\t\t\t\t.getMappingMetamodel()\n\t\t\t\t.getEntityDescriptor(Entity.class.getName());\n\t\tassertThat( persister.getGenerator(), instanceOf( SequenceStyleGenerator.class ) );\n\n\t\tfinal SequenceStyleGenerator generator = (SequenceStyleGenerator) persister.getGenerator();\n\n\t\tfinal int count = 5;\n\n\t\tscope.inTransaction(\n\t\t\t\t(s) -> {\n\t\t\t\t\tfor ( int i = 0; i < count; i++ ) {\n\t\t\t\t\t\tfinal Entity entity = new Entity( \"\" + ( i + 1 ) );\n\t\t\t\t\t\ts.save( entity );\n\n\t\t\t\t\t\tlong expectedId = i + 1;\n\n\t\t\t\t\t\tassertEquals( expectedId, entity.getId().longValue() );\n\t\t\t\t\t\tassertEquals( expectedId, generator.getDatabaseStructure().getTimesAccessed() );\n\t\t\t\t\t\tassertEquals( expectedId, ( (BasicHolder) generator.getOptimizer()\n\t\t\t\t\t\t\t\t.getLastSourceValue() ).getActualLongValue() );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t);\n\t}\n",
        "diffSourceCode": "    38: \t@Test\n    39: \tpublic void testNormalBoundary(SessionFactoryScope scope) {\n    40:         final EntityPersister persister = scope.getSessionFactory()\n    41: \t\t\t\t.getMappingMetamodel()\n    42: \t\t\t\t.getEntityDescriptor(Entity.class.getName());\n-   43: \t\tassertThat( persister.getIdentifierGenerator(), instanceOf( SequenceStyleGenerator.class ) );\n+   43: \t\tassertThat( persister.getGenerator(), instanceOf( SequenceStyleGenerator.class ) );\n    44: \n-   45: \t\tfinal SequenceStyleGenerator generator = (SequenceStyleGenerator) persister.getIdentifierGenerator();\n+   45: \t\tfinal SequenceStyleGenerator generator = (SequenceStyleGenerator) persister.getGenerator();\n    46: \n    47: \t\tfinal int count = 5;\n    48: \n    49: \t\tscope.inTransaction(\n    50: \t\t\t\t(s) -> {\n    51: \t\t\t\t\tfor ( int i = 0; i < count; i++ ) {\n    52: \t\t\t\t\t\tfinal Entity entity = new Entity( \"\" + ( i + 1 ) );\n    53: \t\t\t\t\t\ts.save( entity );\n    54: \n    55: \t\t\t\t\t\tlong expectedId = i + 1;\n    56: \n    57: \t\t\t\t\t\tassertEquals( expectedId, entity.getId().longValue() );\n    58: \t\t\t\t\t\tassertEquals( expectedId, generator.getDatabaseStructure().getTimesAccessed() );\n    59: \t\t\t\t\t\tassertEquals( expectedId, ( (BasicHolder) generator.getOptimizer()\n    60: \t\t\t\t\t\t\t\t.getLastSourceValue() ).getActualLongValue() );\n    61: \t\t\t\t\t}\n    62: \t\t\t\t}\n    63: \t\t);\n    64: \t}\n",
        "uniqueId": "26e73937756de5781043f120905b71abe9398e5e_38_64_461_463_38_64",
        "moveFileExist": true,
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 11,
        "testResult": true,
        "coverageInfo": {
            "testMethod": {
                "missed": 0,
                "covered": 1
            }
        }
    },
    {
        "type": "Extract And Move Method",
        "description": "Extract And Move Method\tpublic getGenerator() : InMemoryGenerator extracted from public testNormalBoundary(scope SessionFactoryScope) : void in class org.hibernate.orm.test.idgen.enhanced.forcedtable.BasicForcedTableSequenceTest & moved to class org.hibernate.persister.entity.EntityPersister",
        "diffLocations": [
            {
                "filePath": "hibernate-core/src/test/java/org/hibernate/orm/test/idgen/enhanced/forcedtable/BasicForcedTableSequenceTest.java",
                "startLine": 34,
                "endLine": 59,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/test/java/org/hibernate/orm/test/idgen/enhanced/forcedtable/BasicForcedTableSequenceTest.java",
                "startLine": 34,
                "endLine": 59,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/test/java/org/hibernate/orm/test/idgen/enhanced/forcedtable/BasicForcedTableSequenceTest.java",
                "startLine": 461,
                "endLine": 463,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "@Test\n\tpublic void testNormalBoundary(SessionFactoryScope scope) {\n        final EntityPersister persister = scope.getSessionFactory()\n\t\t\t\t.getMappingMetamodel()\n\t\t\t\t.getEntityDescriptor(Entity.class.getName());\n\t\tassertThat( persister.getIdentifierGenerator(), instanceOf( SequenceStyleGenerator.class ) );\n\n\t\tfinal SequenceStyleGenerator generator = ( SequenceStyleGenerator ) persister.getIdentifierGenerator();\n\t\tassertThat( generator.getDatabaseStructure(), instanceOf( TableStructure.class ) );\n\t\tassertThat( generator.getOptimizer(), instanceOf( NoopOptimizer.class ) );\n\n\t\tscope.inTransaction(\n\t\t\t\t(session) -> {\n\t\t\t\t\tint count = 5;\n\n\t\t\t\t\tfor ( int i = 0; i < count; i++ ) {\n\t\t\t\t\t\tfinal Entity entity = new Entity( \"\" + ( i + 1 ) );\n\t\t\t\t\t\tsession.save( entity );\n\t\t\t\t\t\tlong expectedId = i + 1;\n\t\t\t\t\t\tassertEquals( expectedId, entity.getId().longValue() );\n\t\t\t\t\t\tassertEquals( expectedId, generator.getDatabaseStructure().getTimesAccessed() );\n\t\t\t\t\t\tassertEquals( expectedId, ( (BasicHolder) generator.getOptimizer().getLastSourceValue() ).getActualLongValue() );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t);\n\t}",
        "filePathBefore": "hibernate-core/src/test/java/org/hibernate/orm/test/idgen/enhanced/forcedtable/BasicForcedTableSequenceTest.java",
        "isPureRefactoring": true,
        "commitId": "26e73937756de5781043f120905b71abe9398e5e",
        "packageNameBefore": "org.hibernate.orm.test.idgen.enhanced.forcedtable",
        "classNameBefore": "org.hibernate.orm.test.idgen.enhanced.forcedtable.BasicForcedTableSequenceTest",
        "methodNameBefore": "org.hibernate.orm.test.idgen.enhanced.forcedtable.BasicForcedTableSequenceTest#testNormalBoundary",
        "invokedMethod": "methodSignature: org.hibernate.boot.model.IdentifierGeneratorDefinition.Builder#getName\n methodBody: public String getName() {\nreturn name;\n}\nmethodSignature: org.hibernate.boot.internal.InFlightMetadataCollectorImpl#getIdentifierGenerator\n methodBody: public IdentifierGeneratorDefinition getIdentifierGenerator(String name) {\nif(name == null){throw new IllegalArgumentException(\"null is not a valid generator name\");\n}return idGeneratorDefinitionMap.get(name);\n}\nmethodSignature: org.hibernate.persister.collection.AbstractCollectionPersister#getIdentifierGenerator\n methodBody: public IdentifierGenerator getIdentifierGenerator() {\nreturn identifierGenerator;\n}\nmethodSignature: org.hibernate.tuple.entity.EntityMetamodel#getSessionFactory\n methodBody: public SessionFactoryImplementor getSessionFactory() {\nreturn sessionFactory;\n}\nmethodSignature: org.hibernate.engine.spi.SessionFactoryImplementor#getName\n methodBody: String getName();\nmethodSignature: org.hibernate.engine.spi.SessionFactoryImplementor#getIdentifierGenerator\n methodBody: IdentifierGenerator getIdentifierGenerator(String rootEntityName);\nmethodSignature: org.hibernate.engine.spi.SessionFactoryDelegatingImpl#getName\n methodBody: public String getName() {\nreturn delegate.getName();\n}\nmethodSignature: org.hibernate.persister.entity.AbstractEntityPersister#getIdentifierGenerator\n methodBody: public IdentifierGenerator getIdentifierGenerator() throws HibernateException {\nreturn entityMetamodel.getIdentifierProperty().getIdentifierGenerator();\n}\nmethodSignature: org.hibernate.query.sqm.mutation.internal.cte.CteInsertHandler#getEntityDescriptor\n methodBody: public EntityMappingType getEntityDescriptor() {\nreturn entityDescriptor;\n}\nmethodSignature: org.hibernate.persister.entity.AbstractEntityPersister#getName\n methodBody: public String getName() {\nreturn getEntityName();\n}\nmethodSignature: org.hibernate.engine.spi.SessionFactoryDelegatingImpl#getIdentifierGenerator\n methodBody: public IdentifierGenerator getIdentifierGenerator(String rootEntityName) {\nreturn delegate.getIdentifierGenerator(rootEntityName);\n}\nmethodSignature: org.hibernate.mapping.SimpleValue#getIdentifierGenerator\n methodBody: public IdentifierGenerator getIdentifierGenerator() {\nreturn identifierGenerator;\n}\nmethodSignature: org.hibernate.dialect.temptable.TemporaryTable#getEntityDescriptor\n methodBody: public EntityMappingType getEntityDescriptor() {\nreturn entityDescriptor;\n}\nmethodSignature: org.hibernate.engine.spi.SessionFactoryImplementor#getSessionFactory\n methodBody: default SessionFactoryImplementor getSessionFactory() {\nreturn this;\n}\nmethodSignature: org.hibernate.tuple.IdentifierAttribute#getIdentifierGenerator\n methodBody: IdentifierGenerator getIdentifierGenerator();\nmethodSignature: org.hibernate.internal.SessionFactoryImpl#getName\n methodBody: public String getName() {\nreturn name;\n}\nmethodSignature: org.hibernate.cfg.BinderHelper#getIdentifierGenerator\n methodBody: private static IdentifierGeneratorDefinition getIdentifierGenerator(\n\t\t\tString name,\n\t\t\tXProperty idXProperty,\n\t\t\tMap<String, IdentifierGeneratorDefinition> localGenerators,\n\t\t\tMetadataBuildingContext buildingContext) {\nif(localGenerators != null){final IdentifierGeneratorDefinition result=localGenerators.get(name);\nif(result != null){return result;\n}}final IdentifierGeneratorDefinition globalDefinition=buildingContext.getMetadataCollector().getIdentifierGenerator(name);\nif(globalDefinition != null){return globalDefinition;\n}log.debugf(\"Could not resolve explicit IdentifierGeneratorDefinition - using implicit interpretation (%s)\",name);\nfinal GeneratedValue generatedValueAnn=idXProperty.getAnnotation(GeneratedValue.class);\nif(generatedValueAnn == null){return new IdentifierGeneratorDefinition(\"assigned\",\"assigned\");\n}final IdGeneratorStrategyInterpreter generationInterpreter=buildingContext.getBuildingOptions().getIdGenerationTypeInterpreter();\nfinal GenerationType generationType=interpretGenerationType(generatedValueAnn);\nif(generationType == null || generationType == GenerationType.SEQUENCE){log.debugf(\"Building implicit sequence-based IdentifierGeneratorDefinition (%s)\",name);\nfinal IdentifierGeneratorDefinition.Builder builder=new IdentifierGeneratorDefinition.Builder();\ngenerationInterpreter.interpretSequenceGenerator(new SequenceGenerator(){\n  @Override public String name(){\n    return name;\n  }\n  @Override public String sequenceName(){\n    return \"\";\n  }\n  @Override public String catalog(){\n    return \"\";\n  }\n  @Override public String schema(){\n    return \"\";\n  }\n  @Override public int initialValue(){\n    return 1;\n  }\n  @Override public int allocationSize(){\n    return 50;\n  }\n  @Override public Class<? extends Annotation> annotationType(){\n    return SequenceGenerator.class;\n  }\n}\n,builder);\nreturn builder.build();\n}if(generationType == GenerationType.TABLE){log.debugf(\"Building implicit table-based IdentifierGeneratorDefinition (%s)\",name);\nfinal IdentifierGeneratorDefinition.Builder builder=new IdentifierGeneratorDefinition.Builder();\ngenerationInterpreter.interpretTableGenerator(new TableGenerator(){\n  @Override public String name(){\n    return name;\n  }\n  @Override public String table(){\n    return \"\";\n  }\n  @Override public int initialValue(){\n    return 0;\n  }\n  @Override public int allocationSize(){\n    return 50;\n  }\n  @Override public String catalog(){\n    return \"\";\n  }\n  @Override public String schema(){\n    return \"\";\n  }\n  @Override public String pkColumnName(){\n    return \"\";\n  }\n  @Override public String valueColumnName(){\n    return \"\";\n  }\n  @Override public String pkColumnValue(){\n    return \"\";\n  }\n  @Override public UniqueConstraint[] uniqueConstraints(){\n    return new UniqueConstraint[0];\n  }\n  @Override public Index[] indexes(){\n    return new Index[0];\n  }\n  @Override public Class<? extends Annotation> annotationType(){\n    return TableGenerator.class;\n  }\n}\n,builder);\nreturn builder.build();\n}final String strategyName;\nif(generationType == GenerationType.IDENTITY){strategyName=\"identity\";\n}{strategyName=generationInterpreter.determineGeneratorName(generationType,new GeneratorNameDeterminationContext(){\n  @Override public Class<?> getIdType(){\n    return buildingContext.getBootstrapContext().getReflectionManager().toClass(idXProperty.getType());\n  }\n  @Override public String getGeneratedValueGeneratorName(){\n    return generatedValueAnn.generator();\n  }\n}\n);\n}log.debugf(\"Building implicit generic IdentifierGeneratorDefinition (%s) : %s\",name,strategyName);\nreturn new IdentifierGeneratorDefinition(name,strategyName,Collections.singletonMap(IdentifierGenerator.GENERATOR_NAME,name));\n}\nmethodSignature: org.hibernate.persister.entity.EntityPersister#getIdentifierGenerator\n methodBody: IdentifierGenerator getIdentifierGenerator();\nmethodSignature: org.hibernate.tuple.entity.EntityMetamodel#getName\n methodBody: public String getName() {\nreturn name;\n}\nmethodSignature: org.hibernate.boot.model.IdentifierGeneratorDefinition#getName\n methodBody: public String getName() {\nreturn name;\n}\nmethodSignature: org.hibernate.engine.spi.SessionFactoryImplementor#getMappingMetamodel\n methodBody: default MappingMetamodelImplementor getMappingMetamodel() {\nreturn getRuntimeMetamodels().getMappingMetamodel();\n}\nmethodSignature: org.hibernate.tuple.IdentifierProperty#getIdentifierGenerator\n methodBody: public IdentifierGenerator getIdentifierGenerator() {\nreturn identifierGenerator;\n}\nmethodSignature: org.hibernate.persister.collection.AbstractCollectionPersister#getName\n methodBody: public String getName() {\nreturn getRole();\n}\nmethodSignature: org.hibernate.persister.collection.CollectionPersister#getIdentifierGenerator\n methodBody: IdentifierGenerator getIdentifierGenerator();\nmethodSignature: org.hibernate.internal.SessionFactoryImpl#getIdentifierGenerator\n methodBody: public IdentifierGenerator getIdentifierGenerator(String rootEntityName) {\nreturn identifierGenerators.get(rootEntityName);\n}",
        "classSignatureBefore": "public class BasicForcedTableSequenceTest ",
        "methodNameBeforeSet": [
            "org.hibernate.orm.test.idgen.enhanced.forcedtable.BasicForcedTableSequenceTest#testNormalBoundary"
        ],
        "classNameBeforeSet": [
            "org.hibernate.orm.test.idgen.enhanced.forcedtable.BasicForcedTableSequenceTest"
        ],
        "classSignatureBeforeSet": [
            "public class BasicForcedTableSequenceTest "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Changes are within the Move Method refactoring mechanics\n",
                "description": "Move Method specific changes - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later\n * See the lgpl.txt file in the root directory or http://www.gnu.org/licenses/lgpl-2.1.html\n */\npackage org.hibernate.orm.test.idgen.enhanced.forcedtable;\n\n\nimport org.hibernate.id.IdentifierGeneratorHelper.BasicHolder;\nimport org.hibernate.id.enhanced.NoopOptimizer;\nimport org.hibernate.id.enhanced.SequenceStyleGenerator;\nimport org.hibernate.id.enhanced.TableStructure;\nimport org.hibernate.persister.entity.EntityPersister;\n\nimport org.hibernate.testing.orm.junit.DomainModel;\nimport org.hibernate.testing.orm.junit.SessionFactory;\nimport org.hibernate.testing.orm.junit.SessionFactoryScope;\n\nimport org.junit.jupiter.api.AfterEach;\nimport org.junit.jupiter.api.Test;\n\nimport static org.hamcrest.Matchers.instanceOf;\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertThat;\nimport static org.junit.Assert.assertTrue;\n\n@DomainModel(\n\t\txmlMappings = \"org/hibernate/orm/test/idgen/enhanced/forcedtable/Basic.hbm.xml\"\n)\n@SessionFactory\npublic class BasicForcedTableSequenceTest {\n\n\t@Test\n\tpublic void testNormalBoundary(SessionFactoryScope scope) {\n        final EntityPersister persister = scope.getSessionFactory()\n\t\t\t\t.getMappingMetamodel()\n\t\t\t\t.getEntityDescriptor(Entity.class.getName());\n\t\tassertThat( persister.getIdentifierGenerator(), instanceOf( SequenceStyleGenerator.class ) );\n\n\t\tfinal SequenceStyleGenerator generator = ( SequenceStyleGenerator ) persister.getIdentifierGenerator();\n\t\tassertThat( generator.getDatabaseStructure(), instanceOf( TableStructure.class ) );\n\t\tassertThat( generator.getOptimizer(), instanceOf( NoopOptimizer.class ) );\n\n\t\tscope.inTransaction(\n\t\t\t\t(session) -> {\n\t\t\t\t\tint count = 5;\n\n\t\t\t\t\tfor ( int i = 0; i < count; i++ ) {\n\t\t\t\t\t\tfinal Entity entity = new Entity( \"\" + ( i + 1 ) );\n\t\t\t\t\t\tsession.save( entity );\n\t\t\t\t\t\tlong expectedId = i + 1;\n\t\t\t\t\t\tassertEquals( expectedId, entity.getId().longValue() );\n\t\t\t\t\t\tassertEquals( expectedId, generator.getDatabaseStructure().getTimesAccessed() );\n\t\t\t\t\t\tassertEquals( expectedId, ( (BasicHolder) generator.getOptimizer().getLastSourceValue() ).getActualLongValue() );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t);\n\t}\n\n\t@AfterEach\n\tpublic void dropTestData(SessionFactoryScope scope) {\n\t\tscope.inTransaction(\n\t\t\t\t(session) -> session.createQuery( \"delete Entity\" ).executeUpdate()\n\t\t);\n\t}\n\n}\n",
        "filePathAfter": "hibernate-core/src/test/java/org/hibernate/orm/test/idgen/enhanced/forcedtable/BasicForcedTableSequenceTest.java",
        "sourceCodeAfterForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later\n * See the lgpl.txt file in the root directory or http://www.gnu.org/licenses/lgpl-2.1.html\n */\npackage org.hibernate.orm.test.idgen.enhanced.forcedtable;\n\n\nimport org.hibernate.id.IdentifierGeneratorHelper.BasicHolder;\nimport org.hibernate.id.enhanced.NoopOptimizer;\nimport org.hibernate.id.enhanced.SequenceStyleGenerator;\nimport org.hibernate.id.enhanced.TableStructure;\nimport org.hibernate.persister.entity.EntityPersister;\n\nimport org.hibernate.testing.orm.junit.DomainModel;\nimport org.hibernate.testing.orm.junit.SessionFactory;\nimport org.hibernate.testing.orm.junit.SessionFactoryScope;\n\nimport org.junit.jupiter.api.AfterEach;\nimport org.junit.jupiter.api.Test;\n\nimport static org.hamcrest.Matchers.instanceOf;\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertThat;\nimport static org.junit.Assert.assertTrue;\n\n@DomainModel(\n\t\txmlMappings = \"org/hibernate/orm/test/idgen/enhanced/forcedtable/Basic.hbm.xml\"\n)\n@SessionFactory\npublic class BasicForcedTableSequenceTest {\n\n\t@Test\n\tpublic void testNormalBoundary(SessionFactoryScope scope) {\n        final EntityPersister persister = scope.getSessionFactory()\n\t\t\t\t.getMappingMetamodel()\n\t\t\t\t.getEntityDescriptor(Entity.class.getName());\n\t\tassertThat( persister.getGenerator(), instanceOf( SequenceStyleGenerator.class ) );\n\n\t\tfinal SequenceStyleGenerator generator = (SequenceStyleGenerator) persister.getGenerator();\n\t\tassertThat( generator.getDatabaseStructure(), instanceOf( TableStructure.class ) );\n\t\tassertThat( generator.getOptimizer(), instanceOf( NoopOptimizer.class ) );\n\n\t\tscope.inTransaction(\n\t\t\t\t(session) -> {\n\t\t\t\t\tint count = 5;\n\n\t\t\t\t\tfor ( int i = 0; i < count; i++ ) {\n\t\t\t\t\t\tfinal Entity entity = new Entity( \"\" + ( i + 1 ) );\n\t\t\t\t\t\tsession.save( entity );\n\t\t\t\t\t\tlong expectedId = i + 1;\n\t\t\t\t\t\tassertEquals( expectedId, entity.getId().longValue() );\n\t\t\t\t\t\tassertEquals( expectedId, generator.getDatabaseStructure().getTimesAccessed() );\n\t\t\t\t\t\tassertEquals( expectedId, ( (BasicHolder) generator.getOptimizer().getLastSourceValue() ).getActualLongValue() );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t);\n\t}\n\n\t@AfterEach\n\tpublic void dropTestData(SessionFactoryScope scope) {\n\t\tscope.inTransaction(\n\t\t\t\t(session) -> session.createQuery( \"delete Entity\" ).executeUpdate()\n\t\t);\n\t}\n\n}\n",
        "diffSourceCodeSet": [
            ""
        ],
        "invokedMethodSet": [
            "methodSignature: org.hibernate.boot.model.IdentifierGeneratorDefinition.Builder#getName\n methodBody: public String getName() {\nreturn name;\n}",
            "methodSignature: org.hibernate.boot.internal.InFlightMetadataCollectorImpl#getIdentifierGenerator\n methodBody: public IdentifierGeneratorDefinition getIdentifierGenerator(String name) {\nif(name == null){throw new IllegalArgumentException(\"null is not a valid generator name\");\n}return idGeneratorDefinitionMap.get(name);\n}",
            "methodSignature: org.hibernate.persister.collection.AbstractCollectionPersister#getIdentifierGenerator\n methodBody: public IdentifierGenerator getIdentifierGenerator() {\nreturn identifierGenerator;\n}",
            "methodSignature: org.hibernate.tuple.entity.EntityMetamodel#getSessionFactory\n methodBody: public SessionFactoryImplementor getSessionFactory() {\nreturn sessionFactory;\n}",
            "methodSignature: org.hibernate.engine.spi.SessionFactoryImplementor#getName\n methodBody: String getName();",
            "methodSignature: org.hibernate.engine.spi.SessionFactoryImplementor#getIdentifierGenerator\n methodBody: IdentifierGenerator getIdentifierGenerator(String rootEntityName);",
            "methodSignature: org.hibernate.engine.spi.SessionFactoryDelegatingImpl#getName\n methodBody: public String getName() {\nreturn delegate.getName();\n}",
            "methodSignature: org.hibernate.persister.entity.AbstractEntityPersister#getIdentifierGenerator\n methodBody: public IdentifierGenerator getIdentifierGenerator() throws HibernateException {\nreturn entityMetamodel.getIdentifierProperty().getIdentifierGenerator();\n}",
            "methodSignature: org.hibernate.query.sqm.mutation.internal.cte.CteInsertHandler#getEntityDescriptor\n methodBody: public EntityMappingType getEntityDescriptor() {\nreturn entityDescriptor;\n}",
            "methodSignature: org.hibernate.persister.entity.AbstractEntityPersister#getName\n methodBody: public String getName() {\nreturn getEntityName();\n}",
            "methodSignature: org.hibernate.engine.spi.SessionFactoryDelegatingImpl#getIdentifierGenerator\n methodBody: public IdentifierGenerator getIdentifierGenerator(String rootEntityName) {\nreturn delegate.getIdentifierGenerator(rootEntityName);\n}",
            "methodSignature: org.hibernate.mapping.SimpleValue#getIdentifierGenerator\n methodBody: public IdentifierGenerator getIdentifierGenerator() {\nreturn identifierGenerator;\n}",
            "methodSignature: org.hibernate.dialect.temptable.TemporaryTable#getEntityDescriptor\n methodBody: public EntityMappingType getEntityDescriptor() {\nreturn entityDescriptor;\n}",
            "methodSignature: org.hibernate.engine.spi.SessionFactoryImplementor#getSessionFactory\n methodBody: default SessionFactoryImplementor getSessionFactory() {\nreturn this;\n}",
            "methodSignature: org.hibernate.tuple.IdentifierAttribute#getIdentifierGenerator\n methodBody: IdentifierGenerator getIdentifierGenerator();",
            "methodSignature: org.hibernate.internal.SessionFactoryImpl#getName\n methodBody: public String getName() {\nreturn name;\n}",
            "methodSignature: org.hibernate.cfg.BinderHelper#getIdentifierGenerator\n methodBody: private static IdentifierGeneratorDefinition getIdentifierGenerator(\n\t\t\tString name,\n\t\t\tXProperty idXProperty,\n\t\t\tMap<String, IdentifierGeneratorDefinition> localGenerators,\n\t\t\tMetadataBuildingContext buildingContext) {\nif(localGenerators != null){final IdentifierGeneratorDefinition result=localGenerators.get(name);\nif(result != null){return result;\n}}final IdentifierGeneratorDefinition globalDefinition=buildingContext.getMetadataCollector().getIdentifierGenerator(name);\nif(globalDefinition != null){return globalDefinition;\n}log.debugf(\"Could not resolve explicit IdentifierGeneratorDefinition - using implicit interpretation (%s)\",name);\nfinal GeneratedValue generatedValueAnn=idXProperty.getAnnotation(GeneratedValue.class);\nif(generatedValueAnn == null){return new IdentifierGeneratorDefinition(\"assigned\",\"assigned\");\n}final IdGeneratorStrategyInterpreter generationInterpreter=buildingContext.getBuildingOptions().getIdGenerationTypeInterpreter();\nfinal GenerationType generationType=interpretGenerationType(generatedValueAnn);\nif(generationType == null || generationType == GenerationType.SEQUENCE){log.debugf(\"Building implicit sequence-based IdentifierGeneratorDefinition (%s)\",name);\nfinal IdentifierGeneratorDefinition.Builder builder=new IdentifierGeneratorDefinition.Builder();\ngenerationInterpreter.interpretSequenceGenerator(new SequenceGenerator(){\n  @Override public String name(){\n    return name;\n  }\n  @Override public String sequenceName(){\n    return \"\";\n  }\n  @Override public String catalog(){\n    return \"\";\n  }\n  @Override public String schema(){\n    return \"\";\n  }\n  @Override public int initialValue(){\n    return 1;\n  }\n  @Override public int allocationSize(){\n    return 50;\n  }\n  @Override public Class<? extends Annotation> annotationType(){\n    return SequenceGenerator.class;\n  }\n}\n,builder);\nreturn builder.build();\n}if(generationType == GenerationType.TABLE){log.debugf(\"Building implicit table-based IdentifierGeneratorDefinition (%s)\",name);\nfinal IdentifierGeneratorDefinition.Builder builder=new IdentifierGeneratorDefinition.Builder();\ngenerationInterpreter.interpretTableGenerator(new TableGenerator(){\n  @Override public String name(){\n    return name;\n  }\n  @Override public String table(){\n    return \"\";\n  }\n  @Override public int initialValue(){\n    return 0;\n  }\n  @Override public int allocationSize(){\n    return 50;\n  }\n  @Override public String catalog(){\n    return \"\";\n  }\n  @Override public String schema(){\n    return \"\";\n  }\n  @Override public String pkColumnName(){\n    return \"\";\n  }\n  @Override public String valueColumnName(){\n    return \"\";\n  }\n  @Override public String pkColumnValue(){\n    return \"\";\n  }\n  @Override public UniqueConstraint[] uniqueConstraints(){\n    return new UniqueConstraint[0];\n  }\n  @Override public Index[] indexes(){\n    return new Index[0];\n  }\n  @Override public Class<? extends Annotation> annotationType(){\n    return TableGenerator.class;\n  }\n}\n,builder);\nreturn builder.build();\n}final String strategyName;\nif(generationType == GenerationType.IDENTITY){strategyName=\"identity\";\n}{strategyName=generationInterpreter.determineGeneratorName(generationType,new GeneratorNameDeterminationContext(){\n  @Override public Class<?> getIdType(){\n    return buildingContext.getBootstrapContext().getReflectionManager().toClass(idXProperty.getType());\n  }\n  @Override public String getGeneratedValueGeneratorName(){\n    return generatedValueAnn.generator();\n  }\n}\n);\n}log.debugf(\"Building implicit generic IdentifierGeneratorDefinition (%s) : %s\",name,strategyName);\nreturn new IdentifierGeneratorDefinition(name,strategyName,Collections.singletonMap(IdentifierGenerator.GENERATOR_NAME,name));\n}",
            "methodSignature: org.hibernate.persister.entity.EntityPersister#getIdentifierGenerator\n methodBody: IdentifierGenerator getIdentifierGenerator();",
            "methodSignature: org.hibernate.tuple.entity.EntityMetamodel#getName\n methodBody: public String getName() {\nreturn name;\n}",
            "methodSignature: org.hibernate.boot.model.IdentifierGeneratorDefinition#getName\n methodBody: public String getName() {\nreturn name;\n}",
            "methodSignature: org.hibernate.engine.spi.SessionFactoryImplementor#getMappingMetamodel\n methodBody: default MappingMetamodelImplementor getMappingMetamodel() {\nreturn getRuntimeMetamodels().getMappingMetamodel();\n}",
            "methodSignature: org.hibernate.tuple.IdentifierProperty#getIdentifierGenerator\n methodBody: public IdentifierGenerator getIdentifierGenerator() {\nreturn identifierGenerator;\n}",
            "methodSignature: org.hibernate.persister.collection.AbstractCollectionPersister#getName\n methodBody: public String getName() {\nreturn getRole();\n}",
            "methodSignature: org.hibernate.persister.collection.CollectionPersister#getIdentifierGenerator\n methodBody: IdentifierGenerator getIdentifierGenerator();",
            "methodSignature: org.hibernate.internal.SessionFactoryImpl#getIdentifierGenerator\n methodBody: public IdentifierGenerator getIdentifierGenerator(String rootEntityName) {\nreturn identifierGenerators.get(rootEntityName);\n}"
        ],
        "sourceCodeAfterRefactoring": "@Test\n\tpublic void testNormalBoundary(SessionFactoryScope scope) {\n        final EntityPersister persister = scope.getSessionFactory()\n\t\t\t\t.getMappingMetamodel()\n\t\t\t\t.getEntityDescriptor(Entity.class.getName());\n\t\tassertThat( persister.getGenerator(), instanceOf( SequenceStyleGenerator.class ) );\n\n\t\tfinal SequenceStyleGenerator generator = (SequenceStyleGenerator) persister.getGenerator();\n\t\tassertThat( generator.getDatabaseStructure(), instanceOf( TableStructure.class ) );\n\t\tassertThat( generator.getOptimizer(), instanceOf( NoopOptimizer.class ) );\n\n\t\tscope.inTransaction(\n\t\t\t\t(session) -> {\n\t\t\t\t\tint count = 5;\n\n\t\t\t\t\tfor ( int i = 0; i < count; i++ ) {\n\t\t\t\t\t\tfinal Entity entity = new Entity( \"\" + ( i + 1 ) );\n\t\t\t\t\t\tsession.save( entity );\n\t\t\t\t\t\tlong expectedId = i + 1;\n\t\t\t\t\t\tassertEquals( expectedId, entity.getId().longValue() );\n\t\t\t\t\t\tassertEquals( expectedId, generator.getDatabaseStructure().getTimesAccessed() );\n\t\t\t\t\t\tassertEquals( expectedId, ( (BasicHolder) generator.getOptimizer().getLastSourceValue() ).getActualLongValue() );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t);\n\t}\n",
        "diffSourceCode": "    34: \t@Test\n    35: \tpublic void testNormalBoundary(SessionFactoryScope scope) {\n    36:         final EntityPersister persister = scope.getSessionFactory()\n    37: \t\t\t\t.getMappingMetamodel()\n    38: \t\t\t\t.getEntityDescriptor(Entity.class.getName());\n-   39: \t\tassertThat( persister.getIdentifierGenerator(), instanceOf( SequenceStyleGenerator.class ) );\n+   39: \t\tassertThat( persister.getGenerator(), instanceOf( SequenceStyleGenerator.class ) );\n    40: \n-   41: \t\tfinal SequenceStyleGenerator generator = ( SequenceStyleGenerator ) persister.getIdentifierGenerator();\n+   41: \t\tfinal SequenceStyleGenerator generator = (SequenceStyleGenerator) persister.getGenerator();\n    42: \t\tassertThat( generator.getDatabaseStructure(), instanceOf( TableStructure.class ) );\n    43: \t\tassertThat( generator.getOptimizer(), instanceOf( NoopOptimizer.class ) );\n    44: \n    45: \t\tscope.inTransaction(\n    46: \t\t\t\t(session) -> {\n    47: \t\t\t\t\tint count = 5;\n    48: \n    49: \t\t\t\t\tfor ( int i = 0; i < count; i++ ) {\n    50: \t\t\t\t\t\tfinal Entity entity = new Entity( \"\" + ( i + 1 ) );\n    51: \t\t\t\t\t\tsession.save( entity );\n    52: \t\t\t\t\t\tlong expectedId = i + 1;\n    53: \t\t\t\t\t\tassertEquals( expectedId, entity.getId().longValue() );\n    54: \t\t\t\t\t\tassertEquals( expectedId, generator.getDatabaseStructure().getTimesAccessed() );\n    55: \t\t\t\t\t\tassertEquals( expectedId, ( (BasicHolder) generator.getOptimizer().getLastSourceValue() ).getActualLongValue() );\n    56: \t\t\t\t\t}\n    57: \t\t\t\t}\n    58: \t\t);\n    59: \t}\n",
        "uniqueId": "26e73937756de5781043f120905b71abe9398e5e_34_59_461_463_34_59",
        "moveFileExist": true,
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 11,
        "testResult": true,
        "coverageInfo": {
            "testMethod": {
                "missed": 0,
                "covered": 1
            }
        }
    },
    {
        "type": "Extract And Move Method",
        "description": "Extract And Move Method\tprotected handleParameterCreation(parameter ColumnValueParameter) : void extracted from protected createValueBinding(columnName String, columnWriteFragment String, jdbcMapping JdbcMapping, parameterUsage ParameterUsage) : ColumnValueBinding in class org.hibernate.sql.model.ast.builder.AbstractTableMutationBuilder & moved to class org.hibernate.sql.model.ast.builder.AbstractTableInsertBuilder",
        "diffLocations": [
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/sql/model/ast/builder/AbstractTableMutationBuilder.java",
                "startLine": 109,
                "endLine": 126,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/sql/model/ast/builder/AbstractTableMutationBuilder.java",
                "startLine": 102,
                "endLine": 119,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/sql/model/ast/builder/AbstractTableMutationBuilder.java",
                "startLine": 92,
                "endLine": 95,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "protected ColumnValueBinding createValueBinding(\n\t\t\tString columnName,\n\t\t\tString columnWriteFragment,\n\t\t\tJdbcMapping jdbcMapping,\n\t\t\tParameterUsage parameterUsage) {\n\t\tfinal ColumnReference columnReference = new ColumnReference( mutatingTable, columnName, jdbcMapping );\n\n\t\tfinal ColumnValueParameter parameter;\n\t\tif ( columnWriteFragment.contains( \"?\" ) ) {\n\t\t\tparameter = new ColumnValueParameter( columnReference, parameterUsage );\n\t\t\tparameters.add( parameter );\n\t\t}\n\t\telse {\n\t\t\tparameter = null;\n\t\t}\n\n\t\treturn new ColumnValueBinding( columnReference, new ColumnWriteFragment( columnWriteFragment, parameter, jdbcMapping ) );\n\t}",
        "filePathBefore": "hibernate-core/src/main/java/org/hibernate/sql/model/ast/builder/AbstractTableMutationBuilder.java",
        "isPureRefactoring": true,
        "commitId": "c04caa18de3c5ff81c17ebb151430b9cf18b6284",
        "packageNameBefore": "org.hibernate.sql.model.ast.builder",
        "classNameBefore": "org.hibernate.sql.model.ast.builder.AbstractTableMutationBuilder",
        "methodNameBefore": "org.hibernate.sql.model.ast.builder.AbstractTableMutationBuilder#createValueBinding",
        "classSignatureBefore": "public abstract class AbstractTableMutationBuilder<M extends TableMutation<?>> implements TableMutationBuilder<M> ",
        "methodNameBeforeSet": [
            "org.hibernate.sql.model.ast.builder.AbstractTableMutationBuilder#createValueBinding"
        ],
        "classNameBeforeSet": [
            "org.hibernate.sql.model.ast.builder.AbstractTableMutationBuilder"
        ],
        "classSignatureBeforeSet": [
            "public abstract class AbstractTableMutationBuilder<M extends TableMutation<?>> implements TableMutationBuilder<M> "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n * See the lgpl.txt file in the root directory or http://www.gnu.org/licenses/lgpl-2.1.html.\n */\npackage org.hibernate.sql.model.ast.builder;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.hibernate.engine.jdbc.mutation.ParameterUsage;\nimport org.hibernate.engine.jdbc.spi.JdbcServices;\nimport org.hibernate.engine.spi.SessionFactoryImplementor;\nimport org.hibernate.metamodel.mapping.JdbcMapping;\nimport org.hibernate.sql.ast.tree.expression.ColumnReference;\nimport org.hibernate.sql.model.MutationTarget;\nimport org.hibernate.sql.model.MutationType;\nimport org.hibernate.sql.model.TableMapping;\nimport org.hibernate.sql.model.ast.ColumnValueBinding;\nimport org.hibernate.sql.model.ast.ColumnValueParameter;\nimport org.hibernate.sql.model.ast.ColumnWriteFragment;\nimport org.hibernate.sql.model.ast.MutatingTableReference;\nimport org.hibernate.sql.model.ast.TableMutation;\n\n/**\n * Base support for TableMutationBuilder implementations\n *\n * @author Steve Ebersole\n */\npublic abstract class AbstractTableMutationBuilder<M extends TableMutation<?>> implements TableMutationBuilder<M> {\n\tprivate final SessionFactoryImplementor sessionFactory;\n\n\tprivate final MutationType mutationType;\n\tprivate final MutationTarget<?> mutationTarget;\n\n\tprivate final MutatingTableReference mutatingTable;\n\n\tprivate final List<ColumnValueParameter> parameters = new ArrayList<>();\n\n\n\tpublic AbstractTableMutationBuilder(\n\t\t\tMutationType mutationType,\n\t\t\tMutationTarget<?> mutationTarget,\n\t\t\tTableMapping table,\n\t\t\tSessionFactoryImplementor sessionFactory) {\n\t\tthis( mutationType, mutationTarget, new MutatingTableReference( table ), sessionFactory );\n\t}\n\n\tpublic AbstractTableMutationBuilder(\n\t\t\tMutationType mutationType,\n\t\t\tMutationTarget<?> mutationTarget,\n\t\t\tMutatingTableReference mutatingTable,\n\t\t\tSessionFactoryImplementor sessionFactory) {\n\t\tthis.mutationType = mutationType;\n\t\tthis.mutationTarget = mutationTarget;\n\t\tthis.sessionFactory = sessionFactory;\n\n\t\tthis.mutatingTable = mutatingTable;\n\t}\n\n\tprotected MutationTarget<?> getMutationTarget() {\n\t\treturn mutationTarget;\n\t}\n\n\t@Override\n\tpublic MutatingTableReference getMutatingTable() {\n\t\treturn mutatingTable;\n\t}\n\n\tprotected SessionFactoryImplementor getSessionFactory() {\n\t\treturn sessionFactory;\n\t}\n\n\tprotected JdbcServices getJdbcServices() {\n\t\treturn sessionFactory.getJdbcServices();\n\t}\n\n\tprotected List<ColumnValueParameter> getParameters() {\n\t\treturn parameters;\n\t}\n\n\tprotected void addColumn(\n\t\t\tString columnName,\n\t\t\tString columnWriteFragment,\n\t\t\tJdbcMapping jdbcMapping,\n\t\t\tList<ColumnValueBinding> list) {\n\t\tfinal ColumnValueBinding valueBinding = createValueBinding( columnName, columnWriteFragment, jdbcMapping );\n\t\tlist.add( valueBinding );\n\t}\n\n\tprotected void addColumn(\n\t\t\tString columnName,\n\t\t\tString columnWriteFragment,\n\t\t\tJdbcMapping jdbcMapping,\n\t\t\tParameterUsage parameterUsage,\n\t\t\tList<ColumnValueBinding> list) {\n\t\tfinal ColumnValueBinding valueBinding = createValueBinding( columnName, columnWriteFragment, jdbcMapping, parameterUsage );\n\t\tlist.add( valueBinding );\n\t}\n\n\tprotected ColumnValueBinding createValueBinding(\n\t\t\tString columnName,\n\t\t\tString columnWriteFragment,\n\t\t\tJdbcMapping jdbcMapping) {\n\t\treturn createValueBinding( columnName, columnWriteFragment, jdbcMapping, ParameterUsage.SET );\n\t}\n\n\tprotected ColumnValueBinding createValueBinding(\n\t\t\tString columnName,\n\t\t\tString columnWriteFragment,\n\t\t\tJdbcMapping jdbcMapping,\n\t\t\tParameterUsage parameterUsage) {\n\t\tfinal ColumnReference columnReference = new ColumnReference( mutatingTable, columnName, jdbcMapping );\n\n\t\tfinal ColumnValueParameter parameter;\n\t\tif ( columnWriteFragment.contains( \"?\" ) ) {\n\t\t\tparameter = new ColumnValueParameter( columnReference, parameterUsage );\n\t\t\tparameters.add( parameter );\n\t\t}\n\t\telse {\n\t\t\tparameter = null;\n\t\t}\n\n\t\treturn new ColumnValueBinding( columnReference, new ColumnWriteFragment( columnWriteFragment, parameter, jdbcMapping ) );\n\t}\n\n\t@SafeVarargs\n\tprotected final <T> List<T> combine(List<T> list1, List<T>... additionalLists) {\n\t\tfinal ArrayList<T> combined = list1 == null\n\t\t\t\t? new ArrayList<>()\n\t\t\t\t: new ArrayList<>( list1 );\n\n\t\tif ( additionalLists != null ) {\n\t\t\tfor ( int i = 0; i < additionalLists.length; i++ ) {\n\t\t\t\tif ( additionalLists[i] == null ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tcombined.addAll( additionalLists[i] );\n\t\t\t}\n\t\t}\n\n\t\treturn combined;\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn \"TableMutationBuilder( \" + mutationType + \" - `\" + mutatingTable.getTableName() + \"`)\";\n\t}\n}\n",
        "filePathAfter": "hibernate-core/src/main/java/org/hibernate/sql/model/ast/builder/AbstractTableMutationBuilder.java",
        "sourceCodeAfterForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n * See the lgpl.txt file in the root directory or http://www.gnu.org/licenses/lgpl-2.1.html.\n */\npackage org.hibernate.sql.model.ast.builder;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.hibernate.engine.jdbc.mutation.ParameterUsage;\nimport org.hibernate.engine.jdbc.spi.JdbcServices;\nimport org.hibernate.engine.spi.SessionFactoryImplementor;\nimport org.hibernate.metamodel.mapping.JdbcMapping;\nimport org.hibernate.sql.ast.tree.expression.ColumnReference;\nimport org.hibernate.sql.model.MutationTarget;\nimport org.hibernate.sql.model.MutationType;\nimport org.hibernate.sql.model.TableMapping;\nimport org.hibernate.sql.model.ast.ColumnValueBinding;\nimport org.hibernate.sql.model.ast.ColumnValueParameter;\nimport org.hibernate.sql.model.ast.ColumnWriteFragment;\nimport org.hibernate.sql.model.ast.MutatingTableReference;\nimport org.hibernate.sql.model.ast.TableMutation;\n\n/**\n * Base support for TableMutationBuilder implementations\n *\n * @author Steve Ebersole\n */\npublic abstract class AbstractTableMutationBuilder<M extends TableMutation<?>> implements TableMutationBuilder<M> {\n\tprivate final SessionFactoryImplementor sessionFactory;\n\n\tprivate final MutationType mutationType;\n\tprivate final MutationTarget<?> mutationTarget;\n\n\tprivate final MutatingTableReference mutatingTable;\n\n\tpublic AbstractTableMutationBuilder(\n\t\t\tMutationType mutationType,\n\t\t\tMutationTarget<?> mutationTarget,\n\t\t\tTableMapping table,\n\t\t\tSessionFactoryImplementor sessionFactory) {\n\t\tthis( mutationType, mutationTarget, new MutatingTableReference( table ), sessionFactory );\n\t}\n\n\tpublic AbstractTableMutationBuilder(\n\t\t\tMutationType mutationType,\n\t\t\tMutationTarget<?> mutationTarget,\n\t\t\tMutatingTableReference mutatingTable,\n\t\t\tSessionFactoryImplementor sessionFactory) {\n\t\tthis.mutationType = mutationType;\n\t\tthis.mutationTarget = mutationTarget;\n\t\tthis.sessionFactory = sessionFactory;\n\n\t\tthis.mutatingTable = mutatingTable;\n\t}\n\n\tprotected MutationTarget<?> getMutationTarget() {\n\t\treturn mutationTarget;\n\t}\n\n\t@Override\n\tpublic MutatingTableReference getMutatingTable() {\n\t\treturn mutatingTable;\n\t}\n\n\tprotected SessionFactoryImplementor getSessionFactory() {\n\t\treturn sessionFactory;\n\t}\n\n\tprotected JdbcServices getJdbcServices() {\n\t\treturn sessionFactory.getJdbcServices();\n\t}\n\n\tprotected void addColumn(\n\t\t\tString columnName,\n\t\t\tString columnWriteFragment,\n\t\t\tJdbcMapping jdbcMapping,\n\t\t\tList<ColumnValueBinding> list) {\n\t\tfinal ColumnValueBinding valueBinding = createValueBinding( columnName, columnWriteFragment, jdbcMapping );\n\t\tlist.add( valueBinding );\n\t}\n\n\tprotected void addColumn(\n\t\t\tString columnName,\n\t\t\tString columnWriteFragment,\n\t\t\tJdbcMapping jdbcMapping,\n\t\t\tParameterUsage parameterUsage,\n\t\t\tList<ColumnValueBinding> list) {\n\t\tfinal ColumnValueBinding valueBinding = createValueBinding( columnName, columnWriteFragment, jdbcMapping, parameterUsage );\n\t\tlist.add( valueBinding );\n\t}\n\n\tprotected ColumnValueBinding createValueBinding(\n\t\t\tString columnName,\n\t\t\tString columnWriteFragment,\n\t\t\tJdbcMapping jdbcMapping) {\n\t\treturn createValueBinding( columnName, columnWriteFragment, jdbcMapping, ParameterUsage.SET );\n\t}\n\n\tprotected ColumnValueBinding createValueBinding(\n\t\t\tString columnName,\n\t\t\tString columnWriteFragment,\n\t\t\tJdbcMapping jdbcMapping,\n\t\t\tParameterUsage parameterUsage) {\n\t\tfinal ColumnReference columnReference = new ColumnReference( mutatingTable, columnName, jdbcMapping );\n\n\t\tfinal ColumnValueParameter parameter;\n\t\tif ( columnWriteFragment.contains( \"?\" ) ) {\n\t\t\tparameter = new ColumnValueParameter( columnReference, parameterUsage );\n\t\t\thandleParameterCreation( parameter );\n\t\t}\n\t\telse {\n\t\t\tparameter = null;\n\t\t}\n\n\t\treturn new ColumnValueBinding( columnReference, new ColumnWriteFragment( columnWriteFragment, parameter, jdbcMapping ) );\n\t}\n\n\tprotected abstract void handleParameterCreation(ColumnValueParameter parameter);\n\n\t@SafeVarargs\n\tprotected final <T> List<T> combine(List<T> list1, List<T>... additionalLists) {\n\t\tfinal ArrayList<T> combined = list1 == null\n\t\t\t\t? new ArrayList<>()\n\t\t\t\t: new ArrayList<>( list1 );\n\n\t\tif ( additionalLists != null ) {\n\t\t\tfor ( int i = 0; i < additionalLists.length; i++ ) {\n\t\t\t\tif ( additionalLists[i] == null ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tcombined.addAll( additionalLists[i] );\n\t\t\t}\n\t\t}\n\n\t\treturn combined;\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn \"TableMutationBuilder( \" + mutationType + \" - `\" + mutatingTable.getTableName() + \"`)\";\n\t}\n}\n",
        "diffSourceCodeSet": [
            "list.add( valueBinding );\n\t}\n\n\tprotected ColumnValueBinding createValueBinding("
        ],
        "invokedMethodSet": [],
        "sourceCodeAfterRefactoring": "protected ColumnValueBinding createValueBinding(\n\t\t\tString columnName,\n\t\t\tString columnWriteFragment,\n\t\t\tJdbcMapping jdbcMapping,\n\t\t\tParameterUsage parameterUsage) {\n\t\tfinal ColumnReference columnReference = new ColumnReference( mutatingTable, columnName, jdbcMapping );\n\n\t\tfinal ColumnValueParameter parameter;\n\t\tif ( columnWriteFragment.contains( \"?\" ) ) {\n\t\t\tparameter = new ColumnValueParameter( columnReference, parameterUsage );\n\t\t\thandleParameterCreation( parameter );\n\t\t}\n\t\telse {\n\t\t\tparameter = null;\n\t\t}\n\n\t\treturn new ColumnValueBinding( columnReference, new ColumnWriteFragment( columnWriteFragment, parameter, jdbcMapping ) );\n\t}\nlist.add( valueBinding );\n\t}\n\n\tprotected ColumnValueBinding createValueBinding(",
        "diffSourceCode": "-   92: \tprotected void addColumn(\n-   93: \t\t\tString columnName,\n-   94: \t\t\tString columnWriteFragment,\n-   95: \t\t\tJdbcMapping jdbcMapping,\n+   92: \t\tlist.add( valueBinding );\n+   93: \t}\n+   94: \n+   95: \tprotected ColumnValueBinding createValueBinding(\n   102: \tprotected ColumnValueBinding createValueBinding(\n   103: \t\t\tString columnName,\n   104: \t\t\tString columnWriteFragment,\n-  105: \t\t\tJdbcMapping jdbcMapping) {\n-  106: \t\treturn createValueBinding( columnName, columnWriteFragment, jdbcMapping, ParameterUsage.SET );\n-  107: \t}\n+  105: \t\t\tJdbcMapping jdbcMapping,\n+  106: \t\t\tParameterUsage parameterUsage) {\n+  107: \t\tfinal ColumnReference columnReference = new ColumnReference( mutatingTable, columnName, jdbcMapping );\n   108: \n-  109: \tprotected ColumnValueBinding createValueBinding(\n-  110: \t\t\tString columnName,\n-  111: \t\t\tString columnWriteFragment,\n-  112: \t\t\tJdbcMapping jdbcMapping,\n-  113: \t\t\tParameterUsage parameterUsage) {\n-  114: \t\tfinal ColumnReference columnReference = new ColumnReference( mutatingTable, columnName, jdbcMapping );\n-  115: \n-  116: \t\tfinal ColumnValueParameter parameter;\n-  117: \t\tif ( columnWriteFragment.contains( \"?\" ) ) {\n-  118: \t\t\tparameter = new ColumnValueParameter( columnReference, parameterUsage );\n-  119: \t\t\tparameters.add( parameter );\n-  120: \t\t}\n-  121: \t\telse {\n-  122: \t\t\tparameter = null;\n-  123: \t\t}\n-  124: \n-  125: \t\treturn new ColumnValueBinding( columnReference, new ColumnWriteFragment( columnWriteFragment, parameter, jdbcMapping ) );\n-  126: \t}\n+  109: \t\tfinal ColumnValueParameter parameter;\n+  110: \t\tif ( columnWriteFragment.contains( \"?\" ) ) {\n+  111: \t\t\tparameter = new ColumnValueParameter( columnReference, parameterUsage );\n+  112: \t\t\thandleParameterCreation( parameter );\n+  113: \t\t}\n+  114: \t\telse {\n+  115: \t\t\tparameter = null;\n+  116: \t\t}\n+  117: \n+  118: \t\treturn new ColumnValueBinding( columnReference, new ColumnWriteFragment( columnWriteFragment, parameter, jdbcMapping ) );\n+  119: \t}\n+  120: \n+  121: \tprotected abstract void handleParameterCreation(ColumnValueParameter parameter);\n+  122: \n+  123: \t@SafeVarargs\n+  124: \tprotected final <T> List<T> combine(List<T> list1, List<T>... additionalLists) {\n+  125: \t\tfinal ArrayList<T> combined = list1 == null\n+  126: \t\t\t\t? new ArrayList<>()\n",
        "uniqueId": "c04caa18de3c5ff81c17ebb151430b9cf18b6284_109_126_92_95_102_119",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 0,
                "covered": 37
            },
            "BRANCH": {
                "missed": 0,
                "covered": 2
            },
            "LINE": {
                "missed": 0,
                "covered": 6
            },
            "COMPLEXITY": {
                "missed": 0,
                "covered": 2
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 11
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprivate advanceToLast() : boolean extracted from public last(rowProcessingState RowProcessingState) : boolean in class org.hibernate.sql.results.jdbc.internal.JdbcValuesResultSetImpl",
        "diffLocations": [
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/sql/results/jdbc/internal/JdbcValuesResultSetImpl.java",
                "startLine": 249,
                "endLine": 266,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/sql/results/jdbc/internal/JdbcValuesResultSetImpl.java",
                "startLine": 198,
                "endLine": 201,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/sql/results/jdbc/internal/JdbcValuesResultSetImpl.java",
                "startLine": 212,
                "endLine": 219,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "@Override\n\tpublic boolean last(RowProcessingState rowProcessingState) {\n\t\treturn advance(\n\t\t\t\t() -> {\n\t\t\t\t\ttry {\n\t\t\t\t\t\t//noinspection RedundantIfStatement\n\t\t\t\t\t\tif ( ! resultSetAccess.getResultSet().last() ) {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\tcatch (SQLException e) {\n\t\t\t\t\t\tthrow makeExecutionException( \"Error advancing (last) ResultSet position\", e );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t);\n\t}",
        "filePathBefore": "hibernate-core/src/main/java/org/hibernate/sql/results/jdbc/internal/JdbcValuesResultSetImpl.java",
        "isPureRefactoring": true,
        "commitId": "c7bd022b075647bee8fd4695595a29334e036d78",
        "packageNameBefore": "org.hibernate.sql.results.jdbc.internal",
        "classNameBefore": "org.hibernate.sql.results.jdbc.internal.JdbcValuesResultSetImpl",
        "methodNameBefore": "org.hibernate.sql.results.jdbc.internal.JdbcValuesResultSetImpl#last",
        "invokedMethod": "methodSignature: org.hibernate.sql.results.jdbc.internal.JdbcValuesResultSetImpl.Advancer#advance\n methodBody: boolean advance();\nmethodSignature: org.hibernate.sql.results.jdbc.internal.JdbcValuesResultSetImpl#last\n methodBody: public boolean last(RowProcessingState rowProcessingState) {\nreturn advance(() -> {\n  try {\n    if (!resultSetAccess.getResultSet().last()) {\n      return false;\n    }\n    return true;\n  }\n catch (  SQLException e) {\n    throw makeExecutionException(\"Error advancing (last) ResultSet position\",e);\n  }\n}\n);\n}\nmethodSignature: org.hibernate.sql.results.jdbc.internal.JdbcValuesResultSetImpl#advance\n methodBody: private boolean advance(Advancer advancer) {\nfinal boolean hasResult=advancer.advance();\nif(!hasResult){return false;\n}readCurrentRowValues();\nreturn true;\n}\nmethodSignature: org.hibernate.sql.results.jdbc.internal.JdbcValuesResultSetImpl#makeExecutionException\n methodBody: private ExecutionException makeExecutionException(String message, SQLException cause) {\nreturn new ExecutionException(message,executionContext.getSession().getJdbcServices().getSqlExceptionHelper().convert(cause,message));\n}",
        "classSignatureBefore": "public class JdbcValuesResultSetImpl extends AbstractJdbcValues ",
        "methodNameBeforeSet": [
            "org.hibernate.sql.results.jdbc.internal.JdbcValuesResultSetImpl#last"
        ],
        "classNameBeforeSet": [
            "org.hibernate.sql.results.jdbc.internal.JdbcValuesResultSetImpl"
        ],
        "classSignatureBeforeSet": [
            "public class JdbcValuesResultSetImpl extends AbstractJdbcValues "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Changes are within the Extract Method refactoring mechanics Severe changes",
                "description": "Return expression has been added within the Extract Method mechanics - with non-mapped leaves",
                "mappingState": 2
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later\n * See the lgpl.txt file in the root directory or http://www.gnu.org/licenses/lgpl-2.1.html\n */\npackage org.hibernate.sql.results.jdbc.internal;\n\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.Arrays;\n\nimport org.hibernate.HibernateException;\nimport org.hibernate.cache.spi.QueryKey;\nimport org.hibernate.cache.spi.QueryResultsCache;\nimport org.hibernate.engine.spi.SessionFactoryImplementor;\nimport org.hibernate.engine.spi.SharedSessionContractImplementor;\nimport org.hibernate.query.spi.QueryOptions;\nimport org.hibernate.sql.ast.spi.SqlSelection;\nimport org.hibernate.sql.exec.ExecutionException;\nimport org.hibernate.sql.exec.spi.ExecutionContext;\nimport org.hibernate.sql.results.caching.QueryCachePutManager;\nimport org.hibernate.sql.results.caching.internal.QueryCachePutManagerDisabledImpl;\nimport org.hibernate.sql.results.caching.internal.QueryCachePutManagerEnabledImpl;\nimport org.hibernate.sql.results.jdbc.spi.JdbcValuesMapping;\nimport org.hibernate.sql.results.jdbc.spi.JdbcValuesMetadata;\nimport org.hibernate.sql.results.jdbc.spi.RowProcessingState;\n\n/**\n * JdbcValuesSource implementation for a JDBC ResultSet as the source\n *\n * @author Steve Ebersole\n */\npublic class JdbcValuesResultSetImpl extends AbstractJdbcValues {\n\n\tprivate final ResultSetAccess resultSetAccess;\n\tprivate final JdbcValuesMapping valuesMapping;\n\tprivate final ExecutionContext executionContext;\n\n\tprivate final SqlSelection[] sqlSelections;\n\tprivate final Object[] currentRowJdbcValues;\n\n\tpublic JdbcValuesResultSetImpl(\n\t\t\tResultSetAccess resultSetAccess,\n\t\t\tQueryKey queryCacheKey,\n\t\t\tString queryIdentifier,\n\t\t\tQueryOptions queryOptions,\n\t\t\tJdbcValuesMapping valuesMapping,\n\t\t\tJdbcValuesMetadata metadataForCache,\n\t\t\tExecutionContext executionContext) {\n\t\tsuper( resolveQueryCachePutManager( executionContext, queryOptions, queryCacheKey, queryIdentifier, metadataForCache ) );\n\t\tthis.resultSetAccess = resultSetAccess;\n\t\tthis.valuesMapping = valuesMapping;\n\t\tthis.executionContext = executionContext;\n\n\t\tthis.sqlSelections = valuesMapping.getSqlSelections().toArray( new SqlSelection[0] );\n\t\tthis.currentRowJdbcValues = new Object[ valuesMapping.getRowSize() ];\n\t}\n\n\tprivate static QueryCachePutManager resolveQueryCachePutManager(\n\t\t\tExecutionContext executionContext,\n\t\t\tQueryOptions queryOptions,\n\t\t\tQueryKey queryCacheKey,\n\t\t\tString queryIdentifier,\n\t\t\tJdbcValuesMetadata metadataForCache) {\n\t\tif ( queryCacheKey != null ) {\n\t\t\tfinal SessionFactoryImplementor factory = executionContext.getSession().getFactory();\n\t\t\tfinal QueryResultsCache queryCache = factory.getCache()\n\t\t\t\t\t.getQueryResultsCache( queryOptions.getResultCacheRegionName() );\n\t\t\treturn new QueryCachePutManagerEnabledImpl(\n\t\t\t\t\tqueryCache,\n\t\t\t\t\tfactory.getStatistics(),\n\t\t\t\t\tqueryCacheKey,\n\t\t\t\t\tqueryIdentifier,\n\t\t\t\t\tmetadataForCache\n\t\t\t);\n\t\t}\n\t\telse {\n\t\t\treturn QueryCachePutManagerDisabledImpl.INSTANCE;\n\t\t}\n\t}\n\n\t@Override\n\tprotected final boolean processNext(RowProcessingState rowProcessingState) {\n\t\treturn advance(\n\t\t\t\t() -> {\n\t\t\t\t\ttry {\n\t\t\t\t\t\t//noinspection RedundantIfStatement\n\t\t\t\t\t\tif ( ! resultSetAccess.getResultSet().next() ) {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\tcatch (SQLException e) {\n\t\t\t\t\t\tthrow makeExecutionException( \"Error advancing (next) ResultSet position\", e );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t);\n\t}\n\n\t@Override\n\tprotected boolean processPrevious(RowProcessingState rowProcessingState) {\n\t\treturn advance(\n\t\t\t\t() -> {\n\t\t\t\t\ttry {\n\t\t\t\t\t\t//noinspection RedundantIfStatement\n\t\t\t\t\t\tif ( ! resultSetAccess.getResultSet().previous() ) {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\tcatch (SQLException e) {\n\t\t\t\t\t\tthrow makeExecutionException( \"Error advancing (previous) ResultSet position\", e );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t);\n\t}\n\n\t@Override\n\tprotected boolean processScroll(int numberOfRows, RowProcessingState rowProcessingState) {\n\t\treturn advance(\n\t\t\t\t() -> {\n\t\t\t\t\ttry {\n\t\t\t\t\t\t//noinspection RedundantIfStatement\n\t\t\t\t\t\tif ( ! resultSetAccess.getResultSet().relative( numberOfRows ) ) {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\tcatch (SQLException e) {\n\t\t\t\t\t\tthrow makeExecutionException( \"Error advancing (scroll) ResultSet position\", e );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t);\n\t}\n\n\t@Override\n\tpublic int getPosition() {\n\t\ttry {\n\t\t\treturn resultSetAccess.getResultSet().getRow() - 1;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow makeExecutionException( \"Error calling ResultSet#getRow\", e );\n\t\t}\n\t}\n\n\t@Override\n\tprotected boolean processPosition(int position, RowProcessingState rowProcessingState) {\n\t\treturn advance(\n\t\t\t\t() -> {\n\t\t\t\t\ttry {\n\t\t\t\t\t\t//noinspection RedundantIfStatement\n\t\t\t\t\t\tif ( ! resultSetAccess.getResultSet().absolute( position ) ) {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\tcatch (SQLException e) {\n\t\t\t\t\t\tthrow makeExecutionException( \"Error advancing (scroll) ResultSet position\", e );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t);\n\t}\n\n\t@Override\n\tpublic boolean isBeforeFirst(RowProcessingState rowProcessingState) {\n\t\ttry {\n\t\t\treturn resultSetAccess.getResultSet().isBeforeFirst();\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow makeExecutionException( \"Error calling ResultSet#isBeforeFirst()\", e );\n\t\t}\n\t}\n\n\t@Override\n\tpublic void beforeFirst(RowProcessingState rowProcessingState) {\n\t\ttry {\n\t\t\tresultSetAccess.getResultSet().beforeFirst();\n\t\t\tArrays.fill( currentRowJdbcValues, null );\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow makeExecutionException( \"Error calling ResultSet#beforeFirst()\", e );\n\t\t}\n\t}\n\n\t@Override\n\tpublic boolean isFirst(RowProcessingState rowProcessingState) {\n\t\ttry {\n\t\t\treturn resultSetAccess.getResultSet().isFirst();\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow makeExecutionException( \"Error calling ResultSet#isFirst()\", e );\n\t\t}\n\t}\n\n\t@Override\n\tpublic boolean first(RowProcessingState rowProcessingState) {\n\t\treturn advance(\n\t\t\t\t() -> {\n\t\t\t\t\ttry {\n\t\t\t\t\t\t//noinspection RedundantIfStatement\n\t\t\t\t\t\tif ( ! resultSetAccess.getResultSet().first() ) {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\tcatch (SQLException e) {\n\t\t\t\t\t\tthrow makeExecutionException( \"Error advancing (first) ResultSet position\", e );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t);\n\t}\n\n\t@Override\n\tpublic boolean isAfterLast(RowProcessingState rowProcessingState) {\n\t\ttry {\n\t\t\treturn resultSetAccess.getResultSet().isAfterLast();\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow makeExecutionException( \"Error calling ResultSet#isAfterLast()\", e );\n\t\t}\n\t}\n\n\t@Override\n\tpublic void afterLast(RowProcessingState rowProcessingState) {\n\t\ttry {\n\t\t\tresultSetAccess.getResultSet().afterLast();\n\t\t\tArrays.fill( currentRowJdbcValues, null );\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow makeExecutionException( \"Error calling ResultSet#afterLast()\", e );\n\t\t}\n\t}\n\n\t@Override\n\tpublic boolean isLast(RowProcessingState rowProcessingState) {\n\t\ttry {\n\t\t\treturn resultSetAccess.getResultSet().isLast();\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow makeExecutionException( \"Error calling ResultSet#isLast()\", e );\n\t\t}\n\t}\n\n\t@Override\n\tpublic boolean last(RowProcessingState rowProcessingState) {\n\t\treturn advance(\n\t\t\t\t() -> {\n\t\t\t\t\ttry {\n\t\t\t\t\t\t//noinspection RedundantIfStatement\n\t\t\t\t\t\tif ( ! resultSetAccess.getResultSet().last() ) {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\tcatch (SQLException e) {\n\t\t\t\t\t\tthrow makeExecutionException( \"Error advancing (last) ResultSet position\", e );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t);\n\t}\n\n\t@FunctionalInterface\n\tprivate interface Advancer {\n\t\tboolean advance();\n\t}\n\n\tprivate boolean advance(Advancer advancer) {\n\t\tfinal boolean hasResult = advancer.advance();\n\t\tif ( ! hasResult ) {\n\t\t\treturn false;\n\t\t}\n\n\t\treadCurrentRowValues();\n\t\treturn true;\n\t}\n\n\tprivate ExecutionException makeExecutionException(String message, SQLException cause) {\n\t\treturn new ExecutionException(\n\t\t\t\tmessage,\n\t\t\t\texecutionContext.getSession().getJdbcServices().getSqlExceptionHelper().convert(\n\t\t\t\t\t\tcause,\n\t\t\t\t\t\tmessage\n\t\t\t\t)\n\t\t);\n\t}\n\n\tprivate void readCurrentRowValues() {\n\t\tfinal ResultSet resultSet = resultSetAccess.getResultSet();\n\t\tfinal SharedSessionContractImplementor session = executionContext.getSession();\n\t\tfor ( final SqlSelection sqlSelection : sqlSelections ) {\n\t\t\ttry {\n\t\t\t\tcurrentRowJdbcValues[ sqlSelection.getValuesArrayPosition() ] = sqlSelection.getJdbcValueExtractor().extract(\n\t\t\t\t\t\tresultSet,\n\t\t\t\t\t\tsqlSelection.getJdbcResultSetIndex(),\n\t\t\t\t\t\tsession\n\t\t\t\t);\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tthrow new HibernateException(\n\t\t\t\t\t\t\"Unable to extract JDBC value for position `\" + sqlSelection.getJdbcResultSetIndex() + \"`\",\n\t\t\t\t\t\te\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tprotected void release() {\n\t\tresultSetAccess.release();\n\t}\n\n\t@Override\n\tpublic JdbcValuesMapping getValuesMapping() {\n\t\treturn valuesMapping;\n\t}\n\n\t@Override\n\tpublic Object[] getCurrentRowValuesArray() {\n\t\treturn currentRowJdbcValues;\n\t}\n\n\t@Override\n\tpublic void setFetchSize(int fetchSize) {\n\t\ttry {\n\t\t\tresultSetAccess.getResultSet().setFetchSize(fetchSize);\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow makeExecutionException( \"Error calling ResultSet.setFetchSize()\", e );\n\t\t}\n\t}\n}\n",
        "filePathAfter": "hibernate-core/src/main/java/org/hibernate/sql/results/jdbc/internal/JdbcValuesResultSetImpl.java",
        "sourceCodeAfterForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later\n * See the lgpl.txt file in the root directory or http://www.gnu.org/licenses/lgpl-2.1.html\n */\npackage org.hibernate.sql.results.jdbc.internal;\n\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.Arrays;\n\nimport org.hibernate.HibernateException;\nimport org.hibernate.cache.spi.QueryKey;\nimport org.hibernate.cache.spi.QueryResultsCache;\nimport org.hibernate.engine.spi.SessionFactoryImplementor;\nimport org.hibernate.engine.spi.SharedSessionContractImplementor;\nimport org.hibernate.query.spi.QueryOptions;\nimport org.hibernate.sql.ast.spi.SqlSelection;\nimport org.hibernate.sql.exec.ExecutionException;\nimport org.hibernate.sql.exec.spi.ExecutionContext;\nimport org.hibernate.sql.results.caching.QueryCachePutManager;\nimport org.hibernate.sql.results.caching.internal.QueryCachePutManagerDisabledImpl;\nimport org.hibernate.sql.results.caching.internal.QueryCachePutManagerEnabledImpl;\nimport org.hibernate.sql.results.jdbc.spi.JdbcValuesMapping;\nimport org.hibernate.sql.results.jdbc.spi.JdbcValuesMetadata;\nimport org.hibernate.sql.results.jdbc.spi.RowProcessingState;\n\n/**\n * JdbcValuesSource implementation for a JDBC ResultSet as the source\n *\n * @author Steve Ebersole\n */\npublic class JdbcValuesResultSetImpl extends AbstractJdbcValues {\n\n\tprivate final ResultSetAccess resultSetAccess;\n\tprivate final JdbcValuesMapping valuesMapping;\n\tprivate final ExecutionContext executionContext;\n\n\tprivate final SqlSelection[] sqlSelections;\n\tprivate final Object[] currentRowJdbcValues;\n\n\tpublic JdbcValuesResultSetImpl(\n\t\t\tResultSetAccess resultSetAccess,\n\t\t\tQueryKey queryCacheKey,\n\t\t\tString queryIdentifier,\n\t\t\tQueryOptions queryOptions,\n\t\t\tJdbcValuesMapping valuesMapping,\n\t\t\tJdbcValuesMetadata metadataForCache,\n\t\t\tExecutionContext executionContext) {\n\t\tsuper( resolveQueryCachePutManager( executionContext, queryOptions, queryCacheKey, queryIdentifier, metadataForCache ) );\n\t\tthis.resultSetAccess = resultSetAccess;\n\t\tthis.valuesMapping = valuesMapping;\n\t\tthis.executionContext = executionContext;\n\n\t\tthis.sqlSelections = valuesMapping.getSqlSelections().toArray( new SqlSelection[0] );\n\t\tthis.currentRowJdbcValues = new Object[ valuesMapping.getRowSize() ];\n\t}\n\n\tprivate static QueryCachePutManager resolveQueryCachePutManager(\n\t\t\tExecutionContext executionContext,\n\t\t\tQueryOptions queryOptions,\n\t\t\tQueryKey queryCacheKey,\n\t\t\tString queryIdentifier,\n\t\t\tJdbcValuesMetadata metadataForCache) {\n\t\tif ( queryCacheKey != null ) {\n\t\t\tfinal SessionFactoryImplementor factory = executionContext.getSession().getFactory();\n\t\t\tfinal QueryResultsCache queryCache = factory.getCache()\n\t\t\t\t\t.getQueryResultsCache( queryOptions.getResultCacheRegionName() );\n\t\t\treturn new QueryCachePutManagerEnabledImpl(\n\t\t\t\t\tqueryCache,\n\t\t\t\t\tfactory.getStatistics(),\n\t\t\t\t\tqueryCacheKey,\n\t\t\t\t\tqueryIdentifier,\n\t\t\t\t\tmetadataForCache\n\t\t\t);\n\t\t}\n\t\telse {\n\t\t\treturn QueryCachePutManagerDisabledImpl.INSTANCE;\n\t\t}\n\t}\n\n\t@Override\n\tprotected final boolean processNext(RowProcessingState rowProcessingState) {\n\t\treturn advance( advanceNext() );\n\t}\n\n\t@Override\n\tprotected boolean processPrevious(RowProcessingState rowProcessingState) {\n\t\treturn advance( advancePrevious() );\n\t}\n\n\t@Override\n\tprotected boolean processScroll(int numberOfRows, RowProcessingState rowProcessingState) {\n\t\treturn advance( scrollRows( numberOfRows ) );\n\t}\n\n\tprivate boolean scrollRows(final int numberOfRows) {\n\t\ttry {\n\t\t\treturn resultSetAccess.getResultSet().relative( numberOfRows );\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow makeExecutionException( \"Error advancing (scroll) ResultSet position\", e );\n\t\t}\n\t}\n\n\t@Override\n\tpublic int getPosition() {\n\t\ttry {\n\t\t\treturn resultSetAccess.getResultSet().getRow() - 1;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow makeExecutionException( \"Error calling ResultSet#getRow\", e );\n\t\t}\n\t}\n\n\t@Override\n\tprotected boolean processPosition(int position, RowProcessingState rowProcessingState) {\n\t\treturn advance( advanceToPosition( position ) );\n\t}\n\n\tprivate boolean advanceToPosition(final int position) {\n\t\ttry {\n\t\t\treturn resultSetAccess.getResultSet().absolute( position );\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow makeExecutionException( \"Error advancing (scroll) ResultSet position\", e );\n\t\t}\n\t}\n\n\t@Override\n\tpublic boolean isBeforeFirst(RowProcessingState rowProcessingState) {\n\t\ttry {\n\t\t\treturn resultSetAccess.getResultSet().isBeforeFirst();\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow makeExecutionException( \"Error calling ResultSet#isBeforeFirst()\", e );\n\t\t}\n\t}\n\n\t@Override\n\tpublic void beforeFirst(RowProcessingState rowProcessingState) {\n\t\ttry {\n\t\t\tresultSetAccess.getResultSet().beforeFirst();\n\t\t\tArrays.fill( currentRowJdbcValues, null );\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow makeExecutionException( \"Error calling ResultSet#beforeFirst()\", e );\n\t\t}\n\t}\n\n\t@Override\n\tpublic boolean isFirst(RowProcessingState rowProcessingState) {\n\t\ttry {\n\t\t\treturn resultSetAccess.getResultSet().isFirst();\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow makeExecutionException( \"Error calling ResultSet#isFirst()\", e );\n\t\t}\n\t}\n\n\t@Override\n\tpublic boolean first(RowProcessingState rowProcessingState) {\n\t\treturn advance( advanceToFirst() );\n\t}\n\n\t@Override\n\tpublic boolean isAfterLast(RowProcessingState rowProcessingState) {\n\t\ttry {\n\t\t\treturn resultSetAccess.getResultSet().isAfterLast();\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow makeExecutionException( \"Error calling ResultSet#isAfterLast()\", e );\n\t\t}\n\t}\n\n\t@Override\n\tpublic void afterLast(RowProcessingState rowProcessingState) {\n\t\ttry {\n\t\t\tresultSetAccess.getResultSet().afterLast();\n\t\t\tArrays.fill( currentRowJdbcValues, null );\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow makeExecutionException( \"Error calling ResultSet#afterLast()\", e );\n\t\t}\n\t}\n\n\t@Override\n\tpublic boolean isLast(RowProcessingState rowProcessingState) {\n\t\ttry {\n\t\t\treturn resultSetAccess.getResultSet().isLast();\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow makeExecutionException( \"Error calling ResultSet#isLast()\", e );\n\t\t}\n\t}\n\n\t@Override\n\tpublic boolean last(RowProcessingState rowProcessingState) {\n\t\treturn advance( advanceToLast() );\n\t}\n\n\tprivate boolean advanceNext() {\n\t\ttry {\n\t\t\treturn resultSetAccess.getResultSet().next();\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow makeExecutionException( \"Error advancing (next) ResultSet position\", e );\n\t\t}\n\t}\n\n\tprivate boolean advanceToLast() {\n\t\ttry {\n\t\t\treturn resultSetAccess.getResultSet().last();\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow makeExecutionException( \"Error advancing (last) ResultSet position\", e );\n\t\t}\n\t}\n\n\tprivate boolean advanceToFirst() {\n\t\ttry {\n\t\t\treturn resultSetAccess.getResultSet().first();\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow makeExecutionException( \"Error advancing (first) ResultSet position\", e );\n\t\t}\n\t}\n\n\tprivate boolean advancePrevious() {\n\t\ttry {\n\t\t\treturn resultSetAccess.getResultSet().previous();\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow makeExecutionException( \"Error advancing (previous) ResultSet position\", e );\n\t\t}\n\t}\n\n\tprivate boolean advance(final boolean hasResult) {\n\t\tif ( ! hasResult ) {\n\t\t\treturn false;\n\t\t}\n\n\t\treadCurrentRowValues();\n\t\treturn true;\n\t}\n\n\tprivate ExecutionException makeExecutionException(String message, SQLException cause) {\n\t\treturn new ExecutionException(\n\t\t\t\tmessage,\n\t\t\t\texecutionContext.getSession().getJdbcServices().getSqlExceptionHelper().convert(\n\t\t\t\t\t\tcause,\n\t\t\t\t\t\tmessage\n\t\t\t\t)\n\t\t);\n\t}\n\n\tprivate void readCurrentRowValues() {\n\t\tfinal ResultSet resultSet = resultSetAccess.getResultSet();\n\t\tfinal SharedSessionContractImplementor session = executionContext.getSession();\n\t\tfor ( final SqlSelection sqlSelection : sqlSelections ) {\n\t\t\ttry {\n\t\t\t\tcurrentRowJdbcValues[ sqlSelection.getValuesArrayPosition() ] = sqlSelection.getJdbcValueExtractor().extract(\n\t\t\t\t\t\tresultSet,\n\t\t\t\t\t\tsqlSelection.getJdbcResultSetIndex(),\n\t\t\t\t\t\tsession\n\t\t\t\t);\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tthrow new HibernateException(\n\t\t\t\t\t\t\"Unable to extract JDBC value for position `\" + sqlSelection.getJdbcResultSetIndex() + \"`\",\n\t\t\t\t\t\te\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tprotected void release() {\n\t\tresultSetAccess.release();\n\t}\n\n\t@Override\n\tpublic JdbcValuesMapping getValuesMapping() {\n\t\treturn valuesMapping;\n\t}\n\n\t@Override\n\tpublic Object[] getCurrentRowValuesArray() {\n\t\treturn currentRowJdbcValues;\n\t}\n\n\t@Override\n\tpublic void setFetchSize(int fetchSize) {\n\t\ttry {\n\t\t\tresultSetAccess.getResultSet().setFetchSize(fetchSize);\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow makeExecutionException( \"Error calling ResultSet.setFetchSize()\", e );\n\t\t}\n\t}\n}\n",
        "diffSourceCodeSet": [
            "private boolean advanceToLast() {\n\t\ttry {\n\t\t\treturn resultSetAccess.getResultSet().last();\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow makeExecutionException( \"Error advancing (last) ResultSet position\", e );\n\t\t}\n\t}"
        ],
        "invokedMethodSet": [
            "methodSignature: org.hibernate.sql.results.jdbc.internal.JdbcValuesResultSetImpl.Advancer#advance\n methodBody: boolean advance();",
            "methodSignature: org.hibernate.sql.results.jdbc.internal.JdbcValuesResultSetImpl#last\n methodBody: public boolean last(RowProcessingState rowProcessingState) {\nreturn advance(() -> {\n  try {\n    if (!resultSetAccess.getResultSet().last()) {\n      return false;\n    }\n    return true;\n  }\n catch (  SQLException e) {\n    throw makeExecutionException(\"Error advancing (last) ResultSet position\",e);\n  }\n}\n);\n}",
            "methodSignature: org.hibernate.sql.results.jdbc.internal.JdbcValuesResultSetImpl#advance\n methodBody: private boolean advance(Advancer advancer) {\nfinal boolean hasResult=advancer.advance();\nif(!hasResult){return false;\n}readCurrentRowValues();\nreturn true;\n}",
            "methodSignature: org.hibernate.sql.results.jdbc.internal.JdbcValuesResultSetImpl#makeExecutionException\n methodBody: private ExecutionException makeExecutionException(String message, SQLException cause) {\nreturn new ExecutionException(message,executionContext.getSession().getJdbcServices().getSqlExceptionHelper().convert(cause,message));\n}"
        ],
        "sourceCodeAfterRefactoring": "@Override\n\tpublic boolean last(RowProcessingState rowProcessingState) {\n\t\treturn advance( advanceToLast() );\n\t}\nprivate boolean advanceToLast() {\n\t\ttry {\n\t\t\treturn resultSetAccess.getResultSet().last();\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow makeExecutionException( \"Error advancing (last) ResultSet position\", e );\n\t\t}\n\t}",
        "diffSourceCode": "-  198: \n-  199: \t@Override\n-  200: \tpublic boolean first(RowProcessingState rowProcessingState) {\n-  201: \t\treturn advance(\n-  212: \t\t\t\t\t\tthrow makeExecutionException( \"Error advancing (first) ResultSet position\", e );\n-  213: \t\t\t\t\t}\n-  214: \t\t\t\t}\n-  215: \t\t);\n-  216: \t}\n-  217: \n-  218: \t@Override\n-  219: \tpublic boolean isAfterLast(RowProcessingState rowProcessingState) {\n-  249: \t@Override\n-  250: \tpublic boolean last(RowProcessingState rowProcessingState) {\n-  251: \t\treturn advance(\n-  252: \t\t\t\t() -> {\n-  253: \t\t\t\t\ttry {\n-  254: \t\t\t\t\t\t//noinspection RedundantIfStatement\n-  255: \t\t\t\t\t\tif ( ! resultSetAccess.getResultSet().last() ) {\n-  256: \t\t\t\t\t\t\treturn false;\n-  257: \t\t\t\t\t\t}\n-  258: \n-  259: \t\t\t\t\t\treturn true;\n-  260: \t\t\t\t\t}\n-  261: \t\t\t\t\tcatch (SQLException e) {\n-  262: \t\t\t\t\t\tthrow makeExecutionException( \"Error advancing (last) ResultSet position\", e );\n-  263: \t\t\t\t\t}\n-  264: \t\t\t\t}\n-  265: \t\t);\n-  266: \t}\n+  198: \t@Override\n+  199: \tpublic boolean last(RowProcessingState rowProcessingState) {\n+  200: \t\treturn advance( advanceToLast() );\n+  201: \t}\n+  212: \tprivate boolean advanceToLast() {\n+  213: \t\ttry {\n+  214: \t\t\treturn resultSetAccess.getResultSet().last();\n+  215: \t\t}\n+  216: \t\tcatch (SQLException e) {\n+  217: \t\t\tthrow makeExecutionException( \"Error advancing (last) ResultSet position\", e );\n+  218: \t\t}\n+  219: \t}\n+  249: \t\treturn new ExecutionException(\n+  250: \t\t\t\tmessage,\n+  251: \t\t\t\texecutionContext.getSession().getJdbcServices().getSqlExceptionHelper().convert(\n+  252: \t\t\t\t\t\tcause,\n+  253: \t\t\t\t\t\tmessage\n+  254: \t\t\t\t)\n+  255: \t\t);\n+  256: \t}\n+  257: \n+  258: \tprivate void readCurrentRowValues() {\n+  259: \t\tfinal ResultSet resultSet = resultSetAccess.getResultSet();\n+  260: \t\tfinal SharedSessionContractImplementor session = executionContext.getSession();\n+  261: \t\tfor ( final SqlSelection sqlSelection : sqlSelections ) {\n+  262: \t\t\ttry {\n+  263: \t\t\t\tcurrentRowJdbcValues[ sqlSelection.getValuesArrayPosition() ] = sqlSelection.getJdbcValueExtractor().extract(\n+  264: \t\t\t\t\t\tresultSet,\n+  265: \t\t\t\t\t\tsqlSelection.getJdbcResultSetIndex(),\n+  266: \t\t\t\t\t\tsession\n",
        "uniqueId": "c7bd022b075647bee8fd4695595a29334e036d78_249_266_212_219_198_201",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 0,
                "covered": 5
            },
            "LINE": {
                "missed": 0,
                "covered": 1
            },
            "COMPLEXITY": {
                "missed": 0,
                "covered": 1
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 11
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprivate link(author Author) : void extracted from public addAuthor(author Author) : void in class org.hibernate.orm.test.mapping.manytomany.ManyToManyListBidirectionalTest.Book",
        "diffLocations": [
            {
                "filePath": "hibernate-core/src/test/java/org/hibernate/orm/test/mapping/manytomany/ManyToManyListBidirectionalTest.java",
                "startLine": 97,
                "endLine": 100,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/test/java/org/hibernate/orm/test/mapping/manytomany/ManyToManyListBidirectionalTest.java",
                "startLine": 116,
                "endLine": 118,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/test/java/org/hibernate/orm/test/mapping/manytomany/ManyToManyListBidirectionalTest.java",
                "startLine": 100,
                "endLine": 103,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "public void addAuthor(Author author) {\n\t\t\tauthors.add( author );\n\t\t\tauthor.books.add( this );\n\t\t}",
        "filePathBefore": "hibernate-core/src/test/java/org/hibernate/orm/test/mapping/manytomany/ManyToManyListBidirectionalTest.java",
        "isPureRefactoring": true,
        "commitId": "a9ac98b364ccf52bb9cb2be5324c9c983e8bd8b3",
        "packageNameBefore": "org.hibernate.orm.test.mapping.manytomany.ManyToManyListBidirectionalTest",
        "classNameBefore": "org.hibernate.orm.test.mapping.manytomany.ManyToManyListBidirectionalTest.Book",
        "methodNameBefore": "org.hibernate.orm.test.mapping.manytomany.ManyToManyListBidirectionalTest.Book#addAuthor",
        "invokedMethod": "methodSignature: org.hibernate.id.IdentifierGeneratorHelper.BasicHolder#add\n methodBody: public IntegralDataTypeHolder add(long addend) {\ncheckInitialized();\nvalue+=addend;\nreturn this;\n}\nmethodSignature: org.hibernate.id.IdentifierGeneratorHelper.BigIntegerHolder#add\n methodBody: public IntegralDataTypeHolder add(long increment) {\ncheckInitialized();\nvalue=value.add(BigInteger.valueOf(increment));\nreturn this;\n}\nmethodSignature: org.hibernate.internal.util.StringHelper#add\n methodBody: public static String[] add(String[] x, String sep, String[] y) {\nfinal String[] result=new String[x.length];\nfor(int i=0; i < x.length; i++){result[i]=x[i] + sep + y[i];\n}return result;\n}\nmethodSignature: org.hibernate.id.IdentifierGeneratorHelper.BigDecimalHolder#add\n methodBody: public IntegralDataTypeHolder add(long increment) {\ncheckInitialized();\nvalue=value.add(BigDecimal.valueOf(increment));\nreturn this;\n}",
        "classSignatureBefore": "public static class Book ",
        "methodNameBeforeSet": [
            "org.hibernate.orm.test.mapping.manytomany.ManyToManyListBidirectionalTest.Book#addAuthor"
        ],
        "classNameBeforeSet": [
            "org.hibernate.orm.test.mapping.manytomany.ManyToManyListBidirectionalTest.Book"
        ],
        "classSignatureBeforeSet": [
            "public static class Book "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later\n * See the lgpl.txt file in the root directory or http://www.gnu.org/licenses/lgpl-2.1.html\n */\npackage org.hibernate.orm.test.mapping.manytomany;\n\nimport static org.assertj.core.api.Assertions.assertThat;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.hibernate.testing.orm.junit.DomainModel;\nimport org.hibernate.testing.orm.junit.ServiceRegistry;\nimport org.hibernate.testing.orm.junit.SessionFactory;\nimport org.hibernate.testing.orm.junit.SessionFactoryScope;\nimport org.junit.jupiter.api.Test;\n\nimport jakarta.persistence.Entity;\nimport jakarta.persistence.Id;\nimport jakarta.persistence.JoinColumn;\nimport jakarta.persistence.JoinTable;\nimport jakarta.persistence.ManyToMany;\n\n@DomainModel(\n\t\tannotatedClasses = {\n\t\t\t\tManyToManyListBidirectionalTest.Book.class,\n\t\t\t\tManyToManyListBidirectionalTest.Author.class\n\t\t}\n)\n@SessionFactory\n@ServiceRegistry\n@SuppressWarnings( \"unused\" )\npublic class ManyToManyListBidirectionalTest {\n\n\t@Test\n\tpublic void test(SessionFactoryScope scope) {\n\t\tscope.inTransaction( session -> {\n\t\t\tfinal Author author1 = new Author( 1 );\n\t\t\tfinal Author author2 = new Author( 2 );\n\n\t\t\tfinal Book bookByAuthor1 = new Book( 1 );\n\t\t\tbookByAuthor1.addAuthor( author1 );\n\n\t\t\tfinal Book bookByAuthor2 = new Book( 2 );\n\t\t\tbookByAuthor2.addAuthor( author2 );\n\n\t\t\tfinal Book bookByAuthor1AndAuthor2 = new Book( 3 );\n\t\t\tbookByAuthor1AndAuthor2.addAuthor( author1 );\n\t\t\tbookByAuthor1AndAuthor2.addAuthor( author2 );\n\n\t\t\tsession.persist( author1 );\n\t\t\tsession.persist( author2 );\n\t\t\tsession.persist( bookByAuthor1 );\n\t\t\tsession.persist( bookByAuthor2 );\n\t\t\tsession.persist( bookByAuthor1AndAuthor2 );\n\t\t} );\n\n\t\tscope.inTransaction( session -> {\n\t\t\tassertThat( session.createQuery( \"from Book b\", Book.class ).list() )\n\t\t\t\t\t.hasSize( 3 )\n\t\t\t\t\t.allSatisfy( book -> assertThat( book.authors )\n\t\t\t\t\t\t\t.allSatisfy( author -> assertThat( author.books ).contains( book ) ) );\n\t\t} );\n\n\t\tscope.inTransaction( session -> {\n\t\t\tsession.createMutationQuery( \"delete from Book\" ).executeUpdate();\n\t\t\tsession.createMutationQuery( \"delete from Author\" ).executeUpdate();\n\t\t} );\n\n\t\tscope.inTransaction( session -> {\n\t\t\tassertThat( session.createQuery( \"from Book\", Book.class ).list() ).isEmpty();\n\t\t\tassertThat( session.createQuery( \"from Author\", Author.class ).list() ).isEmpty();\n\t\t} );\n\t}\n\n\t@Entity(name = \"Book\")\n\tpublic static class Book {\n\n\t\t@Id\n\t\tprivate int id;\n\n\t\tpublic Book() {\n\t\t}\n\n\t\tpublic Book(int id) {\n\t\t\tthis.id = id;\n\t\t}\n\n\t\t@ManyToMany\n\t\t@JoinTable(name = \"book_author\",\n\t\t\t\tjoinColumns = { @JoinColumn(name = \"fk_book\") },\n\t\t\t\tinverseJoinColumns = { @JoinColumn(name = \"fk_author\") })\n\t\tprivate List<Author> authors = new ArrayList<>();\n\n\t\tpublic void addAuthor(Author author) {\n\t\t\tauthors.add( author );\n\t\t\tauthor.books.add( this );\n\t\t}\n\t}\n\n\t@Entity(name = \"Author\")\n\tpublic static class Author {\n\n\t\t@Id\n\t\tprivate int id;\n\n\t\tpublic Author() {\n\t\t}\n\n\t\tpublic Author(int id) {\n\t\t\tthis.id = id;\n\t\t}\n\n\t\t@ManyToMany(mappedBy = \"authors\")\n\t\tprivate List<Book> books = new ArrayList<>();\n\n\t\tpublic void addBook(Book book) {\n\t\t\tbooks.add( book );\n\t\t\tbook.authors.add( this );\n\t\t}\n\t}\n\n}\n",
        "filePathAfter": "hibernate-core/src/test/java/org/hibernate/orm/test/mapping/manytomany/ManyToManyListBidirectionalTest.java",
        "sourceCodeAfterForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later\n * See the lgpl.txt file in the root directory or http://www.gnu.org/licenses/lgpl-2.1.html\n */\npackage org.hibernate.orm.test.mapping.manytomany;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.hibernate.internal.util.collections.ArrayHelper;\n\nimport org.hibernate.testing.orm.junit.DomainModel;\nimport org.hibernate.testing.orm.junit.ServiceRegistry;\nimport org.hibernate.testing.orm.junit.SessionFactory;\nimport org.hibernate.testing.orm.junit.SessionFactoryScope;\nimport org.junit.jupiter.api.Test;\n\nimport jakarta.persistence.Entity;\nimport jakarta.persistence.Id;\nimport jakarta.persistence.JoinColumn;\nimport jakarta.persistence.JoinTable;\nimport jakarta.persistence.ManyToMany;\n\nimport static org.assertj.core.api.Assertions.assertThat;\n\n@DomainModel(\n\t\tannotatedClasses = {\n\t\t\t\tManyToManyListBidirectionalTest.Book.class,\n\t\t\t\tManyToManyListBidirectionalTest.Author.class\n\t\t}\n)\n@SessionFactory\n@ServiceRegistry\n@SuppressWarnings( \"unused\" )\npublic class ManyToManyListBidirectionalTest {\n\n\t@Test\n\tpublic void test(SessionFactoryScope scope) {\n\t\tscope.inTransaction( session -> {\n\t\t\tfinal Author author1 = new Author( 1 );\n\t\t\tfinal Author author2 = new Author( 2 );\n\t\t\tsession.persist( author1 );\n\t\t\tsession.persist( author2 );\n\n\t\t\tfinal Book bookByAuthor1 = new Book( 1, author1 );\n\t\t\tfinal Book bookByAuthor2 = new Book( 2, author2 );\n\t\t\tfinal Book bookByAuthors1And2 = new Book( 3, author1, author2 );\n\t\t\tsession.persist( bookByAuthor1 );\n\t\t\tsession.persist( bookByAuthor2 );\n\t\t\tsession.persist( bookByAuthors1And2 );\n\t\t} );\n\n\t\tscope.inTransaction( session -> {\n\t\t\tfinal List<Book> books = session.createQuery( \"from Book b\", Book.class ).list();\n\n\t\t\tassertThat( books ).hasSize( 3 );\n\t\t\tbooks.forEach( (book) -> {\n\t\t\t\tbook.authors.forEach( (author) -> {\n\t\t\t\t\tassertThat( author.books ).contains( book );\n\t\t\t\t} );\n\t\t\t} );\n\n//\t\t\tassertThat( books )\n//\t\t\t\t\t.hasSize( 3 )\n//\t\t\t\t\t.allSatisfy( book -> assertThat( book.authors )\n//\t\t\t\t\t\t\t.allSatisfy( author -> assertThat( author.books ).contains( book ) ) );\n\t\t} );\n\n\t\tscope.inTransaction( session -> {\n\t\t\tsession.createMutationQuery( \"delete from Book\" ).executeUpdate();\n\t\t\tsession.createMutationQuery( \"delete from Author\" ).executeUpdate();\n\t\t} );\n\n\t\tscope.inTransaction( session -> {\n\t\t\tassertThat( session.createQuery( \"from Book\", Book.class ).list() ).isEmpty();\n\t\t\tassertThat( session.createQuery( \"from Author\", Author.class ).list() ).isEmpty();\n\t\t} );\n\t}\n\n\t@Entity(name = \"Book\")\n\tpublic static class Book {\n\n\t\t@Id\n\t\tprivate int id;\n\n\t\tpublic Book() {\n\t\t}\n\n\t\tpublic Book(int id) {\n\t\t\tthis.id = id;\n\t\t}\n\n\t\tpublic Book(int id, Author author) {\n\t\t\tthis.id = id;\n\t\t\tlink( author );\n\t\t}\n\n\t\tprivate void link(Author author) {\n\t\t\tauthors.add( author );\n\t\t\tauthor.books.add( this );\n\t\t}\n\n\t\tpublic Book(int id, Author... authors) {\n\t\t\tthis.id = id;\n\t\t\tArrayHelper.forEach( authors, this::link );\n\t\t}\n\n\t\t@ManyToMany\n\t\t@JoinTable(name = \"book_author\",\n\t\t\t\tjoinColumns = { @JoinColumn(name = \"fk_book\") },\n\t\t\t\tinverseJoinColumns = { @JoinColumn(name = \"fk_author\") })\n\t\tprivate List<Author> authors = new ArrayList<>();\n\n\t\tpublic void addAuthor(Author author) {\n\t\t\tlink( author );\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"Book(\" + id + \")@\" + Integer.toHexString( hashCode() );\n\t\t}\n\t}\n\n\t@Entity(name = \"Author\")\n\tpublic static class Author {\n\n\t\t@Id\n\t\tprivate int id;\n\n\t\tpublic Author() {\n\t\t}\n\n\t\tpublic Author(int id) {\n\t\t\tthis.id = id;\n\t\t}\n\n\t\t@ManyToMany(mappedBy = \"authors\")\n\t\tprivate List<Book> books = new ArrayList<>();\n\n\t\tpublic void addBook(Book book) {\n\t\t\tbooks.add( book );\n\t\t\tbook.authors.add( this );\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"Author(\" + id + \")@\" + Integer.toHexString( hashCode() );\n\t\t}\n\t}\n\n}\n",
        "diffSourceCodeSet": [
            "private void link(Author author) {\n\t\t\tauthors.add( author );\n\t\t\tauthor.books.add( this );\n\t\t}"
        ],
        "invokedMethodSet": [
            "methodSignature: org.hibernate.id.IdentifierGeneratorHelper.BasicHolder#add\n methodBody: public IntegralDataTypeHolder add(long addend) {\ncheckInitialized();\nvalue+=addend;\nreturn this;\n}",
            "methodSignature: org.hibernate.id.IdentifierGeneratorHelper.BigIntegerHolder#add\n methodBody: public IntegralDataTypeHolder add(long increment) {\ncheckInitialized();\nvalue=value.add(BigInteger.valueOf(increment));\nreturn this;\n}",
            "methodSignature: org.hibernate.internal.util.StringHelper#add\n methodBody: public static String[] add(String[] x, String sep, String[] y) {\nfinal String[] result=new String[x.length];\nfor(int i=0; i < x.length; i++){result[i]=x[i] + sep + y[i];\n}return result;\n}",
            "methodSignature: org.hibernate.id.IdentifierGeneratorHelper.BigDecimalHolder#add\n methodBody: public IntegralDataTypeHolder add(long increment) {\ncheckInitialized();\nvalue=value.add(BigDecimal.valueOf(increment));\nreturn this;\n}"
        ],
        "sourceCodeAfterRefactoring": "public void addAuthor(Author author) {\n\t\t\tlink( author );\n\t\t}\nprivate void link(Author author) {\n\t\t\tauthors.add( author );\n\t\t\tauthor.books.add( this );\n\t\t}",
        "diffSourceCode": "-   97: \t\tpublic void addAuthor(Author author) {\n-   98: \t\t\tauthors.add( author );\n-   99: \t\t\tauthor.books.add( this );\n-  100: \t\t}\n-  101: \t}\n-  102: \n-  103: \t@Entity(name = \"Author\")\n-  116: \t\t@ManyToMany(mappedBy = \"authors\")\n-  117: \t\tprivate List<Book> books = new ArrayList<>();\n-  118: \n+   97: \t\t\tlink( author );\n+   98: \t\t}\n+   99: \n+  100: \t\tprivate void link(Author author) {\n+  101: \t\t\tauthors.add( author );\n+  102: \t\t\tauthor.books.add( this );\n+  103: \t\t}\n+  116: \t\tpublic void addAuthor(Author author) {\n+  117: \t\t\tlink( author );\n+  118: \t\t}\n",
        "uniqueId": "a9ac98b364ccf52bb9cb2be5324c9c983e8bd8b3_97_100_100_103_116_118",
        "moveFileExist": true,
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 11,
        "testResult": true,
        "coverageInfo": {
            "testMethod": {
                "missed": 0,
                "covered": 1
            }
        }
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprivate exportSandboxSchema(sessionImpl SessionImplementor) : void extracted from public testSessionBatchingUsage() : void in class org.hibernate.orm.test.jdbc.internal.BatchingTest",
        "diffLocations": [
            {
                "filePath": "hibernate-core/src/test/java/org/hibernate/orm/test/jdbc/internal/BatchingTest.java",
                "startLine": 180,
                "endLine": 261,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/test/java/org/hibernate/orm/test/jdbc/internal/BatchingTest.java",
                "startLine": 229,
                "endLine": 302,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/test/java/org/hibernate/orm/test/jdbc/internal/BatchingTest.java",
                "startLine": 304,
                "endLine": 323,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "@Test\n\tpublic void testSessionBatchingUsage() throws Exception {\n\t\tSession session = openSession();\n\t\tsession.setJdbcBatchSize( 3 );\n\t\tSessionImplementor sessionImpl = (SessionImplementor) session;\n\n\t\tfinal JdbcCoordinator jdbcCoordinator = sessionImpl.getJdbcCoordinator();\n\t\tLogicalConnectionImplementor logicalConnection = jdbcCoordinator.getLogicalConnection();\n\n\t\t// set up some tables to use\n\t\tStatement statement = jdbcCoordinator.getStatementPreparer().createStatement();\n\t\tString dropSql = sessionFactory().getJdbcServices().getDialect().getDropTableString( \"SANDBOX_JDBC_TST\" );\n\t\ttry {\n\t\t\tjdbcCoordinator.getResultSetReturn().execute( statement, dropSql );\n\t\t}\n\t\tcatch ( Exception e ) {\n\t\t\t// ignore if the DB doesn't support \"if exists\" and the table doesn't exist\n\t\t}\t\tjdbcCoordinator.getResultSetReturn().execute( statement, \"create table SANDBOX_JDBC_TST ( ID integer, NAME varchar(100) )\" );\n        assertTrue( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n\t\tassertTrue( logicalConnection.isPhysicallyConnected() );\n        jdbcCoordinator.getLogicalConnection().getResourceRegistry().release( statement );\n        assertFalse( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n\t\tassertTrue( logicalConnection.isPhysicallyConnected() ); // after_transaction specified\n\n\t\t// ok, now we can get down to it...\n\t\tTransaction txn = session.getTransaction();  // same as Session#getTransaction\n\t\ttxn.begin();\n\n\t\tfinal BatchBuilder batchBuilder = new BatchBuilderImpl( 2 );\n\t\tfinal BatchKey batchKey = new BasicBatchKey( \"this\", Expectations.BASIC );\n\t\tfinal Batch insertBatch = batchBuilder.buildBatch( batchKey, jdbcCoordinator );\n\t\tassertTrue( \"unexpected Batch impl\", BatchingBatch.class.isInstance( insertBatch ) );\n\n\t\tfinal JournalingBatchObserver batchObserver = new JournalingBatchObserver();\n\t\tinsertBatch.addObserver( batchObserver );\n\n\t\tfinal String insertSql = \"insert into SANDBOX_JDBC_TST( ID, NAME ) values ( ?, ? )\";\n\n\t\tPreparedStatement insert = insertBatch.getBatchStatement( insertSql, false );\n\t\tinsert.setLong( 1, 1 );\n\t\tinsert.setString( 2, \"name\" );\n\t\tassertEquals( 0, batchObserver.getExplicitExecutionCount() );\n\t\tassertEquals( 0, batchObserver.getImplicitExecutionCount() );\n\t\tinsertBatch.addToBatch();\n\t\tassertEquals( 0, batchObserver.getExplicitExecutionCount() );\n\t\tassertEquals( 0, batchObserver.getImplicitExecutionCount() );\n        assertTrue( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n\n\t\tPreparedStatement insert2 = insertBatch.getBatchStatement( insertSql, false );\n\t\tassertSame( insert, insert2 );\n\t\tinsert = insert2;\n\t\tinsert.setLong( 1, 2 );\n\t\tinsert.setString( 2, \"another name\" );\n\t\tassertEquals( 0, batchObserver.getExplicitExecutionCount() );\n\t\tassertEquals( 0, batchObserver.getImplicitExecutionCount() );\n\t\tinsertBatch.addToBatch();\n\t\tassertEquals( 0, batchObserver.getExplicitExecutionCount() );\n\t\tassertEquals( 0, batchObserver.getImplicitExecutionCount() );\n        assertTrue( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n\n\t\tPreparedStatement insert3 = insertBatch.getBatchStatement( insertSql, false );\n\t\tassertSame( insert, insert3 );\n\t\tinsert = insert3;\n\t\tinsert.setLong( 1, 3 );\n\t\tinsert.setString( 2, \"yet another name\" );\n\t\tassertEquals( 0, batchObserver.getExplicitExecutionCount() );\n\t\tassertEquals( 0, batchObserver.getImplicitExecutionCount() );\n\t\tinsertBatch.addToBatch();\n\t\tassertEquals( 0, batchObserver.getExplicitExecutionCount() );\n\t\tassertEquals( 1, batchObserver.getImplicitExecutionCount() );\n        assertTrue( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n\n\t\tinsertBatch.execute();\n\t\tassertEquals( 1, batchObserver.getExplicitExecutionCount() );\n\t\tassertEquals( 1, batchObserver.getImplicitExecutionCount() );\n        assertFalse( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n\n\t\tinsertBatch.release();\n\n\t\ttxn.commit();\n\t\tsession.close();\n\t}",
        "filePathBefore": "hibernate-core/src/test/java/org/hibernate/orm/test/jdbc/internal/BatchingTest.java",
        "isPureRefactoring": true,
        "commitId": "a9ac98b364ccf52bb9cb2be5324c9c983e8bd8b3",
        "packageNameBefore": "org.hibernate.orm.test.jdbc.internal",
        "classNameBefore": "org.hibernate.orm.test.jdbc.internal.BatchingTest",
        "methodNameBefore": "org.hibernate.orm.test.jdbc.internal.BatchingTest#testSessionBatchingUsage",
        "invokedMethod": "methodSignature: org.hibernate.action.internal.BulkOperationCleanupAction.NaturalIdCleanup#release\n methodBody: private void release() {\nnaturalIdCacheAccessStrategy.unlockRegion(cacheLock);\n}\nmethodSignature: org.hibernate.orm.test.insertordering.InsertOrderingTest.StatsBatch#addToBatch\n methodBody: public void addToBatch() {\nCounter counter=(Counter)batchSizes.get(currentBatch);\ncounter.count++;\nsuper.addToBatch();\n}\nmethodSignature: org.hibernate.engine.jdbc.spi.JdbcCoordinator#getStatementPreparer\n methodBody: StatementPreparer getStatementPreparer();\nmethodSignature: org.hibernate.engine.jdbc.spi.JdbcServices#getDialect\n methodBody: Dialect getDialect();\nmethodSignature: org.hibernate.engine.jdbc.batch.internal.AbstractBatchImpl#getBatchStatement\n methodBody: public PreparedStatement getBatchStatement(String sql, boolean callable) {\nif(sql == null){throw new IllegalArgumentException(\"sql must be non-null.\");\n}PreparedStatement statement=statements.get(sql);\nif(statement == null){statement=buildBatchStatement(sql,callable);\nstatements.put(sql,statement);\n}{LOG.debug(\"Reusing batch statement\");\nsqlStatementLogger().logStatement(sql);\n}return statement;\n}\nmethodSignature: org.hibernate.engine.jdbc.batch.spi.Batch#execute\n methodBody: void execute();\nmethodSignature: org.hibernate.engine.jdbc.batch.internal.SharedBatchBuildingCode#buildBatch\n methodBody: static Batch buildBatch(final int defaultJdbcBatchSize, final BatchKey key, final JdbcCoordinator jdbcCoordinator) {\nfinal Integer sessionJdbcBatchSize=jdbcCoordinator.getJdbcSessionOwner().getJdbcBatchSize();\nfinal int jdbcBatchSizeToUse=sessionJdbcBatchSize == null ? defaultJdbcBatchSize : sessionJdbcBatchSize;\nreturn jdbcBatchSizeToUse > 1 ? new BatchingBatch(key,jdbcCoordinator,jdbcBatchSizeToUse) : new NonBatchingBatch(key,jdbcCoordinator);\n}\nmethodSignature: org.hibernate.engine.jdbc.internal.JdbcCoordinatorImpl#getLogicalConnection\n methodBody: public LogicalConnectionImplementor getLogicalConnection() {\nreturn logicalConnection;\n}\nmethodSignature: org.hibernate.engine.jdbc.internal.JdbcCoordinatorImpl#close\n methodBody: protected void close(ResultSet resultSet) {\nLOG.tracev(\"Closing result set [{0}]\",resultSet);\nif(resultSet instanceof InvalidatableWrapper){@SuppressWarnings(\"unchecked\") final InvalidatableWrapper<ResultSet> wrapper=(InvalidatableWrapper<ResultSet>)resultSet;\nclose(wrapper.getWrappedObject());\nwrapper.invalidate();\nreturn;\n}tryresultSet.close();\ncatch(Exception e)LOG.debugf(\"Unable to release JDBC result set [%s]\",e.getMessage());\n}\nmethodSignature: org.hibernate.query.sqm.mutation.internal.inline.InlineUpdateHandler#execute\n methodBody: public int execute(DomainQueryExecutionContext executionContext) {\nfinal List<Object> ids=MatchingIdSelectionHelper.selectMatchingIds(sqmUpdate,domainParameterXref,executionContext);\nif(ids == null || ids.isEmpty()){return 0;\n}domainParameterXref.clearExpansions();\nfinal MappingMetamodel domainModel=sessionFactory.getRuntimeMetamodels().getMappingMetamodel();\nfinal String mutatingEntityName=sqmUpdate.getTarget().getModel().getHibernateEntityName();\nfinal EntityPersister entityDescriptor=domainModel.getEntityDescriptor(mutatingEntityName);\nfinal String rootEntityName=entityDescriptor.getEntityPersister().getRootEntityName();\nfinal EntityPersister rootEntityDescriptor=domainModel.getEntityDescriptor(rootEntityName);\nfinal String hierarchyRootTableName=((Joinable)rootEntityDescriptor).getTableName();\nfinal List<Expression> inListExpressions=new ArrayList<>(ids.size());\nfinal EntityIdentifierMapping identifierMapping=entityDescriptor.getIdentifierMapping();\nif(identifierMapping instanceof BasicValuedModelPart){final BasicValuedModelPart basicValuedModelPart=(BasicValuedModelPart)identifierMapping;\nfor(int i=0; i < ids.size(); i++){inListExpressions.add(new QueryLiteral<>(ids.get(i),basicValuedModelPart));\n}}{final int jdbcTypeCount=identifierMapping.getJdbcTypeCount();\nfor(int i=0; i < ids.size(); i++){final Object[] id=(Object[])ids.get(i);\nfinal List<Expression> tupleElements=new ArrayList<>(jdbcTypeCount);\ninListExpressions.add(new SqlTuple(tupleElements,identifierMapping));\nidentifierMapping.forEachJdbcType((index,jdbcMapping) -> {\n  tupleElements.add(new QueryLiteral<>(id[index],(BasicValuedMapping)jdbcMapping));\n}\n);\n}}final MultiTableSqmMutationConverter converterDelegate=new MultiTableSqmMutationConverter(entityDescriptor,sqmUpdate,sqmUpdate.getTarget(),domainParameterXref,executionContext.getQueryOptions(),executionContext.getSession().getLoadQueryInfluencers(),executionContext.getQueryParameterBindings(),sessionFactory);\nfinal TableGroup updatingTableGroup=converterDelegate.getMutatingTableGroup();\nfinal TableReference hierarchyRootTableReference=updatingTableGroup.resolveTableReference(updatingTableGroup.getNavigablePath(),hierarchyRootTableName);\nassert hierarchyRootTableReference != null;\nfinal Map<SqmParameter<?>,List<List<JdbcParameter>>> parameterResolutions;\nif(domainParameterXref.getSqmParameterCount() == 0){parameterResolutions=Collections.emptyMap();\n}{parameterResolutions=new IdentityHashMap<>();\n}final List<Assignment> assignments=new ArrayList<>();\nfinal Map<SqmParameter<?>,MappingModelExpressible<?>> paramTypeResolutions=new LinkedHashMap<>();\nconverterDelegate.visitSetClause(sqmUpdate.getSetClause(),assignments::add,(sqmParameter,mappingType,jdbcParameters) -> {\n  parameterResolutions.computeIfAbsent(sqmParameter,k -> new ArrayList<>(1)).add(jdbcParameters);\n  paramTypeResolutions.put(sqmParameter,mappingType);\n}\n);\nconverterDelegate.addVersionedAssignment(assignments::add,sqmUpdate);\nfinal Predicate providedPredicate;\nfinal SqmWhereClause whereClause=sqmUpdate.getWhereClause();\nif(whereClause == null || whereClause.getPredicate() == null){providedPredicate=null;\n}{providedPredicate=converterDelegate.visitWhereClause(whereClause,columnReference -> {\n}\n,(sqmParameter,mappingType,jdbcParameters) -> {\n  parameterResolutions.computeIfAbsent(sqmParameter,k -> new ArrayList<>(1)).add(jdbcParameters);\n  paramTypeResolutions.put(sqmParameter,mappingType);\n}\n);\nassert providedPredicate != null;\n}final PredicateCollector predicateCollector=new PredicateCollector(providedPredicate);\nentityDescriptor.applyBaseRestrictions(predicateCollector::applyPredicate,updatingTableGroup,true,executionContext.getSession().getLoadQueryInfluencers().getEnabledFilters(),null,converterDelegate);\nconverterDelegate.pruneTableGroupJoins();\nfinal Map<String,TableReference> tableReferenceByAlias=CollectionHelper.mapOfSize(updatingTableGroup.getTableReferenceJoins().size() + 1);\ncollectTableReference(updatingTableGroup.getPrimaryTableReference(),tableReferenceByAlias::put);\nfor(int i=0; i < updatingTableGroup.getTableReferenceJoins().size(); i++){collectTableReference(updatingTableGroup.getTableReferenceJoins().get(i),tableReferenceByAlias::put);\n}final JdbcParameterBindings jdbcParameterBindings=SqmUtil.createJdbcParameterBindings(executionContext.getQueryParameterBindings(),domainParameterXref,SqmUtil.generateJdbcParamsXref(domainParameterXref,() -> parameterResolutions),sessionFactory.getRuntimeMetamodels().getMappingMetamodel(),navigablePath -> updatingTableGroup,new SqmParameterMappingModelResolutionAccess(){\n  @Override @SuppressWarnings(\"unchecked\") public <T>MappingModelExpressible<T> getResolvedMappingModelType(  SqmParameter<T> parameter){\n    return (MappingModelExpressible<T>)paramTypeResolutions.get(parameter);\n  }\n}\n,executionContext.getSession());\nfinal Map<TableReference,List<Assignment>> assignmentsByTable=new HashMap<>();\nfor(int i=0; i < assignments.size(); i++){final Assignment assignment=assignments.get(i);\nfinal List<ColumnReference> assignmentColumnRefs=assignment.getAssignable().getColumnReferences();\nTableReference assignmentTableReference=null;\nfor(int c=0; c < assignmentColumnRefs.size(); c++){final ColumnReference columnReference=assignmentColumnRefs.get(c);\nfinal TableReference tableReference=resolveTableReference(columnReference,tableReferenceByAlias);\nif(assignmentTableReference != null && assignmentTableReference != tableReference){throw new SemanticException(\"Assignment referred to columns from multiple tables: \" + assignment.getAssignable());\n}assignmentTableReference=tableReference;\n}List<Assignment> assignmentsForTable=assignmentsByTable.get(assignmentTableReference);\nif(assignmentsForTable == null){assignmentsForTable=new ArrayList<>();\nassignmentsByTable.put(assignmentTableReference,assignmentsForTable);\n}assignmentsForTable.add(assignment);\n}final int rows=ids.size();\nfinal SqmJdbcExecutionContextAdapter executionContextAdapter=SqmJdbcExecutionContextAdapter.omittingLockingAndPaging(executionContext);\nentityDescriptor.visitConstraintOrderedTables((tableExpression,tableKeyColumnVisitationSupplier) -> updateTable(tableExpression,tableKeyColumnVisitationSupplier,entityDescriptor,updatingTableGroup,assignmentsByTable,inListExpressions,rows,jdbcParameterBindings,executionContextAdapter));\nreturn rows;\n}\nmethodSignature: org.hibernate.dialect.AbstractHANADialect.CloseSuppressingInputStream#close\n methodBody: public void close() {\n}\nmethodSignature: org.hibernate.query.sqm.mutation.internal.inline.InlineDeleteHandler#execute\n methodBody: public int execute(DomainQueryExecutionContext executionContext) {\nfinal List<Object> idsAndFks=MatchingIdSelectionHelper.selectMatchingIds(sqmDeleteStatement,domainParameterXref,executionContext);\nif(idsAndFks == null || idsAndFks.isEmpty()){return 0;\n}final SessionFactoryImplementor factory=executionContext.getSession().getFactory();\nfinal String mutatingEntityName=sqmDeleteStatement.getTarget().getModel().getHibernateEntityName();\nfinal EntityMappingType entityDescriptor=factory.getRuntimeMetamodels().getEntityMappingType(mutatingEntityName);\nfinal JdbcParameterBindings jdbcParameterBindings=new JdbcParameterBindingsImpl(domainParameterXref.getQueryParameterCount());\nfinal MutableInteger valueIndexCounter=new MutableInteger();\nSqmMutationStrategyHelper.visitCollectionTables(entityDescriptor,pluralAttribute -> {\n  if (pluralAttribute.getSeparateCollectionTable() != null) {\n    final ModelPart fkTargetPart=pluralAttribute.getKeyDescriptor().getTargetPart();\n    final int valueIndex;\n    if (fkTargetPart instanceof EntityIdentifierMapping) {\n      valueIndex=0;\n    }\n else {\n      if (valueIndexCounter.get() == 0) {\n        valueIndexCounter.set(entityDescriptor.getIdentifierMapping().getJdbcTypeCount());\n      }\n      valueIndex=valueIndexCounter.get();\n      valueIndexCounter.plus(fkTargetPart.getJdbcTypeCount());\n    }\n    executeDelete(pluralAttribute.getSeparateCollectionTable(),entityDescriptor,() -> fkTargetPart::forEachSelectable,idsAndFks,valueIndex,fkTargetPart,jdbcParameterBindings,executionContext);\n  }\n}\n);\nentityDescriptor.visitConstraintOrderedTables((tableExpression,tableKeyColumnsVisitationSupplier) -> {\n  executeDelete(tableExpression,entityDescriptor,tableKeyColumnsVisitationSupplier,idsAndFks,0,null,jdbcParameterBindings,executionContext);\n}\n);\nreturn idsAndFks.size();\n}\nmethodSignature: org.hibernate.engine.jdbc.internal.JdbcCoordinatorImpl#hasRegisteredResources\n methodBody: private boolean hasRegisteredResources() {\nreturn getLogicalConnection().getResourceRegistry().hasRegisteredResources();\n}\nmethodSignature: org.hibernate.engine.jdbc.batch.spi.Batch#release\n methodBody: void release();\nmethodSignature: org.hibernate.engine.jdbc.batch.internal.UnmodifiableBatchBuilderImpl#buildBatch\n methodBody: public Batch buildBatch(BatchKey key, JdbcCoordinator jdbcCoordinator) {\nreturn SharedBatchBuildingCode.buildBatch(jdbcBatchSize,key,jdbcCoordinator);\n}\nmethodSignature: org.hibernate.persister.entity.AbstractEntityPersister#isInstance\n methodBody: public boolean isInstance(Object object) {\nreturn getRepresentationStrategy().getInstantiator().isInstance(object,getFactory());\n}\nmethodSignature: org.hibernate.orm.test.jpa.transaction.batch.JtaWithFailingBatchTest.TestBatch#addToBatch\n methodBody: public void addToBatch() {\nthrow sqlExceptionHelper().convert(new SQLException(\"fake SQLException\"),\"could not perform addBatch\",currentStatementSql);\n}\nmethodSignature: org.hibernate.action.internal.BulkOperationCleanupAction#execute\n methodBody: public void execute() throws HibernateException {\n}\nmethodSignature: org.hibernate.orm.test.jpa.transaction.batch.JtaWithFailingBatchTest.TestBatch#getBatchStatement\n methodBody: public PreparedStatement getBatchStatement(String sql, boolean callable) {\ncurrentStatementSql=sql;\nPreparedStatement batchStatement=super.getBatchStatement(sql,callable);\ncreatedStatements.add(batchStatement);\nreturn batchStatement;\n}\nmethodSignature: org.hibernate.engine.jdbc.batch.spi.BatchBuilder#buildBatch\n methodBody: Batch buildBatch(BatchKey key, JdbcCoordinator jdbcCoordinator);\nmethodSignature: org.hibernate.procedure.internal.ProcedureCallImpl#execute\n methodBody: public boolean execute() {\ntryreturn outputs().getCurrent() instanceof ResultSetOutput;\ncatch(NoMoreOutputsException e)return false;\ncatch(HibernateException he)throw getSession().getExceptionConverter().convert(he);\ncatch(RuntimeException e)getSession().markForRollbackOnly();\nthrow e;\n}\nmethodSignature: org.hibernate.query.sqm.mutation.internal.cte.CteInsertHandler#execute\n methodBody: public int execute(DomainQueryExecutionContext executionContext) {\nfinal SqmInsertStatement<?> sqmInsertStatement=getSqmStatement();\nfinal SessionFactoryImplementor factory=executionContext.getSession().getFactory();\nfinal EntityPersister entityDescriptor=getEntityDescriptor().getEntityPersister();\nfinal String explicitDmlTargetAlias;\nif(sqmInsertStatement.getTarget().getExplicitAlias() == null){explicitDmlTargetAlias=\"dml_target\";\n}{explicitDmlTargetAlias=sqmInsertStatement.getTarget().getExplicitAlias();\n}final MultiTableSqmMutationConverter sqmConverter=new MultiTableSqmMutationConverter(entityDescriptor,sqmInsertStatement,sqmInsertStatement.getTarget(),explicitDmlTargetAlias,domainParameterXref,executionContext.getQueryOptions(),executionContext.getSession().getLoadQueryInfluencers(),executionContext.getQueryParameterBindings(),factory);\nfinal TableGroup insertingTableGroup=sqmConverter.getMutatingTableGroup();\nfinal Map<SqmParameter<?>,List<List<JdbcParameter>>> parameterResolutions;\nif(domainParameterXref.getSqmParameterCount() == 0){parameterResolutions=Collections.emptyMap();\n}{parameterResolutions=new IdentityHashMap<>();\n}final int size=sqmStatement.getInsertionTargetPaths().size();\nfinal List<Map.Entry<List<CteColumn>,Assignment>> targetPathColumns=new ArrayList<>(size);\nfinal List<CteColumn> targetPathCteColumns=new ArrayList<>(size);\nfinal Map<SqmParameter<?>,MappingModelExpressible<?>> paramTypeResolutions=new LinkedHashMap<>();\nfinal NamedTableReference entityTableReference=new NamedTableReference(cteTable.getTableExpression(),TemporaryTable.DEFAULT_ALIAS,true,sessionFactory);\nfinal InsertStatement insertStatement=new InsertStatement(entityTableReference);\nfinal BaseSqmToSqlAstConverter.AdditionalInsertValues additionalInsertValues=sqmConverter.visitInsertionTargetPaths((assignable,columnReferences) -> {\n  final SqmPathInterpretation<?> pathInterpretation=(SqmPathInterpretation<?>)assignable;\n  final int offset=CteTable.determineModelPartStartIndex(entityDescriptor,pathInterpretation.getExpressionType());\n  if (offset == -1) {\n    throw new IllegalStateException(\"Couldn't find matching cte column for: \" + ((Expression)assignable).getExpressionType());\n  }\n  final int end=offset + pathInterpretation.getExpressionType().getJdbcTypeCount();\n  final List<CteColumn> columns=cteTable.getCteColumns().subList(offset,end);\n  insertStatement.addTargetColumnReferences(columnReferences);\n  targetPathCteColumns.addAll(columns);\n  targetPathColumns.add(new AbstractMap.SimpleEntry<>(columns,new Assignment(assignable,(Expression)assignable)));\n}\n,sqmInsertStatement,entityDescriptor,insertingTableGroup,(sqmParameter,mappingType,jdbcParameters) -> {\n  parameterResolutions.computeIfAbsent(sqmParameter,k -> new ArrayList<>(1)).add(jdbcParameters);\n  paramTypeResolutions.put(sqmParameter,mappingType);\n}\n);\nfinal boolean assignsId=targetPathCteColumns.contains(cteTable.getCteColumns().get(0));\nfinal Stack<SqlAstProcessingState> processingStateStack=sqmConverter.getProcessingStateStack();\nfinal SqlAstProcessingState oldState=processingStateStack.pop();\nfinal Statement queryStatement;\nif(sqmInsertStatement instanceof SqmInsertSelectStatement){final QueryPart queryPart=sqmConverter.visitQueryPart(((SqmInsertSelectStatement<?>)sqmInsertStatement).getSelectQueryPart());\nqueryPart.visitQuerySpecs(querySpec -> {\n  if (additionalInsertValues.applySelections(querySpec,sessionFactory)) {\n    final CteColumn rowNumberColumn=cteTable.getCteColumns().get(cteTable.getCteColumns().size() - 1);\n    final ColumnReference columnReference=new ColumnReference((String)null,rowNumberColumn.getColumnExpression(),false,null,null,rowNumberColumn.getJdbcMapping());\n    insertStatement.getTargetColumnReferences().set(insertStatement.getTargetColumnReferences().size() - 1,columnReference);\n    targetPathCteColumns.set(targetPathCteColumns.size() - 1,rowNumberColumn);\n  }\n  if (!assignsId && entityDescriptor.getIdentifierGenerator() instanceof PostInsertIdentifierGenerator) {\n    querySpec.getSelectClause().addSqlSelection(new SqlSelectionImpl(1,0,SqmInsertStrategyHelper.createRowNumberingExpression(querySpec,sessionFactory)));\n  }\n}\n);\nqueryStatement=new SelectStatement(queryPart);\n}{final List<SqmValues> sqmValuesList=((SqmInsertValuesStatement<?>)sqmInsertStatement).getValuesList();\nfinal List<Values> valuesList=new ArrayList<>(sqmValuesList.size());\nfor(SqmValues sqmValues: sqmValuesList){final Values values=sqmConverter.visitValues(sqmValues);\nadditionalInsertValues.applyValues(values);\nvaluesList.add(values);\n}final QuerySpec querySpec=new QuerySpec(true);\nfinal NavigablePath navigablePath=new NavigablePath(entityDescriptor.getRootPathName());\nfinal List<String> columnNames=new ArrayList<>(targetPathColumns.size());\nfinal String valuesAlias=insertingTableGroup.getPrimaryTableReference().getIdentificationVariable();\nfor(Map.Entry<List<CteColumn>,Assignment> entry: targetPathColumns){for(ColumnReference columnReference: entry.getValue().getAssignable().getColumnReferences()){columnNames.add(columnReference.getColumnExpression());\nquerySpec.getSelectClause().addSqlSelection(new SqlSelectionImpl(1,0,columnReference.getQualifier().equals(valuesAlias) ? columnReference : new ColumnReference(valuesAlias,columnReference.getColumnExpression(),false,null,null,columnReference.getJdbcMapping())));\n}}final ValuesTableGroup valuesTableGroup=new ValuesTableGroup(navigablePath,entityDescriptor.getEntityPersister(),valuesList,insertingTableGroup.getPrimaryTableReference().getIdentificationVariable(),columnNames,true,factory);\nquerySpec.getFromClause().addRoot(valuesTableGroup);\nqueryStatement=new SelectStatement(querySpec);\n}processingStateStack.push(oldState);\nsqmConverter.pruneTableGroupJoins();\nif(!assignsId && entityDescriptor.getIdentifierGenerator() instanceof PostInsertIdentifierGenerator){final CteColumn rowNumberColumn=cteTable.getCteColumns().get(cteTable.getCteColumns().size() - 1);\nfinal ColumnReference columnReference=new ColumnReference((String)null,rowNumberColumn.getColumnExpression(),false,null,null,rowNumberColumn.getJdbcMapping());\ninsertStatement.getTargetColumnReferences().add(columnReference);\ntargetPathCteColumns.add(rowNumberColumn);\n}final CteTable entityCteTable=createCteTable(getCteTable(),targetPathCteColumns,factory);\nfinal QuerySpec querySpec=new QuerySpec(true,1);\nfinal List<DomainResult<?>> domainResults=new ArrayList<>(1);\nfinal SelectStatement statement=new SelectStatement(querySpec,domainResults);\nfinal CteStatement entityCte;\nif(additionalInsertValues.requiresRowNumberIntermediate()){final CteTable fullEntityCteTable=getCteTable();\nfinal String baseTableName=\"base_\" + entityCteTable.getTableExpression();\nfinal CteStatement baseEntityCte=new CteStatement(entityCteTable.withName(baseTableName),queryStatement,CteMaterialization.MATERIALIZED);\nstatement.addCteStatement(baseEntityCte);\nfinal CteColumn rowNumberColumn=fullEntityCteTable.getCteColumns().get(fullEntityCteTable.getCteColumns().size() - 1);\nfinal ColumnReference rowNumberColumnReference=new ColumnReference(\"e\",rowNumberColumn.getColumnExpression(),false,null,null,rowNumberColumn.getJdbcMapping());\nfinal CteColumn idColumn=fullEntityCteTable.getCteColumns().get(0);\nfinal BasicValuedMapping idType=(BasicValuedMapping)idColumn.getJdbcMapping();\nfinal Optimizer optimizer=((OptimizableGenerator)entityDescriptor.getIdentifierGenerator()).getOptimizer();\nfinal BasicValuedMapping integerType=(BasicValuedMapping)rowNumberColumn.getJdbcMapping();\nfinal Expression rowNumberMinusOneModuloIncrement=new BinaryArithmeticExpression(new BinaryArithmeticExpression(rowNumberColumnReference,BinaryArithmeticOperator.SUBTRACT,new QueryLiteral<>(1,(BasicValuedMapping)rowNumberColumn.getJdbcMapping()),integerType),BinaryArithmeticOperator.MODULO,new QueryLiteral<>(optimizer.getIncrementSize(),integerType),integerType);\n{final QuerySpec rowsWithSequenceQuery=new QuerySpec(true);\nrowsWithSequenceQuery.getFromClause().addRoot(new CteTableGroup(new NamedTableReference(baseTableName,\"e\",false,factory)));\nrowsWithSequenceQuery.getSelectClause().addSqlSelection(new SqlSelectionImpl(1,0,rowNumberColumnReference));\nfinal String fragment=((BulkInsertionCapableIdentifierGenerator)entityDescriptor.getIdentifierGenerator()).determineBulkInsertionIdentifierGenerationSelectFragment(sessionFactory.getSqlStringGenerationContext());\nrowsWithSequenceQuery.getSelectClause().addSqlSelection(new SqlSelectionImpl(2,1,new SelfRenderingSqlFragmentExpression(fragment)));\nrowsWithSequenceQuery.applyPredicate(new ComparisonPredicate(rowNumberMinusOneModuloIncrement,ComparisonOperator.EQUAL,new QueryLiteral<>(0,integerType)));\nfinal CteTable rowsWithSequenceCteTable=new CteTable(ROW_NUMBERS_WITH_SEQUENCE_VALUE,List.of(rowNumberColumn,idColumn));\nfinal SelectStatement rowsWithSequenceStatement=new SelectStatement(rowsWithSequenceQuery);\nfinal CteStatement rowsWithSequenceCte=new CteStatement(rowsWithSequenceCteTable,rowsWithSequenceStatement,CteMaterialization.MATERIALIZED);\nstatement.addCteStatement(rowsWithSequenceCte);\n}{final QuerySpec entityQuery=new QuerySpec(true);\nfinal NavigablePath navigablePath=new NavigablePath(baseTableName);\nfinal TableGroup baseTableGroup=new TableGroupImpl(navigablePath,null,new NamedTableReference(baseTableName,\"e\",false,factory),null);\nfinal TableGroup rowsWithSequenceTableGroup=new CteTableGroup(new NamedTableReference(ROW_NUMBERS_WITH_SEQUENCE_VALUE,\"t\",false,factory));\nbaseTableGroup.addTableGroupJoin(new TableGroupJoin(rowsWithSequenceTableGroup.getNavigablePath(),SqlAstJoinType.LEFT,rowsWithSequenceTableGroup,new ComparisonPredicate(new BinaryArithmeticExpression(rowNumberColumnReference,BinaryArithmeticOperator.SUBTRACT,rowNumberMinusOneModuloIncrement,integerType),ComparisonOperator.EQUAL,new ColumnReference(\"t\",rowNumberColumn.getColumnExpression(),false,null,null,rowNumberColumn.getJdbcMapping()))));\nentityQuery.getFromClause().addRoot(baseTableGroup);\nentityQuery.getSelectClause().addSqlSelection(new SqlSelectionImpl(1,0,new BinaryArithmeticExpression(new ColumnReference(\"t\",idColumn.getColumnExpression(),false,null,null,idColumn.getJdbcMapping()),BinaryArithmeticOperator.ADD,new BinaryArithmeticExpression(rowNumberColumnReference,BinaryArithmeticOperator.SUBTRACT,new ColumnReference(\"t\",rowNumberColumn.getColumnExpression(),false,null,null,rowNumberColumn.getJdbcMapping()),integerType),idType)));\nfinal CteTable finalEntityCteTable;\nif(targetPathCteColumns.contains(getCteTable().getCteColumns().get(0))){finalEntityCteTable=entityCteTable;\n}{targetPathCteColumns.add(0,getCteTable().getCteColumns().get(0));\nfinalEntityCteTable=createCteTable(getCteTable(),targetPathCteColumns,factory);\n}final List<CteColumn> cteColumns=finalEntityCteTable.getCteColumns();\nfor(int i=1; i < cteColumns.size(); i++){final CteColumn cteColumn=cteColumns.get(i);\nentityQuery.getSelectClause().addSqlSelection(new SqlSelectionImpl(i + 1,i,new ColumnReference(\"e\",cteColumn.getColumnExpression(),false,null,null,cteColumn.getJdbcMapping())));\n}final SelectStatement entityStatement=new SelectStatement(entityQuery);\nentityCte=new CteStatement(finalEntityCteTable,entityStatement,CteMaterialization.MATERIALIZED);\nstatement.addCteStatement(entityCte);\n}}if(!assignsId && entityDescriptor.getIdentifierGenerator() instanceof PostInsertIdentifierGenerator){final String baseTableName=\"base_\" + entityCteTable.getTableExpression();\nfinal CteStatement baseEntityCte=new CteStatement(entityCteTable.withName(baseTableName),queryStatement,CteMaterialization.MATERIALIZED);\nstatement.addCteStatement(baseEntityCte);\ntargetPathCteColumns.add(0,cteTable.getCteColumns().get(0));\nfinal CteTable finalEntityCteTable=createCteTable(getCteTable(),targetPathCteColumns,factory);\nfinal QuerySpec finalQuerySpec=new QuerySpec(true);\nfinal SelectStatement finalQueryStatement=new SelectStatement(finalQuerySpec);\nentityCte=new CteStatement(finalEntityCteTable,finalQueryStatement,CteMaterialization.MATERIALIZED);\n}{entityCte=new CteStatement(entityCteTable,queryStatement,CteMaterialization.MATERIALIZED);\nstatement.addCteStatement(entityCte);\n}final String baseInsertCte=addDmlCtes(statement,entityCte,targetPathColumns,assignsId,sqmConverter,parameterResolutions,factory);\nfinal Expression count=createCountStar(factory,sqmConverter);\ndomainResults.add(new BasicResult<>(0,null,((SqlExpressible)count).getJdbcMapping()));\nquerySpec.getSelectClause().addSqlSelection(new SqlSelectionImpl(1,0,count));\nquerySpec.getFromClause().addRoot(new CteTableGroup(new NamedTableReference(baseInsertCte,CTE_TABLE_IDENTIFIER,false,factory)));\nfinal JdbcServices jdbcServices=factory.getJdbcServices();\nfinal SqlAstTranslator<JdbcSelect> translator=jdbcServices.getJdbcEnvironment().getSqlAstTranslatorFactory().buildSelectTranslator(factory,statement);\nfinal JdbcParameterBindings jdbcParameterBindings=SqmUtil.createJdbcParameterBindings(executionContext.getQueryParameterBindings(),domainParameterXref,SqmUtil.generateJdbcParamsXref(domainParameterXref,sqmConverter),factory.getRuntimeMetamodels().getMappingMetamodel(),navigablePath -> sqmConverter.getMutatingTableGroup(),new SqmParameterMappingModelResolutionAccess(){\n  @Override @SuppressWarnings(\"unchecked\") public <T>MappingModelExpressible<T> getResolvedMappingModelType(  SqmParameter<T> parameter){\n    return (MappingModelExpressible<T>)paramTypeResolutions.get(parameter);\n  }\n}\n,executionContext.getSession());\nfinal JdbcSelect select=translator.translate(jdbcParameterBindings,executionContext.getQueryOptions());\nexecutionContext.getSession().autoFlushIfRequired(select.getAffectedTableNames());\nList<Object> list=jdbcServices.getJdbcSelectExecutor().list(select,jdbcParameterBindings,SqmJdbcExecutionContextAdapter.omittingLockingAndPaging(executionContext),row -> row[0],ListResultsConsumer.UniqueSemantic.NONE);\nreturn ((Number)list.get(0)).intValue();\n}\nmethodSignature: org.hibernate.query.sqm.mutation.internal.temptable.InsertExecutionDelegate#execute\n methodBody: public int execute(ExecutionContext executionContext) {\nExecuteWithTemporaryTableHelper.performBeforeTemporaryTableUseActions(entityTable,executionContext);\ntryif(sessionUidParameter != null){jdbcParameterBindings.addBinding(sessionUidParameter,new JdbcParameterBindingImpl(entityTable.getSessionUidColumn().getJdbcMapping(),UUID.fromString(sessionUidAccess.apply(executionContext.getSession()))));\n}final int rows=ExecuteWithTemporaryTableHelper.saveIntoTemporaryTable(insertStatement,jdbcParameterBindings,executionContext);\nif(rows != 0){final AbstractEntityPersister persister=(AbstractEntityPersister)entityDescriptor.getEntityPersister();\nfinal int tableSpan=persister.getTableSpan();\ninsertRootTable(persister.getTableName(0),rows,persister.getKeyColumns(0),executionContext);\nif(persister.hasDuplicateTables()){final String[] insertedTables=new String[tableSpan];\ninsertedTables[0]=persister.getTableName(0);\nfor(int i=1; i < tableSpan; i++){if(persister.isInverseTable(i)){continue;\n}final String tableName=persister.getTableName(i);\ninsertedTables[i]=tableName;\nif(ArrayHelper.indexOf(insertedTables,i,tableName) != -1){continue;\n}insertTable(tableName,persister.getKeyColumns(i),persister.isNullableTable(i),executionContext);\n}}{for(int i=1; i < tableSpan; i++){insertTable(persister.getTableName(i),persister.getKeyColumns(i),persister.isNullableTable(i),executionContext);\n}}}return rows;\nfinallyExecuteWithTemporaryTableHelper.performAfterTemporaryTableUseActions(entityTable,sessionUidAccess,afterUseAction,executionContext);\n}\nmethodSignature: org.hibernate.engine.jdbc.internal.JdbcCoordinatorImpl#getResultSetReturn\n methodBody: public ResultSetReturn getResultSetReturn() {\nif(resultSetExtractor == null){resultSetExtractor=new ResultSetReturnImpl(this,jdbcServices);\n}return resultSetExtractor;\n}\nmethodSignature: org.hibernate.engine.jdbc.batch.spi.Batch#addObserver\n methodBody: void addObserver(BatchObserver observer);\nmethodSignature: org.hibernate.query.sqm.mutation.internal.temptable.UpdateExecutionDelegate#execute\n methodBody: public int execute(ExecutionContext executionContext) {\nExecuteWithTemporaryTableHelper.performBeforeTemporaryTableUseActions(idTable,executionContext);\ntryfinal int rows=ExecuteWithTemporaryTableHelper.saveMatchingIdsIntoIdTable(sqmConverter,suppliedPredicate,idTable,sessionUidAccess,jdbcParameterBindings,executionContext);\nfinal QuerySpec idTableSubQuery=ExecuteWithTemporaryTableHelper.createIdTableSelectQuerySpec(idTable,sessionUidAccess,entityDescriptor,executionContext);\nentityDescriptor.visitConstraintOrderedTables((tableExpression,tableKeyColumnVisitationSupplier) -> updateTable(tableExpression,tableKeyColumnVisitationSupplier,rows,idTableSubQuery,executionContext));\nreturn rows;\nfinallyExecuteWithTemporaryTableHelper.performAfterTemporaryTableUseActions(idTable,sessionUidAccess,afterUseAction,executionContext);\n}\nmethodSignature: org.hibernate.metamodel.mapping.internal.MappingModelCreationProcess#execute\n methodBody: private void execute() {\nfor(EntityPersister entityPersister: entityPersisterMap.values()){if(entityPersister instanceof InFlightEntityMappingType){((InFlightEntityMappingType)entityPersister).linkWithSuperType(this);\n}}for(EntityPersister entityPersister: entityPersisterMap.values()){currentlyProcessingRole=entityPersister.getEntityName();\nif(entityPersister instanceof InFlightEntityMappingType){((InFlightEntityMappingType)entityPersister).prepareMappingModel(this);\n}}executePostInitCallbacks();\n}\nmethodSignature: org.hibernate.orm.test.insertordering.InsertOrderingTest.StatsBatchBuilder#buildBatch\n methodBody: public Batch buildBatch(BatchKey key, JdbcCoordinator jdbcCoordinator) {\nreturn new StatsBatch(key,jdbcCoordinator,getJdbcBatchSize());\n}\nmethodSignature: org.hibernate.query.sqm.mutation.internal.cte.AbstractCteMutationHandler#execute\n methodBody: public int execute(DomainQueryExecutionContext executionContext) {\nfinal SqmDeleteOrUpdateStatement sqmMutationStatement=getSqmDeleteOrUpdateStatement();\nfinal SessionFactoryImplementor factory=executionContext.getSession().getFactory();\nfinal EntityMappingType entityDescriptor=getEntityDescriptor();\nfinal String explicitDmlTargetAlias;\nif(sqmMutationStatement.getTarget().getExplicitAlias() == null){explicitDmlTargetAlias=\"dml_target\";\n}{explicitDmlTargetAlias=sqmMutationStatement.getTarget().getExplicitAlias();\n}final MultiTableSqmMutationConverter sqmConverter=new MultiTableSqmMutationConverter(entityDescriptor,sqmMutationStatement,sqmMutationStatement.getTarget(),explicitDmlTargetAlias,domainParameterXref,executionContext.getQueryOptions(),executionContext.getSession().getLoadQueryInfluencers(),executionContext.getQueryParameterBindings(),factory);\nfinal Map<SqmParameter<?>,List<JdbcParameter>> parameterResolutions;\nif(domainParameterXref.getSqmParameterCount() == 0){parameterResolutions=Collections.emptyMap();\n}{parameterResolutions=new IdentityHashMap<>();\n}final Map<SqmParameter,MappingModelExpressible> paramTypeResolutions=new LinkedHashMap<>();\nfinal Predicate restriction=sqmConverter.visitWhereClause(sqmMutationStatement.getWhereClause(),columnReference -> {\n}\n,(sqmParam,mappingType,jdbcParameters) -> paramTypeResolutions.put(sqmParam,mappingType));\nsqmConverter.pruneTableGroupJoins();\nfinal CteStatement idSelectCte=new CteStatement(getCteTable(),MatchingIdSelectionHelper.generateMatchingIdSelectStatement(entityDescriptor,sqmMutationStatement,true,restriction,sqmConverter,executionContext,factory),CteMaterialization.MATERIALIZED);\nfinal QuerySpec querySpec=new QuerySpec(true,1);\nfinal List<DomainResult<?>> domainResults=new ArrayList<>(1);\nfinal SelectStatement statement=new SelectStatement(querySpec,domainResults);\nfinal JdbcServices jdbcServices=factory.getJdbcServices();\nfinal SqlAstTranslator<JdbcSelect> translator=jdbcServices.getJdbcEnvironment().getSqlAstTranslatorFactory().buildSelectTranslator(factory,statement);\nfinal Expression count=createCountStar(factory,sqmConverter);\ndomainResults.add(new BasicResult<>(0,null,((SqlExpressible)count).getJdbcMapping()));\nquerySpec.getSelectClause().addSqlSelection(new SqlSelectionImpl(1,0,count));\nquerySpec.getFromClause().addRoot(new CteTableGroup(new NamedTableReference(idSelectCte.getCteTable().getTableExpression(),CTE_TABLE_IDENTIFIER,false,factory)));\nstatement.addCteStatement(idSelectCte);\naddDmlCtes(statement,idSelectCte,sqmConverter,parameterResolutions,factory);\nfinal JdbcParameterBindings jdbcParameterBindings=SqmUtil.createJdbcParameterBindings(executionContext.getQueryParameterBindings(),domainParameterXref,SqmUtil.generateJdbcParamsXref(domainParameterXref,sqmConverter),factory.getRuntimeMetamodels().getMappingMetamodel(),navigablePath -> sqmConverter.getMutatingTableGroup(),paramTypeResolutions::get,executionContext.getSession());\nfinal LockOptions lockOptions=executionContext.getQueryOptions().getLockOptions();\nfinal LockMode lockMode=lockOptions.getAliasSpecificLockMode(explicitDmlTargetAlias);\nlockOptions.setAliasSpecificLockMode(explicitDmlTargetAlias,LockMode.WRITE);\nfinal JdbcSelect select=translator.translate(jdbcParameterBindings,executionContext.getQueryOptions());\nlockOptions.setAliasSpecificLockMode(explicitDmlTargetAlias,lockMode);\nexecutionContext.getSession().autoFlushIfRequired(select.getAffectedTableNames());\nList<Object> list=jdbcServices.getJdbcSelectExecutor().list(select,jdbcParameterBindings,SqmJdbcExecutionContextAdapter.omittingLockingAndPaging(executionContext),row -> row[0],ListResultsConsumer.UniqueSemantic.NONE);\nreturn ((Number)list.get(0)).intValue();\n}\nmethodSignature: org.hibernate.mapping.Component.ValueGenerationPlan#execute\n methodBody: public void execute(SharedSessionContractImplementor session, Object incomingObject, Object injectionContext) {\nfinal Object generatedValue=subGenerator.generate(session,incomingObject);\ninjector.set(injectionContext,generatedValue);\n}\nmethodSignature: org.hibernate.query.sqm.mutation.internal.temptable.TableBasedInsertHandler.ExecutionDelegate#execute\n methodBody: int execute(ExecutionContext executionContext);\nmethodSignature: org.hibernate.dialect.AbstractHANADialect.MaterializedNClob#setString\n methodBody: public int setString(long pos, String str) throws SQLException {\nthis.data=this.data.substring(0,(int)(pos - 1)) + str + this.data.substring((int)(pos - 1 + str.length()));\nreturn str.length();\n}\nmethodSignature: org.hibernate.engine.jdbc.batch.internal.NonBatchingBatch#addToBatch\n methodBody: public void addToBatch() {\nnotifyObserversImplicitExecution();\nfor(Map.Entry<String,PreparedStatement> entry: getStatements().entrySet()){final String statementSQL=entry.getKey();\ntryfinal PreparedStatement statement=entry.getValue();\nfinal int rowCount=jdbcCoordinator.getResultSetReturn().executeUpdate(statement);\ngetKey().getExpectation().verifyOutcome(rowCount,statement,0,statementSQL);\njdbcCoordinator.getLogicalConnection().getResourceRegistry().release(statement);\njdbcCoordinator.afterStatementExecution();\ncatch(SQLException e)abortBatch(e);\nthrow sqlExceptionHelper().convert(e,\"could not execute non-batched batch statement\",statementSQL);\ncatch(RuntimeException e)abortBatch(e);\nthrow e;\n}getStatements().clear();\n}\nmethodSignature: org.hibernate.engine.jdbc.internal.JdbcCoordinatorImpl#getStatementPreparer\n methodBody: public StatementPreparer getStatementPreparer() {\nif(statementPreparer == null){statementPreparer=new StatementPreparerImpl(this,jdbcServices);\n}return statementPreparer;\n}\nmethodSignature: org.hibernate.sql.Insert#getDialect\n methodBody: protected Dialect getDialect() {\nreturn dialect;\n}\nmethodSignature: org.hibernate.engine.jdbc.batch.internal.AbstractBatchImpl#release\n methodBody: public void release() {\nif(getStatements() != null && !getStatements().isEmpty()){LOG.batchContainedStatementsOnRelease();\n}releaseStatements();\nobservers.clear();\n}\nmethodSignature: org.hibernate.sql.exec.internal.StandardJdbcMutationExecutor#execute\n methodBody: public int execute(\n\t\t\tJdbcMutation jdbcMutation,\n\t\t\tJdbcParameterBindings jdbcParameterBindings,\n\t\t\tFunction<String, PreparedStatement> statementCreator,\n\t\t\tBiConsumer<Integer, PreparedStatement> expectationCheck,\n\t\t\tExecutionContext executionContext) {\nfinal SharedSessionContractImplementor session=executionContext.getSession();\nsession.autoFlushIfRequired(jdbcMutation.getAffectedTableNames());\nfinal LogicalConnectionImplementor logicalConnection=session.getJdbcCoordinator().getLogicalConnection();\nfinal JdbcServices jdbcServices=session.getJdbcServices();\nfinal QueryOptions queryOptions=executionContext.getQueryOptions();\nfinal String finalSql;\nif(queryOptions == null){finalSql=jdbcMutation.getSql();\n}{finalSql=jdbcServices.getDialect().addSqlHintOrComment(jdbcMutation.getSql(),queryOptions,executionContext.getSession().getFactory().getSessionFactoryOptions().isCommentsEnabled());\n}tryfinal PreparedStatement preparedStatement=statementCreator.apply(finalSql);\ntryif(executionContext.getQueryOptions().getTimeout() != null){preparedStatement.setQueryTimeout(executionContext.getQueryOptions().getTimeout());\n}int paramBindingPosition=1;\nfor(JdbcParameterBinder parameterBinder: jdbcMutation.getParameterBinders()){parameterBinder.bindParameterValue(preparedStatement,paramBindingPosition++,jdbcParameterBindings,executionContext);\n}session.getEventListenerManager().jdbcExecuteStatementStart();\ntryint rows=preparedStatement.executeUpdate();\nexpectationCheck.accept(rows,preparedStatement);\nreturn rows;\nfinallysession.getEventListenerManager().jdbcExecuteStatementEnd();\nfinallylogicalConnection.getResourceRegistry().release(preparedStatement);\ncatch(SQLException e)throw jdbcServices.getSqlExceptionHelper().convert(e,\"JDBC exception executing SQL [\" + finalSql + \"]\");\nfinallyexecutionContext.afterStatement(logicalConnection);\n}\nmethodSignature: org.hibernate.sql.exec.spi.JdbcMutationExecutor#execute\n methodBody: int execute(\n\t\t\tJdbcMutation jdbcMutation,\n\t\t\tJdbcParameterBindings jdbcParameterBindings,\n\t\t\tFunction<String, PreparedStatement> statementCreator,\n\t\t\tBiConsumer<Integer, PreparedStatement> expectationCheck,\n\t\t\tExecutionContext executionContext);\nmethodSignature: org.hibernate.engine.jdbc.batch.internal.AbstractBatchImpl#addObserver\n methodBody: public void addObserver(BatchObserver observer) {\nobservers.add(observer);\n}\nmethodSignature: org.hibernate.engine.jdbc.batch.internal.BatchBuilderImpl#setJdbcBatchSize\n methodBody: public void setJdbcBatchSize(int jdbcBatchSize) {\nthis.jdbcBatchSize=jdbcBatchSize;\n}\nmethodSignature: org.hibernate.engine.jdbc.batch.internal.BatchingBatch#getBatchStatement\n methodBody: public PreparedStatement getBatchStatement(String sql, boolean callable) {\ncurrentStatementSql=sql;\nint previousBatchSize=getStatements().size();\ncurrentStatement=super.getBatchStatement(sql,callable);\nint currentBatchSize=getStatements().size();\nif(currentBatchSize > previousBatchSize){this.batchSize=this.configuredBatchSize * currentBatchSize;\n}return currentStatement;\n}\nmethodSignature: org.hibernate.engine.jdbc.batch.spi.Batch#getBatchStatement\n methodBody: PreparedStatement getBatchStatement(String sql, boolean callable);\nmethodSignature: org.hibernate.engine.jdbc.spi.JdbcCoordinator#close\n methodBody: Connection close();\nmethodSignature: org.hibernate.engine.jdbc.batch.spi.Batch#addToBatch\n methodBody: void addToBatch();\nmethodSignature: org.hibernate.engine.jdbc.batch.internal.BatchingBatch#addToBatch\n methodBody: public void addToBatch() {\ntrycurrentStatement.addBatch();\ncatch(SQLException e)abortBatch(e);\nLOG.debug(\"SQLException escaped proxy\",e);\nthrow sqlExceptionHelper().convert(e,\"could not perform addBatch\",currentStatementSql);\ncatch(RuntimeException e)abortBatch(e);\nthrow e;\nstatementPosition++;\nif(statementPosition >= getKey().getBatchedStatementCount()){batchPosition++;\nif(batchPosition == batchSize){notifyObserversImplicitExecution();\nperformExecution();\nbatchPosition=0;\nbatchExecuted=true;\n}statementPosition=0;\n}}\nmethodSignature: org.hibernate.action.internal.BulkOperationCleanupAction.CollectionCleanup#release\n methodBody: private void release() {\ncacheAccess.unlockRegion(cacheLock);\n}\nmethodSignature: org.hibernate.engine.jdbc.batch.internal.AbstractBatchImpl#execute\n methodBody: public final void execute() {\nnotifyObserversExplicitExecution();\nif(getStatements().isEmpty()){return;\n}trydoExecuteBatch();\nfinallyreleaseStatements();\n}\nmethodSignature: org.hibernate.action.internal.BulkOperationCleanupAction.EntityCleanup#release\n methodBody: private void release() {\ncacheAccess.unlockRegion(cacheLock);\n}\nmethodSignature: org.hibernate.sql.results.jdbc.internal.DeferredResultSetAccess#release\n methodBody: public void release() {\nif(resultSet != null){getPersistenceContext().getJdbcCoordinator().getLogicalConnection().getResourceRegistry().release(resultSet,preparedStatement);\nresultSet=null;\n}if(preparedStatement != null){getPersistenceContext().getJdbcCoordinator().getLogicalConnection().getResourceRegistry().release(preparedStatement);\npreparedStatement=null;\n}}\nmethodSignature: org.hibernate.query.sqm.mutation.internal.temptable.RestrictedDeleteExecutionDelegate#execute\n methodBody: public int execute(DomainQueryExecutionContext executionContext) {\nfinal EntityPersister entityDescriptor=sessionFactory.getRuntimeMetamodels().getMappingMetamodel().getEntityDescriptor(sqmDelete.getTarget().getEntityName());\nfinal String hierarchyRootTableName=((Joinable)entityDescriptor).getTableName();\nfinal TableGroup deletingTableGroup=converter.getMutatingTableGroup();\nfinal TableReference hierarchyRootTableReference=deletingTableGroup.resolveTableReference(deletingTableGroup.getNavigablePath(),hierarchyRootTableName);\nassert hierarchyRootTableReference != null;\nfinal Map<SqmParameter<?>,List<List<JdbcParameter>>> parameterResolutions;\nfinal Map<SqmParameter<?>,MappingModelExpressible<?>> paramTypeResolutions;\nif(domainParameterXref.getSqmParameterCount() == 0){parameterResolutions=Collections.emptyMap();\nparamTypeResolutions=Collections.emptyMap();\n}{parameterResolutions=new IdentityHashMap<>();\nparamTypeResolutions=new LinkedHashMap<>();\n}final MutableBoolean needsIdTableWrapper=new MutableBoolean(false);\nfinal Predicate specifiedRestriction=converter.visitWhereClause(sqmDelete.getWhereClause(),columnReference -> {\n  if (!hierarchyRootTableReference.getIdentificationVariable().equals(columnReference.getQualifier())) {\n    needsIdTableWrapper.setValue(true);\n  }\n}\n,(sqmParameter,mappingType,jdbcParameters) -> {\n  parameterResolutions.computeIfAbsent(sqmParameter,k -> new ArrayList<>(1)).add(jdbcParameters);\n  paramTypeResolutions.put(sqmParameter,mappingType);\n}\n);\nfinal PredicateCollector predicateCollector=new PredicateCollector(specifiedRestriction);\nentityDescriptor.applyBaseRestrictions((filterPredicate) -> {\n  needsIdTableWrapper.setValue(true);\n  predicateCollector.applyPredicate(filterPredicate);\n}\n,deletingTableGroup,true,executionContext.getSession().getLoadQueryInfluencers().getEnabledFilters(),null,converter);\nconverter.pruneTableGroupJoins();\nfinal boolean needsIdTable=needsIdTableWrapper.getValue() || entityDescriptor != entityDescriptor.getRootEntityDescriptor();\nfinal SqmJdbcExecutionContextAdapter executionContextAdapter=SqmJdbcExecutionContextAdapter.omittingLockingAndPaging(executionContext);\nif(needsIdTable){return executeWithIdTable(predicateCollector.getPredicate(),deletingTableGroup,parameterResolutions,paramTypeResolutions,executionContextAdapter);\n}{return executeWithoutIdTable(predicateCollector.getPredicate(),deletingTableGroup,parameterResolutions,paramTypeResolutions,converter.getSqlExpressionResolver(),executionContextAdapter);\n}}\nmethodSignature: org.hibernate.orm.test.jpa.transaction.batch.JtaWithFailingBatchTest.TestBatchBuilder#buildBatch\n methodBody: public Batch buildBatch(BatchKey key, JdbcCoordinator jdbcCoordinator) {\nreturn buildBatchTest(key,jdbcCoordinator,getJdbcBatchSize());\n}\nmethodSignature: org.hibernate.orm.test.jpa.transaction.batch.FailingAddToBatchTest.TestBatch#getBatchStatement\n methodBody: public PreparedStatement getBatchStatement(String sql, boolean callable) {\nPreparedStatement batchStatement=super.getBatchStatement(sql,callable);\ncreatedStatements.add(batchStatement);\nreturn batchStatement;\n}\nmethodSignature: org.hibernate.orm.test.jpa.transaction.batch.JtaWithStatementsBatchTest.TestBatchBuilder#buildBatch\n methodBody: public Batch buildBatch(BatchKey key, JdbcCoordinator jdbcCoordinator) {\nreturn buildBatchTest(key,jdbcCoordinator,getJdbcBatchSize());\n}\nmethodSignature: org.hibernate.orm.test.manytomany.batchload.TestingBatchBuilder#buildBatch\n methodBody: public Batch buildBatch(BatchKey key, JdbcCoordinator jdbcCoordinator) {\nreturn new TestingBatch(key,jdbcCoordinator);\n}\nmethodSignature: org.hibernate.persister.collection.AbstractCollectionPersister#getDialect\n methodBody: protected Dialect getDialect() {\nreturn dialect;\n}\nmethodSignature: org.hibernate.engine.jdbc.spi.JdbcCoordinator#getLogicalConnection\n methodBody: LogicalConnectionImplementor getLogicalConnection();\nmethodSignature: org.hibernate.query.sqm.mutation.internal.temptable.TableBasedInsertHandler#execute\n methodBody: public int execute(DomainQueryExecutionContext executionContext) {\nif(log.isTraceEnabled()){log.tracef(\"Starting multi-table insert execution - %s\",getSqmInsertStatement().getTarget().getModel().getName());\n}final SqmJdbcExecutionContextAdapter executionContextAdapter=SqmJdbcExecutionContextAdapter.omittingLockingAndPaging(executionContext);\nreturn resolveDelegate(executionContext).execute(executionContextAdapter);\n}\nmethodSignature: org.hibernate.orm.test.insertordering.InsertOrderingTest.StatsBatch#getBatchStatement\n methodBody: public PreparedStatement getBatchStatement(String sql, boolean callable) {\nif(batchSQL == null || !batchSQL.equals(sql)){currentBatch++;\nbatchSQL=sql;\nbatchSizes.add(currentBatch,new Counter());\n}return super.getBatchStatement(sql,callable);\n}\nmethodSignature: org.hibernate.engine.jdbc.spi.JdbcCoordinator#getResultSetReturn\n methodBody: ResultSetReturn getResultSetReturn();\nmethodSignature: org.hibernate.sql.ast.spi.AbstractSqlAstTranslator#getDialect\n methodBody: public Dialect getDialect() {\nreturn dialect;\n}\nmethodSignature: org.hibernate.engine.jdbc.batch.internal.BatchBuilderImpl#buildBatch\n methodBody: public Batch buildBatch(BatchKey key, JdbcCoordinator jdbcCoordinator) {\nreturn SharedBatchBuildingCode.buildBatch(jdbcBatchSize,key,jdbcCoordinator);\n}\nmethodSignature: org.hibernate.orm.test.jpa.transaction.batch.FailingAddToBatchTest.TestBatchBuilder#buildBatch\n methodBody: public Batch buildBatch(BatchKey key, JdbcCoordinator jdbcCoordinator) {\nreturn buildBatchTest(key,jdbcCoordinator,getJdbcBatchSize());\n}\nmethodSignature: org.hibernate.orm.test.jpa.transaction.batch.FailingAddToBatchTest.TestBatch#addToBatch\n methodBody: public void addToBatch() {\nRuntimeException failure=nextAddToBatchFailure.getAndSet(null);\nif(failure != null){throw failure;\n}super.addToBatch();\n}\nmethodSignature: org.hibernate.dialect.Dialect#getDropTableString\n methodBody: public String getDropTableString(String tableName) {\nfinal StringBuilder buf=new StringBuilder(\"drop table \");\nif(supportsIfExistsBeforeTableName()){buf.append(\"if exists \");\n}buf.append(tableName).append(getCascadeConstraintsString());\nif(supportsIfExistsAfterTableName()){buf.append(\" if exists\");\n}return buf.toString();\n}\nmethodSignature: org.hibernate.engine.jdbc.batch.internal.AbstractBatchImpl#getJdbcCoordinator\n methodBody: protected JdbcCoordinator getJdbcCoordinator(){\nreturn this.jdbcCoordinator;\n}\nmethodSignature: org.hibernate.engine.jdbc.internal.JdbcCoordinatorImpl#sessionFactory\n methodBody: protected SessionFactoryImplementor sessionFactory() {\nreturn this.owner.getJdbcSessionContext().getSessionFactory();\n}\nmethodSignature: org.hibernate.dialect.AbstractHANADialect.CloseSuppressingReader#close\n methodBody: public void close() {\n}\nmethodSignature: org.hibernate.sql.ast.spi.AbstractSqlAstTranslator#getJdbcServices\n methodBody: protected JdbcServices getJdbcServices() {\nreturn getSessionFactory().getJdbcServices();\n}",
        "classSignatureBefore": "public class BatchingTest extends BaseCoreFunctionalTestCase implements BatchKey ",
        "methodNameBeforeSet": [
            "org.hibernate.orm.test.jdbc.internal.BatchingTest#testSessionBatchingUsage"
        ],
        "classNameBeforeSet": [
            "org.hibernate.orm.test.jdbc.internal.BatchingTest"
        ],
        "classSignatureBeforeSet": [
            "public class BatchingTest extends BaseCoreFunctionalTestCase implements BatchKey "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.\n */\npackage org.hibernate.orm.test.jdbc.internal;\n\nimport java.sql.PreparedStatement;\nimport java.sql.Statement;\n\nimport org.hibernate.Session;\nimport org.hibernate.Transaction;\nimport org.hibernate.engine.jdbc.batch.internal.BasicBatchKey;\nimport org.hibernate.engine.jdbc.batch.internal.BatchBuilderImpl;\nimport org.hibernate.engine.jdbc.batch.internal.BatchingBatch;\nimport org.hibernate.engine.jdbc.batch.internal.NonBatchingBatch;\nimport org.hibernate.engine.jdbc.batch.spi.Batch;\nimport org.hibernate.engine.jdbc.batch.spi.BatchBuilder;\nimport org.hibernate.engine.jdbc.batch.spi.BatchKey;\nimport org.hibernate.engine.jdbc.spi.JdbcCoordinator;\nimport org.hibernate.engine.spi.SessionImplementor;\nimport org.hibernate.jdbc.Expectation;\nimport org.hibernate.jdbc.Expectations;\nimport org.hibernate.resource.jdbc.spi.LogicalConnectionImplementor;\n\nimport org.hibernate.testing.junit4.BaseCoreFunctionalTestCase;\nimport org.hibernate.orm.test.common.JournalingBatchObserver;\nimport org.junit.Test;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertFalse;\nimport static org.junit.Assert.assertSame;\nimport static org.junit.Assert.assertTrue;\n\n/**\n * @author Steve Ebersole\n * @author Brett Meyer\n */\npublic class BatchingTest extends BaseCoreFunctionalTestCase implements BatchKey {\n\t@Override\n\tpublic int getBatchedStatementCount() {\n\t\treturn 1;\n\t}\n\n\t@Override\n\tpublic Expectation getExpectation() {\n\t\treturn Expectations.BASIC;\n\t}\n\n\t@Test\n\tpublic void testNonBatchingUsage() throws Exception {\n\t\tSession session = openSession();\n\t\tSessionImplementor sessionImpl = (SessionImplementor) session;\n\t\t\n\t\tfinal JdbcCoordinator jdbcCoordinator = sessionImpl.getJdbcCoordinator();\n\t\tLogicalConnectionImplementor logicalConnection = jdbcCoordinator.getLogicalConnection();\n\n\t\t// set up some tables to use\n\t\tStatement statement = jdbcCoordinator.getStatementPreparer().createStatement();\n\t\tString dropSql = sessionFactory().getJdbcServices().getDialect().getDropTableString( \"SANDBOX_JDBC_TST\" );\n\t\ttry {\n\t\t\tjdbcCoordinator.getResultSetReturn().execute( statement, dropSql );\n\t\t}\n\t\tcatch ( Exception e ) {\n\t\t\t// ignore if the DB doesn't support \"if exists\" and the table doesn't exist\n\t\t}\n\t\tjdbcCoordinator.getResultSetReturn().execute( statement, \"create table SANDBOX_JDBC_TST ( ID integer, NAME varchar(100) )\" );\n        assertTrue( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n\t\tassertTrue( logicalConnection.isPhysicallyConnected() );\n        jdbcCoordinator.getLogicalConnection().getResourceRegistry().release( statement );\n        assertFalse( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n\t\tassertTrue( logicalConnection.isPhysicallyConnected() ); // after_transaction specified\n\n\t\t// ok, now we can get down to it...\n\t\tTransaction txn = session.getTransaction();  // same as Session#getTransaction\n\t\ttxn.begin();\n\n\t\tfinal String insertSql = \"insert into SANDBOX_JDBC_TST( ID, NAME ) values ( ?, ? )\";\n\n\t\tfinal BatchBuilder batchBuilder = new BatchBuilderImpl( -1 );\n\t\tfinal BatchKey batchKey = new BasicBatchKey( \"this\", Expectations.BASIC );\n\t\tfinal Batch insertBatch = batchBuilder.buildBatch( batchKey, jdbcCoordinator );\n\n\t\tfinal JournalingBatchObserver batchObserver = new JournalingBatchObserver();\n\t\tinsertBatch.addObserver( batchObserver );\n\n\t\tassertTrue( \"unexpected Batch impl\", NonBatchingBatch.class.isInstance( insertBatch ) );\n\t\tPreparedStatement insert = insertBatch.getBatchStatement( insertSql, false );\n\t\tinsert.setLong( 1, 1 );\n\t\tinsert.setString( 2, \"name\" );\n\t\tassertEquals( 0, batchObserver.getExplicitExecutionCount() );\n\t\tassertEquals( 0, batchObserver.getImplicitExecutionCount() );\n\t\tinsertBatch.addToBatch();\n\t\tassertEquals( 0, batchObserver.getExplicitExecutionCount() );\n\t\tassertEquals( 1, batchObserver.getImplicitExecutionCount() );\n        assertFalse( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n\n\t\tinsertBatch.execute();\n\t\tassertEquals( 1, batchObserver.getExplicitExecutionCount() );\n\t\tassertEquals( 1, batchObserver.getImplicitExecutionCount() );\n        assertFalse( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n\n\t\tinsertBatch.release();\n\n\t\ttxn.commit();\n\t\tsession.close();\n\t}\n\n\t@Test\n\tpublic void testBatchingUsage() throws Exception {\n\t\tSession session = openSession();\n\t\tSessionImplementor sessionImpl = (SessionImplementor) session;\n\t\t\n\t\tfinal JdbcCoordinator jdbcCoordinator = sessionImpl.getJdbcCoordinator();\n\t\tLogicalConnectionImplementor logicalConnection = jdbcCoordinator.getLogicalConnection();\n\n\t\t// set up some tables to use\n\t\tStatement statement = jdbcCoordinator.getStatementPreparer().createStatement();\n\t\tString dropSql = sessionFactory().getJdbcServices().getDialect().getDropTableString( \"SANDBOX_JDBC_TST\" );\n\t\ttry {\n\t\t\tjdbcCoordinator.getResultSetReturn().execute( statement, dropSql );\n\t\t}\n\t\tcatch ( Exception e ) {\n\t\t\t// ignore if the DB doesn't support \"if exists\" and the table doesn't exist\n\t\t}\t\tjdbcCoordinator.getResultSetReturn().execute( statement, \"create table SANDBOX_JDBC_TST ( ID integer, NAME varchar(100) )\" );\n        assertTrue( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n\t\tassertTrue( logicalConnection.isPhysicallyConnected() );\n        jdbcCoordinator.getLogicalConnection().getResourceRegistry().release( statement );\n        assertFalse( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n\t\tassertTrue( logicalConnection.isPhysicallyConnected() ); // after_transaction specified\n\n\t\t// ok, now we can get down to it...\n\t\tTransaction txn = session.getTransaction();  // same as Session#getTransaction\n\t\ttxn.begin();\n\n\t\tfinal BatchBuilder batchBuilder = new BatchBuilderImpl( 2 );\n\t\tfinal BatchKey batchKey = new BasicBatchKey( \"this\", Expectations.BASIC );\n\t\tfinal Batch insertBatch = batchBuilder.buildBatch( batchKey, jdbcCoordinator );\n\t\tassertTrue( \"unexpected Batch impl\", BatchingBatch.class.isInstance( insertBatch ) );\n\n\t\tfinal JournalingBatchObserver batchObserver = new JournalingBatchObserver();\n\t\tinsertBatch.addObserver( batchObserver );\n\n\t\tfinal String insertSql = \"insert into SANDBOX_JDBC_TST( ID, NAME ) values ( ?, ? )\";\n\n\t\tPreparedStatement insert = insertBatch.getBatchStatement( insertSql, false );\n\t\tinsert.setLong( 1, 1 );\n\t\tinsert.setString( 2, \"name\" );\n\t\tassertEquals( 0, batchObserver.getExplicitExecutionCount() );\n\t\tassertEquals( 0, batchObserver.getImplicitExecutionCount() );\n\t\tinsertBatch.addToBatch();\n\t\tassertEquals( 0, batchObserver.getExplicitExecutionCount() );\n\t\tassertEquals( 0, batchObserver.getImplicitExecutionCount() );\n        assertTrue( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n\n\t\tPreparedStatement insert2 = insertBatch.getBatchStatement( insertSql, false );\n\t\tassertSame( insert, insert2 );\n\t\tinsert = insert2;\n\t\tinsert.setLong( 1, 2 );\n\t\tinsert.setString( 2, \"another name\" );\n\t\tassertEquals( 0, batchObserver.getExplicitExecutionCount() );\n\t\tassertEquals( 0, batchObserver.getImplicitExecutionCount() );\n\t\tinsertBatch.addToBatch();\n\t\tassertEquals( 0, batchObserver.getExplicitExecutionCount() );\n\t\tassertEquals( 1, batchObserver.getImplicitExecutionCount() );\n        assertTrue( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n\n\t\tinsertBatch.execute();\n\t\tassertEquals( 1, batchObserver.getExplicitExecutionCount() );\n\t\tassertEquals( 1, batchObserver.getImplicitExecutionCount() );\n        assertFalse( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n\n\t\tinsertBatch.release();\n\n\t\ttxn.commit();\n\t\tsession.close();\n\t}\n\n\t@Test\n\tpublic void testSessionBatchingUsage() throws Exception {\n\t\tSession session = openSession();\n\t\tsession.setJdbcBatchSize( 3 );\n\t\tSessionImplementor sessionImpl = (SessionImplementor) session;\n\n\t\tfinal JdbcCoordinator jdbcCoordinator = sessionImpl.getJdbcCoordinator();\n\t\tLogicalConnectionImplementor logicalConnection = jdbcCoordinator.getLogicalConnection();\n\n\t\t// set up some tables to use\n\t\tStatement statement = jdbcCoordinator.getStatementPreparer().createStatement();\n\t\tString dropSql = sessionFactory().getJdbcServices().getDialect().getDropTableString( \"SANDBOX_JDBC_TST\" );\n\t\ttry {\n\t\t\tjdbcCoordinator.getResultSetReturn().execute( statement, dropSql );\n\t\t}\n\t\tcatch ( Exception e ) {\n\t\t\t// ignore if the DB doesn't support \"if exists\" and the table doesn't exist\n\t\t}\t\tjdbcCoordinator.getResultSetReturn().execute( statement, \"create table SANDBOX_JDBC_TST ( ID integer, NAME varchar(100) )\" );\n        assertTrue( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n\t\tassertTrue( logicalConnection.isPhysicallyConnected() );\n        jdbcCoordinator.getLogicalConnection().getResourceRegistry().release( statement );\n        assertFalse( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n\t\tassertTrue( logicalConnection.isPhysicallyConnected() ); // after_transaction specified\n\n\t\t// ok, now we can get down to it...\n\t\tTransaction txn = session.getTransaction();  // same as Session#getTransaction\n\t\ttxn.begin();\n\n\t\tfinal BatchBuilder batchBuilder = new BatchBuilderImpl( 2 );\n\t\tfinal BatchKey batchKey = new BasicBatchKey( \"this\", Expectations.BASIC );\n\t\tfinal Batch insertBatch = batchBuilder.buildBatch( batchKey, jdbcCoordinator );\n\t\tassertTrue( \"unexpected Batch impl\", BatchingBatch.class.isInstance( insertBatch ) );\n\n\t\tfinal JournalingBatchObserver batchObserver = new JournalingBatchObserver();\n\t\tinsertBatch.addObserver( batchObserver );\n\n\t\tfinal String insertSql = \"insert into SANDBOX_JDBC_TST( ID, NAME ) values ( ?, ? )\";\n\n\t\tPreparedStatement insert = insertBatch.getBatchStatement( insertSql, false );\n\t\tinsert.setLong( 1, 1 );\n\t\tinsert.setString( 2, \"name\" );\n\t\tassertEquals( 0, batchObserver.getExplicitExecutionCount() );\n\t\tassertEquals( 0, batchObserver.getImplicitExecutionCount() );\n\t\tinsertBatch.addToBatch();\n\t\tassertEquals( 0, batchObserver.getExplicitExecutionCount() );\n\t\tassertEquals( 0, batchObserver.getImplicitExecutionCount() );\n        assertTrue( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n\n\t\tPreparedStatement insert2 = insertBatch.getBatchStatement( insertSql, false );\n\t\tassertSame( insert, insert2 );\n\t\tinsert = insert2;\n\t\tinsert.setLong( 1, 2 );\n\t\tinsert.setString( 2, \"another name\" );\n\t\tassertEquals( 0, batchObserver.getExplicitExecutionCount() );\n\t\tassertEquals( 0, batchObserver.getImplicitExecutionCount() );\n\t\tinsertBatch.addToBatch();\n\t\tassertEquals( 0, batchObserver.getExplicitExecutionCount() );\n\t\tassertEquals( 0, batchObserver.getImplicitExecutionCount() );\n        assertTrue( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n\n\t\tPreparedStatement insert3 = insertBatch.getBatchStatement( insertSql, false );\n\t\tassertSame( insert, insert3 );\n\t\tinsert = insert3;\n\t\tinsert.setLong( 1, 3 );\n\t\tinsert.setString( 2, \"yet another name\" );\n\t\tassertEquals( 0, batchObserver.getExplicitExecutionCount() );\n\t\tassertEquals( 0, batchObserver.getImplicitExecutionCount() );\n\t\tinsertBatch.addToBatch();\n\t\tassertEquals( 0, batchObserver.getExplicitExecutionCount() );\n\t\tassertEquals( 1, batchObserver.getImplicitExecutionCount() );\n        assertTrue( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n\n\t\tinsertBatch.execute();\n\t\tassertEquals( 1, batchObserver.getExplicitExecutionCount() );\n\t\tassertEquals( 1, batchObserver.getImplicitExecutionCount() );\n        assertFalse( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n\n\t\tinsertBatch.release();\n\n\t\ttxn.commit();\n\t\tsession.close();\n\t}\n\n\t@Override\n\tprotected void cleanupTest() throws Exception {\n\t\ttry (Session session = openSession()) {\n\t\t\tsession.doWork( connection -> {\n\t\t\t\tfinal Statement stmnt = connection.createStatement();\n\n\t\t\t\tstmnt.execute( sessionFactory().getJdbcServices().getDialect().getDropTableString( \"SANDBOX_JDBC_TST\" ) );\n\t\t\t} );\n\t\t}\n\t}\n\n}\n",
        "filePathAfter": "hibernate-core/src/test/java/org/hibernate/orm/test/jdbc/internal/BatchingTest.java",
        "sourceCodeAfterForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.\n */\npackage org.hibernate.orm.test.jdbc.internal;\n\nimport java.sql.Statement;\n\nimport org.hibernate.Session;\nimport org.hibernate.Transaction;\nimport org.hibernate.engine.jdbc.batch.internal.BasicBatchKey;\nimport org.hibernate.engine.jdbc.batch.internal.BatchBuilderImpl;\nimport org.hibernate.engine.jdbc.batch.spi.Batch;\nimport org.hibernate.engine.jdbc.batch.spi.BatchKey;\nimport org.hibernate.engine.jdbc.mutation.ParameterUsage;\nimport org.hibernate.engine.jdbc.mutation.internal.JdbcValueBindingsImpl;\nimport org.hibernate.engine.jdbc.spi.JdbcCoordinator;\nimport org.hibernate.engine.spi.SessionImplementor;\nimport org.hibernate.jdbc.Expectation;\nimport org.hibernate.jdbc.Expectations;\nimport org.hibernate.metamodel.mapping.JdbcMapping;\nimport org.hibernate.orm.test.common.JournalingBatchObserver;\nimport org.hibernate.resource.jdbc.spi.LogicalConnectionImplementor;\nimport org.hibernate.sql.model.MutationType;\nimport org.hibernate.sql.model.TableMapping;\nimport org.hibernate.sql.model.jdbc.JdbcValueDescriptor;\nimport org.hibernate.type.StandardBasicTypes;\n\nimport org.hibernate.testing.junit4.BaseCoreFunctionalTestCase;\nimport org.junit.Test;\n\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.hibernate.jdbc.Expectations.NONE;\nimport static org.junit.Assert.assertFalse;\nimport static org.junit.Assert.assertTrue;\n\n/**\n * @author Steve Ebersole\n * @author Brett Meyer\n */\npublic class BatchingTest extends BaseCoreFunctionalTestCase implements BatchKey {\n\tprivate final String SANDBOX_TBL = \"SANDBOX_JDBC_TST\";\n\tprivate final TableMapping SANDBOX_TBL_MAPPING = new TableMapping() {\n\t\t@Override\n\t\tpublic String getTableName() {\n\t\t\treturn SANDBOX_TBL;\n\t\t}\n\n\t\t@Override\n\t\tpublic int getRelativePosition() {\n\t\t\treturn 0;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean isOptional() {\n\t\t\treturn false;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean isInverse() {\n\t\t\treturn false;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean isIdentifierTable() {\n\t\t\treturn true;\n\t\t}\n\n\t\t@Override\n\t\tpublic MutationDetails getInsertDetails() {\n\t\t\treturn new MutationDetails( MutationType.INSERT, NONE, null, false );\n\t\t}\n\n\t\t@Override\n\t\tpublic MutationDetails getUpdateDetails() {\n\t\t\treturn new MutationDetails( MutationType.UPDATE, NONE, null, false );\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean isCascadeDeleteEnabled() {\n\t\t\treturn false;\n\t\t}\n\n\t\t@Override\n\t\tpublic MutationDetails getDeleteDetails() {\n\t\t\treturn new MutationDetails( MutationType.DELETE, NONE, null, false );\n\t\t}\n\t};\n\n\t@Override\n\tpublic int getBatchedStatementCount() {\n\t\treturn 1;\n\t}\n\n\t@Override\n\tpublic Expectation getExpectation() {\n\t\treturn Expectations.BASIC;\n\t}\n\n\t@Test\n\tpublic void testBatchingUsage() throws Exception {\n\t\tfinal Session session = openSession();\n\t\tfinal SessionImplementor sessionImpl = (SessionImplementor) session;\n\t\tfinal JdbcCoordinator jdbcCoordinator = sessionImpl.getJdbcCoordinator();\n\n\t\texportSandboxSchema( sessionImpl );\n\n\t\t// ok, now we can get down to it...\n\t\tTransaction txn = session.getTransaction();  // same as Session#getTransaction\n\t\ttxn.begin();\n\n\t\tfinal String insertSql = \"insert into SANDBOX_JDBC_TST( ID, NAME ) values ( ?, ? )\";\n\n\t\tfinal BatchBuilderImpl batchBuilder = new BatchBuilderImpl( 2 );\n\t\tfinal BatchKey batchKey = new BasicBatchKey( \"this\" );\n\t\tfinal Batch insertBatch = batchBuilder.buildBatch( batchKey, null, SANDBOX_TBL, sessionImpl, insertSql );\n\t\tassertThat( insertBatch ).isNotNull();\n\n\t\tfinal JournalingBatchObserver batchObserver = new JournalingBatchObserver();\n\t\tinsertBatch.addObserver( batchObserver );\n\n\t\tfinal JdbcValueBindingsImpl jdbcValueBindings = sandboxInsertValueBindings( sessionImpl );\n\n\t\t// bind values for #1 - should do nothing at the JDBC level\n\t\tjdbcValueBindings.bindValue( 1, SANDBOX_TBL, \"ID\", ParameterUsage.SET, sessionImpl );\n\t\tjdbcValueBindings.bindValue( \"name\", SANDBOX_TBL, \"NAME\", ParameterUsage.SET, sessionImpl );\n\t\tassertThat( batchObserver.getExplicitExecutionCount() ).isEqualTo( 0 );\n\t\tassertThat( batchObserver.getImplicitExecutionCount() ).isEqualTo( 0 );\n\t\tassertThat( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() ).isFalse();\n\n\t\t// add #1 to the batch - will acquire prepared statement to bind values\n\t\tinsertBatch.addToBatch( jdbcValueBindings, null );\n\t\tassertThat( batchObserver.getExplicitExecutionCount() ).isEqualTo( 0 );\n\t\tassertThat( batchObserver.getImplicitExecutionCount() ).isEqualTo( 0 );\n        assertThat( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() ).isTrue();\n\n\t\t// bind values for #2 - again, nothing at JDBC level (we have statement from earlier)\n\t\tjdbcValueBindings.bindValue( 2, SANDBOX_TBL, \"ID\", ParameterUsage.SET, sessionImpl );\n\t\tjdbcValueBindings.bindValue( \"another name\", SANDBOX_TBL, \"NAME\", ParameterUsage.SET, sessionImpl );\n\t\tassertThat( batchObserver.getExplicitExecutionCount() ).isEqualTo( 0 );\n\t\tassertThat( batchObserver.getImplicitExecutionCount() ).isEqualTo( 0 );\n\n\t\t// add #2 to the batch -\n\t\t// \t\t- uses the previous prepared statement to bind values\n\t\t//\t\t- batch size has been exceeded, trigger an implicit execution\n\t\tinsertBatch.addToBatch( jdbcValueBindings, null );\n\t\tassertThat( batchObserver.getExplicitExecutionCount() ).isEqualTo( 0 );\n\t\tassertThat( batchObserver.getImplicitExecutionCount() ).isEqualTo( 1 );\n\t\tassertThat( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() ).isTrue();\n\n\t\t// execute the batch - effectively only increments the explicit-execution counter\n\t\tinsertBatch.execute();\n\t\tassertThat( batchObserver.getExplicitExecutionCount() ).isEqualTo( 1 );\n\t\tassertThat( batchObserver.getImplicitExecutionCount() ).isEqualTo( 1 );\n\t\tassertThat( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() ).isFalse();\n\n\t\tinsertBatch.release();\n\n\t\ttxn.commit();\n\t\tsession.close();\n\t}\n\n\tprivate JdbcValueBindingsImpl sandboxInsertValueBindings(SessionImplementor session) {\n\t\treturn new JdbcValueBindingsImpl(\n\t\t\t\tMutationType.INSERT,\n\t\t\t\tnull,\n\t\t\t\t(tableName, columnName, usage) -> {\n\t\t\t\t\tassert tableName.equals( SANDBOX_TBL );\n\n\t\t\t\t\tif ( columnName.equals( \"ID\" ) ) {\n\t\t\t\t\t\treturn new JdbcValueDescriptor() {\n\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\tpublic String getColumnName() {\n\t\t\t\t\t\t\t\treturn \"ID\";\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\tpublic ParameterUsage getUsage() {\n\t\t\t\t\t\t\t\treturn ParameterUsage.SET;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\tpublic int getJdbcPosition() {\n\t\t\t\t\t\t\t\treturn 1;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\tpublic JdbcMapping getJdbcMapping() {\n\t\t\t\t\t\t\t\treturn session.getTypeConfiguration()\n\t\t\t\t\t\t\t\t\t\t.getBasicTypeRegistry()\n\t\t\t\t\t\t\t\t\t\t.resolve( StandardBasicTypes.INTEGER );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( columnName.equals( \"NAME\" ) ) {\n\t\t\t\t\t\treturn new JdbcValueDescriptor() {\n\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\tpublic String getColumnName() {\n\t\t\t\t\t\t\t\treturn \"NAME\";\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\tpublic ParameterUsage getUsage() {\n\t\t\t\t\t\t\t\treturn ParameterUsage.SET;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\tpublic int getJdbcPosition() {\n\t\t\t\t\t\t\t\treturn 2;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\tpublic JdbcMapping getJdbcMapping() {\n\t\t\t\t\t\t\t\treturn session.getTypeConfiguration()\n\t\t\t\t\t\t\t\t\t\t.getBasicTypeRegistry()\n\t\t\t\t\t\t\t\t\t\t.resolve( StandardBasicTypes.STRING );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\n\t\t\t\t\tthrow new IllegalArgumentException( \"Unknown column : \" + columnName );\n\t\t\t\t}\n\t\t);\n\t}\n\n\t@Test\n\tpublic void testSessionBatchingUsage() throws Exception {\n\t\tSession session = openSession();\n\t\tsession.setJdbcBatchSize( 3 );\n\t\tSessionImplementor sessionImpl = (SessionImplementor) session;\n\t\tfinal JdbcCoordinator jdbcCoordinator = sessionImpl.getJdbcCoordinator();\n\n\t\texportSandboxSchema( sessionImpl );\n\n\t\t// ok, now we can get down to it...\n\t\tTransaction txn = session.getTransaction();  // same as Session#getTransaction\n\t\ttxn.begin();\n\n\n\t\tfinal String insertSql = \"insert into SANDBOX_JDBC_TST( ID, NAME ) values ( ?, ? )\";\n\n\t\tfinal BatchBuilderImpl batchBuilder = new BatchBuilderImpl( 2 );\n\t\tfinal BatchKey batchKey = new BasicBatchKey( \"this\" );\n\t\tfinal Batch insertBatch = batchBuilder.buildBatch( batchKey, 3, SANDBOX_TBL, sessionImpl, insertSql );\n\t\tassertThat( insertBatch ).isNotNull();\n\n\t\tfinal JournalingBatchObserver batchObserver = new JournalingBatchObserver();\n\t\tinsertBatch.addObserver( batchObserver );\n\n\t\tfinal JdbcValueBindingsImpl jdbcValueBindings = sandboxInsertValueBindings( sessionImpl );\n\n\t\t// bind values for #1 - this does nothing at the JDBC level\n\t\tjdbcValueBindings.bindValue( 1, SANDBOX_TBL, \"ID\", ParameterUsage.SET, sessionImpl );\n\t\tjdbcValueBindings.bindValue( \"name\", SANDBOX_TBL, \"NAME\", ParameterUsage.SET, sessionImpl );\n\t\tassertThat( batchObserver.getExplicitExecutionCount() ).isEqualTo( 0 );\n\t\tassertThat( batchObserver.getImplicitExecutionCount() ).isEqualTo( 0 );\n\t\tassertThat( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() ).isFalse();\n\n\t\t// add the values to the batch - this creates the prepared statement and binds the values\n\t\tinsertBatch.addToBatch( jdbcValueBindings, null );\n\t\tassertThat( batchObserver.getExplicitExecutionCount() ).isEqualTo( 0 );\n\t\tassertThat( batchObserver.getImplicitExecutionCount() ).isEqualTo( 0 );\n\t\tassertThat( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() ).isTrue();\n\n\t\t// bind values for #2 - this does nothing at the JDBC level : we do still have the statement defining the batch\n\t\tjdbcValueBindings.bindValue( 2, SANDBOX_TBL, \"ID\", ParameterUsage.SET, sessionImpl );\n\t\tjdbcValueBindings.bindValue( \"another name\", SANDBOX_TBL, \"NAME\", ParameterUsage.SET, sessionImpl );\n\t\tassertThat( batchObserver.getExplicitExecutionCount() ).isEqualTo( 0 );\n\t\tassertThat( batchObserver.getImplicitExecutionCount() ).isEqualTo( 0 );\n\t\tassertThat( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() ).isTrue();\n\n\t\t// add #2 to batch - we have not exceeded batch size, so we should not get an implicit execution\n\t\tinsertBatch.addToBatch( jdbcValueBindings, null );\n\t\tassertThat( batchObserver.getExplicitExecutionCount() ).isEqualTo( 0 );\n\t\tassertThat( batchObserver.getImplicitExecutionCount() ).isEqualTo( 0 );\n\t\tassertThat( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() ).isTrue();\n\n\t\t// bind values for #3 - this does nothing at the JDBC level : we do still have the statement defining the batch\n\t\tjdbcValueBindings.bindValue( 3, SANDBOX_TBL, \"ID\", ParameterUsage.SET, sessionImpl );\n\t\tjdbcValueBindings.bindValue( \"yet another name\", SANDBOX_TBL, \"NAME\", ParameterUsage.SET, sessionImpl );\n\t\tassertThat( batchObserver.getExplicitExecutionCount() ).isEqualTo( 0 );\n\t\tassertThat( batchObserver.getImplicitExecutionCount() ).isEqualTo( 0 );\n\t\tassertThat( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() ).isTrue();\n\n\t\tinsertBatch.addToBatch( jdbcValueBindings, null );\n\t\tassertThat( batchObserver.getExplicitExecutionCount() ).isEqualTo( 0 );\n\t\tassertThat( batchObserver.getImplicitExecutionCount() ).isEqualTo( 1 );\n\t\tassertThat( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() ).isTrue();\n\n\t\tinsertBatch.execute();\n\t\tassertThat( batchObserver.getExplicitExecutionCount() ).isEqualTo( 1 );\n\t\tassertThat( batchObserver.getImplicitExecutionCount() ).isEqualTo( 1 );\n\t\tassertThat( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() ).isFalse();\n\n\t\tinsertBatch.release();\n\n\t\ttxn.commit();\n\t\tsession.close();\n\t}\n\n\tprivate void exportSandboxSchema(SessionImplementor sessionImpl) {\n\t\tfinal JdbcCoordinator jdbcCoordinator = sessionImpl.getJdbcCoordinator();\n\t\tLogicalConnectionImplementor logicalConnection = jdbcCoordinator.getLogicalConnection();\n\n\t\t// set up some tables to use\n\t\tStatement statement = jdbcCoordinator.getStatementPreparer().createStatement();\n\t\tString dropSql = sessionFactory().getJdbcServices().getDialect().getDropTableString( \"SANDBOX_JDBC_TST\" );\n\t\ttry {\n\t\t\tjdbcCoordinator.getResultSetReturn().execute( statement, dropSql );\n\t\t}\n\t\tcatch ( Exception e ) {\n\t\t\t// ignore if the DB doesn't support \"if exists\" and the table doesn't exist\n\t\t}\n\t\tjdbcCoordinator.getResultSetReturn().execute( statement, \"create table SANDBOX_JDBC_TST ( ID integer, NAME varchar(100) )\" );\n\t\tassertTrue( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n\t\tassertTrue( logicalConnection.isPhysicallyConnected() );\n\t\tjdbcCoordinator.getLogicalConnection().getResourceRegistry().release( statement );\n\t\tassertFalse( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n\t\tassertTrue( logicalConnection.isPhysicallyConnected() ); // after_transaction specified\n\t}\n\n\t@Override\n\tprotected void cleanupTest() throws Exception {\n\t\ttry (Session session = openSession()) {\n\t\t\tsession.doWork( connection -> {\n\t\t\t\tfinal Statement stmnt = connection.createStatement();\n\n\t\t\t\tstmnt.execute( sessionFactory().getJdbcServices().getDialect().getDropTableString( \"SANDBOX_JDBC_TST\" ) );\n\t\t\t} );\n\t\t}\n\t}\n\n}\n",
        "diffSourceCodeSet": [
            "private void exportSandboxSchema(SessionImplementor sessionImpl) {\n\t\tfinal JdbcCoordinator jdbcCoordinator = sessionImpl.getJdbcCoordinator();\n\t\tLogicalConnectionImplementor logicalConnection = jdbcCoordinator.getLogicalConnection();\n\n\t\t// set up some tables to use\n\t\tStatement statement = jdbcCoordinator.getStatementPreparer().createStatement();\n\t\tString dropSql = sessionFactory().getJdbcServices().getDialect().getDropTableString( \"SANDBOX_JDBC_TST\" );\n\t\ttry {\n\t\t\tjdbcCoordinator.getResultSetReturn().execute( statement, dropSql );\n\t\t}\n\t\tcatch ( Exception e ) {\n\t\t\t// ignore if the DB doesn't support \"if exists\" and the table doesn't exist\n\t\t}\n\t\tjdbcCoordinator.getResultSetReturn().execute( statement, \"create table SANDBOX_JDBC_TST ( ID integer, NAME varchar(100) )\" );\n\t\tassertTrue( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n\t\tassertTrue( logicalConnection.isPhysicallyConnected() );\n\t\tjdbcCoordinator.getLogicalConnection().getResourceRegistry().release( statement );\n\t\tassertFalse( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n\t\tassertTrue( logicalConnection.isPhysicallyConnected() ); // after_transaction specified\n\t}"
        ],
        "invokedMethodSet": [
            "methodSignature: org.hibernate.action.internal.BulkOperationCleanupAction.NaturalIdCleanup#release\n methodBody: private void release() {\nnaturalIdCacheAccessStrategy.unlockRegion(cacheLock);\n}",
            "methodSignature: org.hibernate.orm.test.insertordering.InsertOrderingTest.StatsBatch#addToBatch\n methodBody: public void addToBatch() {\nCounter counter=(Counter)batchSizes.get(currentBatch);\ncounter.count++;\nsuper.addToBatch();\n}",
            "methodSignature: org.hibernate.engine.jdbc.spi.JdbcCoordinator#getStatementPreparer\n methodBody: StatementPreparer getStatementPreparer();",
            "methodSignature: org.hibernate.engine.jdbc.spi.JdbcServices#getDialect\n methodBody: Dialect getDialect();",
            "methodSignature: org.hibernate.engine.jdbc.batch.internal.AbstractBatchImpl#getBatchStatement\n methodBody: public PreparedStatement getBatchStatement(String sql, boolean callable) {\nif(sql == null){throw new IllegalArgumentException(\"sql must be non-null.\");\n}PreparedStatement statement=statements.get(sql);\nif(statement == null){statement=buildBatchStatement(sql,callable);\nstatements.put(sql,statement);\n}{LOG.debug(\"Reusing batch statement\");\nsqlStatementLogger().logStatement(sql);\n}return statement;\n}",
            "methodSignature: org.hibernate.engine.jdbc.batch.spi.Batch#execute\n methodBody: void execute();",
            "methodSignature: org.hibernate.engine.jdbc.batch.internal.SharedBatchBuildingCode#buildBatch\n methodBody: static Batch buildBatch(final int defaultJdbcBatchSize, final BatchKey key, final JdbcCoordinator jdbcCoordinator) {\nfinal Integer sessionJdbcBatchSize=jdbcCoordinator.getJdbcSessionOwner().getJdbcBatchSize();\nfinal int jdbcBatchSizeToUse=sessionJdbcBatchSize == null ? defaultJdbcBatchSize : sessionJdbcBatchSize;\nreturn jdbcBatchSizeToUse > 1 ? new BatchingBatch(key,jdbcCoordinator,jdbcBatchSizeToUse) : new NonBatchingBatch(key,jdbcCoordinator);\n}",
            "methodSignature: org.hibernate.engine.jdbc.internal.JdbcCoordinatorImpl#getLogicalConnection\n methodBody: public LogicalConnectionImplementor getLogicalConnection() {\nreturn logicalConnection;\n}",
            "methodSignature: org.hibernate.engine.jdbc.internal.JdbcCoordinatorImpl#close\n methodBody: protected void close(ResultSet resultSet) {\nLOG.tracev(\"Closing result set [{0}]\",resultSet);\nif(resultSet instanceof InvalidatableWrapper){@SuppressWarnings(\"unchecked\") final InvalidatableWrapper<ResultSet> wrapper=(InvalidatableWrapper<ResultSet>)resultSet;\nclose(wrapper.getWrappedObject());\nwrapper.invalidate();\nreturn;\n}tryresultSet.close();\ncatch(Exception e)LOG.debugf(\"Unable to release JDBC result set [%s]\",e.getMessage());\n}",
            "methodSignature: org.hibernate.query.sqm.mutation.internal.inline.InlineUpdateHandler#execute\n methodBody: public int execute(DomainQueryExecutionContext executionContext) {\nfinal List<Object> ids=MatchingIdSelectionHelper.selectMatchingIds(sqmUpdate,domainParameterXref,executionContext);\nif(ids == null || ids.isEmpty()){return 0;\n}domainParameterXref.clearExpansions();\nfinal MappingMetamodel domainModel=sessionFactory.getRuntimeMetamodels().getMappingMetamodel();\nfinal String mutatingEntityName=sqmUpdate.getTarget().getModel().getHibernateEntityName();\nfinal EntityPersister entityDescriptor=domainModel.getEntityDescriptor(mutatingEntityName);\nfinal String rootEntityName=entityDescriptor.getEntityPersister().getRootEntityName();\nfinal EntityPersister rootEntityDescriptor=domainModel.getEntityDescriptor(rootEntityName);\nfinal String hierarchyRootTableName=((Joinable)rootEntityDescriptor).getTableName();\nfinal List<Expression> inListExpressions=new ArrayList<>(ids.size());\nfinal EntityIdentifierMapping identifierMapping=entityDescriptor.getIdentifierMapping();\nif(identifierMapping instanceof BasicValuedModelPart){final BasicValuedModelPart basicValuedModelPart=(BasicValuedModelPart)identifierMapping;\nfor(int i=0; i < ids.size(); i++){inListExpressions.add(new QueryLiteral<>(ids.get(i),basicValuedModelPart));\n}}{final int jdbcTypeCount=identifierMapping.getJdbcTypeCount();\nfor(int i=0; i < ids.size(); i++){final Object[] id=(Object[])ids.get(i);\nfinal List<Expression> tupleElements=new ArrayList<>(jdbcTypeCount);\ninListExpressions.add(new SqlTuple(tupleElements,identifierMapping));\nidentifierMapping.forEachJdbcType((index,jdbcMapping) -> {\n  tupleElements.add(new QueryLiteral<>(id[index],(BasicValuedMapping)jdbcMapping));\n}\n);\n}}final MultiTableSqmMutationConverter converterDelegate=new MultiTableSqmMutationConverter(entityDescriptor,sqmUpdate,sqmUpdate.getTarget(),domainParameterXref,executionContext.getQueryOptions(),executionContext.getSession().getLoadQueryInfluencers(),executionContext.getQueryParameterBindings(),sessionFactory);\nfinal TableGroup updatingTableGroup=converterDelegate.getMutatingTableGroup();\nfinal TableReference hierarchyRootTableReference=updatingTableGroup.resolveTableReference(updatingTableGroup.getNavigablePath(),hierarchyRootTableName);\nassert hierarchyRootTableReference != null;\nfinal Map<SqmParameter<?>,List<List<JdbcParameter>>> parameterResolutions;\nif(domainParameterXref.getSqmParameterCount() == 0){parameterResolutions=Collections.emptyMap();\n}{parameterResolutions=new IdentityHashMap<>();\n}final List<Assignment> assignments=new ArrayList<>();\nfinal Map<SqmParameter<?>,MappingModelExpressible<?>> paramTypeResolutions=new LinkedHashMap<>();\nconverterDelegate.visitSetClause(sqmUpdate.getSetClause(),assignments::add,(sqmParameter,mappingType,jdbcParameters) -> {\n  parameterResolutions.computeIfAbsent(sqmParameter,k -> new ArrayList<>(1)).add(jdbcParameters);\n  paramTypeResolutions.put(sqmParameter,mappingType);\n}\n);\nconverterDelegate.addVersionedAssignment(assignments::add,sqmUpdate);\nfinal Predicate providedPredicate;\nfinal SqmWhereClause whereClause=sqmUpdate.getWhereClause();\nif(whereClause == null || whereClause.getPredicate() == null){providedPredicate=null;\n}{providedPredicate=converterDelegate.visitWhereClause(whereClause,columnReference -> {\n}\n,(sqmParameter,mappingType,jdbcParameters) -> {\n  parameterResolutions.computeIfAbsent(sqmParameter,k -> new ArrayList<>(1)).add(jdbcParameters);\n  paramTypeResolutions.put(sqmParameter,mappingType);\n}\n);\nassert providedPredicate != null;\n}final PredicateCollector predicateCollector=new PredicateCollector(providedPredicate);\nentityDescriptor.applyBaseRestrictions(predicateCollector::applyPredicate,updatingTableGroup,true,executionContext.getSession().getLoadQueryInfluencers().getEnabledFilters(),null,converterDelegate);\nconverterDelegate.pruneTableGroupJoins();\nfinal Map<String,TableReference> tableReferenceByAlias=CollectionHelper.mapOfSize(updatingTableGroup.getTableReferenceJoins().size() + 1);\ncollectTableReference(updatingTableGroup.getPrimaryTableReference(),tableReferenceByAlias::put);\nfor(int i=0; i < updatingTableGroup.getTableReferenceJoins().size(); i++){collectTableReference(updatingTableGroup.getTableReferenceJoins().get(i),tableReferenceByAlias::put);\n}final JdbcParameterBindings jdbcParameterBindings=SqmUtil.createJdbcParameterBindings(executionContext.getQueryParameterBindings(),domainParameterXref,SqmUtil.generateJdbcParamsXref(domainParameterXref,() -> parameterResolutions),sessionFactory.getRuntimeMetamodels().getMappingMetamodel(),navigablePath -> updatingTableGroup,new SqmParameterMappingModelResolutionAccess(){\n  @Override @SuppressWarnings(\"unchecked\") public <T>MappingModelExpressible<T> getResolvedMappingModelType(  SqmParameter<T> parameter){\n    return (MappingModelExpressible<T>)paramTypeResolutions.get(parameter);\n  }\n}\n,executionContext.getSession());\nfinal Map<TableReference,List<Assignment>> assignmentsByTable=new HashMap<>();\nfor(int i=0; i < assignments.size(); i++){final Assignment assignment=assignments.get(i);\nfinal List<ColumnReference> assignmentColumnRefs=assignment.getAssignable().getColumnReferences();\nTableReference assignmentTableReference=null;\nfor(int c=0; c < assignmentColumnRefs.size(); c++){final ColumnReference columnReference=assignmentColumnRefs.get(c);\nfinal TableReference tableReference=resolveTableReference(columnReference,tableReferenceByAlias);\nif(assignmentTableReference != null && assignmentTableReference != tableReference){throw new SemanticException(\"Assignment referred to columns from multiple tables: \" + assignment.getAssignable());\n}assignmentTableReference=tableReference;\n}List<Assignment> assignmentsForTable=assignmentsByTable.get(assignmentTableReference);\nif(assignmentsForTable == null){assignmentsForTable=new ArrayList<>();\nassignmentsByTable.put(assignmentTableReference,assignmentsForTable);\n}assignmentsForTable.add(assignment);\n}final int rows=ids.size();\nfinal SqmJdbcExecutionContextAdapter executionContextAdapter=SqmJdbcExecutionContextAdapter.omittingLockingAndPaging(executionContext);\nentityDescriptor.visitConstraintOrderedTables((tableExpression,tableKeyColumnVisitationSupplier) -> updateTable(tableExpression,tableKeyColumnVisitationSupplier,entityDescriptor,updatingTableGroup,assignmentsByTable,inListExpressions,rows,jdbcParameterBindings,executionContextAdapter));\nreturn rows;\n}",
            "methodSignature: org.hibernate.dialect.AbstractHANADialect.CloseSuppressingInputStream#close\n methodBody: public void close() {\n}",
            "methodSignature: org.hibernate.query.sqm.mutation.internal.inline.InlineDeleteHandler#execute\n methodBody: public int execute(DomainQueryExecutionContext executionContext) {\nfinal List<Object> idsAndFks=MatchingIdSelectionHelper.selectMatchingIds(sqmDeleteStatement,domainParameterXref,executionContext);\nif(idsAndFks == null || idsAndFks.isEmpty()){return 0;\n}final SessionFactoryImplementor factory=executionContext.getSession().getFactory();\nfinal String mutatingEntityName=sqmDeleteStatement.getTarget().getModel().getHibernateEntityName();\nfinal EntityMappingType entityDescriptor=factory.getRuntimeMetamodels().getEntityMappingType(mutatingEntityName);\nfinal JdbcParameterBindings jdbcParameterBindings=new JdbcParameterBindingsImpl(domainParameterXref.getQueryParameterCount());\nfinal MutableInteger valueIndexCounter=new MutableInteger();\nSqmMutationStrategyHelper.visitCollectionTables(entityDescriptor,pluralAttribute -> {\n  if (pluralAttribute.getSeparateCollectionTable() != null) {\n    final ModelPart fkTargetPart=pluralAttribute.getKeyDescriptor().getTargetPart();\n    final int valueIndex;\n    if (fkTargetPart instanceof EntityIdentifierMapping) {\n      valueIndex=0;\n    }\n else {\n      if (valueIndexCounter.get() == 0) {\n        valueIndexCounter.set(entityDescriptor.getIdentifierMapping().getJdbcTypeCount());\n      }\n      valueIndex=valueIndexCounter.get();\n      valueIndexCounter.plus(fkTargetPart.getJdbcTypeCount());\n    }\n    executeDelete(pluralAttribute.getSeparateCollectionTable(),entityDescriptor,() -> fkTargetPart::forEachSelectable,idsAndFks,valueIndex,fkTargetPart,jdbcParameterBindings,executionContext);\n  }\n}\n);\nentityDescriptor.visitConstraintOrderedTables((tableExpression,tableKeyColumnsVisitationSupplier) -> {\n  executeDelete(tableExpression,entityDescriptor,tableKeyColumnsVisitationSupplier,idsAndFks,0,null,jdbcParameterBindings,executionContext);\n}\n);\nreturn idsAndFks.size();\n}",
            "methodSignature: org.hibernate.engine.jdbc.internal.JdbcCoordinatorImpl#hasRegisteredResources\n methodBody: private boolean hasRegisteredResources() {\nreturn getLogicalConnection().getResourceRegistry().hasRegisteredResources();\n}",
            "methodSignature: org.hibernate.engine.jdbc.batch.spi.Batch#release\n methodBody: void release();",
            "methodSignature: org.hibernate.engine.jdbc.batch.internal.UnmodifiableBatchBuilderImpl#buildBatch\n methodBody: public Batch buildBatch(BatchKey key, JdbcCoordinator jdbcCoordinator) {\nreturn SharedBatchBuildingCode.buildBatch(jdbcBatchSize,key,jdbcCoordinator);\n}",
            "methodSignature: org.hibernate.persister.entity.AbstractEntityPersister#isInstance\n methodBody: public boolean isInstance(Object object) {\nreturn getRepresentationStrategy().getInstantiator().isInstance(object,getFactory());\n}",
            "methodSignature: org.hibernate.orm.test.jpa.transaction.batch.JtaWithFailingBatchTest.TestBatch#addToBatch\n methodBody: public void addToBatch() {\nthrow sqlExceptionHelper().convert(new SQLException(\"fake SQLException\"),\"could not perform addBatch\",currentStatementSql);\n}",
            "methodSignature: org.hibernate.action.internal.BulkOperationCleanupAction#execute\n methodBody: public void execute() throws HibernateException {\n}",
            "methodSignature: org.hibernate.orm.test.jpa.transaction.batch.JtaWithFailingBatchTest.TestBatch#getBatchStatement\n methodBody: public PreparedStatement getBatchStatement(String sql, boolean callable) {\ncurrentStatementSql=sql;\nPreparedStatement batchStatement=super.getBatchStatement(sql,callable);\ncreatedStatements.add(batchStatement);\nreturn batchStatement;\n}",
            "methodSignature: org.hibernate.engine.jdbc.batch.spi.BatchBuilder#buildBatch\n methodBody: Batch buildBatch(BatchKey key, JdbcCoordinator jdbcCoordinator);",
            "methodSignature: org.hibernate.procedure.internal.ProcedureCallImpl#execute\n methodBody: public boolean execute() {\ntryreturn outputs().getCurrent() instanceof ResultSetOutput;\ncatch(NoMoreOutputsException e)return false;\ncatch(HibernateException he)throw getSession().getExceptionConverter().convert(he);\ncatch(RuntimeException e)getSession().markForRollbackOnly();\nthrow e;\n}",
            "methodSignature: org.hibernate.query.sqm.mutation.internal.cte.CteInsertHandler#execute\n methodBody: public int execute(DomainQueryExecutionContext executionContext) {\nfinal SqmInsertStatement<?> sqmInsertStatement=getSqmStatement();\nfinal SessionFactoryImplementor factory=executionContext.getSession().getFactory();\nfinal EntityPersister entityDescriptor=getEntityDescriptor().getEntityPersister();\nfinal String explicitDmlTargetAlias;\nif(sqmInsertStatement.getTarget().getExplicitAlias() == null){explicitDmlTargetAlias=\"dml_target\";\n}{explicitDmlTargetAlias=sqmInsertStatement.getTarget().getExplicitAlias();\n}final MultiTableSqmMutationConverter sqmConverter=new MultiTableSqmMutationConverter(entityDescriptor,sqmInsertStatement,sqmInsertStatement.getTarget(),explicitDmlTargetAlias,domainParameterXref,executionContext.getQueryOptions(),executionContext.getSession().getLoadQueryInfluencers(),executionContext.getQueryParameterBindings(),factory);\nfinal TableGroup insertingTableGroup=sqmConverter.getMutatingTableGroup();\nfinal Map<SqmParameter<?>,List<List<JdbcParameter>>> parameterResolutions;\nif(domainParameterXref.getSqmParameterCount() == 0){parameterResolutions=Collections.emptyMap();\n}{parameterResolutions=new IdentityHashMap<>();\n}final int size=sqmStatement.getInsertionTargetPaths().size();\nfinal List<Map.Entry<List<CteColumn>,Assignment>> targetPathColumns=new ArrayList<>(size);\nfinal List<CteColumn> targetPathCteColumns=new ArrayList<>(size);\nfinal Map<SqmParameter<?>,MappingModelExpressible<?>> paramTypeResolutions=new LinkedHashMap<>();\nfinal NamedTableReference entityTableReference=new NamedTableReference(cteTable.getTableExpression(),TemporaryTable.DEFAULT_ALIAS,true,sessionFactory);\nfinal InsertStatement insertStatement=new InsertStatement(entityTableReference);\nfinal BaseSqmToSqlAstConverter.AdditionalInsertValues additionalInsertValues=sqmConverter.visitInsertionTargetPaths((assignable,columnReferences) -> {\n  final SqmPathInterpretation<?> pathInterpretation=(SqmPathInterpretation<?>)assignable;\n  final int offset=CteTable.determineModelPartStartIndex(entityDescriptor,pathInterpretation.getExpressionType());\n  if (offset == -1) {\n    throw new IllegalStateException(\"Couldn't find matching cte column for: \" + ((Expression)assignable).getExpressionType());\n  }\n  final int end=offset + pathInterpretation.getExpressionType().getJdbcTypeCount();\n  final List<CteColumn> columns=cteTable.getCteColumns().subList(offset,end);\n  insertStatement.addTargetColumnReferences(columnReferences);\n  targetPathCteColumns.addAll(columns);\n  targetPathColumns.add(new AbstractMap.SimpleEntry<>(columns,new Assignment(assignable,(Expression)assignable)));\n}\n,sqmInsertStatement,entityDescriptor,insertingTableGroup,(sqmParameter,mappingType,jdbcParameters) -> {\n  parameterResolutions.computeIfAbsent(sqmParameter,k -> new ArrayList<>(1)).add(jdbcParameters);\n  paramTypeResolutions.put(sqmParameter,mappingType);\n}\n);\nfinal boolean assignsId=targetPathCteColumns.contains(cteTable.getCteColumns().get(0));\nfinal Stack<SqlAstProcessingState> processingStateStack=sqmConverter.getProcessingStateStack();\nfinal SqlAstProcessingState oldState=processingStateStack.pop();\nfinal Statement queryStatement;\nif(sqmInsertStatement instanceof SqmInsertSelectStatement){final QueryPart queryPart=sqmConverter.visitQueryPart(((SqmInsertSelectStatement<?>)sqmInsertStatement).getSelectQueryPart());\nqueryPart.visitQuerySpecs(querySpec -> {\n  if (additionalInsertValues.applySelections(querySpec,sessionFactory)) {\n    final CteColumn rowNumberColumn=cteTable.getCteColumns().get(cteTable.getCteColumns().size() - 1);\n    final ColumnReference columnReference=new ColumnReference((String)null,rowNumberColumn.getColumnExpression(),false,null,null,rowNumberColumn.getJdbcMapping());\n    insertStatement.getTargetColumnReferences().set(insertStatement.getTargetColumnReferences().size() - 1,columnReference);\n    targetPathCteColumns.set(targetPathCteColumns.size() - 1,rowNumberColumn);\n  }\n  if (!assignsId && entityDescriptor.getIdentifierGenerator() instanceof PostInsertIdentifierGenerator) {\n    querySpec.getSelectClause().addSqlSelection(new SqlSelectionImpl(1,0,SqmInsertStrategyHelper.createRowNumberingExpression(querySpec,sessionFactory)));\n  }\n}\n);\nqueryStatement=new SelectStatement(queryPart);\n}{final List<SqmValues> sqmValuesList=((SqmInsertValuesStatement<?>)sqmInsertStatement).getValuesList();\nfinal List<Values> valuesList=new ArrayList<>(sqmValuesList.size());\nfor(SqmValues sqmValues: sqmValuesList){final Values values=sqmConverter.visitValues(sqmValues);\nadditionalInsertValues.applyValues(values);\nvaluesList.add(values);\n}final QuerySpec querySpec=new QuerySpec(true);\nfinal NavigablePath navigablePath=new NavigablePath(entityDescriptor.getRootPathName());\nfinal List<String> columnNames=new ArrayList<>(targetPathColumns.size());\nfinal String valuesAlias=insertingTableGroup.getPrimaryTableReference().getIdentificationVariable();\nfor(Map.Entry<List<CteColumn>,Assignment> entry: targetPathColumns){for(ColumnReference columnReference: entry.getValue().getAssignable().getColumnReferences()){columnNames.add(columnReference.getColumnExpression());\nquerySpec.getSelectClause().addSqlSelection(new SqlSelectionImpl(1,0,columnReference.getQualifier().equals(valuesAlias) ? columnReference : new ColumnReference(valuesAlias,columnReference.getColumnExpression(),false,null,null,columnReference.getJdbcMapping())));\n}}final ValuesTableGroup valuesTableGroup=new ValuesTableGroup(navigablePath,entityDescriptor.getEntityPersister(),valuesList,insertingTableGroup.getPrimaryTableReference().getIdentificationVariable(),columnNames,true,factory);\nquerySpec.getFromClause().addRoot(valuesTableGroup);\nqueryStatement=new SelectStatement(querySpec);\n}processingStateStack.push(oldState);\nsqmConverter.pruneTableGroupJoins();\nif(!assignsId && entityDescriptor.getIdentifierGenerator() instanceof PostInsertIdentifierGenerator){final CteColumn rowNumberColumn=cteTable.getCteColumns().get(cteTable.getCteColumns().size() - 1);\nfinal ColumnReference columnReference=new ColumnReference((String)null,rowNumberColumn.getColumnExpression(),false,null,null,rowNumberColumn.getJdbcMapping());\ninsertStatement.getTargetColumnReferences().add(columnReference);\ntargetPathCteColumns.add(rowNumberColumn);\n}final CteTable entityCteTable=createCteTable(getCteTable(),targetPathCteColumns,factory);\nfinal QuerySpec querySpec=new QuerySpec(true,1);\nfinal List<DomainResult<?>> domainResults=new ArrayList<>(1);\nfinal SelectStatement statement=new SelectStatement(querySpec,domainResults);\nfinal CteStatement entityCte;\nif(additionalInsertValues.requiresRowNumberIntermediate()){final CteTable fullEntityCteTable=getCteTable();\nfinal String baseTableName=\"base_\" + entityCteTable.getTableExpression();\nfinal CteStatement baseEntityCte=new CteStatement(entityCteTable.withName(baseTableName),queryStatement,CteMaterialization.MATERIALIZED);\nstatement.addCteStatement(baseEntityCte);\nfinal CteColumn rowNumberColumn=fullEntityCteTable.getCteColumns().get(fullEntityCteTable.getCteColumns().size() - 1);\nfinal ColumnReference rowNumberColumnReference=new ColumnReference(\"e\",rowNumberColumn.getColumnExpression(),false,null,null,rowNumberColumn.getJdbcMapping());\nfinal CteColumn idColumn=fullEntityCteTable.getCteColumns().get(0);\nfinal BasicValuedMapping idType=(BasicValuedMapping)idColumn.getJdbcMapping();\nfinal Optimizer optimizer=((OptimizableGenerator)entityDescriptor.getIdentifierGenerator()).getOptimizer();\nfinal BasicValuedMapping integerType=(BasicValuedMapping)rowNumberColumn.getJdbcMapping();\nfinal Expression rowNumberMinusOneModuloIncrement=new BinaryArithmeticExpression(new BinaryArithmeticExpression(rowNumberColumnReference,BinaryArithmeticOperator.SUBTRACT,new QueryLiteral<>(1,(BasicValuedMapping)rowNumberColumn.getJdbcMapping()),integerType),BinaryArithmeticOperator.MODULO,new QueryLiteral<>(optimizer.getIncrementSize(),integerType),integerType);\n{final QuerySpec rowsWithSequenceQuery=new QuerySpec(true);\nrowsWithSequenceQuery.getFromClause().addRoot(new CteTableGroup(new NamedTableReference(baseTableName,\"e\",false,factory)));\nrowsWithSequenceQuery.getSelectClause().addSqlSelection(new SqlSelectionImpl(1,0,rowNumberColumnReference));\nfinal String fragment=((BulkInsertionCapableIdentifierGenerator)entityDescriptor.getIdentifierGenerator()).determineBulkInsertionIdentifierGenerationSelectFragment(sessionFactory.getSqlStringGenerationContext());\nrowsWithSequenceQuery.getSelectClause().addSqlSelection(new SqlSelectionImpl(2,1,new SelfRenderingSqlFragmentExpression(fragment)));\nrowsWithSequenceQuery.applyPredicate(new ComparisonPredicate(rowNumberMinusOneModuloIncrement,ComparisonOperator.EQUAL,new QueryLiteral<>(0,integerType)));\nfinal CteTable rowsWithSequenceCteTable=new CteTable(ROW_NUMBERS_WITH_SEQUENCE_VALUE,List.of(rowNumberColumn,idColumn));\nfinal SelectStatement rowsWithSequenceStatement=new SelectStatement(rowsWithSequenceQuery);\nfinal CteStatement rowsWithSequenceCte=new CteStatement(rowsWithSequenceCteTable,rowsWithSequenceStatement,CteMaterialization.MATERIALIZED);\nstatement.addCteStatement(rowsWithSequenceCte);\n}{final QuerySpec entityQuery=new QuerySpec(true);\nfinal NavigablePath navigablePath=new NavigablePath(baseTableName);\nfinal TableGroup baseTableGroup=new TableGroupImpl(navigablePath,null,new NamedTableReference(baseTableName,\"e\",false,factory),null);\nfinal TableGroup rowsWithSequenceTableGroup=new CteTableGroup(new NamedTableReference(ROW_NUMBERS_WITH_SEQUENCE_VALUE,\"t\",false,factory));\nbaseTableGroup.addTableGroupJoin(new TableGroupJoin(rowsWithSequenceTableGroup.getNavigablePath(),SqlAstJoinType.LEFT,rowsWithSequenceTableGroup,new ComparisonPredicate(new BinaryArithmeticExpression(rowNumberColumnReference,BinaryArithmeticOperator.SUBTRACT,rowNumberMinusOneModuloIncrement,integerType),ComparisonOperator.EQUAL,new ColumnReference(\"t\",rowNumberColumn.getColumnExpression(),false,null,null,rowNumberColumn.getJdbcMapping()))));\nentityQuery.getFromClause().addRoot(baseTableGroup);\nentityQuery.getSelectClause().addSqlSelection(new SqlSelectionImpl(1,0,new BinaryArithmeticExpression(new ColumnReference(\"t\",idColumn.getColumnExpression(),false,null,null,idColumn.getJdbcMapping()),BinaryArithmeticOperator.ADD,new BinaryArithmeticExpression(rowNumberColumnReference,BinaryArithmeticOperator.SUBTRACT,new ColumnReference(\"t\",rowNumberColumn.getColumnExpression(),false,null,null,rowNumberColumn.getJdbcMapping()),integerType),idType)));\nfinal CteTable finalEntityCteTable;\nif(targetPathCteColumns.contains(getCteTable().getCteColumns().get(0))){finalEntityCteTable=entityCteTable;\n}{targetPathCteColumns.add(0,getCteTable().getCteColumns().get(0));\nfinalEntityCteTable=createCteTable(getCteTable(),targetPathCteColumns,factory);\n}final List<CteColumn> cteColumns=finalEntityCteTable.getCteColumns();\nfor(int i=1; i < cteColumns.size(); i++){final CteColumn cteColumn=cteColumns.get(i);\nentityQuery.getSelectClause().addSqlSelection(new SqlSelectionImpl(i + 1,i,new ColumnReference(\"e\",cteColumn.getColumnExpression(),false,null,null,cteColumn.getJdbcMapping())));\n}final SelectStatement entityStatement=new SelectStatement(entityQuery);\nentityCte=new CteStatement(finalEntityCteTable,entityStatement,CteMaterialization.MATERIALIZED);\nstatement.addCteStatement(entityCte);\n}}if(!assignsId && entityDescriptor.getIdentifierGenerator() instanceof PostInsertIdentifierGenerator){final String baseTableName=\"base_\" + entityCteTable.getTableExpression();\nfinal CteStatement baseEntityCte=new CteStatement(entityCteTable.withName(baseTableName),queryStatement,CteMaterialization.MATERIALIZED);\nstatement.addCteStatement(baseEntityCte);\ntargetPathCteColumns.add(0,cteTable.getCteColumns().get(0));\nfinal CteTable finalEntityCteTable=createCteTable(getCteTable(),targetPathCteColumns,factory);\nfinal QuerySpec finalQuerySpec=new QuerySpec(true);\nfinal SelectStatement finalQueryStatement=new SelectStatement(finalQuerySpec);\nentityCte=new CteStatement(finalEntityCteTable,finalQueryStatement,CteMaterialization.MATERIALIZED);\n}{entityCte=new CteStatement(entityCteTable,queryStatement,CteMaterialization.MATERIALIZED);\nstatement.addCteStatement(entityCte);\n}final String baseInsertCte=addDmlCtes(statement,entityCte,targetPathColumns,assignsId,sqmConverter,parameterResolutions,factory);\nfinal Expression count=createCountStar(factory,sqmConverter);\ndomainResults.add(new BasicResult<>(0,null,((SqlExpressible)count).getJdbcMapping()));\nquerySpec.getSelectClause().addSqlSelection(new SqlSelectionImpl(1,0,count));\nquerySpec.getFromClause().addRoot(new CteTableGroup(new NamedTableReference(baseInsertCte,CTE_TABLE_IDENTIFIER,false,factory)));\nfinal JdbcServices jdbcServices=factory.getJdbcServices();\nfinal SqlAstTranslator<JdbcSelect> translator=jdbcServices.getJdbcEnvironment().getSqlAstTranslatorFactory().buildSelectTranslator(factory,statement);\nfinal JdbcParameterBindings jdbcParameterBindings=SqmUtil.createJdbcParameterBindings(executionContext.getQueryParameterBindings(),domainParameterXref,SqmUtil.generateJdbcParamsXref(domainParameterXref,sqmConverter),factory.getRuntimeMetamodels().getMappingMetamodel(),navigablePath -> sqmConverter.getMutatingTableGroup(),new SqmParameterMappingModelResolutionAccess(){\n  @Override @SuppressWarnings(\"unchecked\") public <T>MappingModelExpressible<T> getResolvedMappingModelType(  SqmParameter<T> parameter){\n    return (MappingModelExpressible<T>)paramTypeResolutions.get(parameter);\n  }\n}\n,executionContext.getSession());\nfinal JdbcSelect select=translator.translate(jdbcParameterBindings,executionContext.getQueryOptions());\nexecutionContext.getSession().autoFlushIfRequired(select.getAffectedTableNames());\nList<Object> list=jdbcServices.getJdbcSelectExecutor().list(select,jdbcParameterBindings,SqmJdbcExecutionContextAdapter.omittingLockingAndPaging(executionContext),row -> row[0],ListResultsConsumer.UniqueSemantic.NONE);\nreturn ((Number)list.get(0)).intValue();\n}",
            "methodSignature: org.hibernate.query.sqm.mutation.internal.temptable.InsertExecutionDelegate#execute\n methodBody: public int execute(ExecutionContext executionContext) {\nExecuteWithTemporaryTableHelper.performBeforeTemporaryTableUseActions(entityTable,executionContext);\ntryif(sessionUidParameter != null){jdbcParameterBindings.addBinding(sessionUidParameter,new JdbcParameterBindingImpl(entityTable.getSessionUidColumn().getJdbcMapping(),UUID.fromString(sessionUidAccess.apply(executionContext.getSession()))));\n}final int rows=ExecuteWithTemporaryTableHelper.saveIntoTemporaryTable(insertStatement,jdbcParameterBindings,executionContext);\nif(rows != 0){final AbstractEntityPersister persister=(AbstractEntityPersister)entityDescriptor.getEntityPersister();\nfinal int tableSpan=persister.getTableSpan();\ninsertRootTable(persister.getTableName(0),rows,persister.getKeyColumns(0),executionContext);\nif(persister.hasDuplicateTables()){final String[] insertedTables=new String[tableSpan];\ninsertedTables[0]=persister.getTableName(0);\nfor(int i=1; i < tableSpan; i++){if(persister.isInverseTable(i)){continue;\n}final String tableName=persister.getTableName(i);\ninsertedTables[i]=tableName;\nif(ArrayHelper.indexOf(insertedTables,i,tableName) != -1){continue;\n}insertTable(tableName,persister.getKeyColumns(i),persister.isNullableTable(i),executionContext);\n}}{for(int i=1; i < tableSpan; i++){insertTable(persister.getTableName(i),persister.getKeyColumns(i),persister.isNullableTable(i),executionContext);\n}}}return rows;\nfinallyExecuteWithTemporaryTableHelper.performAfterTemporaryTableUseActions(entityTable,sessionUidAccess,afterUseAction,executionContext);\n}",
            "methodSignature: org.hibernate.engine.jdbc.internal.JdbcCoordinatorImpl#getResultSetReturn\n methodBody: public ResultSetReturn getResultSetReturn() {\nif(resultSetExtractor == null){resultSetExtractor=new ResultSetReturnImpl(this,jdbcServices);\n}return resultSetExtractor;\n}",
            "methodSignature: org.hibernate.engine.jdbc.batch.spi.Batch#addObserver\n methodBody: void addObserver(BatchObserver observer);",
            "methodSignature: org.hibernate.query.sqm.mutation.internal.temptable.UpdateExecutionDelegate#execute\n methodBody: public int execute(ExecutionContext executionContext) {\nExecuteWithTemporaryTableHelper.performBeforeTemporaryTableUseActions(idTable,executionContext);\ntryfinal int rows=ExecuteWithTemporaryTableHelper.saveMatchingIdsIntoIdTable(sqmConverter,suppliedPredicate,idTable,sessionUidAccess,jdbcParameterBindings,executionContext);\nfinal QuerySpec idTableSubQuery=ExecuteWithTemporaryTableHelper.createIdTableSelectQuerySpec(idTable,sessionUidAccess,entityDescriptor,executionContext);\nentityDescriptor.visitConstraintOrderedTables((tableExpression,tableKeyColumnVisitationSupplier) -> updateTable(tableExpression,tableKeyColumnVisitationSupplier,rows,idTableSubQuery,executionContext));\nreturn rows;\nfinallyExecuteWithTemporaryTableHelper.performAfterTemporaryTableUseActions(idTable,sessionUidAccess,afterUseAction,executionContext);\n}",
            "methodSignature: org.hibernate.metamodel.mapping.internal.MappingModelCreationProcess#execute\n methodBody: private void execute() {\nfor(EntityPersister entityPersister: entityPersisterMap.values()){if(entityPersister instanceof InFlightEntityMappingType){((InFlightEntityMappingType)entityPersister).linkWithSuperType(this);\n}}for(EntityPersister entityPersister: entityPersisterMap.values()){currentlyProcessingRole=entityPersister.getEntityName();\nif(entityPersister instanceof InFlightEntityMappingType){((InFlightEntityMappingType)entityPersister).prepareMappingModel(this);\n}}executePostInitCallbacks();\n}",
            "methodSignature: org.hibernate.orm.test.insertordering.InsertOrderingTest.StatsBatchBuilder#buildBatch\n methodBody: public Batch buildBatch(BatchKey key, JdbcCoordinator jdbcCoordinator) {\nreturn new StatsBatch(key,jdbcCoordinator,getJdbcBatchSize());\n}",
            "methodSignature: org.hibernate.query.sqm.mutation.internal.cte.AbstractCteMutationHandler#execute\n methodBody: public int execute(DomainQueryExecutionContext executionContext) {\nfinal SqmDeleteOrUpdateStatement sqmMutationStatement=getSqmDeleteOrUpdateStatement();\nfinal SessionFactoryImplementor factory=executionContext.getSession().getFactory();\nfinal EntityMappingType entityDescriptor=getEntityDescriptor();\nfinal String explicitDmlTargetAlias;\nif(sqmMutationStatement.getTarget().getExplicitAlias() == null){explicitDmlTargetAlias=\"dml_target\";\n}{explicitDmlTargetAlias=sqmMutationStatement.getTarget().getExplicitAlias();\n}final MultiTableSqmMutationConverter sqmConverter=new MultiTableSqmMutationConverter(entityDescriptor,sqmMutationStatement,sqmMutationStatement.getTarget(),explicitDmlTargetAlias,domainParameterXref,executionContext.getQueryOptions(),executionContext.getSession().getLoadQueryInfluencers(),executionContext.getQueryParameterBindings(),factory);\nfinal Map<SqmParameter<?>,List<JdbcParameter>> parameterResolutions;\nif(domainParameterXref.getSqmParameterCount() == 0){parameterResolutions=Collections.emptyMap();\n}{parameterResolutions=new IdentityHashMap<>();\n}final Map<SqmParameter,MappingModelExpressible> paramTypeResolutions=new LinkedHashMap<>();\nfinal Predicate restriction=sqmConverter.visitWhereClause(sqmMutationStatement.getWhereClause(),columnReference -> {\n}\n,(sqmParam,mappingType,jdbcParameters) -> paramTypeResolutions.put(sqmParam,mappingType));\nsqmConverter.pruneTableGroupJoins();\nfinal CteStatement idSelectCte=new CteStatement(getCteTable(),MatchingIdSelectionHelper.generateMatchingIdSelectStatement(entityDescriptor,sqmMutationStatement,true,restriction,sqmConverter,executionContext,factory),CteMaterialization.MATERIALIZED);\nfinal QuerySpec querySpec=new QuerySpec(true,1);\nfinal List<DomainResult<?>> domainResults=new ArrayList<>(1);\nfinal SelectStatement statement=new SelectStatement(querySpec,domainResults);\nfinal JdbcServices jdbcServices=factory.getJdbcServices();\nfinal SqlAstTranslator<JdbcSelect> translator=jdbcServices.getJdbcEnvironment().getSqlAstTranslatorFactory().buildSelectTranslator(factory,statement);\nfinal Expression count=createCountStar(factory,sqmConverter);\ndomainResults.add(new BasicResult<>(0,null,((SqlExpressible)count).getJdbcMapping()));\nquerySpec.getSelectClause().addSqlSelection(new SqlSelectionImpl(1,0,count));\nquerySpec.getFromClause().addRoot(new CteTableGroup(new NamedTableReference(idSelectCte.getCteTable().getTableExpression(),CTE_TABLE_IDENTIFIER,false,factory)));\nstatement.addCteStatement(idSelectCte);\naddDmlCtes(statement,idSelectCte,sqmConverter,parameterResolutions,factory);\nfinal JdbcParameterBindings jdbcParameterBindings=SqmUtil.createJdbcParameterBindings(executionContext.getQueryParameterBindings(),domainParameterXref,SqmUtil.generateJdbcParamsXref(domainParameterXref,sqmConverter),factory.getRuntimeMetamodels().getMappingMetamodel(),navigablePath -> sqmConverter.getMutatingTableGroup(),paramTypeResolutions::get,executionContext.getSession());\nfinal LockOptions lockOptions=executionContext.getQueryOptions().getLockOptions();\nfinal LockMode lockMode=lockOptions.getAliasSpecificLockMode(explicitDmlTargetAlias);\nlockOptions.setAliasSpecificLockMode(explicitDmlTargetAlias,LockMode.WRITE);\nfinal JdbcSelect select=translator.translate(jdbcParameterBindings,executionContext.getQueryOptions());\nlockOptions.setAliasSpecificLockMode(explicitDmlTargetAlias,lockMode);\nexecutionContext.getSession().autoFlushIfRequired(select.getAffectedTableNames());\nList<Object> list=jdbcServices.getJdbcSelectExecutor().list(select,jdbcParameterBindings,SqmJdbcExecutionContextAdapter.omittingLockingAndPaging(executionContext),row -> row[0],ListResultsConsumer.UniqueSemantic.NONE);\nreturn ((Number)list.get(0)).intValue();\n}",
            "methodSignature: org.hibernate.mapping.Component.ValueGenerationPlan#execute\n methodBody: public void execute(SharedSessionContractImplementor session, Object incomingObject, Object injectionContext) {\nfinal Object generatedValue=subGenerator.generate(session,incomingObject);\ninjector.set(injectionContext,generatedValue);\n}",
            "methodSignature: org.hibernate.query.sqm.mutation.internal.temptable.TableBasedInsertHandler.ExecutionDelegate#execute\n methodBody: int execute(ExecutionContext executionContext);",
            "methodSignature: org.hibernate.dialect.AbstractHANADialect.MaterializedNClob#setString\n methodBody: public int setString(long pos, String str) throws SQLException {\nthis.data=this.data.substring(0,(int)(pos - 1)) + str + this.data.substring((int)(pos - 1 + str.length()));\nreturn str.length();\n}",
            "methodSignature: org.hibernate.engine.jdbc.batch.internal.NonBatchingBatch#addToBatch\n methodBody: public void addToBatch() {\nnotifyObserversImplicitExecution();\nfor(Map.Entry<String,PreparedStatement> entry: getStatements().entrySet()){final String statementSQL=entry.getKey();\ntryfinal PreparedStatement statement=entry.getValue();\nfinal int rowCount=jdbcCoordinator.getResultSetReturn().executeUpdate(statement);\ngetKey().getExpectation().verifyOutcome(rowCount,statement,0,statementSQL);\njdbcCoordinator.getLogicalConnection().getResourceRegistry().release(statement);\njdbcCoordinator.afterStatementExecution();\ncatch(SQLException e)abortBatch(e);\nthrow sqlExceptionHelper().convert(e,\"could not execute non-batched batch statement\",statementSQL);\ncatch(RuntimeException e)abortBatch(e);\nthrow e;\n}getStatements().clear();\n}",
            "methodSignature: org.hibernate.engine.jdbc.internal.JdbcCoordinatorImpl#getStatementPreparer\n methodBody: public StatementPreparer getStatementPreparer() {\nif(statementPreparer == null){statementPreparer=new StatementPreparerImpl(this,jdbcServices);\n}return statementPreparer;\n}",
            "methodSignature: org.hibernate.sql.Insert#getDialect\n methodBody: protected Dialect getDialect() {\nreturn dialect;\n}",
            "methodSignature: org.hibernate.engine.jdbc.batch.internal.AbstractBatchImpl#release\n methodBody: public void release() {\nif(getStatements() != null && !getStatements().isEmpty()){LOG.batchContainedStatementsOnRelease();\n}releaseStatements();\nobservers.clear();\n}",
            "methodSignature: org.hibernate.sql.exec.internal.StandardJdbcMutationExecutor#execute\n methodBody: public int execute(\n\t\t\tJdbcMutation jdbcMutation,\n\t\t\tJdbcParameterBindings jdbcParameterBindings,\n\t\t\tFunction<String, PreparedStatement> statementCreator,\n\t\t\tBiConsumer<Integer, PreparedStatement> expectationCheck,\n\t\t\tExecutionContext executionContext) {\nfinal SharedSessionContractImplementor session=executionContext.getSession();\nsession.autoFlushIfRequired(jdbcMutation.getAffectedTableNames());\nfinal LogicalConnectionImplementor logicalConnection=session.getJdbcCoordinator().getLogicalConnection();\nfinal JdbcServices jdbcServices=session.getJdbcServices();\nfinal QueryOptions queryOptions=executionContext.getQueryOptions();\nfinal String finalSql;\nif(queryOptions == null){finalSql=jdbcMutation.getSql();\n}{finalSql=jdbcServices.getDialect().addSqlHintOrComment(jdbcMutation.getSql(),queryOptions,executionContext.getSession().getFactory().getSessionFactoryOptions().isCommentsEnabled());\n}tryfinal PreparedStatement preparedStatement=statementCreator.apply(finalSql);\ntryif(executionContext.getQueryOptions().getTimeout() != null){preparedStatement.setQueryTimeout(executionContext.getQueryOptions().getTimeout());\n}int paramBindingPosition=1;\nfor(JdbcParameterBinder parameterBinder: jdbcMutation.getParameterBinders()){parameterBinder.bindParameterValue(preparedStatement,paramBindingPosition++,jdbcParameterBindings,executionContext);\n}session.getEventListenerManager().jdbcExecuteStatementStart();\ntryint rows=preparedStatement.executeUpdate();\nexpectationCheck.accept(rows,preparedStatement);\nreturn rows;\nfinallysession.getEventListenerManager().jdbcExecuteStatementEnd();\nfinallylogicalConnection.getResourceRegistry().release(preparedStatement);\ncatch(SQLException e)throw jdbcServices.getSqlExceptionHelper().convert(e,\"JDBC exception executing SQL [\" + finalSql + \"]\");\nfinallyexecutionContext.afterStatement(logicalConnection);\n}",
            "methodSignature: org.hibernate.sql.exec.spi.JdbcMutationExecutor#execute\n methodBody: int execute(\n\t\t\tJdbcMutation jdbcMutation,\n\t\t\tJdbcParameterBindings jdbcParameterBindings,\n\t\t\tFunction<String, PreparedStatement> statementCreator,\n\t\t\tBiConsumer<Integer, PreparedStatement> expectationCheck,\n\t\t\tExecutionContext executionContext);",
            "methodSignature: org.hibernate.engine.jdbc.batch.internal.AbstractBatchImpl#addObserver\n methodBody: public void addObserver(BatchObserver observer) {\nobservers.add(observer);\n}",
            "methodSignature: org.hibernate.engine.jdbc.batch.internal.BatchBuilderImpl#setJdbcBatchSize\n methodBody: public void setJdbcBatchSize(int jdbcBatchSize) {\nthis.jdbcBatchSize=jdbcBatchSize;\n}",
            "methodSignature: org.hibernate.engine.jdbc.batch.internal.BatchingBatch#getBatchStatement\n methodBody: public PreparedStatement getBatchStatement(String sql, boolean callable) {\ncurrentStatementSql=sql;\nint previousBatchSize=getStatements().size();\ncurrentStatement=super.getBatchStatement(sql,callable);\nint currentBatchSize=getStatements().size();\nif(currentBatchSize > previousBatchSize){this.batchSize=this.configuredBatchSize * currentBatchSize;\n}return currentStatement;\n}",
            "methodSignature: org.hibernate.engine.jdbc.batch.spi.Batch#getBatchStatement\n methodBody: PreparedStatement getBatchStatement(String sql, boolean callable);",
            "methodSignature: org.hibernate.engine.jdbc.spi.JdbcCoordinator#close\n methodBody: Connection close();",
            "methodSignature: org.hibernate.engine.jdbc.batch.spi.Batch#addToBatch\n methodBody: void addToBatch();",
            "methodSignature: org.hibernate.engine.jdbc.batch.internal.BatchingBatch#addToBatch\n methodBody: public void addToBatch() {\ntrycurrentStatement.addBatch();\ncatch(SQLException e)abortBatch(e);\nLOG.debug(\"SQLException escaped proxy\",e);\nthrow sqlExceptionHelper().convert(e,\"could not perform addBatch\",currentStatementSql);\ncatch(RuntimeException e)abortBatch(e);\nthrow e;\nstatementPosition++;\nif(statementPosition >= getKey().getBatchedStatementCount()){batchPosition++;\nif(batchPosition == batchSize){notifyObserversImplicitExecution();\nperformExecution();\nbatchPosition=0;\nbatchExecuted=true;\n}statementPosition=0;\n}}",
            "methodSignature: org.hibernate.action.internal.BulkOperationCleanupAction.CollectionCleanup#release\n methodBody: private void release() {\ncacheAccess.unlockRegion(cacheLock);\n}",
            "methodSignature: org.hibernate.engine.jdbc.batch.internal.AbstractBatchImpl#execute\n methodBody: public final void execute() {\nnotifyObserversExplicitExecution();\nif(getStatements().isEmpty()){return;\n}trydoExecuteBatch();\nfinallyreleaseStatements();\n}",
            "methodSignature: org.hibernate.action.internal.BulkOperationCleanupAction.EntityCleanup#release\n methodBody: private void release() {\ncacheAccess.unlockRegion(cacheLock);\n}",
            "methodSignature: org.hibernate.sql.results.jdbc.internal.DeferredResultSetAccess#release\n methodBody: public void release() {\nif(resultSet != null){getPersistenceContext().getJdbcCoordinator().getLogicalConnection().getResourceRegistry().release(resultSet,preparedStatement);\nresultSet=null;\n}if(preparedStatement != null){getPersistenceContext().getJdbcCoordinator().getLogicalConnection().getResourceRegistry().release(preparedStatement);\npreparedStatement=null;\n}}",
            "methodSignature: org.hibernate.query.sqm.mutation.internal.temptable.RestrictedDeleteExecutionDelegate#execute\n methodBody: public int execute(DomainQueryExecutionContext executionContext) {\nfinal EntityPersister entityDescriptor=sessionFactory.getRuntimeMetamodels().getMappingMetamodel().getEntityDescriptor(sqmDelete.getTarget().getEntityName());\nfinal String hierarchyRootTableName=((Joinable)entityDescriptor).getTableName();\nfinal TableGroup deletingTableGroup=converter.getMutatingTableGroup();\nfinal TableReference hierarchyRootTableReference=deletingTableGroup.resolveTableReference(deletingTableGroup.getNavigablePath(),hierarchyRootTableName);\nassert hierarchyRootTableReference != null;\nfinal Map<SqmParameter<?>,List<List<JdbcParameter>>> parameterResolutions;\nfinal Map<SqmParameter<?>,MappingModelExpressible<?>> paramTypeResolutions;\nif(domainParameterXref.getSqmParameterCount() == 0){parameterResolutions=Collections.emptyMap();\nparamTypeResolutions=Collections.emptyMap();\n}{parameterResolutions=new IdentityHashMap<>();\nparamTypeResolutions=new LinkedHashMap<>();\n}final MutableBoolean needsIdTableWrapper=new MutableBoolean(false);\nfinal Predicate specifiedRestriction=converter.visitWhereClause(sqmDelete.getWhereClause(),columnReference -> {\n  if (!hierarchyRootTableReference.getIdentificationVariable().equals(columnReference.getQualifier())) {\n    needsIdTableWrapper.setValue(true);\n  }\n}\n,(sqmParameter,mappingType,jdbcParameters) -> {\n  parameterResolutions.computeIfAbsent(sqmParameter,k -> new ArrayList<>(1)).add(jdbcParameters);\n  paramTypeResolutions.put(sqmParameter,mappingType);\n}\n);\nfinal PredicateCollector predicateCollector=new PredicateCollector(specifiedRestriction);\nentityDescriptor.applyBaseRestrictions((filterPredicate) -> {\n  needsIdTableWrapper.setValue(true);\n  predicateCollector.applyPredicate(filterPredicate);\n}\n,deletingTableGroup,true,executionContext.getSession().getLoadQueryInfluencers().getEnabledFilters(),null,converter);\nconverter.pruneTableGroupJoins();\nfinal boolean needsIdTable=needsIdTableWrapper.getValue() || entityDescriptor != entityDescriptor.getRootEntityDescriptor();\nfinal SqmJdbcExecutionContextAdapter executionContextAdapter=SqmJdbcExecutionContextAdapter.omittingLockingAndPaging(executionContext);\nif(needsIdTable){return executeWithIdTable(predicateCollector.getPredicate(),deletingTableGroup,parameterResolutions,paramTypeResolutions,executionContextAdapter);\n}{return executeWithoutIdTable(predicateCollector.getPredicate(),deletingTableGroup,parameterResolutions,paramTypeResolutions,converter.getSqlExpressionResolver(),executionContextAdapter);\n}}",
            "methodSignature: org.hibernate.orm.test.jpa.transaction.batch.JtaWithFailingBatchTest.TestBatchBuilder#buildBatch\n methodBody: public Batch buildBatch(BatchKey key, JdbcCoordinator jdbcCoordinator) {\nreturn buildBatchTest(key,jdbcCoordinator,getJdbcBatchSize());\n}",
            "methodSignature: org.hibernate.orm.test.jpa.transaction.batch.FailingAddToBatchTest.TestBatch#getBatchStatement\n methodBody: public PreparedStatement getBatchStatement(String sql, boolean callable) {\nPreparedStatement batchStatement=super.getBatchStatement(sql,callable);\ncreatedStatements.add(batchStatement);\nreturn batchStatement;\n}",
            "methodSignature: org.hibernate.orm.test.jpa.transaction.batch.JtaWithStatementsBatchTest.TestBatchBuilder#buildBatch\n methodBody: public Batch buildBatch(BatchKey key, JdbcCoordinator jdbcCoordinator) {\nreturn buildBatchTest(key,jdbcCoordinator,getJdbcBatchSize());\n}",
            "methodSignature: org.hibernate.orm.test.manytomany.batchload.TestingBatchBuilder#buildBatch\n methodBody: public Batch buildBatch(BatchKey key, JdbcCoordinator jdbcCoordinator) {\nreturn new TestingBatch(key,jdbcCoordinator);\n}",
            "methodSignature: org.hibernate.persister.collection.AbstractCollectionPersister#getDialect\n methodBody: protected Dialect getDialect() {\nreturn dialect;\n}",
            "methodSignature: org.hibernate.engine.jdbc.spi.JdbcCoordinator#getLogicalConnection\n methodBody: LogicalConnectionImplementor getLogicalConnection();",
            "methodSignature: org.hibernate.query.sqm.mutation.internal.temptable.TableBasedInsertHandler#execute\n methodBody: public int execute(DomainQueryExecutionContext executionContext) {\nif(log.isTraceEnabled()){log.tracef(\"Starting multi-table insert execution - %s\",getSqmInsertStatement().getTarget().getModel().getName());\n}final SqmJdbcExecutionContextAdapter executionContextAdapter=SqmJdbcExecutionContextAdapter.omittingLockingAndPaging(executionContext);\nreturn resolveDelegate(executionContext).execute(executionContextAdapter);\n}",
            "methodSignature: org.hibernate.orm.test.insertordering.InsertOrderingTest.StatsBatch#getBatchStatement\n methodBody: public PreparedStatement getBatchStatement(String sql, boolean callable) {\nif(batchSQL == null || !batchSQL.equals(sql)){currentBatch++;\nbatchSQL=sql;\nbatchSizes.add(currentBatch,new Counter());\n}return super.getBatchStatement(sql,callable);\n}",
            "methodSignature: org.hibernate.engine.jdbc.spi.JdbcCoordinator#getResultSetReturn\n methodBody: ResultSetReturn getResultSetReturn();",
            "methodSignature: org.hibernate.sql.ast.spi.AbstractSqlAstTranslator#getDialect\n methodBody: public Dialect getDialect() {\nreturn dialect;\n}",
            "methodSignature: org.hibernate.engine.jdbc.batch.internal.BatchBuilderImpl#buildBatch\n methodBody: public Batch buildBatch(BatchKey key, JdbcCoordinator jdbcCoordinator) {\nreturn SharedBatchBuildingCode.buildBatch(jdbcBatchSize,key,jdbcCoordinator);\n}",
            "methodSignature: org.hibernate.orm.test.jpa.transaction.batch.FailingAddToBatchTest.TestBatchBuilder#buildBatch\n methodBody: public Batch buildBatch(BatchKey key, JdbcCoordinator jdbcCoordinator) {\nreturn buildBatchTest(key,jdbcCoordinator,getJdbcBatchSize());\n}",
            "methodSignature: org.hibernate.orm.test.jpa.transaction.batch.FailingAddToBatchTest.TestBatch#addToBatch\n methodBody: public void addToBatch() {\nRuntimeException failure=nextAddToBatchFailure.getAndSet(null);\nif(failure != null){throw failure;\n}super.addToBatch();\n}",
            "methodSignature: org.hibernate.dialect.Dialect#getDropTableString\n methodBody: public String getDropTableString(String tableName) {\nfinal StringBuilder buf=new StringBuilder(\"drop table \");\nif(supportsIfExistsBeforeTableName()){buf.append(\"if exists \");\n}buf.append(tableName).append(getCascadeConstraintsString());\nif(supportsIfExistsAfterTableName()){buf.append(\" if exists\");\n}return buf.toString();\n}",
            "methodSignature: org.hibernate.engine.jdbc.batch.internal.AbstractBatchImpl#getJdbcCoordinator\n methodBody: protected JdbcCoordinator getJdbcCoordinator(){\nreturn this.jdbcCoordinator;\n}",
            "methodSignature: org.hibernate.engine.jdbc.internal.JdbcCoordinatorImpl#sessionFactory\n methodBody: protected SessionFactoryImplementor sessionFactory() {\nreturn this.owner.getJdbcSessionContext().getSessionFactory();\n}",
            "methodSignature: org.hibernate.dialect.AbstractHANADialect.CloseSuppressingReader#close\n methodBody: public void close() {\n}",
            "methodSignature: org.hibernate.sql.ast.spi.AbstractSqlAstTranslator#getJdbcServices\n methodBody: protected JdbcServices getJdbcServices() {\nreturn getSessionFactory().getJdbcServices();\n}"
        ],
        "sourceCodeAfterRefactoring": "@Test\n\tpublic void testSessionBatchingUsage() throws Exception {\n\t\tSession session = openSession();\n\t\tsession.setJdbcBatchSize( 3 );\n\t\tSessionImplementor sessionImpl = (SessionImplementor) session;\n\t\tfinal JdbcCoordinator jdbcCoordinator = sessionImpl.getJdbcCoordinator();\n\n\t\texportSandboxSchema( sessionImpl );\n\n\t\t// ok, now we can get down to it...\n\t\tTransaction txn = session.getTransaction();  // same as Session#getTransaction\n\t\ttxn.begin();\n\n\n\t\tfinal String insertSql = \"insert into SANDBOX_JDBC_TST( ID, NAME ) values ( ?, ? )\";\n\n\t\tfinal BatchBuilderImpl batchBuilder = new BatchBuilderImpl( 2 );\n\t\tfinal BatchKey batchKey = new BasicBatchKey( \"this\" );\n\t\tfinal Batch insertBatch = batchBuilder.buildBatch( batchKey, 3, SANDBOX_TBL, sessionImpl, insertSql );\n\t\tassertThat( insertBatch ).isNotNull();\n\n\t\tfinal JournalingBatchObserver batchObserver = new JournalingBatchObserver();\n\t\tinsertBatch.addObserver( batchObserver );\n\n\t\tfinal JdbcValueBindingsImpl jdbcValueBindings = sandboxInsertValueBindings( sessionImpl );\n\n\t\t// bind values for #1 - this does nothing at the JDBC level\n\t\tjdbcValueBindings.bindValue( 1, SANDBOX_TBL, \"ID\", ParameterUsage.SET, sessionImpl );\n\t\tjdbcValueBindings.bindValue( \"name\", SANDBOX_TBL, \"NAME\", ParameterUsage.SET, sessionImpl );\n\t\tassertThat( batchObserver.getExplicitExecutionCount() ).isEqualTo( 0 );\n\t\tassertThat( batchObserver.getImplicitExecutionCount() ).isEqualTo( 0 );\n\t\tassertThat( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() ).isFalse();\n\n\t\t// add the values to the batch - this creates the prepared statement and binds the values\n\t\tinsertBatch.addToBatch( jdbcValueBindings, null );\n\t\tassertThat( batchObserver.getExplicitExecutionCount() ).isEqualTo( 0 );\n\t\tassertThat( batchObserver.getImplicitExecutionCount() ).isEqualTo( 0 );\n\t\tassertThat( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() ).isTrue();\n\n\t\t// bind values for #2 - this does nothing at the JDBC level : we do still have the statement defining the batch\n\t\tjdbcValueBindings.bindValue( 2, SANDBOX_TBL, \"ID\", ParameterUsage.SET, sessionImpl );\n\t\tjdbcValueBindings.bindValue( \"another name\", SANDBOX_TBL, \"NAME\", ParameterUsage.SET, sessionImpl );\n\t\tassertThat( batchObserver.getExplicitExecutionCount() ).isEqualTo( 0 );\n\t\tassertThat( batchObserver.getImplicitExecutionCount() ).isEqualTo( 0 );\n\t\tassertThat( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() ).isTrue();\n\n\t\t// add #2 to batch - we have not exceeded batch size, so we should not get an implicit execution\n\t\tinsertBatch.addToBatch( jdbcValueBindings, null );\n\t\tassertThat( batchObserver.getExplicitExecutionCount() ).isEqualTo( 0 );\n\t\tassertThat( batchObserver.getImplicitExecutionCount() ).isEqualTo( 0 );\n\t\tassertThat( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() ).isTrue();\n\n\t\t// bind values for #3 - this does nothing at the JDBC level : we do still have the statement defining the batch\n\t\tjdbcValueBindings.bindValue( 3, SANDBOX_TBL, \"ID\", ParameterUsage.SET, sessionImpl );\n\t\tjdbcValueBindings.bindValue( \"yet another name\", SANDBOX_TBL, \"NAME\", ParameterUsage.SET, sessionImpl );\n\t\tassertThat( batchObserver.getExplicitExecutionCount() ).isEqualTo( 0 );\n\t\tassertThat( batchObserver.getImplicitExecutionCount() ).isEqualTo( 0 );\n\t\tassertThat( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() ).isTrue();\n\n\t\tinsertBatch.addToBatch( jdbcValueBindings, null );\n\t\tassertThat( batchObserver.getExplicitExecutionCount() ).isEqualTo( 0 );\n\t\tassertThat( batchObserver.getImplicitExecutionCount() ).isEqualTo( 1 );\n\t\tassertThat( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() ).isTrue();\n\n\t\tinsertBatch.execute();\n\t\tassertThat( batchObserver.getExplicitExecutionCount() ).isEqualTo( 1 );\n\t\tassertThat( batchObserver.getImplicitExecutionCount() ).isEqualTo( 1 );\n\t\tassertThat( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() ).isFalse();\n\n\t\tinsertBatch.release();\n\n\t\ttxn.commit();\n\t\tsession.close();\n\t}\nprivate void exportSandboxSchema(SessionImplementor sessionImpl) {\n\t\tfinal JdbcCoordinator jdbcCoordinator = sessionImpl.getJdbcCoordinator();\n\t\tLogicalConnectionImplementor logicalConnection = jdbcCoordinator.getLogicalConnection();\n\n\t\t// set up some tables to use\n\t\tStatement statement = jdbcCoordinator.getStatementPreparer().createStatement();\n\t\tString dropSql = sessionFactory().getJdbcServices().getDialect().getDropTableString( \"SANDBOX_JDBC_TST\" );\n\t\ttry {\n\t\t\tjdbcCoordinator.getResultSetReturn().execute( statement, dropSql );\n\t\t}\n\t\tcatch ( Exception e ) {\n\t\t\t// ignore if the DB doesn't support \"if exists\" and the table doesn't exist\n\t\t}\n\t\tjdbcCoordinator.getResultSetReturn().execute( statement, \"create table SANDBOX_JDBC_TST ( ID integer, NAME varchar(100) )\" );\n\t\tassertTrue( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n\t\tassertTrue( logicalConnection.isPhysicallyConnected() );\n\t\tjdbcCoordinator.getLogicalConnection().getResourceRegistry().release( statement );\n\t\tassertFalse( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n\t\tassertTrue( logicalConnection.isPhysicallyConnected() ); // after_transaction specified\n\t}",
        "diffSourceCode": "-  180: \t@Test\n-  181: \tpublic void testSessionBatchingUsage() throws Exception {\n-  182: \t\tSession session = openSession();\n-  183: \t\tsession.setJdbcBatchSize( 3 );\n-  184: \t\tSessionImplementor sessionImpl = (SessionImplementor) session;\n-  185: \n-  186: \t\tfinal JdbcCoordinator jdbcCoordinator = sessionImpl.getJdbcCoordinator();\n-  187: \t\tLogicalConnectionImplementor logicalConnection = jdbcCoordinator.getLogicalConnection();\n+  180: \t\t\t\t\t\t\tpublic ParameterUsage getUsage() {\n+  181: \t\t\t\t\t\t\t\treturn ParameterUsage.SET;\n+  182: \t\t\t\t\t\t\t}\n+  183: \n+  184: \t\t\t\t\t\t\t@Override\n+  185: \t\t\t\t\t\t\tpublic int getJdbcPosition() {\n+  186: \t\t\t\t\t\t\t\treturn 1;\n+  187: \t\t\t\t\t\t\t}\n   188: \n-  189: \t\t// set up some tables to use\n-  190: \t\tStatement statement = jdbcCoordinator.getStatementPreparer().createStatement();\n-  191: \t\tString dropSql = sessionFactory().getJdbcServices().getDialect().getDropTableString( \"SANDBOX_JDBC_TST\" );\n-  192: \t\ttry {\n-  193: \t\t\tjdbcCoordinator.getResultSetReturn().execute( statement, dropSql );\n-  194: \t\t}\n-  195: \t\tcatch ( Exception e ) {\n-  196: \t\t\t// ignore if the DB doesn't support \"if exists\" and the table doesn't exist\n-  197: \t\t}\t\tjdbcCoordinator.getResultSetReturn().execute( statement, \"create table SANDBOX_JDBC_TST ( ID integer, NAME varchar(100) )\" );\n-  198:         assertTrue( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n-  199: \t\tassertTrue( logicalConnection.isPhysicallyConnected() );\n-  200:         jdbcCoordinator.getLogicalConnection().getResourceRegistry().release( statement );\n-  201:         assertFalse( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n-  202: \t\tassertTrue( logicalConnection.isPhysicallyConnected() ); // after_transaction specified\n-  203: \n-  204: \t\t// ok, now we can get down to it...\n-  205: \t\tTransaction txn = session.getTransaction();  // same as Session#getTransaction\n-  206: \t\ttxn.begin();\n-  207: \n-  208: \t\tfinal BatchBuilder batchBuilder = new BatchBuilderImpl( 2 );\n-  209: \t\tfinal BatchKey batchKey = new BasicBatchKey( \"this\", Expectations.BASIC );\n-  210: \t\tfinal Batch insertBatch = batchBuilder.buildBatch( batchKey, jdbcCoordinator );\n-  211: \t\tassertTrue( \"unexpected Batch impl\", BatchingBatch.class.isInstance( insertBatch ) );\n-  212: \n-  213: \t\tfinal JournalingBatchObserver batchObserver = new JournalingBatchObserver();\n-  214: \t\tinsertBatch.addObserver( batchObserver );\n-  215: \n-  216: \t\tfinal String insertSql = \"insert into SANDBOX_JDBC_TST( ID, NAME ) values ( ?, ? )\";\n-  217: \n-  218: \t\tPreparedStatement insert = insertBatch.getBatchStatement( insertSql, false );\n-  219: \t\tinsert.setLong( 1, 1 );\n-  220: \t\tinsert.setString( 2, \"name\" );\n-  221: \t\tassertEquals( 0, batchObserver.getExplicitExecutionCount() );\n-  222: \t\tassertEquals( 0, batchObserver.getImplicitExecutionCount() );\n-  223: \t\tinsertBatch.addToBatch();\n-  224: \t\tassertEquals( 0, batchObserver.getExplicitExecutionCount() );\n-  225: \t\tassertEquals( 0, batchObserver.getImplicitExecutionCount() );\n-  226:         assertTrue( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n-  227: \n-  228: \t\tPreparedStatement insert2 = insertBatch.getBatchStatement( insertSql, false );\n-  229: \t\tassertSame( insert, insert2 );\n-  230: \t\tinsert = insert2;\n-  231: \t\tinsert.setLong( 1, 2 );\n-  232: \t\tinsert.setString( 2, \"another name\" );\n-  233: \t\tassertEquals( 0, batchObserver.getExplicitExecutionCount() );\n-  234: \t\tassertEquals( 0, batchObserver.getImplicitExecutionCount() );\n-  235: \t\tinsertBatch.addToBatch();\n-  236: \t\tassertEquals( 0, batchObserver.getExplicitExecutionCount() );\n-  237: \t\tassertEquals( 0, batchObserver.getImplicitExecutionCount() );\n-  238:         assertTrue( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n-  239: \n-  240: \t\tPreparedStatement insert3 = insertBatch.getBatchStatement( insertSql, false );\n-  241: \t\tassertSame( insert, insert3 );\n-  242: \t\tinsert = insert3;\n-  243: \t\tinsert.setLong( 1, 3 );\n-  244: \t\tinsert.setString( 2, \"yet another name\" );\n-  245: \t\tassertEquals( 0, batchObserver.getExplicitExecutionCount() );\n-  246: \t\tassertEquals( 0, batchObserver.getImplicitExecutionCount() );\n-  247: \t\tinsertBatch.addToBatch();\n-  248: \t\tassertEquals( 0, batchObserver.getExplicitExecutionCount() );\n-  249: \t\tassertEquals( 1, batchObserver.getImplicitExecutionCount() );\n-  250:         assertTrue( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n-  251: \n-  252: \t\tinsertBatch.execute();\n-  253: \t\tassertEquals( 1, batchObserver.getExplicitExecutionCount() );\n-  254: \t\tassertEquals( 1, batchObserver.getImplicitExecutionCount() );\n-  255:         assertFalse( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n-  256: \n-  257: \t\tinsertBatch.release();\n-  258: \n-  259: \t\ttxn.commit();\n-  260: \t\tsession.close();\n-  261: \t}\n-  262: \n-  263: \t@Override\n-  264: \tprotected void cleanupTest() throws Exception {\n-  265: \t\ttry (Session session = openSession()) {\n-  266: \t\t\tsession.doWork( connection -> {\n-  267: \t\t\t\tfinal Statement stmnt = connection.createStatement();\n-  268: \n-  269: \t\t\t\tstmnt.execute( sessionFactory().getJdbcServices().getDialect().getDropTableString( \"SANDBOX_JDBC_TST\" ) );\n-  270: \t\t\t} );\n-  271: \t\t}\n-  272: \t}\n-  273: \n-  274: }\n+  189: \t\t\t\t\t\t\t@Override\n+  190: \t\t\t\t\t\t\tpublic JdbcMapping getJdbcMapping() {\n+  191: \t\t\t\t\t\t\t\treturn session.getTypeConfiguration()\n+  192: \t\t\t\t\t\t\t\t\t\t.getBasicTypeRegistry()\n+  193: \t\t\t\t\t\t\t\t\t\t.resolve( StandardBasicTypes.INTEGER );\n+  194: \t\t\t\t\t\t\t}\n+  195: \t\t\t\t\t\t};\n+  196: \t\t\t\t\t}\n+  197: \n+  198: \t\t\t\t\tif ( columnName.equals( \"NAME\" ) ) {\n+  199: \t\t\t\t\t\treturn new JdbcValueDescriptor() {\n+  200: \t\t\t\t\t\t\t@Override\n+  201: \t\t\t\t\t\t\tpublic String getColumnName() {\n+  202: \t\t\t\t\t\t\t\treturn \"NAME\";\n+  203: \t\t\t\t\t\t\t}\n+  204: \n+  205: \t\t\t\t\t\t\t@Override\n+  206: \t\t\t\t\t\t\tpublic ParameterUsage getUsage() {\n+  207: \t\t\t\t\t\t\t\treturn ParameterUsage.SET;\n+  208: \t\t\t\t\t\t\t}\n+  209: \n+  210: \t\t\t\t\t\t\t@Override\n+  211: \t\t\t\t\t\t\tpublic int getJdbcPosition() {\n+  212: \t\t\t\t\t\t\t\treturn 2;\n+  213: \t\t\t\t\t\t\t}\n+  214: \n+  215: \t\t\t\t\t\t\t@Override\n+  216: \t\t\t\t\t\t\tpublic JdbcMapping getJdbcMapping() {\n+  217: \t\t\t\t\t\t\t\treturn session.getTypeConfiguration()\n+  218: \t\t\t\t\t\t\t\t\t\t.getBasicTypeRegistry()\n+  219: \t\t\t\t\t\t\t\t\t\t.resolve( StandardBasicTypes.STRING );\n+  220: \t\t\t\t\t\t\t}\n+  221: \t\t\t\t\t\t};\n+  222: \t\t\t\t\t}\n+  223: \n+  224: \t\t\t\t\tthrow new IllegalArgumentException( \"Unknown column : \" + columnName );\n+  225: \t\t\t\t}\n+  226: \t\t);\n+  227: \t}\n+  228: \n+  229: \t@Test\n+  230: \tpublic void testSessionBatchingUsage() throws Exception {\n+  231: \t\tSession session = openSession();\n+  232: \t\tsession.setJdbcBatchSize( 3 );\n+  233: \t\tSessionImplementor sessionImpl = (SessionImplementor) session;\n+  234: \t\tfinal JdbcCoordinator jdbcCoordinator = sessionImpl.getJdbcCoordinator();\n+  235: \n+  236: \t\texportSandboxSchema( sessionImpl );\n+  237: \n+  238: \t\t// ok, now we can get down to it...\n+  239: \t\tTransaction txn = session.getTransaction();  // same as Session#getTransaction\n+  240: \t\ttxn.begin();\n+  241: \n+  242: \n+  243: \t\tfinal String insertSql = \"insert into SANDBOX_JDBC_TST( ID, NAME ) values ( ?, ? )\";\n+  244: \n+  245: \t\tfinal BatchBuilderImpl batchBuilder = new BatchBuilderImpl( 2 );\n+  246: \t\tfinal BatchKey batchKey = new BasicBatchKey( \"this\" );\n+  247: \t\tfinal Batch insertBatch = batchBuilder.buildBatch( batchKey, 3, SANDBOX_TBL, sessionImpl, insertSql );\n+  248: \t\tassertThat( insertBatch ).isNotNull();\n+  249: \n+  250: \t\tfinal JournalingBatchObserver batchObserver = new JournalingBatchObserver();\n+  251: \t\tinsertBatch.addObserver( batchObserver );\n+  252: \n+  253: \t\tfinal JdbcValueBindingsImpl jdbcValueBindings = sandboxInsertValueBindings( sessionImpl );\n+  254: \n+  255: \t\t// bind values for #1 - this does nothing at the JDBC level\n+  256: \t\tjdbcValueBindings.bindValue( 1, SANDBOX_TBL, \"ID\", ParameterUsage.SET, sessionImpl );\n+  257: \t\tjdbcValueBindings.bindValue( \"name\", SANDBOX_TBL, \"NAME\", ParameterUsage.SET, sessionImpl );\n+  258: \t\tassertThat( batchObserver.getExplicitExecutionCount() ).isEqualTo( 0 );\n+  259: \t\tassertThat( batchObserver.getImplicitExecutionCount() ).isEqualTo( 0 );\n+  260: \t\tassertThat( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() ).isFalse();\n+  261: \n+  262: \t\t// add the values to the batch - this creates the prepared statement and binds the values\n+  263: \t\tinsertBatch.addToBatch( jdbcValueBindings, null );\n+  264: \t\tassertThat( batchObserver.getExplicitExecutionCount() ).isEqualTo( 0 );\n+  265: \t\tassertThat( batchObserver.getImplicitExecutionCount() ).isEqualTo( 0 );\n+  266: \t\tassertThat( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() ).isTrue();\n+  267: \n+  268: \t\t// bind values for #2 - this does nothing at the JDBC level : we do still have the statement defining the batch\n+  269: \t\tjdbcValueBindings.bindValue( 2, SANDBOX_TBL, \"ID\", ParameterUsage.SET, sessionImpl );\n+  270: \t\tjdbcValueBindings.bindValue( \"another name\", SANDBOX_TBL, \"NAME\", ParameterUsage.SET, sessionImpl );\n+  271: \t\tassertThat( batchObserver.getExplicitExecutionCount() ).isEqualTo( 0 );\n+  272: \t\tassertThat( batchObserver.getImplicitExecutionCount() ).isEqualTo( 0 );\n+  273: \t\tassertThat( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() ).isTrue();\n+  274: \n+  275: \t\t// add #2 to batch - we have not exceeded batch size, so we should not get an implicit execution\n+  276: \t\tinsertBatch.addToBatch( jdbcValueBindings, null );\n+  277: \t\tassertThat( batchObserver.getExplicitExecutionCount() ).isEqualTo( 0 );\n+  278: \t\tassertThat( batchObserver.getImplicitExecutionCount() ).isEqualTo( 0 );\n+  279: \t\tassertThat( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() ).isTrue();\n+  280: \n+  281: \t\t// bind values for #3 - this does nothing at the JDBC level : we do still have the statement defining the batch\n+  282: \t\tjdbcValueBindings.bindValue( 3, SANDBOX_TBL, \"ID\", ParameterUsage.SET, sessionImpl );\n+  283: \t\tjdbcValueBindings.bindValue( \"yet another name\", SANDBOX_TBL, \"NAME\", ParameterUsage.SET, sessionImpl );\n+  284: \t\tassertThat( batchObserver.getExplicitExecutionCount() ).isEqualTo( 0 );\n+  285: \t\tassertThat( batchObserver.getImplicitExecutionCount() ).isEqualTo( 0 );\n+  286: \t\tassertThat( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() ).isTrue();\n+  287: \n+  288: \t\tinsertBatch.addToBatch( jdbcValueBindings, null );\n+  289: \t\tassertThat( batchObserver.getExplicitExecutionCount() ).isEqualTo( 0 );\n+  290: \t\tassertThat( batchObserver.getImplicitExecutionCount() ).isEqualTo( 1 );\n+  291: \t\tassertThat( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() ).isTrue();\n+  292: \n+  293: \t\tinsertBatch.execute();\n+  294: \t\tassertThat( batchObserver.getExplicitExecutionCount() ).isEqualTo( 1 );\n+  295: \t\tassertThat( batchObserver.getImplicitExecutionCount() ).isEqualTo( 1 );\n+  296: \t\tassertThat( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() ).isFalse();\n+  297: \n+  298: \t\tinsertBatch.release();\n+  299: \n+  300: \t\ttxn.commit();\n+  301: \t\tsession.close();\n+  302: \t}\n+  304: \tprivate void exportSandboxSchema(SessionImplementor sessionImpl) {\n+  305: \t\tfinal JdbcCoordinator jdbcCoordinator = sessionImpl.getJdbcCoordinator();\n+  306: \t\tLogicalConnectionImplementor logicalConnection = jdbcCoordinator.getLogicalConnection();\n+  307: \n+  308: \t\t// set up some tables to use\n+  309: \t\tStatement statement = jdbcCoordinator.getStatementPreparer().createStatement();\n+  310: \t\tString dropSql = sessionFactory().getJdbcServices().getDialect().getDropTableString( \"SANDBOX_JDBC_TST\" );\n+  311: \t\ttry {\n+  312: \t\t\tjdbcCoordinator.getResultSetReturn().execute( statement, dropSql );\n+  313: \t\t}\n+  314: \t\tcatch ( Exception e ) {\n+  315: \t\t\t// ignore if the DB doesn't support \"if exists\" and the table doesn't exist\n+  316: \t\t}\n+  317: \t\tjdbcCoordinator.getResultSetReturn().execute( statement, \"create table SANDBOX_JDBC_TST ( ID integer, NAME varchar(100) )\" );\n+  318: \t\tassertTrue( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n+  319: \t\tassertTrue( logicalConnection.isPhysicallyConnected() );\n+  320: \t\tjdbcCoordinator.getLogicalConnection().getResourceRegistry().release( statement );\n+  321: \t\tassertFalse( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n+  322: \t\tassertTrue( logicalConnection.isPhysicallyConnected() ); // after_transaction specified\n+  323: \t}\n",
        "uniqueId": "a9ac98b364ccf52bb9cb2be5324c9c983e8bd8b3_180_261_304_323_229_302",
        "moveFileExist": true,
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 11,
        "testResult": true,
        "coverageInfo": {
            "testMethod": {
                "missed": 0,
                "covered": 1
            }
        }
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprivate exportSandboxSchema(sessionImpl SessionImplementor) : void extracted from public testBatchingUsage() : void in class org.hibernate.orm.test.jdbc.internal.BatchingTest",
        "diffLocations": [
            {
                "filePath": "hibernate-core/src/test/java/org/hibernate/orm/test/jdbc/internal/BatchingTest.java",
                "startLine": 110,
                "endLine": 178,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/test/java/org/hibernate/orm/test/jdbc/internal/BatchingTest.java",
                "startLine": 102,
                "endLine": 163,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/test/java/org/hibernate/orm/test/jdbc/internal/BatchingTest.java",
                "startLine": 304,
                "endLine": 323,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "@Test\n\tpublic void testBatchingUsage() throws Exception {\n\t\tSession session = openSession();\n\t\tSessionImplementor sessionImpl = (SessionImplementor) session;\n\t\t\n\t\tfinal JdbcCoordinator jdbcCoordinator = sessionImpl.getJdbcCoordinator();\n\t\tLogicalConnectionImplementor logicalConnection = jdbcCoordinator.getLogicalConnection();\n\n\t\t// set up some tables to use\n\t\tStatement statement = jdbcCoordinator.getStatementPreparer().createStatement();\n\t\tString dropSql = sessionFactory().getJdbcServices().getDialect().getDropTableString( \"SANDBOX_JDBC_TST\" );\n\t\ttry {\n\t\t\tjdbcCoordinator.getResultSetReturn().execute( statement, dropSql );\n\t\t}\n\t\tcatch ( Exception e ) {\n\t\t\t// ignore if the DB doesn't support \"if exists\" and the table doesn't exist\n\t\t}\t\tjdbcCoordinator.getResultSetReturn().execute( statement, \"create table SANDBOX_JDBC_TST ( ID integer, NAME varchar(100) )\" );\n        assertTrue( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n\t\tassertTrue( logicalConnection.isPhysicallyConnected() );\n        jdbcCoordinator.getLogicalConnection().getResourceRegistry().release( statement );\n        assertFalse( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n\t\tassertTrue( logicalConnection.isPhysicallyConnected() ); // after_transaction specified\n\n\t\t// ok, now we can get down to it...\n\t\tTransaction txn = session.getTransaction();  // same as Session#getTransaction\n\t\ttxn.begin();\n\n\t\tfinal BatchBuilder batchBuilder = new BatchBuilderImpl( 2 );\n\t\tfinal BatchKey batchKey = new BasicBatchKey( \"this\", Expectations.BASIC );\n\t\tfinal Batch insertBatch = batchBuilder.buildBatch( batchKey, jdbcCoordinator );\n\t\tassertTrue( \"unexpected Batch impl\", BatchingBatch.class.isInstance( insertBatch ) );\n\n\t\tfinal JournalingBatchObserver batchObserver = new JournalingBatchObserver();\n\t\tinsertBatch.addObserver( batchObserver );\n\n\t\tfinal String insertSql = \"insert into SANDBOX_JDBC_TST( ID, NAME ) values ( ?, ? )\";\n\n\t\tPreparedStatement insert = insertBatch.getBatchStatement( insertSql, false );\n\t\tinsert.setLong( 1, 1 );\n\t\tinsert.setString( 2, \"name\" );\n\t\tassertEquals( 0, batchObserver.getExplicitExecutionCount() );\n\t\tassertEquals( 0, batchObserver.getImplicitExecutionCount() );\n\t\tinsertBatch.addToBatch();\n\t\tassertEquals( 0, batchObserver.getExplicitExecutionCount() );\n\t\tassertEquals( 0, batchObserver.getImplicitExecutionCount() );\n        assertTrue( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n\n\t\tPreparedStatement insert2 = insertBatch.getBatchStatement( insertSql, false );\n\t\tassertSame( insert, insert2 );\n\t\tinsert = insert2;\n\t\tinsert.setLong( 1, 2 );\n\t\tinsert.setString( 2, \"another name\" );\n\t\tassertEquals( 0, batchObserver.getExplicitExecutionCount() );\n\t\tassertEquals( 0, batchObserver.getImplicitExecutionCount() );\n\t\tinsertBatch.addToBatch();\n\t\tassertEquals( 0, batchObserver.getExplicitExecutionCount() );\n\t\tassertEquals( 1, batchObserver.getImplicitExecutionCount() );\n        assertTrue( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n\n\t\tinsertBatch.execute();\n\t\tassertEquals( 1, batchObserver.getExplicitExecutionCount() );\n\t\tassertEquals( 1, batchObserver.getImplicitExecutionCount() );\n        assertFalse( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n\n\t\tinsertBatch.release();\n\n\t\ttxn.commit();\n\t\tsession.close();\n\t}",
        "filePathBefore": "hibernate-core/src/test/java/org/hibernate/orm/test/jdbc/internal/BatchingTest.java",
        "isPureRefactoring": true,
        "commitId": "a9ac98b364ccf52bb9cb2be5324c9c983e8bd8b3",
        "packageNameBefore": "org.hibernate.orm.test.jdbc.internal",
        "classNameBefore": "org.hibernate.orm.test.jdbc.internal.BatchingTest",
        "methodNameBefore": "org.hibernate.orm.test.jdbc.internal.BatchingTest#testBatchingUsage",
        "invokedMethod": "methodSignature: org.hibernate.action.internal.BulkOperationCleanupAction.NaturalIdCleanup#release\n methodBody: private void release() {\nnaturalIdCacheAccessStrategy.unlockRegion(cacheLock);\n}\nmethodSignature: org.hibernate.orm.test.insertordering.InsertOrderingTest.StatsBatch#addToBatch\n methodBody: public void addToBatch() {\nCounter counter=(Counter)batchSizes.get(currentBatch);\ncounter.count++;\nsuper.addToBatch();\n}\nmethodSignature: org.hibernate.engine.jdbc.spi.JdbcCoordinator#getStatementPreparer\n methodBody: StatementPreparer getStatementPreparer();\nmethodSignature: org.hibernate.engine.jdbc.spi.JdbcServices#getDialect\n methodBody: Dialect getDialect();\nmethodSignature: org.hibernate.engine.jdbc.batch.internal.AbstractBatchImpl#getBatchStatement\n methodBody: public PreparedStatement getBatchStatement(String sql, boolean callable) {\nif(sql == null){throw new IllegalArgumentException(\"sql must be non-null.\");\n}PreparedStatement statement=statements.get(sql);\nif(statement == null){statement=buildBatchStatement(sql,callable);\nstatements.put(sql,statement);\n}{LOG.debug(\"Reusing batch statement\");\nsqlStatementLogger().logStatement(sql);\n}return statement;\n}\nmethodSignature: org.hibernate.engine.jdbc.batch.spi.Batch#execute\n methodBody: void execute();\nmethodSignature: org.hibernate.engine.jdbc.batch.internal.SharedBatchBuildingCode#buildBatch\n methodBody: static Batch buildBatch(final int defaultJdbcBatchSize, final BatchKey key, final JdbcCoordinator jdbcCoordinator) {\nfinal Integer sessionJdbcBatchSize=jdbcCoordinator.getJdbcSessionOwner().getJdbcBatchSize();\nfinal int jdbcBatchSizeToUse=sessionJdbcBatchSize == null ? defaultJdbcBatchSize : sessionJdbcBatchSize;\nreturn jdbcBatchSizeToUse > 1 ? new BatchingBatch(key,jdbcCoordinator,jdbcBatchSizeToUse) : new NonBatchingBatch(key,jdbcCoordinator);\n}\nmethodSignature: org.hibernate.engine.jdbc.internal.JdbcCoordinatorImpl#getLogicalConnection\n methodBody: public LogicalConnectionImplementor getLogicalConnection() {\nreturn logicalConnection;\n}\nmethodSignature: org.hibernate.engine.jdbc.internal.JdbcCoordinatorImpl#close\n methodBody: protected void close(ResultSet resultSet) {\nLOG.tracev(\"Closing result set [{0}]\",resultSet);\nif(resultSet instanceof InvalidatableWrapper){@SuppressWarnings(\"unchecked\") final InvalidatableWrapper<ResultSet> wrapper=(InvalidatableWrapper<ResultSet>)resultSet;\nclose(wrapper.getWrappedObject());\nwrapper.invalidate();\nreturn;\n}tryresultSet.close();\ncatch(Exception e)LOG.debugf(\"Unable to release JDBC result set [%s]\",e.getMessage());\n}\nmethodSignature: org.hibernate.query.sqm.mutation.internal.inline.InlineUpdateHandler#execute\n methodBody: public int execute(DomainQueryExecutionContext executionContext) {\nfinal List<Object> ids=MatchingIdSelectionHelper.selectMatchingIds(sqmUpdate,domainParameterXref,executionContext);\nif(ids == null || ids.isEmpty()){return 0;\n}domainParameterXref.clearExpansions();\nfinal MappingMetamodel domainModel=sessionFactory.getRuntimeMetamodels().getMappingMetamodel();\nfinal String mutatingEntityName=sqmUpdate.getTarget().getModel().getHibernateEntityName();\nfinal EntityPersister entityDescriptor=domainModel.getEntityDescriptor(mutatingEntityName);\nfinal String rootEntityName=entityDescriptor.getEntityPersister().getRootEntityName();\nfinal EntityPersister rootEntityDescriptor=domainModel.getEntityDescriptor(rootEntityName);\nfinal String hierarchyRootTableName=((Joinable)rootEntityDescriptor).getTableName();\nfinal List<Expression> inListExpressions=new ArrayList<>(ids.size());\nfinal EntityIdentifierMapping identifierMapping=entityDescriptor.getIdentifierMapping();\nif(identifierMapping instanceof BasicValuedModelPart){final BasicValuedModelPart basicValuedModelPart=(BasicValuedModelPart)identifierMapping;\nfor(int i=0; i < ids.size(); i++){inListExpressions.add(new QueryLiteral<>(ids.get(i),basicValuedModelPart));\n}}{final int jdbcTypeCount=identifierMapping.getJdbcTypeCount();\nfor(int i=0; i < ids.size(); i++){final Object[] id=(Object[])ids.get(i);\nfinal List<Expression> tupleElements=new ArrayList<>(jdbcTypeCount);\ninListExpressions.add(new SqlTuple(tupleElements,identifierMapping));\nidentifierMapping.forEachJdbcType((index,jdbcMapping) -> {\n  tupleElements.add(new QueryLiteral<>(id[index],(BasicValuedMapping)jdbcMapping));\n}\n);\n}}final MultiTableSqmMutationConverter converterDelegate=new MultiTableSqmMutationConverter(entityDescriptor,sqmUpdate,sqmUpdate.getTarget(),domainParameterXref,executionContext.getQueryOptions(),executionContext.getSession().getLoadQueryInfluencers(),executionContext.getQueryParameterBindings(),sessionFactory);\nfinal TableGroup updatingTableGroup=converterDelegate.getMutatingTableGroup();\nfinal TableReference hierarchyRootTableReference=updatingTableGroup.resolveTableReference(updatingTableGroup.getNavigablePath(),hierarchyRootTableName);\nassert hierarchyRootTableReference != null;\nfinal Map<SqmParameter<?>,List<List<JdbcParameter>>> parameterResolutions;\nif(domainParameterXref.getSqmParameterCount() == 0){parameterResolutions=Collections.emptyMap();\n}{parameterResolutions=new IdentityHashMap<>();\n}final List<Assignment> assignments=new ArrayList<>();\nfinal Map<SqmParameter<?>,MappingModelExpressible<?>> paramTypeResolutions=new LinkedHashMap<>();\nconverterDelegate.visitSetClause(sqmUpdate.getSetClause(),assignments::add,(sqmParameter,mappingType,jdbcParameters) -> {\n  parameterResolutions.computeIfAbsent(sqmParameter,k -> new ArrayList<>(1)).add(jdbcParameters);\n  paramTypeResolutions.put(sqmParameter,mappingType);\n}\n);\nconverterDelegate.addVersionedAssignment(assignments::add,sqmUpdate);\nfinal Predicate providedPredicate;\nfinal SqmWhereClause whereClause=sqmUpdate.getWhereClause();\nif(whereClause == null || whereClause.getPredicate() == null){providedPredicate=null;\n}{providedPredicate=converterDelegate.visitWhereClause(whereClause,columnReference -> {\n}\n,(sqmParameter,mappingType,jdbcParameters) -> {\n  parameterResolutions.computeIfAbsent(sqmParameter,k -> new ArrayList<>(1)).add(jdbcParameters);\n  paramTypeResolutions.put(sqmParameter,mappingType);\n}\n);\nassert providedPredicate != null;\n}final PredicateCollector predicateCollector=new PredicateCollector(providedPredicate);\nentityDescriptor.applyBaseRestrictions(predicateCollector::applyPredicate,updatingTableGroup,true,executionContext.getSession().getLoadQueryInfluencers().getEnabledFilters(),null,converterDelegate);\nconverterDelegate.pruneTableGroupJoins();\nfinal Map<String,TableReference> tableReferenceByAlias=CollectionHelper.mapOfSize(updatingTableGroup.getTableReferenceJoins().size() + 1);\ncollectTableReference(updatingTableGroup.getPrimaryTableReference(),tableReferenceByAlias::put);\nfor(int i=0; i < updatingTableGroup.getTableReferenceJoins().size(); i++){collectTableReference(updatingTableGroup.getTableReferenceJoins().get(i),tableReferenceByAlias::put);\n}final JdbcParameterBindings jdbcParameterBindings=SqmUtil.createJdbcParameterBindings(executionContext.getQueryParameterBindings(),domainParameterXref,SqmUtil.generateJdbcParamsXref(domainParameterXref,() -> parameterResolutions),sessionFactory.getRuntimeMetamodels().getMappingMetamodel(),navigablePath -> updatingTableGroup,new SqmParameterMappingModelResolutionAccess(){\n  @Override @SuppressWarnings(\"unchecked\") public <T>MappingModelExpressible<T> getResolvedMappingModelType(  SqmParameter<T> parameter){\n    return (MappingModelExpressible<T>)paramTypeResolutions.get(parameter);\n  }\n}\n,executionContext.getSession());\nfinal Map<TableReference,List<Assignment>> assignmentsByTable=new HashMap<>();\nfor(int i=0; i < assignments.size(); i++){final Assignment assignment=assignments.get(i);\nfinal List<ColumnReference> assignmentColumnRefs=assignment.getAssignable().getColumnReferences();\nTableReference assignmentTableReference=null;\nfor(int c=0; c < assignmentColumnRefs.size(); c++){final ColumnReference columnReference=assignmentColumnRefs.get(c);\nfinal TableReference tableReference=resolveTableReference(columnReference,tableReferenceByAlias);\nif(assignmentTableReference != null && assignmentTableReference != tableReference){throw new SemanticException(\"Assignment referred to columns from multiple tables: \" + assignment.getAssignable());\n}assignmentTableReference=tableReference;\n}List<Assignment> assignmentsForTable=assignmentsByTable.get(assignmentTableReference);\nif(assignmentsForTable == null){assignmentsForTable=new ArrayList<>();\nassignmentsByTable.put(assignmentTableReference,assignmentsForTable);\n}assignmentsForTable.add(assignment);\n}final int rows=ids.size();\nfinal SqmJdbcExecutionContextAdapter executionContextAdapter=SqmJdbcExecutionContextAdapter.omittingLockingAndPaging(executionContext);\nentityDescriptor.visitConstraintOrderedTables((tableExpression,tableKeyColumnVisitationSupplier) -> updateTable(tableExpression,tableKeyColumnVisitationSupplier,entityDescriptor,updatingTableGroup,assignmentsByTable,inListExpressions,rows,jdbcParameterBindings,executionContextAdapter));\nreturn rows;\n}\nmethodSignature: org.hibernate.dialect.AbstractHANADialect.CloseSuppressingInputStream#close\n methodBody: public void close() {\n}\nmethodSignature: org.hibernate.query.sqm.mutation.internal.inline.InlineDeleteHandler#execute\n methodBody: public int execute(DomainQueryExecutionContext executionContext) {\nfinal List<Object> idsAndFks=MatchingIdSelectionHelper.selectMatchingIds(sqmDeleteStatement,domainParameterXref,executionContext);\nif(idsAndFks == null || idsAndFks.isEmpty()){return 0;\n}final SessionFactoryImplementor factory=executionContext.getSession().getFactory();\nfinal String mutatingEntityName=sqmDeleteStatement.getTarget().getModel().getHibernateEntityName();\nfinal EntityMappingType entityDescriptor=factory.getRuntimeMetamodels().getEntityMappingType(mutatingEntityName);\nfinal JdbcParameterBindings jdbcParameterBindings=new JdbcParameterBindingsImpl(domainParameterXref.getQueryParameterCount());\nfinal MutableInteger valueIndexCounter=new MutableInteger();\nSqmMutationStrategyHelper.visitCollectionTables(entityDescriptor,pluralAttribute -> {\n  if (pluralAttribute.getSeparateCollectionTable() != null) {\n    final ModelPart fkTargetPart=pluralAttribute.getKeyDescriptor().getTargetPart();\n    final int valueIndex;\n    if (fkTargetPart instanceof EntityIdentifierMapping) {\n      valueIndex=0;\n    }\n else {\n      if (valueIndexCounter.get() == 0) {\n        valueIndexCounter.set(entityDescriptor.getIdentifierMapping().getJdbcTypeCount());\n      }\n      valueIndex=valueIndexCounter.get();\n      valueIndexCounter.plus(fkTargetPart.getJdbcTypeCount());\n    }\n    executeDelete(pluralAttribute.getSeparateCollectionTable(),entityDescriptor,() -> fkTargetPart::forEachSelectable,idsAndFks,valueIndex,fkTargetPart,jdbcParameterBindings,executionContext);\n  }\n}\n);\nentityDescriptor.visitConstraintOrderedTables((tableExpression,tableKeyColumnsVisitationSupplier) -> {\n  executeDelete(tableExpression,entityDescriptor,tableKeyColumnsVisitationSupplier,idsAndFks,0,null,jdbcParameterBindings,executionContext);\n}\n);\nreturn idsAndFks.size();\n}\nmethodSignature: org.hibernate.engine.jdbc.internal.JdbcCoordinatorImpl#hasRegisteredResources\n methodBody: private boolean hasRegisteredResources() {\nreturn getLogicalConnection().getResourceRegistry().hasRegisteredResources();\n}\nmethodSignature: org.hibernate.engine.jdbc.batch.spi.Batch#release\n methodBody: void release();\nmethodSignature: org.hibernate.engine.jdbc.batch.internal.UnmodifiableBatchBuilderImpl#buildBatch\n methodBody: public Batch buildBatch(BatchKey key, JdbcCoordinator jdbcCoordinator) {\nreturn SharedBatchBuildingCode.buildBatch(jdbcBatchSize,key,jdbcCoordinator);\n}\nmethodSignature: org.hibernate.persister.entity.AbstractEntityPersister#isInstance\n methodBody: public boolean isInstance(Object object) {\nreturn getRepresentationStrategy().getInstantiator().isInstance(object,getFactory());\n}\nmethodSignature: org.hibernate.orm.test.jpa.transaction.batch.JtaWithFailingBatchTest.TestBatch#addToBatch\n methodBody: public void addToBatch() {\nthrow sqlExceptionHelper().convert(new SQLException(\"fake SQLException\"),\"could not perform addBatch\",currentStatementSql);\n}\nmethodSignature: org.hibernate.action.internal.BulkOperationCleanupAction#execute\n methodBody: public void execute() throws HibernateException {\n}\nmethodSignature: org.hibernate.orm.test.jpa.transaction.batch.JtaWithFailingBatchTest.TestBatch#getBatchStatement\n methodBody: public PreparedStatement getBatchStatement(String sql, boolean callable) {\ncurrentStatementSql=sql;\nPreparedStatement batchStatement=super.getBatchStatement(sql,callable);\ncreatedStatements.add(batchStatement);\nreturn batchStatement;\n}\nmethodSignature: org.hibernate.engine.jdbc.batch.spi.BatchBuilder#buildBatch\n methodBody: Batch buildBatch(BatchKey key, JdbcCoordinator jdbcCoordinator);\nmethodSignature: org.hibernate.procedure.internal.ProcedureCallImpl#execute\n methodBody: public boolean execute() {\ntryreturn outputs().getCurrent() instanceof ResultSetOutput;\ncatch(NoMoreOutputsException e)return false;\ncatch(HibernateException he)throw getSession().getExceptionConverter().convert(he);\ncatch(RuntimeException e)getSession().markForRollbackOnly();\nthrow e;\n}\nmethodSignature: org.hibernate.query.sqm.mutation.internal.cte.CteInsertHandler#execute\n methodBody: public int execute(DomainQueryExecutionContext executionContext) {\nfinal SqmInsertStatement<?> sqmInsertStatement=getSqmStatement();\nfinal SessionFactoryImplementor factory=executionContext.getSession().getFactory();\nfinal EntityPersister entityDescriptor=getEntityDescriptor().getEntityPersister();\nfinal String explicitDmlTargetAlias;\nif(sqmInsertStatement.getTarget().getExplicitAlias() == null){explicitDmlTargetAlias=\"dml_target\";\n}{explicitDmlTargetAlias=sqmInsertStatement.getTarget().getExplicitAlias();\n}final MultiTableSqmMutationConverter sqmConverter=new MultiTableSqmMutationConverter(entityDescriptor,sqmInsertStatement,sqmInsertStatement.getTarget(),explicitDmlTargetAlias,domainParameterXref,executionContext.getQueryOptions(),executionContext.getSession().getLoadQueryInfluencers(),executionContext.getQueryParameterBindings(),factory);\nfinal TableGroup insertingTableGroup=sqmConverter.getMutatingTableGroup();\nfinal Map<SqmParameter<?>,List<List<JdbcParameter>>> parameterResolutions;\nif(domainParameterXref.getSqmParameterCount() == 0){parameterResolutions=Collections.emptyMap();\n}{parameterResolutions=new IdentityHashMap<>();\n}final int size=sqmStatement.getInsertionTargetPaths().size();\nfinal List<Map.Entry<List<CteColumn>,Assignment>> targetPathColumns=new ArrayList<>(size);\nfinal List<CteColumn> targetPathCteColumns=new ArrayList<>(size);\nfinal Map<SqmParameter<?>,MappingModelExpressible<?>> paramTypeResolutions=new LinkedHashMap<>();\nfinal NamedTableReference entityTableReference=new NamedTableReference(cteTable.getTableExpression(),TemporaryTable.DEFAULT_ALIAS,true,sessionFactory);\nfinal InsertStatement insertStatement=new InsertStatement(entityTableReference);\nfinal BaseSqmToSqlAstConverter.AdditionalInsertValues additionalInsertValues=sqmConverter.visitInsertionTargetPaths((assignable,columnReferences) -> {\n  final SqmPathInterpretation<?> pathInterpretation=(SqmPathInterpretation<?>)assignable;\n  final int offset=CteTable.determineModelPartStartIndex(entityDescriptor,pathInterpretation.getExpressionType());\n  if (offset == -1) {\n    throw new IllegalStateException(\"Couldn't find matching cte column for: \" + ((Expression)assignable).getExpressionType());\n  }\n  final int end=offset + pathInterpretation.getExpressionType().getJdbcTypeCount();\n  final List<CteColumn> columns=cteTable.getCteColumns().subList(offset,end);\n  insertStatement.addTargetColumnReferences(columnReferences);\n  targetPathCteColumns.addAll(columns);\n  targetPathColumns.add(new AbstractMap.SimpleEntry<>(columns,new Assignment(assignable,(Expression)assignable)));\n}\n,sqmInsertStatement,entityDescriptor,insertingTableGroup,(sqmParameter,mappingType,jdbcParameters) -> {\n  parameterResolutions.computeIfAbsent(sqmParameter,k -> new ArrayList<>(1)).add(jdbcParameters);\n  paramTypeResolutions.put(sqmParameter,mappingType);\n}\n);\nfinal boolean assignsId=targetPathCteColumns.contains(cteTable.getCteColumns().get(0));\nfinal Stack<SqlAstProcessingState> processingStateStack=sqmConverter.getProcessingStateStack();\nfinal SqlAstProcessingState oldState=processingStateStack.pop();\nfinal Statement queryStatement;\nif(sqmInsertStatement instanceof SqmInsertSelectStatement){final QueryPart queryPart=sqmConverter.visitQueryPart(((SqmInsertSelectStatement<?>)sqmInsertStatement).getSelectQueryPart());\nqueryPart.visitQuerySpecs(querySpec -> {\n  if (additionalInsertValues.applySelections(querySpec,sessionFactory)) {\n    final CteColumn rowNumberColumn=cteTable.getCteColumns().get(cteTable.getCteColumns().size() - 1);\n    final ColumnReference columnReference=new ColumnReference((String)null,rowNumberColumn.getColumnExpression(),false,null,null,rowNumberColumn.getJdbcMapping());\n    insertStatement.getTargetColumnReferences().set(insertStatement.getTargetColumnReferences().size() - 1,columnReference);\n    targetPathCteColumns.set(targetPathCteColumns.size() - 1,rowNumberColumn);\n  }\n  if (!assignsId && entityDescriptor.getIdentifierGenerator() instanceof PostInsertIdentifierGenerator) {\n    querySpec.getSelectClause().addSqlSelection(new SqlSelectionImpl(1,0,SqmInsertStrategyHelper.createRowNumberingExpression(querySpec,sessionFactory)));\n  }\n}\n);\nqueryStatement=new SelectStatement(queryPart);\n}{final List<SqmValues> sqmValuesList=((SqmInsertValuesStatement<?>)sqmInsertStatement).getValuesList();\nfinal List<Values> valuesList=new ArrayList<>(sqmValuesList.size());\nfor(SqmValues sqmValues: sqmValuesList){final Values values=sqmConverter.visitValues(sqmValues);\nadditionalInsertValues.applyValues(values);\nvaluesList.add(values);\n}final QuerySpec querySpec=new QuerySpec(true);\nfinal NavigablePath navigablePath=new NavigablePath(entityDescriptor.getRootPathName());\nfinal List<String> columnNames=new ArrayList<>(targetPathColumns.size());\nfinal String valuesAlias=insertingTableGroup.getPrimaryTableReference().getIdentificationVariable();\nfor(Map.Entry<List<CteColumn>,Assignment> entry: targetPathColumns){for(ColumnReference columnReference: entry.getValue().getAssignable().getColumnReferences()){columnNames.add(columnReference.getColumnExpression());\nquerySpec.getSelectClause().addSqlSelection(new SqlSelectionImpl(1,0,columnReference.getQualifier().equals(valuesAlias) ? columnReference : new ColumnReference(valuesAlias,columnReference.getColumnExpression(),false,null,null,columnReference.getJdbcMapping())));\n}}final ValuesTableGroup valuesTableGroup=new ValuesTableGroup(navigablePath,entityDescriptor.getEntityPersister(),valuesList,insertingTableGroup.getPrimaryTableReference().getIdentificationVariable(),columnNames,true,factory);\nquerySpec.getFromClause().addRoot(valuesTableGroup);\nqueryStatement=new SelectStatement(querySpec);\n}processingStateStack.push(oldState);\nsqmConverter.pruneTableGroupJoins();\nif(!assignsId && entityDescriptor.getIdentifierGenerator() instanceof PostInsertIdentifierGenerator){final CteColumn rowNumberColumn=cteTable.getCteColumns().get(cteTable.getCteColumns().size() - 1);\nfinal ColumnReference columnReference=new ColumnReference((String)null,rowNumberColumn.getColumnExpression(),false,null,null,rowNumberColumn.getJdbcMapping());\ninsertStatement.getTargetColumnReferences().add(columnReference);\ntargetPathCteColumns.add(rowNumberColumn);\n}final CteTable entityCteTable=createCteTable(getCteTable(),targetPathCteColumns,factory);\nfinal QuerySpec querySpec=new QuerySpec(true,1);\nfinal List<DomainResult<?>> domainResults=new ArrayList<>(1);\nfinal SelectStatement statement=new SelectStatement(querySpec,domainResults);\nfinal CteStatement entityCte;\nif(additionalInsertValues.requiresRowNumberIntermediate()){final CteTable fullEntityCteTable=getCteTable();\nfinal String baseTableName=\"base_\" + entityCteTable.getTableExpression();\nfinal CteStatement baseEntityCte=new CteStatement(entityCteTable.withName(baseTableName),queryStatement,CteMaterialization.MATERIALIZED);\nstatement.addCteStatement(baseEntityCte);\nfinal CteColumn rowNumberColumn=fullEntityCteTable.getCteColumns().get(fullEntityCteTable.getCteColumns().size() - 1);\nfinal ColumnReference rowNumberColumnReference=new ColumnReference(\"e\",rowNumberColumn.getColumnExpression(),false,null,null,rowNumberColumn.getJdbcMapping());\nfinal CteColumn idColumn=fullEntityCteTable.getCteColumns().get(0);\nfinal BasicValuedMapping idType=(BasicValuedMapping)idColumn.getJdbcMapping();\nfinal Optimizer optimizer=((OptimizableGenerator)entityDescriptor.getIdentifierGenerator()).getOptimizer();\nfinal BasicValuedMapping integerType=(BasicValuedMapping)rowNumberColumn.getJdbcMapping();\nfinal Expression rowNumberMinusOneModuloIncrement=new BinaryArithmeticExpression(new BinaryArithmeticExpression(rowNumberColumnReference,BinaryArithmeticOperator.SUBTRACT,new QueryLiteral<>(1,(BasicValuedMapping)rowNumberColumn.getJdbcMapping()),integerType),BinaryArithmeticOperator.MODULO,new QueryLiteral<>(optimizer.getIncrementSize(),integerType),integerType);\n{final QuerySpec rowsWithSequenceQuery=new QuerySpec(true);\nrowsWithSequenceQuery.getFromClause().addRoot(new CteTableGroup(new NamedTableReference(baseTableName,\"e\",false,factory)));\nrowsWithSequenceQuery.getSelectClause().addSqlSelection(new SqlSelectionImpl(1,0,rowNumberColumnReference));\nfinal String fragment=((BulkInsertionCapableIdentifierGenerator)entityDescriptor.getIdentifierGenerator()).determineBulkInsertionIdentifierGenerationSelectFragment(sessionFactory.getSqlStringGenerationContext());\nrowsWithSequenceQuery.getSelectClause().addSqlSelection(new SqlSelectionImpl(2,1,new SelfRenderingSqlFragmentExpression(fragment)));\nrowsWithSequenceQuery.applyPredicate(new ComparisonPredicate(rowNumberMinusOneModuloIncrement,ComparisonOperator.EQUAL,new QueryLiteral<>(0,integerType)));\nfinal CteTable rowsWithSequenceCteTable=new CteTable(ROW_NUMBERS_WITH_SEQUENCE_VALUE,List.of(rowNumberColumn,idColumn));\nfinal SelectStatement rowsWithSequenceStatement=new SelectStatement(rowsWithSequenceQuery);\nfinal CteStatement rowsWithSequenceCte=new CteStatement(rowsWithSequenceCteTable,rowsWithSequenceStatement,CteMaterialization.MATERIALIZED);\nstatement.addCteStatement(rowsWithSequenceCte);\n}{final QuerySpec entityQuery=new QuerySpec(true);\nfinal NavigablePath navigablePath=new NavigablePath(baseTableName);\nfinal TableGroup baseTableGroup=new TableGroupImpl(navigablePath,null,new NamedTableReference(baseTableName,\"e\",false,factory),null);\nfinal TableGroup rowsWithSequenceTableGroup=new CteTableGroup(new NamedTableReference(ROW_NUMBERS_WITH_SEQUENCE_VALUE,\"t\",false,factory));\nbaseTableGroup.addTableGroupJoin(new TableGroupJoin(rowsWithSequenceTableGroup.getNavigablePath(),SqlAstJoinType.LEFT,rowsWithSequenceTableGroup,new ComparisonPredicate(new BinaryArithmeticExpression(rowNumberColumnReference,BinaryArithmeticOperator.SUBTRACT,rowNumberMinusOneModuloIncrement,integerType),ComparisonOperator.EQUAL,new ColumnReference(\"t\",rowNumberColumn.getColumnExpression(),false,null,null,rowNumberColumn.getJdbcMapping()))));\nentityQuery.getFromClause().addRoot(baseTableGroup);\nentityQuery.getSelectClause().addSqlSelection(new SqlSelectionImpl(1,0,new BinaryArithmeticExpression(new ColumnReference(\"t\",idColumn.getColumnExpression(),false,null,null,idColumn.getJdbcMapping()),BinaryArithmeticOperator.ADD,new BinaryArithmeticExpression(rowNumberColumnReference,BinaryArithmeticOperator.SUBTRACT,new ColumnReference(\"t\",rowNumberColumn.getColumnExpression(),false,null,null,rowNumberColumn.getJdbcMapping()),integerType),idType)));\nfinal CteTable finalEntityCteTable;\nif(targetPathCteColumns.contains(getCteTable().getCteColumns().get(0))){finalEntityCteTable=entityCteTable;\n}{targetPathCteColumns.add(0,getCteTable().getCteColumns().get(0));\nfinalEntityCteTable=createCteTable(getCteTable(),targetPathCteColumns,factory);\n}final List<CteColumn> cteColumns=finalEntityCteTable.getCteColumns();\nfor(int i=1; i < cteColumns.size(); i++){final CteColumn cteColumn=cteColumns.get(i);\nentityQuery.getSelectClause().addSqlSelection(new SqlSelectionImpl(i + 1,i,new ColumnReference(\"e\",cteColumn.getColumnExpression(),false,null,null,cteColumn.getJdbcMapping())));\n}final SelectStatement entityStatement=new SelectStatement(entityQuery);\nentityCte=new CteStatement(finalEntityCteTable,entityStatement,CteMaterialization.MATERIALIZED);\nstatement.addCteStatement(entityCte);\n}}if(!assignsId && entityDescriptor.getIdentifierGenerator() instanceof PostInsertIdentifierGenerator){final String baseTableName=\"base_\" + entityCteTable.getTableExpression();\nfinal CteStatement baseEntityCte=new CteStatement(entityCteTable.withName(baseTableName),queryStatement,CteMaterialization.MATERIALIZED);\nstatement.addCteStatement(baseEntityCte);\ntargetPathCteColumns.add(0,cteTable.getCteColumns().get(0));\nfinal CteTable finalEntityCteTable=createCteTable(getCteTable(),targetPathCteColumns,factory);\nfinal QuerySpec finalQuerySpec=new QuerySpec(true);\nfinal SelectStatement finalQueryStatement=new SelectStatement(finalQuerySpec);\nentityCte=new CteStatement(finalEntityCteTable,finalQueryStatement,CteMaterialization.MATERIALIZED);\n}{entityCte=new CteStatement(entityCteTable,queryStatement,CteMaterialization.MATERIALIZED);\nstatement.addCteStatement(entityCte);\n}final String baseInsertCte=addDmlCtes(statement,entityCte,targetPathColumns,assignsId,sqmConverter,parameterResolutions,factory);\nfinal Expression count=createCountStar(factory,sqmConverter);\ndomainResults.add(new BasicResult<>(0,null,((SqlExpressible)count).getJdbcMapping()));\nquerySpec.getSelectClause().addSqlSelection(new SqlSelectionImpl(1,0,count));\nquerySpec.getFromClause().addRoot(new CteTableGroup(new NamedTableReference(baseInsertCte,CTE_TABLE_IDENTIFIER,false,factory)));\nfinal JdbcServices jdbcServices=factory.getJdbcServices();\nfinal SqlAstTranslator<JdbcSelect> translator=jdbcServices.getJdbcEnvironment().getSqlAstTranslatorFactory().buildSelectTranslator(factory,statement);\nfinal JdbcParameterBindings jdbcParameterBindings=SqmUtil.createJdbcParameterBindings(executionContext.getQueryParameterBindings(),domainParameterXref,SqmUtil.generateJdbcParamsXref(domainParameterXref,sqmConverter),factory.getRuntimeMetamodels().getMappingMetamodel(),navigablePath -> sqmConverter.getMutatingTableGroup(),new SqmParameterMappingModelResolutionAccess(){\n  @Override @SuppressWarnings(\"unchecked\") public <T>MappingModelExpressible<T> getResolvedMappingModelType(  SqmParameter<T> parameter){\n    return (MappingModelExpressible<T>)paramTypeResolutions.get(parameter);\n  }\n}\n,executionContext.getSession());\nfinal JdbcSelect select=translator.translate(jdbcParameterBindings,executionContext.getQueryOptions());\nexecutionContext.getSession().autoFlushIfRequired(select.getAffectedTableNames());\nList<Object> list=jdbcServices.getJdbcSelectExecutor().list(select,jdbcParameterBindings,SqmJdbcExecutionContextAdapter.omittingLockingAndPaging(executionContext),row -> row[0],ListResultsConsumer.UniqueSemantic.NONE);\nreturn ((Number)list.get(0)).intValue();\n}\nmethodSignature: org.hibernate.query.sqm.mutation.internal.temptable.InsertExecutionDelegate#execute\n methodBody: public int execute(ExecutionContext executionContext) {\nExecuteWithTemporaryTableHelper.performBeforeTemporaryTableUseActions(entityTable,executionContext);\ntryif(sessionUidParameter != null){jdbcParameterBindings.addBinding(sessionUidParameter,new JdbcParameterBindingImpl(entityTable.getSessionUidColumn().getJdbcMapping(),UUID.fromString(sessionUidAccess.apply(executionContext.getSession()))));\n}final int rows=ExecuteWithTemporaryTableHelper.saveIntoTemporaryTable(insertStatement,jdbcParameterBindings,executionContext);\nif(rows != 0){final AbstractEntityPersister persister=(AbstractEntityPersister)entityDescriptor.getEntityPersister();\nfinal int tableSpan=persister.getTableSpan();\ninsertRootTable(persister.getTableName(0),rows,persister.getKeyColumns(0),executionContext);\nif(persister.hasDuplicateTables()){final String[] insertedTables=new String[tableSpan];\ninsertedTables[0]=persister.getTableName(0);\nfor(int i=1; i < tableSpan; i++){if(persister.isInverseTable(i)){continue;\n}final String tableName=persister.getTableName(i);\ninsertedTables[i]=tableName;\nif(ArrayHelper.indexOf(insertedTables,i,tableName) != -1){continue;\n}insertTable(tableName,persister.getKeyColumns(i),persister.isNullableTable(i),executionContext);\n}}{for(int i=1; i < tableSpan; i++){insertTable(persister.getTableName(i),persister.getKeyColumns(i),persister.isNullableTable(i),executionContext);\n}}}return rows;\nfinallyExecuteWithTemporaryTableHelper.performAfterTemporaryTableUseActions(entityTable,sessionUidAccess,afterUseAction,executionContext);\n}\nmethodSignature: org.hibernate.engine.jdbc.internal.JdbcCoordinatorImpl#getResultSetReturn\n methodBody: public ResultSetReturn getResultSetReturn() {\nif(resultSetExtractor == null){resultSetExtractor=new ResultSetReturnImpl(this,jdbcServices);\n}return resultSetExtractor;\n}\nmethodSignature: org.hibernate.engine.jdbc.batch.spi.Batch#addObserver\n methodBody: void addObserver(BatchObserver observer);\nmethodSignature: org.hibernate.query.sqm.mutation.internal.temptable.UpdateExecutionDelegate#execute\n methodBody: public int execute(ExecutionContext executionContext) {\nExecuteWithTemporaryTableHelper.performBeforeTemporaryTableUseActions(idTable,executionContext);\ntryfinal int rows=ExecuteWithTemporaryTableHelper.saveMatchingIdsIntoIdTable(sqmConverter,suppliedPredicate,idTable,sessionUidAccess,jdbcParameterBindings,executionContext);\nfinal QuerySpec idTableSubQuery=ExecuteWithTemporaryTableHelper.createIdTableSelectQuerySpec(idTable,sessionUidAccess,entityDescriptor,executionContext);\nentityDescriptor.visitConstraintOrderedTables((tableExpression,tableKeyColumnVisitationSupplier) -> updateTable(tableExpression,tableKeyColumnVisitationSupplier,rows,idTableSubQuery,executionContext));\nreturn rows;\nfinallyExecuteWithTemporaryTableHelper.performAfterTemporaryTableUseActions(idTable,sessionUidAccess,afterUseAction,executionContext);\n}\nmethodSignature: org.hibernate.metamodel.mapping.internal.MappingModelCreationProcess#execute\n methodBody: private void execute() {\nfor(EntityPersister entityPersister: entityPersisterMap.values()){if(entityPersister instanceof InFlightEntityMappingType){((InFlightEntityMappingType)entityPersister).linkWithSuperType(this);\n}}for(EntityPersister entityPersister: entityPersisterMap.values()){currentlyProcessingRole=entityPersister.getEntityName();\nif(entityPersister instanceof InFlightEntityMappingType){((InFlightEntityMappingType)entityPersister).prepareMappingModel(this);\n}}executePostInitCallbacks();\n}\nmethodSignature: org.hibernate.orm.test.insertordering.InsertOrderingTest.StatsBatchBuilder#buildBatch\n methodBody: public Batch buildBatch(BatchKey key, JdbcCoordinator jdbcCoordinator) {\nreturn new StatsBatch(key,jdbcCoordinator,getJdbcBatchSize());\n}\nmethodSignature: org.hibernate.query.sqm.mutation.internal.cte.AbstractCteMutationHandler#execute\n methodBody: public int execute(DomainQueryExecutionContext executionContext) {\nfinal SqmDeleteOrUpdateStatement sqmMutationStatement=getSqmDeleteOrUpdateStatement();\nfinal SessionFactoryImplementor factory=executionContext.getSession().getFactory();\nfinal EntityMappingType entityDescriptor=getEntityDescriptor();\nfinal String explicitDmlTargetAlias;\nif(sqmMutationStatement.getTarget().getExplicitAlias() == null){explicitDmlTargetAlias=\"dml_target\";\n}{explicitDmlTargetAlias=sqmMutationStatement.getTarget().getExplicitAlias();\n}final MultiTableSqmMutationConverter sqmConverter=new MultiTableSqmMutationConverter(entityDescriptor,sqmMutationStatement,sqmMutationStatement.getTarget(),explicitDmlTargetAlias,domainParameterXref,executionContext.getQueryOptions(),executionContext.getSession().getLoadQueryInfluencers(),executionContext.getQueryParameterBindings(),factory);\nfinal Map<SqmParameter<?>,List<JdbcParameter>> parameterResolutions;\nif(domainParameterXref.getSqmParameterCount() == 0){parameterResolutions=Collections.emptyMap();\n}{parameterResolutions=new IdentityHashMap<>();\n}final Map<SqmParameter,MappingModelExpressible> paramTypeResolutions=new LinkedHashMap<>();\nfinal Predicate restriction=sqmConverter.visitWhereClause(sqmMutationStatement.getWhereClause(),columnReference -> {\n}\n,(sqmParam,mappingType,jdbcParameters) -> paramTypeResolutions.put(sqmParam,mappingType));\nsqmConverter.pruneTableGroupJoins();\nfinal CteStatement idSelectCte=new CteStatement(getCteTable(),MatchingIdSelectionHelper.generateMatchingIdSelectStatement(entityDescriptor,sqmMutationStatement,true,restriction,sqmConverter,executionContext,factory),CteMaterialization.MATERIALIZED);\nfinal QuerySpec querySpec=new QuerySpec(true,1);\nfinal List<DomainResult<?>> domainResults=new ArrayList<>(1);\nfinal SelectStatement statement=new SelectStatement(querySpec,domainResults);\nfinal JdbcServices jdbcServices=factory.getJdbcServices();\nfinal SqlAstTranslator<JdbcSelect> translator=jdbcServices.getJdbcEnvironment().getSqlAstTranslatorFactory().buildSelectTranslator(factory,statement);\nfinal Expression count=createCountStar(factory,sqmConverter);\ndomainResults.add(new BasicResult<>(0,null,((SqlExpressible)count).getJdbcMapping()));\nquerySpec.getSelectClause().addSqlSelection(new SqlSelectionImpl(1,0,count));\nquerySpec.getFromClause().addRoot(new CteTableGroup(new NamedTableReference(idSelectCte.getCteTable().getTableExpression(),CTE_TABLE_IDENTIFIER,false,factory)));\nstatement.addCteStatement(idSelectCte);\naddDmlCtes(statement,idSelectCte,sqmConverter,parameterResolutions,factory);\nfinal JdbcParameterBindings jdbcParameterBindings=SqmUtil.createJdbcParameterBindings(executionContext.getQueryParameterBindings(),domainParameterXref,SqmUtil.generateJdbcParamsXref(domainParameterXref,sqmConverter),factory.getRuntimeMetamodels().getMappingMetamodel(),navigablePath -> sqmConverter.getMutatingTableGroup(),paramTypeResolutions::get,executionContext.getSession());\nfinal LockOptions lockOptions=executionContext.getQueryOptions().getLockOptions();\nfinal LockMode lockMode=lockOptions.getAliasSpecificLockMode(explicitDmlTargetAlias);\nlockOptions.setAliasSpecificLockMode(explicitDmlTargetAlias,LockMode.WRITE);\nfinal JdbcSelect select=translator.translate(jdbcParameterBindings,executionContext.getQueryOptions());\nlockOptions.setAliasSpecificLockMode(explicitDmlTargetAlias,lockMode);\nexecutionContext.getSession().autoFlushIfRequired(select.getAffectedTableNames());\nList<Object> list=jdbcServices.getJdbcSelectExecutor().list(select,jdbcParameterBindings,SqmJdbcExecutionContextAdapter.omittingLockingAndPaging(executionContext),row -> row[0],ListResultsConsumer.UniqueSemantic.NONE);\nreturn ((Number)list.get(0)).intValue();\n}\nmethodSignature: org.hibernate.mapping.Component.ValueGenerationPlan#execute\n methodBody: public void execute(SharedSessionContractImplementor session, Object incomingObject, Object injectionContext) {\nfinal Object generatedValue=subGenerator.generate(session,incomingObject);\ninjector.set(injectionContext,generatedValue);\n}\nmethodSignature: org.hibernate.query.sqm.mutation.internal.temptable.TableBasedInsertHandler.ExecutionDelegate#execute\n methodBody: int execute(ExecutionContext executionContext);\nmethodSignature: org.hibernate.dialect.AbstractHANADialect.MaterializedNClob#setString\n methodBody: public int setString(long pos, String str) throws SQLException {\nthis.data=this.data.substring(0,(int)(pos - 1)) + str + this.data.substring((int)(pos - 1 + str.length()));\nreturn str.length();\n}\nmethodSignature: org.hibernate.engine.jdbc.batch.internal.NonBatchingBatch#addToBatch\n methodBody: public void addToBatch() {\nnotifyObserversImplicitExecution();\nfor(Map.Entry<String,PreparedStatement> entry: getStatements().entrySet()){final String statementSQL=entry.getKey();\ntryfinal PreparedStatement statement=entry.getValue();\nfinal int rowCount=jdbcCoordinator.getResultSetReturn().executeUpdate(statement);\ngetKey().getExpectation().verifyOutcome(rowCount,statement,0,statementSQL);\njdbcCoordinator.getLogicalConnection().getResourceRegistry().release(statement);\njdbcCoordinator.afterStatementExecution();\ncatch(SQLException e)abortBatch(e);\nthrow sqlExceptionHelper().convert(e,\"could not execute non-batched batch statement\",statementSQL);\ncatch(RuntimeException e)abortBatch(e);\nthrow e;\n}getStatements().clear();\n}\nmethodSignature: org.hibernate.engine.jdbc.internal.JdbcCoordinatorImpl#getStatementPreparer\n methodBody: public StatementPreparer getStatementPreparer() {\nif(statementPreparer == null){statementPreparer=new StatementPreparerImpl(this,jdbcServices);\n}return statementPreparer;\n}\nmethodSignature: org.hibernate.sql.Insert#getDialect\n methodBody: protected Dialect getDialect() {\nreturn dialect;\n}\nmethodSignature: org.hibernate.engine.jdbc.batch.internal.AbstractBatchImpl#release\n methodBody: public void release() {\nif(getStatements() != null && !getStatements().isEmpty()){LOG.batchContainedStatementsOnRelease();\n}releaseStatements();\nobservers.clear();\n}\nmethodSignature: org.hibernate.sql.exec.internal.StandardJdbcMutationExecutor#execute\n methodBody: public int execute(\n\t\t\tJdbcMutation jdbcMutation,\n\t\t\tJdbcParameterBindings jdbcParameterBindings,\n\t\t\tFunction<String, PreparedStatement> statementCreator,\n\t\t\tBiConsumer<Integer, PreparedStatement> expectationCheck,\n\t\t\tExecutionContext executionContext) {\nfinal SharedSessionContractImplementor session=executionContext.getSession();\nsession.autoFlushIfRequired(jdbcMutation.getAffectedTableNames());\nfinal LogicalConnectionImplementor logicalConnection=session.getJdbcCoordinator().getLogicalConnection();\nfinal JdbcServices jdbcServices=session.getJdbcServices();\nfinal QueryOptions queryOptions=executionContext.getQueryOptions();\nfinal String finalSql;\nif(queryOptions == null){finalSql=jdbcMutation.getSql();\n}{finalSql=jdbcServices.getDialect().addSqlHintOrComment(jdbcMutation.getSql(),queryOptions,executionContext.getSession().getFactory().getSessionFactoryOptions().isCommentsEnabled());\n}tryfinal PreparedStatement preparedStatement=statementCreator.apply(finalSql);\ntryif(executionContext.getQueryOptions().getTimeout() != null){preparedStatement.setQueryTimeout(executionContext.getQueryOptions().getTimeout());\n}int paramBindingPosition=1;\nfor(JdbcParameterBinder parameterBinder: jdbcMutation.getParameterBinders()){parameterBinder.bindParameterValue(preparedStatement,paramBindingPosition++,jdbcParameterBindings,executionContext);\n}session.getEventListenerManager().jdbcExecuteStatementStart();\ntryint rows=preparedStatement.executeUpdate();\nexpectationCheck.accept(rows,preparedStatement);\nreturn rows;\nfinallysession.getEventListenerManager().jdbcExecuteStatementEnd();\nfinallylogicalConnection.getResourceRegistry().release(preparedStatement);\ncatch(SQLException e)throw jdbcServices.getSqlExceptionHelper().convert(e,\"JDBC exception executing SQL [\" + finalSql + \"]\");\nfinallyexecutionContext.afterStatement(logicalConnection);\n}\nmethodSignature: org.hibernate.sql.exec.spi.JdbcMutationExecutor#execute\n methodBody: int execute(\n\t\t\tJdbcMutation jdbcMutation,\n\t\t\tJdbcParameterBindings jdbcParameterBindings,\n\t\t\tFunction<String, PreparedStatement> statementCreator,\n\t\t\tBiConsumer<Integer, PreparedStatement> expectationCheck,\n\t\t\tExecutionContext executionContext);\nmethodSignature: org.hibernate.engine.jdbc.batch.internal.AbstractBatchImpl#addObserver\n methodBody: public void addObserver(BatchObserver observer) {\nobservers.add(observer);\n}\nmethodSignature: org.hibernate.engine.jdbc.batch.internal.BatchingBatch#getBatchStatement\n methodBody: public PreparedStatement getBatchStatement(String sql, boolean callable) {\ncurrentStatementSql=sql;\nint previousBatchSize=getStatements().size();\ncurrentStatement=super.getBatchStatement(sql,callable);\nint currentBatchSize=getStatements().size();\nif(currentBatchSize > previousBatchSize){this.batchSize=this.configuredBatchSize * currentBatchSize;\n}return currentStatement;\n}\nmethodSignature: org.hibernate.engine.jdbc.batch.spi.Batch#getBatchStatement\n methodBody: PreparedStatement getBatchStatement(String sql, boolean callable);\nmethodSignature: org.hibernate.engine.jdbc.spi.JdbcCoordinator#close\n methodBody: Connection close();\nmethodSignature: org.hibernate.engine.jdbc.batch.spi.Batch#addToBatch\n methodBody: void addToBatch();\nmethodSignature: org.hibernate.engine.jdbc.batch.internal.BatchingBatch#addToBatch\n methodBody: public void addToBatch() {\ntrycurrentStatement.addBatch();\ncatch(SQLException e)abortBatch(e);\nLOG.debug(\"SQLException escaped proxy\",e);\nthrow sqlExceptionHelper().convert(e,\"could not perform addBatch\",currentStatementSql);\ncatch(RuntimeException e)abortBatch(e);\nthrow e;\nstatementPosition++;\nif(statementPosition >= getKey().getBatchedStatementCount()){batchPosition++;\nif(batchPosition == batchSize){notifyObserversImplicitExecution();\nperformExecution();\nbatchPosition=0;\nbatchExecuted=true;\n}statementPosition=0;\n}}\nmethodSignature: org.hibernate.action.internal.BulkOperationCleanupAction.CollectionCleanup#release\n methodBody: private void release() {\ncacheAccess.unlockRegion(cacheLock);\n}\nmethodSignature: org.hibernate.engine.jdbc.batch.internal.AbstractBatchImpl#execute\n methodBody: public final void execute() {\nnotifyObserversExplicitExecution();\nif(getStatements().isEmpty()){return;\n}trydoExecuteBatch();\nfinallyreleaseStatements();\n}\nmethodSignature: org.hibernate.action.internal.BulkOperationCleanupAction.EntityCleanup#release\n methodBody: private void release() {\ncacheAccess.unlockRegion(cacheLock);\n}\nmethodSignature: org.hibernate.sql.results.jdbc.internal.DeferredResultSetAccess#release\n methodBody: public void release() {\nif(resultSet != null){getPersistenceContext().getJdbcCoordinator().getLogicalConnection().getResourceRegistry().release(resultSet,preparedStatement);\nresultSet=null;\n}if(preparedStatement != null){getPersistenceContext().getJdbcCoordinator().getLogicalConnection().getResourceRegistry().release(preparedStatement);\npreparedStatement=null;\n}}\nmethodSignature: org.hibernate.query.sqm.mutation.internal.temptable.RestrictedDeleteExecutionDelegate#execute\n methodBody: public int execute(DomainQueryExecutionContext executionContext) {\nfinal EntityPersister entityDescriptor=sessionFactory.getRuntimeMetamodels().getMappingMetamodel().getEntityDescriptor(sqmDelete.getTarget().getEntityName());\nfinal String hierarchyRootTableName=((Joinable)entityDescriptor).getTableName();\nfinal TableGroup deletingTableGroup=converter.getMutatingTableGroup();\nfinal TableReference hierarchyRootTableReference=deletingTableGroup.resolveTableReference(deletingTableGroup.getNavigablePath(),hierarchyRootTableName);\nassert hierarchyRootTableReference != null;\nfinal Map<SqmParameter<?>,List<List<JdbcParameter>>> parameterResolutions;\nfinal Map<SqmParameter<?>,MappingModelExpressible<?>> paramTypeResolutions;\nif(domainParameterXref.getSqmParameterCount() == 0){parameterResolutions=Collections.emptyMap();\nparamTypeResolutions=Collections.emptyMap();\n}{parameterResolutions=new IdentityHashMap<>();\nparamTypeResolutions=new LinkedHashMap<>();\n}final MutableBoolean needsIdTableWrapper=new MutableBoolean(false);\nfinal Predicate specifiedRestriction=converter.visitWhereClause(sqmDelete.getWhereClause(),columnReference -> {\n  if (!hierarchyRootTableReference.getIdentificationVariable().equals(columnReference.getQualifier())) {\n    needsIdTableWrapper.setValue(true);\n  }\n}\n,(sqmParameter,mappingType,jdbcParameters) -> {\n  parameterResolutions.computeIfAbsent(sqmParameter,k -> new ArrayList<>(1)).add(jdbcParameters);\n  paramTypeResolutions.put(sqmParameter,mappingType);\n}\n);\nfinal PredicateCollector predicateCollector=new PredicateCollector(specifiedRestriction);\nentityDescriptor.applyBaseRestrictions((filterPredicate) -> {\n  needsIdTableWrapper.setValue(true);\n  predicateCollector.applyPredicate(filterPredicate);\n}\n,deletingTableGroup,true,executionContext.getSession().getLoadQueryInfluencers().getEnabledFilters(),null,converter);\nconverter.pruneTableGroupJoins();\nfinal boolean needsIdTable=needsIdTableWrapper.getValue() || entityDescriptor != entityDescriptor.getRootEntityDescriptor();\nfinal SqmJdbcExecutionContextAdapter executionContextAdapter=SqmJdbcExecutionContextAdapter.omittingLockingAndPaging(executionContext);\nif(needsIdTable){return executeWithIdTable(predicateCollector.getPredicate(),deletingTableGroup,parameterResolutions,paramTypeResolutions,executionContextAdapter);\n}{return executeWithoutIdTable(predicateCollector.getPredicate(),deletingTableGroup,parameterResolutions,paramTypeResolutions,converter.getSqlExpressionResolver(),executionContextAdapter);\n}}\nmethodSignature: org.hibernate.orm.test.jpa.transaction.batch.JtaWithFailingBatchTest.TestBatchBuilder#buildBatch\n methodBody: public Batch buildBatch(BatchKey key, JdbcCoordinator jdbcCoordinator) {\nreturn buildBatchTest(key,jdbcCoordinator,getJdbcBatchSize());\n}\nmethodSignature: org.hibernate.orm.test.jpa.transaction.batch.FailingAddToBatchTest.TestBatch#getBatchStatement\n methodBody: public PreparedStatement getBatchStatement(String sql, boolean callable) {\nPreparedStatement batchStatement=super.getBatchStatement(sql,callable);\ncreatedStatements.add(batchStatement);\nreturn batchStatement;\n}\nmethodSignature: org.hibernate.orm.test.jpa.transaction.batch.JtaWithStatementsBatchTest.TestBatchBuilder#buildBatch\n methodBody: public Batch buildBatch(BatchKey key, JdbcCoordinator jdbcCoordinator) {\nreturn buildBatchTest(key,jdbcCoordinator,getJdbcBatchSize());\n}\nmethodSignature: org.hibernate.orm.test.manytomany.batchload.TestingBatchBuilder#buildBatch\n methodBody: public Batch buildBatch(BatchKey key, JdbcCoordinator jdbcCoordinator) {\nreturn new TestingBatch(key,jdbcCoordinator);\n}\nmethodSignature: org.hibernate.persister.collection.AbstractCollectionPersister#getDialect\n methodBody: protected Dialect getDialect() {\nreturn dialect;\n}\nmethodSignature: org.hibernate.engine.jdbc.spi.JdbcCoordinator#getLogicalConnection\n methodBody: LogicalConnectionImplementor getLogicalConnection();\nmethodSignature: org.hibernate.query.sqm.mutation.internal.temptable.TableBasedInsertHandler#execute\n methodBody: public int execute(DomainQueryExecutionContext executionContext) {\nif(log.isTraceEnabled()){log.tracef(\"Starting multi-table insert execution - %s\",getSqmInsertStatement().getTarget().getModel().getName());\n}final SqmJdbcExecutionContextAdapter executionContextAdapter=SqmJdbcExecutionContextAdapter.omittingLockingAndPaging(executionContext);\nreturn resolveDelegate(executionContext).execute(executionContextAdapter);\n}\nmethodSignature: org.hibernate.orm.test.insertordering.InsertOrderingTest.StatsBatch#getBatchStatement\n methodBody: public PreparedStatement getBatchStatement(String sql, boolean callable) {\nif(batchSQL == null || !batchSQL.equals(sql)){currentBatch++;\nbatchSQL=sql;\nbatchSizes.add(currentBatch,new Counter());\n}return super.getBatchStatement(sql,callable);\n}\nmethodSignature: org.hibernate.engine.jdbc.spi.JdbcCoordinator#getResultSetReturn\n methodBody: ResultSetReturn getResultSetReturn();\nmethodSignature: org.hibernate.sql.ast.spi.AbstractSqlAstTranslator#getDialect\n methodBody: public Dialect getDialect() {\nreturn dialect;\n}\nmethodSignature: org.hibernate.engine.jdbc.batch.internal.BatchBuilderImpl#buildBatch\n methodBody: public Batch buildBatch(BatchKey key, JdbcCoordinator jdbcCoordinator) {\nreturn SharedBatchBuildingCode.buildBatch(jdbcBatchSize,key,jdbcCoordinator);\n}\nmethodSignature: org.hibernate.orm.test.jpa.transaction.batch.FailingAddToBatchTest.TestBatchBuilder#buildBatch\n methodBody: public Batch buildBatch(BatchKey key, JdbcCoordinator jdbcCoordinator) {\nreturn buildBatchTest(key,jdbcCoordinator,getJdbcBatchSize());\n}\nmethodSignature: org.hibernate.orm.test.jpa.transaction.batch.FailingAddToBatchTest.TestBatch#addToBatch\n methodBody: public void addToBatch() {\nRuntimeException failure=nextAddToBatchFailure.getAndSet(null);\nif(failure != null){throw failure;\n}super.addToBatch();\n}\nmethodSignature: org.hibernate.dialect.Dialect#getDropTableString\n methodBody: public String getDropTableString(String tableName) {\nfinal StringBuilder buf=new StringBuilder(\"drop table \");\nif(supportsIfExistsBeforeTableName()){buf.append(\"if exists \");\n}buf.append(tableName).append(getCascadeConstraintsString());\nif(supportsIfExistsAfterTableName()){buf.append(\" if exists\");\n}return buf.toString();\n}\nmethodSignature: org.hibernate.engine.jdbc.batch.internal.AbstractBatchImpl#getJdbcCoordinator\n methodBody: protected JdbcCoordinator getJdbcCoordinator(){\nreturn this.jdbcCoordinator;\n}\nmethodSignature: org.hibernate.engine.jdbc.internal.JdbcCoordinatorImpl#sessionFactory\n methodBody: protected SessionFactoryImplementor sessionFactory() {\nreturn this.owner.getJdbcSessionContext().getSessionFactory();\n}\nmethodSignature: org.hibernate.dialect.AbstractHANADialect.CloseSuppressingReader#close\n methodBody: public void close() {\n}\nmethodSignature: org.hibernate.sql.ast.spi.AbstractSqlAstTranslator#getJdbcServices\n methodBody: protected JdbcServices getJdbcServices() {\nreturn getSessionFactory().getJdbcServices();\n}",
        "classSignatureBefore": "public class BatchingTest extends BaseCoreFunctionalTestCase implements BatchKey ",
        "methodNameBeforeSet": [
            "org.hibernate.orm.test.jdbc.internal.BatchingTest#testBatchingUsage"
        ],
        "classNameBeforeSet": [
            "org.hibernate.orm.test.jdbc.internal.BatchingTest"
        ],
        "classSignatureBeforeSet": [
            "public class BatchingTest extends BaseCoreFunctionalTestCase implements BatchKey "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.\n */\npackage org.hibernate.orm.test.jdbc.internal;\n\nimport java.sql.PreparedStatement;\nimport java.sql.Statement;\n\nimport org.hibernate.Session;\nimport org.hibernate.Transaction;\nimport org.hibernate.engine.jdbc.batch.internal.BasicBatchKey;\nimport org.hibernate.engine.jdbc.batch.internal.BatchBuilderImpl;\nimport org.hibernate.engine.jdbc.batch.internal.BatchingBatch;\nimport org.hibernate.engine.jdbc.batch.internal.NonBatchingBatch;\nimport org.hibernate.engine.jdbc.batch.spi.Batch;\nimport org.hibernate.engine.jdbc.batch.spi.BatchBuilder;\nimport org.hibernate.engine.jdbc.batch.spi.BatchKey;\nimport org.hibernate.engine.jdbc.spi.JdbcCoordinator;\nimport org.hibernate.engine.spi.SessionImplementor;\nimport org.hibernate.jdbc.Expectation;\nimport org.hibernate.jdbc.Expectations;\nimport org.hibernate.resource.jdbc.spi.LogicalConnectionImplementor;\n\nimport org.hibernate.testing.junit4.BaseCoreFunctionalTestCase;\nimport org.hibernate.orm.test.common.JournalingBatchObserver;\nimport org.junit.Test;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertFalse;\nimport static org.junit.Assert.assertSame;\nimport static org.junit.Assert.assertTrue;\n\n/**\n * @author Steve Ebersole\n * @author Brett Meyer\n */\npublic class BatchingTest extends BaseCoreFunctionalTestCase implements BatchKey {\n\t@Override\n\tpublic int getBatchedStatementCount() {\n\t\treturn 1;\n\t}\n\n\t@Override\n\tpublic Expectation getExpectation() {\n\t\treturn Expectations.BASIC;\n\t}\n\n\t@Test\n\tpublic void testNonBatchingUsage() throws Exception {\n\t\tSession session = openSession();\n\t\tSessionImplementor sessionImpl = (SessionImplementor) session;\n\t\t\n\t\tfinal JdbcCoordinator jdbcCoordinator = sessionImpl.getJdbcCoordinator();\n\t\tLogicalConnectionImplementor logicalConnection = jdbcCoordinator.getLogicalConnection();\n\n\t\t// set up some tables to use\n\t\tStatement statement = jdbcCoordinator.getStatementPreparer().createStatement();\n\t\tString dropSql = sessionFactory().getJdbcServices().getDialect().getDropTableString( \"SANDBOX_JDBC_TST\" );\n\t\ttry {\n\t\t\tjdbcCoordinator.getResultSetReturn().execute( statement, dropSql );\n\t\t}\n\t\tcatch ( Exception e ) {\n\t\t\t// ignore if the DB doesn't support \"if exists\" and the table doesn't exist\n\t\t}\n\t\tjdbcCoordinator.getResultSetReturn().execute( statement, \"create table SANDBOX_JDBC_TST ( ID integer, NAME varchar(100) )\" );\n        assertTrue( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n\t\tassertTrue( logicalConnection.isPhysicallyConnected() );\n        jdbcCoordinator.getLogicalConnection().getResourceRegistry().release( statement );\n        assertFalse( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n\t\tassertTrue( logicalConnection.isPhysicallyConnected() ); // after_transaction specified\n\n\t\t// ok, now we can get down to it...\n\t\tTransaction txn = session.getTransaction();  // same as Session#getTransaction\n\t\ttxn.begin();\n\n\t\tfinal String insertSql = \"insert into SANDBOX_JDBC_TST( ID, NAME ) values ( ?, ? )\";\n\n\t\tfinal BatchBuilder batchBuilder = new BatchBuilderImpl( -1 );\n\t\tfinal BatchKey batchKey = new BasicBatchKey( \"this\", Expectations.BASIC );\n\t\tfinal Batch insertBatch = batchBuilder.buildBatch( batchKey, jdbcCoordinator );\n\n\t\tfinal JournalingBatchObserver batchObserver = new JournalingBatchObserver();\n\t\tinsertBatch.addObserver( batchObserver );\n\n\t\tassertTrue( \"unexpected Batch impl\", NonBatchingBatch.class.isInstance( insertBatch ) );\n\t\tPreparedStatement insert = insertBatch.getBatchStatement( insertSql, false );\n\t\tinsert.setLong( 1, 1 );\n\t\tinsert.setString( 2, \"name\" );\n\t\tassertEquals( 0, batchObserver.getExplicitExecutionCount() );\n\t\tassertEquals( 0, batchObserver.getImplicitExecutionCount() );\n\t\tinsertBatch.addToBatch();\n\t\tassertEquals( 0, batchObserver.getExplicitExecutionCount() );\n\t\tassertEquals( 1, batchObserver.getImplicitExecutionCount() );\n        assertFalse( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n\n\t\tinsertBatch.execute();\n\t\tassertEquals( 1, batchObserver.getExplicitExecutionCount() );\n\t\tassertEquals( 1, batchObserver.getImplicitExecutionCount() );\n        assertFalse( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n\n\t\tinsertBatch.release();\n\n\t\ttxn.commit();\n\t\tsession.close();\n\t}\n\n\t@Test\n\tpublic void testBatchingUsage() throws Exception {\n\t\tSession session = openSession();\n\t\tSessionImplementor sessionImpl = (SessionImplementor) session;\n\t\t\n\t\tfinal JdbcCoordinator jdbcCoordinator = sessionImpl.getJdbcCoordinator();\n\t\tLogicalConnectionImplementor logicalConnection = jdbcCoordinator.getLogicalConnection();\n\n\t\t// set up some tables to use\n\t\tStatement statement = jdbcCoordinator.getStatementPreparer().createStatement();\n\t\tString dropSql = sessionFactory().getJdbcServices().getDialect().getDropTableString( \"SANDBOX_JDBC_TST\" );\n\t\ttry {\n\t\t\tjdbcCoordinator.getResultSetReturn().execute( statement, dropSql );\n\t\t}\n\t\tcatch ( Exception e ) {\n\t\t\t// ignore if the DB doesn't support \"if exists\" and the table doesn't exist\n\t\t}\t\tjdbcCoordinator.getResultSetReturn().execute( statement, \"create table SANDBOX_JDBC_TST ( ID integer, NAME varchar(100) )\" );\n        assertTrue( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n\t\tassertTrue( logicalConnection.isPhysicallyConnected() );\n        jdbcCoordinator.getLogicalConnection().getResourceRegistry().release( statement );\n        assertFalse( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n\t\tassertTrue( logicalConnection.isPhysicallyConnected() ); // after_transaction specified\n\n\t\t// ok, now we can get down to it...\n\t\tTransaction txn = session.getTransaction();  // same as Session#getTransaction\n\t\ttxn.begin();\n\n\t\tfinal BatchBuilder batchBuilder = new BatchBuilderImpl( 2 );\n\t\tfinal BatchKey batchKey = new BasicBatchKey( \"this\", Expectations.BASIC );\n\t\tfinal Batch insertBatch = batchBuilder.buildBatch( batchKey, jdbcCoordinator );\n\t\tassertTrue( \"unexpected Batch impl\", BatchingBatch.class.isInstance( insertBatch ) );\n\n\t\tfinal JournalingBatchObserver batchObserver = new JournalingBatchObserver();\n\t\tinsertBatch.addObserver( batchObserver );\n\n\t\tfinal String insertSql = \"insert into SANDBOX_JDBC_TST( ID, NAME ) values ( ?, ? )\";\n\n\t\tPreparedStatement insert = insertBatch.getBatchStatement( insertSql, false );\n\t\tinsert.setLong( 1, 1 );\n\t\tinsert.setString( 2, \"name\" );\n\t\tassertEquals( 0, batchObserver.getExplicitExecutionCount() );\n\t\tassertEquals( 0, batchObserver.getImplicitExecutionCount() );\n\t\tinsertBatch.addToBatch();\n\t\tassertEquals( 0, batchObserver.getExplicitExecutionCount() );\n\t\tassertEquals( 0, batchObserver.getImplicitExecutionCount() );\n        assertTrue( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n\n\t\tPreparedStatement insert2 = insertBatch.getBatchStatement( insertSql, false );\n\t\tassertSame( insert, insert2 );\n\t\tinsert = insert2;\n\t\tinsert.setLong( 1, 2 );\n\t\tinsert.setString( 2, \"another name\" );\n\t\tassertEquals( 0, batchObserver.getExplicitExecutionCount() );\n\t\tassertEquals( 0, batchObserver.getImplicitExecutionCount() );\n\t\tinsertBatch.addToBatch();\n\t\tassertEquals( 0, batchObserver.getExplicitExecutionCount() );\n\t\tassertEquals( 1, batchObserver.getImplicitExecutionCount() );\n        assertTrue( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n\n\t\tinsertBatch.execute();\n\t\tassertEquals( 1, batchObserver.getExplicitExecutionCount() );\n\t\tassertEquals( 1, batchObserver.getImplicitExecutionCount() );\n        assertFalse( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n\n\t\tinsertBatch.release();\n\n\t\ttxn.commit();\n\t\tsession.close();\n\t}\n\n\t@Test\n\tpublic void testSessionBatchingUsage() throws Exception {\n\t\tSession session = openSession();\n\t\tsession.setJdbcBatchSize( 3 );\n\t\tSessionImplementor sessionImpl = (SessionImplementor) session;\n\n\t\tfinal JdbcCoordinator jdbcCoordinator = sessionImpl.getJdbcCoordinator();\n\t\tLogicalConnectionImplementor logicalConnection = jdbcCoordinator.getLogicalConnection();\n\n\t\t// set up some tables to use\n\t\tStatement statement = jdbcCoordinator.getStatementPreparer().createStatement();\n\t\tString dropSql = sessionFactory().getJdbcServices().getDialect().getDropTableString( \"SANDBOX_JDBC_TST\" );\n\t\ttry {\n\t\t\tjdbcCoordinator.getResultSetReturn().execute( statement, dropSql );\n\t\t}\n\t\tcatch ( Exception e ) {\n\t\t\t// ignore if the DB doesn't support \"if exists\" and the table doesn't exist\n\t\t}\t\tjdbcCoordinator.getResultSetReturn().execute( statement, \"create table SANDBOX_JDBC_TST ( ID integer, NAME varchar(100) )\" );\n        assertTrue( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n\t\tassertTrue( logicalConnection.isPhysicallyConnected() );\n        jdbcCoordinator.getLogicalConnection().getResourceRegistry().release( statement );\n        assertFalse( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n\t\tassertTrue( logicalConnection.isPhysicallyConnected() ); // after_transaction specified\n\n\t\t// ok, now we can get down to it...\n\t\tTransaction txn = session.getTransaction();  // same as Session#getTransaction\n\t\ttxn.begin();\n\n\t\tfinal BatchBuilder batchBuilder = new BatchBuilderImpl( 2 );\n\t\tfinal BatchKey batchKey = new BasicBatchKey( \"this\", Expectations.BASIC );\n\t\tfinal Batch insertBatch = batchBuilder.buildBatch( batchKey, jdbcCoordinator );\n\t\tassertTrue( \"unexpected Batch impl\", BatchingBatch.class.isInstance( insertBatch ) );\n\n\t\tfinal JournalingBatchObserver batchObserver = new JournalingBatchObserver();\n\t\tinsertBatch.addObserver( batchObserver );\n\n\t\tfinal String insertSql = \"insert into SANDBOX_JDBC_TST( ID, NAME ) values ( ?, ? )\";\n\n\t\tPreparedStatement insert = insertBatch.getBatchStatement( insertSql, false );\n\t\tinsert.setLong( 1, 1 );\n\t\tinsert.setString( 2, \"name\" );\n\t\tassertEquals( 0, batchObserver.getExplicitExecutionCount() );\n\t\tassertEquals( 0, batchObserver.getImplicitExecutionCount() );\n\t\tinsertBatch.addToBatch();\n\t\tassertEquals( 0, batchObserver.getExplicitExecutionCount() );\n\t\tassertEquals( 0, batchObserver.getImplicitExecutionCount() );\n        assertTrue( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n\n\t\tPreparedStatement insert2 = insertBatch.getBatchStatement( insertSql, false );\n\t\tassertSame( insert, insert2 );\n\t\tinsert = insert2;\n\t\tinsert.setLong( 1, 2 );\n\t\tinsert.setString( 2, \"another name\" );\n\t\tassertEquals( 0, batchObserver.getExplicitExecutionCount() );\n\t\tassertEquals( 0, batchObserver.getImplicitExecutionCount() );\n\t\tinsertBatch.addToBatch();\n\t\tassertEquals( 0, batchObserver.getExplicitExecutionCount() );\n\t\tassertEquals( 0, batchObserver.getImplicitExecutionCount() );\n        assertTrue( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n\n\t\tPreparedStatement insert3 = insertBatch.getBatchStatement( insertSql, false );\n\t\tassertSame( insert, insert3 );\n\t\tinsert = insert3;\n\t\tinsert.setLong( 1, 3 );\n\t\tinsert.setString( 2, \"yet another name\" );\n\t\tassertEquals( 0, batchObserver.getExplicitExecutionCount() );\n\t\tassertEquals( 0, batchObserver.getImplicitExecutionCount() );\n\t\tinsertBatch.addToBatch();\n\t\tassertEquals( 0, batchObserver.getExplicitExecutionCount() );\n\t\tassertEquals( 1, batchObserver.getImplicitExecutionCount() );\n        assertTrue( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n\n\t\tinsertBatch.execute();\n\t\tassertEquals( 1, batchObserver.getExplicitExecutionCount() );\n\t\tassertEquals( 1, batchObserver.getImplicitExecutionCount() );\n        assertFalse( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n\n\t\tinsertBatch.release();\n\n\t\ttxn.commit();\n\t\tsession.close();\n\t}\n\n\t@Override\n\tprotected void cleanupTest() throws Exception {\n\t\ttry (Session session = openSession()) {\n\t\t\tsession.doWork( connection -> {\n\t\t\t\tfinal Statement stmnt = connection.createStatement();\n\n\t\t\t\tstmnt.execute( sessionFactory().getJdbcServices().getDialect().getDropTableString( \"SANDBOX_JDBC_TST\" ) );\n\t\t\t} );\n\t\t}\n\t}\n\n}\n",
        "filePathAfter": "hibernate-core/src/test/java/org/hibernate/orm/test/jdbc/internal/BatchingTest.java",
        "sourceCodeAfterForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.\n */\npackage org.hibernate.orm.test.jdbc.internal;\n\nimport java.sql.Statement;\n\nimport org.hibernate.Session;\nimport org.hibernate.Transaction;\nimport org.hibernate.engine.jdbc.batch.internal.BasicBatchKey;\nimport org.hibernate.engine.jdbc.batch.internal.BatchBuilderImpl;\nimport org.hibernate.engine.jdbc.batch.spi.Batch;\nimport org.hibernate.engine.jdbc.batch.spi.BatchKey;\nimport org.hibernate.engine.jdbc.mutation.ParameterUsage;\nimport org.hibernate.engine.jdbc.mutation.internal.JdbcValueBindingsImpl;\nimport org.hibernate.engine.jdbc.spi.JdbcCoordinator;\nimport org.hibernate.engine.spi.SessionImplementor;\nimport org.hibernate.jdbc.Expectation;\nimport org.hibernate.jdbc.Expectations;\nimport org.hibernate.metamodel.mapping.JdbcMapping;\nimport org.hibernate.orm.test.common.JournalingBatchObserver;\nimport org.hibernate.resource.jdbc.spi.LogicalConnectionImplementor;\nimport org.hibernate.sql.model.MutationType;\nimport org.hibernate.sql.model.TableMapping;\nimport org.hibernate.sql.model.jdbc.JdbcValueDescriptor;\nimport org.hibernate.type.StandardBasicTypes;\n\nimport org.hibernate.testing.junit4.BaseCoreFunctionalTestCase;\nimport org.junit.Test;\n\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.hibernate.jdbc.Expectations.NONE;\nimport static org.junit.Assert.assertFalse;\nimport static org.junit.Assert.assertTrue;\n\n/**\n * @author Steve Ebersole\n * @author Brett Meyer\n */\npublic class BatchingTest extends BaseCoreFunctionalTestCase implements BatchKey {\n\tprivate final String SANDBOX_TBL = \"SANDBOX_JDBC_TST\";\n\tprivate final TableMapping SANDBOX_TBL_MAPPING = new TableMapping() {\n\t\t@Override\n\t\tpublic String getTableName() {\n\t\t\treturn SANDBOX_TBL;\n\t\t}\n\n\t\t@Override\n\t\tpublic int getRelativePosition() {\n\t\t\treturn 0;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean isOptional() {\n\t\t\treturn false;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean isInverse() {\n\t\t\treturn false;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean isIdentifierTable() {\n\t\t\treturn true;\n\t\t}\n\n\t\t@Override\n\t\tpublic MutationDetails getInsertDetails() {\n\t\t\treturn new MutationDetails( MutationType.INSERT, NONE, null, false );\n\t\t}\n\n\t\t@Override\n\t\tpublic MutationDetails getUpdateDetails() {\n\t\t\treturn new MutationDetails( MutationType.UPDATE, NONE, null, false );\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean isCascadeDeleteEnabled() {\n\t\t\treturn false;\n\t\t}\n\n\t\t@Override\n\t\tpublic MutationDetails getDeleteDetails() {\n\t\t\treturn new MutationDetails( MutationType.DELETE, NONE, null, false );\n\t\t}\n\t};\n\n\t@Override\n\tpublic int getBatchedStatementCount() {\n\t\treturn 1;\n\t}\n\n\t@Override\n\tpublic Expectation getExpectation() {\n\t\treturn Expectations.BASIC;\n\t}\n\n\t@Test\n\tpublic void testBatchingUsage() throws Exception {\n\t\tfinal Session session = openSession();\n\t\tfinal SessionImplementor sessionImpl = (SessionImplementor) session;\n\t\tfinal JdbcCoordinator jdbcCoordinator = sessionImpl.getJdbcCoordinator();\n\n\t\texportSandboxSchema( sessionImpl );\n\n\t\t// ok, now we can get down to it...\n\t\tTransaction txn = session.getTransaction();  // same as Session#getTransaction\n\t\ttxn.begin();\n\n\t\tfinal String insertSql = \"insert into SANDBOX_JDBC_TST( ID, NAME ) values ( ?, ? )\";\n\n\t\tfinal BatchBuilderImpl batchBuilder = new BatchBuilderImpl( 2 );\n\t\tfinal BatchKey batchKey = new BasicBatchKey( \"this\" );\n\t\tfinal Batch insertBatch = batchBuilder.buildBatch( batchKey, null, SANDBOX_TBL, sessionImpl, insertSql );\n\t\tassertThat( insertBatch ).isNotNull();\n\n\t\tfinal JournalingBatchObserver batchObserver = new JournalingBatchObserver();\n\t\tinsertBatch.addObserver( batchObserver );\n\n\t\tfinal JdbcValueBindingsImpl jdbcValueBindings = sandboxInsertValueBindings( sessionImpl );\n\n\t\t// bind values for #1 - should do nothing at the JDBC level\n\t\tjdbcValueBindings.bindValue( 1, SANDBOX_TBL, \"ID\", ParameterUsage.SET, sessionImpl );\n\t\tjdbcValueBindings.bindValue( \"name\", SANDBOX_TBL, \"NAME\", ParameterUsage.SET, sessionImpl );\n\t\tassertThat( batchObserver.getExplicitExecutionCount() ).isEqualTo( 0 );\n\t\tassertThat( batchObserver.getImplicitExecutionCount() ).isEqualTo( 0 );\n\t\tassertThat( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() ).isFalse();\n\n\t\t// add #1 to the batch - will acquire prepared statement to bind values\n\t\tinsertBatch.addToBatch( jdbcValueBindings, null );\n\t\tassertThat( batchObserver.getExplicitExecutionCount() ).isEqualTo( 0 );\n\t\tassertThat( batchObserver.getImplicitExecutionCount() ).isEqualTo( 0 );\n        assertThat( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() ).isTrue();\n\n\t\t// bind values for #2 - again, nothing at JDBC level (we have statement from earlier)\n\t\tjdbcValueBindings.bindValue( 2, SANDBOX_TBL, \"ID\", ParameterUsage.SET, sessionImpl );\n\t\tjdbcValueBindings.bindValue( \"another name\", SANDBOX_TBL, \"NAME\", ParameterUsage.SET, sessionImpl );\n\t\tassertThat( batchObserver.getExplicitExecutionCount() ).isEqualTo( 0 );\n\t\tassertThat( batchObserver.getImplicitExecutionCount() ).isEqualTo( 0 );\n\n\t\t// add #2 to the batch -\n\t\t// \t\t- uses the previous prepared statement to bind values\n\t\t//\t\t- batch size has been exceeded, trigger an implicit execution\n\t\tinsertBatch.addToBatch( jdbcValueBindings, null );\n\t\tassertThat( batchObserver.getExplicitExecutionCount() ).isEqualTo( 0 );\n\t\tassertThat( batchObserver.getImplicitExecutionCount() ).isEqualTo( 1 );\n\t\tassertThat( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() ).isTrue();\n\n\t\t// execute the batch - effectively only increments the explicit-execution counter\n\t\tinsertBatch.execute();\n\t\tassertThat( batchObserver.getExplicitExecutionCount() ).isEqualTo( 1 );\n\t\tassertThat( batchObserver.getImplicitExecutionCount() ).isEqualTo( 1 );\n\t\tassertThat( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() ).isFalse();\n\n\t\tinsertBatch.release();\n\n\t\ttxn.commit();\n\t\tsession.close();\n\t}\n\n\tprivate JdbcValueBindingsImpl sandboxInsertValueBindings(SessionImplementor session) {\n\t\treturn new JdbcValueBindingsImpl(\n\t\t\t\tMutationType.INSERT,\n\t\t\t\tnull,\n\t\t\t\t(tableName, columnName, usage) -> {\n\t\t\t\t\tassert tableName.equals( SANDBOX_TBL );\n\n\t\t\t\t\tif ( columnName.equals( \"ID\" ) ) {\n\t\t\t\t\t\treturn new JdbcValueDescriptor() {\n\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\tpublic String getColumnName() {\n\t\t\t\t\t\t\t\treturn \"ID\";\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\tpublic ParameterUsage getUsage() {\n\t\t\t\t\t\t\t\treturn ParameterUsage.SET;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\tpublic int getJdbcPosition() {\n\t\t\t\t\t\t\t\treturn 1;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\tpublic JdbcMapping getJdbcMapping() {\n\t\t\t\t\t\t\t\treturn session.getTypeConfiguration()\n\t\t\t\t\t\t\t\t\t\t.getBasicTypeRegistry()\n\t\t\t\t\t\t\t\t\t\t.resolve( StandardBasicTypes.INTEGER );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( columnName.equals( \"NAME\" ) ) {\n\t\t\t\t\t\treturn new JdbcValueDescriptor() {\n\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\tpublic String getColumnName() {\n\t\t\t\t\t\t\t\treturn \"NAME\";\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\tpublic ParameterUsage getUsage() {\n\t\t\t\t\t\t\t\treturn ParameterUsage.SET;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\tpublic int getJdbcPosition() {\n\t\t\t\t\t\t\t\treturn 2;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\tpublic JdbcMapping getJdbcMapping() {\n\t\t\t\t\t\t\t\treturn session.getTypeConfiguration()\n\t\t\t\t\t\t\t\t\t\t.getBasicTypeRegistry()\n\t\t\t\t\t\t\t\t\t\t.resolve( StandardBasicTypes.STRING );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\n\t\t\t\t\tthrow new IllegalArgumentException( \"Unknown column : \" + columnName );\n\t\t\t\t}\n\t\t);\n\t}\n\n\t@Test\n\tpublic void testSessionBatchingUsage() throws Exception {\n\t\tSession session = openSession();\n\t\tsession.setJdbcBatchSize( 3 );\n\t\tSessionImplementor sessionImpl = (SessionImplementor) session;\n\t\tfinal JdbcCoordinator jdbcCoordinator = sessionImpl.getJdbcCoordinator();\n\n\t\texportSandboxSchema( sessionImpl );\n\n\t\t// ok, now we can get down to it...\n\t\tTransaction txn = session.getTransaction();  // same as Session#getTransaction\n\t\ttxn.begin();\n\n\n\t\tfinal String insertSql = \"insert into SANDBOX_JDBC_TST( ID, NAME ) values ( ?, ? )\";\n\n\t\tfinal BatchBuilderImpl batchBuilder = new BatchBuilderImpl( 2 );\n\t\tfinal BatchKey batchKey = new BasicBatchKey( \"this\" );\n\t\tfinal Batch insertBatch = batchBuilder.buildBatch( batchKey, 3, SANDBOX_TBL, sessionImpl, insertSql );\n\t\tassertThat( insertBatch ).isNotNull();\n\n\t\tfinal JournalingBatchObserver batchObserver = new JournalingBatchObserver();\n\t\tinsertBatch.addObserver( batchObserver );\n\n\t\tfinal JdbcValueBindingsImpl jdbcValueBindings = sandboxInsertValueBindings( sessionImpl );\n\n\t\t// bind values for #1 - this does nothing at the JDBC level\n\t\tjdbcValueBindings.bindValue( 1, SANDBOX_TBL, \"ID\", ParameterUsage.SET, sessionImpl );\n\t\tjdbcValueBindings.bindValue( \"name\", SANDBOX_TBL, \"NAME\", ParameterUsage.SET, sessionImpl );\n\t\tassertThat( batchObserver.getExplicitExecutionCount() ).isEqualTo( 0 );\n\t\tassertThat( batchObserver.getImplicitExecutionCount() ).isEqualTo( 0 );\n\t\tassertThat( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() ).isFalse();\n\n\t\t// add the values to the batch - this creates the prepared statement and binds the values\n\t\tinsertBatch.addToBatch( jdbcValueBindings, null );\n\t\tassertThat( batchObserver.getExplicitExecutionCount() ).isEqualTo( 0 );\n\t\tassertThat( batchObserver.getImplicitExecutionCount() ).isEqualTo( 0 );\n\t\tassertThat( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() ).isTrue();\n\n\t\t// bind values for #2 - this does nothing at the JDBC level : we do still have the statement defining the batch\n\t\tjdbcValueBindings.bindValue( 2, SANDBOX_TBL, \"ID\", ParameterUsage.SET, sessionImpl );\n\t\tjdbcValueBindings.bindValue( \"another name\", SANDBOX_TBL, \"NAME\", ParameterUsage.SET, sessionImpl );\n\t\tassertThat( batchObserver.getExplicitExecutionCount() ).isEqualTo( 0 );\n\t\tassertThat( batchObserver.getImplicitExecutionCount() ).isEqualTo( 0 );\n\t\tassertThat( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() ).isTrue();\n\n\t\t// add #2 to batch - we have not exceeded batch size, so we should not get an implicit execution\n\t\tinsertBatch.addToBatch( jdbcValueBindings, null );\n\t\tassertThat( batchObserver.getExplicitExecutionCount() ).isEqualTo( 0 );\n\t\tassertThat( batchObserver.getImplicitExecutionCount() ).isEqualTo( 0 );\n\t\tassertThat( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() ).isTrue();\n\n\t\t// bind values for #3 - this does nothing at the JDBC level : we do still have the statement defining the batch\n\t\tjdbcValueBindings.bindValue( 3, SANDBOX_TBL, \"ID\", ParameterUsage.SET, sessionImpl );\n\t\tjdbcValueBindings.bindValue( \"yet another name\", SANDBOX_TBL, \"NAME\", ParameterUsage.SET, sessionImpl );\n\t\tassertThat( batchObserver.getExplicitExecutionCount() ).isEqualTo( 0 );\n\t\tassertThat( batchObserver.getImplicitExecutionCount() ).isEqualTo( 0 );\n\t\tassertThat( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() ).isTrue();\n\n\t\tinsertBatch.addToBatch( jdbcValueBindings, null );\n\t\tassertThat( batchObserver.getExplicitExecutionCount() ).isEqualTo( 0 );\n\t\tassertThat( batchObserver.getImplicitExecutionCount() ).isEqualTo( 1 );\n\t\tassertThat( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() ).isTrue();\n\n\t\tinsertBatch.execute();\n\t\tassertThat( batchObserver.getExplicitExecutionCount() ).isEqualTo( 1 );\n\t\tassertThat( batchObserver.getImplicitExecutionCount() ).isEqualTo( 1 );\n\t\tassertThat( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() ).isFalse();\n\n\t\tinsertBatch.release();\n\n\t\ttxn.commit();\n\t\tsession.close();\n\t}\n\n\tprivate void exportSandboxSchema(SessionImplementor sessionImpl) {\n\t\tfinal JdbcCoordinator jdbcCoordinator = sessionImpl.getJdbcCoordinator();\n\t\tLogicalConnectionImplementor logicalConnection = jdbcCoordinator.getLogicalConnection();\n\n\t\t// set up some tables to use\n\t\tStatement statement = jdbcCoordinator.getStatementPreparer().createStatement();\n\t\tString dropSql = sessionFactory().getJdbcServices().getDialect().getDropTableString( \"SANDBOX_JDBC_TST\" );\n\t\ttry {\n\t\t\tjdbcCoordinator.getResultSetReturn().execute( statement, dropSql );\n\t\t}\n\t\tcatch ( Exception e ) {\n\t\t\t// ignore if the DB doesn't support \"if exists\" and the table doesn't exist\n\t\t}\n\t\tjdbcCoordinator.getResultSetReturn().execute( statement, \"create table SANDBOX_JDBC_TST ( ID integer, NAME varchar(100) )\" );\n\t\tassertTrue( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n\t\tassertTrue( logicalConnection.isPhysicallyConnected() );\n\t\tjdbcCoordinator.getLogicalConnection().getResourceRegistry().release( statement );\n\t\tassertFalse( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n\t\tassertTrue( logicalConnection.isPhysicallyConnected() ); // after_transaction specified\n\t}\n\n\t@Override\n\tprotected void cleanupTest() throws Exception {\n\t\ttry (Session session = openSession()) {\n\t\t\tsession.doWork( connection -> {\n\t\t\t\tfinal Statement stmnt = connection.createStatement();\n\n\t\t\t\tstmnt.execute( sessionFactory().getJdbcServices().getDialect().getDropTableString( \"SANDBOX_JDBC_TST\" ) );\n\t\t\t} );\n\t\t}\n\t}\n\n}\n",
        "diffSourceCodeSet": [
            "private void exportSandboxSchema(SessionImplementor sessionImpl) {\n\t\tfinal JdbcCoordinator jdbcCoordinator = sessionImpl.getJdbcCoordinator();\n\t\tLogicalConnectionImplementor logicalConnection = jdbcCoordinator.getLogicalConnection();\n\n\t\t// set up some tables to use\n\t\tStatement statement = jdbcCoordinator.getStatementPreparer().createStatement();\n\t\tString dropSql = sessionFactory().getJdbcServices().getDialect().getDropTableString( \"SANDBOX_JDBC_TST\" );\n\t\ttry {\n\t\t\tjdbcCoordinator.getResultSetReturn().execute( statement, dropSql );\n\t\t}\n\t\tcatch ( Exception e ) {\n\t\t\t// ignore if the DB doesn't support \"if exists\" and the table doesn't exist\n\t\t}\n\t\tjdbcCoordinator.getResultSetReturn().execute( statement, \"create table SANDBOX_JDBC_TST ( ID integer, NAME varchar(100) )\" );\n\t\tassertTrue( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n\t\tassertTrue( logicalConnection.isPhysicallyConnected() );\n\t\tjdbcCoordinator.getLogicalConnection().getResourceRegistry().release( statement );\n\t\tassertFalse( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n\t\tassertTrue( logicalConnection.isPhysicallyConnected() ); // after_transaction specified\n\t}"
        ],
        "invokedMethodSet": [
            "methodSignature: org.hibernate.action.internal.BulkOperationCleanupAction.NaturalIdCleanup#release\n methodBody: private void release() {\nnaturalIdCacheAccessStrategy.unlockRegion(cacheLock);\n}",
            "methodSignature: org.hibernate.orm.test.insertordering.InsertOrderingTest.StatsBatch#addToBatch\n methodBody: public void addToBatch() {\nCounter counter=(Counter)batchSizes.get(currentBatch);\ncounter.count++;\nsuper.addToBatch();\n}",
            "methodSignature: org.hibernate.engine.jdbc.spi.JdbcCoordinator#getStatementPreparer\n methodBody: StatementPreparer getStatementPreparer();",
            "methodSignature: org.hibernate.engine.jdbc.spi.JdbcServices#getDialect\n methodBody: Dialect getDialect();",
            "methodSignature: org.hibernate.engine.jdbc.batch.internal.AbstractBatchImpl#getBatchStatement\n methodBody: public PreparedStatement getBatchStatement(String sql, boolean callable) {\nif(sql == null){throw new IllegalArgumentException(\"sql must be non-null.\");\n}PreparedStatement statement=statements.get(sql);\nif(statement == null){statement=buildBatchStatement(sql,callable);\nstatements.put(sql,statement);\n}{LOG.debug(\"Reusing batch statement\");\nsqlStatementLogger().logStatement(sql);\n}return statement;\n}",
            "methodSignature: org.hibernate.engine.jdbc.batch.spi.Batch#execute\n methodBody: void execute();",
            "methodSignature: org.hibernate.engine.jdbc.batch.internal.SharedBatchBuildingCode#buildBatch\n methodBody: static Batch buildBatch(final int defaultJdbcBatchSize, final BatchKey key, final JdbcCoordinator jdbcCoordinator) {\nfinal Integer sessionJdbcBatchSize=jdbcCoordinator.getJdbcSessionOwner().getJdbcBatchSize();\nfinal int jdbcBatchSizeToUse=sessionJdbcBatchSize == null ? defaultJdbcBatchSize : sessionJdbcBatchSize;\nreturn jdbcBatchSizeToUse > 1 ? new BatchingBatch(key,jdbcCoordinator,jdbcBatchSizeToUse) : new NonBatchingBatch(key,jdbcCoordinator);\n}",
            "methodSignature: org.hibernate.engine.jdbc.internal.JdbcCoordinatorImpl#getLogicalConnection\n methodBody: public LogicalConnectionImplementor getLogicalConnection() {\nreturn logicalConnection;\n}",
            "methodSignature: org.hibernate.engine.jdbc.internal.JdbcCoordinatorImpl#close\n methodBody: protected void close(ResultSet resultSet) {\nLOG.tracev(\"Closing result set [{0}]\",resultSet);\nif(resultSet instanceof InvalidatableWrapper){@SuppressWarnings(\"unchecked\") final InvalidatableWrapper<ResultSet> wrapper=(InvalidatableWrapper<ResultSet>)resultSet;\nclose(wrapper.getWrappedObject());\nwrapper.invalidate();\nreturn;\n}tryresultSet.close();\ncatch(Exception e)LOG.debugf(\"Unable to release JDBC result set [%s]\",e.getMessage());\n}",
            "methodSignature: org.hibernate.query.sqm.mutation.internal.inline.InlineUpdateHandler#execute\n methodBody: public int execute(DomainQueryExecutionContext executionContext) {\nfinal List<Object> ids=MatchingIdSelectionHelper.selectMatchingIds(sqmUpdate,domainParameterXref,executionContext);\nif(ids == null || ids.isEmpty()){return 0;\n}domainParameterXref.clearExpansions();\nfinal MappingMetamodel domainModel=sessionFactory.getRuntimeMetamodels().getMappingMetamodel();\nfinal String mutatingEntityName=sqmUpdate.getTarget().getModel().getHibernateEntityName();\nfinal EntityPersister entityDescriptor=domainModel.getEntityDescriptor(mutatingEntityName);\nfinal String rootEntityName=entityDescriptor.getEntityPersister().getRootEntityName();\nfinal EntityPersister rootEntityDescriptor=domainModel.getEntityDescriptor(rootEntityName);\nfinal String hierarchyRootTableName=((Joinable)rootEntityDescriptor).getTableName();\nfinal List<Expression> inListExpressions=new ArrayList<>(ids.size());\nfinal EntityIdentifierMapping identifierMapping=entityDescriptor.getIdentifierMapping();\nif(identifierMapping instanceof BasicValuedModelPart){final BasicValuedModelPart basicValuedModelPart=(BasicValuedModelPart)identifierMapping;\nfor(int i=0; i < ids.size(); i++){inListExpressions.add(new QueryLiteral<>(ids.get(i),basicValuedModelPart));\n}}{final int jdbcTypeCount=identifierMapping.getJdbcTypeCount();\nfor(int i=0; i < ids.size(); i++){final Object[] id=(Object[])ids.get(i);\nfinal List<Expression> tupleElements=new ArrayList<>(jdbcTypeCount);\ninListExpressions.add(new SqlTuple(tupleElements,identifierMapping));\nidentifierMapping.forEachJdbcType((index,jdbcMapping) -> {\n  tupleElements.add(new QueryLiteral<>(id[index],(BasicValuedMapping)jdbcMapping));\n}\n);\n}}final MultiTableSqmMutationConverter converterDelegate=new MultiTableSqmMutationConverter(entityDescriptor,sqmUpdate,sqmUpdate.getTarget(),domainParameterXref,executionContext.getQueryOptions(),executionContext.getSession().getLoadQueryInfluencers(),executionContext.getQueryParameterBindings(),sessionFactory);\nfinal TableGroup updatingTableGroup=converterDelegate.getMutatingTableGroup();\nfinal TableReference hierarchyRootTableReference=updatingTableGroup.resolveTableReference(updatingTableGroup.getNavigablePath(),hierarchyRootTableName);\nassert hierarchyRootTableReference != null;\nfinal Map<SqmParameter<?>,List<List<JdbcParameter>>> parameterResolutions;\nif(domainParameterXref.getSqmParameterCount() == 0){parameterResolutions=Collections.emptyMap();\n}{parameterResolutions=new IdentityHashMap<>();\n}final List<Assignment> assignments=new ArrayList<>();\nfinal Map<SqmParameter<?>,MappingModelExpressible<?>> paramTypeResolutions=new LinkedHashMap<>();\nconverterDelegate.visitSetClause(sqmUpdate.getSetClause(),assignments::add,(sqmParameter,mappingType,jdbcParameters) -> {\n  parameterResolutions.computeIfAbsent(sqmParameter,k -> new ArrayList<>(1)).add(jdbcParameters);\n  paramTypeResolutions.put(sqmParameter,mappingType);\n}\n);\nconverterDelegate.addVersionedAssignment(assignments::add,sqmUpdate);\nfinal Predicate providedPredicate;\nfinal SqmWhereClause whereClause=sqmUpdate.getWhereClause();\nif(whereClause == null || whereClause.getPredicate() == null){providedPredicate=null;\n}{providedPredicate=converterDelegate.visitWhereClause(whereClause,columnReference -> {\n}\n,(sqmParameter,mappingType,jdbcParameters) -> {\n  parameterResolutions.computeIfAbsent(sqmParameter,k -> new ArrayList<>(1)).add(jdbcParameters);\n  paramTypeResolutions.put(sqmParameter,mappingType);\n}\n);\nassert providedPredicate != null;\n}final PredicateCollector predicateCollector=new PredicateCollector(providedPredicate);\nentityDescriptor.applyBaseRestrictions(predicateCollector::applyPredicate,updatingTableGroup,true,executionContext.getSession().getLoadQueryInfluencers().getEnabledFilters(),null,converterDelegate);\nconverterDelegate.pruneTableGroupJoins();\nfinal Map<String,TableReference> tableReferenceByAlias=CollectionHelper.mapOfSize(updatingTableGroup.getTableReferenceJoins().size() + 1);\ncollectTableReference(updatingTableGroup.getPrimaryTableReference(),tableReferenceByAlias::put);\nfor(int i=0; i < updatingTableGroup.getTableReferenceJoins().size(); i++){collectTableReference(updatingTableGroup.getTableReferenceJoins().get(i),tableReferenceByAlias::put);\n}final JdbcParameterBindings jdbcParameterBindings=SqmUtil.createJdbcParameterBindings(executionContext.getQueryParameterBindings(),domainParameterXref,SqmUtil.generateJdbcParamsXref(domainParameterXref,() -> parameterResolutions),sessionFactory.getRuntimeMetamodels().getMappingMetamodel(),navigablePath -> updatingTableGroup,new SqmParameterMappingModelResolutionAccess(){\n  @Override @SuppressWarnings(\"unchecked\") public <T>MappingModelExpressible<T> getResolvedMappingModelType(  SqmParameter<T> parameter){\n    return (MappingModelExpressible<T>)paramTypeResolutions.get(parameter);\n  }\n}\n,executionContext.getSession());\nfinal Map<TableReference,List<Assignment>> assignmentsByTable=new HashMap<>();\nfor(int i=0; i < assignments.size(); i++){final Assignment assignment=assignments.get(i);\nfinal List<ColumnReference> assignmentColumnRefs=assignment.getAssignable().getColumnReferences();\nTableReference assignmentTableReference=null;\nfor(int c=0; c < assignmentColumnRefs.size(); c++){final ColumnReference columnReference=assignmentColumnRefs.get(c);\nfinal TableReference tableReference=resolveTableReference(columnReference,tableReferenceByAlias);\nif(assignmentTableReference != null && assignmentTableReference != tableReference){throw new SemanticException(\"Assignment referred to columns from multiple tables: \" + assignment.getAssignable());\n}assignmentTableReference=tableReference;\n}List<Assignment> assignmentsForTable=assignmentsByTable.get(assignmentTableReference);\nif(assignmentsForTable == null){assignmentsForTable=new ArrayList<>();\nassignmentsByTable.put(assignmentTableReference,assignmentsForTable);\n}assignmentsForTable.add(assignment);\n}final int rows=ids.size();\nfinal SqmJdbcExecutionContextAdapter executionContextAdapter=SqmJdbcExecutionContextAdapter.omittingLockingAndPaging(executionContext);\nentityDescriptor.visitConstraintOrderedTables((tableExpression,tableKeyColumnVisitationSupplier) -> updateTable(tableExpression,tableKeyColumnVisitationSupplier,entityDescriptor,updatingTableGroup,assignmentsByTable,inListExpressions,rows,jdbcParameterBindings,executionContextAdapter));\nreturn rows;\n}",
            "methodSignature: org.hibernate.dialect.AbstractHANADialect.CloseSuppressingInputStream#close\n methodBody: public void close() {\n}",
            "methodSignature: org.hibernate.query.sqm.mutation.internal.inline.InlineDeleteHandler#execute\n methodBody: public int execute(DomainQueryExecutionContext executionContext) {\nfinal List<Object> idsAndFks=MatchingIdSelectionHelper.selectMatchingIds(sqmDeleteStatement,domainParameterXref,executionContext);\nif(idsAndFks == null || idsAndFks.isEmpty()){return 0;\n}final SessionFactoryImplementor factory=executionContext.getSession().getFactory();\nfinal String mutatingEntityName=sqmDeleteStatement.getTarget().getModel().getHibernateEntityName();\nfinal EntityMappingType entityDescriptor=factory.getRuntimeMetamodels().getEntityMappingType(mutatingEntityName);\nfinal JdbcParameterBindings jdbcParameterBindings=new JdbcParameterBindingsImpl(domainParameterXref.getQueryParameterCount());\nfinal MutableInteger valueIndexCounter=new MutableInteger();\nSqmMutationStrategyHelper.visitCollectionTables(entityDescriptor,pluralAttribute -> {\n  if (pluralAttribute.getSeparateCollectionTable() != null) {\n    final ModelPart fkTargetPart=pluralAttribute.getKeyDescriptor().getTargetPart();\n    final int valueIndex;\n    if (fkTargetPart instanceof EntityIdentifierMapping) {\n      valueIndex=0;\n    }\n else {\n      if (valueIndexCounter.get() == 0) {\n        valueIndexCounter.set(entityDescriptor.getIdentifierMapping().getJdbcTypeCount());\n      }\n      valueIndex=valueIndexCounter.get();\n      valueIndexCounter.plus(fkTargetPart.getJdbcTypeCount());\n    }\n    executeDelete(pluralAttribute.getSeparateCollectionTable(),entityDescriptor,() -> fkTargetPart::forEachSelectable,idsAndFks,valueIndex,fkTargetPart,jdbcParameterBindings,executionContext);\n  }\n}\n);\nentityDescriptor.visitConstraintOrderedTables((tableExpression,tableKeyColumnsVisitationSupplier) -> {\n  executeDelete(tableExpression,entityDescriptor,tableKeyColumnsVisitationSupplier,idsAndFks,0,null,jdbcParameterBindings,executionContext);\n}\n);\nreturn idsAndFks.size();\n}",
            "methodSignature: org.hibernate.engine.jdbc.internal.JdbcCoordinatorImpl#hasRegisteredResources\n methodBody: private boolean hasRegisteredResources() {\nreturn getLogicalConnection().getResourceRegistry().hasRegisteredResources();\n}",
            "methodSignature: org.hibernate.engine.jdbc.batch.spi.Batch#release\n methodBody: void release();",
            "methodSignature: org.hibernate.engine.jdbc.batch.internal.UnmodifiableBatchBuilderImpl#buildBatch\n methodBody: public Batch buildBatch(BatchKey key, JdbcCoordinator jdbcCoordinator) {\nreturn SharedBatchBuildingCode.buildBatch(jdbcBatchSize,key,jdbcCoordinator);\n}",
            "methodSignature: org.hibernate.persister.entity.AbstractEntityPersister#isInstance\n methodBody: public boolean isInstance(Object object) {\nreturn getRepresentationStrategy().getInstantiator().isInstance(object,getFactory());\n}",
            "methodSignature: org.hibernate.orm.test.jpa.transaction.batch.JtaWithFailingBatchTest.TestBatch#addToBatch\n methodBody: public void addToBatch() {\nthrow sqlExceptionHelper().convert(new SQLException(\"fake SQLException\"),\"could not perform addBatch\",currentStatementSql);\n}",
            "methodSignature: org.hibernate.action.internal.BulkOperationCleanupAction#execute\n methodBody: public void execute() throws HibernateException {\n}",
            "methodSignature: org.hibernate.orm.test.jpa.transaction.batch.JtaWithFailingBatchTest.TestBatch#getBatchStatement\n methodBody: public PreparedStatement getBatchStatement(String sql, boolean callable) {\ncurrentStatementSql=sql;\nPreparedStatement batchStatement=super.getBatchStatement(sql,callable);\ncreatedStatements.add(batchStatement);\nreturn batchStatement;\n}",
            "methodSignature: org.hibernate.engine.jdbc.batch.spi.BatchBuilder#buildBatch\n methodBody: Batch buildBatch(BatchKey key, JdbcCoordinator jdbcCoordinator);",
            "methodSignature: org.hibernate.procedure.internal.ProcedureCallImpl#execute\n methodBody: public boolean execute() {\ntryreturn outputs().getCurrent() instanceof ResultSetOutput;\ncatch(NoMoreOutputsException e)return false;\ncatch(HibernateException he)throw getSession().getExceptionConverter().convert(he);\ncatch(RuntimeException e)getSession().markForRollbackOnly();\nthrow e;\n}",
            "methodSignature: org.hibernate.query.sqm.mutation.internal.cte.CteInsertHandler#execute\n methodBody: public int execute(DomainQueryExecutionContext executionContext) {\nfinal SqmInsertStatement<?> sqmInsertStatement=getSqmStatement();\nfinal SessionFactoryImplementor factory=executionContext.getSession().getFactory();\nfinal EntityPersister entityDescriptor=getEntityDescriptor().getEntityPersister();\nfinal String explicitDmlTargetAlias;\nif(sqmInsertStatement.getTarget().getExplicitAlias() == null){explicitDmlTargetAlias=\"dml_target\";\n}{explicitDmlTargetAlias=sqmInsertStatement.getTarget().getExplicitAlias();\n}final MultiTableSqmMutationConverter sqmConverter=new MultiTableSqmMutationConverter(entityDescriptor,sqmInsertStatement,sqmInsertStatement.getTarget(),explicitDmlTargetAlias,domainParameterXref,executionContext.getQueryOptions(),executionContext.getSession().getLoadQueryInfluencers(),executionContext.getQueryParameterBindings(),factory);\nfinal TableGroup insertingTableGroup=sqmConverter.getMutatingTableGroup();\nfinal Map<SqmParameter<?>,List<List<JdbcParameter>>> parameterResolutions;\nif(domainParameterXref.getSqmParameterCount() == 0){parameterResolutions=Collections.emptyMap();\n}{parameterResolutions=new IdentityHashMap<>();\n}final int size=sqmStatement.getInsertionTargetPaths().size();\nfinal List<Map.Entry<List<CteColumn>,Assignment>> targetPathColumns=new ArrayList<>(size);\nfinal List<CteColumn> targetPathCteColumns=new ArrayList<>(size);\nfinal Map<SqmParameter<?>,MappingModelExpressible<?>> paramTypeResolutions=new LinkedHashMap<>();\nfinal NamedTableReference entityTableReference=new NamedTableReference(cteTable.getTableExpression(),TemporaryTable.DEFAULT_ALIAS,true,sessionFactory);\nfinal InsertStatement insertStatement=new InsertStatement(entityTableReference);\nfinal BaseSqmToSqlAstConverter.AdditionalInsertValues additionalInsertValues=sqmConverter.visitInsertionTargetPaths((assignable,columnReferences) -> {\n  final SqmPathInterpretation<?> pathInterpretation=(SqmPathInterpretation<?>)assignable;\n  final int offset=CteTable.determineModelPartStartIndex(entityDescriptor,pathInterpretation.getExpressionType());\n  if (offset == -1) {\n    throw new IllegalStateException(\"Couldn't find matching cte column for: \" + ((Expression)assignable).getExpressionType());\n  }\n  final int end=offset + pathInterpretation.getExpressionType().getJdbcTypeCount();\n  final List<CteColumn> columns=cteTable.getCteColumns().subList(offset,end);\n  insertStatement.addTargetColumnReferences(columnReferences);\n  targetPathCteColumns.addAll(columns);\n  targetPathColumns.add(new AbstractMap.SimpleEntry<>(columns,new Assignment(assignable,(Expression)assignable)));\n}\n,sqmInsertStatement,entityDescriptor,insertingTableGroup,(sqmParameter,mappingType,jdbcParameters) -> {\n  parameterResolutions.computeIfAbsent(sqmParameter,k -> new ArrayList<>(1)).add(jdbcParameters);\n  paramTypeResolutions.put(sqmParameter,mappingType);\n}\n);\nfinal boolean assignsId=targetPathCteColumns.contains(cteTable.getCteColumns().get(0));\nfinal Stack<SqlAstProcessingState> processingStateStack=sqmConverter.getProcessingStateStack();\nfinal SqlAstProcessingState oldState=processingStateStack.pop();\nfinal Statement queryStatement;\nif(sqmInsertStatement instanceof SqmInsertSelectStatement){final QueryPart queryPart=sqmConverter.visitQueryPart(((SqmInsertSelectStatement<?>)sqmInsertStatement).getSelectQueryPart());\nqueryPart.visitQuerySpecs(querySpec -> {\n  if (additionalInsertValues.applySelections(querySpec,sessionFactory)) {\n    final CteColumn rowNumberColumn=cteTable.getCteColumns().get(cteTable.getCteColumns().size() - 1);\n    final ColumnReference columnReference=new ColumnReference((String)null,rowNumberColumn.getColumnExpression(),false,null,null,rowNumberColumn.getJdbcMapping());\n    insertStatement.getTargetColumnReferences().set(insertStatement.getTargetColumnReferences().size() - 1,columnReference);\n    targetPathCteColumns.set(targetPathCteColumns.size() - 1,rowNumberColumn);\n  }\n  if (!assignsId && entityDescriptor.getIdentifierGenerator() instanceof PostInsertIdentifierGenerator) {\n    querySpec.getSelectClause().addSqlSelection(new SqlSelectionImpl(1,0,SqmInsertStrategyHelper.createRowNumberingExpression(querySpec,sessionFactory)));\n  }\n}\n);\nqueryStatement=new SelectStatement(queryPart);\n}{final List<SqmValues> sqmValuesList=((SqmInsertValuesStatement<?>)sqmInsertStatement).getValuesList();\nfinal List<Values> valuesList=new ArrayList<>(sqmValuesList.size());\nfor(SqmValues sqmValues: sqmValuesList){final Values values=sqmConverter.visitValues(sqmValues);\nadditionalInsertValues.applyValues(values);\nvaluesList.add(values);\n}final QuerySpec querySpec=new QuerySpec(true);\nfinal NavigablePath navigablePath=new NavigablePath(entityDescriptor.getRootPathName());\nfinal List<String> columnNames=new ArrayList<>(targetPathColumns.size());\nfinal String valuesAlias=insertingTableGroup.getPrimaryTableReference().getIdentificationVariable();\nfor(Map.Entry<List<CteColumn>,Assignment> entry: targetPathColumns){for(ColumnReference columnReference: entry.getValue().getAssignable().getColumnReferences()){columnNames.add(columnReference.getColumnExpression());\nquerySpec.getSelectClause().addSqlSelection(new SqlSelectionImpl(1,0,columnReference.getQualifier().equals(valuesAlias) ? columnReference : new ColumnReference(valuesAlias,columnReference.getColumnExpression(),false,null,null,columnReference.getJdbcMapping())));\n}}final ValuesTableGroup valuesTableGroup=new ValuesTableGroup(navigablePath,entityDescriptor.getEntityPersister(),valuesList,insertingTableGroup.getPrimaryTableReference().getIdentificationVariable(),columnNames,true,factory);\nquerySpec.getFromClause().addRoot(valuesTableGroup);\nqueryStatement=new SelectStatement(querySpec);\n}processingStateStack.push(oldState);\nsqmConverter.pruneTableGroupJoins();\nif(!assignsId && entityDescriptor.getIdentifierGenerator() instanceof PostInsertIdentifierGenerator){final CteColumn rowNumberColumn=cteTable.getCteColumns().get(cteTable.getCteColumns().size() - 1);\nfinal ColumnReference columnReference=new ColumnReference((String)null,rowNumberColumn.getColumnExpression(),false,null,null,rowNumberColumn.getJdbcMapping());\ninsertStatement.getTargetColumnReferences().add(columnReference);\ntargetPathCteColumns.add(rowNumberColumn);\n}final CteTable entityCteTable=createCteTable(getCteTable(),targetPathCteColumns,factory);\nfinal QuerySpec querySpec=new QuerySpec(true,1);\nfinal List<DomainResult<?>> domainResults=new ArrayList<>(1);\nfinal SelectStatement statement=new SelectStatement(querySpec,domainResults);\nfinal CteStatement entityCte;\nif(additionalInsertValues.requiresRowNumberIntermediate()){final CteTable fullEntityCteTable=getCteTable();\nfinal String baseTableName=\"base_\" + entityCteTable.getTableExpression();\nfinal CteStatement baseEntityCte=new CteStatement(entityCteTable.withName(baseTableName),queryStatement,CteMaterialization.MATERIALIZED);\nstatement.addCteStatement(baseEntityCte);\nfinal CteColumn rowNumberColumn=fullEntityCteTable.getCteColumns().get(fullEntityCteTable.getCteColumns().size() - 1);\nfinal ColumnReference rowNumberColumnReference=new ColumnReference(\"e\",rowNumberColumn.getColumnExpression(),false,null,null,rowNumberColumn.getJdbcMapping());\nfinal CteColumn idColumn=fullEntityCteTable.getCteColumns().get(0);\nfinal BasicValuedMapping idType=(BasicValuedMapping)idColumn.getJdbcMapping();\nfinal Optimizer optimizer=((OptimizableGenerator)entityDescriptor.getIdentifierGenerator()).getOptimizer();\nfinal BasicValuedMapping integerType=(BasicValuedMapping)rowNumberColumn.getJdbcMapping();\nfinal Expression rowNumberMinusOneModuloIncrement=new BinaryArithmeticExpression(new BinaryArithmeticExpression(rowNumberColumnReference,BinaryArithmeticOperator.SUBTRACT,new QueryLiteral<>(1,(BasicValuedMapping)rowNumberColumn.getJdbcMapping()),integerType),BinaryArithmeticOperator.MODULO,new QueryLiteral<>(optimizer.getIncrementSize(),integerType),integerType);\n{final QuerySpec rowsWithSequenceQuery=new QuerySpec(true);\nrowsWithSequenceQuery.getFromClause().addRoot(new CteTableGroup(new NamedTableReference(baseTableName,\"e\",false,factory)));\nrowsWithSequenceQuery.getSelectClause().addSqlSelection(new SqlSelectionImpl(1,0,rowNumberColumnReference));\nfinal String fragment=((BulkInsertionCapableIdentifierGenerator)entityDescriptor.getIdentifierGenerator()).determineBulkInsertionIdentifierGenerationSelectFragment(sessionFactory.getSqlStringGenerationContext());\nrowsWithSequenceQuery.getSelectClause().addSqlSelection(new SqlSelectionImpl(2,1,new SelfRenderingSqlFragmentExpression(fragment)));\nrowsWithSequenceQuery.applyPredicate(new ComparisonPredicate(rowNumberMinusOneModuloIncrement,ComparisonOperator.EQUAL,new QueryLiteral<>(0,integerType)));\nfinal CteTable rowsWithSequenceCteTable=new CteTable(ROW_NUMBERS_WITH_SEQUENCE_VALUE,List.of(rowNumberColumn,idColumn));\nfinal SelectStatement rowsWithSequenceStatement=new SelectStatement(rowsWithSequenceQuery);\nfinal CteStatement rowsWithSequenceCte=new CteStatement(rowsWithSequenceCteTable,rowsWithSequenceStatement,CteMaterialization.MATERIALIZED);\nstatement.addCteStatement(rowsWithSequenceCte);\n}{final QuerySpec entityQuery=new QuerySpec(true);\nfinal NavigablePath navigablePath=new NavigablePath(baseTableName);\nfinal TableGroup baseTableGroup=new TableGroupImpl(navigablePath,null,new NamedTableReference(baseTableName,\"e\",false,factory),null);\nfinal TableGroup rowsWithSequenceTableGroup=new CteTableGroup(new NamedTableReference(ROW_NUMBERS_WITH_SEQUENCE_VALUE,\"t\",false,factory));\nbaseTableGroup.addTableGroupJoin(new TableGroupJoin(rowsWithSequenceTableGroup.getNavigablePath(),SqlAstJoinType.LEFT,rowsWithSequenceTableGroup,new ComparisonPredicate(new BinaryArithmeticExpression(rowNumberColumnReference,BinaryArithmeticOperator.SUBTRACT,rowNumberMinusOneModuloIncrement,integerType),ComparisonOperator.EQUAL,new ColumnReference(\"t\",rowNumberColumn.getColumnExpression(),false,null,null,rowNumberColumn.getJdbcMapping()))));\nentityQuery.getFromClause().addRoot(baseTableGroup);\nentityQuery.getSelectClause().addSqlSelection(new SqlSelectionImpl(1,0,new BinaryArithmeticExpression(new ColumnReference(\"t\",idColumn.getColumnExpression(),false,null,null,idColumn.getJdbcMapping()),BinaryArithmeticOperator.ADD,new BinaryArithmeticExpression(rowNumberColumnReference,BinaryArithmeticOperator.SUBTRACT,new ColumnReference(\"t\",rowNumberColumn.getColumnExpression(),false,null,null,rowNumberColumn.getJdbcMapping()),integerType),idType)));\nfinal CteTable finalEntityCteTable;\nif(targetPathCteColumns.contains(getCteTable().getCteColumns().get(0))){finalEntityCteTable=entityCteTable;\n}{targetPathCteColumns.add(0,getCteTable().getCteColumns().get(0));\nfinalEntityCteTable=createCteTable(getCteTable(),targetPathCteColumns,factory);\n}final List<CteColumn> cteColumns=finalEntityCteTable.getCteColumns();\nfor(int i=1; i < cteColumns.size(); i++){final CteColumn cteColumn=cteColumns.get(i);\nentityQuery.getSelectClause().addSqlSelection(new SqlSelectionImpl(i + 1,i,new ColumnReference(\"e\",cteColumn.getColumnExpression(),false,null,null,cteColumn.getJdbcMapping())));\n}final SelectStatement entityStatement=new SelectStatement(entityQuery);\nentityCte=new CteStatement(finalEntityCteTable,entityStatement,CteMaterialization.MATERIALIZED);\nstatement.addCteStatement(entityCte);\n}}if(!assignsId && entityDescriptor.getIdentifierGenerator() instanceof PostInsertIdentifierGenerator){final String baseTableName=\"base_\" + entityCteTable.getTableExpression();\nfinal CteStatement baseEntityCte=new CteStatement(entityCteTable.withName(baseTableName),queryStatement,CteMaterialization.MATERIALIZED);\nstatement.addCteStatement(baseEntityCte);\ntargetPathCteColumns.add(0,cteTable.getCteColumns().get(0));\nfinal CteTable finalEntityCteTable=createCteTable(getCteTable(),targetPathCteColumns,factory);\nfinal QuerySpec finalQuerySpec=new QuerySpec(true);\nfinal SelectStatement finalQueryStatement=new SelectStatement(finalQuerySpec);\nentityCte=new CteStatement(finalEntityCteTable,finalQueryStatement,CteMaterialization.MATERIALIZED);\n}{entityCte=new CteStatement(entityCteTable,queryStatement,CteMaterialization.MATERIALIZED);\nstatement.addCteStatement(entityCte);\n}final String baseInsertCte=addDmlCtes(statement,entityCte,targetPathColumns,assignsId,sqmConverter,parameterResolutions,factory);\nfinal Expression count=createCountStar(factory,sqmConverter);\ndomainResults.add(new BasicResult<>(0,null,((SqlExpressible)count).getJdbcMapping()));\nquerySpec.getSelectClause().addSqlSelection(new SqlSelectionImpl(1,0,count));\nquerySpec.getFromClause().addRoot(new CteTableGroup(new NamedTableReference(baseInsertCte,CTE_TABLE_IDENTIFIER,false,factory)));\nfinal JdbcServices jdbcServices=factory.getJdbcServices();\nfinal SqlAstTranslator<JdbcSelect> translator=jdbcServices.getJdbcEnvironment().getSqlAstTranslatorFactory().buildSelectTranslator(factory,statement);\nfinal JdbcParameterBindings jdbcParameterBindings=SqmUtil.createJdbcParameterBindings(executionContext.getQueryParameterBindings(),domainParameterXref,SqmUtil.generateJdbcParamsXref(domainParameterXref,sqmConverter),factory.getRuntimeMetamodels().getMappingMetamodel(),navigablePath -> sqmConverter.getMutatingTableGroup(),new SqmParameterMappingModelResolutionAccess(){\n  @Override @SuppressWarnings(\"unchecked\") public <T>MappingModelExpressible<T> getResolvedMappingModelType(  SqmParameter<T> parameter){\n    return (MappingModelExpressible<T>)paramTypeResolutions.get(parameter);\n  }\n}\n,executionContext.getSession());\nfinal JdbcSelect select=translator.translate(jdbcParameterBindings,executionContext.getQueryOptions());\nexecutionContext.getSession().autoFlushIfRequired(select.getAffectedTableNames());\nList<Object> list=jdbcServices.getJdbcSelectExecutor().list(select,jdbcParameterBindings,SqmJdbcExecutionContextAdapter.omittingLockingAndPaging(executionContext),row -> row[0],ListResultsConsumer.UniqueSemantic.NONE);\nreturn ((Number)list.get(0)).intValue();\n}",
            "methodSignature: org.hibernate.query.sqm.mutation.internal.temptable.InsertExecutionDelegate#execute\n methodBody: public int execute(ExecutionContext executionContext) {\nExecuteWithTemporaryTableHelper.performBeforeTemporaryTableUseActions(entityTable,executionContext);\ntryif(sessionUidParameter != null){jdbcParameterBindings.addBinding(sessionUidParameter,new JdbcParameterBindingImpl(entityTable.getSessionUidColumn().getJdbcMapping(),UUID.fromString(sessionUidAccess.apply(executionContext.getSession()))));\n}final int rows=ExecuteWithTemporaryTableHelper.saveIntoTemporaryTable(insertStatement,jdbcParameterBindings,executionContext);\nif(rows != 0){final AbstractEntityPersister persister=(AbstractEntityPersister)entityDescriptor.getEntityPersister();\nfinal int tableSpan=persister.getTableSpan();\ninsertRootTable(persister.getTableName(0),rows,persister.getKeyColumns(0),executionContext);\nif(persister.hasDuplicateTables()){final String[] insertedTables=new String[tableSpan];\ninsertedTables[0]=persister.getTableName(0);\nfor(int i=1; i < tableSpan; i++){if(persister.isInverseTable(i)){continue;\n}final String tableName=persister.getTableName(i);\ninsertedTables[i]=tableName;\nif(ArrayHelper.indexOf(insertedTables,i,tableName) != -1){continue;\n}insertTable(tableName,persister.getKeyColumns(i),persister.isNullableTable(i),executionContext);\n}}{for(int i=1; i < tableSpan; i++){insertTable(persister.getTableName(i),persister.getKeyColumns(i),persister.isNullableTable(i),executionContext);\n}}}return rows;\nfinallyExecuteWithTemporaryTableHelper.performAfterTemporaryTableUseActions(entityTable,sessionUidAccess,afterUseAction,executionContext);\n}",
            "methodSignature: org.hibernate.engine.jdbc.internal.JdbcCoordinatorImpl#getResultSetReturn\n methodBody: public ResultSetReturn getResultSetReturn() {\nif(resultSetExtractor == null){resultSetExtractor=new ResultSetReturnImpl(this,jdbcServices);\n}return resultSetExtractor;\n}",
            "methodSignature: org.hibernate.engine.jdbc.batch.spi.Batch#addObserver\n methodBody: void addObserver(BatchObserver observer);",
            "methodSignature: org.hibernate.query.sqm.mutation.internal.temptable.UpdateExecutionDelegate#execute\n methodBody: public int execute(ExecutionContext executionContext) {\nExecuteWithTemporaryTableHelper.performBeforeTemporaryTableUseActions(idTable,executionContext);\ntryfinal int rows=ExecuteWithTemporaryTableHelper.saveMatchingIdsIntoIdTable(sqmConverter,suppliedPredicate,idTable,sessionUidAccess,jdbcParameterBindings,executionContext);\nfinal QuerySpec idTableSubQuery=ExecuteWithTemporaryTableHelper.createIdTableSelectQuerySpec(idTable,sessionUidAccess,entityDescriptor,executionContext);\nentityDescriptor.visitConstraintOrderedTables((tableExpression,tableKeyColumnVisitationSupplier) -> updateTable(tableExpression,tableKeyColumnVisitationSupplier,rows,idTableSubQuery,executionContext));\nreturn rows;\nfinallyExecuteWithTemporaryTableHelper.performAfterTemporaryTableUseActions(idTable,sessionUidAccess,afterUseAction,executionContext);\n}",
            "methodSignature: org.hibernate.metamodel.mapping.internal.MappingModelCreationProcess#execute\n methodBody: private void execute() {\nfor(EntityPersister entityPersister: entityPersisterMap.values()){if(entityPersister instanceof InFlightEntityMappingType){((InFlightEntityMappingType)entityPersister).linkWithSuperType(this);\n}}for(EntityPersister entityPersister: entityPersisterMap.values()){currentlyProcessingRole=entityPersister.getEntityName();\nif(entityPersister instanceof InFlightEntityMappingType){((InFlightEntityMappingType)entityPersister).prepareMappingModel(this);\n}}executePostInitCallbacks();\n}",
            "methodSignature: org.hibernate.orm.test.insertordering.InsertOrderingTest.StatsBatchBuilder#buildBatch\n methodBody: public Batch buildBatch(BatchKey key, JdbcCoordinator jdbcCoordinator) {\nreturn new StatsBatch(key,jdbcCoordinator,getJdbcBatchSize());\n}",
            "methodSignature: org.hibernate.query.sqm.mutation.internal.cte.AbstractCteMutationHandler#execute\n methodBody: public int execute(DomainQueryExecutionContext executionContext) {\nfinal SqmDeleteOrUpdateStatement sqmMutationStatement=getSqmDeleteOrUpdateStatement();\nfinal SessionFactoryImplementor factory=executionContext.getSession().getFactory();\nfinal EntityMappingType entityDescriptor=getEntityDescriptor();\nfinal String explicitDmlTargetAlias;\nif(sqmMutationStatement.getTarget().getExplicitAlias() == null){explicitDmlTargetAlias=\"dml_target\";\n}{explicitDmlTargetAlias=sqmMutationStatement.getTarget().getExplicitAlias();\n}final MultiTableSqmMutationConverter sqmConverter=new MultiTableSqmMutationConverter(entityDescriptor,sqmMutationStatement,sqmMutationStatement.getTarget(),explicitDmlTargetAlias,domainParameterXref,executionContext.getQueryOptions(),executionContext.getSession().getLoadQueryInfluencers(),executionContext.getQueryParameterBindings(),factory);\nfinal Map<SqmParameter<?>,List<JdbcParameter>> parameterResolutions;\nif(domainParameterXref.getSqmParameterCount() == 0){parameterResolutions=Collections.emptyMap();\n}{parameterResolutions=new IdentityHashMap<>();\n}final Map<SqmParameter,MappingModelExpressible> paramTypeResolutions=new LinkedHashMap<>();\nfinal Predicate restriction=sqmConverter.visitWhereClause(sqmMutationStatement.getWhereClause(),columnReference -> {\n}\n,(sqmParam,mappingType,jdbcParameters) -> paramTypeResolutions.put(sqmParam,mappingType));\nsqmConverter.pruneTableGroupJoins();\nfinal CteStatement idSelectCte=new CteStatement(getCteTable(),MatchingIdSelectionHelper.generateMatchingIdSelectStatement(entityDescriptor,sqmMutationStatement,true,restriction,sqmConverter,executionContext,factory),CteMaterialization.MATERIALIZED);\nfinal QuerySpec querySpec=new QuerySpec(true,1);\nfinal List<DomainResult<?>> domainResults=new ArrayList<>(1);\nfinal SelectStatement statement=new SelectStatement(querySpec,domainResults);\nfinal JdbcServices jdbcServices=factory.getJdbcServices();\nfinal SqlAstTranslator<JdbcSelect> translator=jdbcServices.getJdbcEnvironment().getSqlAstTranslatorFactory().buildSelectTranslator(factory,statement);\nfinal Expression count=createCountStar(factory,sqmConverter);\ndomainResults.add(new BasicResult<>(0,null,((SqlExpressible)count).getJdbcMapping()));\nquerySpec.getSelectClause().addSqlSelection(new SqlSelectionImpl(1,0,count));\nquerySpec.getFromClause().addRoot(new CteTableGroup(new NamedTableReference(idSelectCte.getCteTable().getTableExpression(),CTE_TABLE_IDENTIFIER,false,factory)));\nstatement.addCteStatement(idSelectCte);\naddDmlCtes(statement,idSelectCte,sqmConverter,parameterResolutions,factory);\nfinal JdbcParameterBindings jdbcParameterBindings=SqmUtil.createJdbcParameterBindings(executionContext.getQueryParameterBindings(),domainParameterXref,SqmUtil.generateJdbcParamsXref(domainParameterXref,sqmConverter),factory.getRuntimeMetamodels().getMappingMetamodel(),navigablePath -> sqmConverter.getMutatingTableGroup(),paramTypeResolutions::get,executionContext.getSession());\nfinal LockOptions lockOptions=executionContext.getQueryOptions().getLockOptions();\nfinal LockMode lockMode=lockOptions.getAliasSpecificLockMode(explicitDmlTargetAlias);\nlockOptions.setAliasSpecificLockMode(explicitDmlTargetAlias,LockMode.WRITE);\nfinal JdbcSelect select=translator.translate(jdbcParameterBindings,executionContext.getQueryOptions());\nlockOptions.setAliasSpecificLockMode(explicitDmlTargetAlias,lockMode);\nexecutionContext.getSession().autoFlushIfRequired(select.getAffectedTableNames());\nList<Object> list=jdbcServices.getJdbcSelectExecutor().list(select,jdbcParameterBindings,SqmJdbcExecutionContextAdapter.omittingLockingAndPaging(executionContext),row -> row[0],ListResultsConsumer.UniqueSemantic.NONE);\nreturn ((Number)list.get(0)).intValue();\n}",
            "methodSignature: org.hibernate.mapping.Component.ValueGenerationPlan#execute\n methodBody: public void execute(SharedSessionContractImplementor session, Object incomingObject, Object injectionContext) {\nfinal Object generatedValue=subGenerator.generate(session,incomingObject);\ninjector.set(injectionContext,generatedValue);\n}",
            "methodSignature: org.hibernate.query.sqm.mutation.internal.temptable.TableBasedInsertHandler.ExecutionDelegate#execute\n methodBody: int execute(ExecutionContext executionContext);",
            "methodSignature: org.hibernate.dialect.AbstractHANADialect.MaterializedNClob#setString\n methodBody: public int setString(long pos, String str) throws SQLException {\nthis.data=this.data.substring(0,(int)(pos - 1)) + str + this.data.substring((int)(pos - 1 + str.length()));\nreturn str.length();\n}",
            "methodSignature: org.hibernate.engine.jdbc.batch.internal.NonBatchingBatch#addToBatch\n methodBody: public void addToBatch() {\nnotifyObserversImplicitExecution();\nfor(Map.Entry<String,PreparedStatement> entry: getStatements().entrySet()){final String statementSQL=entry.getKey();\ntryfinal PreparedStatement statement=entry.getValue();\nfinal int rowCount=jdbcCoordinator.getResultSetReturn().executeUpdate(statement);\ngetKey().getExpectation().verifyOutcome(rowCount,statement,0,statementSQL);\njdbcCoordinator.getLogicalConnection().getResourceRegistry().release(statement);\njdbcCoordinator.afterStatementExecution();\ncatch(SQLException e)abortBatch(e);\nthrow sqlExceptionHelper().convert(e,\"could not execute non-batched batch statement\",statementSQL);\ncatch(RuntimeException e)abortBatch(e);\nthrow e;\n}getStatements().clear();\n}",
            "methodSignature: org.hibernate.engine.jdbc.internal.JdbcCoordinatorImpl#getStatementPreparer\n methodBody: public StatementPreparer getStatementPreparer() {\nif(statementPreparer == null){statementPreparer=new StatementPreparerImpl(this,jdbcServices);\n}return statementPreparer;\n}",
            "methodSignature: org.hibernate.sql.Insert#getDialect\n methodBody: protected Dialect getDialect() {\nreturn dialect;\n}",
            "methodSignature: org.hibernate.engine.jdbc.batch.internal.AbstractBatchImpl#release\n methodBody: public void release() {\nif(getStatements() != null && !getStatements().isEmpty()){LOG.batchContainedStatementsOnRelease();\n}releaseStatements();\nobservers.clear();\n}",
            "methodSignature: org.hibernate.sql.exec.internal.StandardJdbcMutationExecutor#execute\n methodBody: public int execute(\n\t\t\tJdbcMutation jdbcMutation,\n\t\t\tJdbcParameterBindings jdbcParameterBindings,\n\t\t\tFunction<String, PreparedStatement> statementCreator,\n\t\t\tBiConsumer<Integer, PreparedStatement> expectationCheck,\n\t\t\tExecutionContext executionContext) {\nfinal SharedSessionContractImplementor session=executionContext.getSession();\nsession.autoFlushIfRequired(jdbcMutation.getAffectedTableNames());\nfinal LogicalConnectionImplementor logicalConnection=session.getJdbcCoordinator().getLogicalConnection();\nfinal JdbcServices jdbcServices=session.getJdbcServices();\nfinal QueryOptions queryOptions=executionContext.getQueryOptions();\nfinal String finalSql;\nif(queryOptions == null){finalSql=jdbcMutation.getSql();\n}{finalSql=jdbcServices.getDialect().addSqlHintOrComment(jdbcMutation.getSql(),queryOptions,executionContext.getSession().getFactory().getSessionFactoryOptions().isCommentsEnabled());\n}tryfinal PreparedStatement preparedStatement=statementCreator.apply(finalSql);\ntryif(executionContext.getQueryOptions().getTimeout() != null){preparedStatement.setQueryTimeout(executionContext.getQueryOptions().getTimeout());\n}int paramBindingPosition=1;\nfor(JdbcParameterBinder parameterBinder: jdbcMutation.getParameterBinders()){parameterBinder.bindParameterValue(preparedStatement,paramBindingPosition++,jdbcParameterBindings,executionContext);\n}session.getEventListenerManager().jdbcExecuteStatementStart();\ntryint rows=preparedStatement.executeUpdate();\nexpectationCheck.accept(rows,preparedStatement);\nreturn rows;\nfinallysession.getEventListenerManager().jdbcExecuteStatementEnd();\nfinallylogicalConnection.getResourceRegistry().release(preparedStatement);\ncatch(SQLException e)throw jdbcServices.getSqlExceptionHelper().convert(e,\"JDBC exception executing SQL [\" + finalSql + \"]\");\nfinallyexecutionContext.afterStatement(logicalConnection);\n}",
            "methodSignature: org.hibernate.sql.exec.spi.JdbcMutationExecutor#execute\n methodBody: int execute(\n\t\t\tJdbcMutation jdbcMutation,\n\t\t\tJdbcParameterBindings jdbcParameterBindings,\n\t\t\tFunction<String, PreparedStatement> statementCreator,\n\t\t\tBiConsumer<Integer, PreparedStatement> expectationCheck,\n\t\t\tExecutionContext executionContext);",
            "methodSignature: org.hibernate.engine.jdbc.batch.internal.AbstractBatchImpl#addObserver\n methodBody: public void addObserver(BatchObserver observer) {\nobservers.add(observer);\n}",
            "methodSignature: org.hibernate.engine.jdbc.batch.internal.BatchingBatch#getBatchStatement\n methodBody: public PreparedStatement getBatchStatement(String sql, boolean callable) {\ncurrentStatementSql=sql;\nint previousBatchSize=getStatements().size();\ncurrentStatement=super.getBatchStatement(sql,callable);\nint currentBatchSize=getStatements().size();\nif(currentBatchSize > previousBatchSize){this.batchSize=this.configuredBatchSize * currentBatchSize;\n}return currentStatement;\n}",
            "methodSignature: org.hibernate.engine.jdbc.batch.spi.Batch#getBatchStatement\n methodBody: PreparedStatement getBatchStatement(String sql, boolean callable);",
            "methodSignature: org.hibernate.engine.jdbc.spi.JdbcCoordinator#close\n methodBody: Connection close();",
            "methodSignature: org.hibernate.engine.jdbc.batch.spi.Batch#addToBatch\n methodBody: void addToBatch();",
            "methodSignature: org.hibernate.engine.jdbc.batch.internal.BatchingBatch#addToBatch\n methodBody: public void addToBatch() {\ntrycurrentStatement.addBatch();\ncatch(SQLException e)abortBatch(e);\nLOG.debug(\"SQLException escaped proxy\",e);\nthrow sqlExceptionHelper().convert(e,\"could not perform addBatch\",currentStatementSql);\ncatch(RuntimeException e)abortBatch(e);\nthrow e;\nstatementPosition++;\nif(statementPosition >= getKey().getBatchedStatementCount()){batchPosition++;\nif(batchPosition == batchSize){notifyObserversImplicitExecution();\nperformExecution();\nbatchPosition=0;\nbatchExecuted=true;\n}statementPosition=0;\n}}",
            "methodSignature: org.hibernate.action.internal.BulkOperationCleanupAction.CollectionCleanup#release\n methodBody: private void release() {\ncacheAccess.unlockRegion(cacheLock);\n}",
            "methodSignature: org.hibernate.engine.jdbc.batch.internal.AbstractBatchImpl#execute\n methodBody: public final void execute() {\nnotifyObserversExplicitExecution();\nif(getStatements().isEmpty()){return;\n}trydoExecuteBatch();\nfinallyreleaseStatements();\n}",
            "methodSignature: org.hibernate.action.internal.BulkOperationCleanupAction.EntityCleanup#release\n methodBody: private void release() {\ncacheAccess.unlockRegion(cacheLock);\n}",
            "methodSignature: org.hibernate.sql.results.jdbc.internal.DeferredResultSetAccess#release\n methodBody: public void release() {\nif(resultSet != null){getPersistenceContext().getJdbcCoordinator().getLogicalConnection().getResourceRegistry().release(resultSet,preparedStatement);\nresultSet=null;\n}if(preparedStatement != null){getPersistenceContext().getJdbcCoordinator().getLogicalConnection().getResourceRegistry().release(preparedStatement);\npreparedStatement=null;\n}}",
            "methodSignature: org.hibernate.query.sqm.mutation.internal.temptable.RestrictedDeleteExecutionDelegate#execute\n methodBody: public int execute(DomainQueryExecutionContext executionContext) {\nfinal EntityPersister entityDescriptor=sessionFactory.getRuntimeMetamodels().getMappingMetamodel().getEntityDescriptor(sqmDelete.getTarget().getEntityName());\nfinal String hierarchyRootTableName=((Joinable)entityDescriptor).getTableName();\nfinal TableGroup deletingTableGroup=converter.getMutatingTableGroup();\nfinal TableReference hierarchyRootTableReference=deletingTableGroup.resolveTableReference(deletingTableGroup.getNavigablePath(),hierarchyRootTableName);\nassert hierarchyRootTableReference != null;\nfinal Map<SqmParameter<?>,List<List<JdbcParameter>>> parameterResolutions;\nfinal Map<SqmParameter<?>,MappingModelExpressible<?>> paramTypeResolutions;\nif(domainParameterXref.getSqmParameterCount() == 0){parameterResolutions=Collections.emptyMap();\nparamTypeResolutions=Collections.emptyMap();\n}{parameterResolutions=new IdentityHashMap<>();\nparamTypeResolutions=new LinkedHashMap<>();\n}final MutableBoolean needsIdTableWrapper=new MutableBoolean(false);\nfinal Predicate specifiedRestriction=converter.visitWhereClause(sqmDelete.getWhereClause(),columnReference -> {\n  if (!hierarchyRootTableReference.getIdentificationVariable().equals(columnReference.getQualifier())) {\n    needsIdTableWrapper.setValue(true);\n  }\n}\n,(sqmParameter,mappingType,jdbcParameters) -> {\n  parameterResolutions.computeIfAbsent(sqmParameter,k -> new ArrayList<>(1)).add(jdbcParameters);\n  paramTypeResolutions.put(sqmParameter,mappingType);\n}\n);\nfinal PredicateCollector predicateCollector=new PredicateCollector(specifiedRestriction);\nentityDescriptor.applyBaseRestrictions((filterPredicate) -> {\n  needsIdTableWrapper.setValue(true);\n  predicateCollector.applyPredicate(filterPredicate);\n}\n,deletingTableGroup,true,executionContext.getSession().getLoadQueryInfluencers().getEnabledFilters(),null,converter);\nconverter.pruneTableGroupJoins();\nfinal boolean needsIdTable=needsIdTableWrapper.getValue() || entityDescriptor != entityDescriptor.getRootEntityDescriptor();\nfinal SqmJdbcExecutionContextAdapter executionContextAdapter=SqmJdbcExecutionContextAdapter.omittingLockingAndPaging(executionContext);\nif(needsIdTable){return executeWithIdTable(predicateCollector.getPredicate(),deletingTableGroup,parameterResolutions,paramTypeResolutions,executionContextAdapter);\n}{return executeWithoutIdTable(predicateCollector.getPredicate(),deletingTableGroup,parameterResolutions,paramTypeResolutions,converter.getSqlExpressionResolver(),executionContextAdapter);\n}}",
            "methodSignature: org.hibernate.orm.test.jpa.transaction.batch.JtaWithFailingBatchTest.TestBatchBuilder#buildBatch\n methodBody: public Batch buildBatch(BatchKey key, JdbcCoordinator jdbcCoordinator) {\nreturn buildBatchTest(key,jdbcCoordinator,getJdbcBatchSize());\n}",
            "methodSignature: org.hibernate.orm.test.jpa.transaction.batch.FailingAddToBatchTest.TestBatch#getBatchStatement\n methodBody: public PreparedStatement getBatchStatement(String sql, boolean callable) {\nPreparedStatement batchStatement=super.getBatchStatement(sql,callable);\ncreatedStatements.add(batchStatement);\nreturn batchStatement;\n}",
            "methodSignature: org.hibernate.orm.test.jpa.transaction.batch.JtaWithStatementsBatchTest.TestBatchBuilder#buildBatch\n methodBody: public Batch buildBatch(BatchKey key, JdbcCoordinator jdbcCoordinator) {\nreturn buildBatchTest(key,jdbcCoordinator,getJdbcBatchSize());\n}",
            "methodSignature: org.hibernate.orm.test.manytomany.batchload.TestingBatchBuilder#buildBatch\n methodBody: public Batch buildBatch(BatchKey key, JdbcCoordinator jdbcCoordinator) {\nreturn new TestingBatch(key,jdbcCoordinator);\n}",
            "methodSignature: org.hibernate.persister.collection.AbstractCollectionPersister#getDialect\n methodBody: protected Dialect getDialect() {\nreturn dialect;\n}",
            "methodSignature: org.hibernate.engine.jdbc.spi.JdbcCoordinator#getLogicalConnection\n methodBody: LogicalConnectionImplementor getLogicalConnection();",
            "methodSignature: org.hibernate.query.sqm.mutation.internal.temptable.TableBasedInsertHandler#execute\n methodBody: public int execute(DomainQueryExecutionContext executionContext) {\nif(log.isTraceEnabled()){log.tracef(\"Starting multi-table insert execution - %s\",getSqmInsertStatement().getTarget().getModel().getName());\n}final SqmJdbcExecutionContextAdapter executionContextAdapter=SqmJdbcExecutionContextAdapter.omittingLockingAndPaging(executionContext);\nreturn resolveDelegate(executionContext).execute(executionContextAdapter);\n}",
            "methodSignature: org.hibernate.orm.test.insertordering.InsertOrderingTest.StatsBatch#getBatchStatement\n methodBody: public PreparedStatement getBatchStatement(String sql, boolean callable) {\nif(batchSQL == null || !batchSQL.equals(sql)){currentBatch++;\nbatchSQL=sql;\nbatchSizes.add(currentBatch,new Counter());\n}return super.getBatchStatement(sql,callable);\n}",
            "methodSignature: org.hibernate.engine.jdbc.spi.JdbcCoordinator#getResultSetReturn\n methodBody: ResultSetReturn getResultSetReturn();",
            "methodSignature: org.hibernate.sql.ast.spi.AbstractSqlAstTranslator#getDialect\n methodBody: public Dialect getDialect() {\nreturn dialect;\n}",
            "methodSignature: org.hibernate.engine.jdbc.batch.internal.BatchBuilderImpl#buildBatch\n methodBody: public Batch buildBatch(BatchKey key, JdbcCoordinator jdbcCoordinator) {\nreturn SharedBatchBuildingCode.buildBatch(jdbcBatchSize,key,jdbcCoordinator);\n}",
            "methodSignature: org.hibernate.orm.test.jpa.transaction.batch.FailingAddToBatchTest.TestBatchBuilder#buildBatch\n methodBody: public Batch buildBatch(BatchKey key, JdbcCoordinator jdbcCoordinator) {\nreturn buildBatchTest(key,jdbcCoordinator,getJdbcBatchSize());\n}",
            "methodSignature: org.hibernate.orm.test.jpa.transaction.batch.FailingAddToBatchTest.TestBatch#addToBatch\n methodBody: public void addToBatch() {\nRuntimeException failure=nextAddToBatchFailure.getAndSet(null);\nif(failure != null){throw failure;\n}super.addToBatch();\n}",
            "methodSignature: org.hibernate.dialect.Dialect#getDropTableString\n methodBody: public String getDropTableString(String tableName) {\nfinal StringBuilder buf=new StringBuilder(\"drop table \");\nif(supportsIfExistsBeforeTableName()){buf.append(\"if exists \");\n}buf.append(tableName).append(getCascadeConstraintsString());\nif(supportsIfExistsAfterTableName()){buf.append(\" if exists\");\n}return buf.toString();\n}",
            "methodSignature: org.hibernate.engine.jdbc.batch.internal.AbstractBatchImpl#getJdbcCoordinator\n methodBody: protected JdbcCoordinator getJdbcCoordinator(){\nreturn this.jdbcCoordinator;\n}",
            "methodSignature: org.hibernate.engine.jdbc.internal.JdbcCoordinatorImpl#sessionFactory\n methodBody: protected SessionFactoryImplementor sessionFactory() {\nreturn this.owner.getJdbcSessionContext().getSessionFactory();\n}",
            "methodSignature: org.hibernate.dialect.AbstractHANADialect.CloseSuppressingReader#close\n methodBody: public void close() {\n}",
            "methodSignature: org.hibernate.sql.ast.spi.AbstractSqlAstTranslator#getJdbcServices\n methodBody: protected JdbcServices getJdbcServices() {\nreturn getSessionFactory().getJdbcServices();\n}"
        ],
        "sourceCodeAfterRefactoring": "@Test\n\tpublic void testBatchingUsage() throws Exception {\n\t\tfinal Session session = openSession();\n\t\tfinal SessionImplementor sessionImpl = (SessionImplementor) session;\n\t\tfinal JdbcCoordinator jdbcCoordinator = sessionImpl.getJdbcCoordinator();\n\n\t\texportSandboxSchema( sessionImpl );\n\n\t\t// ok, now we can get down to it...\n\t\tTransaction txn = session.getTransaction();  // same as Session#getTransaction\n\t\ttxn.begin();\n\n\t\tfinal String insertSql = \"insert into SANDBOX_JDBC_TST( ID, NAME ) values ( ?, ? )\";\n\n\t\tfinal BatchBuilderImpl batchBuilder = new BatchBuilderImpl( 2 );\n\t\tfinal BatchKey batchKey = new BasicBatchKey( \"this\" );\n\t\tfinal Batch insertBatch = batchBuilder.buildBatch( batchKey, null, SANDBOX_TBL, sessionImpl, insertSql );\n\t\tassertThat( insertBatch ).isNotNull();\n\n\t\tfinal JournalingBatchObserver batchObserver = new JournalingBatchObserver();\n\t\tinsertBatch.addObserver( batchObserver );\n\n\t\tfinal JdbcValueBindingsImpl jdbcValueBindings = sandboxInsertValueBindings( sessionImpl );\n\n\t\t// bind values for #1 - should do nothing at the JDBC level\n\t\tjdbcValueBindings.bindValue( 1, SANDBOX_TBL, \"ID\", ParameterUsage.SET, sessionImpl );\n\t\tjdbcValueBindings.bindValue( \"name\", SANDBOX_TBL, \"NAME\", ParameterUsage.SET, sessionImpl );\n\t\tassertThat( batchObserver.getExplicitExecutionCount() ).isEqualTo( 0 );\n\t\tassertThat( batchObserver.getImplicitExecutionCount() ).isEqualTo( 0 );\n\t\tassertThat( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() ).isFalse();\n\n\t\t// add #1 to the batch - will acquire prepared statement to bind values\n\t\tinsertBatch.addToBatch( jdbcValueBindings, null );\n\t\tassertThat( batchObserver.getExplicitExecutionCount() ).isEqualTo( 0 );\n\t\tassertThat( batchObserver.getImplicitExecutionCount() ).isEqualTo( 0 );\n        assertThat( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() ).isTrue();\n\n\t\t// bind values for #2 - again, nothing at JDBC level (we have statement from earlier)\n\t\tjdbcValueBindings.bindValue( 2, SANDBOX_TBL, \"ID\", ParameterUsage.SET, sessionImpl );\n\t\tjdbcValueBindings.bindValue( \"another name\", SANDBOX_TBL, \"NAME\", ParameterUsage.SET, sessionImpl );\n\t\tassertThat( batchObserver.getExplicitExecutionCount() ).isEqualTo( 0 );\n\t\tassertThat( batchObserver.getImplicitExecutionCount() ).isEqualTo( 0 );\n\n\t\t// add #2 to the batch -\n\t\t// \t\t- uses the previous prepared statement to bind values\n\t\t//\t\t- batch size has been exceeded, trigger an implicit execution\n\t\tinsertBatch.addToBatch( jdbcValueBindings, null );\n\t\tassertThat( batchObserver.getExplicitExecutionCount() ).isEqualTo( 0 );\n\t\tassertThat( batchObserver.getImplicitExecutionCount() ).isEqualTo( 1 );\n\t\tassertThat( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() ).isTrue();\n\n\t\t// execute the batch - effectively only increments the explicit-execution counter\n\t\tinsertBatch.execute();\n\t\tassertThat( batchObserver.getExplicitExecutionCount() ).isEqualTo( 1 );\n\t\tassertThat( batchObserver.getImplicitExecutionCount() ).isEqualTo( 1 );\n\t\tassertThat( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() ).isFalse();\n\n\t\tinsertBatch.release();\n\n\t\ttxn.commit();\n\t\tsession.close();\n\t}\nprivate void exportSandboxSchema(SessionImplementor sessionImpl) {\n\t\tfinal JdbcCoordinator jdbcCoordinator = sessionImpl.getJdbcCoordinator();\n\t\tLogicalConnectionImplementor logicalConnection = jdbcCoordinator.getLogicalConnection();\n\n\t\t// set up some tables to use\n\t\tStatement statement = jdbcCoordinator.getStatementPreparer().createStatement();\n\t\tString dropSql = sessionFactory().getJdbcServices().getDialect().getDropTableString( \"SANDBOX_JDBC_TST\" );\n\t\ttry {\n\t\t\tjdbcCoordinator.getResultSetReturn().execute( statement, dropSql );\n\t\t}\n\t\tcatch ( Exception e ) {\n\t\t\t// ignore if the DB doesn't support \"if exists\" and the table doesn't exist\n\t\t}\n\t\tjdbcCoordinator.getResultSetReturn().execute( statement, \"create table SANDBOX_JDBC_TST ( ID integer, NAME varchar(100) )\" );\n\t\tassertTrue( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n\t\tassertTrue( logicalConnection.isPhysicallyConnected() );\n\t\tjdbcCoordinator.getLogicalConnection().getResourceRegistry().release( statement );\n\t\tassertFalse( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n\t\tassertTrue( logicalConnection.isPhysicallyConnected() ); // after_transaction specified\n\t}",
        "diffSourceCode": "-  102:         assertFalse( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n-  103: \n-  104: \t\tinsertBatch.release();\n-  105: \n-  106: \t\ttxn.commit();\n-  107: \t\tsession.close();\n-  108: \t}\n+  102: \t@Test\n+  103: \tpublic void testBatchingUsage() throws Exception {\n+  104: \t\tfinal Session session = openSession();\n+  105: \t\tfinal SessionImplementor sessionImpl = (SessionImplementor) session;\n+  106: \t\tfinal JdbcCoordinator jdbcCoordinator = sessionImpl.getJdbcCoordinator();\n+  107: \n+  108: \t\texportSandboxSchema( sessionImpl );\n   109: \n-  110: \t@Test\n-  111: \tpublic void testBatchingUsage() throws Exception {\n-  112: \t\tSession session = openSession();\n-  113: \t\tSessionImplementor sessionImpl = (SessionImplementor) session;\n-  114: \t\t\n-  115: \t\tfinal JdbcCoordinator jdbcCoordinator = sessionImpl.getJdbcCoordinator();\n-  116: \t\tLogicalConnectionImplementor logicalConnection = jdbcCoordinator.getLogicalConnection();\n-  117: \n-  118: \t\t// set up some tables to use\n-  119: \t\tStatement statement = jdbcCoordinator.getStatementPreparer().createStatement();\n-  120: \t\tString dropSql = sessionFactory().getJdbcServices().getDialect().getDropTableString( \"SANDBOX_JDBC_TST\" );\n-  121: \t\ttry {\n-  122: \t\t\tjdbcCoordinator.getResultSetReturn().execute( statement, dropSql );\n-  123: \t\t}\n-  124: \t\tcatch ( Exception e ) {\n-  125: \t\t\t// ignore if the DB doesn't support \"if exists\" and the table doesn't exist\n-  126: \t\t}\t\tjdbcCoordinator.getResultSetReturn().execute( statement, \"create table SANDBOX_JDBC_TST ( ID integer, NAME varchar(100) )\" );\n-  127:         assertTrue( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n-  128: \t\tassertTrue( logicalConnection.isPhysicallyConnected() );\n-  129:         jdbcCoordinator.getLogicalConnection().getResourceRegistry().release( statement );\n-  130:         assertFalse( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n-  131: \t\tassertTrue( logicalConnection.isPhysicallyConnected() ); // after_transaction specified\n+  110: \t\t// ok, now we can get down to it...\n+  111: \t\tTransaction txn = session.getTransaction();  // same as Session#getTransaction\n+  112: \t\ttxn.begin();\n+  113: \n+  114: \t\tfinal String insertSql = \"insert into SANDBOX_JDBC_TST( ID, NAME ) values ( ?, ? )\";\n+  115: \n+  116: \t\tfinal BatchBuilderImpl batchBuilder = new BatchBuilderImpl( 2 );\n+  117: \t\tfinal BatchKey batchKey = new BasicBatchKey( \"this\" );\n+  118: \t\tfinal Batch insertBatch = batchBuilder.buildBatch( batchKey, null, SANDBOX_TBL, sessionImpl, insertSql );\n+  119: \t\tassertThat( insertBatch ).isNotNull();\n+  120: \n+  121: \t\tfinal JournalingBatchObserver batchObserver = new JournalingBatchObserver();\n+  122: \t\tinsertBatch.addObserver( batchObserver );\n+  123: \n+  124: \t\tfinal JdbcValueBindingsImpl jdbcValueBindings = sandboxInsertValueBindings( sessionImpl );\n+  125: \n+  126: \t\t// bind values for #1 - should do nothing at the JDBC level\n+  127: \t\tjdbcValueBindings.bindValue( 1, SANDBOX_TBL, \"ID\", ParameterUsage.SET, sessionImpl );\n+  128: \t\tjdbcValueBindings.bindValue( \"name\", SANDBOX_TBL, \"NAME\", ParameterUsage.SET, sessionImpl );\n+  129: \t\tassertThat( batchObserver.getExplicitExecutionCount() ).isEqualTo( 0 );\n+  130: \t\tassertThat( batchObserver.getImplicitExecutionCount() ).isEqualTo( 0 );\n+  131: \t\tassertThat( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() ).isFalse();\n   132: \n-  133: \t\t// ok, now we can get down to it...\n-  134: \t\tTransaction txn = session.getTransaction();  // same as Session#getTransaction\n-  135: \t\ttxn.begin();\n-  136: \n-  137: \t\tfinal BatchBuilder batchBuilder = new BatchBuilderImpl( 2 );\n-  138: \t\tfinal BatchKey batchKey = new BasicBatchKey( \"this\", Expectations.BASIC );\n-  139: \t\tfinal Batch insertBatch = batchBuilder.buildBatch( batchKey, jdbcCoordinator );\n-  140: \t\tassertTrue( \"unexpected Batch impl\", BatchingBatch.class.isInstance( insertBatch ) );\n-  141: \n-  142: \t\tfinal JournalingBatchObserver batchObserver = new JournalingBatchObserver();\n-  143: \t\tinsertBatch.addObserver( batchObserver );\n+  133: \t\t// add #1 to the batch - will acquire prepared statement to bind values\n+  134: \t\tinsertBatch.addToBatch( jdbcValueBindings, null );\n+  135: \t\tassertThat( batchObserver.getExplicitExecutionCount() ).isEqualTo( 0 );\n+  136: \t\tassertThat( batchObserver.getImplicitExecutionCount() ).isEqualTo( 0 );\n+  137:         assertThat( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() ).isTrue();\n+  138: \n+  139: \t\t// bind values for #2 - again, nothing at JDBC level (we have statement from earlier)\n+  140: \t\tjdbcValueBindings.bindValue( 2, SANDBOX_TBL, \"ID\", ParameterUsage.SET, sessionImpl );\n+  141: \t\tjdbcValueBindings.bindValue( \"another name\", SANDBOX_TBL, \"NAME\", ParameterUsage.SET, sessionImpl );\n+  142: \t\tassertThat( batchObserver.getExplicitExecutionCount() ).isEqualTo( 0 );\n+  143: \t\tassertThat( batchObserver.getImplicitExecutionCount() ).isEqualTo( 0 );\n   144: \n-  145: \t\tfinal String insertSql = \"insert into SANDBOX_JDBC_TST( ID, NAME ) values ( ?, ? )\";\n-  146: \n-  147: \t\tPreparedStatement insert = insertBatch.getBatchStatement( insertSql, false );\n-  148: \t\tinsert.setLong( 1, 1 );\n-  149: \t\tinsert.setString( 2, \"name\" );\n-  150: \t\tassertEquals( 0, batchObserver.getExplicitExecutionCount() );\n-  151: \t\tassertEquals( 0, batchObserver.getImplicitExecutionCount() );\n-  152: \t\tinsertBatch.addToBatch();\n-  153: \t\tassertEquals( 0, batchObserver.getExplicitExecutionCount() );\n-  154: \t\tassertEquals( 0, batchObserver.getImplicitExecutionCount() );\n-  155:         assertTrue( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n-  156: \n-  157: \t\tPreparedStatement insert2 = insertBatch.getBatchStatement( insertSql, false );\n-  158: \t\tassertSame( insert, insert2 );\n-  159: \t\tinsert = insert2;\n-  160: \t\tinsert.setLong( 1, 2 );\n-  161: \t\tinsert.setString( 2, \"another name\" );\n-  162: \t\tassertEquals( 0, batchObserver.getExplicitExecutionCount() );\n-  163: \t\tassertEquals( 0, batchObserver.getImplicitExecutionCount() );\n-  164: \t\tinsertBatch.addToBatch();\n-  165: \t\tassertEquals( 0, batchObserver.getExplicitExecutionCount() );\n-  166: \t\tassertEquals( 1, batchObserver.getImplicitExecutionCount() );\n-  167:         assertTrue( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n-  168: \n-  169: \t\tinsertBatch.execute();\n-  170: \t\tassertEquals( 1, batchObserver.getExplicitExecutionCount() );\n-  171: \t\tassertEquals( 1, batchObserver.getImplicitExecutionCount() );\n-  172:         assertFalse( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n-  173: \n-  174: \t\tinsertBatch.release();\n-  175: \n-  176: \t\ttxn.commit();\n-  177: \t\tsession.close();\n-  178: \t}\n+  145: \t\t// add #2 to the batch -\n+  146: \t\t// \t\t- uses the previous prepared statement to bind values\n+  147: \t\t//\t\t- batch size has been exceeded, trigger an implicit execution\n+  148: \t\tinsertBatch.addToBatch( jdbcValueBindings, null );\n+  149: \t\tassertThat( batchObserver.getExplicitExecutionCount() ).isEqualTo( 0 );\n+  150: \t\tassertThat( batchObserver.getImplicitExecutionCount() ).isEqualTo( 1 );\n+  151: \t\tassertThat( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() ).isTrue();\n+  152: \n+  153: \t\t// execute the batch - effectively only increments the explicit-execution counter\n+  154: \t\tinsertBatch.execute();\n+  155: \t\tassertThat( batchObserver.getExplicitExecutionCount() ).isEqualTo( 1 );\n+  156: \t\tassertThat( batchObserver.getImplicitExecutionCount() ).isEqualTo( 1 );\n+  157: \t\tassertThat( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() ).isFalse();\n+  158: \n+  159: \t\tinsertBatch.release();\n+  160: \n+  161: \t\ttxn.commit();\n+  162: \t\tsession.close();\n+  163: \t}\n+  164: \n+  165: \tprivate JdbcValueBindingsImpl sandboxInsertValueBindings(SessionImplementor session) {\n+  166: \t\treturn new JdbcValueBindingsImpl(\n+  167: \t\t\t\tMutationType.INSERT,\n+  168: \t\t\t\tnull,\n+  169: \t\t\t\t(tableName, columnName, usage) -> {\n+  170: \t\t\t\t\tassert tableName.equals( SANDBOX_TBL );\n+  171: \n+  172: \t\t\t\t\tif ( columnName.equals( \"ID\" ) ) {\n+  173: \t\t\t\t\t\treturn new JdbcValueDescriptor() {\n+  174: \t\t\t\t\t\t\t@Override\n+  175: \t\t\t\t\t\t\tpublic String getColumnName() {\n+  176: \t\t\t\t\t\t\t\treturn \"ID\";\n+  177: \t\t\t\t\t\t\t}\n+  178: \n+  304: \tprivate void exportSandboxSchema(SessionImplementor sessionImpl) {\n+  305: \t\tfinal JdbcCoordinator jdbcCoordinator = sessionImpl.getJdbcCoordinator();\n+  306: \t\tLogicalConnectionImplementor logicalConnection = jdbcCoordinator.getLogicalConnection();\n+  307: \n+  308: \t\t// set up some tables to use\n+  309: \t\tStatement statement = jdbcCoordinator.getStatementPreparer().createStatement();\n+  310: \t\tString dropSql = sessionFactory().getJdbcServices().getDialect().getDropTableString( \"SANDBOX_JDBC_TST\" );\n+  311: \t\ttry {\n+  312: \t\t\tjdbcCoordinator.getResultSetReturn().execute( statement, dropSql );\n+  313: \t\t}\n+  314: \t\tcatch ( Exception e ) {\n+  315: \t\t\t// ignore if the DB doesn't support \"if exists\" and the table doesn't exist\n+  316: \t\t}\n+  317: \t\tjdbcCoordinator.getResultSetReturn().execute( statement, \"create table SANDBOX_JDBC_TST ( ID integer, NAME varchar(100) )\" );\n+  318: \t\tassertTrue( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n+  319: \t\tassertTrue( logicalConnection.isPhysicallyConnected() );\n+  320: \t\tjdbcCoordinator.getLogicalConnection().getResourceRegistry().release( statement );\n+  321: \t\tassertFalse( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n+  322: \t\tassertTrue( logicalConnection.isPhysicallyConnected() ); // after_transaction specified\n+  323: \t}\n",
        "uniqueId": "a9ac98b364ccf52bb9cb2be5324c9c983e8bd8b3_110_178_304_323_102_163",
        "moveFileExist": true,
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 11,
        "testResult": true,
        "coverageInfo": {
            "testMethod": {
                "missed": 0,
                "covered": 1
            }
        }
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprivate isQuery() : boolean extracted from public getAttributeDeclarationString() : String in class org.hibernate.processor.annotation.TypedMetaAttribute",
        "diffLocations": [
            {
                "filePath": "tooling/metamodel-generator/src/main/java/org/hibernate/processor/annotation/TypedMetaAttribute.java",
                "startLine": 42,
                "endLine": 78,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "tooling/metamodel-generator/src/main/java/org/hibernate/processor/annotation/TypedMetaAttribute.java",
                "startLine": 59,
                "endLine": 91,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "tooling/metamodel-generator/src/main/java/org/hibernate/processor/annotation/TypedMetaAttribute.java",
                "startLine": 42,
                "endLine": 44,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "@Override\n\tpublic String getAttributeDeclarationString() {\n\t\tfinal boolean isQuery = \"QUERY_\".equals(prefix);  //UGLY!\n\t\tfinal Metamodel entity = getHostingEntity();\n\t\tfinal StringBuilder declaration = new StringBuilder();\n\t\tdeclaration\n\t\t\t\t.append(\"\\n/**\")\n\t\t\t\t.append(\"\\n * The \")\n\t\t\t\t.append(isQuery ? \"query\" : \"entity graph\")\n\t\t\t\t.append(\" named {@value \")\n\t\t\t\t.append(prefix)\n\t\t\t\t.append(fieldName())\n\t\t\t\t.append(\"}\\n\");\n\t\tif ( query != null ) {\n\t\t\tdeclaration.append(\" * <pre>\");\n\t\t\tquery.lines()\n\t\t\t\t\t.forEach( line -> declaration.append(\"\\n * \").append( line ) );\n\t\t\tdeclaration.append(\"\\n * </pre>\\n\");\n\t\t}\n\t\tdeclaration\n\t\t\t\t.append(\" *\\n * @see \")\n\t\t\t\t.append(entity.getQualifiedName())\n\t\t\t\t.append(\"\\n **/\\n\")\n\t\t\t\t.append(\"public static volatile \")\n\t\t\t\t.append(entity.importType(referenceType))\n\t\t\t\t.append('<')\n\t\t\t\t.append(entity.importType(resultType))\n\t\t\t\t.append('>')\n\t\t\t\t.append(' ')\n\t\t\t\t.append('_')\n\t\t\t\t.append(nameToMethodName(getPropertyName()));\n\t\tif ( isQuery ) {\n\t\t\tdeclaration.append('_');\n\t\t}\n\t\tdeclaration.append(';');\n\t\treturn declaration.toString();\n\t}",
        "filePathBefore": "tooling/metamodel-generator/src/main/java/org/hibernate/processor/annotation/TypedMetaAttribute.java",
        "isPureRefactoring": true,
        "commitId": "f474cacf8adf8adc8929798a065d53fedeba5732",
        "packageNameBefore": "org.hibernate.processor.annotation",
        "classNameBefore": "org.hibernate.processor.annotation.TypedMetaAttribute",
        "methodNameBefore": "org.hibernate.processor.annotation.TypedMetaAttribute#getAttributeDeclarationString",
        "invokedMethod": "methodSignature: org.hibernate.processor.annotation.AnnotationMetaAttribute#getHostingEntity\n methodBody: public Metamodel getHostingEntity() {\nreturn parent;\n}\nmethodSignature: org.hibernate.processor.annotation.DataAnnotationMetaAttribute#getHostingEntity\n methodBody: public Metamodel getHostingEntity() {\nreturn parent;\n}\nmethodSignature: org.hibernate.processor.ImportContextImpl#importType\n methodBody: public String importType(String typeExpression) {\nString result=typeExpression;\nString preamble=\"\";\nif(result.startsWith(\"@\")){int index=result.lastIndexOf(' ');\nif(index > 0){preamble=result.substring(0,index + 1);\nresult=result.substring(index + 1);\n}}if(result.startsWith(\"?\")){int index=1;\nwhile(index < result.length() && isWhitespace(result.charAt(index))){index++;\n}if(index < result.length()){int nextIndex=-1;\nif(result.substring(index).startsWith(\"extends\")){nextIndex=index + 7;\n}if(result.substring(index).startsWith(\"super\")){nextIndex=index + 5;\n}if(nextIndex > 0 && nextIndex < result.length() && isWhitespace(result.charAt(nextIndex))){index=nextIndex;\nwhile(isWhitespace(result.charAt(index))){index++;\n}preamble=result.substring(0,index);\nresult=importType(result.substring(index));\n}}}String appendices=\"\";\nif(result.indexOf('<') >= 0){int startIndex=result.indexOf('<');\nint endIndex=result.lastIndexOf('>');\nappendices='<' + importTypes(result.substring(startIndex + 1,endIndex)) + '>' + result.substring(endIndex + 1);\nresult=result.substring(0,startIndex);\n}if(result.indexOf('[') >= 0){int index=result.indexOf('[');\nappendices=result.substring(index);\nresult=result.substring(0,index);\n}if(result.endsWith(\"...\")){appendices=\"...\";\nint index=result.indexOf(\"...\");\nresult=result.substring(0,index);\n}return (preamble + unqualifyName(result) + appendices).replace('$','.');\n}\nmethodSignature: org.hibernate.processor.annotation.DataAnnotationMetaAttribute#fieldName\n methodBody: private String fieldName() {\nreturn getUpperUnderscoreCaseFromLowerCamelCase(getPropertyName().replace('.','_'));\n}\nmethodSignature: org.hibernate.processor.annotation.AbstractQueryMethod#getPropertyName\n methodBody: public String getPropertyName() {\nreturn methodName;\n}\nmethodSignature: org.hibernate.processor.annotation.AnnotationMetaAttribute#toString\n methodBody: public String toString() {\nreturn new StringBuilder().append(\"AnnotationMetaAttribute\").append(\"{element=\").append(element).append(\", type='\").append(type).append('\\'').append('}').toString();\n}\nmethodSignature: org.hibernate.processor.annotation.DataAnnotationMetaAttribute#getPropertyName\n methodBody: public String getPropertyName() {\nfinal String propertyName=propertyName(parent,element);\nreturn path == null ? propertyName : path + '.' + propertyName;\n}\nmethodSignature: org.hibernate.processor.annotation.DataAnnotationMetaAttribute#toString\n methodBody: public String toString() {\nreturn new StringBuilder().append(\"DataAnnotationMetaAttribute\").append(\"{element=\").append(element).append(\", type='\").append(type).append('\\'').append('}').toString();\n}\nmethodSignature: org.hibernate.processor.annotation.AnnotationMetaAttribute#getPropertyName\n methodBody: public String getPropertyName() {\nreturn propertyName(parent,element);\n}\nmethodSignature: org.hibernate.processor.annotation.AnnotationMetaType#getPropertyName\n methodBody: public String getPropertyName() {\nreturn \"class\";\n}\nmethodSignature: org.hibernate.processor.annotation.AnnotationMetaType#getHostingEntity\n methodBody: public Metamodel getHostingEntity() {\nreturn annotationMetaEntity;\n}",
        "classSignatureBefore": "class TypedMetaAttribute extends NameMetaAttribute ",
        "methodNameBeforeSet": [
            "org.hibernate.processor.annotation.TypedMetaAttribute#getAttributeDeclarationString"
        ],
        "classNameBeforeSet": [
            "org.hibernate.processor.annotation.TypedMetaAttribute"
        ],
        "classSignatureBeforeSet": [
            "class TypedMetaAttribute extends NameMetaAttribute "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * SPDX-License-Identifier: LGPL-2.1-or-later\n * Copyright Red Hat Inc. and Hibernate Authors\n */\npackage org.hibernate.processor.annotation;\n\nimport org.checkerframework.checker.nullness.qual.Nullable;\nimport org.hibernate.processor.model.Metamodel;\n\nimport static org.hibernate.processor.util.StringUtil.nameToMethodName;\n\n/**\n * Represents a named query or named entity graph.\n *\n * @author Gavin King\n */\nclass TypedMetaAttribute extends NameMetaAttribute {\n\tprivate final String prefix;\n\tprivate final String resultType;\n\tprivate final String referenceType;\n\tprivate final @Nullable String query;\n\n\tpublic TypedMetaAttribute(\n\t\t\tMetamodel annotationMetaEntity,\n\t\t\tString name,\n\t\t\tString prefix,\n\t\t\tString resultType,\n\t\t\tString referenceType,\n\t\t\t@Nullable String query) {\n\t\tsuper( annotationMetaEntity, name, prefix );\n\t\tthis.prefix = prefix;\n\t\tthis.resultType = resultType;\n\t\tthis.referenceType = referenceType;\n\t\tthis.query = query;\n\t}\n\n\t@Override\n\tpublic boolean hasTypedAttribute() {\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic String getAttributeDeclarationString() {\n\t\tfinal boolean isQuery = \"QUERY_\".equals(prefix);  //UGLY!\n\t\tfinal Metamodel entity = getHostingEntity();\n\t\tfinal StringBuilder declaration = new StringBuilder();\n\t\tdeclaration\n\t\t\t\t.append(\"\\n/**\")\n\t\t\t\t.append(\"\\n * The \")\n\t\t\t\t.append(isQuery ? \"query\" : \"entity graph\")\n\t\t\t\t.append(\" named {@value \")\n\t\t\t\t.append(prefix)\n\t\t\t\t.append(fieldName())\n\t\t\t\t.append(\"}\\n\");\n\t\tif ( query != null ) {\n\t\t\tdeclaration.append(\" * <pre>\");\n\t\t\tquery.lines()\n\t\t\t\t\t.forEach( line -> declaration.append(\"\\n * \").append( line ) );\n\t\t\tdeclaration.append(\"\\n * </pre>\\n\");\n\t\t}\n\t\tdeclaration\n\t\t\t\t.append(\" *\\n * @see \")\n\t\t\t\t.append(entity.getQualifiedName())\n\t\t\t\t.append(\"\\n **/\\n\")\n\t\t\t\t.append(\"public static volatile \")\n\t\t\t\t.append(entity.importType(referenceType))\n\t\t\t\t.append('<')\n\t\t\t\t.append(entity.importType(resultType))\n\t\t\t\t.append('>')\n\t\t\t\t.append(' ')\n\t\t\t\t.append('_')\n\t\t\t\t.append(nameToMethodName(getPropertyName()));\n\t\tif ( isQuery ) {\n\t\t\tdeclaration.append('_');\n\t\t}\n\t\tdeclaration.append(';');\n\t\treturn declaration.toString();\n\t}\n}\n",
        "filePathAfter": "tooling/metamodel-generator/src/main/java/org/hibernate/processor/annotation/TypedMetaAttribute.java",
        "sourceCodeAfterForWhole": "/*\n * SPDX-License-Identifier: LGPL-2.1-or-later\n * Copyright Red Hat Inc. and Hibernate Authors\n */\npackage org.hibernate.processor.annotation;\n\nimport org.checkerframework.checker.nullness.qual.Nullable;\nimport org.hibernate.processor.model.Metamodel;\n\nimport static org.hibernate.processor.util.StringUtil.nameToMethodName;\n\n/**\n * Represents a named query or named entity graph.\n *\n * @author Gavin King\n */\nclass TypedMetaAttribute extends NameMetaAttribute {\n\tprivate final String prefix;\n\tprivate final String resultType;\n\tprivate final String referenceType;\n\tprivate final @Nullable String query;\n\n\tpublic TypedMetaAttribute(\n\t\t\tMetamodel annotationMetaEntity,\n\t\t\tString name,\n\t\t\tString prefix,\n\t\t\tString resultType,\n\t\t\tString referenceType,\n\t\t\t@Nullable String query) {\n\t\tsuper( annotationMetaEntity, name, prefix );\n\t\tthis.prefix = prefix;\n\t\tthis.resultType = resultType;\n\t\tthis.referenceType = referenceType;\n\t\tthis.query = query;\n\t}\n\n\t@Override\n\tpublic boolean hasTypedAttribute() {\n\t\treturn true;\n\t}\n\n\tprivate boolean isQuery() {\n\t\treturn \"QUERY_\".equals(prefix);  //UGLY!\n\t}\n\n\t@Override\n\tpublic String getAttributeNameDeclarationString() {\n\t\tStringBuilder declaration = new StringBuilder();\n\t\tdeclaration\n\t\t\t\t.append(\"\\n/**\\n * @see \")\n\t\t\t\t.append(\"#\");\n\t\tappendFieldName( declaration, isQuery() );\n\t\treturn declaration\n\t\t\t\t.append( \"\\n **/\\n\" )\n\t\t\t\t.append(super.getAttributeNameDeclarationString())\n\t\t\t\t.toString();\n\t}\n\n\t@Override\n\tpublic String getAttributeDeclarationString() {\n\t\tfinal boolean isQuery = isQuery();\n\t\tfinal Metamodel entity = getHostingEntity();\n\t\tfinal StringBuilder declaration = new StringBuilder();\n\t\tdeclaration\n\t\t\t\t.append(\"\\n/**\")\n\t\t\t\t.append(\"\\n * The \")\n\t\t\t\t.append(isQuery ? \"query\" : \"entity graph\")\n\t\t\t\t.append(\" named {@value \")\n\t\t\t\t.append(prefix)\n\t\t\t\t.append(fieldName())\n\t\t\t\t.append(\"}\\n\");\n\t\tif ( query != null ) {\n\t\t\tdeclaration.append(\" * <pre>\");\n\t\t\tquery.lines()\n\t\t\t\t\t.forEach( line -> declaration.append(\"\\n * \").append( line ) );\n\t\t\tdeclaration.append(\"\\n * </pre>\\n\");\n\t\t}\n\t\tdeclaration\n\t\t\t\t.append(\" *\\n * @see \")\n\t\t\t\t.append(entity.getQualifiedName())\n\t\t\t\t.append(\"\\n **/\\n\")\n\t\t\t\t.append(\"public static volatile \")\n\t\t\t\t.append(entity.importType(referenceType))\n\t\t\t\t.append('<')\n\t\t\t\t.append(entity.importType(resultType))\n\t\t\t\t.append('>')\n\t\t\t\t.append(' ');\n\t\tappendFieldName( declaration, isQuery );\n\t\tdeclaration.append(';');\n\t\treturn declaration.toString();\n\t}\n\n\tprivate void appendFieldName(StringBuilder declaration, boolean isQuery) {\n\t\tdeclaration\n\t\t\t\t.append('_')\n\t\t\t\t.append(nameToMethodName(getPropertyName()));\n\t\tif ( isQuery ) {\n\t\t\tdeclaration.append('_');\n\t\t}\n\t}\n}\n",
        "diffSourceCodeSet": [
            "private boolean isQuery() {\n\t\treturn \"QUERY_\".equals(prefix);  //UGLY!\n\t}"
        ],
        "invokedMethodSet": [
            "methodSignature: org.hibernate.processor.annotation.AnnotationMetaAttribute#getHostingEntity\n methodBody: public Metamodel getHostingEntity() {\nreturn parent;\n}",
            "methodSignature: org.hibernate.processor.annotation.DataAnnotationMetaAttribute#getHostingEntity\n methodBody: public Metamodel getHostingEntity() {\nreturn parent;\n}",
            "methodSignature: org.hibernate.processor.ImportContextImpl#importType\n methodBody: public String importType(String typeExpression) {\nString result=typeExpression;\nString preamble=\"\";\nif(result.startsWith(\"@\")){int index=result.lastIndexOf(' ');\nif(index > 0){preamble=result.substring(0,index + 1);\nresult=result.substring(index + 1);\n}}if(result.startsWith(\"?\")){int index=1;\nwhile(index < result.length() && isWhitespace(result.charAt(index))){index++;\n}if(index < result.length()){int nextIndex=-1;\nif(result.substring(index).startsWith(\"extends\")){nextIndex=index + 7;\n}if(result.substring(index).startsWith(\"super\")){nextIndex=index + 5;\n}if(nextIndex > 0 && nextIndex < result.length() && isWhitespace(result.charAt(nextIndex))){index=nextIndex;\nwhile(isWhitespace(result.charAt(index))){index++;\n}preamble=result.substring(0,index);\nresult=importType(result.substring(index));\n}}}String appendices=\"\";\nif(result.indexOf('<') >= 0){int startIndex=result.indexOf('<');\nint endIndex=result.lastIndexOf('>');\nappendices='<' + importTypes(result.substring(startIndex + 1,endIndex)) + '>' + result.substring(endIndex + 1);\nresult=result.substring(0,startIndex);\n}if(result.indexOf('[') >= 0){int index=result.indexOf('[');\nappendices=result.substring(index);\nresult=result.substring(0,index);\n}if(result.endsWith(\"...\")){appendices=\"...\";\nint index=result.indexOf(\"...\");\nresult=result.substring(0,index);\n}return (preamble + unqualifyName(result) + appendices).replace('$','.');\n}",
            "methodSignature: org.hibernate.processor.annotation.DataAnnotationMetaAttribute#fieldName\n methodBody: private String fieldName() {\nreturn getUpperUnderscoreCaseFromLowerCamelCase(getPropertyName().replace('.','_'));\n}",
            "methodSignature: org.hibernate.processor.annotation.AbstractQueryMethod#getPropertyName\n methodBody: public String getPropertyName() {\nreturn methodName;\n}",
            "methodSignature: org.hibernate.processor.annotation.AnnotationMetaAttribute#toString\n methodBody: public String toString() {\nreturn new StringBuilder().append(\"AnnotationMetaAttribute\").append(\"{element=\").append(element).append(\", type='\").append(type).append('\\'').append('}').toString();\n}",
            "methodSignature: org.hibernate.processor.annotation.DataAnnotationMetaAttribute#getPropertyName\n methodBody: public String getPropertyName() {\nfinal String propertyName=propertyName(parent,element);\nreturn path == null ? propertyName : path + '.' + propertyName;\n}",
            "methodSignature: org.hibernate.processor.annotation.DataAnnotationMetaAttribute#toString\n methodBody: public String toString() {\nreturn new StringBuilder().append(\"DataAnnotationMetaAttribute\").append(\"{element=\").append(element).append(\", type='\").append(type).append('\\'').append('}').toString();\n}",
            "methodSignature: org.hibernate.processor.annotation.AnnotationMetaAttribute#getPropertyName\n methodBody: public String getPropertyName() {\nreturn propertyName(parent,element);\n}",
            "methodSignature: org.hibernate.processor.annotation.AnnotationMetaType#getPropertyName\n methodBody: public String getPropertyName() {\nreturn \"class\";\n}",
            "methodSignature: org.hibernate.processor.annotation.AnnotationMetaType#getHostingEntity\n methodBody: public Metamodel getHostingEntity() {\nreturn annotationMetaEntity;\n}"
        ],
        "sourceCodeAfterRefactoring": "@Override\n\tpublic String getAttributeDeclarationString() {\n\t\tfinal boolean isQuery = isQuery();\n\t\tfinal Metamodel entity = getHostingEntity();\n\t\tfinal StringBuilder declaration = new StringBuilder();\n\t\tdeclaration\n\t\t\t\t.append(\"\\n/**\")\n\t\t\t\t.append(\"\\n * The \")\n\t\t\t\t.append(isQuery ? \"query\" : \"entity graph\")\n\t\t\t\t.append(\" named {@value \")\n\t\t\t\t.append(prefix)\n\t\t\t\t.append(fieldName())\n\t\t\t\t.append(\"}\\n\");\n\t\tif ( query != null ) {\n\t\t\tdeclaration.append(\" * <pre>\");\n\t\t\tquery.lines()\n\t\t\t\t\t.forEach( line -> declaration.append(\"\\n * \").append( line ) );\n\t\t\tdeclaration.append(\"\\n * </pre>\\n\");\n\t\t}\n\t\tdeclaration\n\t\t\t\t.append(\" *\\n * @see \")\n\t\t\t\t.append(entity.getQualifiedName())\n\t\t\t\t.append(\"\\n **/\\n\")\n\t\t\t\t.append(\"public static volatile \")\n\t\t\t\t.append(entity.importType(referenceType))\n\t\t\t\t.append('<')\n\t\t\t\t.append(entity.importType(resultType))\n\t\t\t\t.append('>')\n\t\t\t\t.append(' ');\n\t\tappendFieldName( declaration, isQuery );\n\t\tdeclaration.append(';');\n\t\treturn declaration.toString();\n\t}\nprivate boolean isQuery() {\n\t\treturn \"QUERY_\".equals(prefix);  //UGLY!\n\t}",
        "diffSourceCode": "-   42: \t@Override\n-   43: \tpublic String getAttributeDeclarationString() {\n-   44: \t\tfinal boolean isQuery = \"QUERY_\".equals(prefix);  //UGLY!\n-   45: \t\tfinal Metamodel entity = getHostingEntity();\n-   46: \t\tfinal StringBuilder declaration = new StringBuilder();\n-   47: \t\tdeclaration\n-   48: \t\t\t\t.append(\"\\n/**\")\n-   49: \t\t\t\t.append(\"\\n * The \")\n-   50: \t\t\t\t.append(isQuery ? \"query\" : \"entity graph\")\n-   51: \t\t\t\t.append(\" named {@value \")\n-   52: \t\t\t\t.append(prefix)\n-   53: \t\t\t\t.append(fieldName())\n-   54: \t\t\t\t.append(\"}\\n\");\n-   55: \t\tif ( query != null ) {\n-   56: \t\t\tdeclaration.append(\" * <pre>\");\n-   57: \t\t\tquery.lines()\n-   58: \t\t\t\t\t.forEach( line -> declaration.append(\"\\n * \").append( line ) );\n-   59: \t\t\tdeclaration.append(\"\\n * </pre>\\n\");\n-   60: \t\t}\n-   61: \t\tdeclaration\n-   62: \t\t\t\t.append(\" *\\n * @see \")\n-   63: \t\t\t\t.append(entity.getQualifiedName())\n-   64: \t\t\t\t.append(\"\\n **/\\n\")\n-   65: \t\t\t\t.append(\"public static volatile \")\n-   66: \t\t\t\t.append(entity.importType(referenceType))\n-   67: \t\t\t\t.append('<')\n-   68: \t\t\t\t.append(entity.importType(resultType))\n-   69: \t\t\t\t.append('>')\n-   70: \t\t\t\t.append(' ')\n-   71: \t\t\t\t.append('_')\n-   72: \t\t\t\t.append(nameToMethodName(getPropertyName()));\n-   73: \t\tif ( isQuery ) {\n-   74: \t\t\tdeclaration.append('_');\n-   75: \t\t}\n-   76: \t\tdeclaration.append(';');\n-   77: \t\treturn declaration.toString();\n-   78: \t}\n-   79: }\n+   42: \tprivate boolean isQuery() {\n+   43: \t\treturn \"QUERY_\".equals(prefix);  //UGLY!\n+   44: \t}\n+   45: \n+   46: \t@Override\n+   47: \tpublic String getAttributeNameDeclarationString() {\n+   48: \t\tStringBuilder declaration = new StringBuilder();\n+   49: \t\tdeclaration\n+   50: \t\t\t\t.append(\"\\n/**\\n * @see \")\n+   51: \t\t\t\t.append(\"#\");\n+   52: \t\tappendFieldName( declaration, isQuery() );\n+   53: \t\treturn declaration\n+   54: \t\t\t\t.append( \"\\n **/\\n\" )\n+   55: \t\t\t\t.append(super.getAttributeNameDeclarationString())\n+   56: \t\t\t\t.toString();\n+   57: \t}\n+   58: \n+   59: \t@Override\n+   60: \tpublic String getAttributeDeclarationString() {\n+   61: \t\tfinal boolean isQuery = isQuery();\n+   62: \t\tfinal Metamodel entity = getHostingEntity();\n+   63: \t\tfinal StringBuilder declaration = new StringBuilder();\n+   64: \t\tdeclaration\n+   65: \t\t\t\t.append(\"\\n/**\")\n+   66: \t\t\t\t.append(\"\\n * The \")\n+   67: \t\t\t\t.append(isQuery ? \"query\" : \"entity graph\")\n+   68: \t\t\t\t.append(\" named {@value \")\n+   69: \t\t\t\t.append(prefix)\n+   70: \t\t\t\t.append(fieldName())\n+   71: \t\t\t\t.append(\"}\\n\");\n+   72: \t\tif ( query != null ) {\n+   73: \t\t\tdeclaration.append(\" * <pre>\");\n+   74: \t\t\tquery.lines()\n+   75: \t\t\t\t\t.forEach( line -> declaration.append(\"\\n * \").append( line ) );\n+   76: \t\t\tdeclaration.append(\"\\n * </pre>\\n\");\n+   77: \t\t}\n+   78: \t\tdeclaration\n+   79: \t\t\t\t.append(\" *\\n * @see \")\n+   80: \t\t\t\t.append(entity.getQualifiedName())\n+   81: \t\t\t\t.append(\"\\n **/\\n\")\n+   82: \t\t\t\t.append(\"public static volatile \")\n+   83: \t\t\t\t.append(entity.importType(referenceType))\n+   84: \t\t\t\t.append('<')\n+   85: \t\t\t\t.append(entity.importType(resultType))\n+   86: \t\t\t\t.append('>')\n+   87: \t\t\t\t.append(' ');\n+   88: \t\tappendFieldName( declaration, isQuery );\n+   89: \t\tdeclaration.append(';');\n+   90: \t\treturn declaration.toString();\n+   91: \t}\n",
        "uniqueId": "f474cacf8adf8adc8929798a065d53fedeba5732_42_78_42_44_59_91",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 0,
                "covered": 97
            },
            "BRANCH": {
                "missed": 0,
                "covered": 6
            },
            "LINE": {
                "missed": 0,
                "covered": 32
            },
            "COMPLEXITY": {
                "missed": 0,
                "covered": 4
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 21
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprivate createRegistryWithMetadataAccessDisabledAndDialect(dialectClass Class<?>) : StandardServiceRegistry extracted from package testAccessDisabledExplicitDialect(productName String, dialectClass Class<?>, expectedDatabaseVersion DatabaseVersion) : void in class org.hibernate.orm.test.boot.database.metadata.MetadataAccessTests",
        "diffLocations": [
            {
                "filePath": "hibernate-core/src/test/java/org/hibernate/orm/test/boot/database/metadata/MetadataAccessTests.java",
                "startLine": 135,
                "endLine": 156,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/test/java/org/hibernate/orm/test/boot/database/metadata/MetadataAccessTests.java",
                "startLine": 142,
                "endLine": 155,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/test/java/org/hibernate/orm/test/boot/database/metadata/MetadataAccessTests.java",
                "startLine": 157,
                "endLine": 167,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "@ParameterizedTest\n\t@MethodSource(\"dialects\")\n\tvoid testAccessDisabledExplicitDialect(String productName, Class<?> dialectClass, DatabaseVersion expectedDatabaseVersion) {\n\t\tfinal StandardServiceRegistryBuilder registryBuilder = new StandardServiceRegistryBuilder();\n\t\tregistryBuilder.clearSettings();\n\n\t\tregistryBuilder.applySetting( JdbcSettings.ALLOW_METADATA_ON_BOOT, false );\n\t\tregistryBuilder.applySetting( JdbcSettings.DIALECT, dialectClass.getName() );\n\t\tassertThat( registryBuilder.getSettings() )\n\t\t\t\t.doesNotContainKeys( JdbcSettings.JAKARTA_HBM2DDL_DB_NAME );\n\n\t\ttry (StandardServiceRegistry registry = registryBuilder.build()) {\n\t\t\tfinal JdbcEnvironment jdbcEnvironment = registry.getService( JdbcEnvironment.class );\n\t\t\tfinal Dialect dialect = jdbcEnvironment.getDialect();\n\t\t\tassertThat( dialect ).isInstanceOf( dialectClass );\n\t\t\tassertThat( dialect.getVersion() ).isEqualTo( expectedDatabaseVersion );\n\t\t}\n\n\t\tassertThat( triggerable.triggerMessages() )\n\t\t\t\t.as( triggerable.toString() )\n\t\t\t\t.isEmpty();\n\t}",
        "filePathBefore": "hibernate-core/src/test/java/org/hibernate/orm/test/boot/database/metadata/MetadataAccessTests.java",
        "isPureRefactoring": true,
        "commitId": "4b33d0d067010d484702d6ee910aaa3b4584c69b",
        "packageNameBefore": "org.hibernate.orm.test.boot.database.metadata",
        "classNameBefore": "org.hibernate.orm.test.boot.database.metadata.MetadataAccessTests",
        "methodNameBefore": "org.hibernate.orm.test.boot.database.metadata.MetadataAccessTests#testAccessDisabledExplicitDialect",
        "invokedMethod": "methodSignature: org.hibernate.dialect.HANADialect.HANANClobJdbcType#toString\n methodBody: public String toString() {\nreturn \"HANANClobTypeDescriptor\";\n}\nmethodSignature: org.hibernate.dialect.HANADialect.HANAClobJdbcType#toString\n methodBody: public String toString() {\nreturn \"HANAClobTypeDescriptor\";\n}\nmethodSignature: org.hibernate.testing.orm.junit.DialectContext#getDialect\n methodBody: public static synchronized Dialect getDialect() {\nif(dialect == null){init();\n}return dialect;\n}\nmethodSignature: org.hibernate.dialect.Dialect#toString\n methodBody: public String toString() {\nreturn getClass().getName() + \", version: \" + getVersion();\n}\nmethodSignature: org.hibernate.dialect.HANADialect.HANABlobType#toString\n methodBody: public String toString() {\nreturn \"HANABlobType\";\n}\nmethodSignature: org.hibernate.dialect.SimpleDatabaseVersion#toString\n methodBody: public String toString() {\nStringBuilder version=new StringBuilder();\nif(major != NO_VERSION){version.append(major);\n}if(minor != NO_VERSION){version.append(\".\");\nversion.append(minor);\nif(micro > 0){version.append(\".\");\nversion.append(micro);\n}}return version.toString();\n}\nmethodSignature: org.hibernate.dialect.Dialect#getVersion\n methodBody: public DatabaseVersion getVersion() {\nreturn version;\n}\nmethodSignature: org.hibernate.dialect.HANADialect.HANAStreamBlobType#toString\n methodBody: public String toString() {\nreturn \"HANAStreamBlobType\";\n}",
        "classSignatureBefore": "public class MetadataAccessTests ",
        "methodNameBeforeSet": [
            "org.hibernate.orm.test.boot.database.metadata.MetadataAccessTests#testAccessDisabledExplicitDialect"
        ],
        "classNameBeforeSet": [
            "org.hibernate.orm.test.boot.database.metadata.MetadataAccessTests"
        ],
        "classSignatureBeforeSet": [
            "public class MetadataAccessTests "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n * See the lgpl.txt file in the root directory or http://www.gnu.org/licenses/lgpl-2.1.html.\n */\npackage org.hibernate.orm.test.boot.database.metadata;\n\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.hibernate.dialect.SimpleDatabaseVersion.ZERO_VERSION;\nimport static org.junit.jupiter.api.Assertions.fail;\n\nimport java.lang.invoke.MethodHandles;\nimport java.lang.reflect.Field;\nimport java.util.stream.Stream;\n\nimport org.hibernate.HibernateException;\nimport org.hibernate.boot.registry.StandardServiceRegistry;\nimport org.hibernate.boot.registry.StandardServiceRegistryBuilder;\nimport org.hibernate.cfg.AvailableSettings;\nimport org.hibernate.cfg.JdbcSettings;\nimport org.hibernate.dialect.DB2Dialect;\nimport org.hibernate.dialect.DatabaseVersion;\nimport org.hibernate.dialect.Dialect;\nimport org.hibernate.dialect.H2Dialect;\nimport org.hibernate.dialect.HANADialect;\nimport org.hibernate.dialect.HSQLDialect;\nimport org.hibernate.dialect.MariaDBDialect;\nimport org.hibernate.dialect.MySQLDialect;\nimport org.hibernate.dialect.OracleDialect;\nimport org.hibernate.dialect.PostgreSQLDialect;\nimport org.hibernate.dialect.PostgresPlusDialect;\nimport org.hibernate.dialect.SQLServerDialect;\nimport org.hibernate.dialect.SpannerDialect;\nimport org.hibernate.dialect.SybaseDialect;\nimport org.hibernate.engine.jdbc.env.spi.JdbcEnvironment;\nimport org.hibernate.internal.CoreMessageLogger;\nimport org.hibernate.service.spi.ServiceException;\n\nimport org.hibernate.testing.env.TestingDatabaseInfo;\nimport org.hibernate.testing.logger.Triggerable;\nimport org.hibernate.testing.orm.junit.Jira;\nimport org.hibernate.testing.orm.logger.LoggerInspectionExtension;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.extension.RegisterExtension;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.Arguments;\nimport org.junit.jupiter.params.provider.MethodSource;\n\nimport org.jboss.logging.Logger;\n\n/**\n * @author Steve Ebersole\n */\n@Jira( \"https://hibernate.atlassian.net/browse/HHH-17269\" )\npublic class MetadataAccessTests {\n\n\tprivate Triggerable triggerable;\n\n\t@RegisterExtension\n\tpublic LoggerInspectionExtension logger = LoggerInspectionExtension\n\t\t\t.builder().setLogger(\n\t\t\t\t\tLogger.getMessageLogger( MethodHandles.lookup(), CoreMessageLogger.class, Dialect.class.getName() )\n\t\t\t).build();\n\n\t@BeforeEach\n\tpublic void setUp() {\n\t\ttriggerable = logger.watchForLogMessages( \"HHH000511\" );\n\t\ttriggerable.reset();\n\t}\n\n\t@Test\n\tvoid testAccessAllowed() {\n\t\tfinal StandardServiceRegistryBuilder registryBuilder = new StandardServiceRegistryBuilder();\n\t\tregistryBuilder.clearSettings();\n\n\t\t// allow access to the jdbc metadata\n\t\tregistryBuilder.applySetting( JdbcSettings.ALLOW_METADATA_ON_BOOT, true );\n\n\t\t// configure the values needed to connect to a H2 database\n\t\tregistryBuilder.applySetting( AvailableSettings.JAKARTA_JDBC_DRIVER, TestingDatabaseInfo.DRIVER );\n\t\tregistryBuilder.applySetting( AvailableSettings.JAKARTA_JDBC_URL, TestingDatabaseInfo.URL );\n\t\tregistryBuilder.applySetting( AvailableSettings.JAKARTA_JDBC_USER, TestingDatabaseInfo.USER );\n\t\tregistryBuilder.applySetting( AvailableSettings.JAKARTA_JDBC_PASSWORD, TestingDatabaseInfo.PASS );\n\n\t\t// make certain there is no explicit dialect configured\n\t\tassertThat( registryBuilder.getSettings() )\n\t\t\t\t.doesNotContainKeys( JdbcSettings.DIALECT, JdbcSettings.JAKARTA_HBM2DDL_DB_NAME );\n\n\t\ttry (StandardServiceRegistry registry = registryBuilder.build()) {\n\t\t\tfinal JdbcEnvironment jdbcEnvironment = registry.getService( JdbcEnvironment.class );\n\t\t\tfinal Dialect dialect = jdbcEnvironment.getDialect();\n\t\t\tassertThat( dialect ).isNotNull();\n\t\t\tassertThat( dialect ).isInstanceOf( H2Dialect.class );\n\t\t}\n\n\t\tassertThat( triggerable.triggerMessages() )\n\t\t\t\t.as( triggerable.toString() )\n\t\t\t\t.isEmpty();\n\t}\n\n\tstatic Stream<Arguments> dialects() {\n\t\treturn Stream.of(\n\t\t\t\tArguments.of( \"DB2\", DB2Dialect.class,\n\t\t\t\t\t\tgetVersionConstant( DB2Dialect.class, \"MINIMUM_VERSION\") ),\n\t\t\t\tArguments.of( \"EnterpriseDB\", PostgresPlusDialect.class,\n\t\t\t\t\t\tgetVersionConstant( PostgreSQLDialect.class, \"MINIMUM_VERSION\") ),\n\t\t\t\tArguments.of( \"H2\", H2Dialect.class,\n\t\t\t\t\t\tgetVersionConstant( H2Dialect.class, \"MINIMUM_VERSION\") ),\n\t\t\t\tArguments.of( \"HSQL Database Engine\", HSQLDialect.class,\n\t\t\t\t\t\tgetVersionConstant( HSQLDialect.class, \"MINIMUM_VERSION\") ),\n\t\t\t\tArguments.of( \"HDB\", HANADialect.class,\n\t\t\t\t\t\tgetVersionConstant( HANADialect.class, \"MINIMUM_VERSION\") ),\n\t\t\t\tArguments.of( \"MariaDB\", MariaDBDialect.class,\n\t\t\t\t\t\tgetVersionConstant( MariaDBDialect.class, \"MINIMUM_VERSION\") ),\n\t\t\t\tArguments.of( \"MySQL\", MySQLDialect.class,\n\t\t\t\t\t\tgetVersionConstant( MySQLDialect.class, \"MINIMUM_VERSION\") ),\n\t\t\t\tArguments.of( \"Oracle\", OracleDialect.class,\n\t\t\t\t\t\tgetVersionConstant( OracleDialect.class, \"MINIMUM_VERSION\") ),\n\t\t\t\tArguments.of( \"PostgreSQL\", PostgreSQLDialect.class,\n\t\t\t\t\t\tgetVersionConstant( PostgreSQLDialect.class, \"MINIMUM_VERSION\") ),\n\t\t\t\tArguments.of( \"Google Cloud Spanner\", SpannerDialect.class, ZERO_VERSION ),\n\t\t\t\tArguments.of( \"Microsoft SQL Server\", SQLServerDialect.class,\n\t\t\t\t\t\tgetVersionConstant( SQLServerDialect.class, \"MINIMUM_VERSION\") ),\n\t\t\t\tArguments.of( \"Sybase SQL Server\", SybaseDialect.class,\n\t\t\t\t\t\tgetVersionConstant( SybaseDialect.class, \"MINIMUM_VERSION\") ),\n\t\t\t\tArguments.of( \"Adaptive Server Enterprise\", SybaseDialect.class,\n\t\t\t\t\t\tgetVersionConstant( SybaseDialect.class, \"MINIMUM_VERSION\") ),\n\t\t\t\tArguments.of( \"ASE\", SybaseDialect.class,\n\t\t\t\t\t\tgetVersionConstant( SybaseDialect.class, \"MINIMUM_VERSION\") )\n\t\t);\n\t}\n\n\t@ParameterizedTest\n\t@MethodSource(\"dialects\")\n\tvoid testAccessDisabledExplicitDialect(String productName, Class<?> dialectClass, DatabaseVersion expectedDatabaseVersion) {\n\t\tfinal StandardServiceRegistryBuilder registryBuilder = new StandardServiceRegistryBuilder();\n\t\tregistryBuilder.clearSettings();\n\n\t\tregistryBuilder.applySetting( JdbcSettings.ALLOW_METADATA_ON_BOOT, false );\n\t\tregistryBuilder.applySetting( JdbcSettings.DIALECT, dialectClass.getName() );\n\t\tassertThat( registryBuilder.getSettings() )\n\t\t\t\t.doesNotContainKeys( JdbcSettings.JAKARTA_HBM2DDL_DB_NAME );\n\n\t\ttry (StandardServiceRegistry registry = registryBuilder.build()) {\n\t\t\tfinal JdbcEnvironment jdbcEnvironment = registry.getService( JdbcEnvironment.class );\n\t\t\tfinal Dialect dialect = jdbcEnvironment.getDialect();\n\t\t\tassertThat( dialect ).isInstanceOf( dialectClass );\n\t\t\tassertThat( dialect.getVersion() ).isEqualTo( expectedDatabaseVersion );\n\t\t}\n\n\t\tassertThat( triggerable.triggerMessages() )\n\t\t\t\t.as( triggerable.toString() )\n\t\t\t\t.isEmpty();\n\t}\n\n\t@ParameterizedTest\n\t@MethodSource(\"dialects\")\n\t@Jira(\"https://hibernate.atlassian.net/browse/HHH-18079\")\n\t@Jira(\"https://hibernate.atlassian.net/browse/HHH-18080\")\n\tvoid testAccessDisabledExplicitProductName(String productName, Class<?> dialectClass, DatabaseVersion expectedDatabaseVersion) {\n\t\tfinal StandardServiceRegistryBuilder registryBuilder = new StandardServiceRegistryBuilder();\n\t\tregistryBuilder.clearSettings();\n\n\t\tregistryBuilder.applySetting( JdbcSettings.ALLOW_METADATA_ON_BOOT, false );\n\t\tregistryBuilder.applySetting( JdbcSettings.JAKARTA_HBM2DDL_DB_NAME, productName );\n\t\tassertThat( registryBuilder.getSettings() )\n\t\t\t\t.doesNotContainKeys( JdbcSettings.DIALECT );\n\n\t\ttry (StandardServiceRegistry registry = registryBuilder.build()) {\n\t\t\tfinal JdbcEnvironment jdbcEnvironment = registry.getService( JdbcEnvironment.class );\n\t\t\tfinal Dialect dialect = jdbcEnvironment.getDialect();\n\t\t\tassertThat( dialect ).isInstanceOf( dialectClass );\n\t\t\tassertThat( dialect.getVersion() ).isEqualTo( expectedDatabaseVersion );\n\t\t}\n\n\t\tassertThat( triggerable.triggerMessages() )\n\t\t\t\t.as( triggerable.toString() )\n\t\t\t\t.isEmpty();\n\t}\n\n\t@Test\n\t@Jira(\"https://hibernate.atlassian.net/browse/HHH-18080\")\n\tvoid testAccessDisabledNoDialectNorProductName() {\n\t\tfinal StandardServiceRegistryBuilder registryBuilder = new StandardServiceRegistryBuilder();\n\t\tregistryBuilder.clearSettings();\n\t\tassertThat( registryBuilder.getSettings() )\n\t\t\t\t.doesNotContainKeys( JdbcSettings.DIALECT, JdbcSettings.JAKARTA_HBM2DDL_DB_NAME );\n\n\t\tregistryBuilder.applySetting( JdbcSettings.ALLOW_METADATA_ON_BOOT, false );\n\t\ttry (StandardServiceRegistry registry = registryBuilder.build()) {\n\t\t\tfinal JdbcEnvironment jdbcEnvironment = registry.getService( JdbcEnvironment.class );\n\t\t\tfinal Dialect dialect = jdbcEnvironment.getDialect();\n\t\t\tfail( \"Should fail to boot - \" + dialect );\n\t\t}\n\t\tcatch (ServiceException expected) {\n\t\t\tassertThat( expected.getCause() ).isInstanceOf( HibernateException.class );\n\t\t\tfinal HibernateException cause = (HibernateException) expected.getCause();\n\t\t\tassertThat( cause.getMessage() ).startsWith( \"Unable to determine Dialect without JDBC metadata\" );\n\t\t}\n\t}\n\n\t// Ugly hack because neither MINIMUM_VERSION nor getMinimumSupportedVersion()\n\t// can be accessed from this test.\n\tprivate static DatabaseVersion getVersionConstant(Class<? extends Dialect> dialectClass, String versionConstantName) {\n\t\ttry {\n\t\t\tField field = dialectClass.getDeclaredField( versionConstantName );\n\t\t\tfield.setAccessible( true );\n\t\t\treturn (DatabaseVersion) field.get( null );\n\t\t}\n\t\tcatch (IllegalAccessException | NoSuchFieldException e) {\n\t\t\tthrow new RuntimeException( \"Error extracting '\" + versionConstantName + \"' from '\" + dialectClass + \"'\", e );\n\t\t}\n\t}\n}\n",
        "filePathAfter": "hibernate-core/src/test/java/org/hibernate/orm/test/boot/database/metadata/MetadataAccessTests.java",
        "sourceCodeAfterForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n * See the lgpl.txt file in the root directory or http://www.gnu.org/licenses/lgpl-2.1.html.\n */\npackage org.hibernate.orm.test.boot.database.metadata;\n\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.hibernate.dialect.SimpleDatabaseVersion.ZERO_VERSION;\nimport static org.junit.jupiter.api.Assertions.fail;\n\nimport java.lang.invoke.MethodHandles;\nimport java.lang.reflect.Field;\nimport java.util.Map;\nimport java.util.stream.Stream;\n\nimport org.hibernate.HibernateException;\nimport org.hibernate.boot.registry.StandardServiceInitiator;\nimport org.hibernate.boot.registry.StandardServiceRegistry;\nimport org.hibernate.boot.registry.StandardServiceRegistryBuilder;\nimport org.hibernate.cfg.AvailableSettings;\nimport org.hibernate.cfg.JdbcSettings;\nimport org.hibernate.dialect.DB2Dialect;\nimport org.hibernate.dialect.DatabaseVersion;\nimport org.hibernate.dialect.Dialect;\nimport org.hibernate.dialect.H2Dialect;\nimport org.hibernate.dialect.HANADialect;\nimport org.hibernate.dialect.HSQLDialect;\nimport org.hibernate.dialect.MariaDBDialect;\nimport org.hibernate.dialect.MySQLDialect;\nimport org.hibernate.dialect.OracleDialect;\nimport org.hibernate.dialect.PostgreSQLDialect;\nimport org.hibernate.dialect.PostgresPlusDialect;\nimport org.hibernate.dialect.SQLServerDialect;\nimport org.hibernate.dialect.SpannerDialect;\nimport org.hibernate.dialect.SybaseDialect;\nimport org.hibernate.engine.jdbc.dialect.internal.DialectFactoryImpl;\nimport org.hibernate.engine.jdbc.dialect.spi.DialectFactory;\nimport org.hibernate.engine.jdbc.dialect.spi.DialectResolutionInfo;\nimport org.hibernate.engine.jdbc.dialect.spi.DialectResolutionInfoSource;\nimport org.hibernate.engine.jdbc.env.spi.JdbcEnvironment;\nimport org.hibernate.internal.CoreMessageLogger;\nimport org.hibernate.service.spi.ServiceException;\nimport org.hibernate.service.spi.ServiceRegistryImplementor;\n\nimport org.hibernate.testing.env.TestingDatabaseInfo;\nimport org.hibernate.testing.logger.Triggerable;\nimport org.hibernate.testing.orm.junit.DialectContext;\nimport org.hibernate.testing.orm.junit.Jira;\nimport org.hibernate.testing.orm.logger.LoggerInspectionExtension;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.extension.RegisterExtension;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.Arguments;\nimport org.junit.jupiter.params.provider.MethodSource;\n\nimport org.jboss.logging.Logger;\n\n/**\n * @author Steve Ebersole\n */\n@Jira( \"https://hibernate.atlassian.net/browse/HHH-17269\" )\npublic class MetadataAccessTests {\n\n\tprivate Triggerable triggerable;\n\n\t@RegisterExtension\n\tpublic LoggerInspectionExtension logger = LoggerInspectionExtension\n\t\t\t.builder().setLogger(\n\t\t\t\t\tLogger.getMessageLogger( MethodHandles.lookup(), CoreMessageLogger.class, Dialect.class.getName() )\n\t\t\t).build();\n\n\t@BeforeEach\n\tpublic void setUp() {\n\t\ttriggerable = logger.watchForLogMessages( \"HHH000511\" );\n\t\ttriggerable.reset();\n\t}\n\n\t@Test\n\tvoid testAccessAllowed() {\n\t\tfinal StandardServiceRegistryBuilder registryBuilder = new StandardServiceRegistryBuilder();\n\t\tregistryBuilder.clearSettings();\n\n\t\t// allow access to the jdbc metadata\n\t\tregistryBuilder.applySetting( JdbcSettings.ALLOW_METADATA_ON_BOOT, true );\n\n\t\t// configure the values needed to connect to a H2 database\n\t\tregistryBuilder.applySetting( AvailableSettings.JAKARTA_JDBC_DRIVER, TestingDatabaseInfo.DRIVER );\n\t\tregistryBuilder.applySetting( AvailableSettings.JAKARTA_JDBC_URL, TestingDatabaseInfo.URL );\n\t\tregistryBuilder.applySetting( AvailableSettings.JAKARTA_JDBC_USER, TestingDatabaseInfo.USER );\n\t\tregistryBuilder.applySetting( AvailableSettings.JAKARTA_JDBC_PASSWORD, TestingDatabaseInfo.PASS );\n\n\t\t// make certain there is no explicit dialect configured\n\t\tassertThat( registryBuilder.getSettings() )\n\t\t\t\t.doesNotContainKeys( JdbcSettings.DIALECT, JdbcSettings.JAKARTA_HBM2DDL_DB_NAME );\n\n\t\ttry (StandardServiceRegistry registry = registryBuilder.build()) {\n\t\t\tfinal Dialect dialect = getDialect( registry );\n\t\t\tassertThat( dialect ).isNotNull();\n\t\t\tassertThat( dialect ).isInstanceOf( H2Dialect.class );\n\t\t}\n\n\t\tassertThat( triggerable.triggerMessages() )\n\t\t\t\t.as( triggerable.toString() )\n\t\t\t\t.isEmpty();\n\t}\n\n\tstatic Stream<Arguments> dialects() {\n\t\treturn Stream.of(\n\t\t\t\tArguments.of( \"DB2\", DB2Dialect.class,\n\t\t\t\t\t\tgetVersionConstant( DB2Dialect.class, \"MINIMUM_VERSION\") ),\n\t\t\t\tArguments.of( \"EnterpriseDB\", PostgresPlusDialect.class,\n\t\t\t\t\t\tgetVersionConstant( PostgreSQLDialect.class, \"MINIMUM_VERSION\") ),\n\t\t\t\tArguments.of( \"H2\", H2Dialect.class,\n\t\t\t\t\t\tgetVersionConstant( H2Dialect.class, \"MINIMUM_VERSION\") ),\n\t\t\t\tArguments.of( \"HSQL Database Engine\", HSQLDialect.class,\n\t\t\t\t\t\tgetVersionConstant( HSQLDialect.class, \"MINIMUM_VERSION\") ),\n\t\t\t\tArguments.of( \"HDB\", HANADialect.class,\n\t\t\t\t\t\tgetVersionConstant( HANADialect.class, \"MINIMUM_VERSION\") ),\n\t\t\t\tArguments.of( \"MariaDB\", MariaDBDialect.class,\n\t\t\t\t\t\tgetVersionConstant( MariaDBDialect.class, \"MINIMUM_VERSION\") ),\n\t\t\t\tArguments.of( \"MySQL\", MySQLDialect.class,\n\t\t\t\t\t\tgetVersionConstant( MySQLDialect.class, \"MINIMUM_VERSION\") ),\n\t\t\t\tArguments.of( \"Oracle\", OracleDialect.class,\n\t\t\t\t\t\tgetVersionConstant( OracleDialect.class, \"MINIMUM_VERSION\") ),\n\t\t\t\tArguments.of( \"PostgreSQL\", PostgreSQLDialect.class,\n\t\t\t\t\t\tgetVersionConstant( PostgreSQLDialect.class, \"MINIMUM_VERSION\") ),\n\t\t\t\tArguments.of( \"Google Cloud Spanner\", SpannerDialect.class, ZERO_VERSION ),\n\t\t\t\tArguments.of( \"Microsoft SQL Server\", SQLServerDialect.class,\n\t\t\t\t\t\tgetVersionConstant( SQLServerDialect.class, \"MINIMUM_VERSION\") ),\n\t\t\t\tArguments.of( \"Sybase SQL Server\", SybaseDialect.class,\n\t\t\t\t\t\tgetVersionConstant( SybaseDialect.class, \"MINIMUM_VERSION\") ),\n\t\t\t\tArguments.of( \"Adaptive Server Enterprise\", SybaseDialect.class,\n\t\t\t\t\t\tgetVersionConstant( SybaseDialect.class, \"MINIMUM_VERSION\") ),\n\t\t\t\tArguments.of( \"ASE\", SybaseDialect.class,\n\t\t\t\t\t\tgetVersionConstant( SybaseDialect.class, \"MINIMUM_VERSION\") )\n\t\t);\n\t}\n\n\t@ParameterizedTest\n\t@MethodSource(\"dialects\")\n\tvoid testAccessDisabledExplicitDialect(String productName, Class<?> dialectClass,\n\t\t\tDatabaseVersion expectedDatabaseVersion) {\n\t\ttry ( StandardServiceRegistry registry = createRegistryWithMetadataAccessDisabledAndDialect( dialectClass ) ) {\n\t\t\tfinal Dialect dialect = getDialect( registry );\n\t\t\tassertThat( dialect ).isInstanceOf( dialectClass );\n\t\t\tassertThat( dialect.getVersion() ).isEqualTo( expectedDatabaseVersion );\n\t\t}\n\n\t\tassertThat( triggerable.triggerMessages() )\n\t\t\t\t.as( triggerable.toString() )\n\t\t\t\t.isEmpty();\n\t}\n\n\tprivate StandardServiceRegistry createRegistryWithMetadataAccessDisabledAndDialect(Class<?> dialectClass) {\n\t\tfinal StandardServiceRegistryBuilder registryBuilder = new StandardServiceRegistryBuilder();\n\t\tregistryBuilder.clearSettings();\n\n\t\tregistryBuilder.applySetting( JdbcSettings.ALLOW_METADATA_ON_BOOT, false );\n\t\tregistryBuilder.applySetting( JdbcSettings.DIALECT, dialectClass.getName() );\n\t\tassertThat( registryBuilder.getSettings() )\n\t\t\t\t.doesNotContainKeys( JdbcSettings.JAKARTA_HBM2DDL_DB_NAME );\n\n\t\treturn registryBuilder.build();\n\t}\n\n\t@ParameterizedTest\n\t@MethodSource(\"dialects\")\n\t@Jira(\"https://hibernate.atlassian.net/browse/HHH-18079\")\n\t@Jira(\"https://hibernate.atlassian.net/browse/HHH-18080\")\n\tvoid testAccessDisabledExplicitProductName(String productName, Class<?> dialectClass, DatabaseVersion expectedDatabaseVersion) {\n\t\tfinal StandardServiceRegistryBuilder registryBuilder = new StandardServiceRegistryBuilder();\n\t\tregistryBuilder.clearSettings();\n\n\t\tregistryBuilder.applySetting( JdbcSettings.ALLOW_METADATA_ON_BOOT, false );\n\t\tregistryBuilder.applySetting( JdbcSettings.JAKARTA_HBM2DDL_DB_NAME, productName );\n\t\tassertThat( registryBuilder.getSettings() )\n\t\t\t\t.doesNotContainKeys( JdbcSettings.DIALECT );\n\n\t\ttry (StandardServiceRegistry registry = registryBuilder.build()) {\n\t\t\tfinal JdbcEnvironment jdbcEnvironment = registry.getService( JdbcEnvironment.class );\n\t\t\tfinal Dialect dialect = jdbcEnvironment.getDialect();\n\t\t\tassertThat( dialect ).isInstanceOf( dialectClass );\n\t\t\tassertThat( dialect.getVersion() ).isEqualTo( expectedDatabaseVersion );\n\t\t}\n\n\t\tassertThat( triggerable.triggerMessages() )\n\t\t\t\t.as( triggerable.toString() )\n\t\t\t\t.isEmpty();\n\t}\n\n\t@Test\n\t@Jira(\"https://hibernate.atlassian.net/browse/HHH-18080\")\n\tvoid testAccessDisabledNoDialectNorProductName() {\n\t\tfinal StandardServiceRegistryBuilder registryBuilder = new StandardServiceRegistryBuilder();\n\t\tregistryBuilder.clearSettings();\n\t\tassertThat( registryBuilder.getSettings() )\n\t\t\t\t.doesNotContainKeys( JdbcSettings.DIALECT, JdbcSettings.JAKARTA_HBM2DDL_DB_NAME );\n\n\t\tregistryBuilder.applySetting( JdbcSettings.ALLOW_METADATA_ON_BOOT, false );\n\t\ttry (StandardServiceRegistry registry = registryBuilder.build()) {\n\t\t\tfinal Dialect dialect = getDialect( registry );\n\t\t\tfail( \"Should fail to boot - \" + dialect );\n\t\t}\n\t\tcatch (ServiceException expected) {\n\t\t\tassertThat( expected.getCause() ).isInstanceOf( HibernateException.class );\n\t\t\tfinal HibernateException cause = (HibernateException) expected.getCause();\n\t\t\tassertThat( cause.getMessage() ).startsWith( \"Unable to determine Dialect without JDBC metadata\" );\n\t\t}\n\t}\n\n\t@Test\n\tvoid testDetermineDatabaseVersion() {\n\t\tfinal Dialect metadataAccessDisabledDialect;\n\t\ttry ( StandardServiceRegistry registry =\n\t\t\t\tcreateRegistryWithMetadataAccessDisabledAndDialect( DialectContext.getDialectClass() ) ) {\n\t\t\t// The version on this dialect may be anything, but most likely will be the minimum version.\n\t\t\t// We're not interested in that, but in how determineDatabaseVersion() behaves for this dialect,\n\t\t\t// when passed actual resolution info -- which Quarkus may do.\n\t\t\tmetadataAccessDisabledDialect = getDialect( registry );\n\t\t}\n\n\t\ttry ( StandardServiceRegistry registry = createRegistryWithTestedDatabaseAndMetadataAccessAllowed() ) {\n\t\t\tfinal Dialect metadataAccessAllowedDialect = getDialect( registry );\n\n\t\t\t// We expect determineDatabaseVersion(), when called on metadataAccessDisabledDialect,\n\t\t\t// to return the version that would have been returned,\n\t\t\t// had we booted up with auto-detection of version (metadata access allowed).\n\t\t\tassertThat( metadataAccessDisabledDialect.determineDatabaseVersion( getDialectResolutionInfo( registry ) ) )\n\t\t\t\t\t.isEqualTo( metadataAccessAllowedDialect.getVersion() );\n\t\t}\n\t}\n\n\tprivate StandardServiceRegistry createRegistryWithTestedDatabaseAndMetadataAccessAllowed() {\n\t\tfinal StandardServiceRegistryBuilder registryBuilder = new StandardServiceRegistryBuilder();\n\n\t\tregistryBuilder.addInitiator( new CapturingDialectFactory.Initiator() );\n\n\t\t// allow access to the jdbc metadata\n\t\tregistryBuilder.applySetting( JdbcSettings.ALLOW_METADATA_ON_BOOT, true );\n\n\t\t// leave connection info as defined in global test configuration (most likely system properties)\n\n\t\treturn registryBuilder.build();\n\t}\n\n\tprivate static Dialect getDialect(StandardServiceRegistry registry) {\n\t\treturn registry.getService( JdbcEnvironment.class ).getDialect();\n\t}\n\n\tprivate static DialectResolutionInfo getDialectResolutionInfo(StandardServiceRegistry registry) {\n\t\treturn ( (CapturingDialectFactory) registry.getService( DialectFactory.class ) )\n\t\t\t\t.capturedDialectResolutionInfoSource.getDialectResolutionInfo();\n\t}\n\n\t// Ugly hack because neither MINIMUM_VERSION nor getMinimumSupportedVersion()\n\t// can be accessed from this test.\n\tprivate static DatabaseVersion getVersionConstant(Class<? extends Dialect> dialectClass, String versionConstantName) {\n\t\ttry {\n\t\t\tField field = dialectClass.getDeclaredField( versionConstantName );\n\t\t\tfield.setAccessible( true );\n\t\t\treturn (DatabaseVersion) field.get( null );\n\t\t}\n\t\tcatch (IllegalAccessException | NoSuchFieldException e) {\n\t\t\tthrow new RuntimeException( \"Error extracting '\" + versionConstantName + \"' from '\" + dialectClass + \"'\", e );\n\t\t}\n\t}\n\n\t// A hack to easily retrieve DialectResolutionInfo exactly as it would be constructed by Hibernate ORM\n\tprivate static class CapturingDialectFactory extends DialectFactoryImpl {\n\t\tstatic class Initiator implements StandardServiceInitiator<DialectFactory> {\n\t\t\t@Override\n\t\t\tpublic Class<DialectFactory> getServiceInitiated() {\n\t\t\t\treturn DialectFactory.class;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic DialectFactory initiateService(Map<String, Object> configurationValues,\n\t\t\t\t\tServiceRegistryImplementor registry) {\n\t\t\t\treturn new CapturingDialectFactory();\n\t\t\t}\n\t\t}\n\n\t\tDialectResolutionInfoSource capturedDialectResolutionInfoSource;\n\n\t\t@Override\n\t\tpublic Dialect buildDialect(Map<String, Object> configValues, DialectResolutionInfoSource resolutionInfoSource)\n\t\t\t\tthrows HibernateException {\n\t\t\tthis.capturedDialectResolutionInfoSource = resolutionInfoSource;\n\t\t\treturn super.buildDialect( configValues, resolutionInfoSource );\n\t\t}\n\t}\n}\n",
        "diffSourceCodeSet": [
            "private StandardServiceRegistry createRegistryWithMetadataAccessDisabledAndDialect(Class<?> dialectClass) {\n\t\tfinal StandardServiceRegistryBuilder registryBuilder = new StandardServiceRegistryBuilder();\n\t\tregistryBuilder.clearSettings();\n\n\t\tregistryBuilder.applySetting( JdbcSettings.ALLOW_METADATA_ON_BOOT, false );\n\t\tregistryBuilder.applySetting( JdbcSettings.DIALECT, dialectClass.getName() );\n\t\tassertThat( registryBuilder.getSettings() )\n\t\t\t\t.doesNotContainKeys( JdbcSettings.JAKARTA_HBM2DDL_DB_NAME );\n\n\t\treturn registryBuilder.build();\n\t}"
        ],
        "invokedMethodSet": [
            "methodSignature: org.hibernate.dialect.HANADialect.HANANClobJdbcType#toString\n methodBody: public String toString() {\nreturn \"HANANClobTypeDescriptor\";\n}",
            "methodSignature: org.hibernate.dialect.HANADialect.HANAClobJdbcType#toString\n methodBody: public String toString() {\nreturn \"HANAClobTypeDescriptor\";\n}",
            "methodSignature: org.hibernate.testing.orm.junit.DialectContext#getDialect\n methodBody: public static synchronized Dialect getDialect() {\nif(dialect == null){init();\n}return dialect;\n}",
            "methodSignature: org.hibernate.dialect.Dialect#toString\n methodBody: public String toString() {\nreturn getClass().getName() + \", version: \" + getVersion();\n}",
            "methodSignature: org.hibernate.dialect.HANADialect.HANABlobType#toString\n methodBody: public String toString() {\nreturn \"HANABlobType\";\n}",
            "methodSignature: org.hibernate.dialect.SimpleDatabaseVersion#toString\n methodBody: public String toString() {\nStringBuilder version=new StringBuilder();\nif(major != NO_VERSION){version.append(major);\n}if(minor != NO_VERSION){version.append(\".\");\nversion.append(minor);\nif(micro > 0){version.append(\".\");\nversion.append(micro);\n}}return version.toString();\n}",
            "methodSignature: org.hibernate.dialect.Dialect#getVersion\n methodBody: public DatabaseVersion getVersion() {\nreturn version;\n}",
            "methodSignature: org.hibernate.dialect.HANADialect.HANAStreamBlobType#toString\n methodBody: public String toString() {\nreturn \"HANAStreamBlobType\";\n}"
        ],
        "sourceCodeAfterRefactoring": "@ParameterizedTest\n\t@MethodSource(\"dialects\")\n\tvoid testAccessDisabledExplicitDialect(String productName, Class<?> dialectClass,\n\t\t\tDatabaseVersion expectedDatabaseVersion) {\n\t\ttry ( StandardServiceRegistry registry = createRegistryWithMetadataAccessDisabledAndDialect( dialectClass ) ) {\n\t\t\tfinal Dialect dialect = getDialect( registry );\n\t\t\tassertThat( dialect ).isInstanceOf( dialectClass );\n\t\t\tassertThat( dialect.getVersion() ).isEqualTo( expectedDatabaseVersion );\n\t\t}\n\n\t\tassertThat( triggerable.triggerMessages() )\n\t\t\t\t.as( triggerable.toString() )\n\t\t\t\t.isEmpty();\n\t}\nprivate StandardServiceRegistry createRegistryWithMetadataAccessDisabledAndDialect(Class<?> dialectClass) {\n\t\tfinal StandardServiceRegistryBuilder registryBuilder = new StandardServiceRegistryBuilder();\n\t\tregistryBuilder.clearSettings();\n\n\t\tregistryBuilder.applySetting( JdbcSettings.ALLOW_METADATA_ON_BOOT, false );\n\t\tregistryBuilder.applySetting( JdbcSettings.DIALECT, dialectClass.getName() );\n\t\tassertThat( registryBuilder.getSettings() )\n\t\t\t\t.doesNotContainKeys( JdbcSettings.JAKARTA_HBM2DDL_DB_NAME );\n\n\t\treturn registryBuilder.build();\n\t}",
        "diffSourceCode": "-  135: \t@ParameterizedTest\n-  136: \t@MethodSource(\"dialects\")\n-  137: \tvoid testAccessDisabledExplicitDialect(String productName, Class<?> dialectClass, DatabaseVersion expectedDatabaseVersion) {\n-  138: \t\tfinal StandardServiceRegistryBuilder registryBuilder = new StandardServiceRegistryBuilder();\n-  139: \t\tregistryBuilder.clearSettings();\n-  140: \n-  141: \t\tregistryBuilder.applySetting( JdbcSettings.ALLOW_METADATA_ON_BOOT, false );\n-  142: \t\tregistryBuilder.applySetting( JdbcSettings.DIALECT, dialectClass.getName() );\n-  143: \t\tassertThat( registryBuilder.getSettings() )\n-  144: \t\t\t\t.doesNotContainKeys( JdbcSettings.JAKARTA_HBM2DDL_DB_NAME );\n-  145: \n-  146: \t\ttry (StandardServiceRegistry registry = registryBuilder.build()) {\n-  147: \t\t\tfinal JdbcEnvironment jdbcEnvironment = registry.getService( JdbcEnvironment.class );\n-  148: \t\t\tfinal Dialect dialect = jdbcEnvironment.getDialect();\n-  149: \t\t\tassertThat( dialect ).isInstanceOf( dialectClass );\n-  150: \t\t\tassertThat( dialect.getVersion() ).isEqualTo( expectedDatabaseVersion );\n-  151: \t\t}\n-  152: \n-  153: \t\tassertThat( triggerable.triggerMessages() )\n-  154: \t\t\t\t.as( triggerable.toString() )\n-  155: \t\t\t\t.isEmpty();\n-  156: \t}\n-  157: \n-  158: \t@ParameterizedTest\n-  159: \t@MethodSource(\"dialects\")\n-  160: \t@Jira(\"https://hibernate.atlassian.net/browse/HHH-18079\")\n-  161: \t@Jira(\"https://hibernate.atlassian.net/browse/HHH-18080\")\n-  162: \tvoid testAccessDisabledExplicitProductName(String productName, Class<?> dialectClass, DatabaseVersion expectedDatabaseVersion) {\n-  163: \t\tfinal StandardServiceRegistryBuilder registryBuilder = new StandardServiceRegistryBuilder();\n-  164: \t\tregistryBuilder.clearSettings();\n+  135: \t\t\t\tArguments.of( \"Adaptive Server Enterprise\", SybaseDialect.class,\n+  136: \t\t\t\t\t\tgetVersionConstant( SybaseDialect.class, \"MINIMUM_VERSION\") ),\n+  137: \t\t\t\tArguments.of( \"ASE\", SybaseDialect.class,\n+  138: \t\t\t\t\t\tgetVersionConstant( SybaseDialect.class, \"MINIMUM_VERSION\") )\n+  139: \t\t);\n+  140: \t}\n+  141: \n+  142: \t@ParameterizedTest\n+  143: \t@MethodSource(\"dialects\")\n+  144: \tvoid testAccessDisabledExplicitDialect(String productName, Class<?> dialectClass,\n+  145: \t\t\tDatabaseVersion expectedDatabaseVersion) {\n+  146: \t\ttry ( StandardServiceRegistry registry = createRegistryWithMetadataAccessDisabledAndDialect( dialectClass ) ) {\n+  147: \t\t\tfinal Dialect dialect = getDialect( registry );\n+  148: \t\t\tassertThat( dialect ).isInstanceOf( dialectClass );\n+  149: \t\t\tassertThat( dialect.getVersion() ).isEqualTo( expectedDatabaseVersion );\n+  150: \t\t}\n+  151: \n+  152: \t\tassertThat( triggerable.triggerMessages() )\n+  153: \t\t\t\t.as( triggerable.toString() )\n+  154: \t\t\t\t.isEmpty();\n+  155: \t}\n+  156: \n+  157: \tprivate StandardServiceRegistry createRegistryWithMetadataAccessDisabledAndDialect(Class<?> dialectClass) {\n+  158: \t\tfinal StandardServiceRegistryBuilder registryBuilder = new StandardServiceRegistryBuilder();\n+  159: \t\tregistryBuilder.clearSettings();\n+  160: \n+  161: \t\tregistryBuilder.applySetting( JdbcSettings.ALLOW_METADATA_ON_BOOT, false );\n+  162: \t\tregistryBuilder.applySetting( JdbcSettings.DIALECT, dialectClass.getName() );\n+  163: \t\tassertThat( registryBuilder.getSettings() )\n+  164: \t\t\t\t.doesNotContainKeys( JdbcSettings.JAKARTA_HBM2DDL_DB_NAME );\n   165: \n-  166: \t\tregistryBuilder.applySetting( JdbcSettings.ALLOW_METADATA_ON_BOOT, false );\n-  167: \t\tregistryBuilder.applySetting( JdbcSettings.JAKARTA_HBM2DDL_DB_NAME, productName );\n+  166: \t\treturn registryBuilder.build();\n+  167: \t}\n",
        "uniqueId": "4b33d0d067010d484702d6ee910aaa3b4584c69b_135_156_157_167_142_155",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "testMethod": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 17
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprivate staticDetermineDatabaseVersion(info DialectResolutionInfo) : DatabaseVersion extracted from private determineDatabaseVersion(info DialectResolutionInfo) : DatabaseVersion in class org.hibernate.dialect.SQLServerDialect",
        "diffLocations": [
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/dialect/SQLServerDialect.java",
                "startLine": 181,
                "endLine": 189,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/dialect/SQLServerDialect.java",
                "startLine": 181,
                "endLine": 184,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/dialect/SQLServerDialect.java",
                "startLine": 187,
                "endLine": 195,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "private static DatabaseVersion determineDatabaseVersion(DialectResolutionInfo info) {\n\t\tfinal Integer compatibilityLevel = getCompatibilityLevel( info );\n\t\tif ( compatibilityLevel != null ) {\n\t\t\tfinal int majorVersion = compatibilityLevel / 10;\n\t\t\tfinal int minorVersion = compatibilityLevel % 10;\n\t\t\treturn DatabaseVersion.make( majorVersion, minorVersion );\n\t\t}\n\t\treturn info.makeCopyOrDefault( MINIMUM_VERSION );\n\t}",
        "filePathBefore": "hibernate-core/src/main/java/org/hibernate/dialect/SQLServerDialect.java",
        "isPureRefactoring": true,
        "commitId": "4b33d0d067010d484702d6ee910aaa3b4584c69b",
        "packageNameBefore": "org.hibernate.dialect",
        "classNameBefore": "org.hibernate.dialect.SQLServerDialect",
        "methodNameBefore": "org.hibernate.dialect.SQLServerDialect#determineDatabaseVersion",
        "invokedMethod": "methodSignature: org.hibernate.dialect.SQLServerDialect#getCompatibilityLevel\n methodBody: private static Integer getCompatibilityLevel(DialectResolutionInfo info) {\nfinal DatabaseMetaData databaseMetaData=info.getDatabaseMetadata();\nif(databaseMetaData != null){try(java.sql.Statement statement=databaseMetaData.getConnection().createStatement())final ResultSet rs=statement.executeQuery(\"SELECT compatibility_level FROM sys.databases where name = db_name();\");\nif(rs.next()){return rs.getInt(1);\n}catch(SQLException e)throw BasicSQLExceptionConverter.INSTANCE.convert(e);\n}return ConfigurationHelper.getInteger(SQL_SERVER_COMPATIBILITY_LEVEL,info.getConfigurationValues());\n}",
        "classSignatureBefore": "public class SQLServerDialect extends AbstractTransactSQLDialect ",
        "methodNameBeforeSet": [
            "org.hibernate.dialect.SQLServerDialect#determineDatabaseVersion"
        ],
        "classNameBeforeSet": [
            "org.hibernate.dialect.SQLServerDialect"
        ],
        "classSignatureBeforeSet": [
            "public class SQLServerDialect extends AbstractTransactSQLDialect "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.\n */\npackage org.hibernate.dialect;\n\nimport java.sql.DatabaseMetaData;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Types;\nimport java.time.temporal.ChronoField;\nimport java.time.temporal.TemporalAccessor;\nimport java.util.Calendar;\nimport java.util.Date;\nimport java.util.List;\nimport java.util.TimeZone;\n\nimport org.hibernate.Length;\nimport org.hibernate.LockMode;\nimport org.hibernate.LockOptions;\nimport org.hibernate.QueryTimeoutException;\nimport org.hibernate.boot.Metadata;\nimport org.hibernate.boot.model.FunctionContributions;\nimport org.hibernate.boot.model.TypeContributions;\nimport org.hibernate.boot.model.relational.QualifiedSequenceName;\nimport org.hibernate.boot.model.relational.Sequence;\nimport org.hibernate.boot.model.relational.SqlStringGenerationContext;\nimport org.hibernate.dialect.function.CommonFunctionFactory;\nimport org.hibernate.dialect.function.CountFunction;\nimport org.hibernate.dialect.function.SQLServerFormatEmulation;\nimport org.hibernate.dialect.function.SqlServerConvertTruncFunction;\nimport org.hibernate.dialect.identity.IdentityColumnSupport;\nimport org.hibernate.dialect.identity.SQLServerIdentityColumnSupport;\nimport org.hibernate.dialect.pagination.LimitHandler;\nimport org.hibernate.dialect.pagination.SQLServer2012LimitHandler;\nimport org.hibernate.dialect.sequence.SQLServer16SequenceSupport;\nimport org.hibernate.dialect.sequence.SQLServerSequenceSupport;\nimport org.hibernate.dialect.sequence.SequenceSupport;\nimport org.hibernate.dialect.unique.AlterTableUniqueIndexDelegate;\nimport org.hibernate.dialect.unique.UniqueDelegate;\nimport org.hibernate.engine.jdbc.Size;\nimport org.hibernate.engine.jdbc.dialect.spi.BasicSQLExceptionConverter;\nimport org.hibernate.engine.jdbc.dialect.spi.DialectResolutionInfo;\nimport org.hibernate.engine.jdbc.env.spi.IdentifierCaseStrategy;\nimport org.hibernate.engine.jdbc.env.spi.IdentifierHelper;\nimport org.hibernate.engine.jdbc.env.spi.IdentifierHelperBuilder;\nimport org.hibernate.engine.jdbc.env.spi.NameQualifierSupport;\nimport org.hibernate.engine.spi.SessionFactoryImplementor;\nimport org.hibernate.exception.ConstraintViolationException;\nimport org.hibernate.exception.LockTimeoutException;\nimport org.hibernate.exception.spi.SQLExceptionConversionDelegate;\nimport org.hibernate.exception.spi.TemplatedViolatedConstraintNameExtractor;\nimport org.hibernate.exception.spi.ViolatedConstraintNameExtractor;\nimport org.hibernate.internal.util.JdbcExceptionHelper;\nimport org.hibernate.internal.util.config.ConfigurationHelper;\nimport org.hibernate.internal.util.StringHelper;\nimport org.hibernate.mapping.CheckConstraint;\nimport org.hibernate.mapping.Column;\nimport org.hibernate.persister.entity.mutation.EntityMutationTarget;\nimport org.hibernate.procedure.internal.SQLServerCallableStatementSupport;\nimport org.hibernate.procedure.spi.CallableStatementSupport;\nimport org.hibernate.query.sqm.CastType;\nimport org.hibernate.query.sqm.FetchClauseType;\nimport org.hibernate.query.sqm.IntervalType;\nimport org.hibernate.query.sqm.TemporalUnit;\nimport org.hibernate.query.sqm.TrimSpec;\nimport org.hibernate.service.ServiceRegistry;\nimport org.hibernate.sql.ast.SqlAstNodeRenderingMode;\nimport org.hibernate.sql.ast.SqlAstTranslator;\nimport org.hibernate.sql.ast.SqlAstTranslatorFactory;\nimport org.hibernate.sql.ast.spi.SqlAppender;\nimport org.hibernate.sql.ast.spi.StandardSqlAstTranslatorFactory;\nimport org.hibernate.sql.ast.tree.Statement;\nimport org.hibernate.sql.exec.spi.JdbcOperation;\nimport org.hibernate.sql.model.MutationOperation;\nimport org.hibernate.sql.model.internal.OptionalTableUpdate;\nimport org.hibernate.tool.schema.internal.StandardSequenceExporter;\nimport org.hibernate.tool.schema.spi.Exporter;\nimport org.hibernate.type.BasicType;\nimport org.hibernate.type.BasicTypeRegistry;\nimport org.hibernate.type.StandardBasicTypes;\nimport org.hibernate.type.descriptor.java.JavaType;\nimport org.hibernate.type.descriptor.jdbc.JdbcType;\nimport org.hibernate.type.descriptor.jdbc.TimestampUtcAsJdbcTimestampJdbcType;\nimport org.hibernate.type.descriptor.jdbc.TinyIntAsSmallIntJdbcType;\nimport org.hibernate.type.descriptor.jdbc.UUIDJdbcType;\nimport org.hibernate.type.descriptor.jdbc.XmlJdbcType;\nimport org.hibernate.type.descriptor.jdbc.spi.JdbcTypeRegistry;\nimport org.hibernate.type.descriptor.sql.internal.DdlTypeImpl;\nimport org.hibernate.type.descriptor.sql.spi.DdlTypeRegistry;\n\nimport jakarta.persistence.TemporalType;\n\nimport static org.hibernate.cfg.DialectSpecificSettings.SQL_SERVER_COMPATIBILITY_LEVEL;\nimport static org.hibernate.exception.spi.TemplatedViolatedConstraintNameExtractor.extractUsingTemplate;\nimport static org.hibernate.internal.util.JdbcExceptionHelper.extractErrorCode;\nimport static org.hibernate.internal.util.JdbcExceptionHelper.extractSqlState;\nimport static org.hibernate.internal.util.StringHelper.isNotEmpty;\nimport static org.hibernate.query.sqm.TemporalUnit.NANOSECOND;\nimport static org.hibernate.query.sqm.produce.function.FunctionParameterType.INTEGER;\nimport static org.hibernate.type.SqlTypes.BLOB;\nimport static org.hibernate.type.SqlTypes.CLOB;\nimport static org.hibernate.type.SqlTypes.DATE;\nimport static org.hibernate.type.SqlTypes.DOUBLE;\nimport static org.hibernate.type.SqlTypes.GEOGRAPHY;\nimport static org.hibernate.type.SqlTypes.GEOMETRY;\nimport static org.hibernate.type.SqlTypes.LONG32NVARCHAR;\nimport static org.hibernate.type.SqlTypes.LONG32VARBINARY;\nimport static org.hibernate.type.SqlTypes.LONG32VARCHAR;\nimport static org.hibernate.type.SqlTypes.NCLOB;\nimport static org.hibernate.type.SqlTypes.NVARCHAR;\nimport static org.hibernate.type.SqlTypes.OTHER;\nimport static org.hibernate.type.SqlTypes.SQLXML;\nimport static org.hibernate.type.SqlTypes.TIME;\nimport static org.hibernate.type.SqlTypes.TIMESTAMP;\nimport static org.hibernate.type.SqlTypes.TIMESTAMP_WITH_TIMEZONE;\nimport static org.hibernate.type.SqlTypes.TIME_WITH_TIMEZONE;\nimport static org.hibernate.type.SqlTypes.UUID;\nimport static org.hibernate.type.SqlTypes.VARBINARY;\nimport static org.hibernate.type.SqlTypes.VARCHAR;\nimport static org.hibernate.type.descriptor.DateTimeUtils.appendAsDate;\nimport static org.hibernate.type.descriptor.DateTimeUtils.appendAsTime;\nimport static org.hibernate.type.descriptor.DateTimeUtils.appendAsTimestampWithMicros;\nimport static org.hibernate.type.descriptor.DateTimeUtils.appendAsTimestampWithMillis;\n\n/**\n * A dialect for Microsoft SQL Server 2008 and above\n *\n * @author Gavin King\n */\npublic class SQLServerDialect extends AbstractTransactSQLDialect {\n\tprivate final static DatabaseVersion MINIMUM_VERSION = DatabaseVersion.make( 11, 0 );\n\n\t/**\n\t * NOTE : 2100 is the documented limit supposedly - but in my testing, sending\n\t * 2100 parameters fails saying it must be less than 2100.\n\t */\n\tprivate static final int PARAM_LIST_SIZE_LIMIT = 2048;\n\n\t// See microsoft.sql.Types.GEOMETRY\n\tprivate static final int GEOMETRY_TYPE_CODE = -157;\n\t// See microsoft.sql.Types.GEOGRAPHY\n\tprivate static final int GEOGRAPHY_TYPE_CODE = -158;\n\n\tprivate final StandardSequenceExporter exporter;\n\tprivate final UniqueDelegate uniqueDelegate = new AlterTableUniqueIndexDelegate(this);\n\n\tprivate final SizeStrategy sizeStrategy = new SizeStrategyImpl() {\n\t\t@Override\n\t\tpublic Size resolveSize(\n\t\t\t\tJdbcType jdbcType,\n\t\t\t\tJavaType<?> javaType,\n\t\t\t\tInteger precision,\n\t\t\t\tInteger scale,\n\t\t\t\tLong length) {\n\t\t\treturn switch ( jdbcType.getDdlTypeCode() ) {\n\t\t\t\tcase BLOB, CLOB, NCLOB ->\n\t\t\t\t\t\tsuper.resolveSize( jdbcType, javaType, precision, scale,\n\t\t\t\t\t\t\t\tlength == null ? getDefaultLobLength() : length );\n\t\t\t\tdefault -> super.resolveSize( jdbcType, javaType, precision, scale, length );\n\t\t\t};\n\t\t}\n\t};\n\n\tpublic SQLServerDialect() {\n\t\tthis( MINIMUM_VERSION );\n\t}\n\n\tpublic SQLServerDialect(DatabaseVersion version) {\n\t\tsuper(version);\n\t\texporter = createSequenceExporter(version);\n\t}\n\n\tpublic SQLServerDialect(DialectResolutionInfo info) {\n\t\tthis( determineDatabaseVersion( info ) );\n\t\tregisterKeywords( info );\n\t}\n\n\tprivate static DatabaseVersion determineDatabaseVersion(DialectResolutionInfo info) {\n\t\tfinal Integer compatibilityLevel = getCompatibilityLevel( info );\n\t\tif ( compatibilityLevel != null ) {\n\t\t\tfinal int majorVersion = compatibilityLevel / 10;\n\t\t\tfinal int minorVersion = compatibilityLevel % 10;\n\t\t\treturn DatabaseVersion.make( majorVersion, minorVersion );\n\t\t}\n\t\treturn info.makeCopyOrDefault( MINIMUM_VERSION );\n\t}\n\n\tprivate static Integer getCompatibilityLevel(DialectResolutionInfo info) {\n\t\tfinal DatabaseMetaData databaseMetaData = info.getDatabaseMetadata();\n\t\tif ( databaseMetaData != null ) {\n\t\t\ttry ( java.sql.Statement statement = databaseMetaData.getConnection().createStatement() ) {\n\t\t\t\tfinal ResultSet rs = statement.executeQuery( \"SELECT compatibility_level FROM sys.databases where name = db_name();\" );\n\t\t\t\tif ( rs.next() ) {\n\t\t\t\t\treturn rs.getInt( 1 );\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (SQLException e) {\n\t\t\t\tthrow BasicSQLExceptionConverter.INSTANCE.convert( e );\n\t\t\t}\n\t\t}\n\n\t\t// default to the dialect-specific configuration setting\n\t\treturn ConfigurationHelper.getInteger( SQL_SERVER_COMPATIBILITY_LEVEL, info.getConfigurationValues() );\n\t}\n\n\tprivate StandardSequenceExporter createSequenceExporter(DatabaseVersion version) {\n\t\treturn new SqlServerSequenceExporter(this);\n\t}\n\n\t@Override\n\tprotected DatabaseVersion getMinimumSupportedVersion() {\n\t\treturn MINIMUM_VERSION;\n\t}\n\n\t@Override\n\tprotected void registerDefaultKeywords() {\n\t\tsuper.registerDefaultKeywords();\n\t\tregisterKeyword( \"top\" );\n\t\tregisterKeyword( \"key\" );\n\t}\n\n\t@Override\n\tprotected String columnType(int sqlTypeCode) {\n\t\treturn switch (sqlTypeCode) {\n\t\t\t// there is no 'double' type in SQL server\n\t\t\t// but 'float' is double precision by default\n\t\t\tcase DOUBLE -> \"float\";\n\t\t\t// Prefer 'varchar(max)' and 'varbinary(max)' to\n\t\t\t// the deprecated TEXT and IMAGE types. Note that\n\t\t\t// the length of a VARCHAR or VARBINARY column must\n\t\t\t// be either between 1 and 8000 or exactly MAX, and\n\t\t\t// the length of an NVARCHAR column must be either\n\t\t\t// between 1 and 4000 or exactly MAX. (HHH-3965)\n\t\t\tcase CLOB -> \"varchar(max)\";\n\t\t\tcase NCLOB -> \"nvarchar(max)\";\n\t\t\tcase BLOB -> \"varbinary(max)\";\n\t\t\tcase DATE -> \"date\";\n\t\t\tcase TIME -> \"time\";\n\t\t\tcase TIMESTAMP -> \"datetime2($p)\";\n\t\t\tcase TIME_WITH_TIMEZONE, TIMESTAMP_WITH_TIMEZONE -> \"datetimeoffset($p)\";\n\t\t\tdefault -> super.columnType(sqlTypeCode);\n\t\t};\n\t}\n\n\t@Override\n\tprotected String castType(int sqlTypeCode) {\n\t\treturn switch (sqlTypeCode) {\n\t\t\tcase VARCHAR, LONG32VARCHAR, CLOB -> \"varchar(max)\";\n\t\t\tcase NVARCHAR, LONG32NVARCHAR, NCLOB -> \"nvarchar(max)\";\n\t\t\tcase VARBINARY, LONG32VARBINARY, BLOB -> \"varbinary(max)\";\n\t\t\tdefault -> super.castType( sqlTypeCode );\n\t\t};\n\t}\n\n\t@Override\n\tprotected void registerColumnTypes(TypeContributions typeContributions, ServiceRegistry serviceRegistry) {\n\t\tsuper.registerColumnTypes( typeContributions, serviceRegistry );\n\t\tfinal DdlTypeRegistry ddlTypeRegistry = typeContributions.getTypeConfiguration().getDdlTypeRegistry();\n\t\tddlTypeRegistry.addDescriptor( new DdlTypeImpl( GEOMETRY, \"geometry\", this ) );\n\t\tddlTypeRegistry.addDescriptor( new DdlTypeImpl( GEOGRAPHY, \"geography\", this ) );\n\t\tddlTypeRegistry.addDescriptor( new DdlTypeImpl( SQLXML, \"xml\", this ) );\n\t\tddlTypeRegistry.addDescriptor( new DdlTypeImpl( UUID, \"uniqueidentifier\", this ) );\n\t}\n\n\t@Override\n\tpublic JdbcType resolveSqlTypeDescriptor(\n\t\t\tString columnTypeName,\n\t\t\tint jdbcTypeCode,\n\t\t\tint precision,\n\t\t\tint scale,\n\t\t\tJdbcTypeRegistry jdbcTypeRegistry) {\n\t\tswitch ( jdbcTypeCode ) {\n\t\t\tcase OTHER:\n\t\t\t\tif ( columnTypeName.equals(\"uniqueidentifier\") ) {\n\t\t\t\t\tjdbcTypeCode = UUID;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase GEOMETRY_TYPE_CODE:\n\t\t\t\tjdbcTypeCode = GEOMETRY;\n\t\t\t\tbreak;\n\t\t\tcase GEOGRAPHY_TYPE_CODE:\n\t\t\t\tjdbcTypeCode = GEOGRAPHY;\n\t\t\t\tbreak;\n\t\t}\n\t\treturn super.resolveSqlTypeDescriptor( columnTypeName, jdbcTypeCode, precision, scale, jdbcTypeRegistry );\n\t}\n\n\t@Override\n\tpublic int getMaxVarcharLength() {\n\t\treturn 8000;\n\t}\n\n\t@Override\n\tpublic int getMaxNVarcharLength() {\n\t\treturn 4000;\n\t}\n\n\t@Override\n\tpublic TimeZoneSupport getTimeZoneSupport() {\n\t\treturn TimeZoneSupport.NATIVE;\n\t}\n\n\t@Override\n\tpublic long getDefaultLobLength() {\n\t\t// this is essentially the only legal length for\n\t\t// a \"lob\" in SQL Server, i.e. the value of MAX\n\t\t// (caveat: for NVARCHAR it is half this value)\n\t\treturn Length.LONG32;\n\t}\n\n\t@Override\n\tpublic int getMaxIdentifierLength() {\n\t\treturn 128;\n\t}\n\n\t@Override\n\tpublic void contributeTypes(TypeContributions typeContributions, ServiceRegistry serviceRegistry) {\n\t\tsuper.contributeTypes( typeContributions, serviceRegistry );\n\n\t\t// Need to bind as java.sql.Timestamp because reading OffsetDateTime from a \"datetime2\" column fails\n\t\ttypeContributions.contributeJdbcType( TimestampUtcAsJdbcTimestampJdbcType.INSTANCE );\n\n\t\ttypeContributions.getTypeConfiguration().getJdbcTypeRegistry().addDescriptor(\n\t\t\t\tTypes.TINYINT,\n\t\t\t\tTinyIntAsSmallIntJdbcType.INSTANCE\n\t\t);\n\t\ttypeContributions.contributeJdbcType( XmlJdbcType.INSTANCE );\n\t\ttypeContributions.contributeJdbcType( UUIDJdbcType.INSTANCE );\n\t}\n\n\t@Override\n\tpublic void initializeFunctionRegistry(FunctionContributions functionContributions) {\n\t\tsuper.initializeFunctionRegistry(functionContributions);\n\n\t\tfinal BasicTypeRegistry basicTypeRegistry = functionContributions.getTypeConfiguration().getBasicTypeRegistry();\n\t\tBasicType<Date> dateType = basicTypeRegistry.resolve( StandardBasicTypes.DATE );\n\t\tBasicType<Date> timeType = basicTypeRegistry.resolve( StandardBasicTypes.TIME );\n\t\tBasicType<Date> timestampType = basicTypeRegistry.resolve( StandardBasicTypes.TIMESTAMP );\n\n\t\tCommonFunctionFactory functionFactory = new CommonFunctionFactory(functionContributions);\n\n\t\t// For SQL-Server we need to cast certain arguments to varchar(max) to be able to concat them\n\t\tfunctionContributions.getFunctionRegistry().register(\n\t\t\t\t\"count\",\n\t\t\t\tnew CountFunction(\n\t\t\t\t\t\tthis,\n\t\t\t\t\t\tfunctionContributions.getTypeConfiguration(),\n\t\t\t\t\t\tSqlAstNodeRenderingMode.DEFAULT,\n\t\t\t\t\t\t\"count_big\",\n\t\t\t\t\t\t\"+\",\n\t\t\t\t\t\t\"varchar(max)\",\n\t\t\t\t\t\ttrue,\n\t\t\t\t\t\t\"varbinary(max)\"\n\t\t\t\t)\n\t\t);\n\n\t\t// AVG by default uses the input type, so we possibly need to cast the argument type, hence a special function\n\t\tfunctionFactory.avg_castingNonDoubleArguments( this, SqlAstNodeRenderingMode.DEFAULT );\n\n\t\tfunctionFactory.log_log();\n\n\t\tfunctionFactory.round_round();\n\t\tfunctionFactory.everyAny_minMaxIif();\n\t\tfunctionFactory.octetLength_pattern( \"datalength(?1)\" );\n\t\tfunctionFactory.bitLength_pattern( \"datalength(?1)*8\" );\n\n\t\tfunctionFactory.locate_charindex();\n\t\tfunctionFactory.stddevPopSamp_stdevp();\n\t\tfunctionFactory.varPopSamp_varp();\n\n\t\tfunctionContributions.getFunctionRegistry().register(\n\t\t\t\t\"format\",\n\t\t\t\tnew SQLServerFormatEmulation( functionContributions.getTypeConfiguration() )\n\t\t);\n\n\t\t//actually translate() was added in 2017 but\n\t\t//it's not worth adding a new dialect for that!\n\t\tfunctionFactory.translate();\n\n\t\tfunctionFactory.median_percentileCont( true );\n\n\t\tfunctionContributions.getFunctionRegistry().namedDescriptorBuilder( \"datefromparts\" )\n\t\t\t\t.setInvariantType( dateType )\n\t\t\t\t.setExactArgumentCount( 3 )\n\t\t\t\t.setParameterTypes(INTEGER)\n\t\t\t\t.register();\n\t\tfunctionContributions.getFunctionRegistry().namedDescriptorBuilder( \"timefromparts\" )\n\t\t\t\t.setInvariantType( timeType )\n\t\t\t\t.setExactArgumentCount( 5 )\n\t\t\t\t.setParameterTypes(INTEGER)\n\t\t\t\t.register();\n\t\tfunctionContributions.getFunctionRegistry().namedDescriptorBuilder( \"smalldatetimefromparts\" )\n\t\t\t\t.setInvariantType( timestampType )\n\t\t\t\t.setExactArgumentCount( 5 )\n\t\t\t\t.setParameterTypes(INTEGER)\n\t\t\t\t.register();\n\t\tfunctionContributions.getFunctionRegistry().namedDescriptorBuilder( \"datetimefromparts\" )\n\t\t\t\t.setInvariantType( timestampType )\n\t\t\t\t.setExactArgumentCount( 7 )\n\t\t\t\t.setParameterTypes(INTEGER)\n\t\t\t\t.register();\n\t\tfunctionContributions.getFunctionRegistry().namedDescriptorBuilder( \"datetime2fromparts\" )\n\t\t\t\t.setInvariantType( timestampType )\n\t\t\t\t.setExactArgumentCount( 8 )\n\t\t\t\t.setParameterTypes(INTEGER)\n\t\t\t\t.register();\n\t\tfunctionContributions.getFunctionRegistry().namedDescriptorBuilder( \"datetimeoffsetfromparts\" )\n\t\t\t\t.setInvariantType( timestampType )\n\t\t\t\t.setExactArgumentCount( 10 )\n\t\t\t\t.setParameterTypes(INTEGER)\n\t\t\t\t.register();\n\n\t\tfunctionFactory.windowFunctions();\n\t\tfunctionFactory.inverseDistributionOrderedSetAggregates_windowEmulation();\n\t\tfunctionFactory.hypotheticalOrderedSetAggregates_windowEmulation();\n\t\tif ( getVersion().isSameOrAfter( 14 ) ) {\n\t\t\tfunctionFactory.listagg_stringAggWithinGroup( \"varchar(max)\" );\n\t\t}\n\t\tif ( getVersion().isSameOrAfter( 16 ) ) {\n\t\t\tfunctionFactory.leastGreatest();\n\t\t\tfunctionFactory.dateTrunc_datetrunc();\n\t\t\tfunctionFactory.trunc_round_datetrunc();\n\t\t}\n\t\telse {\n\t\t\tfunctionContributions.getFunctionRegistry().register(\n\t\t\t\t\t\"trunc\",\n\t\t\t\t\tnew SqlServerConvertTruncFunction( functionContributions.getTypeConfiguration() )\n\t\t\t);\n\t\t\tfunctionContributions.getFunctionRegistry().registerAlternateKey( \"truncate\", \"trunc\" );\n\t\t}\n\t}\n\n\t@Override\n\tpublic String trimPattern(TrimSpec specification, boolean isWhitespace) {\n\t\tif ( getVersion().isSameOrAfter( 16 ) ) {\n\t\t\treturn switch (specification) {\n\t\t\t\tcase BOTH -> isWhitespace ? \"trim(?1)\" : \"trim(?2 from ?1)\";\n\t\t\t\tcase LEADING -> isWhitespace ? \"ltrim(?1)\" : \"ltrim(?1,?2)\";\n\t\t\t\tcase TRAILING -> isWhitespace ? \"rtrim(?1)\" : \"rtrim(?1,?2)\";\n\t\t\t};\n\t\t}\n\t\treturn super.trimPattern( specification, isWhitespace );\n\t}\n\n\t@Override\n\tpublic SqlAstTranslatorFactory getSqlAstTranslatorFactory() {\n\t\treturn new StandardSqlAstTranslatorFactory() {\n\t\t\t@Override\n\t\t\tprotected <T extends JdbcOperation> SqlAstTranslator<T> buildTranslator(\n\t\t\t\t\tSessionFactoryImplementor sessionFactory, Statement statement) {\n\t\t\t\treturn new SQLServerSqlAstTranslator<>( sessionFactory, statement );\n\t\t\t}\n\t\t};\n\t}\n\n\t@Override\n\tpublic SizeStrategy getSizeStrategy() {\n\t\treturn sizeStrategy;\n\t}\n\n\t@Override\n\tpublic String castPattern(CastType from, CastType to) {\n\t\tif ( to == CastType.STRING ) {\n\t\t\tswitch ( from ) {\n\t\t\t\tcase TIMESTAMP:\n\t\t\t\t\t// SQL Server uses yyyy-MM-dd HH:mm:ss.nnnnnnn by default when doing a cast, but only need second precision\n\t\t\t\t\treturn \"format(?1,'yyyy-MM-dd HH:mm:ss')\";\n\t\t\t\tcase TIME:\n\t\t\t\t\t// SQL Server uses HH:mm:ss.nnnnnnn by default when doing a cast, but only need second precision\n\t\t\t\t\t// SQL Server requires quoting of ':' in time formats and the use of 'hh' instead of 'HH'\n\t\t\t\t\treturn \"format(?1,'hh\\\\:mm\\\\:ss')\";\n\t\t\t}\n\t\t}\n\t\treturn super.castPattern( from, to );\n\t}\n\n\t@Override\n\tpublic String currentTimestamp() {\n\t\treturn \"sysdatetime()\";\n\t}\n\n\t@Override\n\tpublic IdentifierHelper buildIdentifierHelper(IdentifierHelperBuilder builder, DatabaseMetaData dbMetaData)\n\t\t\tthrows SQLException {\n\n\t\tif ( dbMetaData == null ) {\n\t\t\t// TODO: if DatabaseMetaData != null, unquoted case strategy is set to IdentifierCaseStrategy.UPPER\n\t\t\t//       Check to see if this setting is correct.\n\t\t\tbuilder.setUnquotedCaseStrategy( IdentifierCaseStrategy.MIXED );\n\t\t\tbuilder.setQuotedCaseStrategy( IdentifierCaseStrategy.MIXED );\n\t\t}\n\n\t\treturn super.buildIdentifierHelper( builder, dbMetaData );\n\t}\n\n\t@Override\n\tpublic String currentTime() {\n\t\treturn \"convert(time,getdate())\";\n\t}\n\n\t@Override\n\tpublic String currentDate() {\n\t\treturn \"convert(date,getdate())\";\n\t}\n\n\t@Override\n\tpublic String currentTimestampWithTimeZone() {\n\t\treturn \"sysdatetimeoffset()\";\n\t}\n\n\t@Override\n\tpublic String getNoColumnsInsertString() {\n\t\treturn \"default values\";\n\t}\n\n\t@Override\n\tpublic LimitHandler getLimitHandler() {\n\t\treturn SQLServer2012LimitHandler.INSTANCE;\n\t}\n\n\t@Override\n\tpublic boolean supportsValuesList() {\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean supportsDistinctFromPredicate() {\n\t\treturn getVersion().isSameOrAfter( 16 );\n\t}\n\n\t@Override\n\tpublic char closeQuote() {\n\t\treturn ']';\n\t}\n\n\t@Override\n\tpublic String getCurrentSchemaCommand() {\n\t\treturn \"select schema_name()\";\n\t}\n\n\t@Override\n\tpublic boolean supportsIfExistsBeforeTableName() {\n\t\treturn getVersion().isSameOrAfter( 16 ) || super.supportsIfExistsBeforeTableName();\n\t}\n\n\t@Override\n\tpublic boolean supportsIfExistsBeforeConstraintName() {\n\t\treturn getVersion().isSameOrAfter( 16 ) || super.supportsIfExistsBeforeConstraintName();\n\t}\n\n\t@Override\n\tpublic char openQuote() {\n\t\treturn '[';\n\t}\n\n\t@Override\n\tpublic String appendLockHint(LockOptions lockOptions, String tableName) {\n\t\tLockMode lockMode = lockOptions.getAliasSpecificLockMode( tableName );\n\t\tif ( lockMode == null ) {\n\t\t\tlockMode = lockOptions.getLockMode();\n\t\t}\n\n\t\tfinal String writeLockStr = lockOptions.getTimeOut() == LockOptions.SKIP_LOCKED ? \"updlock\" : \"updlock,holdlock\";\n\t\tfinal String readLockStr = lockOptions.getTimeOut() == LockOptions.SKIP_LOCKED ? \"updlock\" : \"holdlock\";\n\n\t\tfinal String noWaitStr = lockOptions.getTimeOut() == LockOptions.NO_WAIT ? \",nowait\" : \"\";\n\t\tfinal String skipLockStr = lockOptions.getTimeOut() == LockOptions.SKIP_LOCKED ? \",readpast\" : \"\";\n\n\t\treturn switch (lockMode) {\n\t\t\tcase PESSIMISTIC_WRITE, WRITE ->\n\t\t\t\t\ttableName + \" with (\" + writeLockStr + \",rowlock\" + noWaitStr + skipLockStr + \")\";\n\t\t\tcase PESSIMISTIC_READ -> tableName + \" with (\" + readLockStr + \",rowlock\" + noWaitStr + skipLockStr + \")\";\n\t\t\tcase UPGRADE_SKIPLOCKED -> tableName + \" with (updlock,rowlock,readpast\" + noWaitStr + \")\";\n\t\t\tcase UPGRADE_NOWAIT -> tableName + \" with (updlock,holdlock,rowlock,nowait)\";\n\t\t\tdefault -> tableName;\n\t\t};\n\t}\n\n\n\t/**\n\t * The current_timestamp is more accurate, but only known to be supported in SQL Server 7.0 and later and\n\t * Sybase not known to support it at all\n\t * <p>\n\t * {@inheritDoc}\n\t */\n\t@Override\n\tpublic String getCurrentTimestampSelectString() {\n\t\treturn \"select current_timestamp\";\n\t}\n\n\t// Overridden informational metadata ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n\t@Override\n\tpublic boolean supportsResultSetPositionQueryMethodsOnForwardOnlyCursor() {\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic boolean supportsCircularCascadeDeleteConstraints() {\n\t\t// SQL Server (at least up through 2005) does not support defining\n\t\t// cascade delete constraints which can circle back to the mutating\n\t\t// table\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic boolean supportsLobValueChangePropagation() {\n\t\t// note: at least my local SQL Server 2005 Express shows this not working...\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic boolean doesReadCommittedCauseWritersToBlockReaders() {\n\t\t// here assume SQLServer2005 using snapshot isolation, which does not have this problem\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic boolean doesRepeatableReadCauseReadersToBlockWriters() {\n\t\t// here assume SQLServer2005 using snapshot isolation, which does not have this problem\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic int getInExpressionCountLimit() {\n\t\treturn PARAM_LIST_SIZE_LIMIT;\n\t}\n\n\t@Override\n\tpublic IdentityColumnSupport getIdentityColumnSupport() {\n\t\treturn SQLServerIdentityColumnSupport.INSTANCE;\n\t}\n\n\t@Override\n\tpublic boolean supportsNonQueryWithCTE() {\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean supportsSkipLocked() {\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean supportsNoWait() {\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean supportsWait() {\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic SequenceSupport getSequenceSupport() {\n\t\treturn getVersion().isSameOrAfter( 16 )\n\t\t\t\t? SQLServer16SequenceSupport.INSTANCE\n\t\t\t\t: SQLServerSequenceSupport.INSTANCE;\n\t}\n\n\t@Override\n\tpublic String getQuerySequencesString() {\n\t\t// The upper-case name should work on both case-sensitive and case-insensitive collations.\n\t\treturn \"select * from INFORMATION_SCHEMA.SEQUENCES\";\n\t}\n\n\t@Override\n\tpublic String getQueryHintString(String sql, String hints) {\n\t\tfinal StringBuilder buffer =\n\t\t\t\tnew StringBuilder( sql.length() + hints.length() + 12 );\n\t\tfinal int pos = sql.indexOf( ';' );\n\t\tif ( pos > -1 ) {\n\t\t\tbuffer.append( sql, 0, pos );\n\t\t}\n\t\telse {\n\t\t\tbuffer.append( sql );\n\t\t}\n\t\tbuffer.append( \" OPTION (\" ).append( hints ).append( \")\" );\n\t\tif ( pos > -1 ) {\n\t\t\tbuffer.append( \";\" );\n\t\t}\n\t\tsql = buffer.toString();\n\t\treturn sql;\n\t}\n\n\t@Override\n\tpublic boolean supportsNullPrecedence() {\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic boolean supportsOffsetInSubquery() {\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean supportsWindowFunctions() {\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean supportsLateral() {\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean supportsRecursiveCTE() {\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean supportsFetchClause(FetchClauseType type) {\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic ViolatedConstraintNameExtractor getViolatedConstraintNameExtractor() {\n\t\treturn new TemplatedViolatedConstraintNameExtractor(\n\t\t\t\tsqle -> {\n\t\t\t\t\tswitch ( extractErrorCode( sqle ) ) {\n\t\t\t\t\t\tcase 2627:\n\t\t\t\t\t\tcase 2601:\n\t\t\t\t\t\t\tString message = sqle.getMessage();\n\t\t\t\t\t\t\tif ( message.contains(\"unique index \") ) {\n\t\t\t\t\t\t\t\treturn extractUsingTemplate( \"unique index '\", \"'\", message);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\treturn extractUsingTemplate( \"'\", \"'\", message);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t);\n\t}\n\n\t@Override\n\tpublic SQLExceptionConversionDelegate buildSQLExceptionConversionDelegate() {\n\t\treturn (sqlException, message, sql) -> {\n\t\t\tfinal String sqlState = extractSqlState( sqlException );\n\t\t\tif ( \"HY008\".equals( sqlState ) ) {\n\t\t\t\treturn new QueryTimeoutException( message, sqlException, sql );\n\t\t\t}\n\n\t\t\treturn switch ( extractErrorCode( sqlException ) ) {\n\t\t\t\tcase 1222 -> new LockTimeoutException( message, sqlException, sql );\n\t\t\t\tcase 2627, 2601 -> new ConstraintViolationException(\n\t\t\t\t\t\tmessage,\n\t\t\t\t\t\tsqlException,\n\t\t\t\t\t\tsql,\n\t\t\t\t\t\tConstraintViolationException.ConstraintKind.UNIQUE,\n\t\t\t\t\t\tgetViolatedConstraintNameExtractor().extractConstraintName( sqlException )\n\t\t\t\t);\n\t\t\t\tdefault -> null;\n\t\t\t};\n\t\t};\n\t}\n\n\t@Override\n\tpublic int getDefaultTimestampPrecision() {\n\t\treturn 7;\n\t}\n\n\t/**\n\t * Even though SQL Server only supports 1/10th microsecond precision,\n\t * we use nanosecond as the \"native\" precision for datetime arithmetic\n\t * since it simplifies calculations.\n\t */\n\t@Override\n\tpublic long getFractionalSecondPrecisionInNanos() {\n//\t\treturn 100; // 1/10th microsecond\n\t\treturn 1;\n\t}\n\n\t@Override\n\tpublic String extractPattern(TemporalUnit unit) {\n\t\treturn switch (unit) {\n\t\t\tcase TIMEZONE_HOUR -> \"(datepart(tz,?2)/60)\";\n\t\t\tcase TIMEZONE_MINUTE -> \"(datepart(tz,?2)%60)\";\n\t\t\t// currently Dialect.extract() doesn't need\n\t\t\t// to handle NANOSECOND (might change that?)\n//\t\t\tcase NANOSECOND ->\n//\t\t\t\t// this should evaluate to a bigint type\n//\t\t\t\t\t\"(datepart(second,?2)*1000000000+datepart(nanosecond,?2))\";\n\t\t\tcase SECOND ->\n\t\t\t\t//this should evaluate to a floating point type\n\t\t\t\t\t\"(datepart(second,?2)+datepart(nanosecond,?2)/1000000000)\";\n\t\t\tcase EPOCH -> \"datediff_big(second, '1970-01-01', ?2)\";\n\t\t\tdefault -> \"datepart(?1,?2)\";\n\t\t};\n\t}\n\n\t@Override @SuppressWarnings(\"deprecation\")\n\tpublic String timestampaddPattern(TemporalUnit unit, TemporalType temporalType, IntervalType intervalType) {\n\t\t// dateadd() supports only especially small magnitudes\n\t\t// since it casts its argument to int (and unfortunately\n\t\t// there's no dateadd_big()) so here we need to use two\n\t\t// calls to dateadd() to add a whole duration\n\t\treturn switch (unit) { //use nanosecond as the \"native\" precision\n\t\t\tcase NANOSECOND, NATIVE -> \"dateadd(nanosecond,?2%1000000000,dateadd(second,?2/1000000000,?3))\";\n\t\t\t// we could, in principle, use 1/10th microsecond as the \"native\" precision\n//\t\t\tcase NATIVE -> \"dateadd(nanosecond,?2%10000000,dateadd(second,?2/10000000,?3))\";\n\t\t\tcase SECOND -> \"dateadd(nanosecond,cast(?2*1e9 as bigint)%1000000000,dateadd(second,?2,?3))\";\n\t\t\tdefault -> \"dateadd(?1,?2,?3)\";\n\t\t};\n\t}\n\n\t@Override @SuppressWarnings(\"deprecation\")\n\tpublic String timestampdiffPattern(TemporalUnit unit, TemporalType fromTemporalType, TemporalType toTemporalType) {\n\t\tif ( unit == TemporalUnit.NATIVE ) {\n\t\t\t//use nanosecond as the \"native\" precision\n\t\t\treturn \"datediff_big(nanosecond,?2,?3)\";\n\t\t}\n\t\telse {\n\t\t\t//datediff() returns an int, and can easily\n\t\t\t//overflow when dealing with \"physical\"\n\t\t\t//durations, so use datediff_big()\n\t\t\treturn unit.normalized() == NANOSECOND\n\t\t\t\t\t? \"datediff_big(?1,?2,?3)\"\n\t\t\t\t\t: \"datediff(?1,?2,?3)\";\n\t\t}\n\t}\n\n\t@Override\n\tpublic String translateDurationField(TemporalUnit unit) {\n\t\t//use nanosecond as the \"native\" precision\n\t\treturn unit == TemporalUnit.NATIVE\n\t\t\t\t? \"nanosecond\"\n\t\t\t\t: super.translateDurationField( unit );\n\t}\n\n\t@Override\n\tpublic String translateExtractField(TemporalUnit unit) {\n\t\treturn switch (unit) {\n\t\t\t//the ISO week number (behavior of \"week\" depends on a system property)\n\t\t\tcase WEEK -> \"isowk\";\n\t\t\tcase OFFSET -> \"tz\";\n\t\t\tdefault -> super.translateExtractField( unit );\n\t\t};\n\t}\n\n\t@Override\n\tpublic void appendDatetimeFormat(SqlAppender appender, String format) {\n\t\tappender.appendSql( datetimeFormat(format).result() );\n\t}\n\n\tpublic static Replacer datetimeFormat(String format) {\n\t\treturn new Replacer( format, \"'\", \"\\\"\" )\n\t\t\t\t//era\n\t\t\t\t.replace(\"G\", \"g\")\n\n\t\t\t\t//y nothing to do\n\t\t\t\t//M nothing to do\n\n\t\t\t\t//w no equivalent\n\t\t\t\t//W no equivalent\n\t\t\t\t//Y no equivalent\n\n\t\t\t\t//day of week\n\t\t\t\t.replace(\"EEEE\", \"dddd\")\n\t\t\t\t.replace(\"EEE\", \"ddd\")\n\t\t\t\t//e no equivalent\n\n\t\t\t\t//d nothing to do\n\t\t\t\t//D no equivalent\n\n\t\t\t\t//am pm\n\t\t\t\t.replace(\"a\", \"tt\")\n\n\t\t\t\t//h nothing to do\n\t\t\t\t//H nothing to do\n\n\t\t\t\t//m nothing to do\n\t\t\t\t//s nothing to do\n\n\t\t\t\t//fractional seconds\n\t\t\t\t.replace(\"S\", \"F\")\n\n\t\t\t\t//timezones\n\t\t\t\t.replace(\"XXX\", \"K\") //UTC represented as \"Z\"\n\t\t\t\t.replace(\"xxx\", \"zzz\")\n\t\t\t\t.replace(\"x\", \"zz\");\n\t}\n\n\t@Override\n\tpublic void appendUUIDLiteral(SqlAppender appender, java.util.UUID literal) {\n\t\tappender.appendSql( \"cast('\" );\n\t\tappender.appendSql( literal.toString() );\n\t\tappender.appendSql( \"' as uniqueidentifier)\" );\n\t}\n\n\t@Override\n\tpublic void appendDateTimeLiteral(\n\t\t\tSqlAppender appender,\n\t\t\tTemporalAccessor temporalAccessor,\n\t\t\t@SuppressWarnings(\"deprecation\")\n\t\t\tTemporalType precision,\n\t\t\tTimeZone jdbcTimeZone) {\n\t\tswitch ( precision ) {\n\t\t\tcase DATE:\n\t\t\t\tappender.appendSql( \"cast('\" );\n\t\t\t\tappendAsDate( appender, temporalAccessor );\n\t\t\t\tappender.appendSql( \"' as date)\" );\n\t\t\t\tbreak;\n\t\t\tcase TIME:\n\t\t\t\t//needed because the {t ... } JDBC is just buggy\n\t\t\t\tappender.appendSql( \"cast('\" );\n\t\t\t\tappendAsTime( appender, temporalAccessor, supportsTemporalLiteralOffset(), jdbcTimeZone );\n\t\t\t\tappender.appendSql( \"' as time)\" );\n\t\t\t\tbreak;\n\t\t\tcase TIMESTAMP:\n\t\t\t\tappender.appendSql( \"cast('\" );\n\t\t\t\t//needed because the {ts ... } JDBC escape chokes on microseconds\n\t\t\t\tif ( supportsTemporalLiteralOffset() && temporalAccessor.isSupported( ChronoField.OFFSET_SECONDS ) ) {\n\t\t\t\t\tappendAsTimestampWithMicros( appender, temporalAccessor, true, jdbcTimeZone );\n\t\t\t\t\tappender.appendSql( \"' as datetimeoffset)\" );\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tappendAsTimestampWithMicros( appender, temporalAccessor, false, jdbcTimeZone );\n\t\t\t\t\tappender.appendSql( \"' as datetime2)\" );\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new IllegalArgumentException();\n\t\t}\n\t}\n\n\t@Override\n\tpublic void appendDateTimeLiteral(\n\t\t\tSqlAppender appender,\n\t\t\tDate date,\n\t\t\t@SuppressWarnings(\"deprecation\")\n\t\t\tTemporalType precision,\n\t\t\tTimeZone jdbcTimeZone) {\n\t\tswitch ( precision ) {\n\t\t\tcase DATE:\n\t\t\t\tappender.appendSql( \"cast('\" );\n\t\t\t\tappendAsDate( appender, date );\n\t\t\t\tappender.appendSql( \"' as date)\" );\n\t\t\t\tbreak;\n\t\t\tcase TIME:\n\t\t\t\t//needed because the {t ... } JDBC is just buggy\n\t\t\t\tappender.appendSql( \"cast('\" );\n\t\t\t\tappendAsTime( appender, date );\n\t\t\t\tappender.appendSql( \"' as time)\" );\n\t\t\t\tbreak;\n\t\t\tcase TIMESTAMP:\n\t\t\t\tappender.appendSql( \"cast('\" );\n\t\t\t\tappendAsTimestampWithMicros( appender, date, jdbcTimeZone );\n\t\t\t\tappender.appendSql( \"' as datetimeoffset)\" );\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new IllegalArgumentException();\n\t\t}\n\t}\n\n\t@Override\n\tpublic void appendDateTimeLiteral(\n\t\t\tSqlAppender appender,\n\t\t\tCalendar calendar,\n\t\t\t@SuppressWarnings(\"deprecation\")\n\t\t\tTemporalType precision,\n\t\t\tTimeZone jdbcTimeZone) {\n\t\tswitch ( precision ) {\n\t\t\tcase DATE:\n\t\t\t\tappender.appendSql( \"cast('\" );\n\t\t\t\tappendAsDate( appender, calendar );\n\t\t\t\tappender.appendSql( \"' as date)\" );\n\t\t\t\tbreak;\n\t\t\tcase TIME:\n\t\t\t\t//needed because the {t ... } JDBC is just buggy\n\t\t\t\tappender.appendSql( \"cast('\" );\n\t\t\t\tappendAsTime( appender, calendar );\n\t\t\t\tappender.appendSql( \"' as time)\" );\n\t\t\t\tbreak;\n\t\t\tcase TIMESTAMP:\n\t\t\t\tappender.appendSql( \"cast('\" );\n\t\t\t\tappendAsTimestampWithMillis( appender, calendar, jdbcTimeZone );\n\t\t\t\tappender.appendSql( \"' as datetime2)\" );\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new IllegalArgumentException();\n\t\t}\n\t}\n\n\t@Override\n\tpublic String getCreateTemporaryTableColumnAnnotation(int sqlTypeCode) {\n\t\treturn switch (sqlTypeCode) {\n\t\t\tcase Types.CHAR, Types.NCHAR, Types.VARCHAR, Types.NVARCHAR, Types.LONGVARCHAR, Types.LONGNVARCHAR ->\n\t\t\t\t\t\"collate database_default\";\n\t\t\tdefault -> \"\";\n\t\t};\n\t}\n\n\t@Override\n\tpublic String[] getDropSchemaCommand(String schemaName) {\n\t\treturn getVersion().isSameOrAfter( 13 )\n\t\t\t\t? new String[] { \"drop schema if exists \" + schemaName }\n\t\t\t\t: super.getDropSchemaCommand( schemaName );\n\t}\n\n\t@Override\n\tpublic String getCreateIndexString(boolean unique) {\n\t\t// we only create unique indexes, as opposed to unique constraints,\n\t\t// when the column is nullable, so safe to infer unique => nullable\n\t\treturn unique ? \"create unique nonclustered index\" : \"create index\";\n\t}\n\n\t@Override\n\tpublic String getCreateIndexTail(boolean unique, List<Column> columns) {\n\t\tif ( unique ) {\n\t\t\tfinal StringBuilder tail = new StringBuilder();\n\t\t\tfor ( Column column : columns ) {\n\t\t\t\tif ( column.isNullable() ) {\n\t\t\t\t\ttail.append( tail.isEmpty() ? \" where \" : \" and \" )\n\t\t\t\t\t\t\t.append( column.getQuotedName( this ) )\n\t\t\t\t\t\t\t.append( \" is not null\" );\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn tail.toString();\n\t\t}\n\t\telse {\n\t\t\treturn \"\";\n\t\t}\n\t}\n\n\t@Override\n\tpublic String getAlterColumnTypeString(String columnName, String columnType, String columnDefinition) {\n\t\treturn \"alter column \" + columnName + \" \" + columnType;\n\t}\n\n\t@Override\n\tpublic boolean supportsAlterColumnType() {\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic NameQualifierSupport getNameQualifierSupport() {\n\t\treturn NameQualifierSupport.BOTH;\n\t}\n\n\t@Override\n\tpublic UniqueDelegate getUniqueDelegate() {\n\t\treturn uniqueDelegate;\n\t}\n\n\t@Override\n\tpublic Exporter<Sequence> getSequenceExporter() {\n\t\treturn exporter == null ? super.getSequenceExporter() : exporter;\n\t}\n\n\tprivate static class SqlServerSequenceExporter extends StandardSequenceExporter {\n\n\t\tpublic SqlServerSequenceExporter(Dialect dialect) {\n\t\t\tsuper( dialect );\n\t\t}\n\n\t\t@Override\n\t\tprotected String getFormattedSequenceName(QualifiedSequenceName name, Metadata metadata,\n\t\t\t\tSqlStringGenerationContext context) {\n\t\t\t// SQL Server does not allow the catalog in the sequence name.\n\t\t\t// See https://docs.microsoft.com/en-us/sql/t-sql/statements/create-sequence-transact-sql?view=sql-server-ver15&viewFallbackFrom=sql-server-ver12\n\t\t\t// Keeping the catalog in the name does not break on ORM, but it fails using Vert.X for Reactive.\n\t\t\treturn context.formatWithoutCatalog( name );\n\t\t}\n\t}\n\n\t@Override\n\tpublic String generatedAs(String generatedAs) {\n\t\treturn \" as (\" + generatedAs + \") persisted\";\n\t}\n\n\t@Override\n\tpublic boolean hasDataTypeBeforeGeneratedAs() {\n\t\treturn false;\n\t}\n\n\t// disabled foreign key constraints still prevent 'truncate table'\n\t// (these would help if we used 'delete' instead of 'truncate')\n\n//\t@Override\n//\tpublic String getDisableConstraintStatement(String tableName, String name) {\n//\t\treturn \"alter table \" + tableName + \" nocheck constraint \" + name;\n//\t}\n//\n//\t@Override\n//\tpublic String getEnableConstraintStatement(String tableName, String name) {\n//\t\treturn \"alter table \" + tableName + \" with check check constraint \" + name;\n//\t}\n\n\n\t@Override\n\tpublic MutationOperation createOptionalTableUpdateOperation(\n\t\t\tEntityMutationTarget mutationTarget,\n\t\t\tOptionalTableUpdate optionalTableUpdate,\n\t\t\tSessionFactoryImplementor factory) {\n\t\tfinal SQLServerSqlAstTranslator<JdbcOperation> translator =\n\t\t\t\tnew SQLServerSqlAstTranslator<>( factory, optionalTableUpdate );\n\t\treturn translator.createMergeOperation( optionalTableUpdate );\n\t}\n\n\t@Override\n\tpublic DmlTargetColumnQualifierSupport getDmlTargetColumnQualifierSupport() {\n\t\treturn DmlTargetColumnQualifierSupport.TABLE_ALIAS;\n\t}\n\n\t@Override\n\tpublic boolean supportsFromClauseInUpdate() {\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic CallableStatementSupport getCallableStatementSupport() {\n\t\treturn SQLServerCallableStatementSupport.INSTANCE;\n\t}\n\n\t@Override\n\tpublic String getCheckConstraintString(CheckConstraint checkConstraint) {\n\t\tfinal String constraintName = checkConstraint.getName();\n\t\treturn constraintName == null\n\t\t\t\t? \" check \" + getCheckConstraintOptions( checkConstraint )\n\t\t\t\t\t\t+ \"(\" + checkConstraint.getConstraint() + \")\"\n\t\t\t\t: \" constraint \" + constraintName + \" check \" + getCheckConstraintOptions( checkConstraint )\n\t\t\t\t\t\t+ \"(\" + checkConstraint.getConstraint() + \")\";\n\t}\n\n\tprivate String getCheckConstraintOptions(CheckConstraint checkConstraint) {\n\t\treturn isNotEmpty( checkConstraint.getOptions() ) ? checkConstraint.getOptions() + \" \" : \"\";\n\t}\n}\n",
        "filePathAfter": "hibernate-core/src/main/java/org/hibernate/dialect/SQLServerDialect.java",
        "sourceCodeAfterForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.\n */\npackage org.hibernate.dialect;\n\nimport java.sql.DatabaseMetaData;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Types;\nimport java.time.temporal.ChronoField;\nimport java.time.temporal.TemporalAccessor;\nimport java.util.Calendar;\nimport java.util.Date;\nimport java.util.List;\nimport java.util.TimeZone;\n\nimport org.hibernate.Length;\nimport org.hibernate.LockMode;\nimport org.hibernate.LockOptions;\nimport org.hibernate.QueryTimeoutException;\nimport org.hibernate.boot.Metadata;\nimport org.hibernate.boot.model.FunctionContributions;\nimport org.hibernate.boot.model.TypeContributions;\nimport org.hibernate.boot.model.relational.QualifiedSequenceName;\nimport org.hibernate.boot.model.relational.Sequence;\nimport org.hibernate.boot.model.relational.SqlStringGenerationContext;\nimport org.hibernate.dialect.function.CommonFunctionFactory;\nimport org.hibernate.dialect.function.CountFunction;\nimport org.hibernate.dialect.function.SQLServerFormatEmulation;\nimport org.hibernate.dialect.function.SqlServerConvertTruncFunction;\nimport org.hibernate.dialect.identity.IdentityColumnSupport;\nimport org.hibernate.dialect.identity.SQLServerIdentityColumnSupport;\nimport org.hibernate.dialect.pagination.LimitHandler;\nimport org.hibernate.dialect.pagination.SQLServer2012LimitHandler;\nimport org.hibernate.dialect.sequence.SQLServer16SequenceSupport;\nimport org.hibernate.dialect.sequence.SQLServerSequenceSupport;\nimport org.hibernate.dialect.sequence.SequenceSupport;\nimport org.hibernate.dialect.unique.AlterTableUniqueIndexDelegate;\nimport org.hibernate.dialect.unique.UniqueDelegate;\nimport org.hibernate.engine.jdbc.Size;\nimport org.hibernate.engine.jdbc.dialect.spi.BasicSQLExceptionConverter;\nimport org.hibernate.engine.jdbc.dialect.spi.DialectResolutionInfo;\nimport org.hibernate.engine.jdbc.env.spi.IdentifierCaseStrategy;\nimport org.hibernate.engine.jdbc.env.spi.IdentifierHelper;\nimport org.hibernate.engine.jdbc.env.spi.IdentifierHelperBuilder;\nimport org.hibernate.engine.jdbc.env.spi.NameQualifierSupport;\nimport org.hibernate.engine.spi.SessionFactoryImplementor;\nimport org.hibernate.exception.ConstraintViolationException;\nimport org.hibernate.exception.LockTimeoutException;\nimport org.hibernate.exception.spi.SQLExceptionConversionDelegate;\nimport org.hibernate.exception.spi.TemplatedViolatedConstraintNameExtractor;\nimport org.hibernate.exception.spi.ViolatedConstraintNameExtractor;\nimport org.hibernate.internal.util.JdbcExceptionHelper;\nimport org.hibernate.internal.util.config.ConfigurationHelper;\nimport org.hibernate.internal.util.StringHelper;\nimport org.hibernate.mapping.CheckConstraint;\nimport org.hibernate.mapping.Column;\nimport org.hibernate.persister.entity.mutation.EntityMutationTarget;\nimport org.hibernate.procedure.internal.SQLServerCallableStatementSupport;\nimport org.hibernate.procedure.spi.CallableStatementSupport;\nimport org.hibernate.query.sqm.CastType;\nimport org.hibernate.query.sqm.FetchClauseType;\nimport org.hibernate.query.sqm.IntervalType;\nimport org.hibernate.query.sqm.TemporalUnit;\nimport org.hibernate.query.sqm.TrimSpec;\nimport org.hibernate.service.ServiceRegistry;\nimport org.hibernate.sql.ast.SqlAstNodeRenderingMode;\nimport org.hibernate.sql.ast.SqlAstTranslator;\nimport org.hibernate.sql.ast.SqlAstTranslatorFactory;\nimport org.hibernate.sql.ast.spi.SqlAppender;\nimport org.hibernate.sql.ast.spi.StandardSqlAstTranslatorFactory;\nimport org.hibernate.sql.ast.tree.Statement;\nimport org.hibernate.sql.exec.spi.JdbcOperation;\nimport org.hibernate.sql.model.MutationOperation;\nimport org.hibernate.sql.model.internal.OptionalTableUpdate;\nimport org.hibernate.tool.schema.internal.StandardSequenceExporter;\nimport org.hibernate.tool.schema.spi.Exporter;\nimport org.hibernate.type.BasicType;\nimport org.hibernate.type.BasicTypeRegistry;\nimport org.hibernate.type.StandardBasicTypes;\nimport org.hibernate.type.descriptor.java.JavaType;\nimport org.hibernate.type.descriptor.jdbc.JdbcType;\nimport org.hibernate.type.descriptor.jdbc.TimestampUtcAsJdbcTimestampJdbcType;\nimport org.hibernate.type.descriptor.jdbc.TinyIntAsSmallIntJdbcType;\nimport org.hibernate.type.descriptor.jdbc.UUIDJdbcType;\nimport org.hibernate.type.descriptor.jdbc.XmlJdbcType;\nimport org.hibernate.type.descriptor.jdbc.spi.JdbcTypeRegistry;\nimport org.hibernate.type.descriptor.sql.internal.DdlTypeImpl;\nimport org.hibernate.type.descriptor.sql.spi.DdlTypeRegistry;\n\nimport jakarta.persistence.TemporalType;\n\nimport static org.hibernate.cfg.DialectSpecificSettings.SQL_SERVER_COMPATIBILITY_LEVEL;\nimport static org.hibernate.exception.spi.TemplatedViolatedConstraintNameExtractor.extractUsingTemplate;\nimport static org.hibernate.internal.util.JdbcExceptionHelper.extractErrorCode;\nimport static org.hibernate.internal.util.JdbcExceptionHelper.extractSqlState;\nimport static org.hibernate.internal.util.StringHelper.isNotEmpty;\nimport static org.hibernate.query.sqm.TemporalUnit.NANOSECOND;\nimport static org.hibernate.query.sqm.produce.function.FunctionParameterType.INTEGER;\nimport static org.hibernate.type.SqlTypes.BLOB;\nimport static org.hibernate.type.SqlTypes.CLOB;\nimport static org.hibernate.type.SqlTypes.DATE;\nimport static org.hibernate.type.SqlTypes.DOUBLE;\nimport static org.hibernate.type.SqlTypes.GEOGRAPHY;\nimport static org.hibernate.type.SqlTypes.GEOMETRY;\nimport static org.hibernate.type.SqlTypes.LONG32NVARCHAR;\nimport static org.hibernate.type.SqlTypes.LONG32VARBINARY;\nimport static org.hibernate.type.SqlTypes.LONG32VARCHAR;\nimport static org.hibernate.type.SqlTypes.NCLOB;\nimport static org.hibernate.type.SqlTypes.NVARCHAR;\nimport static org.hibernate.type.SqlTypes.OTHER;\nimport static org.hibernate.type.SqlTypes.SQLXML;\nimport static org.hibernate.type.SqlTypes.TIME;\nimport static org.hibernate.type.SqlTypes.TIMESTAMP;\nimport static org.hibernate.type.SqlTypes.TIMESTAMP_WITH_TIMEZONE;\nimport static org.hibernate.type.SqlTypes.TIME_WITH_TIMEZONE;\nimport static org.hibernate.type.SqlTypes.UUID;\nimport static org.hibernate.type.SqlTypes.VARBINARY;\nimport static org.hibernate.type.SqlTypes.VARCHAR;\nimport static org.hibernate.type.descriptor.DateTimeUtils.appendAsDate;\nimport static org.hibernate.type.descriptor.DateTimeUtils.appendAsTime;\nimport static org.hibernate.type.descriptor.DateTimeUtils.appendAsTimestampWithMicros;\nimport static org.hibernate.type.descriptor.DateTimeUtils.appendAsTimestampWithMillis;\n\n/**\n * A dialect for Microsoft SQL Server 2008 and above\n *\n * @author Gavin King\n */\npublic class SQLServerDialect extends AbstractTransactSQLDialect {\n\tprivate final static DatabaseVersion MINIMUM_VERSION = DatabaseVersion.make( 11, 0 );\n\n\t/**\n\t * NOTE : 2100 is the documented limit supposedly - but in my testing, sending\n\t * 2100 parameters fails saying it must be less than 2100.\n\t */\n\tprivate static final int PARAM_LIST_SIZE_LIMIT = 2048;\n\n\t// See microsoft.sql.Types.GEOMETRY\n\tprivate static final int GEOMETRY_TYPE_CODE = -157;\n\t// See microsoft.sql.Types.GEOGRAPHY\n\tprivate static final int GEOGRAPHY_TYPE_CODE = -158;\n\n\tprivate final StandardSequenceExporter exporter;\n\tprivate final UniqueDelegate uniqueDelegate = new AlterTableUniqueIndexDelegate(this);\n\n\tprivate final SizeStrategy sizeStrategy = new SizeStrategyImpl() {\n\t\t@Override\n\t\tpublic Size resolveSize(\n\t\t\t\tJdbcType jdbcType,\n\t\t\t\tJavaType<?> javaType,\n\t\t\t\tInteger precision,\n\t\t\t\tInteger scale,\n\t\t\t\tLong length) {\n\t\t\treturn switch ( jdbcType.getDdlTypeCode() ) {\n\t\t\t\tcase BLOB, CLOB, NCLOB ->\n\t\t\t\t\t\tsuper.resolveSize( jdbcType, javaType, precision, scale,\n\t\t\t\t\t\t\t\tlength == null ? getDefaultLobLength() : length );\n\t\t\t\tdefault -> super.resolveSize( jdbcType, javaType, precision, scale, length );\n\t\t\t};\n\t\t}\n\t};\n\n\tpublic SQLServerDialect() {\n\t\tthis( MINIMUM_VERSION );\n\t}\n\n\tpublic SQLServerDialect(DatabaseVersion version) {\n\t\tsuper(version);\n\t\texporter = createSequenceExporter(version);\n\t}\n\n\tpublic SQLServerDialect(DialectResolutionInfo info) {\n\t\tthis( staticDetermineDatabaseVersion( info ) );\n\t\tregisterKeywords( info );\n\t}\n\n\t@Override\n\tpublic DatabaseVersion determineDatabaseVersion(DialectResolutionInfo info) {\n\t\treturn staticDetermineDatabaseVersion(info);\n\t}\n\n\t// Static version necessary to call from constructor\n\tprivate static DatabaseVersion staticDetermineDatabaseVersion(DialectResolutionInfo info) {\n\t\tfinal Integer compatibilityLevel = getCompatibilityLevel( info );\n\t\tif ( compatibilityLevel != null ) {\n\t\t\tfinal int majorVersion = compatibilityLevel / 10;\n\t\t\tfinal int minorVersion = compatibilityLevel % 10;\n\t\t\treturn DatabaseVersion.make( majorVersion, minorVersion );\n\t\t}\n\t\treturn info.makeCopyOrDefault( MINIMUM_VERSION );\n\t}\n\n\tprivate static Integer getCompatibilityLevel(DialectResolutionInfo info) {\n\t\tfinal DatabaseMetaData databaseMetaData = info.getDatabaseMetadata();\n\t\tif ( databaseMetaData != null ) {\n\t\t\ttry ( java.sql.Statement statement = databaseMetaData.getConnection().createStatement() ) {\n\t\t\t\tfinal ResultSet rs = statement.executeQuery( \"SELECT compatibility_level FROM sys.databases where name = db_name();\" );\n\t\t\t\tif ( rs.next() ) {\n\t\t\t\t\treturn rs.getInt( 1 );\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (SQLException e) {\n\t\t\t\tthrow BasicSQLExceptionConverter.INSTANCE.convert( e );\n\t\t\t}\n\t\t}\n\n\t\t// default to the dialect-specific configuration setting\n\t\treturn ConfigurationHelper.getInteger( SQL_SERVER_COMPATIBILITY_LEVEL, info.getConfigurationValues() );\n\t}\n\n\tprivate StandardSequenceExporter createSequenceExporter(DatabaseVersion version) {\n\t\treturn new SqlServerSequenceExporter(this);\n\t}\n\n\t@Override\n\tprotected DatabaseVersion getMinimumSupportedVersion() {\n\t\treturn MINIMUM_VERSION;\n\t}\n\n\t@Override\n\tprotected void registerDefaultKeywords() {\n\t\tsuper.registerDefaultKeywords();\n\t\tregisterKeyword( \"top\" );\n\t\tregisterKeyword( \"key\" );\n\t}\n\n\t@Override\n\tprotected String columnType(int sqlTypeCode) {\n\t\treturn switch (sqlTypeCode) {\n\t\t\t// there is no 'double' type in SQL server\n\t\t\t// but 'float' is double precision by default\n\t\t\tcase DOUBLE -> \"float\";\n\t\t\t// Prefer 'varchar(max)' and 'varbinary(max)' to\n\t\t\t// the deprecated TEXT and IMAGE types. Note that\n\t\t\t// the length of a VARCHAR or VARBINARY column must\n\t\t\t// be either between 1 and 8000 or exactly MAX, and\n\t\t\t// the length of an NVARCHAR column must be either\n\t\t\t// between 1 and 4000 or exactly MAX. (HHH-3965)\n\t\t\tcase CLOB -> \"varchar(max)\";\n\t\t\tcase NCLOB -> \"nvarchar(max)\";\n\t\t\tcase BLOB -> \"varbinary(max)\";\n\t\t\tcase DATE -> \"date\";\n\t\t\tcase TIME -> \"time\";\n\t\t\tcase TIMESTAMP -> \"datetime2($p)\";\n\t\t\tcase TIME_WITH_TIMEZONE, TIMESTAMP_WITH_TIMEZONE -> \"datetimeoffset($p)\";\n\t\t\tdefault -> super.columnType(sqlTypeCode);\n\t\t};\n\t}\n\n\t@Override\n\tprotected String castType(int sqlTypeCode) {\n\t\treturn switch (sqlTypeCode) {\n\t\t\tcase VARCHAR, LONG32VARCHAR, CLOB -> \"varchar(max)\";\n\t\t\tcase NVARCHAR, LONG32NVARCHAR, NCLOB -> \"nvarchar(max)\";\n\t\t\tcase VARBINARY, LONG32VARBINARY, BLOB -> \"varbinary(max)\";\n\t\t\tdefault -> super.castType( sqlTypeCode );\n\t\t};\n\t}\n\n\t@Override\n\tprotected void registerColumnTypes(TypeContributions typeContributions, ServiceRegistry serviceRegistry) {\n\t\tsuper.registerColumnTypes( typeContributions, serviceRegistry );\n\t\tfinal DdlTypeRegistry ddlTypeRegistry = typeContributions.getTypeConfiguration().getDdlTypeRegistry();\n\t\tddlTypeRegistry.addDescriptor( new DdlTypeImpl( GEOMETRY, \"geometry\", this ) );\n\t\tddlTypeRegistry.addDescriptor( new DdlTypeImpl( GEOGRAPHY, \"geography\", this ) );\n\t\tddlTypeRegistry.addDescriptor( new DdlTypeImpl( SQLXML, \"xml\", this ) );\n\t\tddlTypeRegistry.addDescriptor( new DdlTypeImpl( UUID, \"uniqueidentifier\", this ) );\n\t}\n\n\t@Override\n\tpublic JdbcType resolveSqlTypeDescriptor(\n\t\t\tString columnTypeName,\n\t\t\tint jdbcTypeCode,\n\t\t\tint precision,\n\t\t\tint scale,\n\t\t\tJdbcTypeRegistry jdbcTypeRegistry) {\n\t\tswitch ( jdbcTypeCode ) {\n\t\t\tcase OTHER:\n\t\t\t\tif ( columnTypeName.equals(\"uniqueidentifier\") ) {\n\t\t\t\t\tjdbcTypeCode = UUID;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase GEOMETRY_TYPE_CODE:\n\t\t\t\tjdbcTypeCode = GEOMETRY;\n\t\t\t\tbreak;\n\t\t\tcase GEOGRAPHY_TYPE_CODE:\n\t\t\t\tjdbcTypeCode = GEOGRAPHY;\n\t\t\t\tbreak;\n\t\t}\n\t\treturn super.resolveSqlTypeDescriptor( columnTypeName, jdbcTypeCode, precision, scale, jdbcTypeRegistry );\n\t}\n\n\t@Override\n\tpublic int getMaxVarcharLength() {\n\t\treturn 8000;\n\t}\n\n\t@Override\n\tpublic int getMaxNVarcharLength() {\n\t\treturn 4000;\n\t}\n\n\t@Override\n\tpublic TimeZoneSupport getTimeZoneSupport() {\n\t\treturn TimeZoneSupport.NATIVE;\n\t}\n\n\t@Override\n\tpublic long getDefaultLobLength() {\n\t\t// this is essentially the only legal length for\n\t\t// a \"lob\" in SQL Server, i.e. the value of MAX\n\t\t// (caveat: for NVARCHAR it is half this value)\n\t\treturn Length.LONG32;\n\t}\n\n\t@Override\n\tpublic int getMaxIdentifierLength() {\n\t\treturn 128;\n\t}\n\n\t@Override\n\tpublic void contributeTypes(TypeContributions typeContributions, ServiceRegistry serviceRegistry) {\n\t\tsuper.contributeTypes( typeContributions, serviceRegistry );\n\n\t\t// Need to bind as java.sql.Timestamp because reading OffsetDateTime from a \"datetime2\" column fails\n\t\ttypeContributions.contributeJdbcType( TimestampUtcAsJdbcTimestampJdbcType.INSTANCE );\n\n\t\ttypeContributions.getTypeConfiguration().getJdbcTypeRegistry().addDescriptor(\n\t\t\t\tTypes.TINYINT,\n\t\t\t\tTinyIntAsSmallIntJdbcType.INSTANCE\n\t\t);\n\t\ttypeContributions.contributeJdbcType( XmlJdbcType.INSTANCE );\n\t\ttypeContributions.contributeJdbcType( UUIDJdbcType.INSTANCE );\n\t}\n\n\t@Override\n\tpublic void initializeFunctionRegistry(FunctionContributions functionContributions) {\n\t\tsuper.initializeFunctionRegistry(functionContributions);\n\n\t\tfinal BasicTypeRegistry basicTypeRegistry = functionContributions.getTypeConfiguration().getBasicTypeRegistry();\n\t\tBasicType<Date> dateType = basicTypeRegistry.resolve( StandardBasicTypes.DATE );\n\t\tBasicType<Date> timeType = basicTypeRegistry.resolve( StandardBasicTypes.TIME );\n\t\tBasicType<Date> timestampType = basicTypeRegistry.resolve( StandardBasicTypes.TIMESTAMP );\n\n\t\tCommonFunctionFactory functionFactory = new CommonFunctionFactory(functionContributions);\n\n\t\t// For SQL-Server we need to cast certain arguments to varchar(max) to be able to concat them\n\t\tfunctionContributions.getFunctionRegistry().register(\n\t\t\t\t\"count\",\n\t\t\t\tnew CountFunction(\n\t\t\t\t\t\tthis,\n\t\t\t\t\t\tfunctionContributions.getTypeConfiguration(),\n\t\t\t\t\t\tSqlAstNodeRenderingMode.DEFAULT,\n\t\t\t\t\t\t\"count_big\",\n\t\t\t\t\t\t\"+\",\n\t\t\t\t\t\t\"varchar(max)\",\n\t\t\t\t\t\ttrue,\n\t\t\t\t\t\t\"varbinary(max)\"\n\t\t\t\t)\n\t\t);\n\n\t\t// AVG by default uses the input type, so we possibly need to cast the argument type, hence a special function\n\t\tfunctionFactory.avg_castingNonDoubleArguments( this, SqlAstNodeRenderingMode.DEFAULT );\n\n\t\tfunctionFactory.log_log();\n\n\t\tfunctionFactory.round_round();\n\t\tfunctionFactory.everyAny_minMaxIif();\n\t\tfunctionFactory.octetLength_pattern( \"datalength(?1)\" );\n\t\tfunctionFactory.bitLength_pattern( \"datalength(?1)*8\" );\n\n\t\tfunctionFactory.locate_charindex();\n\t\tfunctionFactory.stddevPopSamp_stdevp();\n\t\tfunctionFactory.varPopSamp_varp();\n\n\t\tfunctionContributions.getFunctionRegistry().register(\n\t\t\t\t\"format\",\n\t\t\t\tnew SQLServerFormatEmulation( functionContributions.getTypeConfiguration() )\n\t\t);\n\n\t\t//actually translate() was added in 2017 but\n\t\t//it's not worth adding a new dialect for that!\n\t\tfunctionFactory.translate();\n\n\t\tfunctionFactory.median_percentileCont( true );\n\n\t\tfunctionContributions.getFunctionRegistry().namedDescriptorBuilder( \"datefromparts\" )\n\t\t\t\t.setInvariantType( dateType )\n\t\t\t\t.setExactArgumentCount( 3 )\n\t\t\t\t.setParameterTypes(INTEGER)\n\t\t\t\t.register();\n\t\tfunctionContributions.getFunctionRegistry().namedDescriptorBuilder( \"timefromparts\" )\n\t\t\t\t.setInvariantType( timeType )\n\t\t\t\t.setExactArgumentCount( 5 )\n\t\t\t\t.setParameterTypes(INTEGER)\n\t\t\t\t.register();\n\t\tfunctionContributions.getFunctionRegistry().namedDescriptorBuilder( \"smalldatetimefromparts\" )\n\t\t\t\t.setInvariantType( timestampType )\n\t\t\t\t.setExactArgumentCount( 5 )\n\t\t\t\t.setParameterTypes(INTEGER)\n\t\t\t\t.register();\n\t\tfunctionContributions.getFunctionRegistry().namedDescriptorBuilder( \"datetimefromparts\" )\n\t\t\t\t.setInvariantType( timestampType )\n\t\t\t\t.setExactArgumentCount( 7 )\n\t\t\t\t.setParameterTypes(INTEGER)\n\t\t\t\t.register();\n\t\tfunctionContributions.getFunctionRegistry().namedDescriptorBuilder( \"datetime2fromparts\" )\n\t\t\t\t.setInvariantType( timestampType )\n\t\t\t\t.setExactArgumentCount( 8 )\n\t\t\t\t.setParameterTypes(INTEGER)\n\t\t\t\t.register();\n\t\tfunctionContributions.getFunctionRegistry().namedDescriptorBuilder( \"datetimeoffsetfromparts\" )\n\t\t\t\t.setInvariantType( timestampType )\n\t\t\t\t.setExactArgumentCount( 10 )\n\t\t\t\t.setParameterTypes(INTEGER)\n\t\t\t\t.register();\n\n\t\tfunctionFactory.windowFunctions();\n\t\tfunctionFactory.inverseDistributionOrderedSetAggregates_windowEmulation();\n\t\tfunctionFactory.hypotheticalOrderedSetAggregates_windowEmulation();\n\t\tif ( getVersion().isSameOrAfter( 14 ) ) {\n\t\t\tfunctionFactory.listagg_stringAggWithinGroup( \"varchar(max)\" );\n\t\t}\n\t\tif ( getVersion().isSameOrAfter( 16 ) ) {\n\t\t\tfunctionFactory.leastGreatest();\n\t\t\tfunctionFactory.dateTrunc_datetrunc();\n\t\t\tfunctionFactory.trunc_round_datetrunc();\n\t\t}\n\t\telse {\n\t\t\tfunctionContributions.getFunctionRegistry().register(\n\t\t\t\t\t\"trunc\",\n\t\t\t\t\tnew SqlServerConvertTruncFunction( functionContributions.getTypeConfiguration() )\n\t\t\t);\n\t\t\tfunctionContributions.getFunctionRegistry().registerAlternateKey( \"truncate\", \"trunc\" );\n\t\t}\n\t}\n\n\t@Override\n\tpublic String trimPattern(TrimSpec specification, boolean isWhitespace) {\n\t\tif ( getVersion().isSameOrAfter( 16 ) ) {\n\t\t\treturn switch (specification) {\n\t\t\t\tcase BOTH -> isWhitespace ? \"trim(?1)\" : \"trim(?2 from ?1)\";\n\t\t\t\tcase LEADING -> isWhitespace ? \"ltrim(?1)\" : \"ltrim(?1,?2)\";\n\t\t\t\tcase TRAILING -> isWhitespace ? \"rtrim(?1)\" : \"rtrim(?1,?2)\";\n\t\t\t};\n\t\t}\n\t\treturn super.trimPattern( specification, isWhitespace );\n\t}\n\n\t@Override\n\tpublic SqlAstTranslatorFactory getSqlAstTranslatorFactory() {\n\t\treturn new StandardSqlAstTranslatorFactory() {\n\t\t\t@Override\n\t\t\tprotected <T extends JdbcOperation> SqlAstTranslator<T> buildTranslator(\n\t\t\t\t\tSessionFactoryImplementor sessionFactory, Statement statement) {\n\t\t\t\treturn new SQLServerSqlAstTranslator<>( sessionFactory, statement );\n\t\t\t}\n\t\t};\n\t}\n\n\t@Override\n\tpublic SizeStrategy getSizeStrategy() {\n\t\treturn sizeStrategy;\n\t}\n\n\t@Override\n\tpublic String castPattern(CastType from, CastType to) {\n\t\tif ( to == CastType.STRING ) {\n\t\t\tswitch ( from ) {\n\t\t\t\tcase TIMESTAMP:\n\t\t\t\t\t// SQL Server uses yyyy-MM-dd HH:mm:ss.nnnnnnn by default when doing a cast, but only need second precision\n\t\t\t\t\treturn \"format(?1,'yyyy-MM-dd HH:mm:ss')\";\n\t\t\t\tcase TIME:\n\t\t\t\t\t// SQL Server uses HH:mm:ss.nnnnnnn by default when doing a cast, but only need second precision\n\t\t\t\t\t// SQL Server requires quoting of ':' in time formats and the use of 'hh' instead of 'HH'\n\t\t\t\t\treturn \"format(?1,'hh\\\\:mm\\\\:ss')\";\n\t\t\t}\n\t\t}\n\t\treturn super.castPattern( from, to );\n\t}\n\n\t@Override\n\tpublic String currentTimestamp() {\n\t\treturn \"sysdatetime()\";\n\t}\n\n\t@Override\n\tpublic IdentifierHelper buildIdentifierHelper(IdentifierHelperBuilder builder, DatabaseMetaData dbMetaData)\n\t\t\tthrows SQLException {\n\n\t\tif ( dbMetaData == null ) {\n\t\t\t// TODO: if DatabaseMetaData != null, unquoted case strategy is set to IdentifierCaseStrategy.UPPER\n\t\t\t//       Check to see if this setting is correct.\n\t\t\tbuilder.setUnquotedCaseStrategy( IdentifierCaseStrategy.MIXED );\n\t\t\tbuilder.setQuotedCaseStrategy( IdentifierCaseStrategy.MIXED );\n\t\t}\n\n\t\treturn super.buildIdentifierHelper( builder, dbMetaData );\n\t}\n\n\t@Override\n\tpublic String currentTime() {\n\t\treturn \"convert(time,getdate())\";\n\t}\n\n\t@Override\n\tpublic String currentDate() {\n\t\treturn \"convert(date,getdate())\";\n\t}\n\n\t@Override\n\tpublic String currentTimestampWithTimeZone() {\n\t\treturn \"sysdatetimeoffset()\";\n\t}\n\n\t@Override\n\tpublic String getNoColumnsInsertString() {\n\t\treturn \"default values\";\n\t}\n\n\t@Override\n\tpublic LimitHandler getLimitHandler() {\n\t\treturn SQLServer2012LimitHandler.INSTANCE;\n\t}\n\n\t@Override\n\tpublic boolean supportsValuesList() {\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean supportsDistinctFromPredicate() {\n\t\treturn getVersion().isSameOrAfter( 16 );\n\t}\n\n\t@Override\n\tpublic char closeQuote() {\n\t\treturn ']';\n\t}\n\n\t@Override\n\tpublic String getCurrentSchemaCommand() {\n\t\treturn \"select schema_name()\";\n\t}\n\n\t@Override\n\tpublic boolean supportsIfExistsBeforeTableName() {\n\t\treturn getVersion().isSameOrAfter( 16 ) || super.supportsIfExistsBeforeTableName();\n\t}\n\n\t@Override\n\tpublic boolean supportsIfExistsBeforeConstraintName() {\n\t\treturn getVersion().isSameOrAfter( 16 ) || super.supportsIfExistsBeforeConstraintName();\n\t}\n\n\t@Override\n\tpublic char openQuote() {\n\t\treturn '[';\n\t}\n\n\t@Override\n\tpublic String appendLockHint(LockOptions lockOptions, String tableName) {\n\t\tLockMode lockMode = lockOptions.getAliasSpecificLockMode( tableName );\n\t\tif ( lockMode == null ) {\n\t\t\tlockMode = lockOptions.getLockMode();\n\t\t}\n\n\t\tfinal String writeLockStr = lockOptions.getTimeOut() == LockOptions.SKIP_LOCKED ? \"updlock\" : \"updlock,holdlock\";\n\t\tfinal String readLockStr = lockOptions.getTimeOut() == LockOptions.SKIP_LOCKED ? \"updlock\" : \"holdlock\";\n\n\t\tfinal String noWaitStr = lockOptions.getTimeOut() == LockOptions.NO_WAIT ? \",nowait\" : \"\";\n\t\tfinal String skipLockStr = lockOptions.getTimeOut() == LockOptions.SKIP_LOCKED ? \",readpast\" : \"\";\n\n\t\treturn switch (lockMode) {\n\t\t\tcase PESSIMISTIC_WRITE, WRITE ->\n\t\t\t\t\ttableName + \" with (\" + writeLockStr + \",rowlock\" + noWaitStr + skipLockStr + \")\";\n\t\t\tcase PESSIMISTIC_READ -> tableName + \" with (\" + readLockStr + \",rowlock\" + noWaitStr + skipLockStr + \")\";\n\t\t\tcase UPGRADE_SKIPLOCKED -> tableName + \" with (updlock,rowlock,readpast\" + noWaitStr + \")\";\n\t\t\tcase UPGRADE_NOWAIT -> tableName + \" with (updlock,holdlock,rowlock,nowait)\";\n\t\t\tdefault -> tableName;\n\t\t};\n\t}\n\n\n\t/**\n\t * The current_timestamp is more accurate, but only known to be supported in SQL Server 7.0 and later and\n\t * Sybase not known to support it at all\n\t * <p>\n\t * {@inheritDoc}\n\t */\n\t@Override\n\tpublic String getCurrentTimestampSelectString() {\n\t\treturn \"select current_timestamp\";\n\t}\n\n\t// Overridden informational metadata ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n\t@Override\n\tpublic boolean supportsResultSetPositionQueryMethodsOnForwardOnlyCursor() {\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic boolean supportsCircularCascadeDeleteConstraints() {\n\t\t// SQL Server (at least up through 2005) does not support defining\n\t\t// cascade delete constraints which can circle back to the mutating\n\t\t// table\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic boolean supportsLobValueChangePropagation() {\n\t\t// note: at least my local SQL Server 2005 Express shows this not working...\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic boolean doesReadCommittedCauseWritersToBlockReaders() {\n\t\t// here assume SQLServer2005 using snapshot isolation, which does not have this problem\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic boolean doesRepeatableReadCauseReadersToBlockWriters() {\n\t\t// here assume SQLServer2005 using snapshot isolation, which does not have this problem\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic int getInExpressionCountLimit() {\n\t\treturn PARAM_LIST_SIZE_LIMIT;\n\t}\n\n\t@Override\n\tpublic IdentityColumnSupport getIdentityColumnSupport() {\n\t\treturn SQLServerIdentityColumnSupport.INSTANCE;\n\t}\n\n\t@Override\n\tpublic boolean supportsNonQueryWithCTE() {\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean supportsSkipLocked() {\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean supportsNoWait() {\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean supportsWait() {\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic SequenceSupport getSequenceSupport() {\n\t\treturn getVersion().isSameOrAfter( 16 )\n\t\t\t\t? SQLServer16SequenceSupport.INSTANCE\n\t\t\t\t: SQLServerSequenceSupport.INSTANCE;\n\t}\n\n\t@Override\n\tpublic String getQuerySequencesString() {\n\t\t// The upper-case name should work on both case-sensitive and case-insensitive collations.\n\t\treturn \"select * from INFORMATION_SCHEMA.SEQUENCES\";\n\t}\n\n\t@Override\n\tpublic String getQueryHintString(String sql, String hints) {\n\t\tfinal StringBuilder buffer =\n\t\t\t\tnew StringBuilder( sql.length() + hints.length() + 12 );\n\t\tfinal int pos = sql.indexOf( ';' );\n\t\tif ( pos > -1 ) {\n\t\t\tbuffer.append( sql, 0, pos );\n\t\t}\n\t\telse {\n\t\t\tbuffer.append( sql );\n\t\t}\n\t\tbuffer.append( \" OPTION (\" ).append( hints ).append( \")\" );\n\t\tif ( pos > -1 ) {\n\t\t\tbuffer.append( \";\" );\n\t\t}\n\t\tsql = buffer.toString();\n\t\treturn sql;\n\t}\n\n\t@Override\n\tpublic boolean supportsNullPrecedence() {\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic boolean supportsOffsetInSubquery() {\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean supportsWindowFunctions() {\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean supportsLateral() {\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean supportsRecursiveCTE() {\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean supportsFetchClause(FetchClauseType type) {\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic ViolatedConstraintNameExtractor getViolatedConstraintNameExtractor() {\n\t\treturn new TemplatedViolatedConstraintNameExtractor(\n\t\t\t\tsqle -> {\n\t\t\t\t\tswitch ( extractErrorCode( sqle ) ) {\n\t\t\t\t\t\tcase 2627:\n\t\t\t\t\t\tcase 2601:\n\t\t\t\t\t\t\tString message = sqle.getMessage();\n\t\t\t\t\t\t\tif ( message.contains(\"unique index \") ) {\n\t\t\t\t\t\t\t\treturn extractUsingTemplate( \"unique index '\", \"'\", message);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\treturn extractUsingTemplate( \"'\", \"'\", message);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t);\n\t}\n\n\t@Override\n\tpublic SQLExceptionConversionDelegate buildSQLExceptionConversionDelegate() {\n\t\treturn (sqlException, message, sql) -> {\n\t\t\tfinal String sqlState = extractSqlState( sqlException );\n\t\t\tif ( \"HY008\".equals( sqlState ) ) {\n\t\t\t\treturn new QueryTimeoutException( message, sqlException, sql );\n\t\t\t}\n\n\t\t\treturn switch ( extractErrorCode( sqlException ) ) {\n\t\t\t\tcase 1222 -> new LockTimeoutException( message, sqlException, sql );\n\t\t\t\tcase 2627, 2601 -> new ConstraintViolationException(\n\t\t\t\t\t\tmessage,\n\t\t\t\t\t\tsqlException,\n\t\t\t\t\t\tsql,\n\t\t\t\t\t\tConstraintViolationException.ConstraintKind.UNIQUE,\n\t\t\t\t\t\tgetViolatedConstraintNameExtractor().extractConstraintName( sqlException )\n\t\t\t\t);\n\t\t\t\tdefault -> null;\n\t\t\t};\n\t\t};\n\t}\n\n\t@Override\n\tpublic int getDefaultTimestampPrecision() {\n\t\treturn 7;\n\t}\n\n\t/**\n\t * Even though SQL Server only supports 1/10th microsecond precision,\n\t * we use nanosecond as the \"native\" precision for datetime arithmetic\n\t * since it simplifies calculations.\n\t */\n\t@Override\n\tpublic long getFractionalSecondPrecisionInNanos() {\n//\t\treturn 100; // 1/10th microsecond\n\t\treturn 1;\n\t}\n\n\t@Override\n\tpublic String extractPattern(TemporalUnit unit) {\n\t\treturn switch (unit) {\n\t\t\tcase TIMEZONE_HOUR -> \"(datepart(tz,?2)/60)\";\n\t\t\tcase TIMEZONE_MINUTE -> \"(datepart(tz,?2)%60)\";\n\t\t\t// currently Dialect.extract() doesn't need\n\t\t\t// to handle NANOSECOND (might change that?)\n//\t\t\tcase NANOSECOND ->\n//\t\t\t\t// this should evaluate to a bigint type\n//\t\t\t\t\t\"(datepart(second,?2)*1000000000+datepart(nanosecond,?2))\";\n\t\t\tcase SECOND ->\n\t\t\t\t//this should evaluate to a floating point type\n\t\t\t\t\t\"(datepart(second,?2)+datepart(nanosecond,?2)/1000000000)\";\n\t\t\tcase EPOCH -> \"datediff_big(second, '1970-01-01', ?2)\";\n\t\t\tdefault -> \"datepart(?1,?2)\";\n\t\t};\n\t}\n\n\t@Override @SuppressWarnings(\"deprecation\")\n\tpublic String timestampaddPattern(TemporalUnit unit, TemporalType temporalType, IntervalType intervalType) {\n\t\t// dateadd() supports only especially small magnitudes\n\t\t// since it casts its argument to int (and unfortunately\n\t\t// there's no dateadd_big()) so here we need to use two\n\t\t// calls to dateadd() to add a whole duration\n\t\treturn switch (unit) { //use nanosecond as the \"native\" precision\n\t\t\tcase NANOSECOND, NATIVE -> \"dateadd(nanosecond,?2%1000000000,dateadd(second,?2/1000000000,?3))\";\n\t\t\t// we could, in principle, use 1/10th microsecond as the \"native\" precision\n//\t\t\tcase NATIVE -> \"dateadd(nanosecond,?2%10000000,dateadd(second,?2/10000000,?3))\";\n\t\t\tcase SECOND -> \"dateadd(nanosecond,cast(?2*1e9 as bigint)%1000000000,dateadd(second,?2,?3))\";\n\t\t\tdefault -> \"dateadd(?1,?2,?3)\";\n\t\t};\n\t}\n\n\t@Override @SuppressWarnings(\"deprecation\")\n\tpublic String timestampdiffPattern(TemporalUnit unit, TemporalType fromTemporalType, TemporalType toTemporalType) {\n\t\tif ( unit == TemporalUnit.NATIVE ) {\n\t\t\t//use nanosecond as the \"native\" precision\n\t\t\treturn \"datediff_big(nanosecond,?2,?3)\";\n\t\t}\n\t\telse {\n\t\t\t//datediff() returns an int, and can easily\n\t\t\t//overflow when dealing with \"physical\"\n\t\t\t//durations, so use datediff_big()\n\t\t\treturn unit.normalized() == NANOSECOND\n\t\t\t\t\t? \"datediff_big(?1,?2,?3)\"\n\t\t\t\t\t: \"datediff(?1,?2,?3)\";\n\t\t}\n\t}\n\n\t@Override\n\tpublic String translateDurationField(TemporalUnit unit) {\n\t\t//use nanosecond as the \"native\" precision\n\t\treturn unit == TemporalUnit.NATIVE\n\t\t\t\t? \"nanosecond\"\n\t\t\t\t: super.translateDurationField( unit );\n\t}\n\n\t@Override\n\tpublic String translateExtractField(TemporalUnit unit) {\n\t\treturn switch (unit) {\n\t\t\t//the ISO week number (behavior of \"week\" depends on a system property)\n\t\t\tcase WEEK -> \"isowk\";\n\t\t\tcase OFFSET -> \"tz\";\n\t\t\tdefault -> super.translateExtractField( unit );\n\t\t};\n\t}\n\n\t@Override\n\tpublic void appendDatetimeFormat(SqlAppender appender, String format) {\n\t\tappender.appendSql( datetimeFormat(format).result() );\n\t}\n\n\tpublic static Replacer datetimeFormat(String format) {\n\t\treturn new Replacer( format, \"'\", \"\\\"\" )\n\t\t\t\t//era\n\t\t\t\t.replace(\"G\", \"g\")\n\n\t\t\t\t//y nothing to do\n\t\t\t\t//M nothing to do\n\n\t\t\t\t//w no equivalent\n\t\t\t\t//W no equivalent\n\t\t\t\t//Y no equivalent\n\n\t\t\t\t//day of week\n\t\t\t\t.replace(\"EEEE\", \"dddd\")\n\t\t\t\t.replace(\"EEE\", \"ddd\")\n\t\t\t\t//e no equivalent\n\n\t\t\t\t//d nothing to do\n\t\t\t\t//D no equivalent\n\n\t\t\t\t//am pm\n\t\t\t\t.replace(\"a\", \"tt\")\n\n\t\t\t\t//h nothing to do\n\t\t\t\t//H nothing to do\n\n\t\t\t\t//m nothing to do\n\t\t\t\t//s nothing to do\n\n\t\t\t\t//fractional seconds\n\t\t\t\t.replace(\"S\", \"F\")\n\n\t\t\t\t//timezones\n\t\t\t\t.replace(\"XXX\", \"K\") //UTC represented as \"Z\"\n\t\t\t\t.replace(\"xxx\", \"zzz\")\n\t\t\t\t.replace(\"x\", \"zz\");\n\t}\n\n\t@Override\n\tpublic void appendUUIDLiteral(SqlAppender appender, java.util.UUID literal) {\n\t\tappender.appendSql( \"cast('\" );\n\t\tappender.appendSql( literal.toString() );\n\t\tappender.appendSql( \"' as uniqueidentifier)\" );\n\t}\n\n\t@Override\n\tpublic void appendDateTimeLiteral(\n\t\t\tSqlAppender appender,\n\t\t\tTemporalAccessor temporalAccessor,\n\t\t\t@SuppressWarnings(\"deprecation\")\n\t\t\tTemporalType precision,\n\t\t\tTimeZone jdbcTimeZone) {\n\t\tswitch ( precision ) {\n\t\t\tcase DATE:\n\t\t\t\tappender.appendSql( \"cast('\" );\n\t\t\t\tappendAsDate( appender, temporalAccessor );\n\t\t\t\tappender.appendSql( \"' as date)\" );\n\t\t\t\tbreak;\n\t\t\tcase TIME:\n\t\t\t\t//needed because the {t ... } JDBC is just buggy\n\t\t\t\tappender.appendSql( \"cast('\" );\n\t\t\t\tappendAsTime( appender, temporalAccessor, supportsTemporalLiteralOffset(), jdbcTimeZone );\n\t\t\t\tappender.appendSql( \"' as time)\" );\n\t\t\t\tbreak;\n\t\t\tcase TIMESTAMP:\n\t\t\t\tappender.appendSql( \"cast('\" );\n\t\t\t\t//needed because the {ts ... } JDBC escape chokes on microseconds\n\t\t\t\tif ( supportsTemporalLiteralOffset() && temporalAccessor.isSupported( ChronoField.OFFSET_SECONDS ) ) {\n\t\t\t\t\tappendAsTimestampWithMicros( appender, temporalAccessor, true, jdbcTimeZone );\n\t\t\t\t\tappender.appendSql( \"' as datetimeoffset)\" );\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tappendAsTimestampWithMicros( appender, temporalAccessor, false, jdbcTimeZone );\n\t\t\t\t\tappender.appendSql( \"' as datetime2)\" );\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new IllegalArgumentException();\n\t\t}\n\t}\n\n\t@Override\n\tpublic void appendDateTimeLiteral(\n\t\t\tSqlAppender appender,\n\t\t\tDate date,\n\t\t\t@SuppressWarnings(\"deprecation\")\n\t\t\tTemporalType precision,\n\t\t\tTimeZone jdbcTimeZone) {\n\t\tswitch ( precision ) {\n\t\t\tcase DATE:\n\t\t\t\tappender.appendSql( \"cast('\" );\n\t\t\t\tappendAsDate( appender, date );\n\t\t\t\tappender.appendSql( \"' as date)\" );\n\t\t\t\tbreak;\n\t\t\tcase TIME:\n\t\t\t\t//needed because the {t ... } JDBC is just buggy\n\t\t\t\tappender.appendSql( \"cast('\" );\n\t\t\t\tappendAsTime( appender, date );\n\t\t\t\tappender.appendSql( \"' as time)\" );\n\t\t\t\tbreak;\n\t\t\tcase TIMESTAMP:\n\t\t\t\tappender.appendSql( \"cast('\" );\n\t\t\t\tappendAsTimestampWithMicros( appender, date, jdbcTimeZone );\n\t\t\t\tappender.appendSql( \"' as datetimeoffset)\" );\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new IllegalArgumentException();\n\t\t}\n\t}\n\n\t@Override\n\tpublic void appendDateTimeLiteral(\n\t\t\tSqlAppender appender,\n\t\t\tCalendar calendar,\n\t\t\t@SuppressWarnings(\"deprecation\")\n\t\t\tTemporalType precision,\n\t\t\tTimeZone jdbcTimeZone) {\n\t\tswitch ( precision ) {\n\t\t\tcase DATE:\n\t\t\t\tappender.appendSql( \"cast('\" );\n\t\t\t\tappendAsDate( appender, calendar );\n\t\t\t\tappender.appendSql( \"' as date)\" );\n\t\t\t\tbreak;\n\t\t\tcase TIME:\n\t\t\t\t//needed because the {t ... } JDBC is just buggy\n\t\t\t\tappender.appendSql( \"cast('\" );\n\t\t\t\tappendAsTime( appender, calendar );\n\t\t\t\tappender.appendSql( \"' as time)\" );\n\t\t\t\tbreak;\n\t\t\tcase TIMESTAMP:\n\t\t\t\tappender.appendSql( \"cast('\" );\n\t\t\t\tappendAsTimestampWithMillis( appender, calendar, jdbcTimeZone );\n\t\t\t\tappender.appendSql( \"' as datetime2)\" );\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new IllegalArgumentException();\n\t\t}\n\t}\n\n\t@Override\n\tpublic String getCreateTemporaryTableColumnAnnotation(int sqlTypeCode) {\n\t\treturn switch (sqlTypeCode) {\n\t\t\tcase Types.CHAR, Types.NCHAR, Types.VARCHAR, Types.NVARCHAR, Types.LONGVARCHAR, Types.LONGNVARCHAR ->\n\t\t\t\t\t\"collate database_default\";\n\t\t\tdefault -> \"\";\n\t\t};\n\t}\n\n\t@Override\n\tpublic String[] getDropSchemaCommand(String schemaName) {\n\t\treturn getVersion().isSameOrAfter( 13 )\n\t\t\t\t? new String[] { \"drop schema if exists \" + schemaName }\n\t\t\t\t: super.getDropSchemaCommand( schemaName );\n\t}\n\n\t@Override\n\tpublic String getCreateIndexString(boolean unique) {\n\t\t// we only create unique indexes, as opposed to unique constraints,\n\t\t// when the column is nullable, so safe to infer unique => nullable\n\t\treturn unique ? \"create unique nonclustered index\" : \"create index\";\n\t}\n\n\t@Override\n\tpublic String getCreateIndexTail(boolean unique, List<Column> columns) {\n\t\tif ( unique ) {\n\t\t\tfinal StringBuilder tail = new StringBuilder();\n\t\t\tfor ( Column column : columns ) {\n\t\t\t\tif ( column.isNullable() ) {\n\t\t\t\t\ttail.append( tail.isEmpty() ? \" where \" : \" and \" )\n\t\t\t\t\t\t\t.append( column.getQuotedName( this ) )\n\t\t\t\t\t\t\t.append( \" is not null\" );\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn tail.toString();\n\t\t}\n\t\telse {\n\t\t\treturn \"\";\n\t\t}\n\t}\n\n\t@Override\n\tpublic String getAlterColumnTypeString(String columnName, String columnType, String columnDefinition) {\n\t\treturn \"alter column \" + columnName + \" \" + columnType;\n\t}\n\n\t@Override\n\tpublic boolean supportsAlterColumnType() {\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic NameQualifierSupport getNameQualifierSupport() {\n\t\treturn NameQualifierSupport.BOTH;\n\t}\n\n\t@Override\n\tpublic UniqueDelegate getUniqueDelegate() {\n\t\treturn uniqueDelegate;\n\t}\n\n\t@Override\n\tpublic Exporter<Sequence> getSequenceExporter() {\n\t\treturn exporter == null ? super.getSequenceExporter() : exporter;\n\t}\n\n\tprivate static class SqlServerSequenceExporter extends StandardSequenceExporter {\n\n\t\tpublic SqlServerSequenceExporter(Dialect dialect) {\n\t\t\tsuper( dialect );\n\t\t}\n\n\t\t@Override\n\t\tprotected String getFormattedSequenceName(QualifiedSequenceName name, Metadata metadata,\n\t\t\t\tSqlStringGenerationContext context) {\n\t\t\t// SQL Server does not allow the catalog in the sequence name.\n\t\t\t// See https://docs.microsoft.com/en-us/sql/t-sql/statements/create-sequence-transact-sql?view=sql-server-ver15&viewFallbackFrom=sql-server-ver12\n\t\t\t// Keeping the catalog in the name does not break on ORM, but it fails using Vert.X for Reactive.\n\t\t\treturn context.formatWithoutCatalog( name );\n\t\t}\n\t}\n\n\t@Override\n\tpublic String generatedAs(String generatedAs) {\n\t\treturn \" as (\" + generatedAs + \") persisted\";\n\t}\n\n\t@Override\n\tpublic boolean hasDataTypeBeforeGeneratedAs() {\n\t\treturn false;\n\t}\n\n\t// disabled foreign key constraints still prevent 'truncate table'\n\t// (these would help if we used 'delete' instead of 'truncate')\n\n//\t@Override\n//\tpublic String getDisableConstraintStatement(String tableName, String name) {\n//\t\treturn \"alter table \" + tableName + \" nocheck constraint \" + name;\n//\t}\n//\n//\t@Override\n//\tpublic String getEnableConstraintStatement(String tableName, String name) {\n//\t\treturn \"alter table \" + tableName + \" with check check constraint \" + name;\n//\t}\n\n\n\t@Override\n\tpublic MutationOperation createOptionalTableUpdateOperation(\n\t\t\tEntityMutationTarget mutationTarget,\n\t\t\tOptionalTableUpdate optionalTableUpdate,\n\t\t\tSessionFactoryImplementor factory) {\n\t\tfinal SQLServerSqlAstTranslator<JdbcOperation> translator =\n\t\t\t\tnew SQLServerSqlAstTranslator<>( factory, optionalTableUpdate );\n\t\treturn translator.createMergeOperation( optionalTableUpdate );\n\t}\n\n\t@Override\n\tpublic DmlTargetColumnQualifierSupport getDmlTargetColumnQualifierSupport() {\n\t\treturn DmlTargetColumnQualifierSupport.TABLE_ALIAS;\n\t}\n\n\t@Override\n\tpublic boolean supportsFromClauseInUpdate() {\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic CallableStatementSupport getCallableStatementSupport() {\n\t\treturn SQLServerCallableStatementSupport.INSTANCE;\n\t}\n\n\t@Override\n\tpublic String getCheckConstraintString(CheckConstraint checkConstraint) {\n\t\tfinal String constraintName = checkConstraint.getName();\n\t\treturn constraintName == null\n\t\t\t\t? \" check \" + getCheckConstraintOptions( checkConstraint )\n\t\t\t\t\t\t+ \"(\" + checkConstraint.getConstraint() + \")\"\n\t\t\t\t: \" constraint \" + constraintName + \" check \" + getCheckConstraintOptions( checkConstraint )\n\t\t\t\t\t\t+ \"(\" + checkConstraint.getConstraint() + \")\";\n\t}\n\n\tprivate String getCheckConstraintOptions(CheckConstraint checkConstraint) {\n\t\treturn isNotEmpty( checkConstraint.getOptions() ) ? checkConstraint.getOptions() + \" \" : \"\";\n\t}\n}\n",
        "diffSourceCodeSet": [
            "private static DatabaseVersion staticDetermineDatabaseVersion(DialectResolutionInfo info) {\n\t\tfinal Integer compatibilityLevel = getCompatibilityLevel( info );\n\t\tif ( compatibilityLevel != null ) {\n\t\t\tfinal int majorVersion = compatibilityLevel / 10;\n\t\t\tfinal int minorVersion = compatibilityLevel % 10;\n\t\t\treturn DatabaseVersion.make( majorVersion, minorVersion );\n\t\t}\n\t\treturn info.makeCopyOrDefault( MINIMUM_VERSION );\n\t}"
        ],
        "invokedMethodSet": [
            "methodSignature: org.hibernate.dialect.SQLServerDialect#getCompatibilityLevel\n methodBody: private static Integer getCompatibilityLevel(DialectResolutionInfo info) {\nfinal DatabaseMetaData databaseMetaData=info.getDatabaseMetadata();\nif(databaseMetaData != null){try(java.sql.Statement statement=databaseMetaData.getConnection().createStatement())final ResultSet rs=statement.executeQuery(\"SELECT compatibility_level FROM sys.databases where name = db_name();\");\nif(rs.next()){return rs.getInt(1);\n}catch(SQLException e)throw BasicSQLExceptionConverter.INSTANCE.convert(e);\n}return ConfigurationHelper.getInteger(SQL_SERVER_COMPATIBILITY_LEVEL,info.getConfigurationValues());\n}"
        ],
        "sourceCodeAfterRefactoring": "@Override\n\tpublic DatabaseVersion determineDatabaseVersion(DialectResolutionInfo info) {\n\t\treturn staticDetermineDatabaseVersion(info);\n\t}\nprivate static DatabaseVersion staticDetermineDatabaseVersion(DialectResolutionInfo info) {\n\t\tfinal Integer compatibilityLevel = getCompatibilityLevel( info );\n\t\tif ( compatibilityLevel != null ) {\n\t\t\tfinal int majorVersion = compatibilityLevel / 10;\n\t\t\tfinal int minorVersion = compatibilityLevel % 10;\n\t\t\treturn DatabaseVersion.make( majorVersion, minorVersion );\n\t\t}\n\t\treturn info.makeCopyOrDefault( MINIMUM_VERSION );\n\t}",
        "diffSourceCode": "-  181: \tprivate static DatabaseVersion determineDatabaseVersion(DialectResolutionInfo info) {\n-  182: \t\tfinal Integer compatibilityLevel = getCompatibilityLevel( info );\n-  183: \t\tif ( compatibilityLevel != null ) {\n-  184: \t\t\tfinal int majorVersion = compatibilityLevel / 10;\n-  185: \t\t\tfinal int minorVersion = compatibilityLevel % 10;\n-  186: \t\t\treturn DatabaseVersion.make( majorVersion, minorVersion );\n-  187: \t\t}\n-  188: \t\treturn info.makeCopyOrDefault( MINIMUM_VERSION );\n-  189: \t}\n-  190: \n-  191: \tprivate static Integer getCompatibilityLevel(DialectResolutionInfo info) {\n-  192: \t\tfinal DatabaseMetaData databaseMetaData = info.getDatabaseMetadata();\n-  193: \t\tif ( databaseMetaData != null ) {\n-  194: \t\t\ttry ( java.sql.Statement statement = databaseMetaData.getConnection().createStatement() ) {\n-  195: \t\t\t\tfinal ResultSet rs = statement.executeQuery( \"SELECT compatibility_level FROM sys.databases where name = db_name();\" );\n+  181: \t@Override\n+  182: \tpublic DatabaseVersion determineDatabaseVersion(DialectResolutionInfo info) {\n+  183: \t\treturn staticDetermineDatabaseVersion(info);\n+  184: \t}\n+  185: \n+  186: \t// Static version necessary to call from constructor\n+  187: \tprivate static DatabaseVersion staticDetermineDatabaseVersion(DialectResolutionInfo info) {\n+  188: \t\tfinal Integer compatibilityLevel = getCompatibilityLevel( info );\n+  189: \t\tif ( compatibilityLevel != null ) {\n+  190: \t\t\tfinal int majorVersion = compatibilityLevel / 10;\n+  191: \t\t\tfinal int minorVersion = compatibilityLevel % 10;\n+  192: \t\t\treturn DatabaseVersion.make( majorVersion, minorVersion );\n+  193: \t\t}\n+  194: \t\treturn info.makeCopyOrDefault( MINIMUM_VERSION );\n+  195: \t}\n",
        "uniqueId": "4b33d0d067010d484702d6ee910aaa3b4584c69b_181_189_187_195_181_184",
        "moveFileExist": true,
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 17,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 16,
                "covered": 9
            },
            "BRANCH": {
                "missed": 1,
                "covered": 1
            },
            "LINE": {
                "missed": 3,
                "covered": 3
            },
            "COMPLEXITY": {
                "missed": 1,
                "covered": 1
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        }
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprivate javaType(typeConfiguration TypeConfiguration, impliedJavaType java.lang.reflect.Type) : JavaType<Object> extracted from private determineReflectedJavaType() : JavaType<?> in class org.hibernate.mapping.BasicValue",
        "diffLocations": [
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/mapping/BasicValue.java",
                "startLine": 731,
                "endLine": 792,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/mapping/BasicValue.java",
                "startLine": 745,
                "endLine": 755,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/mapping/BasicValue.java",
                "startLine": 773,
                "endLine": 776,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "private JavaType<?> determineReflectedJavaType() {\n\t\tfinal java.lang.reflect.Type impliedJavaType;\n\n\t\tfinal TypeConfiguration typeConfiguration = getTypeConfiguration();\n\t\tif ( resolvedJavaType != null ) {\n\t\t\timpliedJavaType = resolvedJavaType;\n\t\t}\n\t\telse if ( implicitJavaTypeAccess != null ) {\n\t\t\timpliedJavaType = implicitJavaTypeAccess.apply( typeConfiguration );\n\t\t}\n\t\telse if ( ownerName != null && propertyName != null ) {\n\t\t\timpliedJavaType = ReflectHelper.reflectedPropertyType(\n\t\t\t\t\townerName,\n\t\t\t\t\tpropertyName,\n\t\t\t\t\tgetServiceRegistry().requireService( ClassLoaderService.class )\n\t\t\t);\n\t\t}\n\t\telse {\n\t\t\treturn null;\n\t\t}\n\n\t\tresolvedJavaType = impliedJavaType;\n\n\t\tif ( impliedJavaType == null ) {\n\t\t\treturn null;\n\t\t}\n\n\t\tfinal JavaTypeRegistry javaTypeRegistry = typeConfiguration.getJavaTypeRegistry();\n\t\tfinal JavaType<Object> javaType = javaTypeRegistry.findDescriptor( impliedJavaType );\n\t\tfinal MutabilityPlan<Object> explicitMutabilityPlan = explicitMutabilityPlanAccess != null\n\t\t\t\t? explicitMutabilityPlanAccess.apply( typeConfiguration )\n\t\t\t\t: null;\n\t\tfinal MutabilityPlan<Object> determinedMutabilityPlan = explicitMutabilityPlan != null\n\t\t\t\t? explicitMutabilityPlan\n\t\t\t\t: RegistryHelper.INSTANCE.determineMutabilityPlan( impliedJavaType, typeConfiguration );\n\t\tif ( javaType == null ) {\n\t\t\tif ( jdbcTypeCode != null ) {\n\t\t\t\t// Construct special JavaType instances for JSON/XML types which can report recommended JDBC types\n\t\t\t\t// and implement toString/fromString as well as copying based on FormatMapper operations\n\t\t\t\tswitch ( jdbcTypeCode ) {\n\t\t\t\t\tcase SqlTypes.JSON:\n\t\t\t\t\t\tfinal JavaType<Object> jsonJavaType = new JsonJavaType<>(\n\t\t\t\t\t\t\t\timpliedJavaType,\n\t\t\t\t\t\t\t\tdeterminedMutabilityPlan,\n\t\t\t\t\t\t\t\ttypeConfiguration\n\t\t\t\t\t\t);\n\t\t\t\t\t\tjavaTypeRegistry.addDescriptor( jsonJavaType );\n\t\t\t\t\t\treturn jsonJavaType;\n\t\t\t\t\tcase SqlTypes.SQLXML:\n\t\t\t\t\t\tfinal JavaType<Object> xmlJavaType = new XmlJavaType<>(\n\t\t\t\t\t\t\t\timpliedJavaType,\n\t\t\t\t\t\t\t\tdeterminedMutabilityPlan,\n\t\t\t\t\t\t\t\ttypeConfiguration\n\t\t\t\t\t\t);\n\t\t\t\t\t\tjavaTypeRegistry.addDescriptor( xmlJavaType );\n\t\t\t\t\t\treturn xmlJavaType;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn javaTypeRegistry.resolveDescriptor( impliedJavaType );\n\t\t}\n\t\treturn javaType;\n\t}",
        "filePathBefore": "hibernate-core/src/main/java/org/hibernate/mapping/BasicValue.java",
        "isPureRefactoring": true,
        "commitId": "6c6c92e88d4535be020b4acb3d81f96df39a65d8",
        "packageNameBefore": "org.hibernate.mapping",
        "classNameBefore": "org.hibernate.mapping.BasicValue",
        "methodNameBefore": "org.hibernate.mapping.BasicValue#determineReflectedJavaType",
        "invokedMethod": "methodSignature: org.hibernate.type.spi.TypeConfiguration#getJavaTypeRegistry\n methodBody: public JavaTypeRegistry getJavaTypeRegistry() {\nreturn javaTypeRegistry;\n}\nmethodSignature: org.hibernate.type.spi.TypeConfiguration.Scope#getTypeConfiguration\n methodBody: public TypeConfiguration getTypeConfiguration() {\nreturn typeConfiguration;\n}\nmethodSignature: org.hibernate.type.spi.TypeConfiguration.Scope#getServiceRegistry\n methodBody: private ServiceRegistry getServiceRegistry() {\nif(metadataBuildingContext != null){return metadataBuildingContext.getBootstrapContext().getServiceRegistry();\n}if(sessionFactory != null){return sessionFactory.getServiceRegistry();\n}{return null;\n}}\nmethodSignature: org.hibernate.type.spi.TypeConfiguration#getServiceRegistry\n methodBody: public ServiceRegistry getServiceRegistry() {\nreturn scope.getServiceRegistry();\n}",
        "classSignatureBefore": "public class BasicValue extends SimpleValue implements JdbcTypeIndicators, Resolvable, JpaAttributeConverterCreationContext ",
        "methodNameBeforeSet": [
            "org.hibernate.mapping.BasicValue#determineReflectedJavaType"
        ],
        "classNameBeforeSet": [
            "org.hibernate.mapping.BasicValue"
        ],
        "classSignatureBeforeSet": [
            "public class BasicValue extends SimpleValue implements JdbcTypeIndicators, Resolvable, JpaAttributeConverterCreationContext "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Overlapped refactoring - can be identical by undoing the overlapped refactoring\n- Inline Variable- Severe changes",
                "description": "Return expression has been added within the Extract Method mechanics - with non-mapped leaves",
                "mappingState": 2
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later\n * See the lgpl.txt file in the root directory or http://www.gnu.org/licenses/lgpl-2.1.html\n */\npackage org.hibernate.mapping;\n\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Properties;\nimport java.util.function.Consumer;\nimport java.util.function.Function;\n\nimport org.hibernate.Incubating;\nimport org.hibernate.Internal;\nimport org.hibernate.MappingException;\nimport org.hibernate.TimeZoneStorageStrategy;\nimport org.hibernate.annotations.SoftDelete;\nimport org.hibernate.annotations.SoftDeleteType;\nimport org.hibernate.annotations.TimeZoneStorageType;\nimport org.hibernate.boot.model.TypeDefinition;\nimport org.hibernate.boot.model.convert.internal.AutoApplicableConverterDescriptorBypassedImpl;\nimport org.hibernate.boot.model.convert.internal.ClassBasedConverterDescriptor;\nimport org.hibernate.boot.model.convert.internal.InstanceBasedConverterDescriptor;\nimport org.hibernate.boot.model.convert.spi.AutoApplicableConverterDescriptor;\nimport org.hibernate.boot.model.convert.spi.ConverterDescriptor;\nimport org.hibernate.boot.model.convert.spi.JpaAttributeConverterCreationContext;\nimport org.hibernate.boot.model.process.internal.InferredBasicValueResolution;\nimport org.hibernate.boot.model.process.internal.InferredBasicValueResolver;\nimport org.hibernate.boot.model.process.internal.NamedBasicTypeResolution;\nimport org.hibernate.boot.model.process.internal.NamedConverterResolution;\nimport org.hibernate.boot.model.process.internal.UserTypeResolution;\nimport org.hibernate.boot.model.process.internal.VersionResolution;\nimport org.hibernate.boot.registry.StandardServiceRegistry;\nimport org.hibernate.boot.registry.classloading.spi.ClassLoaderService;\nimport org.hibernate.boot.registry.classloading.spi.ClassLoadingException;\nimport org.hibernate.boot.spi.MetadataBuildingContext;\nimport org.hibernate.dialect.Dialect;\nimport org.hibernate.engine.jdbc.Size;\nimport org.hibernate.internal.CoreLogging;\nimport org.hibernate.internal.CoreMessageLogger;\nimport org.hibernate.internal.util.ReflectHelper;\nimport org.hibernate.internal.util.StringHelper;\nimport org.hibernate.internal.util.collections.CollectionHelper;\nimport org.hibernate.metamodel.mapping.JdbcMapping;\nimport org.hibernate.metamodel.mapping.SelectablePath;\nimport org.hibernate.resource.beans.internal.FallbackBeanInstanceProducer;\nimport org.hibernate.resource.beans.spi.BeanInstanceProducer;\nimport org.hibernate.resource.beans.spi.ManagedBean;\nimport org.hibernate.resource.beans.spi.ManagedBeanRegistry;\nimport org.hibernate.tool.schema.extract.spi.ColumnTypeInformation;\nimport org.hibernate.type.BasicType;\nimport org.hibernate.type.CustomType;\nimport org.hibernate.type.NumericBooleanConverter;\nimport org.hibernate.type.SqlTypes;\nimport org.hibernate.type.TrueFalseConverter;\nimport org.hibernate.type.Type;\nimport org.hibernate.type.WrapperArrayHandling;\nimport org.hibernate.type.descriptor.converter.spi.BasicValueConverter;\nimport org.hibernate.type.descriptor.converter.spi.JpaAttributeConverter;\nimport org.hibernate.type.descriptor.java.BasicJavaType;\nimport org.hibernate.type.descriptor.java.BasicPluralJavaType;\nimport org.hibernate.type.descriptor.java.JavaType;\nimport org.hibernate.type.descriptor.java.MutabilityPlan;\nimport org.hibernate.type.descriptor.java.spi.JavaTypeRegistry;\nimport org.hibernate.type.descriptor.java.spi.JsonJavaType;\nimport org.hibernate.type.descriptor.java.spi.RegistryHelper;\nimport org.hibernate.type.descriptor.java.spi.XmlJavaType;\nimport org.hibernate.type.descriptor.jdbc.BooleanJdbcType;\nimport org.hibernate.type.descriptor.jdbc.JdbcType;\nimport org.hibernate.type.descriptor.jdbc.JdbcTypeIndicators;\nimport org.hibernate.type.internal.BasicTypeImpl;\nimport org.hibernate.type.spi.TypeConfiguration;\nimport org.hibernate.type.spi.TypeConfigurationAware;\nimport org.hibernate.usertype.DynamicParameterizedType;\nimport org.hibernate.usertype.UserType;\n\nimport com.fasterxml.classmate.ResolvedType;\nimport jakarta.persistence.AttributeConverter;\nimport jakarta.persistence.EnumType;\nimport jakarta.persistence.TemporalType;\n\nimport static java.lang.Boolean.parseBoolean;\nimport static org.hibernate.internal.util.collections.CollectionHelper.isNotEmpty;\nimport static org.hibernate.mapping.MappingHelper.injectParameters;\n\n/**\n * @author Steve Ebersole\n */\npublic class BasicValue extends SimpleValue implements JdbcTypeIndicators, Resolvable, JpaAttributeConverterCreationContext {\n\tprivate static final CoreMessageLogger log = CoreLogging.messageLogger( BasicValue.class );\n\n\t// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\t// incoming \"configuration\" values\n\n\tprivate String explicitTypeName;\n\tprivate Map<String,String> explicitLocalTypeParams;\n\n\tprivate Function<TypeConfiguration, BasicJavaType> explicitJavaTypeAccess;\n\tprivate Function<TypeConfiguration, JdbcType> explicitJdbcTypeAccess;\n\tprivate Function<TypeConfiguration, MutabilityPlan> explicitMutabilityPlanAccess;\n\tprivate Function<TypeConfiguration, java.lang.reflect.Type> implicitJavaTypeAccess;\n\n\tprivate EnumType enumerationStyle;\n\tprivate TemporalType temporalPrecision;\n\tprivate TimeZoneStorageType timeZoneStorageType;\n\tprivate boolean isSoftDelete;\n\tprivate SoftDeleteType softDeleteStrategy;\n\n\tprivate java.lang.reflect.Type resolvedJavaType;\n\n\tprivate String ownerName;\n\tprivate String propertyName;\n\tprivate AggregateColumn aggregateColumn;\n\n\t// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\t// Resolved state - available after `#resolve`\n\tprivate Resolution<?> resolution;\n\tprivate Integer jdbcTypeCode;\n\n\n\tpublic BasicValue(MetadataBuildingContext buildingContext) {\n\t\tthis( buildingContext, null );\n\t}\n\n\tpublic BasicValue(MetadataBuildingContext buildingContext, Table table) {\n\t\tsuper( buildingContext, table );\n\t\tbuildingContext.getMetadataCollector().registerValueMappingResolver( this::resolve );\n\t}\n\n\tpublic BasicValue(BasicValue original) {\n\t\tsuper( original );\n\t\tthis.explicitTypeName = original.explicitTypeName;\n\t\tthis.explicitLocalTypeParams = original.explicitLocalTypeParams == null\n\t\t\t\t? null\n\t\t\t\t: new HashMap<>(original.explicitLocalTypeParams);\n\t\tthis.explicitJavaTypeAccess = original.explicitJavaTypeAccess;\n\t\tthis.explicitJdbcTypeAccess = original.explicitJdbcTypeAccess;\n\t\tthis.explicitMutabilityPlanAccess = original.explicitMutabilityPlanAccess;\n\t\tthis.implicitJavaTypeAccess = original.implicitJavaTypeAccess;\n\t\tthis.enumerationStyle = original.enumerationStyle;\n\t\tthis.temporalPrecision = original.temporalPrecision;\n\t\tthis.timeZoneStorageType = original.timeZoneStorageType;\n\t\tthis.resolvedJavaType = original.resolvedJavaType;\n\t\tthis.ownerName = original.ownerName;\n\t\tthis.propertyName = original.propertyName;\n\t}\n\n\t@Override\n\tpublic BasicValue copy() {\n\t\treturn new BasicValue( this );\n\t}\n\n\tpublic boolean isSoftDelete() {\n\t\treturn isSoftDelete;\n\t}\n\n\tpublic SoftDeleteType getSoftDeleteStrategy() {\n\t\treturn softDeleteStrategy;\n\t}\n\n\tpublic void makeSoftDelete(SoftDeleteType strategy) {\n\t\tisSoftDelete = true;\n\t\tsoftDeleteStrategy = strategy;\n\t}\n\n\t// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\t// Setters - in preparation of resolution\n\n\t@Override\n\tpublic void setTypeUsingReflection(String className, String propertyName) throws MappingException {\n\t\tif ( resolution != null ) {\n\t\t\tthrow new IllegalStateException( \"BasicValue already resolved\" );\n\t\t}\n\n\t\tthis.ownerName = className;\n\t\tthis.propertyName = propertyName;\n\n\t\tsuper.setTypeUsingReflection( className, propertyName );\n\t}\n\n\tpublic void setEnumerationStyle(EnumType enumerationStyle) {\n\t\tthis.enumerationStyle = enumerationStyle;\n\t}\n\n\tpublic EnumType getEnumerationStyle() {\n\t\treturn enumerationStyle;\n\t}\n\n\tpublic TimeZoneStorageType getTimeZoneStorageType() {\n\t\treturn timeZoneStorageType;\n\t}\n\n\tpublic void setTimeZoneStorageType(TimeZoneStorageType timeZoneStorageType) {\n\t\tthis.timeZoneStorageType = timeZoneStorageType;\n\t}\n\n\tpublic void setJpaAttributeConverterDescriptor(ConverterDescriptor descriptor) {\n\t\tsetAttributeConverterDescriptor( descriptor );\n\n\t\tsuper.setJpaAttributeConverterDescriptor( descriptor );\n\t}\n\n\t@SuppressWarnings(\"rawtypes\")\n\tpublic void setExplicitJavaTypeAccess(Function<TypeConfiguration, BasicJavaType> explicitJavaTypeAccess) {\n\t\tthis.explicitJavaTypeAccess = explicitJavaTypeAccess;\n\t}\n\n\tpublic void setExplicitJdbcTypeAccess(Function<TypeConfiguration, JdbcType> jdbcTypeAccess) {\n\t\tthis.explicitJdbcTypeAccess = jdbcTypeAccess;\n\t}\n\n\tpublic void setExplicitMutabilityPlanAccess(Function<TypeConfiguration, MutabilityPlan> explicitMutabilityPlanAccess) {\n\t\tthis.explicitMutabilityPlanAccess = explicitMutabilityPlanAccess;\n\t}\n\n\tpublic void setImplicitJavaTypeAccess(Function<TypeConfiguration, java.lang.reflect.Type> implicitJavaTypeAccess) {\n\t\tthis.implicitJavaTypeAccess = implicitJavaTypeAccess;\n\t}\n\n\tpublic Selectable getColumn() {\n\t\tif ( getColumnSpan() == 0 ) {\n\t\t\treturn null;\n\t\t}\n\t\treturn getColumn( 0 );\n\t}\n\n\tpublic java.lang.reflect.Type getResolvedJavaType() {\n\t\treturn resolvedJavaType;\n\t}\n\n\t@Override\n\tpublic long getColumnLength() {\n\t\tfinal Selectable selectable = getColumn();\n\t\tif ( selectable instanceof Column ) {\n\t\t\tfinal Column column = (Column) selectable;\n\t\t\tfinal Long length = column.getLength();\n\t\t\treturn length == null ? NO_COLUMN_LENGTH : length;\n\t\t}\n\t\telse {\n\t\t\treturn NO_COLUMN_LENGTH;\n\t\t}\n\t}\n\n\t@Override\n\tpublic int getColumnPrecision() {\n\t\tfinal Selectable selectable = getColumn();\n\t\tif ( selectable instanceof Column ) {\n\t\t\tfinal Column column = (Column) selectable;\n\t\t\tif ( column.getTemporalPrecision() != null ) {\n\t\t\t\treturn column.getTemporalPrecision();\n\t\t\t}\n\t\t\tfinal Integer precision = column.getPrecision();\n\t\t\treturn precision == null ? NO_COLUMN_PRECISION : precision;\n\t\t}\n\t\telse {\n\t\t\treturn NO_COLUMN_PRECISION;\n\t\t}\n\t}\n\n\t@Override\n\tpublic int getColumnScale() {\n\t\tfinal Selectable selectable = getColumn();\n\t\tif ( selectable instanceof Column ) {\n\t\t\tfinal Column column = (Column) selectable;\n\t\t\tfinal Integer scale = column.getScale();\n\t\t\treturn scale == null ? NO_COLUMN_SCALE : scale;\n\t\t}\n\t\telse {\n\t\t\treturn NO_COLUMN_SCALE;\n\t\t}\n\t}\n\n\t@Override\n\tpublic void addColumn(Column incomingColumn) {\n\t\tsuper.addColumn( incomingColumn );\n\n\t\tcheckSelectable( incomingColumn );\n\t}\n\n\t@Override\n\tpublic void copyTypeFrom(SimpleValue sourceValue) {\n\t\tsuper.copyTypeFrom( sourceValue );\n\t\tif ( sourceValue instanceof BasicValue ) {\n\t\t\tfinal BasicValue basicValue = (BasicValue) sourceValue;\n\t\t\tthis.resolution = basicValue.resolution;\n\t\t\tthis.implicitJavaTypeAccess = (typeConfiguration) -> basicValue.implicitJavaTypeAccess.apply( typeConfiguration );\n\t\t}\n\t}\n\n\tprivate void checkSelectable(Selectable incomingColumn) {\n\t\tif ( incomingColumn == null ) {\n\t\t\tthrow new IllegalArgumentException( \"Incoming column was null\" );\n\t\t}\n\n\t\tfinal Selectable column = getColumn();\n\t\tif ( column == incomingColumn || column.getText().equals( incomingColumn.getText() ) ) {\n\t\t\tlog.debugf( \"Skipping column re-registration: %s.%s\", getTable().getName(), column.getText() );\n\t\t}\n//\t\telse {\n//\t\t\tthrow new IllegalStateException(\n//\t\t\t\t\t\"BasicValue [\" + ownerName + \".\" + propertyName +\n//\t\t\t\t\t\t\t\"] already had column associated: `\" + column.getText() +\n//\t\t\t\t\t\t\t\"` -> `\" + incomingColumn.getText() + \"`\"\n//\t\t\t);\n//\t\t}\n\t}\n\n\t@Override\n\tpublic void addColumn(Column incomingColumn, boolean isInsertable, boolean isUpdatable) {\n\t\tsuper.addColumn( incomingColumn, isInsertable, isUpdatable );\n\t\tcheckSelectable( incomingColumn );\n\t}\n\n\t@Override\n\tpublic void addFormula(Formula formula) {\n\t\tsuper.addFormula( formula );\n\n\t\tcheckSelectable( formula );\n\t}\n\n\t// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\t// Resolution\n\n\t@Override\n\tpublic Type getType() throws MappingException {\n\t\tresolve();\n\t\tassert getResolution() != null;\n\n\t\treturn getResolution().getLegacyResolvedBasicType();\n\t}\n\n\tpublic Resolution<?> getResolution() {\n\t\treturn resolution;\n\t}\n\n\t@Override\n\tpublic boolean resolve(MetadataBuildingContext buildingContext) {\n\t\tresolve();\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic Resolution<?> resolve() {\n\t\tif ( resolution != null ) {\n\t\t\treturn resolution;\n\t\t}\n\n\t\tresolution = buildResolution();\n\n\t\tif ( resolution == null ) {\n\t\t\tthrow new IllegalStateException( \"Unable to resolve BasicValue : \" + this );\n\t\t}\n\n\t\tfinal Selectable selectable = getColumn();\n\t\tfinal Size size;\n\t\tif ( selectable instanceof Column column ) {\n\t\t\tresolveColumn( column, getDialect() );\n\t\t\tsize = column.calculateColumnSize( getDialect(), getBuildingContext().getMetadataCollector() );\n\t\t}\n\t\telse {\n\t\t\tsize = Size.nil();\n\t\t}\n\n\t\tresolution.getJdbcType().addAuxiliaryDatabaseObjects(\n\t\t\t\tresolution.getRelationalJavaType(),\n\t\t\t\tresolution.getValueConverter(),\n\t\t\t\tsize,\n\t\t\t\tgetBuildingContext().getMetadataCollector().getDatabase(),\n\t\t\t\tthis\n\t\t);\n\n\t\treturn resolution;\n\t}\n\n\t@Override\n\tpublic String getExtraCreateTableInfo() {\n\t\treturn resolution.getJdbcType()\n\t\t\t\t.getExtraCreateTableInfo(\n\t\t\t\t\t\tresolution.getRelationalJavaType(),\n\t\t\t\t\t\tgetColumn().getText(),\n\t\t\t\t\t\tgetTable().getName(),\n\t\t\t\t\t\tgetBuildingContext().getMetadataCollector().getDatabase()\n\t\t\t\t);\n\t}\n\n\t@Override\n\tpublic Dialect getDialect() {\n\t\treturn getMetadata().getDatabase().getDialect();\n\t}\n\n\tprivate void resolveColumn(Column column, Dialect dialect) {\n\n\t\tif ( column.getSqlTypeCode() == null ) {\n\t\t\tcolumn.setSqlTypeCode( resolution.getJdbcType().getDdlTypeCode() );\n\t\t}\n\n//\t\tfinal String declaration = resolution.getLegacyResolvedBasicType().getSpecializedTypeDeclaration( dialect );\n//\t\tif ( declaration != null ) {\n//\t\t\tcolumn.setSpecializedTypeDeclaration( declaration );\n//\t\t}\n\n\t\tif ( dialect.supportsColumnCheck() ) {\n\t\t\tfinal String checkCondition = resolution.getLegacyResolvedBasicType()\n\t\t\t\t\t.getCheckCondition( column.getQuotedName( dialect ), dialect );\n\t\t\tif ( checkCondition != null ) {\n\t\t\t\tcolumn.addCheckConstraint( new CheckConstraint( checkCondition ) );\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic AggregateColumn getAggregateColumn() {\n\t\treturn aggregateColumn;\n\t}\n\n\tpublic void setAggregateColumn(AggregateColumn aggregateColumn) {\n\t\tthis.aggregateColumn = aggregateColumn;\n\t}\n\n\tpublic SelectablePath createSelectablePath(String selectableName) {\n\t\tif ( aggregateColumn != null ) {\n\t\t\treturn aggregateColumn.getSelectablePath().append( selectableName );\n\t\t}\n\t\treturn new SelectablePath( selectableName );\n\t}\n\n\tprotected Resolution<?> buildResolution() {\n\t\tfinal Properties typeParameters = getTypeParameters();\n\t\tif ( typeParameters != null\n\t\t\t\t&& parseBoolean( typeParameters.getProperty(DynamicParameterizedType.IS_DYNAMIC) )\n\t\t\t\t&& typeParameters.get(DynamicParameterizedType.PARAMETER_TYPE) == null ) {\n\t\t\tcreateParameterImpl();\n\t\t}\n\n\t\tif ( explicitTypeName != null ) {\n\t\t\treturn interpretExplicitlyNamedType(\n\t\t\t\t\texplicitTypeName,\n\t\t\t\t\texplicitJavaTypeAccess,\n\t\t\t\t\texplicitJdbcTypeAccess,\n\t\t\t\t\texplicitMutabilityPlanAccess,\n\t\t\t\t\tgetAttributeConverterDescriptor(),\n\t\t\t\t\ttypeParameters,\n\t\t\t\t\tthis::setTypeParameters,\n\t\t\t\t\tthis,\n\t\t\t\t\tgetBuildingContext()\n\t\t\t);\n\t\t}\n\n\t\tif ( isVersion() ) {\n\t\t\treturn VersionResolution.from( implicitJavaTypeAccess, timeZoneStorageType, getBuildingContext() );\n\t\t}\n\n\t\t// determine JavaType if we can\n\t\tfinal BasicJavaType<?> explicitJavaType = explicitJavaTypeAccess == null\n\t\t\t\t? null\n\t\t\t\t: explicitJavaTypeAccess.apply( getTypeConfiguration() );\n\n\t\tJavaType<?> javaType = determineJavaType( explicitJavaType );\n\t\tConverterDescriptor attributeConverterDescriptor = getAttributeConverterDescriptor();\n\n\t\tif ( isSoftDelete() ) {\n\t\t\tassert attributeConverterDescriptor != null;\n\t\t\tfinal boolean conversionWasUnspecified = SoftDelete.UnspecifiedConversion.class.equals( attributeConverterDescriptor.getAttributeConverterClass() );\n\t\t\tif ( conversionWasUnspecified ) {\n\t\t\t\tfinal JdbcType jdbcType = BooleanJdbcType.INSTANCE.resolveIndicatedType( this, javaType );\n\t\t\t\tif ( jdbcType.isNumber() ) {\n\t\t\t\t\tattributeConverterDescriptor = new InstanceBasedConverterDescriptor(\n\t\t\t\t\t\t\tNumericBooleanConverter.INSTANCE,\n\t\t\t\t\t\t\tgetBuildingContext().getBootstrapContext().getClassmateContext()\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\telse if ( jdbcType.isString() ) {\n\t\t\t\t\t// here we pick 'T' / 'F' storage, though 'Y' / 'N' is equally valid - its 50/50\n\t\t\t\t\tattributeConverterDescriptor = new InstanceBasedConverterDescriptor(\n\t\t\t\t\t\t\tTrueFalseConverter.INSTANCE,\n\t\t\t\t\t\t\tgetBuildingContext().getBootstrapContext().getClassmateContext()\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// should indicate BIT or BOOLEAN == no conversion needed\n\t\t\t\t\t//\t\t- we still create the converter to properly set up JDBC type, etc\n\t\t\t\t\tattributeConverterDescriptor = new InstanceBasedConverterDescriptor(\n\t\t\t\t\t\t\tPassThruSoftDeleteConverter.INSTANCE,\n\t\t\t\t\t\t\tgetBuildingContext().getBootstrapContext().getClassmateContext()\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( getSoftDeleteStrategy() == SoftDeleteType.ACTIVE ) {\n\t\t\t\tattributeConverterDescriptor = new ReversedConverterDescriptor<>( attributeConverterDescriptor );\n\t\t\t}\n\t\t}\n\n\t\treturn attributeConverterDescriptor != null\n\t\t\t\t? converterResolution( javaType, attributeConverterDescriptor )\n\t\t\t\t: resolution( explicitJavaType, javaType );\n\t}\n\n\tprivate static class ReversedConverterDescriptor<R> implements ConverterDescriptor {\n\t\tprivate final ConverterDescriptor underlyingDescriptor;\n\n\t\tpublic ReversedConverterDescriptor(ConverterDescriptor underlyingDescriptor) {\n\t\t\tthis.underlyingDescriptor = underlyingDescriptor;\n\t\t}\n\n\t\t@Override\n\t\tpublic Class<? extends AttributeConverter<Boolean,R>> getAttributeConverterClass() {\n\t\t\t//noinspection unchecked\n\t\t\treturn (Class<? extends AttributeConverter<Boolean, R>>) getClass();\n\t\t}\n\n\t\t@Override\n\t\tpublic ResolvedType getDomainValueResolvedType() {\n\t\t\treturn underlyingDescriptor.getDomainValueResolvedType();\n\t\t}\n\n\t\t@Override\n\t\tpublic ResolvedType getRelationalValueResolvedType() {\n\t\t\treturn underlyingDescriptor.getRelationalValueResolvedType();\n\t\t}\n\n\t\t@Override\n\t\tpublic AutoApplicableConverterDescriptor getAutoApplyDescriptor() {\n\t\t\treturn AutoApplicableConverterDescriptorBypassedImpl.INSTANCE;\n\t\t}\n\n\t\t@Override\n\t\tpublic JpaAttributeConverter<Boolean,R> createJpaAttributeConverter(JpaAttributeConverterCreationContext context) {\n\t\t\t//noinspection unchecked\n\t\t\treturn new ReversedJpaAttributeConverter<>(\n\t\t\t\t\t(JpaAttributeConverter<Boolean, R>) underlyingDescriptor.createJpaAttributeConverter( context ),\n\t\t\t\t\tcontext.getJavaTypeRegistry().getDescriptor( ReversedJpaAttributeConverter.class )\n\t\t\t);\n\t\t}\n\t}\n\n\tprivate static class ReversedJpaAttributeConverter<R, B extends AttributeConverter<Boolean, R>>\n\t\t\timplements JpaAttributeConverter<Boolean,R>, AttributeConverter<Boolean,R>, ManagedBean<B> {\n\t\tprivate final JpaAttributeConverter<Boolean,R> underlyingJpaConverter;\n\t\tprivate final JavaType<ReversedJpaAttributeConverter<R,B>> converterJavaType;\n\n\t\tpublic ReversedJpaAttributeConverter(\n\t\t\t\tJpaAttributeConverter<Boolean, R> underlyingJpaConverter,\n\t\t\t\tJavaType<ReversedJpaAttributeConverter<R,B>> converterJavaType) {\n\t\t\tthis.underlyingJpaConverter = underlyingJpaConverter;\n\t\t\tthis.converterJavaType = converterJavaType;\n\t\t}\n\n\t\t@Override\n\t\tpublic Boolean toDomainValue(R relationalValue) {\n\t\t\treturn !underlyingJpaConverter.toDomainValue( relationalValue );\n\t\t}\n\n\t\t@Override\n\t\tpublic R toRelationalValue(Boolean domainValue) {\n\t\t\treturn underlyingJpaConverter.toRelationalValue( domainValue != null ? !domainValue : null );\n\t\t}\n\n\t\t@Override\n\t\tpublic Boolean convertToEntityAttribute(R relationalValue) {\n\t\t\treturn toDomainValue( relationalValue );\n\t\t}\n\n\t\t@Override\n\t\tpublic R convertToDatabaseColumn(Boolean domainValue) {\n\t\t\treturn toRelationalValue( domainValue );\n\t\t}\n\n\t\t@Override\n\t\tpublic JavaType<Boolean> getDomainJavaType() {\n\t\t\treturn underlyingJpaConverter.getDomainJavaType();\n\t\t}\n\n\t\t@Override\n\t\tpublic JavaType<R> getRelationalJavaType() {\n\t\t\treturn underlyingJpaConverter.getRelationalJavaType();\n\t\t}\n\n\t\t@Override\n\t\tpublic JavaType<? extends AttributeConverter<Boolean, R>> getConverterJavaType() {\n\t\t\treturn converterJavaType;\n\t\t}\n\n\t\t@Override\n\t\tpublic ManagedBean<? extends AttributeConverter<Boolean, R>> getConverterBean() {\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\tpublic Class<B> getBeanClass() {\n\t\t\t//noinspection unchecked\n\t\t\treturn (Class<B>) getClass();\n\t\t}\n\n\t\t@Override\n\t\tpublic B getBeanInstance() {\n\t\t\t//noinspection unchecked\n\t\t\treturn (B) this;\n\t\t}\n\t}\n\n\tprivate static class PassThruSoftDeleteConverter implements AttributeConverter<Boolean,Boolean> {\n\t\tprivate static final PassThruSoftDeleteConverter INSTANCE = new PassThruSoftDeleteConverter();\n\n\t\t@Override\n\t\tpublic Boolean convertToDatabaseColumn(Boolean domainValue) {\n\t\t\treturn domainValue;\n\t\t}\n\n\t\t@Override\n\t\tpublic Boolean convertToEntityAttribute(Boolean relationalValue) {\n\t\t\treturn relationalValue;\n\t\t}\n\t}\n\n\tprivate Resolution<?> resolution(BasicJavaType explicitJavaType, JavaType<?> javaType) {\n\t\tfinal JavaType<?> basicJavaType;\n\t\tfinal JdbcType jdbcType;\n\t\tif ( explicitJdbcTypeAccess != null ) {\n\t\t\tfinal TypeConfiguration typeConfiguration = getTypeConfiguration();\n\t\t\tjdbcType = explicitJdbcTypeAccess.apply( typeConfiguration );\n\t\t\tbasicJavaType = javaType == null && jdbcType != null\n\t\t\t\t\t? jdbcType.getJdbcRecommendedJavaTypeMapping(null, null, typeConfiguration)\n\t\t\t\t\t: javaType;\n\t\t}\n\t\telse {\n\t\t\tjdbcType = null;\n\t\t\tbasicJavaType = javaType;\n\t\t}\n\t\tif ( basicJavaType == null ) {\n\t\t\tthrow new MappingException( \"Unable to determine JavaType to use : \" + this );\n\t\t}\n\n\t\tif ( basicJavaType instanceof BasicJavaType<?>\n\t\t\t\t&& ( !basicJavaType.getJavaTypeClass().isEnum() || enumerationStyle == null ) ) {\n\t\t\tfinal TypeDefinition autoAppliedTypeDef =\n\t\t\t\t\tgetBuildingContext().getTypeDefinitionRegistry()\n\t\t\t\t\t\t\t.resolveAutoApplied( (BasicJavaType<?>) basicJavaType );\n\t\t\tif ( autoAppliedTypeDef != null ) {\n\t\t\t\tlog.debug(\"BasicValue resolution matched auto-applied type-definition\");\n\t\t\t\treturn autoAppliedTypeDef.resolve( getTypeParameters(), null, getBuildingContext(), this );\n\t\t\t}\n\t\t}\n\n\t\treturn InferredBasicValueResolver.from(\n\t\t\t\texplicitJavaType,\n\t\t\t\tjdbcType,\n\t\t\t\tresolvedJavaType,\n\t\t\t\tthis::determineReflectedJavaType,\n\t\t\t\texplicitMutabilityPlanAccess,\n\t\t\t\tthis,\n\t\t\t\tgetTable(),\n\t\t\t\tgetColumn(),\n\t\t\t\townerName,\n\t\t\t\tpropertyName,\n\t\t\t\tgetBuildingContext()\n\t\t);\n\t}\n\n\t@Override\n\tpublic ManagedBeanRegistry getManagedBeanRegistry() {\n\t\treturn getServiceRegistry().requireService( ManagedBeanRegistry.class );\n\t}\n\n\tprivate Resolution<?> converterResolution(JavaType<?> javaType, ConverterDescriptor attributeConverterDescriptor) {\n\t\tfinal NamedConverterResolution<?> converterResolution = NamedConverterResolution.from(\n\t\t\t\tattributeConverterDescriptor,\n\t\t\t\texplicitJavaTypeAccess,\n\t\t\t\texplicitJdbcTypeAccess,\n\t\t\t\texplicitMutabilityPlanAccess,\n\t\t\t\tresolvedJavaType,\n\t\t\t\tthis,\n\t\t\t\tthis,\n\t\t\t\tgetBuildingContext()\n\t\t);\n\n\t\tif ( javaType instanceof BasicPluralJavaType<?>\n\t\t\t\t&& !attributeConverterDescriptor.getDomainValueResolvedType().getErasedType()\n\t\t\t\t\t\t.isAssignableFrom( javaType.getJavaTypeClass() ) ) {\n\t\t\t// In this case, the converter applies to the element of a BasicPluralJavaType\n\t\t\tfinal BasicPluralJavaType<?> containerJtd = (BasicPluralJavaType<?>) javaType;\n\t\t\tfinal BasicType registeredElementType = converterResolution.getLegacyResolvedBasicType();\n\t\t\tfinal Selectable column = getColumn();\n\t\t\tfinal BasicType<?> registeredType = registeredElementType == null ? null\n\t\t\t\t\t: containerJtd.resolveType(\n\t\t\t\t\t\t\tgetTypeConfiguration(),\n\t\t\t\t\t\t\tgetDialect(),\n\t\t\t\t\t\t\tregisteredElementType,\n\t\t\t\t\t\t\tcolumn instanceof ColumnTypeInformation ? (ColumnTypeInformation) column : null,\n\t\t\t\t\t\t\tthis\n\t\t\t);\n\t\t\tif ( registeredType != null ) {\n\t\t\t\tgetTypeConfiguration().getBasicTypeRegistry().register( registeredType );\n\t\t\t\treturn new InferredBasicValueResolution(\n\t\t\t\t\t\tregisteredType,\n\t\t\t\t\t\tregisteredType.getJavaTypeDescriptor(),\n\t\t\t\t\t\tregisteredType.getJavaTypeDescriptor(),\n\t\t\t\t\t\tregisteredType.getJdbcType(),\n\t\t\t\t\t\tregisteredType,\n\t\t\t\t\t\tnull\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\treturn converterResolution;\n\t}\n\n\tprivate JavaType<?> determineJavaType(JavaType<?> explicitJavaType) {\n\t\tJavaType<?> javaType = explicitJavaType;\n//\n//\t\tif ( javaType == null ) {\n//\t\t\tif ( implicitJavaTypeAccess != null ) {\n//\t\t\t\tfinal java.lang.reflect.Type implicitJtd = implicitJavaTypeAccess.apply( getTypeConfiguration() );\n//\t\t\t\tif ( implicitJtd != null ) {\n//\t\t\t\t\tjavaType = getTypeConfiguration().getJavaTypeRegistry().getDescriptor( implicitJtd );\n//\t\t\t\t}\n//\t\t\t}\n//\t\t}\n\n\t\tif ( javaType == null ) {\n\t\t\tfinal JavaType<?> reflectedJtd = determineReflectedJavaType();\n\t\t\tif ( reflectedJtd != null ) {\n\t\t\t\tjavaType = reflectedJtd;\n\t\t\t}\n\t\t}\n\n\t\treturn javaType;\n\t}\n\n\tprivate JavaType<?> determineReflectedJavaType() {\n\t\tfinal java.lang.reflect.Type impliedJavaType;\n\n\t\tfinal TypeConfiguration typeConfiguration = getTypeConfiguration();\n\t\tif ( resolvedJavaType != null ) {\n\t\t\timpliedJavaType = resolvedJavaType;\n\t\t}\n\t\telse if ( implicitJavaTypeAccess != null ) {\n\t\t\timpliedJavaType = implicitJavaTypeAccess.apply( typeConfiguration );\n\t\t}\n\t\telse if ( ownerName != null && propertyName != null ) {\n\t\t\timpliedJavaType = ReflectHelper.reflectedPropertyType(\n\t\t\t\t\townerName,\n\t\t\t\t\tpropertyName,\n\t\t\t\t\tgetServiceRegistry().requireService( ClassLoaderService.class )\n\t\t\t);\n\t\t}\n\t\telse {\n\t\t\treturn null;\n\t\t}\n\n\t\tresolvedJavaType = impliedJavaType;\n\n\t\tif ( impliedJavaType == null ) {\n\t\t\treturn null;\n\t\t}\n\n\t\tfinal JavaTypeRegistry javaTypeRegistry = typeConfiguration.getJavaTypeRegistry();\n\t\tfinal JavaType<Object> javaType = javaTypeRegistry.findDescriptor( impliedJavaType );\n\t\tfinal MutabilityPlan<Object> explicitMutabilityPlan = explicitMutabilityPlanAccess != null\n\t\t\t\t? explicitMutabilityPlanAccess.apply( typeConfiguration )\n\t\t\t\t: null;\n\t\tfinal MutabilityPlan<Object> determinedMutabilityPlan = explicitMutabilityPlan != null\n\t\t\t\t? explicitMutabilityPlan\n\t\t\t\t: RegistryHelper.INSTANCE.determineMutabilityPlan( impliedJavaType, typeConfiguration );\n\t\tif ( javaType == null ) {\n\t\t\tif ( jdbcTypeCode != null ) {\n\t\t\t\t// Construct special JavaType instances for JSON/XML types which can report recommended JDBC types\n\t\t\t\t// and implement toString/fromString as well as copying based on FormatMapper operations\n\t\t\t\tswitch ( jdbcTypeCode ) {\n\t\t\t\t\tcase SqlTypes.JSON:\n\t\t\t\t\t\tfinal JavaType<Object> jsonJavaType = new JsonJavaType<>(\n\t\t\t\t\t\t\t\timpliedJavaType,\n\t\t\t\t\t\t\t\tdeterminedMutabilityPlan,\n\t\t\t\t\t\t\t\ttypeConfiguration\n\t\t\t\t\t\t);\n\t\t\t\t\t\tjavaTypeRegistry.addDescriptor( jsonJavaType );\n\t\t\t\t\t\treturn jsonJavaType;\n\t\t\t\t\tcase SqlTypes.SQLXML:\n\t\t\t\t\t\tfinal JavaType<Object> xmlJavaType = new XmlJavaType<>(\n\t\t\t\t\t\t\t\timpliedJavaType,\n\t\t\t\t\t\t\t\tdeterminedMutabilityPlan,\n\t\t\t\t\t\t\t\ttypeConfiguration\n\t\t\t\t\t\t);\n\t\t\t\t\t\tjavaTypeRegistry.addDescriptor( xmlJavaType );\n\t\t\t\t\t\treturn xmlJavaType;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn javaTypeRegistry.resolveDescriptor( impliedJavaType );\n\t\t}\n\t\treturn javaType;\n\t}\n\n\tprivate static Resolution<?> interpretExplicitlyNamedType(\n\t\t\tString name,\n\t\t\tFunction<TypeConfiguration, BasicJavaType> explicitJtdAccess,\n\t\t\tFunction<TypeConfiguration, JdbcType> explicitStdAccess,\n\t\t\tFunction<TypeConfiguration, MutabilityPlan> explicitMutabilityPlanAccess,\n\t\t\tConverterDescriptor converterDescriptor,\n\t\t\tMap<Object,Object> localTypeParams,\n\t\t\tConsumer<Properties> combinedParameterConsumer,\n\t\t\tJdbcTypeIndicators stdIndicators,\n\t\t\tMetadataBuildingContext context) {\n\n\t\tfinal StandardServiceRegistry serviceRegistry = context.getBootstrapContext().getServiceRegistry();\n\t\tfinal ManagedBeanRegistry managedBeanRegistry = serviceRegistry.requireService( ManagedBeanRegistry.class );\n\t\tfinal TypeConfiguration typeConfiguration = context.getBootstrapContext().getTypeConfiguration();\n\n\t\tfinal JpaAttributeConverterCreationContext converterCreationContext = new JpaAttributeConverterCreationContext() {\n\t\t\t@Override\n\t\t\tpublic ManagedBeanRegistry getManagedBeanRegistry() {\n\t\t\t\treturn managedBeanRegistry;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic TypeConfiguration getTypeConfiguration() {\n\t\t\t\treturn typeConfiguration;\n\t\t\t}\n\t\t};\n\n\t\t// Name could refer to:\n\t\t//\t\t1) a named converter - HBM support for JPA's AttributeConverter via its `type=\"...\"` XML attribute\n\t\t//\t\t2) a \"named composed\" mapping - like (1), this is mainly to support envers since it tells\n\t\t//\t\t\tHibernate the mappings via DOM.  See `org.hibernate.type.internal.BasicTypeImpl`\n\t\t//\t\t3) basic type \"resolution key\"\n\t\t//\t\t4) UserType or BasicType class name - directly, or through a TypeDefinition\n\n\t\tif ( name.startsWith( ConverterDescriptor.TYPE_NAME_PREFIX  ) ) {\n\t\t\treturn NamedConverterResolution.from(\n\t\t\t\t\tname,\n\t\t\t\t\texplicitJtdAccess,\n\t\t\t\t\texplicitStdAccess,\n\t\t\t\t\texplicitMutabilityPlanAccess,\n\t\t\t\t\tstdIndicators,\n\t\t\t\t\tconverterCreationContext,\n\t\t\t\t\tcontext\n\t\t\t);\n\t\t}\n\n//\t\tif ( name.startsWith( EnumeratedValueResolution.PREFIX ) ) {\n//\t\t\treturn EnumeratedValueResolution.fromName( name, stdIndicators, context );\n//\t\t}\n\n\t\tif ( name.startsWith( BasicTypeImpl.EXTERNALIZED_PREFIX ) ) {\n\t\t\tfinal BasicType<Object> basicType = context.getBootstrapContext().resolveAdHocBasicType( name );\n\t\t\treturn new NamedBasicTypeResolution<>(\n\t\t\t\t\tbasicType.getJavaTypeDescriptor(),\n\t\t\t\t\tbasicType,\n\t\t\t\t\tnull,\n\t\t\t\t\texplicitMutabilityPlanAccess,\n\t\t\t\t\tcontext\n\t\t\t);\n\t\t}\n\n\t\t// see if it is a named basic type\n\t\tfinal BasicType<?> basicTypeByName = typeConfiguration.getBasicTypeRegistry().getRegisteredType( name );\n\t\tif ( basicTypeByName != null ) {\n\t\t\tfinal BasicValueConverter<?,?> valueConverter;\n\t\t\tfinal JavaType<?> domainJtd;\n\t\t\tif ( converterDescriptor != null ) {\n\t\t\t\tvalueConverter = converterDescriptor.createJpaAttributeConverter( converterCreationContext );\n\t\t\t\tdomainJtd = valueConverter.getDomainJavaType();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tvalueConverter = basicTypeByName.getValueConverter();\n\t\t\t\tdomainJtd = basicTypeByName.getJavaTypeDescriptor();\n\t\t\t}\n\n\t\t\treturn new NamedBasicTypeResolution<>(\n\t\t\t\t\tdomainJtd,\n\t\t\t\t\tbasicTypeByName,\n\t\t\t\t\tvalueConverter,\n\t\t\t\t\texplicitMutabilityPlanAccess,\n\t\t\t\t\tcontext\n\t\t\t);\n\t\t}\n\n\t\t// see if it is a named TypeDefinition\n\t\tfinal TypeDefinition typeDefinition = context.getTypeDefinitionRegistry().resolve( name );\n\t\tif ( typeDefinition != null ) {\n\t\t\tfinal Resolution<?> resolution = typeDefinition.resolve(\n\t\t\t\t\tlocalTypeParams,\n\t\t\t\t\texplicitMutabilityPlanAccess != null\n\t\t\t\t\t\t\t? explicitMutabilityPlanAccess.apply( typeConfiguration )\n\t\t\t\t\t\t\t: null,\n\t\t\t\t\tcontext,\n\t\t\t\t\tstdIndicators\n\t\t\t);\n\t\t\tcombinedParameterConsumer.accept( resolution.getCombinedTypeParameters() );\n\t\t\treturn resolution;\n\t\t}\n\n\n\t\t// see if the name is a UserType or BasicType implementor class name\n\t\tfinal ClassLoaderService cls = serviceRegistry.requireService( ClassLoaderService.class );\n\t\ttry {\n\t\t\tfinal Class<?> typeNamedClass = cls.classForName( name );\n\n\t\t\t// if there are no local config params, register an implicit TypeDefinition for this custom type .\n\t\t\t//  later uses may find it and re-use its cacheable reference...\n\t\t\tif ( CollectionHelper.isEmpty( localTypeParams ) ) {\n\t\t\t\tfinal TypeDefinition implicitDefinition = new TypeDefinition(\n\t\t\t\t\t\tname,\n\t\t\t\t\t\ttypeNamedClass,\n\t\t\t\t\t\tnull,\n\t\t\t\t\t\tnull\n\t\t\t\t);\n\t\t\t\tcontext.getTypeDefinitionRegistry().register( implicitDefinition );\n\t\t\t\treturn implicitDefinition.resolve(\n\t\t\t\t\t\tlocalTypeParams,\n\t\t\t\t\t\texplicitMutabilityPlanAccess != null\n\t\t\t\t\t\t\t\t? explicitMutabilityPlanAccess.apply( typeConfiguration )\n\t\t\t\t\t\t\t\t: null,\n\t\t\t\t\t\tcontext,\n\t\t\t\t\t\tstdIndicators\n\t\t\t\t);\n\t\t\t}\n\n\t\t\treturn TypeDefinition.createLocalResolution( name, typeNamedClass, localTypeParams, context );\n\t\t}\n\t\tcatch (ClassLoadingException e) {\n\t\t\t// allow the exception below to trigger\n\t\t\tlog.debugf( \"Could not resolve type-name [%s] as Java type : %s\", name, e );\n\t\t}\n\n\t\tthrow new MappingException( \"Could not resolve named type : \" + name );\n\t}\n\n\n\t// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\t// SqlTypeDescriptorIndicators\n\n\t@Override\n\tpublic EnumType getEnumeratedType() {\n\t\treturn getEnumerationStyle();\n\t}\n\n\n\t@Override\n\tpublic int getPreferredSqlTypeCodeForBoolean() {\n\t\treturn resolveJdbcTypeCode( getBuildingContext().getPreferredSqlTypeCodeForBoolean() );\n\t}\n\n\t@Override\n\tpublic int getPreferredSqlTypeCodeForDuration() {\n\t\treturn resolveJdbcTypeCode( getBuildingContext().getPreferredSqlTypeCodeForDuration() );\n\t}\n\n\t@Override\n\tpublic int getPreferredSqlTypeCodeForUuid() {\n\t\treturn resolveJdbcTypeCode( getBuildingContext().getPreferredSqlTypeCodeForUuid() );\n\t}\n\n\t@Override\n\tpublic int getPreferredSqlTypeCodeForInstant() {\n\t\treturn resolveJdbcTypeCode( getBuildingContext().getPreferredSqlTypeCodeForInstant() );\n\t}\n\n\t@Override\n\tpublic int getPreferredSqlTypeCodeForArray() {\n\t\treturn resolveJdbcTypeCode( getBuildingContext().getPreferredSqlTypeCodeForArray() );\n\t}\n\n\t@Override\n\tpublic int resolveJdbcTypeCode(int jdbcTypeCode) {\n\t\treturn aggregateColumn == null\n\t\t\t\t? jdbcTypeCode\n\t\t\t\t: getDialect().getAggregateSupport()\n\t\t\t\t.aggregateComponentSqlTypeCode( aggregateColumn.getSqlTypeCode( getMetadata() ), jdbcTypeCode );\n\t}\n\n\t@Override\n\tpublic TimeZoneStorageStrategy getDefaultTimeZoneStorageStrategy() {\n\t\treturn timeZoneStorageStrategy( timeZoneStorageType, getBuildingContext() );\n\t}\n\n\t@Internal\n\tpublic static TimeZoneStorageStrategy timeZoneStorageStrategy(\n\t\t\tTimeZoneStorageType timeZoneStorageType,\n\t\t\tMetadataBuildingContext buildingContext) {\n\t\tif ( timeZoneStorageType != null ) {\n\t\t\tswitch ( timeZoneStorageType ) {\n\t\t\t\tcase COLUMN:\n\t\t\t\t\treturn TimeZoneStorageStrategy.COLUMN;\n\t\t\t\tcase NATIVE:\n\t\t\t\t\treturn TimeZoneStorageStrategy.NATIVE;\n\t\t\t\tcase NORMALIZE:\n\t\t\t\t\treturn TimeZoneStorageStrategy.NORMALIZE;\n\t\t\t\tcase NORMALIZE_UTC:\n\t\t\t\t\treturn TimeZoneStorageStrategy.NORMALIZE_UTC;\n\t\t\t}\n\t\t}\n\t\treturn buildingContext.getBuildingOptions().getDefaultTimeZoneStorage();\n\t}\n\n\tpublic void setExplicitTypeParams(Map<String,String> explicitLocalTypeParams) {\n\t\tthis.explicitLocalTypeParams = explicitLocalTypeParams;\n\t}\n\n\tpublic void setExplicitTypeName(String typeName) {\n\t\tthis.explicitTypeName = typeName;\n\t}\n\n\tpublic void setTypeName(String typeName) {\n\t\tif ( StringHelper.isNotEmpty( typeName ) ) {\n\t\t\tif ( typeName.startsWith( ConverterDescriptor.TYPE_NAME_PREFIX ) ) {\n\t\t\t\tfinal String converterClassName = typeName.substring( ConverterDescriptor.TYPE_NAME_PREFIX.length() );\n\t\t\t\tfinal ClassLoaderService cls = getServiceRegistry().requireService( ClassLoaderService.class );\n\t\t\t\ttry {\n\t\t\t\t\tfinal Class<AttributeConverter<?,?>> converterClass = cls.classForName( converterClassName );\n\t\t\t\t\tsetAttributeConverterDescriptor( new ClassBasedConverterDescriptor(\n\t\t\t\t\t\t\tconverterClass,\n\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\tgetBuildingContext().getBootstrapContext().getClassmateContext()\n\t\t\t\t\t) );\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tcatch (Exception e) {\n\t\t\t\t\tlog.logBadHbmAttributeConverterType( typeName, e.getMessage() );\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsetExplicitTypeName( typeName );\n\t\t\t}\n\t\t}\n\n\t\tsuper.setTypeName( typeName );\n\t}\n\n\tprivate static int COUNTER;\n\n\tpublic void setExplicitCustomType(Class<? extends UserType<?>> explicitCustomType) {\n\t\tif ( explicitCustomType != null ) {\n\t\t\tif ( resolution != null ) {\n\t\t\t\tthrow new UnsupportedOperationException( \"Unsupported attempt to set an explicit-custom-type when value is already resolved\" );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tresolution = new UserTypeResolution<>(\n\t\t\t\t\t\tnew CustomType<>(\n\t\t\t\t\t\t\t\tgetConfiguredUserTypeBean( explicitCustomType, getCustomTypeProperties() ),\n\t\t\t\t\t\t\t\tgetTypeConfiguration()\n\t\t\t\t\t\t),\n\t\t\t\t\t\tnull,\n\t\t\t\t\t\tgetCustomTypeProperties()\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate Properties getCustomTypeProperties() {\n\t\tfinal Properties properties = new Properties();\n\t\tif ( isNotEmpty( getTypeParameters() ) ) {\n\t\t\tproperties.putAll( getTypeParameters() );\n\t\t}\n\t\tif ( isNotEmpty( explicitLocalTypeParams ) ) {\n\t\t\tproperties.putAll( explicitLocalTypeParams );\n\t\t}\n\t\treturn properties;\n\t}\n\n\tprivate UserType<?> getConfiguredUserTypeBean(Class<? extends UserType<?>> explicitCustomType, Properties properties) {\n\t\tfinal UserType<?> typeInstance =\n\t\t\t\t!getBuildingContext().getBuildingOptions().isAllowExtensionsInCdi()\n\t\t\t\t\t\t? FallbackBeanInstanceProducer.INSTANCE.produceBeanInstance( explicitCustomType )\n\t\t\t\t\t\t: getUserTypeBean( explicitCustomType, properties ).getBeanInstance();\n\n\t\tif ( typeInstance instanceof TypeConfigurationAware ) {\n\t\t\tfinal TypeConfigurationAware configurationAware = (TypeConfigurationAware) typeInstance;\n\t\t\tconfigurationAware.setTypeConfiguration( getTypeConfiguration() );\n\t\t}\n\n\t\tif ( typeInstance instanceof DynamicParameterizedType ) {\n\t\t\tif ( parseBoolean( properties.getProperty( DynamicParameterizedType.IS_DYNAMIC ) ) ) {\n\t\t\t\tif ( properties.get( DynamicParameterizedType.PARAMETER_TYPE ) == null ) {\n\t\t\t\t\tproperties.put( DynamicParameterizedType.PARAMETER_TYPE, makeParameterImpl() );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tinjectParameters( typeInstance, properties);\n\t\t// envers - grr\n\t\tsetTypeParameters( properties );\n\n\t\treturn typeInstance;\n\t}\n\n\tprivate <T> ManagedBean<T> getUserTypeBean(Class<T> explicitCustomType, Properties properties) {\n\t\tfinal BeanInstanceProducer producer = getBuildingContext().getBootstrapContext().getCustomTypeProducer();\n\t\tfinal ManagedBeanRegistry registry = getServiceRegistry().requireService( ManagedBeanRegistry.class );\n\t\tif ( isNotEmpty( properties ) ) {\n\t\t\tfinal String name = explicitCustomType.getName() + COUNTER++;\n\t\t\treturn registry.getBean( name, explicitCustomType, producer );\n\t\t}\n\t\telse {\n\t\t\treturn registry.getBean( explicitCustomType, producer );\n\t\t}\n\t}\n\n\tpublic void setTemporalPrecision(TemporalType temporalPrecision) {\n\t\tthis.temporalPrecision = temporalPrecision;\n\t}\n\n\t@Override\n\tpublic TemporalType getTemporalPrecision() {\n\t\treturn temporalPrecision;\n\t}\n\n\t@Override\n\tpublic boolean isPreferJavaTimeJdbcTypesEnabled() {\n\t\treturn getBuildingContext().isPreferJavaTimeJdbcTypesEnabled();\n\t}\n\n\t@Override\n\tpublic boolean isPreferNativeEnumTypesEnabled() {\n\t\treturn getBuildingContext().isPreferNativeEnumTypesEnabled();\n\t}\n\n\t@Override\n\tpublic Object accept(ValueVisitor visitor) {\n\t\treturn visitor.accept(this);\n\t}\n\n\t@Internal\n\tpublic boolean isDisallowedWrapperArray() {\n\t\treturn getBuildingContext().getBuildingOptions().getWrapperArrayHandling() == WrapperArrayHandling.DISALLOW\n\t\t\t&& !isLob()\n\t\t\t&& ( explicitJavaTypeAccess == null || explicitJavaTypeAccess.apply( getTypeConfiguration() ) == null )\n\t\t\t&& isWrapperByteOrCharacterArray();\n\t}\n\n\tprivate boolean isWrapperByteOrCharacterArray() {\n\t\tfinal Class<?> javaTypeClass = getResolution().getDomainJavaType().getJavaTypeClass();\n\t\treturn javaTypeClass == Byte[].class || javaTypeClass == Character[].class;\n\t}\n\n\t@Incubating\n\tpublic void setExplicitJdbcTypeCode(Integer jdbcTypeCode) {\n\t\tthis.jdbcTypeCode = jdbcTypeCode;\n\t}\n\n\t@Override\n\tpublic Integer getExplicitJdbcTypeCode() {\n\t\treturn jdbcTypeCode == null ? getPreferredSqlTypeCodeForArray() : jdbcTypeCode;\n\t}\n\n\t/**\n\t * Resolved form of {@link BasicValue} as part of interpreting the\n\t * boot-time model into the run-time model\n\t */\n\tpublic interface Resolution<J> {\n\t\t/**\n\t\t * The BasicType resolved using the pre-6.0 rules.  This is temporarily\n\t\t * needed because of the split in extracting / binding\n\t\t */\n\t\tBasicType<J> getLegacyResolvedBasicType();\n\n\t\t/**\n\t\t * Get the collection of type-parameters collected both locally as well\n\t\t * as from the applied type-def, if one\n\t\t */\n\t\tdefault Properties getCombinedTypeParameters() {\n\t\t\treturn null;\n\t\t}\n\n\t\tJdbcMapping getJdbcMapping();\n\n\t\t/**\n\t\t * The JavaType for the value as part of the domain model\n\t\t */\n\t\tJavaType<J> getDomainJavaType();\n\n\t\t/**\n\t\t * The JavaType for the relational value as part of\n\t\t * the relational model (its JDBC representation)\n\t\t */\n\t\tJavaType<?> getRelationalJavaType();\n\n\t\t/**\n\t\t * The JavaType for the relational value as part of\n\t\t * the relational model (its JDBC representation)\n\t\t */\n\t\tJdbcType getJdbcType();\n\n\t\t/**\n\t\t * Converter, if any, to convert values between the\n\t\t * domain and relational JavaType representations\n\t\t */\n\t\tBasicValueConverter<J,?> getValueConverter();\n\n\t\t/**\n\t\t * The resolved MutabilityPlan\n\t\t */\n\t\tMutabilityPlan<J> getMutabilityPlan();\n\n\t\tdefault void updateResolution(BasicType<?> type) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\t}\n}\n",
        "filePathAfter": "hibernate-core/src/main/java/org/hibernate/mapping/BasicValue.java",
        "sourceCodeAfterForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later\n * See the lgpl.txt file in the root directory or http://www.gnu.org/licenses/lgpl-2.1.html\n */\npackage org.hibernate.mapping;\n\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Properties;\nimport java.util.function.Consumer;\nimport java.util.function.Function;\n\nimport org.hibernate.Incubating;\nimport org.hibernate.Internal;\nimport org.hibernate.MappingException;\nimport org.hibernate.TimeZoneStorageStrategy;\nimport org.hibernate.annotations.SoftDelete;\nimport org.hibernate.annotations.SoftDeleteType;\nimport org.hibernate.annotations.TimeZoneStorageType;\nimport org.hibernate.boot.model.TypeDefinition;\nimport org.hibernate.boot.model.convert.internal.AutoApplicableConverterDescriptorBypassedImpl;\nimport org.hibernate.boot.model.convert.internal.ClassBasedConverterDescriptor;\nimport org.hibernate.boot.model.convert.internal.InstanceBasedConverterDescriptor;\nimport org.hibernate.boot.model.convert.spi.AutoApplicableConverterDescriptor;\nimport org.hibernate.boot.model.convert.spi.ConverterDescriptor;\nimport org.hibernate.boot.model.convert.spi.JpaAttributeConverterCreationContext;\nimport org.hibernate.boot.model.process.internal.InferredBasicValueResolution;\nimport org.hibernate.boot.model.process.internal.InferredBasicValueResolver;\nimport org.hibernate.boot.model.process.internal.NamedBasicTypeResolution;\nimport org.hibernate.boot.model.process.internal.NamedConverterResolution;\nimport org.hibernate.boot.model.process.internal.UserTypeResolution;\nimport org.hibernate.boot.model.process.internal.VersionResolution;\nimport org.hibernate.boot.registry.StandardServiceRegistry;\nimport org.hibernate.boot.registry.classloading.spi.ClassLoaderService;\nimport org.hibernate.boot.registry.classloading.spi.ClassLoadingException;\nimport org.hibernate.boot.spi.MetadataBuildingContext;\nimport org.hibernate.dialect.Dialect;\nimport org.hibernate.engine.jdbc.Size;\nimport org.hibernate.internal.CoreLogging;\nimport org.hibernate.internal.CoreMessageLogger;\nimport org.hibernate.internal.util.StringHelper;\nimport org.hibernate.internal.util.collections.CollectionHelper;\nimport org.hibernate.metamodel.mapping.JdbcMapping;\nimport org.hibernate.metamodel.mapping.SelectablePath;\nimport org.hibernate.resource.beans.internal.FallbackBeanInstanceProducer;\nimport org.hibernate.resource.beans.spi.BeanInstanceProducer;\nimport org.hibernate.resource.beans.spi.ManagedBean;\nimport org.hibernate.resource.beans.spi.ManagedBeanRegistry;\nimport org.hibernate.tool.schema.extract.spi.ColumnTypeInformation;\nimport org.hibernate.type.BasicType;\nimport org.hibernate.type.CustomType;\nimport org.hibernate.type.NumericBooleanConverter;\nimport org.hibernate.type.SqlTypes;\nimport org.hibernate.type.TrueFalseConverter;\nimport org.hibernate.type.Type;\nimport org.hibernate.type.WrapperArrayHandling;\nimport org.hibernate.type.descriptor.converter.spi.BasicValueConverter;\nimport org.hibernate.type.descriptor.converter.spi.JpaAttributeConverter;\nimport org.hibernate.type.descriptor.java.BasicJavaType;\nimport org.hibernate.type.descriptor.java.BasicPluralJavaType;\nimport org.hibernate.type.descriptor.java.JavaType;\nimport org.hibernate.type.descriptor.java.MutabilityPlan;\nimport org.hibernate.type.descriptor.java.spi.JavaTypeRegistry;\nimport org.hibernate.type.descriptor.java.spi.JsonJavaType;\nimport org.hibernate.type.descriptor.java.spi.RegistryHelper;\nimport org.hibernate.type.descriptor.java.spi.XmlJavaType;\nimport org.hibernate.type.descriptor.jdbc.BooleanJdbcType;\nimport org.hibernate.type.descriptor.jdbc.JdbcType;\nimport org.hibernate.type.descriptor.jdbc.JdbcTypeIndicators;\nimport org.hibernate.type.internal.BasicTypeImpl;\nimport org.hibernate.type.spi.TypeConfiguration;\nimport org.hibernate.type.spi.TypeConfigurationAware;\nimport org.hibernate.usertype.DynamicParameterizedType;\nimport org.hibernate.usertype.UserType;\n\nimport com.fasterxml.classmate.ResolvedType;\nimport jakarta.persistence.AttributeConverter;\nimport jakarta.persistence.EnumType;\nimport jakarta.persistence.TemporalType;\n\nimport static java.lang.Boolean.parseBoolean;\nimport static org.hibernate.internal.util.ReflectHelper.reflectedPropertyType;\nimport static org.hibernate.internal.util.collections.CollectionHelper.isNotEmpty;\nimport static org.hibernate.mapping.MappingHelper.injectParameters;\n\n/**\n * @author Steve Ebersole\n */\npublic class BasicValue extends SimpleValue implements JdbcTypeIndicators, Resolvable, JpaAttributeConverterCreationContext {\n\tprivate static final CoreMessageLogger log = CoreLogging.messageLogger( BasicValue.class );\n\n\t// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\t// incoming \"configuration\" values\n\n\tprivate String explicitTypeName;\n\tprivate Map<String,String> explicitLocalTypeParams;\n\n\tprivate Function<TypeConfiguration, BasicJavaType> explicitJavaTypeAccess;\n\tprivate Function<TypeConfiguration, JdbcType> explicitJdbcTypeAccess;\n\tprivate Function<TypeConfiguration, MutabilityPlan> explicitMutabilityPlanAccess;\n\tprivate Function<TypeConfiguration, java.lang.reflect.Type> implicitJavaTypeAccess;\n\n\tprivate EnumType enumerationStyle;\n\t@SuppressWarnings(\"deprecation\")\n\tprivate TemporalType temporalPrecision;\n\tprivate TimeZoneStorageType timeZoneStorageType;\n\tprivate boolean isSoftDelete;\n\tprivate SoftDeleteType softDeleteStrategy;\n\n\tprivate java.lang.reflect.Type resolvedJavaType;\n\n\tprivate String ownerName;\n\tprivate String propertyName;\n\tprivate AggregateColumn aggregateColumn;\n\n\t// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\t// Resolved state - available after `#resolve`\n\tprivate Resolution<?> resolution;\n\tprivate Integer jdbcTypeCode;\n\n\n\tpublic BasicValue(MetadataBuildingContext buildingContext) {\n\t\tthis( buildingContext, null );\n\t}\n\n\tpublic BasicValue(MetadataBuildingContext buildingContext, Table table) {\n\t\tsuper( buildingContext, table );\n\t\tbuildingContext.getMetadataCollector().registerValueMappingResolver( this::resolve );\n\t}\n\n\tpublic BasicValue(BasicValue original) {\n\t\tsuper( original );\n\t\tthis.explicitTypeName = original.explicitTypeName;\n\t\tthis.explicitLocalTypeParams = original.explicitLocalTypeParams == null\n\t\t\t\t? null\n\t\t\t\t: new HashMap<>(original.explicitLocalTypeParams);\n\t\tthis.explicitJavaTypeAccess = original.explicitJavaTypeAccess;\n\t\tthis.explicitJdbcTypeAccess = original.explicitJdbcTypeAccess;\n\t\tthis.explicitMutabilityPlanAccess = original.explicitMutabilityPlanAccess;\n\t\tthis.implicitJavaTypeAccess = original.implicitJavaTypeAccess;\n\t\tthis.enumerationStyle = original.enumerationStyle;\n\t\tthis.temporalPrecision = original.temporalPrecision;\n\t\tthis.timeZoneStorageType = original.timeZoneStorageType;\n\t\tthis.resolvedJavaType = original.resolvedJavaType;\n\t\tthis.ownerName = original.ownerName;\n\t\tthis.propertyName = original.propertyName;\n\t}\n\n\t@Override\n\tpublic BasicValue copy() {\n\t\treturn new BasicValue( this );\n\t}\n\n\tpublic boolean isSoftDelete() {\n\t\treturn isSoftDelete;\n\t}\n\n\tpublic SoftDeleteType getSoftDeleteStrategy() {\n\t\treturn softDeleteStrategy;\n\t}\n\n\tpublic void makeSoftDelete(SoftDeleteType strategy) {\n\t\tisSoftDelete = true;\n\t\tsoftDeleteStrategy = strategy;\n\t}\n\n\t// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\t// Setters - in preparation of resolution\n\n\t@Override\n\tpublic void setTypeUsingReflection(String className, String propertyName) throws MappingException {\n\t\tif ( resolution != null ) {\n\t\t\tthrow new IllegalStateException( \"BasicValue already resolved\" );\n\t\t}\n\n\t\tthis.ownerName = className;\n\t\tthis.propertyName = propertyName;\n\n\t\tsuper.setTypeUsingReflection( className, propertyName );\n\t}\n\n\tpublic void setEnumerationStyle(EnumType enumerationStyle) {\n\t\tthis.enumerationStyle = enumerationStyle;\n\t}\n\n\tpublic EnumType getEnumerationStyle() {\n\t\treturn enumerationStyle;\n\t}\n\n\tpublic TimeZoneStorageType getTimeZoneStorageType() {\n\t\treturn timeZoneStorageType;\n\t}\n\n\tpublic void setTimeZoneStorageType(TimeZoneStorageType timeZoneStorageType) {\n\t\tthis.timeZoneStorageType = timeZoneStorageType;\n\t}\n\n\tpublic void setJpaAttributeConverterDescriptor(ConverterDescriptor descriptor) {\n\t\tsetAttributeConverterDescriptor( descriptor );\n\n\t\tsuper.setJpaAttributeConverterDescriptor( descriptor );\n\t}\n\n\t@SuppressWarnings(\"rawtypes\")\n\tpublic void setExplicitJavaTypeAccess(Function<TypeConfiguration, BasicJavaType> explicitJavaTypeAccess) {\n\t\tthis.explicitJavaTypeAccess = explicitJavaTypeAccess;\n\t}\n\n\tpublic void setExplicitJdbcTypeAccess(Function<TypeConfiguration, JdbcType> jdbcTypeAccess) {\n\t\tthis.explicitJdbcTypeAccess = jdbcTypeAccess;\n\t}\n\n\tpublic void setExplicitMutabilityPlanAccess(Function<TypeConfiguration, MutabilityPlan> explicitMutabilityPlanAccess) {\n\t\tthis.explicitMutabilityPlanAccess = explicitMutabilityPlanAccess;\n\t}\n\n\tpublic void setImplicitJavaTypeAccess(Function<TypeConfiguration, java.lang.reflect.Type> implicitJavaTypeAccess) {\n\t\tthis.implicitJavaTypeAccess = implicitJavaTypeAccess;\n\t}\n\n\tpublic Selectable getColumn() {\n\t\tif ( getColumnSpan() == 0 ) {\n\t\t\treturn null;\n\t\t}\n\t\treturn getColumn( 0 );\n\t}\n\n\tpublic java.lang.reflect.Type getResolvedJavaType() {\n\t\treturn resolvedJavaType;\n\t}\n\n\t@Override\n\tpublic long getColumnLength() {\n\t\tfinal Selectable selectable = getColumn();\n\t\tif ( selectable instanceof Column column ) {\n\t\t\tfinal Long length = column.getLength();\n\t\t\treturn length == null ? NO_COLUMN_LENGTH : length;\n\t\t}\n\t\telse {\n\t\t\treturn NO_COLUMN_LENGTH;\n\t\t}\n\t}\n\n\t@Override\n\tpublic int getColumnPrecision() {\n\t\tfinal Selectable selectable = getColumn();\n\t\tif ( selectable instanceof Column column ) {\n\t\t\tfinal Integer temporalPrecision = column.getTemporalPrecision();\n\t\t\tif ( temporalPrecision != null ) {\n\t\t\t\treturn temporalPrecision;\n\t\t\t}\n\t\t\tfinal Integer precision = column.getPrecision();\n\t\t\treturn precision == null ? NO_COLUMN_PRECISION : precision;\n\t\t}\n\t\telse {\n\t\t\treturn NO_COLUMN_PRECISION;\n\t\t}\n\t}\n\n\t@Override\n\tpublic int getColumnScale() {\n\t\tfinal Selectable selectable = getColumn();\n\t\tif ( selectable instanceof Column column ) {\n\t\t\tfinal Integer scale = column.getScale();\n\t\t\treturn scale == null ? NO_COLUMN_SCALE : scale;\n\t\t}\n\t\telse {\n\t\t\treturn NO_COLUMN_SCALE;\n\t\t}\n\t}\n\n\t@Override\n\tpublic void addColumn(Column incomingColumn) {\n\t\tsuper.addColumn( incomingColumn );\n\n\t\tcheckSelectable( incomingColumn );\n\t}\n\n\t@Override\n\tpublic void copyTypeFrom(SimpleValue sourceValue) {\n\t\tsuper.copyTypeFrom( sourceValue );\n\t\tif ( sourceValue instanceof BasicValue basicValue ) {\n\t\t\tresolution = basicValue.resolution;\n\t\t\timplicitJavaTypeAccess =\n\t\t\t\t\ttypeConfiguration -> basicValue.implicitJavaTypeAccess.apply( typeConfiguration );\n\t\t}\n\t}\n\n\tprivate void checkSelectable(Selectable incomingColumn) {\n\t\tif ( incomingColumn == null ) {\n\t\t\tthrow new IllegalArgumentException( \"Incoming column was null\" );\n\t\t}\n\n\t\tfinal Selectable column = getColumn();\n\t\tif ( column == incomingColumn || column.getText().equals( incomingColumn.getText() ) ) {\n\t\t\tlog.debugf( \"Skipping column re-registration: %s.%s\", getTable().getName(), column.getText() );\n\t\t}\n//\t\telse {\n//\t\t\tthrow new IllegalStateException(\n//\t\t\t\t\t\"BasicValue [\" + ownerName + \".\" + propertyName +\n//\t\t\t\t\t\t\t\"] already had column associated: `\" + column.getText() +\n//\t\t\t\t\t\t\t\"` -> `\" + incomingColumn.getText() + \"`\"\n//\t\t\t);\n//\t\t}\n\t}\n\n\t@Override\n\tpublic void addColumn(Column incomingColumn, boolean isInsertable, boolean isUpdatable) {\n\t\tsuper.addColumn( incomingColumn, isInsertable, isUpdatable );\n\t\tcheckSelectable( incomingColumn );\n\t}\n\n\t@Override\n\tpublic void addFormula(Formula formula) {\n\t\tsuper.addFormula( formula );\n\n\t\tcheckSelectable( formula );\n\t}\n\n\t// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\t// Resolution\n\n\t@Override\n\tpublic Type getType() throws MappingException {\n\t\tresolve();\n\t\tassert getResolution() != null;\n\n\t\treturn getResolution().getLegacyResolvedBasicType();\n\t}\n\n\tpublic Resolution<?> getResolution() {\n\t\treturn resolution;\n\t}\n\n\t@Override\n\tpublic boolean resolve(MetadataBuildingContext buildingContext) {\n\t\tresolve();\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic Resolution<?> resolve() {\n\t\tif ( resolution != null ) {\n\t\t\treturn resolution;\n\t\t}\n\n\t\tresolution = buildResolution();\n\n\t\tif ( resolution == null ) {\n\t\t\tthrow new IllegalStateException( \"Unable to resolve BasicValue : \" + this );\n\t\t}\n\n\t\tfinal Selectable selectable = getColumn();\n\t\tfinal Size size;\n\t\tif ( selectable instanceof Column column ) {\n\t\t\tresolveColumn( column, getDialect() );\n\t\t\tsize = column.calculateColumnSize( getDialect(), getBuildingContext().getMetadataCollector() );\n\t\t}\n\t\telse {\n\t\t\tsize = Size.nil();\n\t\t}\n\n\t\tresolution.getJdbcType().addAuxiliaryDatabaseObjects(\n\t\t\t\tresolution.getRelationalJavaType(),\n\t\t\t\tresolution.getValueConverter(),\n\t\t\t\tsize,\n\t\t\t\tgetBuildingContext().getMetadataCollector().getDatabase(),\n\t\t\t\tthis\n\t\t);\n\n\t\treturn resolution;\n\t}\n\n\t@Override\n\tpublic String getExtraCreateTableInfo() {\n\t\treturn resolution.getJdbcType()\n\t\t\t\t.getExtraCreateTableInfo(\n\t\t\t\t\t\tresolution.getRelationalJavaType(),\n\t\t\t\t\t\tgetColumn().getText(),\n\t\t\t\t\t\tgetTable().getName(),\n\t\t\t\t\t\tgetBuildingContext().getMetadataCollector().getDatabase()\n\t\t\t\t);\n\t}\n\n\t@Override\n\tpublic Dialect getDialect() {\n\t\treturn getMetadata().getDatabase().getDialect();\n\t}\n\n\tprivate void resolveColumn(Column column, Dialect dialect) {\n\n\t\tif ( column.getSqlTypeCode() == null ) {\n\t\t\tcolumn.setSqlTypeCode( resolution.getJdbcType().getDdlTypeCode() );\n\t\t}\n\n//\t\tfinal String declaration = resolution.getLegacyResolvedBasicType().getSpecializedTypeDeclaration( dialect );\n//\t\tif ( declaration != null ) {\n//\t\t\tcolumn.setSpecializedTypeDeclaration( declaration );\n//\t\t}\n\n\t\tif ( dialect.supportsColumnCheck() ) {\n\t\t\tfinal String checkCondition = resolution.getLegacyResolvedBasicType()\n\t\t\t\t\t.getCheckCondition( column.getQuotedName( dialect ), dialect );\n\t\t\tif ( checkCondition != null ) {\n\t\t\t\tcolumn.addCheckConstraint( new CheckConstraint( checkCondition ) );\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic AggregateColumn getAggregateColumn() {\n\t\treturn aggregateColumn;\n\t}\n\n\tpublic void setAggregateColumn(AggregateColumn aggregateColumn) {\n\t\tthis.aggregateColumn = aggregateColumn;\n\t}\n\n\tpublic SelectablePath createSelectablePath(String selectableName) {\n\t\tif ( aggregateColumn != null ) {\n\t\t\treturn aggregateColumn.getSelectablePath().append( selectableName );\n\t\t}\n\t\treturn new SelectablePath( selectableName );\n\t}\n\n\tprotected Resolution<?> buildResolution() {\n\t\tfinal Properties typeParameters = getTypeParameters();\n\t\tif ( typeParameters != null\n\t\t\t\t&& parseBoolean( typeParameters.getProperty(DynamicParameterizedType.IS_DYNAMIC) )\n\t\t\t\t&& typeParameters.get(DynamicParameterizedType.PARAMETER_TYPE) == null ) {\n\t\t\tcreateParameterImpl();\n\t\t}\n\n\t\tif ( explicitTypeName != null ) {\n\t\t\treturn interpretExplicitlyNamedType(\n\t\t\t\t\texplicitTypeName,\n\t\t\t\t\texplicitJavaTypeAccess,\n\t\t\t\t\texplicitJdbcTypeAccess,\n\t\t\t\t\texplicitMutabilityPlanAccess,\n\t\t\t\t\tgetAttributeConverterDescriptor(),\n\t\t\t\t\ttypeParameters,\n\t\t\t\t\tthis::setTypeParameters,\n\t\t\t\t\tthis,\n\t\t\t\t\tgetBuildingContext()\n\t\t\t);\n\t\t}\n\t\telse if ( isVersion() ) {\n\t\t\treturn VersionResolution.from( implicitJavaTypeAccess, timeZoneStorageType, getBuildingContext() );\n\t\t}\n\t\telse {\n\t\t\t// determine JavaType if we can\n\t\t\tfinal BasicJavaType<?> explicitJavaType = getExplicitJavaType();\n\t\t\tfinal JavaType<?> javaType = determineJavaType( explicitJavaType );\n\t\t\tfinal ConverterDescriptor converterDescriptor = getConverterDescriptor( javaType );\n\t\t\treturn converterDescriptor != null\n\t\t\t\t\t? converterResolution( javaType, converterDescriptor )\n\t\t\t\t\t: resolution( explicitJavaType, javaType );\n\t\t}\n\t}\n\n\tprivate BasicJavaType<?> getExplicitJavaType() {\n\t\treturn explicitJavaTypeAccess == null ? null\n\t\t\t\t: explicitJavaTypeAccess.apply( getTypeConfiguration() );\n\t}\n\n\tprivate ConverterDescriptor getConverterDescriptor(JavaType<?> javaType) {\n\t\tfinal ConverterDescriptor converterDescriptor = getAttributeConverterDescriptor();\n\t\tif ( isSoftDelete() ) {\n\t\t\tassert converterDescriptor != null;\n\t\t\tfinal ConverterDescriptor softDeleteConverterDescriptor =\n\t\t\t\t\tgetSoftDeleteConverterDescriptor( converterDescriptor, javaType);\n\t\t\treturn getSoftDeleteStrategy() == SoftDeleteType.ACTIVE\n\t\t\t\t\t? new ReversedConverterDescriptor<>( softDeleteConverterDescriptor )\n\t\t\t\t\t: softDeleteConverterDescriptor;\n\t\t}\n\t\telse {\n\t\t\treturn converterDescriptor;\n\t\t}\n\t}\n\n\tprivate ConverterDescriptor getSoftDeleteConverterDescriptor(\n\t\t\tConverterDescriptor attributeConverterDescriptor, JavaType<?> javaType) {\n\t\tfinal boolean conversionWasUnspecified =\n\t\t\t\tSoftDelete.UnspecifiedConversion.class.equals( attributeConverterDescriptor.getAttributeConverterClass() );\n\t\tif ( conversionWasUnspecified ) {\n\t\t\tfinal JdbcType jdbcType = BooleanJdbcType.INSTANCE.resolveIndicatedType( this, javaType);\n\t\t\tif ( jdbcType.isNumber() ) {\n\t\t\t\treturn new InstanceBasedConverterDescriptor(\n\t\t\t\t\t\tNumericBooleanConverter.INSTANCE,\n\t\t\t\t\t\tgetBuildingContext().getBootstrapContext().getClassmateContext()\n\t\t\t\t);\n\t\t\t}\n\t\t\telse if ( jdbcType.isString() ) {\n\t\t\t\t// here we pick 'T' / 'F' storage, though 'Y' / 'N' is equally valid - its 50/50\n\t\t\t\treturn new InstanceBasedConverterDescriptor(\n\t\t\t\t\t\tTrueFalseConverter.INSTANCE,\n\t\t\t\t\t\tgetBuildingContext().getBootstrapContext().getClassmateContext()\n\t\t\t\t);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// should indicate BIT or BOOLEAN == no conversion needed\n\t\t\t\t//\t\t- we still create the converter to properly set up JDBC type, etc\n\t\t\t\treturn new InstanceBasedConverterDescriptor(\n\t\t\t\t\t\tPassThruSoftDeleteConverter.INSTANCE,\n\t\t\t\t\t\tgetBuildingContext().getBootstrapContext().getClassmateContext()\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\treturn attributeConverterDescriptor;\n\t\t}\n\t}\n\n\tprivate static class ReversedConverterDescriptor<R> implements ConverterDescriptor {\n\t\tprivate final ConverterDescriptor underlyingDescriptor;\n\n\t\tpublic ReversedConverterDescriptor(ConverterDescriptor underlyingDescriptor) {\n\t\t\tthis.underlyingDescriptor = underlyingDescriptor;\n\t\t}\n\n\t\t@Override\n\t\tpublic Class<? extends AttributeConverter<Boolean,R>> getAttributeConverterClass() {\n\t\t\t//noinspection unchecked\n\t\t\treturn (Class<? extends AttributeConverter<Boolean, R>>) getClass();\n\t\t}\n\n\t\t@Override\n\t\tpublic ResolvedType getDomainValueResolvedType() {\n\t\t\treturn underlyingDescriptor.getDomainValueResolvedType();\n\t\t}\n\n\t\t@Override\n\t\tpublic ResolvedType getRelationalValueResolvedType() {\n\t\t\treturn underlyingDescriptor.getRelationalValueResolvedType();\n\t\t}\n\n\t\t@Override\n\t\tpublic AutoApplicableConverterDescriptor getAutoApplyDescriptor() {\n\t\t\treturn AutoApplicableConverterDescriptorBypassedImpl.INSTANCE;\n\t\t}\n\n\t\t@Override\n\t\tpublic JpaAttributeConverter<Boolean,R> createJpaAttributeConverter(JpaAttributeConverterCreationContext context) {\n\t\t\t//noinspection unchecked\n\t\t\treturn new ReversedJpaAttributeConverter<>(\n\t\t\t\t\t(JpaAttributeConverter<Boolean, R>) underlyingDescriptor.createJpaAttributeConverter( context ),\n\t\t\t\t\tcontext.getJavaTypeRegistry().getDescriptor( ReversedJpaAttributeConverter.class )\n\t\t\t);\n\t\t}\n\t}\n\n\tprivate static class ReversedJpaAttributeConverter<R, B extends AttributeConverter<Boolean, R>>\n\t\t\timplements JpaAttributeConverter<Boolean,R>, AttributeConverter<Boolean,R>, ManagedBean<B> {\n\t\tprivate final JpaAttributeConverter<Boolean,R> underlyingJpaConverter;\n\t\tprivate final JavaType<ReversedJpaAttributeConverter<R,B>> converterJavaType;\n\n\t\tpublic ReversedJpaAttributeConverter(\n\t\t\t\tJpaAttributeConverter<Boolean, R> underlyingJpaConverter,\n\t\t\t\tJavaType<ReversedJpaAttributeConverter<R,B>> converterJavaType) {\n\t\t\tthis.underlyingJpaConverter = underlyingJpaConverter;\n\t\t\tthis.converterJavaType = converterJavaType;\n\t\t}\n\n\t\t@Override\n\t\tpublic Boolean toDomainValue(R relationalValue) {\n\t\t\treturn !underlyingJpaConverter.toDomainValue( relationalValue );\n\t\t}\n\n\t\t@Override\n\t\tpublic R toRelationalValue(Boolean domainValue) {\n\t\t\treturn underlyingJpaConverter.toRelationalValue( domainValue != null ? !domainValue : null );\n\t\t}\n\n\t\t@Override\n\t\tpublic Boolean convertToEntityAttribute(R relationalValue) {\n\t\t\treturn toDomainValue( relationalValue );\n\t\t}\n\n\t\t@Override\n\t\tpublic R convertToDatabaseColumn(Boolean domainValue) {\n\t\t\treturn toRelationalValue( domainValue );\n\t\t}\n\n\t\t@Override\n\t\tpublic JavaType<Boolean> getDomainJavaType() {\n\t\t\treturn underlyingJpaConverter.getDomainJavaType();\n\t\t}\n\n\t\t@Override\n\t\tpublic JavaType<R> getRelationalJavaType() {\n\t\t\treturn underlyingJpaConverter.getRelationalJavaType();\n\t\t}\n\n\t\t@Override\n\t\tpublic JavaType<? extends AttributeConverter<Boolean, R>> getConverterJavaType() {\n\t\t\treturn converterJavaType;\n\t\t}\n\n\t\t@Override\n\t\tpublic ManagedBean<? extends AttributeConverter<Boolean, R>> getConverterBean() {\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\tpublic Class<B> getBeanClass() {\n\t\t\t//noinspection unchecked\n\t\t\treturn (Class<B>) getClass();\n\t\t}\n\n\t\t@Override\n\t\tpublic B getBeanInstance() {\n\t\t\t//noinspection unchecked\n\t\t\treturn (B) this;\n\t\t}\n\t}\n\n\tprivate static class PassThruSoftDeleteConverter implements AttributeConverter<Boolean,Boolean> {\n\t\tprivate static final PassThruSoftDeleteConverter INSTANCE = new PassThruSoftDeleteConverter();\n\n\t\t@Override\n\t\tpublic Boolean convertToDatabaseColumn(Boolean domainValue) {\n\t\t\treturn domainValue;\n\t\t}\n\n\t\t@Override\n\t\tpublic Boolean convertToEntityAttribute(Boolean relationalValue) {\n\t\t\treturn relationalValue;\n\t\t}\n\t}\n\n\tprivate Resolution<?> resolution(BasicJavaType explicitJavaType, JavaType<?> javaType) {\n\t\tfinal JavaType<?> basicJavaType;\n\t\tfinal JdbcType jdbcType;\n\t\tif ( explicitJdbcTypeAccess != null ) {\n\t\t\tfinal TypeConfiguration typeConfiguration = getTypeConfiguration();\n\t\t\tjdbcType = explicitJdbcTypeAccess.apply( typeConfiguration );\n\t\t\tbasicJavaType = javaType == null && jdbcType != null\n\t\t\t\t\t? jdbcType.getJdbcRecommendedJavaTypeMapping(null, null, typeConfiguration)\n\t\t\t\t\t: javaType;\n\t\t}\n\t\telse {\n\t\t\tjdbcType = null;\n\t\t\tbasicJavaType = javaType;\n\t\t}\n\t\tif ( basicJavaType == null ) {\n\t\t\tthrow new MappingException( \"Unable to determine JavaType to use : \" + this );\n\t\t}\n\n\t\tif ( basicJavaType instanceof BasicJavaType<?>\n\t\t\t\t&& ( !basicJavaType.getJavaTypeClass().isEnum() || enumerationStyle == null ) ) {\n\t\t\tfinal TypeDefinition autoAppliedTypeDef =\n\t\t\t\t\tgetBuildingContext().getTypeDefinitionRegistry()\n\t\t\t\t\t\t\t.resolveAutoApplied( (BasicJavaType<?>) basicJavaType );\n\t\t\tif ( autoAppliedTypeDef != null ) {\n\t\t\t\tlog.debug(\"BasicValue resolution matched auto-applied type-definition\");\n\t\t\t\treturn autoAppliedTypeDef.resolve( getTypeParameters(), null, getBuildingContext(), this );\n\t\t\t}\n\t\t}\n\n\t\treturn InferredBasicValueResolver.from(\n\t\t\t\texplicitJavaType,\n\t\t\t\tjdbcType,\n\t\t\t\tresolvedJavaType,\n\t\t\t\tthis::determineReflectedJavaType,\n\t\t\t\texplicitMutabilityPlanAccess,\n\t\t\t\tthis,\n\t\t\t\tgetTable(),\n\t\t\t\tgetColumn(),\n\t\t\t\townerName,\n\t\t\t\tpropertyName,\n\t\t\t\tgetBuildingContext()\n\t\t);\n\t}\n\n\t@Override\n\tpublic ManagedBeanRegistry getManagedBeanRegistry() {\n\t\treturn getServiceRegistry().requireService( ManagedBeanRegistry.class );\n\t}\n\n\tprivate Resolution<?> converterResolution(JavaType<?> javaType, ConverterDescriptor attributeConverterDescriptor) {\n\t\tfinal NamedConverterResolution<?> converterResolution = NamedConverterResolution.from(\n\t\t\t\tattributeConverterDescriptor,\n\t\t\t\texplicitJavaTypeAccess,\n\t\t\t\texplicitJdbcTypeAccess,\n\t\t\t\texplicitMutabilityPlanAccess,\n\t\t\t\tresolvedJavaType,\n\t\t\t\tthis,\n\t\t\t\tthis,\n\t\t\t\tgetBuildingContext()\n\t\t);\n\n\t\tif ( javaType instanceof BasicPluralJavaType<?> containerJtd\n\t\t\t\t&& !attributeConverterDescriptor.getDomainValueResolvedType().getErasedType()\n\t\t\t\t\t\t.isAssignableFrom( javaType.getJavaTypeClass() ) ) {\n\t\t\t// In this case, the converter applies to the element of a BasicPluralJavaType\n\t\t\tfinal BasicType registeredElementType = converterResolution.getLegacyResolvedBasicType();\n\t\t\tfinal Selectable column = getColumn();\n\t\t\tfinal BasicType<?> registeredType = registeredElementType == null ? null\n\t\t\t\t\t: containerJtd.resolveType(\n\t\t\t\t\t\t\tgetTypeConfiguration(),\n\t\t\t\t\t\t\tgetDialect(),\n\t\t\t\t\t\t\tregisteredElementType,\n\t\t\t\t\t\t\tcolumn instanceof ColumnTypeInformation ? (ColumnTypeInformation) column : null,\n\t\t\t\t\t\t\tthis\n\t\t\t);\n\t\t\tif ( registeredType != null ) {\n\t\t\t\tgetTypeConfiguration().getBasicTypeRegistry().register( registeredType );\n\t\t\t\treturn new InferredBasicValueResolution(\n\t\t\t\t\t\tregisteredType,\n\t\t\t\t\t\tregisteredType.getJavaTypeDescriptor(),\n\t\t\t\t\t\tregisteredType.getJavaTypeDescriptor(),\n\t\t\t\t\t\tregisteredType.getJdbcType(),\n\t\t\t\t\t\tregisteredType,\n\t\t\t\t\t\tnull\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\treturn converterResolution;\n\t}\n\n\tprivate JavaType<?> determineJavaType(JavaType<?> explicitJavaType) {\n\t\tJavaType<?> javaType = explicitJavaType;\n//\n//\t\tif ( javaType == null ) {\n//\t\t\tif ( implicitJavaTypeAccess != null ) {\n//\t\t\t\tfinal java.lang.reflect.Type implicitJtd = implicitJavaTypeAccess.apply( getTypeConfiguration() );\n//\t\t\t\tif ( implicitJtd != null ) {\n//\t\t\t\t\tjavaType = getTypeConfiguration().getJavaTypeRegistry().getDescriptor( implicitJtd );\n//\t\t\t\t}\n//\t\t\t}\n//\t\t}\n\n\t\tif ( javaType == null ) {\n\t\t\tfinal JavaType<?> reflectedJtd = determineReflectedJavaType();\n\t\t\tif ( reflectedJtd != null ) {\n\t\t\t\tjavaType = reflectedJtd;\n\t\t\t}\n\t\t}\n\n\t\treturn javaType;\n\t}\n\n\tprivate JavaType<?> determineReflectedJavaType() {\n\t\tfinal TypeConfiguration typeConfiguration = getTypeConfiguration();\n\t\tfinal java.lang.reflect.Type impliedJavaType = impliedJavaType( typeConfiguration );\n\t\tif ( impliedJavaType == null ) {\n\t\t\treturn null;\n\t\t}\n\t\telse {\n\t\t\tresolvedJavaType = impliedJavaType;\n\t\t\treturn javaType( typeConfiguration, impliedJavaType );\n\t\t}\n\t}\n\n\tprivate java.lang.reflect.Type impliedJavaType(TypeConfiguration typeConfiguration) {\n\t\tif ( resolvedJavaType != null ) {\n\t\t\treturn resolvedJavaType;\n\t\t}\n\t\telse if ( implicitJavaTypeAccess != null ) {\n\t\t\treturn implicitJavaTypeAccess.apply(typeConfiguration);\n\t\t}\n\t\telse if ( ownerName != null && propertyName != null ) {\n\t\t\treturn reflectedPropertyType( ownerName, propertyName,\n\t\t\t\t\tgetServiceRegistry().requireService( ClassLoaderService.class ) );\n\t\t}\n\t\telse {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tprivate JavaType<Object> javaType(TypeConfiguration typeConfiguration, java.lang.reflect.Type impliedJavaType) {\n\t\tfinal JavaType<Object> javaType = typeConfiguration.getJavaTypeRegistry().findDescriptor( impliedJavaType );\n\t\treturn javaType == null ? specialJavaType( typeConfiguration, impliedJavaType ) : javaType;\n\t}\n\n\tprivate JavaType<Object> specialJavaType(\n\t\t\tTypeConfiguration typeConfiguration,\n\t\t\tjava.lang.reflect.Type impliedJavaType) {\n\t\tfinal JavaTypeRegistry javaTypeRegistry = typeConfiguration.getJavaTypeRegistry();\n\t\tif ( jdbcTypeCode != null ) {\n\t\t\t// Construct special JavaType instances for JSON/XML types which can report recommended JDBC types\n\t\t\t// and implement toString/fromString as well as copying based on FormatMapper operations\n\t\t\tswitch ( jdbcTypeCode ) {\n\t\t\t\tcase SqlTypes.JSON:\n\t\t\t\t\tfinal JavaType<Object> jsonJavaType =\n\t\t\t\t\t\t\tnew JsonJavaType<>( impliedJavaType,\n\t\t\t\t\t\t\t\t\tmutabilityPlan( typeConfiguration, impliedJavaType ),\n\t\t\t\t\t\t\t\t\ttypeConfiguration );\n\t\t\t\t\tjavaTypeRegistry.addDescriptor( jsonJavaType );\n\t\t\t\t\treturn jsonJavaType;\n\t\t\t\tcase SqlTypes.SQLXML:\n\t\t\t\t\tfinal JavaType<Object> xmlJavaType =\n\t\t\t\t\t\t\tnew XmlJavaType<>( impliedJavaType,\n\t\t\t\t\t\t\t\t\tmutabilityPlan( typeConfiguration, impliedJavaType ),\n\t\t\t\t\t\t\t\t\ttypeConfiguration );\n\t\t\t\t\tjavaTypeRegistry.addDescriptor( xmlJavaType );\n\t\t\t\t\treturn xmlJavaType;\n\t\t\t}\n\t\t}\n\t\treturn javaTypeRegistry.resolveDescriptor( impliedJavaType );\n\t}\n\n\tprivate MutabilityPlan<Object> mutabilityPlan(\n\t\t\tTypeConfiguration typeConfiguration, java.lang.reflect.Type impliedJavaType) {\n\t\tfinal MutabilityPlan<Object> explicitMutabilityPlan = getExplicitMutabilityPlan();\n\t\treturn explicitMutabilityPlan != null\n\t\t\t\t? explicitMutabilityPlan\n\t\t\t\t: RegistryHelper.INSTANCE.determineMutabilityPlan( impliedJavaType, typeConfiguration );\n\t}\n\n\tprivate MutabilityPlan<Object> getExplicitMutabilityPlan() {\n\t\treturn explicitMutabilityPlanAccess == null ? null\n\t\t\t\t: explicitMutabilityPlanAccess.apply( getTypeConfiguration()  );\n\t}\n\n\tprivate static Resolution<?> interpretExplicitlyNamedType(\n\t\t\tString name,\n\t\t\tFunction<TypeConfiguration, BasicJavaType> explicitJtdAccess,\n\t\t\tFunction<TypeConfiguration, JdbcType> explicitStdAccess,\n\t\t\tFunction<TypeConfiguration, MutabilityPlan> explicitMutabilityPlanAccess,\n\t\t\tConverterDescriptor converterDescriptor,\n\t\t\tMap<Object,Object> localTypeParams,\n\t\t\tConsumer<Properties> combinedParameterConsumer,\n\t\t\tJdbcTypeIndicators stdIndicators,\n\t\t\tMetadataBuildingContext context) {\n\n\t\tfinal StandardServiceRegistry serviceRegistry = context.getBootstrapContext().getServiceRegistry();\n\t\tfinal ManagedBeanRegistry managedBeanRegistry = serviceRegistry.requireService( ManagedBeanRegistry.class );\n\t\tfinal TypeConfiguration typeConfiguration = context.getBootstrapContext().getTypeConfiguration();\n\n\t\tfinal JpaAttributeConverterCreationContext converterCreationContext = new JpaAttributeConverterCreationContext() {\n\t\t\t@Override\n\t\t\tpublic ManagedBeanRegistry getManagedBeanRegistry() {\n\t\t\t\treturn managedBeanRegistry;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic TypeConfiguration getTypeConfiguration() {\n\t\t\t\treturn typeConfiguration;\n\t\t\t}\n\t\t};\n\n\t\t// Name could refer to:\n\t\t//\t\t1) a named converter - HBM support for JPA's AttributeConverter via its `type=\"...\"` XML attribute\n\t\t//\t\t2) a \"named composed\" mapping - like (1), this is mainly to support envers since it tells\n\t\t//\t\t\tHibernate the mappings via DOM.  See `org.hibernate.type.internal.BasicTypeImpl`\n\t\t//\t\t3) basic type \"resolution key\"\n\t\t//\t\t4) UserType or BasicType class name - directly, or through a TypeDefinition\n\n\t\tif ( name.startsWith( ConverterDescriptor.TYPE_NAME_PREFIX  ) ) {\n\t\t\treturn NamedConverterResolution.from(\n\t\t\t\t\tname,\n\t\t\t\t\texplicitJtdAccess,\n\t\t\t\t\texplicitStdAccess,\n\t\t\t\t\texplicitMutabilityPlanAccess,\n\t\t\t\t\tstdIndicators,\n\t\t\t\t\tconverterCreationContext,\n\t\t\t\t\tcontext\n\t\t\t);\n\t\t}\n\n//\t\tif ( name.startsWith( EnumeratedValueResolution.PREFIX ) ) {\n//\t\t\treturn EnumeratedValueResolution.fromName( name, stdIndicators, context );\n//\t\t}\n\n\t\tif ( name.startsWith( BasicTypeImpl.EXTERNALIZED_PREFIX ) ) {\n\t\t\tfinal BasicType<Object> basicType = context.getBootstrapContext().resolveAdHocBasicType( name );\n\t\t\treturn new NamedBasicTypeResolution<>(\n\t\t\t\t\tbasicType.getJavaTypeDescriptor(),\n\t\t\t\t\tbasicType,\n\t\t\t\t\tnull,\n\t\t\t\t\texplicitMutabilityPlanAccess,\n\t\t\t\t\tcontext\n\t\t\t);\n\t\t}\n\n\t\t// see if it is a named basic type\n\t\tfinal BasicType<?> basicTypeByName = typeConfiguration.getBasicTypeRegistry().getRegisteredType( name );\n\t\tif ( basicTypeByName != null ) {\n\t\t\tfinal BasicValueConverter<?,?> valueConverter;\n\t\t\tfinal JavaType<?> domainJtd;\n\t\t\tif ( converterDescriptor != null ) {\n\t\t\t\tvalueConverter = converterDescriptor.createJpaAttributeConverter( converterCreationContext );\n\t\t\t\tdomainJtd = valueConverter.getDomainJavaType();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tvalueConverter = basicTypeByName.getValueConverter();\n\t\t\t\tdomainJtd = basicTypeByName.getJavaTypeDescriptor();\n\t\t\t}\n\n\t\t\treturn new NamedBasicTypeResolution<>(\n\t\t\t\t\tdomainJtd,\n\t\t\t\t\tbasicTypeByName,\n\t\t\t\t\tvalueConverter,\n\t\t\t\t\texplicitMutabilityPlanAccess,\n\t\t\t\t\tcontext\n\t\t\t);\n\t\t}\n\n\t\t// see if it is a named TypeDefinition\n\t\tfinal TypeDefinition typeDefinition = context.getTypeDefinitionRegistry().resolve( name );\n\t\tif ( typeDefinition != null ) {\n\t\t\tfinal Resolution<?> resolution = typeDefinition.resolve(\n\t\t\t\t\tlocalTypeParams,\n\t\t\t\t\texplicitMutabilityPlanAccess != null\n\t\t\t\t\t\t\t? explicitMutabilityPlanAccess.apply( typeConfiguration )\n\t\t\t\t\t\t\t: null,\n\t\t\t\t\tcontext,\n\t\t\t\t\tstdIndicators\n\t\t\t);\n\t\t\tcombinedParameterConsumer.accept( resolution.getCombinedTypeParameters() );\n\t\t\treturn resolution;\n\t\t}\n\n\n\t\t// see if the name is a UserType or BasicType implementor class name\n\t\tfinal ClassLoaderService cls = serviceRegistry.requireService( ClassLoaderService.class );\n\t\ttry {\n\t\t\tfinal Class<?> typeNamedClass = cls.classForName( name );\n\n\t\t\t// if there are no local config params, register an implicit TypeDefinition for this custom type .\n\t\t\t//  later uses may find it and re-use its cacheable reference...\n\t\t\tif ( CollectionHelper.isEmpty( localTypeParams ) ) {\n\t\t\t\tfinal TypeDefinition implicitDefinition = new TypeDefinition(\n\t\t\t\t\t\tname,\n\t\t\t\t\t\ttypeNamedClass,\n\t\t\t\t\t\tnull,\n\t\t\t\t\t\tnull\n\t\t\t\t);\n\t\t\t\tcontext.getTypeDefinitionRegistry().register( implicitDefinition );\n\t\t\t\treturn implicitDefinition.resolve(\n\t\t\t\t\t\tlocalTypeParams,\n\t\t\t\t\t\texplicitMutabilityPlanAccess != null\n\t\t\t\t\t\t\t\t? explicitMutabilityPlanAccess.apply( typeConfiguration )\n\t\t\t\t\t\t\t\t: null,\n\t\t\t\t\t\tcontext,\n\t\t\t\t\t\tstdIndicators\n\t\t\t\t);\n\t\t\t}\n\n\t\t\treturn TypeDefinition.createLocalResolution( name, typeNamedClass, localTypeParams, context );\n\t\t}\n\t\tcatch (ClassLoadingException e) {\n\t\t\t// allow the exception below to trigger\n\t\t\tlog.debugf( \"Could not resolve type-name [%s] as Java type : %s\", name, e );\n\t\t}\n\n\t\tthrow new MappingException( \"Could not resolve named type : \" + name );\n\t}\n\n\n\t// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\t// SqlTypeDescriptorIndicators\n\n\t@Override\n\tpublic EnumType getEnumeratedType() {\n\t\treturn getEnumerationStyle();\n\t}\n\n\n\t@Override\n\tpublic int getPreferredSqlTypeCodeForBoolean() {\n\t\treturn resolveJdbcTypeCode( getBuildingContext().getPreferredSqlTypeCodeForBoolean() );\n\t}\n\n\t@Override\n\tpublic int getPreferredSqlTypeCodeForDuration() {\n\t\treturn resolveJdbcTypeCode( getBuildingContext().getPreferredSqlTypeCodeForDuration() );\n\t}\n\n\t@Override\n\tpublic int getPreferredSqlTypeCodeForUuid() {\n\t\treturn resolveJdbcTypeCode( getBuildingContext().getPreferredSqlTypeCodeForUuid() );\n\t}\n\n\t@Override\n\tpublic int getPreferredSqlTypeCodeForInstant() {\n\t\treturn resolveJdbcTypeCode( getBuildingContext().getPreferredSqlTypeCodeForInstant() );\n\t}\n\n\t@Override\n\tpublic int getPreferredSqlTypeCodeForArray() {\n\t\treturn resolveJdbcTypeCode( getBuildingContext().getPreferredSqlTypeCodeForArray() );\n\t}\n\n\t@Override\n\tpublic int resolveJdbcTypeCode(int jdbcTypeCode) {\n\t\treturn aggregateColumn == null\n\t\t\t\t? jdbcTypeCode\n\t\t\t\t: getDialect().getAggregateSupport()\n\t\t\t\t.aggregateComponentSqlTypeCode( aggregateColumn.getSqlTypeCode( getMetadata() ), jdbcTypeCode );\n\t}\n\n\t@Override\n\tpublic TimeZoneStorageStrategy getDefaultTimeZoneStorageStrategy() {\n\t\treturn timeZoneStorageStrategy( timeZoneStorageType, getBuildingContext() );\n\t}\n\n\t@Internal\n\tpublic static TimeZoneStorageStrategy timeZoneStorageStrategy(\n\t\t\tTimeZoneStorageType timeZoneStorageType,\n\t\t\tMetadataBuildingContext buildingContext) {\n\t\tif ( timeZoneStorageType != null ) {\n\t\t\tswitch ( timeZoneStorageType ) {\n\t\t\t\tcase COLUMN:\n\t\t\t\t\treturn TimeZoneStorageStrategy.COLUMN;\n\t\t\t\tcase NATIVE:\n\t\t\t\t\treturn TimeZoneStorageStrategy.NATIVE;\n\t\t\t\tcase NORMALIZE:\n\t\t\t\t\treturn TimeZoneStorageStrategy.NORMALIZE;\n\t\t\t\tcase NORMALIZE_UTC:\n\t\t\t\t\treturn TimeZoneStorageStrategy.NORMALIZE_UTC;\n\t\t\t}\n\t\t}\n\t\treturn buildingContext.getBuildingOptions().getDefaultTimeZoneStorage();\n\t}\n\n\tpublic void setExplicitTypeParams(Map<String,String> explicitLocalTypeParams) {\n\t\tthis.explicitLocalTypeParams = explicitLocalTypeParams;\n\t}\n\n\tpublic void setExplicitTypeName(String typeName) {\n\t\tthis.explicitTypeName = typeName;\n\t}\n\n\tpublic void setTypeName(String typeName) {\n\t\tif ( StringHelper.isNotEmpty( typeName ) ) {\n\t\t\tif ( typeName.startsWith( ConverterDescriptor.TYPE_NAME_PREFIX ) ) {\n\t\t\t\tfinal String converterClassName = typeName.substring( ConverterDescriptor.TYPE_NAME_PREFIX.length() );\n\t\t\t\tfinal ClassLoaderService cls = getServiceRegistry().requireService( ClassLoaderService.class );\n\t\t\t\ttry {\n\t\t\t\t\tfinal Class<AttributeConverter<?,?>> converterClass = cls.classForName( converterClassName );\n\t\t\t\t\tsetAttributeConverterDescriptor( new ClassBasedConverterDescriptor(\n\t\t\t\t\t\t\tconverterClass,\n\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\tgetBuildingContext().getBootstrapContext().getClassmateContext()\n\t\t\t\t\t) );\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tcatch (Exception e) {\n\t\t\t\t\tlog.logBadHbmAttributeConverterType( typeName, e.getMessage() );\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsetExplicitTypeName( typeName );\n\t\t\t}\n\t\t}\n\n\t\tsuper.setTypeName( typeName );\n\t}\n\n\tprivate static int COUNTER;\n\n\tpublic void setExplicitCustomType(Class<? extends UserType<?>> explicitCustomType) {\n\t\tif ( explicitCustomType != null ) {\n\t\t\tif ( resolution != null ) {\n\t\t\t\tthrow new UnsupportedOperationException( \"Unsupported attempt to set an explicit-custom-type when value is already resolved\" );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tresolution = new UserTypeResolution<>(\n\t\t\t\t\t\tnew CustomType<>(\n\t\t\t\t\t\t\t\tgetConfiguredUserTypeBean( explicitCustomType, getCustomTypeProperties() ),\n\t\t\t\t\t\t\t\tgetTypeConfiguration()\n\t\t\t\t\t\t),\n\t\t\t\t\t\tnull,\n\t\t\t\t\t\tgetCustomTypeProperties()\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate Properties getCustomTypeProperties() {\n\t\tfinal Properties properties = new Properties();\n\t\tif ( isNotEmpty( getTypeParameters() ) ) {\n\t\t\tproperties.putAll( getTypeParameters() );\n\t\t}\n\t\tif ( isNotEmpty( explicitLocalTypeParams ) ) {\n\t\t\tproperties.putAll( explicitLocalTypeParams );\n\t\t}\n\t\treturn properties;\n\t}\n\n\tprivate UserType<?> getConfiguredUserTypeBean(Class<? extends UserType<?>> explicitCustomType, Properties properties) {\n\t\tfinal UserType<?> typeInstance =\n\t\t\t\t!getBuildingContext().getBuildingOptions().isAllowExtensionsInCdi()\n\t\t\t\t\t\t? FallbackBeanInstanceProducer.INSTANCE.produceBeanInstance( explicitCustomType )\n\t\t\t\t\t\t: getUserTypeBean( explicitCustomType, properties ).getBeanInstance();\n\n\t\tif ( typeInstance instanceof TypeConfigurationAware configurationAware ) {\n\t\t\tconfigurationAware.setTypeConfiguration( getTypeConfiguration() );\n\t\t}\n\n\t\tif ( typeInstance instanceof DynamicParameterizedType ) {\n\t\t\tif ( parseBoolean( properties.getProperty( DynamicParameterizedType.IS_DYNAMIC ) ) ) {\n\t\t\t\tif ( properties.get( DynamicParameterizedType.PARAMETER_TYPE ) == null ) {\n\t\t\t\t\tproperties.put( DynamicParameterizedType.PARAMETER_TYPE, makeParameterImpl() );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tinjectParameters( typeInstance, properties);\n\t\t// envers - grr\n\t\tsetTypeParameters( properties );\n\n\t\treturn typeInstance;\n\t}\n\n\tprivate <T> ManagedBean<T> getUserTypeBean(Class<T> explicitCustomType, Properties properties) {\n\t\tfinal BeanInstanceProducer producer = getBuildingContext().getBootstrapContext().getCustomTypeProducer();\n\t\tfinal ManagedBeanRegistry registry = getServiceRegistry().requireService( ManagedBeanRegistry.class );\n\t\tif ( isNotEmpty( properties ) ) {\n\t\t\tfinal String name = explicitCustomType.getName() + COUNTER++;\n\t\t\treturn registry.getBean( name, explicitCustomType, producer );\n\t\t}\n\t\telse {\n\t\t\treturn registry.getBean( explicitCustomType, producer );\n\t\t}\n\t}\n\n\t@SuppressWarnings(\"deprecation\")\n\tpublic void setTemporalPrecision(TemporalType temporalPrecision) {\n\t\tthis.temporalPrecision = temporalPrecision;\n\t}\n\n\t@Override @SuppressWarnings(\"deprecation\")\n\tpublic TemporalType getTemporalPrecision() {\n\t\treturn temporalPrecision;\n\t}\n\n\t@Override\n\tpublic boolean isPreferJavaTimeJdbcTypesEnabled() {\n\t\treturn getBuildingContext().isPreferJavaTimeJdbcTypesEnabled();\n\t}\n\n\t@Override\n\tpublic boolean isPreferNativeEnumTypesEnabled() {\n\t\treturn getBuildingContext().isPreferNativeEnumTypesEnabled();\n\t}\n\n\t@Override\n\tpublic Object accept(ValueVisitor visitor) {\n\t\treturn visitor.accept(this);\n\t}\n\n\t@Internal\n\tpublic boolean isDisallowedWrapperArray() {\n\t\treturn getBuildingContext().getBuildingOptions().getWrapperArrayHandling() == WrapperArrayHandling.DISALLOW\n\t\t\t&& !isLob()\n\t\t\t&& ( explicitJavaTypeAccess == null || explicitJavaTypeAccess.apply( getTypeConfiguration() ) == null )\n\t\t\t&& isWrapperByteOrCharacterArray();\n\t}\n\n\tprivate boolean isWrapperByteOrCharacterArray() {\n\t\tfinal Class<?> javaTypeClass = getResolution().getDomainJavaType().getJavaTypeClass();\n\t\treturn javaTypeClass == Byte[].class || javaTypeClass == Character[].class;\n\t}\n\n\t@Incubating\n\tpublic void setExplicitJdbcTypeCode(Integer jdbcTypeCode) {\n\t\tthis.jdbcTypeCode = jdbcTypeCode;\n\t}\n\n\t@Override\n\tpublic Integer getExplicitJdbcTypeCode() {\n\t\treturn jdbcTypeCode == null ? getPreferredSqlTypeCodeForArray() : jdbcTypeCode;\n\t}\n\n\t/**\n\t * Resolved form of {@link BasicValue} as part of interpreting the\n\t * boot-time model into the run-time model\n\t */\n\tpublic interface Resolution<J> {\n\t\t/**\n\t\t * The BasicType resolved using the pre-6.0 rules.  This is temporarily\n\t\t * needed because of the split in extracting / binding\n\t\t */\n\t\tBasicType<J> getLegacyResolvedBasicType();\n\n\t\t/**\n\t\t * Get the collection of type-parameters collected both locally as well\n\t\t * as from the applied type-def, if one\n\t\t */\n\t\tdefault Properties getCombinedTypeParameters() {\n\t\t\treturn null;\n\t\t}\n\n\t\tJdbcMapping getJdbcMapping();\n\n\t\t/**\n\t\t * The JavaType for the value as part of the domain model\n\t\t */\n\t\tJavaType<J> getDomainJavaType();\n\n\t\t/**\n\t\t * The JavaType for the relational value as part of\n\t\t * the relational model (its JDBC representation)\n\t\t */\n\t\tJavaType<?> getRelationalJavaType();\n\n\t\t/**\n\t\t * The JavaType for the relational value as part of\n\t\t * the relational model (its JDBC representation)\n\t\t */\n\t\tJdbcType getJdbcType();\n\n\t\t/**\n\t\t * Converter, if any, to convert values between the\n\t\t * domain and relational JavaType representations\n\t\t */\n\t\tBasicValueConverter<J,?> getValueConverter();\n\n\t\t/**\n\t\t * The resolved MutabilityPlan\n\t\t */\n\t\tMutabilityPlan<J> getMutabilityPlan();\n\n\t\tdefault void updateResolution(BasicType<?> type) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\t}\n}\n",
        "diffSourceCodeSet": [
            "private JavaType<Object> javaType(TypeConfiguration typeConfiguration, java.lang.reflect.Type impliedJavaType) {\n\t\tfinal JavaType<Object> javaType = typeConfiguration.getJavaTypeRegistry().findDescriptor( impliedJavaType );\n\t\treturn javaType == null ? specialJavaType( typeConfiguration, impliedJavaType ) : javaType;\n\t}"
        ],
        "invokedMethodSet": [
            "methodSignature: org.hibernate.type.spi.TypeConfiguration#getJavaTypeRegistry\n methodBody: public JavaTypeRegistry getJavaTypeRegistry() {\nreturn javaTypeRegistry;\n}",
            "methodSignature: org.hibernate.type.spi.TypeConfiguration.Scope#getTypeConfiguration\n methodBody: public TypeConfiguration getTypeConfiguration() {\nreturn typeConfiguration;\n}",
            "methodSignature: org.hibernate.type.spi.TypeConfiguration.Scope#getServiceRegistry\n methodBody: private ServiceRegistry getServiceRegistry() {\nif(metadataBuildingContext != null){return metadataBuildingContext.getBootstrapContext().getServiceRegistry();\n}if(sessionFactory != null){return sessionFactory.getServiceRegistry();\n}{return null;\n}}",
            "methodSignature: org.hibernate.type.spi.TypeConfiguration#getServiceRegistry\n methodBody: public ServiceRegistry getServiceRegistry() {\nreturn scope.getServiceRegistry();\n}"
        ],
        "sourceCodeAfterRefactoring": "private JavaType<?> determineReflectedJavaType() {\n\t\tfinal TypeConfiguration typeConfiguration = getTypeConfiguration();\n\t\tfinal java.lang.reflect.Type impliedJavaType = impliedJavaType( typeConfiguration );\n\t\tif ( impliedJavaType == null ) {\n\t\t\treturn null;\n\t\t}\n\t\telse {\n\t\t\tresolvedJavaType = impliedJavaType;\n\t\t\treturn javaType( typeConfiguration, impliedJavaType );\n\t\t}\n\t}\nprivate JavaType<Object> javaType(TypeConfiguration typeConfiguration, java.lang.reflect.Type impliedJavaType) {\n\t\tfinal JavaType<Object> javaType = typeConfiguration.getJavaTypeRegistry().findDescriptor( impliedJavaType );\n\t\treturn javaType == null ? specialJavaType( typeConfiguration, impliedJavaType ) : javaType;\n\t}",
        "diffSourceCode": "-  731: \tprivate JavaType<?> determineReflectedJavaType() {\n-  732: \t\tfinal java.lang.reflect.Type impliedJavaType;\n-  733: \n-  734: \t\tfinal TypeConfiguration typeConfiguration = getTypeConfiguration();\n-  735: \t\tif ( resolvedJavaType != null ) {\n-  736: \t\t\timpliedJavaType = resolvedJavaType;\n-  737: \t\t}\n-  738: \t\telse if ( implicitJavaTypeAccess != null ) {\n-  739: \t\t\timpliedJavaType = implicitJavaTypeAccess.apply( typeConfiguration );\n+  731: //\t\t\t\t}\n+  732: //\t\t\t}\n+  733: //\t\t}\n+  734: \n+  735: \t\tif ( javaType == null ) {\n+  736: \t\t\tfinal JavaType<?> reflectedJtd = determineReflectedJavaType();\n+  737: \t\t\tif ( reflectedJtd != null ) {\n+  738: \t\t\t\tjavaType = reflectedJtd;\n+  739: \t\t\t}\n   740: \t\t}\n-  741: \t\telse if ( ownerName != null && propertyName != null ) {\n-  742: \t\t\timpliedJavaType = ReflectHelper.reflectedPropertyType(\n-  743: \t\t\t\t\townerName,\n-  744: \t\t\t\t\tpropertyName,\n-  745: \t\t\t\t\tgetServiceRegistry().requireService( ClassLoaderService.class )\n-  746: \t\t\t);\n-  747: \t\t}\n-  748: \t\telse {\n+  741: \n+  742: \t\treturn javaType;\n+  743: \t}\n+  744: \n+  745: \tprivate JavaType<?> determineReflectedJavaType() {\n+  746: \t\tfinal TypeConfiguration typeConfiguration = getTypeConfiguration();\n+  747: \t\tfinal java.lang.reflect.Type impliedJavaType = impliedJavaType( typeConfiguration );\n+  748: \t\tif ( impliedJavaType == null ) {\n   749: \t\t\treturn null;\n   750: \t\t}\n-  751: \n-  752: \t\tresolvedJavaType = impliedJavaType;\n-  753: \n-  754: \t\tif ( impliedJavaType == null ) {\n-  755: \t\t\treturn null;\n-  756: \t\t}\n-  757: \n-  758: \t\tfinal JavaTypeRegistry javaTypeRegistry = typeConfiguration.getJavaTypeRegistry();\n-  759: \t\tfinal JavaType<Object> javaType = javaTypeRegistry.findDescriptor( impliedJavaType );\n-  760: \t\tfinal MutabilityPlan<Object> explicitMutabilityPlan = explicitMutabilityPlanAccess != null\n-  761: \t\t\t\t? explicitMutabilityPlanAccess.apply( typeConfiguration )\n-  762: \t\t\t\t: null;\n-  763: \t\tfinal MutabilityPlan<Object> determinedMutabilityPlan = explicitMutabilityPlan != null\n-  764: \t\t\t\t? explicitMutabilityPlan\n-  765: \t\t\t\t: RegistryHelper.INSTANCE.determineMutabilityPlan( impliedJavaType, typeConfiguration );\n-  766: \t\tif ( javaType == null ) {\n-  767: \t\t\tif ( jdbcTypeCode != null ) {\n-  768: \t\t\t\t// Construct special JavaType instances for JSON/XML types which can report recommended JDBC types\n-  769: \t\t\t\t// and implement toString/fromString as well as copying based on FormatMapper operations\n-  770: \t\t\t\tswitch ( jdbcTypeCode ) {\n-  771: \t\t\t\t\tcase SqlTypes.JSON:\n-  772: \t\t\t\t\t\tfinal JavaType<Object> jsonJavaType = new JsonJavaType<>(\n-  773: \t\t\t\t\t\t\t\timpliedJavaType,\n-  774: \t\t\t\t\t\t\t\tdeterminedMutabilityPlan,\n-  775: \t\t\t\t\t\t\t\ttypeConfiguration\n-  776: \t\t\t\t\t\t);\n-  777: \t\t\t\t\t\tjavaTypeRegistry.addDescriptor( jsonJavaType );\n-  778: \t\t\t\t\t\treturn jsonJavaType;\n-  779: \t\t\t\t\tcase SqlTypes.SQLXML:\n-  780: \t\t\t\t\t\tfinal JavaType<Object> xmlJavaType = new XmlJavaType<>(\n-  781: \t\t\t\t\t\t\t\timpliedJavaType,\n-  782: \t\t\t\t\t\t\t\tdeterminedMutabilityPlan,\n-  783: \t\t\t\t\t\t\t\ttypeConfiguration\n-  784: \t\t\t\t\t\t);\n-  785: \t\t\t\t\t\tjavaTypeRegistry.addDescriptor( xmlJavaType );\n-  786: \t\t\t\t\t\treturn xmlJavaType;\n-  787: \t\t\t\t}\n-  788: \t\t\t}\n-  789: \t\t\treturn javaTypeRegistry.resolveDescriptor( impliedJavaType );\n-  790: \t\t}\n-  791: \t\treturn javaType;\n-  792: \t}\n+  751: \t\telse {\n+  752: \t\t\tresolvedJavaType = impliedJavaType;\n+  753: \t\t\treturn javaType( typeConfiguration, impliedJavaType );\n+  754: \t\t}\n+  755: \t}\n+  756: \n+  757: \tprivate java.lang.reflect.Type impliedJavaType(TypeConfiguration typeConfiguration) {\n+  758: \t\tif ( resolvedJavaType != null ) {\n+  759: \t\t\treturn resolvedJavaType;\n+  760: \t\t}\n+  761: \t\telse if ( implicitJavaTypeAccess != null ) {\n+  762: \t\t\treturn implicitJavaTypeAccess.apply(typeConfiguration);\n+  763: \t\t}\n+  764: \t\telse if ( ownerName != null && propertyName != null ) {\n+  765: \t\t\treturn reflectedPropertyType( ownerName, propertyName,\n+  766: \t\t\t\t\tgetServiceRegistry().requireService( ClassLoaderService.class ) );\n+  767: \t\t}\n+  768: \t\telse {\n+  769: \t\t\treturn null;\n+  770: \t\t}\n+  771: \t}\n+  772: \n+  773: \tprivate JavaType<Object> javaType(TypeConfiguration typeConfiguration, java.lang.reflect.Type impliedJavaType) {\n+  774: \t\tfinal JavaType<Object> javaType = typeConfiguration.getJavaTypeRegistry().findDescriptor( impliedJavaType );\n+  775: \t\treturn javaType == null ? specialJavaType( typeConfiguration, impliedJavaType ) : javaType;\n+  776: \t}\n+  777: \n+  778: \tprivate JavaType<Object> specialJavaType(\n+  779: \t\t\tTypeConfiguration typeConfiguration,\n+  780: \t\t\tjava.lang.reflect.Type impliedJavaType) {\n+  781: \t\tfinal JavaTypeRegistry javaTypeRegistry = typeConfiguration.getJavaTypeRegistry();\n+  782: \t\tif ( jdbcTypeCode != null ) {\n+  783: \t\t\t// Construct special JavaType instances for JSON/XML types which can report recommended JDBC types\n+  784: \t\t\t// and implement toString/fromString as well as copying based on FormatMapper operations\n+  785: \t\t\tswitch ( jdbcTypeCode ) {\n+  786: \t\t\t\tcase SqlTypes.JSON:\n+  787: \t\t\t\t\tfinal JavaType<Object> jsonJavaType =\n+  788: \t\t\t\t\t\t\tnew JsonJavaType<>( impliedJavaType,\n+  789: \t\t\t\t\t\t\t\t\tmutabilityPlan( typeConfiguration, impliedJavaType ),\n+  790: \t\t\t\t\t\t\t\t\ttypeConfiguration );\n+  791: \t\t\t\t\tjavaTypeRegistry.addDescriptor( jsonJavaType );\n+  792: \t\t\t\t\treturn jsonJavaType;\n",
        "uniqueId": "6c6c92e88d4535be020b4acb3d81f96df39a65d8_731_792_773_776_745_755",
        "moveFileExist": true,
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 21,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 0,
                "covered": 19
            },
            "BRANCH": {
                "missed": 0,
                "covered": 2
            },
            "LINE": {
                "missed": 0,
                "covered": 6
            },
            "COMPLEXITY": {
                "missed": 0,
                "covered": 2
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        }
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprivate createPersistenceUnitInfo(jpa Jpa) : PersistenceUnitInfoImpl extracted from public findEntityManagerFactoryScope(testScope Object, emfAnnWrapper Optional<Jpa>, context ExtensionContext) : EntityManagerFactoryScope in class org.hibernate.testing.orm.junit.EntityManagerFactoryExtension",
        "diffLocations": [
            {
                "filePath": "hibernate-testing/src/main/java/org/hibernate/testing/orm/junit/EntityManagerFactoryExtension.java",
                "startLine": 66,
                "endLine": 203,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-testing/src/main/java/org/hibernate/testing/orm/junit/EntityManagerFactoryExtension.java",
                "startLine": 61,
                "endLine": 91,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-testing/src/main/java/org/hibernate/testing/orm/junit/EntityManagerFactoryExtension.java",
                "startLine": 113,
                "endLine": 121,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "public static EntityManagerFactoryScope findEntityManagerFactoryScope(\n\t\t\tObject testScope,\n\t\t\tOptional<Jpa> emfAnnWrapper,\n\t\t\tExtensionContext context) {\n\n\t\tif ( emfAnnWrapper.isEmpty() ) {\n\t\t\t// No annotation on the test class, should be on the test methods\n\t\t\treturn null;\n\t\t}\n\n\t\tfinal ExtensionContext.Store store = locateExtensionStore( testScope, context );\n\t\tfinal EntityManagerFactoryScope existing = (EntityManagerFactoryScope) store.get( EMF_KEY );\n\t\tif ( existing != null ) {\n\t\t\treturn existing;\n\t\t}\n\n\t\tif ( !context.getElement().isPresent() ) {\n\t\t\tthrow new RuntimeException( \"Unable to determine how to handle given ExtensionContext : \" + context.getDisplayName() );\n\t\t}\n\t\tfinal Jpa emfAnn = emfAnnWrapper.get();\n\n\t\tfinal PersistenceUnitInfoImpl pui = new PersistenceUnitInfoImpl( emfAnn.persistenceUnitName() );\n\t\t( (Map<Object, Object>) Environment.getProperties() ).forEach(\n\t\t\t\t(key, value) ->\n\t\t\t\t\t\tpui.getProperties().put( key, value )\n\t\t);\n\n\t\tpui.setTransactionType( emfAnn.transactionType() );\n\t\tpui.setCacheMode( emfAnn.sharedCacheMode() );\n\t\tpui.setValidationMode( emfAnn.validationMode() );\n\t\tpui.setExcludeUnlistedClasses( emfAnn.excludeUnlistedClasses() );\n\n\t\t// JpaCompliance\n\t\tpui.getProperties().put( AvailableSettings.JPA_COMPLIANCE, emfAnn.jpaComplianceEnabled() );\n\t\tpui.getProperties().put( AvailableSettings.JPA_QUERY_COMPLIANCE, emfAnn.queryComplianceEnabled() );\n\t\tpui.getProperties().put( AvailableSettings.JPA_TRANSACTION_COMPLIANCE, emfAnn.transactionComplianceEnabled() );\n\t\tpui.getProperties().put( AvailableSettings.JPA_CLOSED_COMPLIANCE, emfAnn.closedComplianceEnabled() );\n\t\tpui.getProperties().put( AvailableSettings.JPA_PROXY_COMPLIANCE, emfAnn.proxyComplianceEnabled() );\n\t\tpui.getProperties().put( AvailableSettings.JPA_CACHING_COMPLIANCE, emfAnn.cacheComplianceEnabled() );\n\t\tpui.getProperties().put( AvailableSettings.JPA_ID_GENERATOR_GLOBAL_SCOPE_COMPLIANCE, emfAnn.generatorScopeComplianceEnabled() );\n\t\tpui.getProperties().put( AvailableSettings.JPA_ORDER_BY_MAPPING_COMPLIANCE, emfAnn.orderByMappingComplianceEnabled() );\n\t\tpui.getProperties().put( AvailableSettings.JPA_LOAD_BY_ID_COMPLIANCE, emfAnn.loadByIdComplianceEnabled() );\n\n\t\tfinal Setting[] properties = emfAnn.properties();\n\t\tfor ( int i = 0; i < properties.length; i++ ) {\n\t\t\tfinal Setting property = properties[i];\n\t\t\tpui.getProperties().setProperty( property.name(), property.value() );\n\t\t}\n\n\t\tpui.getProperties().setProperty(\n\t\t\t\tAvailableSettings.GENERATE_STATISTICS,\n\t\t\t\tBoolean.toString( emfAnn.generateStatistics() )\n\t\t);\n\n\t\tif ( emfAnn.exportSchema() ) {\n\t\t\tpui.getProperties().setProperty(\n\t\t\t\t\tAvailableSettings.JAKARTA_HBM2DDL_DATABASE_ACTION,\n\t\t\t\t\tAction.CREATE_DROP.getExternalHbm2ddlName()\n\t\t\t);\n\t\t}\n\n\t\tif ( emfAnn.annotatedPackageNames().length > 0 ) {\n\t\t\tpui.applyManagedClassNames( emfAnn.annotatedPackageNames() );\n\t\t}\n\n\t\tif ( emfAnn.annotatedClassNames().length > 0 ) {\n\t\t\tpui.applyManagedClassNames( emfAnn.annotatedClassNames() );\n\t\t}\n\n\t\tif ( emfAnn.annotatedClasses().length > 0 ) {\n\t\t\tfor ( int i = 0; i < emfAnn.annotatedClasses().length; i++ ) {\n\t\t\t\tpui.applyManagedClassNames( emfAnn.annotatedClasses()[i].getName() );\n\t\t\t}\n\t\t}\n\n\t\tif ( emfAnn.xmlMappings().length > 0 ) {\n\t\t\tpui.applyMappingFiles( emfAnn.xmlMappings() );\n\t\t}\n\n\t\tif ( emfAnn.standardModels().length > 0 ) {\n\t\t\tfor ( int i = 0; i < emfAnn.standardModels().length; i++ ) {\n\t\t\t\tfinal StandardDomainModel standardDomainModel = emfAnn.standardModels()[i];\n\t\t\t\tfor ( int i1 = 0; i1 < standardDomainModel.getDescriptor().getAnnotatedClasses().length; i1++ ) {\n\t\t\t\t\tfinal Class<?> annotatedClass = standardDomainModel.getDescriptor().getAnnotatedClasses()[i1];\n\t\t\t\t\tpui.applyManagedClassNames( annotatedClass.getName() );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ( emfAnn.modelDescriptorClasses().length > 0 ) {\n\t\t\tfor ( int i = 0; i < emfAnn.modelDescriptorClasses().length; i++ ) {\n\t\t\t\tfinal Class<? extends DomainModelDescriptor> modelDescriptorClass = emfAnn.modelDescriptorClasses()[i];\n\t\t\t\tfinal DomainModelDescriptor domainModelDescriptor = instantiateDomainModelDescriptor(\n\t\t\t\t\t\tmodelDescriptorClass );\n\t\t\t\tfor ( int i1 = 0; i1 < domainModelDescriptor.getAnnotatedClasses().length; i1++ ) {\n\t\t\t\t\tfinal Class<?> annotatedClass = domainModelDescriptor.getAnnotatedClasses()[i1];\n\t\t\t\t\tpui.applyManagedClassNames( annotatedClass.getName() );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfinal Map<String, Object> integrationSettings = new HashMap<>();\n\n\t\tintegrationSettings.put( PersistentTableStrategy.DROP_ID_TABLES, \"true\" );\n\t\tintegrationSettings.put( GlobalTemporaryTableMutationStrategy.DROP_ID_TABLES, \"true\" );\n\t\tintegrationSettings.put( LocalTemporaryTableMutationStrategy.DROP_ID_TABLES, \"true\" );\n\t\tfor ( int i = 0; i < emfAnn.integrationSettings().length; i++ ) {\n\t\t\tfinal Setting setting = emfAnn.integrationSettings()[i];\n\t\t\tintegrationSettings.put( setting.name(), setting.value() );\n\t\t}\n\n\t\tfor ( SettingProvider providerAnn : emfAnn.settingProviders() ) {\n\t\t\tfinal Class<? extends SettingProvider.Provider<?>> providerImpl = providerAnn.provider();\n\t\t\ttry {\n\t\t\t\tfinal SettingProvider.Provider<?> provider = providerImpl.getConstructor().newInstance();\n\t\t\t\tintegrationSettings.put( providerAnn.settingName(), provider.getSetting() );\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tlog.error( \"Error obtaining setting provider for \" + providerImpl.getName(), e );\n\t\t\t}\n\t\t}\n\n\t\t// statement inspector\n\t\tif ( emfAnn.useCollectingStatementInspector() ) {\n\t\t\tString inspectorSetting = (String) integrationSettings.get( AvailableSettings.STATEMENT_INSPECTOR );\n\t\t\tif ( !(inspectorSetting == null || inspectorSetting.isBlank()) ) {\n\t\t\t\tlog.warn( String.format( \"Overriding the explicit \\\"%1s\\\" statement inspector setting\", inspectorSetting ) );\n\t\t\t}\n\t\t\tintegrationSettings.put( AvailableSettings.STATEMENT_INSPECTOR, new SQLStatementInspector() );\n\t\t}\n\n\t\tServiceRegistryUtil.applySettings( integrationSettings );\n\t\tfinal EntityManagerFactoryScopeImpl scope = new EntityManagerFactoryScopeImpl( pui, integrationSettings );\n\n\t\tstore.put( EMF_KEY, scope );\n\n\t\treturn scope;\n\t}",
        "filePathBefore": "hibernate-testing/src/main/java/org/hibernate/testing/orm/junit/EntityManagerFactoryExtension.java",
        "isPureRefactoring": true,
        "commitId": "4781c09d0df0eb4ce05b2fa0d2a12747023ae024",
        "packageNameBefore": "org.hibernate.testing.orm.junit",
        "classNameBefore": "org.hibernate.testing.orm.junit.EntityManagerFactoryExtension",
        "methodNameBefore": "org.hibernate.testing.orm.junit.EntityManagerFactoryExtension#findEntityManagerFactoryScope",
        "invokedMethod": "methodSignature: org.hibernate.jpa.boot.internal.ParsedPersistenceXmlDescriptor#setValidationMode\n methodBody: public void setValidationMode(String validationMode) {\nsetValidationMode(ValidationMode.valueOf(validationMode));\n}\nmethodSignature: org.hibernate.testing.junit4.BaseNonConfigCoreFunctionalTestCase#getAnnotatedClasses\n methodBody: protected Class[] getAnnotatedClasses() {\nreturn NO_CLASSES;\n}\nmethodSignature: org.hibernate.jpa.boot.internal.PersistenceUnitInfoDescriptor#getName\n methodBody: public String getName() {\nreturn persistenceUnitInfo.getPersistenceUnitName();\n}\nmethodSignature: org.hibernate.testing.orm.jpa.PersistenceUnitInfoImpl#setTransactionType\n methodBody: public void setTransactionType(PersistenceUnitTransactionType transactionType) {\nthis.transactionType=transactionType;\n}\nmethodSignature: org.hibernate.testing.orm.junit.EntityManagerFactoryBasedFunctionalTest#applySettings\n methodBody: protected void applySettings(Map<Object, Object> settings) {\nString[] mappings=getMappings();\nif(mappings != null){settings.put(AvailableSettings.HBM_XML_FILES,String.join(\",\",mappings));\n}}\nmethodSignature: org.hibernate.testing.orm.jpa.PersistenceUnitInfoImpl#setValidationMode\n methodBody: public void setValidationMode(ValidationMode validationMode) {\nthis.validationMode=validationMode;\n}\nmethodSignature: org.hibernate.collection.spi.AbstractPersistentCollection.SetProxy#isEmpty\n methodBody: public boolean isEmpty() {\nreturn set.isEmpty();\n}\nmethodSignature: org.hibernate.testing.orm.jpa.PersistenceUnitInfoImpl#applyMappingFiles\n methodBody: public void applyMappingFiles(String... mappingFiles) {\nif(this.mappingFiles == null){this.mappingFiles=new ArrayList<>();\n}Collections.addAll(this.mappingFiles,mappingFiles);\n}\nmethodSignature: org.hibernate.testing.util.jpa.DelegatingPersistenceUnitInfo#getProperties\n methodBody: public Properties getProperties() {\nreturn delegate.getProperties();\n}\nmethodSignature: org.hibernate.orm.test.exceptionhandling.BaseJpaOrNativeBootstrapFunctionalTestCase.TestingPersistenceUnitDescriptorImpl#getName\n methodBody: public String getName() {\nreturn name;\n}\nmethodSignature: org.hibernate.collection.spi.PersistentList#get\n methodBody: public E get(int index) {\nif(index < 0){throw new ArrayIndexOutOfBoundsException(\"negative index\");\n}final Object result=readElementByIndex(index);\nreturn result == UNKNOWN ? list.get(index) : (E)result;\n}\nmethodSignature: org.hibernate.orm.test.bootstrap.BootstrapTest.PersistenceUnitInfoImpl#getProperties\n methodBody: public Properties getProperties() {\nreturn properties;\n}\nmethodSignature: org.hibernate.testing.orm.junit.EntityManagerFactoryBasedFunctionalTest.TestingPersistenceUnitDescriptorImpl#getName\n methodBody: public String getName() {\nreturn name;\n}\nmethodSignature: org.hibernate.jpa.boot.spi.PersistenceConfigurationDescriptor#getName\n methodBody: public String getName() {\nreturn persistenceConfiguration.name();\n}\nmethodSignature: org.hibernate.jpa.boot.internal.PersistenceUnitInfoDescriptor#getProperties\n methodBody: public Properties getProperties() {\nreturn persistenceUnitInfo.getProperties();\n}\nmethodSignature: org.hibernate.jpa.boot.spi.PersistenceUnitDescriptor#getProperties\n methodBody: Properties getProperties();\nmethodSignature: org.hibernate.testing.orm.junit.BaseSessionFactoryFunctionalTest#getAnnotatedClasses\n methodBody: protected Class[] getAnnotatedClasses() {\nreturn NO_CLASSES;\n}\nmethodSignature: org.hibernate.testing.orm.junit.BaseSessionFactoryFunctionalTest#applySettings\n methodBody: protected void applySettings(StandardServiceRegistryBuilder builder) {\n}\nmethodSignature: org.hibernate.testing.orm.jpa.PersistenceUnitInfoAdapter#getProperties\n methodBody: public Properties getProperties() {\nif(properties == null){properties=new Properties();\n}return properties;\n}\nmethodSignature: org.hibernate.testing.util.jpa.DelegatingPersistenceUnitInfo#excludeUnlistedClasses\n methodBody: public boolean excludeUnlistedClasses() {\nreturn delegate.excludeUnlistedClasses();\n}\nmethodSignature: org.hibernate.testing.util.jpa.PersistenceUnitInfoAdapter#getProperties\n methodBody: public Properties getProperties() {\nreturn properties;\n}\nmethodSignature: org.hibernate.testing.orm.jpa.PersistenceUnitInfoImpl#setCacheMode\n methodBody: public void setCacheMode(SharedCacheMode cacheMode) {\nthis.cacheMode=cacheMode;\n}\nmethodSignature: org.hibernate.jpa.boot.internal.ParsedPersistenceXmlDescriptor#getName\n methodBody: public String getName() {\nreturn name;\n}\nmethodSignature: org.hibernate.orm.test.jpa.BaseEntityManagerFunctionalTestCase.TestingPersistenceUnitDescriptorImpl#getName\n methodBody: public String getName() {\nreturn name;\n}\nmethodSignature: org.hibernate.testing.orm.jpa.PersistenceUnitInfoImpl#excludeUnlistedClasses\n methodBody: public boolean excludeUnlistedClasses() {\nreturn excludeUnlistedClasses;\n}\nmethodSignature: org.hibernate.testing.orm.junit.EntityManagerFactoryBasedFunctionalTest#getAnnotatedClasses\n methodBody: protected Class<?>[] getAnnotatedClasses() {\nreturn NO_CLASSES;\n}\nmethodSignature: org.hibernate.collection.spi.AbstractPersistentCollection.ListProxy#get\n methodBody: public E get(int i) {\nreturn list.get(i);\n}\nmethodSignature: org.hibernate.testing.util.jpa.PersistenceUnitInfoAdapter#excludeUnlistedClasses\n methodBody: public boolean excludeUnlistedClasses() {\nreturn false;\n}\nmethodSignature: org.hibernate.orm.test.exceptionhandling.BaseJpaOrNativeBootstrapFunctionalTestCase#getAnnotatedClasses\n methodBody: protected Class<?>[] getAnnotatedClasses() {\nreturn NO_CLASSES;\n}\nmethodSignature: org.hibernate.orm.test.bootstrap.BootstrapTest.PersistenceUnitInfoImpl#excludeUnlistedClasses\n methodBody: public boolean excludeUnlistedClasses() {\nreturn false;\n}\nmethodSignature: org.hibernate.jpa.boot.spi.PersistenceConfigurationDescriptor#getProperties\n methodBody: public Properties getProperties() {\nreturn properties;\n}\nmethodSignature: org.hibernate.testing.orm.jpa.PersistenceUnitDescriptorAdapter#getProperties\n methodBody: public Properties getProperties() {\nif(properties == null){properties=new Properties();\n}return properties;\n}\nmethodSignature: org.hibernate.collection.spi.PersistentBag#get\n methodBody: public E get(int i) {\nread();\nreturn bag.get(i);\n}\nmethodSignature: org.hibernate.testing.orm.jpa.PersistenceUnitInfoAdapter#excludeUnlistedClasses\n methodBody: public boolean excludeUnlistedClasses() {\nreturn false;\n}\nmethodSignature: org.hibernate.testing.orm.jpa.PersistenceUnitInfoImpl#setExcludeUnlistedClasses\n methodBody: public void setExcludeUnlistedClasses(boolean excludeUnlistedClasses) {\nthis.excludeUnlistedClasses=excludeUnlistedClasses;\n}\nmethodSignature: org.hibernate.collection.spi.PersistentList#toString\n methodBody: public String toString() {\nread();\nreturn list.toString();\n}\nmethodSignature: org.hibernate.testing.junit4.BaseCoreFunctionalTestCase#getAnnotatedClasses\n methodBody: protected Class<?>[] getAnnotatedClasses() {\nreturn NO_CLASSES;\n}\nmethodSignature: org.hibernate.collection.spi.PersistentBag#getElement\n methodBody: public Object getElement(Object entry) {\nreturn entry;\n}\nmethodSignature: org.hibernate.collection.spi.PersistentBag#isEmpty\n methodBody: public boolean isEmpty() {\nreturn readSize() ? getCachedSize() == 0 : bag.isEmpty();\n}\nmethodSignature: org.hibernate.orm.test.jpa.xml.versions.JpaXsdVersionsTest.PersistenceUnitInfoImpl#getProperties\n methodBody: public Properties getProperties() {\nreturn properties;\n}\nmethodSignature: org.hibernate.jpa.boot.internal.ParsedPersistenceXmlDescriptor#setTransactionType\n methodBody: public void setTransactionType(PersistenceUnitTransactionType transactionType) {\nthis.transactionType=transactionType;\n}\nmethodSignature: org.hibernate.orm.test.jpa.EntityManagerTest#getAnnotatedClasses\n methodBody: public Class[] getAnnotatedClasses() {\nreturn new Class[]{Item.class,Distributor.class,Wallet.class};\n}\nmethodSignature: org.hibernate.orm.test.jpa.BaseEntityManagerFunctionalTestCase#getAnnotatedClasses\n methodBody: protected Class<?>[] getAnnotatedClasses() {\nreturn NO_CLASSES;\n}\nmethodSignature: org.hibernate.testing.orm.junit.EntityManagerFactoryBasedFunctionalTest#exportSchema\n methodBody: protected boolean exportSchema() {\nreturn true;\n}\nmethodSignature: org.hibernate.jpa.boot.internal.ParsedPersistenceXmlDescriptor#getProperties\n methodBody: public Properties getProperties() {\nreturn properties;\n}\nmethodSignature: org.hibernate.internal.SessionFactoryImpl#getProperties\n methodBody: public Map<String, Object> getProperties() {\nvalidateNotClosed();\nreturn settings;\n}\nmethodSignature: org.hibernate.testing.util.jpa.PersistenceUnitInfoPropertiesWrapper#excludeUnlistedClasses\n methodBody: public boolean excludeUnlistedClasses() {\nreturn false;\n}\nmethodSignature: org.hibernate.orm.test.jpa.xml.versions.JpaXsdVersionsTest.PersistenceUnitInfoImpl#excludeUnlistedClasses\n methodBody: public boolean excludeUnlistedClasses() {\nreturn false;\n}\nmethodSignature: org.hibernate.jpa.boot.spi.PersistenceUnitDescriptor#getName\n methodBody: String getName();\nmethodSignature: org.hibernate.orm.test.exceptionhandling.BaseJpaOrNativeBootstrapFunctionalTestCase.TestingPersistenceUnitDescriptorImpl#getProperties\n methodBody: public Properties getProperties() {\nreturn null;\n}\nmethodSignature: org.hibernate.testing.orm.jpa.PersistenceUnitDescriptorAdapter#getName\n methodBody: public String getName() {\nreturn name;\n}\nmethodSignature: org.hibernate.testing.orm.junit.EntityManagerFactoryExtension#locateExtensionStore\n methodBody: private static ExtensionContext.Store locateExtensionStore(Object testScope, ExtensionContext context) {\nreturn JUnitHelper.locateExtensionStore(EntityManagerFactoryExtension.class,context,testScope);\n}\nmethodSignature: org.hibernate.jpa.boot.internal.ParsedPersistenceXmlDescriptor#setExcludeUnlistedClasses\n methodBody: public void setExcludeUnlistedClasses(boolean excludeUnlistedClasses) {\nthis.excludeUnlistedClasses=excludeUnlistedClasses;\n}\nmethodSignature: org.hibernate.testing.orm.jpa.PersistenceUnitInfoImpl#applyManagedClassNames\n methodBody: public void applyManagedClassNames(String... managedClassNames) {\nif(this.managedClassNames == null){this.managedClassNames=new ArrayList<>();\n}Collections.addAll(this.managedClassNames,managedClassNames);\n}\nmethodSignature: org.hibernate.testing.util.jpa.PersistenceUnitInfoPropertiesWrapper#getProperties\n methodBody: public Properties getProperties() {\nif(properties == null){properties=new Properties();\n}return properties;\n}\nmethodSignature: org.hibernate.collection.spi.PersistentList#getElement\n methodBody: public Object getElement(Object entry) {\nreturn entry;\n}\nmethodSignature: org.hibernate.orm.test.jpa.BaseEntityManagerFunctionalTestCase.TestingPersistenceUnitDescriptorImpl#getProperties\n methodBody: public Properties getProperties() {\nreturn null;\n}\nmethodSignature: org.hibernate.internal.SessionFactoryImpl#getName\n methodBody: public String getName() {\nreturn name;\n}\nmethodSignature: org.hibernate.testing.orm.junit.EntityManagerFactoryBasedFunctionalTest.TestingPersistenceUnitDescriptorImpl#getProperties\n methodBody: public Properties getProperties() {\nreturn null;\n}\nmethodSignature: org.hibernate.collection.spi.PersistentList#isEmpty\n methodBody: public boolean isEmpty() {\nreturn readSize() ? getCachedSize() == 0 : list.isEmpty();\n}\nmethodSignature: org.hibernate.testing.orm.jpa.PersistenceUnitInfoImpl#getProperties\n methodBody: public Properties getProperties() {\nreturn properties;\n}\nmethodSignature: org.hibernate.testing.orm.junit.EntityManagerFactoryExtension#instantiateDomainModelDescriptor\n methodBody: private static DomainModelDescriptor instantiateDomainModelDescriptor(Class<? extends DomainModelDescriptor> modelDescriptorClass) {\ntryfinal Field[] declaredFields=modelDescriptorClass.getDeclaredFields();\nfor(int i=0; i < declaredFields.length; i++){final Field field=declaredFields[i];\nif(ReflectHelper.isStaticField(field)){final Object value=field.get(null);\nif(value instanceof DomainModelDescriptor){return (DomainModelDescriptor)value;\n}}}catch(IllegalAccessException e)throw new RuntimeException(\"Problem accessing DomainModelDescriptor fields : \" + modelDescriptorClass.getName(),e);\ntryreturn modelDescriptorClass.getConstructor(null).newInstance(null);\ncatch(InstantiationException|IllegalAccessException|InvocationTargetException|NoSuchMethodException e)throw new RuntimeException(\"Problem instantiation DomainModelDescriptor : \" + modelDescriptorClass.getName(),e);\n}\nmethodSignature: org.hibernate.testing.orm.junit.BaseSessionFactoryFunctionalTest#exportSchema\n methodBody: protected boolean exportSchema() {\nreturn true;\n}\nmethodSignature: org.hibernate.collection.spi.AbstractPersistentCollection.ListProxy#isEmpty\n methodBody: public boolean isEmpty() {\nreturn list.isEmpty();\n}\nmethodSignature: org.hibernate.collection.spi.PersistentBag#toString\n methodBody: public String toString() {\nread();\nreturn bag.toString();\n}",
        "classSignatureBefore": "public class EntityManagerFactoryExtension\n\t\timplements TestInstancePostProcessor, BeforeEachCallback, TestExecutionExceptionHandler ",
        "methodNameBeforeSet": [
            "org.hibernate.testing.orm.junit.EntityManagerFactoryExtension#findEntityManagerFactoryScope"
        ],
        "classNameBeforeSet": [
            "org.hibernate.testing.orm.junit.EntityManagerFactoryExtension"
        ],
        "classSignatureBeforeSet": [
            "public class EntityManagerFactoryExtension\n\t\timplements TestInstancePostProcessor, BeforeEachCallback, TestExecutionExceptionHandler "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Overlapped refactoring - can be identical by undoing the overlapped refactoring\n- Rename Variable- Severe changes",
                "description": "Return expression has been added within the Extract Method mechanics - with non-mapped leaves",
                "mappingState": 2
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later\n * See the lgpl.txt file in the root directory or http://www.gnu.org/licenses/lgpl-2.1.html\n */\npackage org.hibernate.testing.orm.junit;\n\nimport java.lang.reflect.Field;\nimport java.lang.reflect.InvocationTargetException;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.Set;\nimport jakarta.persistence.spi.PersistenceUnitInfo;\n\nimport org.hibernate.SessionFactoryObserver;\nimport org.hibernate.boot.registry.StandardServiceRegistry;\nimport org.hibernate.boot.spi.MetadataImplementor;\nimport org.hibernate.cfg.AvailableSettings;\nimport org.hibernate.cfg.Environment;\nimport org.hibernate.engine.spi.SessionFactoryImplementor;\nimport org.hibernate.internal.util.ReflectHelper;\nimport org.hibernate.jpa.boot.internal.PersistenceUnitInfoDescriptor;\nimport org.hibernate.jpa.boot.spi.Bootstrap;\nimport org.hibernate.jpa.boot.spi.EntityManagerFactoryBuilder;\nimport org.hibernate.query.sqm.mutation.internal.temptable.GlobalTemporaryTableMutationStrategy;\nimport org.hibernate.query.sqm.mutation.internal.temptable.LocalTemporaryTableMutationStrategy;\nimport org.hibernate.query.sqm.mutation.internal.temptable.PersistentTableStrategy;\nimport org.hibernate.tool.schema.Action;\nimport org.hibernate.tool.schema.spi.SchemaManagementToolCoordinator;\nimport org.hibernate.tool.schema.spi.SchemaManagementToolCoordinator.ActionGrouping;\n\nimport org.hibernate.testing.jdbc.SQLStatementInspector;\nimport org.hibernate.testing.orm.domain.DomainModelDescriptor;\nimport org.hibernate.testing.orm.domain.StandardDomainModel;\nimport org.hibernate.testing.orm.jpa.PersistenceUnitInfoImpl;\nimport org.hibernate.testing.util.ServiceRegistryUtil;\nimport org.junit.jupiter.api.extension.BeforeEachCallback;\nimport org.junit.jupiter.api.extension.ExtensionContext;\nimport org.junit.jupiter.api.extension.TestExecutionExceptionHandler;\nimport org.junit.jupiter.api.extension.TestInstancePostProcessor;\nimport org.junit.platform.commons.support.AnnotationSupport;\n\nimport org.jboss.logging.Logger;\n\n/**\n * hibernate-testing implementation of a few JUnit5 contracts to support SessionFactory-based testing,\n * including argument injection (or see {@link SessionFactoryScopeAware})\n *\n * @author Steve Ebersole\n *\n * @see DomainModelExtension\n * @see SessionFactoryExtension\n */\npublic class EntityManagerFactoryExtension\n\t\timplements TestInstancePostProcessor, BeforeEachCallback, TestExecutionExceptionHandler {\n\n\tprivate static final Logger log = Logger.getLogger( EntityManagerFactoryExtension.class );\n\tprivate static final String EMF_KEY = EntityManagerFactoryScope.class.getName();\n\n\tprivate static ExtensionContext.Store locateExtensionStore(Object testScope, ExtensionContext context) {\n\t\treturn JUnitHelper.locateExtensionStore( EntityManagerFactoryExtension.class, context, testScope );\n\t}\n\n\tpublic static EntityManagerFactoryScope findEntityManagerFactoryScope(\n\t\t\tObject testScope,\n\t\t\tOptional<Jpa> emfAnnWrapper,\n\t\t\tExtensionContext context) {\n\n\t\tif ( emfAnnWrapper.isEmpty() ) {\n\t\t\t// No annotation on the test class, should be on the test methods\n\t\t\treturn null;\n\t\t}\n\n\t\tfinal ExtensionContext.Store store = locateExtensionStore( testScope, context );\n\t\tfinal EntityManagerFactoryScope existing = (EntityManagerFactoryScope) store.get( EMF_KEY );\n\t\tif ( existing != null ) {\n\t\t\treturn existing;\n\t\t}\n\n\t\tif ( !context.getElement().isPresent() ) {\n\t\t\tthrow new RuntimeException( \"Unable to determine how to handle given ExtensionContext : \" + context.getDisplayName() );\n\t\t}\n\t\tfinal Jpa emfAnn = emfAnnWrapper.get();\n\n\t\tfinal PersistenceUnitInfoImpl pui = new PersistenceUnitInfoImpl( emfAnn.persistenceUnitName() );\n\t\t( (Map<Object, Object>) Environment.getProperties() ).forEach(\n\t\t\t\t(key, value) ->\n\t\t\t\t\t\tpui.getProperties().put( key, value )\n\t\t);\n\n\t\tpui.setTransactionType( emfAnn.transactionType() );\n\t\tpui.setCacheMode( emfAnn.sharedCacheMode() );\n\t\tpui.setValidationMode( emfAnn.validationMode() );\n\t\tpui.setExcludeUnlistedClasses( emfAnn.excludeUnlistedClasses() );\n\n\t\t// JpaCompliance\n\t\tpui.getProperties().put( AvailableSettings.JPA_COMPLIANCE, emfAnn.jpaComplianceEnabled() );\n\t\tpui.getProperties().put( AvailableSettings.JPA_QUERY_COMPLIANCE, emfAnn.queryComplianceEnabled() );\n\t\tpui.getProperties().put( AvailableSettings.JPA_TRANSACTION_COMPLIANCE, emfAnn.transactionComplianceEnabled() );\n\t\tpui.getProperties().put( AvailableSettings.JPA_CLOSED_COMPLIANCE, emfAnn.closedComplianceEnabled() );\n\t\tpui.getProperties().put( AvailableSettings.JPA_PROXY_COMPLIANCE, emfAnn.proxyComplianceEnabled() );\n\t\tpui.getProperties().put( AvailableSettings.JPA_CACHING_COMPLIANCE, emfAnn.cacheComplianceEnabled() );\n\t\tpui.getProperties().put( AvailableSettings.JPA_ID_GENERATOR_GLOBAL_SCOPE_COMPLIANCE, emfAnn.generatorScopeComplianceEnabled() );\n\t\tpui.getProperties().put( AvailableSettings.JPA_ORDER_BY_MAPPING_COMPLIANCE, emfAnn.orderByMappingComplianceEnabled() );\n\t\tpui.getProperties().put( AvailableSettings.JPA_LOAD_BY_ID_COMPLIANCE, emfAnn.loadByIdComplianceEnabled() );\n\n\t\tfinal Setting[] properties = emfAnn.properties();\n\t\tfor ( int i = 0; i < properties.length; i++ ) {\n\t\t\tfinal Setting property = properties[i];\n\t\t\tpui.getProperties().setProperty( property.name(), property.value() );\n\t\t}\n\n\t\tpui.getProperties().setProperty(\n\t\t\t\tAvailableSettings.GENERATE_STATISTICS,\n\t\t\t\tBoolean.toString( emfAnn.generateStatistics() )\n\t\t);\n\n\t\tif ( emfAnn.exportSchema() ) {\n\t\t\tpui.getProperties().setProperty(\n\t\t\t\t\tAvailableSettings.JAKARTA_HBM2DDL_DATABASE_ACTION,\n\t\t\t\t\tAction.CREATE_DROP.getExternalHbm2ddlName()\n\t\t\t);\n\t\t}\n\n\t\tif ( emfAnn.annotatedPackageNames().length > 0 ) {\n\t\t\tpui.applyManagedClassNames( emfAnn.annotatedPackageNames() );\n\t\t}\n\n\t\tif ( emfAnn.annotatedClassNames().length > 0 ) {\n\t\t\tpui.applyManagedClassNames( emfAnn.annotatedClassNames() );\n\t\t}\n\n\t\tif ( emfAnn.annotatedClasses().length > 0 ) {\n\t\t\tfor ( int i = 0; i < emfAnn.annotatedClasses().length; i++ ) {\n\t\t\t\tpui.applyManagedClassNames( emfAnn.annotatedClasses()[i].getName() );\n\t\t\t}\n\t\t}\n\n\t\tif ( emfAnn.xmlMappings().length > 0 ) {\n\t\t\tpui.applyMappingFiles( emfAnn.xmlMappings() );\n\t\t}\n\n\t\tif ( emfAnn.standardModels().length > 0 ) {\n\t\t\tfor ( int i = 0; i < emfAnn.standardModels().length; i++ ) {\n\t\t\t\tfinal StandardDomainModel standardDomainModel = emfAnn.standardModels()[i];\n\t\t\t\tfor ( int i1 = 0; i1 < standardDomainModel.getDescriptor().getAnnotatedClasses().length; i1++ ) {\n\t\t\t\t\tfinal Class<?> annotatedClass = standardDomainModel.getDescriptor().getAnnotatedClasses()[i1];\n\t\t\t\t\tpui.applyManagedClassNames( annotatedClass.getName() );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ( emfAnn.modelDescriptorClasses().length > 0 ) {\n\t\t\tfor ( int i = 0; i < emfAnn.modelDescriptorClasses().length; i++ ) {\n\t\t\t\tfinal Class<? extends DomainModelDescriptor> modelDescriptorClass = emfAnn.modelDescriptorClasses()[i];\n\t\t\t\tfinal DomainModelDescriptor domainModelDescriptor = instantiateDomainModelDescriptor(\n\t\t\t\t\t\tmodelDescriptorClass );\n\t\t\t\tfor ( int i1 = 0; i1 < domainModelDescriptor.getAnnotatedClasses().length; i1++ ) {\n\t\t\t\t\tfinal Class<?> annotatedClass = domainModelDescriptor.getAnnotatedClasses()[i1];\n\t\t\t\t\tpui.applyManagedClassNames( annotatedClass.getName() );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfinal Map<String, Object> integrationSettings = new HashMap<>();\n\n\t\tintegrationSettings.put( PersistentTableStrategy.DROP_ID_TABLES, \"true\" );\n\t\tintegrationSettings.put( GlobalTemporaryTableMutationStrategy.DROP_ID_TABLES, \"true\" );\n\t\tintegrationSettings.put( LocalTemporaryTableMutationStrategy.DROP_ID_TABLES, \"true\" );\n\t\tfor ( int i = 0; i < emfAnn.integrationSettings().length; i++ ) {\n\t\t\tfinal Setting setting = emfAnn.integrationSettings()[i];\n\t\t\tintegrationSettings.put( setting.name(), setting.value() );\n\t\t}\n\n\t\tfor ( SettingProvider providerAnn : emfAnn.settingProviders() ) {\n\t\t\tfinal Class<? extends SettingProvider.Provider<?>> providerImpl = providerAnn.provider();\n\t\t\ttry {\n\t\t\t\tfinal SettingProvider.Provider<?> provider = providerImpl.getConstructor().newInstance();\n\t\t\t\tintegrationSettings.put( providerAnn.settingName(), provider.getSetting() );\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tlog.error( \"Error obtaining setting provider for \" + providerImpl.getName(), e );\n\t\t\t}\n\t\t}\n\n\t\t// statement inspector\n\t\tif ( emfAnn.useCollectingStatementInspector() ) {\n\t\t\tString inspectorSetting = (String) integrationSettings.get( AvailableSettings.STATEMENT_INSPECTOR );\n\t\t\tif ( !(inspectorSetting == null || inspectorSetting.isBlank()) ) {\n\t\t\t\tlog.warn( String.format( \"Overriding the explicit \\\"%1s\\\" statement inspector setting\", inspectorSetting ) );\n\t\t\t}\n\t\t\tintegrationSettings.put( AvailableSettings.STATEMENT_INSPECTOR, new SQLStatementInspector() );\n\t\t}\n\n\t\tServiceRegistryUtil.applySettings( integrationSettings );\n\t\tfinal EntityManagerFactoryScopeImpl scope = new EntityManagerFactoryScopeImpl( pui, integrationSettings );\n\n\t\tstore.put( EMF_KEY, scope );\n\n\t\treturn scope;\n\t}\n\n\tprivate static DomainModelDescriptor instantiateDomainModelDescriptor(Class<? extends DomainModelDescriptor> modelDescriptorClass) {\n\t\t// first, see if it has a static singleton reference and use that if so\n\t\ttry {\n\t\t\tfinal Field[] declaredFields = modelDescriptorClass.getDeclaredFields();\n\t\t\tfor ( int i = 0; i < declaredFields.length; i++ ) {\n\t\t\t\tfinal Field field = declaredFields[i];\n\t\t\t\tif ( ReflectHelper.isStaticField( field ) ) {\n\t\t\t\t\tfinal Object value = field.get( null );\n\t\t\t\t\tif ( value instanceof DomainModelDescriptor ) {\n\t\t\t\t\t\treturn (DomainModelDescriptor) value;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (IllegalAccessException e) {\n\t\t\tthrow new RuntimeException(\n\t\t\t\t\t\"Problem accessing DomainModelDescriptor fields : \" + modelDescriptorClass.getName(),\n\t\t\t\t\te\n\t\t\t);\n\t\t}\n\n\t\t// no singleton field, try to instantiate it via reflection\n\t\ttry {\n\t\t\treturn modelDescriptorClass.getConstructor( null ).newInstance( null );\n\t\t}\n\t\tcatch (InstantiationException | IllegalAccessException | InvocationTargetException | NoSuchMethodException e) {\n\t\t\tthrow new RuntimeException(\n\t\t\t\t\t\"Problem instantiation DomainModelDescriptor : \" + modelDescriptorClass.getName(),\n\t\t\t\t\te\n\t\t\t);\n\t\t}\n\t}\n\n\tprivate static void prepareSchemaExport(\n\t\t\tSessionFactoryImplementor sessionFactory,\n\t\t\tMetadataImplementor model) {\n\t\tfinal Map<String, Object> baseProperties = sessionFactory.getProperties();\n\n\t\tfinal Set<ActionGrouping> groupings = ActionGrouping.interpret( model, baseProperties );\n\t\tif ( !groupings.isEmpty() ) {\n\t\t\t// the properties contained explicit settings for auto schema tooling - skip the annotation\n\t\t\treturn;\n\t\t}\n\n\t\tfinal HashMap<String,Object> settings = new HashMap<>( baseProperties );\n\t\tsettings.put( AvailableSettings.JAKARTA_HBM2DDL_DATABASE_ACTION, Action.CREATE_DROP );\n\n\t\tfinal StandardServiceRegistry serviceRegistry = model.getMetadataBuildingOptions().getServiceRegistry();\n\n\n\t\tSchemaManagementToolCoordinator.process(\n\t\t\t\tmodel,\n\t\t\t\tserviceRegistry,\n\t\t\t\tsettings,\n\t\t\t\taction -> sessionFactory.addObserver(\n\t\t\t\t\t\tnew SessionFactoryObserver() {\n\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\tpublic void sessionFactoryClosing(org.hibernate.SessionFactory factory) {\n\t\t\t\t\t\t\t\taction.perform( serviceRegistry );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t)\n\t\t);\n\t}\n\n\t@Override\n\tpublic void beforeEach(ExtensionContext context) {\n\t\tlog.tracef( \"#beforeEach(%s)\", context.getDisplayName() );\n\t\tfinal Optional<Jpa> emfAnnWrapper = AnnotationSupport.findAnnotation(\n\t\t\t\tcontext.getRequiredTestMethod(),\n\t\t\t\tJpa.class\n\t\t);\n\n\t\tif ( emfAnnWrapper.isEmpty() ) {\n\t\t\t// assume the annotation is defined on the class-level...\n\t\t\treturn;\n\t\t}\n\n\t\tfindEntityManagerFactoryScope( context.getRequiredTestMethod(), emfAnnWrapper, context );\n\t}\n\n\t@Override\n\tpublic void postProcessTestInstance(Object testInstance, ExtensionContext context) {\n\t\tlog.tracef( \"#postProcessTestInstance(%s, %s)\", testInstance, context.getDisplayName() );\n\n\t\tfinal Optional<Jpa> emfAnnWrapper = AnnotationSupport.findAnnotation(\n\t\t\t\tcontext.getRequiredTestClass(),\n\t\t\t\tJpa.class\n\t\t);\n\n\t\tfindEntityManagerFactoryScope( testInstance, emfAnnWrapper, context );\n\t}\n\n\t@Override\n\tpublic void handleTestExecutionException(ExtensionContext context, Throwable throwable) throws Throwable {\n\t\tlog.tracef( \"#handleTestExecutionException(%s, %s)\", context.getDisplayName(), throwable );\n\n\t\ttry {\n\t\t\tfinal Object testInstance = context.getRequiredTestInstance();\n\t\t\tfinal ExtensionContext.Store store = locateExtensionStore( testInstance, context );\n\t\t\tfinal EntityManagerFactoryScopeImpl scope = (EntityManagerFactoryScopeImpl) store.get( EMF_KEY );\n\t\t\tscope.releaseEntityManagerFactory();\n\t\t}\n\t\tcatch (Exception ignore) {\n\t\t}\n\n\t\tthrow throwable;\n\t}\n\n\tprivate static class EntityManagerFactoryScopeImpl extends AbstractEntityManagerFactoryScope {\n\t\tprivate final PersistenceUnitInfo persistenceUnitInfo;\n\t\tprivate final Map<String, Object> integrationSettings;\n\n\t\tprivate EntityManagerFactoryScopeImpl(\n\t\t\t\tPersistenceUnitInfo persistenceUnitInfo,\n\t\t\t\tMap<String, Object> integrationSettings) {\n\t\t\tthis.persistenceUnitInfo = persistenceUnitInfo;\n\t\t\tthis.integrationSettings = integrationSettings;\n\t\t}\n\n\t\tprotected jakarta.persistence.EntityManagerFactory createEntityManagerFactory() {\n\t\t\tfinal EntityManagerFactoryBuilder emfBuilder = Bootstrap.getEntityManagerFactoryBuilder(\n\t\t\t\t\tnew PersistenceUnitInfoDescriptor( persistenceUnitInfo ),\n\t\t\t\t\tintegrationSettings\n\t\t\t);\n\n\t\t\treturn emfBuilder.build();\n\t\t}\n\t}\n}\n",
        "filePathAfter": "hibernate-testing/src/main/java/org/hibernate/testing/orm/junit/EntityManagerFactoryExtension.java",
        "sourceCodeAfterForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later\n * See the lgpl.txt file in the root directory or http://www.gnu.org/licenses/lgpl-2.1.html\n */\npackage org.hibernate.testing.orm.junit;\n\nimport java.lang.reflect.Field;\nimport java.lang.reflect.InvocationTargetException;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.Properties;\n\nimport jakarta.persistence.spi.PersistenceUnitInfo;\n\nimport org.hibernate.cfg.AvailableSettings;\nimport org.hibernate.cfg.Environment;\nimport org.hibernate.internal.util.ReflectHelper;\nimport org.hibernate.jpa.boot.internal.PersistenceUnitInfoDescriptor;\nimport org.hibernate.query.sqm.mutation.internal.temptable.GlobalTemporaryTableMutationStrategy;\nimport org.hibernate.query.sqm.mutation.internal.temptable.LocalTemporaryTableMutationStrategy;\nimport org.hibernate.query.sqm.mutation.internal.temptable.PersistentTableStrategy;\nimport org.hibernate.tool.schema.Action;\n\nimport org.hibernate.testing.jdbc.SQLStatementInspector;\nimport org.hibernate.testing.orm.domain.DomainModelDescriptor;\nimport org.hibernate.testing.orm.domain.StandardDomainModel;\nimport org.hibernate.testing.orm.jpa.PersistenceUnitInfoImpl;\nimport org.hibernate.testing.util.ServiceRegistryUtil;\nimport org.junit.jupiter.api.extension.BeforeEachCallback;\nimport org.junit.jupiter.api.extension.ExtensionContext;\nimport org.junit.jupiter.api.extension.TestExecutionExceptionHandler;\nimport org.junit.jupiter.api.extension.TestInstancePostProcessor;\n\nimport org.jboss.logging.Logger;\n\nimport static org.hibernate.jpa.boot.spi.Bootstrap.getEntityManagerFactoryBuilder;\nimport static org.junit.platform.commons.support.AnnotationSupport.findAnnotation;\n\n/**\n * hibernate-testing implementation of a few JUnit5 contracts to support SessionFactory-based testing,\n * including argument injection (or see {@link SessionFactoryScopeAware})\n *\n * @author Steve Ebersole\n *\n * @see DomainModelExtension\n * @see SessionFactoryExtension\n */\npublic class EntityManagerFactoryExtension\n\t\timplements TestInstancePostProcessor, BeforeEachCallback, TestExecutionExceptionHandler {\n\n\tprivate static final Logger log = Logger.getLogger( EntityManagerFactoryExtension.class );\n\tprivate static final String EMF_KEY = EntityManagerFactoryScope.class.getName();\n\n\tprivate static ExtensionContext.Store locateExtensionStore(Object testScope, ExtensionContext context) {\n\t\treturn JUnitHelper.locateExtensionStore( EntityManagerFactoryExtension.class, context, testScope );\n\t}\n\n\tpublic static EntityManagerFactoryScope findEntityManagerFactoryScope(\n\t\t\tObject testScope, Optional<Jpa> optionalJpa, ExtensionContext context) {\n\n\t\tif ( optionalJpa.isEmpty() ) {\n\t\t\t// No annotation on the test class, should be on the test methods\n\t\t\treturn null;\n\t\t}\n\n\t\tfinal ExtensionContext.Store store = locateExtensionStore( testScope, context );\n\t\tfinal EntityManagerFactoryScope existing = (EntityManagerFactoryScope) store.get( EMF_KEY );\n\t\tif ( existing != null ) {\n\t\t\treturn existing;\n\t\t}\n\t\tif ( context.getElement().isEmpty() ) {\n\t\t\tthrow new RuntimeException( \"Unable to determine how to handle given ExtensionContext : \"\n\t\t\t\t\t+ context.getDisplayName() );\n\t\t}\n\n\t\tfinal Jpa jpa = optionalJpa.get();\n\t\tfinal PersistenceUnitInfoImpl pui = createPersistenceUnitInfo( jpa );\n\t\tcollectProperties( pui, jpa );\n\t\tmanagedClassesAndMappings( jpa, pui );\n\t\tfinal Map<String, Object> integrationSettings = collectIntegrationSettings( jpa );\n\t\t// statement inspector\n\t\tsetupStatementInspector( jpa, integrationSettings );\n\t\tServiceRegistryUtil.applySettings( integrationSettings );\n\t\tfinal EntityManagerFactoryScopeImpl scope =\n\t\t\t\tnew EntityManagerFactoryScopeImpl( pui, integrationSettings );\n\t\tstore.put( EMF_KEY, scope );\n\t\treturn scope;\n\t}\n\n\tprivate static void collectProperties(PersistenceUnitInfoImpl pui, Jpa jpa) {\n\t\tfinal Properties properties = pui.getProperties();\n\t\tproperties.putAll( Environment.getProperties() );\n\t\t// JpaCompliance\n\t\tsetJpaComplianceProperties( properties, jpa );\n\t\tfor ( Setting property : jpa.properties() ) {\n\t\t\tproperties.setProperty( property.name(), property.value() );\n\t\t}\n\t\tproperties.setProperty(\n\t\t\t\tAvailableSettings.GENERATE_STATISTICS,\n\t\t\t\tBoolean.toString( jpa.generateStatistics() )\n\t\t);\n\t\tif ( jpa.exportSchema() ) {\n\t\t\tproperties.setProperty(\n\t\t\t\t\tAvailableSettings.JAKARTA_HBM2DDL_DATABASE_ACTION,\n\t\t\t\t\tAction.CREATE_DROP.getExternalHbm2ddlName()\n\t\t\t);\n\t\t}\n\t}\n\n\tprivate static PersistenceUnitInfoImpl createPersistenceUnitInfo(Jpa jpa) {\n\t\tfinal PersistenceUnitInfoImpl pui =\n\t\t\t\tnew PersistenceUnitInfoImpl( jpa.persistenceUnitName() );\n\t\tpui.setTransactionType( jpa.transactionType() );\n\t\tpui.setCacheMode( jpa.sharedCacheMode() );\n\t\tpui.setValidationMode( jpa.validationMode() );\n\t\tpui.setExcludeUnlistedClasses( jpa.excludeUnlistedClasses() );\n\t\treturn pui;\n\t}\n\n\tprivate static void managedClassesAndMappings(Jpa jpa, PersistenceUnitInfoImpl pui) {\n\t\tif ( jpa.annotatedPackageNames().length > 0 ) {\n\t\t\tpui.applyManagedClassNames( jpa.annotatedPackageNames() );\n\t\t}\n\n\t\tif ( jpa.annotatedClassNames().length > 0 ) {\n\t\t\tpui.applyManagedClassNames( jpa.annotatedClassNames() );\n\t\t}\n\n\t\tif ( jpa.annotatedClasses().length > 0 ) {\n\t\t\tfor (int i = 0; i < jpa.annotatedClasses().length; i++ ) {\n\t\t\t\tpui.applyManagedClassNames( jpa.annotatedClasses()[i].getName() );\n\t\t\t}\n\t\t}\n\n\t\tif ( jpa.xmlMappings().length > 0 ) {\n\t\t\tpui.applyMappingFiles( jpa.xmlMappings() );\n\t\t}\n\n\t\tfor ( StandardDomainModel standardDomainModel : jpa.standardModels() ) {\n\t\t\tfor ( Class<?> annotatedClass : standardDomainModel.getDescriptor().getAnnotatedClasses() ) {\n\t\t\t\tpui.applyManagedClassNames( annotatedClass.getName() );\n\t\t\t}\n\t\t}\n\n\t\tfor ( Class<? extends DomainModelDescriptor> modelDescriptorClass :\n\t\t\t\tjpa.modelDescriptorClasses() ) {\n\t\t\tfinal DomainModelDescriptor domainModelDescriptor =\n\t\t\t\t\tinstantiateDomainModelDescriptor( modelDescriptorClass );\n\t\t\tfinal Class<?>[] annotatedClasses = domainModelDescriptor.getAnnotatedClasses();\n\t\t\tfor ( Class<?> annotatedClass : annotatedClasses ) {\n\t\t\t\tpui.applyManagedClassNames( annotatedClass.getName() );\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate static Map<String, Object> collectIntegrationSettings(Jpa jpa) {\n\t\tfinal Map<String, Object> integrationSettings = new HashMap<>();\n\t\tintegrationSettings.put( PersistentTableStrategy.DROP_ID_TABLES, \"true\" );\n\t\tintegrationSettings.put( GlobalTemporaryTableMutationStrategy.DROP_ID_TABLES, \"true\" );\n\t\tintegrationSettings.put( LocalTemporaryTableMutationStrategy.DROP_ID_TABLES, \"true\" );\n\t\tfinal Setting[] settings = jpa.integrationSettings();\n\t\tfor ( Setting setting : settings ) {\n\t\t\tintegrationSettings.put( setting.name(), setting.value() );\n\t\t}\n\t\tfor ( SettingProvider providerAnn : jpa.settingProviders() ) {\n\t\t\tfinal Class<? extends SettingProvider.Provider<?>> providerImpl = providerAnn.provider();\n\t\t\ttry {\n\t\t\t\tintegrationSettings.put( providerAnn.settingName(),\n\t\t\t\t\t\tproviderImpl.getConstructor().newInstance().getSetting() );\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tlog.error( \"Error obtaining setting provider for \" + providerImpl.getName(), e );\n\t\t\t}\n\t\t}\n\t\treturn integrationSettings;\n\t}\n\n\tprivate static void setupStatementInspector(Jpa jpa, Map<String, Object> integrationSettings) {\n\t\tif ( jpa.useCollectingStatementInspector() ) {\n\t\t\tfinal String inspectorSetting = (String) integrationSettings.get( AvailableSettings.STATEMENT_INSPECTOR );\n\t\t\tif ( inspectorSetting != null && !inspectorSetting.isBlank() ) {\n\t\t\t\tlog.warn( String.format( \"Overriding the explicit \\\"%1s\\\" statement inspector setting\", inspectorSetting ) );\n\t\t\t}\n\t\t\tintegrationSettings.put( AvailableSettings.STATEMENT_INSPECTOR, new SQLStatementInspector() );\n\t\t}\n\t}\n\n\tprivate static void setJpaComplianceProperties(Properties properties, Jpa jpa) {\n\t\tproperties.put( AvailableSettings.JPA_COMPLIANCE, jpa.jpaComplianceEnabled() );\n\t\tproperties.put( AvailableSettings.JPA_QUERY_COMPLIANCE, jpa.queryComplianceEnabled() );\n\t\tproperties.put( AvailableSettings.JPA_TRANSACTION_COMPLIANCE, jpa.transactionComplianceEnabled() );\n\t\tproperties.put( AvailableSettings.JPA_CLOSED_COMPLIANCE, jpa.closedComplianceEnabled() );\n\t\tproperties.put( AvailableSettings.JPA_PROXY_COMPLIANCE, jpa.proxyComplianceEnabled() );\n\t\tproperties.put( AvailableSettings.JPA_CACHING_COMPLIANCE, jpa.cacheComplianceEnabled() );\n\t\tproperties.put( AvailableSettings.JPA_ID_GENERATOR_GLOBAL_SCOPE_COMPLIANCE, jpa.generatorScopeComplianceEnabled() );\n\t\tproperties.put( AvailableSettings.JPA_ORDER_BY_MAPPING_COMPLIANCE, jpa.orderByMappingComplianceEnabled() );\n\t\tproperties.put( AvailableSettings.JPA_LOAD_BY_ID_COMPLIANCE, jpa.loadByIdComplianceEnabled() );\n\t}\n\n\tprivate static DomainModelDescriptor instantiateDomainModelDescriptor(\n\t\t\tClass<? extends DomainModelDescriptor> modelDescriptorClass) {\n\t\t// first, see if it has a static singleton reference and use that if so\n\t\ttry {\n\t\t\tfor ( Field field : modelDescriptorClass.getDeclaredFields() ) {\n\t\t\t\tif ( ReflectHelper.isStaticField(field) ) {\n\t\t\t\t\tfinal Object value = field.get( null );\n\t\t\t\t\tif ( value instanceof DomainModelDescriptor descriptor ) {\n\t\t\t\t\t\treturn descriptor;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (IllegalAccessException e) {\n\t\t\tthrow new RuntimeException( \"Problem accessing DomainModelDescriptor fields : \"\n\t\t\t\t\t+ modelDescriptorClass.getName(), e );\n\t\t}\n\n\t\t// no singleton field, try to instantiate it via reflection\n\t\ttry {\n\t\t\treturn modelDescriptorClass.getConstructor( null ).newInstance( null );\n\t\t}\n\t\tcatch (InstantiationException | IllegalAccessException | InvocationTargetException | NoSuchMethodException e) {\n\t\t\tthrow new RuntimeException( \"Problem instantiation DomainModelDescriptor : \"\n\t\t\t\t\t+ modelDescriptorClass.getName(), e );\n\t\t}\n\t}\n\n\t@Override\n\tpublic void beforeEach(ExtensionContext context) {\n\t\tlog.tracef( \"#beforeEach(%s)\", context.getDisplayName() );\n\t\tfinal Optional<Jpa> optionalJpa = findAnnotation( context.getRequiredTestMethod(), Jpa.class );\n\t\tif ( optionalJpa.isPresent() ) {\n\t\t\tfindEntityManagerFactoryScope( context.getRequiredTestMethod(), optionalJpa, context );\n\t\t}\n\t\t// else assume the annotation is defined on the class-level...\n\t}\n\n\t@Override\n\tpublic void postProcessTestInstance(Object testInstance, ExtensionContext context) {\n\t\tlog.tracef( \"#postProcessTestInstance(%s, %s)\", testInstance, context.getDisplayName() );\n\t\tfinal Optional<Jpa> optionalJpa = findAnnotation( context.getRequiredTestClass(), Jpa.class );\n\t\tfindEntityManagerFactoryScope( testInstance, optionalJpa, context );\n\t}\n\n\t@Override\n\tpublic void handleTestExecutionException(ExtensionContext context, Throwable throwable) throws Throwable {\n\t\tlog.tracef( \"#handleTestExecutionException(%s, %s)\", context.getDisplayName(), throwable );\n\t\ttry {\n\t\t\tfinal ExtensionContext.Store store = locateExtensionStore( context.getRequiredTestInstance(), context );\n\t\t\tfinal EntityManagerFactoryScopeImpl scope = (EntityManagerFactoryScopeImpl) store.get( EMF_KEY );\n\t\t\tscope.releaseEntityManagerFactory();\n\t\t}\n\t\tcatch (Exception ignore) {\n\t\t}\n\t\tthrow throwable;\n\t}\n\n\tprivate static class EntityManagerFactoryScopeImpl extends AbstractEntityManagerFactoryScope {\n\t\tprivate final PersistenceUnitInfo persistenceUnitInfo;\n\t\tprivate final Map<String, Object> integrationSettings;\n\n\t\tprivate EntityManagerFactoryScopeImpl(\n\t\t\t\tPersistenceUnitInfo persistenceUnitInfo,\n\t\t\t\tMap<String, Object> integrationSettings) {\n\t\t\tthis.persistenceUnitInfo = persistenceUnitInfo;\n\t\t\tthis.integrationSettings = integrationSettings;\n\t\t}\n\n\t\tprotected jakarta.persistence.EntityManagerFactory createEntityManagerFactory() {\n\t\t\tfinal PersistenceUnitInfoDescriptor descriptor = new PersistenceUnitInfoDescriptor( persistenceUnitInfo );\n\t\t\treturn getEntityManagerFactoryBuilder( descriptor, integrationSettings ).build();\n\t\t}\n\t}\n}\n",
        "diffSourceCodeSet": [
            "private static PersistenceUnitInfoImpl createPersistenceUnitInfo(Jpa jpa) {\n\t\tfinal PersistenceUnitInfoImpl pui =\n\t\t\t\tnew PersistenceUnitInfoImpl( jpa.persistenceUnitName() );\n\t\tpui.setTransactionType( jpa.transactionType() );\n\t\tpui.setCacheMode( jpa.sharedCacheMode() );\n\t\tpui.setValidationMode( jpa.validationMode() );\n\t\tpui.setExcludeUnlistedClasses( jpa.excludeUnlistedClasses() );\n\t\treturn pui;\n\t}"
        ],
        "invokedMethodSet": [
            "methodSignature: org.hibernate.jpa.boot.internal.ParsedPersistenceXmlDescriptor#setValidationMode\n methodBody: public void setValidationMode(String validationMode) {\nsetValidationMode(ValidationMode.valueOf(validationMode));\n}",
            "methodSignature: org.hibernate.testing.junit4.BaseNonConfigCoreFunctionalTestCase#getAnnotatedClasses\n methodBody: protected Class[] getAnnotatedClasses() {\nreturn NO_CLASSES;\n}",
            "methodSignature: org.hibernate.jpa.boot.internal.PersistenceUnitInfoDescriptor#getName\n methodBody: public String getName() {\nreturn persistenceUnitInfo.getPersistenceUnitName();\n}",
            "methodSignature: org.hibernate.testing.orm.jpa.PersistenceUnitInfoImpl#setTransactionType\n methodBody: public void setTransactionType(PersistenceUnitTransactionType transactionType) {\nthis.transactionType=transactionType;\n}",
            "methodSignature: org.hibernate.testing.orm.junit.EntityManagerFactoryBasedFunctionalTest#applySettings\n methodBody: protected void applySettings(Map<Object, Object> settings) {\nString[] mappings=getMappings();\nif(mappings != null){settings.put(AvailableSettings.HBM_XML_FILES,String.join(\",\",mappings));\n}}",
            "methodSignature: org.hibernate.testing.orm.jpa.PersistenceUnitInfoImpl#setValidationMode\n methodBody: public void setValidationMode(ValidationMode validationMode) {\nthis.validationMode=validationMode;\n}",
            "methodSignature: org.hibernate.collection.spi.AbstractPersistentCollection.SetProxy#isEmpty\n methodBody: public boolean isEmpty() {\nreturn set.isEmpty();\n}",
            "methodSignature: org.hibernate.testing.orm.jpa.PersistenceUnitInfoImpl#applyMappingFiles\n methodBody: public void applyMappingFiles(String... mappingFiles) {\nif(this.mappingFiles == null){this.mappingFiles=new ArrayList<>();\n}Collections.addAll(this.mappingFiles,mappingFiles);\n}",
            "methodSignature: org.hibernate.testing.util.jpa.DelegatingPersistenceUnitInfo#getProperties\n methodBody: public Properties getProperties() {\nreturn delegate.getProperties();\n}",
            "methodSignature: org.hibernate.orm.test.exceptionhandling.BaseJpaOrNativeBootstrapFunctionalTestCase.TestingPersistenceUnitDescriptorImpl#getName\n methodBody: public String getName() {\nreturn name;\n}",
            "methodSignature: org.hibernate.collection.spi.PersistentList#get\n methodBody: public E get(int index) {\nif(index < 0){throw new ArrayIndexOutOfBoundsException(\"negative index\");\n}final Object result=readElementByIndex(index);\nreturn result == UNKNOWN ? list.get(index) : (E)result;\n}",
            "methodSignature: org.hibernate.orm.test.bootstrap.BootstrapTest.PersistenceUnitInfoImpl#getProperties\n methodBody: public Properties getProperties() {\nreturn properties;\n}",
            "methodSignature: org.hibernate.testing.orm.junit.EntityManagerFactoryBasedFunctionalTest.TestingPersistenceUnitDescriptorImpl#getName\n methodBody: public String getName() {\nreturn name;\n}",
            "methodSignature: org.hibernate.jpa.boot.spi.PersistenceConfigurationDescriptor#getName\n methodBody: public String getName() {\nreturn persistenceConfiguration.name();\n}",
            "methodSignature: org.hibernate.jpa.boot.internal.PersistenceUnitInfoDescriptor#getProperties\n methodBody: public Properties getProperties() {\nreturn persistenceUnitInfo.getProperties();\n}",
            "methodSignature: org.hibernate.jpa.boot.spi.PersistenceUnitDescriptor#getProperties\n methodBody: Properties getProperties();",
            "methodSignature: org.hibernate.testing.orm.junit.BaseSessionFactoryFunctionalTest#getAnnotatedClasses\n methodBody: protected Class[] getAnnotatedClasses() {\nreturn NO_CLASSES;\n}",
            "methodSignature: org.hibernate.testing.orm.junit.BaseSessionFactoryFunctionalTest#applySettings\n methodBody: protected void applySettings(StandardServiceRegistryBuilder builder) {\n}",
            "methodSignature: org.hibernate.testing.orm.jpa.PersistenceUnitInfoAdapter#getProperties\n methodBody: public Properties getProperties() {\nif(properties == null){properties=new Properties();\n}return properties;\n}",
            "methodSignature: org.hibernate.testing.util.jpa.DelegatingPersistenceUnitInfo#excludeUnlistedClasses\n methodBody: public boolean excludeUnlistedClasses() {\nreturn delegate.excludeUnlistedClasses();\n}",
            "methodSignature: org.hibernate.testing.util.jpa.PersistenceUnitInfoAdapter#getProperties\n methodBody: public Properties getProperties() {\nreturn properties;\n}",
            "methodSignature: org.hibernate.testing.orm.jpa.PersistenceUnitInfoImpl#setCacheMode\n methodBody: public void setCacheMode(SharedCacheMode cacheMode) {\nthis.cacheMode=cacheMode;\n}",
            "methodSignature: org.hibernate.jpa.boot.internal.ParsedPersistenceXmlDescriptor#getName\n methodBody: public String getName() {\nreturn name;\n}",
            "methodSignature: org.hibernate.orm.test.jpa.BaseEntityManagerFunctionalTestCase.TestingPersistenceUnitDescriptorImpl#getName\n methodBody: public String getName() {\nreturn name;\n}",
            "methodSignature: org.hibernate.testing.orm.jpa.PersistenceUnitInfoImpl#excludeUnlistedClasses\n methodBody: public boolean excludeUnlistedClasses() {\nreturn excludeUnlistedClasses;\n}",
            "methodSignature: org.hibernate.testing.orm.junit.EntityManagerFactoryBasedFunctionalTest#getAnnotatedClasses\n methodBody: protected Class<?>[] getAnnotatedClasses() {\nreturn NO_CLASSES;\n}",
            "methodSignature: org.hibernate.collection.spi.AbstractPersistentCollection.ListProxy#get\n methodBody: public E get(int i) {\nreturn list.get(i);\n}",
            "methodSignature: org.hibernate.testing.util.jpa.PersistenceUnitInfoAdapter#excludeUnlistedClasses\n methodBody: public boolean excludeUnlistedClasses() {\nreturn false;\n}",
            "methodSignature: org.hibernate.orm.test.exceptionhandling.BaseJpaOrNativeBootstrapFunctionalTestCase#getAnnotatedClasses\n methodBody: protected Class<?>[] getAnnotatedClasses() {\nreturn NO_CLASSES;\n}",
            "methodSignature: org.hibernate.orm.test.bootstrap.BootstrapTest.PersistenceUnitInfoImpl#excludeUnlistedClasses\n methodBody: public boolean excludeUnlistedClasses() {\nreturn false;\n}",
            "methodSignature: org.hibernate.jpa.boot.spi.PersistenceConfigurationDescriptor#getProperties\n methodBody: public Properties getProperties() {\nreturn properties;\n}",
            "methodSignature: org.hibernate.testing.orm.jpa.PersistenceUnitDescriptorAdapter#getProperties\n methodBody: public Properties getProperties() {\nif(properties == null){properties=new Properties();\n}return properties;\n}",
            "methodSignature: org.hibernate.collection.spi.PersistentBag#get\n methodBody: public E get(int i) {\nread();\nreturn bag.get(i);\n}",
            "methodSignature: org.hibernate.testing.orm.jpa.PersistenceUnitInfoAdapter#excludeUnlistedClasses\n methodBody: public boolean excludeUnlistedClasses() {\nreturn false;\n}",
            "methodSignature: org.hibernate.testing.orm.jpa.PersistenceUnitInfoImpl#setExcludeUnlistedClasses\n methodBody: public void setExcludeUnlistedClasses(boolean excludeUnlistedClasses) {\nthis.excludeUnlistedClasses=excludeUnlistedClasses;\n}",
            "methodSignature: org.hibernate.collection.spi.PersistentList#toString\n methodBody: public String toString() {\nread();\nreturn list.toString();\n}",
            "methodSignature: org.hibernate.testing.junit4.BaseCoreFunctionalTestCase#getAnnotatedClasses\n methodBody: protected Class<?>[] getAnnotatedClasses() {\nreturn NO_CLASSES;\n}",
            "methodSignature: org.hibernate.collection.spi.PersistentBag#getElement\n methodBody: public Object getElement(Object entry) {\nreturn entry;\n}",
            "methodSignature: org.hibernate.collection.spi.PersistentBag#isEmpty\n methodBody: public boolean isEmpty() {\nreturn readSize() ? getCachedSize() == 0 : bag.isEmpty();\n}",
            "methodSignature: org.hibernate.orm.test.jpa.xml.versions.JpaXsdVersionsTest.PersistenceUnitInfoImpl#getProperties\n methodBody: public Properties getProperties() {\nreturn properties;\n}",
            "methodSignature: org.hibernate.jpa.boot.internal.ParsedPersistenceXmlDescriptor#setTransactionType\n methodBody: public void setTransactionType(PersistenceUnitTransactionType transactionType) {\nthis.transactionType=transactionType;\n}",
            "methodSignature: org.hibernate.orm.test.jpa.EntityManagerTest#getAnnotatedClasses\n methodBody: public Class[] getAnnotatedClasses() {\nreturn new Class[]{Item.class,Distributor.class,Wallet.class};\n}",
            "methodSignature: org.hibernate.orm.test.jpa.BaseEntityManagerFunctionalTestCase#getAnnotatedClasses\n methodBody: protected Class<?>[] getAnnotatedClasses() {\nreturn NO_CLASSES;\n}",
            "methodSignature: org.hibernate.testing.orm.junit.EntityManagerFactoryBasedFunctionalTest#exportSchema\n methodBody: protected boolean exportSchema() {\nreturn true;\n}",
            "methodSignature: org.hibernate.jpa.boot.internal.ParsedPersistenceXmlDescriptor#getProperties\n methodBody: public Properties getProperties() {\nreturn properties;\n}",
            "methodSignature: org.hibernate.internal.SessionFactoryImpl#getProperties\n methodBody: public Map<String, Object> getProperties() {\nvalidateNotClosed();\nreturn settings;\n}",
            "methodSignature: org.hibernate.testing.util.jpa.PersistenceUnitInfoPropertiesWrapper#excludeUnlistedClasses\n methodBody: public boolean excludeUnlistedClasses() {\nreturn false;\n}",
            "methodSignature: org.hibernate.orm.test.jpa.xml.versions.JpaXsdVersionsTest.PersistenceUnitInfoImpl#excludeUnlistedClasses\n methodBody: public boolean excludeUnlistedClasses() {\nreturn false;\n}",
            "methodSignature: org.hibernate.jpa.boot.spi.PersistenceUnitDescriptor#getName\n methodBody: String getName();",
            "methodSignature: org.hibernate.orm.test.exceptionhandling.BaseJpaOrNativeBootstrapFunctionalTestCase.TestingPersistenceUnitDescriptorImpl#getProperties\n methodBody: public Properties getProperties() {\nreturn null;\n}",
            "methodSignature: org.hibernate.testing.orm.jpa.PersistenceUnitDescriptorAdapter#getName\n methodBody: public String getName() {\nreturn name;\n}",
            "methodSignature: org.hibernate.testing.orm.junit.EntityManagerFactoryExtension#locateExtensionStore\n methodBody: private static ExtensionContext.Store locateExtensionStore(Object testScope, ExtensionContext context) {\nreturn JUnitHelper.locateExtensionStore(EntityManagerFactoryExtension.class,context,testScope);\n}",
            "methodSignature: org.hibernate.jpa.boot.internal.ParsedPersistenceXmlDescriptor#setExcludeUnlistedClasses\n methodBody: public void setExcludeUnlistedClasses(boolean excludeUnlistedClasses) {\nthis.excludeUnlistedClasses=excludeUnlistedClasses;\n}",
            "methodSignature: org.hibernate.testing.orm.jpa.PersistenceUnitInfoImpl#applyManagedClassNames\n methodBody: public void applyManagedClassNames(String... managedClassNames) {\nif(this.managedClassNames == null){this.managedClassNames=new ArrayList<>();\n}Collections.addAll(this.managedClassNames,managedClassNames);\n}",
            "methodSignature: org.hibernate.testing.util.jpa.PersistenceUnitInfoPropertiesWrapper#getProperties\n methodBody: public Properties getProperties() {\nif(properties == null){properties=new Properties();\n}return properties;\n}",
            "methodSignature: org.hibernate.collection.spi.PersistentList#getElement\n methodBody: public Object getElement(Object entry) {\nreturn entry;\n}",
            "methodSignature: org.hibernate.orm.test.jpa.BaseEntityManagerFunctionalTestCase.TestingPersistenceUnitDescriptorImpl#getProperties\n methodBody: public Properties getProperties() {\nreturn null;\n}",
            "methodSignature: org.hibernate.internal.SessionFactoryImpl#getName\n methodBody: public String getName() {\nreturn name;\n}",
            "methodSignature: org.hibernate.testing.orm.junit.EntityManagerFactoryBasedFunctionalTest.TestingPersistenceUnitDescriptorImpl#getProperties\n methodBody: public Properties getProperties() {\nreturn null;\n}",
            "methodSignature: org.hibernate.collection.spi.PersistentList#isEmpty\n methodBody: public boolean isEmpty() {\nreturn readSize() ? getCachedSize() == 0 : list.isEmpty();\n}",
            "methodSignature: org.hibernate.testing.orm.jpa.PersistenceUnitInfoImpl#getProperties\n methodBody: public Properties getProperties() {\nreturn properties;\n}",
            "methodSignature: org.hibernate.testing.orm.junit.EntityManagerFactoryExtension#instantiateDomainModelDescriptor\n methodBody: private static DomainModelDescriptor instantiateDomainModelDescriptor(Class<? extends DomainModelDescriptor> modelDescriptorClass) {\ntryfinal Field[] declaredFields=modelDescriptorClass.getDeclaredFields();\nfor(int i=0; i < declaredFields.length; i++){final Field field=declaredFields[i];\nif(ReflectHelper.isStaticField(field)){final Object value=field.get(null);\nif(value instanceof DomainModelDescriptor){return (DomainModelDescriptor)value;\n}}}catch(IllegalAccessException e)throw new RuntimeException(\"Problem accessing DomainModelDescriptor fields : \" + modelDescriptorClass.getName(),e);\ntryreturn modelDescriptorClass.getConstructor(null).newInstance(null);\ncatch(InstantiationException|IllegalAccessException|InvocationTargetException|NoSuchMethodException e)throw new RuntimeException(\"Problem instantiation DomainModelDescriptor : \" + modelDescriptorClass.getName(),e);\n}",
            "methodSignature: org.hibernate.testing.orm.junit.BaseSessionFactoryFunctionalTest#exportSchema\n methodBody: protected boolean exportSchema() {\nreturn true;\n}",
            "methodSignature: org.hibernate.collection.spi.AbstractPersistentCollection.ListProxy#isEmpty\n methodBody: public boolean isEmpty() {\nreturn list.isEmpty();\n}",
            "methodSignature: org.hibernate.collection.spi.PersistentBag#toString\n methodBody: public String toString() {\nread();\nreturn bag.toString();\n}"
        ],
        "sourceCodeAfterRefactoring": "public static EntityManagerFactoryScope findEntityManagerFactoryScope(\n\t\t\tObject testScope, Optional<Jpa> optionalJpa, ExtensionContext context) {\n\n\t\tif ( optionalJpa.isEmpty() ) {\n\t\t\t// No annotation on the test class, should be on the test methods\n\t\t\treturn null;\n\t\t}\n\n\t\tfinal ExtensionContext.Store store = locateExtensionStore( testScope, context );\n\t\tfinal EntityManagerFactoryScope existing = (EntityManagerFactoryScope) store.get( EMF_KEY );\n\t\tif ( existing != null ) {\n\t\t\treturn existing;\n\t\t}\n\t\tif ( context.getElement().isEmpty() ) {\n\t\t\tthrow new RuntimeException( \"Unable to determine how to handle given ExtensionContext : \"\n\t\t\t\t\t+ context.getDisplayName() );\n\t\t}\n\n\t\tfinal Jpa jpa = optionalJpa.get();\n\t\tfinal PersistenceUnitInfoImpl pui = createPersistenceUnitInfo( jpa );\n\t\tcollectProperties( pui, jpa );\n\t\tmanagedClassesAndMappings( jpa, pui );\n\t\tfinal Map<String, Object> integrationSettings = collectIntegrationSettings( jpa );\n\t\t// statement inspector\n\t\tsetupStatementInspector( jpa, integrationSettings );\n\t\tServiceRegistryUtil.applySettings( integrationSettings );\n\t\tfinal EntityManagerFactoryScopeImpl scope =\n\t\t\t\tnew EntityManagerFactoryScopeImpl( pui, integrationSettings );\n\t\tstore.put( EMF_KEY, scope );\n\t\treturn scope;\n\t}\nprivate static PersistenceUnitInfoImpl createPersistenceUnitInfo(Jpa jpa) {\n\t\tfinal PersistenceUnitInfoImpl pui =\n\t\t\t\tnew PersistenceUnitInfoImpl( jpa.persistenceUnitName() );\n\t\tpui.setTransactionType( jpa.transactionType() );\n\t\tpui.setCacheMode( jpa.sharedCacheMode() );\n\t\tpui.setValidationMode( jpa.validationMode() );\n\t\tpui.setExcludeUnlistedClasses( jpa.excludeUnlistedClasses() );\n\t\treturn pui;\n\t}",
        "diffSourceCode": "-   61: \n-   62: \tprivate static ExtensionContext.Store locateExtensionStore(Object testScope, ExtensionContext context) {\n-   63: \t\treturn JUnitHelper.locateExtensionStore( EntityManagerFactoryExtension.class, context, testScope );\n-   64: \t}\n-   65: \n-   66: \tpublic static EntityManagerFactoryScope findEntityManagerFactoryScope(\n-   67: \t\t\tObject testScope,\n-   68: \t\t\tOptional<Jpa> emfAnnWrapper,\n-   69: \t\t\tExtensionContext context) {\n-   70: \n-   71: \t\tif ( emfAnnWrapper.isEmpty() ) {\n-   72: \t\t\t// No annotation on the test class, should be on the test methods\n-   73: \t\t\treturn null;\n-   74: \t\t}\n-   75: \n-   76: \t\tfinal ExtensionContext.Store store = locateExtensionStore( testScope, context );\n-   77: \t\tfinal EntityManagerFactoryScope existing = (EntityManagerFactoryScope) store.get( EMF_KEY );\n-   78: \t\tif ( existing != null ) {\n-   79: \t\t\treturn existing;\n-   80: \t\t}\n-   81: \n-   82: \t\tif ( !context.getElement().isPresent() ) {\n-   83: \t\t\tthrow new RuntimeException( \"Unable to determine how to handle given ExtensionContext : \" + context.getDisplayName() );\n-   84: \t\t}\n-   85: \t\tfinal Jpa emfAnn = emfAnnWrapper.get();\n-   86: \n-   87: \t\tfinal PersistenceUnitInfoImpl pui = new PersistenceUnitInfoImpl( emfAnn.persistenceUnitName() );\n-   88: \t\t( (Map<Object, Object>) Environment.getProperties() ).forEach(\n-   89: \t\t\t\t(key, value) ->\n-   90: \t\t\t\t\t\tpui.getProperties().put( key, value )\n-   91: \t\t);\n+   61: \tpublic static EntityManagerFactoryScope findEntityManagerFactoryScope(\n+   62: \t\t\tObject testScope, Optional<Jpa> optionalJpa, ExtensionContext context) {\n+   63: \n+   64: \t\tif ( optionalJpa.isEmpty() ) {\n+   65: \t\t\t// No annotation on the test class, should be on the test methods\n+   66: \t\t\treturn null;\n+   67: \t\t}\n+   68: \n+   69: \t\tfinal ExtensionContext.Store store = locateExtensionStore( testScope, context );\n+   70: \t\tfinal EntityManagerFactoryScope existing = (EntityManagerFactoryScope) store.get( EMF_KEY );\n+   71: \t\tif ( existing != null ) {\n+   72: \t\t\treturn existing;\n+   73: \t\t}\n+   74: \t\tif ( context.getElement().isEmpty() ) {\n+   75: \t\t\tthrow new RuntimeException( \"Unable to determine how to handle given ExtensionContext : \"\n+   76: \t\t\t\t\t+ context.getDisplayName() );\n+   77: \t\t}\n+   78: \n+   79: \t\tfinal Jpa jpa = optionalJpa.get();\n+   80: \t\tfinal PersistenceUnitInfoImpl pui = createPersistenceUnitInfo( jpa );\n+   81: \t\tcollectProperties( pui, jpa );\n+   82: \t\tmanagedClassesAndMappings( jpa, pui );\n+   83: \t\tfinal Map<String, Object> integrationSettings = collectIntegrationSettings( jpa );\n+   84: \t\t// statement inspector\n+   85: \t\tsetupStatementInspector( jpa, integrationSettings );\n+   86: \t\tServiceRegistryUtil.applySettings( integrationSettings );\n+   87: \t\tfinal EntityManagerFactoryScopeImpl scope =\n+   88: \t\t\t\tnew EntityManagerFactoryScopeImpl( pui, integrationSettings );\n+   89: \t\tstore.put( EMF_KEY, scope );\n+   90: \t\treturn scope;\n+   91: \t}\n    92: \n-   93: \t\tpui.setTransactionType( emfAnn.transactionType() );\n-   94: \t\tpui.setCacheMode( emfAnn.sharedCacheMode() );\n-   95: \t\tpui.setValidationMode( emfAnn.validationMode() );\n-   96: \t\tpui.setExcludeUnlistedClasses( emfAnn.excludeUnlistedClasses() );\n-   97: \n-   98: \t\t// JpaCompliance\n-   99: \t\tpui.getProperties().put( AvailableSettings.JPA_COMPLIANCE, emfAnn.jpaComplianceEnabled() );\n-  100: \t\tpui.getProperties().put( AvailableSettings.JPA_QUERY_COMPLIANCE, emfAnn.queryComplianceEnabled() );\n-  101: \t\tpui.getProperties().put( AvailableSettings.JPA_TRANSACTION_COMPLIANCE, emfAnn.transactionComplianceEnabled() );\n-  102: \t\tpui.getProperties().put( AvailableSettings.JPA_CLOSED_COMPLIANCE, emfAnn.closedComplianceEnabled() );\n-  103: \t\tpui.getProperties().put( AvailableSettings.JPA_PROXY_COMPLIANCE, emfAnn.proxyComplianceEnabled() );\n-  104: \t\tpui.getProperties().put( AvailableSettings.JPA_CACHING_COMPLIANCE, emfAnn.cacheComplianceEnabled() );\n-  105: \t\tpui.getProperties().put( AvailableSettings.JPA_ID_GENERATOR_GLOBAL_SCOPE_COMPLIANCE, emfAnn.generatorScopeComplianceEnabled() );\n-  106: \t\tpui.getProperties().put( AvailableSettings.JPA_ORDER_BY_MAPPING_COMPLIANCE, emfAnn.orderByMappingComplianceEnabled() );\n-  107: \t\tpui.getProperties().put( AvailableSettings.JPA_LOAD_BY_ID_COMPLIANCE, emfAnn.loadByIdComplianceEnabled() );\n-  108: \n-  109: \t\tfinal Setting[] properties = emfAnn.properties();\n-  110: \t\tfor ( int i = 0; i < properties.length; i++ ) {\n-  111: \t\t\tfinal Setting property = properties[i];\n-  112: \t\t\tpui.getProperties().setProperty( property.name(), property.value() );\n-  113: \t\t}\n-  114: \n-  115: \t\tpui.getProperties().setProperty(\n-  116: \t\t\t\tAvailableSettings.GENERATE_STATISTICS,\n-  117: \t\t\t\tBoolean.toString( emfAnn.generateStatistics() )\n-  118: \t\t);\n-  119: \n-  120: \t\tif ( emfAnn.exportSchema() ) {\n-  121: \t\t\tpui.getProperties().setProperty(\n-  122: \t\t\t\t\tAvailableSettings.JAKARTA_HBM2DDL_DATABASE_ACTION,\n-  123: \t\t\t\t\tAction.CREATE_DROP.getExternalHbm2ddlName()\n-  124: \t\t\t);\n-  125: \t\t}\n-  126: \n-  127: \t\tif ( emfAnn.annotatedPackageNames().length > 0 ) {\n-  128: \t\t\tpui.applyManagedClassNames( emfAnn.annotatedPackageNames() );\n-  129: \t\t}\n-  130: \n-  131: \t\tif ( emfAnn.annotatedClassNames().length > 0 ) {\n-  132: \t\t\tpui.applyManagedClassNames( emfAnn.annotatedClassNames() );\n-  133: \t\t}\n-  134: \n-  135: \t\tif ( emfAnn.annotatedClasses().length > 0 ) {\n-  136: \t\t\tfor ( int i = 0; i < emfAnn.annotatedClasses().length; i++ ) {\n-  137: \t\t\t\tpui.applyManagedClassNames( emfAnn.annotatedClasses()[i].getName() );\n-  138: \t\t\t}\n-  139: \t\t}\n-  140: \n-  141: \t\tif ( emfAnn.xmlMappings().length > 0 ) {\n-  142: \t\t\tpui.applyMappingFiles( emfAnn.xmlMappings() );\n-  143: \t\t}\n-  144: \n-  145: \t\tif ( emfAnn.standardModels().length > 0 ) {\n-  146: \t\t\tfor ( int i = 0; i < emfAnn.standardModels().length; i++ ) {\n-  147: \t\t\t\tfinal StandardDomainModel standardDomainModel = emfAnn.standardModels()[i];\n-  148: \t\t\t\tfor ( int i1 = 0; i1 < standardDomainModel.getDescriptor().getAnnotatedClasses().length; i1++ ) {\n-  149: \t\t\t\t\tfinal Class<?> annotatedClass = standardDomainModel.getDescriptor().getAnnotatedClasses()[i1];\n-  150: \t\t\t\t\tpui.applyManagedClassNames( annotatedClass.getName() );\n-  151: \t\t\t\t}\n-  152: \t\t\t}\n-  153: \t\t}\n-  154: \n-  155: \t\tif ( emfAnn.modelDescriptorClasses().length > 0 ) {\n-  156: \t\t\tfor ( int i = 0; i < emfAnn.modelDescriptorClasses().length; i++ ) {\n-  157: \t\t\t\tfinal Class<? extends DomainModelDescriptor> modelDescriptorClass = emfAnn.modelDescriptorClasses()[i];\n-  158: \t\t\t\tfinal DomainModelDescriptor domainModelDescriptor = instantiateDomainModelDescriptor(\n-  159: \t\t\t\t\t\tmodelDescriptorClass );\n-  160: \t\t\t\tfor ( int i1 = 0; i1 < domainModelDescriptor.getAnnotatedClasses().length; i1++ ) {\n-  161: \t\t\t\t\tfinal Class<?> annotatedClass = domainModelDescriptor.getAnnotatedClasses()[i1];\n-  162: \t\t\t\t\tpui.applyManagedClassNames( annotatedClass.getName() );\n-  163: \t\t\t\t}\n-  164: \t\t\t}\n-  165: \t\t}\n-  166: \n-  167: \t\tfinal Map<String, Object> integrationSettings = new HashMap<>();\n-  168: \n-  169: \t\tintegrationSettings.put( PersistentTableStrategy.DROP_ID_TABLES, \"true\" );\n-  170: \t\tintegrationSettings.put( GlobalTemporaryTableMutationStrategy.DROP_ID_TABLES, \"true\" );\n-  171: \t\tintegrationSettings.put( LocalTemporaryTableMutationStrategy.DROP_ID_TABLES, \"true\" );\n-  172: \t\tfor ( int i = 0; i < emfAnn.integrationSettings().length; i++ ) {\n-  173: \t\t\tfinal Setting setting = emfAnn.integrationSettings()[i];\n-  174: \t\t\tintegrationSettings.put( setting.name(), setting.value() );\n-  175: \t\t}\n-  176: \n-  177: \t\tfor ( SettingProvider providerAnn : emfAnn.settingProviders() ) {\n-  178: \t\t\tfinal Class<? extends SettingProvider.Provider<?>> providerImpl = providerAnn.provider();\n-  179: \t\t\ttry {\n-  180: \t\t\t\tfinal SettingProvider.Provider<?> provider = providerImpl.getConstructor().newInstance();\n-  181: \t\t\t\tintegrationSettings.put( providerAnn.settingName(), provider.getSetting() );\n-  182: \t\t\t}\n-  183: \t\t\tcatch (Exception e) {\n-  184: \t\t\t\tlog.error( \"Error obtaining setting provider for \" + providerImpl.getName(), e );\n-  185: \t\t\t}\n-  186: \t\t}\n-  187: \n-  188: \t\t// statement inspector\n-  189: \t\tif ( emfAnn.useCollectingStatementInspector() ) {\n-  190: \t\t\tString inspectorSetting = (String) integrationSettings.get( AvailableSettings.STATEMENT_INSPECTOR );\n-  191: \t\t\tif ( !(inspectorSetting == null || inspectorSetting.isBlank()) ) {\n-  192: \t\t\t\tlog.warn( String.format( \"Overriding the explicit \\\"%1s\\\" statement inspector setting\", inspectorSetting ) );\n-  193: \t\t\t}\n-  194: \t\t\tintegrationSettings.put( AvailableSettings.STATEMENT_INSPECTOR, new SQLStatementInspector() );\n-  195: \t\t}\n-  196: \n-  197: \t\tServiceRegistryUtil.applySettings( integrationSettings );\n-  198: \t\tfinal EntityManagerFactoryScopeImpl scope = new EntityManagerFactoryScopeImpl( pui, integrationSettings );\n-  199: \n-  200: \t\tstore.put( EMF_KEY, scope );\n-  201: \n-  202: \t\treturn scope;\n-  203: \t}\n+   93: \tprivate static void collectProperties(PersistenceUnitInfoImpl pui, Jpa jpa) {\n+   94: \t\tfinal Properties properties = pui.getProperties();\n+   95: \t\tproperties.putAll( Environment.getProperties() );\n+   96: \t\t// JpaCompliance\n+   97: \t\tsetJpaComplianceProperties( properties, jpa );\n+   98: \t\tfor ( Setting property : jpa.properties() ) {\n+   99: \t\t\tproperties.setProperty( property.name(), property.value() );\n+  100: \t\t}\n+  101: \t\tproperties.setProperty(\n+  102: \t\t\t\tAvailableSettings.GENERATE_STATISTICS,\n+  103: \t\t\t\tBoolean.toString( jpa.generateStatistics() )\n+  104: \t\t);\n+  105: \t\tif ( jpa.exportSchema() ) {\n+  106: \t\t\tproperties.setProperty(\n+  107: \t\t\t\t\tAvailableSettings.JAKARTA_HBM2DDL_DATABASE_ACTION,\n+  108: \t\t\t\t\tAction.CREATE_DROP.getExternalHbm2ddlName()\n+  109: \t\t\t);\n+  110: \t\t}\n+  111: \t}\n+  112: \n+  113: \tprivate static PersistenceUnitInfoImpl createPersistenceUnitInfo(Jpa jpa) {\n+  114: \t\tfinal PersistenceUnitInfoImpl pui =\n+  115: \t\t\t\tnew PersistenceUnitInfoImpl( jpa.persistenceUnitName() );\n+  116: \t\tpui.setTransactionType( jpa.transactionType() );\n+  117: \t\tpui.setCacheMode( jpa.sharedCacheMode() );\n+  118: \t\tpui.setValidationMode( jpa.validationMode() );\n+  119: \t\tpui.setExcludeUnlistedClasses( jpa.excludeUnlistedClasses() );\n+  120: \t\treturn pui;\n+  121: \t}\n+  122: \n+  123: \tprivate static void managedClassesAndMappings(Jpa jpa, PersistenceUnitInfoImpl pui) {\n+  124: \t\tif ( jpa.annotatedPackageNames().length > 0 ) {\n+  125: \t\t\tpui.applyManagedClassNames( jpa.annotatedPackageNames() );\n+  126: \t\t}\n+  127: \n+  128: \t\tif ( jpa.annotatedClassNames().length > 0 ) {\n+  129: \t\t\tpui.applyManagedClassNames( jpa.annotatedClassNames() );\n+  130: \t\t}\n+  131: \n+  132: \t\tif ( jpa.annotatedClasses().length > 0 ) {\n+  133: \t\t\tfor (int i = 0; i < jpa.annotatedClasses().length; i++ ) {\n+  134: \t\t\t\tpui.applyManagedClassNames( jpa.annotatedClasses()[i].getName() );\n+  135: \t\t\t}\n+  136: \t\t}\n+  137: \n+  138: \t\tif ( jpa.xmlMappings().length > 0 ) {\n+  139: \t\t\tpui.applyMappingFiles( jpa.xmlMappings() );\n+  140: \t\t}\n+  141: \n+  142: \t\tfor ( StandardDomainModel standardDomainModel : jpa.standardModels() ) {\n+  143: \t\t\tfor ( Class<?> annotatedClass : standardDomainModel.getDescriptor().getAnnotatedClasses() ) {\n+  144: \t\t\t\tpui.applyManagedClassNames( annotatedClass.getName() );\n+  145: \t\t\t}\n+  146: \t\t}\n+  147: \n+  148: \t\tfor ( Class<? extends DomainModelDescriptor> modelDescriptorClass :\n+  149: \t\t\t\tjpa.modelDescriptorClasses() ) {\n+  150: \t\t\tfinal DomainModelDescriptor domainModelDescriptor =\n+  151: \t\t\t\t\tinstantiateDomainModelDescriptor( modelDescriptorClass );\n+  152: \t\t\tfinal Class<?>[] annotatedClasses = domainModelDescriptor.getAnnotatedClasses();\n+  153: \t\t\tfor ( Class<?> annotatedClass : annotatedClasses ) {\n+  154: \t\t\t\tpui.applyManagedClassNames( annotatedClass.getName() );\n+  155: \t\t\t}\n+  156: \t\t}\n+  157: \t}\n+  158: \n+  159: \tprivate static Map<String, Object> collectIntegrationSettings(Jpa jpa) {\n+  160: \t\tfinal Map<String, Object> integrationSettings = new HashMap<>();\n+  161: \t\tintegrationSettings.put( PersistentTableStrategy.DROP_ID_TABLES, \"true\" );\n+  162: \t\tintegrationSettings.put( GlobalTemporaryTableMutationStrategy.DROP_ID_TABLES, \"true\" );\n+  163: \t\tintegrationSettings.put( LocalTemporaryTableMutationStrategy.DROP_ID_TABLES, \"true\" );\n+  164: \t\tfinal Setting[] settings = jpa.integrationSettings();\n+  165: \t\tfor ( Setting setting : settings ) {\n+  166: \t\t\tintegrationSettings.put( setting.name(), setting.value() );\n+  167: \t\t}\n+  168: \t\tfor ( SettingProvider providerAnn : jpa.settingProviders() ) {\n+  169: \t\t\tfinal Class<? extends SettingProvider.Provider<?>> providerImpl = providerAnn.provider();\n+  170: \t\t\ttry {\n+  171: \t\t\t\tintegrationSettings.put( providerAnn.settingName(),\n+  172: \t\t\t\t\t\tproviderImpl.getConstructor().newInstance().getSetting() );\n+  173: \t\t\t}\n+  174: \t\t\tcatch (Exception e) {\n+  175: \t\t\t\tlog.error( \"Error obtaining setting provider for \" + providerImpl.getName(), e );\n+  176: \t\t\t}\n+  177: \t\t}\n+  178: \t\treturn integrationSettings;\n+  179: \t}\n+  180: \n+  181: \tprivate static void setupStatementInspector(Jpa jpa, Map<String, Object> integrationSettings) {\n+  182: \t\tif ( jpa.useCollectingStatementInspector() ) {\n+  183: \t\t\tfinal String inspectorSetting = (String) integrationSettings.get( AvailableSettings.STATEMENT_INSPECTOR );\n+  184: \t\t\tif ( inspectorSetting != null && !inspectorSetting.isBlank() ) {\n+  185: \t\t\t\tlog.warn( String.format( \"Overriding the explicit \\\"%1s\\\" statement inspector setting\", inspectorSetting ) );\n+  186: \t\t\t}\n+  187: \t\t\tintegrationSettings.put( AvailableSettings.STATEMENT_INSPECTOR, new SQLStatementInspector() );\n+  188: \t\t}\n+  189: \t}\n+  190: \n+  191: \tprivate static void setJpaComplianceProperties(Properties properties, Jpa jpa) {\n+  192: \t\tproperties.put( AvailableSettings.JPA_COMPLIANCE, jpa.jpaComplianceEnabled() );\n+  193: \t\tproperties.put( AvailableSettings.JPA_QUERY_COMPLIANCE, jpa.queryComplianceEnabled() );\n+  194: \t\tproperties.put( AvailableSettings.JPA_TRANSACTION_COMPLIANCE, jpa.transactionComplianceEnabled() );\n+  195: \t\tproperties.put( AvailableSettings.JPA_CLOSED_COMPLIANCE, jpa.closedComplianceEnabled() );\n+  196: \t\tproperties.put( AvailableSettings.JPA_PROXY_COMPLIANCE, jpa.proxyComplianceEnabled() );\n+  197: \t\tproperties.put( AvailableSettings.JPA_CACHING_COMPLIANCE, jpa.cacheComplianceEnabled() );\n+  198: \t\tproperties.put( AvailableSettings.JPA_ID_GENERATOR_GLOBAL_SCOPE_COMPLIANCE, jpa.generatorScopeComplianceEnabled() );\n+  199: \t\tproperties.put( AvailableSettings.JPA_ORDER_BY_MAPPING_COMPLIANCE, jpa.orderByMappingComplianceEnabled() );\n+  200: \t\tproperties.put( AvailableSettings.JPA_LOAD_BY_ID_COMPLIANCE, jpa.loadByIdComplianceEnabled() );\n+  201: \t}\n+  202: \n+  203: \tprivate static DomainModelDescriptor instantiateDomainModelDescriptor(\n",
        "uniqueId": "4781c09d0df0eb4ce05b2fa0d2a12747023ae024_66_203_113_121_61_91",
        "moveFileExist": true,
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 21,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 7,
                "covered": 55
            },
            "BRANCH": {
                "missed": 1,
                "covered": 5
            },
            "LINE": {
                "missed": 2,
                "covered": 17
            },
            "COMPLEXITY": {
                "missed": 1,
                "covered": 3
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        }
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprivate setJpaComplianceProperties(properties Properties, jpa Jpa) : void extracted from public findEntityManagerFactoryScope(testScope Object, emfAnnWrapper Optional<Jpa>, context ExtensionContext) : EntityManagerFactoryScope in class org.hibernate.testing.orm.junit.EntityManagerFactoryExtension",
        "diffLocations": [
            {
                "filePath": "hibernate-testing/src/main/java/org/hibernate/testing/orm/junit/EntityManagerFactoryExtension.java",
                "startLine": 66,
                "endLine": 203,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-testing/src/main/java/org/hibernate/testing/orm/junit/EntityManagerFactoryExtension.java",
                "startLine": 93,
                "endLine": 111,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-testing/src/main/java/org/hibernate/testing/orm/junit/EntityManagerFactoryExtension.java",
                "startLine": 191,
                "endLine": 201,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "public static EntityManagerFactoryScope findEntityManagerFactoryScope(\n\t\t\tObject testScope,\n\t\t\tOptional<Jpa> emfAnnWrapper,\n\t\t\tExtensionContext context) {\n\n\t\tif ( emfAnnWrapper.isEmpty() ) {\n\t\t\t// No annotation on the test class, should be on the test methods\n\t\t\treturn null;\n\t\t}\n\n\t\tfinal ExtensionContext.Store store = locateExtensionStore( testScope, context );\n\t\tfinal EntityManagerFactoryScope existing = (EntityManagerFactoryScope) store.get( EMF_KEY );\n\t\tif ( existing != null ) {\n\t\t\treturn existing;\n\t\t}\n\n\t\tif ( !context.getElement().isPresent() ) {\n\t\t\tthrow new RuntimeException( \"Unable to determine how to handle given ExtensionContext : \" + context.getDisplayName() );\n\t\t}\n\t\tfinal Jpa emfAnn = emfAnnWrapper.get();\n\n\t\tfinal PersistenceUnitInfoImpl pui = new PersistenceUnitInfoImpl( emfAnn.persistenceUnitName() );\n\t\t( (Map<Object, Object>) Environment.getProperties() ).forEach(\n\t\t\t\t(key, value) ->\n\t\t\t\t\t\tpui.getProperties().put( key, value )\n\t\t);\n\n\t\tpui.setTransactionType( emfAnn.transactionType() );\n\t\tpui.setCacheMode( emfAnn.sharedCacheMode() );\n\t\tpui.setValidationMode( emfAnn.validationMode() );\n\t\tpui.setExcludeUnlistedClasses( emfAnn.excludeUnlistedClasses() );\n\n\t\t// JpaCompliance\n\t\tpui.getProperties().put( AvailableSettings.JPA_COMPLIANCE, emfAnn.jpaComplianceEnabled() );\n\t\tpui.getProperties().put( AvailableSettings.JPA_QUERY_COMPLIANCE, emfAnn.queryComplianceEnabled() );\n\t\tpui.getProperties().put( AvailableSettings.JPA_TRANSACTION_COMPLIANCE, emfAnn.transactionComplianceEnabled() );\n\t\tpui.getProperties().put( AvailableSettings.JPA_CLOSED_COMPLIANCE, emfAnn.closedComplianceEnabled() );\n\t\tpui.getProperties().put( AvailableSettings.JPA_PROXY_COMPLIANCE, emfAnn.proxyComplianceEnabled() );\n\t\tpui.getProperties().put( AvailableSettings.JPA_CACHING_COMPLIANCE, emfAnn.cacheComplianceEnabled() );\n\t\tpui.getProperties().put( AvailableSettings.JPA_ID_GENERATOR_GLOBAL_SCOPE_COMPLIANCE, emfAnn.generatorScopeComplianceEnabled() );\n\t\tpui.getProperties().put( AvailableSettings.JPA_ORDER_BY_MAPPING_COMPLIANCE, emfAnn.orderByMappingComplianceEnabled() );\n\t\tpui.getProperties().put( AvailableSettings.JPA_LOAD_BY_ID_COMPLIANCE, emfAnn.loadByIdComplianceEnabled() );\n\n\t\tfinal Setting[] properties = emfAnn.properties();\n\t\tfor ( int i = 0; i < properties.length; i++ ) {\n\t\t\tfinal Setting property = properties[i];\n\t\t\tpui.getProperties().setProperty( property.name(), property.value() );\n\t\t}\n\n\t\tpui.getProperties().setProperty(\n\t\t\t\tAvailableSettings.GENERATE_STATISTICS,\n\t\t\t\tBoolean.toString( emfAnn.generateStatistics() )\n\t\t);\n\n\t\tif ( emfAnn.exportSchema() ) {\n\t\t\tpui.getProperties().setProperty(\n\t\t\t\t\tAvailableSettings.JAKARTA_HBM2DDL_DATABASE_ACTION,\n\t\t\t\t\tAction.CREATE_DROP.getExternalHbm2ddlName()\n\t\t\t);\n\t\t}\n\n\t\tif ( emfAnn.annotatedPackageNames().length > 0 ) {\n\t\t\tpui.applyManagedClassNames( emfAnn.annotatedPackageNames() );\n\t\t}\n\n\t\tif ( emfAnn.annotatedClassNames().length > 0 ) {\n\t\t\tpui.applyManagedClassNames( emfAnn.annotatedClassNames() );\n\t\t}\n\n\t\tif ( emfAnn.annotatedClasses().length > 0 ) {\n\t\t\tfor ( int i = 0; i < emfAnn.annotatedClasses().length; i++ ) {\n\t\t\t\tpui.applyManagedClassNames( emfAnn.annotatedClasses()[i].getName() );\n\t\t\t}\n\t\t}\n\n\t\tif ( emfAnn.xmlMappings().length > 0 ) {\n\t\t\tpui.applyMappingFiles( emfAnn.xmlMappings() );\n\t\t}\n\n\t\tif ( emfAnn.standardModels().length > 0 ) {\n\t\t\tfor ( int i = 0; i < emfAnn.standardModels().length; i++ ) {\n\t\t\t\tfinal StandardDomainModel standardDomainModel = emfAnn.standardModels()[i];\n\t\t\t\tfor ( int i1 = 0; i1 < standardDomainModel.getDescriptor().getAnnotatedClasses().length; i1++ ) {\n\t\t\t\t\tfinal Class<?> annotatedClass = standardDomainModel.getDescriptor().getAnnotatedClasses()[i1];\n\t\t\t\t\tpui.applyManagedClassNames( annotatedClass.getName() );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ( emfAnn.modelDescriptorClasses().length > 0 ) {\n\t\t\tfor ( int i = 0; i < emfAnn.modelDescriptorClasses().length; i++ ) {\n\t\t\t\tfinal Class<? extends DomainModelDescriptor> modelDescriptorClass = emfAnn.modelDescriptorClasses()[i];\n\t\t\t\tfinal DomainModelDescriptor domainModelDescriptor = instantiateDomainModelDescriptor(\n\t\t\t\t\t\tmodelDescriptorClass );\n\t\t\t\tfor ( int i1 = 0; i1 < domainModelDescriptor.getAnnotatedClasses().length; i1++ ) {\n\t\t\t\t\tfinal Class<?> annotatedClass = domainModelDescriptor.getAnnotatedClasses()[i1];\n\t\t\t\t\tpui.applyManagedClassNames( annotatedClass.getName() );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfinal Map<String, Object> integrationSettings = new HashMap<>();\n\n\t\tintegrationSettings.put( PersistentTableStrategy.DROP_ID_TABLES, \"true\" );\n\t\tintegrationSettings.put( GlobalTemporaryTableMutationStrategy.DROP_ID_TABLES, \"true\" );\n\t\tintegrationSettings.put( LocalTemporaryTableMutationStrategy.DROP_ID_TABLES, \"true\" );\n\t\tfor ( int i = 0; i < emfAnn.integrationSettings().length; i++ ) {\n\t\t\tfinal Setting setting = emfAnn.integrationSettings()[i];\n\t\t\tintegrationSettings.put( setting.name(), setting.value() );\n\t\t}\n\n\t\tfor ( SettingProvider providerAnn : emfAnn.settingProviders() ) {\n\t\t\tfinal Class<? extends SettingProvider.Provider<?>> providerImpl = providerAnn.provider();\n\t\t\ttry {\n\t\t\t\tfinal SettingProvider.Provider<?> provider = providerImpl.getConstructor().newInstance();\n\t\t\t\tintegrationSettings.put( providerAnn.settingName(), provider.getSetting() );\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tlog.error( \"Error obtaining setting provider for \" + providerImpl.getName(), e );\n\t\t\t}\n\t\t}\n\n\t\t// statement inspector\n\t\tif ( emfAnn.useCollectingStatementInspector() ) {\n\t\t\tString inspectorSetting = (String) integrationSettings.get( AvailableSettings.STATEMENT_INSPECTOR );\n\t\t\tif ( !(inspectorSetting == null || inspectorSetting.isBlank()) ) {\n\t\t\t\tlog.warn( String.format( \"Overriding the explicit \\\"%1s\\\" statement inspector setting\", inspectorSetting ) );\n\t\t\t}\n\t\t\tintegrationSettings.put( AvailableSettings.STATEMENT_INSPECTOR, new SQLStatementInspector() );\n\t\t}\n\n\t\tServiceRegistryUtil.applySettings( integrationSettings );\n\t\tfinal EntityManagerFactoryScopeImpl scope = new EntityManagerFactoryScopeImpl( pui, integrationSettings );\n\n\t\tstore.put( EMF_KEY, scope );\n\n\t\treturn scope;\n\t}",
        "filePathBefore": "hibernate-testing/src/main/java/org/hibernate/testing/orm/junit/EntityManagerFactoryExtension.java",
        "isPureRefactoring": true,
        "commitId": "4781c09d0df0eb4ce05b2fa0d2a12747023ae024",
        "packageNameBefore": "org.hibernate.testing.orm.junit",
        "classNameBefore": "org.hibernate.testing.orm.junit.EntityManagerFactoryExtension",
        "methodNameBefore": "org.hibernate.testing.orm.junit.EntityManagerFactoryExtension#findEntityManagerFactoryScope",
        "invokedMethod": "methodSignature: org.hibernate.jpa.boot.internal.ParsedPersistenceXmlDescriptor#setValidationMode\n methodBody: public void setValidationMode(String validationMode) {\nsetValidationMode(ValidationMode.valueOf(validationMode));\n}\nmethodSignature: org.hibernate.testing.junit4.BaseNonConfigCoreFunctionalTestCase#getAnnotatedClasses\n methodBody: protected Class[] getAnnotatedClasses() {\nreturn NO_CLASSES;\n}\nmethodSignature: org.hibernate.jpa.boot.internal.PersistenceUnitInfoDescriptor#getName\n methodBody: public String getName() {\nreturn persistenceUnitInfo.getPersistenceUnitName();\n}\nmethodSignature: org.hibernate.testing.orm.jpa.PersistenceUnitInfoImpl#setTransactionType\n methodBody: public void setTransactionType(PersistenceUnitTransactionType transactionType) {\nthis.transactionType=transactionType;\n}\nmethodSignature: org.hibernate.testing.orm.junit.EntityManagerFactoryBasedFunctionalTest#applySettings\n methodBody: protected void applySettings(Map<Object, Object> settings) {\nString[] mappings=getMappings();\nif(mappings != null){settings.put(AvailableSettings.HBM_XML_FILES,String.join(\",\",mappings));\n}}\nmethodSignature: org.hibernate.testing.orm.jpa.PersistenceUnitInfoImpl#setValidationMode\n methodBody: public void setValidationMode(ValidationMode validationMode) {\nthis.validationMode=validationMode;\n}\nmethodSignature: org.hibernate.collection.spi.AbstractPersistentCollection.SetProxy#isEmpty\n methodBody: public boolean isEmpty() {\nreturn set.isEmpty();\n}\nmethodSignature: org.hibernate.testing.orm.jpa.PersistenceUnitInfoImpl#applyMappingFiles\n methodBody: public void applyMappingFiles(String... mappingFiles) {\nif(this.mappingFiles == null){this.mappingFiles=new ArrayList<>();\n}Collections.addAll(this.mappingFiles,mappingFiles);\n}\nmethodSignature: org.hibernate.testing.util.jpa.DelegatingPersistenceUnitInfo#getProperties\n methodBody: public Properties getProperties() {\nreturn delegate.getProperties();\n}\nmethodSignature: org.hibernate.orm.test.exceptionhandling.BaseJpaOrNativeBootstrapFunctionalTestCase.TestingPersistenceUnitDescriptorImpl#getName\n methodBody: public String getName() {\nreturn name;\n}\nmethodSignature: org.hibernate.collection.spi.PersistentList#get\n methodBody: public E get(int index) {\nif(index < 0){throw new ArrayIndexOutOfBoundsException(\"negative index\");\n}final Object result=readElementByIndex(index);\nreturn result == UNKNOWN ? list.get(index) : (E)result;\n}\nmethodSignature: org.hibernate.orm.test.bootstrap.BootstrapTest.PersistenceUnitInfoImpl#getProperties\n methodBody: public Properties getProperties() {\nreturn properties;\n}\nmethodSignature: org.hibernate.testing.orm.junit.EntityManagerFactoryBasedFunctionalTest.TestingPersistenceUnitDescriptorImpl#getName\n methodBody: public String getName() {\nreturn name;\n}\nmethodSignature: org.hibernate.jpa.boot.spi.PersistenceConfigurationDescriptor#getName\n methodBody: public String getName() {\nreturn persistenceConfiguration.name();\n}\nmethodSignature: org.hibernate.jpa.boot.internal.PersistenceUnitInfoDescriptor#getProperties\n methodBody: public Properties getProperties() {\nreturn persistenceUnitInfo.getProperties();\n}\nmethodSignature: org.hibernate.jpa.boot.spi.PersistenceUnitDescriptor#getProperties\n methodBody: Properties getProperties();\nmethodSignature: org.hibernate.testing.orm.junit.BaseSessionFactoryFunctionalTest#getAnnotatedClasses\n methodBody: protected Class[] getAnnotatedClasses() {\nreturn NO_CLASSES;\n}\nmethodSignature: org.hibernate.testing.orm.junit.BaseSessionFactoryFunctionalTest#applySettings\n methodBody: protected void applySettings(StandardServiceRegistryBuilder builder) {\n}\nmethodSignature: org.hibernate.testing.orm.jpa.PersistenceUnitInfoAdapter#getProperties\n methodBody: public Properties getProperties() {\nif(properties == null){properties=new Properties();\n}return properties;\n}\nmethodSignature: org.hibernate.testing.util.jpa.DelegatingPersistenceUnitInfo#excludeUnlistedClasses\n methodBody: public boolean excludeUnlistedClasses() {\nreturn delegate.excludeUnlistedClasses();\n}\nmethodSignature: org.hibernate.testing.util.jpa.PersistenceUnitInfoAdapter#getProperties\n methodBody: public Properties getProperties() {\nreturn properties;\n}\nmethodSignature: org.hibernate.testing.orm.jpa.PersistenceUnitInfoImpl#setCacheMode\n methodBody: public void setCacheMode(SharedCacheMode cacheMode) {\nthis.cacheMode=cacheMode;\n}\nmethodSignature: org.hibernate.jpa.boot.internal.ParsedPersistenceXmlDescriptor#getName\n methodBody: public String getName() {\nreturn name;\n}\nmethodSignature: org.hibernate.orm.test.jpa.BaseEntityManagerFunctionalTestCase.TestingPersistenceUnitDescriptorImpl#getName\n methodBody: public String getName() {\nreturn name;\n}\nmethodSignature: org.hibernate.testing.orm.jpa.PersistenceUnitInfoImpl#excludeUnlistedClasses\n methodBody: public boolean excludeUnlistedClasses() {\nreturn excludeUnlistedClasses;\n}\nmethodSignature: org.hibernate.testing.orm.junit.EntityManagerFactoryBasedFunctionalTest#getAnnotatedClasses\n methodBody: protected Class<?>[] getAnnotatedClasses() {\nreturn NO_CLASSES;\n}\nmethodSignature: org.hibernate.collection.spi.AbstractPersistentCollection.ListProxy#get\n methodBody: public E get(int i) {\nreturn list.get(i);\n}\nmethodSignature: org.hibernate.testing.util.jpa.PersistenceUnitInfoAdapter#excludeUnlistedClasses\n methodBody: public boolean excludeUnlistedClasses() {\nreturn false;\n}\nmethodSignature: org.hibernate.orm.test.exceptionhandling.BaseJpaOrNativeBootstrapFunctionalTestCase#getAnnotatedClasses\n methodBody: protected Class<?>[] getAnnotatedClasses() {\nreturn NO_CLASSES;\n}\nmethodSignature: org.hibernate.orm.test.bootstrap.BootstrapTest.PersistenceUnitInfoImpl#excludeUnlistedClasses\n methodBody: public boolean excludeUnlistedClasses() {\nreturn false;\n}\nmethodSignature: org.hibernate.jpa.boot.spi.PersistenceConfigurationDescriptor#getProperties\n methodBody: public Properties getProperties() {\nreturn properties;\n}\nmethodSignature: org.hibernate.testing.orm.jpa.PersistenceUnitDescriptorAdapter#getProperties\n methodBody: public Properties getProperties() {\nif(properties == null){properties=new Properties();\n}return properties;\n}\nmethodSignature: org.hibernate.collection.spi.PersistentBag#get\n methodBody: public E get(int i) {\nread();\nreturn bag.get(i);\n}\nmethodSignature: org.hibernate.testing.orm.jpa.PersistenceUnitInfoAdapter#excludeUnlistedClasses\n methodBody: public boolean excludeUnlistedClasses() {\nreturn false;\n}\nmethodSignature: org.hibernate.testing.orm.jpa.PersistenceUnitInfoImpl#setExcludeUnlistedClasses\n methodBody: public void setExcludeUnlistedClasses(boolean excludeUnlistedClasses) {\nthis.excludeUnlistedClasses=excludeUnlistedClasses;\n}\nmethodSignature: org.hibernate.collection.spi.PersistentList#toString\n methodBody: public String toString() {\nread();\nreturn list.toString();\n}\nmethodSignature: org.hibernate.testing.junit4.BaseCoreFunctionalTestCase#getAnnotatedClasses\n methodBody: protected Class<?>[] getAnnotatedClasses() {\nreturn NO_CLASSES;\n}\nmethodSignature: org.hibernate.collection.spi.PersistentBag#getElement\n methodBody: public Object getElement(Object entry) {\nreturn entry;\n}\nmethodSignature: org.hibernate.collection.spi.PersistentBag#isEmpty\n methodBody: public boolean isEmpty() {\nreturn readSize() ? getCachedSize() == 0 : bag.isEmpty();\n}\nmethodSignature: org.hibernate.orm.test.jpa.xml.versions.JpaXsdVersionsTest.PersistenceUnitInfoImpl#getProperties\n methodBody: public Properties getProperties() {\nreturn properties;\n}\nmethodSignature: org.hibernate.jpa.boot.internal.ParsedPersistenceXmlDescriptor#setTransactionType\n methodBody: public void setTransactionType(PersistenceUnitTransactionType transactionType) {\nthis.transactionType=transactionType;\n}\nmethodSignature: org.hibernate.orm.test.jpa.EntityManagerTest#getAnnotatedClasses\n methodBody: public Class[] getAnnotatedClasses() {\nreturn new Class[]{Item.class,Distributor.class,Wallet.class};\n}\nmethodSignature: org.hibernate.orm.test.jpa.BaseEntityManagerFunctionalTestCase#getAnnotatedClasses\n methodBody: protected Class<?>[] getAnnotatedClasses() {\nreturn NO_CLASSES;\n}\nmethodSignature: org.hibernate.testing.orm.junit.EntityManagerFactoryBasedFunctionalTest#exportSchema\n methodBody: protected boolean exportSchema() {\nreturn true;\n}\nmethodSignature: org.hibernate.jpa.boot.internal.ParsedPersistenceXmlDescriptor#getProperties\n methodBody: public Properties getProperties() {\nreturn properties;\n}\nmethodSignature: org.hibernate.internal.SessionFactoryImpl#getProperties\n methodBody: public Map<String, Object> getProperties() {\nvalidateNotClosed();\nreturn settings;\n}\nmethodSignature: org.hibernate.testing.util.jpa.PersistenceUnitInfoPropertiesWrapper#excludeUnlistedClasses\n methodBody: public boolean excludeUnlistedClasses() {\nreturn false;\n}\nmethodSignature: org.hibernate.orm.test.jpa.xml.versions.JpaXsdVersionsTest.PersistenceUnitInfoImpl#excludeUnlistedClasses\n methodBody: public boolean excludeUnlistedClasses() {\nreturn false;\n}\nmethodSignature: org.hibernate.jpa.boot.spi.PersistenceUnitDescriptor#getName\n methodBody: String getName();\nmethodSignature: org.hibernate.orm.test.exceptionhandling.BaseJpaOrNativeBootstrapFunctionalTestCase.TestingPersistenceUnitDescriptorImpl#getProperties\n methodBody: public Properties getProperties() {\nreturn null;\n}\nmethodSignature: org.hibernate.testing.orm.jpa.PersistenceUnitDescriptorAdapter#getName\n methodBody: public String getName() {\nreturn name;\n}\nmethodSignature: org.hibernate.testing.orm.junit.EntityManagerFactoryExtension#locateExtensionStore\n methodBody: private static ExtensionContext.Store locateExtensionStore(Object testScope, ExtensionContext context) {\nreturn JUnitHelper.locateExtensionStore(EntityManagerFactoryExtension.class,context,testScope);\n}\nmethodSignature: org.hibernate.jpa.boot.internal.ParsedPersistenceXmlDescriptor#setExcludeUnlistedClasses\n methodBody: public void setExcludeUnlistedClasses(boolean excludeUnlistedClasses) {\nthis.excludeUnlistedClasses=excludeUnlistedClasses;\n}\nmethodSignature: org.hibernate.testing.orm.jpa.PersistenceUnitInfoImpl#applyManagedClassNames\n methodBody: public void applyManagedClassNames(String... managedClassNames) {\nif(this.managedClassNames == null){this.managedClassNames=new ArrayList<>();\n}Collections.addAll(this.managedClassNames,managedClassNames);\n}\nmethodSignature: org.hibernate.testing.util.jpa.PersistenceUnitInfoPropertiesWrapper#getProperties\n methodBody: public Properties getProperties() {\nif(properties == null){properties=new Properties();\n}return properties;\n}\nmethodSignature: org.hibernate.collection.spi.PersistentList#getElement\n methodBody: public Object getElement(Object entry) {\nreturn entry;\n}\nmethodSignature: org.hibernate.orm.test.jpa.BaseEntityManagerFunctionalTestCase.TestingPersistenceUnitDescriptorImpl#getProperties\n methodBody: public Properties getProperties() {\nreturn null;\n}\nmethodSignature: org.hibernate.internal.SessionFactoryImpl#getName\n methodBody: public String getName() {\nreturn name;\n}\nmethodSignature: org.hibernate.testing.orm.junit.EntityManagerFactoryBasedFunctionalTest.TestingPersistenceUnitDescriptorImpl#getProperties\n methodBody: public Properties getProperties() {\nreturn null;\n}\nmethodSignature: org.hibernate.collection.spi.PersistentList#isEmpty\n methodBody: public boolean isEmpty() {\nreturn readSize() ? getCachedSize() == 0 : list.isEmpty();\n}\nmethodSignature: org.hibernate.testing.orm.jpa.PersistenceUnitInfoImpl#getProperties\n methodBody: public Properties getProperties() {\nreturn properties;\n}\nmethodSignature: org.hibernate.testing.orm.junit.EntityManagerFactoryExtension#instantiateDomainModelDescriptor\n methodBody: private static DomainModelDescriptor instantiateDomainModelDescriptor(Class<? extends DomainModelDescriptor> modelDescriptorClass) {\ntryfinal Field[] declaredFields=modelDescriptorClass.getDeclaredFields();\nfor(int i=0; i < declaredFields.length; i++){final Field field=declaredFields[i];\nif(ReflectHelper.isStaticField(field)){final Object value=field.get(null);\nif(value instanceof DomainModelDescriptor){return (DomainModelDescriptor)value;\n}}}catch(IllegalAccessException e)throw new RuntimeException(\"Problem accessing DomainModelDescriptor fields : \" + modelDescriptorClass.getName(),e);\ntryreturn modelDescriptorClass.getConstructor(null).newInstance(null);\ncatch(InstantiationException|IllegalAccessException|InvocationTargetException|NoSuchMethodException e)throw new RuntimeException(\"Problem instantiation DomainModelDescriptor : \" + modelDescriptorClass.getName(),e);\n}\nmethodSignature: org.hibernate.testing.orm.junit.BaseSessionFactoryFunctionalTest#exportSchema\n methodBody: protected boolean exportSchema() {\nreturn true;\n}\nmethodSignature: org.hibernate.collection.spi.AbstractPersistentCollection.ListProxy#isEmpty\n methodBody: public boolean isEmpty() {\nreturn list.isEmpty();\n}\nmethodSignature: org.hibernate.collection.spi.PersistentBag#toString\n methodBody: public String toString() {\nread();\nreturn bag.toString();\n}",
        "classSignatureBefore": "public class EntityManagerFactoryExtension\n\t\timplements TestInstancePostProcessor, BeforeEachCallback, TestExecutionExceptionHandler ",
        "methodNameBeforeSet": [
            "org.hibernate.testing.orm.junit.EntityManagerFactoryExtension#findEntityManagerFactoryScope"
        ],
        "classNameBeforeSet": [
            "org.hibernate.testing.orm.junit.EntityManagerFactoryExtension"
        ],
        "classSignatureBeforeSet": [
            "public class EntityManagerFactoryExtension\n\t\timplements TestInstancePostProcessor, BeforeEachCallback, TestExecutionExceptionHandler "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Changes are within the Extract Method refactoring mechanics\nOverlapped refactoring - can be identical by undoing the overlapped refactoring\n- Rename Variable-",
                "description": "Rename Variable on top of the extract method - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later\n * See the lgpl.txt file in the root directory or http://www.gnu.org/licenses/lgpl-2.1.html\n */\npackage org.hibernate.testing.orm.junit;\n\nimport java.lang.reflect.Field;\nimport java.lang.reflect.InvocationTargetException;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.Set;\nimport jakarta.persistence.spi.PersistenceUnitInfo;\n\nimport org.hibernate.SessionFactoryObserver;\nimport org.hibernate.boot.registry.StandardServiceRegistry;\nimport org.hibernate.boot.spi.MetadataImplementor;\nimport org.hibernate.cfg.AvailableSettings;\nimport org.hibernate.cfg.Environment;\nimport org.hibernate.engine.spi.SessionFactoryImplementor;\nimport org.hibernate.internal.util.ReflectHelper;\nimport org.hibernate.jpa.boot.internal.PersistenceUnitInfoDescriptor;\nimport org.hibernate.jpa.boot.spi.Bootstrap;\nimport org.hibernate.jpa.boot.spi.EntityManagerFactoryBuilder;\nimport org.hibernate.query.sqm.mutation.internal.temptable.GlobalTemporaryTableMutationStrategy;\nimport org.hibernate.query.sqm.mutation.internal.temptable.LocalTemporaryTableMutationStrategy;\nimport org.hibernate.query.sqm.mutation.internal.temptable.PersistentTableStrategy;\nimport org.hibernate.tool.schema.Action;\nimport org.hibernate.tool.schema.spi.SchemaManagementToolCoordinator;\nimport org.hibernate.tool.schema.spi.SchemaManagementToolCoordinator.ActionGrouping;\n\nimport org.hibernate.testing.jdbc.SQLStatementInspector;\nimport org.hibernate.testing.orm.domain.DomainModelDescriptor;\nimport org.hibernate.testing.orm.domain.StandardDomainModel;\nimport org.hibernate.testing.orm.jpa.PersistenceUnitInfoImpl;\nimport org.hibernate.testing.util.ServiceRegistryUtil;\nimport org.junit.jupiter.api.extension.BeforeEachCallback;\nimport org.junit.jupiter.api.extension.ExtensionContext;\nimport org.junit.jupiter.api.extension.TestExecutionExceptionHandler;\nimport org.junit.jupiter.api.extension.TestInstancePostProcessor;\nimport org.junit.platform.commons.support.AnnotationSupport;\n\nimport org.jboss.logging.Logger;\n\n/**\n * hibernate-testing implementation of a few JUnit5 contracts to support SessionFactory-based testing,\n * including argument injection (or see {@link SessionFactoryScopeAware})\n *\n * @author Steve Ebersole\n *\n * @see DomainModelExtension\n * @see SessionFactoryExtension\n */\npublic class EntityManagerFactoryExtension\n\t\timplements TestInstancePostProcessor, BeforeEachCallback, TestExecutionExceptionHandler {\n\n\tprivate static final Logger log = Logger.getLogger( EntityManagerFactoryExtension.class );\n\tprivate static final String EMF_KEY = EntityManagerFactoryScope.class.getName();\n\n\tprivate static ExtensionContext.Store locateExtensionStore(Object testScope, ExtensionContext context) {\n\t\treturn JUnitHelper.locateExtensionStore( EntityManagerFactoryExtension.class, context, testScope );\n\t}\n\n\tpublic static EntityManagerFactoryScope findEntityManagerFactoryScope(\n\t\t\tObject testScope,\n\t\t\tOptional<Jpa> emfAnnWrapper,\n\t\t\tExtensionContext context) {\n\n\t\tif ( emfAnnWrapper.isEmpty() ) {\n\t\t\t// No annotation on the test class, should be on the test methods\n\t\t\treturn null;\n\t\t}\n\n\t\tfinal ExtensionContext.Store store = locateExtensionStore( testScope, context );\n\t\tfinal EntityManagerFactoryScope existing = (EntityManagerFactoryScope) store.get( EMF_KEY );\n\t\tif ( existing != null ) {\n\t\t\treturn existing;\n\t\t}\n\n\t\tif ( !context.getElement().isPresent() ) {\n\t\t\tthrow new RuntimeException( \"Unable to determine how to handle given ExtensionContext : \" + context.getDisplayName() );\n\t\t}\n\t\tfinal Jpa emfAnn = emfAnnWrapper.get();\n\n\t\tfinal PersistenceUnitInfoImpl pui = new PersistenceUnitInfoImpl( emfAnn.persistenceUnitName() );\n\t\t( (Map<Object, Object>) Environment.getProperties() ).forEach(\n\t\t\t\t(key, value) ->\n\t\t\t\t\t\tpui.getProperties().put( key, value )\n\t\t);\n\n\t\tpui.setTransactionType( emfAnn.transactionType() );\n\t\tpui.setCacheMode( emfAnn.sharedCacheMode() );\n\t\tpui.setValidationMode( emfAnn.validationMode() );\n\t\tpui.setExcludeUnlistedClasses( emfAnn.excludeUnlistedClasses() );\n\n\t\t// JpaCompliance\n\t\tpui.getProperties().put( AvailableSettings.JPA_COMPLIANCE, emfAnn.jpaComplianceEnabled() );\n\t\tpui.getProperties().put( AvailableSettings.JPA_QUERY_COMPLIANCE, emfAnn.queryComplianceEnabled() );\n\t\tpui.getProperties().put( AvailableSettings.JPA_TRANSACTION_COMPLIANCE, emfAnn.transactionComplianceEnabled() );\n\t\tpui.getProperties().put( AvailableSettings.JPA_CLOSED_COMPLIANCE, emfAnn.closedComplianceEnabled() );\n\t\tpui.getProperties().put( AvailableSettings.JPA_PROXY_COMPLIANCE, emfAnn.proxyComplianceEnabled() );\n\t\tpui.getProperties().put( AvailableSettings.JPA_CACHING_COMPLIANCE, emfAnn.cacheComplianceEnabled() );\n\t\tpui.getProperties().put( AvailableSettings.JPA_ID_GENERATOR_GLOBAL_SCOPE_COMPLIANCE, emfAnn.generatorScopeComplianceEnabled() );\n\t\tpui.getProperties().put( AvailableSettings.JPA_ORDER_BY_MAPPING_COMPLIANCE, emfAnn.orderByMappingComplianceEnabled() );\n\t\tpui.getProperties().put( AvailableSettings.JPA_LOAD_BY_ID_COMPLIANCE, emfAnn.loadByIdComplianceEnabled() );\n\n\t\tfinal Setting[] properties = emfAnn.properties();\n\t\tfor ( int i = 0; i < properties.length; i++ ) {\n\t\t\tfinal Setting property = properties[i];\n\t\t\tpui.getProperties().setProperty( property.name(), property.value() );\n\t\t}\n\n\t\tpui.getProperties().setProperty(\n\t\t\t\tAvailableSettings.GENERATE_STATISTICS,\n\t\t\t\tBoolean.toString( emfAnn.generateStatistics() )\n\t\t);\n\n\t\tif ( emfAnn.exportSchema() ) {\n\t\t\tpui.getProperties().setProperty(\n\t\t\t\t\tAvailableSettings.JAKARTA_HBM2DDL_DATABASE_ACTION,\n\t\t\t\t\tAction.CREATE_DROP.getExternalHbm2ddlName()\n\t\t\t);\n\t\t}\n\n\t\tif ( emfAnn.annotatedPackageNames().length > 0 ) {\n\t\t\tpui.applyManagedClassNames( emfAnn.annotatedPackageNames() );\n\t\t}\n\n\t\tif ( emfAnn.annotatedClassNames().length > 0 ) {\n\t\t\tpui.applyManagedClassNames( emfAnn.annotatedClassNames() );\n\t\t}\n\n\t\tif ( emfAnn.annotatedClasses().length > 0 ) {\n\t\t\tfor ( int i = 0; i < emfAnn.annotatedClasses().length; i++ ) {\n\t\t\t\tpui.applyManagedClassNames( emfAnn.annotatedClasses()[i].getName() );\n\t\t\t}\n\t\t}\n\n\t\tif ( emfAnn.xmlMappings().length > 0 ) {\n\t\t\tpui.applyMappingFiles( emfAnn.xmlMappings() );\n\t\t}\n\n\t\tif ( emfAnn.standardModels().length > 0 ) {\n\t\t\tfor ( int i = 0; i < emfAnn.standardModels().length; i++ ) {\n\t\t\t\tfinal StandardDomainModel standardDomainModel = emfAnn.standardModels()[i];\n\t\t\t\tfor ( int i1 = 0; i1 < standardDomainModel.getDescriptor().getAnnotatedClasses().length; i1++ ) {\n\t\t\t\t\tfinal Class<?> annotatedClass = standardDomainModel.getDescriptor().getAnnotatedClasses()[i1];\n\t\t\t\t\tpui.applyManagedClassNames( annotatedClass.getName() );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ( emfAnn.modelDescriptorClasses().length > 0 ) {\n\t\t\tfor ( int i = 0; i < emfAnn.modelDescriptorClasses().length; i++ ) {\n\t\t\t\tfinal Class<? extends DomainModelDescriptor> modelDescriptorClass = emfAnn.modelDescriptorClasses()[i];\n\t\t\t\tfinal DomainModelDescriptor domainModelDescriptor = instantiateDomainModelDescriptor(\n\t\t\t\t\t\tmodelDescriptorClass );\n\t\t\t\tfor ( int i1 = 0; i1 < domainModelDescriptor.getAnnotatedClasses().length; i1++ ) {\n\t\t\t\t\tfinal Class<?> annotatedClass = domainModelDescriptor.getAnnotatedClasses()[i1];\n\t\t\t\t\tpui.applyManagedClassNames( annotatedClass.getName() );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfinal Map<String, Object> integrationSettings = new HashMap<>();\n\n\t\tintegrationSettings.put( PersistentTableStrategy.DROP_ID_TABLES, \"true\" );\n\t\tintegrationSettings.put( GlobalTemporaryTableMutationStrategy.DROP_ID_TABLES, \"true\" );\n\t\tintegrationSettings.put( LocalTemporaryTableMutationStrategy.DROP_ID_TABLES, \"true\" );\n\t\tfor ( int i = 0; i < emfAnn.integrationSettings().length; i++ ) {\n\t\t\tfinal Setting setting = emfAnn.integrationSettings()[i];\n\t\t\tintegrationSettings.put( setting.name(), setting.value() );\n\t\t}\n\n\t\tfor ( SettingProvider providerAnn : emfAnn.settingProviders() ) {\n\t\t\tfinal Class<? extends SettingProvider.Provider<?>> providerImpl = providerAnn.provider();\n\t\t\ttry {\n\t\t\t\tfinal SettingProvider.Provider<?> provider = providerImpl.getConstructor().newInstance();\n\t\t\t\tintegrationSettings.put( providerAnn.settingName(), provider.getSetting() );\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tlog.error( \"Error obtaining setting provider for \" + providerImpl.getName(), e );\n\t\t\t}\n\t\t}\n\n\t\t// statement inspector\n\t\tif ( emfAnn.useCollectingStatementInspector() ) {\n\t\t\tString inspectorSetting = (String) integrationSettings.get( AvailableSettings.STATEMENT_INSPECTOR );\n\t\t\tif ( !(inspectorSetting == null || inspectorSetting.isBlank()) ) {\n\t\t\t\tlog.warn( String.format( \"Overriding the explicit \\\"%1s\\\" statement inspector setting\", inspectorSetting ) );\n\t\t\t}\n\t\t\tintegrationSettings.put( AvailableSettings.STATEMENT_INSPECTOR, new SQLStatementInspector() );\n\t\t}\n\n\t\tServiceRegistryUtil.applySettings( integrationSettings );\n\t\tfinal EntityManagerFactoryScopeImpl scope = new EntityManagerFactoryScopeImpl( pui, integrationSettings );\n\n\t\tstore.put( EMF_KEY, scope );\n\n\t\treturn scope;\n\t}\n\n\tprivate static DomainModelDescriptor instantiateDomainModelDescriptor(Class<? extends DomainModelDescriptor> modelDescriptorClass) {\n\t\t// first, see if it has a static singleton reference and use that if so\n\t\ttry {\n\t\t\tfinal Field[] declaredFields = modelDescriptorClass.getDeclaredFields();\n\t\t\tfor ( int i = 0; i < declaredFields.length; i++ ) {\n\t\t\t\tfinal Field field = declaredFields[i];\n\t\t\t\tif ( ReflectHelper.isStaticField( field ) ) {\n\t\t\t\t\tfinal Object value = field.get( null );\n\t\t\t\t\tif ( value instanceof DomainModelDescriptor ) {\n\t\t\t\t\t\treturn (DomainModelDescriptor) value;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (IllegalAccessException e) {\n\t\t\tthrow new RuntimeException(\n\t\t\t\t\t\"Problem accessing DomainModelDescriptor fields : \" + modelDescriptorClass.getName(),\n\t\t\t\t\te\n\t\t\t);\n\t\t}\n\n\t\t// no singleton field, try to instantiate it via reflection\n\t\ttry {\n\t\t\treturn modelDescriptorClass.getConstructor( null ).newInstance( null );\n\t\t}\n\t\tcatch (InstantiationException | IllegalAccessException | InvocationTargetException | NoSuchMethodException e) {\n\t\t\tthrow new RuntimeException(\n\t\t\t\t\t\"Problem instantiation DomainModelDescriptor : \" + modelDescriptorClass.getName(),\n\t\t\t\t\te\n\t\t\t);\n\t\t}\n\t}\n\n\tprivate static void prepareSchemaExport(\n\t\t\tSessionFactoryImplementor sessionFactory,\n\t\t\tMetadataImplementor model) {\n\t\tfinal Map<String, Object> baseProperties = sessionFactory.getProperties();\n\n\t\tfinal Set<ActionGrouping> groupings = ActionGrouping.interpret( model, baseProperties );\n\t\tif ( !groupings.isEmpty() ) {\n\t\t\t// the properties contained explicit settings for auto schema tooling - skip the annotation\n\t\t\treturn;\n\t\t}\n\n\t\tfinal HashMap<String,Object> settings = new HashMap<>( baseProperties );\n\t\tsettings.put( AvailableSettings.JAKARTA_HBM2DDL_DATABASE_ACTION, Action.CREATE_DROP );\n\n\t\tfinal StandardServiceRegistry serviceRegistry = model.getMetadataBuildingOptions().getServiceRegistry();\n\n\n\t\tSchemaManagementToolCoordinator.process(\n\t\t\t\tmodel,\n\t\t\t\tserviceRegistry,\n\t\t\t\tsettings,\n\t\t\t\taction -> sessionFactory.addObserver(\n\t\t\t\t\t\tnew SessionFactoryObserver() {\n\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\tpublic void sessionFactoryClosing(org.hibernate.SessionFactory factory) {\n\t\t\t\t\t\t\t\taction.perform( serviceRegistry );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t)\n\t\t);\n\t}\n\n\t@Override\n\tpublic void beforeEach(ExtensionContext context) {\n\t\tlog.tracef( \"#beforeEach(%s)\", context.getDisplayName() );\n\t\tfinal Optional<Jpa> emfAnnWrapper = AnnotationSupport.findAnnotation(\n\t\t\t\tcontext.getRequiredTestMethod(),\n\t\t\t\tJpa.class\n\t\t);\n\n\t\tif ( emfAnnWrapper.isEmpty() ) {\n\t\t\t// assume the annotation is defined on the class-level...\n\t\t\treturn;\n\t\t}\n\n\t\tfindEntityManagerFactoryScope( context.getRequiredTestMethod(), emfAnnWrapper, context );\n\t}\n\n\t@Override\n\tpublic void postProcessTestInstance(Object testInstance, ExtensionContext context) {\n\t\tlog.tracef( \"#postProcessTestInstance(%s, %s)\", testInstance, context.getDisplayName() );\n\n\t\tfinal Optional<Jpa> emfAnnWrapper = AnnotationSupport.findAnnotation(\n\t\t\t\tcontext.getRequiredTestClass(),\n\t\t\t\tJpa.class\n\t\t);\n\n\t\tfindEntityManagerFactoryScope( testInstance, emfAnnWrapper, context );\n\t}\n\n\t@Override\n\tpublic void handleTestExecutionException(ExtensionContext context, Throwable throwable) throws Throwable {\n\t\tlog.tracef( \"#handleTestExecutionException(%s, %s)\", context.getDisplayName(), throwable );\n\n\t\ttry {\n\t\t\tfinal Object testInstance = context.getRequiredTestInstance();\n\t\t\tfinal ExtensionContext.Store store = locateExtensionStore( testInstance, context );\n\t\t\tfinal EntityManagerFactoryScopeImpl scope = (EntityManagerFactoryScopeImpl) store.get( EMF_KEY );\n\t\t\tscope.releaseEntityManagerFactory();\n\t\t}\n\t\tcatch (Exception ignore) {\n\t\t}\n\n\t\tthrow throwable;\n\t}\n\n\tprivate static class EntityManagerFactoryScopeImpl extends AbstractEntityManagerFactoryScope {\n\t\tprivate final PersistenceUnitInfo persistenceUnitInfo;\n\t\tprivate final Map<String, Object> integrationSettings;\n\n\t\tprivate EntityManagerFactoryScopeImpl(\n\t\t\t\tPersistenceUnitInfo persistenceUnitInfo,\n\t\t\t\tMap<String, Object> integrationSettings) {\n\t\t\tthis.persistenceUnitInfo = persistenceUnitInfo;\n\t\t\tthis.integrationSettings = integrationSettings;\n\t\t}\n\n\t\tprotected jakarta.persistence.EntityManagerFactory createEntityManagerFactory() {\n\t\t\tfinal EntityManagerFactoryBuilder emfBuilder = Bootstrap.getEntityManagerFactoryBuilder(\n\t\t\t\t\tnew PersistenceUnitInfoDescriptor( persistenceUnitInfo ),\n\t\t\t\t\tintegrationSettings\n\t\t\t);\n\n\t\t\treturn emfBuilder.build();\n\t\t}\n\t}\n}\n",
        "filePathAfter": "hibernate-testing/src/main/java/org/hibernate/testing/orm/junit/EntityManagerFactoryExtension.java",
        "sourceCodeAfterForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later\n * See the lgpl.txt file in the root directory or http://www.gnu.org/licenses/lgpl-2.1.html\n */\npackage org.hibernate.testing.orm.junit;\n\nimport java.lang.reflect.Field;\nimport java.lang.reflect.InvocationTargetException;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.Properties;\n\nimport jakarta.persistence.spi.PersistenceUnitInfo;\n\nimport org.hibernate.cfg.AvailableSettings;\nimport org.hibernate.cfg.Environment;\nimport org.hibernate.internal.util.ReflectHelper;\nimport org.hibernate.jpa.boot.internal.PersistenceUnitInfoDescriptor;\nimport org.hibernate.query.sqm.mutation.internal.temptable.GlobalTemporaryTableMutationStrategy;\nimport org.hibernate.query.sqm.mutation.internal.temptable.LocalTemporaryTableMutationStrategy;\nimport org.hibernate.query.sqm.mutation.internal.temptable.PersistentTableStrategy;\nimport org.hibernate.tool.schema.Action;\n\nimport org.hibernate.testing.jdbc.SQLStatementInspector;\nimport org.hibernate.testing.orm.domain.DomainModelDescriptor;\nimport org.hibernate.testing.orm.domain.StandardDomainModel;\nimport org.hibernate.testing.orm.jpa.PersistenceUnitInfoImpl;\nimport org.hibernate.testing.util.ServiceRegistryUtil;\nimport org.junit.jupiter.api.extension.BeforeEachCallback;\nimport org.junit.jupiter.api.extension.ExtensionContext;\nimport org.junit.jupiter.api.extension.TestExecutionExceptionHandler;\nimport org.junit.jupiter.api.extension.TestInstancePostProcessor;\n\nimport org.jboss.logging.Logger;\n\nimport static org.hibernate.jpa.boot.spi.Bootstrap.getEntityManagerFactoryBuilder;\nimport static org.junit.platform.commons.support.AnnotationSupport.findAnnotation;\n\n/**\n * hibernate-testing implementation of a few JUnit5 contracts to support SessionFactory-based testing,\n * including argument injection (or see {@link SessionFactoryScopeAware})\n *\n * @author Steve Ebersole\n *\n * @see DomainModelExtension\n * @see SessionFactoryExtension\n */\npublic class EntityManagerFactoryExtension\n\t\timplements TestInstancePostProcessor, BeforeEachCallback, TestExecutionExceptionHandler {\n\n\tprivate static final Logger log = Logger.getLogger( EntityManagerFactoryExtension.class );\n\tprivate static final String EMF_KEY = EntityManagerFactoryScope.class.getName();\n\n\tprivate static ExtensionContext.Store locateExtensionStore(Object testScope, ExtensionContext context) {\n\t\treturn JUnitHelper.locateExtensionStore( EntityManagerFactoryExtension.class, context, testScope );\n\t}\n\n\tpublic static EntityManagerFactoryScope findEntityManagerFactoryScope(\n\t\t\tObject testScope, Optional<Jpa> optionalJpa, ExtensionContext context) {\n\n\t\tif ( optionalJpa.isEmpty() ) {\n\t\t\t// No annotation on the test class, should be on the test methods\n\t\t\treturn null;\n\t\t}\n\n\t\tfinal ExtensionContext.Store store = locateExtensionStore( testScope, context );\n\t\tfinal EntityManagerFactoryScope existing = (EntityManagerFactoryScope) store.get( EMF_KEY );\n\t\tif ( existing != null ) {\n\t\t\treturn existing;\n\t\t}\n\t\tif ( context.getElement().isEmpty() ) {\n\t\t\tthrow new RuntimeException( \"Unable to determine how to handle given ExtensionContext : \"\n\t\t\t\t\t+ context.getDisplayName() );\n\t\t}\n\n\t\tfinal Jpa jpa = optionalJpa.get();\n\t\tfinal PersistenceUnitInfoImpl pui = createPersistenceUnitInfo( jpa );\n\t\tcollectProperties( pui, jpa );\n\t\tmanagedClassesAndMappings( jpa, pui );\n\t\tfinal Map<String, Object> integrationSettings = collectIntegrationSettings( jpa );\n\t\t// statement inspector\n\t\tsetupStatementInspector( jpa, integrationSettings );\n\t\tServiceRegistryUtil.applySettings( integrationSettings );\n\t\tfinal EntityManagerFactoryScopeImpl scope =\n\t\t\t\tnew EntityManagerFactoryScopeImpl( pui, integrationSettings );\n\t\tstore.put( EMF_KEY, scope );\n\t\treturn scope;\n\t}\n\n\tprivate static void collectProperties(PersistenceUnitInfoImpl pui, Jpa jpa) {\n\t\tfinal Properties properties = pui.getProperties();\n\t\tproperties.putAll( Environment.getProperties() );\n\t\t// JpaCompliance\n\t\tsetJpaComplianceProperties( properties, jpa );\n\t\tfor ( Setting property : jpa.properties() ) {\n\t\t\tproperties.setProperty( property.name(), property.value() );\n\t\t}\n\t\tproperties.setProperty(\n\t\t\t\tAvailableSettings.GENERATE_STATISTICS,\n\t\t\t\tBoolean.toString( jpa.generateStatistics() )\n\t\t);\n\t\tif ( jpa.exportSchema() ) {\n\t\t\tproperties.setProperty(\n\t\t\t\t\tAvailableSettings.JAKARTA_HBM2DDL_DATABASE_ACTION,\n\t\t\t\t\tAction.CREATE_DROP.getExternalHbm2ddlName()\n\t\t\t);\n\t\t}\n\t}\n\n\tprivate static PersistenceUnitInfoImpl createPersistenceUnitInfo(Jpa jpa) {\n\t\tfinal PersistenceUnitInfoImpl pui =\n\t\t\t\tnew PersistenceUnitInfoImpl( jpa.persistenceUnitName() );\n\t\tpui.setTransactionType( jpa.transactionType() );\n\t\tpui.setCacheMode( jpa.sharedCacheMode() );\n\t\tpui.setValidationMode( jpa.validationMode() );\n\t\tpui.setExcludeUnlistedClasses( jpa.excludeUnlistedClasses() );\n\t\treturn pui;\n\t}\n\n\tprivate static void managedClassesAndMappings(Jpa jpa, PersistenceUnitInfoImpl pui) {\n\t\tif ( jpa.annotatedPackageNames().length > 0 ) {\n\t\t\tpui.applyManagedClassNames( jpa.annotatedPackageNames() );\n\t\t}\n\n\t\tif ( jpa.annotatedClassNames().length > 0 ) {\n\t\t\tpui.applyManagedClassNames( jpa.annotatedClassNames() );\n\t\t}\n\n\t\tif ( jpa.annotatedClasses().length > 0 ) {\n\t\t\tfor (int i = 0; i < jpa.annotatedClasses().length; i++ ) {\n\t\t\t\tpui.applyManagedClassNames( jpa.annotatedClasses()[i].getName() );\n\t\t\t}\n\t\t}\n\n\t\tif ( jpa.xmlMappings().length > 0 ) {\n\t\t\tpui.applyMappingFiles( jpa.xmlMappings() );\n\t\t}\n\n\t\tfor ( StandardDomainModel standardDomainModel : jpa.standardModels() ) {\n\t\t\tfor ( Class<?> annotatedClass : standardDomainModel.getDescriptor().getAnnotatedClasses() ) {\n\t\t\t\tpui.applyManagedClassNames( annotatedClass.getName() );\n\t\t\t}\n\t\t}\n\n\t\tfor ( Class<? extends DomainModelDescriptor> modelDescriptorClass :\n\t\t\t\tjpa.modelDescriptorClasses() ) {\n\t\t\tfinal DomainModelDescriptor domainModelDescriptor =\n\t\t\t\t\tinstantiateDomainModelDescriptor( modelDescriptorClass );\n\t\t\tfinal Class<?>[] annotatedClasses = domainModelDescriptor.getAnnotatedClasses();\n\t\t\tfor ( Class<?> annotatedClass : annotatedClasses ) {\n\t\t\t\tpui.applyManagedClassNames( annotatedClass.getName() );\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate static Map<String, Object> collectIntegrationSettings(Jpa jpa) {\n\t\tfinal Map<String, Object> integrationSettings = new HashMap<>();\n\t\tintegrationSettings.put( PersistentTableStrategy.DROP_ID_TABLES, \"true\" );\n\t\tintegrationSettings.put( GlobalTemporaryTableMutationStrategy.DROP_ID_TABLES, \"true\" );\n\t\tintegrationSettings.put( LocalTemporaryTableMutationStrategy.DROP_ID_TABLES, \"true\" );\n\t\tfinal Setting[] settings = jpa.integrationSettings();\n\t\tfor ( Setting setting : settings ) {\n\t\t\tintegrationSettings.put( setting.name(), setting.value() );\n\t\t}\n\t\tfor ( SettingProvider providerAnn : jpa.settingProviders() ) {\n\t\t\tfinal Class<? extends SettingProvider.Provider<?>> providerImpl = providerAnn.provider();\n\t\t\ttry {\n\t\t\t\tintegrationSettings.put( providerAnn.settingName(),\n\t\t\t\t\t\tproviderImpl.getConstructor().newInstance().getSetting() );\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tlog.error( \"Error obtaining setting provider for \" + providerImpl.getName(), e );\n\t\t\t}\n\t\t}\n\t\treturn integrationSettings;\n\t}\n\n\tprivate static void setupStatementInspector(Jpa jpa, Map<String, Object> integrationSettings) {\n\t\tif ( jpa.useCollectingStatementInspector() ) {\n\t\t\tfinal String inspectorSetting = (String) integrationSettings.get( AvailableSettings.STATEMENT_INSPECTOR );\n\t\t\tif ( inspectorSetting != null && !inspectorSetting.isBlank() ) {\n\t\t\t\tlog.warn( String.format( \"Overriding the explicit \\\"%1s\\\" statement inspector setting\", inspectorSetting ) );\n\t\t\t}\n\t\t\tintegrationSettings.put( AvailableSettings.STATEMENT_INSPECTOR, new SQLStatementInspector() );\n\t\t}\n\t}\n\n\tprivate static void setJpaComplianceProperties(Properties properties, Jpa jpa) {\n\t\tproperties.put( AvailableSettings.JPA_COMPLIANCE, jpa.jpaComplianceEnabled() );\n\t\tproperties.put( AvailableSettings.JPA_QUERY_COMPLIANCE, jpa.queryComplianceEnabled() );\n\t\tproperties.put( AvailableSettings.JPA_TRANSACTION_COMPLIANCE, jpa.transactionComplianceEnabled() );\n\t\tproperties.put( AvailableSettings.JPA_CLOSED_COMPLIANCE, jpa.closedComplianceEnabled() );\n\t\tproperties.put( AvailableSettings.JPA_PROXY_COMPLIANCE, jpa.proxyComplianceEnabled() );\n\t\tproperties.put( AvailableSettings.JPA_CACHING_COMPLIANCE, jpa.cacheComplianceEnabled() );\n\t\tproperties.put( AvailableSettings.JPA_ID_GENERATOR_GLOBAL_SCOPE_COMPLIANCE, jpa.generatorScopeComplianceEnabled() );\n\t\tproperties.put( AvailableSettings.JPA_ORDER_BY_MAPPING_COMPLIANCE, jpa.orderByMappingComplianceEnabled() );\n\t\tproperties.put( AvailableSettings.JPA_LOAD_BY_ID_COMPLIANCE, jpa.loadByIdComplianceEnabled() );\n\t}\n\n\tprivate static DomainModelDescriptor instantiateDomainModelDescriptor(\n\t\t\tClass<? extends DomainModelDescriptor> modelDescriptorClass) {\n\t\t// first, see if it has a static singleton reference and use that if so\n\t\ttry {\n\t\t\tfor ( Field field : modelDescriptorClass.getDeclaredFields() ) {\n\t\t\t\tif ( ReflectHelper.isStaticField(field) ) {\n\t\t\t\t\tfinal Object value = field.get( null );\n\t\t\t\t\tif ( value instanceof DomainModelDescriptor descriptor ) {\n\t\t\t\t\t\treturn descriptor;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (IllegalAccessException e) {\n\t\t\tthrow new RuntimeException( \"Problem accessing DomainModelDescriptor fields : \"\n\t\t\t\t\t+ modelDescriptorClass.getName(), e );\n\t\t}\n\n\t\t// no singleton field, try to instantiate it via reflection\n\t\ttry {\n\t\t\treturn modelDescriptorClass.getConstructor( null ).newInstance( null );\n\t\t}\n\t\tcatch (InstantiationException | IllegalAccessException | InvocationTargetException | NoSuchMethodException e) {\n\t\t\tthrow new RuntimeException( \"Problem instantiation DomainModelDescriptor : \"\n\t\t\t\t\t+ modelDescriptorClass.getName(), e );\n\t\t}\n\t}\n\n\t@Override\n\tpublic void beforeEach(ExtensionContext context) {\n\t\tlog.tracef( \"#beforeEach(%s)\", context.getDisplayName() );\n\t\tfinal Optional<Jpa> optionalJpa = findAnnotation( context.getRequiredTestMethod(), Jpa.class );\n\t\tif ( optionalJpa.isPresent() ) {\n\t\t\tfindEntityManagerFactoryScope( context.getRequiredTestMethod(), optionalJpa, context );\n\t\t}\n\t\t// else assume the annotation is defined on the class-level...\n\t}\n\n\t@Override\n\tpublic void postProcessTestInstance(Object testInstance, ExtensionContext context) {\n\t\tlog.tracef( \"#postProcessTestInstance(%s, %s)\", testInstance, context.getDisplayName() );\n\t\tfinal Optional<Jpa> optionalJpa = findAnnotation( context.getRequiredTestClass(), Jpa.class );\n\t\tfindEntityManagerFactoryScope( testInstance, optionalJpa, context );\n\t}\n\n\t@Override\n\tpublic void handleTestExecutionException(ExtensionContext context, Throwable throwable) throws Throwable {\n\t\tlog.tracef( \"#handleTestExecutionException(%s, %s)\", context.getDisplayName(), throwable );\n\t\ttry {\n\t\t\tfinal ExtensionContext.Store store = locateExtensionStore( context.getRequiredTestInstance(), context );\n\t\t\tfinal EntityManagerFactoryScopeImpl scope = (EntityManagerFactoryScopeImpl) store.get( EMF_KEY );\n\t\t\tscope.releaseEntityManagerFactory();\n\t\t}\n\t\tcatch (Exception ignore) {\n\t\t}\n\t\tthrow throwable;\n\t}\n\n\tprivate static class EntityManagerFactoryScopeImpl extends AbstractEntityManagerFactoryScope {\n\t\tprivate final PersistenceUnitInfo persistenceUnitInfo;\n\t\tprivate final Map<String, Object> integrationSettings;\n\n\t\tprivate EntityManagerFactoryScopeImpl(\n\t\t\t\tPersistenceUnitInfo persistenceUnitInfo,\n\t\t\t\tMap<String, Object> integrationSettings) {\n\t\t\tthis.persistenceUnitInfo = persistenceUnitInfo;\n\t\t\tthis.integrationSettings = integrationSettings;\n\t\t}\n\n\t\tprotected jakarta.persistence.EntityManagerFactory createEntityManagerFactory() {\n\t\t\tfinal PersistenceUnitInfoDescriptor descriptor = new PersistenceUnitInfoDescriptor( persistenceUnitInfo );\n\t\t\treturn getEntityManagerFactoryBuilder( descriptor, integrationSettings ).build();\n\t\t}\n\t}\n}\n",
        "diffSourceCodeSet": [
            "private static void setJpaComplianceProperties(Properties properties, Jpa jpa) {\n\t\tproperties.put( AvailableSettings.JPA_COMPLIANCE, jpa.jpaComplianceEnabled() );\n\t\tproperties.put( AvailableSettings.JPA_QUERY_COMPLIANCE, jpa.queryComplianceEnabled() );\n\t\tproperties.put( AvailableSettings.JPA_TRANSACTION_COMPLIANCE, jpa.transactionComplianceEnabled() );\n\t\tproperties.put( AvailableSettings.JPA_CLOSED_COMPLIANCE, jpa.closedComplianceEnabled() );\n\t\tproperties.put( AvailableSettings.JPA_PROXY_COMPLIANCE, jpa.proxyComplianceEnabled() );\n\t\tproperties.put( AvailableSettings.JPA_CACHING_COMPLIANCE, jpa.cacheComplianceEnabled() );\n\t\tproperties.put( AvailableSettings.JPA_ID_GENERATOR_GLOBAL_SCOPE_COMPLIANCE, jpa.generatorScopeComplianceEnabled() );\n\t\tproperties.put( AvailableSettings.JPA_ORDER_BY_MAPPING_COMPLIANCE, jpa.orderByMappingComplianceEnabled() );\n\t\tproperties.put( AvailableSettings.JPA_LOAD_BY_ID_COMPLIANCE, jpa.loadByIdComplianceEnabled() );\n\t}"
        ],
        "invokedMethodSet": [
            "methodSignature: org.hibernate.jpa.boot.internal.ParsedPersistenceXmlDescriptor#setValidationMode\n methodBody: public void setValidationMode(String validationMode) {\nsetValidationMode(ValidationMode.valueOf(validationMode));\n}",
            "methodSignature: org.hibernate.testing.junit4.BaseNonConfigCoreFunctionalTestCase#getAnnotatedClasses\n methodBody: protected Class[] getAnnotatedClasses() {\nreturn NO_CLASSES;\n}",
            "methodSignature: org.hibernate.jpa.boot.internal.PersistenceUnitInfoDescriptor#getName\n methodBody: public String getName() {\nreturn persistenceUnitInfo.getPersistenceUnitName();\n}",
            "methodSignature: org.hibernate.testing.orm.jpa.PersistenceUnitInfoImpl#setTransactionType\n methodBody: public void setTransactionType(PersistenceUnitTransactionType transactionType) {\nthis.transactionType=transactionType;\n}",
            "methodSignature: org.hibernate.testing.orm.junit.EntityManagerFactoryBasedFunctionalTest#applySettings\n methodBody: protected void applySettings(Map<Object, Object> settings) {\nString[] mappings=getMappings();\nif(mappings != null){settings.put(AvailableSettings.HBM_XML_FILES,String.join(\",\",mappings));\n}}",
            "methodSignature: org.hibernate.testing.orm.jpa.PersistenceUnitInfoImpl#setValidationMode\n methodBody: public void setValidationMode(ValidationMode validationMode) {\nthis.validationMode=validationMode;\n}",
            "methodSignature: org.hibernate.collection.spi.AbstractPersistentCollection.SetProxy#isEmpty\n methodBody: public boolean isEmpty() {\nreturn set.isEmpty();\n}",
            "methodSignature: org.hibernate.testing.orm.jpa.PersistenceUnitInfoImpl#applyMappingFiles\n methodBody: public void applyMappingFiles(String... mappingFiles) {\nif(this.mappingFiles == null){this.mappingFiles=new ArrayList<>();\n}Collections.addAll(this.mappingFiles,mappingFiles);\n}",
            "methodSignature: org.hibernate.testing.util.jpa.DelegatingPersistenceUnitInfo#getProperties\n methodBody: public Properties getProperties() {\nreturn delegate.getProperties();\n}",
            "methodSignature: org.hibernate.orm.test.exceptionhandling.BaseJpaOrNativeBootstrapFunctionalTestCase.TestingPersistenceUnitDescriptorImpl#getName\n methodBody: public String getName() {\nreturn name;\n}",
            "methodSignature: org.hibernate.collection.spi.PersistentList#get\n methodBody: public E get(int index) {\nif(index < 0){throw new ArrayIndexOutOfBoundsException(\"negative index\");\n}final Object result=readElementByIndex(index);\nreturn result == UNKNOWN ? list.get(index) : (E)result;\n}",
            "methodSignature: org.hibernate.orm.test.bootstrap.BootstrapTest.PersistenceUnitInfoImpl#getProperties\n methodBody: public Properties getProperties() {\nreturn properties;\n}",
            "methodSignature: org.hibernate.testing.orm.junit.EntityManagerFactoryBasedFunctionalTest.TestingPersistenceUnitDescriptorImpl#getName\n methodBody: public String getName() {\nreturn name;\n}",
            "methodSignature: org.hibernate.jpa.boot.spi.PersistenceConfigurationDescriptor#getName\n methodBody: public String getName() {\nreturn persistenceConfiguration.name();\n}",
            "methodSignature: org.hibernate.jpa.boot.internal.PersistenceUnitInfoDescriptor#getProperties\n methodBody: public Properties getProperties() {\nreturn persistenceUnitInfo.getProperties();\n}",
            "methodSignature: org.hibernate.jpa.boot.spi.PersistenceUnitDescriptor#getProperties\n methodBody: Properties getProperties();",
            "methodSignature: org.hibernate.testing.orm.junit.BaseSessionFactoryFunctionalTest#getAnnotatedClasses\n methodBody: protected Class[] getAnnotatedClasses() {\nreturn NO_CLASSES;\n}",
            "methodSignature: org.hibernate.testing.orm.junit.BaseSessionFactoryFunctionalTest#applySettings\n methodBody: protected void applySettings(StandardServiceRegistryBuilder builder) {\n}",
            "methodSignature: org.hibernate.testing.orm.jpa.PersistenceUnitInfoAdapter#getProperties\n methodBody: public Properties getProperties() {\nif(properties == null){properties=new Properties();\n}return properties;\n}",
            "methodSignature: org.hibernate.testing.util.jpa.DelegatingPersistenceUnitInfo#excludeUnlistedClasses\n methodBody: public boolean excludeUnlistedClasses() {\nreturn delegate.excludeUnlistedClasses();\n}",
            "methodSignature: org.hibernate.testing.util.jpa.PersistenceUnitInfoAdapter#getProperties\n methodBody: public Properties getProperties() {\nreturn properties;\n}",
            "methodSignature: org.hibernate.testing.orm.jpa.PersistenceUnitInfoImpl#setCacheMode\n methodBody: public void setCacheMode(SharedCacheMode cacheMode) {\nthis.cacheMode=cacheMode;\n}",
            "methodSignature: org.hibernate.jpa.boot.internal.ParsedPersistenceXmlDescriptor#getName\n methodBody: public String getName() {\nreturn name;\n}",
            "methodSignature: org.hibernate.orm.test.jpa.BaseEntityManagerFunctionalTestCase.TestingPersistenceUnitDescriptorImpl#getName\n methodBody: public String getName() {\nreturn name;\n}",
            "methodSignature: org.hibernate.testing.orm.jpa.PersistenceUnitInfoImpl#excludeUnlistedClasses\n methodBody: public boolean excludeUnlistedClasses() {\nreturn excludeUnlistedClasses;\n}",
            "methodSignature: org.hibernate.testing.orm.junit.EntityManagerFactoryBasedFunctionalTest#getAnnotatedClasses\n methodBody: protected Class<?>[] getAnnotatedClasses() {\nreturn NO_CLASSES;\n}",
            "methodSignature: org.hibernate.collection.spi.AbstractPersistentCollection.ListProxy#get\n methodBody: public E get(int i) {\nreturn list.get(i);\n}",
            "methodSignature: org.hibernate.testing.util.jpa.PersistenceUnitInfoAdapter#excludeUnlistedClasses\n methodBody: public boolean excludeUnlistedClasses() {\nreturn false;\n}",
            "methodSignature: org.hibernate.orm.test.exceptionhandling.BaseJpaOrNativeBootstrapFunctionalTestCase#getAnnotatedClasses\n methodBody: protected Class<?>[] getAnnotatedClasses() {\nreturn NO_CLASSES;\n}",
            "methodSignature: org.hibernate.orm.test.bootstrap.BootstrapTest.PersistenceUnitInfoImpl#excludeUnlistedClasses\n methodBody: public boolean excludeUnlistedClasses() {\nreturn false;\n}",
            "methodSignature: org.hibernate.jpa.boot.spi.PersistenceConfigurationDescriptor#getProperties\n methodBody: public Properties getProperties() {\nreturn properties;\n}",
            "methodSignature: org.hibernate.testing.orm.jpa.PersistenceUnitDescriptorAdapter#getProperties\n methodBody: public Properties getProperties() {\nif(properties == null){properties=new Properties();\n}return properties;\n}",
            "methodSignature: org.hibernate.collection.spi.PersistentBag#get\n methodBody: public E get(int i) {\nread();\nreturn bag.get(i);\n}",
            "methodSignature: org.hibernate.testing.orm.jpa.PersistenceUnitInfoAdapter#excludeUnlistedClasses\n methodBody: public boolean excludeUnlistedClasses() {\nreturn false;\n}",
            "methodSignature: org.hibernate.testing.orm.jpa.PersistenceUnitInfoImpl#setExcludeUnlistedClasses\n methodBody: public void setExcludeUnlistedClasses(boolean excludeUnlistedClasses) {\nthis.excludeUnlistedClasses=excludeUnlistedClasses;\n}",
            "methodSignature: org.hibernate.collection.spi.PersistentList#toString\n methodBody: public String toString() {\nread();\nreturn list.toString();\n}",
            "methodSignature: org.hibernate.testing.junit4.BaseCoreFunctionalTestCase#getAnnotatedClasses\n methodBody: protected Class<?>[] getAnnotatedClasses() {\nreturn NO_CLASSES;\n}",
            "methodSignature: org.hibernate.collection.spi.PersistentBag#getElement\n methodBody: public Object getElement(Object entry) {\nreturn entry;\n}",
            "methodSignature: org.hibernate.collection.spi.PersistentBag#isEmpty\n methodBody: public boolean isEmpty() {\nreturn readSize() ? getCachedSize() == 0 : bag.isEmpty();\n}",
            "methodSignature: org.hibernate.orm.test.jpa.xml.versions.JpaXsdVersionsTest.PersistenceUnitInfoImpl#getProperties\n methodBody: public Properties getProperties() {\nreturn properties;\n}",
            "methodSignature: org.hibernate.jpa.boot.internal.ParsedPersistenceXmlDescriptor#setTransactionType\n methodBody: public void setTransactionType(PersistenceUnitTransactionType transactionType) {\nthis.transactionType=transactionType;\n}",
            "methodSignature: org.hibernate.orm.test.jpa.EntityManagerTest#getAnnotatedClasses\n methodBody: public Class[] getAnnotatedClasses() {\nreturn new Class[]{Item.class,Distributor.class,Wallet.class};\n}",
            "methodSignature: org.hibernate.orm.test.jpa.BaseEntityManagerFunctionalTestCase#getAnnotatedClasses\n methodBody: protected Class<?>[] getAnnotatedClasses() {\nreturn NO_CLASSES;\n}",
            "methodSignature: org.hibernate.testing.orm.junit.EntityManagerFactoryBasedFunctionalTest#exportSchema\n methodBody: protected boolean exportSchema() {\nreturn true;\n}",
            "methodSignature: org.hibernate.jpa.boot.internal.ParsedPersistenceXmlDescriptor#getProperties\n methodBody: public Properties getProperties() {\nreturn properties;\n}",
            "methodSignature: org.hibernate.internal.SessionFactoryImpl#getProperties\n methodBody: public Map<String, Object> getProperties() {\nvalidateNotClosed();\nreturn settings;\n}",
            "methodSignature: org.hibernate.testing.util.jpa.PersistenceUnitInfoPropertiesWrapper#excludeUnlistedClasses\n methodBody: public boolean excludeUnlistedClasses() {\nreturn false;\n}",
            "methodSignature: org.hibernate.orm.test.jpa.xml.versions.JpaXsdVersionsTest.PersistenceUnitInfoImpl#excludeUnlistedClasses\n methodBody: public boolean excludeUnlistedClasses() {\nreturn false;\n}",
            "methodSignature: org.hibernate.jpa.boot.spi.PersistenceUnitDescriptor#getName\n methodBody: String getName();",
            "methodSignature: org.hibernate.orm.test.exceptionhandling.BaseJpaOrNativeBootstrapFunctionalTestCase.TestingPersistenceUnitDescriptorImpl#getProperties\n methodBody: public Properties getProperties() {\nreturn null;\n}",
            "methodSignature: org.hibernate.testing.orm.jpa.PersistenceUnitDescriptorAdapter#getName\n methodBody: public String getName() {\nreturn name;\n}",
            "methodSignature: org.hibernate.testing.orm.junit.EntityManagerFactoryExtension#locateExtensionStore\n methodBody: private static ExtensionContext.Store locateExtensionStore(Object testScope, ExtensionContext context) {\nreturn JUnitHelper.locateExtensionStore(EntityManagerFactoryExtension.class,context,testScope);\n}",
            "methodSignature: org.hibernate.jpa.boot.internal.ParsedPersistenceXmlDescriptor#setExcludeUnlistedClasses\n methodBody: public void setExcludeUnlistedClasses(boolean excludeUnlistedClasses) {\nthis.excludeUnlistedClasses=excludeUnlistedClasses;\n}",
            "methodSignature: org.hibernate.testing.orm.jpa.PersistenceUnitInfoImpl#applyManagedClassNames\n methodBody: public void applyManagedClassNames(String... managedClassNames) {\nif(this.managedClassNames == null){this.managedClassNames=new ArrayList<>();\n}Collections.addAll(this.managedClassNames,managedClassNames);\n}",
            "methodSignature: org.hibernate.testing.util.jpa.PersistenceUnitInfoPropertiesWrapper#getProperties\n methodBody: public Properties getProperties() {\nif(properties == null){properties=new Properties();\n}return properties;\n}",
            "methodSignature: org.hibernate.collection.spi.PersistentList#getElement\n methodBody: public Object getElement(Object entry) {\nreturn entry;\n}",
            "methodSignature: org.hibernate.orm.test.jpa.BaseEntityManagerFunctionalTestCase.TestingPersistenceUnitDescriptorImpl#getProperties\n methodBody: public Properties getProperties() {\nreturn null;\n}",
            "methodSignature: org.hibernate.internal.SessionFactoryImpl#getName\n methodBody: public String getName() {\nreturn name;\n}",
            "methodSignature: org.hibernate.testing.orm.junit.EntityManagerFactoryBasedFunctionalTest.TestingPersistenceUnitDescriptorImpl#getProperties\n methodBody: public Properties getProperties() {\nreturn null;\n}",
            "methodSignature: org.hibernate.collection.spi.PersistentList#isEmpty\n methodBody: public boolean isEmpty() {\nreturn readSize() ? getCachedSize() == 0 : list.isEmpty();\n}",
            "methodSignature: org.hibernate.testing.orm.jpa.PersistenceUnitInfoImpl#getProperties\n methodBody: public Properties getProperties() {\nreturn properties;\n}",
            "methodSignature: org.hibernate.testing.orm.junit.EntityManagerFactoryExtension#instantiateDomainModelDescriptor\n methodBody: private static DomainModelDescriptor instantiateDomainModelDescriptor(Class<? extends DomainModelDescriptor> modelDescriptorClass) {\ntryfinal Field[] declaredFields=modelDescriptorClass.getDeclaredFields();\nfor(int i=0; i < declaredFields.length; i++){final Field field=declaredFields[i];\nif(ReflectHelper.isStaticField(field)){final Object value=field.get(null);\nif(value instanceof DomainModelDescriptor){return (DomainModelDescriptor)value;\n}}}catch(IllegalAccessException e)throw new RuntimeException(\"Problem accessing DomainModelDescriptor fields : \" + modelDescriptorClass.getName(),e);\ntryreturn modelDescriptorClass.getConstructor(null).newInstance(null);\ncatch(InstantiationException|IllegalAccessException|InvocationTargetException|NoSuchMethodException e)throw new RuntimeException(\"Problem instantiation DomainModelDescriptor : \" + modelDescriptorClass.getName(),e);\n}",
            "methodSignature: org.hibernate.testing.orm.junit.BaseSessionFactoryFunctionalTest#exportSchema\n methodBody: protected boolean exportSchema() {\nreturn true;\n}",
            "methodSignature: org.hibernate.collection.spi.AbstractPersistentCollection.ListProxy#isEmpty\n methodBody: public boolean isEmpty() {\nreturn list.isEmpty();\n}",
            "methodSignature: org.hibernate.collection.spi.PersistentBag#toString\n methodBody: public String toString() {\nread();\nreturn bag.toString();\n}"
        ],
        "sourceCodeAfterRefactoring": "private static void collectProperties(PersistenceUnitInfoImpl pui, Jpa jpa) {\n\t\tfinal Properties properties = pui.getProperties();\n\t\tproperties.putAll( Environment.getProperties() );\n\t\t// JpaCompliance\n\t\tsetJpaComplianceProperties( properties, jpa );\n\t\tfor ( Setting property : jpa.properties() ) {\n\t\t\tproperties.setProperty( property.name(), property.value() );\n\t\t}\n\t\tproperties.setProperty(\n\t\t\t\tAvailableSettings.GENERATE_STATISTICS,\n\t\t\t\tBoolean.toString( jpa.generateStatistics() )\n\t\t);\n\t\tif ( jpa.exportSchema() ) {\n\t\t\tproperties.setProperty(\n\t\t\t\t\tAvailableSettings.JAKARTA_HBM2DDL_DATABASE_ACTION,\n\t\t\t\t\tAction.CREATE_DROP.getExternalHbm2ddlName()\n\t\t\t);\n\t\t}\n\t}\nprivate static void setJpaComplianceProperties(Properties properties, Jpa jpa) {\n\t\tproperties.put( AvailableSettings.JPA_COMPLIANCE, jpa.jpaComplianceEnabled() );\n\t\tproperties.put( AvailableSettings.JPA_QUERY_COMPLIANCE, jpa.queryComplianceEnabled() );\n\t\tproperties.put( AvailableSettings.JPA_TRANSACTION_COMPLIANCE, jpa.transactionComplianceEnabled() );\n\t\tproperties.put( AvailableSettings.JPA_CLOSED_COMPLIANCE, jpa.closedComplianceEnabled() );\n\t\tproperties.put( AvailableSettings.JPA_PROXY_COMPLIANCE, jpa.proxyComplianceEnabled() );\n\t\tproperties.put( AvailableSettings.JPA_CACHING_COMPLIANCE, jpa.cacheComplianceEnabled() );\n\t\tproperties.put( AvailableSettings.JPA_ID_GENERATOR_GLOBAL_SCOPE_COMPLIANCE, jpa.generatorScopeComplianceEnabled() );\n\t\tproperties.put( AvailableSettings.JPA_ORDER_BY_MAPPING_COMPLIANCE, jpa.orderByMappingComplianceEnabled() );\n\t\tproperties.put( AvailableSettings.JPA_LOAD_BY_ID_COMPLIANCE, jpa.loadByIdComplianceEnabled() );\n\t}",
        "diffSourceCode": "-   66: \tpublic static EntityManagerFactoryScope findEntityManagerFactoryScope(\n-   67: \t\t\tObject testScope,\n-   68: \t\t\tOptional<Jpa> emfAnnWrapper,\n-   69: \t\t\tExtensionContext context) {\n-   70: \n-   71: \t\tif ( emfAnnWrapper.isEmpty() ) {\n-   72: \t\t\t// No annotation on the test class, should be on the test methods\n-   73: \t\t\treturn null;\n-   74: \t\t}\n-   75: \n-   76: \t\tfinal ExtensionContext.Store store = locateExtensionStore( testScope, context );\n-   77: \t\tfinal EntityManagerFactoryScope existing = (EntityManagerFactoryScope) store.get( EMF_KEY );\n-   78: \t\tif ( existing != null ) {\n-   79: \t\t\treturn existing;\n-   80: \t\t}\n-   81: \n-   82: \t\tif ( !context.getElement().isPresent() ) {\n-   83: \t\t\tthrow new RuntimeException( \"Unable to determine how to handle given ExtensionContext : \" + context.getDisplayName() );\n-   84: \t\t}\n-   85: \t\tfinal Jpa emfAnn = emfAnnWrapper.get();\n-   86: \n-   87: \t\tfinal PersistenceUnitInfoImpl pui = new PersistenceUnitInfoImpl( emfAnn.persistenceUnitName() );\n-   88: \t\t( (Map<Object, Object>) Environment.getProperties() ).forEach(\n-   89: \t\t\t\t(key, value) ->\n-   90: \t\t\t\t\t\tpui.getProperties().put( key, value )\n-   91: \t\t);\n+   66: \t\t\treturn null;\n+   67: \t\t}\n+   68: \n+   69: \t\tfinal ExtensionContext.Store store = locateExtensionStore( testScope, context );\n+   70: \t\tfinal EntityManagerFactoryScope existing = (EntityManagerFactoryScope) store.get( EMF_KEY );\n+   71: \t\tif ( existing != null ) {\n+   72: \t\t\treturn existing;\n+   73: \t\t}\n+   74: \t\tif ( context.getElement().isEmpty() ) {\n+   75: \t\t\tthrow new RuntimeException( \"Unable to determine how to handle given ExtensionContext : \"\n+   76: \t\t\t\t\t+ context.getDisplayName() );\n+   77: \t\t}\n+   78: \n+   79: \t\tfinal Jpa jpa = optionalJpa.get();\n+   80: \t\tfinal PersistenceUnitInfoImpl pui = createPersistenceUnitInfo( jpa );\n+   81: \t\tcollectProperties( pui, jpa );\n+   82: \t\tmanagedClassesAndMappings( jpa, pui );\n+   83: \t\tfinal Map<String, Object> integrationSettings = collectIntegrationSettings( jpa );\n+   84: \t\t// statement inspector\n+   85: \t\tsetupStatementInspector( jpa, integrationSettings );\n+   86: \t\tServiceRegistryUtil.applySettings( integrationSettings );\n+   87: \t\tfinal EntityManagerFactoryScopeImpl scope =\n+   88: \t\t\t\tnew EntityManagerFactoryScopeImpl( pui, integrationSettings );\n+   89: \t\tstore.put( EMF_KEY, scope );\n+   90: \t\treturn scope;\n+   91: \t}\n    92: \n-   93: \t\tpui.setTransactionType( emfAnn.transactionType() );\n-   94: \t\tpui.setCacheMode( emfAnn.sharedCacheMode() );\n-   95: \t\tpui.setValidationMode( emfAnn.validationMode() );\n-   96: \t\tpui.setExcludeUnlistedClasses( emfAnn.excludeUnlistedClasses() );\n-   97: \n-   98: \t\t// JpaCompliance\n-   99: \t\tpui.getProperties().put( AvailableSettings.JPA_COMPLIANCE, emfAnn.jpaComplianceEnabled() );\n-  100: \t\tpui.getProperties().put( AvailableSettings.JPA_QUERY_COMPLIANCE, emfAnn.queryComplianceEnabled() );\n-  101: \t\tpui.getProperties().put( AvailableSettings.JPA_TRANSACTION_COMPLIANCE, emfAnn.transactionComplianceEnabled() );\n-  102: \t\tpui.getProperties().put( AvailableSettings.JPA_CLOSED_COMPLIANCE, emfAnn.closedComplianceEnabled() );\n-  103: \t\tpui.getProperties().put( AvailableSettings.JPA_PROXY_COMPLIANCE, emfAnn.proxyComplianceEnabled() );\n-  104: \t\tpui.getProperties().put( AvailableSettings.JPA_CACHING_COMPLIANCE, emfAnn.cacheComplianceEnabled() );\n-  105: \t\tpui.getProperties().put( AvailableSettings.JPA_ID_GENERATOR_GLOBAL_SCOPE_COMPLIANCE, emfAnn.generatorScopeComplianceEnabled() );\n-  106: \t\tpui.getProperties().put( AvailableSettings.JPA_ORDER_BY_MAPPING_COMPLIANCE, emfAnn.orderByMappingComplianceEnabled() );\n-  107: \t\tpui.getProperties().put( AvailableSettings.JPA_LOAD_BY_ID_COMPLIANCE, emfAnn.loadByIdComplianceEnabled() );\n-  108: \n-  109: \t\tfinal Setting[] properties = emfAnn.properties();\n-  110: \t\tfor ( int i = 0; i < properties.length; i++ ) {\n-  111: \t\t\tfinal Setting property = properties[i];\n-  112: \t\t\tpui.getProperties().setProperty( property.name(), property.value() );\n-  113: \t\t}\n-  114: \n-  115: \t\tpui.getProperties().setProperty(\n-  116: \t\t\t\tAvailableSettings.GENERATE_STATISTICS,\n-  117: \t\t\t\tBoolean.toString( emfAnn.generateStatistics() )\n-  118: \t\t);\n-  119: \n-  120: \t\tif ( emfAnn.exportSchema() ) {\n-  121: \t\t\tpui.getProperties().setProperty(\n-  122: \t\t\t\t\tAvailableSettings.JAKARTA_HBM2DDL_DATABASE_ACTION,\n-  123: \t\t\t\t\tAction.CREATE_DROP.getExternalHbm2ddlName()\n-  124: \t\t\t);\n-  125: \t\t}\n-  126: \n-  127: \t\tif ( emfAnn.annotatedPackageNames().length > 0 ) {\n-  128: \t\t\tpui.applyManagedClassNames( emfAnn.annotatedPackageNames() );\n-  129: \t\t}\n-  130: \n-  131: \t\tif ( emfAnn.annotatedClassNames().length > 0 ) {\n-  132: \t\t\tpui.applyManagedClassNames( emfAnn.annotatedClassNames() );\n-  133: \t\t}\n-  134: \n-  135: \t\tif ( emfAnn.annotatedClasses().length > 0 ) {\n-  136: \t\t\tfor ( int i = 0; i < emfAnn.annotatedClasses().length; i++ ) {\n-  137: \t\t\t\tpui.applyManagedClassNames( emfAnn.annotatedClasses()[i].getName() );\n-  138: \t\t\t}\n-  139: \t\t}\n-  140: \n-  141: \t\tif ( emfAnn.xmlMappings().length > 0 ) {\n-  142: \t\t\tpui.applyMappingFiles( emfAnn.xmlMappings() );\n-  143: \t\t}\n-  144: \n-  145: \t\tif ( emfAnn.standardModels().length > 0 ) {\n-  146: \t\t\tfor ( int i = 0; i < emfAnn.standardModels().length; i++ ) {\n-  147: \t\t\t\tfinal StandardDomainModel standardDomainModel = emfAnn.standardModels()[i];\n-  148: \t\t\t\tfor ( int i1 = 0; i1 < standardDomainModel.getDescriptor().getAnnotatedClasses().length; i1++ ) {\n-  149: \t\t\t\t\tfinal Class<?> annotatedClass = standardDomainModel.getDescriptor().getAnnotatedClasses()[i1];\n-  150: \t\t\t\t\tpui.applyManagedClassNames( annotatedClass.getName() );\n-  151: \t\t\t\t}\n-  152: \t\t\t}\n-  153: \t\t}\n-  154: \n-  155: \t\tif ( emfAnn.modelDescriptorClasses().length > 0 ) {\n-  156: \t\t\tfor ( int i = 0; i < emfAnn.modelDescriptorClasses().length; i++ ) {\n-  157: \t\t\t\tfinal Class<? extends DomainModelDescriptor> modelDescriptorClass = emfAnn.modelDescriptorClasses()[i];\n-  158: \t\t\t\tfinal DomainModelDescriptor domainModelDescriptor = instantiateDomainModelDescriptor(\n-  159: \t\t\t\t\t\tmodelDescriptorClass );\n-  160: \t\t\t\tfor ( int i1 = 0; i1 < domainModelDescriptor.getAnnotatedClasses().length; i1++ ) {\n-  161: \t\t\t\t\tfinal Class<?> annotatedClass = domainModelDescriptor.getAnnotatedClasses()[i1];\n-  162: \t\t\t\t\tpui.applyManagedClassNames( annotatedClass.getName() );\n-  163: \t\t\t\t}\n-  164: \t\t\t}\n-  165: \t\t}\n-  166: \n-  167: \t\tfinal Map<String, Object> integrationSettings = new HashMap<>();\n-  168: \n-  169: \t\tintegrationSettings.put( PersistentTableStrategy.DROP_ID_TABLES, \"true\" );\n-  170: \t\tintegrationSettings.put( GlobalTemporaryTableMutationStrategy.DROP_ID_TABLES, \"true\" );\n-  171: \t\tintegrationSettings.put( LocalTemporaryTableMutationStrategy.DROP_ID_TABLES, \"true\" );\n-  172: \t\tfor ( int i = 0; i < emfAnn.integrationSettings().length; i++ ) {\n-  173: \t\t\tfinal Setting setting = emfAnn.integrationSettings()[i];\n-  174: \t\t\tintegrationSettings.put( setting.name(), setting.value() );\n-  175: \t\t}\n-  176: \n-  177: \t\tfor ( SettingProvider providerAnn : emfAnn.settingProviders() ) {\n-  178: \t\t\tfinal Class<? extends SettingProvider.Provider<?>> providerImpl = providerAnn.provider();\n-  179: \t\t\ttry {\n-  180: \t\t\t\tfinal SettingProvider.Provider<?> provider = providerImpl.getConstructor().newInstance();\n-  181: \t\t\t\tintegrationSettings.put( providerAnn.settingName(), provider.getSetting() );\n-  182: \t\t\t}\n-  183: \t\t\tcatch (Exception e) {\n-  184: \t\t\t\tlog.error( \"Error obtaining setting provider for \" + providerImpl.getName(), e );\n-  185: \t\t\t}\n-  186: \t\t}\n-  187: \n-  188: \t\t// statement inspector\n-  189: \t\tif ( emfAnn.useCollectingStatementInspector() ) {\n-  190: \t\t\tString inspectorSetting = (String) integrationSettings.get( AvailableSettings.STATEMENT_INSPECTOR );\n-  191: \t\t\tif ( !(inspectorSetting == null || inspectorSetting.isBlank()) ) {\n-  192: \t\t\t\tlog.warn( String.format( \"Overriding the explicit \\\"%1s\\\" statement inspector setting\", inspectorSetting ) );\n-  193: \t\t\t}\n-  194: \t\t\tintegrationSettings.put( AvailableSettings.STATEMENT_INSPECTOR, new SQLStatementInspector() );\n-  195: \t\t}\n-  196: \n-  197: \t\tServiceRegistryUtil.applySettings( integrationSettings );\n-  198: \t\tfinal EntityManagerFactoryScopeImpl scope = new EntityManagerFactoryScopeImpl( pui, integrationSettings );\n-  199: \n-  200: \t\tstore.put( EMF_KEY, scope );\n-  201: \n-  202: \t\treturn scope;\n-  203: \t}\n+   93: \tprivate static void collectProperties(PersistenceUnitInfoImpl pui, Jpa jpa) {\n+   94: \t\tfinal Properties properties = pui.getProperties();\n+   95: \t\tproperties.putAll( Environment.getProperties() );\n+   96: \t\t// JpaCompliance\n+   97: \t\tsetJpaComplianceProperties( properties, jpa );\n+   98: \t\tfor ( Setting property : jpa.properties() ) {\n+   99: \t\t\tproperties.setProperty( property.name(), property.value() );\n+  100: \t\t}\n+  101: \t\tproperties.setProperty(\n+  102: \t\t\t\tAvailableSettings.GENERATE_STATISTICS,\n+  103: \t\t\t\tBoolean.toString( jpa.generateStatistics() )\n+  104: \t\t);\n+  105: \t\tif ( jpa.exportSchema() ) {\n+  106: \t\t\tproperties.setProperty(\n+  107: \t\t\t\t\tAvailableSettings.JAKARTA_HBM2DDL_DATABASE_ACTION,\n+  108: \t\t\t\t\tAction.CREATE_DROP.getExternalHbm2ddlName()\n+  109: \t\t\t);\n+  110: \t\t}\n+  111: \t}\n+  112: \n+  113: \tprivate static PersistenceUnitInfoImpl createPersistenceUnitInfo(Jpa jpa) {\n+  114: \t\tfinal PersistenceUnitInfoImpl pui =\n+  115: \t\t\t\tnew PersistenceUnitInfoImpl( jpa.persistenceUnitName() );\n+  116: \t\tpui.setTransactionType( jpa.transactionType() );\n+  117: \t\tpui.setCacheMode( jpa.sharedCacheMode() );\n+  118: \t\tpui.setValidationMode( jpa.validationMode() );\n+  119: \t\tpui.setExcludeUnlistedClasses( jpa.excludeUnlistedClasses() );\n+  120: \t\treturn pui;\n+  121: \t}\n+  122: \n+  123: \tprivate static void managedClassesAndMappings(Jpa jpa, PersistenceUnitInfoImpl pui) {\n+  124: \t\tif ( jpa.annotatedPackageNames().length > 0 ) {\n+  125: \t\t\tpui.applyManagedClassNames( jpa.annotatedPackageNames() );\n+  126: \t\t}\n+  127: \n+  128: \t\tif ( jpa.annotatedClassNames().length > 0 ) {\n+  129: \t\t\tpui.applyManagedClassNames( jpa.annotatedClassNames() );\n+  130: \t\t}\n+  131: \n+  132: \t\tif ( jpa.annotatedClasses().length > 0 ) {\n+  133: \t\t\tfor (int i = 0; i < jpa.annotatedClasses().length; i++ ) {\n+  134: \t\t\t\tpui.applyManagedClassNames( jpa.annotatedClasses()[i].getName() );\n+  135: \t\t\t}\n+  136: \t\t}\n+  137: \n+  138: \t\tif ( jpa.xmlMappings().length > 0 ) {\n+  139: \t\t\tpui.applyMappingFiles( jpa.xmlMappings() );\n+  140: \t\t}\n+  141: \n+  142: \t\tfor ( StandardDomainModel standardDomainModel : jpa.standardModels() ) {\n+  143: \t\t\tfor ( Class<?> annotatedClass : standardDomainModel.getDescriptor().getAnnotatedClasses() ) {\n+  144: \t\t\t\tpui.applyManagedClassNames( annotatedClass.getName() );\n+  145: \t\t\t}\n+  146: \t\t}\n+  147: \n+  148: \t\tfor ( Class<? extends DomainModelDescriptor> modelDescriptorClass :\n+  149: \t\t\t\tjpa.modelDescriptorClasses() ) {\n+  150: \t\t\tfinal DomainModelDescriptor domainModelDescriptor =\n+  151: \t\t\t\t\tinstantiateDomainModelDescriptor( modelDescriptorClass );\n+  152: \t\t\tfinal Class<?>[] annotatedClasses = domainModelDescriptor.getAnnotatedClasses();\n+  153: \t\t\tfor ( Class<?> annotatedClass : annotatedClasses ) {\n+  154: \t\t\t\tpui.applyManagedClassNames( annotatedClass.getName() );\n+  155: \t\t\t}\n+  156: \t\t}\n+  157: \t}\n+  158: \n+  159: \tprivate static Map<String, Object> collectIntegrationSettings(Jpa jpa) {\n+  160: \t\tfinal Map<String, Object> integrationSettings = new HashMap<>();\n+  161: \t\tintegrationSettings.put( PersistentTableStrategy.DROP_ID_TABLES, \"true\" );\n+  162: \t\tintegrationSettings.put( GlobalTemporaryTableMutationStrategy.DROP_ID_TABLES, \"true\" );\n+  163: \t\tintegrationSettings.put( LocalTemporaryTableMutationStrategy.DROP_ID_TABLES, \"true\" );\n+  164: \t\tfinal Setting[] settings = jpa.integrationSettings();\n+  165: \t\tfor ( Setting setting : settings ) {\n+  166: \t\t\tintegrationSettings.put( setting.name(), setting.value() );\n+  167: \t\t}\n+  168: \t\tfor ( SettingProvider providerAnn : jpa.settingProviders() ) {\n+  169: \t\t\tfinal Class<? extends SettingProvider.Provider<?>> providerImpl = providerAnn.provider();\n+  170: \t\t\ttry {\n+  171: \t\t\t\tintegrationSettings.put( providerAnn.settingName(),\n+  172: \t\t\t\t\t\tproviderImpl.getConstructor().newInstance().getSetting() );\n+  173: \t\t\t}\n+  174: \t\t\tcatch (Exception e) {\n+  175: \t\t\t\tlog.error( \"Error obtaining setting provider for \" + providerImpl.getName(), e );\n+  176: \t\t\t}\n+  177: \t\t}\n+  178: \t\treturn integrationSettings;\n+  179: \t}\n+  180: \n+  181: \tprivate static void setupStatementInspector(Jpa jpa, Map<String, Object> integrationSettings) {\n+  182: \t\tif ( jpa.useCollectingStatementInspector() ) {\n+  183: \t\t\tfinal String inspectorSetting = (String) integrationSettings.get( AvailableSettings.STATEMENT_INSPECTOR );\n+  184: \t\t\tif ( inspectorSetting != null && !inspectorSetting.isBlank() ) {\n+  185: \t\t\t\tlog.warn( String.format( \"Overriding the explicit \\\"%1s\\\" statement inspector setting\", inspectorSetting ) );\n+  186: \t\t\t}\n+  187: \t\t\tintegrationSettings.put( AvailableSettings.STATEMENT_INSPECTOR, new SQLStatementInspector() );\n+  188: \t\t}\n+  189: \t}\n+  190: \n+  191: \tprivate static void setJpaComplianceProperties(Properties properties, Jpa jpa) {\n+  192: \t\tproperties.put( AvailableSettings.JPA_COMPLIANCE, jpa.jpaComplianceEnabled() );\n+  193: \t\tproperties.put( AvailableSettings.JPA_QUERY_COMPLIANCE, jpa.queryComplianceEnabled() );\n+  194: \t\tproperties.put( AvailableSettings.JPA_TRANSACTION_COMPLIANCE, jpa.transactionComplianceEnabled() );\n+  195: \t\tproperties.put( AvailableSettings.JPA_CLOSED_COMPLIANCE, jpa.closedComplianceEnabled() );\n+  196: \t\tproperties.put( AvailableSettings.JPA_PROXY_COMPLIANCE, jpa.proxyComplianceEnabled() );\n+  197: \t\tproperties.put( AvailableSettings.JPA_CACHING_COMPLIANCE, jpa.cacheComplianceEnabled() );\n+  198: \t\tproperties.put( AvailableSettings.JPA_ID_GENERATOR_GLOBAL_SCOPE_COMPLIANCE, jpa.generatorScopeComplianceEnabled() );\n+  199: \t\tproperties.put( AvailableSettings.JPA_ORDER_BY_MAPPING_COMPLIANCE, jpa.orderByMappingComplianceEnabled() );\n+  200: \t\tproperties.put( AvailableSettings.JPA_LOAD_BY_ID_COMPLIANCE, jpa.loadByIdComplianceEnabled() );\n+  201: \t}\n+  202: \n+  203: \tprivate static DomainModelDescriptor instantiateDomainModelDescriptor(\n",
        "uniqueId": "4781c09d0df0eb4ce05b2fa0d2a12747023ae024_66_203_191_201_93_111",
        "moveFileExist": true,
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 21,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 7,
                "covered": 55
            },
            "BRANCH": {
                "missed": 1,
                "covered": 5
            },
            "LINE": {
                "missed": 2,
                "covered": 17
            },
            "COMPLEXITY": {
                "missed": 1,
                "covered": 3
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        }
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprivate canRollBack(sessionImplementor SessionImplementor) : boolean extracted from private completeStrayTransaction() : void in class org.hibernate.orm.test.exceptionhandling.BaseJpaOrNativeBootstrapFunctionalTestCase",
        "diffLocations": [
            {
                "filePath": "hibernate-core/src/test/java/org/hibernate/orm/test/exceptionhandling/BaseJpaOrNativeBootstrapFunctionalTestCase.java",
                "startLine": 361,
                "endLine": 384,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/test/java/org/hibernate/orm/test/exceptionhandling/BaseJpaOrNativeBootstrapFunctionalTestCase.java",
                "startLine": 352,
                "endLine": 374,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/test/java/org/hibernate/orm/test/exceptionhandling/BaseJpaOrNativeBootstrapFunctionalTestCase.java",
                "startLine": 376,
                "endLine": 379,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "private void completeStrayTransaction() {\n\t\tif ( session == null ) {\n\t\t\t// nothing to do\n\t\t\treturn;\n\t\t}\n\n\t\tif ( ( (SessionImplementor) session ).isClosed() ) {\n\t\t\t// nothing to do\n\t\t\treturn;\n\t\t}\n\n\t\tif ( !session.isConnected() ) {\n\t\t\t// nothing to do\n\t\t\treturn;\n\t\t}\n\n\t\tfinal TransactionCoordinator.TransactionDriver tdc =\n\t\t\t\t( (SessionImplementor) session ).getTransactionCoordinator().getTransactionDriverControl();\n\n\t\tif ( tdc.getStatus().canRollback() ) {\n\t\t\tsession.getTransaction().rollback();\n\t\t}\n\t\tsession.close();\n\t}",
        "filePathBefore": "hibernate-core/src/test/java/org/hibernate/orm/test/exceptionhandling/BaseJpaOrNativeBootstrapFunctionalTestCase.java",
        "isPureRefactoring": true,
        "commitId": "4781c09d0df0eb4ce05b2fa0d2a12747023ae024",
        "packageNameBefore": "org.hibernate.orm.test.exceptionhandling",
        "classNameBefore": "org.hibernate.orm.test.exceptionhandling.BaseJpaOrNativeBootstrapFunctionalTestCase",
        "methodNameBefore": "org.hibernate.orm.test.exceptionhandling.BaseJpaOrNativeBootstrapFunctionalTestCase#completeStrayTransaction",
        "invokedMethod": "methodSignature: org.hibernate.internal.SessionFactoryImpl#isClosed\n methodBody: public boolean isClosed() {\nreturn status == Status.CLOSED;\n}\nmethodSignature: org.hibernate.internal.SessionFactoryImpl#close\n methodBody: public void close() throws HibernateException {\nsynchronized(this){if(status != Status.OPEN){if(getSessionFactoryOptions().getJpaCompliance().isJpaClosedComplianceEnabled()){throw new IllegalStateException(\"EntityManagerFactory is already closed\");\n}LOG.trace(\"Already closed\");\nreturn;\n}status=Status.CLOSING;\n}tryLOG.closing();\nobserver.sessionFactoryClosing(this);\nif(cacheAccess != null){cacheAccess.close();\n}if(runtimeMetamodels != null && runtimeMetamodels.getMappingMetamodel() != null){final JdbcConnectionAccess jdbcConnectionAccess=jdbcServices.getBootstrapJdbcConnectionAccess();\nruntimeMetamodels.getMappingMetamodel().forEachEntityDescriptor(entityPersister -> {\n  if (entityPersister.getSqmMultiTableMutationStrategy() != null) {\n    entityPersister.getSqmMultiTableMutationStrategy().release(this,jdbcConnectionAccess);\n  }\n  if (entityPersister.getSqmMultiTableInsertStrategy() != null) {\n    entityPersister.getSqmMultiTableInsertStrategy().release(this,jdbcConnectionAccess);\n  }\n}\n);\n((MappingMetamodelImpl)runtimeMetamodels.getMappingMetamodel()).close();\n}if(queryEngine != null){queryEngine.close();\n}if(eventEngine != null){eventEngine.stop();\n}finallystatus=Status.CLOSED;\nobserver.sessionFactoryClosed(this);\nserviceRegistry.destroy();\n}",
        "classSignatureBefore": "public abstract class BaseJpaOrNativeBootstrapFunctionalTestCase extends BaseUnitTestCase ",
        "methodNameBeforeSet": [
            "org.hibernate.orm.test.exceptionhandling.BaseJpaOrNativeBootstrapFunctionalTestCase#completeStrayTransaction"
        ],
        "classNameBeforeSet": [
            "org.hibernate.orm.test.exceptionhandling.BaseJpaOrNativeBootstrapFunctionalTestCase"
        ],
        "classSignatureBeforeSet": [
            "public abstract class BaseJpaOrNativeBootstrapFunctionalTestCase extends BaseUnitTestCase "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Overlapped refactoring - can be identical by undoing the overlapped refactoring\n- Inline Variable-",
                "description": "Inline Variable on top of the extracted method - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.\n */\npackage org.hibernate.orm.test.exceptionhandling;\n\nimport java.net.URL;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Properties;\n\nimport org.hibernate.HibernateException;\nimport org.hibernate.Interceptor;\nimport org.hibernate.Session;\nimport org.hibernate.boot.registry.BootstrapServiceRegistry;\nimport org.hibernate.boot.registry.BootstrapServiceRegistryBuilder;\nimport org.hibernate.boot.registry.StandardServiceRegistryBuilder;\nimport org.hibernate.boot.registry.internal.StandardServiceRegistryImpl;\nimport org.hibernate.bytecode.enhance.spi.EnhancementContext;\nimport org.hibernate.bytecode.spi.ClassTransformer;\nimport org.hibernate.cfg.AvailableSettings;\nimport org.hibernate.cfg.Configuration;\nimport org.hibernate.cfg.Environment;\nimport org.hibernate.dialect.Dialect;\nimport org.hibernate.engine.spi.SessionFactoryImplementor;\nimport org.hibernate.engine.spi.SessionImplementor;\nimport org.hibernate.internal.util.PropertiesHelper;\nimport org.hibernate.internal.util.config.ConfigurationHelper;\nimport org.hibernate.jpa.HibernatePersistenceProvider;\nimport org.hibernate.jpa.boot.spi.Bootstrap;\nimport org.hibernate.jpa.boot.spi.PersistenceUnitDescriptor;\nimport org.hibernate.resource.transaction.spi.TransactionCoordinator;\n\nimport org.hibernate.testing.AfterClassOnce;\nimport org.hibernate.testing.BeforeClassOnce;\nimport org.hibernate.testing.cache.CachingRegionFactory;\nimport org.hibernate.testing.junit4.BaseUnitTestCase;\nimport org.hibernate.testing.orm.junit.DialectContext;\nimport org.hibernate.testing.util.ServiceRegistryUtil;\nimport org.junit.After;\n\nimport jakarta.persistence.EntityManager;\nimport jakarta.persistence.SharedCacheMode;\nimport jakarta.persistence.ValidationMode;\nimport jakarta.persistence.spi.PersistenceUnitTransactionType;\n\nimport static org.junit.Assert.fail;\n\n/**\n * A base class for all functional tests.\n */\npublic abstract class BaseJpaOrNativeBootstrapFunctionalTestCase extends BaseUnitTestCase {\n\n\t// IMPL NOTE : Here we use @Before and @After (instead of @BeforeClassOnce and @AfterClassOnce like we do in\n\t// BaseCoreFunctionalTestCase) because the old HEM test methodology was to create an EMF for each test method.\n\n\tprivate static final Dialect dialect = DialectContext.getDialect();\n\n\tpublic enum BootstrapMethod {\n\t\tJPA,\n\t\tNATIVE\n\t}\n\n\tprivate final BootstrapMethod bootstrapMethod;\n\n\tprivate StandardServiceRegistryImpl serviceRegistry;\n\tprivate SessionFactoryImplementor sessionFactory;\n\n\tprivate Session session;\n\n\tprotected Dialect getDialect() {\n\t\treturn dialect;\n\t}\n\n\tprotected SessionFactoryImplementor sessionFactory() {\n\t\treturn sessionFactory;\n\t}\n\n\tprotected StandardServiceRegistryImpl serviceRegistry() {\n\t\treturn serviceRegistry;\n\t}\n\n\tprotected Session openSession() throws HibernateException {\n\t\tsession = sessionFactory().openSession();\n\t\treturn session;\n\t}\n\n\tprotected Session openSession(Interceptor interceptor) throws HibernateException {\n\t\tsession = sessionFactory().withOptions().interceptor( interceptor ).openSession();\n\t\treturn session;\n\t}\n\n\tprotected EntityManager openEntityManager() throws HibernateException {\n\t\treturn openSession().unwrap( EntityManager.class );\n\t}\n\n\tprotected BaseJpaOrNativeBootstrapFunctionalTestCase(BootstrapMethod bootstrapMethod) {\n\t\tthis.bootstrapMethod = bootstrapMethod;\n\t}\n\n\t@BeforeClassOnce\n\t@SuppressWarnings( {\"UnusedDeclaration\"})\n\tpublic void buildSessionOrEntityManagerFactory() {\n\t\tswitch ( bootstrapMethod ) {\n\t\t\tcase JPA:\n\t\t\t\tbuildEntityManagerFactory();\n\t\t\t\tbreak;\n\t\t\tcase NATIVE:\n\t\t\t\tbuildSessionFactory();\n\t\t\t\tbreak;\n\t\t}\n\n\t\tafterSessionOrEntityManagerFactoryBuilt();\n\t}\n\n\tprivate void buildEntityManagerFactory() {\n\t\tlog.trace( \"Building EntityManagerFactory\" );\n\n\t\tProperties properties = buildProperties();\n\t\tArrayList<Class> classes = new ArrayList<Class>();\n\n\t\tclasses.addAll( Arrays.asList( getAnnotatedClasses() ) );\n\t\tproperties.put( org.hibernate.cfg.AvailableSettings.LOADED_CLASSES, classes );\n\t\tServiceRegistryUtil.applySettings( properties );\n\n\t\tsessionFactory =  Bootstrap.getEntityManagerFactoryBuilder(\n\t\t\t\tbuildPersistenceUnitDescriptor(),\n\t\t\t\tproperties\n\t\t).build().unwrap( SessionFactoryImplementor.class );\n\n\t\tserviceRegistry = (StandardServiceRegistryImpl) sessionFactory.getServiceRegistry()\n\t\t\t\t.getParentServiceRegistry();\n\t}\n\n\tprivate void buildSessionFactory() {\n\t\t// for now, build the configuration to get all the property settings\n\t\tConfiguration configuration = new Configuration();\n\t\tconfiguration.setProperties( buildProperties() );\n\n\t\tClass<?>[] annotatedClasses = getAnnotatedClasses();\n\t\tif ( annotatedClasses != null ) {\n\t\t\tfor ( Class<?> annotatedClass : annotatedClasses ) {\n\t\t\t\tconfiguration.addAnnotatedClass( annotatedClass );\n\t\t\t}\n\t\t}\n\n\t\tBootstrapServiceRegistry bootRegistry = buildBootstrapServiceRegistry();\n\t\tserviceRegistry = buildServiceRegistry( bootRegistry, configuration );\n\t\tsessionFactory = ( SessionFactoryImplementor ) configuration.buildSessionFactory( serviceRegistry );\n\n\t\tafterSessionOrEntityManagerFactoryBuilt();\n\t}\n\n\n\tprivate PersistenceUnitDescriptor buildPersistenceUnitDescriptor() {\n\t\treturn new TestingPersistenceUnitDescriptorImpl( getClass().getSimpleName() );\n\t}\n\n\tpublic static class TestingPersistenceUnitDescriptorImpl implements PersistenceUnitDescriptor {\n\t\tprivate final String name;\n\n\t\tpublic TestingPersistenceUnitDescriptorImpl(String name) {\n\t\t\tthis.name = name;\n\t\t}\n\n\t\t@Override\n\t\tpublic URL getPersistenceUnitRootUrl() {\n\t\t\treturn null;\n\t\t}\n\n\t\t@Override\n\t\tpublic String getName() {\n\t\t\treturn name;\n\t\t}\n\n\t\t@Override\n\t\tpublic String getProviderClassName() {\n\t\t\treturn HibernatePersistenceProvider.class.getName();\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean isUseQuotedIdentifiers() {\n\t\t\treturn false;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean isExcludeUnlistedClasses() {\n\t\t\treturn false;\n\t\t}\n\n\t\t@Override\n\t\tpublic PersistenceUnitTransactionType getTransactionType() {\n\t\t\treturn null;\n\t\t}\n\n\t\t@Override\n\t\tpublic ValidationMode getValidationMode() {\n\t\t\treturn null;\n\t\t}\n\n\t\t@Override\n\t\tpublic SharedCacheMode getSharedCacheMode() {\n\t\t\treturn null;\n\t\t}\n\n\t\t@Override\n\t\tpublic List<String> getManagedClassNames() {\n\t\t\treturn null;\n\t\t}\n\n\t\t@Override\n\t\tpublic List<String> getMappingFileNames() {\n\t\t\treturn null;\n\t\t}\n\n\t\t@Override\n\t\tpublic List<URL> getJarFileUrls() {\n\t\t\treturn null;\n\t\t}\n\n\t\t@Override\n\t\tpublic Object getNonJtaDataSource() {\n\t\t\treturn null;\n\t\t}\n\n\t\t@Override\n\t\tpublic Object getJtaDataSource() {\n\t\t\treturn null;\n\t\t}\n\n\t\t@Override\n\t\tpublic Properties getProperties() {\n\t\t\treturn null;\n\t\t}\n\n\t\t@Override\n\t\tpublic ClassLoader getClassLoader() {\n\t\t\treturn null;\n\t\t}\n\n\t\t@Override\n\t\tpublic ClassLoader getTempClassLoader() {\n\t\t\treturn null;\n\t\t}\n\n\t\t@Override\n\t\tpublic void pushClassTransformer(EnhancementContext enhancementContext) {\n\t\t}\n\n\t\t@Override\n\t\tpublic ClassTransformer getClassTransformer() {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tprivate BootstrapServiceRegistry buildBootstrapServiceRegistry() {\n\t\tfinal BootstrapServiceRegistryBuilder builder = new BootstrapServiceRegistryBuilder();\n\t\tbuilder.applyClassLoader( getClass().getClassLoader() );\n\t\tprepareBootstrapRegistryBuilder( builder );\n\t\treturn builder.build();\n\t}\n\n\tprotected void prepareBootstrapRegistryBuilder(BootstrapServiceRegistryBuilder builder) {\n\t}\n\n\tprivate StandardServiceRegistryImpl buildServiceRegistry(BootstrapServiceRegistry bootRegistry, Configuration configuration) {\n\t\tProperties properties = new Properties();\n\t\tproperties.putAll( configuration.getProperties() );\n\t\tConfigurationHelper.resolvePlaceHolders( properties );\n\n\t\tStandardServiceRegistryBuilder cfgRegistryBuilder = configuration.getStandardServiceRegistryBuilder();\n\n\t\tStandardServiceRegistryBuilder registryBuilder = new StandardServiceRegistryBuilder( bootRegistry, cfgRegistryBuilder.getAggregatedCfgXml() )\n\t\t\t\t.applySettings( properties );\n\t\tServiceRegistryUtil.applySettings( registryBuilder );\n\n\t\treturn (StandardServiceRegistryImpl) registryBuilder.build();\n\t}\n\n\tprivate Properties buildProperties() {\n\t\tProperties properties = Environment.getProperties();\n\n\t\tproperties.put( AvailableSettings.CACHE_REGION_FACTORY, CachingRegionFactory.class.getName() );\n\t\tfor ( Map.Entry<Class, String> entry : getCachedClasses().entrySet() ) {\n\t\t\tproperties.put( AvailableSettings.CLASS_CACHE_PREFIX + \".\" + entry.getKey().getName(), entry.getValue() );\n\t\t}\n\t\tfor ( Map.Entry<String, String> entry : getCachedCollections().entrySet() ) {\n\t\t\tproperties.put( AvailableSettings.COLLECTION_CACHE_PREFIX + \".\" + entry.getKey(), entry.getValue() );\n\t\t}\n\n\t\tconfigure( PropertiesHelper.map( properties ) );\n\n\t\tif ( createSchema() ) {\n\t\t\tproperties.put( AvailableSettings.HBM2DDL_AUTO, \"create-drop\" );\n\t\t}\n\t\tproperties.put( AvailableSettings.DIALECT, getDialect().getClass().getName() );\n\n\t\treturn properties;\n\t}\n\n\tprotected void configure(Map<String, Object> properties) {\n\t}\n\n\tprotected static final Class<?>[] NO_CLASSES = new Class[0];\n\n\tprotected Class<?>[] getAnnotatedClasses() {\n\t\treturn NO_CLASSES;\n\t}\n\n\tpublic Map<Class, String> getCachedClasses() {\n\t\treturn new HashMap<>();\n\t}\n\n\tpublic Map<String, String> getCachedCollections() {\n\t\treturn new HashMap<>();\n\t}\n\n\tprotected void afterSessionOrEntityManagerFactoryBuilt() {\n\t}\n\n\tprotected boolean createSchema() {\n\t\treturn true;\n\t}\n\n\t@After\n\tpublic final void afterTest() throws Exception {\n\t\tcompleteStrayTransaction();\n\n\t\tcleanupSession();\n\n\t}\n\n\t@AfterClassOnce\n\t@SuppressWarnings( {\"UnusedDeclaration\"})\n\tprotected void releaseSessionFactory() {\n\t\tif ( sessionFactory == null ) {\n\t\t\treturn;\n\t\t}\n\t\tsessionFactory.close();\n\t\tsessionFactory = null;\n\t\tif ( serviceRegistry != null ) {\n\t\t\tif ( serviceRegistry.isActive() ) {\n\t\t\t\ttry {\n\t\t\t\t\tserviceRegistry.destroy();\n\t\t\t\t}\n\t\t\t\tcatch (Exception ignore) {\n\t\t\t\t}\n\t\t\t\tfail( \"StandardServiceRegistry was not closed down as expected\" );\n\t\t\t}\n\t\t}\n\t\tserviceRegistry=null;\n\t}\n\n\tprivate void completeStrayTransaction() {\n\t\tif ( session == null ) {\n\t\t\t// nothing to do\n\t\t\treturn;\n\t\t}\n\n\t\tif ( ( (SessionImplementor) session ).isClosed() ) {\n\t\t\t// nothing to do\n\t\t\treturn;\n\t\t}\n\n\t\tif ( !session.isConnected() ) {\n\t\t\t// nothing to do\n\t\t\treturn;\n\t\t}\n\n\t\tfinal TransactionCoordinator.TransactionDriver tdc =\n\t\t\t\t( (SessionImplementor) session ).getTransactionCoordinator().getTransactionDriverControl();\n\n\t\tif ( tdc.getStatus().canRollback() ) {\n\t\t\tsession.getTransaction().rollback();\n\t\t}\n\t\tsession.close();\n\t}\n\n\tprivate void cleanupSession() {\n\t\tif ( session != null && ! ( (SessionImplementor) session ).isClosed() ) {\n\t\t\tsession.close();\n\t\t}\n\t\tsession = null;\n\t}\n}\n",
        "filePathAfter": "hibernate-core/src/test/java/org/hibernate/orm/test/exceptionhandling/BaseJpaOrNativeBootstrapFunctionalTestCase.java",
        "sourceCodeAfterForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.\n */\npackage org.hibernate.orm.test.exceptionhandling;\n\nimport java.net.URL;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Properties;\n\nimport org.hibernate.HibernateException;\nimport org.hibernate.Interceptor;\nimport org.hibernate.Session;\nimport org.hibernate.boot.cfgxml.spi.LoadedConfig;\nimport org.hibernate.boot.registry.BootstrapServiceRegistry;\nimport org.hibernate.boot.registry.BootstrapServiceRegistryBuilder;\nimport org.hibernate.boot.registry.StandardServiceRegistryBuilder;\nimport org.hibernate.boot.registry.internal.StandardServiceRegistryImpl;\nimport org.hibernate.bytecode.enhance.spi.EnhancementContext;\nimport org.hibernate.bytecode.spi.ClassTransformer;\nimport org.hibernate.cfg.AvailableSettings;\nimport org.hibernate.cfg.Configuration;\nimport org.hibernate.cfg.Environment;\nimport org.hibernate.dialect.Dialect;\nimport org.hibernate.engine.spi.SessionFactoryImplementor;\nimport org.hibernate.engine.spi.SessionImplementor;\nimport org.hibernate.internal.util.PropertiesHelper;\nimport org.hibernate.jpa.HibernatePersistenceProvider;\nimport org.hibernate.jpa.boot.spi.PersistenceUnitDescriptor;\n\nimport org.hibernate.testing.AfterClassOnce;\nimport org.hibernate.testing.BeforeClassOnce;\nimport org.hibernate.testing.cache.CachingRegionFactory;\nimport org.hibernate.testing.junit4.BaseUnitTestCase;\nimport org.hibernate.testing.orm.junit.DialectContext;\nimport org.hibernate.testing.util.ServiceRegistryUtil;\nimport org.junit.After;\n\nimport jakarta.persistence.EntityManager;\nimport jakarta.persistence.SharedCacheMode;\nimport jakarta.persistence.ValidationMode;\nimport jakarta.persistence.PersistenceUnitTransactionType;\n\nimport static org.hibernate.internal.util.config.ConfigurationHelper.resolvePlaceHolders;\nimport static org.hibernate.jpa.boot.spi.Bootstrap.getEntityManagerFactoryBuilder;\nimport static org.junit.Assert.fail;\n\n/**\n * A base class for all functional tests.\n */\npublic abstract class BaseJpaOrNativeBootstrapFunctionalTestCase extends BaseUnitTestCase {\n\n\t// IMPL NOTE : Here we use @Before and @After (instead of @BeforeClassOnce and @AfterClassOnce like we do in\n\t// BaseCoreFunctionalTestCase) because the old HEM test methodology was to create an EMF for each test method.\n\n\tprivate static final Dialect dialect = DialectContext.getDialect();\n\n\tpublic enum BootstrapMethod {\n\t\tJPA,\n\t\tNATIVE\n\t}\n\n\tprivate final BootstrapMethod bootstrapMethod;\n\n\tprivate StandardServiceRegistryImpl serviceRegistry;\n\tprivate SessionFactoryImplementor sessionFactory;\n\n\tprivate Session session;\n\n\tprotected Dialect getDialect() {\n\t\treturn dialect;\n\t}\n\n\tprotected SessionFactoryImplementor sessionFactory() {\n\t\treturn sessionFactory;\n\t}\n\n\tprotected StandardServiceRegistryImpl serviceRegistry() {\n\t\treturn serviceRegistry;\n\t}\n\n\tprotected Session openSession() throws HibernateException {\n\t\tsession = sessionFactory().openSession();\n\t\treturn session;\n\t}\n\n\tprotected Session openSession(Interceptor interceptor) throws HibernateException {\n\t\tsession = sessionFactory().withOptions().interceptor( interceptor ).openSession();\n\t\treturn session;\n\t}\n\n\tprotected EntityManager openEntityManager() throws HibernateException {\n\t\treturn openSession().unwrap( EntityManager.class );\n\t}\n\n\tprotected BaseJpaOrNativeBootstrapFunctionalTestCase(BootstrapMethod bootstrapMethod) {\n\t\tthis.bootstrapMethod = bootstrapMethod;\n\t}\n\n\t@BeforeClassOnce\n\tpublic void buildSessionOrEntityManagerFactory() {\n\t\tswitch ( bootstrapMethod ) {\n\t\t\tcase JPA:\n\t\t\t\tbuildEntityManagerFactory();\n\t\t\t\tbreak;\n\t\t\tcase NATIVE:\n\t\t\t\tbuildSessionFactory();\n\t\t\t\tbreak;\n\t\t}\n\t\tafterSessionOrEntityManagerFactoryBuilt();\n\t}\n\n\tprivate void buildEntityManagerFactory() {\n\t\tlog.trace( \"Building EntityManagerFactory\" );\n\n\t\tfinal Properties properties = buildProperties();\n\t\tproperties.put( AvailableSettings.LOADED_CLASSES, List.of( getAnnotatedClasses() ) );\n\t\tServiceRegistryUtil.applySettings( properties );\n\n\t\tsessionFactory =\n\t\t\t\tgetEntityManagerFactoryBuilder( buildPersistenceUnitDescriptor(), properties )\n\t\t\t\t\t\t.build().unwrap( SessionFactoryImplementor.class );\n\n\t\tserviceRegistry = (StandardServiceRegistryImpl)\n\t\t\t\tsessionFactory.getServiceRegistry().getParentServiceRegistry();\n\t}\n\n\tprivate void buildSessionFactory() {\n\t\t// for now, build the configuration to get all the property settings\n\t\tfinal Configuration configuration = new Configuration();\n\t\tconfiguration.setProperties( buildProperties() );\n\n\t\tfinal Class<?>[] annotatedClasses = getAnnotatedClasses();\n\t\tif ( annotatedClasses != null ) {\n\t\t\tfor ( Class<?> annotatedClass : annotatedClasses ) {\n\t\t\t\tconfiguration.addAnnotatedClass( annotatedClass );\n\t\t\t}\n\t\t}\n\n\t\tserviceRegistry = buildServiceRegistry( buildBootstrapServiceRegistry(), configuration );\n\t\tsessionFactory = (SessionFactoryImplementor) configuration.buildSessionFactory( serviceRegistry );\n\n\t\tafterSessionOrEntityManagerFactoryBuilt();\n\t}\n\n\n\tprivate PersistenceUnitDescriptor buildPersistenceUnitDescriptor() {\n\t\treturn new TestingPersistenceUnitDescriptorImpl( getClass().getSimpleName() );\n\t}\n\n\tpublic static class TestingPersistenceUnitDescriptorImpl implements PersistenceUnitDescriptor {\n\t\tprivate final String name;\n\n\t\tpublic TestingPersistenceUnitDescriptorImpl(String name) {\n\t\t\tthis.name = name;\n\t\t}\n\n\t\t@Override\n\t\tpublic URL getPersistenceUnitRootUrl() {\n\t\t\treturn null;\n\t\t}\n\n\t\t@Override\n\t\tpublic String getName() {\n\t\t\treturn name;\n\t\t}\n\n\t\t@Override\n\t\tpublic String getProviderClassName() {\n\t\t\treturn HibernatePersistenceProvider.class.getName();\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean isUseQuotedIdentifiers() {\n\t\t\treturn false;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean isExcludeUnlistedClasses() {\n\t\t\treturn false;\n\t\t}\n\n\t\t@Override\n\t\tpublic PersistenceUnitTransactionType getPersistenceUnitTransactionType() {\n\t\t\treturn null;\n\t\t}\n\n\t\t@Override @SuppressWarnings(\"removal\")\n\t\tpublic jakarta.persistence.spi.PersistenceUnitTransactionType getTransactionType() {\n\t\t\treturn null;\n\t\t}\n\n\t\t@Override\n\t\tpublic ValidationMode getValidationMode() {\n\t\t\treturn null;\n\t\t}\n\n\t\t@Override\n\t\tpublic SharedCacheMode getSharedCacheMode() {\n\t\t\treturn null;\n\t\t}\n\n\t\t@Override\n\t\tpublic List<String> getManagedClassNames() {\n\t\t\treturn null;\n\t\t}\n\n\t\t@Override\n\t\tpublic List<String> getMappingFileNames() {\n\t\t\treturn null;\n\t\t}\n\n\t\t@Override\n\t\tpublic List<URL> getJarFileUrls() {\n\t\t\treturn null;\n\t\t}\n\n\t\t@Override\n\t\tpublic Object getNonJtaDataSource() {\n\t\t\treturn null;\n\t\t}\n\n\t\t@Override\n\t\tpublic Object getJtaDataSource() {\n\t\t\treturn null;\n\t\t}\n\n\t\t@Override\n\t\tpublic Properties getProperties() {\n\t\t\treturn null;\n\t\t}\n\n\t\t@Override\n\t\tpublic ClassLoader getClassLoader() {\n\t\t\treturn null;\n\t\t}\n\n\t\t@Override\n\t\tpublic ClassLoader getTempClassLoader() {\n\t\t\treturn null;\n\t\t}\n\n\t\t@Override\n\t\tpublic void pushClassTransformer(EnhancementContext enhancementContext) {\n\t\t}\n\n\t\t@Override\n\t\tpublic ClassTransformer getClassTransformer() {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tprivate BootstrapServiceRegistry buildBootstrapServiceRegistry() {\n\t\tfinal BootstrapServiceRegistryBuilder builder = new BootstrapServiceRegistryBuilder();\n\t\tbuilder.applyClassLoader( getClass().getClassLoader() );\n\t\tprepareBootstrapRegistryBuilder( builder );\n\t\treturn builder.build();\n\t}\n\n\tprotected void prepareBootstrapRegistryBuilder(BootstrapServiceRegistryBuilder builder) {\n\t}\n\n\tprivate StandardServiceRegistryImpl buildServiceRegistry(\n\t\t\tBootstrapServiceRegistry bootRegistry, Configuration configuration) {\n\t\tfinal Properties properties = new Properties();\n\t\tproperties.putAll( configuration.getProperties() );\n\t\tresolvePlaceHolders( properties );\n\t\tfinal LoadedConfig loadedConfig =\n\t\t\t\tconfiguration.getStandardServiceRegistryBuilder().getAggregatedCfgXml();\n\t\tfinal StandardServiceRegistryBuilder registryBuilder =\n\t\t\t\tnew StandardServiceRegistryBuilder( bootRegistry, loadedConfig )\n\t\t\t\t\t\t.applySettings( properties );\n\t\tServiceRegistryUtil.applySettings( registryBuilder );\n\t\treturn (StandardServiceRegistryImpl) registryBuilder.build();\n\t}\n\n\tprivate Properties buildProperties() {\n\t\tfinal Properties properties = Environment.getProperties();\n\t\tproperties.put( AvailableSettings.CACHE_REGION_FACTORY, CachingRegionFactory.class.getName() );\n\t\tfor ( Map.Entry<Class<?>, String> entry : getCachedClasses().entrySet() ) {\n\t\t\tproperties.put( AvailableSettings.CLASS_CACHE_PREFIX + \".\" + entry.getKey().getName(), entry.getValue() );\n\t\t}\n\t\tfor ( Map.Entry<String, String> entry : getCachedCollections().entrySet() ) {\n\t\t\tproperties.put( AvailableSettings.COLLECTION_CACHE_PREFIX + \".\" + entry.getKey(), entry.getValue() );\n\t\t}\n\n\t\tconfigure( PropertiesHelper.map( properties ) );\n\n\t\tif ( createSchema() ) {\n\t\t\tproperties.put( AvailableSettings.HBM2DDL_AUTO, \"create-drop\" );\n\t\t}\n\t\tproperties.put( AvailableSettings.DIALECT, getDialect().getClass().getName() );\n\n\t\treturn properties;\n\t}\n\n\tprotected void configure(Map<String, Object> properties) {\n\t}\n\n\tprotected static final Class<?>[] NO_CLASSES = new Class[0];\n\n\tprotected Class<?>[] getAnnotatedClasses() {\n\t\treturn NO_CLASSES;\n\t}\n\n\tpublic Map<Class<?>, String> getCachedClasses() {\n\t\treturn new HashMap<>();\n\t}\n\n\tpublic Map<String, String> getCachedCollections() {\n\t\treturn new HashMap<>();\n\t}\n\n\tprotected void afterSessionOrEntityManagerFactoryBuilt() {\n\t}\n\n\tprotected boolean createSchema() {\n\t\treturn true;\n\t}\n\n\t@After\n\tpublic final void afterTest()  {\n\t\tcompleteStrayTransaction();\n\t\tcleanupSession();\n\t}\n\n\t@AfterClassOnce\n\t@SuppressWarnings(\"UnusedDeclaration\")\n\tprotected void releaseSessionFactory() {\n\t\tif ( sessionFactory == null ) {\n\t\t\treturn;\n\t\t}\n\t\tsessionFactory.close();\n\t\tsessionFactory = null;\n\t\tif ( serviceRegistry != null ) {\n\t\t\tif ( serviceRegistry.isActive() ) {\n\t\t\t\ttry {\n\t\t\t\t\tserviceRegistry.destroy();\n\t\t\t\t}\n\t\t\t\tcatch (Exception ignore) {\n\t\t\t\t}\n\t\t\t\tfail( \"StandardServiceRegistry was not closed down as expected\" );\n\t\t\t}\n\t\t}\n\t\tserviceRegistry=null;\n\t}\n\n\tprivate void completeStrayTransaction() {\n\t\tif ( session == null ) {\n\t\t\t// nothing to do\n\t\t\treturn;\n\t\t}\n\n\t\tfinal SessionImplementor sessionImplementor = (SessionImplementor) session;\n\n\t\tif ( sessionImplementor.isClosed() ) {\n\t\t\t// nothing to do\n\t\t\treturn;\n\t\t}\n\n\t\tif ( !session.isConnected() ) {\n\t\t\t// nothing to do\n\t\t\treturn;\n\t\t}\n\n\t\tif ( canRollBack( sessionImplementor ) ) {\n\t\t\tsession.getTransaction().rollback();\n\t\t}\n\t\tsession.close();\n\t}\n\n\tprivate static boolean canRollBack(SessionImplementor sessionImplementor) {\n\t\treturn sessionImplementor.getTransactionCoordinator()\n\t\t\t\t.getTransactionDriverControl().getStatus().canRollback();\n\t}\n\n\tprivate void cleanupSession() {\n\t\tif ( session != null && ! ( (SessionImplementor) session ).isClosed() ) {\n\t\t\tsession.close();\n\t\t}\n\t\tsession = null;\n\t}\n}\n",
        "diffSourceCodeSet": [
            "private static boolean canRollBack(SessionImplementor sessionImplementor) {\n\t\treturn sessionImplementor.getTransactionCoordinator()\n\t\t\t\t.getTransactionDriverControl().getStatus().canRollback();\n\t}"
        ],
        "invokedMethodSet": [
            "methodSignature: org.hibernate.internal.SessionFactoryImpl#isClosed\n methodBody: public boolean isClosed() {\nreturn status == Status.CLOSED;\n}",
            "methodSignature: org.hibernate.internal.SessionFactoryImpl#close\n methodBody: public void close() throws HibernateException {\nsynchronized(this){if(status != Status.OPEN){if(getSessionFactoryOptions().getJpaCompliance().isJpaClosedComplianceEnabled()){throw new IllegalStateException(\"EntityManagerFactory is already closed\");\n}LOG.trace(\"Already closed\");\nreturn;\n}status=Status.CLOSING;\n}tryLOG.closing();\nobserver.sessionFactoryClosing(this);\nif(cacheAccess != null){cacheAccess.close();\n}if(runtimeMetamodels != null && runtimeMetamodels.getMappingMetamodel() != null){final JdbcConnectionAccess jdbcConnectionAccess=jdbcServices.getBootstrapJdbcConnectionAccess();\nruntimeMetamodels.getMappingMetamodel().forEachEntityDescriptor(entityPersister -> {\n  if (entityPersister.getSqmMultiTableMutationStrategy() != null) {\n    entityPersister.getSqmMultiTableMutationStrategy().release(this,jdbcConnectionAccess);\n  }\n  if (entityPersister.getSqmMultiTableInsertStrategy() != null) {\n    entityPersister.getSqmMultiTableInsertStrategy().release(this,jdbcConnectionAccess);\n  }\n}\n);\n((MappingMetamodelImpl)runtimeMetamodels.getMappingMetamodel()).close();\n}if(queryEngine != null){queryEngine.close();\n}if(eventEngine != null){eventEngine.stop();\n}finallystatus=Status.CLOSED;\nobserver.sessionFactoryClosed(this);\nserviceRegistry.destroy();\n}"
        ],
        "sourceCodeAfterRefactoring": "private void completeStrayTransaction() {\n\t\tif ( session == null ) {\n\t\t\t// nothing to do\n\t\t\treturn;\n\t\t}\n\n\t\tfinal SessionImplementor sessionImplementor = (SessionImplementor) session;\n\n\t\tif ( sessionImplementor.isClosed() ) {\n\t\t\t// nothing to do\n\t\t\treturn;\n\t\t}\n\n\t\tif ( !session.isConnected() ) {\n\t\t\t// nothing to do\n\t\t\treturn;\n\t\t}\n\n\t\tif ( canRollBack( sessionImplementor ) ) {\n\t\t\tsession.getTransaction().rollback();\n\t\t}\n\t\tsession.close();\n\t}\nprivate static boolean canRollBack(SessionImplementor sessionImplementor) {\n\t\treturn sessionImplementor.getTransactionCoordinator()\n\t\t\t\t.getTransactionDriverControl().getStatus().canRollback();\n\t}",
        "diffSourceCode": "-  352: \t\t\t\t}\n-  353: \t\t\t\tcatch (Exception ignore) {\n-  354: \t\t\t\t}\n-  355: \t\t\t\tfail( \"StandardServiceRegistry was not closed down as expected\" );\n-  356: \t\t\t}\n-  357: \t\t}\n-  358: \t\tserviceRegistry=null;\n-  359: \t}\n-  360: \n-  361: \tprivate void completeStrayTransaction() {\n-  362: \t\tif ( session == null ) {\n-  363: \t\t\t// nothing to do\n-  364: \t\t\treturn;\n-  365: \t\t}\n-  366: \n-  367: \t\tif ( ( (SessionImplementor) session ).isClosed() ) {\n-  368: \t\t\t// nothing to do\n-  369: \t\t\treturn;\n-  370: \t\t}\n-  371: \n-  372: \t\tif ( !session.isConnected() ) {\n-  373: \t\t\t// nothing to do\n-  374: \t\t\treturn;\n-  375: \t\t}\n-  376: \n-  377: \t\tfinal TransactionCoordinator.TransactionDriver tdc =\n-  378: \t\t\t\t( (SessionImplementor) session ).getTransactionCoordinator().getTransactionDriverControl();\n-  379: \n-  380: \t\tif ( tdc.getStatus().canRollback() ) {\n-  381: \t\t\tsession.getTransaction().rollback();\n-  382: \t\t}\n-  383: \t\tsession.close();\n-  384: \t}\n+  352: \tprivate void completeStrayTransaction() {\n+  353: \t\tif ( session == null ) {\n+  354: \t\t\t// nothing to do\n+  355: \t\t\treturn;\n+  356: \t\t}\n+  357: \n+  358: \t\tfinal SessionImplementor sessionImplementor = (SessionImplementor) session;\n+  359: \n+  360: \t\tif ( sessionImplementor.isClosed() ) {\n+  361: \t\t\t// nothing to do\n+  362: \t\t\treturn;\n+  363: \t\t}\n+  364: \n+  365: \t\tif ( !session.isConnected() ) {\n+  366: \t\t\t// nothing to do\n+  367: \t\t\treturn;\n+  368: \t\t}\n+  369: \n+  370: \t\tif ( canRollBack( sessionImplementor ) ) {\n+  371: \t\t\tsession.getTransaction().rollback();\n+  372: \t\t}\n+  373: \t\tsession.close();\n+  374: \t}\n+  375: \n+  376: \tprivate static boolean canRollBack(SessionImplementor sessionImplementor) {\n+  377: \t\treturn sessionImplementor.getTransactionCoordinator()\n+  378: \t\t\t\t.getTransactionDriverControl().getStatus().canRollback();\n+  379: \t}\n+  380: \n+  381: \tprivate void cleanupSession() {\n+  382: \t\tif ( session != null && ! ( (SessionImplementor) session ).isClosed() ) {\n+  383: \t\t\tsession.close();\n+  384: \t\t}\n",
        "uniqueId": "4781c09d0df0eb4ce05b2fa0d2a12747023ae024_361_384_376_379_352_374",
        "moveFileExist": true,
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 21,
        "testResult": true,
        "coverageInfo": {
            "testMethod": {
                "missed": 0,
                "covered": 1
            }
        }
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprivate createListenerArrayForWrite(len int) : T[] extracted from private handleListenerAddition(listener T, additionHandler Consumer<T>) : void in class org.hibernate.event.service.internal.EventListenerGroupImpl",
        "diffLocations": [
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/event/service/internal/EventListenerGroupImpl.java",
                "startLine": 277,
                "endLine": 342,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/event/service/internal/EventListenerGroupImpl.java",
                "startLine": 288,
                "endLine": 352,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/event/service/internal/EventListenerGroupImpl.java",
                "startLine": 354,
                "endLine": 357,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "private void handleListenerAddition(T listener, Consumer<T> additionHandler) {\n\t\tfinal T[] listenersRead = this.listeners;\n\t\tif ( listenersRead == null ) {\n\t\t\tadditionHandler.accept( listener );\n\t\t\treturn;\n\t\t}\n\t\tfinal T[] listenersWrite = (T[]) Array.newInstance( eventType.baseListenerInterface(), listenersRead.length );\n\t\tSystem.arraycopy( listenersRead, 0, listenersWrite, 0, listenersRead.length );\n\n\t\tfinal boolean debugEnabled = log.isDebugEnabled();\n\n\t\tfor ( DuplicationStrategy strategy : duplicationStrategies ) {\n\n\t\t\t// for each strategy, see if the strategy indicates that any of the existing\n\t\t\t//\t\tlisteners match the listener being added.  If so, we want to apply that\n\t\t\t//\t\tstrategy's action.  Control it returned immediately after applying the action\n\t\t\t//\t\ton match - meaning no further strategies are checked...\n\n\t\t\tfor ( int i = 0; i < listenersRead.length; i++ ) {\n\t\t\t\tfinal T existingListener = listenersRead[i];\n\t\t\t\tif ( debugEnabled ) {\n\t\t\t\t\tlog.debugf(\n\t\t\t\t\t\t\t\"Checking incoming listener [`%s`] for match against existing listener [`%s`]\",\n\t\t\t\t\t\t\tlistener,\n\t\t\t\t\t\t\texistingListener\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tif ( strategy.areMatch( listener,  existingListener ) ) {\n\t\t\t\t\tif ( debugEnabled ) {\n\t\t\t\t\t\tlog.debugf( \"Found listener match between `%s` and `%s`\", listener, existingListener );\n\t\t\t\t\t}\n\n\t\t\t\t\tswitch ( strategy.getAction() ) {\n\t\t\t\t\t\tcase ERROR: {\n\t\t\t\t\t\t\tthrow new EventListenerRegistrationException( \"Duplicate event listener found\" );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase KEEP_ORIGINAL: {\n\t\t\t\t\t\t\tif ( debugEnabled ) {\n\t\t\t\t\t\t\t\tlog.debugf( \"Skipping listener registration (%s) : `%s`\", strategy.getAction(), listener );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase REPLACE_ORIGINAL: {\n\t\t\t\t\t\t\tif ( debugEnabled ) {\n\t\t\t\t\t\t\t\tlog.debugf( \"Replacing listener registration (%s) : `%s` -> `%s`\", strategy.getAction(), existingListener, listener );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tprepareListener( listener );\n\n\t\t\t\t\t\t\tlistenersWrite[i] = listener;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// we've found a match - we should return: the match action has already been applied at this point\n\t\t\t\t\t// apply all pending changes:\n\t\t\t\t\tsetListeners( listenersWrite );\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// we did not find any match.. add it\n\t\tcheckAgainstBaseInterface( listener );\n\t\tperformInjections( listener );\n\t\tadditionHandler.accept( listener );\n\t}",
        "filePathBefore": "hibernate-core/src/main/java/org/hibernate/event/service/internal/EventListenerGroupImpl.java",
        "isPureRefactoring": true,
        "commitId": "052eb0b78c6d5864e0a1b1ec63b487382c82ec1b",
        "packageNameBefore": "org.hibernate.event.service.internal",
        "classNameBefore": "org.hibernate.event.service.internal.EventListenerGroupImpl",
        "methodNameBefore": "org.hibernate.event.service.internal.EventListenerGroupImpl#handleListenerAddition",
        "invokedMethod": "methodSignature: org.hibernate.event.service.internal.EventListenerGroupImpl#prepareListener\n methodBody: private void prepareListener(T listener) {\ncheckAgainstBaseInterface(listener);\nperformInjections(listener);\n}\nmethodSignature: org.hibernate.event.service.internal.EventListenerGroupImpl#checkAgainstBaseInterface\n methodBody: private void checkAgainstBaseInterface(T listener) {\nif(!eventType.baseListenerInterface().isInstance(listener)){throw new EventListenerRegistrationException(\"Listener did not implement expected interface [\" + eventType.baseListenerInterface().getName() + \"]\");\n}}\nmethodSignature: org.hibernate.event.service.internal.EventListenerGroupImpl#setListeners\n methodBody: private synchronized void setListeners(T[] newListeners) {\nthis.listeners=newListeners;\nif(newListeners == null || newListeners.length == 0){this.listenersAsList=emptyList();\n}{this.listenersAsList=asList(newListeners);\n}}\nmethodSignature: org.hibernate.event.service.internal.EventListenerGroupImpl#performInjections\n methodBody: private void performInjections(T listener) {\nif(listener instanceof CallbackRegistryConsumer){((CallbackRegistryConsumer)listener).injectCallbackRegistry(callbackRegistry);\n}if(listener instanceof JpaBootstrapSensitive){((JpaBootstrapSensitive)listener).wasJpaBootstrap(isJpaBootstrap);\n}}",
        "classSignatureBefore": "class EventListenerGroupImpl<T> implements EventListenerGroup<T> ",
        "methodNameBeforeSet": [
            "org.hibernate.event.service.internal.EventListenerGroupImpl#handleListenerAddition"
        ],
        "classNameBeforeSet": [
            "org.hibernate.event.service.internal.EventListenerGroupImpl"
        ],
        "classSignatureBeforeSet": [
            "class EventListenerGroupImpl<T> implements EventListenerGroup<T> "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Overlapped refactoring - can be identical by undoing the overlapped refactoring\n- Extract Variable-",
                "description": "Extract variable on the top of the extract method - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.\n */\npackage org.hibernate.event.service.internal;\n\nimport java.lang.reflect.Array;\nimport java.util.Collections;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.CompletionStage;\nimport java.util.function.BiConsumer;\nimport java.util.function.BiFunction;\nimport java.util.function.Consumer;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\n\nimport org.hibernate.event.service.spi.DuplicationStrategy;\nimport org.hibernate.event.service.spi.EventActionWithParameter;\nimport org.hibernate.event.service.spi.EventListenerGroup;\nimport org.hibernate.event.service.spi.EventListenerRegistrationException;\nimport org.hibernate.event.service.spi.JpaBootstrapSensitive;\nimport org.hibernate.event.spi.EventType;\nimport org.hibernate.jpa.event.spi.CallbackRegistry;\nimport org.hibernate.jpa.event.spi.CallbackRegistryConsumer;\n\nimport org.jboss.logging.Logger;\n\nimport static java.util.Arrays.asList;\nimport static java.util.Collections.emptyList;\n\n/**\n * Standard EventListenerGroup implementation\n *\n * @author Steve Ebersole\n * @author Sanne Grinovero\n */\nclass EventListenerGroupImpl<T> implements EventListenerGroup<T> {\n\n\tprivate static final Logger log = Logger.getLogger( EventListenerGroupImpl.class );\n\tprivate static final Set<DuplicationStrategy> DEFAULT_DUPLICATION_STRATEGIES = Collections.unmodifiableSet( makeDefaultDuplicationStrategy() );\n\tprivate static final CompletableFuture COMPLETED = CompletableFuture.completedFuture( null );\n\n\tprivate final EventType<T> eventType;\n\tprivate final CallbackRegistry callbackRegistry;\n\tprivate final boolean isJpaBootstrap;\n\n\t//TODO at least the list of listeners should be made constant;\n\t//unfortunately a number of external integrations rely on being able to make\n\t//changes to listeners at runtime, so this will require some planning.\n\tprivate volatile Set<DuplicationStrategy> duplicationStrategies = DEFAULT_DUPLICATION_STRATEGIES;\n\tprivate volatile T[] listeners = null;\n\tprivate volatile List<T> listenersAsList = emptyList();\n\n\tpublic EventListenerGroupImpl(\n\t\t\tEventType<T> eventType,\n\t\t\tCallbackRegistry callbackRegistry,\n\t\t\tboolean isJpaBootstrap) {\n\t\tthis.eventType = eventType;\n\t\tthis.callbackRegistry = callbackRegistry;\n\t\tthis.isJpaBootstrap = isJpaBootstrap;\n\t}\n\n\t@Override\n\tpublic EventType<T> getEventType() {\n\t\treturn eventType;\n\t}\n\n\t@Override\n\tpublic boolean isEmpty() {\n\t\treturn count() <= 0;\n\t}\n\n\t@Override\n\tpublic int count() {\n\t\tfinal T[] ls = listeners;\n\t\treturn ls == null ? 0 : ls.length;\n\t}\n\n\t@Override\n\tpublic void clear() {\n\t\t//Odd semantics: we're expected (for backwards compatibility) to also clear the default DuplicationStrategy.\n\t\tduplicationStrategies = new LinkedHashSet<>();\n\t\tsetListeners( null );\n\t}\n\n\t// For efficiency reasons we use both a representation as List and as array;\n\t// ensure consistency between the two fields by delegating any mutation to both\n\t// fields to this method.\n\tprivate synchronized void setListeners(T[] newListeners) {\n\t\tthis.listeners = newListeners;\n\t\tif ( newListeners == null || newListeners.length == 0 ) {\n\t\t\tthis.listenersAsList = emptyList();\n\t\t}\n\t\telse {\n\t\t\tthis.listenersAsList = asList( newListeners );\n\t\t}\n\t}\n\n\t@Override\n\tpublic void clearListeners() {\n\t\tsetListeners( null );\n\t}\n\n\t@Override\n\tpublic final <U> void fireLazyEventOnEachListener(final Supplier<U> eventSupplier, final BiConsumer<T,U> actionOnEvent) {\n\t\tfinal T[] ls = listeners;\n\t\tif ( ls != null && ls.length != 0 ) {\n\t\t\tfinal U event = eventSupplier.get();\n\t\t\t//noinspection ForLoopReplaceableByForEach\n\t\t\tfor ( int i = 0; i < ls.length; i++ ) {\n\t\t\t\tactionOnEvent.accept( ls[i], event );\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic final <U> void fireEventOnEachListener(final U event, final BiConsumer<T,U> actionOnEvent) {\n\t\tfinal T[] ls = listeners;\n\t\tif ( ls != null ) {\n\t\t\t//noinspection ForLoopReplaceableByForEach\n\t\t\tfor ( int i = 0; i < ls.length; i++ ) {\n\t\t\t\tactionOnEvent.accept( ls[i], event );\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic <U,X> void fireEventOnEachListener(final U event, final X parameter, final EventActionWithParameter<T, U, X> actionOnEvent) {\n\t\tfinal T[] ls = listeners;\n\t\tif ( ls != null ) {\n\t\t\t//noinspection ForLoopReplaceableByForEach\n\t\t\tfor ( int i = 0; i < ls.length; i++ ) {\n\t\t\t\tactionOnEvent.applyEventToListener( ls[i], event, parameter );\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic <R, U, RL> CompletionStage<R> fireEventOnEachListener(\n\t\t\tfinal U event,\n\t\t\tfinal Function<RL, Function<U, CompletionStage<R>>> fun) {\n\t\tCompletionStage<R> ret = COMPLETED;\n\t\tfinal T[] ls = listeners;\n\t\tif ( ls != null && ls.length != 0 ) {\n\t\t\tfor ( T listener : ls ) {\n\t\t\t\t//to preserve atomicity of the Session methods\n\t\t\t\t//call apply() from within the arg of thenCompose()\n\t\t\t\tret = ret.thenCompose( v -> fun.apply( (RL) listener ).apply( event ) );\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\n\t@Override\n\tpublic <R, U, RL, X> CompletionStage<R> fireEventOnEachListener(\n\t\t\tU event, X param, Function<RL, BiFunction<U, X, CompletionStage<R>>> fun) {\n\t\tCompletionStage<R> ret = COMPLETED;\n\t\tfinal T[] ls = listeners;\n\t\tif ( ls != null && ls.length != 0 ) {\n\t\t\tfor ( T listener : ls ) {\n\t\t\t\t//to preserve atomicity of the Session methods\n\t\t\t\t//call apply() from within the arg of thenCompose()\n\t\t\t\tret = ret.thenCompose( v -> fun.apply( (RL) listener ).apply( event, param ) );\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\n\t@Override\n\tpublic <R, U, RL> CompletionStage<R> fireLazyEventOnEachListener(\n\t\t\tfinal Supplier<U> eventSupplier,\n\t\t\tfinal Function<RL, Function<U, CompletionStage<R>>> fun) {\n\t\tCompletionStage<R> ret = COMPLETED;\n\t\tfinal T[] ls = listeners;\n\t\tif ( ls != null && ls.length != 0 ) {\n\t\t\tfinal U event = eventSupplier.get();\n\t\t\tfor ( T listener : ls ) {\n\t\t\t\t//to preserve atomicity of the Session methods\n\t\t\t\t//call apply() from within the arg of thenCompose()\n\t\t\t\tret = ret.thenCompose( v -> fun.apply( (RL) listener ).apply( event ) );\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\n\t@Override\n\tpublic void addDuplicationStrategy(DuplicationStrategy strategy) {\n\t\tif ( duplicationStrategies == DEFAULT_DUPLICATION_STRATEGIES ) {\n\t\t\tduplicationStrategies = makeDefaultDuplicationStrategy();\n\t\t}\n\t\tduplicationStrategies.add( strategy );\n\t}\n\n\t@Override\n\tpublic void appendListener(T listener) {\n\t\thandleListenerAddition( listener, this::internalAppend );\n\t}\n\n\t@Override\n\t@SafeVarargs\n\tpublic final void appendListeners(T... listeners) {\n\t\t//noinspection ForLoopReplaceableByForEach\n\t\tfor ( int i = 0; i < listeners.length; i++ ) {\n\t\t\thandleListenerAddition( listeners[i], this::internalAppend );\n\t\t}\n\t}\n\n\tprivate void internalAppend(T listener) {\n\t\tprepareListener( listener );\n\t\tfinal T[] listenersRead = this.listeners;\n\t\tfinal T[] listenersWrite;\n\n\t\tif ( listenersRead == null ) {\n\t\t\t//noinspection unchecked\n\t\t\tlistenersWrite = (T[]) Array.newInstance( eventType.baseListenerInterface(), 1 );\n\t\t\tlistenersWrite[0] = listener;\n\t\t}\n\t\telse {\n\t\t\tfinal int size = listenersRead.length;\n\n\t\t\t//noinspection unchecked\n\t\t\tlistenersWrite = (T[]) Array.newInstance( eventType.baseListenerInterface(), size+1 );\n\n\t\t\t// first copy the existing listeners\n\t\t\tSystem.arraycopy( listenersRead, 0, listenersWrite, 0, size );\n\n\t\t\t// and then put the new one after them\n\t\t\tlistenersWrite[size] = listener;\n\t\t}\n\t\tsetListeners( listenersWrite );\n\t}\n\n\t@Override\n\tpublic void prependListener(T listener) {\n\t\thandleListenerAddition( listener, this::internalPrepend );\n\t}\n\n\t@Override\n\t@SafeVarargs\n\tpublic final void prependListeners(T... listeners) {\n\t\t//noinspection ForLoopReplaceableByForEach\n\t\tfor ( int i = 0; i < listeners.length; i++ ) {\n\t\t\thandleListenerAddition( listeners[i], this::internalPrepend );\n\t\t}\n\t}\n\n\tprivate void internalPrepend(T listener) {\n\t\tprepareListener( listener );\n\t\tfinal T[] listenersRead = this.listeners;\n\t\tfinal T[] listenersWrite;\n\n\t\tif ( listenersRead == null ) {\n\t\t\t//noinspection unchecked\n\t\t\tlistenersWrite = (T[]) Array.newInstance( eventType.baseListenerInterface(), 1 );\n\t\t\tlistenersWrite[0] = listener;\n\t\t}\n\t\telse {\n\t\t\tfinal int size = listenersRead.length;\n\n\t\t\t//noinspection unchecked\n\t\t\tlistenersWrite = (T[]) Array.newInstance( eventType.baseListenerInterface(), size+1 );\n\n\t\t\t// put the new one first\n\t\t\tlistenersWrite[0] = listener;\n\n\t\t\t// and copy the rest after it\n\t\t\tSystem.arraycopy( listenersRead, 0, listenersWrite, 1, size );\n\t\t}\n\t\tsetListeners( listenersWrite );\n\t}\n\n\tprivate void handleListenerAddition(T listener, Consumer<T> additionHandler) {\n\t\tfinal T[] listenersRead = this.listeners;\n\t\tif ( listenersRead == null ) {\n\t\t\tadditionHandler.accept( listener );\n\t\t\treturn;\n\t\t}\n\t\tfinal T[] listenersWrite = (T[]) Array.newInstance( eventType.baseListenerInterface(), listenersRead.length );\n\t\tSystem.arraycopy( listenersRead, 0, listenersWrite, 0, listenersRead.length );\n\n\t\tfinal boolean debugEnabled = log.isDebugEnabled();\n\n\t\tfor ( DuplicationStrategy strategy : duplicationStrategies ) {\n\n\t\t\t// for each strategy, see if the strategy indicates that any of the existing\n\t\t\t//\t\tlisteners match the listener being added.  If so, we want to apply that\n\t\t\t//\t\tstrategy's action.  Control it returned immediately after applying the action\n\t\t\t//\t\ton match - meaning no further strategies are checked...\n\n\t\t\tfor ( int i = 0; i < listenersRead.length; i++ ) {\n\t\t\t\tfinal T existingListener = listenersRead[i];\n\t\t\t\tif ( debugEnabled ) {\n\t\t\t\t\tlog.debugf(\n\t\t\t\t\t\t\t\"Checking incoming listener [`%s`] for match against existing listener [`%s`]\",\n\t\t\t\t\t\t\tlistener,\n\t\t\t\t\t\t\texistingListener\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tif ( strategy.areMatch( listener,  existingListener ) ) {\n\t\t\t\t\tif ( debugEnabled ) {\n\t\t\t\t\t\tlog.debugf( \"Found listener match between `%s` and `%s`\", listener, existingListener );\n\t\t\t\t\t}\n\n\t\t\t\t\tswitch ( strategy.getAction() ) {\n\t\t\t\t\t\tcase ERROR: {\n\t\t\t\t\t\t\tthrow new EventListenerRegistrationException( \"Duplicate event listener found\" );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase KEEP_ORIGINAL: {\n\t\t\t\t\t\t\tif ( debugEnabled ) {\n\t\t\t\t\t\t\t\tlog.debugf( \"Skipping listener registration (%s) : `%s`\", strategy.getAction(), listener );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase REPLACE_ORIGINAL: {\n\t\t\t\t\t\t\tif ( debugEnabled ) {\n\t\t\t\t\t\t\t\tlog.debugf( \"Replacing listener registration (%s) : `%s` -> `%s`\", strategy.getAction(), existingListener, listener );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tprepareListener( listener );\n\n\t\t\t\t\t\t\tlistenersWrite[i] = listener;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// we've found a match - we should return: the match action has already been applied at this point\n\t\t\t\t\t// apply all pending changes:\n\t\t\t\t\tsetListeners( listenersWrite );\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// we did not find any match.. add it\n\t\tcheckAgainstBaseInterface( listener );\n\t\tperformInjections( listener );\n\t\tadditionHandler.accept( listener );\n\t}\n\n\tprivate void prepareListener(T listener) {\n\t\tcheckAgainstBaseInterface( listener );\n\t\tperformInjections( listener );\n\t}\n\n\tprivate void performInjections(T listener) {\n\t\tif ( listener instanceof CallbackRegistryConsumer ) {\n\t\t\t( (CallbackRegistryConsumer) listener ).injectCallbackRegistry( callbackRegistry );\n\t\t}\n\n\t\tif ( listener instanceof JpaBootstrapSensitive ) {\n\t\t\t( (JpaBootstrapSensitive) listener ).wasJpaBootstrap( isJpaBootstrap );\n\t\t}\n\t}\n\n\tprivate void checkAgainstBaseInterface(T listener) {\n\t\tif ( !eventType.baseListenerInterface().isInstance( listener ) ) {\n\t\t\tthrow new EventListenerRegistrationException(\n\t\t\t\t\t\"Listener did not implement expected interface [\" + eventType.baseListenerInterface().getName() + \"]\"\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * Implementation note: should be final for performance reasons.\n\t * @deprecated this is not the most efficient way for iterating the event listeners.\n\t * See {@link #fireEventOnEachListener(Object, BiConsumer)} and co. for better alternatives.\n\t */\n\t@Override\n\t@Deprecated\n\tpublic final Iterable<T> listeners() {\n\t\treturn this.listenersAsList;\n\t}\n\n\tprivate static Set<DuplicationStrategy> makeDefaultDuplicationStrategy() {\n\t\tfinal Set<DuplicationStrategy> duplicationStrategies = new LinkedHashSet<>();\n\t\tduplicationStrategies.add(\n\t\t\t\t// At minimum make sure we do not register the same exact listener class multiple times.\n\t\t\t\tnew DuplicationStrategy() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic boolean areMatch(Object listener, Object original) {\n\t\t\t\t\t\treturn listener.getClass().equals( original.getClass() );\n\t\t\t\t\t}\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic Action getAction() {\n\t\t\t\t\t\treturn Action.ERROR;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t);\n\t\treturn duplicationStrategies;\n\t}\n\n}\n",
        "filePathAfter": "hibernate-core/src/main/java/org/hibernate/event/service/internal/EventListenerGroupImpl.java",
        "sourceCodeAfterForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.\n */\npackage org.hibernate.event.service.internal;\n\nimport java.lang.reflect.Array;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.CompletionStage;\nimport java.util.function.BiConsumer;\nimport java.util.function.BiFunction;\nimport java.util.function.Consumer;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\n\nimport org.hibernate.event.service.spi.DuplicationStrategy;\nimport org.hibernate.event.service.spi.EventActionWithParameter;\nimport org.hibernate.event.service.spi.EventListenerGroup;\nimport org.hibernate.event.service.spi.EventListenerRegistrationException;\nimport org.hibernate.event.service.spi.JpaBootstrapSensitive;\nimport org.hibernate.event.spi.EventType;\nimport org.hibernate.jpa.event.spi.CallbackRegistry;\nimport org.hibernate.jpa.event.spi.CallbackRegistryConsumer;\n\nimport org.jboss.logging.Logger;\n\nimport static java.util.Arrays.asList;\nimport static java.util.Collections.emptyList;\nimport static java.util.Collections.singleton;\nimport static java.util.concurrent.CompletableFuture.completedFuture;\n\n/**\n * Standard EventListenerGroup implementation\n *\n * @author Steve Ebersole\n * @author Sanne Grinovero\n */\nclass EventListenerGroupImpl<T> implements EventListenerGroup<T> {\n\n\tprivate static final Logger log = Logger.getLogger( EventListenerGroupImpl.class );\n\n\tprivate static final DuplicationStrategy DEFAULT_DUPLICATION_STRATEGY =\n\t\t\tnew DuplicationStrategy() {\n\t\t\t\t@Override\n\t\t\t\tpublic boolean areMatch(Object listener, Object original) {\n\t\t\t\t\treturn listener.getClass().equals( original.getClass() );\n\t\t\t\t}\n\t\t\t\t@Override\n\t\t\t\tpublic Action getAction() {\n\t\t\t\t\treturn Action.ERROR;\n\t\t\t\t}\n\t\t\t};\n\tprivate static final Set<DuplicationStrategy> DEFAULT_DUPLICATION_STRATEGIES =\n\t\t\tsingleton( DEFAULT_DUPLICATION_STRATEGY );\n\n\tprivate static final CompletableFuture<?> COMPLETED = completedFuture( null );\n\t@SuppressWarnings(\"unchecked\")\n\tprivate static <R> CompletableFuture<R> nullCompletion() {\n\t\treturn (CompletableFuture<R>) COMPLETED;\n\t}\n\n\tprivate final EventType<T> eventType;\n\tprivate final CallbackRegistry callbackRegistry;\n\tprivate final boolean isJpaBootstrap;\n\n\t//TODO at least the list of listeners should be made constant;\n\t//unfortunately a number of external integrations rely on being able to make\n\t//changes to listeners at runtime, so this will require some planning.\n\tprivate volatile Set<DuplicationStrategy> duplicationStrategies = DEFAULT_DUPLICATION_STRATEGIES;\n\tprivate volatile T[] listeners = null;\n\tprivate volatile List<T> listenersAsList = emptyList();\n\n\tpublic EventListenerGroupImpl(EventType<T> eventType, CallbackRegistry callbackRegistry, boolean isJpaBootstrap) {\n\t\tthis.eventType = eventType;\n\t\tthis.callbackRegistry = callbackRegistry;\n\t\tthis.isJpaBootstrap = isJpaBootstrap;\n\t}\n\n\t@Override\n\tpublic EventType<T> getEventType() {\n\t\treturn eventType;\n\t}\n\n\t@Override\n\tpublic boolean isEmpty() {\n\t\treturn count() <= 0;\n\t}\n\n\t@Override\n\tpublic int count() {\n\t\tfinal T[] ls = listeners;\n\t\treturn ls == null ? 0 : ls.length;\n\t}\n\n\t@Override\n\tpublic void clear() {\n\t\t//Odd semantics: we're expected (for backwards compatibility)\n\t\t//               to also clear the default DuplicationStrategy.\n\t\tduplicationStrategies = new LinkedHashSet<>();\n\t\tsetListeners( null );\n\t}\n\n\t// For efficiency reasons we use both a representation as List and as array;\n\t// ensure consistency between the two fields by delegating any mutation to both\n\t// fields to this method.\n\tprivate synchronized void setListeners(T[] newListeners) {\n\t\tlisteners = newListeners;\n\t\tlistenersAsList = newListeners == null || newListeners.length == 0\n\t\t\t\t? emptyList()\n\t\t\t\t: asList( newListeners );\n\t}\n\n\t@Override\n\tpublic void clearListeners() {\n\t\tsetListeners( null );\n\t}\n\n\t@Override\n\tpublic final <U> void fireLazyEventOnEachListener(Supplier<U> eventSupplier, BiConsumer<T,U> actionOnEvent) {\n\t\tfinal T[] ls = listeners;\n\t\tif ( ls != null && ls.length != 0 ) {\n\t\t\tfinal U event = eventSupplier.get();\n\t\t\t//noinspection ForLoopReplaceableByForEach\n\t\t\tfor ( int i = 0; i < ls.length; i++ ) {\n\t\t\t\tactionOnEvent.accept( ls[i], event );\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic final <U> void fireEventOnEachListener(U event, BiConsumer<T,U> actionOnEvent) {\n\t\tfinal T[] ls = listeners;\n\t\tif ( ls != null ) {\n\t\t\t//noinspection ForLoopReplaceableByForEach\n\t\t\tfor ( int i = 0; i < ls.length; i++ ) {\n\t\t\t\tactionOnEvent.accept( ls[i], event );\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic <U,X> void fireEventOnEachListener(U event, X parameter, EventActionWithParameter<T, U, X> actionOnEvent) {\n\t\tfinal T[] ls = listeners;\n\t\tif ( ls != null ) {\n\t\t\t//noinspection ForLoopReplaceableByForEach\n\t\t\tfor ( int i = 0; i < ls.length; i++ ) {\n\t\t\t\tactionOnEvent.applyEventToListener( ls[i], event, parameter );\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic <R, U, RL> CompletionStage<R> fireEventOnEachListener(\n\t\t\tfinal U event,\n\t\t\tfinal Function<RL, Function<U, CompletionStage<R>>> fun) {\n\t\tCompletionStage<R> ret = nullCompletion();\n\t\tfinal T[] ls = listeners;\n\t\tif ( ls != null ) {\n\t\t\tfor ( T listener : ls ) {\n\t\t\t\t//to preserve atomicity of the Session methods\n\t\t\t\t//call apply() from within the arg of thenCompose()\n\t\t\t\tret = ret.thenCompose( v -> fun.apply( (RL) listener ).apply( event ) );\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\n\t@Override\n\tpublic <R, U, RL, X> CompletionStage<R> fireEventOnEachListener(\n\t\t\tU event, X param, Function<RL, BiFunction<U, X, CompletionStage<R>>> fun) {\n\t\tCompletionStage<R> ret = nullCompletion();\n\t\tfinal T[] ls = listeners;\n\t\tif ( ls != null ) {\n\t\t\tfor ( T listener : ls ) {\n\t\t\t\t//to preserve atomicity of the Session methods\n\t\t\t\t//call apply() from within the arg of thenCompose()\n\t\t\t\tret = ret.thenCompose( v -> fun.apply( (RL) listener ).apply( event, param ) );\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\n\t@Override\n\tpublic <R, U, RL> CompletionStage<R> fireLazyEventOnEachListener(\n\t\t\tSupplier<U> eventSupplier,\n\t\t\tFunction<RL, Function<U, CompletionStage<R>>> fun) {\n\t\tCompletionStage<R> ret = nullCompletion();\n\t\tfinal T[] ls = listeners;\n\t\tif ( ls != null && ls.length != 0 ) {\n\t\t\tfinal U event = eventSupplier.get();\n\t\t\tfor ( T listener : ls ) {\n\t\t\t\t//to preserve atomicity of the Session methods\n\t\t\t\t//call apply() from within the arg of thenCompose()\n\t\t\t\tret = ret.thenCompose( v -> fun.apply( (RL) listener ).apply( event ) );\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\n\t@Override\n\tpublic void addDuplicationStrategy(DuplicationStrategy strategy) {\n\t\tif ( duplicationStrategies == DEFAULT_DUPLICATION_STRATEGIES ) {\n\t\t\t// At minimum make sure we do not register the same exact listener class multiple times.\n\t\t\tduplicationStrategies = new LinkedHashSet<>( DEFAULT_DUPLICATION_STRATEGIES );\n\t\t}\n\t\tduplicationStrategies.add( strategy );\n\t}\n\n\t@Override\n\tpublic void appendListener(T listener) {\n\t\thandleListenerAddition( listener, this::internalAppend );\n\t}\n\n\t@Override\n\t@SafeVarargs\n\tpublic final void appendListeners(T... listeners) {\n\t\t//noinspection ForLoopReplaceableByForEach\n\t\tfor ( int i = 0; i < listeners.length; i++ ) {\n\t\t\thandleListenerAddition( listeners[i], this::internalAppend );\n\t\t}\n\t}\n\n\tprivate void internalAppend(T listener) {\n\t\tprepareListener( listener );\n\t\tfinal T[] listenersRead = listeners;\n\t\tfinal T[] listenersWrite;\n\n\t\tif ( listenersRead == null ) {\n\t\t\tlistenersWrite = createListenerArrayForWrite( 1 );\n\t\t\tlistenersWrite[0] = listener;\n\t\t}\n\t\telse {\n\t\t\tfinal int size = listenersRead.length;\n\n\t\t\tlistenersWrite = createListenerArrayForWrite( size + 1 );\n\n\t\t\t// first copy the existing listeners\n\t\t\tSystem.arraycopy( listenersRead, 0, listenersWrite, 0, size );\n\n\t\t\t// and then put the new one after them\n\t\t\tlistenersWrite[size] = listener;\n\t\t}\n\t\tsetListeners( listenersWrite );\n\t}\n\n\t@Override\n\tpublic void prependListener(T listener) {\n\t\thandleListenerAddition( listener, this::internalPrepend );\n\t}\n\n\t@Override\n\t@SafeVarargs\n\tpublic final void prependListeners(T... listeners) {\n\t\t//noinspection ForLoopReplaceableByForEach\n\t\tfor ( int i = 0; i < listeners.length; i++ ) {\n\t\t\thandleListenerAddition( listeners[i], this::internalPrepend );\n\t\t}\n\t}\n\n\tprivate void internalPrepend(T listener) {\n\t\tprepareListener( listener );\n\t\tfinal T[] listenersRead = listeners;\n\t\tfinal T[] listenersWrite;\n\n\t\tif ( listenersRead == null ) {\n\t\t\tlistenersWrite = createListenerArrayForWrite( 1 );\n\t\t\tlistenersWrite[0] = listener;\n\t\t}\n\t\telse {\n\t\t\tfinal int size = listenersRead.length;\n\n\t\t\tlistenersWrite = createListenerArrayForWrite( size + 1 );\n\n\t\t\t// put the new one first\n\t\t\tlistenersWrite[0] = listener;\n\n\t\t\t// and copy the rest after it\n\t\t\tSystem.arraycopy( listenersRead, 0, listenersWrite, 1, size );\n\t\t}\n\t\tsetListeners( listenersWrite );\n\t}\n\n\tprivate void handleListenerAddition(T listener, Consumer<T> additionHandler) {\n\t\tfinal T[] listenersRead = listeners;\n\t\tif ( listenersRead == null ) {\n\t\t\tadditionHandler.accept( listener );\n\t\t\treturn;\n\t\t}\n\t\tint size = listenersRead.length;\n\n\t\tfinal T[] listenersWrite = createListenerArrayForWrite( size );\n\t\tSystem.arraycopy( listenersRead, 0, listenersWrite, 0, size );\n\n\t\tfinal boolean debugEnabled = log.isDebugEnabled();\n\n\t\tfor ( DuplicationStrategy strategy : duplicationStrategies ) {\n\n\t\t\t// for each strategy, see if the strategy indicates that any of the existing\n\t\t\t//\t\tlisteners match the listener being added.  If so, we want to apply that\n\t\t\t//\t\tstrategy's action.  Control it returned immediately after applying the action\n\t\t\t//\t\ton match - meaning no further strategies are checked...\n\n\t\t\tfor ( int i = 0; i < size; i++ ) {\n\t\t\t\tfinal T existingListener = listenersRead[i];\n\t\t\t\tif ( debugEnabled ) {\n\t\t\t\t\tlog.debugf( \"Checking incoming listener [`%s`] for match against existing listener [`%s`]\",\n\t\t\t\t\t\t\tlistener, existingListener );\n\t\t\t\t}\n\n\t\t\t\tif ( strategy.areMatch( listener,  existingListener ) ) {\n\t\t\t\t\tif ( debugEnabled ) {\n\t\t\t\t\t\tlog.debugf( \"Found listener match between `%s` and `%s`\",\n\t\t\t\t\t\t\t\tlistener, existingListener );\n\t\t\t\t\t}\n\n\t\t\t\t\tfinal DuplicationStrategy.Action action = strategy.getAction();\n\t\t\t\t\tswitch (action) {\n\t\t\t\t\t\tcase ERROR:\n\t\t\t\t\t\t\tthrow new EventListenerRegistrationException( \"Duplicate event listener found\" );\n\t\t\t\t\t\tcase KEEP_ORIGINAL:\n\t\t\t\t\t\t\tif ( debugEnabled ) {\n\t\t\t\t\t\t\t\tlog.debugf( \"Skipping listener registration (%s) : `%s`\",\n\t\t\t\t\t\t\t\t\t\taction, listener );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\tcase REPLACE_ORIGINAL:\n\t\t\t\t\t\t\tif ( debugEnabled ) {\n\t\t\t\t\t\t\t\tlog.debugf( \"Replacing listener registration (%s) : `%s` -> `%s`\",\n\t\t\t\t\t\t\t\t\t\taction, existingListener, listener );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tprepareListener( listener );\n\t\t\t\t\t\t\tlistenersWrite[i] = listener;\n\t\t\t\t\t}\n\n\t\t\t\t\t// we've found a match - we should return: the match action has already been applied at this point\n\t\t\t\t\t// apply all pending changes:\n\t\t\t\t\tsetListeners( listenersWrite );\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// we did not find any match, add it\n\t\tcheckAgainstBaseInterface( listener );\n\t\tperformInjections( listener );\n\t\tadditionHandler.accept( listener );\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tprivate T[] createListenerArrayForWrite(int len) {\n\t\treturn (T[]) Array.newInstance( eventType.baseListenerInterface(), len );\n\t}\n\n\tprivate void prepareListener(T listener) {\n\t\tcheckAgainstBaseInterface( listener );\n\t\tperformInjections( listener );\n\t}\n\n\tprivate void performInjections(T listener) {\n\t\tif ( listener instanceof CallbackRegistryConsumer consumer ) {\n\t\t\tconsumer.injectCallbackRegistry( callbackRegistry );\n\t\t}\n\t\tif ( listener instanceof JpaBootstrapSensitive sensitive ) {\n\t\t\tsensitive.wasJpaBootstrap( isJpaBootstrap );\n\t\t}\n\t}\n\n\tprivate void checkAgainstBaseInterface(T listener) {\n\t\tif ( !eventType.baseListenerInterface().isInstance( listener ) ) {\n\t\t\tthrow new EventListenerRegistrationException( \"Listener did not implement expected interface [\"\n\t\t\t\t\t+ eventType.baseListenerInterface().getName() + \"]\" );\n\t\t}\n\t}\n\n\t/**\n\t * Implementation note: should be final for performance reasons.\n\t * @deprecated this is not the most efficient way for iterating the event listeners.\n\t * See {@link #fireEventOnEachListener(Object, BiConsumer)} and co. for better alternatives.\n\t */\n\t@Override\n\t@Deprecated\n\tpublic final Iterable<T> listeners() {\n\t\treturn listenersAsList;\n\t}\n}\n",
        "diffSourceCodeSet": [
            "@SuppressWarnings(\"unchecked\")\n\tprivate T[] createListenerArrayForWrite(int len) {\n\t\treturn (T[]) Array.newInstance( eventType.baseListenerInterface(), len );\n\t}"
        ],
        "invokedMethodSet": [
            "methodSignature: org.hibernate.event.service.internal.EventListenerGroupImpl#prepareListener\n methodBody: private void prepareListener(T listener) {\ncheckAgainstBaseInterface(listener);\nperformInjections(listener);\n}",
            "methodSignature: org.hibernate.event.service.internal.EventListenerGroupImpl#checkAgainstBaseInterface\n methodBody: private void checkAgainstBaseInterface(T listener) {\nif(!eventType.baseListenerInterface().isInstance(listener)){throw new EventListenerRegistrationException(\"Listener did not implement expected interface [\" + eventType.baseListenerInterface().getName() + \"]\");\n}}",
            "methodSignature: org.hibernate.event.service.internal.EventListenerGroupImpl#setListeners\n methodBody: private synchronized void setListeners(T[] newListeners) {\nthis.listeners=newListeners;\nif(newListeners == null || newListeners.length == 0){this.listenersAsList=emptyList();\n}{this.listenersAsList=asList(newListeners);\n}}",
            "methodSignature: org.hibernate.event.service.internal.EventListenerGroupImpl#performInjections\n methodBody: private void performInjections(T listener) {\nif(listener instanceof CallbackRegistryConsumer){((CallbackRegistryConsumer)listener).injectCallbackRegistry(callbackRegistry);\n}if(listener instanceof JpaBootstrapSensitive){((JpaBootstrapSensitive)listener).wasJpaBootstrap(isJpaBootstrap);\n}}"
        ],
        "sourceCodeAfterRefactoring": "private void handleListenerAddition(T listener, Consumer<T> additionHandler) {\n\t\tfinal T[] listenersRead = listeners;\n\t\tif ( listenersRead == null ) {\n\t\t\tadditionHandler.accept( listener );\n\t\t\treturn;\n\t\t}\n\t\tint size = listenersRead.length;\n\n\t\tfinal T[] listenersWrite = createListenerArrayForWrite( size );\n\t\tSystem.arraycopy( listenersRead, 0, listenersWrite, 0, size );\n\n\t\tfinal boolean debugEnabled = log.isDebugEnabled();\n\n\t\tfor ( DuplicationStrategy strategy : duplicationStrategies ) {\n\n\t\t\t// for each strategy, see if the strategy indicates that any of the existing\n\t\t\t//\t\tlisteners match the listener being added.  If so, we want to apply that\n\t\t\t//\t\tstrategy's action.  Control it returned immediately after applying the action\n\t\t\t//\t\ton match - meaning no further strategies are checked...\n\n\t\t\tfor ( int i = 0; i < size; i++ ) {\n\t\t\t\tfinal T existingListener = listenersRead[i];\n\t\t\t\tif ( debugEnabled ) {\n\t\t\t\t\tlog.debugf( \"Checking incoming listener [`%s`] for match against existing listener [`%s`]\",\n\t\t\t\t\t\t\tlistener, existingListener );\n\t\t\t\t}\n\n\t\t\t\tif ( strategy.areMatch( listener,  existingListener ) ) {\n\t\t\t\t\tif ( debugEnabled ) {\n\t\t\t\t\t\tlog.debugf( \"Found listener match between `%s` and `%s`\",\n\t\t\t\t\t\t\t\tlistener, existingListener );\n\t\t\t\t\t}\n\n\t\t\t\t\tfinal DuplicationStrategy.Action action = strategy.getAction();\n\t\t\t\t\tswitch (action) {\n\t\t\t\t\t\tcase ERROR:\n\t\t\t\t\t\t\tthrow new EventListenerRegistrationException( \"Duplicate event listener found\" );\n\t\t\t\t\t\tcase KEEP_ORIGINAL:\n\t\t\t\t\t\t\tif ( debugEnabled ) {\n\t\t\t\t\t\t\t\tlog.debugf( \"Skipping listener registration (%s) : `%s`\",\n\t\t\t\t\t\t\t\t\t\taction, listener );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\tcase REPLACE_ORIGINAL:\n\t\t\t\t\t\t\tif ( debugEnabled ) {\n\t\t\t\t\t\t\t\tlog.debugf( \"Replacing listener registration (%s) : `%s` -> `%s`\",\n\t\t\t\t\t\t\t\t\t\taction, existingListener, listener );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tprepareListener( listener );\n\t\t\t\t\t\t\tlistenersWrite[i] = listener;\n\t\t\t\t\t}\n\n\t\t\t\t\t// we've found a match - we should return: the match action has already been applied at this point\n\t\t\t\t\t// apply all pending changes:\n\t\t\t\t\tsetListeners( listenersWrite );\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// we did not find any match, add it\n\t\tcheckAgainstBaseInterface( listener );\n\t\tperformInjections( listener );\n\t\tadditionHandler.accept( listener );\n\t}\n@SuppressWarnings(\"unchecked\")\n\tprivate T[] createListenerArrayForWrite(int len) {\n\t\treturn (T[]) Array.newInstance( eventType.baseListenerInterface(), len );\n\t}",
        "diffSourceCode": "-  277: \tprivate void handleListenerAddition(T listener, Consumer<T> additionHandler) {\n-  278: \t\tfinal T[] listenersRead = this.listeners;\n-  279: \t\tif ( listenersRead == null ) {\n-  280: \t\t\tadditionHandler.accept( listener );\n-  281: \t\t\treturn;\n-  282: \t\t}\n-  283: \t\tfinal T[] listenersWrite = (T[]) Array.newInstance( eventType.baseListenerInterface(), listenersRead.length );\n-  284: \t\tSystem.arraycopy( listenersRead, 0, listenersWrite, 0, listenersRead.length );\n-  285: \n-  286: \t\tfinal boolean debugEnabled = log.isDebugEnabled();\n+  277: \t\t\tlistenersWrite = createListenerArrayForWrite( size + 1 );\n+  278: \n+  279: \t\t\t// put the new one first\n+  280: \t\t\tlistenersWrite[0] = listener;\n+  281: \n+  282: \t\t\t// and copy the rest after it\n+  283: \t\t\tSystem.arraycopy( listenersRead, 0, listenersWrite, 1, size );\n+  284: \t\t}\n+  285: \t\tsetListeners( listenersWrite );\n+  286: \t}\n   287: \n-  288: \t\tfor ( DuplicationStrategy strategy : duplicationStrategies ) {\n-  289: \n-  290: \t\t\t// for each strategy, see if the strategy indicates that any of the existing\n-  291: \t\t\t//\t\tlisteners match the listener being added.  If so, we want to apply that\n-  292: \t\t\t//\t\tstrategy's action.  Control it returned immediately after applying the action\n-  293: \t\t\t//\t\ton match - meaning no further strategies are checked...\n-  294: \n-  295: \t\t\tfor ( int i = 0; i < listenersRead.length; i++ ) {\n-  296: \t\t\t\tfinal T existingListener = listenersRead[i];\n-  297: \t\t\t\tif ( debugEnabled ) {\n-  298: \t\t\t\t\tlog.debugf(\n-  299: \t\t\t\t\t\t\t\"Checking incoming listener [`%s`] for match against existing listener [`%s`]\",\n-  300: \t\t\t\t\t\t\tlistener,\n-  301: \t\t\t\t\t\t\texistingListener\n-  302: \t\t\t\t\t);\n-  303: \t\t\t\t}\n-  304: \n-  305: \t\t\t\tif ( strategy.areMatch( listener,  existingListener ) ) {\n-  306: \t\t\t\t\tif ( debugEnabled ) {\n-  307: \t\t\t\t\t\tlog.debugf( \"Found listener match between `%s` and `%s`\", listener, existingListener );\n-  308: \t\t\t\t\t}\n-  309: \n-  310: \t\t\t\t\tswitch ( strategy.getAction() ) {\n-  311: \t\t\t\t\t\tcase ERROR: {\n-  312: \t\t\t\t\t\t\tthrow new EventListenerRegistrationException( \"Duplicate event listener found\" );\n-  313: \t\t\t\t\t\t}\n-  314: \t\t\t\t\t\tcase KEEP_ORIGINAL: {\n-  315: \t\t\t\t\t\t\tif ( debugEnabled ) {\n-  316: \t\t\t\t\t\t\t\tlog.debugf( \"Skipping listener registration (%s) : `%s`\", strategy.getAction(), listener );\n-  317: \t\t\t\t\t\t\t}\n-  318: \t\t\t\t\t\t\treturn;\n-  319: \t\t\t\t\t\t}\n-  320: \t\t\t\t\t\tcase REPLACE_ORIGINAL: {\n-  321: \t\t\t\t\t\t\tif ( debugEnabled ) {\n-  322: \t\t\t\t\t\t\t\tlog.debugf( \"Replacing listener registration (%s) : `%s` -> `%s`\", strategy.getAction(), existingListener, listener );\n-  323: \t\t\t\t\t\t\t}\n-  324: \t\t\t\t\t\t\tprepareListener( listener );\n-  325: \n-  326: \t\t\t\t\t\t\tlistenersWrite[i] = listener;\n-  327: \t\t\t\t\t\t}\n-  328: \t\t\t\t\t}\n-  329: \n-  330: \t\t\t\t\t// we've found a match - we should return: the match action has already been applied at this point\n-  331: \t\t\t\t\t// apply all pending changes:\n-  332: \t\t\t\t\tsetListeners( listenersWrite );\n-  333: \t\t\t\t\treturn;\n-  334: \t\t\t\t}\n-  335: \t\t\t}\n-  336: \t\t}\n-  337: \n-  338: \t\t// we did not find any match.. add it\n-  339: \t\tcheckAgainstBaseInterface( listener );\n-  340: \t\tperformInjections( listener );\n-  341: \t\tadditionHandler.accept( listener );\n-  342: \t}\n-  343: \n-  344: \tprivate void prepareListener(T listener) {\n-  345: \t\tcheckAgainstBaseInterface( listener );\n-  346: \t\tperformInjections( listener );\n-  347: \t}\n-  348: \n-  349: \tprivate void performInjections(T listener) {\n-  350: \t\tif ( listener instanceof CallbackRegistryConsumer ) {\n-  351: \t\t\t( (CallbackRegistryConsumer) listener ).injectCallbackRegistry( callbackRegistry );\n-  352: \t\t}\n-  354: \t\tif ( listener instanceof JpaBootstrapSensitive ) {\n-  355: \t\t\t( (JpaBootstrapSensitive) listener ).wasJpaBootstrap( isJpaBootstrap );\n-  356: \t\t}\n+  288: \tprivate void handleListenerAddition(T listener, Consumer<T> additionHandler) {\n+  289: \t\tfinal T[] listenersRead = listeners;\n+  290: \t\tif ( listenersRead == null ) {\n+  291: \t\t\tadditionHandler.accept( listener );\n+  292: \t\t\treturn;\n+  293: \t\t}\n+  294: \t\tint size = listenersRead.length;\n+  295: \n+  296: \t\tfinal T[] listenersWrite = createListenerArrayForWrite( size );\n+  297: \t\tSystem.arraycopy( listenersRead, 0, listenersWrite, 0, size );\n+  298: \n+  299: \t\tfinal boolean debugEnabled = log.isDebugEnabled();\n+  300: \n+  301: \t\tfor ( DuplicationStrategy strategy : duplicationStrategies ) {\n+  302: \n+  303: \t\t\t// for each strategy, see if the strategy indicates that any of the existing\n+  304: \t\t\t//\t\tlisteners match the listener being added.  If so, we want to apply that\n+  305: \t\t\t//\t\tstrategy's action.  Control it returned immediately after applying the action\n+  306: \t\t\t//\t\ton match - meaning no further strategies are checked...\n+  307: \n+  308: \t\t\tfor ( int i = 0; i < size; i++ ) {\n+  309: \t\t\t\tfinal T existingListener = listenersRead[i];\n+  310: \t\t\t\tif ( debugEnabled ) {\n+  311: \t\t\t\t\tlog.debugf( \"Checking incoming listener [`%s`] for match against existing listener [`%s`]\",\n+  312: \t\t\t\t\t\t\tlistener, existingListener );\n+  313: \t\t\t\t}\n+  314: \n+  315: \t\t\t\tif ( strategy.areMatch( listener,  existingListener ) ) {\n+  316: \t\t\t\t\tif ( debugEnabled ) {\n+  317: \t\t\t\t\t\tlog.debugf( \"Found listener match between `%s` and `%s`\",\n+  318: \t\t\t\t\t\t\t\tlistener, existingListener );\n+  319: \t\t\t\t\t}\n+  320: \n+  321: \t\t\t\t\tfinal DuplicationStrategy.Action action = strategy.getAction();\n+  322: \t\t\t\t\tswitch (action) {\n+  323: \t\t\t\t\t\tcase ERROR:\n+  324: \t\t\t\t\t\t\tthrow new EventListenerRegistrationException( \"Duplicate event listener found\" );\n+  325: \t\t\t\t\t\tcase KEEP_ORIGINAL:\n+  326: \t\t\t\t\t\t\tif ( debugEnabled ) {\n+  327: \t\t\t\t\t\t\t\tlog.debugf( \"Skipping listener registration (%s) : `%s`\",\n+  328: \t\t\t\t\t\t\t\t\t\taction, listener );\n+  329: \t\t\t\t\t\t\t}\n+  330: \t\t\t\t\t\t\treturn;\n+  331: \t\t\t\t\t\tcase REPLACE_ORIGINAL:\n+  332: \t\t\t\t\t\t\tif ( debugEnabled ) {\n+  333: \t\t\t\t\t\t\t\tlog.debugf( \"Replacing listener registration (%s) : `%s` -> `%s`\",\n+  334: \t\t\t\t\t\t\t\t\t\taction, existingListener, listener );\n+  335: \t\t\t\t\t\t\t}\n+  336: \t\t\t\t\t\t\tprepareListener( listener );\n+  337: \t\t\t\t\t\t\tlistenersWrite[i] = listener;\n+  338: \t\t\t\t\t}\n+  339: \n+  340: \t\t\t\t\t// we've found a match - we should return: the match action has already been applied at this point\n+  341: \t\t\t\t\t// apply all pending changes:\n+  342: \t\t\t\t\tsetListeners( listenersWrite );\n+  343: \t\t\t\t\treturn;\n+  344: \t\t\t\t}\n+  345: \t\t\t}\n+  346: \t\t}\n+  347: \n+  348: \t\t// we did not find any match, add it\n+  349: \t\tcheckAgainstBaseInterface( listener );\n+  350: \t\tperformInjections( listener );\n+  351: \t\tadditionHandler.accept( listener );\n+  352: \t}\n+  354: \t@SuppressWarnings(\"unchecked\")\n+  355: \tprivate T[] createListenerArrayForWrite(int len) {\n+  356: \t\treturn (T[]) Array.newInstance( eventType.baseListenerInterface(), len );\n   357: \t}\n",
        "uniqueId": "052eb0b78c6d5864e0a1b1ec63b487382c82ec1b_277_342_354_357_288_352",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 23,
                "covered": 97
            },
            "BRANCH": {
                "missed": 5,
                "covered": 15
            },
            "LINE": {
                "missed": 4,
                "covered": 27
            },
            "COMPLEXITY": {
                "missed": 5,
                "covered": 7
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 21
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprivate createListenerArrayForWrite(len int) : T[] extracted from private internalPrepend(listener T) : void in class org.hibernate.event.service.internal.EventListenerGroupImpl",
        "diffLocations": [
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/event/service/internal/EventListenerGroupImpl.java",
                "startLine": 252,
                "endLine": 275,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/event/service/internal/EventListenerGroupImpl.java",
                "startLine": 265,
                "endLine": 286,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/event/service/internal/EventListenerGroupImpl.java",
                "startLine": 354,
                "endLine": 357,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "private void internalPrepend(T listener) {\n\t\tprepareListener( listener );\n\t\tfinal T[] listenersRead = this.listeners;\n\t\tfinal T[] listenersWrite;\n\n\t\tif ( listenersRead == null ) {\n\t\t\t//noinspection unchecked\n\t\t\tlistenersWrite = (T[]) Array.newInstance( eventType.baseListenerInterface(), 1 );\n\t\t\tlistenersWrite[0] = listener;\n\t\t}\n\t\telse {\n\t\t\tfinal int size = listenersRead.length;\n\n\t\t\t//noinspection unchecked\n\t\t\tlistenersWrite = (T[]) Array.newInstance( eventType.baseListenerInterface(), size+1 );\n\n\t\t\t// put the new one first\n\t\t\tlistenersWrite[0] = listener;\n\n\t\t\t// and copy the rest after it\n\t\t\tSystem.arraycopy( listenersRead, 0, listenersWrite, 1, size );\n\t\t}\n\t\tsetListeners( listenersWrite );\n\t}",
        "filePathBefore": "hibernate-core/src/main/java/org/hibernate/event/service/internal/EventListenerGroupImpl.java",
        "isPureRefactoring": true,
        "commitId": "052eb0b78c6d5864e0a1b1ec63b487382c82ec1b",
        "packageNameBefore": "org.hibernate.event.service.internal",
        "classNameBefore": "org.hibernate.event.service.internal.EventListenerGroupImpl",
        "methodNameBefore": "org.hibernate.event.service.internal.EventListenerGroupImpl#internalPrepend",
        "invokedMethod": "methodSignature: org.hibernate.event.service.internal.EventListenerGroupImpl#prepareListener\n methodBody: private void prepareListener(T listener) {\ncheckAgainstBaseInterface(listener);\nperformInjections(listener);\n}\nmethodSignature: org.hibernate.event.service.internal.EventListenerGroupImpl#setListeners\n methodBody: private synchronized void setListeners(T[] newListeners) {\nthis.listeners=newListeners;\nif(newListeners == null || newListeners.length == 0){this.listenersAsList=emptyList();\n}{this.listenersAsList=asList(newListeners);\n}}",
        "classSignatureBefore": "class EventListenerGroupImpl<T> implements EventListenerGroup<T> ",
        "methodNameBeforeSet": [
            "org.hibernate.event.service.internal.EventListenerGroupImpl#internalPrepend"
        ],
        "classNameBeforeSet": [
            "org.hibernate.event.service.internal.EventListenerGroupImpl"
        ],
        "classSignatureBeforeSet": [
            "class EventListenerGroupImpl<T> implements EventListenerGroup<T> "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Changes are within the Extract Method refactoring mechanics",
                "description": "All replacements have been justified - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.\n */\npackage org.hibernate.event.service.internal;\n\nimport java.lang.reflect.Array;\nimport java.util.Collections;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.CompletionStage;\nimport java.util.function.BiConsumer;\nimport java.util.function.BiFunction;\nimport java.util.function.Consumer;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\n\nimport org.hibernate.event.service.spi.DuplicationStrategy;\nimport org.hibernate.event.service.spi.EventActionWithParameter;\nimport org.hibernate.event.service.spi.EventListenerGroup;\nimport org.hibernate.event.service.spi.EventListenerRegistrationException;\nimport org.hibernate.event.service.spi.JpaBootstrapSensitive;\nimport org.hibernate.event.spi.EventType;\nimport org.hibernate.jpa.event.spi.CallbackRegistry;\nimport org.hibernate.jpa.event.spi.CallbackRegistryConsumer;\n\nimport org.jboss.logging.Logger;\n\nimport static java.util.Arrays.asList;\nimport static java.util.Collections.emptyList;\n\n/**\n * Standard EventListenerGroup implementation\n *\n * @author Steve Ebersole\n * @author Sanne Grinovero\n */\nclass EventListenerGroupImpl<T> implements EventListenerGroup<T> {\n\n\tprivate static final Logger log = Logger.getLogger( EventListenerGroupImpl.class );\n\tprivate static final Set<DuplicationStrategy> DEFAULT_DUPLICATION_STRATEGIES = Collections.unmodifiableSet( makeDefaultDuplicationStrategy() );\n\tprivate static final CompletableFuture COMPLETED = CompletableFuture.completedFuture( null );\n\n\tprivate final EventType<T> eventType;\n\tprivate final CallbackRegistry callbackRegistry;\n\tprivate final boolean isJpaBootstrap;\n\n\t//TODO at least the list of listeners should be made constant;\n\t//unfortunately a number of external integrations rely on being able to make\n\t//changes to listeners at runtime, so this will require some planning.\n\tprivate volatile Set<DuplicationStrategy> duplicationStrategies = DEFAULT_DUPLICATION_STRATEGIES;\n\tprivate volatile T[] listeners = null;\n\tprivate volatile List<T> listenersAsList = emptyList();\n\n\tpublic EventListenerGroupImpl(\n\t\t\tEventType<T> eventType,\n\t\t\tCallbackRegistry callbackRegistry,\n\t\t\tboolean isJpaBootstrap) {\n\t\tthis.eventType = eventType;\n\t\tthis.callbackRegistry = callbackRegistry;\n\t\tthis.isJpaBootstrap = isJpaBootstrap;\n\t}\n\n\t@Override\n\tpublic EventType<T> getEventType() {\n\t\treturn eventType;\n\t}\n\n\t@Override\n\tpublic boolean isEmpty() {\n\t\treturn count() <= 0;\n\t}\n\n\t@Override\n\tpublic int count() {\n\t\tfinal T[] ls = listeners;\n\t\treturn ls == null ? 0 : ls.length;\n\t}\n\n\t@Override\n\tpublic void clear() {\n\t\t//Odd semantics: we're expected (for backwards compatibility) to also clear the default DuplicationStrategy.\n\t\tduplicationStrategies = new LinkedHashSet<>();\n\t\tsetListeners( null );\n\t}\n\n\t// For efficiency reasons we use both a representation as List and as array;\n\t// ensure consistency between the two fields by delegating any mutation to both\n\t// fields to this method.\n\tprivate synchronized void setListeners(T[] newListeners) {\n\t\tthis.listeners = newListeners;\n\t\tif ( newListeners == null || newListeners.length == 0 ) {\n\t\t\tthis.listenersAsList = emptyList();\n\t\t}\n\t\telse {\n\t\t\tthis.listenersAsList = asList( newListeners );\n\t\t}\n\t}\n\n\t@Override\n\tpublic void clearListeners() {\n\t\tsetListeners( null );\n\t}\n\n\t@Override\n\tpublic final <U> void fireLazyEventOnEachListener(final Supplier<U> eventSupplier, final BiConsumer<T,U> actionOnEvent) {\n\t\tfinal T[] ls = listeners;\n\t\tif ( ls != null && ls.length != 0 ) {\n\t\t\tfinal U event = eventSupplier.get();\n\t\t\t//noinspection ForLoopReplaceableByForEach\n\t\t\tfor ( int i = 0; i < ls.length; i++ ) {\n\t\t\t\tactionOnEvent.accept( ls[i], event );\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic final <U> void fireEventOnEachListener(final U event, final BiConsumer<T,U> actionOnEvent) {\n\t\tfinal T[] ls = listeners;\n\t\tif ( ls != null ) {\n\t\t\t//noinspection ForLoopReplaceableByForEach\n\t\t\tfor ( int i = 0; i < ls.length; i++ ) {\n\t\t\t\tactionOnEvent.accept( ls[i], event );\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic <U,X> void fireEventOnEachListener(final U event, final X parameter, final EventActionWithParameter<T, U, X> actionOnEvent) {\n\t\tfinal T[] ls = listeners;\n\t\tif ( ls != null ) {\n\t\t\t//noinspection ForLoopReplaceableByForEach\n\t\t\tfor ( int i = 0; i < ls.length; i++ ) {\n\t\t\t\tactionOnEvent.applyEventToListener( ls[i], event, parameter );\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic <R, U, RL> CompletionStage<R> fireEventOnEachListener(\n\t\t\tfinal U event,\n\t\t\tfinal Function<RL, Function<U, CompletionStage<R>>> fun) {\n\t\tCompletionStage<R> ret = COMPLETED;\n\t\tfinal T[] ls = listeners;\n\t\tif ( ls != null && ls.length != 0 ) {\n\t\t\tfor ( T listener : ls ) {\n\t\t\t\t//to preserve atomicity of the Session methods\n\t\t\t\t//call apply() from within the arg of thenCompose()\n\t\t\t\tret = ret.thenCompose( v -> fun.apply( (RL) listener ).apply( event ) );\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\n\t@Override\n\tpublic <R, U, RL, X> CompletionStage<R> fireEventOnEachListener(\n\t\t\tU event, X param, Function<RL, BiFunction<U, X, CompletionStage<R>>> fun) {\n\t\tCompletionStage<R> ret = COMPLETED;\n\t\tfinal T[] ls = listeners;\n\t\tif ( ls != null && ls.length != 0 ) {\n\t\t\tfor ( T listener : ls ) {\n\t\t\t\t//to preserve atomicity of the Session methods\n\t\t\t\t//call apply() from within the arg of thenCompose()\n\t\t\t\tret = ret.thenCompose( v -> fun.apply( (RL) listener ).apply( event, param ) );\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\n\t@Override\n\tpublic <R, U, RL> CompletionStage<R> fireLazyEventOnEachListener(\n\t\t\tfinal Supplier<U> eventSupplier,\n\t\t\tfinal Function<RL, Function<U, CompletionStage<R>>> fun) {\n\t\tCompletionStage<R> ret = COMPLETED;\n\t\tfinal T[] ls = listeners;\n\t\tif ( ls != null && ls.length != 0 ) {\n\t\t\tfinal U event = eventSupplier.get();\n\t\t\tfor ( T listener : ls ) {\n\t\t\t\t//to preserve atomicity of the Session methods\n\t\t\t\t//call apply() from within the arg of thenCompose()\n\t\t\t\tret = ret.thenCompose( v -> fun.apply( (RL) listener ).apply( event ) );\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\n\t@Override\n\tpublic void addDuplicationStrategy(DuplicationStrategy strategy) {\n\t\tif ( duplicationStrategies == DEFAULT_DUPLICATION_STRATEGIES ) {\n\t\t\tduplicationStrategies = makeDefaultDuplicationStrategy();\n\t\t}\n\t\tduplicationStrategies.add( strategy );\n\t}\n\n\t@Override\n\tpublic void appendListener(T listener) {\n\t\thandleListenerAddition( listener, this::internalAppend );\n\t}\n\n\t@Override\n\t@SafeVarargs\n\tpublic final void appendListeners(T... listeners) {\n\t\t//noinspection ForLoopReplaceableByForEach\n\t\tfor ( int i = 0; i < listeners.length; i++ ) {\n\t\t\thandleListenerAddition( listeners[i], this::internalAppend );\n\t\t}\n\t}\n\n\tprivate void internalAppend(T listener) {\n\t\tprepareListener( listener );\n\t\tfinal T[] listenersRead = this.listeners;\n\t\tfinal T[] listenersWrite;\n\n\t\tif ( listenersRead == null ) {\n\t\t\t//noinspection unchecked\n\t\t\tlistenersWrite = (T[]) Array.newInstance( eventType.baseListenerInterface(), 1 );\n\t\t\tlistenersWrite[0] = listener;\n\t\t}\n\t\telse {\n\t\t\tfinal int size = listenersRead.length;\n\n\t\t\t//noinspection unchecked\n\t\t\tlistenersWrite = (T[]) Array.newInstance( eventType.baseListenerInterface(), size+1 );\n\n\t\t\t// first copy the existing listeners\n\t\t\tSystem.arraycopy( listenersRead, 0, listenersWrite, 0, size );\n\n\t\t\t// and then put the new one after them\n\t\t\tlistenersWrite[size] = listener;\n\t\t}\n\t\tsetListeners( listenersWrite );\n\t}\n\n\t@Override\n\tpublic void prependListener(T listener) {\n\t\thandleListenerAddition( listener, this::internalPrepend );\n\t}\n\n\t@Override\n\t@SafeVarargs\n\tpublic final void prependListeners(T... listeners) {\n\t\t//noinspection ForLoopReplaceableByForEach\n\t\tfor ( int i = 0; i < listeners.length; i++ ) {\n\t\t\thandleListenerAddition( listeners[i], this::internalPrepend );\n\t\t}\n\t}\n\n\tprivate void internalPrepend(T listener) {\n\t\tprepareListener( listener );\n\t\tfinal T[] listenersRead = this.listeners;\n\t\tfinal T[] listenersWrite;\n\n\t\tif ( listenersRead == null ) {\n\t\t\t//noinspection unchecked\n\t\t\tlistenersWrite = (T[]) Array.newInstance( eventType.baseListenerInterface(), 1 );\n\t\t\tlistenersWrite[0] = listener;\n\t\t}\n\t\telse {\n\t\t\tfinal int size = listenersRead.length;\n\n\t\t\t//noinspection unchecked\n\t\t\tlistenersWrite = (T[]) Array.newInstance( eventType.baseListenerInterface(), size+1 );\n\n\t\t\t// put the new one first\n\t\t\tlistenersWrite[0] = listener;\n\n\t\t\t// and copy the rest after it\n\t\t\tSystem.arraycopy( listenersRead, 0, listenersWrite, 1, size );\n\t\t}\n\t\tsetListeners( listenersWrite );\n\t}\n\n\tprivate void handleListenerAddition(T listener, Consumer<T> additionHandler) {\n\t\tfinal T[] listenersRead = this.listeners;\n\t\tif ( listenersRead == null ) {\n\t\t\tadditionHandler.accept( listener );\n\t\t\treturn;\n\t\t}\n\t\tfinal T[] listenersWrite = (T[]) Array.newInstance( eventType.baseListenerInterface(), listenersRead.length );\n\t\tSystem.arraycopy( listenersRead, 0, listenersWrite, 0, listenersRead.length );\n\n\t\tfinal boolean debugEnabled = log.isDebugEnabled();\n\n\t\tfor ( DuplicationStrategy strategy : duplicationStrategies ) {\n\n\t\t\t// for each strategy, see if the strategy indicates that any of the existing\n\t\t\t//\t\tlisteners match the listener being added.  If so, we want to apply that\n\t\t\t//\t\tstrategy's action.  Control it returned immediately after applying the action\n\t\t\t//\t\ton match - meaning no further strategies are checked...\n\n\t\t\tfor ( int i = 0; i < listenersRead.length; i++ ) {\n\t\t\t\tfinal T existingListener = listenersRead[i];\n\t\t\t\tif ( debugEnabled ) {\n\t\t\t\t\tlog.debugf(\n\t\t\t\t\t\t\t\"Checking incoming listener [`%s`] for match against existing listener [`%s`]\",\n\t\t\t\t\t\t\tlistener,\n\t\t\t\t\t\t\texistingListener\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tif ( strategy.areMatch( listener,  existingListener ) ) {\n\t\t\t\t\tif ( debugEnabled ) {\n\t\t\t\t\t\tlog.debugf( \"Found listener match between `%s` and `%s`\", listener, existingListener );\n\t\t\t\t\t}\n\n\t\t\t\t\tswitch ( strategy.getAction() ) {\n\t\t\t\t\t\tcase ERROR: {\n\t\t\t\t\t\t\tthrow new EventListenerRegistrationException( \"Duplicate event listener found\" );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase KEEP_ORIGINAL: {\n\t\t\t\t\t\t\tif ( debugEnabled ) {\n\t\t\t\t\t\t\t\tlog.debugf( \"Skipping listener registration (%s) : `%s`\", strategy.getAction(), listener );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase REPLACE_ORIGINAL: {\n\t\t\t\t\t\t\tif ( debugEnabled ) {\n\t\t\t\t\t\t\t\tlog.debugf( \"Replacing listener registration (%s) : `%s` -> `%s`\", strategy.getAction(), existingListener, listener );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tprepareListener( listener );\n\n\t\t\t\t\t\t\tlistenersWrite[i] = listener;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// we've found a match - we should return: the match action has already been applied at this point\n\t\t\t\t\t// apply all pending changes:\n\t\t\t\t\tsetListeners( listenersWrite );\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// we did not find any match.. add it\n\t\tcheckAgainstBaseInterface( listener );\n\t\tperformInjections( listener );\n\t\tadditionHandler.accept( listener );\n\t}\n\n\tprivate void prepareListener(T listener) {\n\t\tcheckAgainstBaseInterface( listener );\n\t\tperformInjections( listener );\n\t}\n\n\tprivate void performInjections(T listener) {\n\t\tif ( listener instanceof CallbackRegistryConsumer ) {\n\t\t\t( (CallbackRegistryConsumer) listener ).injectCallbackRegistry( callbackRegistry );\n\t\t}\n\n\t\tif ( listener instanceof JpaBootstrapSensitive ) {\n\t\t\t( (JpaBootstrapSensitive) listener ).wasJpaBootstrap( isJpaBootstrap );\n\t\t}\n\t}\n\n\tprivate void checkAgainstBaseInterface(T listener) {\n\t\tif ( !eventType.baseListenerInterface().isInstance( listener ) ) {\n\t\t\tthrow new EventListenerRegistrationException(\n\t\t\t\t\t\"Listener did not implement expected interface [\" + eventType.baseListenerInterface().getName() + \"]\"\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * Implementation note: should be final for performance reasons.\n\t * @deprecated this is not the most efficient way for iterating the event listeners.\n\t * See {@link #fireEventOnEachListener(Object, BiConsumer)} and co. for better alternatives.\n\t */\n\t@Override\n\t@Deprecated\n\tpublic final Iterable<T> listeners() {\n\t\treturn this.listenersAsList;\n\t}\n\n\tprivate static Set<DuplicationStrategy> makeDefaultDuplicationStrategy() {\n\t\tfinal Set<DuplicationStrategy> duplicationStrategies = new LinkedHashSet<>();\n\t\tduplicationStrategies.add(\n\t\t\t\t// At minimum make sure we do not register the same exact listener class multiple times.\n\t\t\t\tnew DuplicationStrategy() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic boolean areMatch(Object listener, Object original) {\n\t\t\t\t\t\treturn listener.getClass().equals( original.getClass() );\n\t\t\t\t\t}\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic Action getAction() {\n\t\t\t\t\t\treturn Action.ERROR;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t);\n\t\treturn duplicationStrategies;\n\t}\n\n}\n",
        "filePathAfter": "hibernate-core/src/main/java/org/hibernate/event/service/internal/EventListenerGroupImpl.java",
        "sourceCodeAfterForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.\n */\npackage org.hibernate.event.service.internal;\n\nimport java.lang.reflect.Array;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.CompletionStage;\nimport java.util.function.BiConsumer;\nimport java.util.function.BiFunction;\nimport java.util.function.Consumer;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\n\nimport org.hibernate.event.service.spi.DuplicationStrategy;\nimport org.hibernate.event.service.spi.EventActionWithParameter;\nimport org.hibernate.event.service.spi.EventListenerGroup;\nimport org.hibernate.event.service.spi.EventListenerRegistrationException;\nimport org.hibernate.event.service.spi.JpaBootstrapSensitive;\nimport org.hibernate.event.spi.EventType;\nimport org.hibernate.jpa.event.spi.CallbackRegistry;\nimport org.hibernate.jpa.event.spi.CallbackRegistryConsumer;\n\nimport org.jboss.logging.Logger;\n\nimport static java.util.Arrays.asList;\nimport static java.util.Collections.emptyList;\nimport static java.util.Collections.singleton;\nimport static java.util.concurrent.CompletableFuture.completedFuture;\n\n/**\n * Standard EventListenerGroup implementation\n *\n * @author Steve Ebersole\n * @author Sanne Grinovero\n */\nclass EventListenerGroupImpl<T> implements EventListenerGroup<T> {\n\n\tprivate static final Logger log = Logger.getLogger( EventListenerGroupImpl.class );\n\n\tprivate static final DuplicationStrategy DEFAULT_DUPLICATION_STRATEGY =\n\t\t\tnew DuplicationStrategy() {\n\t\t\t\t@Override\n\t\t\t\tpublic boolean areMatch(Object listener, Object original) {\n\t\t\t\t\treturn listener.getClass().equals( original.getClass() );\n\t\t\t\t}\n\t\t\t\t@Override\n\t\t\t\tpublic Action getAction() {\n\t\t\t\t\treturn Action.ERROR;\n\t\t\t\t}\n\t\t\t};\n\tprivate static final Set<DuplicationStrategy> DEFAULT_DUPLICATION_STRATEGIES =\n\t\t\tsingleton( DEFAULT_DUPLICATION_STRATEGY );\n\n\tprivate static final CompletableFuture<?> COMPLETED = completedFuture( null );\n\t@SuppressWarnings(\"unchecked\")\n\tprivate static <R> CompletableFuture<R> nullCompletion() {\n\t\treturn (CompletableFuture<R>) COMPLETED;\n\t}\n\n\tprivate final EventType<T> eventType;\n\tprivate final CallbackRegistry callbackRegistry;\n\tprivate final boolean isJpaBootstrap;\n\n\t//TODO at least the list of listeners should be made constant;\n\t//unfortunately a number of external integrations rely on being able to make\n\t//changes to listeners at runtime, so this will require some planning.\n\tprivate volatile Set<DuplicationStrategy> duplicationStrategies = DEFAULT_DUPLICATION_STRATEGIES;\n\tprivate volatile T[] listeners = null;\n\tprivate volatile List<T> listenersAsList = emptyList();\n\n\tpublic EventListenerGroupImpl(EventType<T> eventType, CallbackRegistry callbackRegistry, boolean isJpaBootstrap) {\n\t\tthis.eventType = eventType;\n\t\tthis.callbackRegistry = callbackRegistry;\n\t\tthis.isJpaBootstrap = isJpaBootstrap;\n\t}\n\n\t@Override\n\tpublic EventType<T> getEventType() {\n\t\treturn eventType;\n\t}\n\n\t@Override\n\tpublic boolean isEmpty() {\n\t\treturn count() <= 0;\n\t}\n\n\t@Override\n\tpublic int count() {\n\t\tfinal T[] ls = listeners;\n\t\treturn ls == null ? 0 : ls.length;\n\t}\n\n\t@Override\n\tpublic void clear() {\n\t\t//Odd semantics: we're expected (for backwards compatibility)\n\t\t//               to also clear the default DuplicationStrategy.\n\t\tduplicationStrategies = new LinkedHashSet<>();\n\t\tsetListeners( null );\n\t}\n\n\t// For efficiency reasons we use both a representation as List and as array;\n\t// ensure consistency between the two fields by delegating any mutation to both\n\t// fields to this method.\n\tprivate synchronized void setListeners(T[] newListeners) {\n\t\tlisteners = newListeners;\n\t\tlistenersAsList = newListeners == null || newListeners.length == 0\n\t\t\t\t? emptyList()\n\t\t\t\t: asList( newListeners );\n\t}\n\n\t@Override\n\tpublic void clearListeners() {\n\t\tsetListeners( null );\n\t}\n\n\t@Override\n\tpublic final <U> void fireLazyEventOnEachListener(Supplier<U> eventSupplier, BiConsumer<T,U> actionOnEvent) {\n\t\tfinal T[] ls = listeners;\n\t\tif ( ls != null && ls.length != 0 ) {\n\t\t\tfinal U event = eventSupplier.get();\n\t\t\t//noinspection ForLoopReplaceableByForEach\n\t\t\tfor ( int i = 0; i < ls.length; i++ ) {\n\t\t\t\tactionOnEvent.accept( ls[i], event );\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic final <U> void fireEventOnEachListener(U event, BiConsumer<T,U> actionOnEvent) {\n\t\tfinal T[] ls = listeners;\n\t\tif ( ls != null ) {\n\t\t\t//noinspection ForLoopReplaceableByForEach\n\t\t\tfor ( int i = 0; i < ls.length; i++ ) {\n\t\t\t\tactionOnEvent.accept( ls[i], event );\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic <U,X> void fireEventOnEachListener(U event, X parameter, EventActionWithParameter<T, U, X> actionOnEvent) {\n\t\tfinal T[] ls = listeners;\n\t\tif ( ls != null ) {\n\t\t\t//noinspection ForLoopReplaceableByForEach\n\t\t\tfor ( int i = 0; i < ls.length; i++ ) {\n\t\t\t\tactionOnEvent.applyEventToListener( ls[i], event, parameter );\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic <R, U, RL> CompletionStage<R> fireEventOnEachListener(\n\t\t\tfinal U event,\n\t\t\tfinal Function<RL, Function<U, CompletionStage<R>>> fun) {\n\t\tCompletionStage<R> ret = nullCompletion();\n\t\tfinal T[] ls = listeners;\n\t\tif ( ls != null ) {\n\t\t\tfor ( T listener : ls ) {\n\t\t\t\t//to preserve atomicity of the Session methods\n\t\t\t\t//call apply() from within the arg of thenCompose()\n\t\t\t\tret = ret.thenCompose( v -> fun.apply( (RL) listener ).apply( event ) );\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\n\t@Override\n\tpublic <R, U, RL, X> CompletionStage<R> fireEventOnEachListener(\n\t\t\tU event, X param, Function<RL, BiFunction<U, X, CompletionStage<R>>> fun) {\n\t\tCompletionStage<R> ret = nullCompletion();\n\t\tfinal T[] ls = listeners;\n\t\tif ( ls != null ) {\n\t\t\tfor ( T listener : ls ) {\n\t\t\t\t//to preserve atomicity of the Session methods\n\t\t\t\t//call apply() from within the arg of thenCompose()\n\t\t\t\tret = ret.thenCompose( v -> fun.apply( (RL) listener ).apply( event, param ) );\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\n\t@Override\n\tpublic <R, U, RL> CompletionStage<R> fireLazyEventOnEachListener(\n\t\t\tSupplier<U> eventSupplier,\n\t\t\tFunction<RL, Function<U, CompletionStage<R>>> fun) {\n\t\tCompletionStage<R> ret = nullCompletion();\n\t\tfinal T[] ls = listeners;\n\t\tif ( ls != null && ls.length != 0 ) {\n\t\t\tfinal U event = eventSupplier.get();\n\t\t\tfor ( T listener : ls ) {\n\t\t\t\t//to preserve atomicity of the Session methods\n\t\t\t\t//call apply() from within the arg of thenCompose()\n\t\t\t\tret = ret.thenCompose( v -> fun.apply( (RL) listener ).apply( event ) );\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\n\t@Override\n\tpublic void addDuplicationStrategy(DuplicationStrategy strategy) {\n\t\tif ( duplicationStrategies == DEFAULT_DUPLICATION_STRATEGIES ) {\n\t\t\t// At minimum make sure we do not register the same exact listener class multiple times.\n\t\t\tduplicationStrategies = new LinkedHashSet<>( DEFAULT_DUPLICATION_STRATEGIES );\n\t\t}\n\t\tduplicationStrategies.add( strategy );\n\t}\n\n\t@Override\n\tpublic void appendListener(T listener) {\n\t\thandleListenerAddition( listener, this::internalAppend );\n\t}\n\n\t@Override\n\t@SafeVarargs\n\tpublic final void appendListeners(T... listeners) {\n\t\t//noinspection ForLoopReplaceableByForEach\n\t\tfor ( int i = 0; i < listeners.length; i++ ) {\n\t\t\thandleListenerAddition( listeners[i], this::internalAppend );\n\t\t}\n\t}\n\n\tprivate void internalAppend(T listener) {\n\t\tprepareListener( listener );\n\t\tfinal T[] listenersRead = listeners;\n\t\tfinal T[] listenersWrite;\n\n\t\tif ( listenersRead == null ) {\n\t\t\tlistenersWrite = createListenerArrayForWrite( 1 );\n\t\t\tlistenersWrite[0] = listener;\n\t\t}\n\t\telse {\n\t\t\tfinal int size = listenersRead.length;\n\n\t\t\tlistenersWrite = createListenerArrayForWrite( size + 1 );\n\n\t\t\t// first copy the existing listeners\n\t\t\tSystem.arraycopy( listenersRead, 0, listenersWrite, 0, size );\n\n\t\t\t// and then put the new one after them\n\t\t\tlistenersWrite[size] = listener;\n\t\t}\n\t\tsetListeners( listenersWrite );\n\t}\n\n\t@Override\n\tpublic void prependListener(T listener) {\n\t\thandleListenerAddition( listener, this::internalPrepend );\n\t}\n\n\t@Override\n\t@SafeVarargs\n\tpublic final void prependListeners(T... listeners) {\n\t\t//noinspection ForLoopReplaceableByForEach\n\t\tfor ( int i = 0; i < listeners.length; i++ ) {\n\t\t\thandleListenerAddition( listeners[i], this::internalPrepend );\n\t\t}\n\t}\n\n\tprivate void internalPrepend(T listener) {\n\t\tprepareListener( listener );\n\t\tfinal T[] listenersRead = listeners;\n\t\tfinal T[] listenersWrite;\n\n\t\tif ( listenersRead == null ) {\n\t\t\tlistenersWrite = createListenerArrayForWrite( 1 );\n\t\t\tlistenersWrite[0] = listener;\n\t\t}\n\t\telse {\n\t\t\tfinal int size = listenersRead.length;\n\n\t\t\tlistenersWrite = createListenerArrayForWrite( size + 1 );\n\n\t\t\t// put the new one first\n\t\t\tlistenersWrite[0] = listener;\n\n\t\t\t// and copy the rest after it\n\t\t\tSystem.arraycopy( listenersRead, 0, listenersWrite, 1, size );\n\t\t}\n\t\tsetListeners( listenersWrite );\n\t}\n\n\tprivate void handleListenerAddition(T listener, Consumer<T> additionHandler) {\n\t\tfinal T[] listenersRead = listeners;\n\t\tif ( listenersRead == null ) {\n\t\t\tadditionHandler.accept( listener );\n\t\t\treturn;\n\t\t}\n\t\tint size = listenersRead.length;\n\n\t\tfinal T[] listenersWrite = createListenerArrayForWrite( size );\n\t\tSystem.arraycopy( listenersRead, 0, listenersWrite, 0, size );\n\n\t\tfinal boolean debugEnabled = log.isDebugEnabled();\n\n\t\tfor ( DuplicationStrategy strategy : duplicationStrategies ) {\n\n\t\t\t// for each strategy, see if the strategy indicates that any of the existing\n\t\t\t//\t\tlisteners match the listener being added.  If so, we want to apply that\n\t\t\t//\t\tstrategy's action.  Control it returned immediately after applying the action\n\t\t\t//\t\ton match - meaning no further strategies are checked...\n\n\t\t\tfor ( int i = 0; i < size; i++ ) {\n\t\t\t\tfinal T existingListener = listenersRead[i];\n\t\t\t\tif ( debugEnabled ) {\n\t\t\t\t\tlog.debugf( \"Checking incoming listener [`%s`] for match against existing listener [`%s`]\",\n\t\t\t\t\t\t\tlistener, existingListener );\n\t\t\t\t}\n\n\t\t\t\tif ( strategy.areMatch( listener,  existingListener ) ) {\n\t\t\t\t\tif ( debugEnabled ) {\n\t\t\t\t\t\tlog.debugf( \"Found listener match between `%s` and `%s`\",\n\t\t\t\t\t\t\t\tlistener, existingListener );\n\t\t\t\t\t}\n\n\t\t\t\t\tfinal DuplicationStrategy.Action action = strategy.getAction();\n\t\t\t\t\tswitch (action) {\n\t\t\t\t\t\tcase ERROR:\n\t\t\t\t\t\t\tthrow new EventListenerRegistrationException( \"Duplicate event listener found\" );\n\t\t\t\t\t\tcase KEEP_ORIGINAL:\n\t\t\t\t\t\t\tif ( debugEnabled ) {\n\t\t\t\t\t\t\t\tlog.debugf( \"Skipping listener registration (%s) : `%s`\",\n\t\t\t\t\t\t\t\t\t\taction, listener );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\tcase REPLACE_ORIGINAL:\n\t\t\t\t\t\t\tif ( debugEnabled ) {\n\t\t\t\t\t\t\t\tlog.debugf( \"Replacing listener registration (%s) : `%s` -> `%s`\",\n\t\t\t\t\t\t\t\t\t\taction, existingListener, listener );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tprepareListener( listener );\n\t\t\t\t\t\t\tlistenersWrite[i] = listener;\n\t\t\t\t\t}\n\n\t\t\t\t\t// we've found a match - we should return: the match action has already been applied at this point\n\t\t\t\t\t// apply all pending changes:\n\t\t\t\t\tsetListeners( listenersWrite );\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// we did not find any match, add it\n\t\tcheckAgainstBaseInterface( listener );\n\t\tperformInjections( listener );\n\t\tadditionHandler.accept( listener );\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tprivate T[] createListenerArrayForWrite(int len) {\n\t\treturn (T[]) Array.newInstance( eventType.baseListenerInterface(), len );\n\t}\n\n\tprivate void prepareListener(T listener) {\n\t\tcheckAgainstBaseInterface( listener );\n\t\tperformInjections( listener );\n\t}\n\n\tprivate void performInjections(T listener) {\n\t\tif ( listener instanceof CallbackRegistryConsumer consumer ) {\n\t\t\tconsumer.injectCallbackRegistry( callbackRegistry );\n\t\t}\n\t\tif ( listener instanceof JpaBootstrapSensitive sensitive ) {\n\t\t\tsensitive.wasJpaBootstrap( isJpaBootstrap );\n\t\t}\n\t}\n\n\tprivate void checkAgainstBaseInterface(T listener) {\n\t\tif ( !eventType.baseListenerInterface().isInstance( listener ) ) {\n\t\t\tthrow new EventListenerRegistrationException( \"Listener did not implement expected interface [\"\n\t\t\t\t\t+ eventType.baseListenerInterface().getName() + \"]\" );\n\t\t}\n\t}\n\n\t/**\n\t * Implementation note: should be final for performance reasons.\n\t * @deprecated this is not the most efficient way for iterating the event listeners.\n\t * See {@link #fireEventOnEachListener(Object, BiConsumer)} and co. for better alternatives.\n\t */\n\t@Override\n\t@Deprecated\n\tpublic final Iterable<T> listeners() {\n\t\treturn listenersAsList;\n\t}\n}\n",
        "diffSourceCodeSet": [
            "@SuppressWarnings(\"unchecked\")\n\tprivate T[] createListenerArrayForWrite(int len) {\n\t\treturn (T[]) Array.newInstance( eventType.baseListenerInterface(), len );\n\t}"
        ],
        "invokedMethodSet": [
            "methodSignature: org.hibernate.event.service.internal.EventListenerGroupImpl#prepareListener\n methodBody: private void prepareListener(T listener) {\ncheckAgainstBaseInterface(listener);\nperformInjections(listener);\n}",
            "methodSignature: org.hibernate.event.service.internal.EventListenerGroupImpl#setListeners\n methodBody: private synchronized void setListeners(T[] newListeners) {\nthis.listeners=newListeners;\nif(newListeners == null || newListeners.length == 0){this.listenersAsList=emptyList();\n}{this.listenersAsList=asList(newListeners);\n}}"
        ],
        "sourceCodeAfterRefactoring": "private void internalPrepend(T listener) {\n\t\tprepareListener( listener );\n\t\tfinal T[] listenersRead = listeners;\n\t\tfinal T[] listenersWrite;\n\n\t\tif ( listenersRead == null ) {\n\t\t\tlistenersWrite = createListenerArrayForWrite( 1 );\n\t\t\tlistenersWrite[0] = listener;\n\t\t}\n\t\telse {\n\t\t\tfinal int size = listenersRead.length;\n\n\t\t\tlistenersWrite = createListenerArrayForWrite( size + 1 );\n\n\t\t\t// put the new one first\n\t\t\tlistenersWrite[0] = listener;\n\n\t\t\t// and copy the rest after it\n\t\t\tSystem.arraycopy( listenersRead, 0, listenersWrite, 1, size );\n\t\t}\n\t\tsetListeners( listenersWrite );\n\t}\n@SuppressWarnings(\"unchecked\")\n\tprivate T[] createListenerArrayForWrite(int len) {\n\t\treturn (T[]) Array.newInstance( eventType.baseListenerInterface(), len );\n\t}",
        "diffSourceCode": "-  252: \tprivate void internalPrepend(T listener) {\n-  253: \t\tprepareListener( listener );\n-  254: \t\tfinal T[] listenersRead = this.listeners;\n-  255: \t\tfinal T[] listenersWrite;\n-  256: \n-  257: \t\tif ( listenersRead == null ) {\n-  258: \t\t\t//noinspection unchecked\n-  259: \t\t\tlistenersWrite = (T[]) Array.newInstance( eventType.baseListenerInterface(), 1 );\n-  260: \t\t\tlistenersWrite[0] = listener;\n-  261: \t\t}\n-  262: \t\telse {\n-  263: \t\t\tfinal int size = listenersRead.length;\n+  252: \tpublic void prependListener(T listener) {\n+  253: \t\thandleListenerAddition( listener, this::internalPrepend );\n+  254: \t}\n+  255: \n+  256: \t@Override\n+  257: \t@SafeVarargs\n+  258: \tpublic final void prependListeners(T... listeners) {\n+  259: \t\t//noinspection ForLoopReplaceableByForEach\n+  260: \t\tfor ( int i = 0; i < listeners.length; i++ ) {\n+  261: \t\t\thandleListenerAddition( listeners[i], this::internalPrepend );\n+  262: \t\t}\n+  263: \t}\n   264: \n-  265: \t\t\t//noinspection unchecked\n-  266: \t\t\tlistenersWrite = (T[]) Array.newInstance( eventType.baseListenerInterface(), size+1 );\n-  267: \n-  268: \t\t\t// put the new one first\n-  269: \t\t\tlistenersWrite[0] = listener;\n-  270: \n-  271: \t\t\t// and copy the rest after it\n-  272: \t\t\tSystem.arraycopy( listenersRead, 0, listenersWrite, 1, size );\n+  265: \tprivate void internalPrepend(T listener) {\n+  266: \t\tprepareListener( listener );\n+  267: \t\tfinal T[] listenersRead = listeners;\n+  268: \t\tfinal T[] listenersWrite;\n+  269: \n+  270: \t\tif ( listenersRead == null ) {\n+  271: \t\t\tlistenersWrite = createListenerArrayForWrite( 1 );\n+  272: \t\t\tlistenersWrite[0] = listener;\n   273: \t\t}\n-  274: \t\tsetListeners( listenersWrite );\n-  275: \t}\n+  274: \t\telse {\n+  275: \t\t\tfinal int size = listenersRead.length;\n   276: \n-  277: \tprivate void handleListenerAddition(T listener, Consumer<T> additionHandler) {\n-  278: \t\tfinal T[] listenersRead = this.listeners;\n-  279: \t\tif ( listenersRead == null ) {\n-  280: \t\t\tadditionHandler.accept( listener );\n-  281: \t\t\treturn;\n-  282: \t\t}\n-  283: \t\tfinal T[] listenersWrite = (T[]) Array.newInstance( eventType.baseListenerInterface(), listenersRead.length );\n-  284: \t\tSystem.arraycopy( listenersRead, 0, listenersWrite, 0, listenersRead.length );\n-  285: \n-  286: \t\tfinal boolean debugEnabled = log.isDebugEnabled();\n-  354: \t\tif ( listener instanceof JpaBootstrapSensitive ) {\n-  355: \t\t\t( (JpaBootstrapSensitive) listener ).wasJpaBootstrap( isJpaBootstrap );\n-  356: \t\t}\n+  277: \t\t\tlistenersWrite = createListenerArrayForWrite( size + 1 );\n+  278: \n+  279: \t\t\t// put the new one first\n+  280: \t\t\tlistenersWrite[0] = listener;\n+  281: \n+  282: \t\t\t// and copy the rest after it\n+  283: \t\t\tSystem.arraycopy( listenersRead, 0, listenersWrite, 1, size );\n+  284: \t\t}\n+  285: \t\tsetListeners( listenersWrite );\n+  286: \t}\n+  354: \t@SuppressWarnings(\"unchecked\")\n+  355: \tprivate T[] createListenerArrayForWrite(int len) {\n+  356: \t\treturn (T[]) Array.newInstance( eventType.baseListenerInterface(), len );\n   357: \t}\n",
        "uniqueId": "052eb0b78c6d5864e0a1b1ec63b487382c82ec1b_252_275_354_357_265_286",
        "moveFileExist": true,
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 21,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 9,
                "covered": 31
            },
            "BRANCH": {
                "missed": 1,
                "covered": 1
            },
            "LINE": {
                "missed": 2,
                "covered": 9
            },
            "COMPLEXITY": {
                "missed": 1,
                "covered": 1
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        }
    }
]