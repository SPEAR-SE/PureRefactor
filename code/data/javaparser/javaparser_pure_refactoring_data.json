[
    {
        "type": "Extract Method",
        "description": "Extract Method\tprivate assertCompilationFails(s String) : void extracted from package record_cannotExtend() : void in class com.github.javaparser.ast.body.RecordDeclarationTest",
        "diffLocations": [
            {
                "filePath": "javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/RecordDeclarationTest.java",
                "startLine": 95,
                "endLine": 104,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/RecordDeclarationTest.java",
                "startLine": 96,
                "endLine": 103,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/RecordDeclarationTest.java",
                "startLine": 307,
                "endLine": 311,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "/**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-record\n     */\n    @Test\n    void record_cannotExtend() {\n        String s = \"record Point(int x, int y) extends OtherThing { }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n    }",
        "filePathBefore": "javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/RecordDeclarationTest.java",
        "isPureRefactoring": true,
        "commitId": "a73aba7b8cef7c52666d25169a3f6e495c65bcd2",
        "packageNameBefore": "com.github.javaparser.ast.body",
        "classNameBefore": "com.github.javaparser.ast.body.RecordDeclarationTest",
        "methodNameBefore": "com.github.javaparser.ast.body.RecordDeclarationTest#record_cannotExtend",
        "classSignatureBefore": "public class RecordDeclarationTest ",
        "methodNameBeforeSet": [
            "com.github.javaparser.ast.body.RecordDeclarationTest#record_cannotExtend"
        ],
        "classNameBeforeSet": [
            "com.github.javaparser.ast.body.RecordDeclarationTest"
        ],
        "classSignatureBeforeSet": [
            "public class RecordDeclarationTest "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "package com.github.javaparser.ast.body;\n\nimport com.github.javaparser.ParserConfiguration;\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.Modifier;\nimport com.github.javaparser.ast.NodeList;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.EnumSource;\nimport org.opentest4j.AssertionFailedError;\n\nimport java.util.List;\n\nimport static com.github.javaparser.utils.TestParser.parseCompilationUnit;\nimport static com.github.javaparser.utils.TestUtils.assertEqualsStringIgnoringEol;\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\npublic class RecordDeclarationTest {\n\n    @ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_13\", \"JAVA_13_PREVIEW\", \"JAVA_14\", \"JAVA_15\"})\n    void basicGrammarCompiles_languageLevelValidation_forbidden(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"record Point(int x, int y) { }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(languageLevel, s);\n        });\n    }\n\n    @ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_14_PREVIEW\", \"JAVA_15_PREVIEW\", \"JAVA_16\", \"JAVA_16_PREVIEW\"})\n    void basicGrammarCompiles_languageLevelValidation_permitted(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(languageLevel, s);\n    }\n\n    @Test\n    void basicGrammarCompiles() {\n        /* https://openjdk.java.net/jeps/395#Description */\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    @Test\n    void basicGrammar() {\n        /* https://openjdk.java.net/jeps/395#Description */\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        assertTrue(recordDeclaration.isRecordDeclaration());\n        assertTrue(recordDeclaration.getImplementedTypes().isEmpty());\n        assertTrue(recordDeclaration.getTypeParameters().isEmpty());\n        assertTrue(recordDeclaration.getFullyQualifiedName().isPresent());\n        assertEquals(\"Point\", recordDeclaration.getFullyQualifiedName().get());\n        assertTrue(recordDeclaration.isRecordDeclaration());\n\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"x\", parameter0.getNameAsString());\n        assertEquals(\"int\", parameter0.getTypeAsString());\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"y\", parameter1.getNameAsString());\n        assertEquals(\"int\", parameter1.getTypeAsString());\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Description\n     */\n    @Test\n    void basicRecordPrints() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        String expected = \"\" +\n                \"record Point(int x, int y) {\\n\" +\n                \"}\\n\" +\n                \"\";\n        assertEqualsStringIgnoringEol(expected, cu.toString());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-record\n     */\n    @Test\n    void record_cannotExtend() {\n        String s = \"record Point(int x, int y) extends OtherThing { }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_cannotBeAbstract() {\n        String s = \"abstract record Point(int x, int y) { }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n    }\n\n    @Test\n    void recordWithVarArgs() {\n        String s = \"record R(T1 c1, Tn... cn){ }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"c1\", parameter0.getNameAsString());\n        assertEquals(\"T1\", parameter0.getTypeAsString());\n        assertFalse(parameter0.isVarArgs());\n\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"cn\", parameter1.getNameAsString());\n        assertEquals(\"Tn\", parameter1.getTypeAsString());\n        assertTrue(parameter1.isVarArgs());\n    }\n\n    @Test\n    void recordWithAnnotationedParameters() {\n        String s = \"record Card(@MyAnno Rank rank, @MyAnno Suit suit) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"rank\", parameter0.getNameAsString());\n        assertEquals(\"Rank\", parameter0.getTypeAsString());\n        assertEquals(1, parameter0.getAnnotations().size());\n\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"suit\", parameter1.getNameAsString());\n        assertEquals(\"Suit\", parameter1.getTypeAsString());\n        assertEquals(1, parameter1.getAnnotations().size());\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    @Test\n    void record_emptyMembers() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    @Test\n    void record_permitStaticFields() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    static int z;\\n\" +\n                \"\\n\" +\n                \"    static {\\n\" +\n                \"        int z = 10;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    @Test\n    void record_permitMethods() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    public String xyz() {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    @Test\n    void record_mustNotAllowNonStaticFields() {\n        String s = \"record Point(int x, int y) { int z; }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n    }\n\n    @Test\n    void record_mustAllowStaticFields() {\n        String s = \"record Point(int x, int y) { static int z; }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n\n    @Test\n    void record_mustNotAllowMismatchedComponentAccessorReturnType() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public String x() {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n\n    }\n\n    @Test\n    void record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public String x(int a) {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    @Test\n    void record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod2() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public int x(int a) {\\n\" +\n                \"        return 10;\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n\n    @Test\n    void record_allowComponentAccessorWithMatchingType() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return 10;\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    // https://bugs.openjdk.java.net/browse/JDK-8222777\n    @Test\n    void recordDeclarationFromTheJDK8222777() {\n        CompilationUnit cu = parseCompilationUnit(\"\" +\n                \"public record Range(int lo, int hi) {\\n\" +\n                \"\\n\" +\n                \"  public Range {\\n\" +\n                \"    if (lo > hi)  /* referring here to the implicit constructor parameters */\\n\" +\n                \"      throw new IllegalArgumentException(String.format(\\\"(%d,%d)\\\", lo, hi));\\n\" +\n                \"  }\\n\" +\n                \"}\"\n        );\n\n        RecordDeclaration record = cu.findFirst(RecordDeclaration.class).get();\n        assertThat(record.getNameAsString()).isEqualTo(\"Range\");\n        assertThat(record.getModifiers()).containsExactly(Modifier.publicModifier());\n        // test parameters\n        // get constructor\n        // test parameters (none)\n    }\n}\n",
        "filePathAfter": "javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/RecordDeclarationTest.java",
        "sourceCodeAfterForWhole": "package com.github.javaparser.ast.body;\n\nimport com.github.javaparser.ParserConfiguration;\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.Modifier;\nimport com.github.javaparser.ast.NodeList;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.EnumSource;\nimport org.opentest4j.AssertionFailedError;\n\nimport java.util.List;\n\nimport static com.github.javaparser.utils.TestParser.parseCompilationUnit;\nimport static com.github.javaparser.utils.TestUtils.assertEqualsStringIgnoringEol;\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\npublic class RecordDeclarationTest {\n\n    @ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_13\", \"JAVA_13_PREVIEW\", \"JAVA_14\", \"JAVA_15\"})\n    void basicGrammarCompiles_languageLevelValidation_forbidden(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"record Point(int x, int y) { }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(languageLevel, s);\n        });\n    }\n\n    @ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_14_PREVIEW\", \"JAVA_15_PREVIEW\", \"JAVA_16\", \"JAVA_16_PREVIEW\"})\n    void basicGrammarCompiles_languageLevelValidation_permitted(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(languageLevel, s);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Description\n     */\n    @Test\n    void basicGrammarCompiles() {\n        String s = \"record Point(int x, int y) { }\";\n        assertOneRecordDeclaration(parseCompilationUnit(s));\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Description\n     */\n    @Test\n    void basicGrammar() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        RecordDeclaration recordDeclaration = cu.findAll(RecordDeclaration.class).get(0);\n\n        assertTrue(recordDeclaration.isRecordDeclaration());\n        assertTrue(recordDeclaration.getImplementedTypes().isEmpty());\n        assertTrue(recordDeclaration.getTypeParameters().isEmpty());\n        assertTrue(recordDeclaration.getFullyQualifiedName().isPresent());\n        assertEquals(\"Point\", recordDeclaration.getFullyQualifiedName().get());\n        assertTrue(recordDeclaration.isRecordDeclaration());\n\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"x\", parameter0.getNameAsString());\n        assertEquals(\"int\", parameter0.getTypeAsString());\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"y\", parameter1.getNameAsString());\n        assertEquals(\"int\", parameter1.getTypeAsString());\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Description\n     */\n    @Test\n    void basicRecordPrints() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        String expected = \"\" +\n                \"record Point(int x, int y) {\\n\" +\n                \"}\\n\" +\n                \"\";\n        assertEqualsStringIgnoringEol(expected, cu.toString());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-record\n     */\n    @Test\n    void record_cannotExtend() {\n        String s = \"record Point(int x, int y) extends OtherThing { }\";\n        assertCompilationFails(s);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_cannotBeAbstract() {\n        String s = \"abstract record Point(int x, int y) { }\";\n        assertCompilationFails(s);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_mayImplementInterfaces() {\n        String s = \"record Point(int x, int y) implements OtherInterface { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void recordWithVarArgs() {\n        String s = \"record R(T1 c1, Tn... cn){ }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"c1\", parameter0.getNameAsString());\n        assertEquals(\"T1\", parameter0.getTypeAsString());\n        assertFalse(parameter0.isVarArgs());\n\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"cn\", parameter1.getNameAsString());\n        assertEquals(\"Tn\", parameter1.getTypeAsString());\n        assertTrue(parameter1.isVarArgs());\n    }\n\n    @Test\n    void recordWithAnnotationedParameters() {\n        String s = \"record Card(@MyAnno Rank rank, @MyAnno Suit suit) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"rank\", parameter0.getNameAsString());\n        assertEquals(\"Rank\", parameter0.getTypeAsString());\n        assertEquals(1, parameter0.getAnnotations().size());\n\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"suit\", parameter1.getNameAsString());\n        assertEquals(\"Suit\", parameter1.getTypeAsString());\n        assertEquals(1, parameter1.getAnnotations().size());\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    @Test\n    void record_emptyMembers() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    @Test\n    void record_permitStaticFields() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    static int z;\\n\" +\n                \"\\n\" +\n                \"    static {\\n\" +\n                \"        int z = 10;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_permitMethods() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    public String xyz() {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_mustNotAllowNonStaticFields() {\n        String s = \"record Point(int x, int y) { int z; }\";\n        assertCompilationFails(s);\n    }\n\n    @Test\n    void record_mustAllowStaticFields() {\n        String s = \"record Point(int x, int y) { static int z; }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n\n    @Test\n    void record_mustNotAllowMismatchedComponentAccessorReturnType() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public String x() {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \" }\";\n        assertCompilationFails(s);\n    }\n\n    @Test\n    void record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public String x(int a) {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod2() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public int x(int a) {\\n\" +\n                \"        return 10;\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_allowComponentAccessorWithMatchingType() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return 10;\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    // https://bugs.openjdk.java.net/browse/JDK-8222777\n    @Test\n    void recordDeclarationFromTheJDK8222777() {\n        CompilationUnit cu = parseCompilationUnit(\"\" +\n                \"public record Range(int lo, int hi) {\\n\" +\n                \"\\n\" +\n                \"  public Range {\\n\" +\n                \"    if (lo > hi)  /* referring here to the implicit constructor parameters */\\n\" +\n                \"      throw new IllegalArgumentException(String.format(\\\"(%d,%d)\\\", lo, hi));\\n\" +\n                \"  }\\n\" +\n                \"}\"\n        );\n\n        RecordDeclaration record = cu.findFirst(RecordDeclaration.class).get();\n        assertThat(record.getNameAsString()).isEqualTo(\"Range\");\n        assertThat(record.getModifiers()).containsExactly(Modifier.publicModifier());\n        // test parameters\n        // get constructor\n        // test parameters (none)\n    }\n\n\n    private void assertCompilationFails(String s) {\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n    }\n\n    private void assertOneRecordDeclaration(CompilationUnit cu) {\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n}\n",
        "diffSourceCodeSet": [
            "private void assertCompilationFails(String s) {\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n    }"
        ],
        "invokedMethodSet": [],
        "sourceCodeAfterRefactoring": "/**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-record\n     */\n    @Test\n    void record_cannotExtend() {\n        String s = \"record Point(int x, int y) extends OtherThing { }\";\n        assertCompilationFails(s);\n    }\nprivate void assertCompilationFails(String s) {\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n    }",
        "diffSourceCode": "-   95:     /**\n-   96:      * https://openjdk.java.net/jeps/395#Restrictions-on-record\n-   97:      */\n-   98:     @Test\n-   99:     void record_cannotExtend() {\n-  100:         String s = \"record Point(int x, int y) extends OtherThing { }\";\n-  101:         assertThrows(AssertionFailedError.class, () -> {\n-  102:             CompilationUnit cu = parseCompilationUnit(s);\n-  103:         });\n-  104:     }\n-  307:         // test parameters (none)\n-  308:     }\n-  309: }\n+   95: \n+   96:     /**\n+   97:      * https://openjdk.java.net/jeps/395#Restrictions-on-record\n+   98:      */\n+   99:     @Test\n+  100:     void record_cannotExtend() {\n+  101:         String s = \"record Point(int x, int y) extends OtherThing { }\";\n+  102:         assertCompilationFails(s);\n+  103:     }\n+  104: \n+  307:     private void assertCompilationFails(String s) {\n+  308:         assertThrows(AssertionFailedError.class, () -> {\n+  309:             CompilationUnit cu = parseCompilationUnit(s);\n+  310:         });\n+  311:     }\n",
        "uniqueId": "a73aba7b8cef7c52666d25169a3f6e495c65bcd2_95_104_307_311_96_103",
        "moveFileExist": true,
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 1.8,
        "testResult": true,
        "coverageInfo": {
            "testMethod": {
                "missed": 0,
                "covered": 1
            }
        }
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprivate assertOneRecordDeclaration(cu CompilationUnit) : void extracted from package basicGrammar() : void in class com.github.javaparser.ast.body.RecordDeclarationTest",
        "diffLocations": [
            {
                "filePath": "javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/RecordDeclarationTest.java",
                "startLine": 50,
                "endLine": 78,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/RecordDeclarationTest.java",
                "startLine": 49,
                "endLine": 78,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/RecordDeclarationTest.java",
                "startLine": 313,
                "endLine": 316,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "@Test\n    void basicGrammar() {\n        /* https://openjdk.java.net/jeps/395#Description */\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        assertTrue(recordDeclaration.isRecordDeclaration());\n        assertTrue(recordDeclaration.getImplementedTypes().isEmpty());\n        assertTrue(recordDeclaration.getTypeParameters().isEmpty());\n        assertTrue(recordDeclaration.getFullyQualifiedName().isPresent());\n        assertEquals(\"Point\", recordDeclaration.getFullyQualifiedName().get());\n        assertTrue(recordDeclaration.isRecordDeclaration());\n\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"x\", parameter0.getNameAsString());\n        assertEquals(\"int\", parameter0.getTypeAsString());\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"y\", parameter1.getNameAsString());\n        assertEquals(\"int\", parameter1.getTypeAsString());\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }",
        "filePathBefore": "javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/RecordDeclarationTest.java",
        "isPureRefactoring": true,
        "commitId": "a73aba7b8cef7c52666d25169a3f6e495c65bcd2",
        "packageNameBefore": "com.github.javaparser.ast.body",
        "classNameBefore": "com.github.javaparser.ast.body.RecordDeclarationTest",
        "methodNameBefore": "com.github.javaparser.ast.body.RecordDeclarationTest#basicGrammar",
        "classSignatureBefore": "public class RecordDeclarationTest ",
        "methodNameBeforeSet": [
            "com.github.javaparser.ast.body.RecordDeclarationTest#basicGrammar"
        ],
        "classNameBeforeSet": [
            "com.github.javaparser.ast.body.RecordDeclarationTest"
        ],
        "classSignatureBeforeSet": [
            "public class RecordDeclarationTest "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "package com.github.javaparser.ast.body;\n\nimport com.github.javaparser.ParserConfiguration;\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.Modifier;\nimport com.github.javaparser.ast.NodeList;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.EnumSource;\nimport org.opentest4j.AssertionFailedError;\n\nimport java.util.List;\n\nimport static com.github.javaparser.utils.TestParser.parseCompilationUnit;\nimport static com.github.javaparser.utils.TestUtils.assertEqualsStringIgnoringEol;\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\npublic class RecordDeclarationTest {\n\n    @ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_13\", \"JAVA_13_PREVIEW\", \"JAVA_14\", \"JAVA_15\"})\n    void basicGrammarCompiles_languageLevelValidation_forbidden(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"record Point(int x, int y) { }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(languageLevel, s);\n        });\n    }\n\n    @ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_14_PREVIEW\", \"JAVA_15_PREVIEW\", \"JAVA_16\", \"JAVA_16_PREVIEW\"})\n    void basicGrammarCompiles_languageLevelValidation_permitted(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(languageLevel, s);\n    }\n\n    @Test\n    void basicGrammarCompiles() {\n        /* https://openjdk.java.net/jeps/395#Description */\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    @Test\n    void basicGrammar() {\n        /* https://openjdk.java.net/jeps/395#Description */\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        assertTrue(recordDeclaration.isRecordDeclaration());\n        assertTrue(recordDeclaration.getImplementedTypes().isEmpty());\n        assertTrue(recordDeclaration.getTypeParameters().isEmpty());\n        assertTrue(recordDeclaration.getFullyQualifiedName().isPresent());\n        assertEquals(\"Point\", recordDeclaration.getFullyQualifiedName().get());\n        assertTrue(recordDeclaration.isRecordDeclaration());\n\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"x\", parameter0.getNameAsString());\n        assertEquals(\"int\", parameter0.getTypeAsString());\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"y\", parameter1.getNameAsString());\n        assertEquals(\"int\", parameter1.getTypeAsString());\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Description\n     */\n    @Test\n    void basicRecordPrints() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        String expected = \"\" +\n                \"record Point(int x, int y) {\\n\" +\n                \"}\\n\" +\n                \"\";\n        assertEqualsStringIgnoringEol(expected, cu.toString());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-record\n     */\n    @Test\n    void record_cannotExtend() {\n        String s = \"record Point(int x, int y) extends OtherThing { }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_cannotBeAbstract() {\n        String s = \"abstract record Point(int x, int y) { }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n    }\n\n    @Test\n    void recordWithVarArgs() {\n        String s = \"record R(T1 c1, Tn... cn){ }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"c1\", parameter0.getNameAsString());\n        assertEquals(\"T1\", parameter0.getTypeAsString());\n        assertFalse(parameter0.isVarArgs());\n\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"cn\", parameter1.getNameAsString());\n        assertEquals(\"Tn\", parameter1.getTypeAsString());\n        assertTrue(parameter1.isVarArgs());\n    }\n\n    @Test\n    void recordWithAnnotationedParameters() {\n        String s = \"record Card(@MyAnno Rank rank, @MyAnno Suit suit) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"rank\", parameter0.getNameAsString());\n        assertEquals(\"Rank\", parameter0.getTypeAsString());\n        assertEquals(1, parameter0.getAnnotations().size());\n\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"suit\", parameter1.getNameAsString());\n        assertEquals(\"Suit\", parameter1.getTypeAsString());\n        assertEquals(1, parameter1.getAnnotations().size());\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    @Test\n    void record_emptyMembers() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    @Test\n    void record_permitStaticFields() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    static int z;\\n\" +\n                \"\\n\" +\n                \"    static {\\n\" +\n                \"        int z = 10;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    @Test\n    void record_permitMethods() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    public String xyz() {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    @Test\n    void record_mustNotAllowNonStaticFields() {\n        String s = \"record Point(int x, int y) { int z; }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n    }\n\n    @Test\n    void record_mustAllowStaticFields() {\n        String s = \"record Point(int x, int y) { static int z; }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n\n    @Test\n    void record_mustNotAllowMismatchedComponentAccessorReturnType() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public String x() {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n\n    }\n\n    @Test\n    void record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public String x(int a) {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    @Test\n    void record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod2() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public int x(int a) {\\n\" +\n                \"        return 10;\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n\n    @Test\n    void record_allowComponentAccessorWithMatchingType() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return 10;\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    // https://bugs.openjdk.java.net/browse/JDK-8222777\n    @Test\n    void recordDeclarationFromTheJDK8222777() {\n        CompilationUnit cu = parseCompilationUnit(\"\" +\n                \"public record Range(int lo, int hi) {\\n\" +\n                \"\\n\" +\n                \"  public Range {\\n\" +\n                \"    if (lo > hi)  /* referring here to the implicit constructor parameters */\\n\" +\n                \"      throw new IllegalArgumentException(String.format(\\\"(%d,%d)\\\", lo, hi));\\n\" +\n                \"  }\\n\" +\n                \"}\"\n        );\n\n        RecordDeclaration record = cu.findFirst(RecordDeclaration.class).get();\n        assertThat(record.getNameAsString()).isEqualTo(\"Range\");\n        assertThat(record.getModifiers()).containsExactly(Modifier.publicModifier());\n        // test parameters\n        // get constructor\n        // test parameters (none)\n    }\n}\n",
        "filePathAfter": "javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/RecordDeclarationTest.java",
        "sourceCodeAfterForWhole": "package com.github.javaparser.ast.body;\n\nimport com.github.javaparser.ParserConfiguration;\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.Modifier;\nimport com.github.javaparser.ast.NodeList;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.EnumSource;\nimport org.opentest4j.AssertionFailedError;\n\nimport java.util.List;\n\nimport static com.github.javaparser.utils.TestParser.parseCompilationUnit;\nimport static com.github.javaparser.utils.TestUtils.assertEqualsStringIgnoringEol;\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\npublic class RecordDeclarationTest {\n\n    @ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_13\", \"JAVA_13_PREVIEW\", \"JAVA_14\", \"JAVA_15\"})\n    void basicGrammarCompiles_languageLevelValidation_forbidden(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"record Point(int x, int y) { }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(languageLevel, s);\n        });\n    }\n\n    @ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_14_PREVIEW\", \"JAVA_15_PREVIEW\", \"JAVA_16\", \"JAVA_16_PREVIEW\"})\n    void basicGrammarCompiles_languageLevelValidation_permitted(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(languageLevel, s);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Description\n     */\n    @Test\n    void basicGrammarCompiles() {\n        String s = \"record Point(int x, int y) { }\";\n        assertOneRecordDeclaration(parseCompilationUnit(s));\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Description\n     */\n    @Test\n    void basicGrammar() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        RecordDeclaration recordDeclaration = cu.findAll(RecordDeclaration.class).get(0);\n\n        assertTrue(recordDeclaration.isRecordDeclaration());\n        assertTrue(recordDeclaration.getImplementedTypes().isEmpty());\n        assertTrue(recordDeclaration.getTypeParameters().isEmpty());\n        assertTrue(recordDeclaration.getFullyQualifiedName().isPresent());\n        assertEquals(\"Point\", recordDeclaration.getFullyQualifiedName().get());\n        assertTrue(recordDeclaration.isRecordDeclaration());\n\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"x\", parameter0.getNameAsString());\n        assertEquals(\"int\", parameter0.getTypeAsString());\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"y\", parameter1.getNameAsString());\n        assertEquals(\"int\", parameter1.getTypeAsString());\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Description\n     */\n    @Test\n    void basicRecordPrints() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        String expected = \"\" +\n                \"record Point(int x, int y) {\\n\" +\n                \"}\\n\" +\n                \"\";\n        assertEqualsStringIgnoringEol(expected, cu.toString());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-record\n     */\n    @Test\n    void record_cannotExtend() {\n        String s = \"record Point(int x, int y) extends OtherThing { }\";\n        assertCompilationFails(s);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_cannotBeAbstract() {\n        String s = \"abstract record Point(int x, int y) { }\";\n        assertCompilationFails(s);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_mayImplementInterfaces() {\n        String s = \"record Point(int x, int y) implements OtherInterface { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void recordWithVarArgs() {\n        String s = \"record R(T1 c1, Tn... cn){ }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"c1\", parameter0.getNameAsString());\n        assertEquals(\"T1\", parameter0.getTypeAsString());\n        assertFalse(parameter0.isVarArgs());\n\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"cn\", parameter1.getNameAsString());\n        assertEquals(\"Tn\", parameter1.getTypeAsString());\n        assertTrue(parameter1.isVarArgs());\n    }\n\n    @Test\n    void recordWithAnnotationedParameters() {\n        String s = \"record Card(@MyAnno Rank rank, @MyAnno Suit suit) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"rank\", parameter0.getNameAsString());\n        assertEquals(\"Rank\", parameter0.getTypeAsString());\n        assertEquals(1, parameter0.getAnnotations().size());\n\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"suit\", parameter1.getNameAsString());\n        assertEquals(\"Suit\", parameter1.getTypeAsString());\n        assertEquals(1, parameter1.getAnnotations().size());\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    @Test\n    void record_emptyMembers() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    @Test\n    void record_permitStaticFields() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    static int z;\\n\" +\n                \"\\n\" +\n                \"    static {\\n\" +\n                \"        int z = 10;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_permitMethods() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    public String xyz() {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_mustNotAllowNonStaticFields() {\n        String s = \"record Point(int x, int y) { int z; }\";\n        assertCompilationFails(s);\n    }\n\n    @Test\n    void record_mustAllowStaticFields() {\n        String s = \"record Point(int x, int y) { static int z; }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n\n    @Test\n    void record_mustNotAllowMismatchedComponentAccessorReturnType() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public String x() {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \" }\";\n        assertCompilationFails(s);\n    }\n\n    @Test\n    void record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public String x(int a) {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod2() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public int x(int a) {\\n\" +\n                \"        return 10;\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_allowComponentAccessorWithMatchingType() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return 10;\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    // https://bugs.openjdk.java.net/browse/JDK-8222777\n    @Test\n    void recordDeclarationFromTheJDK8222777() {\n        CompilationUnit cu = parseCompilationUnit(\"\" +\n                \"public record Range(int lo, int hi) {\\n\" +\n                \"\\n\" +\n                \"  public Range {\\n\" +\n                \"    if (lo > hi)  /* referring here to the implicit constructor parameters */\\n\" +\n                \"      throw new IllegalArgumentException(String.format(\\\"(%d,%d)\\\", lo, hi));\\n\" +\n                \"  }\\n\" +\n                \"}\"\n        );\n\n        RecordDeclaration record = cu.findFirst(RecordDeclaration.class).get();\n        assertThat(record.getNameAsString()).isEqualTo(\"Range\");\n        assertThat(record.getModifiers()).containsExactly(Modifier.publicModifier());\n        // test parameters\n        // get constructor\n        // test parameters (none)\n    }\n\n\n    private void assertCompilationFails(String s) {\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n    }\n\n    private void assertOneRecordDeclaration(CompilationUnit cu) {\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n}\n",
        "diffSourceCodeSet": [
            "private void assertOneRecordDeclaration(CompilationUnit cu) {\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }"
        ],
        "invokedMethodSet": [],
        "sourceCodeAfterRefactoring": "/**\n     * https://openjdk.java.net/jeps/395#Description\n     */\n    @Test\n    void basicGrammar() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        RecordDeclaration recordDeclaration = cu.findAll(RecordDeclaration.class).get(0);\n\n        assertTrue(recordDeclaration.isRecordDeclaration());\n        assertTrue(recordDeclaration.getImplementedTypes().isEmpty());\n        assertTrue(recordDeclaration.getTypeParameters().isEmpty());\n        assertTrue(recordDeclaration.getFullyQualifiedName().isPresent());\n        assertEquals(\"Point\", recordDeclaration.getFullyQualifiedName().get());\n        assertTrue(recordDeclaration.isRecordDeclaration());\n\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"x\", parameter0.getNameAsString());\n        assertEquals(\"int\", parameter0.getTypeAsString());\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"y\", parameter1.getNameAsString());\n        assertEquals(\"int\", parameter1.getTypeAsString());\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\nprivate void assertOneRecordDeclaration(CompilationUnit cu) {\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }",
        "diffSourceCode": "-   49: \n-   50:     @Test\n-   51:     void basicGrammar() {\n-   52:         /* https://openjdk.java.net/jeps/395#Description */\n-   53:         String s = \"record Point(int x, int y) { }\";\n-   54:         CompilationUnit cu = parseCompilationUnit(s);\n-   55: \n-   56:         List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n-   57:         assertEquals(1, recordDeclarations.size());\n-   58: \n-   59:         RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n+   49:     /**\n+   50:      * https://openjdk.java.net/jeps/395#Description\n+   51:      */\n+   52:     @Test\n+   53:     void basicGrammar() {\n+   54:         String s = \"record Point(int x, int y) { }\";\n+   55:         CompilationUnit cu = parseCompilationUnit(s);\n+   56:         assertOneRecordDeclaration(cu);\n+   57: \n+   58:         RecordDeclaration recordDeclaration = cu.findAll(RecordDeclaration.class).get(0);\n+   59: \n    60:         assertTrue(recordDeclaration.isRecordDeclaration());\n    61:         assertTrue(recordDeclaration.getImplementedTypes().isEmpty());\n    62:         assertTrue(recordDeclaration.getTypeParameters().isEmpty());\n    63:         assertTrue(recordDeclaration.getFullyQualifiedName().isPresent());\n    64:         assertEquals(\"Point\", recordDeclaration.getFullyQualifiedName().get());\n    65:         assertTrue(recordDeclaration.isRecordDeclaration());\n    66: \n    67:         NodeList<Parameter> parameters = recordDeclaration.getParameters();\n    68:         assertEquals(2, parameters.size());\n    69: \n    70:         Parameter parameter0 = parameters.get(0);\n    71:         assertEquals(\"x\", parameter0.getNameAsString());\n    72:         assertEquals(\"int\", parameter0.getTypeAsString());\n    73:         Parameter parameter1 = parameters.get(1);\n    74:         assertEquals(\"y\", parameter1.getNameAsString());\n    75:         assertEquals(\"int\", parameter1.getTypeAsString());\n    76: \n    77:         assertEquals(0, recordDeclaration.getMembers().size());\n    78:     }\n+  313:     private void assertOneRecordDeclaration(CompilationUnit cu) {\n+  314:         List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n+  315:         assertEquals(1, recordDeclarations.size());\n+  316:     }\n",
        "uniqueId": "a73aba7b8cef7c52666d25169a3f6e495c65bcd2_50_78_313_316_49_78",
        "moveFileExist": true,
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 1.8,
        "testResult": true,
        "coverageInfo": {
            "testMethod": {
                "missed": 0,
                "covered": 1
            }
        }
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprivate assertOneRecordDeclaration(cu CompilationUnit) : void extracted from package basicGrammarCompiles() : void in class com.github.javaparser.ast.body.RecordDeclarationTest",
        "diffLocations": [
            {
                "filePath": "javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/RecordDeclarationTest.java",
                "startLine": 40,
                "endLine": 48,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/RecordDeclarationTest.java",
                "startLine": 40,
                "endLine": 47,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/RecordDeclarationTest.java",
                "startLine": 313,
                "endLine": 316,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "@Test\n    void basicGrammarCompiles() {\n        /* https://openjdk.java.net/jeps/395#Description */\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }",
        "filePathBefore": "javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/RecordDeclarationTest.java",
        "isPureRefactoring": true,
        "commitId": "a73aba7b8cef7c52666d25169a3f6e495c65bcd2",
        "packageNameBefore": "com.github.javaparser.ast.body",
        "classNameBefore": "com.github.javaparser.ast.body.RecordDeclarationTest",
        "methodNameBefore": "com.github.javaparser.ast.body.RecordDeclarationTest#basicGrammarCompiles",
        "classSignatureBefore": "public class RecordDeclarationTest ",
        "methodNameBeforeSet": [
            "com.github.javaparser.ast.body.RecordDeclarationTest#basicGrammarCompiles"
        ],
        "classNameBeforeSet": [
            "com.github.javaparser.ast.body.RecordDeclarationTest"
        ],
        "classSignatureBeforeSet": [
            "public class RecordDeclarationTest "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "package com.github.javaparser.ast.body;\n\nimport com.github.javaparser.ParserConfiguration;\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.Modifier;\nimport com.github.javaparser.ast.NodeList;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.EnumSource;\nimport org.opentest4j.AssertionFailedError;\n\nimport java.util.List;\n\nimport static com.github.javaparser.utils.TestParser.parseCompilationUnit;\nimport static com.github.javaparser.utils.TestUtils.assertEqualsStringIgnoringEol;\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\npublic class RecordDeclarationTest {\n\n    @ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_13\", \"JAVA_13_PREVIEW\", \"JAVA_14\", \"JAVA_15\"})\n    void basicGrammarCompiles_languageLevelValidation_forbidden(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"record Point(int x, int y) { }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(languageLevel, s);\n        });\n    }\n\n    @ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_14_PREVIEW\", \"JAVA_15_PREVIEW\", \"JAVA_16\", \"JAVA_16_PREVIEW\"})\n    void basicGrammarCompiles_languageLevelValidation_permitted(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(languageLevel, s);\n    }\n\n    @Test\n    void basicGrammarCompiles() {\n        /* https://openjdk.java.net/jeps/395#Description */\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    @Test\n    void basicGrammar() {\n        /* https://openjdk.java.net/jeps/395#Description */\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        assertTrue(recordDeclaration.isRecordDeclaration());\n        assertTrue(recordDeclaration.getImplementedTypes().isEmpty());\n        assertTrue(recordDeclaration.getTypeParameters().isEmpty());\n        assertTrue(recordDeclaration.getFullyQualifiedName().isPresent());\n        assertEquals(\"Point\", recordDeclaration.getFullyQualifiedName().get());\n        assertTrue(recordDeclaration.isRecordDeclaration());\n\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"x\", parameter0.getNameAsString());\n        assertEquals(\"int\", parameter0.getTypeAsString());\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"y\", parameter1.getNameAsString());\n        assertEquals(\"int\", parameter1.getTypeAsString());\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Description\n     */\n    @Test\n    void basicRecordPrints() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        String expected = \"\" +\n                \"record Point(int x, int y) {\\n\" +\n                \"}\\n\" +\n                \"\";\n        assertEqualsStringIgnoringEol(expected, cu.toString());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-record\n     */\n    @Test\n    void record_cannotExtend() {\n        String s = \"record Point(int x, int y) extends OtherThing { }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_cannotBeAbstract() {\n        String s = \"abstract record Point(int x, int y) { }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n    }\n\n    @Test\n    void recordWithVarArgs() {\n        String s = \"record R(T1 c1, Tn... cn){ }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"c1\", parameter0.getNameAsString());\n        assertEquals(\"T1\", parameter0.getTypeAsString());\n        assertFalse(parameter0.isVarArgs());\n\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"cn\", parameter1.getNameAsString());\n        assertEquals(\"Tn\", parameter1.getTypeAsString());\n        assertTrue(parameter1.isVarArgs());\n    }\n\n    @Test\n    void recordWithAnnotationedParameters() {\n        String s = \"record Card(@MyAnno Rank rank, @MyAnno Suit suit) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"rank\", parameter0.getNameAsString());\n        assertEquals(\"Rank\", parameter0.getTypeAsString());\n        assertEquals(1, parameter0.getAnnotations().size());\n\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"suit\", parameter1.getNameAsString());\n        assertEquals(\"Suit\", parameter1.getTypeAsString());\n        assertEquals(1, parameter1.getAnnotations().size());\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    @Test\n    void record_emptyMembers() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    @Test\n    void record_permitStaticFields() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    static int z;\\n\" +\n                \"\\n\" +\n                \"    static {\\n\" +\n                \"        int z = 10;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    @Test\n    void record_permitMethods() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    public String xyz() {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    @Test\n    void record_mustNotAllowNonStaticFields() {\n        String s = \"record Point(int x, int y) { int z; }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n    }\n\n    @Test\n    void record_mustAllowStaticFields() {\n        String s = \"record Point(int x, int y) { static int z; }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n\n    @Test\n    void record_mustNotAllowMismatchedComponentAccessorReturnType() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public String x() {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n\n    }\n\n    @Test\n    void record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public String x(int a) {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    @Test\n    void record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod2() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public int x(int a) {\\n\" +\n                \"        return 10;\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n\n    @Test\n    void record_allowComponentAccessorWithMatchingType() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return 10;\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    // https://bugs.openjdk.java.net/browse/JDK-8222777\n    @Test\n    void recordDeclarationFromTheJDK8222777() {\n        CompilationUnit cu = parseCompilationUnit(\"\" +\n                \"public record Range(int lo, int hi) {\\n\" +\n                \"\\n\" +\n                \"  public Range {\\n\" +\n                \"    if (lo > hi)  /* referring here to the implicit constructor parameters */\\n\" +\n                \"      throw new IllegalArgumentException(String.format(\\\"(%d,%d)\\\", lo, hi));\\n\" +\n                \"  }\\n\" +\n                \"}\"\n        );\n\n        RecordDeclaration record = cu.findFirst(RecordDeclaration.class).get();\n        assertThat(record.getNameAsString()).isEqualTo(\"Range\");\n        assertThat(record.getModifiers()).containsExactly(Modifier.publicModifier());\n        // test parameters\n        // get constructor\n        // test parameters (none)\n    }\n}\n",
        "filePathAfter": "javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/RecordDeclarationTest.java",
        "sourceCodeAfterForWhole": "package com.github.javaparser.ast.body;\n\nimport com.github.javaparser.ParserConfiguration;\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.Modifier;\nimport com.github.javaparser.ast.NodeList;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.EnumSource;\nimport org.opentest4j.AssertionFailedError;\n\nimport java.util.List;\n\nimport static com.github.javaparser.utils.TestParser.parseCompilationUnit;\nimport static com.github.javaparser.utils.TestUtils.assertEqualsStringIgnoringEol;\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\npublic class RecordDeclarationTest {\n\n    @ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_13\", \"JAVA_13_PREVIEW\", \"JAVA_14\", \"JAVA_15\"})\n    void basicGrammarCompiles_languageLevelValidation_forbidden(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"record Point(int x, int y) { }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(languageLevel, s);\n        });\n    }\n\n    @ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_14_PREVIEW\", \"JAVA_15_PREVIEW\", \"JAVA_16\", \"JAVA_16_PREVIEW\"})\n    void basicGrammarCompiles_languageLevelValidation_permitted(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(languageLevel, s);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Description\n     */\n    @Test\n    void basicGrammarCompiles() {\n        String s = \"record Point(int x, int y) { }\";\n        assertOneRecordDeclaration(parseCompilationUnit(s));\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Description\n     */\n    @Test\n    void basicGrammar() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        RecordDeclaration recordDeclaration = cu.findAll(RecordDeclaration.class).get(0);\n\n        assertTrue(recordDeclaration.isRecordDeclaration());\n        assertTrue(recordDeclaration.getImplementedTypes().isEmpty());\n        assertTrue(recordDeclaration.getTypeParameters().isEmpty());\n        assertTrue(recordDeclaration.getFullyQualifiedName().isPresent());\n        assertEquals(\"Point\", recordDeclaration.getFullyQualifiedName().get());\n        assertTrue(recordDeclaration.isRecordDeclaration());\n\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"x\", parameter0.getNameAsString());\n        assertEquals(\"int\", parameter0.getTypeAsString());\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"y\", parameter1.getNameAsString());\n        assertEquals(\"int\", parameter1.getTypeAsString());\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Description\n     */\n    @Test\n    void basicRecordPrints() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        String expected = \"\" +\n                \"record Point(int x, int y) {\\n\" +\n                \"}\\n\" +\n                \"\";\n        assertEqualsStringIgnoringEol(expected, cu.toString());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-record\n     */\n    @Test\n    void record_cannotExtend() {\n        String s = \"record Point(int x, int y) extends OtherThing { }\";\n        assertCompilationFails(s);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_cannotBeAbstract() {\n        String s = \"abstract record Point(int x, int y) { }\";\n        assertCompilationFails(s);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_mayImplementInterfaces() {\n        String s = \"record Point(int x, int y) implements OtherInterface { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void recordWithVarArgs() {\n        String s = \"record R(T1 c1, Tn... cn){ }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"c1\", parameter0.getNameAsString());\n        assertEquals(\"T1\", parameter0.getTypeAsString());\n        assertFalse(parameter0.isVarArgs());\n\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"cn\", parameter1.getNameAsString());\n        assertEquals(\"Tn\", parameter1.getTypeAsString());\n        assertTrue(parameter1.isVarArgs());\n    }\n\n    @Test\n    void recordWithAnnotationedParameters() {\n        String s = \"record Card(@MyAnno Rank rank, @MyAnno Suit suit) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"rank\", parameter0.getNameAsString());\n        assertEquals(\"Rank\", parameter0.getTypeAsString());\n        assertEquals(1, parameter0.getAnnotations().size());\n\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"suit\", parameter1.getNameAsString());\n        assertEquals(\"Suit\", parameter1.getTypeAsString());\n        assertEquals(1, parameter1.getAnnotations().size());\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    @Test\n    void record_emptyMembers() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    @Test\n    void record_permitStaticFields() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    static int z;\\n\" +\n                \"\\n\" +\n                \"    static {\\n\" +\n                \"        int z = 10;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_permitMethods() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    public String xyz() {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_mustNotAllowNonStaticFields() {\n        String s = \"record Point(int x, int y) { int z; }\";\n        assertCompilationFails(s);\n    }\n\n    @Test\n    void record_mustAllowStaticFields() {\n        String s = \"record Point(int x, int y) { static int z; }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n\n    @Test\n    void record_mustNotAllowMismatchedComponentAccessorReturnType() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public String x() {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \" }\";\n        assertCompilationFails(s);\n    }\n\n    @Test\n    void record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public String x(int a) {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod2() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public int x(int a) {\\n\" +\n                \"        return 10;\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_allowComponentAccessorWithMatchingType() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return 10;\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    // https://bugs.openjdk.java.net/browse/JDK-8222777\n    @Test\n    void recordDeclarationFromTheJDK8222777() {\n        CompilationUnit cu = parseCompilationUnit(\"\" +\n                \"public record Range(int lo, int hi) {\\n\" +\n                \"\\n\" +\n                \"  public Range {\\n\" +\n                \"    if (lo > hi)  /* referring here to the implicit constructor parameters */\\n\" +\n                \"      throw new IllegalArgumentException(String.format(\\\"(%d,%d)\\\", lo, hi));\\n\" +\n                \"  }\\n\" +\n                \"}\"\n        );\n\n        RecordDeclaration record = cu.findFirst(RecordDeclaration.class).get();\n        assertThat(record.getNameAsString()).isEqualTo(\"Range\");\n        assertThat(record.getModifiers()).containsExactly(Modifier.publicModifier());\n        // test parameters\n        // get constructor\n        // test parameters (none)\n    }\n\n\n    private void assertCompilationFails(String s) {\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n    }\n\n    private void assertOneRecordDeclaration(CompilationUnit cu) {\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n}\n",
        "diffSourceCodeSet": [
            "private void assertOneRecordDeclaration(CompilationUnit cu) {\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }"
        ],
        "invokedMethodSet": [],
        "sourceCodeAfterRefactoring": "/**\n     * https://openjdk.java.net/jeps/395#Description\n     */\n    @Test\n    void basicGrammarCompiles() {\n        String s = \"record Point(int x, int y) { }\";\n        assertOneRecordDeclaration(parseCompilationUnit(s));\n    }\nprivate void assertOneRecordDeclaration(CompilationUnit cu) {\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }",
        "diffSourceCode": "-   40:     @Test\n-   41:     void basicGrammarCompiles() {\n-   42:         /* https://openjdk.java.net/jeps/395#Description */\n-   43:         String s = \"record Point(int x, int y) { }\";\n-   44:         CompilationUnit cu = parseCompilationUnit(s);\n-   45: \n-   46:         List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n-   47:         assertEquals(1, recordDeclarations.size());\n-   48:     }\n+   40:     /**\n+   41:      * https://openjdk.java.net/jeps/395#Description\n+   42:      */\n+   43:     @Test\n+   44:     void basicGrammarCompiles() {\n+   45:         String s = \"record Point(int x, int y) { }\";\n+   46:         assertOneRecordDeclaration(parseCompilationUnit(s));\n+   47:     }\n+   48: \n+  313:     private void assertOneRecordDeclaration(CompilationUnit cu) {\n+  314:         List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n+  315:         assertEquals(1, recordDeclarations.size());\n+  316:     }\n",
        "uniqueId": "a73aba7b8cef7c52666d25169a3f6e495c65bcd2_40_48_313_316_40_47",
        "moveFileExist": true,
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 1.8,
        "testResult": true,
        "coverageInfo": {
            "testMethod": {
                "missed": 0,
                "covered": 1
            }
        }
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprotected createDefaultPrinter(configuration PrinterConfiguration) : Printer extracted from protected createDefaultPrinter() : Printer in class com.github.javaparser.ast.Node",
        "diffLocations": [
            {
                "filePath": "javaparser-core/src/main/java/com/github/javaparser/ast/Node.java",
                "startLine": 225,
                "endLine": 228,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "javaparser-core/src/main/java/com/github/javaparser/ast/Node.java",
                "startLine": 222,
                "endLine": 224,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "javaparser-core/src/main/java/com/github/javaparser/ast/Node.java",
                "startLine": 226,
                "endLine": 228,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "protected Printer createDefaultPrinter() {\n        PrinterConfiguration configuration = getDefaultPrinterConfiguration();\n        return new DefaultPrettyPrinter(configuration);\n    }",
        "filePathBefore": "javaparser-core/src/main/java/com/github/javaparser/ast/Node.java",
        "isPureRefactoring": true,
        "commitId": "9d8184e1a607dcfcd3733b8a40587459f2a583d1",
        "packageNameBefore": "com.github.javaparser.ast",
        "classNameBefore": "com.github.javaparser.ast.Node",
        "methodNameBefore": "com.github.javaparser.ast.Node#createDefaultPrinter",
        "invokedMethod": "methodSignature: com.github.javaparser.ast.Node#getDefaultPrinterConfiguration\n methodBody: protected  PrinterConfiguration getDefaultPrinterConfiguration() {\nreturn new DefaultPrinterConfiguration();\n}",
        "classSignatureBefore": "public abstract class Node implements Cloneable, HasParentNode<Node>, Visitable, NodeWithRange<Node>, NodeWithTokenRange<Node> ",
        "methodNameBeforeSet": [
            "com.github.javaparser.ast.Node#createDefaultPrinter"
        ],
        "classNameBeforeSet": [
            "com.github.javaparser.ast.Node"
        ],
        "classSignatureBeforeSet": [
            "public abstract class Node implements Cloneable, HasParentNode<Node>, Visitable, NodeWithRange<Node>, NodeWithTokenRange<Node> "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Copyright (C) 2007-2010 J\u00falio Vilmar Gesser.\n * Copyright (C) 2011, 2013-2020 The JavaParser Team.\n *\n * This file is part of JavaParser.\n *\n * JavaParser can be used either under the terms of\n * a) the GNU Lesser General Public License as published by\n *     the Free Software Foundation, either version 3 of the License, or\n *     (at your option) any later version.\n * b) the terms of the Apache License\n *\n * You should have received a copy of both licenses in LICENCE.LGPL and\n * LICENCE.APACHE. Please refer to those files for details.\n *\n * JavaParser is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n */\npackage com.github.javaparser.ast;\n\nimport static com.github.javaparser.ast.Node.Parsedness.PARSED;\nimport static com.github.javaparser.ast.Node.TreeTraversal.PREORDER;\nimport static java.util.Collections.emptySet;\nimport static java.util.Collections.unmodifiableList;\nimport static java.util.Spliterator.DISTINCT;\nimport static java.util.Spliterator.NONNULL;\n\nimport java.util.ArrayList;\nimport java.util.Comparator;\nimport java.util.HashSet;\nimport java.util.IdentityHashMap;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Optional;\nimport java.util.Queue;\nimport java.util.Set;\nimport java.util.Spliterators;\nimport java.util.Stack;\nimport java.util.function.Consumer;\nimport java.util.function.Function;\nimport java.util.function.Predicate;\nimport java.util.stream.Stream;\nimport java.util.stream.StreamSupport;\n\nimport com.github.javaparser.HasParentNode;\nimport com.github.javaparser.Position;\nimport com.github.javaparser.Range;\nimport com.github.javaparser.TokenRange;\nimport com.github.javaparser.ast.comments.BlockComment;\nimport com.github.javaparser.ast.comments.Comment;\nimport com.github.javaparser.ast.comments.LineComment;\nimport com.github.javaparser.ast.nodeTypes.NodeWithRange;\nimport com.github.javaparser.ast.nodeTypes.NodeWithTokenRange;\nimport com.github.javaparser.ast.observer.AstObserver;\nimport com.github.javaparser.ast.observer.ObservableProperty;\nimport com.github.javaparser.ast.observer.PropagatingAstObserver;\nimport com.github.javaparser.ast.visitor.CloneVisitor;\nimport com.github.javaparser.ast.visitor.EqualsVisitor;\nimport com.github.javaparser.ast.visitor.HashCodeVisitor;\nimport com.github.javaparser.ast.visitor.Visitable;\nimport com.github.javaparser.metamodel.InternalProperty;\nimport com.github.javaparser.metamodel.JavaParserMetaModel;\nimport com.github.javaparser.metamodel.NodeMetaModel;\nimport com.github.javaparser.metamodel.OptionalProperty;\nimport com.github.javaparser.metamodel.PropertyMetaModel;\nimport com.github.javaparser.printer.DefaultPrettyPrinter;\nimport com.github.javaparser.printer.Printer;\nimport com.github.javaparser.printer.configuration.PrinterConfiguration;\nimport com.github.javaparser.printer.configuration.DefaultPrinterConfiguration;\nimport com.github.javaparser.printer.configuration.DefaultPrinterConfiguration.ConfigOption;\nimport com.github.javaparser.resolution.SymbolResolver;\nimport com.github.javaparser.utils.LineSeparator;\n\n/**\n * Base class for all nodes of the abstract syntax tree.\n * <h2>Construction</h2>\n * <p>The tree is built by instantiating the required nodes, then adding them to other nodes.\n * If it is the parser who is building the tree, it will use the largest constructor,\n * the one with \"range\" as the first parameter.\n * If you want to manually instantiate nodes, we suggest to...\n * <ul>\n * <li>use a convenience method, like \"addStatement(...)\", or if none are available...</li>\n * <li>use a convenient constructor, like ClassOrInterfaceType(String name), or if none are available...</li>\n * <li>use the default constructor.</li>\n * <li>Alternatively, use one of the JavaParser.parse(snippet) methods.</li>\n * </ul>\n * ... and use the various methods on the node to initialize it further, if needed.\n * <h2>Parent/child</h2>\n * <p>The parent node field is managed automatically and can be seen as read only.\n * Note that there is only one parent,\n * and trying to use the same node in two places will lead to unexpected behaviour.\n * It is advised to clone() a node before moving it around.\n * <h2>Comments</h2>\n * <p>Each Node can have one associated comment which describes it and\n * a number of \"orphan comments\" which it contains but are not specifically\n * associated to any child.\n * <h2>Positions</h2>\n * <p>When the parser creates nodes, it sets their source code position in the \"range\" field.\n * When you manually instantiate nodes, their range is not set.\n * The top left character is position 1, 1.\n * Note that since this is an <i>abstract</i> syntax tree,\n * it leaves out a lot of text from the original source file,\n * like where braces or comma's are exactly.\n * Therefore there is no position information on everything in the original source file.\n * <h2>Observers</h2>\n * <p>It is possible to add observers to the the tree.\n * Any change in the tree is sent as an event to any observers watching.\n * <h2>Visitors</h2>\n * <p>The most comfortable way of working with an abstract syntax tree is using visitors.\n * You can use one of the visitors in the visitor package, or extend one of them.\n * A visitor can be \"run\" by calling accept on a node:\n * <pre>node.accept(visitor, argument);</pre>\n * where argument is an object of your choice (often simply null.)\n *\n * @author Julio Vilmar Gesser\n */\npublic abstract class Node implements Cloneable, HasParentNode<Node>, Visitable, NodeWithRange<Node>, NodeWithTokenRange<Node> {\n\n    /**\n     * Different registration mode for observers on nodes.\n     */\n    public enum ObserverRegistrationMode {\n\n        /**\n         * Notify exclusively for changes happening on this node alone.\n         */\n        JUST_THIS_NODE,\n        /**\n         * Notify for changes happening on this node and all its descendants existing at the moment in\n         * which the observer was registered. Nodes attached later will not be observed.\n         */\n        THIS_NODE_AND_EXISTING_DESCENDANTS,\n        /**\n         * Notify for changes happening on this node and all its descendants. The descendants existing at the moment in\n         * which the observer was registered will be observed immediately. As new nodes are attached later they are\n         * automatically registered to be observed.\n         */\n        SELF_PROPAGATING\n    }\n\n    public enum Parsedness {\n\n        PARSED, UNPARSABLE\n    }\n\n    /**\n     * This can be used to sort nodes on position.\n     */\n    public static Comparator<NodeWithRange<?>> NODE_BY_BEGIN_POSITION = (a, b) -> {\n        if (a.hasRange() && b.hasRange()) {\n            return a.getRange().get().begin.compareTo(b.getRange().get().begin);\n        }\n        if (a.hasRange() || b.hasRange()) {\n            if (a.hasRange()) {\n                return 1;\n            }\n            return -1;\n        }\n        return 0;\n    };\n\n    protected static final PrinterConfiguration prettyPrinterNoCommentsConfiguration = new DefaultPrinterConfiguration().removeOption(ConfigOption.PRINT_COMMENTS);\n    \n    @InternalProperty\n    private Range range;\n\n    @InternalProperty\n    private TokenRange tokenRange;\n\n    @InternalProperty\n    private Node parentNode;\n\n    @InternalProperty\n    private List<Node> childNodes = new LinkedList<>();\n\n    @InternalProperty\n    private List<Comment> orphanComments = new LinkedList<>();\n\n    @InternalProperty\n    private IdentityHashMap<DataKey<?>, Object> data = null;\n\n    @OptionalProperty\n    private Comment comment;\n\n    @InternalProperty\n    private Set<AstObserver> observers = new HashSet<>();\n\n    @InternalProperty\n    private Parsedness parsed = PARSED;\n\n    protected Node(TokenRange tokenRange) {\n        setTokenRange(tokenRange);\n    }\n\n    /**\n     * Called in every constructor for node specific code.\n     * It can't be written in the constructor itself because it will\n     * be overwritten during code generation.\n     */\n    protected void customInitialization() {\n    }\n    \n    /*\n     * If there is a printer defined in CompilationUnit, returns it\n     * else create a new DefaultPrettyPrinter with default parameters\n     */\n    protected Printer getPrinter() {\n        Optional<CompilationUnit> cu = findCompilationUnit();\n        if (!cu.isPresent()) {\n            return createDefaultPrinter();\n        }\n        return cu.get().getPrinter();\n    }\n    \n    /*\n     * Return the printer initialized with the specified configuration\n     */\n    protected Printer getPrinter(PrinterConfiguration configuration) {\n        return getPrinter().setConfiguration(configuration);\n    }\n    \n    protected Printer createDefaultPrinter() {\n        PrinterConfiguration configuration = getDefaultPrinterConfiguration();\n        return new DefaultPrettyPrinter(configuration);\n    }\n    \n    /*\n     * returns a default printer configuration\n     */\n    protected  PrinterConfiguration getDefaultPrinterConfiguration() {\n        return new DefaultPrinterConfiguration();\n    }\n\n    /**\n     * This is a comment associated with this node.\n     *\n     * @return comment property\n     */\n    @Generated(\"com.github.javaparser.generator.core.node.PropertyGenerator\")\n    public Optional<Comment> getComment() {\n        return Optional.ofNullable(comment);\n    }\n\n    /**\n     * @return the range of characters in the source code that this node covers.\n     */\n    public Optional<Range> getRange() {\n        return Optional.ofNullable(range);\n    }\n\n    /**\n     * @return the range of tokens that this node covers.\n     */\n    public Optional<TokenRange> getTokenRange() {\n        return Optional.ofNullable(tokenRange);\n    }\n\n    public Node setTokenRange(TokenRange tokenRange) {\n        this.tokenRange = tokenRange;\n        if (tokenRange == null || !(tokenRange.getBegin().hasRange() && tokenRange.getEnd().hasRange())) {\n            range = null;\n        } else {\n            range = new Range(tokenRange.getBegin().getRange().get().begin, tokenRange.getEnd().getRange().get().end);\n        }\n        return this;\n    }\n\n    /**\n     * @param range the range of characters in the source code that this node covers. null can be used to indicate that\n     *              no range information is known, or that it is not of interest.\n     */\n    public Node setRange(Range range) {\n        if (this.range == range) {\n            return this;\n        }\n        notifyPropertyChange(ObservableProperty.RANGE, this.range, range);\n        this.range = range;\n        return this;\n    }\n\n    /**\n     * Use this to store additional information to this node.\n     *\n     * @param comment to be set\n     */\n    public Node setComment(final Comment comment) {\n        if (this.comment == comment) {\n            return this;\n        }\n        notifyPropertyChange(ObservableProperty.COMMENT, this.comment, comment);\n        if (this.comment != null) {\n            this.comment.setCommentedNode(null);\n        }\n        this.comment = comment;\n        if (comment != null) {\n            this.comment.setCommentedNode(this);\n        }\n        return this;\n    }\n\n    /**\n     * Use this to store additional information to this node.\n     *\n     * @param comment to be set\n     */\n    public final Node setLineComment(String comment) {\n        return setComment(new LineComment(comment));\n    }\n\n    /**\n     * Use this to store additional information to this node.\n     *\n     * @param comment to be set\n     */\n    public final Node setBlockComment(String comment) {\n        return setComment(new BlockComment(comment));\n    }\n\n    /**\n     * @return pretty printed source code for this node and its children.\n     */\n    @Override\n    public final String toString() {\n        if (containsData(LINE_SEPARATOR_KEY)) {\n            LineSeparator lineSeparator = getLineEndingStyleOrDefault(LineSeparator.SYSTEM);\n            PrinterConfiguration config = getDefaultPrinterConfiguration();\n            config.addOption(ConfigOption.END_OF_LINE_CHARACTER.value(lineSeparator.asRawString()));\n            return getPrinter(config).print(this);\n        }\n        return getPrinter().print(this);\n    }\n\n    /**\n     * @return pretty printed source code for this node and its children.\n     * Formatting can be configured with parameter PrinterConfiguration.\n     */\n    public final String toString(PrinterConfiguration configuration) {\n        return getPrinter(configuration).print(this);\n    }\n\n    @Override\n    public final int hashCode() {\n        return HashCodeVisitor.hashCode(this);\n    }\n\n    @Override\n    public boolean equals(final Object obj) {\n        if (obj == null || !(obj instanceof Node)) {\n            return false;\n        }\n        return EqualsVisitor.equals(this, (Node) obj);\n    }\n\n    @Override\n    public Optional<Node> getParentNode() {\n        return Optional.ofNullable(parentNode);\n    }\n\n    /**\n     * Contains all nodes that have this node set as their parent.\n     * You can add and remove nodes from this list by adding or removing nodes from the fields of this node.\n     *\n     * @return all nodes that have this node as their parent.\n     */\n    public List<Node> getChildNodes() {\n        return unmodifiableList(childNodes);\n    }\n\n    public void addOrphanComment(Comment comment) {\n        orphanComments.add(comment);\n        comment.setParentNode(this);\n    }\n\n    public boolean removeOrphanComment(Comment comment) {\n        boolean removed = orphanComments.remove(comment);\n        if (removed) {\n            notifyPropertyChange(ObservableProperty.COMMENT, comment, null);\n            comment.setParentNode(null);\n        }\n        return removed;\n    }\n\n    /**\n     * This is a list of Comment which are inside the node and are not associated\n     * with any meaningful AST Node.\n     * <p>\n     * For example, comments at the end of methods (immediately before the parenthesis)\n     * or at the end of CompilationUnit are orphan comments.\n     * <p>\n     * When more than one comment preceeds a statement, the one immediately preceding it\n     * it is associated with the statements, while the others are orphans.\n     * <p>\n     * Changes to this list are not persisted.\n     *\n     * @return all comments that cannot be attributed to a concept\n     */\n    public List<Comment> getOrphanComments() {\n        return new LinkedList<>(orphanComments);\n    }\n\n    /**\n     * This is the list of Comment which are contained in the Node either because\n     * they are properly associated to one of its children or because they are floating\n     * around inside the Node\n     *\n     * @return all Comments within the node as a list\n     */\n    public List<Comment> getAllContainedComments() {\n        List<Comment> comments = new LinkedList<>();\n        comments.addAll(getOrphanComments());\n        for (Node child : getChildNodes()) {\n            child.getComment().ifPresent(comments::add);\n            comments.addAll(child.getAllContainedComments());\n        }\n        return comments;\n    }\n\n    /**\n     * Assign a new parent to this node, removing it\n     * from the list of children of the previous parent, if any.\n     *\n     * @param newParentNode node to be set as parent\n     */\n    @Override\n    public Node setParentNode(Node newParentNode) {\n        if (newParentNode == parentNode) {\n            return this;\n        }\n        observers.forEach(o -> o.parentChange(this, parentNode, newParentNode));\n        // remove from old parent, if any\n        if (parentNode != null) {\n            final List<Node> parentChildNodes = parentNode.childNodes;\n            for (int i = 0; i < parentChildNodes.size(); i++) {\n                if (parentChildNodes.get(i) == this) {\n                    parentChildNodes.remove(i);\n                }\n            }\n        }\n        parentNode = newParentNode;\n        // add to new parent, if any\n        if (parentNode != null) {\n            parentNode.childNodes.add(this);\n        }\n        return this;\n    }\n\n    protected void setAsParentNodeOf(Node childNode) {\n        if (childNode != null) {\n            childNode.setParentNode(getParentNodeForChildren());\n        }\n    }\n\n    /**\n     * @deprecated Use {@link Position#ABSOLUTE_BEGIN_LINE}\n     */\n    @Deprecated\n    public static final int ABSOLUTE_BEGIN_LINE = Position.ABSOLUTE_BEGIN_LINE;\n\n    /**\n     * @deprecated Use {@link Position#ABSOLUTE_END_LINE}\n     */\n    @Deprecated\n    public static final int ABSOLUTE_END_LINE = Position.ABSOLUTE_END_LINE;\n\n    public void tryAddImportToParentCompilationUnit(Class<?> clazz) {\n        findAncestor(CompilationUnit.class).ifPresent(p -> p.addImport(clazz));\n    }\n\n    /**\n     * Recursively finds all nodes of a certain type.\n     *\n     * @param clazz the type of node to find.\n     * @deprecated use {@link Node#findAll(Class)} but be aware that findAll also considers the initial node.\n     */\n    @Deprecated\n    public <N extends Node> List<N> getChildNodesByType(Class<N> clazz) {\n        List<N> nodes = new ArrayList<>();\n        for (Node child : getChildNodes()) {\n            if (clazz.isInstance(child)) {\n                nodes.add(clazz.cast(child));\n            }\n            nodes.addAll(child.getChildNodesByType(clazz));\n        }\n        return nodes;\n    }\n\n    /**\n     * @deprecated use {@link Node#findAll(Class)} but be aware that findAll also considers the initial node.\n     */\n    @Deprecated\n    public <N extends Node> List<N> getNodesByType(Class<N> clazz) {\n        return getChildNodesByType(clazz);\n    }\n\n    /**\n     * Gets data for this node using the given key.\n     *\n     * @param <M> The type of the data.\n     * @param key The key for the data\n     * @return The data.\n     * @throws IllegalStateException if the key was not set in this node.\n     * @see Node#containsData(DataKey)\n     * @see DataKey\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <M> M getData(final DataKey<M> key) {\n        if (data == null) {\n            throw new IllegalStateException(\"No data of this type found. Use containsData to check for this first.\");\n        }\n        M value = (M) data.get(key);\n        if (value == null) {\n            throw new IllegalStateException(\"No data of this type found. Use containsData to check for this first.\");\n        }\n        return value;\n    }\n\n    /**\n     * This method was added to support the clone method.\n     *\n     * @return all known data keys.\n     */\n    public Set<DataKey<?>> getDataKeys() {\n        if (data == null) {\n            return emptySet();\n        }\n        return data.keySet();\n    }\n\n    /**\n     * Sets data for this node using the given key.\n     * For information on creating DataKey, see {@link DataKey}.\n     *\n     * @param <M>    The type of data\n     * @param key    The singleton key for the data\n     * @param object The data object\n     * @see DataKey\n     */\n    public <M> void setData(DataKey<M> key, M object) {\n        if (data == null) {\n            data = new IdentityHashMap<>();\n        }\n        data.put(key, object);\n    }\n\n    /**\n     * @return does this node have data for this key?\n     * @see DataKey\n     */\n    public boolean containsData(DataKey<?> key) {\n        if (data == null) {\n            return false;\n        }\n        return data.containsKey(key);\n    }\n\n    /**\n     * Remove data by key.\n     *\n     * @see DataKey\n     */\n    public void removeData(DataKey<?> key) {\n        if (data != null) {\n            data.remove(key);\n        }\n    }\n\n    /**\n     * Try to remove this node from the parent\n     *\n     * @return true if removed, false if it is a required property of the parent, or if the parent isn't set.\n     * @throws RuntimeException if it fails in an unexpected way\n     */\n    public boolean remove() {\n        if (parentNode == null) {\n            return false;\n        }\n        return parentNode.remove(this);\n    }\n\n    /**\n     * Try to replace this node in the parent with the supplied node.\n     *\n     * @return true if removed, or if the parent isn't set.\n     * @throws RuntimeException if it fails in an unexpected way\n     */\n    public boolean replace(Node node) {\n        if (parentNode == null) {\n            return false;\n        }\n        return parentNode.replace(this, node);\n    }\n\n    /**\n     * Forcibly removes this node from the AST.\n     * If it cannot be removed from the parent with remove(),\n     * it will try to remove its parent instead,\n     * until it finds a node that can be removed,\n     * or no parent can be found.\n     * <p>\n     * Since everything at CompilationUnit level is removable,\n     * this method will only (silently) fail when the node is in a detached AST fragment.\n     */\n    public void removeForced() {\n        if (!remove()) {\n            getParentNode().ifPresent(Node::remove);\n        }\n    }\n\n    @Override\n    public Node getParentNodeForChildren() {\n        return this;\n    }\n\n    protected void setAsParentNodeOf(NodeList<? extends Node> list) {\n        if (list != null) {\n            list.setParentNode(getParentNodeForChildren());\n        }\n    }\n\n    public <P> void notifyPropertyChange(ObservableProperty property, P oldValue, P newValue) {\n        this.observers.forEach(o -> o.propertyChange(this, property, oldValue, newValue));\n    }\n\n    @Override\n    public void unregister(AstObserver observer) {\n        this.observers.remove(observer);\n    }\n\n    @Override\n    public void register(AstObserver observer) {\n        this.observers.add(observer);\n    }\n\n    /**\n     * Register a new observer for the given node. Depending on the mode specified also descendants, existing\n     * and new, could be observed. For more details see <i>ObserverRegistrationMode</i>.\n     */\n    public void register(AstObserver observer, ObserverRegistrationMode mode) {\n        if (mode == null) {\n            throw new IllegalArgumentException(\"Mode should be not null\");\n        }\n        switch(mode) {\n            case JUST_THIS_NODE:\n                register(observer);\n                break;\n            case THIS_NODE_AND_EXISTING_DESCENDANTS:\n                registerForSubtree(observer);\n                break;\n            case SELF_PROPAGATING:\n                registerForSubtree(PropagatingAstObserver.transformInPropagatingObserver(observer));\n                break;\n            default:\n                throw new UnsupportedOperationException(\"This mode is not supported: \" + mode);\n        }\n    }\n\n    /**\n     * Register the observer for the current node and all the contained node and nodelists, recursively.\n     */\n    public void registerForSubtree(AstObserver observer) {\n        register(observer);\n        this.getChildNodes().forEach(c -> c.registerForSubtree(observer));\n        for (PropertyMetaModel property : getMetaModel().getAllPropertyMetaModels()) {\n            if (property.isNodeList()) {\n                NodeList<?> nodeList = (NodeList<?>) property.getValue(this);\n                if (nodeList != null)\n                    nodeList.register(observer);\n            }\n        }\n    }\n\n    @Override\n    public boolean isRegistered(AstObserver observer) {\n        return this.observers.contains(observer);\n    }\n\n    @Generated(\"com.github.javaparser.generator.core.node.RemoveMethodGenerator\")\n    public boolean remove(Node node) {\n        if (node == null)\n            return false;\n        if (comment != null) {\n            if (node == comment) {\n                removeComment();\n                return true;\n            }\n        }\n        return false;\n    }\n\n    @Generated(\"com.github.javaparser.generator.core.node.RemoveMethodGenerator\")\n    public Node removeComment() {\n        return setComment((Comment) null);\n    }\n\n    @Override\n    @Generated(\"com.github.javaparser.generator.core.node.CloneGenerator\")\n    public Node clone() {\n        return (Node) accept(new CloneVisitor(), null);\n    }\n\n    /**\n     * @return get JavaParser specific node introspection information.\n     */\n    @Generated(\"com.github.javaparser.generator.core.node.GetMetaModelGenerator\")\n    public NodeMetaModel getMetaModel() {\n        return JavaParserMetaModel.nodeMetaModel;\n    }\n\n    /**\n     * @return whether this node was successfully parsed or not.\n     * If it was not, only the range and tokenRange fields will be valid.\n     */\n    public Parsedness getParsed() {\n        return parsed;\n    }\n\n    /**\n     * Used by the parser to flag unparsable nodes.\n     */\n    public Node setParsed(Parsedness parsed) {\n        this.parsed = parsed;\n        return this;\n    }\n\n    @Generated(\"com.github.javaparser.generator.core.node.ReplaceMethodGenerator\")\n    public boolean replace(Node node, Node replacementNode) {\n        if (node == null)\n            return false;\n        if (comment != null) {\n            if (node == comment) {\n                setComment((Comment) replacementNode);\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Finds the root node of this AST by finding the topmost parent.\n     */\n    public Node findRootNode() {\n        Node n = this;\n        while (n.getParentNode().isPresent()) {\n            n = n.getParentNode().get();\n        }\n        return n;\n    }\n\n    /**\n     * @return the containing CompilationUnit, or empty if this node is not inside a compilation unit.\n     */\n    public Optional<CompilationUnit> findCompilationUnit() {\n        Node rootNode = findRootNode();\n        if (rootNode instanceof CompilationUnit) {\n            return Optional.of((CompilationUnit) rootNode);\n        }\n        return Optional.empty();\n    }\n\n    public LineSeparator getLineEndingStyleOrDefault(LineSeparator defaultLineSeparator) {\n        if (getLineEndingStyle().isStandardEol()) {\n            return getLineEndingStyle();\n        }\n        return defaultLineSeparator;\n    }\n\n    public LineSeparator getLineEndingStyle() {\n        Node current = this;\n        // First check this node\n        if (current.containsData(Node.LINE_SEPARATOR_KEY)) {\n            LineSeparator lineSeparator = current.getData(Node.LINE_SEPARATOR_KEY);\n            return lineSeparator;\n        }\n        // Then check parent/ancestor nodes\n        while (current.getParentNode().isPresent()) {\n            current = current.getParentNode().get();\n            if (current.containsData(Node.LINE_SEPARATOR_KEY)) {\n                return current.getData(Node.LINE_SEPARATOR_KEY);\n            }\n        }\n        // Default to the system line separator if it's not already set within the parsed node/code.\n        return LineSeparator.SYSTEM;\n    }\n\n    protected SymbolResolver getSymbolResolver() {\n        return findCompilationUnit().map(cu -> {\n            if (cu.containsData(SYMBOL_RESOLVER_KEY)) {\n                return cu.getData(SYMBOL_RESOLVER_KEY);\n            } else {\n                throw new IllegalStateException(\"Symbol resolution not configured: to configure consider setting a SymbolResolver in the ParserConfiguration\");\n            }\n        }).orElseThrow(() -> new IllegalStateException(\"The node is not inserted in a CompilationUnit\"));\n    }\n\n    // We need to expose it because we will need to use it to inject the SymbolSolver\n    public static final DataKey<SymbolResolver> SYMBOL_RESOLVER_KEY = new DataKey<SymbolResolver>() {\n    };\n\n    public static final DataKey<LineSeparator> LINE_SEPARATOR_KEY = new DataKey<LineSeparator>() {\n    };\n\n    public enum TreeTraversal {\n\n        PREORDER, BREADTHFIRST, POSTORDER, PARENTS, DIRECT_CHILDREN\n    }\n\n    private Iterator<Node> treeIterator(TreeTraversal traversal) {\n        switch(traversal) {\n            case BREADTHFIRST:\n                return new BreadthFirstIterator(this);\n            case POSTORDER:\n                return new PostOrderIterator(this);\n            case PREORDER:\n                return new PreOrderIterator(this);\n            case DIRECT_CHILDREN:\n                return new DirectChildrenIterator(this);\n            case PARENTS:\n                return new ParentsVisitor(this);\n            default:\n                throw new IllegalArgumentException(\"Unknown traversal choice.\");\n        }\n    }\n\n    private Iterable<Node> treeIterable(TreeTraversal traversal) {\n        return () -> treeIterator(traversal);\n    }\n\n    /**\n     * Make a stream of nodes using traversal algorithm \"traversal\".\n     */\n    public Stream<Node> stream(TreeTraversal traversal) {\n        return StreamSupport.stream(Spliterators.spliteratorUnknownSize(treeIterator(traversal), NONNULL | DISTINCT), false);\n    }\n\n    /**\n     * Make a stream of nodes using pre-order traversal.\n     */\n    public Stream<Node> stream() {\n        return StreamSupport.stream(Spliterators.spliteratorUnknownSize(treeIterator(PREORDER), NONNULL | DISTINCT), false);\n    }\n\n    /**\n     * Walks the AST, calling the consumer for every node, with traversal algorithm \"traversal\".\n     * <br>This is the most general walk method. All other walk and findAll methods are based on this.\n     */\n    public void walk(TreeTraversal traversal, Consumer<Node> consumer) {\n        // Could be implemented as a call to the above walk method, but this is a little more efficient.\n        for (Node node : treeIterable(traversal)) {\n            consumer.accept(node);\n        }\n    }\n\n    /**\n     * Walks the AST, calling the consumer for every node with pre-order traversal.\n     */\n    public void walk(Consumer<Node> consumer) {\n        walk(PREORDER, consumer);\n    }\n\n    /**\n     * Walks the AST with pre-order traversal, calling the consumer for every node of type \"nodeType\".\n     */\n    public <T extends Node> void walk(Class<T> nodeType, Consumer<T> consumer) {\n        walk(TreeTraversal.PREORDER, node -> {\n            if (nodeType.isAssignableFrom(node.getClass())) {\n                consumer.accept(nodeType.cast(node));\n            }\n        });\n    }\n\n    /**\n     * Walks the AST with pre-order traversal, returning all nodes of type \"nodeType\".\n     */\n    public <T extends Node> List<T> findAll(Class<T> nodeType) {\n        final List<T> found = new ArrayList<>();\n        walk(nodeType, found::add);\n        return found;\n    }\n\n    /**\n     * Walks the AST with pre-order traversal, returning all nodes of type \"nodeType\" that match the predicate.\n     */\n    public <T extends Node> List<T> findAll(Class<T> nodeType, Predicate<T> predicate) {\n        final List<T> found = new ArrayList<>();\n        walk(nodeType, n -> {\n            if (predicate.test(n))\n                found.add(n);\n        });\n        return found;\n    }\n\n    /**\n     * Walks the AST, applying the function for every node, with traversal algorithm \"traversal\". If the function\n     * returns something else than null, the traversal is stopped and the function result is returned. <br>This is the\n     * most general findFirst method. All other findFirst methods are based on this.\n     */\n    public <T> Optional<T> findFirst(TreeTraversal traversal, Function<Node, Optional<T>> consumer) {\n        for (Node node : treeIterable(traversal)) {\n            final Optional<T> result = consumer.apply(node);\n            if (result.isPresent()) {\n                return result;\n            }\n        }\n        return Optional.empty();\n    }\n\n    /**\n     * Walks the AST with pre-order traversal, returning the first node of type \"nodeType\" or empty() if none is found.\n     */\n    public <N extends Node> Optional<N> findFirst(Class<N> nodeType) {\n        return findFirst(TreeTraversal.PREORDER, node -> {\n            if (nodeType.isAssignableFrom(node.getClass())) {\n                return Optional.of(nodeType.cast(node));\n            }\n            return Optional.empty();\n        });\n    }\n\n    /**\n     * Walks the AST with pre-order traversal, returning the first node of type \"nodeType\" that matches \"predicate\" or empty() if none is\n     * found.\n     */\n    public <N extends Node> Optional<N> findFirst(Class<N> nodeType, Predicate<N> predicate) {\n        return findFirst(TreeTraversal.PREORDER, node -> {\n            if (nodeType.isAssignableFrom(node.getClass())) {\n                final N castNode = nodeType.cast(node);\n                if (predicate.test(castNode)) {\n                    return Optional.of(castNode);\n                }\n            }\n            return Optional.empty();\n        });\n    }\n\n    /**\n     * Determines whether this node is an ancestor of the given node. A node is <i>not</i> an ancestor of itself.\n     *\n     * @param descendant the node for which to determine whether it has this node as an ancestor.\n     * @return {@code true} if this node is an ancestor of the given node, and {@code false} otherwise.\n     * @see HasParentNode#isDescendantOf(Node)\n     */\n    public boolean isAncestorOf(Node descendant) {\n        return this != descendant && findFirst(Node.class, n -> n == descendant).isPresent();\n    }\n\n    /**\n     * Performs a breadth-first node traversal starting with a given node.\n     *\n     * @see <a href=\"https://en.wikipedia.org/wiki/Breadth-first_search\">Breadth-first traversal</a>\n     */\n    public static class BreadthFirstIterator implements Iterator<Node> {\n\n        private final Queue<Node> queue = new LinkedList<>();\n\n        public BreadthFirstIterator(Node node) {\n            queue.add(node);\n        }\n\n        @Override\n        public boolean hasNext() {\n            return !queue.isEmpty();\n        }\n\n        @Override\n        public Node next() {\n            Node next = queue.remove();\n            queue.addAll(next.getChildNodes());\n            return next;\n        }\n    }\n\n    /**\n     * Performs a simple traversal over all nodes that have the passed node as their parent.\n     */\n    public static class DirectChildrenIterator implements Iterator<Node> {\n\n        private final Iterator<Node> childrenIterator;\n\n        public DirectChildrenIterator(Node node) {\n            childrenIterator = new ArrayList<>(node.getChildNodes()).iterator();\n        }\n\n        @Override\n        public boolean hasNext() {\n            return childrenIterator.hasNext();\n        }\n\n        @Override\n        public Node next() {\n            return childrenIterator.next();\n        }\n    }\n\n    /**\n     * Iterates over the parent of the node, then the parent's parent, then the parent's parent's parent, until running\n     * out of parents.\n     */\n    public static class ParentsVisitor implements Iterator<Node> {\n\n        private Node node;\n\n        public ParentsVisitor(Node node) {\n            this.node = node;\n        }\n\n        @Override\n        public boolean hasNext() {\n            return node.getParentNode().isPresent();\n        }\n\n        @Override\n        public Node next() {\n            node = node.getParentNode().orElse(null);\n            return node;\n        }\n    }\n\n    /**\n     * Performs a pre-order (or depth-first) node traversal starting with a given node.\n     *\n     * @see <a href=\"https://en.wikipedia.org/wiki/Pre-order\">Pre-order traversal</a>\n     */\n    public static class PreOrderIterator implements Iterator<Node> {\n\n        private final Stack<Node> stack = new Stack<>();\n\n        public PreOrderIterator(Node node) {\n            stack.add(node);\n        }\n\n        @Override\n        public boolean hasNext() {\n            return !stack.isEmpty();\n        }\n\n        @Override\n        public Node next() {\n            Node next = stack.pop();\n            List<Node> children = next.getChildNodes();\n            for (int i = children.size() - 1; i >= 0; i--) {\n                stack.add(children.get(i));\n            }\n            return next;\n        }\n    }\n\n    /**\n     * Performs a post-order (or leaves-first) node traversal starting with a given node.\n     *\n     * @see <a href=\"https://en.wikipedia.org/wiki/Post-order\">Post-order traversal</a>\n     */\n    public static class PostOrderIterator implements Iterator<Node> {\n\n        private final Stack<List<Node>> nodesStack = new Stack<>();\n\n        private final Stack<Integer> cursorStack = new Stack<>();\n\n        private final Node root;\n\n        private boolean hasNext = true;\n\n        public PostOrderIterator(Node root) {\n            this.root = root;\n            fillStackToLeaf(root);\n        }\n\n        private void fillStackToLeaf(Node node) {\n            while (true) {\n                List<Node> childNodes = new ArrayList<>(node.getChildNodes());\n                if (childNodes.isEmpty()) {\n                    break;\n                }\n                nodesStack.push(childNodes);\n                cursorStack.push(0);\n                node = childNodes.get(0);\n            }\n        }\n\n        @Override\n        public boolean hasNext() {\n            return hasNext;\n        }\n\n        @Override\n        public Node next() {\n            final List<Node> nodes = nodesStack.peek();\n            final int cursor = cursorStack.peek();\n            final boolean levelHasNext = cursor < nodes.size();\n            if (levelHasNext) {\n                Node node = nodes.get(cursor);\n                fillStackToLeaf(node);\n                return nextFromLevel();\n            } else {\n                nodesStack.pop();\n                cursorStack.pop();\n                hasNext = !nodesStack.empty();\n                if (hasNext) {\n                    return nextFromLevel();\n                }\n                return root;\n            }\n        }\n\n        private Node nextFromLevel() {\n            final List<Node> nodes = nodesStack.peek();\n            final int cursor = cursorStack.pop();\n            cursorStack.push(cursor + 1);\n            return nodes.get(cursor);\n        }\n    }\n}\n",
        "filePathAfter": "javaparser-core/src/main/java/com/github/javaparser/ast/Node.java",
        "sourceCodeAfterForWhole": "/*\n * Copyright (C) 2007-2010 J\u00falio Vilmar Gesser.\n * Copyright (C) 2011, 2013-2020 The JavaParser Team.\n *\n * This file is part of JavaParser.\n *\n * JavaParser can be used either under the terms of\n * a) the GNU Lesser General Public License as published by\n *     the Free Software Foundation, either version 3 of the License, or\n *     (at your option) any later version.\n * b) the terms of the Apache License\n *\n * You should have received a copy of both licenses in LICENCE.LGPL and\n * LICENCE.APACHE. Please refer to those files for details.\n *\n * JavaParser is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n */\npackage com.github.javaparser.ast;\n\nimport static com.github.javaparser.ast.Node.Parsedness.PARSED;\nimport static com.github.javaparser.ast.Node.TreeTraversal.PREORDER;\nimport static java.util.Collections.emptySet;\nimport static java.util.Collections.unmodifiableList;\nimport static java.util.Spliterator.DISTINCT;\nimport static java.util.Spliterator.NONNULL;\n\nimport java.util.ArrayList;\nimport java.util.Comparator;\nimport java.util.HashSet;\nimport java.util.IdentityHashMap;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Optional;\nimport java.util.Queue;\nimport java.util.Set;\nimport java.util.Spliterators;\nimport java.util.Stack;\nimport java.util.function.Consumer;\nimport java.util.function.Function;\nimport java.util.function.Predicate;\nimport java.util.stream.Stream;\nimport java.util.stream.StreamSupport;\n\nimport com.github.javaparser.HasParentNode;\nimport com.github.javaparser.Position;\nimport com.github.javaparser.Range;\nimport com.github.javaparser.TokenRange;\nimport com.github.javaparser.ast.comments.BlockComment;\nimport com.github.javaparser.ast.comments.Comment;\nimport com.github.javaparser.ast.comments.LineComment;\nimport com.github.javaparser.ast.nodeTypes.NodeWithRange;\nimport com.github.javaparser.ast.nodeTypes.NodeWithTokenRange;\nimport com.github.javaparser.ast.observer.AstObserver;\nimport com.github.javaparser.ast.observer.ObservableProperty;\nimport com.github.javaparser.ast.observer.PropagatingAstObserver;\nimport com.github.javaparser.ast.visitor.CloneVisitor;\nimport com.github.javaparser.ast.visitor.EqualsVisitor;\nimport com.github.javaparser.ast.visitor.HashCodeVisitor;\nimport com.github.javaparser.ast.visitor.Visitable;\nimport com.github.javaparser.metamodel.InternalProperty;\nimport com.github.javaparser.metamodel.JavaParserMetaModel;\nimport com.github.javaparser.metamodel.NodeMetaModel;\nimport com.github.javaparser.metamodel.OptionalProperty;\nimport com.github.javaparser.metamodel.PropertyMetaModel;\nimport com.github.javaparser.printer.DefaultPrettyPrinter;\nimport com.github.javaparser.printer.Printer;\nimport com.github.javaparser.printer.configuration.ConfigurationOption;\nimport com.github.javaparser.printer.configuration.DefaultPrinterConfiguration;\nimport com.github.javaparser.printer.configuration.DefaultPrinterConfiguration.ConfigOption;\nimport com.github.javaparser.printer.configuration.PrinterConfiguration;\nimport com.github.javaparser.resolution.SymbolResolver;\nimport com.github.javaparser.utils.LineSeparator;\n\n/**\n * Base class for all nodes of the abstract syntax tree.\n * <h2>Construction</h2>\n * <p>The tree is built by instantiating the required nodes, then adding them to other nodes.\n * If it is the parser who is building the tree, it will use the largest constructor,\n * the one with \"range\" as the first parameter.\n * If you want to manually instantiate nodes, we suggest to...\n * <ul>\n * <li>use a convenience method, like \"addStatement(...)\", or if none are available...</li>\n * <li>use a convenient constructor, like ClassOrInterfaceType(String name), or if none are available...</li>\n * <li>use the default constructor.</li>\n * <li>Alternatively, use one of the JavaParser.parse(snippet) methods.</li>\n * </ul>\n * ... and use the various methods on the node to initialize it further, if needed.\n * <h2>Parent/child</h2>\n * <p>The parent node field is managed automatically and can be seen as read only.\n * Note that there is only one parent,\n * and trying to use the same node in two places will lead to unexpected behaviour.\n * It is advised to clone() a node before moving it around.\n * <h2>Comments</h2>\n * <p>Each Node can have one associated comment which describes it and\n * a number of \"orphan comments\" which it contains but are not specifically\n * associated to any child.\n * <h2>Positions</h2>\n * <p>When the parser creates nodes, it sets their source code position in the \"range\" field.\n * When you manually instantiate nodes, their range is not set.\n * The top left character is position 1, 1.\n * Note that since this is an <i>abstract</i> syntax tree,\n * it leaves out a lot of text from the original source file,\n * like where braces or comma's are exactly.\n * Therefore there is no position information on everything in the original source file.\n * <h2>Observers</h2>\n * <p>It is possible to add observers to the the tree.\n * Any change in the tree is sent as an event to any observers watching.\n * <h2>Visitors</h2>\n * <p>The most comfortable way of working with an abstract syntax tree is using visitors.\n * You can use one of the visitors in the visitor package, or extend one of them.\n * A visitor can be \"run\" by calling accept on a node:\n * <pre>node.accept(visitor, argument);</pre>\n * where argument is an object of your choice (often simply null.)\n *\n * @author Julio Vilmar Gesser\n */\npublic abstract class Node implements Cloneable, HasParentNode<Node>, Visitable, NodeWithRange<Node>, NodeWithTokenRange<Node> {\n\n    /**\n     * Different registration mode for observers on nodes.\n     */\n    public enum ObserverRegistrationMode {\n\n        /**\n         * Notify exclusively for changes happening on this node alone.\n         */\n        JUST_THIS_NODE,\n        /**\n         * Notify for changes happening on this node and all its descendants existing at the moment in\n         * which the observer was registered. Nodes attached later will not be observed.\n         */\n        THIS_NODE_AND_EXISTING_DESCENDANTS,\n        /**\n         * Notify for changes happening on this node and all its descendants. The descendants existing at the moment in\n         * which the observer was registered will be observed immediately. As new nodes are attached later they are\n         * automatically registered to be observed.\n         */\n        SELF_PROPAGATING\n    }\n\n    public enum Parsedness {\n\n        PARSED, UNPARSABLE\n    }\n\n    /**\n     * This can be used to sort nodes on position.\n     */\n    public static Comparator<NodeWithRange<?>> NODE_BY_BEGIN_POSITION = (a, b) -> {\n        if (a.hasRange() && b.hasRange()) {\n            return a.getRange().get().begin.compareTo(b.getRange().get().begin);\n        }\n        if (a.hasRange() || b.hasRange()) {\n            if (a.hasRange()) {\n                return 1;\n            }\n            return -1;\n        }\n        return 0;\n    };\n\n    protected static final PrinterConfiguration prettyPrinterNoCommentsConfiguration = new DefaultPrinterConfiguration().removeOption(new ConfigurationOption(ConfigOption.PRINT_COMMENTS));\n    \n    @InternalProperty\n    private Range range;\n\n    @InternalProperty\n    private TokenRange tokenRange;\n\n    @InternalProperty\n    private Node parentNode;\n\n    @InternalProperty\n    private List<Node> childNodes = new LinkedList<>();\n\n    @InternalProperty\n    private List<Comment> orphanComments = new LinkedList<>();\n\n    @InternalProperty\n    private IdentityHashMap<DataKey<?>, Object> data = null;\n\n    @OptionalProperty\n    private Comment comment;\n\n    @InternalProperty\n    private Set<AstObserver> observers = new HashSet<>();\n\n    @InternalProperty\n    private Parsedness parsed = PARSED;\n\n    protected Node(TokenRange tokenRange) {\n        setTokenRange(tokenRange);\n    }\n\n    /**\n     * Called in every constructor for node specific code.\n     * It can't be written in the constructor itself because it will\n     * be overwritten during code generation.\n     */\n    protected void customInitialization() {\n    }\n    \n    /*\n     * If there is a printer defined in CompilationUnit, returns it\n     * else create a new DefaultPrettyPrinter with default parameters\n     */\n    protected Printer getPrinter() {\n        return findCompilationUnit().map(c-> c.getPrinter()).orElse(createDefaultPrinter());\n    }\n    \n    /*\n     * Return the printer initialized with the specified configuration\n     */\n    protected Printer getPrinter(PrinterConfiguration configuration) {\n        return findCompilationUnit().map(c-> c.getPrinter(configuration)).orElse(createDefaultPrinter(configuration));\n    }\n    \n    protected Printer createDefaultPrinter() {\n        return createDefaultPrinter(getDefaultPrinterConfiguration());\n    }\n    \n    protected Printer createDefaultPrinter(PrinterConfiguration configuration) {\n        return new DefaultPrettyPrinter(configuration);\n    }\n    \n    /*\n     * returns a default printer configuration\n     */\n    protected  PrinterConfiguration getDefaultPrinterConfiguration() {\n        return new DefaultPrinterConfiguration();\n    }\n    \n    /**\n     * This is a comment associated with this node.\n     *\n     * @return comment property\n     */\n    @Generated(\"com.github.javaparser.generator.core.node.PropertyGenerator\")\n    public Optional<Comment> getComment() {\n        return Optional.ofNullable(comment);\n    }\n\n    /**\n     * @return the range of characters in the source code that this node covers.\n     */\n    public Optional<Range> getRange() {\n        return Optional.ofNullable(range);\n    }\n\n    /**\n     * @return the range of tokens that this node covers.\n     */\n    public Optional<TokenRange> getTokenRange() {\n        return Optional.ofNullable(tokenRange);\n    }\n\n    public Node setTokenRange(TokenRange tokenRange) {\n        this.tokenRange = tokenRange;\n        if (tokenRange == null || !(tokenRange.getBegin().hasRange() && tokenRange.getEnd().hasRange())) {\n            range = null;\n        } else {\n            range = new Range(tokenRange.getBegin().getRange().get().begin, tokenRange.getEnd().getRange().get().end);\n        }\n        return this;\n    }\n\n    /**\n     * @param range the range of characters in the source code that this node covers. null can be used to indicate that\n     *              no range information is known, or that it is not of interest.\n     */\n    public Node setRange(Range range) {\n        if (this.range == range) {\n            return this;\n        }\n        notifyPropertyChange(ObservableProperty.RANGE, this.range, range);\n        this.range = range;\n        return this;\n    }\n\n    /**\n     * Use this to store additional information to this node.\n     *\n     * @param comment to be set\n     */\n    public Node setComment(final Comment comment) {\n        if (this.comment == comment) {\n            return this;\n        }\n        notifyPropertyChange(ObservableProperty.COMMENT, this.comment, comment);\n        if (this.comment != null) {\n            this.comment.setCommentedNode(null);\n        }\n        this.comment = comment;\n        if (comment != null) {\n            this.comment.setCommentedNode(this);\n        }\n        return this;\n    }\n\n    /**\n     * Use this to store additional information to this node.\n     *\n     * @param comment to be set\n     */\n    public final Node setLineComment(String comment) {\n        return setComment(new LineComment(comment));\n    }\n\n    /**\n     * Use this to store additional information to this node.\n     *\n     * @param comment to be set\n     */\n    public final Node setBlockComment(String comment) {\n        return setComment(new BlockComment(comment));\n    }\n\n    /**\n     * @return pretty printed source code for this node and its children.\n     */\n    @Override\n    public final String toString() {\n        if (containsData(LINE_SEPARATOR_KEY)) {\n            LineSeparator lineSeparator = getLineEndingStyleOrDefault(LineSeparator.SYSTEM);\n            PrinterConfiguration config = getDefaultPrinterConfiguration();\n            config.addOption(new ConfigurationOption(ConfigOption.END_OF_LINE_CHARACTER, lineSeparator.asRawString()));\n            return getPrinter(config).print(this);\n        }\n        return getPrinter().print(this);\n    }\n\n    /**\n     * @return pretty printed source code for this node and its children.\n     * Formatting can be configured with parameter PrinterConfiguration.\n     */\n    public final String toString(PrinterConfiguration configuration) {\n        return getPrinter(configuration).print(this);\n    }\n\n    @Override\n    public final int hashCode() {\n        return HashCodeVisitor.hashCode(this);\n    }\n\n    @Override\n    public boolean equals(final Object obj) {\n        if (obj == null || !(obj instanceof Node)) {\n            return false;\n        }\n        return EqualsVisitor.equals(this, (Node) obj);\n    }\n\n    @Override\n    public Optional<Node> getParentNode() {\n        return Optional.ofNullable(parentNode);\n    }\n\n    /**\n     * Contains all nodes that have this node set as their parent.\n     * You can add and remove nodes from this list by adding or removing nodes from the fields of this node.\n     *\n     * @return all nodes that have this node as their parent.\n     */\n    public List<Node> getChildNodes() {\n        return unmodifiableList(childNodes);\n    }\n\n    public void addOrphanComment(Comment comment) {\n        orphanComments.add(comment);\n        comment.setParentNode(this);\n    }\n\n    public boolean removeOrphanComment(Comment comment) {\n        boolean removed = orphanComments.remove(comment);\n        if (removed) {\n            notifyPropertyChange(ObservableProperty.COMMENT, comment, null);\n            comment.setParentNode(null);\n        }\n        return removed;\n    }\n\n    /**\n     * This is a list of Comment which are inside the node and are not associated\n     * with any meaningful AST Node.\n     * <p>\n     * For example, comments at the end of methods (immediately before the parenthesis)\n     * or at the end of CompilationUnit are orphan comments.\n     * <p>\n     * When more than one comment preceeds a statement, the one immediately preceding it\n     * it is associated with the statements, while the others are orphans.\n     * <p>\n     * Changes to this list are not persisted.\n     *\n     * @return all comments that cannot be attributed to a concept\n     */\n    public List<Comment> getOrphanComments() {\n        return new LinkedList<>(orphanComments);\n    }\n\n    /**\n     * This is the list of Comment which are contained in the Node either because\n     * they are properly associated to one of its children or because they are floating\n     * around inside the Node\n     *\n     * @return all Comments within the node as a list\n     */\n    public List<Comment> getAllContainedComments() {\n        List<Comment> comments = new LinkedList<>();\n        comments.addAll(getOrphanComments());\n        for (Node child : getChildNodes()) {\n            child.getComment().ifPresent(comments::add);\n            comments.addAll(child.getAllContainedComments());\n        }\n        return comments;\n    }\n\n    /**\n     * Assign a new parent to this node, removing it\n     * from the list of children of the previous parent, if any.\n     *\n     * @param newParentNode node to be set as parent\n     */\n    @Override\n    public Node setParentNode(Node newParentNode) {\n        if (newParentNode == parentNode) {\n            return this;\n        }\n        observers.forEach(o -> o.parentChange(this, parentNode, newParentNode));\n        // remove from old parent, if any\n        if (parentNode != null) {\n            final List<Node> parentChildNodes = parentNode.childNodes;\n            for (int i = 0; i < parentChildNodes.size(); i++) {\n                if (parentChildNodes.get(i) == this) {\n                    parentChildNodes.remove(i);\n                }\n            }\n        }\n        parentNode = newParentNode;\n        // add to new parent, if any\n        if (parentNode != null) {\n            parentNode.childNodes.add(this);\n        }\n        return this;\n    }\n\n    protected void setAsParentNodeOf(Node childNode) {\n        if (childNode != null) {\n            childNode.setParentNode(getParentNodeForChildren());\n        }\n    }\n\n    /**\n     * @deprecated Use {@link Position#ABSOLUTE_BEGIN_LINE}\n     */\n    @Deprecated\n    public static final int ABSOLUTE_BEGIN_LINE = Position.ABSOLUTE_BEGIN_LINE;\n\n    /**\n     * @deprecated Use {@link Position#ABSOLUTE_END_LINE}\n     */\n    @Deprecated\n    public static final int ABSOLUTE_END_LINE = Position.ABSOLUTE_END_LINE;\n\n    public void tryAddImportToParentCompilationUnit(Class<?> clazz) {\n        findAncestor(CompilationUnit.class).ifPresent(p -> p.addImport(clazz));\n    }\n\n    /**\n     * Recursively finds all nodes of a certain type.\n     *\n     * @param clazz the type of node to find.\n     * @deprecated use {@link Node#findAll(Class)} but be aware that findAll also considers the initial node.\n     */\n    @Deprecated\n    public <N extends Node> List<N> getChildNodesByType(Class<N> clazz) {\n        List<N> nodes = new ArrayList<>();\n        for (Node child : getChildNodes()) {\n            if (clazz.isInstance(child)) {\n                nodes.add(clazz.cast(child));\n            }\n            nodes.addAll(child.getChildNodesByType(clazz));\n        }\n        return nodes;\n    }\n\n    /**\n     * @deprecated use {@link Node#findAll(Class)} but be aware that findAll also considers the initial node.\n     */\n    @Deprecated\n    public <N extends Node> List<N> getNodesByType(Class<N> clazz) {\n        return getChildNodesByType(clazz);\n    }\n\n    /**\n     * Gets data for this node using the given key.\n     *\n     * @param <M> The type of the data.\n     * @param key The key for the data\n     * @return The data.\n     * @throws IllegalStateException if the key was not set in this node.\n     * @see Node#containsData(DataKey)\n     * @see DataKey\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <M> M getData(final DataKey<M> key) {\n        if (data == null) {\n            throw new IllegalStateException(\"No data of this type found. Use containsData to check for this first.\");\n        }\n        M value = (M) data.get(key);\n        if (value == null) {\n            throw new IllegalStateException(\"No data of this type found. Use containsData to check for this first.\");\n        }\n        return value;\n    }\n\n    /**\n     * This method was added to support the clone method.\n     *\n     * @return all known data keys.\n     */\n    public Set<DataKey<?>> getDataKeys() {\n        if (data == null) {\n            return emptySet();\n        }\n        return data.keySet();\n    }\n\n    /**\n     * Sets data for this node using the given key.\n     * For information on creating DataKey, see {@link DataKey}.\n     *\n     * @param <M>    The type of data\n     * @param key    The singleton key for the data\n     * @param object The data object\n     * @see DataKey\n     */\n    public <M> void setData(DataKey<M> key, M object) {\n        if (data == null) {\n            data = new IdentityHashMap<>();\n        }\n        data.put(key, object);\n    }\n\n    /**\n     * @return does this node have data for this key?\n     * @see DataKey\n     */\n    public boolean containsData(DataKey<?> key) {\n        if (data == null) {\n            return false;\n        }\n        return data.containsKey(key);\n    }\n\n    /**\n     * Remove data by key.\n     *\n     * @see DataKey\n     */\n    public void removeData(DataKey<?> key) {\n        if (data != null) {\n            data.remove(key);\n        }\n    }\n\n    /**\n     * Try to remove this node from the parent\n     *\n     * @return true if removed, false if it is a required property of the parent, or if the parent isn't set.\n     * @throws RuntimeException if it fails in an unexpected way\n     */\n    public boolean remove() {\n        if (parentNode == null) {\n            return false;\n        }\n        return parentNode.remove(this);\n    }\n\n    /**\n     * Try to replace this node in the parent with the supplied node.\n     *\n     * @return true if removed, or if the parent isn't set.\n     * @throws RuntimeException if it fails in an unexpected way\n     */\n    public boolean replace(Node node) {\n        if (parentNode == null) {\n            return false;\n        }\n        return parentNode.replace(this, node);\n    }\n\n    /**\n     * Forcibly removes this node from the AST.\n     * If it cannot be removed from the parent with remove(),\n     * it will try to remove its parent instead,\n     * until it finds a node that can be removed,\n     * or no parent can be found.\n     * <p>\n     * Since everything at CompilationUnit level is removable,\n     * this method will only (silently) fail when the node is in a detached AST fragment.\n     */\n    public void removeForced() {\n        if (!remove()) {\n            getParentNode().ifPresent(Node::remove);\n        }\n    }\n\n    @Override\n    public Node getParentNodeForChildren() {\n        return this;\n    }\n\n    protected void setAsParentNodeOf(NodeList<? extends Node> list) {\n        if (list != null) {\n            list.setParentNode(getParentNodeForChildren());\n        }\n    }\n\n    public <P> void notifyPropertyChange(ObservableProperty property, P oldValue, P newValue) {\n        this.observers.forEach(o -> o.propertyChange(this, property, oldValue, newValue));\n    }\n\n    @Override\n    public void unregister(AstObserver observer) {\n        this.observers.remove(observer);\n    }\n\n    @Override\n    public void register(AstObserver observer) {\n        this.observers.add(observer);\n    }\n\n    /**\n     * Register a new observer for the given node. Depending on the mode specified also descendants, existing\n     * and new, could be observed. For more details see <i>ObserverRegistrationMode</i>.\n     */\n    public void register(AstObserver observer, ObserverRegistrationMode mode) {\n        if (mode == null) {\n            throw new IllegalArgumentException(\"Mode should be not null\");\n        }\n        switch(mode) {\n            case JUST_THIS_NODE:\n                register(observer);\n                break;\n            case THIS_NODE_AND_EXISTING_DESCENDANTS:\n                registerForSubtree(observer);\n                break;\n            case SELF_PROPAGATING:\n                registerForSubtree(PropagatingAstObserver.transformInPropagatingObserver(observer));\n                break;\n            default:\n                throw new UnsupportedOperationException(\"This mode is not supported: \" + mode);\n        }\n    }\n\n    /**\n     * Register the observer for the current node and all the contained node and nodelists, recursively.\n     */\n    public void registerForSubtree(AstObserver observer) {\n        register(observer);\n        this.getChildNodes().forEach(c -> c.registerForSubtree(observer));\n        for (PropertyMetaModel property : getMetaModel().getAllPropertyMetaModels()) {\n            if (property.isNodeList()) {\n                NodeList<?> nodeList = (NodeList<?>) property.getValue(this);\n                if (nodeList != null)\n                    nodeList.register(observer);\n            }\n        }\n    }\n\n    @Override\n    public boolean isRegistered(AstObserver observer) {\n        return this.observers.contains(observer);\n    }\n\n    @Generated(\"com.github.javaparser.generator.core.node.RemoveMethodGenerator\")\n    public boolean remove(Node node) {\n        if (node == null)\n            return false;\n        if (comment != null) {\n            if (node == comment) {\n                removeComment();\n                return true;\n            }\n        }\n        return false;\n    }\n\n    @Generated(\"com.github.javaparser.generator.core.node.RemoveMethodGenerator\")\n    public Node removeComment() {\n        return setComment((Comment) null);\n    }\n\n    @Override\n    @Generated(\"com.github.javaparser.generator.core.node.CloneGenerator\")\n    public Node clone() {\n        return (Node) accept(new CloneVisitor(), null);\n    }\n\n    /**\n     * @return get JavaParser specific node introspection information.\n     */\n    @Generated(\"com.github.javaparser.generator.core.node.GetMetaModelGenerator\")\n    public NodeMetaModel getMetaModel() {\n        return JavaParserMetaModel.nodeMetaModel;\n    }\n\n    /**\n     * @return whether this node was successfully parsed or not.\n     * If it was not, only the range and tokenRange fields will be valid.\n     */\n    public Parsedness getParsed() {\n        return parsed;\n    }\n\n    /**\n     * Used by the parser to flag unparsable nodes.\n     */\n    public Node setParsed(Parsedness parsed) {\n        this.parsed = parsed;\n        return this;\n    }\n\n    @Generated(\"com.github.javaparser.generator.core.node.ReplaceMethodGenerator\")\n    public boolean replace(Node node, Node replacementNode) {\n        if (node == null)\n            return false;\n        if (comment != null) {\n            if (node == comment) {\n                setComment((Comment) replacementNode);\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Finds the root node of this AST by finding the topmost parent.\n     */\n    public Node findRootNode() {\n        Node n = this;\n        while (n.getParentNode().isPresent()) {\n            n = n.getParentNode().get();\n        }\n        return n;\n    }\n\n    /**\n     * @return the containing CompilationUnit, or empty if this node is not inside a compilation unit.\n     */\n    public Optional<CompilationUnit> findCompilationUnit() {\n        Node rootNode = findRootNode();\n        if (rootNode instanceof CompilationUnit) {\n            return Optional.of((CompilationUnit) rootNode);\n        }\n        return Optional.empty();\n    }\n\n    public LineSeparator getLineEndingStyleOrDefault(LineSeparator defaultLineSeparator) {\n        if (getLineEndingStyle().isStandardEol()) {\n            return getLineEndingStyle();\n        }\n        return defaultLineSeparator;\n    }\n\n    public LineSeparator getLineEndingStyle() {\n        Node current = this;\n        // First check this node\n        if (current.containsData(Node.LINE_SEPARATOR_KEY)) {\n            LineSeparator lineSeparator = current.getData(Node.LINE_SEPARATOR_KEY);\n            return lineSeparator;\n        }\n        // Then check parent/ancestor nodes\n        while (current.getParentNode().isPresent()) {\n            current = current.getParentNode().get();\n            if (current.containsData(Node.LINE_SEPARATOR_KEY)) {\n                return current.getData(Node.LINE_SEPARATOR_KEY);\n            }\n        }\n        // Default to the system line separator if it's not already set within the parsed node/code.\n        return LineSeparator.SYSTEM;\n    }\n\n    protected SymbolResolver getSymbolResolver() {\n        return findCompilationUnit().map(cu -> {\n            if (cu.containsData(SYMBOL_RESOLVER_KEY)) {\n                return cu.getData(SYMBOL_RESOLVER_KEY);\n            } else {\n                throw new IllegalStateException(\"Symbol resolution not configured: to configure consider setting a SymbolResolver in the ParserConfiguration\");\n            }\n        }).orElseThrow(() -> new IllegalStateException(\"The node is not inserted in a CompilationUnit\"));\n    }\n\n    // We need to expose it because we will need to use it to inject the SymbolSolver\n    public static final DataKey<SymbolResolver> SYMBOL_RESOLVER_KEY = new DataKey<SymbolResolver>() {\n    };\n\n    public static final DataKey<LineSeparator> LINE_SEPARATOR_KEY = new DataKey<LineSeparator>() {\n    };\n\n    public enum TreeTraversal {\n\n        PREORDER, BREADTHFIRST, POSTORDER, PARENTS, DIRECT_CHILDREN\n    }\n\n    private Iterator<Node> treeIterator(TreeTraversal traversal) {\n        switch(traversal) {\n            case BREADTHFIRST:\n                return new BreadthFirstIterator(this);\n            case POSTORDER:\n                return new PostOrderIterator(this);\n            case PREORDER:\n                return new PreOrderIterator(this);\n            case DIRECT_CHILDREN:\n                return new DirectChildrenIterator(this);\n            case PARENTS:\n                return new ParentsVisitor(this);\n            default:\n                throw new IllegalArgumentException(\"Unknown traversal choice.\");\n        }\n    }\n\n    private Iterable<Node> treeIterable(TreeTraversal traversal) {\n        return () -> treeIterator(traversal);\n    }\n\n    /**\n     * Make a stream of nodes using traversal algorithm \"traversal\".\n     */\n    public Stream<Node> stream(TreeTraversal traversal) {\n        return StreamSupport.stream(Spliterators.spliteratorUnknownSize(treeIterator(traversal), NONNULL | DISTINCT), false);\n    }\n\n    /**\n     * Make a stream of nodes using pre-order traversal.\n     */\n    public Stream<Node> stream() {\n        return StreamSupport.stream(Spliterators.spliteratorUnknownSize(treeIterator(PREORDER), NONNULL | DISTINCT), false);\n    }\n\n    /**\n     * Walks the AST, calling the consumer for every node, with traversal algorithm \"traversal\".\n     * <br>This is the most general walk method. All other walk and findAll methods are based on this.\n     */\n    public void walk(TreeTraversal traversal, Consumer<Node> consumer) {\n        // Could be implemented as a call to the above walk method, but this is a little more efficient.\n        for (Node node : treeIterable(traversal)) {\n            consumer.accept(node);\n        }\n    }\n\n    /**\n     * Walks the AST, calling the consumer for every node with pre-order traversal.\n     */\n    public void walk(Consumer<Node> consumer) {\n        walk(PREORDER, consumer);\n    }\n\n    /**\n     * Walks the AST with pre-order traversal, calling the consumer for every node of type \"nodeType\".\n     */\n    public <T extends Node> void walk(Class<T> nodeType, Consumer<T> consumer) {\n        walk(TreeTraversal.PREORDER, node -> {\n            if (nodeType.isAssignableFrom(node.getClass())) {\n                consumer.accept(nodeType.cast(node));\n            }\n        });\n    }\n\n    /**\n     * Walks the AST with pre-order traversal, returning all nodes of type \"nodeType\".\n     */\n    public <T extends Node> List<T> findAll(Class<T> nodeType) {\n        final List<T> found = new ArrayList<>();\n        walk(nodeType, found::add);\n        return found;\n    }\n\n    /**\n     * Walks the AST with pre-order traversal, returning all nodes of type \"nodeType\" that match the predicate.\n     */\n    public <T extends Node> List<T> findAll(Class<T> nodeType, Predicate<T> predicate) {\n        final List<T> found = new ArrayList<>();\n        walk(nodeType, n -> {\n            if (predicate.test(n))\n                found.add(n);\n        });\n        return found;\n    }\n\n    /**\n     * Walks the AST, applying the function for every node, with traversal algorithm \"traversal\". If the function\n     * returns something else than null, the traversal is stopped and the function result is returned. <br>This is the\n     * most general findFirst method. All other findFirst methods are based on this.\n     */\n    public <T> Optional<T> findFirst(TreeTraversal traversal, Function<Node, Optional<T>> consumer) {\n        for (Node node : treeIterable(traversal)) {\n            final Optional<T> result = consumer.apply(node);\n            if (result.isPresent()) {\n                return result;\n            }\n        }\n        return Optional.empty();\n    }\n\n    /**\n     * Walks the AST with pre-order traversal, returning the first node of type \"nodeType\" or empty() if none is found.\n     */\n    public <N extends Node> Optional<N> findFirst(Class<N> nodeType) {\n        return findFirst(TreeTraversal.PREORDER, node -> {\n            if (nodeType.isAssignableFrom(node.getClass())) {\n                return Optional.of(nodeType.cast(node));\n            }\n            return Optional.empty();\n        });\n    }\n\n    /**\n     * Walks the AST with pre-order traversal, returning the first node of type \"nodeType\" that matches \"predicate\" or empty() if none is\n     * found.\n     */\n    public <N extends Node> Optional<N> findFirst(Class<N> nodeType, Predicate<N> predicate) {\n        return findFirst(TreeTraversal.PREORDER, node -> {\n            if (nodeType.isAssignableFrom(node.getClass())) {\n                final N castNode = nodeType.cast(node);\n                if (predicate.test(castNode)) {\n                    return Optional.of(castNode);\n                }\n            }\n            return Optional.empty();\n        });\n    }\n\n    /**\n     * Determines whether this node is an ancestor of the given node. A node is <i>not</i> an ancestor of itself.\n     *\n     * @param descendant the node for which to determine whether it has this node as an ancestor.\n     * @return {@code true} if this node is an ancestor of the given node, and {@code false} otherwise.\n     * @see HasParentNode#isDescendantOf(Node)\n     */\n    public boolean isAncestorOf(Node descendant) {\n        return this != descendant && findFirst(Node.class, n -> n == descendant).isPresent();\n    }\n\n    /**\n     * Performs a breadth-first node traversal starting with a given node.\n     *\n     * @see <a href=\"https://en.wikipedia.org/wiki/Breadth-first_search\">Breadth-first traversal</a>\n     */\n    public static class BreadthFirstIterator implements Iterator<Node> {\n\n        private final Queue<Node> queue = new LinkedList<>();\n\n        public BreadthFirstIterator(Node node) {\n            queue.add(node);\n        }\n\n        @Override\n        public boolean hasNext() {\n            return !queue.isEmpty();\n        }\n\n        @Override\n        public Node next() {\n            Node next = queue.remove();\n            queue.addAll(next.getChildNodes());\n            return next;\n        }\n    }\n\n    /**\n     * Performs a simple traversal over all nodes that have the passed node as their parent.\n     */\n    public static class DirectChildrenIterator implements Iterator<Node> {\n\n        private final Iterator<Node> childrenIterator;\n\n        public DirectChildrenIterator(Node node) {\n            childrenIterator = new ArrayList<>(node.getChildNodes()).iterator();\n        }\n\n        @Override\n        public boolean hasNext() {\n            return childrenIterator.hasNext();\n        }\n\n        @Override\n        public Node next() {\n            return childrenIterator.next();\n        }\n    }\n\n    /**\n     * Iterates over the parent of the node, then the parent's parent, then the parent's parent's parent, until running\n     * out of parents.\n     */\n    public static class ParentsVisitor implements Iterator<Node> {\n\n        private Node node;\n\n        public ParentsVisitor(Node node) {\n            this.node = node;\n        }\n\n        @Override\n        public boolean hasNext() {\n            return node.getParentNode().isPresent();\n        }\n\n        @Override\n        public Node next() {\n            node = node.getParentNode().orElse(null);\n            return node;\n        }\n    }\n\n    /**\n     * Performs a pre-order (or depth-first) node traversal starting with a given node.\n     *\n     * @see <a href=\"https://en.wikipedia.org/wiki/Pre-order\">Pre-order traversal</a>\n     */\n    public static class PreOrderIterator implements Iterator<Node> {\n\n        private final Stack<Node> stack = new Stack<>();\n\n        public PreOrderIterator(Node node) {\n            stack.add(node);\n        }\n\n        @Override\n        public boolean hasNext() {\n            return !stack.isEmpty();\n        }\n\n        @Override\n        public Node next() {\n            Node next = stack.pop();\n            List<Node> children = next.getChildNodes();\n            for (int i = children.size() - 1; i >= 0; i--) {\n                stack.add(children.get(i));\n            }\n            return next;\n        }\n    }\n\n    /**\n     * Performs a post-order (or leaves-first) node traversal starting with a given node.\n     *\n     * @see <a href=\"https://en.wikipedia.org/wiki/Post-order\">Post-order traversal</a>\n     */\n    public static class PostOrderIterator implements Iterator<Node> {\n\n        private final Stack<List<Node>> nodesStack = new Stack<>();\n\n        private final Stack<Integer> cursorStack = new Stack<>();\n\n        private final Node root;\n\n        private boolean hasNext = true;\n\n        public PostOrderIterator(Node root) {\n            this.root = root;\n            fillStackToLeaf(root);\n        }\n\n        private void fillStackToLeaf(Node node) {\n            while (true) {\n                List<Node> childNodes = new ArrayList<>(node.getChildNodes());\n                if (childNodes.isEmpty()) {\n                    break;\n                }\n                nodesStack.push(childNodes);\n                cursorStack.push(0);\n                node = childNodes.get(0);\n            }\n        }\n\n        @Override\n        public boolean hasNext() {\n            return hasNext;\n        }\n\n        @Override\n        public Node next() {\n            final List<Node> nodes = nodesStack.peek();\n            final int cursor = cursorStack.peek();\n            final boolean levelHasNext = cursor < nodes.size();\n            if (levelHasNext) {\n                Node node = nodes.get(cursor);\n                fillStackToLeaf(node);\n                return nextFromLevel();\n            } else {\n                nodesStack.pop();\n                cursorStack.pop();\n                hasNext = !nodesStack.empty();\n                if (hasNext) {\n                    return nextFromLevel();\n                }\n                return root;\n            }\n        }\n\n        private Node nextFromLevel() {\n            final List<Node> nodes = nodesStack.peek();\n            final int cursor = cursorStack.pop();\n            cursorStack.push(cursor + 1);\n            return nodes.get(cursor);\n        }\n    }\n}\n",
        "diffSourceCodeSet": [
            "protected Printer createDefaultPrinter(PrinterConfiguration configuration) {\n        return new DefaultPrettyPrinter(configuration);\n    }"
        ],
        "invokedMethodSet": [
            "methodSignature: com.github.javaparser.ast.Node#getDefaultPrinterConfiguration\n methodBody: protected  PrinterConfiguration getDefaultPrinterConfiguration() {\nreturn new DefaultPrinterConfiguration();\n}"
        ],
        "sourceCodeAfterRefactoring": "protected Printer createDefaultPrinter() {\n        return createDefaultPrinter(getDefaultPrinterConfiguration());\n    }\nprotected Printer createDefaultPrinter(PrinterConfiguration configuration) {\n        return new DefaultPrettyPrinter(configuration);\n    }",
        "diffSourceCode": "-  222:         return getPrinter().setConfiguration(configuration);\n-  223:     }\n-  224:     \n-  225:     protected Printer createDefaultPrinter() {\n-  226:         PrinterConfiguration configuration = getDefaultPrinterConfiguration();\n+  222:     protected Printer createDefaultPrinter() {\n+  223:         return createDefaultPrinter(getDefaultPrinterConfiguration());\n+  224:     }\n+  225:     \n+  226:     protected Printer createDefaultPrinter(PrinterConfiguration configuration) {\n   227:         return new DefaultPrettyPrinter(configuration);\n   228:     }\n",
        "uniqueId": "9d8184e1a607dcfcd3733b8a40587459f2a583d1_225_228_226_228_222_224",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 0,
                "covered": 8
            },
            "LINE": {
                "missed": 0,
                "covered": 2
            },
            "COMPLEXITY": {
                "missed": 0,
                "covered": 1
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 1.8
    },
    {
        "type": "Extract And Move Method",
        "description": "Extract And Move Method\tpublic getWidth() : int extracted from private calculateIndentWithAlignTo(column int) : String in class com.github.javaparser.printer.SourcePrinter & moved to class com.github.javaparser.printer.configuration.Indentation.IndentType",
        "diffLocations": [
            {
                "filePath": "javaparser-core/src/main/java/com/github/javaparser/printer/SourcePrinter.java",
                "startLine": 87,
                "endLine": 129,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "javaparser-core/src/main/java/com/github/javaparser/printer/SourcePrinter.java",
                "startLine": 87,
                "endLine": 129,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "javaparser-core/src/main/java/com/github/javaparser/printer/SourcePrinter.java",
                "startLine": 53,
                "endLine": 55,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "private String calculateIndentWithAlignTo(int column) {\n        if (column < lastPrintedIndent.length()){\n            throw new IllegalStateException(\"Attempt to indent less than the previous indent.\");\n        }\n\n        StringBuilder newIndent = new StringBuilder(lastPrintedIndent);\n        switch (indentation.type) {\n            case SPACES:\n            case TABS_WITH_SPACE_ALIGN:\n                while (newIndent.length() < column) {\n                    newIndent.append(IndentType.SPACES.car);\n                }\n                break;\n\n            case TABS:\n                IndentType currentIndentType = indentation.type; \n                int logicalIndentLength = newIndent.length();\n                while ((logicalIndentLength + currentIndentType.width) <= column) {\n                    newIndent.insert(0, currentIndentType.car);\n                    logicalIndentLength += currentIndentType.width;\n                }\n                while (logicalIndentLength < column) {\n                    newIndent.append(IndentType.SPACES.car);\n                    logicalIndentLength++;\n                }\n                StringBuilder fullTab = new StringBuilder();\n                for(int i=0; i<currentIndentType.width; i++){\n                    fullTab.append(IndentType.SPACES.car);\n                }\n                String fullTabString = fullTab.toString();\n                if ((newIndent.length() >= currentIndentType.width)\n                        && newIndent.substring(newIndent.length() - currentIndentType.width).equals(fullTabString)) {\n                    int i = newIndent.indexOf(fullTabString);\n                    newIndent.replace(i, i + currentIndentType.width, currentIndentType.car.toString());\n                }\n                break;\n\n            default:\n                throw new AssertionError(\"Unhandled indent type\");\n        }\n\n        return newIndent.toString();\n    }",
        "filePathBefore": "javaparser-core/src/main/java/com/github/javaparser/printer/SourcePrinter.java",
        "isPureRefactoring": true,
        "commitId": "b08e66263903837d53a688b5d12a758c8cdf167e",
        "packageNameBefore": "com.github.javaparser.printer",
        "classNameBefore": "com.github.javaparser.printer.SourcePrinter",
        "methodNameBefore": "com.github.javaparser.printer.SourcePrinter#calculateIndentWithAlignTo",
        "invokedMethod": "methodSignature: com.github.javaparser.printer.SourcePrinter#toString\n methodBody: public String toString() {\nreturn buf.toString();\n}\nmethodSignature: com.github.javaparser.printer.SourcePrinter#append\n methodBody: private void append(String arg) {\nbuf.append(arg);\ncursor=cursor.withColumn(cursor.column + arg.length());\n}",
        "classSignatureBefore": "public class SourcePrinter ",
        "methodNameBeforeSet": [
            "com.github.javaparser.printer.SourcePrinter#calculateIndentWithAlignTo"
        ],
        "classNameBeforeSet": [
            "com.github.javaparser.printer.SourcePrinter"
        ],
        "classSignatureBeforeSet": [
            "public class SourcePrinter "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Copyright (C) 2007-2010 J\u00falio Vilmar Gesser.\n * Copyright (C) 2011, 2013-2020 The JavaParser Team.\n *\n * This file is part of JavaParser.\n *\n * JavaParser can be used either under the terms of\n * a) the GNU Lesser General Public License as published by\n *     the Free Software Foundation, either version 3 of the License, or\n *     (at your option) any later version.\n * b) the terms of the Apache License\n *\n * You should have received a copy of both licenses in LICENCE.LGPL and\n * LICENCE.APACHE. Please refer to those files for details.\n *\n * JavaParser is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n */\n\npackage com.github.javaparser.printer;\n\nimport java.util.Deque;\nimport java.util.LinkedList;\n\nimport com.github.javaparser.Position;\nimport com.github.javaparser.printer.PrettyPrinterConfiguration.IndentType;\nimport com.github.javaparser.printer.PrettyPrinterConfiguration.Indentation;\nimport com.github.javaparser.utils.Utils;\n\n/**\n * A support class for code that outputs formatted source code.\n */\npublic class SourcePrinter {\n    private final String endOfLineCharacter;\n    private final Indentation indentation;\n\n    private final Deque<String> indents = new LinkedList<>();\n    private final Deque<String> reindentedIndents = new LinkedList<>();\n    private String lastPrintedIndent = \"\";\n    private final StringBuilder buf = new StringBuilder();\n    private Position cursor = new Position(Position.FIRST_LINE, Position.FIRST_COLUMN - 1); // Start before the first column\n    private boolean indented = false;\n\n    SourcePrinter() {\n        this(new PrettyPrinterConfiguration());\n    }\n\n    SourcePrinter(final PrettyPrinterConfiguration configuration) {\n        indentation = configuration.getIndentation();\n        endOfLineCharacter = configuration.getEndOfLineCharacter();\n        indents.push(\"\");\n    }\n\n    /**\n     * Add the default indentation to the current indentation and push it on the indentation stack.\n     * Does not actually output anything.\n     */\n    public SourcePrinter indent() {\n        String currentIndent = indents.peek();\n        switch (indentation.type) {\n            case SPACES:\n            case TABS_WITH_SPACE_ALIGN:\n                indents.push(currentIndent + indentation.getIndent());\n                break;\n\n            case TABS:\n                indents.push(indentation.getIndent() + currentIndent);\n                break;\n\n            default:\n                throw new AssertionError(\"Unhandled indent type\");\n        }\n        return this;\n    }\n\n    /**\n     * Add to the current indentation until it is reaches \"column\" and push it on the indentation stack.\n     * Does not actually output anything.\n     */\n    public SourcePrinter indentWithAlignTo(int column) {\n        indents.push(calculateIndentWithAlignTo(column));\n        return this;\n    }\n\n    private String calculateIndentWithAlignTo(int column) {\n        if (column < lastPrintedIndent.length()){\n            throw new IllegalStateException(\"Attempt to indent less than the previous indent.\");\n        }\n\n        StringBuilder newIndent = new StringBuilder(lastPrintedIndent);\n        switch (indentation.type) {\n            case SPACES:\n            case TABS_WITH_SPACE_ALIGN:\n                while (newIndent.length() < column) {\n                    newIndent.append(IndentType.SPACES.car);\n                }\n                break;\n\n            case TABS:\n                IndentType currentIndentType = indentation.type; \n                int logicalIndentLength = newIndent.length();\n                while ((logicalIndentLength + currentIndentType.width) <= column) {\n                    newIndent.insert(0, currentIndentType.car);\n                    logicalIndentLength += currentIndentType.width;\n                }\n                while (logicalIndentLength < column) {\n                    newIndent.append(IndentType.SPACES.car);\n                    logicalIndentLength++;\n                }\n                StringBuilder fullTab = new StringBuilder();\n                for(int i=0; i<currentIndentType.width; i++){\n                    fullTab.append(IndentType.SPACES.car);\n                }\n                String fullTabString = fullTab.toString();\n                if ((newIndent.length() >= currentIndentType.width)\n                        && newIndent.substring(newIndent.length() - currentIndentType.width).equals(fullTabString)) {\n                    int i = newIndent.indexOf(fullTabString);\n                    newIndent.replace(i, i + currentIndentType.width, currentIndentType.car.toString());\n                }\n                break;\n\n            default:\n                throw new AssertionError(\"Unhandled indent type\");\n        }\n\n        return newIndent.toString();\n    }\n\n    /**\n     * Pop the last indentation of the indentation stack.\n     * Does not actually output anything.\n     */\n    public SourcePrinter unindent() {\n        if (indents.isEmpty()) {\n            // Since we start out with an empty indent on the stack, this will only occur\n            // the second time we over-unindent.\n            throw new IllegalStateException(\"Indent/unindent calls are not well-balanced.\");\n        }\n        indents.pop();\n        return this;\n    }\n\n    private void append(String arg) {\n        buf.append(arg);\n        cursor = cursor.withColumn(cursor.column + arg.length());\n    }\n\n    /**\n     * Append the source string passed as argument to the buffer.\n     * If this is being appended at the beginning of a line, performs indentation first.\n     * <p>\n     * The source line to be printed should not contain newline/carriage-return characters;\n     * use {@link #println(String)} to automatically append a newline at the end of the source string.\n     * If the source line passed as argument contains newline/carriage-return characters would\n     * impredictably affect a correct computation of the current {@link #getCursor()} position.\n     *\n     * @param arg source line to be printed (should not contain newline/carriage-return characters)\n     * @return this instance, for nesting calls to method as fluent interface\n     * @see SourcePrinter#println(String)\n     */\n    public SourcePrinter print(final String arg) {\n        if (!indented) {\n            lastPrintedIndent = indents.peek();\n            append(lastPrintedIndent);\n            indented = true;\n        }\n        append(arg);\n        return this;\n    }\n\n    /**\n     * Append the source string passed as argument to the buffer, then append a newline.\n     * If this is being appended at the beginning of a line, performs indentation first.\n     * <p>\n     * The source line to be printed should not contain newline/carriage-return characters.\n     * If the source line passed as argument contains newline/carriage-return characters would\n     * impredictably affect a correct computation of the current {@link #getCursor()} position.\n     *\n     * @param arg source line to be printed (should not contain newline/carriage-return characters)\n     * @return this instance, for nesting calls to method as fluent interface\n     */\n    public SourcePrinter println(final String arg) {\n        print(arg);\n        println();\n        return this;\n    }\n\n    /**\n     * Append a newline to the buffer.\n     *\n     * @return this instance, for nesting calls to method as fluent interface\n     */\n    public SourcePrinter println() {\n        buf.append(endOfLineCharacter);\n        cursor = new Position(cursor.line + 1, Position.FIRST_COLUMN - 1); // Start before the first column\n        indented = false;\n        return this;\n    }\n\n    /**\n     * Return the current cursor position (line, column) in the source printer buffer.\n     * <p>\n     * Please notice in order to guarantee a correct computation of the cursor position,\n     * this printer expect the contracts of the methods {@link #print(String)} and {@link #println(String)}\n     * has been respected through all method calls, meaning the source string passed as argument to those method\n     * calls did not contain newline/carriage-return characters.\n     *\n     * @return the current cursor position (line, column).\n     */\n    public Position getCursor() {\n        return cursor;\n    }\n\n    /**\n     * @return the currently printed source code.\n     * @deprecated use toString()\n     */\n    @Deprecated\n    public String getSource() {\n        return toString();\n    }\n\n    /**\n     * @return the currently printed source code.\n     */\n    @Override\n    public String toString() {\n        return buf.toString();\n    }\n\n    /**\n     * Changes all EOL characters in \"content\" to the EOL character this SourcePrinter is using.\n     */\n    public String normalizeEolInTextBlock(String content) {\n        return Utils.normalizeEolInTextBlock(content, endOfLineCharacter);\n    }\n\n    /**\n     * Set the top-most indent to the column the cursor is currently in, can be undone with\n     * {@link #reindentToPreviousLevel()}. Does not actually output anything.\n     */\n    public void reindentWithAlignToCursor() {\n        String newIndent = calculateIndentWithAlignTo(cursor.column);\n        reindentedIndents.push(indents.pop());\n        indents.push(newIndent);\n    }\n\n    /**\n     * Set the top-most indent to the column the cursor was before the last {@link #reindentWithAlignToCursor()} call.\n     * Does not actually output anything.\n     */\n    public void reindentToPreviousLevel() {\n        if (reindentedIndents.isEmpty()) {\n            throw new IllegalStateException(\"Reindent calls are not well-balanced.\");\n        }\n        indents.pop();\n        indents.push(reindentedIndents.pop());\n    }\n\n    /**\n     * Adds an indent to the top of the stack that is a copy of the current top indent.\n     * With this you announce \"I'm going to indent the next line(s)\" but not how far yet.\n     * Once you do know, you can pop this indent (\"unindent\") and indent to the right column.\n     * (Does not actually output anything.)\n     */\n    public void duplicateIndent() {\n        indents.push(indents.peek());\n    }\n}\n",
        "filePathAfter": "javaparser-core/src/main/java/com/github/javaparser/printer/SourcePrinter.java",
        "sourceCodeAfterForWhole": "/*\n * Copyright (C) 2007-2010 J\u00falio Vilmar Gesser.\n * Copyright (C) 2011, 2013-2020 The JavaParser Team.\n *\n * This file is part of JavaParser.\n *\n * JavaParser can be used either under the terms of\n * a) the GNU Lesser General Public License as published by\n *     the Free Software Foundation, either version 3 of the License, or\n *     (at your option) any later version.\n * b) the terms of the Apache License\n *\n * You should have received a copy of both licenses in LICENCE.LGPL and\n * LICENCE.APACHE. Please refer to those files for details.\n *\n * JavaParser is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n */\n\npackage com.github.javaparser.printer;\n\nimport java.util.Deque;\nimport java.util.LinkedList;\n\nimport com.github.javaparser.Position;\nimport com.github.javaparser.printer.configuration.Indentation;\nimport com.github.javaparser.printer.configuration.Indentation.IndentType;\nimport com.github.javaparser.utils.Utils;\n\n/**\n * A support class for code that outputs formatted source code.\n */\npublic class SourcePrinter {\n    private final String endOfLineCharacter;\n    private final Indentation indentation;\n\n    private final Deque<String> indents = new LinkedList<>();\n    private final Deque<String> reindentedIndents = new LinkedList<>();\n    private String lastPrintedIndent = \"\";\n    private final StringBuilder buf = new StringBuilder();\n    private Position cursor = new Position(Position.FIRST_LINE, Position.FIRST_COLUMN - 1); // Start before the first column\n    private boolean indented = false;\n\n    SourcePrinter() {\n        this(new PrettyPrinterConfiguration());\n    }\n\n    SourcePrinter(final PrettyPrinterConfiguration configuration) {\n        indentation = configuration.getIndentation();\n        endOfLineCharacter = configuration.getEndOfLineCharacter();\n        indents.push(\"\");\n    }\n\n    /**\n     * Add the default indentation to the current indentation and push it on the indentation stack.\n     * Does not actually output anything.\n     */\n    public SourcePrinter indent() {\n        String currentIndent = indents.peek();\n        switch (indentation.getType()) {\n            case SPACES:\n            case TABS_WITH_SPACE_ALIGN:\n                indents.push(currentIndent + indentation.getIndent());\n                break;\n\n            case TABS:\n                indents.push(indentation.getIndent() + currentIndent);\n                break;\n\n            default:\n                throw new AssertionError(\"Unhandled indent type\");\n        }\n        return this;\n    }\n\n    /**\n     * Add to the current indentation until it is reaches \"column\" and push it on the indentation stack.\n     * Does not actually output anything.\n     */\n    public SourcePrinter indentWithAlignTo(int column) {\n        indents.push(calculateIndentWithAlignTo(column));\n        return this;\n    }\n\n    private String calculateIndentWithAlignTo(int column) {\n        if (column < lastPrintedIndent.length()){\n            throw new IllegalStateException(\"Attempt to indent less than the previous indent.\");\n        }\n\n        StringBuilder newIndent = new StringBuilder(lastPrintedIndent);\n        switch (indentation.getType()) {\n            case SPACES:\n            case TABS_WITH_SPACE_ALIGN:\n                while (newIndent.length() < column) {\n                    newIndent.append(IndentType.SPACES.getCar());\n                }\n                break;\n\n            case TABS:\n                IndentType currentIndentType = indentation.getType(); \n                int logicalIndentLength = newIndent.length();\n                while ((logicalIndentLength + currentIndentType.getWidth()) <= column) {\n                    newIndent.insert(0, currentIndentType.getCar());\n                    logicalIndentLength += currentIndentType.getWidth();\n                }\n                while (logicalIndentLength < column) {\n                    newIndent.append(IndentType.SPACES.getCar());\n                    logicalIndentLength++;\n                }\n                StringBuilder fullTab = new StringBuilder();\n                for(int i=0; i<currentIndentType.getWidth(); i++){\n                    fullTab.append(IndentType.SPACES.getCar());\n                }\n                String fullTabString = fullTab.toString();\n                if ((newIndent.length() >= currentIndentType.getWidth())\n                        && newIndent.substring(newIndent.length() - currentIndentType.getWidth()).equals(fullTabString)) {\n                    int i = newIndent.indexOf(fullTabString);\n                    newIndent.replace(i, i + currentIndentType.getWidth(), currentIndentType.getCar().toString());\n                }\n                break;\n\n            default:\n                throw new AssertionError(\"Unhandled indent type\");\n        }\n\n        return newIndent.toString();\n    }\n\n    /**\n     * Pop the last indentation of the indentation stack.\n     * Does not actually output anything.\n     */\n    public SourcePrinter unindent() {\n        if (indents.isEmpty()) {\n            // Since we start out with an empty indent on the stack, this will only occur\n            // the second time we over-unindent.\n            throw new IllegalStateException(\"Indent/unindent calls are not well-balanced.\");\n        }\n        indents.pop();\n        return this;\n    }\n\n    private void append(String arg) {\n        buf.append(arg);\n        cursor = cursor.withColumn(cursor.column + arg.length());\n    }\n\n    /**\n     * Append the source string passed as argument to the buffer.\n     * If this is being appended at the beginning of a line, performs indentation first.\n     * <p>\n     * The source line to be printed should not contain newline/carriage-return characters;\n     * use {@link #println(String)} to automatically append a newline at the end of the source string.\n     * If the source line passed as argument contains newline/carriage-return characters would\n     * impredictably affect a correct computation of the current {@link #getCursor()} position.\n     *\n     * @param arg source line to be printed (should not contain newline/carriage-return characters)\n     * @return this instance, for nesting calls to method as fluent interface\n     * @see SourcePrinter#println(String)\n     */\n    public SourcePrinter print(final String arg) {\n        if (!indented) {\n            lastPrintedIndent = indents.peek();\n            append(lastPrintedIndent);\n            indented = true;\n        }\n        append(arg);\n        return this;\n    }\n\n    /**\n     * Append the source string passed as argument to the buffer, then append a newline.\n     * If this is being appended at the beginning of a line, performs indentation first.\n     * <p>\n     * The source line to be printed should not contain newline/carriage-return characters.\n     * If the source line passed as argument contains newline/carriage-return characters would\n     * impredictably affect a correct computation of the current {@link #getCursor()} position.\n     *\n     * @param arg source line to be printed (should not contain newline/carriage-return characters)\n     * @return this instance, for nesting calls to method as fluent interface\n     */\n    public SourcePrinter println(final String arg) {\n        print(arg);\n        println();\n        return this;\n    }\n\n    /**\n     * Append a newline to the buffer.\n     *\n     * @return this instance, for nesting calls to method as fluent interface\n     */\n    public SourcePrinter println() {\n        buf.append(endOfLineCharacter);\n        cursor = new Position(cursor.line + 1, Position.FIRST_COLUMN - 1); // Start before the first column\n        indented = false;\n        return this;\n    }\n\n    /**\n     * Return the current cursor position (line, column) in the source printer buffer.\n     * <p>\n     * Please notice in order to guarantee a correct computation of the cursor position,\n     * this printer expect the contracts of the methods {@link #print(String)} and {@link #println(String)}\n     * has been respected through all method calls, meaning the source string passed as argument to those method\n     * calls did not contain newline/carriage-return characters.\n     *\n     * @return the current cursor position (line, column).\n     */\n    public Position getCursor() {\n        return cursor;\n    }\n\n    /**\n     * @return the currently printed source code.\n     * @deprecated use toString()\n     */\n    @Deprecated\n    public String getSource() {\n        return toString();\n    }\n\n    /**\n     * @return the currently printed source code.\n     */\n    @Override\n    public String toString() {\n        return buf.toString();\n    }\n\n    /**\n     * Changes all EOL characters in \"content\" to the EOL character this SourcePrinter is using.\n     */\n    public String normalizeEolInTextBlock(String content) {\n        return Utils.normalizeEolInTextBlock(content, endOfLineCharacter);\n    }\n\n    /**\n     * Set the top-most indent to the column the cursor is currently in, can be undone with\n     * {@link #reindentToPreviousLevel()}. Does not actually output anything.\n     */\n    public void reindentWithAlignToCursor() {\n        String newIndent = calculateIndentWithAlignTo(cursor.column);\n        reindentedIndents.push(indents.pop());\n        indents.push(newIndent);\n    }\n\n    /**\n     * Set the top-most indent to the column the cursor was before the last {@link #reindentWithAlignToCursor()} call.\n     * Does not actually output anything.\n     */\n    public void reindentToPreviousLevel() {\n        if (reindentedIndents.isEmpty()) {\n            throw new IllegalStateException(\"Reindent calls are not well-balanced.\");\n        }\n        indents.pop();\n        indents.push(reindentedIndents.pop());\n    }\n\n    /**\n     * Adds an indent to the top of the stack that is a copy of the current top indent.\n     * With this you announce \"I'm going to indent the next line(s)\" but not how far yet.\n     * Once you do know, you can pop this indent (\"unindent\") and indent to the right column.\n     * (Does not actually output anything.)\n     */\n    public void duplicateIndent() {\n        indents.push(indents.peek());\n    }\n}\n",
        "diffSourceCodeSet": [
            "indents.push(\"\");\n    }"
        ],
        "invokedMethodSet": [
            "methodSignature: com.github.javaparser.printer.SourcePrinter#toString\n methodBody: public String toString() {\nreturn buf.toString();\n}",
            "methodSignature: com.github.javaparser.printer.SourcePrinter#append\n methodBody: private void append(String arg) {\nbuf.append(arg);\ncursor=cursor.withColumn(cursor.column + arg.length());\n}"
        ],
        "sourceCodeAfterRefactoring": "private String calculateIndentWithAlignTo(int column) {\n        if (column < lastPrintedIndent.length()){\n            throw new IllegalStateException(\"Attempt to indent less than the previous indent.\");\n        }\n\n        StringBuilder newIndent = new StringBuilder(lastPrintedIndent);\n        switch (indentation.getType()) {\n            case SPACES:\n            case TABS_WITH_SPACE_ALIGN:\n                while (newIndent.length() < column) {\n                    newIndent.append(IndentType.SPACES.getCar());\n                }\n                break;\n\n            case TABS:\n                IndentType currentIndentType = indentation.getType(); \n                int logicalIndentLength = newIndent.length();\n                while ((logicalIndentLength + currentIndentType.getWidth()) <= column) {\n                    newIndent.insert(0, currentIndentType.getCar());\n                    logicalIndentLength += currentIndentType.getWidth();\n                }\n                while (logicalIndentLength < column) {\n                    newIndent.append(IndentType.SPACES.getCar());\n                    logicalIndentLength++;\n                }\n                StringBuilder fullTab = new StringBuilder();\n                for(int i=0; i<currentIndentType.getWidth(); i++){\n                    fullTab.append(IndentType.SPACES.getCar());\n                }\n                String fullTabString = fullTab.toString();\n                if ((newIndent.length() >= currentIndentType.getWidth())\n                        && newIndent.substring(newIndent.length() - currentIndentType.getWidth()).equals(fullTabString)) {\n                    int i = newIndent.indexOf(fullTabString);\n                    newIndent.replace(i, i + currentIndentType.getWidth(), currentIndentType.getCar().toString());\n                }\n                break;\n\n            default:\n                throw new AssertionError(\"Unhandled indent type\");\n        }\n\n        return newIndent.toString();\n    }\nindents.push(\"\");\n    }",
        "diffSourceCode": "    53:         indents.push(\"\");\n    54:     }\n    55: \n    87:     private String calculateIndentWithAlignTo(int column) {\n    88:         if (column < lastPrintedIndent.length()){\n    89:             throw new IllegalStateException(\"Attempt to indent less than the previous indent.\");\n    90:         }\n    91: \n    92:         StringBuilder newIndent = new StringBuilder(lastPrintedIndent);\n-   93:         switch (indentation.type) {\n+   93:         switch (indentation.getType()) {\n    94:             case SPACES:\n    95:             case TABS_WITH_SPACE_ALIGN:\n    96:                 while (newIndent.length() < column) {\n-   97:                     newIndent.append(IndentType.SPACES.car);\n+   97:                     newIndent.append(IndentType.SPACES.getCar());\n    98:                 }\n    99:                 break;\n   100: \n   101:             case TABS:\n-  102:                 IndentType currentIndentType = indentation.type; \n+  102:                 IndentType currentIndentType = indentation.getType(); \n   103:                 int logicalIndentLength = newIndent.length();\n-  104:                 while ((logicalIndentLength + currentIndentType.width) <= column) {\n-  105:                     newIndent.insert(0, currentIndentType.car);\n-  106:                     logicalIndentLength += currentIndentType.width;\n+  104:                 while ((logicalIndentLength + currentIndentType.getWidth()) <= column) {\n+  105:                     newIndent.insert(0, currentIndentType.getCar());\n+  106:                     logicalIndentLength += currentIndentType.getWidth();\n   107:                 }\n   108:                 while (logicalIndentLength < column) {\n-  109:                     newIndent.append(IndentType.SPACES.car);\n+  109:                     newIndent.append(IndentType.SPACES.getCar());\n   110:                     logicalIndentLength++;\n   111:                 }\n   112:                 StringBuilder fullTab = new StringBuilder();\n-  113:                 for(int i=0; i<currentIndentType.width; i++){\n-  114:                     fullTab.append(IndentType.SPACES.car);\n+  113:                 for(int i=0; i<currentIndentType.getWidth(); i++){\n+  114:                     fullTab.append(IndentType.SPACES.getCar());\n   115:                 }\n   116:                 String fullTabString = fullTab.toString();\n-  117:                 if ((newIndent.length() >= currentIndentType.width)\n-  118:                         && newIndent.substring(newIndent.length() - currentIndentType.width).equals(fullTabString)) {\n+  117:                 if ((newIndent.length() >= currentIndentType.getWidth())\n+  118:                         && newIndent.substring(newIndent.length() - currentIndentType.getWidth()).equals(fullTabString)) {\n   119:                     int i = newIndent.indexOf(fullTabString);\n-  120:                     newIndent.replace(i, i + currentIndentType.width, currentIndentType.car.toString());\n+  120:                     newIndent.replace(i, i + currentIndentType.getWidth(), currentIndentType.getCar().toString());\n   121:                 }\n   122:                 break;\n   123: \n   124:             default:\n   125:                 throw new AssertionError(\"Unhandled indent type\");\n   126:         }\n   127: \n   128:         return newIndent.toString();\n   129:     }\n",
        "uniqueId": "b08e66263903837d53a688b5d12a758c8cdf167e_87_129_53_55_87_129",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 26,
                "covered": 101
            },
            "BRANCH": {
                "missed": 4,
                "covered": 13
            },
            "LINE": {
                "missed": 5,
                "covered": 20
            },
            "COMPLEXITY": {
                "missed": 4,
                "covered": 6
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 1.8
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprivate assertOneRecordDeclaration(cu CompilationUnit) : void extracted from package record_mustAllowStaticFields() : void in class com.github.javaparser.ast.body.RecordDeclarationTest",
        "diffLocations": [
            {
                "filePath": "javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/RecordDeclarationTest.java",
                "startLine": 226,
                "endLine": 232,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/RecordDeclarationTest.java",
                "startLine": 231,
                "endLine": 236,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/RecordDeclarationTest.java",
                "startLine": 313,
                "endLine": 316,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "@Test\n    void record_mustAllowStaticFields() {\n        String s = \"record Point(int x, int y) { static int z; }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }",
        "filePathBefore": "javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/RecordDeclarationTest.java",
        "isPureRefactoring": true,
        "commitId": "a73aba7b8cef7c52666d25169a3f6e495c65bcd2",
        "packageNameBefore": "com.github.javaparser.ast.body",
        "classNameBefore": "com.github.javaparser.ast.body.RecordDeclarationTest",
        "methodNameBefore": "com.github.javaparser.ast.body.RecordDeclarationTest#record_mustAllowStaticFields",
        "classSignatureBefore": "public class RecordDeclarationTest ",
        "methodNameBeforeSet": [
            "com.github.javaparser.ast.body.RecordDeclarationTest#record_mustAllowStaticFields"
        ],
        "classNameBeforeSet": [
            "com.github.javaparser.ast.body.RecordDeclarationTest"
        ],
        "classSignatureBeforeSet": [
            "public class RecordDeclarationTest "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "package com.github.javaparser.ast.body;\n\nimport com.github.javaparser.ParserConfiguration;\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.Modifier;\nimport com.github.javaparser.ast.NodeList;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.EnumSource;\nimport org.opentest4j.AssertionFailedError;\n\nimport java.util.List;\n\nimport static com.github.javaparser.utils.TestParser.parseCompilationUnit;\nimport static com.github.javaparser.utils.TestUtils.assertEqualsStringIgnoringEol;\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\npublic class RecordDeclarationTest {\n\n    @ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_13\", \"JAVA_13_PREVIEW\", \"JAVA_14\", \"JAVA_15\"})\n    void basicGrammarCompiles_languageLevelValidation_forbidden(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"record Point(int x, int y) { }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(languageLevel, s);\n        });\n    }\n\n    @ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_14_PREVIEW\", \"JAVA_15_PREVIEW\", \"JAVA_16\", \"JAVA_16_PREVIEW\"})\n    void basicGrammarCompiles_languageLevelValidation_permitted(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(languageLevel, s);\n    }\n\n    @Test\n    void basicGrammarCompiles() {\n        /* https://openjdk.java.net/jeps/395#Description */\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    @Test\n    void basicGrammar() {\n        /* https://openjdk.java.net/jeps/395#Description */\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        assertTrue(recordDeclaration.isRecordDeclaration());\n        assertTrue(recordDeclaration.getImplementedTypes().isEmpty());\n        assertTrue(recordDeclaration.getTypeParameters().isEmpty());\n        assertTrue(recordDeclaration.getFullyQualifiedName().isPresent());\n        assertEquals(\"Point\", recordDeclaration.getFullyQualifiedName().get());\n        assertTrue(recordDeclaration.isRecordDeclaration());\n\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"x\", parameter0.getNameAsString());\n        assertEquals(\"int\", parameter0.getTypeAsString());\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"y\", parameter1.getNameAsString());\n        assertEquals(\"int\", parameter1.getTypeAsString());\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Description\n     */\n    @Test\n    void basicRecordPrints() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        String expected = \"\" +\n                \"record Point(int x, int y) {\\n\" +\n                \"}\\n\" +\n                \"\";\n        assertEqualsStringIgnoringEol(expected, cu.toString());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-record\n     */\n    @Test\n    void record_cannotExtend() {\n        String s = \"record Point(int x, int y) extends OtherThing { }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_cannotBeAbstract() {\n        String s = \"abstract record Point(int x, int y) { }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n    }\n\n    @Test\n    void recordWithVarArgs() {\n        String s = \"record R(T1 c1, Tn... cn){ }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"c1\", parameter0.getNameAsString());\n        assertEquals(\"T1\", parameter0.getTypeAsString());\n        assertFalse(parameter0.isVarArgs());\n\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"cn\", parameter1.getNameAsString());\n        assertEquals(\"Tn\", parameter1.getTypeAsString());\n        assertTrue(parameter1.isVarArgs());\n    }\n\n    @Test\n    void recordWithAnnotationedParameters() {\n        String s = \"record Card(@MyAnno Rank rank, @MyAnno Suit suit) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"rank\", parameter0.getNameAsString());\n        assertEquals(\"Rank\", parameter0.getTypeAsString());\n        assertEquals(1, parameter0.getAnnotations().size());\n\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"suit\", parameter1.getNameAsString());\n        assertEquals(\"Suit\", parameter1.getTypeAsString());\n        assertEquals(1, parameter1.getAnnotations().size());\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    @Test\n    void record_emptyMembers() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    @Test\n    void record_permitStaticFields() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    static int z;\\n\" +\n                \"\\n\" +\n                \"    static {\\n\" +\n                \"        int z = 10;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    @Test\n    void record_permitMethods() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    public String xyz() {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    @Test\n    void record_mustNotAllowNonStaticFields() {\n        String s = \"record Point(int x, int y) { int z; }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n    }\n\n    @Test\n    void record_mustAllowStaticFields() {\n        String s = \"record Point(int x, int y) { static int z; }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n\n    @Test\n    void record_mustNotAllowMismatchedComponentAccessorReturnType() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public String x() {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n\n    }\n\n    @Test\n    void record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public String x(int a) {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    @Test\n    void record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod2() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public int x(int a) {\\n\" +\n                \"        return 10;\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n\n    @Test\n    void record_allowComponentAccessorWithMatchingType() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return 10;\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    // https://bugs.openjdk.java.net/browse/JDK-8222777\n    @Test\n    void recordDeclarationFromTheJDK8222777() {\n        CompilationUnit cu = parseCompilationUnit(\"\" +\n                \"public record Range(int lo, int hi) {\\n\" +\n                \"\\n\" +\n                \"  public Range {\\n\" +\n                \"    if (lo > hi)  /* referring here to the implicit constructor parameters */\\n\" +\n                \"      throw new IllegalArgumentException(String.format(\\\"(%d,%d)\\\", lo, hi));\\n\" +\n                \"  }\\n\" +\n                \"}\"\n        );\n\n        RecordDeclaration record = cu.findFirst(RecordDeclaration.class).get();\n        assertThat(record.getNameAsString()).isEqualTo(\"Range\");\n        assertThat(record.getModifiers()).containsExactly(Modifier.publicModifier());\n        // test parameters\n        // get constructor\n        // test parameters (none)\n    }\n}\n",
        "filePathAfter": "javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/RecordDeclarationTest.java",
        "sourceCodeAfterForWhole": "package com.github.javaparser.ast.body;\n\nimport com.github.javaparser.ParserConfiguration;\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.Modifier;\nimport com.github.javaparser.ast.NodeList;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.EnumSource;\nimport org.opentest4j.AssertionFailedError;\n\nimport java.util.List;\n\nimport static com.github.javaparser.utils.TestParser.parseCompilationUnit;\nimport static com.github.javaparser.utils.TestUtils.assertEqualsStringIgnoringEol;\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\npublic class RecordDeclarationTest {\n\n    @ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_13\", \"JAVA_13_PREVIEW\", \"JAVA_14\", \"JAVA_15\"})\n    void basicGrammarCompiles_languageLevelValidation_forbidden(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"record Point(int x, int y) { }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(languageLevel, s);\n        });\n    }\n\n    @ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_14_PREVIEW\", \"JAVA_15_PREVIEW\", \"JAVA_16\", \"JAVA_16_PREVIEW\"})\n    void basicGrammarCompiles_languageLevelValidation_permitted(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(languageLevel, s);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Description\n     */\n    @Test\n    void basicGrammarCompiles() {\n        String s = \"record Point(int x, int y) { }\";\n        assertOneRecordDeclaration(parseCompilationUnit(s));\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Description\n     */\n    @Test\n    void basicGrammar() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        RecordDeclaration recordDeclaration = cu.findAll(RecordDeclaration.class).get(0);\n\n        assertTrue(recordDeclaration.isRecordDeclaration());\n        assertTrue(recordDeclaration.getImplementedTypes().isEmpty());\n        assertTrue(recordDeclaration.getTypeParameters().isEmpty());\n        assertTrue(recordDeclaration.getFullyQualifiedName().isPresent());\n        assertEquals(\"Point\", recordDeclaration.getFullyQualifiedName().get());\n        assertTrue(recordDeclaration.isRecordDeclaration());\n\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"x\", parameter0.getNameAsString());\n        assertEquals(\"int\", parameter0.getTypeAsString());\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"y\", parameter1.getNameAsString());\n        assertEquals(\"int\", parameter1.getTypeAsString());\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Description\n     */\n    @Test\n    void basicRecordPrints() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        String expected = \"\" +\n                \"record Point(int x, int y) {\\n\" +\n                \"}\\n\" +\n                \"\";\n        assertEqualsStringIgnoringEol(expected, cu.toString());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-record\n     */\n    @Test\n    void record_cannotExtend() {\n        String s = \"record Point(int x, int y) extends OtherThing { }\";\n        assertCompilationFails(s);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_cannotBeAbstract() {\n        String s = \"abstract record Point(int x, int y) { }\";\n        assertCompilationFails(s);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_mayImplementInterfaces() {\n        String s = \"record Point(int x, int y) implements OtherInterface { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void recordWithVarArgs() {\n        String s = \"record R(T1 c1, Tn... cn){ }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"c1\", parameter0.getNameAsString());\n        assertEquals(\"T1\", parameter0.getTypeAsString());\n        assertFalse(parameter0.isVarArgs());\n\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"cn\", parameter1.getNameAsString());\n        assertEquals(\"Tn\", parameter1.getTypeAsString());\n        assertTrue(parameter1.isVarArgs());\n    }\n\n    @Test\n    void recordWithAnnotationedParameters() {\n        String s = \"record Card(@MyAnno Rank rank, @MyAnno Suit suit) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"rank\", parameter0.getNameAsString());\n        assertEquals(\"Rank\", parameter0.getTypeAsString());\n        assertEquals(1, parameter0.getAnnotations().size());\n\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"suit\", parameter1.getNameAsString());\n        assertEquals(\"Suit\", parameter1.getTypeAsString());\n        assertEquals(1, parameter1.getAnnotations().size());\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    @Test\n    void record_emptyMembers() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    @Test\n    void record_permitStaticFields() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    static int z;\\n\" +\n                \"\\n\" +\n                \"    static {\\n\" +\n                \"        int z = 10;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_permitMethods() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    public String xyz() {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_mustNotAllowNonStaticFields() {\n        String s = \"record Point(int x, int y) { int z; }\";\n        assertCompilationFails(s);\n    }\n\n    @Test\n    void record_mustAllowStaticFields() {\n        String s = \"record Point(int x, int y) { static int z; }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n\n    @Test\n    void record_mustNotAllowMismatchedComponentAccessorReturnType() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public String x() {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \" }\";\n        assertCompilationFails(s);\n    }\n\n    @Test\n    void record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public String x(int a) {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod2() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public int x(int a) {\\n\" +\n                \"        return 10;\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_allowComponentAccessorWithMatchingType() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return 10;\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    // https://bugs.openjdk.java.net/browse/JDK-8222777\n    @Test\n    void recordDeclarationFromTheJDK8222777() {\n        CompilationUnit cu = parseCompilationUnit(\"\" +\n                \"public record Range(int lo, int hi) {\\n\" +\n                \"\\n\" +\n                \"  public Range {\\n\" +\n                \"    if (lo > hi)  /* referring here to the implicit constructor parameters */\\n\" +\n                \"      throw new IllegalArgumentException(String.format(\\\"(%d,%d)\\\", lo, hi));\\n\" +\n                \"  }\\n\" +\n                \"}\"\n        );\n\n        RecordDeclaration record = cu.findFirst(RecordDeclaration.class).get();\n        assertThat(record.getNameAsString()).isEqualTo(\"Range\");\n        assertThat(record.getModifiers()).containsExactly(Modifier.publicModifier());\n        // test parameters\n        // get constructor\n        // test parameters (none)\n    }\n\n\n    private void assertCompilationFails(String s) {\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n    }\n\n    private void assertOneRecordDeclaration(CompilationUnit cu) {\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n}\n",
        "diffSourceCodeSet": [
            "private void assertOneRecordDeclaration(CompilationUnit cu) {\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }"
        ],
        "invokedMethodSet": [],
        "sourceCodeAfterRefactoring": "@Test\n    void record_mustAllowStaticFields() {\n        String s = \"record Point(int x, int y) { static int z; }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\nprivate void assertOneRecordDeclaration(CompilationUnit cu) {\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }",
        "diffSourceCode": "-  226:     @Test\n-  227:     void record_mustAllowStaticFields() {\n-  228:         String s = \"record Point(int x, int y) { static int z; }\";\n-  229:         CompilationUnit cu = parseCompilationUnit(s);\n-  230:         List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n-  231:         assertEquals(1, recordDeclarations.size());\n-  232:     }\n-  233: \n-  234: \n-  235:     @Test\n-  236:     void record_mustNotAllowMismatchedComponentAccessorReturnType() {\n+  226:     void record_mustNotAllowNonStaticFields() {\n+  227:         String s = \"record Point(int x, int y) { int z; }\";\n+  228:         assertCompilationFails(s);\n+  229:     }\n+  230: \n+  231:     @Test\n+  232:     void record_mustAllowStaticFields() {\n+  233:         String s = \"record Point(int x, int y) { static int z; }\";\n+  234:         CompilationUnit cu = parseCompilationUnit(s);\n+  235:         assertOneRecordDeclaration(cu);\n+  236:     }\n+  313:     private void assertOneRecordDeclaration(CompilationUnit cu) {\n+  314:         List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n+  315:         assertEquals(1, recordDeclarations.size());\n+  316:     }\n",
        "uniqueId": "a73aba7b8cef7c52666d25169a3f6e495c65bcd2_226_232_313_316_231_236",
        "moveFileExist": true,
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 1.8,
        "testResult": true,
        "coverageInfo": {
            "testMethod": {
                "missed": 0,
                "covered": 1
            }
        }
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprivate assertCompilationFails(s String) : void extracted from package record_mustNotAllowNonStaticFields() : void in class com.github.javaparser.ast.body.RecordDeclarationTest",
        "diffLocations": [
            {
                "filePath": "javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/RecordDeclarationTest.java",
                "startLine": 218,
                "endLine": 224,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/RecordDeclarationTest.java",
                "startLine": 225,
                "endLine": 229,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/RecordDeclarationTest.java",
                "startLine": 307,
                "endLine": 311,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "@Test\n    void record_mustNotAllowNonStaticFields() {\n        String s = \"record Point(int x, int y) { int z; }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n    }",
        "filePathBefore": "javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/RecordDeclarationTest.java",
        "isPureRefactoring": true,
        "commitId": "a73aba7b8cef7c52666d25169a3f6e495c65bcd2",
        "packageNameBefore": "com.github.javaparser.ast.body",
        "classNameBefore": "com.github.javaparser.ast.body.RecordDeclarationTest",
        "methodNameBefore": "com.github.javaparser.ast.body.RecordDeclarationTest#record_mustNotAllowNonStaticFields",
        "classSignatureBefore": "public class RecordDeclarationTest ",
        "methodNameBeforeSet": [
            "com.github.javaparser.ast.body.RecordDeclarationTest#record_mustNotAllowNonStaticFields"
        ],
        "classNameBeforeSet": [
            "com.github.javaparser.ast.body.RecordDeclarationTest"
        ],
        "classSignatureBeforeSet": [
            "public class RecordDeclarationTest "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "package com.github.javaparser.ast.body;\n\nimport com.github.javaparser.ParserConfiguration;\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.Modifier;\nimport com.github.javaparser.ast.NodeList;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.EnumSource;\nimport org.opentest4j.AssertionFailedError;\n\nimport java.util.List;\n\nimport static com.github.javaparser.utils.TestParser.parseCompilationUnit;\nimport static com.github.javaparser.utils.TestUtils.assertEqualsStringIgnoringEol;\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\npublic class RecordDeclarationTest {\n\n    @ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_13\", \"JAVA_13_PREVIEW\", \"JAVA_14\", \"JAVA_15\"})\n    void basicGrammarCompiles_languageLevelValidation_forbidden(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"record Point(int x, int y) { }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(languageLevel, s);\n        });\n    }\n\n    @ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_14_PREVIEW\", \"JAVA_15_PREVIEW\", \"JAVA_16\", \"JAVA_16_PREVIEW\"})\n    void basicGrammarCompiles_languageLevelValidation_permitted(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(languageLevel, s);\n    }\n\n    @Test\n    void basicGrammarCompiles() {\n        /* https://openjdk.java.net/jeps/395#Description */\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    @Test\n    void basicGrammar() {\n        /* https://openjdk.java.net/jeps/395#Description */\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        assertTrue(recordDeclaration.isRecordDeclaration());\n        assertTrue(recordDeclaration.getImplementedTypes().isEmpty());\n        assertTrue(recordDeclaration.getTypeParameters().isEmpty());\n        assertTrue(recordDeclaration.getFullyQualifiedName().isPresent());\n        assertEquals(\"Point\", recordDeclaration.getFullyQualifiedName().get());\n        assertTrue(recordDeclaration.isRecordDeclaration());\n\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"x\", parameter0.getNameAsString());\n        assertEquals(\"int\", parameter0.getTypeAsString());\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"y\", parameter1.getNameAsString());\n        assertEquals(\"int\", parameter1.getTypeAsString());\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Description\n     */\n    @Test\n    void basicRecordPrints() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        String expected = \"\" +\n                \"record Point(int x, int y) {\\n\" +\n                \"}\\n\" +\n                \"\";\n        assertEqualsStringIgnoringEol(expected, cu.toString());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-record\n     */\n    @Test\n    void record_cannotExtend() {\n        String s = \"record Point(int x, int y) extends OtherThing { }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_cannotBeAbstract() {\n        String s = \"abstract record Point(int x, int y) { }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n    }\n\n    @Test\n    void recordWithVarArgs() {\n        String s = \"record R(T1 c1, Tn... cn){ }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"c1\", parameter0.getNameAsString());\n        assertEquals(\"T1\", parameter0.getTypeAsString());\n        assertFalse(parameter0.isVarArgs());\n\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"cn\", parameter1.getNameAsString());\n        assertEquals(\"Tn\", parameter1.getTypeAsString());\n        assertTrue(parameter1.isVarArgs());\n    }\n\n    @Test\n    void recordWithAnnotationedParameters() {\n        String s = \"record Card(@MyAnno Rank rank, @MyAnno Suit suit) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"rank\", parameter0.getNameAsString());\n        assertEquals(\"Rank\", parameter0.getTypeAsString());\n        assertEquals(1, parameter0.getAnnotations().size());\n\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"suit\", parameter1.getNameAsString());\n        assertEquals(\"Suit\", parameter1.getTypeAsString());\n        assertEquals(1, parameter1.getAnnotations().size());\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    @Test\n    void record_emptyMembers() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    @Test\n    void record_permitStaticFields() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    static int z;\\n\" +\n                \"\\n\" +\n                \"    static {\\n\" +\n                \"        int z = 10;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    @Test\n    void record_permitMethods() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    public String xyz() {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    @Test\n    void record_mustNotAllowNonStaticFields() {\n        String s = \"record Point(int x, int y) { int z; }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n    }\n\n    @Test\n    void record_mustAllowStaticFields() {\n        String s = \"record Point(int x, int y) { static int z; }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n\n    @Test\n    void record_mustNotAllowMismatchedComponentAccessorReturnType() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public String x() {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n\n    }\n\n    @Test\n    void record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public String x(int a) {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    @Test\n    void record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod2() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public int x(int a) {\\n\" +\n                \"        return 10;\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n\n    @Test\n    void record_allowComponentAccessorWithMatchingType() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return 10;\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    // https://bugs.openjdk.java.net/browse/JDK-8222777\n    @Test\n    void recordDeclarationFromTheJDK8222777() {\n        CompilationUnit cu = parseCompilationUnit(\"\" +\n                \"public record Range(int lo, int hi) {\\n\" +\n                \"\\n\" +\n                \"  public Range {\\n\" +\n                \"    if (lo > hi)  /* referring here to the implicit constructor parameters */\\n\" +\n                \"      throw new IllegalArgumentException(String.format(\\\"(%d,%d)\\\", lo, hi));\\n\" +\n                \"  }\\n\" +\n                \"}\"\n        );\n\n        RecordDeclaration record = cu.findFirst(RecordDeclaration.class).get();\n        assertThat(record.getNameAsString()).isEqualTo(\"Range\");\n        assertThat(record.getModifiers()).containsExactly(Modifier.publicModifier());\n        // test parameters\n        // get constructor\n        // test parameters (none)\n    }\n}\n",
        "filePathAfter": "javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/RecordDeclarationTest.java",
        "sourceCodeAfterForWhole": "package com.github.javaparser.ast.body;\n\nimport com.github.javaparser.ParserConfiguration;\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.Modifier;\nimport com.github.javaparser.ast.NodeList;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.EnumSource;\nimport org.opentest4j.AssertionFailedError;\n\nimport java.util.List;\n\nimport static com.github.javaparser.utils.TestParser.parseCompilationUnit;\nimport static com.github.javaparser.utils.TestUtils.assertEqualsStringIgnoringEol;\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\npublic class RecordDeclarationTest {\n\n    @ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_13\", \"JAVA_13_PREVIEW\", \"JAVA_14\", \"JAVA_15\"})\n    void basicGrammarCompiles_languageLevelValidation_forbidden(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"record Point(int x, int y) { }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(languageLevel, s);\n        });\n    }\n\n    @ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_14_PREVIEW\", \"JAVA_15_PREVIEW\", \"JAVA_16\", \"JAVA_16_PREVIEW\"})\n    void basicGrammarCompiles_languageLevelValidation_permitted(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(languageLevel, s);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Description\n     */\n    @Test\n    void basicGrammarCompiles() {\n        String s = \"record Point(int x, int y) { }\";\n        assertOneRecordDeclaration(parseCompilationUnit(s));\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Description\n     */\n    @Test\n    void basicGrammar() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        RecordDeclaration recordDeclaration = cu.findAll(RecordDeclaration.class).get(0);\n\n        assertTrue(recordDeclaration.isRecordDeclaration());\n        assertTrue(recordDeclaration.getImplementedTypes().isEmpty());\n        assertTrue(recordDeclaration.getTypeParameters().isEmpty());\n        assertTrue(recordDeclaration.getFullyQualifiedName().isPresent());\n        assertEquals(\"Point\", recordDeclaration.getFullyQualifiedName().get());\n        assertTrue(recordDeclaration.isRecordDeclaration());\n\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"x\", parameter0.getNameAsString());\n        assertEquals(\"int\", parameter0.getTypeAsString());\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"y\", parameter1.getNameAsString());\n        assertEquals(\"int\", parameter1.getTypeAsString());\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Description\n     */\n    @Test\n    void basicRecordPrints() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        String expected = \"\" +\n                \"record Point(int x, int y) {\\n\" +\n                \"}\\n\" +\n                \"\";\n        assertEqualsStringIgnoringEol(expected, cu.toString());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-record\n     */\n    @Test\n    void record_cannotExtend() {\n        String s = \"record Point(int x, int y) extends OtherThing { }\";\n        assertCompilationFails(s);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_cannotBeAbstract() {\n        String s = \"abstract record Point(int x, int y) { }\";\n        assertCompilationFails(s);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_mayImplementInterfaces() {\n        String s = \"record Point(int x, int y) implements OtherInterface { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void recordWithVarArgs() {\n        String s = \"record R(T1 c1, Tn... cn){ }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"c1\", parameter0.getNameAsString());\n        assertEquals(\"T1\", parameter0.getTypeAsString());\n        assertFalse(parameter0.isVarArgs());\n\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"cn\", parameter1.getNameAsString());\n        assertEquals(\"Tn\", parameter1.getTypeAsString());\n        assertTrue(parameter1.isVarArgs());\n    }\n\n    @Test\n    void recordWithAnnotationedParameters() {\n        String s = \"record Card(@MyAnno Rank rank, @MyAnno Suit suit) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"rank\", parameter0.getNameAsString());\n        assertEquals(\"Rank\", parameter0.getTypeAsString());\n        assertEquals(1, parameter0.getAnnotations().size());\n\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"suit\", parameter1.getNameAsString());\n        assertEquals(\"Suit\", parameter1.getTypeAsString());\n        assertEquals(1, parameter1.getAnnotations().size());\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    @Test\n    void record_emptyMembers() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    @Test\n    void record_permitStaticFields() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    static int z;\\n\" +\n                \"\\n\" +\n                \"    static {\\n\" +\n                \"        int z = 10;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_permitMethods() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    public String xyz() {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_mustNotAllowNonStaticFields() {\n        String s = \"record Point(int x, int y) { int z; }\";\n        assertCompilationFails(s);\n    }\n\n    @Test\n    void record_mustAllowStaticFields() {\n        String s = \"record Point(int x, int y) { static int z; }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n\n    @Test\n    void record_mustNotAllowMismatchedComponentAccessorReturnType() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public String x() {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \" }\";\n        assertCompilationFails(s);\n    }\n\n    @Test\n    void record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public String x(int a) {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod2() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public int x(int a) {\\n\" +\n                \"        return 10;\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_allowComponentAccessorWithMatchingType() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return 10;\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    // https://bugs.openjdk.java.net/browse/JDK-8222777\n    @Test\n    void recordDeclarationFromTheJDK8222777() {\n        CompilationUnit cu = parseCompilationUnit(\"\" +\n                \"public record Range(int lo, int hi) {\\n\" +\n                \"\\n\" +\n                \"  public Range {\\n\" +\n                \"    if (lo > hi)  /* referring here to the implicit constructor parameters */\\n\" +\n                \"      throw new IllegalArgumentException(String.format(\\\"(%d,%d)\\\", lo, hi));\\n\" +\n                \"  }\\n\" +\n                \"}\"\n        );\n\n        RecordDeclaration record = cu.findFirst(RecordDeclaration.class).get();\n        assertThat(record.getNameAsString()).isEqualTo(\"Range\");\n        assertThat(record.getModifiers()).containsExactly(Modifier.publicModifier());\n        // test parameters\n        // get constructor\n        // test parameters (none)\n    }\n\n\n    private void assertCompilationFails(String s) {\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n    }\n\n    private void assertOneRecordDeclaration(CompilationUnit cu) {\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n}\n",
        "diffSourceCodeSet": [
            "private void assertCompilationFails(String s) {\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n    }"
        ],
        "invokedMethodSet": [],
        "sourceCodeAfterRefactoring": "@Test\n    void record_mustNotAllowNonStaticFields() {\n        String s = \"record Point(int x, int y) { int z; }\";\n        assertCompilationFails(s);\n    }\nprivate void assertCompilationFails(String s) {\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n    }",
        "diffSourceCode": "-  218:     @Test\n-  219:     void record_mustNotAllowNonStaticFields() {\n-  220:         String s = \"record Point(int x, int y) { int z; }\";\n-  221:         assertThrows(AssertionFailedError.class, () -> {\n-  222:             CompilationUnit cu = parseCompilationUnit(s);\n-  223:         });\n-  224:     }\n-  225: \n-  226:     @Test\n-  227:     void record_mustAllowStaticFields() {\n-  228:         String s = \"record Point(int x, int y) { static int z; }\";\n-  229:         CompilationUnit cu = parseCompilationUnit(s);\n-  307:         // test parameters (none)\n-  308:     }\n-  309: }\n+  218:                 \"\\n\" +\n+  219:                 \"}\\n\" +\n+  220:                 \"\";\n+  221:         CompilationUnit cu = parseCompilationUnit(s);\n+  222:         assertOneRecordDeclaration(cu);\n+  223:     }\n+  224: \n+  225:     @Test\n+  226:     void record_mustNotAllowNonStaticFields() {\n+  227:         String s = \"record Point(int x, int y) { int z; }\";\n+  228:         assertCompilationFails(s);\n+  229:     }\n+  307:     private void assertCompilationFails(String s) {\n+  308:         assertThrows(AssertionFailedError.class, () -> {\n+  309:             CompilationUnit cu = parseCompilationUnit(s);\n+  310:         });\n+  311:     }\n",
        "uniqueId": "a73aba7b8cef7c52666d25169a3f6e495c65bcd2_218_224_307_311_225_229",
        "moveFileExist": true,
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 1.8,
        "testResult": true,
        "coverageInfo": {
            "testMethod": {
                "missed": 0,
                "covered": 1
            }
        }
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprivate assertOneRecordDeclaration(cu CompilationUnit) : void extracted from package record_permitMethods() : void in class com.github.javaparser.ast.body.RecordDeclarationTest",
        "diffLocations": [
            {
                "filePath": "javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/RecordDeclarationTest.java",
                "startLine": 198,
                "endLine": 216,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/RecordDeclarationTest.java",
                "startLine": 206,
                "endLine": 223,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/RecordDeclarationTest.java",
                "startLine": 313,
                "endLine": 316,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "@Test\n    void record_permitMethods() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    public String xyz() {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }",
        "filePathBefore": "javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/RecordDeclarationTest.java",
        "isPureRefactoring": true,
        "commitId": "a73aba7b8cef7c52666d25169a3f6e495c65bcd2",
        "packageNameBefore": "com.github.javaparser.ast.body",
        "classNameBefore": "com.github.javaparser.ast.body.RecordDeclarationTest",
        "methodNameBefore": "com.github.javaparser.ast.body.RecordDeclarationTest#record_permitMethods",
        "classSignatureBefore": "public class RecordDeclarationTest ",
        "methodNameBeforeSet": [
            "com.github.javaparser.ast.body.RecordDeclarationTest#record_permitMethods"
        ],
        "classNameBeforeSet": [
            "com.github.javaparser.ast.body.RecordDeclarationTest"
        ],
        "classSignatureBeforeSet": [
            "public class RecordDeclarationTest "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "package com.github.javaparser.ast.body;\n\nimport com.github.javaparser.ParserConfiguration;\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.Modifier;\nimport com.github.javaparser.ast.NodeList;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.EnumSource;\nimport org.opentest4j.AssertionFailedError;\n\nimport java.util.List;\n\nimport static com.github.javaparser.utils.TestParser.parseCompilationUnit;\nimport static com.github.javaparser.utils.TestUtils.assertEqualsStringIgnoringEol;\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\npublic class RecordDeclarationTest {\n\n    @ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_13\", \"JAVA_13_PREVIEW\", \"JAVA_14\", \"JAVA_15\"})\n    void basicGrammarCompiles_languageLevelValidation_forbidden(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"record Point(int x, int y) { }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(languageLevel, s);\n        });\n    }\n\n    @ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_14_PREVIEW\", \"JAVA_15_PREVIEW\", \"JAVA_16\", \"JAVA_16_PREVIEW\"})\n    void basicGrammarCompiles_languageLevelValidation_permitted(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(languageLevel, s);\n    }\n\n    @Test\n    void basicGrammarCompiles() {\n        /* https://openjdk.java.net/jeps/395#Description */\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    @Test\n    void basicGrammar() {\n        /* https://openjdk.java.net/jeps/395#Description */\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        assertTrue(recordDeclaration.isRecordDeclaration());\n        assertTrue(recordDeclaration.getImplementedTypes().isEmpty());\n        assertTrue(recordDeclaration.getTypeParameters().isEmpty());\n        assertTrue(recordDeclaration.getFullyQualifiedName().isPresent());\n        assertEquals(\"Point\", recordDeclaration.getFullyQualifiedName().get());\n        assertTrue(recordDeclaration.isRecordDeclaration());\n\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"x\", parameter0.getNameAsString());\n        assertEquals(\"int\", parameter0.getTypeAsString());\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"y\", parameter1.getNameAsString());\n        assertEquals(\"int\", parameter1.getTypeAsString());\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Description\n     */\n    @Test\n    void basicRecordPrints() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        String expected = \"\" +\n                \"record Point(int x, int y) {\\n\" +\n                \"}\\n\" +\n                \"\";\n        assertEqualsStringIgnoringEol(expected, cu.toString());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-record\n     */\n    @Test\n    void record_cannotExtend() {\n        String s = \"record Point(int x, int y) extends OtherThing { }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_cannotBeAbstract() {\n        String s = \"abstract record Point(int x, int y) { }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n    }\n\n    @Test\n    void recordWithVarArgs() {\n        String s = \"record R(T1 c1, Tn... cn){ }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"c1\", parameter0.getNameAsString());\n        assertEquals(\"T1\", parameter0.getTypeAsString());\n        assertFalse(parameter0.isVarArgs());\n\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"cn\", parameter1.getNameAsString());\n        assertEquals(\"Tn\", parameter1.getTypeAsString());\n        assertTrue(parameter1.isVarArgs());\n    }\n\n    @Test\n    void recordWithAnnotationedParameters() {\n        String s = \"record Card(@MyAnno Rank rank, @MyAnno Suit suit) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"rank\", parameter0.getNameAsString());\n        assertEquals(\"Rank\", parameter0.getTypeAsString());\n        assertEquals(1, parameter0.getAnnotations().size());\n\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"suit\", parameter1.getNameAsString());\n        assertEquals(\"Suit\", parameter1.getTypeAsString());\n        assertEquals(1, parameter1.getAnnotations().size());\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    @Test\n    void record_emptyMembers() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    @Test\n    void record_permitStaticFields() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    static int z;\\n\" +\n                \"\\n\" +\n                \"    static {\\n\" +\n                \"        int z = 10;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    @Test\n    void record_permitMethods() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    public String xyz() {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    @Test\n    void record_mustNotAllowNonStaticFields() {\n        String s = \"record Point(int x, int y) { int z; }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n    }\n\n    @Test\n    void record_mustAllowStaticFields() {\n        String s = \"record Point(int x, int y) { static int z; }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n\n    @Test\n    void record_mustNotAllowMismatchedComponentAccessorReturnType() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public String x() {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n\n    }\n\n    @Test\n    void record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public String x(int a) {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    @Test\n    void record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod2() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public int x(int a) {\\n\" +\n                \"        return 10;\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n\n    @Test\n    void record_allowComponentAccessorWithMatchingType() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return 10;\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    // https://bugs.openjdk.java.net/browse/JDK-8222777\n    @Test\n    void recordDeclarationFromTheJDK8222777() {\n        CompilationUnit cu = parseCompilationUnit(\"\" +\n                \"public record Range(int lo, int hi) {\\n\" +\n                \"\\n\" +\n                \"  public Range {\\n\" +\n                \"    if (lo > hi)  /* referring here to the implicit constructor parameters */\\n\" +\n                \"      throw new IllegalArgumentException(String.format(\\\"(%d,%d)\\\", lo, hi));\\n\" +\n                \"  }\\n\" +\n                \"}\"\n        );\n\n        RecordDeclaration record = cu.findFirst(RecordDeclaration.class).get();\n        assertThat(record.getNameAsString()).isEqualTo(\"Range\");\n        assertThat(record.getModifiers()).containsExactly(Modifier.publicModifier());\n        // test parameters\n        // get constructor\n        // test parameters (none)\n    }\n}\n",
        "filePathAfter": "javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/RecordDeclarationTest.java",
        "sourceCodeAfterForWhole": "package com.github.javaparser.ast.body;\n\nimport com.github.javaparser.ParserConfiguration;\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.Modifier;\nimport com.github.javaparser.ast.NodeList;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.EnumSource;\nimport org.opentest4j.AssertionFailedError;\n\nimport java.util.List;\n\nimport static com.github.javaparser.utils.TestParser.parseCompilationUnit;\nimport static com.github.javaparser.utils.TestUtils.assertEqualsStringIgnoringEol;\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\npublic class RecordDeclarationTest {\n\n    @ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_13\", \"JAVA_13_PREVIEW\", \"JAVA_14\", \"JAVA_15\"})\n    void basicGrammarCompiles_languageLevelValidation_forbidden(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"record Point(int x, int y) { }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(languageLevel, s);\n        });\n    }\n\n    @ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_14_PREVIEW\", \"JAVA_15_PREVIEW\", \"JAVA_16\", \"JAVA_16_PREVIEW\"})\n    void basicGrammarCompiles_languageLevelValidation_permitted(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(languageLevel, s);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Description\n     */\n    @Test\n    void basicGrammarCompiles() {\n        String s = \"record Point(int x, int y) { }\";\n        assertOneRecordDeclaration(parseCompilationUnit(s));\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Description\n     */\n    @Test\n    void basicGrammar() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        RecordDeclaration recordDeclaration = cu.findAll(RecordDeclaration.class).get(0);\n\n        assertTrue(recordDeclaration.isRecordDeclaration());\n        assertTrue(recordDeclaration.getImplementedTypes().isEmpty());\n        assertTrue(recordDeclaration.getTypeParameters().isEmpty());\n        assertTrue(recordDeclaration.getFullyQualifiedName().isPresent());\n        assertEquals(\"Point\", recordDeclaration.getFullyQualifiedName().get());\n        assertTrue(recordDeclaration.isRecordDeclaration());\n\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"x\", parameter0.getNameAsString());\n        assertEquals(\"int\", parameter0.getTypeAsString());\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"y\", parameter1.getNameAsString());\n        assertEquals(\"int\", parameter1.getTypeAsString());\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Description\n     */\n    @Test\n    void basicRecordPrints() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        String expected = \"\" +\n                \"record Point(int x, int y) {\\n\" +\n                \"}\\n\" +\n                \"\";\n        assertEqualsStringIgnoringEol(expected, cu.toString());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-record\n     */\n    @Test\n    void record_cannotExtend() {\n        String s = \"record Point(int x, int y) extends OtherThing { }\";\n        assertCompilationFails(s);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_cannotBeAbstract() {\n        String s = \"abstract record Point(int x, int y) { }\";\n        assertCompilationFails(s);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_mayImplementInterfaces() {\n        String s = \"record Point(int x, int y) implements OtherInterface { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void recordWithVarArgs() {\n        String s = \"record R(T1 c1, Tn... cn){ }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"c1\", parameter0.getNameAsString());\n        assertEquals(\"T1\", parameter0.getTypeAsString());\n        assertFalse(parameter0.isVarArgs());\n\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"cn\", parameter1.getNameAsString());\n        assertEquals(\"Tn\", parameter1.getTypeAsString());\n        assertTrue(parameter1.isVarArgs());\n    }\n\n    @Test\n    void recordWithAnnotationedParameters() {\n        String s = \"record Card(@MyAnno Rank rank, @MyAnno Suit suit) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"rank\", parameter0.getNameAsString());\n        assertEquals(\"Rank\", parameter0.getTypeAsString());\n        assertEquals(1, parameter0.getAnnotations().size());\n\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"suit\", parameter1.getNameAsString());\n        assertEquals(\"Suit\", parameter1.getTypeAsString());\n        assertEquals(1, parameter1.getAnnotations().size());\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    @Test\n    void record_emptyMembers() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    @Test\n    void record_permitStaticFields() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    static int z;\\n\" +\n                \"\\n\" +\n                \"    static {\\n\" +\n                \"        int z = 10;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_permitMethods() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    public String xyz() {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_mustNotAllowNonStaticFields() {\n        String s = \"record Point(int x, int y) { int z; }\";\n        assertCompilationFails(s);\n    }\n\n    @Test\n    void record_mustAllowStaticFields() {\n        String s = \"record Point(int x, int y) { static int z; }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n\n    @Test\n    void record_mustNotAllowMismatchedComponentAccessorReturnType() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public String x() {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \" }\";\n        assertCompilationFails(s);\n    }\n\n    @Test\n    void record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public String x(int a) {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod2() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public int x(int a) {\\n\" +\n                \"        return 10;\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_allowComponentAccessorWithMatchingType() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return 10;\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    // https://bugs.openjdk.java.net/browse/JDK-8222777\n    @Test\n    void recordDeclarationFromTheJDK8222777() {\n        CompilationUnit cu = parseCompilationUnit(\"\" +\n                \"public record Range(int lo, int hi) {\\n\" +\n                \"\\n\" +\n                \"  public Range {\\n\" +\n                \"    if (lo > hi)  /* referring here to the implicit constructor parameters */\\n\" +\n                \"      throw new IllegalArgumentException(String.format(\\\"(%d,%d)\\\", lo, hi));\\n\" +\n                \"  }\\n\" +\n                \"}\"\n        );\n\n        RecordDeclaration record = cu.findFirst(RecordDeclaration.class).get();\n        assertThat(record.getNameAsString()).isEqualTo(\"Range\");\n        assertThat(record.getModifiers()).containsExactly(Modifier.publicModifier());\n        // test parameters\n        // get constructor\n        // test parameters (none)\n    }\n\n\n    private void assertCompilationFails(String s) {\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n    }\n\n    private void assertOneRecordDeclaration(CompilationUnit cu) {\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n}\n",
        "diffSourceCodeSet": [
            "private void assertOneRecordDeclaration(CompilationUnit cu) {\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }"
        ],
        "invokedMethodSet": [],
        "sourceCodeAfterRefactoring": "@Test\n    void record_permitMethods() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    public String xyz() {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\nprivate void assertOneRecordDeclaration(CompilationUnit cu) {\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }",
        "diffSourceCode": "-  198:     @Test\n-  199:     void record_permitMethods() {\n-  200:         String s = \"\" +\n-  201:                 \"record ABC(int x, int y) {\\n\" +\n-  202:                 \"\\n\" +\n-  203:                 \"    public int x() {\\n\" +\n-  204:                 \"        return x;\\n\" +\n-  205:                 \"    }\\n\" +\n-  206:                 \"\\n\" +\n-  207:                 \"    public String xyz() {\\n\" +\n-  208:                 \"        return \\\"10\\\";\\n\" +\n-  209:                 \"    }\\n\" +\n+  198:                 \"    }\\n\" +\n+  199:                 \"\\n\" +\n+  200:                 \"}\\n\" +\n+  201:                 \"\";\n+  202:         CompilationUnit cu = parseCompilationUnit(s);\n+  203:         assertOneRecordDeclaration(cu);\n+  204:     }\n+  205: \n+  206:     @Test\n+  207:     void record_permitMethods() {\n+  208:         String s = \"\" +\n+  209:                 \"record ABC(int x, int y) {\\n\" +\n   210:                 \"\\n\" +\n-  211:                 \"}\\n\" +\n-  212:                 \"\";\n-  213:         CompilationUnit cu = parseCompilationUnit(s);\n-  214:         List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n-  215:         assertEquals(1, recordDeclarations.size());\n-  216:     }\n-  217: \n-  218:     @Test\n-  219:     void record_mustNotAllowNonStaticFields() {\n-  220:         String s = \"record Point(int x, int y) { int z; }\";\n-  221:         assertThrows(AssertionFailedError.class, () -> {\n-  222:             CompilationUnit cu = parseCompilationUnit(s);\n-  223:         });\n+  211:                 \"    public int x() {\\n\" +\n+  212:                 \"        return x;\\n\" +\n+  213:                 \"    }\\n\" +\n+  214:                 \"\\n\" +\n+  215:                 \"    public String xyz() {\\n\" +\n+  216:                 \"        return \\\"10\\\";\\n\" +\n+  217:                 \"    }\\n\" +\n+  218:                 \"\\n\" +\n+  219:                 \"}\\n\" +\n+  220:                 \"\";\n+  221:         CompilationUnit cu = parseCompilationUnit(s);\n+  222:         assertOneRecordDeclaration(cu);\n+  223:     }\n+  313:     private void assertOneRecordDeclaration(CompilationUnit cu) {\n+  314:         List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n+  315:         assertEquals(1, recordDeclarations.size());\n+  316:     }\n",
        "uniqueId": "a73aba7b8cef7c52666d25169a3f6e495c65bcd2_198_216_313_316_206_223",
        "moveFileExist": true,
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 1.8,
        "testResult": true,
        "coverageInfo": {
            "testMethod": {
                "missed": 0,
                "covered": 1
            }
        }
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprivate assertOneRecordDeclaration(cu CompilationUnit) : void extracted from package record_permitStaticFields() : void in class com.github.javaparser.ast.body.RecordDeclarationTest",
        "diffLocations": [
            {
                "filePath": "javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/RecordDeclarationTest.java",
                "startLine": 176,
                "endLine": 196,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/RecordDeclarationTest.java",
                "startLine": 185,
                "endLine": 204,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/RecordDeclarationTest.java",
                "startLine": 313,
                "endLine": 316,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "@Test\n    void record_permitStaticFields() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    static int z;\\n\" +\n                \"\\n\" +\n                \"    static {\\n\" +\n                \"        int z = 10;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }",
        "filePathBefore": "javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/RecordDeclarationTest.java",
        "isPureRefactoring": true,
        "commitId": "a73aba7b8cef7c52666d25169a3f6e495c65bcd2",
        "packageNameBefore": "com.github.javaparser.ast.body",
        "classNameBefore": "com.github.javaparser.ast.body.RecordDeclarationTest",
        "methodNameBefore": "com.github.javaparser.ast.body.RecordDeclarationTest#record_permitStaticFields",
        "classSignatureBefore": "public class RecordDeclarationTest ",
        "methodNameBeforeSet": [
            "com.github.javaparser.ast.body.RecordDeclarationTest#record_permitStaticFields"
        ],
        "classNameBeforeSet": [
            "com.github.javaparser.ast.body.RecordDeclarationTest"
        ],
        "classSignatureBeforeSet": [
            "public class RecordDeclarationTest "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "package com.github.javaparser.ast.body;\n\nimport com.github.javaparser.ParserConfiguration;\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.Modifier;\nimport com.github.javaparser.ast.NodeList;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.EnumSource;\nimport org.opentest4j.AssertionFailedError;\n\nimport java.util.List;\n\nimport static com.github.javaparser.utils.TestParser.parseCompilationUnit;\nimport static com.github.javaparser.utils.TestUtils.assertEqualsStringIgnoringEol;\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\npublic class RecordDeclarationTest {\n\n    @ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_13\", \"JAVA_13_PREVIEW\", \"JAVA_14\", \"JAVA_15\"})\n    void basicGrammarCompiles_languageLevelValidation_forbidden(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"record Point(int x, int y) { }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(languageLevel, s);\n        });\n    }\n\n    @ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_14_PREVIEW\", \"JAVA_15_PREVIEW\", \"JAVA_16\", \"JAVA_16_PREVIEW\"})\n    void basicGrammarCompiles_languageLevelValidation_permitted(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(languageLevel, s);\n    }\n\n    @Test\n    void basicGrammarCompiles() {\n        /* https://openjdk.java.net/jeps/395#Description */\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    @Test\n    void basicGrammar() {\n        /* https://openjdk.java.net/jeps/395#Description */\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        assertTrue(recordDeclaration.isRecordDeclaration());\n        assertTrue(recordDeclaration.getImplementedTypes().isEmpty());\n        assertTrue(recordDeclaration.getTypeParameters().isEmpty());\n        assertTrue(recordDeclaration.getFullyQualifiedName().isPresent());\n        assertEquals(\"Point\", recordDeclaration.getFullyQualifiedName().get());\n        assertTrue(recordDeclaration.isRecordDeclaration());\n\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"x\", parameter0.getNameAsString());\n        assertEquals(\"int\", parameter0.getTypeAsString());\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"y\", parameter1.getNameAsString());\n        assertEquals(\"int\", parameter1.getTypeAsString());\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Description\n     */\n    @Test\n    void basicRecordPrints() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        String expected = \"\" +\n                \"record Point(int x, int y) {\\n\" +\n                \"}\\n\" +\n                \"\";\n        assertEqualsStringIgnoringEol(expected, cu.toString());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-record\n     */\n    @Test\n    void record_cannotExtend() {\n        String s = \"record Point(int x, int y) extends OtherThing { }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_cannotBeAbstract() {\n        String s = \"abstract record Point(int x, int y) { }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n    }\n\n    @Test\n    void recordWithVarArgs() {\n        String s = \"record R(T1 c1, Tn... cn){ }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"c1\", parameter0.getNameAsString());\n        assertEquals(\"T1\", parameter0.getTypeAsString());\n        assertFalse(parameter0.isVarArgs());\n\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"cn\", parameter1.getNameAsString());\n        assertEquals(\"Tn\", parameter1.getTypeAsString());\n        assertTrue(parameter1.isVarArgs());\n    }\n\n    @Test\n    void recordWithAnnotationedParameters() {\n        String s = \"record Card(@MyAnno Rank rank, @MyAnno Suit suit) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"rank\", parameter0.getNameAsString());\n        assertEquals(\"Rank\", parameter0.getTypeAsString());\n        assertEquals(1, parameter0.getAnnotations().size());\n\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"suit\", parameter1.getNameAsString());\n        assertEquals(\"Suit\", parameter1.getTypeAsString());\n        assertEquals(1, parameter1.getAnnotations().size());\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    @Test\n    void record_emptyMembers() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    @Test\n    void record_permitStaticFields() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    static int z;\\n\" +\n                \"\\n\" +\n                \"    static {\\n\" +\n                \"        int z = 10;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    @Test\n    void record_permitMethods() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    public String xyz() {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    @Test\n    void record_mustNotAllowNonStaticFields() {\n        String s = \"record Point(int x, int y) { int z; }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n    }\n\n    @Test\n    void record_mustAllowStaticFields() {\n        String s = \"record Point(int x, int y) { static int z; }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n\n    @Test\n    void record_mustNotAllowMismatchedComponentAccessorReturnType() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public String x() {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n\n    }\n\n    @Test\n    void record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public String x(int a) {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    @Test\n    void record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod2() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public int x(int a) {\\n\" +\n                \"        return 10;\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n\n    @Test\n    void record_allowComponentAccessorWithMatchingType() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return 10;\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    // https://bugs.openjdk.java.net/browse/JDK-8222777\n    @Test\n    void recordDeclarationFromTheJDK8222777() {\n        CompilationUnit cu = parseCompilationUnit(\"\" +\n                \"public record Range(int lo, int hi) {\\n\" +\n                \"\\n\" +\n                \"  public Range {\\n\" +\n                \"    if (lo > hi)  /* referring here to the implicit constructor parameters */\\n\" +\n                \"      throw new IllegalArgumentException(String.format(\\\"(%d,%d)\\\", lo, hi));\\n\" +\n                \"  }\\n\" +\n                \"}\"\n        );\n\n        RecordDeclaration record = cu.findFirst(RecordDeclaration.class).get();\n        assertThat(record.getNameAsString()).isEqualTo(\"Range\");\n        assertThat(record.getModifiers()).containsExactly(Modifier.publicModifier());\n        // test parameters\n        // get constructor\n        // test parameters (none)\n    }\n}\n",
        "filePathAfter": "javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/RecordDeclarationTest.java",
        "sourceCodeAfterForWhole": "package com.github.javaparser.ast.body;\n\nimport com.github.javaparser.ParserConfiguration;\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.Modifier;\nimport com.github.javaparser.ast.NodeList;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.EnumSource;\nimport org.opentest4j.AssertionFailedError;\n\nimport java.util.List;\n\nimport static com.github.javaparser.utils.TestParser.parseCompilationUnit;\nimport static com.github.javaparser.utils.TestUtils.assertEqualsStringIgnoringEol;\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\npublic class RecordDeclarationTest {\n\n    @ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_13\", \"JAVA_13_PREVIEW\", \"JAVA_14\", \"JAVA_15\"})\n    void basicGrammarCompiles_languageLevelValidation_forbidden(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"record Point(int x, int y) { }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(languageLevel, s);\n        });\n    }\n\n    @ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_14_PREVIEW\", \"JAVA_15_PREVIEW\", \"JAVA_16\", \"JAVA_16_PREVIEW\"})\n    void basicGrammarCompiles_languageLevelValidation_permitted(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(languageLevel, s);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Description\n     */\n    @Test\n    void basicGrammarCompiles() {\n        String s = \"record Point(int x, int y) { }\";\n        assertOneRecordDeclaration(parseCompilationUnit(s));\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Description\n     */\n    @Test\n    void basicGrammar() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        RecordDeclaration recordDeclaration = cu.findAll(RecordDeclaration.class).get(0);\n\n        assertTrue(recordDeclaration.isRecordDeclaration());\n        assertTrue(recordDeclaration.getImplementedTypes().isEmpty());\n        assertTrue(recordDeclaration.getTypeParameters().isEmpty());\n        assertTrue(recordDeclaration.getFullyQualifiedName().isPresent());\n        assertEquals(\"Point\", recordDeclaration.getFullyQualifiedName().get());\n        assertTrue(recordDeclaration.isRecordDeclaration());\n\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"x\", parameter0.getNameAsString());\n        assertEquals(\"int\", parameter0.getTypeAsString());\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"y\", parameter1.getNameAsString());\n        assertEquals(\"int\", parameter1.getTypeAsString());\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Description\n     */\n    @Test\n    void basicRecordPrints() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        String expected = \"\" +\n                \"record Point(int x, int y) {\\n\" +\n                \"}\\n\" +\n                \"\";\n        assertEqualsStringIgnoringEol(expected, cu.toString());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-record\n     */\n    @Test\n    void record_cannotExtend() {\n        String s = \"record Point(int x, int y) extends OtherThing { }\";\n        assertCompilationFails(s);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_cannotBeAbstract() {\n        String s = \"abstract record Point(int x, int y) { }\";\n        assertCompilationFails(s);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_mayImplementInterfaces() {\n        String s = \"record Point(int x, int y) implements OtherInterface { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void recordWithVarArgs() {\n        String s = \"record R(T1 c1, Tn... cn){ }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"c1\", parameter0.getNameAsString());\n        assertEquals(\"T1\", parameter0.getTypeAsString());\n        assertFalse(parameter0.isVarArgs());\n\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"cn\", parameter1.getNameAsString());\n        assertEquals(\"Tn\", parameter1.getTypeAsString());\n        assertTrue(parameter1.isVarArgs());\n    }\n\n    @Test\n    void recordWithAnnotationedParameters() {\n        String s = \"record Card(@MyAnno Rank rank, @MyAnno Suit suit) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"rank\", parameter0.getNameAsString());\n        assertEquals(\"Rank\", parameter0.getTypeAsString());\n        assertEquals(1, parameter0.getAnnotations().size());\n\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"suit\", parameter1.getNameAsString());\n        assertEquals(\"Suit\", parameter1.getTypeAsString());\n        assertEquals(1, parameter1.getAnnotations().size());\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    @Test\n    void record_emptyMembers() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    @Test\n    void record_permitStaticFields() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    static int z;\\n\" +\n                \"\\n\" +\n                \"    static {\\n\" +\n                \"        int z = 10;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_permitMethods() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    public String xyz() {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_mustNotAllowNonStaticFields() {\n        String s = \"record Point(int x, int y) { int z; }\";\n        assertCompilationFails(s);\n    }\n\n    @Test\n    void record_mustAllowStaticFields() {\n        String s = \"record Point(int x, int y) { static int z; }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n\n    @Test\n    void record_mustNotAllowMismatchedComponentAccessorReturnType() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public String x() {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \" }\";\n        assertCompilationFails(s);\n    }\n\n    @Test\n    void record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public String x(int a) {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod2() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public int x(int a) {\\n\" +\n                \"        return 10;\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_allowComponentAccessorWithMatchingType() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return 10;\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    // https://bugs.openjdk.java.net/browse/JDK-8222777\n    @Test\n    void recordDeclarationFromTheJDK8222777() {\n        CompilationUnit cu = parseCompilationUnit(\"\" +\n                \"public record Range(int lo, int hi) {\\n\" +\n                \"\\n\" +\n                \"  public Range {\\n\" +\n                \"    if (lo > hi)  /* referring here to the implicit constructor parameters */\\n\" +\n                \"      throw new IllegalArgumentException(String.format(\\\"(%d,%d)\\\", lo, hi));\\n\" +\n                \"  }\\n\" +\n                \"}\"\n        );\n\n        RecordDeclaration record = cu.findFirst(RecordDeclaration.class).get();\n        assertThat(record.getNameAsString()).isEqualTo(\"Range\");\n        assertThat(record.getModifiers()).containsExactly(Modifier.publicModifier());\n        // test parameters\n        // get constructor\n        // test parameters (none)\n    }\n\n\n    private void assertCompilationFails(String s) {\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n    }\n\n    private void assertOneRecordDeclaration(CompilationUnit cu) {\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n}\n",
        "diffSourceCodeSet": [
            "private void assertOneRecordDeclaration(CompilationUnit cu) {\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }"
        ],
        "invokedMethodSet": [],
        "sourceCodeAfterRefactoring": "@Test\n    void record_permitStaticFields() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    static int z;\\n\" +\n                \"\\n\" +\n                \"    static {\\n\" +\n                \"        int z = 10;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\nprivate void assertOneRecordDeclaration(CompilationUnit cu) {\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }",
        "diffSourceCode": "-  176:     @Test\n-  177:     void record_permitStaticFields() {\n-  178:         String s = \"\" +\n-  179:                 \"record ABC(int x, int y) {\\n\" +\n-  180:                 \"\\n\" +\n-  181:                 \"    static int z;\\n\" +\n-  182:                 \"\\n\" +\n-  183:                 \"    static {\\n\" +\n-  184:                 \"        int z = 10;\\n\" +\n-  185:                 \"    }\\n\" +\n-  186:                 \"\\n\" +\n-  187:                 \"    public int x() {\\n\" +\n-  188:                 \"        return x;\\n\" +\n-  189:                 \"    }\\n\" +\n-  190:                 \"\\n\" +\n-  191:                 \"}\\n\" +\n-  192:                 \"\";\n-  193:         CompilationUnit cu = parseCompilationUnit(s);\n-  194:         List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n-  195:         assertEquals(1, recordDeclarations.size());\n-  196:     }\n-  197: \n-  198:     @Test\n-  199:     void record_permitMethods() {\n-  200:         String s = \"\" +\n-  201:                 \"record ABC(int x, int y) {\\n\" +\n-  202:                 \"\\n\" +\n-  203:                 \"    public int x() {\\n\" +\n-  204:                 \"        return x;\\n\" +\n+  176:         CompilationUnit cu = parseCompilationUnit(s);\n+  177:         assertOneRecordDeclaration(cu);\n+  178: \n+  179:         List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n+  180:         RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n+  181: \n+  182:         assertEquals(0, recordDeclaration.getMembers().size());\n+  183:     }\n+  184: \n+  185:     @Test\n+  186:     void record_permitStaticFields() {\n+  187:         String s = \"\" +\n+  188:                 \"record ABC(int x, int y) {\\n\" +\n+  189:                 \"\\n\" +\n+  190:                 \"    static int z;\\n\" +\n+  191:                 \"\\n\" +\n+  192:                 \"    static {\\n\" +\n+  193:                 \"        int z = 10;\\n\" +\n+  194:                 \"    }\\n\" +\n+  195:                 \"\\n\" +\n+  196:                 \"    public int x() {\\n\" +\n+  197:                 \"        return x;\\n\" +\n+  198:                 \"    }\\n\" +\n+  199:                 \"\\n\" +\n+  200:                 \"}\\n\" +\n+  201:                 \"\";\n+  202:         CompilationUnit cu = parseCompilationUnit(s);\n+  203:         assertOneRecordDeclaration(cu);\n+  204:     }\n+  313:     private void assertOneRecordDeclaration(CompilationUnit cu) {\n+  314:         List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n+  315:         assertEquals(1, recordDeclarations.size());\n+  316:     }\n",
        "uniqueId": "a73aba7b8cef7c52666d25169a3f6e495c65bcd2_176_196_313_316_185_204",
        "moveFileExist": true,
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 1.8,
        "testResult": true,
        "coverageInfo": {
            "testMethod": {
                "missed": 0,
                "covered": 1
            }
        }
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprivate assertCompilationFails(s String) : void extracted from package record_cannotBeAbstract() : void in class com.github.javaparser.ast.body.RecordDeclarationTest",
        "diffLocations": [
            {
                "filePath": "javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/RecordDeclarationTest.java",
                "startLine": 106,
                "endLine": 115,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/RecordDeclarationTest.java",
                "startLine": 105,
                "endLine": 112,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/RecordDeclarationTest.java",
                "startLine": 307,
                "endLine": 311,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "/**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_cannotBeAbstract() {\n        String s = \"abstract record Point(int x, int y) { }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n    }",
        "filePathBefore": "javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/RecordDeclarationTest.java",
        "isPureRefactoring": true,
        "commitId": "a73aba7b8cef7c52666d25169a3f6e495c65bcd2",
        "packageNameBefore": "com.github.javaparser.ast.body",
        "classNameBefore": "com.github.javaparser.ast.body.RecordDeclarationTest",
        "methodNameBefore": "com.github.javaparser.ast.body.RecordDeclarationTest#record_cannotBeAbstract",
        "classSignatureBefore": "public class RecordDeclarationTest ",
        "methodNameBeforeSet": [
            "com.github.javaparser.ast.body.RecordDeclarationTest#record_cannotBeAbstract"
        ],
        "classNameBeforeSet": [
            "com.github.javaparser.ast.body.RecordDeclarationTest"
        ],
        "classSignatureBeforeSet": [
            "public class RecordDeclarationTest "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "package com.github.javaparser.ast.body;\n\nimport com.github.javaparser.ParserConfiguration;\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.Modifier;\nimport com.github.javaparser.ast.NodeList;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.EnumSource;\nimport org.opentest4j.AssertionFailedError;\n\nimport java.util.List;\n\nimport static com.github.javaparser.utils.TestParser.parseCompilationUnit;\nimport static com.github.javaparser.utils.TestUtils.assertEqualsStringIgnoringEol;\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\npublic class RecordDeclarationTest {\n\n    @ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_13\", \"JAVA_13_PREVIEW\", \"JAVA_14\", \"JAVA_15\"})\n    void basicGrammarCompiles_languageLevelValidation_forbidden(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"record Point(int x, int y) { }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(languageLevel, s);\n        });\n    }\n\n    @ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_14_PREVIEW\", \"JAVA_15_PREVIEW\", \"JAVA_16\", \"JAVA_16_PREVIEW\"})\n    void basicGrammarCompiles_languageLevelValidation_permitted(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(languageLevel, s);\n    }\n\n    @Test\n    void basicGrammarCompiles() {\n        /* https://openjdk.java.net/jeps/395#Description */\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    @Test\n    void basicGrammar() {\n        /* https://openjdk.java.net/jeps/395#Description */\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        assertTrue(recordDeclaration.isRecordDeclaration());\n        assertTrue(recordDeclaration.getImplementedTypes().isEmpty());\n        assertTrue(recordDeclaration.getTypeParameters().isEmpty());\n        assertTrue(recordDeclaration.getFullyQualifiedName().isPresent());\n        assertEquals(\"Point\", recordDeclaration.getFullyQualifiedName().get());\n        assertTrue(recordDeclaration.isRecordDeclaration());\n\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"x\", parameter0.getNameAsString());\n        assertEquals(\"int\", parameter0.getTypeAsString());\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"y\", parameter1.getNameAsString());\n        assertEquals(\"int\", parameter1.getTypeAsString());\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Description\n     */\n    @Test\n    void basicRecordPrints() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        String expected = \"\" +\n                \"record Point(int x, int y) {\\n\" +\n                \"}\\n\" +\n                \"\";\n        assertEqualsStringIgnoringEol(expected, cu.toString());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-record\n     */\n    @Test\n    void record_cannotExtend() {\n        String s = \"record Point(int x, int y) extends OtherThing { }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_cannotBeAbstract() {\n        String s = \"abstract record Point(int x, int y) { }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n    }\n\n    @Test\n    void recordWithVarArgs() {\n        String s = \"record R(T1 c1, Tn... cn){ }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"c1\", parameter0.getNameAsString());\n        assertEquals(\"T1\", parameter0.getTypeAsString());\n        assertFalse(parameter0.isVarArgs());\n\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"cn\", parameter1.getNameAsString());\n        assertEquals(\"Tn\", parameter1.getTypeAsString());\n        assertTrue(parameter1.isVarArgs());\n    }\n\n    @Test\n    void recordWithAnnotationedParameters() {\n        String s = \"record Card(@MyAnno Rank rank, @MyAnno Suit suit) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"rank\", parameter0.getNameAsString());\n        assertEquals(\"Rank\", parameter0.getTypeAsString());\n        assertEquals(1, parameter0.getAnnotations().size());\n\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"suit\", parameter1.getNameAsString());\n        assertEquals(\"Suit\", parameter1.getTypeAsString());\n        assertEquals(1, parameter1.getAnnotations().size());\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    @Test\n    void record_emptyMembers() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    @Test\n    void record_permitStaticFields() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    static int z;\\n\" +\n                \"\\n\" +\n                \"    static {\\n\" +\n                \"        int z = 10;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    @Test\n    void record_permitMethods() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    public String xyz() {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    @Test\n    void record_mustNotAllowNonStaticFields() {\n        String s = \"record Point(int x, int y) { int z; }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n    }\n\n    @Test\n    void record_mustAllowStaticFields() {\n        String s = \"record Point(int x, int y) { static int z; }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n\n    @Test\n    void record_mustNotAllowMismatchedComponentAccessorReturnType() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public String x() {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n\n    }\n\n    @Test\n    void record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public String x(int a) {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    @Test\n    void record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod2() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public int x(int a) {\\n\" +\n                \"        return 10;\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n\n    @Test\n    void record_allowComponentAccessorWithMatchingType() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return 10;\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    // https://bugs.openjdk.java.net/browse/JDK-8222777\n    @Test\n    void recordDeclarationFromTheJDK8222777() {\n        CompilationUnit cu = parseCompilationUnit(\"\" +\n                \"public record Range(int lo, int hi) {\\n\" +\n                \"\\n\" +\n                \"  public Range {\\n\" +\n                \"    if (lo > hi)  /* referring here to the implicit constructor parameters */\\n\" +\n                \"      throw new IllegalArgumentException(String.format(\\\"(%d,%d)\\\", lo, hi));\\n\" +\n                \"  }\\n\" +\n                \"}\"\n        );\n\n        RecordDeclaration record = cu.findFirst(RecordDeclaration.class).get();\n        assertThat(record.getNameAsString()).isEqualTo(\"Range\");\n        assertThat(record.getModifiers()).containsExactly(Modifier.publicModifier());\n        // test parameters\n        // get constructor\n        // test parameters (none)\n    }\n}\n",
        "filePathAfter": "javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/RecordDeclarationTest.java",
        "sourceCodeAfterForWhole": "package com.github.javaparser.ast.body;\n\nimport com.github.javaparser.ParserConfiguration;\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.Modifier;\nimport com.github.javaparser.ast.NodeList;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.EnumSource;\nimport org.opentest4j.AssertionFailedError;\n\nimport java.util.List;\n\nimport static com.github.javaparser.utils.TestParser.parseCompilationUnit;\nimport static com.github.javaparser.utils.TestUtils.assertEqualsStringIgnoringEol;\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\npublic class RecordDeclarationTest {\n\n    @ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_13\", \"JAVA_13_PREVIEW\", \"JAVA_14\", \"JAVA_15\"})\n    void basicGrammarCompiles_languageLevelValidation_forbidden(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"record Point(int x, int y) { }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(languageLevel, s);\n        });\n    }\n\n    @ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_14_PREVIEW\", \"JAVA_15_PREVIEW\", \"JAVA_16\", \"JAVA_16_PREVIEW\"})\n    void basicGrammarCompiles_languageLevelValidation_permitted(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(languageLevel, s);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Description\n     */\n    @Test\n    void basicGrammarCompiles() {\n        String s = \"record Point(int x, int y) { }\";\n        assertOneRecordDeclaration(parseCompilationUnit(s));\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Description\n     */\n    @Test\n    void basicGrammar() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        RecordDeclaration recordDeclaration = cu.findAll(RecordDeclaration.class).get(0);\n\n        assertTrue(recordDeclaration.isRecordDeclaration());\n        assertTrue(recordDeclaration.getImplementedTypes().isEmpty());\n        assertTrue(recordDeclaration.getTypeParameters().isEmpty());\n        assertTrue(recordDeclaration.getFullyQualifiedName().isPresent());\n        assertEquals(\"Point\", recordDeclaration.getFullyQualifiedName().get());\n        assertTrue(recordDeclaration.isRecordDeclaration());\n\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"x\", parameter0.getNameAsString());\n        assertEquals(\"int\", parameter0.getTypeAsString());\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"y\", parameter1.getNameAsString());\n        assertEquals(\"int\", parameter1.getTypeAsString());\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Description\n     */\n    @Test\n    void basicRecordPrints() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        String expected = \"\" +\n                \"record Point(int x, int y) {\\n\" +\n                \"}\\n\" +\n                \"\";\n        assertEqualsStringIgnoringEol(expected, cu.toString());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-record\n     */\n    @Test\n    void record_cannotExtend() {\n        String s = \"record Point(int x, int y) extends OtherThing { }\";\n        assertCompilationFails(s);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_cannotBeAbstract() {\n        String s = \"abstract record Point(int x, int y) { }\";\n        assertCompilationFails(s);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_mayImplementInterfaces() {\n        String s = \"record Point(int x, int y) implements OtherInterface { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void recordWithVarArgs() {\n        String s = \"record R(T1 c1, Tn... cn){ }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"c1\", parameter0.getNameAsString());\n        assertEquals(\"T1\", parameter0.getTypeAsString());\n        assertFalse(parameter0.isVarArgs());\n\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"cn\", parameter1.getNameAsString());\n        assertEquals(\"Tn\", parameter1.getTypeAsString());\n        assertTrue(parameter1.isVarArgs());\n    }\n\n    @Test\n    void recordWithAnnotationedParameters() {\n        String s = \"record Card(@MyAnno Rank rank, @MyAnno Suit suit) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"rank\", parameter0.getNameAsString());\n        assertEquals(\"Rank\", parameter0.getTypeAsString());\n        assertEquals(1, parameter0.getAnnotations().size());\n\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"suit\", parameter1.getNameAsString());\n        assertEquals(\"Suit\", parameter1.getTypeAsString());\n        assertEquals(1, parameter1.getAnnotations().size());\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    @Test\n    void record_emptyMembers() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    @Test\n    void record_permitStaticFields() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    static int z;\\n\" +\n                \"\\n\" +\n                \"    static {\\n\" +\n                \"        int z = 10;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_permitMethods() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    public String xyz() {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_mustNotAllowNonStaticFields() {\n        String s = \"record Point(int x, int y) { int z; }\";\n        assertCompilationFails(s);\n    }\n\n    @Test\n    void record_mustAllowStaticFields() {\n        String s = \"record Point(int x, int y) { static int z; }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n\n    @Test\n    void record_mustNotAllowMismatchedComponentAccessorReturnType() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public String x() {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \" }\";\n        assertCompilationFails(s);\n    }\n\n    @Test\n    void record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public String x(int a) {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod2() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public int x(int a) {\\n\" +\n                \"        return 10;\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_allowComponentAccessorWithMatchingType() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return 10;\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    // https://bugs.openjdk.java.net/browse/JDK-8222777\n    @Test\n    void recordDeclarationFromTheJDK8222777() {\n        CompilationUnit cu = parseCompilationUnit(\"\" +\n                \"public record Range(int lo, int hi) {\\n\" +\n                \"\\n\" +\n                \"  public Range {\\n\" +\n                \"    if (lo > hi)  /* referring here to the implicit constructor parameters */\\n\" +\n                \"      throw new IllegalArgumentException(String.format(\\\"(%d,%d)\\\", lo, hi));\\n\" +\n                \"  }\\n\" +\n                \"}\"\n        );\n\n        RecordDeclaration record = cu.findFirst(RecordDeclaration.class).get();\n        assertThat(record.getNameAsString()).isEqualTo(\"Range\");\n        assertThat(record.getModifiers()).containsExactly(Modifier.publicModifier());\n        // test parameters\n        // get constructor\n        // test parameters (none)\n    }\n\n\n    private void assertCompilationFails(String s) {\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n    }\n\n    private void assertOneRecordDeclaration(CompilationUnit cu) {\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n}\n",
        "diffSourceCodeSet": [
            "private void assertCompilationFails(String s) {\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n    }"
        ],
        "invokedMethodSet": [],
        "sourceCodeAfterRefactoring": "/**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_cannotBeAbstract() {\n        String s = \"abstract record Point(int x, int y) { }\";\n        assertCompilationFails(s);\n    }\nprivate void assertCompilationFails(String s) {\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n    }",
        "diffSourceCode": "-  105: \n-  106:     /**\n-  107:      * https://openjdk.java.net/jeps/395#Restrictions-on-records\n-  108:      */\n-  109:     @Test\n-  110:     void record_cannotBeAbstract() {\n-  111:         String s = \"abstract record Point(int x, int y) { }\";\n-  112:         assertThrows(AssertionFailedError.class, () -> {\n-  113:             CompilationUnit cu = parseCompilationUnit(s);\n-  114:         });\n-  115:     }\n-  307:         // test parameters (none)\n-  308:     }\n-  309: }\n+  105:     /**\n+  106:      * https://openjdk.java.net/jeps/395#Restrictions-on-records\n+  107:      */\n+  108:     @Test\n+  109:     void record_cannotBeAbstract() {\n+  110:         String s = \"abstract record Point(int x, int y) { }\";\n+  111:         assertCompilationFails(s);\n+  112:     }\n+  113: \n+  114:     /**\n+  115:      * https://openjdk.java.net/jeps/395#Restrictions-on-records\n+  307:     private void assertCompilationFails(String s) {\n+  308:         assertThrows(AssertionFailedError.class, () -> {\n+  309:             CompilationUnit cu = parseCompilationUnit(s);\n+  310:         });\n+  311:     }\n",
        "uniqueId": "a73aba7b8cef7c52666d25169a3f6e495c65bcd2_106_115_307_311_105_112",
        "moveFileExist": true,
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 1.8,
        "testResult": true,
        "coverageInfo": {
            "testMethod": {
                "missed": 0,
                "covered": 1
            }
        }
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tpackage provider(source String) : UnicodeEscapeProcessingProvider extracted from private read(source String) : String in class com.github.javaparser.UnicodeEscapeProcessingProviderTest",
        "diffLocations": [
            {
                "filePath": "javaparser-core-testing/src/test/java/com/github/javaparser/UnicodeEscapeProcessingProviderTest.java",
                "startLine": 123,
                "endLine": 140,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "javaparser-core-testing/src/test/java/com/github/javaparser/UnicodeEscapeProcessingProviderTest.java",
                "startLine": 123,
                "endLine": 125,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "javaparser-core-testing/src/test/java/com/github/javaparser/UnicodeEscapeProcessingProviderTest.java",
                "startLine": 127,
                "endLine": 131,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "private String read(String source) throws IOException {\n\t\tUnicodeEscapeProcessingProvider provider = new UnicodeEscapeProcessingProvider(10, \n\t\t\t\tnew StringProvider(source));\n\t\n\t\tStringBuilder result = new StringBuilder();\n\t\tchar[] buffer = new char[10];\n\t\twhile (true) {\n\t\t\tint direct = provider.read(buffer, 0, buffer.length);\n\t\t\tif (direct < 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tresult.append(buffer, 0, direct);\n\t\t}\n\t\t\n\t\tprovider.close();\n\t\n\t\treturn result.toString();\n\t}",
        "filePathBefore": "javaparser-core-testing/src/test/java/com/github/javaparser/UnicodeEscapeProcessingProviderTest.java",
        "isPureRefactoring": true,
        "commitId": "baf9003923057506e2518c688bc1e5d09d5052d6",
        "packageNameBefore": "com.github.javaparser",
        "classNameBefore": "com.github.javaparser.UnicodeEscapeProcessingProviderTest",
        "methodNameBefore": "com.github.javaparser.UnicodeEscapeProcessingProviderTest#read",
        "invokedMethod": "methodSignature: com.github.javaparser.UnicodeEscapeProcessingProvider#read\n methodBody: public int read(char[] buffer, final int offset, int len) throws IOException {\nint pos=offset;\nint stop=offset + len;\nwhile(pos < stop){int ch=nextOutputChar();\nif(ch < 0){if(pos == offset){return EOF;\n}{break;\n}}{buffer[pos++]=(char)ch;\n}}return pos - offset;\n}\nmethodSignature: com.github.javaparser.UnicodeEscapeProcessingProviderTest#read\n methodBody: private String read(String source) throws IOException {\nUnicodeEscapeProcessingProvider provider=new UnicodeEscapeProcessingProvider(10,new StringProvider(source));\nStringBuilder result=new StringBuilder();\nchar[] buffer=new char[10];\nwhile(true){int direct=provider.read(buffer,0,buffer.length);\nif(direct < 0){break;\n}result.append(buffer,0,direct);\n}provider.close();\nreturn result.toString();\n}\nmethodSignature: com.github.javaparser.UnicodeEscapeProcessingProvider#close\n methodBody: public void close() throws IOException {\n_input.close();\n}",
        "classSignatureBefore": "public class UnicodeEscapeProcessingProviderTest ",
        "methodNameBeforeSet": [
            "com.github.javaparser.UnicodeEscapeProcessingProviderTest#read"
        ],
        "classNameBeforeSet": [
            "com.github.javaparser.UnicodeEscapeProcessingProviderTest"
        ],
        "classSignatureBeforeSet": [
            "public class UnicodeEscapeProcessingProviderTest "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Changes are within the Extract Method refactoring mechanics Severe changes",
                "description": "Return expression has been added within the Extract Method mechanics - with non-mapped leaves",
                "mappingState": 2
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Copyright (C) 2019 The JavaParser Team.\n *\n * This file is part of JavaParser.\n *\n * JavaParser can be used either under the terms of\n * a) the GNU Lesser General Public License as published by\n *     the Free Software Foundation, either version 3 of the License, or\n *     (at your option) any later version.\n * b) the terms of the Apache License\n *\n * You should have received a copy of both licenses in LICENCE.LGPL and\n * LICENCE.APACHE. Please refer to those files for details.\n *\n * JavaParser is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n */\npackage com.github.javaparser;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport java.io.IOException;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * Test case for {@link UnicodeEscapeProcessingProvider}.\n */\npublic class UnicodeEscapeProcessingProviderTest {\n\n\t@Test\n\tvoid testUnicodeEscape() throws IOException {\n\t\tassertEquals(\"13\" + '\\u12aA' + \"98\", new String(read(\"13\\\\u12aA98\")));\n\t}\n\n\t@Test\n\tvoid testEscapedUnicodeEscape() throws IOException {\n\t\tassertEquals(\"13\\\\\\\\u12aA98\", new String(read(\"13\\\\\\\\u12aA98\")));\n\t}\n\t\n\t@Test\n\tvoid testUnicodeEscapeWithMultipleUs() throws IOException {\n\t\tassertEquals(\"13\" + '\\u12aA' + \"98\", new String(read(\"13\\\\uuuuuu12aA98\")));\n\t}\n\t\n\t@Test\n\tvoid testInputEndingInBackslash() throws IOException {\n\t\tassertEquals(\"foobar\\\\\", new String(read(\"foobar\\\\\")));\n\t}\n\t\n\t@Test\n\tvoid testInputEndingInBackslashU() throws IOException {\n\t\tassertEquals(\"foobar\\\\u\", new String(read(\"foobar\\\\u\")));\n\t}\n\t\n\t@Test\n\tvoid testInputEndingInBackslashUs() throws IOException {\n\t\tassertEquals(\"foobar\\\\uuuuuu\", new String(read(\"foobar\\\\uuuuuu\")));\n\t}\n\t\n\t@Test\n\tvoid testInputEndingInBackslashU1() throws IOException {\n\t\tassertEquals(\"foobar\\\\uA\", new String(read(\"foobar\\\\uA\")));\n\t}\n\t\n\t@Test\n\tvoid testInputEndingInBackslashU2() throws IOException {\n\t\tassertEquals(\"foobar\\\\uAB\", new String(read(\"foobar\\\\uAB\")));\n\t}\n\t\n\t@Test\n\tvoid testInputEndingInBackslashU3() throws IOException {\n\t\tassertEquals(\"foobar\\\\uABC\", new String(read(\"foobar\\\\uABC\")));\n\t}\n\t\n\t@Test\n\tvoid testInputEndingUnicodeEscape() throws IOException {\n\t\tassertEquals(\"foobar\\uABCD\", new String(read(\"foobar\\\\uABCD\")));\n\t}\n\t\n\t@Test\n\tvoid testEmptyInput() throws IOException {\n\t\tassertEquals(\"\", new String(read(\"\")));\n\t}\n\n\t@Test\n\tvoid testBadUnicodeEscape0() throws IOException {\n\t\tassertEquals(\"13\\\\ux\", new String(read(\"13\\\\ux\")));\n\t}\n\t\n\t@Test\n\tvoid testBadUnicodeEscape1() throws IOException {\n\t\tassertEquals(\"13\\\\u1x\", new String(read(\"13\\\\u1x\")));\n\t}\n\n\t@Test\n\tvoid testBadUnicodeEscape2() throws IOException {\n\t\tassertEquals(\"13\\\\u1Ax\", new String(read(\"13\\\\u1Ax\")));\n\t}\n\n\t@Test\n\tvoid testBadUnicodeEscape3() throws IOException {\n\t\tassertEquals(\"13\\\\u1ABx\", new String(read(\"13\\\\u1ABx\")));\n\t}\n\n\t@Test\n\tvoid testBadUnicodeEscapeMultipleUs() throws IOException {\n\t\tassertEquals(\"13\\\\uuuuuu1ABx\", new String(read(\"13\\\\uuuuuu1ABx\")));\n\t}\n\n\t@Test\n\tvoid testPushBackWithFullBuffer() throws IOException {\n\t\tassertEquals(\"12345678\\\\uuxxxxxxxxxxxxxxxxxxxxxxx\", new String(read(\"12345678\\\\uuxxxxxxxxxxxxxxxxxxxxxxx\")));\n\t}\n\t\n\t@Test\n\tvoid testPushBackWithBufferShift() throws IOException {\n\t\tassertEquals(\"12345678\\\\uuxx\", new String(read(\"12345678\\\\uuxx\")));\n\t}\n\t\n\tprivate String read(String source) throws IOException {\n\t\tUnicodeEscapeProcessingProvider provider = new UnicodeEscapeProcessingProvider(10, \n\t\t\t\tnew StringProvider(source));\n\t\n\t\tStringBuilder result = new StringBuilder();\n\t\tchar[] buffer = new char[10];\n\t\twhile (true) {\n\t\t\tint direct = provider.read(buffer, 0, buffer.length);\n\t\t\tif (direct < 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tresult.append(buffer, 0, direct);\n\t\t}\n\t\t\n\t\tprovider.close();\n\t\n\t\treturn result.toString();\n\t}\n}\n",
        "filePathAfter": "javaparser-core-testing/src/test/java/com/github/javaparser/UnicodeEscapeProcessingProviderTest.java",
        "sourceCodeAfterForWhole": "/*\n * Copyright (C) 2019 The JavaParser Team.\n *\n * This file is part of JavaParser.\n *\n * JavaParser can be used either under the terms of\n * a) the GNU Lesser General Public License as published by\n *     the Free Software Foundation, either version 3 of the License, or\n *     (at your option) any later version.\n * b) the terms of the Apache License\n *\n * You should have received a copy of both licenses in LICENCE.LGPL and\n * LICENCE.APACHE. Please refer to those files for details.\n *\n * JavaParser is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n */\npackage com.github.javaparser;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport java.io.IOException;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * Test case for {@link UnicodeEscapeProcessingProvider}.\n */\npublic class UnicodeEscapeProcessingProviderTest {\n\n\t@Test\n\tvoid testUnicodeEscape() throws IOException {\n\t\tassertEquals(\"13\" + '\\u12aA' + \"98\", new String(read(\"13\\\\u12aA98\")));\n\t}\n\n\t@Test\n\tvoid testEscapedUnicodeEscape() throws IOException {\n\t\tassertEquals(\"13\\\\\\\\u12aA98\", new String(read(\"13\\\\\\\\u12aA98\")));\n\t}\n\t\n\t@Test\n\tvoid testUnicodeEscapeWithMultipleUs() throws IOException {\n\t\tassertEquals(\"13\" + '\\u12aA' + \"98\", new String(read(\"13\\\\uuuuuu12aA98\")));\n\t}\n\t\n\t@Test\n\tvoid testInputEndingInBackslash() throws IOException {\n\t\tassertEquals(\"foobar\\\\\", new String(read(\"foobar\\\\\")));\n\t}\n\t\n\t@Test\n\tvoid testInputEndingInBackslashU() throws IOException {\n\t\tassertEquals(\"foobar\\\\u\", new String(read(\"foobar\\\\u\")));\n\t}\n\t\n\t@Test\n\tvoid testInputEndingInBackslashUs() throws IOException {\n\t\tassertEquals(\"foobar\\\\uuuuuu\", new String(read(\"foobar\\\\uuuuuu\")));\n\t}\n\t\n\t@Test\n\tvoid testInputEndingInBackslashU1() throws IOException {\n\t\tassertEquals(\"foobar\\\\uA\", new String(read(\"foobar\\\\uA\")));\n\t}\n\t\n\t@Test\n\tvoid testInputEndingInBackslashU2() throws IOException {\n\t\tassertEquals(\"foobar\\\\uAB\", new String(read(\"foobar\\\\uAB\")));\n\t}\n\t\n\t@Test\n\tvoid testInputEndingInBackslashU3() throws IOException {\n\t\tassertEquals(\"foobar\\\\uABC\", new String(read(\"foobar\\\\uABC\")));\n\t}\n\t\n\t@Test\n\tvoid testInputEndingUnicodeEscape() throws IOException {\n\t\tassertEquals(\"foobar\\uABCD\", new String(read(\"foobar\\\\uABCD\")));\n\t}\n\t\n\t@Test\n\tvoid testEmptyInput() throws IOException {\n\t\tassertEquals(\"\", new String(read(\"\")));\n\t}\n\n\t@Test\n\tvoid testBadUnicodeEscape0() throws IOException {\n\t\tassertEquals(\"13\\\\ux\", new String(read(\"13\\\\ux\")));\n\t}\n\t\n\t@Test\n\tvoid testBadUnicodeEscape1() throws IOException {\n\t\tassertEquals(\"13\\\\u1x\", new String(read(\"13\\\\u1x\")));\n\t}\n\n\t@Test\n\tvoid testBadUnicodeEscape2() throws IOException {\n\t\tassertEquals(\"13\\\\u1Ax\", new String(read(\"13\\\\u1Ax\")));\n\t}\n\n\t@Test\n\tvoid testBadUnicodeEscape3() throws IOException {\n\t\tassertEquals(\"13\\\\u1ABx\", new String(read(\"13\\\\u1ABx\")));\n\t}\n\n\t@Test\n\tvoid testBadUnicodeEscapeMultipleUs() throws IOException {\n\t\tassertEquals(\"13\\\\uuuuuu1ABx\", new String(read(\"13\\\\uuuuuu1ABx\")));\n\t}\n\n\t@Test\n\tvoid testPushBackWithFullBuffer() throws IOException {\n\t\tassertEquals(\"12345678\\\\uuxxxxxxxxxxxxxxxxxxxxxxx\", new String(read(\"12345678\\\\uuxxxxxxxxxxxxxxxxxxxxxxx\")));\n\t}\n\t\n\t@Test\n\tvoid testPushBackWithBufferShift() throws IOException {\n\t\tassertEquals(\"12345678\\\\uuxx\", new String(read(\"12345678\\\\uuxx\")));\n\t}\n\t\n\tstatic String read(String source) throws IOException {\n\t\treturn process(provider(source));\n\t}\n\n\tstatic UnicodeEscapeProcessingProvider provider(String source) {\n\t\tUnicodeEscapeProcessingProvider provider = new UnicodeEscapeProcessingProvider(10, \n\t\t\t\tnew StringProvider(source));\n\t\treturn provider;\n\t}\n\n\tstatic String process(UnicodeEscapeProcessingProvider provider)\n\t\t\tthrows IOException {\n\t\tStringBuilder result = new StringBuilder();\n\t\tchar[] buffer = new char[10];\n\t\twhile (true) {\n\t\t\tint direct = provider.read(buffer, 0, buffer.length);\n\t\t\tif (direct < 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tresult.append(buffer, 0, direct);\n\t\t}\n\t\t\n\t\tprovider.close();\n\t\n\t\treturn result.toString();\n\t}\n}\n",
        "diffSourceCodeSet": [
            "static UnicodeEscapeProcessingProvider provider(String source) {\n\t\tUnicodeEscapeProcessingProvider provider = new UnicodeEscapeProcessingProvider(10, \n\t\t\t\tnew StringProvider(source));\n\t\treturn provider;\n\t}"
        ],
        "invokedMethodSet": [
            "methodSignature: com.github.javaparser.UnicodeEscapeProcessingProvider#read\n methodBody: public int read(char[] buffer, final int offset, int len) throws IOException {\nint pos=offset;\nint stop=offset + len;\nwhile(pos < stop){int ch=nextOutputChar();\nif(ch < 0){if(pos == offset){return EOF;\n}{break;\n}}{buffer[pos++]=(char)ch;\n}}return pos - offset;\n}",
            "methodSignature: com.github.javaparser.UnicodeEscapeProcessingProviderTest#read\n methodBody: private String read(String source) throws IOException {\nUnicodeEscapeProcessingProvider provider=new UnicodeEscapeProcessingProvider(10,new StringProvider(source));\nStringBuilder result=new StringBuilder();\nchar[] buffer=new char[10];\nwhile(true){int direct=provider.read(buffer,0,buffer.length);\nif(direct < 0){break;\n}result.append(buffer,0,direct);\n}provider.close();\nreturn result.toString();\n}",
            "methodSignature: com.github.javaparser.UnicodeEscapeProcessingProvider#close\n methodBody: public void close() throws IOException {\n_input.close();\n}"
        ],
        "sourceCodeAfterRefactoring": "static String read(String source) throws IOException {\n\t\treturn process(provider(source));\n\t}\nstatic UnicodeEscapeProcessingProvider provider(String source) {\n\t\tUnicodeEscapeProcessingProvider provider = new UnicodeEscapeProcessingProvider(10, \n\t\t\t\tnew StringProvider(source));\n\t\treturn provider;\n\t}",
        "diffSourceCode": "-  123: \tprivate String read(String source) throws IOException {\n-  124: \t\tUnicodeEscapeProcessingProvider provider = new UnicodeEscapeProcessingProvider(10, \n-  125: \t\t\t\tnew StringProvider(source));\n-  126: \t\n-  127: \t\tStringBuilder result = new StringBuilder();\n-  128: \t\tchar[] buffer = new char[10];\n-  129: \t\twhile (true) {\n-  130: \t\t\tint direct = provider.read(buffer, 0, buffer.length);\n-  131: \t\t\tif (direct < 0) {\n-  132: \t\t\t\tbreak;\n-  133: \t\t\t}\n-  134: \t\t\tresult.append(buffer, 0, direct);\n-  135: \t\t}\n-  136: \t\t\n-  137: \t\tprovider.close();\n-  138: \t\n-  139: \t\treturn result.toString();\n-  140: \t}\n+  123: \tstatic String read(String source) throws IOException {\n+  124: \t\treturn process(provider(source));\n+  125: \t}\n+  126: \n+  127: \tstatic UnicodeEscapeProcessingProvider provider(String source) {\n+  128: \t\tUnicodeEscapeProcessingProvider provider = new UnicodeEscapeProcessingProvider(10, \n+  129: \t\t\t\tnew StringProvider(source));\n+  130: \t\treturn provider;\n+  131: \t}\n+  132: \n+  133: \tstatic String process(UnicodeEscapeProcessingProvider provider)\n+  134: \t\t\tthrows IOException {\n+  135: \t\tStringBuilder result = new StringBuilder();\n+  136: \t\tchar[] buffer = new char[10];\n+  137: \t\twhile (true) {\n+  138: \t\t\tint direct = provider.read(buffer, 0, buffer.length);\n+  139: \t\t\tif (direct < 0) {\n+  140: \t\t\t\tbreak;\n",
        "uniqueId": "baf9003923057506e2518c688bc1e5d09d5052d6_123_140_127_131_123_125",
        "moveFileExist": true,
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 1.8,
        "testResult": true,
        "coverageInfo": {
            "testMethod": {
                "missed": 0,
                "covered": 1
            }
        }
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tpublic deserializeObject(reader JsonReader, delegates Map<String,Delegate>) : Node extracted from public deserializeObject(reader JsonReader) : Node in class com.github.javaparser.serialization.JavaParserJsonDeserializer",
        "diffLocations": [
            {
                "filePath": "javaparser-core-serialization/src/main/java/com/github/javaparser/serialization/JavaParserJsonDeserializer.java",
                "startLine": 48,
                "endLine": 52,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "javaparser-core-serialization/src/main/java/com/github/javaparser/serialization/JavaParserJsonDeserializer.java",
                "startLine": 44,
                "endLine": 46,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "javaparser-core-serialization/src/main/java/com/github/javaparser/serialization/JavaParserJsonDeserializer.java",
                "startLine": 48,
                "endLine": 52,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "public Node deserializeObject(JsonReader reader) {\n        Log.info(\"Deserializing JSON to Node.\");\n        JsonObject jsonObject = reader.readObject();\n        return deserializeObject(jsonObject);\n    }",
        "filePathBefore": "javaparser-core-serialization/src/main/java/com/github/javaparser/serialization/JavaParserJsonDeserializer.java",
        "isPureRefactoring": true,
        "commitId": "ef3ecbbbdebff45488e6017781f8caf59c2056fa",
        "packageNameBefore": "com.github.javaparser.serialization",
        "classNameBefore": "com.github.javaparser.serialization.JavaParserJsonDeserializer",
        "methodNameBefore": "com.github.javaparser.serialization.JavaParserJsonDeserializer#deserializeObject",
        "invokedMethod": "methodSignature: com.github.javaparser.serialization.JavaParserJsonDeserializer#deserializeObject\n methodBody: private Node deserializeObject(JsonObject nodeJson) {\ntryString serializedNodeType=nodeJson.getString(SERIALIZED_CLASS_KEY);\nBaseNodeMetaModel nodeMetaModel=getNodeMetaModel(Class.forName(serializedNodeType)).orElseThrow(() -> new IllegalStateException(\"Trying to deserialize an unknown node type: \" + serializedNodeType));\nMap<String,Object> parameters=new HashMap<>();\nfor(String name: nodeJson.keySet()){if(name.equals(SERIALIZED_CLASS_KEY)){continue;\n}PropertyMetaModel propertyMetaModel=nodeMetaModel.getAllPropertyMetaModels().stream().filter(mm -> mm.getName().equals(name)).findFirst().orElseThrow(() -> new IllegalStateException(\"Unknown property: \" + nodeMetaModel.getQualifiedClassName() + \".\" + name));\nif(propertyMetaModel.isNodeList()){JsonArray nodeListJson=nodeJson.getJsonArray(name);\nparameters.put(name,deserializeNodeList(nodeListJson));\n}if(propertyMetaModel.isEnumSet()){JsonArray enumSetJson=nodeJson.getJsonArray(name);\nparameters.put(name,deserializeEnumSet(enumSetJson));\n}if(propertyMetaModel.isNode()){parameters.put(name,deserializeObject(nodeJson.getJsonObject(name)));\n}{Class<?> type=propertyMetaModel.getType();\nif(type == String.class){parameters.put(name,nodeJson.getString(name));\n}if(type == boolean.class){parameters.put(name,Boolean.parseBoolean(nodeJson.getString(name)));\n}if(Enum.class.isAssignableFrom(type)){parameters.put(name,Enum.valueOf((Class<? extends Enum>)type,nodeJson.getString(name)));\n}{throw new IllegalStateException(\"Don't know how to convert: \" + type);\n}}}return nodeMetaModel.construct(parameters);\ncatch(ClassNotFoundException e)throw new RuntimeException(e);\n}",
        "classSignatureBefore": "public class JavaParserJsonDeserializer ",
        "methodNameBeforeSet": [
            "com.github.javaparser.serialization.JavaParserJsonDeserializer#deserializeObject"
        ],
        "classNameBeforeSet": [
            "com.github.javaparser.serialization.JavaParserJsonDeserializer"
        ],
        "classSignatureBeforeSet": [
            "public class JavaParserJsonDeserializer "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Overlapped refactoring - can be identical by undoing the overlapped refactoring\n- Add Parameter-",
                "description": "Parametrization or Add Parameter on top of the extract method - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Copyright (C) 2007-2010 J\u00falio Vilmar Gesser.\n * Copyright (C) 2011, 2013-2018 The JavaParser Team.\n *\n * This file is part of JavaParser.\n *\n * JavaParser can be used either under the terms of\n * a) the GNU Lesser General Public License as published by\n *     the Free Software Foundation, either version 3 of the License, or\n *     (at your option) any later version.\n * b) the terms of the Apache License\n *\n * You should have received a copy of both licenses in LICENCE.LGPL and\n * LICENCE.APACHE. Please refer to those files for details.\n *\n * JavaParser is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n */\npackage com.github.javaparser.serialization;\n\nimport com.github.javaparser.ast.Modifier;\nimport com.github.javaparser.ast.Node;\nimport com.github.javaparser.ast.NodeList;\nimport com.github.javaparser.metamodel.BaseNodeMetaModel;\nimport com.github.javaparser.metamodel.PropertyMetaModel;\nimport com.github.javaparser.utils.Log;\n\nimport javax.json.JsonArray;\nimport javax.json.JsonObject;\nimport javax.json.JsonReader;\nimport javax.json.JsonString;\nimport java.util.EnumSet;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.stream.Collectors;\n\nimport static com.github.javaparser.ast.NodeList.toNodeList;\nimport static com.github.javaparser.metamodel.JavaParserMetaModel.getNodeMetaModel;\nimport static com.github.javaparser.serialization.JavaParserJsonSerializer.SERIALIZED_CLASS_KEY;\n\n/**\n * Deserializes the JSON file that was built by {@link JavaParserJsonSerializer}.\n */\npublic class JavaParserJsonDeserializer {\n\n    public Node deserializeObject(JsonReader reader) {\n        Log.info(\"Deserializing JSON to Node.\");\n        JsonObject jsonObject = reader.readObject();\n        return deserializeObject(jsonObject);\n    }\n\n    private Node deserializeObject(JsonObject nodeJson) {\n        try {\n            String serializedNodeType = nodeJson.getString(SERIALIZED_CLASS_KEY);\n            BaseNodeMetaModel nodeMetaModel = getNodeMetaModel(Class.forName(serializedNodeType))\n                    .orElseThrow(() -> new IllegalStateException(\"Trying to deserialize an unknown node type: \" + serializedNodeType));\n            Map<String, Object> parameters = new HashMap<>();\n            for (String name : nodeJson.keySet()) {\n                if (name.equals(SERIALIZED_CLASS_KEY)) {\n                    continue;\n                }\n\n                PropertyMetaModel propertyMetaModel = nodeMetaModel.getAllPropertyMetaModels().stream()\n                        .filter(mm -> mm.getName().equals(name))\n                        .findFirst().orElseThrow(() -> new IllegalStateException(\"Unknown property: \" + nodeMetaModel.getQualifiedClassName() + \".\" + name));\n\n                if (propertyMetaModel.isNodeList()) {\n                    JsonArray nodeListJson = nodeJson.getJsonArray(name);\n                    parameters.put(name, deserializeNodeList(nodeListJson));\n                } else if (propertyMetaModel.isEnumSet()) {\n                    JsonArray enumSetJson = nodeJson.getJsonArray(name);\n                    parameters.put(name, deserializeEnumSet(enumSetJson));\n                } else if (propertyMetaModel.isNode()) {\n                    parameters.put(name, deserializeObject(nodeJson.getJsonObject(name)));\n                } else {\n                    Class<?> type = propertyMetaModel.getType();\n                    if (type == String.class) {\n                        parameters.put(name, nodeJson.getString(name));\n                    } else if (type == boolean.class) {\n                        parameters.put(name, Boolean.parseBoolean(nodeJson.getString(name)));\n                    } else if (Enum.class.isAssignableFrom(type)) {\n                        parameters.put(name, Enum.valueOf((Class<? extends Enum>) type, nodeJson.getString(name)));\n                    } else {\n                        throw new IllegalStateException(\"Don't know how to convert: \" + type);\n                    }\n                }\n            }\n\n            return nodeMetaModel.construct(parameters);\n        } catch (ClassNotFoundException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    private EnumSet<?> deserializeEnumSet(JsonArray enumSetJson) {\n        return enumSetJson.stream().map(v -> (JsonString) v).map(s -> Modifier.valueOf(s.getString())).collect(Collectors.toCollection(() -> EnumSet.noneOf(Modifier.class)));\n    }\n\n    private NodeList<?> deserializeNodeList(JsonArray nodeListJson) {\n        return nodeListJson.stream().map(nodeJson -> deserializeObject((JsonObject) nodeJson)).collect(toNodeList());\n    }\n}\n",
        "filePathAfter": "javaparser-core-serialization/src/main/java/com/github/javaparser/serialization/JavaParserJsonDeserializer.java",
        "sourceCodeAfterForWhole": "/*\n * Copyright (C) 2007-2010 J\u00falio Vilmar Gesser.\n * Copyright (C) 2011, 2013-2018 The JavaParser Team.\n *\n * This file is part of JavaParser.\n *\n * JavaParser can be used either under the terms of\n * a) the GNU Lesser General Public License as published by\n *     the Free Software Foundation, either version 3 of the License, or\n *     (at your option) any later version.\n * b) the terms of the Apache License\n *\n * You should have received a copy of both licenses in LICENCE.LGPL and\n * LICENCE.APACHE. Please refer to those files for details.\n *\n * JavaParser is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n */\npackage com.github.javaparser.serialization;\n\nimport com.github.javaparser.ast.Modifier;\nimport com.github.javaparser.ast.Node;\nimport com.github.javaparser.ast.NodeList;\nimport com.github.javaparser.metamodel.BaseNodeMetaModel;\nimport com.github.javaparser.metamodel.PropertyMetaModel;\nimport com.github.javaparser.utils.Log;\nimport com.github.javaparser.utils.Pair;\n\nimport javax.json.*;\nimport java.util.*;\nimport java.util.stream.Collectors;\n\nimport static com.github.javaparser.ast.NodeList.toNodeList;\nimport static com.github.javaparser.metamodel.JavaParserMetaModel.getNodeMetaModel;\nimport static com.github.javaparser.serialization.JavaParserJsonSerializer.SERIALIZED_CLASS_KEY;\n\n/**\n * Deserializes the JSON file that was built by {@link JavaParserJsonSerializer}.\n */\npublic class JavaParserJsonDeserializer {\n\n    public Node deserializeObject(JsonReader reader) {\n        return deserializeObject(reader, new HashMap<>());\n    }\n\n    public Node deserializeObject(JsonReader reader, Map<String, Delegate> delegates) {\n        Log.info(\"Deserializing JSON to Node.\");\n        JsonObject jsonObject = reader.readObject();\n        return deserializeObject(jsonObject, delegates);\n    }\n\n    private Node deserializeObject(JsonObject nodeJson, Map<String, Delegate> delegates) {\n        try {\n            String serializedNodeType = nodeJson.getString(SERIALIZED_CLASS_KEY);\n            BaseNodeMetaModel nodeMetaModel = getNodeMetaModel(Class.forName(serializedNodeType))\n                    .orElseThrow(() -> new IllegalStateException(\"Trying to deserialize an unknown node type: \" + serializedNodeType));\n            Map<String, Object> parameters = new HashMap<>();\n            List<Pair<String, JsonValue>> jsonValuesForDelegates = new LinkedList<>();\n            for (String name : nodeJson.keySet()) {\n                if (name.equals(SERIALIZED_CLASS_KEY)) {\n                    continue;\n                } else if (delegates.containsKey(name)) {\n                    jsonValuesForDelegates.add(\n                            new Pair<>(name, nodeJson.get(name))\n                    );\n                    continue;\n                }\n\n                PropertyMetaModel propertyMetaModel = nodeMetaModel.getAllPropertyMetaModels().stream()\n                        .filter(mm -> mm.getName().equals(name))\n                        .findFirst().orElseThrow(() -> new IllegalStateException(\"Unknown property: \" + nodeMetaModel.getQualifiedClassName() + \".\" + name));\n\n                if (propertyMetaModel.isNodeList()) {\n                    JsonArray nodeListJson = nodeJson.getJsonArray(name);\n                    parameters.put(name, deserializeNodeList(nodeListJson, delegates));\n                } else if (propertyMetaModel.isEnumSet()) {\n                    JsonArray enumSetJson = nodeJson.getJsonArray(name);\n                    parameters.put(name, deserializeEnumSet(enumSetJson));\n                } else if (propertyMetaModel.isNode()) {\n                    parameters.put(name, deserializeObject(nodeJson.getJsonObject(name), delegates));\n                } else {\n                    Class<?> type = propertyMetaModel.getType();\n                    if (type == String.class) {\n                        parameters.put(name, nodeJson.getString(name));\n                    } else if (type == boolean.class) {\n                        parameters.put(name, Boolean.parseBoolean(nodeJson.getString(name)));\n                    } else if (Enum.class.isAssignableFrom(type)) {\n                        parameters.put(name, Enum.valueOf((Class<? extends Enum>) type, nodeJson.getString(name)));\n                    } else {\n                        throw new IllegalStateException(\"Don't know how to convert: \" + type);\n                    }\n                }\n            }\n\n            Node node = nodeMetaModel.construct(parameters);\n            for (Pair<String, JsonValue> nameAndValue : jsonValuesForDelegates) {\n                delegates.get(nameAndValue.a).fromJson(nameAndValue.a, nameAndValue.b, node);\n            }\n\n            return node;\n        } catch (ClassNotFoundException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    private EnumSet<?> deserializeEnumSet(JsonArray enumSetJson) {\n        return enumSetJson.stream().map(v -> (JsonString) v).map(s -> Modifier.valueOf(s.getString())).collect(Collectors.toCollection(() -> EnumSet.noneOf(Modifier.class)));\n    }\n\n    private NodeList<?> deserializeNodeList(JsonArray nodeListJson, Map<String, Delegate> delegates) {\n        return nodeListJson.stream().map(nodeJson -> deserializeObject((JsonObject) nodeJson, delegates)).collect(toNodeList());\n    }\n\n    interface Delegate {\n        void fromJson(String propertyName, JsonValue jsonValue, Node node);\n    }\n}\n",
        "diffSourceCodeSet": [
            "public Node deserializeObject(JsonReader reader, Map<String, Delegate> delegates) {\n        Log.info(\"Deserializing JSON to Node.\");\n        JsonObject jsonObject = reader.readObject();\n        return deserializeObject(jsonObject, delegates);\n    }"
        ],
        "invokedMethodSet": [
            "methodSignature: com.github.javaparser.serialization.JavaParserJsonDeserializer#deserializeObject\n methodBody: private Node deserializeObject(JsonObject nodeJson) {\ntryString serializedNodeType=nodeJson.getString(SERIALIZED_CLASS_KEY);\nBaseNodeMetaModel nodeMetaModel=getNodeMetaModel(Class.forName(serializedNodeType)).orElseThrow(() -> new IllegalStateException(\"Trying to deserialize an unknown node type: \" + serializedNodeType));\nMap<String,Object> parameters=new HashMap<>();\nfor(String name: nodeJson.keySet()){if(name.equals(SERIALIZED_CLASS_KEY)){continue;\n}PropertyMetaModel propertyMetaModel=nodeMetaModel.getAllPropertyMetaModels().stream().filter(mm -> mm.getName().equals(name)).findFirst().orElseThrow(() -> new IllegalStateException(\"Unknown property: \" + nodeMetaModel.getQualifiedClassName() + \".\" + name));\nif(propertyMetaModel.isNodeList()){JsonArray nodeListJson=nodeJson.getJsonArray(name);\nparameters.put(name,deserializeNodeList(nodeListJson));\n}if(propertyMetaModel.isEnumSet()){JsonArray enumSetJson=nodeJson.getJsonArray(name);\nparameters.put(name,deserializeEnumSet(enumSetJson));\n}if(propertyMetaModel.isNode()){parameters.put(name,deserializeObject(nodeJson.getJsonObject(name)));\n}{Class<?> type=propertyMetaModel.getType();\nif(type == String.class){parameters.put(name,nodeJson.getString(name));\n}if(type == boolean.class){parameters.put(name,Boolean.parseBoolean(nodeJson.getString(name)));\n}if(Enum.class.isAssignableFrom(type)){parameters.put(name,Enum.valueOf((Class<? extends Enum>)type,nodeJson.getString(name)));\n}{throw new IllegalStateException(\"Don't know how to convert: \" + type);\n}}}return nodeMetaModel.construct(parameters);\ncatch(ClassNotFoundException e)throw new RuntimeException(e);\n}"
        ],
        "sourceCodeAfterRefactoring": "public Node deserializeObject(JsonReader reader) {\n        return deserializeObject(reader, new HashMap<>());\n    }\npublic Node deserializeObject(JsonReader reader, Map<String, Delegate> delegates) {\n        Log.info(\"Deserializing JSON to Node.\");\n        JsonObject jsonObject = reader.readObject();\n        return deserializeObject(jsonObject, delegates);\n    }",
        "diffSourceCode": "-   44:  * Deserializes the JSON file that was built by {@link JavaParserJsonSerializer}.\n-   45:  */\n-   46: public class JavaParserJsonDeserializer {\n-   48:     public Node deserializeObject(JsonReader reader) {\n+   44:     public Node deserializeObject(JsonReader reader) {\n+   45:         return deserializeObject(reader, new HashMap<>());\n+   46:     }\n+   48:     public Node deserializeObject(JsonReader reader, Map<String, Delegate> delegates) {\n    49:         Log.info(\"Deserializing JSON to Node.\");\n    50:         JsonObject jsonObject = reader.readObject();\n-   51:         return deserializeObject(jsonObject);\n+   51:         return deserializeObject(jsonObject, delegates);\n    52:     }\n",
        "uniqueId": "ef3ecbbbdebff45488e6017781f8caf59c2056fa_48_52_48_52_44_46",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 18,
                "covered": 134
            },
            "BRANCH": {
                "missed": 1,
                "covered": 15
            },
            "LINE": {
                "missed": 3,
                "covered": 27
            },
            "COMPLEXITY": {
                "missed": 1,
                "covered": 8
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 1.8
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tpublic assertProblems(result List<Problem>, expectedArg String...) : void extracted from public assertProblems(result ParseResult<?>, expectedArg String...) : void in class com.github.javaparser.utils.TestUtils",
        "diffLocations": [
            {
                "filePath": "javaparser-testing/src/test/java/com/github/javaparser/utils/TestUtils.java",
                "startLine": 129,
                "endLine": 134,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "javaparser-testing/src/test/java/com/github/javaparser/utils/TestUtils.java",
                "startLine": 126,
                "endLine": 128,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "javaparser-testing/src/test/java/com/github/javaparser/utils/TestUtils.java",
                "startLine": 130,
                "endLine": 135,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "public static void assertProblems(ParseResult<?> result, String... expectedArg) {\n        Set<String> actual = result.getProblems().stream().map(Problem::toString).collect(Collectors.toSet());\n        Set<String> expected = new HashSet<>();\n        expected.addAll(Arrays.asList(expectedArg));\n        assertCollections(expected, actual);\n    }",
        "filePathBefore": "javaparser-testing/src/test/java/com/github/javaparser/utils/TestUtils.java",
        "isPureRefactoring": true,
        "commitId": "f80c6cd0b31865ada2c77df0e159bb94646e1888",
        "packageNameBefore": "com.github.javaparser.utils",
        "classNameBefore": "com.github.javaparser.utils.TestUtils",
        "methodNameBefore": "com.github.javaparser.utils.TestUtils#assertProblems",
        "invokedMethod": "methodSignature: com.github.javaparser.utils.TestUtils#assertCollections\n methodBody: public static void assertCollections(Collection<?> expected, Collection<?> actual) {\nfinal StringBuilder out=new StringBuilder();\nfor(Object e: expected){if(actual.contains(e)){actual.remove(e);\n}{out.append(\"Missing: \").append(e).append(EOL);\n}}for(Object a: actual){out.append(\"Unexpected: \").append(a).append(EOL);\n}String s=out.toString();\nif(s.isEmpty()){return;\n}fail(s);\n}",
        "classSignatureBefore": "public class TestUtils ",
        "methodNameBeforeSet": [
            "com.github.javaparser.utils.TestUtils#assertProblems"
        ],
        "classNameBeforeSet": [
            "com.github.javaparser.utils.TestUtils"
        ],
        "classSignatureBeforeSet": [
            "public class TestUtils "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Changes are within the Extract Method refactoring mechanics",
                "description": "All replacements have been justified - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "package com.github.javaparser.utils;\n\nimport com.github.javaparser.*;\nimport com.github.javaparser.ast.expr.Expression;\nimport com.github.javaparser.ast.validator.Java9Validator;\nimport okhttp3.OkHttpClient;\nimport okhttp3.Request;\nimport okhttp3.Response;\n\nimport java.io.*;\nimport java.net.URL;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.HashSet;\nimport java.util.Set;\nimport java.util.stream.Collectors;\nimport java.util.zip.ZipEntry;\nimport java.util.zip.ZipInputStream;\n\nimport static com.github.javaparser.utils.CodeGenerationUtils.f;\nimport static com.github.javaparser.Providers.provider;\nimport static com.github.javaparser.utils.Utils.EOL;\nimport static org.junit.Assert.assertTrue;\nimport static org.junit.Assert.fail;\n\npublic class TestUtils {\n    /**\n     * Takes care of setting all the end of line character to platform specific ones.\n     */\n    public static String readResource(String resourceName) throws IOException {\n        if (resourceName.startsWith(\"/\")) {\n            resourceName = resourceName.substring(1);\n        }\n        try (final InputStream resourceAsStream = TestUtils.class.getClassLoader().getResourceAsStream(resourceName)) {\n            if (resourceAsStream == null) {\n                fail(\"not found: \" + resourceName);\n            }\n            try (final InputStreamReader reader = new InputStreamReader(resourceAsStream, \"utf-8\");\n                 final BufferedReader br = new BufferedReader(reader)) {\n                final StringBuilder builder = new StringBuilder();\n                String line;\n                while ((line = br.readLine()) != null) {\n                    builder.append(line).append(Utils.EOL);\n                }\n                return builder.toString();\n            }\n        }\n    }\n\n    public static void assertInstanceOf(Class<?> expectedType, Object instance) {\n        assertTrue(f(\"%s is not an instance of %s.\", instance.getClass(), expectedType), expectedType.isAssignableFrom(instance.getClass()));\n    }\n\n    /**\n     * Unzip a zip file into a directory.\n     */\n    public static void unzip(Path zipFile, Path outputFolder) throws IOException {\n        Log.info(\"Unzipping %s to %s\", zipFile, outputFolder);\n\n        final byte[] buffer = new byte[1024 * 1024];\n\n        outputFolder.toFile().mkdirs();\n\n        try (ZipInputStream zis = new ZipInputStream(new FileInputStream(zipFile.toFile()))) {\n            ZipEntry ze = zis.getNextEntry();\n\n            while (ze != null) {\n                final Path newFile = outputFolder.resolve(ze.getName());\n\n                if (ze.isDirectory()) {\n                    Log.trace(\"mkdir %s\", newFile.toAbsolutePath());\n                    newFile.toFile().mkdirs();\n                } else {\n                    Log.info(\"unzip %s\", newFile.toAbsolutePath());\n                    try (FileOutputStream fos = new FileOutputStream(newFile.toFile())) {\n                        int len;\n                        while ((len = zis.read(buffer)) > 0) {\n                            fos.write(buffer, 0, len);\n                        }\n                    }\n                }\n                zis.closeEntry();\n                ze = zis.getNextEntry();\n            }\n\n        }\n        Log.info(\"Unzipped %s to %s\", zipFile, outputFolder);\n    }\n\n    /**\n     * Download a file from a URL to disk.\n     */\n    public static void download(URL url, Path destination) throws IOException {\n        OkHttpClient client = new OkHttpClient();\n        Request request = new Request.Builder()\n                .url(url)\n                .build();\n\n        Response response = client.newCall(request).execute();\n        Files.write(destination, response.body().bytes());\n    }\n\n    public static String temporaryDirectory() {\n        return System.getProperty(\"java.io.tmpdir\");\n    }\n\n    public static void assertCollections(Collection<?> expected, Collection<?> actual) {\n        final StringBuilder out = new StringBuilder();\n        for (Object e : expected) {\n            if (actual.contains(e)) {\n                actual.remove(e);\n            } else {\n                out.append(\"Missing: \").append(e).append(EOL);\n            }\n        }\n        for (Object a : actual) {\n            out.append(\"Unexpected: \").append(a).append(EOL);\n        }\n\n        String s = out.toString();\n        if (s.isEmpty()) {\n            return;\n        }\n        fail(s);\n    }\n\n    public static void assertProblems(ParseResult<?> result, String... expectedArg) {\n        Set<String> actual = result.getProblems().stream().map(Problem::toString).collect(Collectors.toSet());\n        Set<String> expected = new HashSet<>();\n        expected.addAll(Arrays.asList(expectedArg));\n        assertCollections(expected, actual);\n    }\n\n    public static void assertNoProblems(ParseResult<?> result) {\n        assertProblems(result);\n    }\n\n    public static void assertExpressionValid(String expression) {\n        JavaParser javaParser = new JavaParser(new ParserConfiguration().setValidator(new Java9Validator()));\n        ParseResult<Expression> result = javaParser.parse(ParseStart.EXPRESSION, provider(expression));\n        assertTrue(result.getProblems().toString(), result.isSuccessful());\n    }\n}\n",
        "filePathAfter": "javaparser-testing/src/test/java/com/github/javaparser/utils/TestUtils.java",
        "sourceCodeAfterForWhole": "package com.github.javaparser.utils;\n\nimport com.github.javaparser.*;\nimport com.github.javaparser.ast.expr.Expression;\nimport com.github.javaparser.ast.validator.Java9Validator;\nimport okhttp3.OkHttpClient;\nimport okhttp3.Request;\nimport okhttp3.Response;\n\nimport java.io.*;\nimport java.net.URL;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.*;\nimport java.util.stream.Collectors;\nimport java.util.zip.ZipEntry;\nimport java.util.zip.ZipInputStream;\n\nimport static com.github.javaparser.utils.CodeGenerationUtils.f;\nimport static com.github.javaparser.Providers.provider;\nimport static com.github.javaparser.utils.Utils.EOL;\nimport static org.junit.Assert.assertTrue;\nimport static org.junit.Assert.fail;\n\npublic class TestUtils {\n    /**\n     * Takes care of setting all the end of line character to platform specific ones.\n     */\n    public static String readResource(String resourceName) throws IOException {\n        if (resourceName.startsWith(\"/\")) {\n            resourceName = resourceName.substring(1);\n        }\n        try (final InputStream resourceAsStream = TestUtils.class.getClassLoader().getResourceAsStream(resourceName)) {\n            if (resourceAsStream == null) {\n                fail(\"not found: \" + resourceName);\n            }\n            try (final InputStreamReader reader = new InputStreamReader(resourceAsStream, \"utf-8\");\n                 final BufferedReader br = new BufferedReader(reader)) {\n                final StringBuilder builder = new StringBuilder();\n                String line;\n                while ((line = br.readLine()) != null) {\n                    builder.append(line).append(Utils.EOL);\n                }\n                return builder.toString();\n            }\n        }\n    }\n\n    public static void assertInstanceOf(Class<?> expectedType, Object instance) {\n        assertTrue(f(\"%s is not an instance of %s.\", instance.getClass(), expectedType), expectedType.isAssignableFrom(instance.getClass()));\n    }\n\n    /**\n     * Unzip a zip file into a directory.\n     */\n    public static void unzip(Path zipFile, Path outputFolder) throws IOException {\n        Log.info(\"Unzipping %s to %s\", zipFile, outputFolder);\n\n        final byte[] buffer = new byte[1024 * 1024];\n\n        outputFolder.toFile().mkdirs();\n\n        try (ZipInputStream zis = new ZipInputStream(new FileInputStream(zipFile.toFile()))) {\n            ZipEntry ze = zis.getNextEntry();\n\n            while (ze != null) {\n                final Path newFile = outputFolder.resolve(ze.getName());\n\n                if (ze.isDirectory()) {\n                    Log.trace(\"mkdir %s\", newFile.toAbsolutePath());\n                    newFile.toFile().mkdirs();\n                } else {\n                    Log.info(\"unzip %s\", newFile.toAbsolutePath());\n                    try (FileOutputStream fos = new FileOutputStream(newFile.toFile())) {\n                        int len;\n                        while ((len = zis.read(buffer)) > 0) {\n                            fos.write(buffer, 0, len);\n                        }\n                    }\n                }\n                zis.closeEntry();\n                ze = zis.getNextEntry();\n            }\n\n        }\n        Log.info(\"Unzipped %s to %s\", zipFile, outputFolder);\n    }\n\n    /**\n     * Download a file from a URL to disk.\n     */\n    public static void download(URL url, Path destination) throws IOException {\n        OkHttpClient client = new OkHttpClient();\n        Request request = new Request.Builder()\n                .url(url)\n                .build();\n\n        Response response = client.newCall(request).execute();\n        Files.write(destination, response.body().bytes());\n    }\n\n    public static String temporaryDirectory() {\n        return System.getProperty(\"java.io.tmpdir\");\n    }\n\n    public static void assertCollections(Collection<?> expected, Collection<?> actual) {\n        final StringBuilder out = new StringBuilder();\n        for (Object e : expected) {\n            if (actual.contains(e)) {\n                actual.remove(e);\n            } else {\n                out.append(\"Missing: \").append(e).append(EOL);\n            }\n        }\n        for (Object a : actual) {\n            out.append(\"Unexpected: \").append(a).append(EOL);\n        }\n\n        String s = out.toString();\n        if (s.isEmpty()) {\n            return;\n        }\n        fail(s);\n    }\n\n    public static void assertProblems(ParseResult<?> result, String... expectedArg) {\n        assertProblems(result.getProblems(), expectedArg);\n    }\n\n    public static void assertProblems(List<Problem> result, String... expectedArg) {\n        Set<String> actual = result.stream().map(Problem::toString).collect(Collectors.toSet());\n        Set<String> expected = new HashSet<>();\n        expected.addAll(Arrays.asList(expectedArg));\n        assertCollections(expected, actual);\n    }\n\n    public static void assertNoProblems(ParseResult<?> result) {\n        assertProblems(result);\n    }\n\n    public static void assertExpressionValid(String expression) {\n        JavaParser javaParser = new JavaParser(new ParserConfiguration().setValidator(new Java9Validator()));\n        ParseResult<Expression> result = javaParser.parse(ParseStart.EXPRESSION, provider(expression));\n        assertTrue(result.getProblems().toString(), result.isSuccessful());\n    }\n}\n",
        "diffSourceCodeSet": [
            "public static void assertProblems(List<Problem> result, String... expectedArg) {\n        Set<String> actual = result.stream().map(Problem::toString).collect(Collectors.toSet());\n        Set<String> expected = new HashSet<>();\n        expected.addAll(Arrays.asList(expectedArg));\n        assertCollections(expected, actual);\n    }"
        ],
        "invokedMethodSet": [
            "methodSignature: com.github.javaparser.utils.TestUtils#assertCollections\n methodBody: public static void assertCollections(Collection<?> expected, Collection<?> actual) {\nfinal StringBuilder out=new StringBuilder();\nfor(Object e: expected){if(actual.contains(e)){actual.remove(e);\n}{out.append(\"Missing: \").append(e).append(EOL);\n}}for(Object a: actual){out.append(\"Unexpected: \").append(a).append(EOL);\n}String s=out.toString();\nif(s.isEmpty()){return;\n}fail(s);\n}"
        ],
        "sourceCodeAfterRefactoring": "public static void assertProblems(ParseResult<?> result, String... expectedArg) {\n        assertProblems(result.getProblems(), expectedArg);\n    }\npublic static void assertProblems(List<Problem> result, String... expectedArg) {\n        Set<String> actual = result.stream().map(Problem::toString).collect(Collectors.toSet());\n        Set<String> expected = new HashSet<>();\n        expected.addAll(Arrays.asList(expectedArg));\n        assertCollections(expected, actual);\n    }",
        "diffSourceCode": "-  126:         fail(s);\n-  127:     }\n-  128: \n-  129:     public static void assertProblems(ParseResult<?> result, String... expectedArg) {\n-  130:         Set<String> actual = result.getProblems().stream().map(Problem::toString).collect(Collectors.toSet());\n-  131:         Set<String> expected = new HashSet<>();\n-  132:         expected.addAll(Arrays.asList(expectedArg));\n-  133:         assertCollections(expected, actual);\n-  134:     }\n-  135: \n+  126:     public static void assertProblems(ParseResult<?> result, String... expectedArg) {\n+  127:         assertProblems(result.getProblems(), expectedArg);\n+  128:     }\n+  129: \n+  130:     public static void assertProblems(List<Problem> result, String... expectedArg) {\n+  131:         Set<String> actual = result.stream().map(Problem::toString).collect(Collectors.toSet());\n+  132:         Set<String> expected = new HashSet<>();\n+  133:         expected.addAll(Arrays.asList(expectedArg));\n+  134:         assertCollections(expected, actual);\n+  135:     }\n",
        "uniqueId": "f80c6cd0b31865ada2c77df0e159bb94646e1888_129_134_130_135_126_128",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "testMethod": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 1.8
    },
    {
        "type": "Move Method",
        "description": "Move Method\tpublic moduleRequires() : void from class com.github.javaparser.ast.validator.Java1_2ValidatorTest to public moduleRequires() : void from class com.github.javaparser.ast.validator.Java9ValidatorTest",
        "diffLocations": [
            {
                "filePath": "javaparser-testing/src/test/java/com/github/javaparser/ast/validator/Java1_2ValidatorTest.java",
                "startLine": 110,
                "endLine": 129,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "javaparser-testing/src/test/java/com/github/javaparser/ast/validator/Java9ValidatorTest.java",
                "startLine": 31,
                "endLine": 50,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "@Test\n    public void moduleRequires() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(\"module x{requires \" + allModifiers + \" a;}\"));\n        assertProblems(result,\n                \"(line 1,col 10) Can have only one of 'public', 'protected', 'private'.\",\n                \"(line 1,col 10) Can have only one of 'final', 'abstract'.\",\n                \"(line 1,col 10) Can have only one of 'native', 'strictfp'.\",\n                \"(line 1,col 10) 'transient' is not allowed here.\",\n                \"(line 1,col 10) 'volatile' is not allowed here.\",\n                \"(line 1,col 10) 'final' is not allowed here.\",\n                \"(line 1,col 10) 'synchronized' is not allowed here.\",\n                \"(line 1,col 10) 'default' is not allowed here.\",\n                \"(line 1,col 10) 'native' is not allowed here.\",\n                \"(line 1,col 10) 'private' is not allowed here.\",\n                \"(line 1,col 10) 'protected' is not allowed here.\",\n                \"(line 1,col 10) 'strictfp' is not allowed here.\",\n                \"(line 1,col 10) 'abstract' is not allowed here.\",\n                \"(line 1,col 10) 'public' is not allowed here.\"\n        );\n    }",
        "filePathBefore": "javaparser-testing/src/test/java/com/github/javaparser/ast/validator/Java1_2ValidatorTest.java",
        "isPureRefactoring": true,
        "commitId": "60236c613723e7add97cc5e529d0d9bad02872ff",
        "packageNameBefore": "com.github.javaparser.ast.validator",
        "classNameBefore": "com.github.javaparser.ast.validator.Java1_2ValidatorTest",
        "methodNameBefore": "com.github.javaparser.ast.validator.Java1_2ValidatorTest#moduleRequires",
        "classSignatureBefore": "public class Java1_2ValidatorTest ",
        "methodNameBeforeSet": [
            "com.github.javaparser.ast.validator.Java1_2ValidatorTest#moduleRequires"
        ],
        "classNameBeforeSet": [
            "com.github.javaparser.ast.validator.Java1_2ValidatorTest"
        ],
        "classSignatureBeforeSet": [
            "public class Java1_2ValidatorTest "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "package com.github.javaparser.ast.validator;\n\nimport com.github.javaparser.JavaParser;\nimport com.github.javaparser.ParseResult;\nimport com.github.javaparser.ParserConfiguration;\nimport com.github.javaparser.ast.CompilationUnit;\nimport org.junit.Test;\n\nimport static com.github.javaparser.ParseStart.COMPILATION_UNIT;\nimport static com.github.javaparser.Providers.provider;\nimport static com.github.javaparser.utils.TestUtils.assertProblems;\n\npublic class Java1_2ValidatorTest {\n    public static final JavaParser javaParser = new JavaParser(new ParserConfiguration().setValidator(new Java1_2Validator()));\n\n    private final String allModifiers = \"public protected private abstract static final transient volatile synchronized native strictfp transitive default \";\n\n    @Test\n    public void topClass() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(allModifiers + \"class X{}\"));\n        assertProblems(result,\n                \"(line 1,col 1) Can have only one of 'public', 'protected', 'private'.\",\n                \"(line 1,col 1) Can have only one of 'final', 'abstract'.\",\n                \"(line 1,col 1) Can have only one of 'native', 'strictfp'.\",\n                \"(line 1,col 1) 'transient' is not allowed here.\",\n                \"(line 1,col 1) 'default' is not allowed here.\",\n                \"(line 1,col 1) 'volatile' is not allowed here.\",\n                \"(line 1,col 1) 'private' is not allowed here.\",\n                \"(line 1,col 1) 'protected' is not allowed here.\",\n                \"(line 1,col 1) 'synchronized' is not allowed here.\",\n                \"(line 1,col 1) 'native' is not allowed here.\",\n                \"(line 1,col 1) 'transitive' is not allowed here.\",\n                \"(line 1,col 1) 'static' is not allowed here.\"\n        );\n    }\n\n    @Test\n    public void nestedClass() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(\"class X{\" + allModifiers + \"class I{}}\"));\n        assertProblems(result,\n                \"(line 1,col 9) Can have only one of 'public', 'protected', 'private'.\",\n                \"(line 1,col 9) Can have only one of 'final', 'abstract'.\",\n                \"(line 1,col 9) Can have only one of 'native', 'strictfp'.\",\n                \"(line 1,col 9) 'transient' is not allowed here.\",\n                \"(line 1,col 9) 'default' is not allowed here.\",\n                \"(line 1,col 9) 'volatile' is not allowed here.\",\n                \"(line 1,col 9) 'synchronized' is not allowed here.\",\n                \"(line 1,col 9) 'native' is not allowed here.\",\n                \"(line 1,col 9) 'transitive' is not allowed here.\"\n        );\n    }\n\n    @Test\n    public void localClass() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(\"class X{ void x() {\" + allModifiers + \"class I{}}}\"));\n        assertProblems(result,\n                \"(line 1,col 20) Can have only one of 'public', 'protected', 'private'.\",\n                \"(line 1,col 20) Can have only one of 'final', 'abstract'.\",\n                \"(line 1,col 20) Can have only one of 'native', 'strictfp'.\",\n                \"(line 1,col 20) 'transient' is not allowed here.\",\n                \"(line 1,col 20) 'volatile' is not allowed here.\",\n                \"(line 1,col 20) 'default' is not allowed here.\",\n                \"(line 1,col 20) 'synchronized' is not allowed here.\",\n                \"(line 1,col 20) 'native' is not allowed here.\",\n                \"(line 1,col 20) 'transitive' is not allowed here.\",\n                \"(line 1,col 20) 'static' is not allowed here.\",\n                \"(line 1,col 20) 'public' is not allowed here.\",\n                \"(line 1,col 20) 'private' is not allowed here.\",\n                \"(line 1,col 20) 'protected' is not allowed here.\"\n        );\n    }\n\n    @Test\n    public void topInterface() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(allModifiers + \"interface X{}\"));\n        assertProblems(result,\n                \"(line 1,col 1) Can have only one of 'public', 'protected', 'private'.\",\n                \"(line 1,col 1) Can have only one of 'final', 'abstract'.\",\n                \"(line 1,col 1) Can have only one of 'native', 'strictfp'.\",\n                \"(line 1,col 1) 'transient' is not allowed here.\",\n                \"(line 1,col 1) 'volatile' is not allowed here.\",\n                \"(line 1,col 1) 'default' is not allowed here.\",\n                \"(line 1,col 1) 'synchronized' is not allowed here.\",\n                \"(line 1,col 1) 'native' is not allowed here.\",\n                \"(line 1,col 1) 'transitive' is not allowed here.\",\n                \"(line 1,col 1) 'static' is not allowed here.\",\n                \"(line 1,col 1) 'final' is not allowed here.\",\n                \"(line 1,col 1) 'private' is not allowed here.\",\n                \"(line 1,col 1) 'protected' is not allowed here.\"\n        );\n    }\n\n    @Test\n    public void nestedInterface() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(\"class X{\" + allModifiers + \"interface I{}}\"));\n        assertProblems(result,\n                \"(line 1,col 9) Can have only one of 'public', 'protected', 'private'.\",\n                \"(line 1,col 9) Can have only one of 'final', 'abstract'.\",\n                \"(line 1,col 9) Can have only one of 'native', 'strictfp'.\",\n                \"(line 1,col 9) 'transient' is not allowed here.\",\n                \"(line 1,col 9) 'volatile' is not allowed here.\",\n                \"(line 1,col 9) 'default' is not allowed here.\",\n                \"(line 1,col 9) 'final' is not allowed here.\",\n                \"(line 1,col 9) 'synchronized' is not allowed here.\",\n                \"(line 1,col 9) 'native' is not allowed here.\",\n                \"(line 1,col 9) 'transitive' is not allowed here.\"\n        );\n    }\n\n    @Test\n    public void moduleRequires() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(\"module x{requires \" + allModifiers + \" a;}\"));\n        assertProblems(result,\n                \"(line 1,col 10) Can have only one of 'public', 'protected', 'private'.\",\n                \"(line 1,col 10) Can have only one of 'final', 'abstract'.\",\n                \"(line 1,col 10) Can have only one of 'native', 'strictfp'.\",\n                \"(line 1,col 10) 'transient' is not allowed here.\",\n                \"(line 1,col 10) 'volatile' is not allowed here.\",\n                \"(line 1,col 10) 'final' is not allowed here.\",\n                \"(line 1,col 10) 'synchronized' is not allowed here.\",\n                \"(line 1,col 10) 'default' is not allowed here.\",\n                \"(line 1,col 10) 'native' is not allowed here.\",\n                \"(line 1,col 10) 'private' is not allowed here.\",\n                \"(line 1,col 10) 'protected' is not allowed here.\",\n                \"(line 1,col 10) 'strictfp' is not allowed here.\",\n                \"(line 1,col 10) 'abstract' is not allowed here.\",\n                \"(line 1,col 10) 'public' is not allowed here.\"\n        );\n    }\n\n    @Test\n    public void constructor() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(\"class X{\" + allModifiers + \"X(){};}\"));\n        assertProblems(result,\n                \"(line 1,col 9) Can have only one of 'public', 'protected', 'private'.\",\n                \"(line 1,col 9) Can have only one of 'final', 'abstract'.\",\n                \"(line 1,col 9) Can have only one of 'native', 'strictfp'.\",\n                \"(line 1,col 9) 'transient' is not allowed here.\",\n                \"(line 1,col 9) 'volatile' is not allowed here.\",\n                \"(line 1,col 9) 'final' is not allowed here.\",\n                \"(line 1,col 9) 'synchronized' is not allowed here.\",\n                \"(line 1,col 9) 'default' is not allowed here.\",\n                \"(line 1,col 9) 'native' is not allowed here.\",\n                \"(line 1,col 9) 'strictfp' is not allowed here.\",\n                \"(line 1,col 9) 'abstract' is not allowed here.\",\n                \"(line 1,col 9) 'static' is not allowed here.\",\n                \"(line 1,col 9) 'transitive' is not allowed here.\"\n        );\n    }\n\n    @Test\n    public void constructorParameter() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(\"class X{X(\" + allModifiers + \" int i){};}\"));\n        assertProblems(result,\n                \"(line 1,col 11) Can have only one of 'public', 'protected', 'private'.\",\n                \"(line 1,col 11) Can have only one of 'final', 'abstract'.\",\n                \"(line 1,col 11) Can have only one of 'native', 'strictfp'.\",\n                \"(line 1,col 11) 'transient' is not allowed here.\",\n                \"(line 1,col 11) 'volatile' is not allowed here.\",\n                \"(line 1,col 11) 'synchronized' is not allowed here.\",\n                \"(line 1,col 11) 'native' is not allowed here.\",\n                \"(line 1,col 11) 'strictfp' is not allowed here.\",\n                \"(line 1,col 11) 'default' is not allowed here.\",\n                \"(line 1,col 11) 'abstract' is not allowed here.\",\n                \"(line 1,col 11) 'static' is not allowed here.\",\n                \"(line 1,col 11) 'transitive' is not allowed here.\",\n                \"(line 1,col 11) 'private' is not allowed here.\",\n                \"(line 1,col 11) 'public' is not allowed here.\",\n                \"(line 1,col 11) 'protected' is not allowed here.\"\n        );\n    }\n\n    @Test\n    public void classMethod() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(\"class X{\" + allModifiers + \"int x(){};}\"));\n        assertProblems(result,\n                \"(line 1,col 9) Can have only one of 'public', 'protected', 'private'.\",\n                \"(line 1,col 9) Can have only one of 'final', 'abstract'.\",\n                \"(line 1,col 9) Can have only one of 'native', 'strictfp'.\",\n                \"(line 1,col 9) Cannot be 'abstract' and also 'private', 'static', 'final', 'native', 'strictfp', 'synchronized'.\",\n                \"(line 1,col 9) 'transient' is not allowed here.\",\n                \"(line 1,col 9) 'default' is not allowed here.\",\n                \"(line 1,col 9) 'volatile' is not allowed here.\",\n                \"(line 1,col 9) 'transitive' is not allowed here.\"\n        );\n    }\n\n    @Test\n    public void interfaceMethod() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(\"interface X{\" + allModifiers + \"int x(){};}\"));\n        assertProblems(result,\n                \"(line 1,col 13) Can have only one of 'public', 'protected', 'private'.\",\n                \"(line 1,col 13) Can have only one of 'final', 'abstract'.\",\n                \"(line 1,col 13) Can have only one of 'native', 'strictfp'.\",\n                \"(line 1,col 13) Cannot be 'abstract' and also 'private', 'static', 'final', 'native', 'strictfp', 'synchronized'.\",\n                \"(line 1,col 13) 'transient' is not allowed here.\",\n                \"(line 1,col 13) 'volatile' is not allowed here.\",\n                \"(line 1,col 13) 'default' is not allowed here.\",\n                \"(line 1,col 13) 'transitive' is not allowed here.\"\n        );\n    }\n\n    @Test\n    public void methodParameter() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(\"class X{int x(\" + allModifiers + \" int i){};}\"));\n        assertProblems(result,\n                \"(line 1,col 15) Can have only one of 'public', 'protected', 'private'.\",\n                \"(line 1,col 15) Can have only one of 'final', 'abstract'.\",\n                \"(line 1,col 15) Can have only one of 'native', 'strictfp'.\",\n                \"(line 1,col 15) 'transient' is not allowed here.\",\n                \"(line 1,col 15) 'volatile' is not allowed here.\",\n                \"(line 1,col 15) 'synchronized' is not allowed here.\",\n                \"(line 1,col 15) 'native' is not allowed here.\",\n                \"(line 1,col 15) 'strictfp' is not allowed here.\",\n                \"(line 1,col 15) 'abstract' is not allowed here.\",\n                \"(line 1,col 15) 'default' is not allowed here.\",\n                \"(line 1,col 15) 'static' is not allowed here.\",\n                \"(line 1,col 15) 'transitive' is not allowed here.\",\n                \"(line 1,col 15) 'private' is not allowed here.\",\n                \"(line 1,col 15) 'public' is not allowed here.\",\n                \"(line 1,col 15) 'protected' is not allowed here.\"\n        );\n    }\n\n    @Test\n    public void field() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(\"class X{\" + allModifiers + \"int i;}\"));\n        assertProblems(result,\n                \"(line 1,col 9) Can have only one of 'public', 'protected', 'private'.\",\n                \"(line 1,col 9) Can have only one of 'final', 'abstract'.\",\n                \"(line 1,col 9) Can have only one of 'native', 'strictfp'.\",\n                \"(line 1,col 9) 'synchronized' is not allowed here.\",\n                \"(line 1,col 9) 'native' is not allowed here.\",\n                \"(line 1,col 9) 'strictfp' is not allowed here.\",\n                \"(line 1,col 9) 'default' is not allowed here.\",\n                \"(line 1,col 9) 'abstract' is not allowed here.\",\n                \"(line 1,col 9) 'transitive' is not allowed here.\"\n        );\n    }\n\n    @Test\n    public void localVariable() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(\"class X{int x(){\" + allModifiers + \"int i;}}\"));\n        assertProblems(result,\n                \"(line 1,col 17) Can have only one of 'public', 'protected', 'private'.\",\n                \"(line 1,col 17) Can have only one of 'final', 'abstract'.\",\n                \"(line 1,col 17) Can have only one of 'native', 'strictfp'.\",\n                \"(line 1,col 17) 'transient' is not allowed here.\",\n                \"(line 1,col 17) 'volatile' is not allowed here.\",\n                \"(line 1,col 17) 'synchronized' is not allowed here.\",\n                \"(line 1,col 17) 'native' is not allowed here.\",\n                \"(line 1,col 17) 'default' is not allowed here.\",\n                \"(line 1,col 17) 'strictfp' is not allowed here.\",\n                \"(line 1,col 17) 'abstract' is not allowed here.\",\n                \"(line 1,col 17) 'static' is not allowed here.\",\n                \"(line 1,col 17) 'transitive' is not allowed here.\",\n                \"(line 1,col 17) 'private' is not allowed here.\",\n                \"(line 1,col 17) 'public' is not allowed here.\",\n                \"(line 1,col 17) 'protected' is not allowed here.\"\n        );\n    }\n\n    @Test\n    public void catchParameter() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(\"class X{int x(){ try{}catch(\"+ allModifiers +\" Integer x){}}}\"));\n        assertProblems(result,\n                \"(line 1,col 144) Can have only one of 'public', 'protected', 'private'.\",\n                \"(line 1,col 144) Can have only one of 'final', 'abstract'.\",\n                \"(line 1,col 144) Can have only one of 'native', 'strictfp'.\",\n                \"(line 1,col 144) 'transient' is not allowed here.\",\n                \"(line 1,col 144) 'volatile' is not allowed here.\",\n                \"(line 1,col 144) 'synchronized' is not allowed here.\",\n                \"(line 1,col 144) 'native' is not allowed here.\",\n                \"(line 1,col 144) 'default' is not allowed here.\",\n                \"(line 1,col 144) 'strictfp' is not allowed here.\",\n                \"(line 1,col 144) 'abstract' is not allowed here.\",\n                \"(line 1,col 144) 'static' is not allowed here.\",\n                \"(line 1,col 144) 'transitive' is not allowed here.\",\n                \"(line 1,col 144) 'private' is not allowed here.\",\n                \"(line 1,col 144) 'public' is not allowed here.\",\n                \"(line 1,col 144) 'protected' is not allowed here.\"\n        );\n    }\n}\n",
        "filePathAfter": "javaparser-testing/src/test/java/com/github/javaparser/ast/validator/Java9ValidatorTest.java",
        "sourceCodeAfterForWhole": "package com.github.javaparser.ast.validator;\n\nimport com.github.javaparser.JavaParser;\nimport com.github.javaparser.ParseResult;\nimport com.github.javaparser.ParserConfiguration;\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.stmt.Statement;\nimport org.junit.Test;\n\nimport static com.github.javaparser.ParseStart.COMPILATION_UNIT;\nimport static com.github.javaparser.ParseStart.STATEMENT;\nimport static com.github.javaparser.Providers.provider;\nimport static com.github.javaparser.ast.validator.Java1_1ValidatorTest.allModifiers;\nimport static com.github.javaparser.utils.TestUtils.assertNoProblems;\nimport static com.github.javaparser.utils.TestUtils.assertProblems;\n\npublic class Java9ValidatorTest {\n    public static final JavaParser javaParser = new JavaParser(new ParserConfiguration().setValidator(new Java9Validator()));\n\n    @Test\n    public void underscoreIdentifiers() {\n        ParseResult<Statement> result = javaParser.parse(STATEMENT, provider(\"a.b._.c.d = act(_, _ -> _);\"));\n        assertProblems(result,\n                \"(line 1,col 5) '_' is a reserved keyword.\",\n                \"(line 1,col 17) '_' is a reserved keyword.\",\n                \"(line 1,col 20) '_' is a reserved keyword.\",\n                \"(line 1,col 25) '_' is a reserved keyword.\"\n        );\n    }\n\n    @Test\n    public void moduleRequires() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(\"module x{requires \" + allModifiers + \" a;}\"));\n        assertProblems(result,\n                \"(line 1,col 10) Can have only one of 'public', 'protected', 'private'.\",\n                \"(line 1,col 10) Can have only one of 'final', 'abstract'.\",\n                \"(line 1,col 10) Can have only one of 'native', 'strictfp'.\",\n                \"(line 1,col 10) 'transient' is not allowed here.\",\n                \"(line 1,col 10) 'volatile' is not allowed here.\",\n                \"(line 1,col 10) 'final' is not allowed here.\",\n                \"(line 1,col 10) 'synchronized' is not allowed here.\",\n                \"(line 1,col 10) 'default' is not allowed here.\",\n                \"(line 1,col 10) 'native' is not allowed here.\",\n                \"(line 1,col 10) 'private' is not allowed here.\",\n                \"(line 1,col 10) 'protected' is not allowed here.\",\n                \"(line 1,col 10) 'strictfp' is not allowed here.\",\n                \"(line 1,col 10) 'abstract' is not allowed here.\",\n                \"(line 1,col 10) 'public' is not allowed here.\"\n        );\n    }\n\n    @Test\n    public void modules() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(\"open module x {}\"));\n        assertNoProblems(result);\n    }\n}\n",
        "diffSourceCodeSet": [],
        "invokedMethodSet": [],
        "sourceCodeAfterRefactoring": "@Test\n    public void moduleRequires() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(\"module x{requires \" + allModifiers + \" a;}\"));\n        assertProblems(result,\n                \"(line 1,col 10) Can have only one of 'public', 'protected', 'private'.\",\n                \"(line 1,col 10) Can have only one of 'final', 'abstract'.\",\n                \"(line 1,col 10) Can have only one of 'native', 'strictfp'.\",\n                \"(line 1,col 10) 'transient' is not allowed here.\",\n                \"(line 1,col 10) 'volatile' is not allowed here.\",\n                \"(line 1,col 10) 'final' is not allowed here.\",\n                \"(line 1,col 10) 'synchronized' is not allowed here.\",\n                \"(line 1,col 10) 'default' is not allowed here.\",\n                \"(line 1,col 10) 'native' is not allowed here.\",\n                \"(line 1,col 10) 'private' is not allowed here.\",\n                \"(line 1,col 10) 'protected' is not allowed here.\",\n                \"(line 1,col 10) 'strictfp' is not allowed here.\",\n                \"(line 1,col 10) 'abstract' is not allowed here.\",\n                \"(line 1,col 10) 'public' is not allowed here.\"\n        );\n    }",
        "diffSourceCode": "-   31:                 \"(line 1,col 1) 'native' is not allowed here.\",\n-   32:                 \"(line 1,col 1) 'transitive' is not allowed here.\",\n-   33:                 \"(line 1,col 1) 'static' is not allowed here.\"\n-   34:         );\n-   35:     }\n-   36: \n-   37:     @Test\n-   38:     public void nestedClass() {\n-   39:         ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(\"class X{\" + allModifiers + \"class I{}}\"));\n-   40:         assertProblems(result,\n-   41:                 \"(line 1,col 9) Can have only one of 'public', 'protected', 'private'.\",\n-   42:                 \"(line 1,col 9) Can have only one of 'final', 'abstract'.\",\n-   43:                 \"(line 1,col 9) Can have only one of 'native', 'strictfp'.\",\n-   44:                 \"(line 1,col 9) 'transient' is not allowed here.\",\n-   45:                 \"(line 1,col 9) 'default' is not allowed here.\",\n-   46:                 \"(line 1,col 9) 'volatile' is not allowed here.\",\n-   47:                 \"(line 1,col 9) 'synchronized' is not allowed here.\",\n-   48:                 \"(line 1,col 9) 'native' is not allowed here.\",\n-   49:                 \"(line 1,col 9) 'transitive' is not allowed here.\"\n-   50:         );\n-  110:     @Test\n-  111:     public void moduleRequires() {\n-  112:         ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(\"module x{requires \" + allModifiers + \" a;}\"));\n-  113:         assertProblems(result,\n-  114:                 \"(line 1,col 10) Can have only one of 'public', 'protected', 'private'.\",\n-  115:                 \"(line 1,col 10) Can have only one of 'final', 'abstract'.\",\n-  116:                 \"(line 1,col 10) Can have only one of 'native', 'strictfp'.\",\n-  117:                 \"(line 1,col 10) 'transient' is not allowed here.\",\n-  118:                 \"(line 1,col 10) 'volatile' is not allowed here.\",\n-  119:                 \"(line 1,col 10) 'final' is not allowed here.\",\n-  120:                 \"(line 1,col 10) 'synchronized' is not allowed here.\",\n-  121:                 \"(line 1,col 10) 'default' is not allowed here.\",\n-  122:                 \"(line 1,col 10) 'native' is not allowed here.\",\n-  123:                 \"(line 1,col 10) 'private' is not allowed here.\",\n-  124:                 \"(line 1,col 10) 'protected' is not allowed here.\",\n-  125:                 \"(line 1,col 10) 'strictfp' is not allowed here.\",\n-  126:                 \"(line 1,col 10) 'abstract' is not allowed here.\",\n-  127:                 \"(line 1,col 10) 'public' is not allowed here.\"\n-  128:         );\n-  129:     }\n+   31:     @Test\n+   32:     public void moduleRequires() {\n+   33:         ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(\"module x{requires \" + allModifiers + \" a;}\"));\n+   34:         assertProblems(result,\n+   35:                 \"(line 1,col 10) Can have only one of 'public', 'protected', 'private'.\",\n+   36:                 \"(line 1,col 10) Can have only one of 'final', 'abstract'.\",\n+   37:                 \"(line 1,col 10) Can have only one of 'native', 'strictfp'.\",\n+   38:                 \"(line 1,col 10) 'transient' is not allowed here.\",\n+   39:                 \"(line 1,col 10) 'volatile' is not allowed here.\",\n+   40:                 \"(line 1,col 10) 'final' is not allowed here.\",\n+   41:                 \"(line 1,col 10) 'synchronized' is not allowed here.\",\n+   42:                 \"(line 1,col 10) 'default' is not allowed here.\",\n+   43:                 \"(line 1,col 10) 'native' is not allowed here.\",\n+   44:                 \"(line 1,col 10) 'private' is not allowed here.\",\n+   45:                 \"(line 1,col 10) 'protected' is not allowed here.\",\n+   46:                 \"(line 1,col 10) 'strictfp' is not allowed here.\",\n+   47:                 \"(line 1,col 10) 'abstract' is not allowed here.\",\n+   48:                 \"(line 1,col 10) 'public' is not allowed here.\"\n+   49:         );\n+   50:     }\n",
        "uniqueId": "60236c613723e7add97cc5e529d0d9bad02872ff_110_129__31_50",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "testMethod": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 1.8
    },
    {
        "type": "Move Method",
        "description": "Move Method\tpublic nestedEnum() : void from class com.github.javaparser.ast.validator.Java1_2ValidatorTest to public nestedEnum() : void from class com.github.javaparser.ast.validator.Java5ValidatorTest",
        "diffLocations": [
            {
                "filePath": "javaparser-testing/src/test/java/com/github/javaparser/ast/validator/Java1_2ValidatorTest.java",
                "startLine": 131,
                "endLine": 147,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "javaparser-testing/src/test/java/com/github/javaparser/ast/validator/Java5ValidatorTest.java",
                "startLine": 102,
                "endLine": 118,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "@Test\n    public void nestedEnum() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(\"class X{\" + allModifiers + \"enum I{}}\"));\n        assertProblems(result,\n                \"(line 1,col 9) Can have only one of 'public', 'protected', 'private'.\",\n                \"(line 1,col 9) Can have only one of 'final', 'abstract'.\",\n                \"(line 1,col 9) Can have only one of 'native', 'strictfp'.\",\n                \"(line 1,col 9) 'transient' is not allowed here.\",\n                \"(line 1,col 9) 'volatile' is not allowed here.\",\n                \"(line 1,col 9) 'default' is not allowed here.\",\n                \"(line 1,col 9) 'abstract' is not allowed here.\",\n                \"(line 1,col 9) 'final' is not allowed here.\",\n                \"(line 1,col 9) 'synchronized' is not allowed here.\",\n                \"(line 1,col 9) 'native' is not allowed here.\",\n                \"(line 1,col 9) 'transitive' is not allowed here.\"\n        );\n    }",
        "filePathBefore": "javaparser-testing/src/test/java/com/github/javaparser/ast/validator/Java1_2ValidatorTest.java",
        "isPureRefactoring": true,
        "commitId": "da6302311ef508f830434a997a9b61f24750c6a1",
        "packageNameBefore": "com.github.javaparser.ast.validator",
        "classNameBefore": "com.github.javaparser.ast.validator.Java1_2ValidatorTest",
        "methodNameBefore": "com.github.javaparser.ast.validator.Java1_2ValidatorTest#nestedEnum",
        "classSignatureBefore": "public class Java1_2ValidatorTest ",
        "methodNameBeforeSet": [
            "com.github.javaparser.ast.validator.Java1_2ValidatorTest#nestedEnum"
        ],
        "classNameBeforeSet": [
            "com.github.javaparser.ast.validator.Java1_2ValidatorTest"
        ],
        "classSignatureBeforeSet": [
            "public class Java1_2ValidatorTest "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "package com.github.javaparser.ast.validator;\n\nimport com.github.javaparser.JavaParser;\nimport com.github.javaparser.ParseResult;\nimport com.github.javaparser.ParserConfiguration;\nimport com.github.javaparser.ast.CompilationUnit;\nimport org.junit.Test;\n\nimport static com.github.javaparser.ParseStart.COMPILATION_UNIT;\nimport static com.github.javaparser.Providers.provider;\nimport static com.github.javaparser.utils.TestUtils.assertProblems;\n\npublic class Java1_2ValidatorTest {\n    public static final JavaParser javaParser = new JavaParser(new ParserConfiguration().setValidator(new Java1_2Validator()));\n\n    private final String allModifiers = \"public protected private abstract static final transient volatile synchronized native strictfp transitive default \";\n\n    @Test\n    public void topClass() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(allModifiers + \"class X{}\"));\n        assertProblems(result,\n                \"(line 1,col 1) Can have only one of 'public', 'protected', 'private'.\",\n                \"(line 1,col 1) Can have only one of 'final', 'abstract'.\",\n                \"(line 1,col 1) Can have only one of 'native', 'strictfp'.\",\n                \"(line 1,col 1) 'transient' is not allowed here.\",\n                \"(line 1,col 1) 'default' is not allowed here.\",\n                \"(line 1,col 1) 'volatile' is not allowed here.\",\n                \"(line 1,col 1) 'private' is not allowed here.\",\n                \"(line 1,col 1) 'protected' is not allowed here.\",\n                \"(line 1,col 1) 'synchronized' is not allowed here.\",\n                \"(line 1,col 1) 'native' is not allowed here.\",\n                \"(line 1,col 1) 'transitive' is not allowed here.\",\n                \"(line 1,col 1) 'static' is not allowed here.\"\n        );\n    }\n\n    @Test\n    public void nestedClass() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(\"class X{\" + allModifiers + \"class I{}}\"));\n        assertProblems(result,\n                \"(line 1,col 9) Can have only one of 'public', 'protected', 'private'.\",\n                \"(line 1,col 9) Can have only one of 'final', 'abstract'.\",\n                \"(line 1,col 9) Can have only one of 'native', 'strictfp'.\",\n                \"(line 1,col 9) 'transient' is not allowed here.\",\n                \"(line 1,col 9) 'default' is not allowed here.\",\n                \"(line 1,col 9) 'volatile' is not allowed here.\",\n                \"(line 1,col 9) 'synchronized' is not allowed here.\",\n                \"(line 1,col 9) 'native' is not allowed here.\",\n                \"(line 1,col 9) 'transitive' is not allowed here.\"\n        );\n    }\n\n    @Test\n    public void localClass() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(\"class X{ void x() {\" + allModifiers + \"class I{}}}\"));\n        assertProblems(result,\n                \"(line 1,col 20) Can have only one of 'public', 'protected', 'private'.\",\n                \"(line 1,col 20) Can have only one of 'final', 'abstract'.\",\n                \"(line 1,col 20) Can have only one of 'native', 'strictfp'.\",\n                \"(line 1,col 20) 'transient' is not allowed here.\",\n                \"(line 1,col 20) 'volatile' is not allowed here.\",\n                \"(line 1,col 20) 'default' is not allowed here.\",\n                \"(line 1,col 20) 'synchronized' is not allowed here.\",\n                \"(line 1,col 20) 'native' is not allowed here.\",\n                \"(line 1,col 20) 'transitive' is not allowed here.\",\n                \"(line 1,col 20) 'static' is not allowed here.\",\n                \"(line 1,col 20) 'public' is not allowed here.\",\n                \"(line 1,col 20) 'private' is not allowed here.\",\n                \"(line 1,col 20) 'protected' is not allowed here.\"\n        );\n    }\n\n    @Test\n    public void topInterface() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(allModifiers + \"interface X{}\"));\n        assertProblems(result,\n                \"(line 1,col 1) Can have only one of 'public', 'protected', 'private'.\",\n                \"(line 1,col 1) Can have only one of 'final', 'abstract'.\",\n                \"(line 1,col 1) Can have only one of 'native', 'strictfp'.\",\n                \"(line 1,col 1) 'transient' is not allowed here.\",\n                \"(line 1,col 1) 'volatile' is not allowed here.\",\n                \"(line 1,col 1) 'default' is not allowed here.\",\n                \"(line 1,col 1) 'synchronized' is not allowed here.\",\n                \"(line 1,col 1) 'native' is not allowed here.\",\n                \"(line 1,col 1) 'transitive' is not allowed here.\",\n                \"(line 1,col 1) 'static' is not allowed here.\",\n                \"(line 1,col 1) 'final' is not allowed here.\",\n                \"(line 1,col 1) 'private' is not allowed here.\",\n                \"(line 1,col 1) 'protected' is not allowed here.\"\n        );\n    }\n\n    @Test\n    public void nestedInterface() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(\"class X{\" + allModifiers + \"interface I{}}\"));\n        assertProblems(result,\n                \"(line 1,col 9) Can have only one of 'public', 'protected', 'private'.\",\n                \"(line 1,col 9) Can have only one of 'final', 'abstract'.\",\n                \"(line 1,col 9) Can have only one of 'native', 'strictfp'.\",\n                \"(line 1,col 9) 'transient' is not allowed here.\",\n                \"(line 1,col 9) 'volatile' is not allowed here.\",\n                \"(line 1,col 9) 'default' is not allowed here.\",\n                \"(line 1,col 9) 'final' is not allowed here.\",\n                \"(line 1,col 9) 'synchronized' is not allowed here.\",\n                \"(line 1,col 9) 'native' is not allowed here.\",\n                \"(line 1,col 9) 'transitive' is not allowed here.\"\n        );\n    }\n\n    @Test\n    public void topEnum() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(allModifiers + \"enum X{}\"));\n        assertProblems(result,\n                \"(line 1,col 1) Can have only one of 'public', 'protected', 'private'.\",\n                \"(line 1,col 1) Can have only one of 'final', 'abstract'.\",\n                \"(line 1,col 1) Can have only one of 'native', 'strictfp'.\",\n                \"(line 1,col 1) 'transient' is not allowed here.\",\n                \"(line 1,col 1) 'volatile' is not allowed here.\",\n                \"(line 1,col 1) 'synchronized' is not allowed here.\",\n                \"(line 1,col 1) 'default' is not allowed here.\",\n                \"(line 1,col 1) 'native' is not allowed here.\",\n                \"(line 1,col 1) 'transitive' is not allowed here.\",\n                \"(line 1,col 1) 'static' is not allowed here.\",\n                \"(line 1,col 1) 'abstract' is not allowed here.\",\n                \"(line 1,col 1) 'final' is not allowed here.\",\n                \"(line 1,col 1) 'private' is not allowed here.\",\n                \"(line 1,col 1) 'protected' is not allowed here.\"\n        );\n    }\n\n    @Test\n    public void nestedEnum() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(\"class X{\" + allModifiers + \"enum I{}}\"));\n        assertProblems(result,\n                \"(line 1,col 9) Can have only one of 'public', 'protected', 'private'.\",\n                \"(line 1,col 9) Can have only one of 'final', 'abstract'.\",\n                \"(line 1,col 9) Can have only one of 'native', 'strictfp'.\",\n                \"(line 1,col 9) 'transient' is not allowed here.\",\n                \"(line 1,col 9) 'volatile' is not allowed here.\",\n                \"(line 1,col 9) 'default' is not allowed here.\",\n                \"(line 1,col 9) 'abstract' is not allowed here.\",\n                \"(line 1,col 9) 'final' is not allowed here.\",\n                \"(line 1,col 9) 'synchronized' is not allowed here.\",\n                \"(line 1,col 9) 'native' is not allowed here.\",\n                \"(line 1,col 9) 'transitive' is not allowed here.\"\n        );\n    }\n    @Test\n    public void moduleRequires() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(\"module x{requires \" + allModifiers + \" a;}\"));\n        assertProblems(result,\n                \"(line 1,col 10) Can have only one of 'public', 'protected', 'private'.\",\n                \"(line 1,col 10) Can have only one of 'final', 'abstract'.\",\n                \"(line 1,col 10) Can have only one of 'native', 'strictfp'.\",\n                \"(line 1,col 10) 'transient' is not allowed here.\",\n                \"(line 1,col 10) 'volatile' is not allowed here.\",\n                \"(line 1,col 10) 'final' is not allowed here.\",\n                \"(line 1,col 10) 'synchronized' is not allowed here.\",\n                \"(line 1,col 10) 'default' is not allowed here.\",\n                \"(line 1,col 10) 'native' is not allowed here.\",\n                \"(line 1,col 10) 'private' is not allowed here.\",\n                \"(line 1,col 10) 'protected' is not allowed here.\",\n                \"(line 1,col 10) 'strictfp' is not allowed here.\",\n                \"(line 1,col 10) 'abstract' is not allowed here.\",\n                \"(line 1,col 10) 'public' is not allowed here.\"\n        );\n    }\n\n    @Test\n    public void constructor() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(\"class X{\" + allModifiers + \"X(){};}\"));\n        assertProblems(result,\n                \"(line 1,col 9) Can have only one of 'public', 'protected', 'private'.\",\n                \"(line 1,col 9) Can have only one of 'final', 'abstract'.\",\n                \"(line 1,col 9) Can have only one of 'native', 'strictfp'.\",\n                \"(line 1,col 9) 'transient' is not allowed here.\",\n                \"(line 1,col 9) 'volatile' is not allowed here.\",\n                \"(line 1,col 9) 'final' is not allowed here.\",\n                \"(line 1,col 9) 'synchronized' is not allowed here.\",\n                \"(line 1,col 9) 'default' is not allowed here.\",\n                \"(line 1,col 9) 'native' is not allowed here.\",\n                \"(line 1,col 9) 'strictfp' is not allowed here.\",\n                \"(line 1,col 9) 'abstract' is not allowed here.\",\n                \"(line 1,col 9) 'static' is not allowed here.\",\n                \"(line 1,col 9) 'transitive' is not allowed here.\"\n        );\n    }\n\n    @Test\n    public void constructorParameter() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(\"class X{X(\" + allModifiers + \" int i){};}\"));\n        assertProblems(result,\n                \"(line 1,col 11) Can have only one of 'public', 'protected', 'private'.\",\n                \"(line 1,col 11) Can have only one of 'final', 'abstract'.\",\n                \"(line 1,col 11) Can have only one of 'native', 'strictfp'.\",\n                \"(line 1,col 11) 'transient' is not allowed here.\",\n                \"(line 1,col 11) 'volatile' is not allowed here.\",\n                \"(line 1,col 11) 'synchronized' is not allowed here.\",\n                \"(line 1,col 11) 'native' is not allowed here.\",\n                \"(line 1,col 11) 'strictfp' is not allowed here.\",\n                \"(line 1,col 11) 'default' is not allowed here.\",\n                \"(line 1,col 11) 'abstract' is not allowed here.\",\n                \"(line 1,col 11) 'static' is not allowed here.\",\n                \"(line 1,col 11) 'transitive' is not allowed here.\",\n                \"(line 1,col 11) 'private' is not allowed here.\",\n                \"(line 1,col 11) 'public' is not allowed here.\",\n                \"(line 1,col 11) 'protected' is not allowed here.\"\n        );\n    }\n\n    @Test\n    public void classMethod() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(\"class X{\" + allModifiers + \"int x(){};}\"));\n        assertProblems(result,\n                \"(line 1,col 9) Can have only one of 'public', 'protected', 'private'.\",\n                \"(line 1,col 9) Can have only one of 'final', 'abstract'.\",\n                \"(line 1,col 9) Can have only one of 'native', 'strictfp'.\",\n                \"(line 1,col 9) Cannot be 'abstract' and also 'private', 'static', 'final', 'native', 'strictfp', 'synchronized'.\",\n                \"(line 1,col 9) 'transient' is not allowed here.\",\n                \"(line 1,col 9) 'default' is not allowed here.\",\n                \"(line 1,col 9) 'volatile' is not allowed here.\",\n                \"(line 1,col 9) 'transitive' is not allowed here.\"\n        );\n    }\n\n    @Test\n    public void interfaceMethod() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(\"interface X{\" + allModifiers + \"int x(){};}\"));\n        assertProblems(result,\n                \"(line 1,col 13) Can have only one of 'public', 'protected', 'private'.\",\n                \"(line 1,col 13) Can have only one of 'final', 'abstract'.\",\n                \"(line 1,col 13) Can have only one of 'native', 'strictfp'.\",\n                \"(line 1,col 13) Cannot be 'abstract' and also 'private', 'static', 'final', 'native', 'strictfp', 'synchronized'.\",\n                \"(line 1,col 13) 'transient' is not allowed here.\",\n                \"(line 1,col 13) 'volatile' is not allowed here.\",\n                \"(line 1,col 13) 'default' is not allowed here.\",\n                \"(line 1,col 13) 'transitive' is not allowed here.\"\n        );\n    }\n\n    @Test\n    public void methodParameter() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(\"class X{int x(\" + allModifiers + \" int i){};}\"));\n        assertProblems(result,\n                \"(line 1,col 15) Can have only one of 'public', 'protected', 'private'.\",\n                \"(line 1,col 15) Can have only one of 'final', 'abstract'.\",\n                \"(line 1,col 15) Can have only one of 'native', 'strictfp'.\",\n                \"(line 1,col 15) 'transient' is not allowed here.\",\n                \"(line 1,col 15) 'volatile' is not allowed here.\",\n                \"(line 1,col 15) 'synchronized' is not allowed here.\",\n                \"(line 1,col 15) 'native' is not allowed here.\",\n                \"(line 1,col 15) 'strictfp' is not allowed here.\",\n                \"(line 1,col 15) 'abstract' is not allowed here.\",\n                \"(line 1,col 15) 'default' is not allowed here.\",\n                \"(line 1,col 15) 'static' is not allowed here.\",\n                \"(line 1,col 15) 'transitive' is not allowed here.\",\n                \"(line 1,col 15) 'private' is not allowed here.\",\n                \"(line 1,col 15) 'public' is not allowed here.\",\n                \"(line 1,col 15) 'protected' is not allowed here.\"\n        );\n    }\n\n    @Test\n    public void field() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(\"class X{\" + allModifiers + \"int i;}\"));\n        assertProblems(result,\n                \"(line 1,col 9) Can have only one of 'public', 'protected', 'private'.\",\n                \"(line 1,col 9) Can have only one of 'final', 'abstract'.\",\n                \"(line 1,col 9) Can have only one of 'native', 'strictfp'.\",\n                \"(line 1,col 9) 'synchronized' is not allowed here.\",\n                \"(line 1,col 9) 'native' is not allowed here.\",\n                \"(line 1,col 9) 'strictfp' is not allowed here.\",\n                \"(line 1,col 9) 'default' is not allowed here.\",\n                \"(line 1,col 9) 'abstract' is not allowed here.\",\n                \"(line 1,col 9) 'transitive' is not allowed here.\"\n        );\n    }\n\n    @Test\n    public void localVariable() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(\"class X{int x(){\" + allModifiers + \"int i;}}\"));\n        assertProblems(result,\n                \"(line 1,col 17) Can have only one of 'public', 'protected', 'private'.\",\n                \"(line 1,col 17) Can have only one of 'final', 'abstract'.\",\n                \"(line 1,col 17) Can have only one of 'native', 'strictfp'.\",\n                \"(line 1,col 17) 'transient' is not allowed here.\",\n                \"(line 1,col 17) 'volatile' is not allowed here.\",\n                \"(line 1,col 17) 'synchronized' is not allowed here.\",\n                \"(line 1,col 17) 'native' is not allowed here.\",\n                \"(line 1,col 17) 'default' is not allowed here.\",\n                \"(line 1,col 17) 'strictfp' is not allowed here.\",\n                \"(line 1,col 17) 'abstract' is not allowed here.\",\n                \"(line 1,col 17) 'static' is not allowed here.\",\n                \"(line 1,col 17) 'transitive' is not allowed here.\",\n                \"(line 1,col 17) 'private' is not allowed here.\",\n                \"(line 1,col 17) 'public' is not allowed here.\",\n                \"(line 1,col 17) 'protected' is not allowed here.\"\n        );\n    }\n\n    @Test\n    public void catchParameter() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(\"class X{int x(){ try{}catch(\"+ allModifiers +\" Integer x){}}}\"));\n        assertProblems(result,\n                \"(line 1,col 144) Can have only one of 'public', 'protected', 'private'.\",\n                \"(line 1,col 144) Can have only one of 'final', 'abstract'.\",\n                \"(line 1,col 144) Can have only one of 'native', 'strictfp'.\",\n                \"(line 1,col 144) 'transient' is not allowed here.\",\n                \"(line 1,col 144) 'volatile' is not allowed here.\",\n                \"(line 1,col 144) 'synchronized' is not allowed here.\",\n                \"(line 1,col 144) 'native' is not allowed here.\",\n                \"(line 1,col 144) 'default' is not allowed here.\",\n                \"(line 1,col 144) 'strictfp' is not allowed here.\",\n                \"(line 1,col 144) 'abstract' is not allowed here.\",\n                \"(line 1,col 144) 'static' is not allowed here.\",\n                \"(line 1,col 144) 'transitive' is not allowed here.\",\n                \"(line 1,col 144) 'private' is not allowed here.\",\n                \"(line 1,col 144) 'public' is not allowed here.\",\n                \"(line 1,col 144) 'protected' is not allowed here.\"\n        );\n    }\n}\n",
        "filePathAfter": "javaparser-testing/src/test/java/com/github/javaparser/ast/validator/Java5ValidatorTest.java",
        "sourceCodeAfterForWhole": "package com.github.javaparser.ast.validator;\n\nimport com.github.javaparser.JavaParser;\nimport com.github.javaparser.ParseResult;\nimport com.github.javaparser.ParserConfiguration;\nimport com.github.javaparser.ast.CompilationUnit;\nimport org.junit.Test;\n\nimport static com.github.javaparser.ParseStart.COMPILATION_UNIT;\nimport static com.github.javaparser.Providers.provider;\nimport static com.github.javaparser.ast.validator.Java1_1ValidatorTest.allModifiers;\nimport static com.github.javaparser.utils.TestUtils.assertProblems;\n\npublic class Java5ValidatorTest {\n    public static final JavaParser javaParser = new JavaParser(new ParserConfiguration().setValidator(new Java5Validator()));\n\n    @Test\n    public void genericsWithoutDiamond() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(\"class X<A>{List<String> b = new ArrayList<>();}\"));\n        assertProblems(result, \"(line 1,col 33) The diamond operator is not supported.\");\n    }\n\n    @Test\n    public void topAnnotationDeclaration() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(allModifiers + \"@interface X{}\"));\n        assertProblems(result,\n                \"(line 1,col 1) Can have only one of 'public', 'protected', 'private'.\",\n                \"(line 1,col 1) Can have only one of 'final', 'abstract'.\",\n                \"(line 1,col 1) Can have only one of 'native', 'strictfp'.\",\n                \"(line 1,col 1) 'transient' is not allowed here.\",\n                \"(line 1,col 1) 'volatile' is not allowed here.\",\n                \"(line 1,col 1) 'synchronized' is not allowed here.\",\n                \"(line 1,col 1) 'default' is not allowed here.\",\n                \"(line 1,col 1) 'native' is not allowed here.\",\n                \"(line 1,col 1) 'transitive' is not allowed here.\",\n                \"(line 1,col 1) 'static' is not allowed here.\",\n                \"(line 1,col 1) 'final' is not allowed here.\",\n                \"(line 1,col 1) 'private' is not allowed here.\",\n                \"(line 1,col 1) 'protected' is not allowed here.\"\n        );\n    }\n\n    @Test\n    public void nestedAnnotationDeclaration() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(\"class X{\" + allModifiers + \"@interface I{}}\"));\n        assertProblems(result,\n                \"(line 1,col 9) Can have only one of 'public', 'protected', 'private'.\",\n                \"(line 1,col 9) Can have only one of 'final', 'abstract'.\",\n                \"(line 1,col 9) Can have only one of 'native', 'strictfp'.\",\n                \"(line 1,col 9) 'transient' is not allowed here.\",\n                \"(line 1,col 9) 'volatile' is not allowed here.\",\n                \"(line 1,col 9) 'default' is not allowed here.\",\n                \"(line 1,col 9) 'final' is not allowed here.\",\n                \"(line 1,col 9) 'synchronized' is not allowed here.\",\n                \"(line 1,col 9) 'native' is not allowed here.\",\n                \"(line 1,col 9) 'transitive' is not allowed here.\"\n        );\n    }\n\n    @Test\n    public void annotationMember() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(\"@interface X{\" + allModifiers + \"int x();}\"));\n        assertProblems(result,\n                \"(line 1,col 14) Can have only one of 'public', 'protected', 'private'.\",\n                \"(line 1,col 14) Can have only one of 'final', 'abstract'.\",\n                \"(line 1,col 14) Can have only one of 'native', 'strictfp'.\",\n                \"(line 1,col 14) 'transient' is not allowed here.\",\n                \"(line 1,col 14) 'volatile' is not allowed here.\",\n                \"(line 1,col 14) 'final' is not allowed here.\",\n                \"(line 1,col 14) 'synchronized' is not allowed here.\",\n                \"(line 1,col 14) 'default' is not allowed here.\",\n                \"(line 1,col 14) 'native' is not allowed here.\",\n                \"(line 1,col 14) 'protected' is not allowed here.\",\n                \"(line 1,col 14) 'private' is not allowed here.\",\n                \"(line 1,col 14) 'strictfp' is not allowed here.\",\n                \"(line 1,col 14) 'static' is not allowed here.\",\n                \"(line 1,col 14) 'transitive' is not allowed here.\"\n        );\n    }\n\n    @Test\n    public void topEnum() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(allModifiers + \"enum X{}\"));\n        assertProblems(result,\n                \"(line 1,col 1) Can have only one of 'public', 'protected', 'private'.\",\n                \"(line 1,col 1) Can have only one of 'final', 'abstract'.\",\n                \"(line 1,col 1) Can have only one of 'native', 'strictfp'.\",\n                \"(line 1,col 1) 'transient' is not allowed here.\",\n                \"(line 1,col 1) 'volatile' is not allowed here.\",\n                \"(line 1,col 1) 'synchronized' is not allowed here.\",\n                \"(line 1,col 1) 'default' is not allowed here.\",\n                \"(line 1,col 1) 'native' is not allowed here.\",\n                \"(line 1,col 1) 'transitive' is not allowed here.\",\n                \"(line 1,col 1) 'static' is not allowed here.\",\n                \"(line 1,col 1) 'abstract' is not allowed here.\",\n                \"(line 1,col 1) 'final' is not allowed here.\",\n                \"(line 1,col 1) 'private' is not allowed here.\",\n                \"(line 1,col 1) 'protected' is not allowed here.\"\n        );\n    }\n\n    @Test\n    public void nestedEnum() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(\"class X{\" + allModifiers + \"enum I{}}\"));\n        assertProblems(result,\n                \"(line 1,col 9) Can have only one of 'public', 'protected', 'private'.\",\n                \"(line 1,col 9) Can have only one of 'final', 'abstract'.\",\n                \"(line 1,col 9) Can have only one of 'native', 'strictfp'.\",\n                \"(line 1,col 9) 'transient' is not allowed here.\",\n                \"(line 1,col 9) 'volatile' is not allowed here.\",\n                \"(line 1,col 9) 'default' is not allowed here.\",\n                \"(line 1,col 9) 'abstract' is not allowed here.\",\n                \"(line 1,col 9) 'final' is not allowed here.\",\n                \"(line 1,col 9) 'synchronized' is not allowed here.\",\n                \"(line 1,col 9) 'native' is not allowed here.\",\n                \"(line 1,col 9) 'transitive' is not allowed here.\"\n        );\n    }\n\n}\n",
        "diffSourceCodeSet": [],
        "invokedMethodSet": [],
        "sourceCodeAfterRefactoring": "@Test\n    public void nestedEnum() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(\"class X{\" + allModifiers + \"enum I{}}\"));\n        assertProblems(result,\n                \"(line 1,col 9) Can have only one of 'public', 'protected', 'private'.\",\n                \"(line 1,col 9) Can have only one of 'final', 'abstract'.\",\n                \"(line 1,col 9) Can have only one of 'native', 'strictfp'.\",\n                \"(line 1,col 9) 'transient' is not allowed here.\",\n                \"(line 1,col 9) 'volatile' is not allowed here.\",\n                \"(line 1,col 9) 'default' is not allowed here.\",\n                \"(line 1,col 9) 'abstract' is not allowed here.\",\n                \"(line 1,col 9) 'final' is not allowed here.\",\n                \"(line 1,col 9) 'synchronized' is not allowed here.\",\n                \"(line 1,col 9) 'native' is not allowed here.\",\n                \"(line 1,col 9) 'transitive' is not allowed here.\"\n        );\n    }",
        "diffSourceCode": "-  102:                 \"(line 1,col 9) 'default' is not allowed here.\",\n-  103:                 \"(line 1,col 9) 'final' is not allowed here.\",\n-  104:                 \"(line 1,col 9) 'synchronized' is not allowed here.\",\n-  105:                 \"(line 1,col 9) 'native' is not allowed here.\",\n-  106:                 \"(line 1,col 9) 'transitive' is not allowed here.\"\n-  107:         );\n-  108:     }\n-  109: \n-  110:     @Test\n-  111:     public void topEnum() {\n-  112:         ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(allModifiers + \"enum X{}\"));\n-  113:         assertProblems(result,\n-  114:                 \"(line 1,col 1) Can have only one of 'public', 'protected', 'private'.\",\n-  115:                 \"(line 1,col 1) Can have only one of 'final', 'abstract'.\",\n-  116:                 \"(line 1,col 1) Can have only one of 'native', 'strictfp'.\",\n-  117:                 \"(line 1,col 1) 'transient' is not allowed here.\",\n-  118:                 \"(line 1,col 1) 'volatile' is not allowed here.\",\n-  131:     @Test\n-  132:     public void nestedEnum() {\n-  133:         ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(\"class X{\" + allModifiers + \"enum I{}}\"));\n-  134:         assertProblems(result,\n-  135:                 \"(line 1,col 9) Can have only one of 'public', 'protected', 'private'.\",\n-  136:                 \"(line 1,col 9) Can have only one of 'final', 'abstract'.\",\n-  137:                 \"(line 1,col 9) Can have only one of 'native', 'strictfp'.\",\n-  138:                 \"(line 1,col 9) 'transient' is not allowed here.\",\n-  139:                 \"(line 1,col 9) 'volatile' is not allowed here.\",\n-  140:                 \"(line 1,col 9) 'default' is not allowed here.\",\n-  141:                 \"(line 1,col 9) 'abstract' is not allowed here.\",\n-  142:                 \"(line 1,col 9) 'final' is not allowed here.\",\n-  143:                 \"(line 1,col 9) 'synchronized' is not allowed here.\",\n-  144:                 \"(line 1,col 9) 'native' is not allowed here.\",\n-  145:                 \"(line 1,col 9) 'transitive' is not allowed here.\"\n-  146:         );\n-  147:     }\n+  102:     @Test\n+  103:     public void nestedEnum() {\n+  104:         ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(\"class X{\" + allModifiers + \"enum I{}}\"));\n+  105:         assertProblems(result,\n+  106:                 \"(line 1,col 9) Can have only one of 'public', 'protected', 'private'.\",\n+  107:                 \"(line 1,col 9) Can have only one of 'final', 'abstract'.\",\n+  108:                 \"(line 1,col 9) Can have only one of 'native', 'strictfp'.\",\n+  109:                 \"(line 1,col 9) 'transient' is not allowed here.\",\n+  110:                 \"(line 1,col 9) 'volatile' is not allowed here.\",\n+  111:                 \"(line 1,col 9) 'default' is not allowed here.\",\n+  112:                 \"(line 1,col 9) 'abstract' is not allowed here.\",\n+  113:                 \"(line 1,col 9) 'final' is not allowed here.\",\n+  114:                 \"(line 1,col 9) 'synchronized' is not allowed here.\",\n+  115:                 \"(line 1,col 9) 'native' is not allowed here.\",\n+  116:                 \"(line 1,col 9) 'transitive' is not allowed here.\"\n+  117:         );\n+  118:     }\n",
        "uniqueId": "da6302311ef508f830434a997a9b61f24750c6a1_131_147__102_118",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "testMethod": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 1.8
    },
    {
        "type": "Move And Inline Method",
        "description": "Move And Inline Method\tpublic solveSymbol(name String) : SymbolReference<? extends ResolvedValueDeclaration> moved from class com.github.javaparser.symbolsolver.javaparsermodel.contexts.MethodCallExprContext to class com.github.javaparser.symbolsolver.javaparsermodel.contexts.BlockStmtContext & inlined to public solveSymbol(name String) : SymbolReference<? extends ResolvedValueDeclaration>",
        "diffLocations": [
            {
                "filePath": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/BlockStmtContext.java",
                "startLine": 76,
                "endLine": 98,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/BlockStmtContext.java",
                "startLine": 79,
                "endLine": 110,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/BlockStmtContext.java",
                "startLine": 156,
                "endLine": 161,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "",
        "filePathBefore": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/BlockStmtContext.java",
        "isPureRefactoring": true,
        "commitId": "2903fc918dd87be53192aa1065047392f7adf4d1",
        "packageNameBefore": "com.github.javaparser.symbolsolver.javaparsermodel.contexts",
        "classNameBefore": "com.github.javaparser.symbolsolver.javaparsermodel.contexts.MethodCallExprContext",
        "methodNameBefore": "com.github.javaparser.symbolsolver.javaparsermodel.contexts.MethodCallExprContext#solveSymbol",
        "invokedMethod": "methodSignature: com.github.javaparser.symbolsolver.javaparsermodel.contexts.StatementContext#solveSymbol\n methodBody: public SymbolReference<? extends ResolvedValueDeclaration> solveSymbol(String name) {\nSymbolDeclarator symbolDeclarator=JavaParserFactory.getSymbolDeclarator(wrappedNode,typeSolver);\nSymbolReference<? extends ResolvedValueDeclaration> symbolReference=solveWith(symbolDeclarator,name);\nif(symbolReference.isSolved()){return symbolReference;\n}Context parentContext=getParent().orElseThrow(() -> new RuntimeException(\"Parent context unexpectedly empty.\"));\nNode parentOfWrappedNode=demandParentNode(wrappedNode);\nif(parentOfWrappedNode instanceof MethodDeclaration){return parentContext.solveSymbol(name);\n}if(parentOfWrappedNode instanceof ConstructorDeclaration){return parentContext.solveSymbol(name);\n}if(parentOfWrappedNode instanceof LambdaExpr){return parentContext.solveSymbol(name);\n}if(!(parentOfWrappedNode instanceof NodeWithStatements)){return parentContext.solveSymbol(name);\n}NodeWithStatements<?> nodeWithStmt=(NodeWithStatements<?>)parentOfWrappedNode;\nint position=-1;\nfor(int i=0; i < nodeWithStmt.getStatements().size(); i++){if(nodeWithStmt.getStatements().get(i).equals(wrappedNode)){position=i;\n}}if(position == -1){throw new RuntimeException();\n}for(int i=position - 1; i >= 0; i--){symbolDeclarator=JavaParserFactory.getSymbolDeclarator(nodeWithStmt.getStatements().get(i),typeSolver);\nsymbolReference=solveWith(symbolDeclarator,name);\nif(symbolReference.isSolved()){return symbolReference;\n}}return parentContext.solveSymbol(name);\n}\nmethodSignature: com.github.javaparser.symbolsolver.javaparsermodel.contexts.AbstractMethodLikeDeclarationContext#solveSymbol\n methodBody: public final SymbolReference<? extends ResolvedValueDeclaration> solveSymbol(String name) {\nfor(Parameter parameter: wrappedNode.getParameters()){SymbolDeclarator sb=JavaParserFactory.getSymbolDeclarator(parameter,typeSolver);\nSymbolReference<? extends ResolvedValueDeclaration> symbolReference=AbstractJavaParserContext.solveWith(sb,name);\nif(symbolReference.isSolved()){return symbolReference;\n}}return getParent().orElseThrow(() -> new RuntimeException(\"Parent context unexpectedly empty.\")).solveSymbol(name);\n}\nmethodSignature: com.github.javaparser.symbolsolver.javaparsermodel.contexts.CatchClauseContext#solveSymbol\n methodBody: public final SymbolReference<? extends ResolvedValueDeclaration> solveSymbol(String name) {\nSymbolDeclarator sb=JavaParserFactory.getSymbolDeclarator(wrappedNode.getParameter(),typeSolver);\nSymbolReference<? extends ResolvedValueDeclaration> symbolReference=AbstractJavaParserContext.solveWith(sb,name);\nif(symbolReference.isSolved()){return symbolReference;\n}return getParent().orElseThrow(() -> new RuntimeException(\"Parent context unexpectedly empty.\")).solveSymbol(name);\n}\nmethodSignature: com.github.javaparser.symbolsolver.javaparsermodel.contexts.LambdaExprContext#solveSymbol\n methodBody: public SymbolReference<? extends ResolvedValueDeclaration> solveSymbol(String name) {\nfor(Parameter parameter: wrappedNode.getParameters()){SymbolDeclarator sb=JavaParserFactory.getSymbolDeclarator(parameter,typeSolver);\nSymbolReference<ResolvedValueDeclaration> symbolReference=solveWith(sb,name);\nif(symbolReference.isSolved()){return symbolReference;\n}}return getParent().orElseThrow(() -> new RuntimeException(\"Parent context unexpectedly empty.\")).solveSymbol(name);\n}\nmethodSignature: com.github.javaparser.symbolsolver.core.resolution.Context#getParent\n methodBody: Optional<Context> getParent();\nmethodSignature: com.github.javaparser.symbolsolver.javaparsermodel.contexts.AnnotationDeclarationContext#solveSymbol\n methodBody: public SymbolReference<? extends ResolvedValueDeclaration> solveSymbol(String name) {\nif(typeSolver == null)throw new IllegalArgumentException();\nif(this.getDeclaration().hasField(name)){return SymbolReference.solved(this.getDeclaration().getField(name));\n}return getParent().orElseThrow(() -> new RuntimeException(\"Parent context unexpectedly empty.\")).solveSymbol(name);\n}\nmethodSignature: com.github.javaparser.symbolsolver.javaparsermodel.contexts.TryWithResourceContext#solveSymbol\n methodBody: public SymbolReference<? extends ResolvedValueDeclaration> solveSymbol(String name) {\nfor(Expression expr: wrappedNode.getResources()){if(expr instanceof VariableDeclarationExpr){for(VariableDeclarator v: ((VariableDeclarationExpr)expr).getVariables()){if(v.getName().getIdentifier().equals(name)){return SymbolReference.solved(JavaParserSymbolDeclaration.localVar(v,typeSolver));\n}}}}if(demandParentNode(wrappedNode) instanceof BlockStmt){return StatementContext.solveInBlock(name,typeSolver,wrappedNode);\n}{return getParent().orElseThrow(() -> new RuntimeException(\"Parent context unexpectedly empty.\")).solveSymbol(name);\n}}\nmethodSignature: com.github.javaparser.symbolsolver.javaparsermodel.contexts.AbstractJavaParserContext#getParent\n methodBody: public final Optional<Context> getParent() {\nNode parent=wrappedNode.getParentNode().orElse(null);\nif(parent instanceof MethodCallExpr){MethodCallExpr parentCall=(MethodCallExpr)parent;\nboolean found=false;\nif(parentCall.getArguments() != null){for(Expression expression: parentCall.getArguments()){if(expression == wrappedNode){found=true;\nbreak;\n}}}if(found){Node notMethod=parent;\nwhile(notMethod instanceof MethodCallExpr){notMethod=demandParentNode(notMethod);\n}return Optional.of(JavaParserFactory.getContext(notMethod,typeSolver));\n}}Node notMethod=parent;\nwhile(notMethod instanceof MethodCallExpr || notMethod instanceof FieldAccessExpr){notMethod=notMethod.getParentNode().orElse(null);\n}if(notMethod == null){return Optional.empty();\n}return Optional.of(JavaParserFactory.getContext(notMethod,typeSolver));\n}\nmethodSignature: com.github.javaparser.symbolsolver.javaparsermodel.contexts.ForEachStatementContext#solveSymbol\n methodBody: public SymbolReference<? extends ResolvedValueDeclaration> solveSymbol(String name) {\nif(wrappedNode.getVariable().getVariables().size() != 1){throw new IllegalStateException();\n}VariableDeclarator variableDeclarator=wrappedNode.getVariable().getVariables().get(0);\nif(variableDeclarator.getName().getId().equals(name)){return SymbolReference.solved(JavaParserSymbolDeclaration.localVar(variableDeclarator,typeSolver));\n}{if(demandParentNode(wrappedNode) instanceof BlockStmt){return StatementContext.solveInBlock(name,typeSolver,wrappedNode);\n}{return getParent().orElseThrow(() -> new RuntimeException(\"Parent context unexpectedly empty.\")).solveSymbol(name);\n}}}\nmethodSignature: com.github.javaparser.symbolsolver.javaparsermodel.contexts.ClassOrInterfaceDeclarationContext#solveSymbol\n methodBody: public SymbolReference<? extends ResolvedValueDeclaration> solveSymbol(String name) {\nif(typeSolver == null)throw new IllegalArgumentException();\nif(this.getDeclaration().hasVisibleField(name)){return SymbolReference.solved(this.getDeclaration().getVisibleField(name));\n}return getParent().orElseThrow(() -> new RuntimeException(\"Parent context unexpectedly empty.\")).solveSymbol(name);\n}\nmethodSignature: com.github.javaparser.symbolsolver.javaparsermodel.contexts.FieldAccessContext#solveSymbol\n methodBody: public SymbolReference<? extends ResolvedValueDeclaration> solveSymbol(String name) {\nif(wrappedNode.getName().toString().equals(name)){if(wrappedNode.getScope() instanceof ThisExpr){ResolvedType typeOfThis=JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\nif(typeOfThis.asReferenceType().getTypeDeclaration().isPresent()){return new SymbolSolver(typeSolver).solveSymbolInType(typeOfThis.asReferenceType().getTypeDeclaration().get(),name);\n}}}return JavaParserFactory.getContext(demandParentNode(wrappedNode),typeSolver).solveSymbol(name);\n}\nmethodSignature: com.github.javaparser.symbolsolver.javaparsermodel.contexts.AnonymousClassDeclarationContext#solveSymbol\n methodBody: public SymbolReference<? extends ResolvedValueDeclaration> solveSymbol(String name) {\nPreconditions.checkArgument(typeSolver != null);\nif(myDeclaration.hasField(name)){return SymbolReference.solved(myDeclaration.getField(name));\n}return getParent().orElseThrow(() -> new RuntimeException(\"Parent context unexpectedly empty.\")).solveSymbol(name);\n}\nmethodSignature: com.github.javaparser.symbolsolver.core.resolution.Context#solveSymbol\n methodBody: default SymbolReference<? extends ResolvedValueDeclaration> solveSymbol(String name) {\nreturn getParent().orElseThrow(() -> new RuntimeException(\"Parent context unexpectedly empty.\")).solveSymbol(name);\n}\nmethodSignature: com.github.javaparser.symbolsolver.javaparsermodel.contexts.SwitchEntryContext#solveSymbol\n methodBody: public SymbolReference<? extends ResolvedValueDeclaration> solveSymbol(String name) {\nSwitchStmt switchStmt=(SwitchStmt)demandParentNode(wrappedNode);\nResolvedType type=JavaParserFacade.get(typeSolver).getType(switchStmt.getSelector());\nif(type.isReferenceType() && type.asReferenceType().getTypeDeclaration().isPresent()){ResolvedReferenceTypeDeclaration typeDeclaration=type.asReferenceType().getTypeDeclaration().get();\nif(typeDeclaration.isEnum()){if(type instanceof ReferenceTypeImpl){ReferenceTypeImpl referenceType=(ReferenceTypeImpl)type;\nif(referenceType.getTypeDeclaration().isPresent()){ResolvedReferenceTypeDeclaration typeUsageTypeDeclaration=referenceType.getTypeDeclaration().get();\nif(typeUsageTypeDeclaration.asEnum().hasEnumConstant(name)){return SymbolReference.solved(typeUsageTypeDeclaration.asEnum().getEnumConstant(name));\n}if(typeUsageTypeDeclaration.hasField(name)){return SymbolReference.solved(typeUsageTypeDeclaration.getField(name));\n}}{}}{throw new UnsupportedOperationException();\n}}}for(SwitchEntry seStmt: switchStmt.getEntries()){for(Statement stmt: seStmt.getStatements()){SymbolDeclarator symbolDeclarator=JavaParserFactory.getSymbolDeclarator(stmt,typeSolver);\nSymbolReference<? extends ResolvedValueDeclaration> symbolReference=solveWith(symbolDeclarator,name);\nif(symbolReference.isSolved()){return symbolReference;\n}}if(seStmt == wrappedNode){break;\n}}return getParent().orElseThrow(() -> new RuntimeException(\"Parent context unexpectedly empty.\")).solveSymbol(name);\n}\nmethodSignature: com.github.javaparser.symbolsolver.javaparsermodel.contexts.EnumDeclarationContext#solveSymbol\n methodBody: public SymbolReference<? extends ResolvedValueDeclaration> solveSymbol(String name) {\nif(typeSolver == null)throw new IllegalArgumentException();\nfor(EnumConstantDeclaration constant: wrappedNode.getEntries()){if(constant.getName().getId().equals(name)){return SymbolReference.solved(new JavaParserEnumConstantDeclaration(constant,typeSolver));\n}}if(this.getDeclaration().hasField(name)){return SymbolReference.solved(this.getDeclaration().getField(name));\n}return getParent().orElseThrow(() -> new RuntimeException(\"Parent context unexpectedly empty.\")).solveSymbol(name);\n}\nmethodSignature: com.github.javaparser.symbolsolver.resolution.SymbolSolver#solveSymbol\n methodBody: public SymbolReference<? extends ResolvedValueDeclaration> solveSymbol(String name, Node node) {\nreturn solveSymbol(name,JavaParserFactory.getContext(node,typeSolver));\n}\nmethodSignature: com.github.javaparser.symbolsolver.javaparsermodel.contexts.BlockStmtContext#solveSymbol\n methodBody: public SymbolReference<? extends ResolvedValueDeclaration> solveSymbol(String name) {\nif(wrappedNode.getStatements().size() > 0){List<VariableDeclarator> variableDeclarators=new LinkedList<>();\nwrappedNode.getStatements().forEach(stmt -> variableDeclarators.addAll(localVariablesExposedToChild(stmt)));\nif(!variableDeclarators.isEmpty()){for(VariableDeclarator vd: variableDeclarators){if(vd.getNameAsString().equals(name)){return SymbolReference.solved(JavaParserSymbolDeclaration.localVar(vd,typeSolver));\n}}}}return super.solveSymbol(name);\n}\nmethodSignature: com.github.javaparser.symbolsolver.javaparsermodel.contexts.MethodCallExprContext#solveSymbol\n methodBody: public SymbolReference<? extends ResolvedValueDeclaration> solveSymbol(String name) {\nreturn getParent().orElseThrow(() -> new RuntimeException(\"Parent context unexpectedly empty.\")).solveSymbol(name);\n}\nmethodSignature: com.github.javaparser.symbolsolver.javaparsermodel.contexts.ForStatementContext#solveSymbol\n methodBody: public SymbolReference<? extends ResolvedValueDeclaration> solveSymbol(String name) {\nfor(Expression expression: wrappedNode.getInitialization()){if(expression instanceof VariableDeclarationExpr){VariableDeclarationExpr variableDeclarationExpr=(VariableDeclarationExpr)expression;\nfor(VariableDeclarator variableDeclarator: variableDeclarationExpr.getVariables()){if(variableDeclarator.getName().getId().equals(name)){return SymbolReference.solved(JavaParserSymbolDeclaration.localVar(variableDeclarator,typeSolver));\n}}}if(!(expression instanceof AssignExpr || expression instanceof MethodCallExpr || expression instanceof UnaryExpr)){throw new UnsupportedOperationException(expression.getClass().getCanonicalName());\n}}if(demandParentNode(wrappedNode) instanceof NodeWithStatements){return StatementContext.solveInBlock(name,typeSolver,wrappedNode);\n}{return getParent().orElseThrow(() -> new RuntimeException(\"Parent context unexpectedly empty.\")).solveSymbol(name);\n}}",
        "classSignatureBefore": "public class MethodCallExprContext extends AbstractJavaParserContext<MethodCallExpr> ",
        "methodNameBeforeSet": [
            "com.github.javaparser.symbolsolver.javaparsermodel.contexts.MethodCallExprContext#solveSymbol"
        ],
        "classNameBeforeSet": [
            "com.github.javaparser.symbolsolver.javaparsermodel.contexts.MethodCallExprContext"
        ],
        "classSignatureBeforeSet": [
            "public class MethodCallExprContext extends AbstractJavaParserContext<MethodCallExpr> "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Tolerable changes in the body\n",
                "description": "All replacements have been justified - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Copyright (C) 2015-2016 Federico Tomassetti\n * Copyright (C) 2017-2020 The JavaParser Team.\n *\n * This file is part of JavaParser.\n *\n * JavaParser can be used either under the terms of\n * a) the GNU Lesser General Public License as published by\n *     the Free Software Foundation, either version 3 of the License, or\n *     (at your option) any later version.\n * b) the terms of the Apache License\n *\n * You should have received a copy of both licenses in LICENCE.LGPL and\n * LICENCE.APACHE. Please refer to those files for details.\n *\n * JavaParser is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n */\n\npackage com.github.javaparser.symbolsolver.javaparsermodel.contexts;\n\nimport java.util.Collections;\nimport java.util.LinkedList;\nimport java.util.List;\n\nimport com.github.javaparser.ast.Node;\nimport com.github.javaparser.ast.body.VariableDeclarator;\nimport com.github.javaparser.ast.expr.VariableDeclarationExpr;\nimport com.github.javaparser.ast.stmt.BlockStmt;\nimport com.github.javaparser.ast.stmt.ExpressionStmt;\nimport com.github.javaparser.ast.stmt.Statement;\nimport com.github.javaparser.resolution.declarations.ResolvedValueDeclaration;\nimport com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserSymbolDeclaration;\nimport com.github.javaparser.symbolsolver.model.resolution.SymbolReference;\nimport com.github.javaparser.symbolsolver.model.resolution.TypeSolver;\n\npublic class BlockStmtContext extends AbstractJavaParserContext<BlockStmt> {\n\n    public BlockStmtContext(BlockStmt wrappedNode, TypeSolver typeSolver) {\n        super(wrappedNode, typeSolver);\n    }\n\n    @Override\n    public List<VariableDeclarator> localVariablesExposedToChild(Node child) {\n        int position = -1;\n        for (int i = 0; i < wrappedNode.getStatements().size(); i++) {\n            if (wrappedNode.getStatements().get(i).equals(child)) {\n                position = i;\n            }\n        }\n        if (position == -1) {\n            throw new RuntimeException();\n        }\n        List<VariableDeclarator> variableDeclarators = new LinkedList<>();\n        for (int i = position - 1; i >= 0; i--) {\n            variableDeclarators.addAll(localVariablesDeclaredIn(wrappedNode.getStatement(i)));\n        }\n        return variableDeclarators;\n    }\n\n    private List<VariableDeclarator> localVariablesDeclaredIn(Statement statement) {\n        if (statement instanceof ExpressionStmt) {\n            ExpressionStmt expressionStmt = (ExpressionStmt)statement;\n            if (expressionStmt.getExpression() instanceof VariableDeclarationExpr) {\n                VariableDeclarationExpr variableDeclarationExpr = (VariableDeclarationExpr)expressionStmt.getExpression();\n                List<VariableDeclarator> variableDeclarators = new LinkedList<>();\n                variableDeclarators.addAll(variableDeclarationExpr.getVariables());\n                return variableDeclarators;\n            }\n        }\n        return Collections.emptyList();\n    }\n    \n    @Override\n    public SymbolReference<? extends ResolvedValueDeclaration> solveSymbol(String name) {\n        // tries to resolve a declaration from local variables defined in child statements\n        // or from parent node context\n        // for example resolve declaration for the MethodCallExpr a.method() in\n        // A a = this;\n        // { \n        //   a.method(); \n        // }\n        if (wrappedNode.getStatements().size() > 0) {\n            List<VariableDeclarator> variableDeclarators = new LinkedList<>();\n            // find all variable declarators exposed in child\n            wrappedNode.getStatements().forEach(stmt-> variableDeclarators.addAll(localVariablesExposedToChild(stmt)));\n            if (!variableDeclarators.isEmpty()) {\n                for (VariableDeclarator vd : variableDeclarators) {\n                    if (vd.getNameAsString().equals(name) ) {\n                        return SymbolReference.solved(JavaParserSymbolDeclaration.localVar(vd, typeSolver));\n                    }\n                }\n            }\n        }\n        return super.solveSymbol(name);\n    } \n}\n",
        "filePathAfter": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/BlockStmtContext.java",
        "sourceCodeAfterForWhole": "/*\n * Copyright (C) 2015-2016 Federico Tomassetti\n * Copyright (C) 2017-2020 The JavaParser Team.\n *\n * This file is part of JavaParser.\n *\n * JavaParser can be used either under the terms of\n * a) the GNU Lesser General Public License as published by\n *     the Free Software Foundation, either version 3 of the License, or\n *     (at your option) any later version.\n * b) the terms of the Apache License\n *\n * You should have received a copy of both licenses in LICENCE.LGPL and\n * LICENCE.APACHE. Please refer to those files for details.\n *\n * JavaParser is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n */\n\npackage com.github.javaparser.symbolsolver.javaparsermodel.contexts;\n\nimport com.github.javaparser.ast.Node;\nimport com.github.javaparser.ast.body.VariableDeclarator;\nimport com.github.javaparser.ast.expr.PatternExpr;\nimport com.github.javaparser.ast.expr.VariableDeclarationExpr;\nimport com.github.javaparser.ast.stmt.BlockStmt;\nimport com.github.javaparser.ast.stmt.ExpressionStmt;\nimport com.github.javaparser.ast.stmt.Statement;\nimport com.github.javaparser.resolution.declarations.ResolvedValueDeclaration;\nimport com.github.javaparser.symbolsolver.core.resolution.Context;\nimport com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserSymbolDeclaration;\nimport com.github.javaparser.symbolsolver.model.resolution.SymbolReference;\nimport com.github.javaparser.symbolsolver.model.resolution.TypeSolver;\n\nimport java.util.Collections;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Optional;\n\npublic class BlockStmtContext extends AbstractJavaParserContext<BlockStmt> {\n\n    public BlockStmtContext(BlockStmt wrappedNode, TypeSolver typeSolver) {\n        super(wrappedNode, typeSolver);\n    }\n\n    @Override\n    public List<VariableDeclarator> localVariablesExposedToChild(Node child) {\n        int position = -1;\n        for (int i = 0; i < wrappedNode.getStatements().size(); i++) {\n            if (wrappedNode.getStatements().get(i).equals(child)) {\n                position = i;\n            }\n        }\n        if (position == -1) {\n            throw new RuntimeException();\n        }\n        List<VariableDeclarator> variableDeclarators = new LinkedList<>();\n        for (int i = position - 1; i >= 0; i--) {\n            variableDeclarators.addAll(localVariablesDeclaredIn(wrappedNode.getStatement(i)));\n        }\n        return variableDeclarators;\n    }\n\n    private List<VariableDeclarator> localVariablesDeclaredIn(Statement statement) {\n        if (statement instanceof ExpressionStmt) {\n            ExpressionStmt expressionStmt = (ExpressionStmt) statement;\n            if (expressionStmt.getExpression() instanceof VariableDeclarationExpr) {\n                VariableDeclarationExpr variableDeclarationExpr = (VariableDeclarationExpr) expressionStmt.getExpression();\n                List<VariableDeclarator> variableDeclarators = new LinkedList<>();\n                variableDeclarators.addAll(variableDeclarationExpr.getVariables());\n                return variableDeclarators;\n            }\n        }\n        return Collections.emptyList();\n    }\n\n    @Override\n    public SymbolReference<? extends ResolvedValueDeclaration> solveSymbol(String name) {\n        Optional<Context> optionalParent = getParent();\n        if (!optionalParent.isPresent()) {\n            return SymbolReference.unsolved(ResolvedValueDeclaration.class);\n        }\n\n        if (wrappedNode.getStatements().size() > 0) {\n            // tries to resolve a declaration from local variables defined in child statements\n            // or from parent node context\n            // for example resolve declaration for the MethodCallExpr a.method() in\n            // A a = this;\n            // {\n            //   a.method();\n            // }\n\n            List<VariableDeclarator> variableDeclarators = new LinkedList<>();\n            // find all variable declarators exposed in child\n            wrappedNode.getStatements().forEach(stmt -> variableDeclarators.addAll(localVariablesExposedToChild(stmt)));\n            if (!variableDeclarators.isEmpty()) {\n                // FIXME: Work backwards from the current statement, to only consider declarations prior to this statement.\n                for (VariableDeclarator vd : variableDeclarators) {\n                    if (vd.getNameAsString().equals(name)) {\n                        return SymbolReference.solved(JavaParserSymbolDeclaration.localVar(vd, typeSolver));\n                    }\n                }\n            }\n        }\n\n        // Otherwise continue as normal...\n        return solveSymbolInParentContext(name);\n    }\n}\n",
        "diffSourceCodeSet": [],
        "invokedMethodSet": [
            "methodSignature: com.github.javaparser.symbolsolver.javaparsermodel.contexts.StatementContext#solveSymbol\n methodBody: public SymbolReference<? extends ResolvedValueDeclaration> solveSymbol(String name) {\nSymbolDeclarator symbolDeclarator=JavaParserFactory.getSymbolDeclarator(wrappedNode,typeSolver);\nSymbolReference<? extends ResolvedValueDeclaration> symbolReference=solveWith(symbolDeclarator,name);\nif(symbolReference.isSolved()){return symbolReference;\n}Context parentContext=getParent().orElseThrow(() -> new RuntimeException(\"Parent context unexpectedly empty.\"));\nNode parentOfWrappedNode=demandParentNode(wrappedNode);\nif(parentOfWrappedNode instanceof MethodDeclaration){return parentContext.solveSymbol(name);\n}if(parentOfWrappedNode instanceof ConstructorDeclaration){return parentContext.solveSymbol(name);\n}if(parentOfWrappedNode instanceof LambdaExpr){return parentContext.solveSymbol(name);\n}if(!(parentOfWrappedNode instanceof NodeWithStatements)){return parentContext.solveSymbol(name);\n}NodeWithStatements<?> nodeWithStmt=(NodeWithStatements<?>)parentOfWrappedNode;\nint position=-1;\nfor(int i=0; i < nodeWithStmt.getStatements().size(); i++){if(nodeWithStmt.getStatements().get(i).equals(wrappedNode)){position=i;\n}}if(position == -1){throw new RuntimeException();\n}for(int i=position - 1; i >= 0; i--){symbolDeclarator=JavaParserFactory.getSymbolDeclarator(nodeWithStmt.getStatements().get(i),typeSolver);\nsymbolReference=solveWith(symbolDeclarator,name);\nif(symbolReference.isSolved()){return symbolReference;\n}}return parentContext.solveSymbol(name);\n}",
            "methodSignature: com.github.javaparser.symbolsolver.javaparsermodel.contexts.AbstractMethodLikeDeclarationContext#solveSymbol\n methodBody: public final SymbolReference<? extends ResolvedValueDeclaration> solveSymbol(String name) {\nfor(Parameter parameter: wrappedNode.getParameters()){SymbolDeclarator sb=JavaParserFactory.getSymbolDeclarator(parameter,typeSolver);\nSymbolReference<? extends ResolvedValueDeclaration> symbolReference=AbstractJavaParserContext.solveWith(sb,name);\nif(symbolReference.isSolved()){return symbolReference;\n}}return getParent().orElseThrow(() -> new RuntimeException(\"Parent context unexpectedly empty.\")).solveSymbol(name);\n}",
            "methodSignature: com.github.javaparser.symbolsolver.javaparsermodel.contexts.CatchClauseContext#solveSymbol\n methodBody: public final SymbolReference<? extends ResolvedValueDeclaration> solveSymbol(String name) {\nSymbolDeclarator sb=JavaParserFactory.getSymbolDeclarator(wrappedNode.getParameter(),typeSolver);\nSymbolReference<? extends ResolvedValueDeclaration> symbolReference=AbstractJavaParserContext.solveWith(sb,name);\nif(symbolReference.isSolved()){return symbolReference;\n}return getParent().orElseThrow(() -> new RuntimeException(\"Parent context unexpectedly empty.\")).solveSymbol(name);\n}",
            "methodSignature: com.github.javaparser.symbolsolver.javaparsermodel.contexts.LambdaExprContext#solveSymbol\n methodBody: public SymbolReference<? extends ResolvedValueDeclaration> solveSymbol(String name) {\nfor(Parameter parameter: wrappedNode.getParameters()){SymbolDeclarator sb=JavaParserFactory.getSymbolDeclarator(parameter,typeSolver);\nSymbolReference<ResolvedValueDeclaration> symbolReference=solveWith(sb,name);\nif(symbolReference.isSolved()){return symbolReference;\n}}return getParent().orElseThrow(() -> new RuntimeException(\"Parent context unexpectedly empty.\")).solveSymbol(name);\n}",
            "methodSignature: com.github.javaparser.symbolsolver.core.resolution.Context#getParent\n methodBody: Optional<Context> getParent();",
            "methodSignature: com.github.javaparser.symbolsolver.javaparsermodel.contexts.AnnotationDeclarationContext#solveSymbol\n methodBody: public SymbolReference<? extends ResolvedValueDeclaration> solveSymbol(String name) {\nif(typeSolver == null)throw new IllegalArgumentException();\nif(this.getDeclaration().hasField(name)){return SymbolReference.solved(this.getDeclaration().getField(name));\n}return getParent().orElseThrow(() -> new RuntimeException(\"Parent context unexpectedly empty.\")).solveSymbol(name);\n}",
            "methodSignature: com.github.javaparser.symbolsolver.javaparsermodel.contexts.TryWithResourceContext#solveSymbol\n methodBody: public SymbolReference<? extends ResolvedValueDeclaration> solveSymbol(String name) {\nfor(Expression expr: wrappedNode.getResources()){if(expr instanceof VariableDeclarationExpr){for(VariableDeclarator v: ((VariableDeclarationExpr)expr).getVariables()){if(v.getName().getIdentifier().equals(name)){return SymbolReference.solved(JavaParserSymbolDeclaration.localVar(v,typeSolver));\n}}}}if(demandParentNode(wrappedNode) instanceof BlockStmt){return StatementContext.solveInBlock(name,typeSolver,wrappedNode);\n}{return getParent().orElseThrow(() -> new RuntimeException(\"Parent context unexpectedly empty.\")).solveSymbol(name);\n}}",
            "methodSignature: com.github.javaparser.symbolsolver.javaparsermodel.contexts.AbstractJavaParserContext#getParent\n methodBody: public final Optional<Context> getParent() {\nNode parent=wrappedNode.getParentNode().orElse(null);\nif(parent instanceof MethodCallExpr){MethodCallExpr parentCall=(MethodCallExpr)parent;\nboolean found=false;\nif(parentCall.getArguments() != null){for(Expression expression: parentCall.getArguments()){if(expression == wrappedNode){found=true;\nbreak;\n}}}if(found){Node notMethod=parent;\nwhile(notMethod instanceof MethodCallExpr){notMethod=demandParentNode(notMethod);\n}return Optional.of(JavaParserFactory.getContext(notMethod,typeSolver));\n}}Node notMethod=parent;\nwhile(notMethod instanceof MethodCallExpr || notMethod instanceof FieldAccessExpr){notMethod=notMethod.getParentNode().orElse(null);\n}if(notMethod == null){return Optional.empty();\n}return Optional.of(JavaParserFactory.getContext(notMethod,typeSolver));\n}",
            "methodSignature: com.github.javaparser.symbolsolver.javaparsermodel.contexts.ForEachStatementContext#solveSymbol\n methodBody: public SymbolReference<? extends ResolvedValueDeclaration> solveSymbol(String name) {\nif(wrappedNode.getVariable().getVariables().size() != 1){throw new IllegalStateException();\n}VariableDeclarator variableDeclarator=wrappedNode.getVariable().getVariables().get(0);\nif(variableDeclarator.getName().getId().equals(name)){return SymbolReference.solved(JavaParserSymbolDeclaration.localVar(variableDeclarator,typeSolver));\n}{if(demandParentNode(wrappedNode) instanceof BlockStmt){return StatementContext.solveInBlock(name,typeSolver,wrappedNode);\n}{return getParent().orElseThrow(() -> new RuntimeException(\"Parent context unexpectedly empty.\")).solveSymbol(name);\n}}}",
            "methodSignature: com.github.javaparser.symbolsolver.javaparsermodel.contexts.ClassOrInterfaceDeclarationContext#solveSymbol\n methodBody: public SymbolReference<? extends ResolvedValueDeclaration> solveSymbol(String name) {\nif(typeSolver == null)throw new IllegalArgumentException();\nif(this.getDeclaration().hasVisibleField(name)){return SymbolReference.solved(this.getDeclaration().getVisibleField(name));\n}return getParent().orElseThrow(() -> new RuntimeException(\"Parent context unexpectedly empty.\")).solveSymbol(name);\n}",
            "methodSignature: com.github.javaparser.symbolsolver.javaparsermodel.contexts.FieldAccessContext#solveSymbol\n methodBody: public SymbolReference<? extends ResolvedValueDeclaration> solveSymbol(String name) {\nif(wrappedNode.getName().toString().equals(name)){if(wrappedNode.getScope() instanceof ThisExpr){ResolvedType typeOfThis=JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\nif(typeOfThis.asReferenceType().getTypeDeclaration().isPresent()){return new SymbolSolver(typeSolver).solveSymbolInType(typeOfThis.asReferenceType().getTypeDeclaration().get(),name);\n}}}return JavaParserFactory.getContext(demandParentNode(wrappedNode),typeSolver).solveSymbol(name);\n}",
            "methodSignature: com.github.javaparser.symbolsolver.javaparsermodel.contexts.AnonymousClassDeclarationContext#solveSymbol\n methodBody: public SymbolReference<? extends ResolvedValueDeclaration> solveSymbol(String name) {\nPreconditions.checkArgument(typeSolver != null);\nif(myDeclaration.hasField(name)){return SymbolReference.solved(myDeclaration.getField(name));\n}return getParent().orElseThrow(() -> new RuntimeException(\"Parent context unexpectedly empty.\")).solveSymbol(name);\n}",
            "methodSignature: com.github.javaparser.symbolsolver.core.resolution.Context#solveSymbol\n methodBody: default SymbolReference<? extends ResolvedValueDeclaration> solveSymbol(String name) {\nreturn getParent().orElseThrow(() -> new RuntimeException(\"Parent context unexpectedly empty.\")).solveSymbol(name);\n}",
            "methodSignature: com.github.javaparser.symbolsolver.javaparsermodel.contexts.SwitchEntryContext#solveSymbol\n methodBody: public SymbolReference<? extends ResolvedValueDeclaration> solveSymbol(String name) {\nSwitchStmt switchStmt=(SwitchStmt)demandParentNode(wrappedNode);\nResolvedType type=JavaParserFacade.get(typeSolver).getType(switchStmt.getSelector());\nif(type.isReferenceType() && type.asReferenceType().getTypeDeclaration().isPresent()){ResolvedReferenceTypeDeclaration typeDeclaration=type.asReferenceType().getTypeDeclaration().get();\nif(typeDeclaration.isEnum()){if(type instanceof ReferenceTypeImpl){ReferenceTypeImpl referenceType=(ReferenceTypeImpl)type;\nif(referenceType.getTypeDeclaration().isPresent()){ResolvedReferenceTypeDeclaration typeUsageTypeDeclaration=referenceType.getTypeDeclaration().get();\nif(typeUsageTypeDeclaration.asEnum().hasEnumConstant(name)){return SymbolReference.solved(typeUsageTypeDeclaration.asEnum().getEnumConstant(name));\n}if(typeUsageTypeDeclaration.hasField(name)){return SymbolReference.solved(typeUsageTypeDeclaration.getField(name));\n}}{}}{throw new UnsupportedOperationException();\n}}}for(SwitchEntry seStmt: switchStmt.getEntries()){for(Statement stmt: seStmt.getStatements()){SymbolDeclarator symbolDeclarator=JavaParserFactory.getSymbolDeclarator(stmt,typeSolver);\nSymbolReference<? extends ResolvedValueDeclaration> symbolReference=solveWith(symbolDeclarator,name);\nif(symbolReference.isSolved()){return symbolReference;\n}}if(seStmt == wrappedNode){break;\n}}return getParent().orElseThrow(() -> new RuntimeException(\"Parent context unexpectedly empty.\")).solveSymbol(name);\n}",
            "methodSignature: com.github.javaparser.symbolsolver.javaparsermodel.contexts.EnumDeclarationContext#solveSymbol\n methodBody: public SymbolReference<? extends ResolvedValueDeclaration> solveSymbol(String name) {\nif(typeSolver == null)throw new IllegalArgumentException();\nfor(EnumConstantDeclaration constant: wrappedNode.getEntries()){if(constant.getName().getId().equals(name)){return SymbolReference.solved(new JavaParserEnumConstantDeclaration(constant,typeSolver));\n}}if(this.getDeclaration().hasField(name)){return SymbolReference.solved(this.getDeclaration().getField(name));\n}return getParent().orElseThrow(() -> new RuntimeException(\"Parent context unexpectedly empty.\")).solveSymbol(name);\n}",
            "methodSignature: com.github.javaparser.symbolsolver.resolution.SymbolSolver#solveSymbol\n methodBody: public SymbolReference<? extends ResolvedValueDeclaration> solveSymbol(String name, Node node) {\nreturn solveSymbol(name,JavaParserFactory.getContext(node,typeSolver));\n}",
            "methodSignature: com.github.javaparser.symbolsolver.javaparsermodel.contexts.BlockStmtContext#solveSymbol\n methodBody: public SymbolReference<? extends ResolvedValueDeclaration> solveSymbol(String name) {\nif(wrappedNode.getStatements().size() > 0){List<VariableDeclarator> variableDeclarators=new LinkedList<>();\nwrappedNode.getStatements().forEach(stmt -> variableDeclarators.addAll(localVariablesExposedToChild(stmt)));\nif(!variableDeclarators.isEmpty()){for(VariableDeclarator vd: variableDeclarators){if(vd.getNameAsString().equals(name)){return SymbolReference.solved(JavaParserSymbolDeclaration.localVar(vd,typeSolver));\n}}}}return super.solveSymbol(name);\n}",
            "methodSignature: com.github.javaparser.symbolsolver.javaparsermodel.contexts.MethodCallExprContext#solveSymbol\n methodBody: public SymbolReference<? extends ResolvedValueDeclaration> solveSymbol(String name) {\nreturn getParent().orElseThrow(() -> new RuntimeException(\"Parent context unexpectedly empty.\")).solveSymbol(name);\n}",
            "methodSignature: com.github.javaparser.symbolsolver.javaparsermodel.contexts.ForStatementContext#solveSymbol\n methodBody: public SymbolReference<? extends ResolvedValueDeclaration> solveSymbol(String name) {\nfor(Expression expression: wrappedNode.getInitialization()){if(expression instanceof VariableDeclarationExpr){VariableDeclarationExpr variableDeclarationExpr=(VariableDeclarationExpr)expression;\nfor(VariableDeclarator variableDeclarator: variableDeclarationExpr.getVariables()){if(variableDeclarator.getName().getId().equals(name)){return SymbolReference.solved(JavaParserSymbolDeclaration.localVar(variableDeclarator,typeSolver));\n}}}if(!(expression instanceof AssignExpr || expression instanceof MethodCallExpr || expression instanceof UnaryExpr)){throw new UnsupportedOperationException(expression.getClass().getCanonicalName());\n}}if(demandParentNode(wrappedNode) instanceof NodeWithStatements){return StatementContext.solveInBlock(name,typeSolver,wrappedNode);\n}{return getParent().orElseThrow(() -> new RuntimeException(\"Parent context unexpectedly empty.\")).solveSymbol(name);\n}}"
        ],
        "sourceCodeAfterRefactoring": "@Override\n    public SymbolReference<? extends ResolvedValueDeclaration> solveSymbol(String name) {\n        Optional<Context> optionalParent = getParent();\n        if (!optionalParent.isPresent()) {\n            return SymbolReference.unsolved(ResolvedValueDeclaration.class);\n        }\n\n        if (wrappedNode.getStatements().size() > 0) {\n            // tries to resolve a declaration from local variables defined in child statements\n            // or from parent node context\n            // for example resolve declaration for the MethodCallExpr a.method() in\n            // A a = this;\n            // {\n            //   a.method();\n            // }\n\n            List<VariableDeclarator> variableDeclarators = new LinkedList<>();\n            // find all variable declarators exposed in child\n            wrappedNode.getStatements().forEach(stmt -> variableDeclarators.addAll(localVariablesExposedToChild(stmt)));\n            if (!variableDeclarators.isEmpty()) {\n                // FIXME: Work backwards from the current statement, to only consider declarations prior to this statement.\n                for (VariableDeclarator vd : variableDeclarators) {\n                    if (vd.getNameAsString().equals(name)) {\n                        return SymbolReference.solved(JavaParserSymbolDeclaration.localVar(vd, typeSolver));\n                    }\n                }\n            }\n        }\n\n        // Otherwise continue as normal...\n        return solveSymbolInParentContext(name);\n    }",
        "diffSourceCode": "-   76:     @Override\n-   77:     public SymbolReference<? extends ResolvedValueDeclaration> solveSymbol(String name) {\n-   78:         // tries to resolve a declaration from local variables defined in child statements\n-   79:         // or from parent node context\n-   80:         // for example resolve declaration for the MethodCallExpr a.method() in\n-   81:         // A a = this;\n-   82:         // { \n-   83:         //   a.method(); \n-   84:         // }\n-   85:         if (wrappedNode.getStatements().size() > 0) {\n-   86:             List<VariableDeclarator> variableDeclarators = new LinkedList<>();\n-   87:             // find all variable declarators exposed in child\n-   88:             wrappedNode.getStatements().forEach(stmt-> variableDeclarators.addAll(localVariablesExposedToChild(stmt)));\n-   89:             if (!variableDeclarators.isEmpty()) {\n-   90:                 for (VariableDeclarator vd : variableDeclarators) {\n-   91:                     if (vd.getNameAsString().equals(name) ) {\n-   92:                         return SymbolReference.solved(JavaParserSymbolDeclaration.localVar(vd, typeSolver));\n-   93:                     }\n-   94:                 }\n-   95:             }\n-   96:         }\n-   97:         return super.solveSymbol(name);\n-   98:     } \n-   99: }\n+   76:         return Collections.emptyList();\n+   77:     }\n+   78: \n+   79:     @Override\n+   80:     public SymbolReference<? extends ResolvedValueDeclaration> solveSymbol(String name) {\n+   81:         Optional<Context> optionalParent = getParent();\n+   82:         if (!optionalParent.isPresent()) {\n+   83:             return SymbolReference.unsolved(ResolvedValueDeclaration.class);\n+   84:         }\n+   85: \n+   86:         if (wrappedNode.getStatements().size() > 0) {\n+   87:             // tries to resolve a declaration from local variables defined in child statements\n+   88:             // or from parent node context\n+   89:             // for example resolve declaration for the MethodCallExpr a.method() in\n+   90:             // A a = this;\n+   91:             // {\n+   92:             //   a.method();\n+   93:             // }\n+   94: \n+   95:             List<VariableDeclarator> variableDeclarators = new LinkedList<>();\n+   96:             // find all variable declarators exposed in child\n+   97:             wrappedNode.getStatements().forEach(stmt -> variableDeclarators.addAll(localVariablesExposedToChild(stmt)));\n+   98:             if (!variableDeclarators.isEmpty()) {\n+   99:                 // FIXME: Work backwards from the current statement, to only consider declarations prior to this statement.\n+  100:                 for (VariableDeclarator vd : variableDeclarators) {\n+  101:                     if (vd.getNameAsString().equals(name)) {\n+  102:                         return SymbolReference.solved(JavaParserSymbolDeclaration.localVar(vd, typeSolver));\n+  103:                     }\n+  104:                 }\n+  105:             }\n+  106:         }\n+  107: \n+  108:         // Otherwise continue as normal...\n+  109:         return solveSymbolInParentContext(name);\n+  110:     }\n",
        "uniqueId": "2903fc918dd87be53192aa1065047392f7adf4d1_76_98__79_110_156_161",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 0,
                "covered": 8
            },
            "LINE": {
                "missed": 0,
                "covered": 3
            },
            "COMPLEXITY": {
                "missed": 0,
                "covered": 1
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 1.8
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprivate parse(languageLevel ParserConfiguration.LanguageLevel, code String, parseStart ParseStart<PS>) : PS extracted from private parse(code String, parseStart ParseStart<PS>) : PS in class com.github.javaparser.symbolsolver.resolution.ContextTest",
        "diffLocations": [
            {
                "filePath": "javaparser-symbol-solver-testing/src/test/java/com/github/javaparser/symbolsolver/resolution/ContextTest.java",
                "startLine": 594,
                "endLine": 604,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "javaparser-symbol-solver-testing/src/test/java/com/github/javaparser/symbolsolver/resolution/ContextTest.java",
                "startLine": 610,
                "endLine": 612,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "javaparser-symbol-solver-testing/src/test/java/com/github/javaparser/symbolsolver/resolution/ContextTest.java",
                "startLine": 614,
                "endLine": 624,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "private <PS extends Node> PS parse(String code, ParseStart<PS> parseStart) {\n        ParserConfiguration parserConfiguration = new ParserConfiguration();\n        parserConfiguration.setLanguageLevel(ParserConfiguration.LanguageLevel.JAVA_10);\n        ParseResult<PS> parseResult = new JavaParser(parserConfiguration).parse(parseStart, new StringProvider(code));\n        if (!parseResult.isSuccessful()) {\n            parseResult.getProblems().forEach(p -> System.out.println(\"ERR: \" + p));\n        }\n        assertTrue(parseResult.isSuccessful());\n        PS root = parseResult.getResult().get();\n        return root;\n    }",
        "filePathBefore": "javaparser-symbol-solver-testing/src/test/java/com/github/javaparser/symbolsolver/resolution/ContextTest.java",
        "isPureRefactoring": true,
        "commitId": "2903fc918dd87be53192aa1065047392f7adf4d1",
        "packageNameBefore": "com.github.javaparser.symbolsolver.resolution",
        "classNameBefore": "com.github.javaparser.symbolsolver.resolution.ContextTest",
        "methodNameBefore": "com.github.javaparser.symbolsolver.resolution.ContextTest#parse",
        "invokedMethod": "methodSignature: com.github.javaparser.symbolsolver.resolution.ContextTest#parse\n methodBody: private <PS extends Node> PS parse(String code, ParseStart<PS> parseStart) {\nParserConfiguration parserConfiguration=new ParserConfiguration();\nparserConfiguration.setLanguageLevel(ParserConfiguration.LanguageLevel.JAVA_10);\nParseResult<PS> parseResult=new JavaParser(parserConfiguration).parse(parseStart,new StringProvider(code));\nif(!parseResult.isSuccessful()){parseResult.getProblems().forEach(p -> System.out.println(\"ERR: \" + p));\n}assertTrue(parseResult.isSuccessful());\nPS root=parseResult.getResult().get();\nreturn root;\n}\nmethodSignature: com.github.javaparser.symbolsolver.resolution.naming.AbstractNameLogicTest#parse\n methodBody: protected <N extends Node> N parse(String code, ParseStart<N> parseStart, Optional<TypeSolver> typeSolver) {\nParserConfiguration parserConfiguration=new ParserConfiguration();\nparserConfiguration.setLanguageLevel(ParserConfiguration.LanguageLevel.JAVA_10);\nif(typeSolver.isPresent()){parserConfiguration.setSymbolResolver(new JavaSymbolSolver(typeSolver.get()));\n}ParseResult<N> parseResult=new JavaParser(parserConfiguration).parse(parseStart,new StringProvider(code));\nif(!parseResult.isSuccessful()){parseResult.getProblems().forEach(p -> System.out.println(\"ERR: \" + p));\n}assertTrue(parseResult.isSuccessful());\nN root=parseResult.getResult().get();\nreturn root;\n}",
        "classSignatureBefore": "class ContextTest extends AbstractSymbolResolutionTest ",
        "methodNameBeforeSet": [
            "com.github.javaparser.symbolsolver.resolution.ContextTest#parse"
        ],
        "classNameBeforeSet": [
            "com.github.javaparser.symbolsolver.resolution.ContextTest"
        ],
        "classSignatureBeforeSet": [
            "class ContextTest extends AbstractSymbolResolutionTest "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Changes are within the Extract Method refactoring mechanics",
                "description": "All the mappings are matched! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Copyright (C) 2015-2016 Federico Tomassetti\n * Copyright (C) 2017-2019 The JavaParser Team.\n *\n * This file is part of JavaParser.\n *\n * JavaParser can be used either under the terms of\n * a) the GNU Lesser General Public License as published by\n *     the Free Software Foundation, either version 3 of the License, or\n *     (at your option) any later version.\n * b) the terms of the Apache License\n *\n * You should have received a copy of both licenses in LICENCE.LGPL and\n * LICENCE.APACHE. Please refer to those files for details.\n *\n * JavaParser is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n */\n\npackage com.github.javaparser.symbolsolver.resolution;\n\nimport com.github.javaparser.*;\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.Node;\nimport com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;\nimport com.github.javaparser.ast.body.ConstructorDeclaration;\nimport com.github.javaparser.ast.body.MethodDeclaration;\nimport com.github.javaparser.ast.body.Parameter;\nimport com.github.javaparser.ast.body.VariableDeclarator;\nimport com.github.javaparser.ast.expr.*;\nimport com.github.javaparser.ast.stmt.*;\nimport com.github.javaparser.resolution.MethodUsage;\nimport com.github.javaparser.resolution.declarations.ResolvedClassDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedReferenceTypeDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedTypeDeclaration;\nimport com.github.javaparser.resolution.types.ResolvedType;\nimport com.github.javaparser.symbolsolver.AbstractSymbolResolutionTest;\nimport com.github.javaparser.symbolsolver.core.resolution.Context;\nimport com.github.javaparser.symbolsolver.javaparser.Navigator;\nimport com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade;\nimport com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFactory;\nimport com.github.javaparser.symbolsolver.model.resolution.SymbolReference;\nimport com.github.javaparser.symbolsolver.model.resolution.TypeSolver;\nimport com.github.javaparser.symbolsolver.reflectionmodel.ReflectionClassDeclaration;\nimport com.github.javaparser.symbolsolver.resolution.typesolvers.*;\nimport com.github.javaparser.symbolsolver.utils.LeanParserConfiguration;\nimport org.junit.jupiter.api.Test;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.nio.file.Path;\nimport java.util.Collections;\nimport java.util.List;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport static org.mockito.Mockito.mock;\nimport static org.mockito.Mockito.when;\n\nclass ContextTest extends AbstractSymbolResolutionTest {\n\n    private TypeSolver typeSolver = new CombinedTypeSolver(new MemoryTypeSolver(), new ReflectionTypeSolver());\n\n    private CompilationUnit parseSample(String sampleName) {\n        InputStream is = ContextTest.class.getClassLoader().getResourceAsStream(sampleName + \".java.txt\");\n        return StaticJavaParser.parse(is);\n    }\n\n    @Test\n    void resolveDeclaredFieldReference() {\n        CompilationUnit cu = parseSample(\"ReferencesToField\");\n        com.github.javaparser.ast.body.ClassOrInterfaceDeclaration referencesToField = Navigator.demandClass(cu, \"ReferencesToField\");\n        MethodDeclaration method1 = Navigator.demandMethod(referencesToField, \"method1\");\n        ExpressionStmt stmt = (ExpressionStmt) method1.getBody().get().getStatements().get(0);\n        AssignExpr assignExpr = (AssignExpr) stmt.getExpression();\n\n        SymbolSolver symbolSolver = new SymbolSolver(typeSolver);\n        SymbolReference symbolReference = symbolSolver.solveSymbol(\"i\", assignExpr.getTarget());\n\n        assertTrue(symbolReference.isSolved());\n        assertEquals(\"i\", symbolReference.getCorrespondingDeclaration().getName());\n        assertTrue(symbolReference.getCorrespondingDeclaration().isField());\n    }\n\n    @Test\n    void resolveInheritedFieldReference() {\n        CompilationUnit cu = parseSample(\"ReferencesToField\");\n        com.github.javaparser.ast.body.ClassOrInterfaceDeclaration referencesToField = Navigator.demandClass(cu, \"ReferencesToFieldExtendingClass\");\n        MethodDeclaration method1 = Navigator.demandMethod(referencesToField, \"method2\");\n        ExpressionStmt stmt = (ExpressionStmt) method1.getBody().get().getStatements().get(0);\n        AssignExpr assignExpr = (AssignExpr) stmt.getExpression();\n\n        SymbolSolver symbolSolver = new SymbolSolver(typeSolver);\n        SymbolReference symbolReference = symbolSolver.solveSymbol(\"i\", assignExpr.getTarget());\n\n        assertTrue(symbolReference.isSolved());\n        assertEquals(\"i\", symbolReference.getCorrespondingDeclaration().getName());\n        assertTrue(symbolReference.getCorrespondingDeclaration().isField());\n    }\n\n    @Test\n    void resolveParameterReference() {\n        CompilationUnit cu = parseSample(\"ReferencesToParameter\");\n        com.github.javaparser.ast.body.ClassOrInterfaceDeclaration referencesToField = Navigator.demandClass(cu, \"ReferenceToParameter\");\n        MethodDeclaration method1 = Navigator.demandMethod(referencesToField, \"aMethod\");\n        NameExpr foo = Navigator.findNameExpression(method1, \"foo\").get();\n\n        SymbolSolver symbolSolver = new SymbolSolver(typeSolver);\n        SymbolReference symbolReference = symbolSolver.solveSymbol(\"foo\", foo);\n\n        assertTrue(symbolReference.isSolved());\n        assertEquals(\"foo\", symbolReference.getCorrespondingDeclaration().getName());\n        assertTrue(symbolReference.getCorrespondingDeclaration().isParameter());\n    }\n\n    @Test\n    void resolveReferenceToImportedType() {\n        CompilationUnit cu = parseSample(\"Navigator\");\n        com.github.javaparser.ast.body.ClassOrInterfaceDeclaration referencesToField = Navigator.demandClass(cu, \"Navigator\");\n        MethodDeclaration method = Navigator.demandMethod(referencesToField, \"findType\");\n        Parameter param = method.getParameters().get(0);\n\n        ResolvedClassDeclaration compilationUnitDecl = mock(ResolvedClassDeclaration.class);\n        when(compilationUnitDecl.getName()).thenReturn(\"CompilationUnit\");\n        when(compilationUnitDecl.getQualifiedName()).thenReturn(\"com.github.javaparser.ast.CompilationUnit\");\n        TypeSolver typeSolver = mock(TypeSolver.class);\n        when(typeSolver.getSolvedJavaLangObject()).thenReturn(new ReflectionClassDeclaration(Object.class, typeSolver));\n        when(typeSolver.getRoot()).thenReturn(typeSolver);\n        when(typeSolver.solveType(\"java.lang.Object\")).thenReturn(new ReflectionClassDeclaration(Object.class, typeSolver));\n        when(typeSolver.tryToSolveType(\"com.github.javaparser.ast.CompilationUnit\")).thenReturn(SymbolReference.solved(compilationUnitDecl));\n        SymbolSolver symbolSolver = new SymbolSolver(typeSolver);\n\n        SymbolReference<? extends ResolvedTypeDeclaration> ref = symbolSolver.solveType(\"CompilationUnit\", param);\n\n        assertTrue(ref.isSolved());\n        assertEquals(\"CompilationUnit\", ref.getCorrespondingDeclaration().getName());\n        assertEquals(\"com.github.javaparser.ast.CompilationUnit\", ref.getCorrespondingDeclaration().getQualifiedName());\n    }\n\n    @Test\n    void resolveReferenceUsingQualifiedName() {\n        CompilationUnit cu = parseSample(\"Navigator2\");\n        com.github.javaparser.ast.body.ClassOrInterfaceDeclaration referencesToField = Navigator.demandClass(cu, \"Navigator\");\n        MethodDeclaration method = Navigator.demandMethod(referencesToField, \"findType\");\n        Parameter param = method.getParameters().get(0);\n\n        ResolvedClassDeclaration compilationUnitDecl = mock(ResolvedClassDeclaration.class);\n        when(compilationUnitDecl.getName()).thenReturn(\"CompilationUnit\");\n        when(compilationUnitDecl.getQualifiedName()).thenReturn(\"com.github.javaparser.ast.CompilationUnit\");\n        TypeSolver typeSolver = mock(TypeSolver.class);\n        when(typeSolver.getSolvedJavaLangObject()).thenReturn(new ReflectionClassDeclaration(Object.class, typeSolver));\n        //when(typeSolver.tryToSolveType(\"java.lang.com.github.javaparser.ast.CompilationUnit\")).thenReturn(SymbolReference.unsolved(ClassDeclaration.class));\n        when(typeSolver.getRoot()).thenReturn(typeSolver);\n        when(typeSolver.solveType(\"java.lang.Object\")).thenReturn(new ReflectionClassDeclaration(Object.class, typeSolver));\n        when(typeSolver.tryToSolveType(\"com.github.javaparser.ast.CompilationUnit\")).thenReturn(SymbolReference.solved(compilationUnitDecl));\n        SymbolSolver symbolSolver = new SymbolSolver(typeSolver);\n        \n        SymbolReference<? extends ResolvedTypeDeclaration> ref = symbolSolver.solveType(\"com.github.javaparser.ast.CompilationUnit\", param);\n\n        assertTrue(ref.isSolved());\n        assertEquals(\"CompilationUnit\", ref.getCorrespondingDeclaration().getName());\n        assertEquals(\"com.github.javaparser.ast.CompilationUnit\", ref.getCorrespondingDeclaration().getQualifiedName());\n    }\n\n    @Test\n    void resolveReferenceToClassesInTheSamePackage() {\n        CompilationUnit cu = parseSample(\"Navigator3\");\n        com.github.javaparser.ast.body.ClassOrInterfaceDeclaration referencesToField = Navigator.demandClass(cu, \"Navigator\");\n        MethodDeclaration method = Navigator.demandMethod(referencesToField, \"findType\");\n        Parameter param = method.getParameters().get(0);\n\n        ResolvedClassDeclaration compilationUnitDecl = mock(ResolvedClassDeclaration.class);\n        when(compilationUnitDecl.getName()).thenReturn(\"CompilationUnit\");\n        when(compilationUnitDecl.getQualifiedName()).thenReturn(\"my.packagez.CompilationUnit\");\n        TypeSolver typeSolver = mock(TypeSolver.class);\n        when(typeSolver.getSolvedJavaLangObject()).thenReturn(new ReflectionClassDeclaration(Object.class, typeSolver));\n        when(typeSolver.getRoot()).thenReturn(typeSolver);\n        when(typeSolver.solveType(\"java.lang.Object\")).thenReturn(new ReflectionClassDeclaration(Object.class, typeSolver));\n        when(typeSolver.tryToSolveType(\"my.packagez.CompilationUnit\")).thenReturn(SymbolReference.solved(compilationUnitDecl));\n        SymbolSolver symbolSolver = new SymbolSolver(typeSolver);\n\n        SymbolReference<? extends ResolvedTypeDeclaration> ref = symbolSolver.solveType(\"CompilationUnit\", param);\n\n        assertTrue(ref.isSolved());\n        assertEquals(\"CompilationUnit\", ref.getCorrespondingDeclaration().getName());\n        assertEquals(\"my.packagez.CompilationUnit\", ref.getCorrespondingDeclaration().getQualifiedName());\n    }\n\n    @Test\n    void resolveReferenceToClassInJavaLang() {\n        CompilationUnit cu = parseSample(\"Navigator\");\n        com.github.javaparser.ast.body.ClassOrInterfaceDeclaration referencesToField = Navigator.demandClass(cu, \"Navigator\");\n        MethodDeclaration method = Navigator.demandMethod(referencesToField, \"findType\");\n        Parameter param = method.getParameters().get(1);\n\n        ResolvedClassDeclaration stringDecl = mock(ResolvedClassDeclaration.class);\n        when(stringDecl.getName()).thenReturn(\"String\");\n        when(stringDecl.getQualifiedName()).thenReturn(\"java.lang.String\");\n        TypeSolver typeSolver = mock(TypeSolver.class);\n        when(typeSolver.getSolvedJavaLangObject()).thenReturn(new ReflectionClassDeclaration(Object.class, typeSolver));\n        when(typeSolver.tryToSolveType(\"me.tomassetti.symbolsolver.javaparser.String\")).thenReturn(SymbolReference.unsolved(ResolvedReferenceTypeDeclaration.class));\n        when(typeSolver.getRoot()).thenReturn(typeSolver);\n        when(typeSolver.solveType(\"java.lang.Object\")).thenReturn(new ReflectionClassDeclaration(Object.class, typeSolver));\n        when(typeSolver.tryToSolveType(\"java.lang.String\")).thenReturn(SymbolReference.solved(stringDecl));\n        SymbolSolver symbolSolver = new SymbolSolver(typeSolver);\n\n        SymbolReference<? extends ResolvedTypeDeclaration> ref = symbolSolver.solveType(\"String\", param);\n\n        assertTrue(ref.isSolved());\n        assertEquals(\"String\", ref.getCorrespondingDeclaration().getName());\n        assertEquals(\"java.lang.String\", ref.getCorrespondingDeclaration().getQualifiedName());\n    }\n\n    @Test\n    void resolveReferenceToMethod() throws IOException {\n        CompilationUnit cu = parseSample(\"Navigator\");\n        com.github.javaparser.ast.body.ClassOrInterfaceDeclaration referencesToField = Navigator.demandClass(cu, \"Navigator\");\n        MethodDeclaration method = Navigator.demandMethod(referencesToField, \"findType\");\n        MethodCallExpr callToGetTypes = Navigator.findMethodCall(method, \"getTypes\").get();\n\n        Path pathToJar = adaptPath(\"src/test/resources/javaparser-core-2.1.0.jar\");\n        TypeSolver typeSolver = new CombinedTypeSolver(new JarTypeSolver(pathToJar), new ReflectionTypeSolver(true));\n        SymbolSolver symbolSolver = new SymbolSolver(typeSolver);\n\n        MethodUsage ref = symbolSolver.solveMethod(\"getTypes\", Collections.emptyList(), callToGetTypes);\n\n        assertEquals(\"getTypes\", ref.getName());\n        assertEquals(\"com.github.javaparser.ast.CompilationUnit\", ref.declaringType().getQualifiedName());\n\n        //verify(typeSolver);\n    }\n\n    @Test\n    void resolveCascadeOfReferencesToMethod() throws IOException {\n        CompilationUnit cu = parseSample(\"Navigator\");\n        com.github.javaparser.ast.body.ClassOrInterfaceDeclaration referencesToField = Navigator.demandClass(cu, \"Navigator\");\n        MethodDeclaration method = Navigator.demandMethod(referencesToField, \"findType\");\n        MethodCallExpr callToStream = Navigator.findMethodCall(method, \"stream\").get();\n\n        Path pathToJar = adaptPath(\"src/test/resources/javaparser-core-2.1.0.jar\");\n        TypeSolver typeSolver = new CombinedTypeSolver(new JarTypeSolver(pathToJar), new ReflectionTypeSolver(true));\n        SymbolSolver symbolSolver = new SymbolSolver(typeSolver);\n        MethodUsage ref = symbolSolver.solveMethod(\"stream\", Collections.emptyList(), callToStream);\n\n        assertEquals(\"stream\", ref.getName());\n        assertEquals(\"java.util.Collection\", ref.declaringType().getQualifiedName());\n    }\n\n    @Test\n    void resolveReferenceToMethodCalledOnArrayAccess() {\n        CompilationUnit cu = parseSample(\"ArrayAccess\");\n        com.github.javaparser.ast.body.ClassOrInterfaceDeclaration clazz = Navigator.demandClass(cu, \"ArrayAccess\");\n        MethodDeclaration method = Navigator.demandMethod(clazz, \"access\");\n        MethodCallExpr callToTrim = Navigator.findMethodCall(method, \"trim\").get();\n\n        Path src = adaptPath(\"src/test/resources\");\n        TypeSolver typeSolver = new CombinedTypeSolver(new ReflectionTypeSolver(), new JavaParserTypeSolver(src, new LeanParserConfiguration()));\n        SymbolSolver symbolSolver = new SymbolSolver(typeSolver);\n        MethodUsage ref = symbolSolver.solveMethod(\"trim\", Collections.emptyList(), callToTrim);\n\n        assertEquals(\"trim\", ref.getName());\n        assertEquals(\"java.lang.String\", ref.declaringType().getQualifiedName());\n    }\n\n    @Test\n    void resolveReferenceToJreType() {\n        CompilationUnit cu = parseSample(\"NavigatorSimplified\");\n        com.github.javaparser.ast.body.ClassOrInterfaceDeclaration clazz = Navigator.demandClass(cu, \"Navigator\");\n        MethodDeclaration method = Navigator.demandMethod(clazz, \"foo\");\n        com.github.javaparser.ast.type.Type streamJavaParserType = method.getParameters().get(0).getType();\n\n        TypeSolver typeSolver = new ReflectionTypeSolver();\n        ResolvedType streamType = JavaParserFacade.get(typeSolver).convert(streamJavaParserType, method);\n\n        assertEquals(\"java.util.stream.Stream<java.lang.String>\", streamType.describe());\n    }\n\n    @Test\n    void resolveReferenceToMethodWithLambda() {\n        CompilationUnit cu = parseSample(\"NavigatorSimplified\");\n        com.github.javaparser.ast.body.ClassOrInterfaceDeclaration clazz = Navigator.demandClass(cu, \"Navigator\");\n        MethodDeclaration method = Navigator.demandMethod(clazz, \"findType\");\n        MethodCallExpr methodCallExpr = Navigator.findMethodCall(method, \"filter\").get();\n\n        TypeSolver typeSolver = new ReflectionTypeSolver();\n        ResolvedType ref = JavaParserFacade.get(typeSolver).getType(methodCallExpr);\n\n        assertEquals(\"java.util.stream.Stream<java.lang.String>\", ref.describe());\n        assertEquals(1, ref.asReferenceType().typeParametersValues().size());\n        assertEquals(\"java.lang.String\", ref.asReferenceType().typeParametersValues().get(0).describe());\n    }\n\n    @Test\n    void resolveReferenceToLambdaParamBase() {\n        CompilationUnit cu = parseSample(\"NavigatorSimplified\");\n        com.github.javaparser.ast.body.ClassOrInterfaceDeclaration clazz = Navigator.demandClass(cu, \"Navigator\");\n        MethodDeclaration method = Navigator.demandMethod(clazz, \"findType\");\n        NameExpr refToT = Navigator.findNameExpression(method, \"t\").get();\n\n        TypeSolver typeSolver = new ReflectionTypeSolver();\n        JavaParserFacade javaParserFacade = JavaParserFacade.get(typeSolver);\n        ResolvedType ref = javaParserFacade.getType(refToT);\n\n        assertEquals(\"? super java.lang.String\", ref.describe());\n    }\n\n    @Test\n    void resolveReferenceToLambdaParamSimplified() {\n        CompilationUnit cu = parseSample(\"NavigatorSimplified\");\n        com.github.javaparser.ast.body.ClassOrInterfaceDeclaration clazz = Navigator.demandClass(cu, \"Navigator\");\n        MethodDeclaration method = Navigator.demandMethod(clazz, \"findType\");\n        MethodCallExpr call = Navigator.findMethodCall(method, \"isEmpty\").get();\n\n        TypeSolver typeSolver = new ReflectionTypeSolver();\n        SymbolSolver symbolSolver = new SymbolSolver(typeSolver);\n        MethodUsage ref = symbolSolver.solveMethod(\"isEmpty\", Collections.emptyList(), call);\n\n        assertEquals(\"isEmpty\", ref.getName());\n        assertEquals(\"java.lang.String\", ref.declaringType().getQualifiedName());\n    }\n\n    @Test\n    void resolveGenericReturnTypeOfMethodInJar() throws IOException {\n        CompilationUnit cu = parseSample(\"Navigator\");\n        com.github.javaparser.ast.body.ClassOrInterfaceDeclaration clazz = Navigator.demandClass(cu, \"Navigator\");\n        MethodDeclaration method = Navigator.demandMethod(clazz, \"findType\");\n        MethodCallExpr call = Navigator.findMethodCall(method, \"getTypes\").get();\n\n        Path pathToJar = adaptPath(\"src/test/resources/javaparser-core-2.1.0.jar\");\n        TypeSolver typeSolver = new CombinedTypeSolver(new ReflectionTypeSolver(), new JarTypeSolver(pathToJar));\n        MethodUsage methodUsage = JavaParserFacade.get(typeSolver).solveMethodAsUsage(call);\n\n        assertEquals(\"getTypes\", methodUsage.getName());\n        assertEquals(\"java.util.List<com.github.javaparser.ast.body.TypeDeclaration>\", methodUsage.returnType().describe());\n        assertEquals(1, methodUsage.returnType().asReferenceType().typeParametersValues().size());\n        assertEquals(\"com.github.javaparser.ast.body.TypeDeclaration\", methodUsage.returnType().asReferenceType().typeParametersValues().get(0).describe());\n    }\n\n    @Test\n    void resolveCompoundGenericReturnTypeOfMethodInJar() throws IOException {\n        CompilationUnit cu = parseSample(\"GenericClassNavigator\");\n        com.github.javaparser.ast.body.ClassOrInterfaceDeclaration clazz = Navigator.demandClass(cu, \"GenericClassNavigator\");\n        MethodDeclaration method = Navigator.demandMethod(clazz, \"doubleTyped\");\n        MethodCallExpr call = Navigator.findMethodCall(method, \"genericMethodWithDoubleTypedReturnType\").get();\n\n        Path pathToJar = adaptPath(\"src/test/resources/javassist_generics/generics.jar\");\n        TypeSolver typeSolver = new CombinedTypeSolver(new ReflectionTypeSolver(), new JarTypeSolver(pathToJar));\n        MethodUsage methodUsage = JavaParserFacade.get(typeSolver).solveMethodAsUsage(call);\n\n        assertEquals(\"genericMethodWithDoubleTypedReturnType\", methodUsage.getName());\n        assertEquals(\"java.util.Map<T, V>\", methodUsage.returnType().describe());\n    }\n\n    @Test\n    void resolveNestedGenericReturnTypeOfMethodInJar() throws IOException {\n        CompilationUnit cu = parseSample(\"GenericClassNavigator\");\n        com.github.javaparser.ast.body.ClassOrInterfaceDeclaration clazz = Navigator.demandClass(cu, \"GenericClassNavigator\");\n        MethodDeclaration method = Navigator.demandMethod(clazz, \"nestedTyped\");\n        MethodCallExpr call = Navigator.findMethodCall(method, \"genericMethodWithNestedReturnType\").get();\n\n        Path pathToJar = adaptPath(\"src/test/resources/javassist_generics/generics.jar\");\n        TypeSolver typeSolver = new CombinedTypeSolver(new ReflectionTypeSolver(), new JarTypeSolver(pathToJar));\n        MethodUsage methodUsage = JavaParserFacade.get(typeSolver).solveMethodAsUsage(call);\n\n        assertEquals(\"genericMethodWithNestedReturnType\", methodUsage.getName());\n        assertEquals(\"java.util.List<java.util.List<T>>\", methodUsage.returnType().describe());\n    }\n\n    @Test\n    void resolveSimpleGenericReturnTypeOfMethodInJar() throws IOException {\n        CompilationUnit cu = parseSample(\"GenericClassNavigator\");\n        com.github.javaparser.ast.body.ClassOrInterfaceDeclaration clazz = Navigator.demandClass(cu, \"GenericClassNavigator\");\n        MethodDeclaration method = Navigator.demandMethod(clazz, \"simple\");\n        MethodCallExpr call = Navigator.findMethodCall(method, \"get\").get();\n\n        Path pathToJar = adaptPath(\"src/test/resources/javassist_generics/generics.jar\");\n        TypeSolver typeSolver = new CombinedTypeSolver(new ReflectionTypeSolver(), new JarTypeSolver(pathToJar));\n        MethodUsage methodUsage = JavaParserFacade.get(typeSolver).solveMethodAsUsage(call);\n\n        assertEquals(\"get\", methodUsage.getName());\n        assertEquals(\"java.util.List<java.util.List<java.lang.String>>\", methodUsage.returnType().describe());\n    }\n\n    @Test\n    void resolveGenericReturnTypeFromInputParam() throws IOException {\n        CompilationUnit cu = parseSample(\"GenericClassNavigator\");\n        com.github.javaparser.ast.body.ClassOrInterfaceDeclaration clazz = Navigator.demandClass(cu, \"GenericClassNavigator\");\n        MethodDeclaration method = Navigator.demandMethod(clazz, \"input\");\n        MethodCallExpr call = Navigator.findMethodCall(method, \"copy\").get();\n\n        Path pathToJar = adaptPath(\"src/test/resources/javassist_generics/generics.jar\");\n        TypeSolver typeSolver = new CombinedTypeSolver(new ReflectionTypeSolver(), new JarTypeSolver(pathToJar));\n        MethodUsage methodUsage = JavaParserFacade.get(typeSolver).solveMethodAsUsage(call);\n\n        assertEquals(\"copy\", methodUsage.getName());\n        assertEquals(\"javaparser.GenericClass<java.util.List<java.lang.String>>\", methodUsage.returnType().describe());\n    }\n\n    @Test\n    void resolveComplexGenericReturnType() throws IOException {\n        CompilationUnit cu = parseSample(\"GenericClassNavigator\");\n        com.github.javaparser.ast.body.ClassOrInterfaceDeclaration clazz = Navigator.demandClass(cu, \"GenericClassNavigator\");\n        MethodDeclaration method = Navigator.demandMethod(clazz, \"complex\");\n        MethodCallExpr call = Navigator.findMethodCall(method, \"complexGenerics\").get();\n\n        Path pathToJar = adaptPath(\"src/test/resources/javassist_generics/generics.jar\");\n        TypeSolver typeSolver = new CombinedTypeSolver(new ReflectionTypeSolver(), new JarTypeSolver(pathToJar));\n        MethodUsage methodUsage = JavaParserFacade.get(typeSolver).solveMethodAsUsage(call);\n\n        assertEquals(\"complexGenerics\", methodUsage.getName());\n        assertEquals(\"T\", methodUsage.returnType().describe());\n    }\n\n    @Test\n    void resolveDoubleNestedClassType() throws IOException {\n        CompilationUnit cu = parseSample(\"GenericClassNavigator\");\n        com.github.javaparser.ast.body.ClassOrInterfaceDeclaration clazz = Navigator.demandClass(cu, \"GenericClassNavigator\");\n        MethodDeclaration method = Navigator.demandMethod(clazz, \"nestedTypes\");\n        MethodCallExpr call = Navigator.findMethodCall(method, \"asList\").get();\n\n        Path pathToJar = adaptPath(\"src/test/resources/javassist_generics/generics.jar\");\n        TypeSolver typeSolver = new CombinedTypeSolver(new ReflectionTypeSolver(), new JarTypeSolver(pathToJar));\n        MethodUsage methodUsage = JavaParserFacade.get(typeSolver).solveMethodAsUsage(call);\n\n        assertEquals(\"asList\", methodUsage.getName());\n        assertEquals(\"java.util.List<javaparser.GenericClass.Bar.NestedBar>\", methodUsage.getParamType(0).describe());\n    }\n\n    @Test\n    void resolveTypeUsageOfFirstMethodInGenericClass() throws IOException {\n        CompilationUnit cu = parseSample(\"Navigator\");\n        com.github.javaparser.ast.body.ClassOrInterfaceDeclaration clazz = Navigator.demandClass(cu, \"Navigator\");\n        MethodDeclaration method = Navigator.demandMethod(clazz, \"findType\");\n        MethodCallExpr callToGetTypes = Navigator.findMethodCall(method, \"getTypes\").get();\n\n        Path pathToJar = adaptPath(\"src/test/resources/javaparser-core-2.1.0.jar\");\n        TypeSolver typeSolver = new CombinedTypeSolver(new ReflectionTypeSolver(), new JarTypeSolver(pathToJar));\n        MethodUsage filterUsage = JavaParserFacade.get(typeSolver).solveMethodAsUsage(callToGetTypes);\n\n        assertEquals(\"java.util.List<com.github.javaparser.ast.body.TypeDeclaration>\", filterUsage.returnType().describe());\n        assertEquals(1, filterUsage.returnType().asReferenceType().typeParametersValues().size());\n        assertEquals(\"com.github.javaparser.ast.body.TypeDeclaration\", filterUsage.returnType().asReferenceType().typeParametersValues().get(0).describe());\n    }\n\n    @Test\n    void resolveTypeUsageOfMethodInGenericClass() throws IOException {\n        CompilationUnit cu = parseSample(\"Navigator\");\n        com.github.javaparser.ast.body.ClassOrInterfaceDeclaration clazz = Navigator.demandClass(cu, \"Navigator\");\n        MethodDeclaration method = Navigator.demandMethod(clazz, \"findType\");\n        MethodCallExpr callToStream = Navigator.findMethodCall(method, \"stream\").get();\n\n        Path pathToJar = adaptPath(\"src/test/resources/javaparser-core-2.1.0.jar\");\n        TypeSolver typeSolver = new CombinedTypeSolver(new ReflectionTypeSolver(), new JarTypeSolver(pathToJar));\n        MethodUsage filterUsage = JavaParserFacade.get(typeSolver).solveMethodAsUsage(callToStream);\n\n        assertEquals(\"java.util.stream.Stream<com.github.javaparser.ast.body.TypeDeclaration>\", filterUsage.returnType().describe());\n    }\n\n    @Test\n    void resolveTypeUsageOfCascadeMethodInGenericClass() throws IOException {\n        CompilationUnit cu = parseSample(\"Navigator\");\n        com.github.javaparser.ast.body.ClassOrInterfaceDeclaration clazz = Navigator.demandClass(cu, \"Navigator\");\n        MethodDeclaration method = Navigator.demandMethod(clazz, \"findType\");\n        MethodCallExpr callToFilter = Navigator.findMethodCall(method, \"filter\").get();\n\n        Path pathToJar = adaptPath(\"src/test/resources/javaparser-core-2.1.0.jar\");\n        TypeSolver typeSolver = new CombinedTypeSolver(new ReflectionTypeSolver(), new JarTypeSolver(pathToJar));\n        MethodUsage filterUsage = JavaParserFacade.get(typeSolver).solveMethodAsUsage(callToFilter);\n\n        assertEquals(\"java.util.stream.Stream<com.github.javaparser.ast.body.TypeDeclaration>\", filterUsage.returnType().describe());\n    }\n\n    @Test\n    void resolveLambdaType() throws IOException {\n        CompilationUnit cu = parseSample(\"Navigator\");\n        com.github.javaparser.ast.body.ClassOrInterfaceDeclaration clazz = Navigator.demandClass(cu, \"Navigator\");\n        MethodDeclaration method = Navigator.demandMethod(clazz, \"findType\");\n        MethodCallExpr callToFilter = Navigator.findMethodCall(method, \"filter\").get();\n        Expression lambdaExpr = callToFilter.getArguments().get(0);\n\n        Path pathToJar = adaptPath(\"src/test/resources/javaparser-core-2.1.0.jar\");\n        TypeSolver typeSolver = new CombinedTypeSolver(new ReflectionTypeSolver(), new JarTypeSolver(pathToJar));\n        ResolvedType typeOfLambdaExpr = JavaParserFacade.get(typeSolver).getType(lambdaExpr);\n\n        assertEquals(\"java.util.function.Predicate<? super com.github.javaparser.ast.body.TypeDeclaration>\", typeOfLambdaExpr.describe());\n    }\n\n    @Test\n    void resolveReferenceToLambdaParam() throws IOException {\n        CompilationUnit cu = parseSample(\"Navigator\");\n        com.github.javaparser.ast.body.ClassOrInterfaceDeclaration clazz = Navigator.demandClass(cu, \"Navigator\");\n        MethodDeclaration method = Navigator.demandMethod(clazz, \"findType\");\n        MethodCallExpr callToGetName = Navigator.findMethodCall(method, \"getName\").get();\n        Expression referenceToT = callToGetName.getScope().get();\n\n        Path pathToJar = adaptPath(\"src/test/resources/javaparser-core-2.1.0.jar\");\n        TypeSolver typeSolver = new CombinedTypeSolver(new ReflectionTypeSolver(), new JarTypeSolver(pathToJar));\n        ResolvedType typeOfT = JavaParserFacade.get(typeSolver).getType(referenceToT);\n\n        assertEquals(\"? super com.github.javaparser.ast.body.TypeDeclaration\", typeOfT.describe());\n    }\n\n    @Test\n    void resolveReferenceToCallOnLambdaParam() throws IOException {\n        CompilationUnit cu = parseSample(\"Navigator\");\n        com.github.javaparser.ast.body.ClassOrInterfaceDeclaration clazz = Navigator.demandClass(cu, \"Navigator\");\n        MethodDeclaration method = Navigator.demandMethod(clazz, \"findType\");\n        MethodCallExpr callToGetName = Navigator.findMethodCall(method, \"getName\").get();\n\n        Path pathToJar = adaptPath(\"src/test/resources/javaparser-core-2.1.0.jar\");\n        TypeSolver typeSolver = new CombinedTypeSolver(new ReflectionTypeSolver(), new JarTypeSolver(pathToJar));\n        MethodUsage methodUsage = JavaParserFacade.get(typeSolver).solveMethodAsUsage(callToGetName);\n\n        assertEquals(\"getName\", methodUsage.getName());\n        assertEquals(\"com.github.javaparser.ast.body.TypeDeclaration\", methodUsage.declaringType().getQualifiedName());\n    }\n\n    @Test\n    void resolveReferenceToOverloadMethodWithNullParam() {\n        CompilationUnit cu = parseSample(\"OverloadedMethods\");\n        com.github.javaparser.ast.body.ClassOrInterfaceDeclaration clazz = Navigator.demandClass(cu, \"OverloadedMethods\");\n        MethodDeclaration method = Navigator.demandMethod(clazz, \"m1\");\n        MethodCallExpr call = Navigator.findMethodCall(method, \"overloaded\").get();\n\n        ReflectionTypeSolver typeSolver = new ReflectionTypeSolver();\n        MethodUsage ref = JavaParserFacade.get(typeSolver).solveMethodAsUsage(call);\n\n        assertEquals(\"overloaded\", ref.getName());\n        assertEquals(1, ref.getNoParams());\n        assertEquals(\"java.lang.String\", ref.getParamTypes().get(0).describe());\n    }\n\n    @Test\n    void resolveReferenceToOverloadMethodFindStricter() {\n        CompilationUnit cu = parseSample(\"OverloadedMethods\");\n        com.github.javaparser.ast.body.ClassOrInterfaceDeclaration clazz = Navigator.demandClass(cu, \"OverloadedMethods\");\n        MethodDeclaration method = Navigator.demandMethod(clazz, \"m2\");\n        MethodCallExpr call = Navigator.findMethodCall(method, \"overloaded\").get();\n\n        ReflectionTypeSolver typeSolver = new ReflectionTypeSolver();\n        MethodUsage ref = JavaParserFacade.get(typeSolver).solveMethodAsUsage(call);\n\n        assertEquals(\"overloaded\", ref.getName());\n        assertEquals(1, ref.getNoParams());\n        assertEquals(\"java.lang.String\", ref.getParamTypes().get(0).describe());\n    }\n\n    @Test\n    void resolveReferenceToMethodWithGenericArrayTypeParam() {\n        CompilationUnit cu = parseSample(\"GenericArrayMethodArgument\");\n        ClassOrInterfaceDeclaration clazz = Navigator.demandClass(cu, \"GenericArrayMethodArgument\");\n        MethodDeclaration method = Navigator.demandMethod(clazz, \"bar\");\n        MethodCallExpr call = Navigator.findMethodCall(method, \"foo\").get();\n\n        TypeSolver typeSolver = new ReflectionTypeSolver();\n        MethodUsage ref = JavaParserFacade.get(typeSolver).solveMethodAsUsage(call);\n\n        assertEquals(\"foo\", ref.getName());\n        assertEquals(1, ref.getNoParams());\n        assertEquals(\"java.lang.String[]\", ref.getParamType(0).describe());\n    }\n\n    @Test\n    void resolveInheritedMethodFromInterface() {\n        CompilationUnit cu = parseSample(\"InterfaceInheritance\");\n        com.github.javaparser.ast.body.ClassOrInterfaceDeclaration clazz = Navigator.demandClass(cu, \"Test\");\n        MethodDeclaration method = Navigator.demandMethod(clazz, \"test\");\n        MethodCallExpr call = Navigator.findMethodCall(method, \"foobar\").get();\n\n        Path src = adaptPath(\"src/test/resources\");\n        TypeSolver typeSolver = new CombinedTypeSolver(new ReflectionTypeSolver(), new JavaParserTypeSolver(src));\n        ResolvedType type = JavaParserFacade.get(typeSolver).getType(call);\n\n        assertEquals(\"double\", type.describe());\n    }\n\n    @Test\n    void resolveReferenceToOverloadMethodFindOnlyCompatible() {\n        CompilationUnit cu = parseSample(\"OverloadedMethods\");\n        com.github.javaparser.ast.body.ClassOrInterfaceDeclaration clazz = Navigator.demandClass(cu, \"OverloadedMethods\");\n        MethodDeclaration method = Navigator.demandMethod(clazz, \"m3\");\n        MethodCallExpr call = Navigator.findMethodCall(method, \"overloaded\").get();\n\n        ReflectionTypeSolver typeSolver = new ReflectionTypeSolver();\n        MethodUsage ref = JavaParserFacade.get(typeSolver).solveMethodAsUsage(call);\n\n        assertEquals(\"overloaded\", ref.getName());\n        assertEquals(1, ref.getNoParams());\n        assertEquals(\"java.lang.Object\", ref.getParamTypes().get(0).describe());\n    }\n\n    private <PS extends Node> PS parse(String code, ParseStart<PS> parseStart) {\n        ParserConfiguration parserConfiguration = new ParserConfiguration();\n        parserConfiguration.setLanguageLevel(ParserConfiguration.LanguageLevel.JAVA_10);\n        ParseResult<PS> parseResult = new JavaParser(parserConfiguration).parse(parseStart, new StringProvider(code));\n        if (!parseResult.isSuccessful()) {\n            parseResult.getProblems().forEach(p -> System.out.println(\"ERR: \" + p));\n        }\n        assertTrue(parseResult.isSuccessful());\n        PS root = parseResult.getResult().get();\n        return root;\n    }\n\n    @Test\n    void localVariableDeclarationInScope() {\n        String name = \"a\";\n        CompilationUnit cu = parse(\"class A { void foo() {\\n\" +\n                \"SomeClass a; a.aField;\" + \"\\n\" +\n                \"} }\", ParseStart.COMPILATION_UNIT);\n\n        // The block statement expose to the 2nd statement the local var\n        BlockStmt blockStmt = cu.findAll(BlockStmt.class).get(0);\n        Context context1 = JavaParserFactory.getContext(blockStmt, typeSolver);\n        assertEquals(1, context1.localVariablesExposedToChild(blockStmt.getStatement(1)).size());\n\n        Node nameNode = cu.findAll(NameExpr.class).get(0);\n        Context context = JavaParserFactory.getContext(nameNode, typeSolver);\n        assertTrue(context.localVariableDeclarationInScope(name).isPresent());\n    }\n\n    //\n    // Testing JLS 6.3 Scope of a Declaration\n    //\n\n    // The scope of a formal parameter of a method (\u00a78.4.1), constructor (\u00a78.8.1), or lambda expression (\u00a715.27) is the\n    // entire body of the method, constructor, or lambda expression.\n\n    private void assertNoParamsExposedToChildInContextNamed(Node parent, Node child, String paramName) {\n        assertNumberOfParamsExposedToChildInContextNamed(parent, child, paramName, 0, \"the element is exposed and it should not\");\n    }\n\n    private void assertOneParamExposedToChildInContextNamed(Node parent, Node child, String paramName) {\n        assertNumberOfParamsExposedToChildInContextNamed(parent, child, paramName, 1, \"the element is not exposed as expected\");\n    }\n\n    private void assertNumberOfParamsExposedToChildInContextNamed(Node parent, Node child, String paramName,\n                                                                  int expectedNumber, String message) {\n        assertEquals(expectedNumber, JavaParserFactory.getContext(parent, typeSolver)\n                .parametersExposedToChild(child).stream().filter(p -> p.getNameAsString().equals(paramName)).count(), message);\n    }\n\n    private void assertNoVarsExposedToChildInContextNamed(Node parent, Node child, String paramName) {\n        assertNumberOfVarsExposedToChildInContextNamed(parent, child, paramName, 0, \"the element is exposed and it should not\");\n    }\n\n    private void assertOneVarExposedToChildInContextNamed(Node parent, Node child, String paramName) {\n        assertNumberOfVarsExposedToChildInContextNamed(parent, child, paramName, 1, \"the element is not exposed as expected\");\n    }\n\n    private void assertNumberOfVarsExposedToChildInContextNamed(Node parent, Node child, String paramName,\n                                                                  int expectedNumber, String message) {\n        List<VariableDeclarator> vars = JavaParserFactory.getContext(parent, typeSolver)\n                .localVariablesExposedToChild(child);\n        assertEquals(expectedNumber, vars.stream().filter(p -> p.getNameAsString().equals(paramName)).count(), message);\n    }\n\n    @Test\n    void parametersExposedToChildForMethod() {\n        MethodDeclaration method = parse(\"void foo(int myParam) { aCall(); }\",\n                ParseStart.CLASS_BODY).asMethodDeclaration();\n        assertOneParamExposedToChildInContextNamed(method, method.getBody().get(), \"myParam\");\n        assertNoParamsExposedToChildInContextNamed(method, method.getType(), \"myParam\");\n        assertNoParamsExposedToChildInContextNamed(method, method.getParameter(0), \"myParam\");\n    }\n\n    @Test\n    void parametersExposedToChildForConstructor() {\n        ConstructorDeclaration constructor = parse(\"Foo(int myParam) { aCall(); }\",\n                ParseStart.CLASS_BODY).asConstructorDeclaration();\n        assertOneParamExposedToChildInContextNamed(constructor, constructor.getBody(), \"myParam\");\n        assertNoParamsExposedToChildInContextNamed(constructor, constructor.getParameter(0), \"myParam\");\n    }\n\n    @Test\n    void parametersExposedToChildForLambda() {\n        LambdaExpr lambda = (LambdaExpr)parse(\"Object myLambda = (myParam) -> myParam * 2;\",\n                ParseStart.STATEMENT).asExpressionStmt().getExpression().asVariableDeclarationExpr()\n                .getVariables().get(0).getInitializer().get();\n        assertOneParamExposedToChildInContextNamed(lambda, lambda.getBody(), \"myParam\");\n        assertNoParamsExposedToChildInContextNamed(lambda, lambda.getParameter(0), \"myParam\");\n    }\n\n    // The scope of a local variable declaration in a block (\u00a714.4) is the rest of the block in which the declaration\n    // appears, starting with its own initializer and including any further declarators to the right in the local\n    // variable declaration statement.\n\n    @Test\n    void localVariablesExposedToChildWithinABlock() {\n        BlockStmt blockStmt = parse(\"{ preStatement(); int a = 1, b = 2; otherStatement(); }\",\n                ParseStart.STATEMENT).asBlockStmt();\n        assertNoVarsExposedToChildInContextNamed(blockStmt, blockStmt.getStatement(0), \"a\");\n        assertNoVarsExposedToChildInContextNamed(blockStmt, blockStmt.getStatement(0), \"b\");\n        assertOneVarExposedToChildInContextNamed(blockStmt, blockStmt.getStatement(2), \"a\");\n        assertOneVarExposedToChildInContextNamed(blockStmt, blockStmt.getStatement(2), \"b\");\n\n        VariableDeclarationExpr varDecl = blockStmt.getStatement(1).asExpressionStmt().getExpression()\n                .asVariableDeclarationExpr();\n        VariableDeclarator varA = varDecl.getVariables().get(0);\n        VariableDeclarator varB = varDecl.getVariables().get(1);\n        assertOneVarExposedToChildInContextNamed(varA,\n                varA.getInitializer().get(), \"a\");\n        assertOneVarExposedToChildInContextNamed(varDecl,\n                varB, \"a\");\n        assertNoVarsExposedToChildInContextNamed(varDecl,\n                varA, \"b\");\n    }\n\n    // The scope of a local variable declared in the ForInit part of a basic for statement (\u00a714.14.1) includes all of the following:\n    // * Its own initializer\n    // * Any further declarators to the right in the ForInit part of the for statement\n    // * The Expression and ForUpdate parts of the for statement\n    // * The contained Statement\n\n    @Test\n    void localVariablesExposedToChildWithinForStmt() {\n        ForStmt forStmt = parse(\"for (int i=0, j=1;i<10;i++) { body(); }\",\n                ParseStart.STATEMENT).asForStmt();\n        VariableDeclarationExpr initializations = forStmt.getInitialization().get(0).asVariableDeclarationExpr();\n        assertOneVarExposedToChildInContextNamed(initializations,\n                initializations.getVariable(1),\n                \"i\");\n        assertOneVarExposedToChildInContextNamed(forStmt,\n                forStmt.getCompare().get(),\n                \"i\");\n        assertOneVarExposedToChildInContextNamed(forStmt,\n                forStmt.getUpdate().get(0),\n                \"i\");\n        assertOneVarExposedToChildInContextNamed(forStmt,\n                forStmt.getBody(),\n                \"i\");\n    }\n\n    // The scope of a local variable declared in the FormalParameter part of an enhanced for statement (\u00a714.14.2) is\n    // the contained Statement.\n\n    @Test\n    void localVariablesExposedToChildWithinEnhancedForeachStmt() {\n        ForEachStmt foreachStmt = parse(\"for (int i: myList) { body(); }\",\n                ParseStart.STATEMENT).asForEachStmt();\n        assertOneVarExposedToChildInContextNamed(foreachStmt, foreachStmt.getBody(), \"i\");\n        assertNoVarsExposedToChildInContextNamed(foreachStmt, foreachStmt.getVariable(), \"i\");\n        assertNoVarsExposedToChildInContextNamed(foreachStmt, foreachStmt.getIterable(), \"i\");\n    }\n\n    // The scope of a parameter of an exception handler that is declared in a catch clause of a try statement (\u00a714.20)\n    // is the entire block associated with the catch.\n\n    @Test\n    void parametersExposedToChildWithinTryStatement() {\n        CatchClause catchClause = parse(\"try {  } catch(Exception e) { body(); }\",\n                ParseStart.STATEMENT).asTryStmt().getCatchClauses().get(0);\n        assertOneParamExposedToChildInContextNamed(catchClause, catchClause.getBody(), \"e\");\n        assertNoParamsExposedToChildInContextNamed(catchClause, catchClause.getParameter(), \"e\");\n    }\n\n    // The scope of a variable declared in the ResourceSpecification of a try-with-resources statement (\u00a714.20.3) is\n    // from the declaration rightward over the remainder of the ResourceSpecification and the entire try block\n    // associated with the try-with-resources statement.\n\n    @Test\n    void localVariablesExposedToChildWithinTryWithResourcesStatement() {\n        TryStmt stmt = parse(\"try (Object res1 = foo(); Object res2 = foo()) { body(); }\",\n                ParseStart.STATEMENT).asTryStmt();\n        assertOneVarExposedToChildInContextNamed(stmt, stmt.getResources().get(1), \"res1\");\n        assertNoVarsExposedToChildInContextNamed(stmt, stmt.getResources().get(0), \"res1\");\n        assertOneVarExposedToChildInContextNamed(stmt, stmt.getTryBlock(), \"res1\");\n    }\n\n}\n",
        "filePathAfter": "javaparser-symbol-solver-testing/src/test/java/com/github/javaparser/symbolsolver/resolution/ContextTest.java",
        "sourceCodeAfterForWhole": "/*\n * Copyright (C) 2015-2016 Federico Tomassetti\n * Copyright (C) 2017-2019 The JavaParser Team.\n *\n * This file is part of JavaParser.\n *\n * JavaParser can be used either under the terms of\n * a) the GNU Lesser General Public License as published by\n *     the Free Software Foundation, either version 3 of the License, or\n *     (at your option) any later version.\n * b) the terms of the Apache License\n *\n * You should have received a copy of both licenses in LICENCE.LGPL and\n * LICENCE.APACHE. Please refer to those files for details.\n *\n * JavaParser is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n */\n\npackage com.github.javaparser.symbolsolver.resolution;\n\nimport com.github.javaparser.JavaParser;\nimport com.github.javaparser.ParseResult;\nimport com.github.javaparser.ParseStart;\nimport com.github.javaparser.ParserConfiguration;\nimport com.github.javaparser.StaticJavaParser;\nimport com.github.javaparser.StringProvider;\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.Node;\nimport com.github.javaparser.ast.NodeList;\nimport com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;\nimport com.github.javaparser.ast.body.ConstructorDeclaration;\nimport com.github.javaparser.ast.body.MethodDeclaration;\nimport com.github.javaparser.ast.body.Parameter;\nimport com.github.javaparser.ast.body.VariableDeclarator;\nimport com.github.javaparser.ast.expr.*;\nimport com.github.javaparser.ast.stmt.*;\nimport com.github.javaparser.resolution.MethodUsage;\nimport com.github.javaparser.resolution.declarations.ResolvedClassDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedReferenceTypeDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedTypeDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedValueDeclaration;\nimport com.github.javaparser.resolution.types.ResolvedType;\nimport com.github.javaparser.symbolsolver.AbstractSymbolResolutionTest;\nimport com.github.javaparser.symbolsolver.core.resolution.Context;\nimport com.github.javaparser.symbolsolver.javaparser.Navigator;\nimport com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade;\nimport com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFactory;\nimport com.github.javaparser.symbolsolver.model.resolution.SymbolReference;\nimport com.github.javaparser.symbolsolver.model.resolution.TypeSolver;\nimport com.github.javaparser.symbolsolver.reflectionmodel.ReflectionClassDeclaration;\nimport com.github.javaparser.symbolsolver.resolution.typesolvers.CombinedTypeSolver;\nimport com.github.javaparser.symbolsolver.resolution.typesolvers.JarTypeSolver;\nimport com.github.javaparser.symbolsolver.resolution.typesolvers.JavaParserTypeSolver;\nimport com.github.javaparser.symbolsolver.resolution.typesolvers.MemoryTypeSolver;\nimport com.github.javaparser.symbolsolver.resolution.typesolvers.ReflectionTypeSolver;\nimport com.github.javaparser.symbolsolver.utils.LeanParserConfiguration;\nimport org.junit.jupiter.api.Disabled;\nimport org.junit.jupiter.api.Nested;\nimport org.junit.jupiter.api.Test;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.nio.file.Path;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Optional;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport static org.mockito.Mockito.mock;\nimport static org.mockito.Mockito.when;\n\nclass ContextTest extends AbstractSymbolResolutionTest {\n\n    private final TypeSolver typeSolver = new CombinedTypeSolver(new MemoryTypeSolver(), new ReflectionTypeSolver());\n\n    private CompilationUnit parseSample(String sampleName) {\n        InputStream is = ContextTest.class.getClassLoader().getResourceAsStream(sampleName + \".java.txt\");\n        return StaticJavaParser.parse(is);\n    }\n\n    @Test\n    void resolveDeclaredFieldReference() {\n        CompilationUnit cu = parseSample(\"ReferencesToField\");\n        ClassOrInterfaceDeclaration referencesToField = Navigator.demandClass(cu, \"ReferencesToField\");\n        MethodDeclaration method1 = Navigator.demandMethod(referencesToField, \"method1\");\n        ExpressionStmt stmt = (ExpressionStmt) method1.getBody().get().getStatements().get(0);\n        AssignExpr assignExpr = (AssignExpr) stmt.getExpression();\n\n        SymbolSolver symbolSolver = new SymbolSolver(typeSolver);\n        SymbolReference symbolReference = symbolSolver.solveSymbol(\"i\", assignExpr.getTarget());\n\n        assertTrue(symbolReference.isSolved());\n        assertEquals(\"i\", symbolReference.getCorrespondingDeclaration().getName());\n        assertTrue(symbolReference.getCorrespondingDeclaration().isField());\n    }\n\n    @Test\n    void resolveInheritedFieldReference() {\n        CompilationUnit cu = parseSample(\"ReferencesToField\");\n        ClassOrInterfaceDeclaration referencesToField = Navigator.demandClass(cu, \"ReferencesToFieldExtendingClass\");\n        MethodDeclaration method1 = Navigator.demandMethod(referencesToField, \"method2\");\n        ExpressionStmt stmt = (ExpressionStmt) method1.getBody().get().getStatements().get(0);\n        AssignExpr assignExpr = (AssignExpr) stmt.getExpression();\n\n        SymbolSolver symbolSolver = new SymbolSolver(typeSolver);\n        SymbolReference symbolReference = symbolSolver.solveSymbol(\"i\", assignExpr.getTarget());\n\n        assertTrue(symbolReference.isSolved());\n        assertEquals(\"i\", symbolReference.getCorrespondingDeclaration().getName());\n        assertTrue(symbolReference.getCorrespondingDeclaration().isField());\n    }\n\n    @Test\n    void resolveParameterReference() {\n        CompilationUnit cu = parseSample(\"ReferencesToParameter\");\n        ClassOrInterfaceDeclaration referencesToField = Navigator.demandClass(cu, \"ReferenceToParameter\");\n        MethodDeclaration method1 = Navigator.demandMethod(referencesToField, \"aMethod\");\n        NameExpr foo = Navigator.findNameExpression(method1, \"foo\").get();\n\n        SymbolSolver symbolSolver = new SymbolSolver(typeSolver);\n        SymbolReference symbolReference = symbolSolver.solveSymbol(\"foo\", foo);\n\n        assertTrue(symbolReference.isSolved());\n        assertEquals(\"foo\", symbolReference.getCorrespondingDeclaration().getName());\n        assertTrue(symbolReference.getCorrespondingDeclaration().isParameter());\n    }\n\n    @Test\n    void resolveReferenceToImportedType() {\n        CompilationUnit cu = parseSample(\"Navigator\");\n        ClassOrInterfaceDeclaration referencesToField = Navigator.demandClass(cu, \"Navigator\");\n        MethodDeclaration method = Navigator.demandMethod(referencesToField, \"findType\");\n        Parameter param = method.getParameters().get(0);\n\n        ResolvedClassDeclaration compilationUnitDecl = mock(ResolvedClassDeclaration.class);\n        when(compilationUnitDecl.getName()).thenReturn(\"CompilationUnit\");\n        when(compilationUnitDecl.getQualifiedName()).thenReturn(\"com.github.javaparser.ast.CompilationUnit\");\n        TypeSolver typeSolver = mock(TypeSolver.class);\n        when(typeSolver.getSolvedJavaLangObject()).thenReturn(new ReflectionClassDeclaration(Object.class, typeSolver));\n        when(typeSolver.getRoot()).thenReturn(typeSolver);\n        when(typeSolver.solveType(\"java.lang.Object\")).thenReturn(new ReflectionClassDeclaration(Object.class, typeSolver));\n        when(typeSolver.tryToSolveType(\"com.github.javaparser.ast.CompilationUnit\")).thenReturn(SymbolReference.solved(compilationUnitDecl));\n        SymbolSolver symbolSolver = new SymbolSolver(typeSolver);\n\n        SymbolReference<? extends ResolvedTypeDeclaration> ref = symbolSolver.solveType(\"CompilationUnit\", param);\n\n        assertTrue(ref.isSolved());\n        assertEquals(\"CompilationUnit\", ref.getCorrespondingDeclaration().getName());\n        assertEquals(\"com.github.javaparser.ast.CompilationUnit\", ref.getCorrespondingDeclaration().getQualifiedName());\n    }\n\n    @Test\n    void resolveReferenceUsingQualifiedName() {\n        CompilationUnit cu = parseSample(\"Navigator2\");\n        ClassOrInterfaceDeclaration referencesToField = Navigator.demandClass(cu, \"Navigator\");\n        MethodDeclaration method = Navigator.demandMethod(referencesToField, \"findType\");\n        Parameter param = method.getParameters().get(0);\n\n        ResolvedClassDeclaration compilationUnitDecl = mock(ResolvedClassDeclaration.class);\n        when(compilationUnitDecl.getName()).thenReturn(\"CompilationUnit\");\n        when(compilationUnitDecl.getQualifiedName()).thenReturn(\"com.github.javaparser.ast.CompilationUnit\");\n        TypeSolver typeSolver = mock(TypeSolver.class);\n        when(typeSolver.getSolvedJavaLangObject()).thenReturn(new ReflectionClassDeclaration(Object.class, typeSolver));\n        //when(typeSolver.tryToSolveType(\"java.lang.com.github.javaparser.ast.CompilationUnit\")).thenReturn(SymbolReference.unsolved(ClassDeclaration.class));\n        when(typeSolver.getRoot()).thenReturn(typeSolver);\n        when(typeSolver.solveType(\"java.lang.Object\")).thenReturn(new ReflectionClassDeclaration(Object.class, typeSolver));\n        when(typeSolver.tryToSolveType(\"com.github.javaparser.ast.CompilationUnit\")).thenReturn(SymbolReference.solved(compilationUnitDecl));\n        SymbolSolver symbolSolver = new SymbolSolver(typeSolver);\n\n        SymbolReference<? extends ResolvedTypeDeclaration> ref = symbolSolver.solveType(\"com.github.javaparser.ast.CompilationUnit\", param);\n\n        assertTrue(ref.isSolved());\n        assertEquals(\"CompilationUnit\", ref.getCorrespondingDeclaration().getName());\n        assertEquals(\"com.github.javaparser.ast.CompilationUnit\", ref.getCorrespondingDeclaration().getQualifiedName());\n    }\n\n    @Test\n    void resolveReferenceToClassesInTheSamePackage() {\n        CompilationUnit cu = parseSample(\"Navigator3\");\n        ClassOrInterfaceDeclaration referencesToField = Navigator.demandClass(cu, \"Navigator\");\n        MethodDeclaration method = Navigator.demandMethod(referencesToField, \"findType\");\n        Parameter param = method.getParameters().get(0);\n\n        ResolvedClassDeclaration compilationUnitDecl = mock(ResolvedClassDeclaration.class);\n        when(compilationUnitDecl.getName()).thenReturn(\"CompilationUnit\");\n        when(compilationUnitDecl.getQualifiedName()).thenReturn(\"my.packagez.CompilationUnit\");\n        TypeSolver typeSolver = mock(TypeSolver.class);\n        when(typeSolver.getSolvedJavaLangObject()).thenReturn(new ReflectionClassDeclaration(Object.class, typeSolver));\n        when(typeSolver.getRoot()).thenReturn(typeSolver);\n        when(typeSolver.solveType(\"java.lang.Object\")).thenReturn(new ReflectionClassDeclaration(Object.class, typeSolver));\n        when(typeSolver.tryToSolveType(\"my.packagez.CompilationUnit\")).thenReturn(SymbolReference.solved(compilationUnitDecl));\n        SymbolSolver symbolSolver = new SymbolSolver(typeSolver);\n\n        SymbolReference<? extends ResolvedTypeDeclaration> ref = symbolSolver.solveType(\"CompilationUnit\", param);\n\n        assertTrue(ref.isSolved());\n        assertEquals(\"CompilationUnit\", ref.getCorrespondingDeclaration().getName());\n        assertEquals(\"my.packagez.CompilationUnit\", ref.getCorrespondingDeclaration().getQualifiedName());\n    }\n\n    @Test\n    void resolveReferenceToClassInJavaLang() {\n        CompilationUnit cu = parseSample(\"Navigator\");\n        ClassOrInterfaceDeclaration referencesToField = Navigator.demandClass(cu, \"Navigator\");\n        MethodDeclaration method = Navigator.demandMethod(referencesToField, \"findType\");\n        Parameter param = method.getParameters().get(1);\n\n        ResolvedClassDeclaration stringDecl = mock(ResolvedClassDeclaration.class);\n        when(stringDecl.getName()).thenReturn(\"String\");\n        when(stringDecl.getQualifiedName()).thenReturn(\"java.lang.String\");\n        TypeSolver typeSolver = mock(TypeSolver.class);\n        when(typeSolver.getSolvedJavaLangObject()).thenReturn(new ReflectionClassDeclaration(Object.class, typeSolver));\n        when(typeSolver.tryToSolveType(\"me.tomassetti.symbolsolver.javaparser.String\")).thenReturn(SymbolReference.unsolved(ResolvedReferenceTypeDeclaration.class));\n        when(typeSolver.getRoot()).thenReturn(typeSolver);\n        when(typeSolver.solveType(\"java.lang.Object\")).thenReturn(new ReflectionClassDeclaration(Object.class, typeSolver));\n        when(typeSolver.tryToSolveType(\"java.lang.String\")).thenReturn(SymbolReference.solved(stringDecl));\n        SymbolSolver symbolSolver = new SymbolSolver(typeSolver);\n\n        SymbolReference<? extends ResolvedTypeDeclaration> ref = symbolSolver.solveType(\"String\", param);\n\n        assertTrue(ref.isSolved());\n        assertEquals(\"String\", ref.getCorrespondingDeclaration().getName());\n        assertEquals(\"java.lang.String\", ref.getCorrespondingDeclaration().getQualifiedName());\n    }\n\n    @Test\n    void resolveReferenceToMethod() throws IOException {\n        CompilationUnit cu = parseSample(\"Navigator\");\n        ClassOrInterfaceDeclaration referencesToField = Navigator.demandClass(cu, \"Navigator\");\n        MethodDeclaration method = Navigator.demandMethod(referencesToField, \"findType\");\n        MethodCallExpr callToGetTypes = Navigator.findMethodCall(method, \"getTypes\").get();\n\n        Path pathToJar = adaptPath(\"src/test/resources/javaparser-core-2.1.0.jar\");\n        TypeSolver typeSolver = new CombinedTypeSolver(new JarTypeSolver(pathToJar), new ReflectionTypeSolver(true));\n        SymbolSolver symbolSolver = new SymbolSolver(typeSolver);\n\n        MethodUsage ref = symbolSolver.solveMethod(\"getTypes\", Collections.emptyList(), callToGetTypes);\n\n        assertEquals(\"getTypes\", ref.getName());\n        assertEquals(\"com.github.javaparser.ast.CompilationUnit\", ref.declaringType().getQualifiedName());\n\n        //verify(typeSolver);\n    }\n\n    @Test\n    void resolveCascadeOfReferencesToMethod() throws IOException {\n        CompilationUnit cu = parseSample(\"Navigator\");\n        ClassOrInterfaceDeclaration referencesToField = Navigator.demandClass(cu, \"Navigator\");\n        MethodDeclaration method = Navigator.demandMethod(referencesToField, \"findType\");\n        MethodCallExpr callToStream = Navigator.findMethodCall(method, \"stream\").get();\n\n        Path pathToJar = adaptPath(\"src/test/resources/javaparser-core-2.1.0.jar\");\n        TypeSolver typeSolver = new CombinedTypeSolver(new JarTypeSolver(pathToJar), new ReflectionTypeSolver(true));\n        SymbolSolver symbolSolver = new SymbolSolver(typeSolver);\n        MethodUsage ref = symbolSolver.solveMethod(\"stream\", Collections.emptyList(), callToStream);\n\n        assertEquals(\"stream\", ref.getName());\n        assertEquals(\"java.util.Collection\", ref.declaringType().getQualifiedName());\n    }\n\n    @Test\n    void resolveReferenceToMethodCalledOnArrayAccess() {\n        CompilationUnit cu = parseSample(\"ArrayAccess\");\n        ClassOrInterfaceDeclaration clazz = Navigator.demandClass(cu, \"ArrayAccess\");\n        MethodDeclaration method = Navigator.demandMethod(clazz, \"access\");\n        MethodCallExpr callToTrim = Navigator.findMethodCall(method, \"trim\").get();\n\n        Path src = adaptPath(\"src/test/resources\");\n        TypeSolver typeSolver = new CombinedTypeSolver(new ReflectionTypeSolver(), new JavaParserTypeSolver(src, new LeanParserConfiguration()));\n        SymbolSolver symbolSolver = new SymbolSolver(typeSolver);\n        MethodUsage ref = symbolSolver.solveMethod(\"trim\", Collections.emptyList(), callToTrim);\n\n        assertEquals(\"trim\", ref.getName());\n        assertEquals(\"java.lang.String\", ref.declaringType().getQualifiedName());\n    }\n\n    @Test\n    void resolveReferenceToJreType() {\n        CompilationUnit cu = parseSample(\"NavigatorSimplified\");\n        ClassOrInterfaceDeclaration clazz = Navigator.demandClass(cu, \"Navigator\");\n        MethodDeclaration method = Navigator.demandMethod(clazz, \"foo\");\n        com.github.javaparser.ast.type.Type streamJavaParserType = method.getParameters().get(0).getType();\n\n        TypeSolver typeSolver = new ReflectionTypeSolver();\n        ResolvedType streamType = JavaParserFacade.get(typeSolver).convert(streamJavaParserType, method);\n\n        assertEquals(\"java.util.stream.Stream<java.lang.String>\", streamType.describe());\n    }\n\n    @Test\n    void resolveReferenceToMethodWithLambda() {\n        CompilationUnit cu = parseSample(\"NavigatorSimplified\");\n        ClassOrInterfaceDeclaration clazz = Navigator.demandClass(cu, \"Navigator\");\n        MethodDeclaration method = Navigator.demandMethod(clazz, \"findType\");\n        MethodCallExpr methodCallExpr = Navigator.findMethodCall(method, \"filter\").get();\n\n        TypeSolver typeSolver = new ReflectionTypeSolver();\n        ResolvedType ref = JavaParserFacade.get(typeSolver).getType(methodCallExpr);\n\n        assertEquals(\"java.util.stream.Stream<java.lang.String>\", ref.describe());\n        assertEquals(1, ref.asReferenceType().typeParametersValues().size());\n        assertEquals(\"java.lang.String\", ref.asReferenceType().typeParametersValues().get(0).describe());\n    }\n\n    @Test\n    void resolveReferenceToLambdaParamBase() {\n        CompilationUnit cu = parseSample(\"NavigatorSimplified\");\n        ClassOrInterfaceDeclaration clazz = Navigator.demandClass(cu, \"Navigator\");\n        MethodDeclaration method = Navigator.demandMethod(clazz, \"findType\");\n        NameExpr refToT = Navigator.findNameExpression(method, \"t\").get();\n\n        TypeSolver typeSolver = new ReflectionTypeSolver();\n        JavaParserFacade javaParserFacade = JavaParserFacade.get(typeSolver);\n        ResolvedType ref = javaParserFacade.getType(refToT);\n\n        assertEquals(\"? super java.lang.String\", ref.describe());\n    }\n\n    @Test\n    void resolveReferenceToLambdaParamSimplified() {\n        CompilationUnit cu = parseSample(\"NavigatorSimplified\");\n        ClassOrInterfaceDeclaration clazz = Navigator.demandClass(cu, \"Navigator\");\n        MethodDeclaration method = Navigator.demandMethod(clazz, \"findType\");\n        MethodCallExpr call = Navigator.findMethodCall(method, \"isEmpty\").get();\n\n        TypeSolver typeSolver = new ReflectionTypeSolver();\n        SymbolSolver symbolSolver = new SymbolSolver(typeSolver);\n        MethodUsage ref = symbolSolver.solveMethod(\"isEmpty\", Collections.emptyList(), call);\n\n        assertEquals(\"isEmpty\", ref.getName());\n        assertEquals(\"java.lang.String\", ref.declaringType().getQualifiedName());\n    }\n\n    @Test\n    void resolveGenericReturnTypeOfMethodInJar() throws IOException {\n        CompilationUnit cu = parseSample(\"Navigator\");\n        ClassOrInterfaceDeclaration clazz = Navigator.demandClass(cu, \"Navigator\");\n        MethodDeclaration method = Navigator.demandMethod(clazz, \"findType\");\n        MethodCallExpr call = Navigator.findMethodCall(method, \"getTypes\").get();\n\n        Path pathToJar = adaptPath(\"src/test/resources/javaparser-core-2.1.0.jar\");\n        TypeSolver typeSolver = new CombinedTypeSolver(new ReflectionTypeSolver(), new JarTypeSolver(pathToJar));\n        MethodUsage methodUsage = JavaParserFacade.get(typeSolver).solveMethodAsUsage(call);\n\n        assertEquals(\"getTypes\", methodUsage.getName());\n        assertEquals(\"java.util.List<com.github.javaparser.ast.body.TypeDeclaration>\", methodUsage.returnType().describe());\n        assertEquals(1, methodUsage.returnType().asReferenceType().typeParametersValues().size());\n        assertEquals(\"com.github.javaparser.ast.body.TypeDeclaration\", methodUsage.returnType().asReferenceType().typeParametersValues().get(0).describe());\n    }\n\n    @Test\n    void resolveCompoundGenericReturnTypeOfMethodInJar() throws IOException {\n        CompilationUnit cu = parseSample(\"GenericClassNavigator\");\n        ClassOrInterfaceDeclaration clazz = Navigator.demandClass(cu, \"GenericClassNavigator\");\n        MethodDeclaration method = Navigator.demandMethod(clazz, \"doubleTyped\");\n        MethodCallExpr call = Navigator.findMethodCall(method, \"genericMethodWithDoubleTypedReturnType\").get();\n\n        Path pathToJar = adaptPath(\"src/test/resources/javassist_generics/generics.jar\");\n        TypeSolver typeSolver = new CombinedTypeSolver(new ReflectionTypeSolver(), new JarTypeSolver(pathToJar));\n        MethodUsage methodUsage = JavaParserFacade.get(typeSolver).solveMethodAsUsage(call);\n\n        assertEquals(\"genericMethodWithDoubleTypedReturnType\", methodUsage.getName());\n        assertEquals(\"java.util.Map<T, V>\", methodUsage.returnType().describe());\n    }\n\n    @Test\n    void resolveNestedGenericReturnTypeOfMethodInJar() throws IOException {\n        CompilationUnit cu = parseSample(\"GenericClassNavigator\");\n        ClassOrInterfaceDeclaration clazz = Navigator.demandClass(cu, \"GenericClassNavigator\");\n        MethodDeclaration method = Navigator.demandMethod(clazz, \"nestedTyped\");\n        MethodCallExpr call = Navigator.findMethodCall(method, \"genericMethodWithNestedReturnType\").get();\n\n        Path pathToJar = adaptPath(\"src/test/resources/javassist_generics/generics.jar\");\n        TypeSolver typeSolver = new CombinedTypeSolver(new ReflectionTypeSolver(), new JarTypeSolver(pathToJar));\n        MethodUsage methodUsage = JavaParserFacade.get(typeSolver).solveMethodAsUsage(call);\n\n        assertEquals(\"genericMethodWithNestedReturnType\", methodUsage.getName());\n        assertEquals(\"java.util.List<java.util.List<T>>\", methodUsage.returnType().describe());\n    }\n\n    @Test\n    void resolveSimpleGenericReturnTypeOfMethodInJar() throws IOException {\n        CompilationUnit cu = parseSample(\"GenericClassNavigator\");\n        ClassOrInterfaceDeclaration clazz = Navigator.demandClass(cu, \"GenericClassNavigator\");\n        MethodDeclaration method = Navigator.demandMethod(clazz, \"simple\");\n        MethodCallExpr call = Navigator.findMethodCall(method, \"get\").get();\n\n        Path pathToJar = adaptPath(\"src/test/resources/javassist_generics/generics.jar\");\n        TypeSolver typeSolver = new CombinedTypeSolver(new ReflectionTypeSolver(), new JarTypeSolver(pathToJar));\n        MethodUsage methodUsage = JavaParserFacade.get(typeSolver).solveMethodAsUsage(call);\n\n        assertEquals(\"get\", methodUsage.getName());\n        assertEquals(\"java.util.List<java.util.List<java.lang.String>>\", methodUsage.returnType().describe());\n    }\n\n    @Test\n    void resolveGenericReturnTypeFromInputParam() throws IOException {\n        CompilationUnit cu = parseSample(\"GenericClassNavigator\");\n        ClassOrInterfaceDeclaration clazz = Navigator.demandClass(cu, \"GenericClassNavigator\");\n        MethodDeclaration method = Navigator.demandMethod(clazz, \"input\");\n        MethodCallExpr call = Navigator.findMethodCall(method, \"copy\").get();\n\n        Path pathToJar = adaptPath(\"src/test/resources/javassist_generics/generics.jar\");\n        TypeSolver typeSolver = new CombinedTypeSolver(new ReflectionTypeSolver(), new JarTypeSolver(pathToJar));\n        MethodUsage methodUsage = JavaParserFacade.get(typeSolver).solveMethodAsUsage(call);\n\n        assertEquals(\"copy\", methodUsage.getName());\n        assertEquals(\"javaparser.GenericClass<java.util.List<java.lang.String>>\", methodUsage.returnType().describe());\n    }\n\n    @Test\n    void resolveComplexGenericReturnType() throws IOException {\n        CompilationUnit cu = parseSample(\"GenericClassNavigator\");\n        ClassOrInterfaceDeclaration clazz = Navigator.demandClass(cu, \"GenericClassNavigator\");\n        MethodDeclaration method = Navigator.demandMethod(clazz, \"complex\");\n        MethodCallExpr call = Navigator.findMethodCall(method, \"complexGenerics\").get();\n\n        Path pathToJar = adaptPath(\"src/test/resources/javassist_generics/generics.jar\");\n        TypeSolver typeSolver = new CombinedTypeSolver(new ReflectionTypeSolver(), new JarTypeSolver(pathToJar));\n        MethodUsage methodUsage = JavaParserFacade.get(typeSolver).solveMethodAsUsage(call);\n\n        assertEquals(\"complexGenerics\", methodUsage.getName());\n        assertEquals(\"T\", methodUsage.returnType().describe());\n    }\n\n    @Test\n    void resolveDoubleNestedClassType() throws IOException {\n        CompilationUnit cu = parseSample(\"GenericClassNavigator\");\n        ClassOrInterfaceDeclaration clazz = Navigator.demandClass(cu, \"GenericClassNavigator\");\n        MethodDeclaration method = Navigator.demandMethod(clazz, \"nestedTypes\");\n        MethodCallExpr call = Navigator.findMethodCall(method, \"asList\").get();\n\n        Path pathToJar = adaptPath(\"src/test/resources/javassist_generics/generics.jar\");\n        TypeSolver typeSolver = new CombinedTypeSolver(new ReflectionTypeSolver(), new JarTypeSolver(pathToJar));\n        MethodUsage methodUsage = JavaParserFacade.get(typeSolver).solveMethodAsUsage(call);\n\n        assertEquals(\"asList\", methodUsage.getName());\n        assertEquals(\"java.util.List<javaparser.GenericClass.Bar.NestedBar>\", methodUsage.getParamType(0).describe());\n    }\n\n    @Test\n    void resolveTypeUsageOfFirstMethodInGenericClass() throws IOException {\n        CompilationUnit cu = parseSample(\"Navigator\");\n        ClassOrInterfaceDeclaration clazz = Navigator.demandClass(cu, \"Navigator\");\n        MethodDeclaration method = Navigator.demandMethod(clazz, \"findType\");\n        MethodCallExpr callToGetTypes = Navigator.findMethodCall(method, \"getTypes\").get();\n\n        Path pathToJar = adaptPath(\"src/test/resources/javaparser-core-2.1.0.jar\");\n        TypeSolver typeSolver = new CombinedTypeSolver(new ReflectionTypeSolver(), new JarTypeSolver(pathToJar));\n        MethodUsage filterUsage = JavaParserFacade.get(typeSolver).solveMethodAsUsage(callToGetTypes);\n\n        assertEquals(\"java.util.List<com.github.javaparser.ast.body.TypeDeclaration>\", filterUsage.returnType().describe());\n        assertEquals(1, filterUsage.returnType().asReferenceType().typeParametersValues().size());\n        assertEquals(\"com.github.javaparser.ast.body.TypeDeclaration\", filterUsage.returnType().asReferenceType().typeParametersValues().get(0).describe());\n    }\n\n    @Test\n    void resolveTypeUsageOfMethodInGenericClass() throws IOException {\n        CompilationUnit cu = parseSample(\"Navigator\");\n        ClassOrInterfaceDeclaration clazz = Navigator.demandClass(cu, \"Navigator\");\n        MethodDeclaration method = Navigator.demandMethod(clazz, \"findType\");\n        MethodCallExpr callToStream = Navigator.findMethodCall(method, \"stream\").get();\n\n        Path pathToJar = adaptPath(\"src/test/resources/javaparser-core-2.1.0.jar\");\n        TypeSolver typeSolver = new CombinedTypeSolver(new ReflectionTypeSolver(), new JarTypeSolver(pathToJar));\n        MethodUsage filterUsage = JavaParserFacade.get(typeSolver).solveMethodAsUsage(callToStream);\n\n        assertEquals(\"java.util.stream.Stream<com.github.javaparser.ast.body.TypeDeclaration>\", filterUsage.returnType().describe());\n    }\n\n    @Test\n    void resolveTypeUsageOfCascadeMethodInGenericClass() throws IOException {\n        CompilationUnit cu = parseSample(\"Navigator\");\n        ClassOrInterfaceDeclaration clazz = Navigator.demandClass(cu, \"Navigator\");\n        MethodDeclaration method = Navigator.demandMethod(clazz, \"findType\");\n        MethodCallExpr callToFilter = Navigator.findMethodCall(method, \"filter\").get();\n\n        Path pathToJar = adaptPath(\"src/test/resources/javaparser-core-2.1.0.jar\");\n        TypeSolver typeSolver = new CombinedTypeSolver(new ReflectionTypeSolver(), new JarTypeSolver(pathToJar));\n        MethodUsage filterUsage = JavaParserFacade.get(typeSolver).solveMethodAsUsage(callToFilter);\n\n        assertEquals(\"java.util.stream.Stream<com.github.javaparser.ast.body.TypeDeclaration>\", filterUsage.returnType().describe());\n    }\n\n    @Test\n    void resolveLambdaType() throws IOException {\n        CompilationUnit cu = parseSample(\"Navigator\");\n        ClassOrInterfaceDeclaration clazz = Navigator.demandClass(cu, \"Navigator\");\n        MethodDeclaration method = Navigator.demandMethod(clazz, \"findType\");\n        MethodCallExpr callToFilter = Navigator.findMethodCall(method, \"filter\").get();\n        Expression lambdaExpr = callToFilter.getArguments().get(0);\n\n        Path pathToJar = adaptPath(\"src/test/resources/javaparser-core-2.1.0.jar\");\n        TypeSolver typeSolver = new CombinedTypeSolver(new ReflectionTypeSolver(), new JarTypeSolver(pathToJar));\n        ResolvedType typeOfLambdaExpr = JavaParserFacade.get(typeSolver).getType(lambdaExpr);\n\n        assertEquals(\"java.util.function.Predicate<? super com.github.javaparser.ast.body.TypeDeclaration>\", typeOfLambdaExpr.describe());\n    }\n\n    @Test\n    void resolveReferenceToLambdaParam() throws IOException {\n        CompilationUnit cu = parseSample(\"Navigator\");\n        ClassOrInterfaceDeclaration clazz = Navigator.demandClass(cu, \"Navigator\");\n        MethodDeclaration method = Navigator.demandMethod(clazz, \"findType\");\n        MethodCallExpr callToGetName = Navigator.findMethodCall(method, \"getName\").get();\n        Expression referenceToT = callToGetName.getScope().get();\n\n        Path pathToJar = adaptPath(\"src/test/resources/javaparser-core-2.1.0.jar\");\n        TypeSolver typeSolver = new CombinedTypeSolver(new ReflectionTypeSolver(), new JarTypeSolver(pathToJar));\n        ResolvedType typeOfT = JavaParserFacade.get(typeSolver).getType(referenceToT);\n\n        assertEquals(\"? super com.github.javaparser.ast.body.TypeDeclaration\", typeOfT.describe());\n    }\n\n    @Test\n    void resolveReferenceToCallOnLambdaParam() throws IOException {\n        CompilationUnit cu = parseSample(\"Navigator\");\n        ClassOrInterfaceDeclaration clazz = Navigator.demandClass(cu, \"Navigator\");\n        MethodDeclaration method = Navigator.demandMethod(clazz, \"findType\");\n        MethodCallExpr callToGetName = Navigator.findMethodCall(method, \"getName\").get();\n\n        Path pathToJar = adaptPath(\"src/test/resources/javaparser-core-2.1.0.jar\");\n        TypeSolver typeSolver = new CombinedTypeSolver(new ReflectionTypeSolver(), new JarTypeSolver(pathToJar));\n        MethodUsage methodUsage = JavaParserFacade.get(typeSolver).solveMethodAsUsage(callToGetName);\n\n        assertEquals(\"getName\", methodUsage.getName());\n        assertEquals(\"com.github.javaparser.ast.body.TypeDeclaration\", methodUsage.declaringType().getQualifiedName());\n    }\n\n    @Test\n    void resolveReferenceToOverloadMethodWithNullParam() {\n        CompilationUnit cu = parseSample(\"OverloadedMethods\");\n        ClassOrInterfaceDeclaration clazz = Navigator.demandClass(cu, \"OverloadedMethods\");\n        MethodDeclaration method = Navigator.demandMethod(clazz, \"m1\");\n        MethodCallExpr call = Navigator.findMethodCall(method, \"overloaded\").get();\n\n        ReflectionTypeSolver typeSolver = new ReflectionTypeSolver();\n        MethodUsage ref = JavaParserFacade.get(typeSolver).solveMethodAsUsage(call);\n\n        assertEquals(\"overloaded\", ref.getName());\n        assertEquals(1, ref.getNoParams());\n        assertEquals(\"java.lang.String\", ref.getParamTypes().get(0).describe());\n    }\n\n    @Test\n    void resolveReferenceToOverloadMethodFindStricter() {\n        CompilationUnit cu = parseSample(\"OverloadedMethods\");\n        ClassOrInterfaceDeclaration clazz = Navigator.demandClass(cu, \"OverloadedMethods\");\n        MethodDeclaration method = Navigator.demandMethod(clazz, \"m2\");\n        MethodCallExpr call = Navigator.findMethodCall(method, \"overloaded\").get();\n\n        ReflectionTypeSolver typeSolver = new ReflectionTypeSolver();\n        MethodUsage ref = JavaParserFacade.get(typeSolver).solveMethodAsUsage(call);\n\n        assertEquals(\"overloaded\", ref.getName());\n        assertEquals(1, ref.getNoParams());\n        assertEquals(\"java.lang.String\", ref.getParamTypes().get(0).describe());\n    }\n\n    @Test\n    void resolveReferenceToMethodWithGenericArrayTypeParam() {\n        CompilationUnit cu = parseSample(\"GenericArrayMethodArgument\");\n        ClassOrInterfaceDeclaration clazz = Navigator.demandClass(cu, \"GenericArrayMethodArgument\");\n        MethodDeclaration method = Navigator.demandMethod(clazz, \"bar\");\n        MethodCallExpr call = Navigator.findMethodCall(method, \"foo\").get();\n\n        TypeSolver typeSolver = new ReflectionTypeSolver();\n        MethodUsage ref = JavaParserFacade.get(typeSolver).solveMethodAsUsage(call);\n\n        assertEquals(\"foo\", ref.getName());\n        assertEquals(1, ref.getNoParams());\n        assertEquals(\"java.lang.String[]\", ref.getParamType(0).describe());\n    }\n\n    @Test\n    void resolveInheritedMethodFromInterface() {\n        CompilationUnit cu = parseSample(\"InterfaceInheritance\");\n        ClassOrInterfaceDeclaration clazz = Navigator.demandClass(cu, \"Test\");\n        MethodDeclaration method = Navigator.demandMethod(clazz, \"test\");\n        MethodCallExpr call = Navigator.findMethodCall(method, \"foobar\").get();\n\n        Path src = adaptPath(\"src/test/resources\");\n        TypeSolver typeSolver = new CombinedTypeSolver(new ReflectionTypeSolver(), new JavaParserTypeSolver(src));\n        ResolvedType type = JavaParserFacade.get(typeSolver).getType(call);\n\n        assertEquals(\"double\", type.describe());\n    }\n\n    @Test\n    void resolveReferenceToOverloadMethodFindOnlyCompatible() {\n        CompilationUnit cu = parseSample(\"OverloadedMethods\");\n        ClassOrInterfaceDeclaration clazz = Navigator.demandClass(cu, \"OverloadedMethods\");\n        MethodDeclaration method = Navigator.demandMethod(clazz, \"m3\");\n        MethodCallExpr call = Navigator.findMethodCall(method, \"overloaded\").get();\n\n        ReflectionTypeSolver typeSolver = new ReflectionTypeSolver();\n        MethodUsage ref = JavaParserFacade.get(typeSolver).solveMethodAsUsage(call);\n\n        assertEquals(\"overloaded\", ref.getName());\n        assertEquals(1, ref.getNoParams());\n        assertEquals(\"java.lang.Object\", ref.getParamTypes().get(0).describe());\n    }\n\n    private <PS extends Node> PS parse(String code, ParseStart<PS> parseStart) {\n        return parse(ParserConfiguration.LanguageLevel.JAVA_10, code, parseStart);\n    }\n\n    private <PS extends Node> PS parse(ParserConfiguration.LanguageLevel languageLevel, String code, ParseStart<PS> parseStart) {\n        ParserConfiguration parserConfiguration = new ParserConfiguration();\n        parserConfiguration.setLanguageLevel(languageLevel);\n        ParseResult<PS> parseResult = new JavaParser(parserConfiguration).parse(parseStart, new StringProvider(code));\n        if (!parseResult.isSuccessful()) {\n            parseResult.getProblems().forEach(p -> System.out.println(\"ERR: \" + p));\n        }\n        assertTrue(parseResult.isSuccessful());\n        PS root = parseResult.getResult().get();\n        return root;\n    }\n\n    @Test\n    void localVariableDeclarationInScope() {\n        String name = \"a\";\n        CompilationUnit cu = parse(\"class A { void foo() {\\n\" +\n                \"SomeClass a; a.aField;\" + \"\\n\" +\n                \"} }\", ParseStart.COMPILATION_UNIT);\n\n        // The block statement expose to the 2nd statement the local var\n        BlockStmt blockStmt = cu.findAll(BlockStmt.class).get(0);\n        Context context1 = JavaParserFactory.getContext(blockStmt, typeSolver);\n        assertEquals(1, context1.localVariablesExposedToChild(blockStmt.getStatement(1)).size());\n\n        Node nameNode = cu.findAll(NameExpr.class).get(0);\n        Context context = JavaParserFactory.getContext(nameNode, typeSolver);\n        assertTrue(context.localVariableDeclarationInScope(name).isPresent());\n    }\n\n    //\n    // Testing JLS 6.3 Scope of a Declaration\n    //\n\n    // The scope of a formal parameter of a method (\u00a78.4.1), constructor (\u00a78.8.1), or lambda expression (\u00a715.27) is the\n    // entire body of the method, constructor, or lambda expression.\n\n    private void assertNoParamsExposedToChildInContextNamed(Node parent, Node child, String paramName) {\n        assertNumberOfParamsExposedToChildInContextNamed(parent, child, paramName, 0, \"the element is exposed and it should not\");\n    }\n\n    private void assertOneParamExposedToChildInContextNamed(Node parent, Node child, String paramName) {\n        assertNumberOfParamsExposedToChildInContextNamed(parent, child, paramName, 1, \"the element is not exposed as expected\");\n    }\n\n    private void assertNumberOfParamsExposedToChildInContextNamed(Node parent, Node child, String paramName,\n                                                                  int expectedNumber, String message) {\n        assertEquals(expectedNumber, JavaParserFactory.getContext(parent, typeSolver)\n                .parametersExposedToChild(child).stream().filter(p -> p.getNameAsString().equals(paramName)).count(), \"[\" + paramName + \"]: \" + message);\n    }\n\n    private void assertNoVarsExposedToChildInContextNamed(Node parent, Node child, String paramName) {\n        assertNumberOfVarsExposedToChildInContextNamed(parent, child, paramName, 0, \"the element is exposed and it should not\");\n    }\n\n    private void assertOneVarExposedToChildInContextNamed(Node parent, Node child, String paramName) {\n        assertNumberOfVarsExposedToChildInContextNamed(parent, child, paramName, 1, \"the element is not exposed as expected\");\n    }\n\n    private void assertNumberOfVarsExposedToChildInContextNamed(Node parent, Node child, String paramName,\n                                                                  int expectedNumber, String message) {\n        List<VariableDeclarator> vars = JavaParserFactory.getContext(parent, typeSolver)\n                .localVariablesExposedToChild(child);\n        assertEquals(expectedNumber, vars.stream().filter(p -> p.getNameAsString().equals(paramName)).count(), \"[\" + paramName + \"]: \" + message);\n    }\n\n    private void assertNoPatternExprsExposedToImmediateParentInContextNamed(Node parent, String patternExprName, String message) {\n        assertNumberOfPatternExprsExposedToImmediateParentInContextNamed(parent, patternExprName, 0, message);\n    }\n    private void assertOnePatternExprsExposedToImmediateParentInContextNamed(Node parent, String patternExprName, String message) {\n        assertNumberOfPatternExprsExposedToImmediateParentInContextNamed(parent, patternExprName, 1, message);\n    }\n    private void assertNumberOfPatternExprsExposedToImmediateParentInContextNamed(Node parent, String patternExprName,\n                                                                  int expectedNumber, String message) {\n        List<PatternExpr> vars = JavaParserFactory.getContext(parent, typeSolver)\n                .patternExprsExposedFromChildren();\n        assertEquals(expectedNumber, vars.stream().filter(p -> p.getNameAsString().equals(patternExprName)).count(), \"[\" + patternExprName + \"]: \" + message);\n    }\n\n    private void assertNoNegatedPatternExprsExposedToImmediateParentInContextNamed(Node parent, String patternExprName, String message) {\n        assertNumberOfNegatedPatternExprsExposedToImmediateParentInContextNamed(parent, patternExprName, 0, message);\n    }\n    private void assertOneNegatedPatternExprsExposedToImmediateParentInContextNamed(Node parent, String patternExprName, String message) {\n        assertNumberOfNegatedPatternExprsExposedToImmediateParentInContextNamed(parent, patternExprName, 1, message);\n    }\n    private void assertNumberOfNegatedPatternExprsExposedToImmediateParentInContextNamed(Node parent, String patternExprName,\n                                                                  int expectedNumber, String message) {\n        List<PatternExpr> vars = JavaParserFactory.getContext(parent, typeSolver)\n                .negatedPatternExprsExposedFromChildren();\n        assertEquals(expectedNumber, vars.stream().filter(p -> p.getNameAsString().equals(patternExprName)).count(), \"[\" + patternExprName + \"]: \" + message);\n    }\n\n    @Test\n    void parametersExposedToChildForMethod() {\n        MethodDeclaration method = parse(\"void foo(int myParam) { aCall(); }\",\n                ParseStart.CLASS_BODY).asMethodDeclaration();\n        assertOneParamExposedToChildInContextNamed(method, method.getBody().get(), \"myParam\");\n        assertNoParamsExposedToChildInContextNamed(method, method.getType(), \"myParam\");\n        assertNoParamsExposedToChildInContextNamed(method, method.getParameter(0), \"myParam\");\n    }\n\n    @Test\n    void parametersExposedToChildForConstructor() {\n        ConstructorDeclaration constructor = parse(\"Foo(int myParam) { aCall(); }\",\n                ParseStart.CLASS_BODY).asConstructorDeclaration();\n        assertOneParamExposedToChildInContextNamed(constructor, constructor.getBody(), \"myParam\");\n        assertNoParamsExposedToChildInContextNamed(constructor, constructor.getParameter(0), \"myParam\");\n    }\n\n    @Test\n    void parametersExposedToChildForLambda() {\n        LambdaExpr lambda = (LambdaExpr) parse(\"Object myLambda = (myParam) -> myParam * 2;\",\n                ParseStart.STATEMENT).asExpressionStmt().getExpression().asVariableDeclarationExpr()\n                .getVariables().get(0).getInitializer().get();\n        assertOneParamExposedToChildInContextNamed(lambda, lambda.getBody(), \"myParam\");\n        assertNoParamsExposedToChildInContextNamed(lambda, lambda.getParameter(0), \"myParam\");\n    }\n\n    // The scope of a local variable declaration in a block (\u00a714.4) is the rest of the block in which the declaration\n    // appears, starting with its own initializer and including any further declarators to the right in the local\n    // variable declaration statement.\n\n    @Test\n    void localVariablesExposedToChildWithinABlock() {\n        BlockStmt blockStmt = parse(\"{ preStatement(); int a = 1, b = 2; otherStatement(); }\",\n                ParseStart.STATEMENT).asBlockStmt();\n        assertNoVarsExposedToChildInContextNamed(blockStmt, blockStmt.getStatement(0), \"a\");\n        assertNoVarsExposedToChildInContextNamed(blockStmt, blockStmt.getStatement(0), \"b\");\n        assertOneVarExposedToChildInContextNamed(blockStmt, blockStmt.getStatement(2), \"a\");\n        assertOneVarExposedToChildInContextNamed(blockStmt, blockStmt.getStatement(2), \"b\");\n\n        VariableDeclarationExpr varDecl = blockStmt.getStatement(1).asExpressionStmt().getExpression()\n                .asVariableDeclarationExpr();\n        VariableDeclarator varA = varDecl.getVariables().get(0);\n        VariableDeclarator varB = varDecl.getVariables().get(1);\n        assertOneVarExposedToChildInContextNamed(varA,\n                varA.getInitializer().get(), \"a\");\n        assertOneVarExposedToChildInContextNamed(varDecl,\n                varB, \"a\");\n        assertNoVarsExposedToChildInContextNamed(varDecl,\n                varA, \"b\");\n    }\n\n    // The scope of a local variable declared in the ForInit part of a basic for statement (\u00a714.14.1) includes all of the following:\n    // * Its own initializer\n    // * Any further declarators to the right in the ForInit part of the for statement\n    // * The Expression and ForUpdate parts of the for statement\n    // * The contained Statement\n\n    @Test\n    void localVariablesExposedToChildWithinForStmt() {\n        ForStmt forStmt = parse(\"for (int i=0, j=1;i<10;i++) { body(); }\",\n                ParseStart.STATEMENT).asForStmt();\n        VariableDeclarationExpr initializations = forStmt.getInitialization().get(0).asVariableDeclarationExpr();\n        assertOneVarExposedToChildInContextNamed(initializations,\n                initializations.getVariable(1),\n                \"i\");\n        assertOneVarExposedToChildInContextNamed(forStmt,\n                forStmt.getCompare().get(),\n                \"i\");\n        assertOneVarExposedToChildInContextNamed(forStmt,\n                forStmt.getUpdate().get(0),\n                \"i\");\n        assertOneVarExposedToChildInContextNamed(forStmt,\n                forStmt.getBody(),\n                \"i\");\n    }\n\n    // The scope of a local variable declared in the FormalParameter part of an enhanced for statement (\u00a714.14.2) is\n    // the contained Statement.\n\n    @Test\n    void localVariablesExposedToChildWithinEnhancedForeachStmt() {\n        ForEachStmt foreachStmt = parse(\"for (int i: myList) { body(); }\",\n                ParseStart.STATEMENT).asForEachStmt();\n        assertOneVarExposedToChildInContextNamed(foreachStmt, foreachStmt.getBody(), \"i\");\n        assertNoVarsExposedToChildInContextNamed(foreachStmt, foreachStmt.getVariable(), \"i\");\n        assertNoVarsExposedToChildInContextNamed(foreachStmt, foreachStmt.getIterable(), \"i\");\n    }\n\n    // The scope of a parameter of an exception handler that is declared in a catch clause of a try statement (\u00a714.20)\n    // is the entire block associated with the catch.\n\n    @Test\n    void parametersExposedToChildWithinTryStatement() {\n        CatchClause catchClause = parse(\"try {  } catch(Exception e) { body(); }\",\n                ParseStart.STATEMENT).asTryStmt().getCatchClauses().get(0);\n        assertOneParamExposedToChildInContextNamed(catchClause, catchClause.getBody(), \"e\");\n        assertNoParamsExposedToChildInContextNamed(catchClause, catchClause.getParameter(), \"e\");\n    }\n\n    // The scope of a variable declared in the ResourceSpecification of a try-with-resources statement (\u00a714.20.3) is\n    // from the declaration rightward over the remainder of the ResourceSpecification and the entire try block\n    // associated with the try-with-resources statement.\n\n    @Test\n    void localVariablesExposedToChildWithinTryWithResourcesStatement() {\n        TryStmt stmt = parse(\"try (Object res1 = foo(); Object res2 = foo()) { body(); }\",\n                ParseStart.STATEMENT).asTryStmt();\n        assertOneVarExposedToChildInContextNamed(stmt, stmt.getResources().get(1), \"res1\");\n        assertNoVarsExposedToChildInContextNamed(stmt, stmt.getResources().get(0), \"res1\");\n        assertOneVarExposedToChildInContextNamed(stmt, stmt.getTryBlock(), \"res1\");\n    }\n\n    @Nested\n    class PatternExprTests {\n        @Test\n        void instanceOfPatternExpr0() {\n            InstanceOfExpr instanceOfExpr = parse(ParserConfiguration.LanguageLevel.JAVA_14, \"a instanceof String\", ParseStart.EXPRESSION).asInstanceOfExpr();\n            String message = \"No Pattern Expr must be available from this expression.\";\n            assertNoPatternExprsExposedToImmediateParentInContextNamed(instanceOfExpr, \"\", message);\n            assertNoNegatedPatternExprsExposedToImmediateParentInContextNamed(instanceOfExpr, \"s\", message);\n        }\n\n        @Test\n        void instanceOfPatternExpr1() {\n            String message = \"Only s must be available from this expression.\";\n            InstanceOfExpr instanceOfExpr = parse(ParserConfiguration.LanguageLevel.JAVA_14, \"a instanceof String s\", ParseStart.EXPRESSION).asInstanceOfExpr();\n            assertOnePatternExprsExposedToImmediateParentInContextNamed(instanceOfExpr, \"s\", message);\n            assertNoNegatedPatternExprsExposedToImmediateParentInContextNamed(instanceOfExpr, \"s\", message);\n        }\n\n        @Test\n        void instanceOfPatternExpr2() {\n            String message = \"Only s must be available from this enclosed expression.\";\n            EnclosedExpr enclosedExpr = parse(ParserConfiguration.LanguageLevel.JAVA_14, \"(a instanceof String s)\", ParseStart.EXPRESSION).asEnclosedExpr();\n            assertOnePatternExprsExposedToImmediateParentInContextNamed(enclosedExpr, \"s\", message);\n            assertNoNegatedPatternExprsExposedToImmediateParentInContextNamed(enclosedExpr, \"s\", message);\n        }\n\n        @Test\n        void instanceOfPatternExpr3() {\n            String message = \"Only s must be available from this multiple-enclosed expression.\";\n            EnclosedExpr enclosedExpr = parse(ParserConfiguration.LanguageLevel.JAVA_14, \"(((a instanceof String s)))\", ParseStart.EXPRESSION).asEnclosedExpr();\n            assertOnePatternExprsExposedToImmediateParentInContextNamed(enclosedExpr, \"s\", message);\n            assertNoNegatedPatternExprsExposedToImmediateParentInContextNamed(enclosedExpr, \"s\", message);\n        }\n\n\n        @Nested\n        class PatternExprNegationTests {\n            @Test\n            void instanceOfPatternExpr4() {\n                String message = \"Only s (NEGATED) must be available from this expression.\";\n                UnaryExpr unaryExpr = parse(ParserConfiguration.LanguageLevel.JAVA_14, \"!(a instanceof String s)\", ParseStart.EXPRESSION).asUnaryExpr();\n                assertNoPatternExprsExposedToImmediateParentInContextNamed(unaryExpr, \"s\", message);\n                assertOneNegatedPatternExprsExposedToImmediateParentInContextNamed(unaryExpr, \"s\", message);\n            }\n\n            @Test\n            void instanceOfPatternExpr5() {\n                String message = \"Only s must be available from this double-negated expression.\";\n                UnaryExpr unaryExpr = parse(ParserConfiguration.LanguageLevel.JAVA_14, \"!!(a instanceof String s)\", ParseStart.EXPRESSION).asUnaryExpr();\n                assertOnePatternExprsExposedToImmediateParentInContextNamed(unaryExpr, \"s\", \"Double negative means that it is true - it should be available.\");\n                assertNoNegatedPatternExprsExposedToImmediateParentInContextNamed(unaryExpr, \"s\", message);\n            }\n\n            @Test\n            void instanceOfPatternExpr6() {\n                String message = \"Only s (NEGATED) must be available from this triple-negated expression.\";\n                UnaryExpr unaryExpr = parse(ParserConfiguration.LanguageLevel.JAVA_14, \"!!!(a instanceof String s)\", ParseStart.EXPRESSION).asUnaryExpr();\n                assertNoPatternExprsExposedToImmediateParentInContextNamed(unaryExpr, \"s\", message);\n                assertOneNegatedPatternExprsExposedToImmediateParentInContextNamed(unaryExpr, \"s\", message);\n            }\n\n            @Test\n            void instanceOfPatternExpr7() {\n                String message = \"Only s must be available from this quadruple-negated expression.\";\n                UnaryExpr unaryExpr = parse(ParserConfiguration.LanguageLevel.JAVA_14, \"!!!!(a instanceof String s)\", ParseStart.EXPRESSION).asUnaryExpr();\n                assertOnePatternExprsExposedToImmediateParentInContextNamed(unaryExpr, \"s\", message + \" -- \" + \"Double negative means that it is true - it should be available.\");\n            }\n        }\n\n\n        @Nested\n        class PatternExprBinaryExprTests {\n\n            @Test\n            void instanceOfPatternExprBinaryExpr1() {\n                String message = \"Only s must be available from this expression.\";\n                BinaryExpr binaryExpr = parse(ParserConfiguration.LanguageLevel.JAVA_14, \"a instanceof String s == true\", ParseStart.EXPRESSION).asBinaryExpr();\n                assertOnePatternExprsExposedToImmediateParentInContextNamed(binaryExpr, \"s\", message);\n                assertNoNegatedPatternExprsExposedToImmediateParentInContextNamed(binaryExpr, \"s\", message);\n            }\n\n            @Test\n            void instanceOfPatternExprBinaryExpr2() {\n                String message = \"Only s must be available from this expression.\";\n                BinaryExpr binaryExpr = parse(ParserConfiguration.LanguageLevel.JAVA_14, \"true == a instanceof String s\", ParseStart.EXPRESSION).asBinaryExpr();\n                assertOnePatternExprsExposedToImmediateParentInContextNamed(binaryExpr, \"s\", message);\n                assertNoNegatedPatternExprsExposedToImmediateParentInContextNamed(binaryExpr, \"s\", message);\n            }\n\n            @Test\n            void instanceOfPatternExprBinaryExpr3() {\n                String message = \"Only s (NEGATED) must be available from this expression.\";\n                BinaryExpr binaryExpr = parse(ParserConfiguration.LanguageLevel.JAVA_14, \"a instanceof String s == false\", ParseStart.EXPRESSION).asBinaryExpr();\n                assertNoPatternExprsExposedToImmediateParentInContextNamed(binaryExpr, \"s\", message);\n                assertOneNegatedPatternExprsExposedToImmediateParentInContextNamed(binaryExpr, \"s\", message);\n            }\n\n            @Test\n            void instanceOfPatternExprBinaryExpr4() {\n                String message = \"Only s (NEGATED) must be available from this expression.\";\n                BinaryExpr binaryExpr = parse(ParserConfiguration.LanguageLevel.JAVA_14, \"false == a instanceof String s\", ParseStart.EXPRESSION).asBinaryExpr();\n                assertNoPatternExprsExposedToImmediateParentInContextNamed(binaryExpr, \"s\", message);\n                assertOneNegatedPatternExprsExposedToImmediateParentInContextNamed(binaryExpr, \"s\", message);\n            }\n\n            @Test\n            void instanceOfPatternExprBinaryExpr5() {\n                String message = \"Only s (NEGATED) must be available from this expression.\";\n                BinaryExpr binaryExpr = parse(ParserConfiguration.LanguageLevel.JAVA_14, \"a instanceof String s != true\", ParseStart.EXPRESSION).asBinaryExpr();\n                assertNoPatternExprsExposedToImmediateParentInContextNamed(binaryExpr, \"s\", message);\n            }\n\n            @Test\n            void instanceOfPatternExprBinaryExpr5_negated() {\n                String message = \"Only s (NEGATED) must be available from this expression.\";\n                BinaryExpr binaryExpr = parse(ParserConfiguration.LanguageLevel.JAVA_14, \"a instanceof String s != true\", ParseStart.EXPRESSION).asBinaryExpr();\n                assertOneNegatedPatternExprsExposedToImmediateParentInContextNamed(binaryExpr, \"s\", message);\n            }\n\n            @Test\n            void instanceOfPatternExprBinaryExpr5b() {\n                String message = \"Only s (NEGATED) must be available from this expression.\";\n                EnclosedExpr enclosedExpr = parse(ParserConfiguration.LanguageLevel.JAVA_14, \"(a instanceof String s != true)\", ParseStart.EXPRESSION).asEnclosedExpr();\n                assertNoPatternExprsExposedToImmediateParentInContextNamed(enclosedExpr, \"s\", message);\n            }\n\n            @Test\n            void instanceOfPatternExprBinaryExpr5b_negated() {\n                String message = \"Only s (NEGATED) must be available from this expression.\";\n                EnclosedExpr enclosedExpr = parse(ParserConfiguration.LanguageLevel.JAVA_14, \"(a instanceof String s != true)\", ParseStart.EXPRESSION).asEnclosedExpr();\n                assertOneNegatedPatternExprsExposedToImmediateParentInContextNamed(enclosedExpr, \"s\", message);\n            }\n\n            @Test\n            void instanceOfPatternExprBinaryExpr6() {\n                String message = \"Only s (NEGATED) must be available from this expression.\";\n                BinaryExpr binaryExpr = parse(ParserConfiguration.LanguageLevel.JAVA_14, \"a instanceof String s != false\", ParseStart.EXPRESSION).asBinaryExpr();\n                assertOnePatternExprsExposedToImmediateParentInContextNamed(binaryExpr, \"s\", message);\n            }\n\n            @Test\n            void instanceOfPatternExprBinaryExpr6_negated() {\n                String message = \"Only s (NEGATED) must be available from this expression.\";\n                BinaryExpr binaryExpr = parse(ParserConfiguration.LanguageLevel.JAVA_14, \"a instanceof String s != false\", ParseStart.EXPRESSION).asBinaryExpr();\n                assertNoNegatedPatternExprsExposedToImmediateParentInContextNamed(binaryExpr, \"s\", message);\n            }\n\n            @Test\n            void instanceOfPatternExprBinaryExpr7() {\n                String message = \"Only s (NEGATED) must be available from this double-negated expression.\";\n                UnaryExpr unaryExpr = parse(ParserConfiguration.LanguageLevel.JAVA_14, \"!(a instanceof String s != true)\", ParseStart.EXPRESSION).asUnaryExpr();\n                assertOnePatternExprsExposedToImmediateParentInContextNamed(unaryExpr, \"s\", message);\n            }\n\n            @Test\n            void instanceOfPatternExprBinaryExpr7_negated() {\n                String message = \"Only s must be available from this double-negated expression.\";\n                UnaryExpr unaryExpr = parse(ParserConfiguration.LanguageLevel.JAVA_14, \"!(a instanceof String s != true)\", ParseStart.EXPRESSION).asUnaryExpr();\n                assertNoNegatedPatternExprsExposedToImmediateParentInContextNamed(unaryExpr, \"s\", message);\n            }\n\n            @Test\n            void instanceOfPatternExprBinaryExpr8() {\n                String message = \"Only s must be available from this double-negated expression.\";\n                UnaryExpr unaryExpr = parse(ParserConfiguration.LanguageLevel.JAVA_14, \"!(a instanceof String s != false)\", ParseStart.EXPRESSION).asUnaryExpr();\n                assertNoPatternExprsExposedToImmediateParentInContextNamed(unaryExpr, \"s\", message);\n            }\n\n            @Test\n            void instanceOfPatternExprBinaryExpr8_negated() {\n                String message = \"Only s must be available from this double-negated expression.\";\n                UnaryExpr unaryExpr = parse(ParserConfiguration.LanguageLevel.JAVA_14, \"!(a instanceof String s != false)\", ParseStart.EXPRESSION).asUnaryExpr();\n                assertOneNegatedPatternExprsExposedToImmediateParentInContextNamed(unaryExpr, \"s\", message);\n            }\n\n            @Test\n            void instanceOfPatternExprBinaryExpr9() {\n                String message = \"Must be no patterns available from this || expression (neither is guaranteed to be true).\";\n                BinaryExpr binaryExpr = parse(ParserConfiguration.LanguageLevel.JAVA_14, \"(a instanceof String s) || a instanceof String s2\", ParseStart.EXPRESSION).asBinaryExpr();\n                assertNoPatternExprsExposedToImmediateParentInContextNamed(binaryExpr, \"s\", message);\n                assertNoNegatedPatternExprsExposedToImmediateParentInContextNamed(binaryExpr, \"s\", message);\n            }\n\n        }\n\n\n        @Nested\n        class PatternExprVariableDeclarationTests {\n\n            @Test\n            void instanceOfPatternExprVariableDeclaration_variableDeclaration() {\n                ExpressionStmt expressionStmt = parse(ParserConfiguration.LanguageLevel.JAVA_14, \"boolean x = a instanceof String s == true;\", ParseStart.STATEMENT).asExpressionStmt();\n\n                String message = \"No pattern must be available outside of this variable declaration expression (note that the declaration expr contains many declarators).\";\n                VariableDeclarationExpr variableDeclarationExpr = expressionStmt.getExpression().asVariableDeclarationExpr();\n                assertNoPatternExprsExposedToImmediateParentInContextNamed(variableDeclarationExpr, \"s\", message);\n                assertNoNegatedPatternExprsExposedToImmediateParentInContextNamed(variableDeclarationExpr, \"s\", message);\n            }\n\n            @Test\n            void instanceOfPatternExprVariableDeclaration_variableDeclarator() {\n                ExpressionStmt expressionStmt = parse(ParserConfiguration.LanguageLevel.JAVA_14, \"boolean x = a instanceof String s == true;\", ParseStart.STATEMENT).asExpressionStmt();\n\n                String message = \"No pattern must be available outside of this variable declaration expression (note that the declaration expr contains many declarators).\";\n                VariableDeclarationExpr variableDeclarationExpr = expressionStmt.getExpression().asVariableDeclarationExpr();\n                assertNoPatternExprsExposedToImmediateParentInContextNamed(variableDeclarationExpr, \"s\", message);\n                assertNoNegatedPatternExprsExposedToImmediateParentInContextNamed(variableDeclarationExpr, \"s\", message);\n\n                NodeList<VariableDeclarator> variables = variableDeclarationExpr.getVariables();\n                assertEquals(1, variables.size(), \"Expected 1 variable -- issue with test configuration/sample?\");\n\n\n                message = \"No pattern must be available outside of this variable declarator (x).\";\n                VariableDeclarator variableDeclaratorX = variables.get(0);\n                assertNoPatternExprsExposedToImmediateParentInContextNamed(variableDeclaratorX, \"s\", message);\n                assertNoNegatedPatternExprsExposedToImmediateParentInContextNamed(variableDeclaratorX, \"s\", message);\n                assertNoPatternExprsExposedToImmediateParentInContextNamed(variableDeclaratorX, \"s2\", message);\n                assertNoNegatedPatternExprsExposedToImmediateParentInContextNamed(variableDeclaratorX, \"s2\", message);\n\n            }\n\n            @Test\n            void instanceOfPatternExprVariableDeclaration_variableDeclaratorStatements1() {\n                String x = \"\" +\n                        \"{\\n\" +\n                        \"    boolean x = a instanceof String s;\\n\" +\n                        \"    boolean result = s.contains(\\\"b\\\");\\n\" +\n                        \"}\\n\" +\n                        \"\";\n                BlockStmt blockStmt = parse(ParserConfiguration.LanguageLevel.JAVA_14, x, ParseStart.BLOCK).asBlockStmt();\n\n                NodeList<Statement> statements = blockStmt.getStatements();\n                assertEquals(2, statements.size(), \"Expected 2 statements -- issue with test configuration/sample?\");\n\n                String message = \"No pattern must be available outside of this statement.\";\n                Statement xStatement = statements.get(0);\n                assertNoPatternExprsExposedToImmediateParentInContextNamed(xStatement, \"s\", message);\n                assertNoNegatedPatternExprsExposedToImmediateParentInContextNamed(xStatement, \"s\", message);\n\n                Statement resultStatement = statements.get(1);\n                Expression expression = resultStatement.asExpressionStmt().getExpression();\n                VariableDeclarationExpr variableDeclarationExpr = expression.asVariableDeclarationExpr();\n\n                Context context = JavaParserFactory.getContext(variableDeclarationExpr, typeSolver);\n                SymbolReference<? extends ResolvedValueDeclaration> s = context.solveSymbol(\"s\");\n                assertFalse(s.isSolved(), \"s is not available -- it is not definitively true when in a separate statement.\");\n\n            }\n\n            @Test\n            void instanceOfPatternExprVariableDeclaration_variableDeclaratorStatements2() {\n                String x = \"\" +\n                        \"{\\n\" +\n                        \"    boolean x = (a instanceof String s);\\n\" +\n                        \"    boolean y = !(a instanceof String s);\\n\" +\n                        \"    boolean result = s.contains(\\\"b\\\");\\n\" +\n                        \"}\\n\" +\n                        \"\";\n                BlockStmt blockStmt = parse(ParserConfiguration.LanguageLevel.JAVA_14, x, ParseStart.BLOCK).asBlockStmt();\n\n                NodeList<Statement> statements = blockStmt.getStatements();\n                assertEquals(3, statements.size(), \"Expected 3 statements -- issue with test configuration/sample?\");\n\n                String message;\n                message = \"No pattern must be available outside of this statement (x)\";\n                Statement xStatement = statements.get(0);\n                assertNoPatternExprsExposedToImmediateParentInContextNamed(xStatement, \"s\", message);\n                assertNoNegatedPatternExprsExposedToImmediateParentInContextNamed(xStatement, \"s\", message);\n\n                message = \"No pattern must be available outside of this statement (y)\";\n                Statement yStatement = statements.get(1);\n                assertNoPatternExprsExposedToImmediateParentInContextNamed(yStatement, \"s\", message);\n                assertNoNegatedPatternExprsExposedToImmediateParentInContextNamed(yStatement, \"s\", message);\n\n                Statement resultStatement = statements.get(2);\n                Expression expression = resultStatement.asExpressionStmt().getExpression();\n                VariableDeclarationExpr variableDeclarationExpr = expression.asVariableDeclarationExpr();\n\n                Context context = JavaParserFactory.getContext(variableDeclarationExpr, typeSolver);\n                SymbolReference<? extends ResolvedValueDeclaration> s = context.solveSymbol(\"s\");\n                assertFalse(s.isSolved(), \"s is not available -- it is not definitively true when in a separate statement.\");\n            }\n\n            @Test\n            void instanceOfPatternExprVariableDeclaration_variableDeclaratorStatements3() {\n                String x = \"\" +\n                        \"{\\n\" +\n                        \"    boolean x = !(a instanceof String s);\\n\" +\n                        \"    boolean result = s.contains(\\\"b\\\");\\n\" +\n                        \"}\\n\" +\n                        \"\";\n                BlockStmt blockStmt = parse(ParserConfiguration.LanguageLevel.JAVA_14, x, ParseStart.BLOCK).asBlockStmt();\n\n                NodeList<Statement> statements = blockStmt.getStatements();\n                assertEquals(2, statements.size(), \"Expected 2 statements -- issue with test configuration/sample?\");\n\n                String message = \"No pattern must be available outside of this statement (x)\";\n                Statement xStatement = statements.get(0);\n                assertNoPatternExprsExposedToImmediateParentInContextNamed(xStatement, \"s\", message);\n                assertNoNegatedPatternExprsExposedToImmediateParentInContextNamed(xStatement, \"s\", message);\n\n                Statement resultStatement = statements.get(1);\n                Expression expression = resultStatement.asExpressionStmt().getExpression();\n                VariableDeclarationExpr variableDeclarationExpr = expression.asVariableDeclarationExpr();\n\n                Context context = JavaParserFactory.getContext(variableDeclarationExpr, typeSolver);\n                SymbolReference<? extends ResolvedValueDeclaration> s = context.solveSymbol(\"s\");\n                assertFalse(s.isSolved(), \"s is not available -- it is not definitively true when in a separate statement.\");\n\n            }\n\n        }\n\n\n        @Nested\n        class PatternExprScopeTests {\n\n            @Test\n            void instanceOfPatternExprResolution_expr1() {\n                ExpressionStmt expressionStmt = parse(ParserConfiguration.LanguageLevel.JAVA_14, \"boolean x = a instanceof String s && a instanceof String s2;\", ParseStart.STATEMENT).asExpressionStmt();\n\n                String message = \"No pattern must be available outside of this variable declaration expression (note that the declaration expr contains many declarators).\";\n                VariableDeclarationExpr variableDeclarationExpr = expressionStmt.getExpression().asVariableDeclarationExpr();\n                assertNoPatternExprsExposedToImmediateParentInContextNamed(variableDeclarationExpr, \"s\", message);\n                assertNoPatternExprsExposedToImmediateParentInContextNamed(variableDeclarationExpr, \"s2\", message);\n                assertNoNegatedPatternExprsExposedToImmediateParentInContextNamed(variableDeclarationExpr, \"s\", message);\n                assertNoNegatedPatternExprsExposedToImmediateParentInContextNamed(variableDeclarationExpr, \"s2\", message);\n\n\n                NodeList<VariableDeclarator> variables = variableDeclarationExpr.getVariables();\n                assertEquals(1, variables.size(), \"Expected 1 variable -- issue with test configuration/sample?\");\n\n                BinaryExpr binaryExpr = variables.get(0).getInitializer().get().asBinaryExpr();\n\n                message = \"Only s must be available from this declarator (left).\";\n                Expression leftBranch = binaryExpr.getLeft();\n                assertOnePatternExprsExposedToImmediateParentInContextNamed(leftBranch, \"s\", message);\n                assertNoNegatedPatternExprsExposedToImmediateParentInContextNamed(leftBranch, \"s\", message);\n                assertNoPatternExprsExposedToImmediateParentInContextNamed(leftBranch, \"s2\", message);\n                assertNoNegatedPatternExprsExposedToImmediateParentInContextNamed(leftBranch, \"s2\", message);\n\n                message = \"Only s2 must be available from this declarator (right).\";\n                Expression rightBranch = binaryExpr.getRight();\n                assertNoPatternExprsExposedToImmediateParentInContextNamed(rightBranch, \"s\", message);\n                assertNoNegatedPatternExprsExposedToImmediateParentInContextNamed(rightBranch, \"s\", message);\n                assertOnePatternExprsExposedToImmediateParentInContextNamed(rightBranch, \"s2\", message);\n                assertNoNegatedPatternExprsExposedToImmediateParentInContextNamed(rightBranch, \"s2\", message);\n            }\n\n            @Test\n            void instanceOfPatternExprResolution_expr2() {\n                ExpressionStmt expressionStmt = parse(ParserConfiguration.LanguageLevel.JAVA_14, \"boolean x = !(a instanceof String s) && a instanceof String s2;\", ParseStart.STATEMENT).asExpressionStmt();\n\n                String message = \"No pattern must be available outside of this variable declaration expression (note that the declaration expr contains many declarators).\";\n                VariableDeclarationExpr variableDeclarationExpr = expressionStmt.getExpression().asVariableDeclarationExpr();\n                assertNoPatternExprsExposedToImmediateParentInContextNamed(variableDeclarationExpr, \"s\", message);\n                assertNoPatternExprsExposedToImmediateParentInContextNamed(variableDeclarationExpr, \"s2\", message);\n                assertNoNegatedPatternExprsExposedToImmediateParentInContextNamed(variableDeclarationExpr, \"s\", message);\n                assertNoNegatedPatternExprsExposedToImmediateParentInContextNamed(variableDeclarationExpr, \"s2\", message);\n\n                // TODO: Assert pattern available from the binaryexpr\n            }\n\n            @Test\n            void instanceOfPatternExprResolution_expr3() {\n                ExpressionStmt expressionStmt = parse(ParserConfiguration.LanguageLevel.JAVA_14, \"boolean x = \\\"\\\" instanceof String s || \\\"\\\" instanceof String s2;\", ParseStart.STATEMENT).asExpressionStmt();\n\n//                String message = \"Both s and s2 must be available from this declaration expression (AND).\";\n                String message = \"No pattern must be available outside of this statement.\";\n                VariableDeclarationExpr variableDeclarationExpr = expressionStmt.getExpression().asVariableDeclarationExpr();\n                assertNoPatternExprsExposedToImmediateParentInContextNamed(variableDeclarationExpr, \"s\", message);\n                assertNoPatternExprsExposedToImmediateParentInContextNamed(variableDeclarationExpr, \"s2\", message);\n                assertNoNegatedPatternExprsExposedToImmediateParentInContextNamed(variableDeclarationExpr, \"s\", message);\n                assertNoNegatedPatternExprsExposedToImmediateParentInContextNamed(variableDeclarationExpr, \"s2\", message);\n\n                // TODO: Assert pattern available from the binaryexpr\n            }\n\n            @Test\n            void instanceOfPatternExprResolution_expr_AND1() {\n                BinaryExpr binaryExpr = parse(ParserConfiguration.LanguageLevel.JAVA_14, \"a instanceof String s && s instanceof String s2\", ParseStart.EXPRESSION).asBinaryExpr();\n\n                String message;\n\n                message = \"Only s must be available from this declarator (left).\";\n                Expression leftBranch = binaryExpr.getLeft();\n                assertOnePatternExprsExposedToImmediateParentInContextNamed(leftBranch, \"s\", message);\n                assertNoNegatedPatternExprsExposedToImmediateParentInContextNamed(leftBranch, \"s\", message);\n                assertNoPatternExprsExposedToImmediateParentInContextNamed(leftBranch, \"s2\", message);\n                assertNoNegatedPatternExprsExposedToImmediateParentInContextNamed(leftBranch, \"s2\", message);\n\n                message = \"s and s2 must be available from this declarator (right).\";\n                Expression rightBranch = binaryExpr.getRight();\n                assertNoPatternExprsExposedToImmediateParentInContextNamed(rightBranch, \"s\", message);\n                assertNoNegatedPatternExprsExposedToImmediateParentInContextNamed(rightBranch, \"s\", message);\n                assertOnePatternExprsExposedToImmediateParentInContextNamed(rightBranch, \"s2\", message);\n                assertNoNegatedPatternExprsExposedToImmediateParentInContextNamed(rightBranch, \"s2\", message);\n            }\n\n            @Test\n            void instanceOfPatternExprResolution_expr_AND_solving1() {\n                BinaryExpr binaryExpr = parse(ParserConfiguration.LanguageLevel.JAVA_14, \"a instanceof String s && s instanceof String s2\", ParseStart.EXPRESSION).asBinaryExpr();\n\n                String message;\n\n                message = \"Only s must be available on the LEFT branch of an AND.\";\n                Expression leftBranch = binaryExpr.getLeft();\n                Context leftBranchContext = JavaParserFactory.getContext(leftBranch, typeSolver);\n                SymbolReference<? extends ResolvedValueDeclaration> left_s = leftBranchContext.solveSymbol(\"s\");\n                assertTrue(left_s.isSolved());\n                Optional<PatternExpr> optionalPatternExpr = leftBranchContext.patternExprInScope(\"s\");\n                SymbolReference<? extends ResolvedValueDeclaration> left_s2 = leftBranchContext.solveSymbol(\"s2\");\n                assertFalse(left_s2.isSolved());\n\n\n                message = \"s and s2 must be available on the RIGHT branch of an AND.\";\n                Expression rightBranch = binaryExpr.getRight();\n                Context rightBranchContext = JavaParserFactory.getContext(rightBranch, typeSolver);\n                SymbolReference<? extends ResolvedValueDeclaration> right_s = rightBranchContext.solveSymbol(\"s\");\n                assertTrue(right_s.isSolved());\n                SymbolReference<? extends ResolvedValueDeclaration> right_s2 = rightBranchContext.solveSymbol(\"s2\");\n                assertTrue(right_s2.isSolved());\n            }\n\n            @Test\n            void instanceOfPatternExprResolution_expr_OR1() {\n                BinaryExpr binaryExpr = parse(ParserConfiguration.LanguageLevel.JAVA_14, \"a instanceof String s || s instanceof String s2\", ParseStart.EXPRESSION).asBinaryExpr();\n\n                String message;\n\n                message = \"Only s must be available from this declarator (left).\";\n                Expression leftBranch = binaryExpr.getLeft();\n                assertOnePatternExprsExposedToImmediateParentInContextNamed(leftBranch, \"s\", message);\n                assertNoNegatedPatternExprsExposedToImmediateParentInContextNamed(leftBranch, \"s\", message);\n                assertNoPatternExprsExposedToImmediateParentInContextNamed(leftBranch, \"s2\", message);\n                assertNoNegatedPatternExprsExposedToImmediateParentInContextNamed(leftBranch, \"s2\", message);\n\n                message = \"Only s2 must be available from this declarator (right).\";\n                Expression rightBranch = binaryExpr.getRight();\n                assertNoPatternExprsExposedToImmediateParentInContextNamed(rightBranch, \"s\", message);\n                assertNoNegatedPatternExprsExposedToImmediateParentInContextNamed(rightBranch, \"s\", message);\n                assertOnePatternExprsExposedToImmediateParentInContextNamed(rightBranch, \"s2\", message);\n                assertNoNegatedPatternExprsExposedToImmediateParentInContextNamed(rightBranch, \"s2\", message);\n            }\n\n\n            @Test\n            void instanceOfPatternExprResolution1() {\n                CompilationUnit compilationUnit = parse(ParserConfiguration.LanguageLevel.JAVA_14, \"class X { void x() { boolean foo = ((a instanceof String s) && s.length() > 0); } }\", ParseStart.COMPILATION_UNIT);\n\n                List<EnclosedExpr> enclosedExprs = compilationUnit.findAll(EnclosedExpr.class);\n                assertEquals(2, enclosedExprs.size());\n\n                EnclosedExpr enclosedExpr = enclosedExprs.get(0);\n\n                List<NameExpr> nameExprs = enclosedExpr.findAll(NameExpr.class);\n                assertEquals(2, nameExprs.size());\n\n                NameExpr nameExpr = nameExprs.get(1);\n                assertEquals(\"s\", nameExpr.getNameAsString());\n\n                Context context = JavaParserFactory.getContext(nameExpr, typeSolver);\n                SymbolReference<? extends ResolvedValueDeclaration> symbolReference = context.solveSymbol(\"s\");\n                System.out.println(\"symbolReference = \" + symbolReference);\n\n                assertTrue(symbolReference.isSolved(), \"symbol not solved\");\n                ResolvedDeclaration correspondingDeclaration = symbolReference.getCorrespondingDeclaration();\n                assertEquals(\"s\", correspondingDeclaration.getName(), \"unexpected name for the solved symbol\");\n                assertTrue(correspondingDeclaration.isPattern());\n                assertEquals(\"s\", correspondingDeclaration.asPattern().getName(), \"unexpected name for the solved pattern\");\n                assertEquals(\"java.lang.String\", correspondingDeclaration.asPattern().getType().asReferenceType().getQualifiedName(), \"unexpected type for the solved pattern\");\n\n            }\n\n            @Test\n            void instanceOfPatternExprResolution1_negated() {\n                CompilationUnit compilationUnit = parse(ParserConfiguration.LanguageLevel.JAVA_14, \"class X { void x() { boolean foo = (!(a instanceof String s) && s.length() > 0); } }\", ParseStart.COMPILATION_UNIT);\n\n                List<EnclosedExpr> enclosedExprs = compilationUnit.findAll(EnclosedExpr.class);\n                assertEquals(2, enclosedExprs.size());\n\n                EnclosedExpr enclosedExpr = enclosedExprs.get(0);\n\n                List<NameExpr> nameExprs = enclosedExpr.findAll(NameExpr.class);\n                assertEquals(2, nameExprs.size());\n\n                NameExpr nameExpr = nameExprs.get(1);\n                assertEquals(\"s\", nameExpr.getNameAsString());\n\n                Context context = JavaParserFactory.getContext(nameExpr, typeSolver);\n                SymbolReference<? extends ResolvedValueDeclaration> symbolReference = context.solveSymbol(\"s\");\n                System.out.println(\"symbolReference = \" + symbolReference);\n\n                assertFalse(symbolReference.isSolved(), \"symbol supposed to be not solved\");\n            }\n\n            @Test\n            void instanceOfPatternExprResolution2() {\n                CompilationUnit compilationUnit = parse(ParserConfiguration.LanguageLevel.JAVA_14, \"class X { void x() { boolean foo = ((a instanceof String s) || s.length() > 0); } }\", ParseStart.COMPILATION_UNIT);\n\n                List<EnclosedExpr> enclosedExprs = compilationUnit.findAll(EnclosedExpr.class);\n                assertEquals(2, enclosedExprs.size());\n\n                EnclosedExpr enclosedExpr = enclosedExprs.get(0);\n\n                List<NameExpr> nameExprs = enclosedExpr.findAll(NameExpr.class);\n                assertEquals(2, nameExprs.size());\n\n                NameExpr nameExpr = nameExprs.get(1);\n                assertEquals(\"s\", nameExpr.getNameAsString());\n\n                Context context = JavaParserFactory.getContext(nameExpr, typeSolver);\n                SymbolReference<? extends ResolvedValueDeclaration> symbolReference = context.solveSymbol(\"s\");\n                System.out.println(\"symbolReference = \" + symbolReference);\n\n                assertFalse(symbolReference.isSolved(), \"symbol supposed to be not solved\");\n            }\n\n            @Nested\n            class IfElse {\n\n\n                @Test\n                void instanceOfPattern_ifBlock1() {\n                    String x = \"\" +\n                            \"if (a instanceof String s) {\\n\" +\n                            \"    result = s.contains(\\\"in scope\\\");\\n\" +\n                            \"}\\n\" +\n                            \"\";\n                    IfStmt ifStmt = parse(ParserConfiguration.LanguageLevel.JAVA_14, x, ParseStart.STATEMENT).asIfStmt();\n\n                    List<MethodCallExpr> methodCallExprs = ifStmt.findAll(MethodCallExpr.class);\n                    System.out.println(\"methodCallExprs = \" + methodCallExprs);\n                    assertEquals(1, methodCallExprs.size());\n\n                    MethodCallExpr methodCallExpr = methodCallExprs.get(0);\n                    Context context = JavaParserFactory.getContext(methodCallExpr, typeSolver);\n\n                    SymbolReference<? extends ResolvedValueDeclaration> s = context.solveSymbol(\"s\");\n                    assertTrue(s.isSolved());\n                    assertTrue(s.getCorrespondingDeclaration().isPattern());\n                }\n\n                @Test\n                void instanceOfPattern_ifBlock1_noBraces() {\n                    String x = \"\" +\n                            \"if (a instanceof String s) \\n\" +\n                            \"    result = s.contains(\\\"in scope\\\");\\n\" +\n                            \"\\n\" +\n                            \"\";\n                    IfStmt ifStmt = parse(ParserConfiguration.LanguageLevel.JAVA_14, x, ParseStart.STATEMENT).asIfStmt();\n\n                    List<MethodCallExpr> methodCallExprs = ifStmt.findAll(MethodCallExpr.class);\n                    System.out.println(\"methodCallExprs = \" + methodCallExprs);\n                    assertEquals(1, methodCallExprs.size());\n\n                    MethodCallExpr methodCallExpr = methodCallExprs.get(0);\n                    Context context = JavaParserFactory.getContext(methodCallExpr, typeSolver);\n\n                    SymbolReference<? extends ResolvedValueDeclaration> s = context.solveSymbol(\"s\");\n                    assertTrue(s.isSolved());\n                    assertTrue(s.getCorrespondingDeclaration().isPattern());\n                }\n\n                @Test\n                void instanceOfPattern_ifBlock1_negatedCondition() {\n                    String x = \"\" +\n                            \"if (!(a instanceof String s)) {\\n\" +\n                            \"    result = s.contains(\\\"NOT in scope\\\");\\n\" +\n                            \"}\\n\" +\n                            \"\";\n                    IfStmt ifStmt = parse(ParserConfiguration.LanguageLevel.JAVA_14, x, ParseStart.STATEMENT).asIfStmt();\n\n                    List<MethodCallExpr> methodCallExprs = ifStmt.findAll(MethodCallExpr.class);\n                    System.out.println(\"methodCallExprs = \" + methodCallExprs);\n                    assertEquals(1, methodCallExprs.size());\n\n                    MethodCallExpr methodCallExpr = methodCallExprs.get(0);\n                    Context context = JavaParserFactory.getContext(methodCallExpr, typeSolver);\n\n                    SymbolReference<? extends ResolvedValueDeclaration> s = context.solveSymbol(\"s\");\n                    assertFalse(s.isSolved());\n                }\n\n                @Test\n                void instanceOfPattern_ifBlock1_noBraces_negatedCondition() {\n                    String x = \"\" +\n                            \"if (!(a instanceof String s)) \\n\" +\n                            \"    result = s.contains(\\\"NOT in scope\\\");\\n\" +\n                            \"\\n\" +\n                            \"\";\n                    IfStmt ifStmt = parse(ParserConfiguration.LanguageLevel.JAVA_14, x, ParseStart.STATEMENT).asIfStmt();\n\n                    List<MethodCallExpr> methodCallExprs = ifStmt.findAll(MethodCallExpr.class);\n                    System.out.println(\"methodCallExprs = \" + methodCallExprs);\n                    assertEquals(1, methodCallExprs.size());\n\n                    MethodCallExpr methodCallExpr = methodCallExprs.get(0);\n                    Context context = JavaParserFactory.getContext(methodCallExpr, typeSolver);\n\n                    SymbolReference<? extends ResolvedValueDeclaration> s = context.solveSymbol(\"s\");\n                    assertFalse(s.isSolved());\n                }\n\n                @Test\n                void instanceOfPattern_ifElseBlock1() {\n                    String x = \"\" +\n                            \"{\\n\" +\n                            \"    List s;\\n\" +\n                            \"    if (!(a instanceof String s)) {\\n\" +\n                            \"        result = s.contains(\\\"in scope\\\");\\n\" +\n                            \"    } else if (true) {\\n\" +\n                            \"        result = s.contains(\\\"in scope\\\");\\n\" +\n                            \"    }\\n\" +\n                            \"}\\n\" +\n                            \"\";\n                    BlockStmt blockStmt = parse(ParserConfiguration.LanguageLevel.JAVA_14, x, ParseStart.BLOCK).asBlockStmt();\n\n                    List<MethodCallExpr> methodCallExprs = blockStmt.findAll(MethodCallExpr.class);\n                    System.out.println(\"methodCallExprs = \" + methodCallExprs);\n                    assertEquals(2, methodCallExprs.size());\n\n                    // The first one should resolve to the standard variable (the list)\n                    MethodCallExpr methodCallExpr_list = methodCallExprs.get(0);\n                    Context context_list = JavaParserFactory.getContext(methodCallExpr_list, typeSolver);\n                    SymbolReference<? extends ResolvedValueDeclaration> s_list = context_list.solveSymbol(\"s\");\n                    assertTrue(s_list.isSolved());\n                    assertFalse(s_list.getCorrespondingDeclaration().isPattern());\n//                    assertTrue(s_list.getCorrespondingDeclaration().isVariable()); // Should pass but seemingly not implemented/overridden, perhaps?\n\n                    // The second one should resolve to the pattern variable (the string).\n                    MethodCallExpr methodCallExpr_string = methodCallExprs.get(1);\n                    Context context_string = JavaParserFactory.getContext(methodCallExpr_string, typeSolver);\n                    SymbolReference<? extends ResolvedValueDeclaration> s_string = context_string.solveSymbol(\"s\");\n                    assertTrue(s_string.isSolved());\n                    assertTrue(s_string.getCorrespondingDeclaration().isPattern());\n                }\n\n                @Test\n                void instanceOfPattern_ifElseBlock2() {\n                    String x = \"\" +\n                            \"{\\n\" +\n                            \"    List s;\\n\" +\n                            \"    if (!(a instanceof String s)) {\\n\" +\n                            \"        result = s.contains(\\\"\\\");\\n\" +\n                            \"    } else if (true) {\\n\" +\n                            \"        result = s.contains(\\\"\\\");\\n\" +\n                            \"    } else if (true) {\\n\" +\n                            \"        result = s.contains(\\\"\\\");\\n\" +\n                            \"    } else {\\n\" +\n                            \"        result = s.contains(\\\"\\\");\\n\" +\n                            \"    }\\n\" +\n                            \"}\\n\" +\n                            \"\";\n                    BlockStmt blockStmt = parse(ParserConfiguration.LanguageLevel.JAVA_14, x, ParseStart.BLOCK).asBlockStmt();\n\n                    List<MethodCallExpr> methodCallExprs = blockStmt.findAll(MethodCallExpr.class);\n                    System.out.println(\"methodCallExprs = \" + methodCallExprs);\n                    assertEquals(4, methodCallExprs.size());\n\n                    // The first one should resolve to the standard variable (the list)\n                    MethodCallExpr methodCallExpr_list = methodCallExprs.get(0);\n                    Context context_list = JavaParserFactory.getContext(methodCallExpr_list, typeSolver);\n                    SymbolReference<? extends ResolvedValueDeclaration> s_list = context_list.solveSymbol(\"s\");\n                    assertTrue(s_list.isSolved());\n                    assertFalse(s_list.getCorrespondingDeclaration().isPattern());\n//                    assertTrue(s_list.getCorrespondingDeclaration().isVariable()); // Should pass but seemingly not implemented/overridden, perhaps?\n\n                    // The second one should resolve to the pattern variable (the string).\n                    MethodCallExpr methodCallExpr_string = methodCallExprs.get(1);\n                    Context context_string = JavaParserFactory.getContext(methodCallExpr_string, typeSolver);\n                    SymbolReference<? extends ResolvedValueDeclaration> s_string = context_string.solveSymbol(\"s\");\n                    assertTrue(s_string.isSolved());\n                    assertTrue(s_string.getCorrespondingDeclaration().isPattern());\n\n                    // The third one should resolve to the pattern variable (the string).\n                    MethodCallExpr methodCallExpr_string2 = methodCallExprs.get(2);\n                    Context context_string2 = JavaParserFactory.getContext(methodCallExpr_string2, typeSolver);\n                    SymbolReference<? extends ResolvedValueDeclaration> s_string2 = context_string2.solveSymbol(\"s\");\n                    assertTrue(s_string2.isSolved());\n                    assertTrue(s_string2.getCorrespondingDeclaration().isPattern());\n\n                    // The fourth one should resolve to the pattern variable (the string).\n                    MethodCallExpr methodCallExpr_string3 = methodCallExprs.get(2);\n                    Context context_string3 = JavaParserFactory.getContext(methodCallExpr_string3, typeSolver);\n                    SymbolReference<? extends ResolvedValueDeclaration> s_string3 = context_string3.solveSymbol(\"s\");\n                    assertTrue(s_string3.isSolved());\n                    assertTrue(s_string3.getCorrespondingDeclaration().isPattern());\n                }\n\n                @Test\n                void instanceOfPattern_ifElseBlock3() {\n                    String x = \"\" +\n                            \"{\\n\" +\n                            \"    List s;\\n\" +\n                            \"    if (false) {\\n\" +\n                            \"        result = s.contains(\\\"\\\");\\n\" +\n                            \"    } else if (!(a instanceof String s)) {\\n\" +\n                            \"        result = s.contains(\\\"\\\");\\n\" +\n                            \"    } else if (true) {\\n\" +\n                            \"        result = s.contains(\\\"\\\");\\n\" +\n                            \"    } else {\\n\" +\n                            \"        result = s.contains(\\\"\\\");\\n\" +\n                            \"    }\\n\" +\n                            \"}\\n\" +\n                            \"\";\n                    BlockStmt blockStmt = parse(ParserConfiguration.LanguageLevel.JAVA_14, x, ParseStart.BLOCK).asBlockStmt();\n\n                    List<MethodCallExpr> methodCallExprs = blockStmt.findAll(MethodCallExpr.class);\n                    System.out.println(\"methodCallExprs = \" + methodCallExprs);\n                    assertEquals(4, methodCallExprs.size());\n\n                    // The first one should resolve to the standard variable (the list)\n                    MethodCallExpr methodCallExpr_list = methodCallExprs.get(0);\n                    Context context_list = JavaParserFactory.getContext(methodCallExpr_list, typeSolver);\n                    SymbolReference<? extends ResolvedValueDeclaration> s_list = context_list.solveSymbol(\"s\");\n                    assertTrue(s_list.isSolved());\n                    assertFalse(s_list.getCorrespondingDeclaration().isPattern());\n\n                    // The second one should resolve to the standard variable (the list).\n                    MethodCallExpr methodCallExpr_string = methodCallExprs.get(1);\n                    Context context_string = JavaParserFactory.getContext(methodCallExpr_string, typeSolver);\n                    SymbolReference<? extends ResolvedValueDeclaration> s_string = context_string.solveSymbol(\"s\");\n                    assertTrue(s_string.isSolved());\n                    assertFalse(s_string.getCorrespondingDeclaration().isPattern());\n\n                    // The third one should resolve to the pattern variable (the string).\n                    MethodCallExpr methodCallExpr_string2 = methodCallExprs.get(2);\n                    Context context_string2 = JavaParserFactory.getContext(methodCallExpr_string2, typeSolver);\n                    SymbolReference<? extends ResolvedValueDeclaration> s_string2 = context_string2.solveSymbol(\"s\");\n                    assertTrue(s_string2.isSolved());\n                    assertTrue(s_string2.getCorrespondingDeclaration().isPattern());\n\n                    // The fourth one should resolve to the pattern variable (the string).\n                    MethodCallExpr methodCallExpr_string3 = methodCallExprs.get(2);\n                    Context context_string3 = JavaParserFactory.getContext(methodCallExpr_string3, typeSolver);\n                    SymbolReference<? extends ResolvedValueDeclaration> s_string3 = context_string3.solveSymbol(\"s\");\n                    assertTrue(s_string3.isSolved());\n                    assertTrue(s_string3.getCorrespondingDeclaration().isPattern());\n                }\n            }\n        }\n\n    }\n\n}\n",
        "diffSourceCodeSet": [
            "private <PS extends Node> PS parse(ParserConfiguration.LanguageLevel languageLevel, String code, ParseStart<PS> parseStart) {\n        ParserConfiguration parserConfiguration = new ParserConfiguration();\n        parserConfiguration.setLanguageLevel(languageLevel);\n        ParseResult<PS> parseResult = new JavaParser(parserConfiguration).parse(parseStart, new StringProvider(code));\n        if (!parseResult.isSuccessful()) {\n            parseResult.getProblems().forEach(p -> System.out.println(\"ERR: \" + p));\n        }\n        assertTrue(parseResult.isSuccessful());\n        PS root = parseResult.getResult().get();\n        return root;\n    }"
        ],
        "invokedMethodSet": [
            "methodSignature: com.github.javaparser.symbolsolver.resolution.ContextTest#parse\n methodBody: private <PS extends Node> PS parse(String code, ParseStart<PS> parseStart) {\nParserConfiguration parserConfiguration=new ParserConfiguration();\nparserConfiguration.setLanguageLevel(ParserConfiguration.LanguageLevel.JAVA_10);\nParseResult<PS> parseResult=new JavaParser(parserConfiguration).parse(parseStart,new StringProvider(code));\nif(!parseResult.isSuccessful()){parseResult.getProblems().forEach(p -> System.out.println(\"ERR: \" + p));\n}assertTrue(parseResult.isSuccessful());\nPS root=parseResult.getResult().get();\nreturn root;\n}",
            "methodSignature: com.github.javaparser.symbolsolver.resolution.naming.AbstractNameLogicTest#parse\n methodBody: protected <N extends Node> N parse(String code, ParseStart<N> parseStart, Optional<TypeSolver> typeSolver) {\nParserConfiguration parserConfiguration=new ParserConfiguration();\nparserConfiguration.setLanguageLevel(ParserConfiguration.LanguageLevel.JAVA_10);\nif(typeSolver.isPresent()){parserConfiguration.setSymbolResolver(new JavaSymbolSolver(typeSolver.get()));\n}ParseResult<N> parseResult=new JavaParser(parserConfiguration).parse(parseStart,new StringProvider(code));\nif(!parseResult.isSuccessful()){parseResult.getProblems().forEach(p -> System.out.println(\"ERR: \" + p));\n}assertTrue(parseResult.isSuccessful());\nN root=parseResult.getResult().get();\nreturn root;\n}"
        ],
        "sourceCodeAfterRefactoring": "private <PS extends Node> PS parse(String code, ParseStart<PS> parseStart) {\n        return parse(ParserConfiguration.LanguageLevel.JAVA_10, code, parseStart);\n    }\nprivate <PS extends Node> PS parse(ParserConfiguration.LanguageLevel languageLevel, String code, ParseStart<PS> parseStart) {\n        ParserConfiguration parserConfiguration = new ParserConfiguration();\n        parserConfiguration.setLanguageLevel(languageLevel);\n        ParseResult<PS> parseResult = new JavaParser(parserConfiguration).parse(parseStart, new StringProvider(code));\n        if (!parseResult.isSuccessful()) {\n            parseResult.getProblems().forEach(p -> System.out.println(\"ERR: \" + p));\n        }\n        assertTrue(parseResult.isSuccessful());\n        PS root = parseResult.getResult().get();\n        return root;\n    }",
        "diffSourceCode": "-  594:     private <PS extends Node> PS parse(String code, ParseStart<PS> parseStart) {\n-  595:         ParserConfiguration parserConfiguration = new ParserConfiguration();\n-  596:         parserConfiguration.setLanguageLevel(ParserConfiguration.LanguageLevel.JAVA_10);\n-  597:         ParseResult<PS> parseResult = new JavaParser(parserConfiguration).parse(parseStart, new StringProvider(code));\n-  598:         if (!parseResult.isSuccessful()) {\n-  599:             parseResult.getProblems().forEach(p -> System.out.println(\"ERR: \" + p));\n-  600:         }\n-  601:         assertTrue(parseResult.isSuccessful());\n-  602:         PS root = parseResult.getResult().get();\n-  603:         return root;\n-  604:     }\n-  610:                 \"SomeClass a; a.aField;\" + \"\\n\" +\n-  611:                 \"} }\", ParseStart.COMPILATION_UNIT);\n-  612: \n-  614:         BlockStmt blockStmt = cu.findAll(BlockStmt.class).get(0);\n-  615:         Context context1 = JavaParserFactory.getContext(blockStmt, typeSolver);\n-  616:         assertEquals(1, context1.localVariablesExposedToChild(blockStmt.getStatement(1)).size());\n-  617: \n-  618:         Node nameNode = cu.findAll(NameExpr.class).get(0);\n-  619:         Context context = JavaParserFactory.getContext(nameNode, typeSolver);\n-  620:         assertTrue(context.localVariableDeclarationInScope(name).isPresent());\n-  621:     }\n-  622: \n-  623:     //\n-  624:     // Testing JLS 6.3 Scope of a Declaration\n+  594: \n+  595:     @Test\n+  596:     void resolveReferenceToOverloadMethodFindOnlyCompatible() {\n+  597:         CompilationUnit cu = parseSample(\"OverloadedMethods\");\n+  598:         ClassOrInterfaceDeclaration clazz = Navigator.demandClass(cu, \"OverloadedMethods\");\n+  599:         MethodDeclaration method = Navigator.demandMethod(clazz, \"m3\");\n+  600:         MethodCallExpr call = Navigator.findMethodCall(method, \"overloaded\").get();\n+  601: \n+  602:         ReflectionTypeSolver typeSolver = new ReflectionTypeSolver();\n+  603:         MethodUsage ref = JavaParserFacade.get(typeSolver).solveMethodAsUsage(call);\n+  604: \n+  610:     private <PS extends Node> PS parse(String code, ParseStart<PS> parseStart) {\n+  611:         return parse(ParserConfiguration.LanguageLevel.JAVA_10, code, parseStart);\n+  612:     }\n+  614:     private <PS extends Node> PS parse(ParserConfiguration.LanguageLevel languageLevel, String code, ParseStart<PS> parseStart) {\n+  615:         ParserConfiguration parserConfiguration = new ParserConfiguration();\n+  616:         parserConfiguration.setLanguageLevel(languageLevel);\n+  617:         ParseResult<PS> parseResult = new JavaParser(parserConfiguration).parse(parseStart, new StringProvider(code));\n+  618:         if (!parseResult.isSuccessful()) {\n+  619:             parseResult.getProblems().forEach(p -> System.out.println(\"ERR: \" + p));\n+  620:         }\n+  621:         assertTrue(parseResult.isSuccessful());\n+  622:         PS root = parseResult.getResult().get();\n+  623:         return root;\n+  624:     }\n",
        "uniqueId": "2903fc918dd87be53192aa1065047392f7adf4d1_594_604_614_624_610_612",
        "moveFileExist": true,
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 1.8,
        "testResult": true,
        "coverageInfo": {
            "testMethod": {
                "missed": 0,
                "covered": 1
            }
        }
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tpublic assertEqualsStringIgnoringEol(expected String, actual String, message String) : void extracted from public assertEqualsNoEol(expected String, actual String, message String) : void in class com.github.javaparser.utils.TestUtils",
        "diffLocations": [
            {
                "filePath": "javaparser-core-testing/src/test/java/com/github/javaparser/utils/TestUtils.java",
                "startLine": 278,
                "endLine": 283,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "javaparser-core-testing/src/test/java/com/github/javaparser/utils/TestUtils.java",
                "startLine": 267,
                "endLine": 274,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "javaparser-core-testing/src/test/java/com/github/javaparser/utils/TestUtils.java",
                "startLine": 320,
                "endLine": 329,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "/**\n     * Assert that \"actual\" equals \"expected\", and that any EOL characters in \"actual\" are correct for the platform.\n     */\n    public static void assertEqualsNoEol(String expected, String actual, String message) {\n        assertEquals(normalizeEolInTextBlock(expected, LineEnding.ARBITRARY), normalizeEolInTextBlock(actual, LineEnding.ARBITRARY), message);\n    }",
        "filePathBefore": "javaparser-core-testing/src/test/java/com/github/javaparser/utils/TestUtils.java",
        "isPureRefactoring": true,
        "commitId": "339d45a5694b569dee7bab605eb700a564975b6c",
        "packageNameBefore": "com.github.javaparser.utils",
        "classNameBefore": "com.github.javaparser.utils.TestUtils",
        "methodNameBefore": "com.github.javaparser.utils.TestUtils#assertEqualsNoEol",
        "classSignatureBefore": "public class TestUtils ",
        "methodNameBeforeSet": [
            "com.github.javaparser.utils.TestUtils#assertEqualsNoEol"
        ],
        "classNameBeforeSet": [
            "com.github.javaparser.utils.TestUtils"
        ],
        "classSignatureBeforeSet": [
            "public class TestUtils "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Overlapped refactoring - can be identical by undoing the overlapped refactoring\n- Extract Method-",
                "description": "Extract Method on top of the extracted method - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Copyright (C) 2007-2010 J\u00falio Vilmar Gesser.\n * Copyright (C) 2011, 2013-2019 The JavaParser Team.\n *\n * This file is part of JavaParser.\n *\n * JavaParser can be used either under the terms of\n * a) the GNU Lesser General Public License as published by\n *     the Free Software Foundation, either version 3 of the License, or\n *     (at your option) any later version.\n * b) the terms of the Apache License\n *\n * You should have received a copy of both licenses in LICENCE.LGPL and\n * LICENCE.APACHE. Please refer to those files for details.\n *\n * JavaParser is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n */\n\npackage com.github.javaparser.utils;\n\nimport com.github.javaparser.JavaParser;\nimport com.github.javaparser.ParseResult;\nimport com.github.javaparser.ParseStart;\nimport com.github.javaparser.ParserConfiguration;\nimport com.github.javaparser.Problem;\nimport com.github.javaparser.ast.expr.Expression;\nimport okhttp3.OkHttpClient;\nimport okhttp3.Request;\nimport okhttp3.Response;\n\nimport java.io.BufferedReader;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.net.URISyntaxException;\nimport java.net.URL;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.Collection;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.stream.Collectors;\nimport java.util.zip.ZipEntry;\nimport java.util.zip.ZipInputStream;\n\nimport static com.github.javaparser.ParserConfiguration.LanguageLevel.JAVA_9;\nimport static com.github.javaparser.Providers.provider;\nimport static com.github.javaparser.utils.CodeGenerationUtils.f;\nimport static com.github.javaparser.utils.Utils.normalizeEolInTextBlock;\nimport static java.nio.charset.StandardCharsets.UTF_8;\nimport static java.util.Arrays.asList;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class TestUtils {\n\n    /**\n     * Read the resource's contents line-by-line, and use the <strong>system's line separator</strong> to separate lines.\n     * Takes care of setting all the end of line character to platform specific ones.\n     * <br>\n     * <br>If you wish to read the file as-is, use {@link #readResource(String)} which reads the file stream character-by-character.\n     */\n    public static String readResourceUsingSystemEol(String resourceName) {\n        return readResource(resourceName, LineEnding.SYSTEM);\n    }\n\n    /**\n     * Read the resource's contents line-by-line, and use the <strong>given line separator</strong> to separate lines.\n     * <br>\n     * <br>If you wish to read the file as-is, use {@link #readResource(String)} which reads the file stream character-by-character.\n     */\n    public static String readResource(String resourceName, LineEnding lineEnding) {\n        if (resourceName.startsWith(\"/\")) {\n            resourceName = resourceName.substring(1);\n        }\n        try (final InputStream resourceAsStream = TestUtils.class.getClassLoader().getResourceAsStream(resourceName)) {\n            if (resourceAsStream == null) {\n                fail(\"resource not found by name: \" + resourceName);\n            }\n            try (final InputStreamReader reader = new InputStreamReader(resourceAsStream, UTF_8);\n                 final BufferedReader br = new BufferedReader(reader)) {\n                final StringBuilder builder = new StringBuilder(4096);\n                String line;\n                while ((line = br.readLine()) != null) {\n                    builder.append(line).append(lineEnding.toString());\n                }\n                return builder.toString();\n            }\n        } catch (IOException e) {\n            fail(e);\n            return null;\n        }\n    }\n\n\n    /**\n     * Read the resource's contents as-is.\n     * <br>\n     * <br>If you wish to specify the line endings,\n     * use {@link #readResourceUsingSystemEol(String)}\n     * or {@link #readResource(String, LineEnding)}\n     */\n    public static String readResource(String resourceName) {\n        if (resourceName.startsWith(\"/\")) {\n            resourceName = resourceName.substring(1);\n        }\n        try (final InputStream resourceAsStream = TestUtils.class.getClassLoader().getResourceAsStream(resourceName)) {\n            if (resourceAsStream == null) {\n                fail(\"not found: \" + resourceName);\n            }\n            try (final InputStreamReader reader = new InputStreamReader(resourceAsStream, UTF_8);\n                 final BufferedReader br = new BufferedReader(reader)\n            ) {\n                // Switched to reading char-by-char as opposed to line-by-line.\n                // This helps to retain the resource's own line endings.\n                final StringBuilder builder = new StringBuilder(4096);\n                for (int c = br.read(); c != -1; c = br.read()) {\n                    builder.append((char) c);\n                }\n                return builder.toString();\n            }\n        } catch (IOException e) {\n            fail(e);\n            return null;\n        }\n    }\n\n    /**\n     * Use this assertion if line endings are important, otherwise use {@link #assertEqualToTextResourceNoEol(String, String)}\n     */\n    public static void assertEqualToTextResource(String resourceName, String actual) {\n        String expected = readResourceUsingSystemEol(resourceName);\n\n        // First test equality ignoring EOL chars\n        assertEqualsNoEol(expected, actual);\n\n        // If this passes but the next one fails, the failure is due only to EOL differences, allowing a more precise test failure message.\n        assertEquals(\n                expected,\n                actual,\n                String.format(\"failed due to line separator differences -- Expected: %s, but actual: %s (system eol: %s)\",\n                        LineEnding.detect(expected).escaped(),\n                        LineEnding.detect(actual).escaped(),\n                        LineEnding.SYSTEM.escaped()\n                )\n        );\n    }\n\n    /**\n     * If line endings are important, use {@link #assertEqualToTextResource(String, String)}\n     */\n    public static void assertEqualToTextResourceNoEol(String resourceName, String actual) {\n        String expected = readResourceUsingSystemEol(resourceName);\n        assertEquals(expected, actual, \"failed due to line separator differences\");\n    }\n\n    public static String readTextResource(Class<?> relativeClass, String resourceName) {\n        final URL resourceAsStream = relativeClass.getResource(resourceName);\n        try {\n            byte[] bytes = Files.readAllBytes(Paths.get(resourceAsStream.toURI()));\n            return new String(bytes, UTF_8);\n        } catch (IOException | URISyntaxException e) {\n            fail(e);\n            return null;\n        }\n    }\n\n    public static void assertInstanceOf(Class<?> expectedType, Object instance) {\n        assertTrue(expectedType.isAssignableFrom(instance.getClass()), f(\"%s is not an instance of %s.\", instance.getClass(), expectedType));\n    }\n\n    /**\n     * Unzip a zip file into a directory.\n     */\n    public static void unzip(Path zipFile, Path outputFolder) throws IOException {\n        Log.info(\"Unzipping %s to %s\", () -> zipFile, () -> outputFolder);\n\n        final byte[] buffer = new byte[1024 * 1024];\n\n        outputFolder.toFile().mkdirs();\n\n        try (ZipInputStream zis = new ZipInputStream(new FileInputStream(zipFile.toFile()))) {\n            ZipEntry ze = zis.getNextEntry();\n\n            while (ze != null) {\n                final Path newFile = outputFolder.resolve(ze.getName());\n\n                if (ze.isDirectory()) {\n                    Log.trace(\"mkdir %s\", newFile::toAbsolutePath);\n                    newFile.toFile().mkdirs();\n                } else {\n                    Log.info(\"unzip %s\", newFile::toAbsolutePath);\n                    try (FileOutputStream fos = new FileOutputStream(newFile.toFile())) {\n                        int len;\n                        while ((len = zis.read(buffer)) > 0) {\n                            fos.write(buffer, 0, len);\n                        }\n                    }\n                }\n                zis.closeEntry();\n                ze = zis.getNextEntry();\n            }\n\n        }\n        Log.info(\"Unzipped %s to %s\", () -> zipFile, () -> outputFolder);\n    }\n\n    /**\n     * Download a file from a URL to disk.\n     */\n    public static void download(URL url, Path destination) throws IOException {\n        OkHttpClient client = new OkHttpClient();\n        Request request = new Request.Builder()\n                .url(url)\n                .build();\n\n        Response response = client.newCall(request).execute();\n        Files.write(destination, response.body().bytes());\n    }\n\n    public static String temporaryDirectory() {\n        return System.getProperty(\"java.io.tmpdir\");\n    }\n\n    public static void assertCollections(Collection<?> expected, Collection<?> actual) {\n        final StringBuilder out = new StringBuilder();\n        for (Object e : expected) {\n            if (actual.contains(e)) {\n                actual.remove(e);\n            } else {\n                out.append(\"Missing: \").append(e).append(LineEnding.SYSTEM);\n            }\n        }\n        for (Object a : actual) {\n            out.append(\"Unexpected: \").append(a).append(LineEnding.SYSTEM);\n        }\n\n        String s = out.toString();\n        if (s.isEmpty()) {\n            return;\n        }\n        fail(s);\n    }\n\n    public static void assertProblems(ParseResult<?> result, String... expectedArg) {\n        assertProblems(result.getProblems(), expectedArg);\n    }\n\n    public static void assertProblems(List<Problem> result, String... expectedArg) {\n        Set<String> actual = result.stream().map(Problem::toString).collect(Collectors.toSet());\n        Set<String> expected = new HashSet<>(asList(expectedArg));\n        assertCollections(expected, actual);\n    }\n\n    public static void assertNoProblems(ParseResult<?> result) {\n        assertProblems(result);\n    }\n\n    public static void assertExpressionValid(String expression) {\n        JavaParser javaParser = new JavaParser(new ParserConfiguration().setLanguageLevel(JAVA_9));\n        ParseResult<Expression> result = javaParser.parse(ParseStart.EXPRESSION, provider(expression));\n        assertTrue(result.isSuccessful(), result.getProblems().toString());\n    }\n\n    /**\n     * Assert that \"actual\" equals \"expected\", and that any EOL characters in \"actual\" are correct for the platform.\n     */\n    public static void assertEqualsNoEol(String expected, String actual) {\n        assertEquals(normalizeEolInTextBlock(expected, LineEnding.ARBITRARY), normalizeEolInTextBlock(actual, LineEnding.ARBITRARY));\n    }\n\n    /**\n     * Assert that \"actual\" equals \"expected\", and that any EOL characters in \"actual\" are correct for the platform.\n     */\n    public static void assertEqualsNoEol(String expected, String actual, String message) {\n        assertEquals(normalizeEolInTextBlock(expected, LineEnding.ARBITRARY), normalizeEolInTextBlock(actual, LineEnding.ARBITRARY), message);\n    }\n}\n",
        "filePathAfter": "javaparser-core-testing/src/test/java/com/github/javaparser/utils/TestUtils.java",
        "sourceCodeAfterForWhole": "/*\n * Copyright (C) 2007-2010 J\u00falio Vilmar Gesser.\n * Copyright (C) 2011, 2013-2019 The JavaParser Team.\n *\n * This file is part of JavaParser.\n *\n * JavaParser can be used either under the terms of\n * a) the GNU Lesser General Public License as published by\n *     the Free Software Foundation, either version 3 of the License, or\n *     (at your option) any later version.\n * b) the terms of the Apache License\n *\n * You should have received a copy of both licenses in LICENCE.LGPL and\n * LICENCE.APACHE. Please refer to those files for details.\n *\n * JavaParser is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n */\n\npackage com.github.javaparser.utils;\n\nimport com.github.javaparser.JavaParser;\nimport com.github.javaparser.ParseResult;\nimport com.github.javaparser.ParseStart;\nimport com.github.javaparser.ParserConfiguration;\nimport com.github.javaparser.Problem;\nimport com.github.javaparser.ast.expr.Expression;\nimport okhttp3.OkHttpClient;\nimport okhttp3.Request;\nimport okhttp3.Response;\n\nimport java.io.BufferedReader;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.net.URISyntaxException;\nimport java.net.URL;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.Collection;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.stream.Collectors;\nimport java.util.zip.ZipEntry;\nimport java.util.zip.ZipInputStream;\n\nimport static com.github.javaparser.ParserConfiguration.LanguageLevel.JAVA_9;\nimport static com.github.javaparser.Providers.provider;\nimport static com.github.javaparser.utils.CodeGenerationUtils.f;\nimport static com.github.javaparser.utils.Utils.normalizeEolInTextBlock;\nimport static java.nio.charset.StandardCharsets.UTF_8;\nimport static java.util.Arrays.asList;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class TestUtils {\n\n    /**\n     * Read the resource's contents line-by-line, and use the <strong>system's line separator</strong> to separate lines.\n     * Takes care of setting all the end of line character to platform specific ones.\n     * <br>\n     * <br>If you wish to read the file as-is, use {@link #readResource(String)} which reads the file stream character-by-character.\n     */\n    public static String readResourceUsingSystemEol(String resourceName) {\n        return readResource(resourceName, LineEnding.SYSTEM);\n    }\n\n    /**\n     * Read the resource's contents line-by-line, and use the <strong>given line separator</strong> to separate lines.\n     * <br>\n     * <br>If you wish to read the file as-is, use {@link #readResource(String)} which reads the file stream character-by-character.\n     */\n    public static String readResource(String resourceName, LineEnding lineEnding) {\n        if (resourceName.startsWith(\"/\")) {\n            resourceName = resourceName.substring(1);\n        }\n        try (final InputStream resourceAsStream = TestUtils.class.getClassLoader().getResourceAsStream(resourceName)) {\n            if (resourceAsStream == null) {\n                fail(\"resource not found by name: \" + resourceName);\n            }\n            try (final InputStreamReader reader = new InputStreamReader(resourceAsStream, UTF_8);\n                 final BufferedReader br = new BufferedReader(reader)) {\n                final StringBuilder builder = new StringBuilder(4096);\n                String line;\n                while ((line = br.readLine()) != null) {\n                    builder.append(line).append(lineEnding.toString());\n                }\n                return builder.toString();\n            }\n        } catch (IOException e) {\n            fail(e);\n            return null;\n        }\n    }\n\n\n    /**\n     * Read the resource's contents as-is.\n     * <br>\n     * <br>If you wish to specify the line endings,\n     * use {@link #readResourceUsingSystemEol(String)}\n     * or {@link #readResource(String, LineEnding)}\n     */\n    public static String readResource(String resourceName) {\n        if (resourceName.startsWith(\"/\")) {\n            resourceName = resourceName.substring(1);\n        }\n        try (final InputStream resourceAsStream = TestUtils.class.getClassLoader().getResourceAsStream(resourceName)) {\n            if (resourceAsStream == null) {\n                fail(\"not found: \" + resourceName);\n            }\n            try (final InputStreamReader reader = new InputStreamReader(resourceAsStream, UTF_8);\n                 final BufferedReader br = new BufferedReader(reader)\n            ) {\n                // Switched to reading char-by-char as opposed to line-by-line.\n                // This helps to retain the resource's own line endings.\n                final StringBuilder builder = new StringBuilder(4096);\n                for (int c = br.read(); c != -1; c = br.read()) {\n                    builder.append((char) c);\n                }\n                return builder.toString();\n            }\n        } catch (IOException e) {\n            fail(e);\n            return null;\n        }\n    }\n\n    /**\n     * Use this assertion if line endings are important, otherwise use {@link #assertEqualToTextResourceNoEol(String, String)}\n     */\n    public static void assertEqualToTextResource(String resourceName, String actual) {\n        String expected = readResourceUsingSystemEol(resourceName);\n        assertEqualsString(expected, actual);\n    }\n\n    /**\n     * If line endings are important, use {@link #assertEqualToTextResource(String, String)}\n     */\n    public static void assertEqualToTextResourceNoEol(String resourceName, String actual) {\n        String expected = readResourceUsingSystemEol(resourceName);\n        assertEqualsNoEol(expected, actual);\n    }\n\n    public static String readTextResource(Class<?> relativeClass, String resourceName) {\n        final URL resourceAsStream = relativeClass.getResource(resourceName);\n        try {\n            byte[] bytes = Files.readAllBytes(Paths.get(resourceAsStream.toURI()));\n            return new String(bytes, UTF_8);\n        } catch (IOException | URISyntaxException e) {\n            fail(e);\n            return null;\n        }\n    }\n\n    public static void assertInstanceOf(Class<?> expectedType, Object instance) {\n        assertTrue(expectedType.isAssignableFrom(instance.getClass()), f(\"%s is not an instance of %s.\", instance.getClass(), expectedType));\n    }\n\n    /**\n     * Unzip a zip file into a directory.\n     */\n    public static void unzip(Path zipFile, Path outputFolder) throws IOException {\n        Log.info(\"Unzipping %s to %s\", () -> zipFile, () -> outputFolder);\n\n        final byte[] buffer = new byte[1024 * 1024];\n\n        outputFolder.toFile().mkdirs();\n\n        try (ZipInputStream zis = new ZipInputStream(new FileInputStream(zipFile.toFile()))) {\n            ZipEntry ze = zis.getNextEntry();\n\n            while (ze != null) {\n                final Path newFile = outputFolder.resolve(ze.getName());\n\n                if (ze.isDirectory()) {\n                    Log.trace(\"mkdir %s\", newFile::toAbsolutePath);\n                    newFile.toFile().mkdirs();\n                } else {\n                    Log.info(\"unzip %s\", newFile::toAbsolutePath);\n                    try (FileOutputStream fos = new FileOutputStream(newFile.toFile())) {\n                        int len;\n                        while ((len = zis.read(buffer)) > 0) {\n                            fos.write(buffer, 0, len);\n                        }\n                    }\n                }\n                zis.closeEntry();\n                ze = zis.getNextEntry();\n            }\n\n        }\n        Log.info(\"Unzipped %s to %s\", () -> zipFile, () -> outputFolder);\n    }\n\n    /**\n     * Download a file from a URL to disk.\n     */\n    public static void download(URL url, Path destination) throws IOException {\n        OkHttpClient client = new OkHttpClient();\n        Request request = new Request.Builder()\n                .url(url)\n                .build();\n\n        Response response = client.newCall(request).execute();\n        Files.write(destination, response.body().bytes());\n    }\n\n    public static String temporaryDirectory() {\n        return System.getProperty(\"java.io.tmpdir\");\n    }\n\n    public static void assertCollections(Collection<?> expected, Collection<?> actual) {\n        final StringBuilder out = new StringBuilder();\n        for (Object e : expected) {\n            if (actual.contains(e)) {\n                actual.remove(e);\n            } else {\n                out.append(\"Missing: \").append(e).append(LineEnding.SYSTEM);\n            }\n        }\n        for (Object a : actual) {\n            out.append(\"Unexpected: \").append(a).append(LineEnding.SYSTEM);\n        }\n\n        String s = out.toString();\n        if (s.isEmpty()) {\n            return;\n        }\n        fail(s);\n    }\n\n    public static void assertProblems(ParseResult<?> result, String... expectedArg) {\n        assertProblems(result.getProblems(), expectedArg);\n    }\n\n    public static void assertProblems(List<Problem> result, String... expectedArg) {\n        Set<String> actual = result.stream().map(Problem::toString).collect(Collectors.toSet());\n        Set<String> expected = new HashSet<>(asList(expectedArg));\n        assertCollections(expected, actual);\n    }\n\n    public static void assertNoProblems(ParseResult<?> result) {\n        assertProblems(result);\n    }\n\n    public static void assertExpressionValid(String expression) {\n        JavaParser javaParser = new JavaParser(new ParserConfiguration().setLanguageLevel(JAVA_9));\n        ParseResult<Expression> result = javaParser.parse(ParseStart.EXPRESSION, provider(expression));\n        assertTrue(result.isSuccessful(), result.getProblems().toString());\n    }\n\n    /**\n     * Assert that \"actual\" equals \"expected\", ignoring line separators.\n     * @deprecated Use {@link #assertEqualsStringIgnoringEol(String, String)}\n     */\n    @Deprecated\n    public static void assertEqualsNoEol(String expected, String actual) {\n        assertEqualsStringIgnoringEol(expected, actual);\n    }\n\n    /**\n     * Assert that \"actual\" equals \"expected\", ignoring line separators.\n     * @deprecated Use {@link #assertEqualsStringIgnoringEol(String, String, String)}\n     */\n    @Deprecated\n    public static void assertEqualsNoEol(String expected, String actual, String message) {\n        assertEqualsStringIgnoringEol(expected, actual, message);\n    }\n\n\n    /**\n     * Assert that \"actual\" equals \"expected\".\n     * <br>First checks if the content is equal ignoring line separators.\n     * <br>If this passes, then we check if the content is equal - if this fails then we can\n     *  advise that the difference is <em>only</em> in the line separators.\n     */\n    public static void assertEqualsString(String expected, String actual) {\n        assertEqualsString(expected, actual, \"\");\n    }\n\n    /**\n     * Assert that \"actual\" equals \"expected\".\n     * <br>First checks if the content is equal ignoring line separators.\n     * <br>If this passes, then we check if the content is equal - if this fails then we can\n     *  advise that the difference is <em>only</em> in the line separators.\n     */\n    public static void assertEqualsString(String expected, String actual, String message) {\n        // First test equality ignoring EOL chars\n        assertEqualsNoEol(expected, actual, message);\n\n        // If this passes but the next one fails, the failure is due only to EOL differences, allowing a more precise test failure message.\n        assertEquals(\n                expected,\n                actual,\n                message + String.format(\" -- failed due to line separator differences -- Expected: %s, but actual: %s (system eol: %s)\",\n                        LineEnding.detect(expected).escaped(),\n                        LineEnding.detect(actual).escaped(),\n                        LineEnding.SYSTEM.escaped()\n                )\n        );\n    }\n\n\n    /**\n     * Assert that \"actual\" equals \"expected\", ignoring line separators.\n     */\n    public static void assertEqualsStringIgnoringEol(String expected, String actual) {\n        assertEqualsString(\n                normalizeEolInTextBlock(expected, LineEnding.ARBITRARY),\n                normalizeEolInTextBlock(actual, LineEnding.ARBITRARY)\n        );\n    }\n\n    /**\n     * Assert that \"actual\" equals \"expected\", ignoring line separators.\n     */\n    public static void assertEqualsStringIgnoringEol(String expected, String actual, String message) {\n        assertEqualsString(\n                normalizeEolInTextBlock(expected, LineEnding.ARBITRARY),\n                normalizeEolInTextBlock(actual, LineEnding.ARBITRARY),\n                message\n        );\n    }\n\n\n    /**\n     * Assert that the given string is detected as having the given line separator.\n     */\n    public static void assertLineSeparator(String text, LineEnding expectedLineSeparator) {\n        LineEnding actualLineSeparator = LineEnding.detect(text);\n        assertEquals(expectedLineSeparator, actualLineSeparator);\n    }\n\n    /**\n     * Assert that the given string is detected as having the given line separator.\n     */\n    public static void assertLineSeparator(String text, LineEnding expectedLineSeparator, String message) {\n        LineEnding actualLineSeparator = LineEnding.detect(text);\n        assertEquals(expectedLineSeparator, actualLineSeparator, message);\n    }\n\n}\n",
        "diffSourceCodeSet": [
            "/**\n     * Assert that \"actual\" equals \"expected\", ignoring line separators.\n     */\n    public static void assertEqualsStringIgnoringEol(String expected, String actual, String message) {\n        assertEqualsString(\n                normalizeEolInTextBlock(expected, LineEnding.ARBITRARY),\n                normalizeEolInTextBlock(actual, LineEnding.ARBITRARY),\n                message\n        );\n    }"
        ],
        "invokedMethodSet": [],
        "sourceCodeAfterRefactoring": "/**\n     * Assert that \"actual\" equals \"expected\", ignoring line separators.\n     * @deprecated Use {@link #assertEqualsStringIgnoringEol(String, String, String)}\n     */\n    @Deprecated\n    public static void assertEqualsNoEol(String expected, String actual, String message) {\n        assertEqualsStringIgnoringEol(expected, actual, message);\n    }\n/**\n     * Assert that \"actual\" equals \"expected\", ignoring line separators.\n     */\n    public static void assertEqualsStringIgnoringEol(String expected, String actual, String message) {\n        assertEqualsString(\n                normalizeEolInTextBlock(expected, LineEnding.ARBITRARY),\n                normalizeEolInTextBlock(actual, LineEnding.ARBITRARY),\n                message\n        );\n    }",
        "diffSourceCode": "-  267:         ParseResult<Expression> result = javaParser.parse(ParseStart.EXPRESSION, provider(expression));\n-  268:         assertTrue(result.isSuccessful(), result.getProblems().toString());\n-  269:     }\n-  270: \n-  271:     /**\n-  272:      * Assert that \"actual\" equals \"expected\", and that any EOL characters in \"actual\" are correct for the platform.\n-  273:      */\n-  274:     public static void assertEqualsNoEol(String expected, String actual) {\n-  278:     /**\n-  279:      * Assert that \"actual\" equals \"expected\", and that any EOL characters in \"actual\" are correct for the platform.\n-  280:      */\n-  281:     public static void assertEqualsNoEol(String expected, String actual, String message) {\n-  282:         assertEquals(normalizeEolInTextBlock(expected, LineEnding.ARBITRARY), normalizeEolInTextBlock(actual, LineEnding.ARBITRARY), message);\n-  283:     }\n+  267:     /**\n+  268:      * Assert that \"actual\" equals \"expected\", ignoring line separators.\n+  269:      * @deprecated Use {@link #assertEqualsStringIgnoringEol(String, String, String)}\n+  270:      */\n+  271:     @Deprecated\n+  272:     public static void assertEqualsNoEol(String expected, String actual, String message) {\n+  273:         assertEqualsStringIgnoringEol(expected, actual, message);\n+  274:     }\n+  278:      * Assert that \"actual\" equals \"expected\".\n+  279:      * <br>First checks if the content is equal ignoring line separators.\n+  280:      * <br>If this passes, then we check if the content is equal - if this fails then we can\n+  281:      *  advise that the difference is <em>only</em> in the line separators.\n+  282:      */\n+  283:     public static void assertEqualsString(String expected, String actual) {\n+  320:     /**\n+  321:      * Assert that \"actual\" equals \"expected\", ignoring line separators.\n+  322:      */\n+  323:     public static void assertEqualsStringIgnoringEol(String expected, String actual, String message) {\n+  324:         assertEqualsString(\n+  325:                 normalizeEolInTextBlock(expected, LineEnding.ARBITRARY),\n+  326:                 normalizeEolInTextBlock(actual, LineEnding.ARBITRARY),\n+  327:                 message\n+  328:         );\n+  329:     }\n",
        "uniqueId": "339d45a5694b569dee7bab605eb700a564975b6c_278_283_320_329_267_274",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "testMethod": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 1.8
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tpublic assertEqualsStringIgnoringEol(expected String, actual String) : void extracted from public assertEqualsNoEol(expected String, actual String) : void in class com.github.javaparser.utils.TestUtils",
        "diffLocations": [
            {
                "filePath": "javaparser-core-testing/src/test/java/com/github/javaparser/utils/TestUtils.java",
                "startLine": 271,
                "endLine": 276,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "javaparser-core-testing/src/test/java/com/github/javaparser/utils/TestUtils.java",
                "startLine": 258,
                "endLine": 265,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "javaparser-core-testing/src/test/java/com/github/javaparser/utils/TestUtils.java",
                "startLine": 310,
                "endLine": 318,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "/**\n     * Assert that \"actual\" equals \"expected\", and that any EOL characters in \"actual\" are correct for the platform.\n     */\n    public static void assertEqualsNoEol(String expected, String actual) {\n        assertEquals(normalizeEolInTextBlock(expected, LineEnding.ARBITRARY), normalizeEolInTextBlock(actual, LineEnding.ARBITRARY));\n    }",
        "filePathBefore": "javaparser-core-testing/src/test/java/com/github/javaparser/utils/TestUtils.java",
        "isPureRefactoring": true,
        "commitId": "339d45a5694b569dee7bab605eb700a564975b6c",
        "packageNameBefore": "com.github.javaparser.utils",
        "classNameBefore": "com.github.javaparser.utils.TestUtils",
        "methodNameBefore": "com.github.javaparser.utils.TestUtils#assertEqualsNoEol",
        "classSignatureBefore": "public class TestUtils ",
        "methodNameBeforeSet": [
            "com.github.javaparser.utils.TestUtils#assertEqualsNoEol"
        ],
        "classNameBeforeSet": [
            "com.github.javaparser.utils.TestUtils"
        ],
        "classSignatureBeforeSet": [
            "public class TestUtils "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Overlapped refactoring - can be identical by undoing the overlapped refactoring\n- Extract Method-",
                "description": "Extract Method on top of the extracted method - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Copyright (C) 2007-2010 J\u00falio Vilmar Gesser.\n * Copyright (C) 2011, 2013-2019 The JavaParser Team.\n *\n * This file is part of JavaParser.\n *\n * JavaParser can be used either under the terms of\n * a) the GNU Lesser General Public License as published by\n *     the Free Software Foundation, either version 3 of the License, or\n *     (at your option) any later version.\n * b) the terms of the Apache License\n *\n * You should have received a copy of both licenses in LICENCE.LGPL and\n * LICENCE.APACHE. Please refer to those files for details.\n *\n * JavaParser is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n */\n\npackage com.github.javaparser.utils;\n\nimport com.github.javaparser.JavaParser;\nimport com.github.javaparser.ParseResult;\nimport com.github.javaparser.ParseStart;\nimport com.github.javaparser.ParserConfiguration;\nimport com.github.javaparser.Problem;\nimport com.github.javaparser.ast.expr.Expression;\nimport okhttp3.OkHttpClient;\nimport okhttp3.Request;\nimport okhttp3.Response;\n\nimport java.io.BufferedReader;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.net.URISyntaxException;\nimport java.net.URL;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.Collection;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.stream.Collectors;\nimport java.util.zip.ZipEntry;\nimport java.util.zip.ZipInputStream;\n\nimport static com.github.javaparser.ParserConfiguration.LanguageLevel.JAVA_9;\nimport static com.github.javaparser.Providers.provider;\nimport static com.github.javaparser.utils.CodeGenerationUtils.f;\nimport static com.github.javaparser.utils.Utils.normalizeEolInTextBlock;\nimport static java.nio.charset.StandardCharsets.UTF_8;\nimport static java.util.Arrays.asList;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class TestUtils {\n\n    /**\n     * Read the resource's contents line-by-line, and use the <strong>system's line separator</strong> to separate lines.\n     * Takes care of setting all the end of line character to platform specific ones.\n     * <br>\n     * <br>If you wish to read the file as-is, use {@link #readResource(String)} which reads the file stream character-by-character.\n     */\n    public static String readResourceUsingSystemEol(String resourceName) {\n        return readResource(resourceName, LineEnding.SYSTEM);\n    }\n\n    /**\n     * Read the resource's contents line-by-line, and use the <strong>given line separator</strong> to separate lines.\n     * <br>\n     * <br>If you wish to read the file as-is, use {@link #readResource(String)} which reads the file stream character-by-character.\n     */\n    public static String readResource(String resourceName, LineEnding lineEnding) {\n        if (resourceName.startsWith(\"/\")) {\n            resourceName = resourceName.substring(1);\n        }\n        try (final InputStream resourceAsStream = TestUtils.class.getClassLoader().getResourceAsStream(resourceName)) {\n            if (resourceAsStream == null) {\n                fail(\"resource not found by name: \" + resourceName);\n            }\n            try (final InputStreamReader reader = new InputStreamReader(resourceAsStream, UTF_8);\n                 final BufferedReader br = new BufferedReader(reader)) {\n                final StringBuilder builder = new StringBuilder(4096);\n                String line;\n                while ((line = br.readLine()) != null) {\n                    builder.append(line).append(lineEnding.toString());\n                }\n                return builder.toString();\n            }\n        } catch (IOException e) {\n            fail(e);\n            return null;\n        }\n    }\n\n\n    /**\n     * Read the resource's contents as-is.\n     * <br>\n     * <br>If you wish to specify the line endings,\n     * use {@link #readResourceUsingSystemEol(String)}\n     * or {@link #readResource(String, LineEnding)}\n     */\n    public static String readResource(String resourceName) {\n        if (resourceName.startsWith(\"/\")) {\n            resourceName = resourceName.substring(1);\n        }\n        try (final InputStream resourceAsStream = TestUtils.class.getClassLoader().getResourceAsStream(resourceName)) {\n            if (resourceAsStream == null) {\n                fail(\"not found: \" + resourceName);\n            }\n            try (final InputStreamReader reader = new InputStreamReader(resourceAsStream, UTF_8);\n                 final BufferedReader br = new BufferedReader(reader)\n            ) {\n                // Switched to reading char-by-char as opposed to line-by-line.\n                // This helps to retain the resource's own line endings.\n                final StringBuilder builder = new StringBuilder(4096);\n                for (int c = br.read(); c != -1; c = br.read()) {\n                    builder.append((char) c);\n                }\n                return builder.toString();\n            }\n        } catch (IOException e) {\n            fail(e);\n            return null;\n        }\n    }\n\n    /**\n     * Use this assertion if line endings are important, otherwise use {@link #assertEqualToTextResourceNoEol(String, String)}\n     */\n    public static void assertEqualToTextResource(String resourceName, String actual) {\n        String expected = readResourceUsingSystemEol(resourceName);\n\n        // First test equality ignoring EOL chars\n        assertEqualsNoEol(expected, actual);\n\n        // If this passes but the next one fails, the failure is due only to EOL differences, allowing a more precise test failure message.\n        assertEquals(\n                expected,\n                actual,\n                String.format(\"failed due to line separator differences -- Expected: %s, but actual: %s (system eol: %s)\",\n                        LineEnding.detect(expected).escaped(),\n                        LineEnding.detect(actual).escaped(),\n                        LineEnding.SYSTEM.escaped()\n                )\n        );\n    }\n\n    /**\n     * If line endings are important, use {@link #assertEqualToTextResource(String, String)}\n     */\n    public static void assertEqualToTextResourceNoEol(String resourceName, String actual) {\n        String expected = readResourceUsingSystemEol(resourceName);\n        assertEquals(expected, actual, \"failed due to line separator differences\");\n    }\n\n    public static String readTextResource(Class<?> relativeClass, String resourceName) {\n        final URL resourceAsStream = relativeClass.getResource(resourceName);\n        try {\n            byte[] bytes = Files.readAllBytes(Paths.get(resourceAsStream.toURI()));\n            return new String(bytes, UTF_8);\n        } catch (IOException | URISyntaxException e) {\n            fail(e);\n            return null;\n        }\n    }\n\n    public static void assertInstanceOf(Class<?> expectedType, Object instance) {\n        assertTrue(expectedType.isAssignableFrom(instance.getClass()), f(\"%s is not an instance of %s.\", instance.getClass(), expectedType));\n    }\n\n    /**\n     * Unzip a zip file into a directory.\n     */\n    public static void unzip(Path zipFile, Path outputFolder) throws IOException {\n        Log.info(\"Unzipping %s to %s\", () -> zipFile, () -> outputFolder);\n\n        final byte[] buffer = new byte[1024 * 1024];\n\n        outputFolder.toFile().mkdirs();\n\n        try (ZipInputStream zis = new ZipInputStream(new FileInputStream(zipFile.toFile()))) {\n            ZipEntry ze = zis.getNextEntry();\n\n            while (ze != null) {\n                final Path newFile = outputFolder.resolve(ze.getName());\n\n                if (ze.isDirectory()) {\n                    Log.trace(\"mkdir %s\", newFile::toAbsolutePath);\n                    newFile.toFile().mkdirs();\n                } else {\n                    Log.info(\"unzip %s\", newFile::toAbsolutePath);\n                    try (FileOutputStream fos = new FileOutputStream(newFile.toFile())) {\n                        int len;\n                        while ((len = zis.read(buffer)) > 0) {\n                            fos.write(buffer, 0, len);\n                        }\n                    }\n                }\n                zis.closeEntry();\n                ze = zis.getNextEntry();\n            }\n\n        }\n        Log.info(\"Unzipped %s to %s\", () -> zipFile, () -> outputFolder);\n    }\n\n    /**\n     * Download a file from a URL to disk.\n     */\n    public static void download(URL url, Path destination) throws IOException {\n        OkHttpClient client = new OkHttpClient();\n        Request request = new Request.Builder()\n                .url(url)\n                .build();\n\n        Response response = client.newCall(request).execute();\n        Files.write(destination, response.body().bytes());\n    }\n\n    public static String temporaryDirectory() {\n        return System.getProperty(\"java.io.tmpdir\");\n    }\n\n    public static void assertCollections(Collection<?> expected, Collection<?> actual) {\n        final StringBuilder out = new StringBuilder();\n        for (Object e : expected) {\n            if (actual.contains(e)) {\n                actual.remove(e);\n            } else {\n                out.append(\"Missing: \").append(e).append(LineEnding.SYSTEM);\n            }\n        }\n        for (Object a : actual) {\n            out.append(\"Unexpected: \").append(a).append(LineEnding.SYSTEM);\n        }\n\n        String s = out.toString();\n        if (s.isEmpty()) {\n            return;\n        }\n        fail(s);\n    }\n\n    public static void assertProblems(ParseResult<?> result, String... expectedArg) {\n        assertProblems(result.getProblems(), expectedArg);\n    }\n\n    public static void assertProblems(List<Problem> result, String... expectedArg) {\n        Set<String> actual = result.stream().map(Problem::toString).collect(Collectors.toSet());\n        Set<String> expected = new HashSet<>(asList(expectedArg));\n        assertCollections(expected, actual);\n    }\n\n    public static void assertNoProblems(ParseResult<?> result) {\n        assertProblems(result);\n    }\n\n    public static void assertExpressionValid(String expression) {\n        JavaParser javaParser = new JavaParser(new ParserConfiguration().setLanguageLevel(JAVA_9));\n        ParseResult<Expression> result = javaParser.parse(ParseStart.EXPRESSION, provider(expression));\n        assertTrue(result.isSuccessful(), result.getProblems().toString());\n    }\n\n    /**\n     * Assert that \"actual\" equals \"expected\", and that any EOL characters in \"actual\" are correct for the platform.\n     */\n    public static void assertEqualsNoEol(String expected, String actual) {\n        assertEquals(normalizeEolInTextBlock(expected, LineEnding.ARBITRARY), normalizeEolInTextBlock(actual, LineEnding.ARBITRARY));\n    }\n\n    /**\n     * Assert that \"actual\" equals \"expected\", and that any EOL characters in \"actual\" are correct for the platform.\n     */\n    public static void assertEqualsNoEol(String expected, String actual, String message) {\n        assertEquals(normalizeEolInTextBlock(expected, LineEnding.ARBITRARY), normalizeEolInTextBlock(actual, LineEnding.ARBITRARY), message);\n    }\n}\n",
        "filePathAfter": "javaparser-core-testing/src/test/java/com/github/javaparser/utils/TestUtils.java",
        "sourceCodeAfterForWhole": "/*\n * Copyright (C) 2007-2010 J\u00falio Vilmar Gesser.\n * Copyright (C) 2011, 2013-2019 The JavaParser Team.\n *\n * This file is part of JavaParser.\n *\n * JavaParser can be used either under the terms of\n * a) the GNU Lesser General Public License as published by\n *     the Free Software Foundation, either version 3 of the License, or\n *     (at your option) any later version.\n * b) the terms of the Apache License\n *\n * You should have received a copy of both licenses in LICENCE.LGPL and\n * LICENCE.APACHE. Please refer to those files for details.\n *\n * JavaParser is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n */\n\npackage com.github.javaparser.utils;\n\nimport com.github.javaparser.JavaParser;\nimport com.github.javaparser.ParseResult;\nimport com.github.javaparser.ParseStart;\nimport com.github.javaparser.ParserConfiguration;\nimport com.github.javaparser.Problem;\nimport com.github.javaparser.ast.expr.Expression;\nimport okhttp3.OkHttpClient;\nimport okhttp3.Request;\nimport okhttp3.Response;\n\nimport java.io.BufferedReader;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.net.URISyntaxException;\nimport java.net.URL;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.Collection;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.stream.Collectors;\nimport java.util.zip.ZipEntry;\nimport java.util.zip.ZipInputStream;\n\nimport static com.github.javaparser.ParserConfiguration.LanguageLevel.JAVA_9;\nimport static com.github.javaparser.Providers.provider;\nimport static com.github.javaparser.utils.CodeGenerationUtils.f;\nimport static com.github.javaparser.utils.Utils.normalizeEolInTextBlock;\nimport static java.nio.charset.StandardCharsets.UTF_8;\nimport static java.util.Arrays.asList;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class TestUtils {\n\n    /**\n     * Read the resource's contents line-by-line, and use the <strong>system's line separator</strong> to separate lines.\n     * Takes care of setting all the end of line character to platform specific ones.\n     * <br>\n     * <br>If you wish to read the file as-is, use {@link #readResource(String)} which reads the file stream character-by-character.\n     */\n    public static String readResourceUsingSystemEol(String resourceName) {\n        return readResource(resourceName, LineEnding.SYSTEM);\n    }\n\n    /**\n     * Read the resource's contents line-by-line, and use the <strong>given line separator</strong> to separate lines.\n     * <br>\n     * <br>If you wish to read the file as-is, use {@link #readResource(String)} which reads the file stream character-by-character.\n     */\n    public static String readResource(String resourceName, LineEnding lineEnding) {\n        if (resourceName.startsWith(\"/\")) {\n            resourceName = resourceName.substring(1);\n        }\n        try (final InputStream resourceAsStream = TestUtils.class.getClassLoader().getResourceAsStream(resourceName)) {\n            if (resourceAsStream == null) {\n                fail(\"resource not found by name: \" + resourceName);\n            }\n            try (final InputStreamReader reader = new InputStreamReader(resourceAsStream, UTF_8);\n                 final BufferedReader br = new BufferedReader(reader)) {\n                final StringBuilder builder = new StringBuilder(4096);\n                String line;\n                while ((line = br.readLine()) != null) {\n                    builder.append(line).append(lineEnding.toString());\n                }\n                return builder.toString();\n            }\n        } catch (IOException e) {\n            fail(e);\n            return null;\n        }\n    }\n\n\n    /**\n     * Read the resource's contents as-is.\n     * <br>\n     * <br>If you wish to specify the line endings,\n     * use {@link #readResourceUsingSystemEol(String)}\n     * or {@link #readResource(String, LineEnding)}\n     */\n    public static String readResource(String resourceName) {\n        if (resourceName.startsWith(\"/\")) {\n            resourceName = resourceName.substring(1);\n        }\n        try (final InputStream resourceAsStream = TestUtils.class.getClassLoader().getResourceAsStream(resourceName)) {\n            if (resourceAsStream == null) {\n                fail(\"not found: \" + resourceName);\n            }\n            try (final InputStreamReader reader = new InputStreamReader(resourceAsStream, UTF_8);\n                 final BufferedReader br = new BufferedReader(reader)\n            ) {\n                // Switched to reading char-by-char as opposed to line-by-line.\n                // This helps to retain the resource's own line endings.\n                final StringBuilder builder = new StringBuilder(4096);\n                for (int c = br.read(); c != -1; c = br.read()) {\n                    builder.append((char) c);\n                }\n                return builder.toString();\n            }\n        } catch (IOException e) {\n            fail(e);\n            return null;\n        }\n    }\n\n    /**\n     * Use this assertion if line endings are important, otherwise use {@link #assertEqualToTextResourceNoEol(String, String)}\n     */\n    public static void assertEqualToTextResource(String resourceName, String actual) {\n        String expected = readResourceUsingSystemEol(resourceName);\n        assertEqualsString(expected, actual);\n    }\n\n    /**\n     * If line endings are important, use {@link #assertEqualToTextResource(String, String)}\n     */\n    public static void assertEqualToTextResourceNoEol(String resourceName, String actual) {\n        String expected = readResourceUsingSystemEol(resourceName);\n        assertEqualsNoEol(expected, actual);\n    }\n\n    public static String readTextResource(Class<?> relativeClass, String resourceName) {\n        final URL resourceAsStream = relativeClass.getResource(resourceName);\n        try {\n            byte[] bytes = Files.readAllBytes(Paths.get(resourceAsStream.toURI()));\n            return new String(bytes, UTF_8);\n        } catch (IOException | URISyntaxException e) {\n            fail(e);\n            return null;\n        }\n    }\n\n    public static void assertInstanceOf(Class<?> expectedType, Object instance) {\n        assertTrue(expectedType.isAssignableFrom(instance.getClass()), f(\"%s is not an instance of %s.\", instance.getClass(), expectedType));\n    }\n\n    /**\n     * Unzip a zip file into a directory.\n     */\n    public static void unzip(Path zipFile, Path outputFolder) throws IOException {\n        Log.info(\"Unzipping %s to %s\", () -> zipFile, () -> outputFolder);\n\n        final byte[] buffer = new byte[1024 * 1024];\n\n        outputFolder.toFile().mkdirs();\n\n        try (ZipInputStream zis = new ZipInputStream(new FileInputStream(zipFile.toFile()))) {\n            ZipEntry ze = zis.getNextEntry();\n\n            while (ze != null) {\n                final Path newFile = outputFolder.resolve(ze.getName());\n\n                if (ze.isDirectory()) {\n                    Log.trace(\"mkdir %s\", newFile::toAbsolutePath);\n                    newFile.toFile().mkdirs();\n                } else {\n                    Log.info(\"unzip %s\", newFile::toAbsolutePath);\n                    try (FileOutputStream fos = new FileOutputStream(newFile.toFile())) {\n                        int len;\n                        while ((len = zis.read(buffer)) > 0) {\n                            fos.write(buffer, 0, len);\n                        }\n                    }\n                }\n                zis.closeEntry();\n                ze = zis.getNextEntry();\n            }\n\n        }\n        Log.info(\"Unzipped %s to %s\", () -> zipFile, () -> outputFolder);\n    }\n\n    /**\n     * Download a file from a URL to disk.\n     */\n    public static void download(URL url, Path destination) throws IOException {\n        OkHttpClient client = new OkHttpClient();\n        Request request = new Request.Builder()\n                .url(url)\n                .build();\n\n        Response response = client.newCall(request).execute();\n        Files.write(destination, response.body().bytes());\n    }\n\n    public static String temporaryDirectory() {\n        return System.getProperty(\"java.io.tmpdir\");\n    }\n\n    public static void assertCollections(Collection<?> expected, Collection<?> actual) {\n        final StringBuilder out = new StringBuilder();\n        for (Object e : expected) {\n            if (actual.contains(e)) {\n                actual.remove(e);\n            } else {\n                out.append(\"Missing: \").append(e).append(LineEnding.SYSTEM);\n            }\n        }\n        for (Object a : actual) {\n            out.append(\"Unexpected: \").append(a).append(LineEnding.SYSTEM);\n        }\n\n        String s = out.toString();\n        if (s.isEmpty()) {\n            return;\n        }\n        fail(s);\n    }\n\n    public static void assertProblems(ParseResult<?> result, String... expectedArg) {\n        assertProblems(result.getProblems(), expectedArg);\n    }\n\n    public static void assertProblems(List<Problem> result, String... expectedArg) {\n        Set<String> actual = result.stream().map(Problem::toString).collect(Collectors.toSet());\n        Set<String> expected = new HashSet<>(asList(expectedArg));\n        assertCollections(expected, actual);\n    }\n\n    public static void assertNoProblems(ParseResult<?> result) {\n        assertProblems(result);\n    }\n\n    public static void assertExpressionValid(String expression) {\n        JavaParser javaParser = new JavaParser(new ParserConfiguration().setLanguageLevel(JAVA_9));\n        ParseResult<Expression> result = javaParser.parse(ParseStart.EXPRESSION, provider(expression));\n        assertTrue(result.isSuccessful(), result.getProblems().toString());\n    }\n\n    /**\n     * Assert that \"actual\" equals \"expected\", ignoring line separators.\n     * @deprecated Use {@link #assertEqualsStringIgnoringEol(String, String)}\n     */\n    @Deprecated\n    public static void assertEqualsNoEol(String expected, String actual) {\n        assertEqualsStringIgnoringEol(expected, actual);\n    }\n\n    /**\n     * Assert that \"actual\" equals \"expected\", ignoring line separators.\n     * @deprecated Use {@link #assertEqualsStringIgnoringEol(String, String, String)}\n     */\n    @Deprecated\n    public static void assertEqualsNoEol(String expected, String actual, String message) {\n        assertEqualsStringIgnoringEol(expected, actual, message);\n    }\n\n\n    /**\n     * Assert that \"actual\" equals \"expected\".\n     * <br>First checks if the content is equal ignoring line separators.\n     * <br>If this passes, then we check if the content is equal - if this fails then we can\n     *  advise that the difference is <em>only</em> in the line separators.\n     */\n    public static void assertEqualsString(String expected, String actual) {\n        assertEqualsString(expected, actual, \"\");\n    }\n\n    /**\n     * Assert that \"actual\" equals \"expected\".\n     * <br>First checks if the content is equal ignoring line separators.\n     * <br>If this passes, then we check if the content is equal - if this fails then we can\n     *  advise that the difference is <em>only</em> in the line separators.\n     */\n    public static void assertEqualsString(String expected, String actual, String message) {\n        // First test equality ignoring EOL chars\n        assertEqualsNoEol(expected, actual, message);\n\n        // If this passes but the next one fails, the failure is due only to EOL differences, allowing a more precise test failure message.\n        assertEquals(\n                expected,\n                actual,\n                message + String.format(\" -- failed due to line separator differences -- Expected: %s, but actual: %s (system eol: %s)\",\n                        LineEnding.detect(expected).escaped(),\n                        LineEnding.detect(actual).escaped(),\n                        LineEnding.SYSTEM.escaped()\n                )\n        );\n    }\n\n\n    /**\n     * Assert that \"actual\" equals \"expected\", ignoring line separators.\n     */\n    public static void assertEqualsStringIgnoringEol(String expected, String actual) {\n        assertEqualsString(\n                normalizeEolInTextBlock(expected, LineEnding.ARBITRARY),\n                normalizeEolInTextBlock(actual, LineEnding.ARBITRARY)\n        );\n    }\n\n    /**\n     * Assert that \"actual\" equals \"expected\", ignoring line separators.\n     */\n    public static void assertEqualsStringIgnoringEol(String expected, String actual, String message) {\n        assertEqualsString(\n                normalizeEolInTextBlock(expected, LineEnding.ARBITRARY),\n                normalizeEolInTextBlock(actual, LineEnding.ARBITRARY),\n                message\n        );\n    }\n\n\n    /**\n     * Assert that the given string is detected as having the given line separator.\n     */\n    public static void assertLineSeparator(String text, LineEnding expectedLineSeparator) {\n        LineEnding actualLineSeparator = LineEnding.detect(text);\n        assertEquals(expectedLineSeparator, actualLineSeparator);\n    }\n\n    /**\n     * Assert that the given string is detected as having the given line separator.\n     */\n    public static void assertLineSeparator(String text, LineEnding expectedLineSeparator, String message) {\n        LineEnding actualLineSeparator = LineEnding.detect(text);\n        assertEquals(expectedLineSeparator, actualLineSeparator, message);\n    }\n\n}\n",
        "diffSourceCodeSet": [
            "/**\n     * Assert that \"actual\" equals \"expected\", ignoring line separators.\n     */\n    public static void assertEqualsStringIgnoringEol(String expected, String actual) {\n        assertEqualsString(\n                normalizeEolInTextBlock(expected, LineEnding.ARBITRARY),\n                normalizeEolInTextBlock(actual, LineEnding.ARBITRARY)\n        );\n    }"
        ],
        "invokedMethodSet": [],
        "sourceCodeAfterRefactoring": "/**\n     * Assert that \"actual\" equals \"expected\", ignoring line separators.\n     * @deprecated Use {@link #assertEqualsStringIgnoringEol(String, String)}\n     */\n    @Deprecated\n    public static void assertEqualsNoEol(String expected, String actual) {\n        assertEqualsStringIgnoringEol(expected, actual);\n    }\n/**\n     * Assert that \"actual\" equals \"expected\", ignoring line separators.\n     */\n    public static void assertEqualsStringIgnoringEol(String expected, String actual) {\n        assertEqualsString(\n                normalizeEolInTextBlock(expected, LineEnding.ARBITRARY),\n                normalizeEolInTextBlock(actual, LineEnding.ARBITRARY)\n        );\n    }",
        "diffSourceCode": "-  258:         assertCollections(expected, actual);\n-  259:     }\n-  260: \n-  261:     public static void assertNoProblems(ParseResult<?> result) {\n-  262:         assertProblems(result);\n-  263:     }\n-  264: \n-  265:     public static void assertExpressionValid(String expression) {\n-  271:     /**\n-  272:      * Assert that \"actual\" equals \"expected\", and that any EOL characters in \"actual\" are correct for the platform.\n-  273:      */\n-  274:     public static void assertEqualsNoEol(String expected, String actual) {\n-  275:         assertEquals(normalizeEolInTextBlock(expected, LineEnding.ARBITRARY), normalizeEolInTextBlock(actual, LineEnding.ARBITRARY));\n-  276:     }\n+  258:     /**\n+  259:      * Assert that \"actual\" equals \"expected\", ignoring line separators.\n+  260:      * @deprecated Use {@link #assertEqualsStringIgnoringEol(String, String)}\n+  261:      */\n+  262:     @Deprecated\n+  263:     public static void assertEqualsNoEol(String expected, String actual) {\n+  264:         assertEqualsStringIgnoringEol(expected, actual);\n+  265:     }\n+  271:     @Deprecated\n+  272:     public static void assertEqualsNoEol(String expected, String actual, String message) {\n+  273:         assertEqualsStringIgnoringEol(expected, actual, message);\n+  274:     }\n+  275: \n+  276: \n+  310:     /**\n+  311:      * Assert that \"actual\" equals \"expected\", ignoring line separators.\n+  312:      */\n+  313:     public static void assertEqualsStringIgnoringEol(String expected, String actual) {\n+  314:         assertEqualsString(\n+  315:                 normalizeEolInTextBlock(expected, LineEnding.ARBITRARY),\n+  316:                 normalizeEolInTextBlock(actual, LineEnding.ARBITRARY)\n+  317:         );\n+  318:     }\n",
        "uniqueId": "339d45a5694b569dee7bab605eb700a564975b6c_271_276_310_318_258_265",
        "moveFileExist": true,
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 1.8,
        "testResult": true,
        "coverageInfo": {
            "testMethod": {
                "missed": 0,
                "covered": 1
            }
        }
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tpackage process(provider UnicodeEscapeProcessingProvider) : String extracted from private read(source String) : String in class com.github.javaparser.UnicodeEscapeProcessingProviderTest",
        "diffLocations": [
            {
                "filePath": "javaparser-core-testing/src/test/java/com/github/javaparser/UnicodeEscapeProcessingProviderTest.java",
                "startLine": 123,
                "endLine": 140,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "javaparser-core-testing/src/test/java/com/github/javaparser/UnicodeEscapeProcessingProviderTest.java",
                "startLine": 123,
                "endLine": 125,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "javaparser-core-testing/src/test/java/com/github/javaparser/UnicodeEscapeProcessingProviderTest.java",
                "startLine": 133,
                "endLine": 148,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "private String read(String source) throws IOException {\n\t\tUnicodeEscapeProcessingProvider provider = new UnicodeEscapeProcessingProvider(10, \n\t\t\t\tnew StringProvider(source));\n\t\n\t\tStringBuilder result = new StringBuilder();\n\t\tchar[] buffer = new char[10];\n\t\twhile (true) {\n\t\t\tint direct = provider.read(buffer, 0, buffer.length);\n\t\t\tif (direct < 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tresult.append(buffer, 0, direct);\n\t\t}\n\t\t\n\t\tprovider.close();\n\t\n\t\treturn result.toString();\n\t}",
        "filePathBefore": "javaparser-core-testing/src/test/java/com/github/javaparser/UnicodeEscapeProcessingProviderTest.java",
        "isPureRefactoring": true,
        "commitId": "baf9003923057506e2518c688bc1e5d09d5052d6",
        "packageNameBefore": "com.github.javaparser",
        "classNameBefore": "com.github.javaparser.UnicodeEscapeProcessingProviderTest",
        "methodNameBefore": "com.github.javaparser.UnicodeEscapeProcessingProviderTest#read",
        "invokedMethod": "methodSignature: com.github.javaparser.UnicodeEscapeProcessingProvider#read\n methodBody: public int read(char[] buffer, final int offset, int len) throws IOException {\nint pos=offset;\nint stop=offset + len;\nwhile(pos < stop){int ch=nextOutputChar();\nif(ch < 0){if(pos == offset){return EOF;\n}{break;\n}}{buffer[pos++]=(char)ch;\n}}return pos - offset;\n}\nmethodSignature: com.github.javaparser.UnicodeEscapeProcessingProviderTest#read\n methodBody: private String read(String source) throws IOException {\nUnicodeEscapeProcessingProvider provider=new UnicodeEscapeProcessingProvider(10,new StringProvider(source));\nStringBuilder result=new StringBuilder();\nchar[] buffer=new char[10];\nwhile(true){int direct=provider.read(buffer,0,buffer.length);\nif(direct < 0){break;\n}result.append(buffer,0,direct);\n}provider.close();\nreturn result.toString();\n}\nmethodSignature: com.github.javaparser.UnicodeEscapeProcessingProvider#close\n methodBody: public void close() throws IOException {\n_input.close();\n}",
        "classSignatureBefore": "public class UnicodeEscapeProcessingProviderTest ",
        "methodNameBeforeSet": [
            "com.github.javaparser.UnicodeEscapeProcessingProviderTest#read"
        ],
        "classNameBeforeSet": [
            "com.github.javaparser.UnicodeEscapeProcessingProviderTest"
        ],
        "classSignatureBeforeSet": [
            "public class UnicodeEscapeProcessingProviderTest "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Copyright (C) 2019 The JavaParser Team.\n *\n * This file is part of JavaParser.\n *\n * JavaParser can be used either under the terms of\n * a) the GNU Lesser General Public License as published by\n *     the Free Software Foundation, either version 3 of the License, or\n *     (at your option) any later version.\n * b) the terms of the Apache License\n *\n * You should have received a copy of both licenses in LICENCE.LGPL and\n * LICENCE.APACHE. Please refer to those files for details.\n *\n * JavaParser is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n */\npackage com.github.javaparser;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport java.io.IOException;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * Test case for {@link UnicodeEscapeProcessingProvider}.\n */\npublic class UnicodeEscapeProcessingProviderTest {\n\n\t@Test\n\tvoid testUnicodeEscape() throws IOException {\n\t\tassertEquals(\"13\" + '\\u12aA' + \"98\", new String(read(\"13\\\\u12aA98\")));\n\t}\n\n\t@Test\n\tvoid testEscapedUnicodeEscape() throws IOException {\n\t\tassertEquals(\"13\\\\\\\\u12aA98\", new String(read(\"13\\\\\\\\u12aA98\")));\n\t}\n\t\n\t@Test\n\tvoid testUnicodeEscapeWithMultipleUs() throws IOException {\n\t\tassertEquals(\"13\" + '\\u12aA' + \"98\", new String(read(\"13\\\\uuuuuu12aA98\")));\n\t}\n\t\n\t@Test\n\tvoid testInputEndingInBackslash() throws IOException {\n\t\tassertEquals(\"foobar\\\\\", new String(read(\"foobar\\\\\")));\n\t}\n\t\n\t@Test\n\tvoid testInputEndingInBackslashU() throws IOException {\n\t\tassertEquals(\"foobar\\\\u\", new String(read(\"foobar\\\\u\")));\n\t}\n\t\n\t@Test\n\tvoid testInputEndingInBackslashUs() throws IOException {\n\t\tassertEquals(\"foobar\\\\uuuuuu\", new String(read(\"foobar\\\\uuuuuu\")));\n\t}\n\t\n\t@Test\n\tvoid testInputEndingInBackslashU1() throws IOException {\n\t\tassertEquals(\"foobar\\\\uA\", new String(read(\"foobar\\\\uA\")));\n\t}\n\t\n\t@Test\n\tvoid testInputEndingInBackslashU2() throws IOException {\n\t\tassertEquals(\"foobar\\\\uAB\", new String(read(\"foobar\\\\uAB\")));\n\t}\n\t\n\t@Test\n\tvoid testInputEndingInBackslashU3() throws IOException {\n\t\tassertEquals(\"foobar\\\\uABC\", new String(read(\"foobar\\\\uABC\")));\n\t}\n\t\n\t@Test\n\tvoid testInputEndingUnicodeEscape() throws IOException {\n\t\tassertEquals(\"foobar\\uABCD\", new String(read(\"foobar\\\\uABCD\")));\n\t}\n\t\n\t@Test\n\tvoid testEmptyInput() throws IOException {\n\t\tassertEquals(\"\", new String(read(\"\")));\n\t}\n\n\t@Test\n\tvoid testBadUnicodeEscape0() throws IOException {\n\t\tassertEquals(\"13\\\\ux\", new String(read(\"13\\\\ux\")));\n\t}\n\t\n\t@Test\n\tvoid testBadUnicodeEscape1() throws IOException {\n\t\tassertEquals(\"13\\\\u1x\", new String(read(\"13\\\\u1x\")));\n\t}\n\n\t@Test\n\tvoid testBadUnicodeEscape2() throws IOException {\n\t\tassertEquals(\"13\\\\u1Ax\", new String(read(\"13\\\\u1Ax\")));\n\t}\n\n\t@Test\n\tvoid testBadUnicodeEscape3() throws IOException {\n\t\tassertEquals(\"13\\\\u1ABx\", new String(read(\"13\\\\u1ABx\")));\n\t}\n\n\t@Test\n\tvoid testBadUnicodeEscapeMultipleUs() throws IOException {\n\t\tassertEquals(\"13\\\\uuuuuu1ABx\", new String(read(\"13\\\\uuuuuu1ABx\")));\n\t}\n\n\t@Test\n\tvoid testPushBackWithFullBuffer() throws IOException {\n\t\tassertEquals(\"12345678\\\\uuxxxxxxxxxxxxxxxxxxxxxxx\", new String(read(\"12345678\\\\uuxxxxxxxxxxxxxxxxxxxxxxx\")));\n\t}\n\t\n\t@Test\n\tvoid testPushBackWithBufferShift() throws IOException {\n\t\tassertEquals(\"12345678\\\\uuxx\", new String(read(\"12345678\\\\uuxx\")));\n\t}\n\t\n\tprivate String read(String source) throws IOException {\n\t\tUnicodeEscapeProcessingProvider provider = new UnicodeEscapeProcessingProvider(10, \n\t\t\t\tnew StringProvider(source));\n\t\n\t\tStringBuilder result = new StringBuilder();\n\t\tchar[] buffer = new char[10];\n\t\twhile (true) {\n\t\t\tint direct = provider.read(buffer, 0, buffer.length);\n\t\t\tif (direct < 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tresult.append(buffer, 0, direct);\n\t\t}\n\t\t\n\t\tprovider.close();\n\t\n\t\treturn result.toString();\n\t}\n}\n",
        "filePathAfter": "javaparser-core-testing/src/test/java/com/github/javaparser/UnicodeEscapeProcessingProviderTest.java",
        "sourceCodeAfterForWhole": "/*\n * Copyright (C) 2019 The JavaParser Team.\n *\n * This file is part of JavaParser.\n *\n * JavaParser can be used either under the terms of\n * a) the GNU Lesser General Public License as published by\n *     the Free Software Foundation, either version 3 of the License, or\n *     (at your option) any later version.\n * b) the terms of the Apache License\n *\n * You should have received a copy of both licenses in LICENCE.LGPL and\n * LICENCE.APACHE. Please refer to those files for details.\n *\n * JavaParser is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n */\npackage com.github.javaparser;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport java.io.IOException;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * Test case for {@link UnicodeEscapeProcessingProvider}.\n */\npublic class UnicodeEscapeProcessingProviderTest {\n\n\t@Test\n\tvoid testUnicodeEscape() throws IOException {\n\t\tassertEquals(\"13\" + '\\u12aA' + \"98\", new String(read(\"13\\\\u12aA98\")));\n\t}\n\n\t@Test\n\tvoid testEscapedUnicodeEscape() throws IOException {\n\t\tassertEquals(\"13\\\\\\\\u12aA98\", new String(read(\"13\\\\\\\\u12aA98\")));\n\t}\n\t\n\t@Test\n\tvoid testUnicodeEscapeWithMultipleUs() throws IOException {\n\t\tassertEquals(\"13\" + '\\u12aA' + \"98\", new String(read(\"13\\\\uuuuuu12aA98\")));\n\t}\n\t\n\t@Test\n\tvoid testInputEndingInBackslash() throws IOException {\n\t\tassertEquals(\"foobar\\\\\", new String(read(\"foobar\\\\\")));\n\t}\n\t\n\t@Test\n\tvoid testInputEndingInBackslashU() throws IOException {\n\t\tassertEquals(\"foobar\\\\u\", new String(read(\"foobar\\\\u\")));\n\t}\n\t\n\t@Test\n\tvoid testInputEndingInBackslashUs() throws IOException {\n\t\tassertEquals(\"foobar\\\\uuuuuu\", new String(read(\"foobar\\\\uuuuuu\")));\n\t}\n\t\n\t@Test\n\tvoid testInputEndingInBackslashU1() throws IOException {\n\t\tassertEquals(\"foobar\\\\uA\", new String(read(\"foobar\\\\uA\")));\n\t}\n\t\n\t@Test\n\tvoid testInputEndingInBackslashU2() throws IOException {\n\t\tassertEquals(\"foobar\\\\uAB\", new String(read(\"foobar\\\\uAB\")));\n\t}\n\t\n\t@Test\n\tvoid testInputEndingInBackslashU3() throws IOException {\n\t\tassertEquals(\"foobar\\\\uABC\", new String(read(\"foobar\\\\uABC\")));\n\t}\n\t\n\t@Test\n\tvoid testInputEndingUnicodeEscape() throws IOException {\n\t\tassertEquals(\"foobar\\uABCD\", new String(read(\"foobar\\\\uABCD\")));\n\t}\n\t\n\t@Test\n\tvoid testEmptyInput() throws IOException {\n\t\tassertEquals(\"\", new String(read(\"\")));\n\t}\n\n\t@Test\n\tvoid testBadUnicodeEscape0() throws IOException {\n\t\tassertEquals(\"13\\\\ux\", new String(read(\"13\\\\ux\")));\n\t}\n\t\n\t@Test\n\tvoid testBadUnicodeEscape1() throws IOException {\n\t\tassertEquals(\"13\\\\u1x\", new String(read(\"13\\\\u1x\")));\n\t}\n\n\t@Test\n\tvoid testBadUnicodeEscape2() throws IOException {\n\t\tassertEquals(\"13\\\\u1Ax\", new String(read(\"13\\\\u1Ax\")));\n\t}\n\n\t@Test\n\tvoid testBadUnicodeEscape3() throws IOException {\n\t\tassertEquals(\"13\\\\u1ABx\", new String(read(\"13\\\\u1ABx\")));\n\t}\n\n\t@Test\n\tvoid testBadUnicodeEscapeMultipleUs() throws IOException {\n\t\tassertEquals(\"13\\\\uuuuuu1ABx\", new String(read(\"13\\\\uuuuuu1ABx\")));\n\t}\n\n\t@Test\n\tvoid testPushBackWithFullBuffer() throws IOException {\n\t\tassertEquals(\"12345678\\\\uuxxxxxxxxxxxxxxxxxxxxxxx\", new String(read(\"12345678\\\\uuxxxxxxxxxxxxxxxxxxxxxxx\")));\n\t}\n\t\n\t@Test\n\tvoid testPushBackWithBufferShift() throws IOException {\n\t\tassertEquals(\"12345678\\\\uuxx\", new String(read(\"12345678\\\\uuxx\")));\n\t}\n\t\n\tstatic String read(String source) throws IOException {\n\t\treturn process(provider(source));\n\t}\n\n\tstatic UnicodeEscapeProcessingProvider provider(String source) {\n\t\tUnicodeEscapeProcessingProvider provider = new UnicodeEscapeProcessingProvider(10, \n\t\t\t\tnew StringProvider(source));\n\t\treturn provider;\n\t}\n\n\tstatic String process(UnicodeEscapeProcessingProvider provider)\n\t\t\tthrows IOException {\n\t\tStringBuilder result = new StringBuilder();\n\t\tchar[] buffer = new char[10];\n\t\twhile (true) {\n\t\t\tint direct = provider.read(buffer, 0, buffer.length);\n\t\t\tif (direct < 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tresult.append(buffer, 0, direct);\n\t\t}\n\t\t\n\t\tprovider.close();\n\t\n\t\treturn result.toString();\n\t}\n}\n",
        "diffSourceCodeSet": [
            "static String process(UnicodeEscapeProcessingProvider provider)\n\t\t\tthrows IOException {\n\t\tStringBuilder result = new StringBuilder();\n\t\tchar[] buffer = new char[10];\n\t\twhile (true) {\n\t\t\tint direct = provider.read(buffer, 0, buffer.length);\n\t\t\tif (direct < 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tresult.append(buffer, 0, direct);\n\t\t}\n\t\t\n\t\tprovider.close();\n\t\n\t\treturn result.toString();\n\t}"
        ],
        "invokedMethodSet": [
            "methodSignature: com.github.javaparser.UnicodeEscapeProcessingProvider#read\n methodBody: public int read(char[] buffer, final int offset, int len) throws IOException {\nint pos=offset;\nint stop=offset + len;\nwhile(pos < stop){int ch=nextOutputChar();\nif(ch < 0){if(pos == offset){return EOF;\n}{break;\n}}{buffer[pos++]=(char)ch;\n}}return pos - offset;\n}",
            "methodSignature: com.github.javaparser.UnicodeEscapeProcessingProviderTest#read\n methodBody: private String read(String source) throws IOException {\nUnicodeEscapeProcessingProvider provider=new UnicodeEscapeProcessingProvider(10,new StringProvider(source));\nStringBuilder result=new StringBuilder();\nchar[] buffer=new char[10];\nwhile(true){int direct=provider.read(buffer,0,buffer.length);\nif(direct < 0){break;\n}result.append(buffer,0,direct);\n}provider.close();\nreturn result.toString();\n}",
            "methodSignature: com.github.javaparser.UnicodeEscapeProcessingProvider#close\n methodBody: public void close() throws IOException {\n_input.close();\n}"
        ],
        "sourceCodeAfterRefactoring": "static String read(String source) throws IOException {\n\t\treturn process(provider(source));\n\t}\nstatic String process(UnicodeEscapeProcessingProvider provider)\n\t\t\tthrows IOException {\n\t\tStringBuilder result = new StringBuilder();\n\t\tchar[] buffer = new char[10];\n\t\twhile (true) {\n\t\t\tint direct = provider.read(buffer, 0, buffer.length);\n\t\t\tif (direct < 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tresult.append(buffer, 0, direct);\n\t\t}\n\t\t\n\t\tprovider.close();\n\t\n\t\treturn result.toString();\n\t}",
        "diffSourceCode": "-  123: \tprivate String read(String source) throws IOException {\n-  124: \t\tUnicodeEscapeProcessingProvider provider = new UnicodeEscapeProcessingProvider(10, \n-  125: \t\t\t\tnew StringProvider(source));\n-  126: \t\n-  127: \t\tStringBuilder result = new StringBuilder();\n-  128: \t\tchar[] buffer = new char[10];\n-  129: \t\twhile (true) {\n-  130: \t\t\tint direct = provider.read(buffer, 0, buffer.length);\n-  131: \t\t\tif (direct < 0) {\n-  132: \t\t\t\tbreak;\n-  133: \t\t\t}\n-  134: \t\t\tresult.append(buffer, 0, direct);\n-  135: \t\t}\n-  136: \t\t\n-  137: \t\tprovider.close();\n-  138: \t\n-  139: \t\treturn result.toString();\n-  140: \t}\n-  141: }\n+  123: \tstatic String read(String source) throws IOException {\n+  124: \t\treturn process(provider(source));\n+  125: \t}\n+  126: \n+  127: \tstatic UnicodeEscapeProcessingProvider provider(String source) {\n+  128: \t\tUnicodeEscapeProcessingProvider provider = new UnicodeEscapeProcessingProvider(10, \n+  129: \t\t\t\tnew StringProvider(source));\n+  130: \t\treturn provider;\n+  131: \t}\n+  132: \n+  133: \tstatic String process(UnicodeEscapeProcessingProvider provider)\n+  134: \t\t\tthrows IOException {\n+  135: \t\tStringBuilder result = new StringBuilder();\n+  136: \t\tchar[] buffer = new char[10];\n+  137: \t\twhile (true) {\n+  138: \t\t\tint direct = provider.read(buffer, 0, buffer.length);\n+  139: \t\t\tif (direct < 0) {\n+  140: \t\t\t\tbreak;\n+  141: \t\t\t}\n+  142: \t\t\tresult.append(buffer, 0, direct);\n+  143: \t\t}\n+  144: \t\t\n+  145: \t\tprovider.close();\n+  146: \t\n+  147: \t\treturn result.toString();\n+  148: \t}\n",
        "uniqueId": "baf9003923057506e2518c688bc1e5d09d5052d6_123_140_133_148_123_125",
        "moveFileExist": true,
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 1.8,
        "testResult": true,
        "coverageInfo": {
            "testMethod": {
                "missed": 0,
                "covered": 1
            }
        }
    },
    {
        "type": "Move Method",
        "description": "Move Method\tpublic topEnum() : void from class com.github.javaparser.ast.validator.Java1_2ValidatorTest to public topEnum() : void from class com.github.javaparser.ast.validator.Java5ValidatorTest",
        "diffLocations": [
            {
                "filePath": "javaparser-testing/src/test/java/com/github/javaparser/ast/validator/Java1_2ValidatorTest.java",
                "startLine": 110,
                "endLine": 129,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "javaparser-testing/src/test/java/com/github/javaparser/ast/validator/Java5ValidatorTest.java",
                "startLine": 81,
                "endLine": 100,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "@Test\n    public void topEnum() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(allModifiers + \"enum X{}\"));\n        assertProblems(result,\n                \"(line 1,col 1) Can have only one of 'public', 'protected', 'private'.\",\n                \"(line 1,col 1) Can have only one of 'final', 'abstract'.\",\n                \"(line 1,col 1) Can have only one of 'native', 'strictfp'.\",\n                \"(line 1,col 1) 'transient' is not allowed here.\",\n                \"(line 1,col 1) 'volatile' is not allowed here.\",\n                \"(line 1,col 1) 'synchronized' is not allowed here.\",\n                \"(line 1,col 1) 'default' is not allowed here.\",\n                \"(line 1,col 1) 'native' is not allowed here.\",\n                \"(line 1,col 1) 'transitive' is not allowed here.\",\n                \"(line 1,col 1) 'static' is not allowed here.\",\n                \"(line 1,col 1) 'abstract' is not allowed here.\",\n                \"(line 1,col 1) 'final' is not allowed here.\",\n                \"(line 1,col 1) 'private' is not allowed here.\",\n                \"(line 1,col 1) 'protected' is not allowed here.\"\n        );\n    }",
        "filePathBefore": "javaparser-testing/src/test/java/com/github/javaparser/ast/validator/Java1_2ValidatorTest.java",
        "isPureRefactoring": true,
        "commitId": "da6302311ef508f830434a997a9b61f24750c6a1",
        "packageNameBefore": "com.github.javaparser.ast.validator",
        "classNameBefore": "com.github.javaparser.ast.validator.Java1_2ValidatorTest",
        "methodNameBefore": "com.github.javaparser.ast.validator.Java1_2ValidatorTest#topEnum",
        "classSignatureBefore": "public class Java1_2ValidatorTest ",
        "methodNameBeforeSet": [
            "com.github.javaparser.ast.validator.Java1_2ValidatorTest#topEnum"
        ],
        "classNameBeforeSet": [
            "com.github.javaparser.ast.validator.Java1_2ValidatorTest"
        ],
        "classSignatureBeforeSet": [
            "public class Java1_2ValidatorTest "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "package com.github.javaparser.ast.validator;\n\nimport com.github.javaparser.JavaParser;\nimport com.github.javaparser.ParseResult;\nimport com.github.javaparser.ParserConfiguration;\nimport com.github.javaparser.ast.CompilationUnit;\nimport org.junit.Test;\n\nimport static com.github.javaparser.ParseStart.COMPILATION_UNIT;\nimport static com.github.javaparser.Providers.provider;\nimport static com.github.javaparser.utils.TestUtils.assertProblems;\n\npublic class Java1_2ValidatorTest {\n    public static final JavaParser javaParser = new JavaParser(new ParserConfiguration().setValidator(new Java1_2Validator()));\n\n    private final String allModifiers = \"public protected private abstract static final transient volatile synchronized native strictfp transitive default \";\n\n    @Test\n    public void topClass() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(allModifiers + \"class X{}\"));\n        assertProblems(result,\n                \"(line 1,col 1) Can have only one of 'public', 'protected', 'private'.\",\n                \"(line 1,col 1) Can have only one of 'final', 'abstract'.\",\n                \"(line 1,col 1) Can have only one of 'native', 'strictfp'.\",\n                \"(line 1,col 1) 'transient' is not allowed here.\",\n                \"(line 1,col 1) 'default' is not allowed here.\",\n                \"(line 1,col 1) 'volatile' is not allowed here.\",\n                \"(line 1,col 1) 'private' is not allowed here.\",\n                \"(line 1,col 1) 'protected' is not allowed here.\",\n                \"(line 1,col 1) 'synchronized' is not allowed here.\",\n                \"(line 1,col 1) 'native' is not allowed here.\",\n                \"(line 1,col 1) 'transitive' is not allowed here.\",\n                \"(line 1,col 1) 'static' is not allowed here.\"\n        );\n    }\n\n    @Test\n    public void nestedClass() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(\"class X{\" + allModifiers + \"class I{}}\"));\n        assertProblems(result,\n                \"(line 1,col 9) Can have only one of 'public', 'protected', 'private'.\",\n                \"(line 1,col 9) Can have only one of 'final', 'abstract'.\",\n                \"(line 1,col 9) Can have only one of 'native', 'strictfp'.\",\n                \"(line 1,col 9) 'transient' is not allowed here.\",\n                \"(line 1,col 9) 'default' is not allowed here.\",\n                \"(line 1,col 9) 'volatile' is not allowed here.\",\n                \"(line 1,col 9) 'synchronized' is not allowed here.\",\n                \"(line 1,col 9) 'native' is not allowed here.\",\n                \"(line 1,col 9) 'transitive' is not allowed here.\"\n        );\n    }\n\n    @Test\n    public void localClass() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(\"class X{ void x() {\" + allModifiers + \"class I{}}}\"));\n        assertProblems(result,\n                \"(line 1,col 20) Can have only one of 'public', 'protected', 'private'.\",\n                \"(line 1,col 20) Can have only one of 'final', 'abstract'.\",\n                \"(line 1,col 20) Can have only one of 'native', 'strictfp'.\",\n                \"(line 1,col 20) 'transient' is not allowed here.\",\n                \"(line 1,col 20) 'volatile' is not allowed here.\",\n                \"(line 1,col 20) 'default' is not allowed here.\",\n                \"(line 1,col 20) 'synchronized' is not allowed here.\",\n                \"(line 1,col 20) 'native' is not allowed here.\",\n                \"(line 1,col 20) 'transitive' is not allowed here.\",\n                \"(line 1,col 20) 'static' is not allowed here.\",\n                \"(line 1,col 20) 'public' is not allowed here.\",\n                \"(line 1,col 20) 'private' is not allowed here.\",\n                \"(line 1,col 20) 'protected' is not allowed here.\"\n        );\n    }\n\n    @Test\n    public void topInterface() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(allModifiers + \"interface X{}\"));\n        assertProblems(result,\n                \"(line 1,col 1) Can have only one of 'public', 'protected', 'private'.\",\n                \"(line 1,col 1) Can have only one of 'final', 'abstract'.\",\n                \"(line 1,col 1) Can have only one of 'native', 'strictfp'.\",\n                \"(line 1,col 1) 'transient' is not allowed here.\",\n                \"(line 1,col 1) 'volatile' is not allowed here.\",\n                \"(line 1,col 1) 'default' is not allowed here.\",\n                \"(line 1,col 1) 'synchronized' is not allowed here.\",\n                \"(line 1,col 1) 'native' is not allowed here.\",\n                \"(line 1,col 1) 'transitive' is not allowed here.\",\n                \"(line 1,col 1) 'static' is not allowed here.\",\n                \"(line 1,col 1) 'final' is not allowed here.\",\n                \"(line 1,col 1) 'private' is not allowed here.\",\n                \"(line 1,col 1) 'protected' is not allowed here.\"\n        );\n    }\n\n    @Test\n    public void nestedInterface() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(\"class X{\" + allModifiers + \"interface I{}}\"));\n        assertProblems(result,\n                \"(line 1,col 9) Can have only one of 'public', 'protected', 'private'.\",\n                \"(line 1,col 9) Can have only one of 'final', 'abstract'.\",\n                \"(line 1,col 9) Can have only one of 'native', 'strictfp'.\",\n                \"(line 1,col 9) 'transient' is not allowed here.\",\n                \"(line 1,col 9) 'volatile' is not allowed here.\",\n                \"(line 1,col 9) 'default' is not allowed here.\",\n                \"(line 1,col 9) 'final' is not allowed here.\",\n                \"(line 1,col 9) 'synchronized' is not allowed here.\",\n                \"(line 1,col 9) 'native' is not allowed here.\",\n                \"(line 1,col 9) 'transitive' is not allowed here.\"\n        );\n    }\n\n    @Test\n    public void topEnum() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(allModifiers + \"enum X{}\"));\n        assertProblems(result,\n                \"(line 1,col 1) Can have only one of 'public', 'protected', 'private'.\",\n                \"(line 1,col 1) Can have only one of 'final', 'abstract'.\",\n                \"(line 1,col 1) Can have only one of 'native', 'strictfp'.\",\n                \"(line 1,col 1) 'transient' is not allowed here.\",\n                \"(line 1,col 1) 'volatile' is not allowed here.\",\n                \"(line 1,col 1) 'synchronized' is not allowed here.\",\n                \"(line 1,col 1) 'default' is not allowed here.\",\n                \"(line 1,col 1) 'native' is not allowed here.\",\n                \"(line 1,col 1) 'transitive' is not allowed here.\",\n                \"(line 1,col 1) 'static' is not allowed here.\",\n                \"(line 1,col 1) 'abstract' is not allowed here.\",\n                \"(line 1,col 1) 'final' is not allowed here.\",\n                \"(line 1,col 1) 'private' is not allowed here.\",\n                \"(line 1,col 1) 'protected' is not allowed here.\"\n        );\n    }\n\n    @Test\n    public void nestedEnum() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(\"class X{\" + allModifiers + \"enum I{}}\"));\n        assertProblems(result,\n                \"(line 1,col 9) Can have only one of 'public', 'protected', 'private'.\",\n                \"(line 1,col 9) Can have only one of 'final', 'abstract'.\",\n                \"(line 1,col 9) Can have only one of 'native', 'strictfp'.\",\n                \"(line 1,col 9) 'transient' is not allowed here.\",\n                \"(line 1,col 9) 'volatile' is not allowed here.\",\n                \"(line 1,col 9) 'default' is not allowed here.\",\n                \"(line 1,col 9) 'abstract' is not allowed here.\",\n                \"(line 1,col 9) 'final' is not allowed here.\",\n                \"(line 1,col 9) 'synchronized' is not allowed here.\",\n                \"(line 1,col 9) 'native' is not allowed here.\",\n                \"(line 1,col 9) 'transitive' is not allowed here.\"\n        );\n    }\n    @Test\n    public void moduleRequires() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(\"module x{requires \" + allModifiers + \" a;}\"));\n        assertProblems(result,\n                \"(line 1,col 10) Can have only one of 'public', 'protected', 'private'.\",\n                \"(line 1,col 10) Can have only one of 'final', 'abstract'.\",\n                \"(line 1,col 10) Can have only one of 'native', 'strictfp'.\",\n                \"(line 1,col 10) 'transient' is not allowed here.\",\n                \"(line 1,col 10) 'volatile' is not allowed here.\",\n                \"(line 1,col 10) 'final' is not allowed here.\",\n                \"(line 1,col 10) 'synchronized' is not allowed here.\",\n                \"(line 1,col 10) 'default' is not allowed here.\",\n                \"(line 1,col 10) 'native' is not allowed here.\",\n                \"(line 1,col 10) 'private' is not allowed here.\",\n                \"(line 1,col 10) 'protected' is not allowed here.\",\n                \"(line 1,col 10) 'strictfp' is not allowed here.\",\n                \"(line 1,col 10) 'abstract' is not allowed here.\",\n                \"(line 1,col 10) 'public' is not allowed here.\"\n        );\n    }\n\n    @Test\n    public void constructor() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(\"class X{\" + allModifiers + \"X(){};}\"));\n        assertProblems(result,\n                \"(line 1,col 9) Can have only one of 'public', 'protected', 'private'.\",\n                \"(line 1,col 9) Can have only one of 'final', 'abstract'.\",\n                \"(line 1,col 9) Can have only one of 'native', 'strictfp'.\",\n                \"(line 1,col 9) 'transient' is not allowed here.\",\n                \"(line 1,col 9) 'volatile' is not allowed here.\",\n                \"(line 1,col 9) 'final' is not allowed here.\",\n                \"(line 1,col 9) 'synchronized' is not allowed here.\",\n                \"(line 1,col 9) 'default' is not allowed here.\",\n                \"(line 1,col 9) 'native' is not allowed here.\",\n                \"(line 1,col 9) 'strictfp' is not allowed here.\",\n                \"(line 1,col 9) 'abstract' is not allowed here.\",\n                \"(line 1,col 9) 'static' is not allowed here.\",\n                \"(line 1,col 9) 'transitive' is not allowed here.\"\n        );\n    }\n\n    @Test\n    public void constructorParameter() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(\"class X{X(\" + allModifiers + \" int i){};}\"));\n        assertProblems(result,\n                \"(line 1,col 11) Can have only one of 'public', 'protected', 'private'.\",\n                \"(line 1,col 11) Can have only one of 'final', 'abstract'.\",\n                \"(line 1,col 11) Can have only one of 'native', 'strictfp'.\",\n                \"(line 1,col 11) 'transient' is not allowed here.\",\n                \"(line 1,col 11) 'volatile' is not allowed here.\",\n                \"(line 1,col 11) 'synchronized' is not allowed here.\",\n                \"(line 1,col 11) 'native' is not allowed here.\",\n                \"(line 1,col 11) 'strictfp' is not allowed here.\",\n                \"(line 1,col 11) 'default' is not allowed here.\",\n                \"(line 1,col 11) 'abstract' is not allowed here.\",\n                \"(line 1,col 11) 'static' is not allowed here.\",\n                \"(line 1,col 11) 'transitive' is not allowed here.\",\n                \"(line 1,col 11) 'private' is not allowed here.\",\n                \"(line 1,col 11) 'public' is not allowed here.\",\n                \"(line 1,col 11) 'protected' is not allowed here.\"\n        );\n    }\n\n    @Test\n    public void classMethod() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(\"class X{\" + allModifiers + \"int x(){};}\"));\n        assertProblems(result,\n                \"(line 1,col 9) Can have only one of 'public', 'protected', 'private'.\",\n                \"(line 1,col 9) Can have only one of 'final', 'abstract'.\",\n                \"(line 1,col 9) Can have only one of 'native', 'strictfp'.\",\n                \"(line 1,col 9) Cannot be 'abstract' and also 'private', 'static', 'final', 'native', 'strictfp', 'synchronized'.\",\n                \"(line 1,col 9) 'transient' is not allowed here.\",\n                \"(line 1,col 9) 'default' is not allowed here.\",\n                \"(line 1,col 9) 'volatile' is not allowed here.\",\n                \"(line 1,col 9) 'transitive' is not allowed here.\"\n        );\n    }\n\n    @Test\n    public void interfaceMethod() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(\"interface X{\" + allModifiers + \"int x(){};}\"));\n        assertProblems(result,\n                \"(line 1,col 13) Can have only one of 'public', 'protected', 'private'.\",\n                \"(line 1,col 13) Can have only one of 'final', 'abstract'.\",\n                \"(line 1,col 13) Can have only one of 'native', 'strictfp'.\",\n                \"(line 1,col 13) Cannot be 'abstract' and also 'private', 'static', 'final', 'native', 'strictfp', 'synchronized'.\",\n                \"(line 1,col 13) 'transient' is not allowed here.\",\n                \"(line 1,col 13) 'volatile' is not allowed here.\",\n                \"(line 1,col 13) 'default' is not allowed here.\",\n                \"(line 1,col 13) 'transitive' is not allowed here.\"\n        );\n    }\n\n    @Test\n    public void methodParameter() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(\"class X{int x(\" + allModifiers + \" int i){};}\"));\n        assertProblems(result,\n                \"(line 1,col 15) Can have only one of 'public', 'protected', 'private'.\",\n                \"(line 1,col 15) Can have only one of 'final', 'abstract'.\",\n                \"(line 1,col 15) Can have only one of 'native', 'strictfp'.\",\n                \"(line 1,col 15) 'transient' is not allowed here.\",\n                \"(line 1,col 15) 'volatile' is not allowed here.\",\n                \"(line 1,col 15) 'synchronized' is not allowed here.\",\n                \"(line 1,col 15) 'native' is not allowed here.\",\n                \"(line 1,col 15) 'strictfp' is not allowed here.\",\n                \"(line 1,col 15) 'abstract' is not allowed here.\",\n                \"(line 1,col 15) 'default' is not allowed here.\",\n                \"(line 1,col 15) 'static' is not allowed here.\",\n                \"(line 1,col 15) 'transitive' is not allowed here.\",\n                \"(line 1,col 15) 'private' is not allowed here.\",\n                \"(line 1,col 15) 'public' is not allowed here.\",\n                \"(line 1,col 15) 'protected' is not allowed here.\"\n        );\n    }\n\n    @Test\n    public void field() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(\"class X{\" + allModifiers + \"int i;}\"));\n        assertProblems(result,\n                \"(line 1,col 9) Can have only one of 'public', 'protected', 'private'.\",\n                \"(line 1,col 9) Can have only one of 'final', 'abstract'.\",\n                \"(line 1,col 9) Can have only one of 'native', 'strictfp'.\",\n                \"(line 1,col 9) 'synchronized' is not allowed here.\",\n                \"(line 1,col 9) 'native' is not allowed here.\",\n                \"(line 1,col 9) 'strictfp' is not allowed here.\",\n                \"(line 1,col 9) 'default' is not allowed here.\",\n                \"(line 1,col 9) 'abstract' is not allowed here.\",\n                \"(line 1,col 9) 'transitive' is not allowed here.\"\n        );\n    }\n\n    @Test\n    public void localVariable() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(\"class X{int x(){\" + allModifiers + \"int i;}}\"));\n        assertProblems(result,\n                \"(line 1,col 17) Can have only one of 'public', 'protected', 'private'.\",\n                \"(line 1,col 17) Can have only one of 'final', 'abstract'.\",\n                \"(line 1,col 17) Can have only one of 'native', 'strictfp'.\",\n                \"(line 1,col 17) 'transient' is not allowed here.\",\n                \"(line 1,col 17) 'volatile' is not allowed here.\",\n                \"(line 1,col 17) 'synchronized' is not allowed here.\",\n                \"(line 1,col 17) 'native' is not allowed here.\",\n                \"(line 1,col 17) 'default' is not allowed here.\",\n                \"(line 1,col 17) 'strictfp' is not allowed here.\",\n                \"(line 1,col 17) 'abstract' is not allowed here.\",\n                \"(line 1,col 17) 'static' is not allowed here.\",\n                \"(line 1,col 17) 'transitive' is not allowed here.\",\n                \"(line 1,col 17) 'private' is not allowed here.\",\n                \"(line 1,col 17) 'public' is not allowed here.\",\n                \"(line 1,col 17) 'protected' is not allowed here.\"\n        );\n    }\n\n    @Test\n    public void catchParameter() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(\"class X{int x(){ try{}catch(\"+ allModifiers +\" Integer x){}}}\"));\n        assertProblems(result,\n                \"(line 1,col 144) Can have only one of 'public', 'protected', 'private'.\",\n                \"(line 1,col 144) Can have only one of 'final', 'abstract'.\",\n                \"(line 1,col 144) Can have only one of 'native', 'strictfp'.\",\n                \"(line 1,col 144) 'transient' is not allowed here.\",\n                \"(line 1,col 144) 'volatile' is not allowed here.\",\n                \"(line 1,col 144) 'synchronized' is not allowed here.\",\n                \"(line 1,col 144) 'native' is not allowed here.\",\n                \"(line 1,col 144) 'default' is not allowed here.\",\n                \"(line 1,col 144) 'strictfp' is not allowed here.\",\n                \"(line 1,col 144) 'abstract' is not allowed here.\",\n                \"(line 1,col 144) 'static' is not allowed here.\",\n                \"(line 1,col 144) 'transitive' is not allowed here.\",\n                \"(line 1,col 144) 'private' is not allowed here.\",\n                \"(line 1,col 144) 'public' is not allowed here.\",\n                \"(line 1,col 144) 'protected' is not allowed here.\"\n        );\n    }\n}\n",
        "filePathAfter": "javaparser-testing/src/test/java/com/github/javaparser/ast/validator/Java5ValidatorTest.java",
        "sourceCodeAfterForWhole": "package com.github.javaparser.ast.validator;\n\nimport com.github.javaparser.JavaParser;\nimport com.github.javaparser.ParseResult;\nimport com.github.javaparser.ParserConfiguration;\nimport com.github.javaparser.ast.CompilationUnit;\nimport org.junit.Test;\n\nimport static com.github.javaparser.ParseStart.COMPILATION_UNIT;\nimport static com.github.javaparser.Providers.provider;\nimport static com.github.javaparser.ast.validator.Java1_1ValidatorTest.allModifiers;\nimport static com.github.javaparser.utils.TestUtils.assertProblems;\n\npublic class Java5ValidatorTest {\n    public static final JavaParser javaParser = new JavaParser(new ParserConfiguration().setValidator(new Java5Validator()));\n\n    @Test\n    public void genericsWithoutDiamond() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(\"class X<A>{List<String> b = new ArrayList<>();}\"));\n        assertProblems(result, \"(line 1,col 33) The diamond operator is not supported.\");\n    }\n\n    @Test\n    public void topAnnotationDeclaration() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(allModifiers + \"@interface X{}\"));\n        assertProblems(result,\n                \"(line 1,col 1) Can have only one of 'public', 'protected', 'private'.\",\n                \"(line 1,col 1) Can have only one of 'final', 'abstract'.\",\n                \"(line 1,col 1) Can have only one of 'native', 'strictfp'.\",\n                \"(line 1,col 1) 'transient' is not allowed here.\",\n                \"(line 1,col 1) 'volatile' is not allowed here.\",\n                \"(line 1,col 1) 'synchronized' is not allowed here.\",\n                \"(line 1,col 1) 'default' is not allowed here.\",\n                \"(line 1,col 1) 'native' is not allowed here.\",\n                \"(line 1,col 1) 'transitive' is not allowed here.\",\n                \"(line 1,col 1) 'static' is not allowed here.\",\n                \"(line 1,col 1) 'final' is not allowed here.\",\n                \"(line 1,col 1) 'private' is not allowed here.\",\n                \"(line 1,col 1) 'protected' is not allowed here.\"\n        );\n    }\n\n    @Test\n    public void nestedAnnotationDeclaration() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(\"class X{\" + allModifiers + \"@interface I{}}\"));\n        assertProblems(result,\n                \"(line 1,col 9) Can have only one of 'public', 'protected', 'private'.\",\n                \"(line 1,col 9) Can have only one of 'final', 'abstract'.\",\n                \"(line 1,col 9) Can have only one of 'native', 'strictfp'.\",\n                \"(line 1,col 9) 'transient' is not allowed here.\",\n                \"(line 1,col 9) 'volatile' is not allowed here.\",\n                \"(line 1,col 9) 'default' is not allowed here.\",\n                \"(line 1,col 9) 'final' is not allowed here.\",\n                \"(line 1,col 9) 'synchronized' is not allowed here.\",\n                \"(line 1,col 9) 'native' is not allowed here.\",\n                \"(line 1,col 9) 'transitive' is not allowed here.\"\n        );\n    }\n\n    @Test\n    public void annotationMember() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(\"@interface X{\" + allModifiers + \"int x();}\"));\n        assertProblems(result,\n                \"(line 1,col 14) Can have only one of 'public', 'protected', 'private'.\",\n                \"(line 1,col 14) Can have only one of 'final', 'abstract'.\",\n                \"(line 1,col 14) Can have only one of 'native', 'strictfp'.\",\n                \"(line 1,col 14) 'transient' is not allowed here.\",\n                \"(line 1,col 14) 'volatile' is not allowed here.\",\n                \"(line 1,col 14) 'final' is not allowed here.\",\n                \"(line 1,col 14) 'synchronized' is not allowed here.\",\n                \"(line 1,col 14) 'default' is not allowed here.\",\n                \"(line 1,col 14) 'native' is not allowed here.\",\n                \"(line 1,col 14) 'protected' is not allowed here.\",\n                \"(line 1,col 14) 'private' is not allowed here.\",\n                \"(line 1,col 14) 'strictfp' is not allowed here.\",\n                \"(line 1,col 14) 'static' is not allowed here.\",\n                \"(line 1,col 14) 'transitive' is not allowed here.\"\n        );\n    }\n\n    @Test\n    public void topEnum() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(allModifiers + \"enum X{}\"));\n        assertProblems(result,\n                \"(line 1,col 1) Can have only one of 'public', 'protected', 'private'.\",\n                \"(line 1,col 1) Can have only one of 'final', 'abstract'.\",\n                \"(line 1,col 1) Can have only one of 'native', 'strictfp'.\",\n                \"(line 1,col 1) 'transient' is not allowed here.\",\n                \"(line 1,col 1) 'volatile' is not allowed here.\",\n                \"(line 1,col 1) 'synchronized' is not allowed here.\",\n                \"(line 1,col 1) 'default' is not allowed here.\",\n                \"(line 1,col 1) 'native' is not allowed here.\",\n                \"(line 1,col 1) 'transitive' is not allowed here.\",\n                \"(line 1,col 1) 'static' is not allowed here.\",\n                \"(line 1,col 1) 'abstract' is not allowed here.\",\n                \"(line 1,col 1) 'final' is not allowed here.\",\n                \"(line 1,col 1) 'private' is not allowed here.\",\n                \"(line 1,col 1) 'protected' is not allowed here.\"\n        );\n    }\n\n    @Test\n    public void nestedEnum() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(\"class X{\" + allModifiers + \"enum I{}}\"));\n        assertProblems(result,\n                \"(line 1,col 9) Can have only one of 'public', 'protected', 'private'.\",\n                \"(line 1,col 9) Can have only one of 'final', 'abstract'.\",\n                \"(line 1,col 9) Can have only one of 'native', 'strictfp'.\",\n                \"(line 1,col 9) 'transient' is not allowed here.\",\n                \"(line 1,col 9) 'volatile' is not allowed here.\",\n                \"(line 1,col 9) 'default' is not allowed here.\",\n                \"(line 1,col 9) 'abstract' is not allowed here.\",\n                \"(line 1,col 9) 'final' is not allowed here.\",\n                \"(line 1,col 9) 'synchronized' is not allowed here.\",\n                \"(line 1,col 9) 'native' is not allowed here.\",\n                \"(line 1,col 9) 'transitive' is not allowed here.\"\n        );\n    }\n\n}\n",
        "diffSourceCodeSet": [],
        "invokedMethodSet": [],
        "sourceCodeAfterRefactoring": "@Test\n    public void topEnum() {\n        ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(allModifiers + \"enum X{}\"));\n        assertProblems(result,\n                \"(line 1,col 1) Can have only one of 'public', 'protected', 'private'.\",\n                \"(line 1,col 1) Can have only one of 'final', 'abstract'.\",\n                \"(line 1,col 1) Can have only one of 'native', 'strictfp'.\",\n                \"(line 1,col 1) 'transient' is not allowed here.\",\n                \"(line 1,col 1) 'volatile' is not allowed here.\",\n                \"(line 1,col 1) 'synchronized' is not allowed here.\",\n                \"(line 1,col 1) 'default' is not allowed here.\",\n                \"(line 1,col 1) 'native' is not allowed here.\",\n                \"(line 1,col 1) 'transitive' is not allowed here.\",\n                \"(line 1,col 1) 'static' is not allowed here.\",\n                \"(line 1,col 1) 'abstract' is not allowed here.\",\n                \"(line 1,col 1) 'final' is not allowed here.\",\n                \"(line 1,col 1) 'private' is not allowed here.\",\n                \"(line 1,col 1) 'protected' is not allowed here.\"\n        );\n    }",
        "diffSourceCode": "-   81:                 \"(line 1,col 1) 'volatile' is not allowed here.\",\n-   82:                 \"(line 1,col 1) 'default' is not allowed here.\",\n-   83:                 \"(line 1,col 1) 'synchronized' is not allowed here.\",\n-   84:                 \"(line 1,col 1) 'native' is not allowed here.\",\n-   85:                 \"(line 1,col 1) 'transitive' is not allowed here.\",\n-   86:                 \"(line 1,col 1) 'static' is not allowed here.\",\n-   87:                 \"(line 1,col 1) 'final' is not allowed here.\",\n-   88:                 \"(line 1,col 1) 'private' is not allowed here.\",\n-   89:                 \"(line 1,col 1) 'protected' is not allowed here.\"\n-   90:         );\n-   91:     }\n-   92: \n-   93:     @Test\n-   94:     public void nestedInterface() {\n-   95:         ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(\"class X{\" + allModifiers + \"interface I{}}\"));\n-   96:         assertProblems(result,\n-   97:                 \"(line 1,col 9) Can have only one of 'public', 'protected', 'private'.\",\n-   98:                 \"(line 1,col 9) Can have only one of 'final', 'abstract'.\",\n-   99:                 \"(line 1,col 9) Can have only one of 'native', 'strictfp'.\",\n-  100:                 \"(line 1,col 9) 'transient' is not allowed here.\",\n-  110:     @Test\n-  111:     public void topEnum() {\n-  112:         ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(allModifiers + \"enum X{}\"));\n-  113:         assertProblems(result,\n-  114:                 \"(line 1,col 1) Can have only one of 'public', 'protected', 'private'.\",\n-  115:                 \"(line 1,col 1) Can have only one of 'final', 'abstract'.\",\n-  116:                 \"(line 1,col 1) Can have only one of 'native', 'strictfp'.\",\n-  117:                 \"(line 1,col 1) 'transient' is not allowed here.\",\n-  118:                 \"(line 1,col 1) 'volatile' is not allowed here.\",\n-  119:                 \"(line 1,col 1) 'synchronized' is not allowed here.\",\n-  120:                 \"(line 1,col 1) 'default' is not allowed here.\",\n-  121:                 \"(line 1,col 1) 'native' is not allowed here.\",\n-  122:                 \"(line 1,col 1) 'transitive' is not allowed here.\",\n-  123:                 \"(line 1,col 1) 'static' is not allowed here.\",\n-  124:                 \"(line 1,col 1) 'abstract' is not allowed here.\",\n-  125:                 \"(line 1,col 1) 'final' is not allowed here.\",\n-  126:                 \"(line 1,col 1) 'private' is not allowed here.\",\n-  127:                 \"(line 1,col 1) 'protected' is not allowed here.\"\n-  128:         );\n-  129:     }\n+   81:     @Test\n+   82:     public void topEnum() {\n+   83:         ParseResult<CompilationUnit> result = javaParser.parse(COMPILATION_UNIT, provider(allModifiers + \"enum X{}\"));\n+   84:         assertProblems(result,\n+   85:                 \"(line 1,col 1) Can have only one of 'public', 'protected', 'private'.\",\n+   86:                 \"(line 1,col 1) Can have only one of 'final', 'abstract'.\",\n+   87:                 \"(line 1,col 1) Can have only one of 'native', 'strictfp'.\",\n+   88:                 \"(line 1,col 1) 'transient' is not allowed here.\",\n+   89:                 \"(line 1,col 1) 'volatile' is not allowed here.\",\n+   90:                 \"(line 1,col 1) 'synchronized' is not allowed here.\",\n+   91:                 \"(line 1,col 1) 'default' is not allowed here.\",\n+   92:                 \"(line 1,col 1) 'native' is not allowed here.\",\n+   93:                 \"(line 1,col 1) 'transitive' is not allowed here.\",\n+   94:                 \"(line 1,col 1) 'static' is not allowed here.\",\n+   95:                 \"(line 1,col 1) 'abstract' is not allowed here.\",\n+   96:                 \"(line 1,col 1) 'final' is not allowed here.\",\n+   97:                 \"(line 1,col 1) 'private' is not allowed here.\",\n+   98:                 \"(line 1,col 1) 'protected' is not allowed here.\"\n+   99:         );\n+  100:     }\n+  110:                 \"(line 1,col 9) 'volatile' is not allowed here.\",\n+  111:                 \"(line 1,col 9) 'default' is not allowed here.\",\n+  112:                 \"(line 1,col 9) 'abstract' is not allowed here.\",\n+  113:                 \"(line 1,col 9) 'final' is not allowed here.\",\n+  114:                 \"(line 1,col 9) 'synchronized' is not allowed here.\",\n+  115:                 \"(line 1,col 9) 'native' is not allowed here.\",\n+  116:                 \"(line 1,col 9) 'transitive' is not allowed here.\"\n+  117:         );\n+  118:     }\n+  119: \n+  120: }\n",
        "uniqueId": "da6302311ef508f830434a997a9b61f24750c6a1_110_129__81_100",
        "moveFileExist": true,
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 1.8,
        "testResult": true,
        "coverageInfo": {
            "testMethod": {
                "missed": 0,
                "covered": 1
            }
        }
    },
    {
        "type": "Extract And Move Method",
        "description": "Extract And Move Method\tpublic assertNoProblems(result ParseResult<?>) : void extracted from public leftHandAssignmentCanBeInBraces() : void in class com.github.javaparser.ast.validator.BaseJavaValidatorTest & moved to class com.github.javaparser.utils.TestUtils",
        "diffLocations": [
            {
                "filePath": "javaparser-testing/src/test/java/com/github/javaparser/ast/validator/BaseJavaValidatorTest.java",
                "startLine": 72,
                "endLine": 76,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "javaparser-testing/src/test/java/com/github/javaparser/ast/validator/BaseJavaValidatorTest.java",
                "startLine": 73,
                "endLine": 77,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "javaparser-testing/src/test/java/com/github/javaparser/ast/validator/BaseJavaValidatorTest.java",
                "startLine": 133,
                "endLine": 135,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "@Test\n    public void leftHandAssignmentCanBeInBraces() {\n        ParseResult<Expression> result = new JavaParser().parse(EXPRESSION, provider(\"(i) += (i) += 1\"));\n        assertProblems(result);\n    }",
        "filePathBefore": "javaparser-testing/src/test/java/com/github/javaparser/ast/validator/BaseJavaValidatorTest.java",
        "isPureRefactoring": true,
        "commitId": "034b17a06497b52eb066eaf1ece5f086305ec840",
        "packageNameBefore": "com.github.javaparser.ast.validator",
        "classNameBefore": "com.github.javaparser.ast.validator.BaseJavaValidatorTest",
        "methodNameBefore": "com.github.javaparser.ast.validator.BaseJavaValidatorTest#leftHandAssignmentCanBeInBraces",
        "invokedMethod": "methodSignature: com.github.javaparser.utils.TestUtils#assertProblems\n methodBody: public static void assertProblems(ParseResult<?> result, String... expectedArg) {\nSet<String> actual=result.getProblems().stream().map(Problem::toString).collect(Collectors.toSet());\nSet<String> expected=new HashSet<>();\nexpected.addAll(Arrays.asList(expectedArg));\nassertCollections(expected,actual);\n}",
        "classSignatureBefore": "public class BaseJavaValidatorTest ",
        "methodNameBeforeSet": [
            "com.github.javaparser.ast.validator.BaseJavaValidatorTest#leftHandAssignmentCanBeInBraces"
        ],
        "classNameBeforeSet": [
            "com.github.javaparser.ast.validator.BaseJavaValidatorTest"
        ],
        "classSignatureBeforeSet": [
            "public class BaseJavaValidatorTest "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "package com.github.javaparser.ast.validator;\n\nimport com.github.javaparser.JavaParser;\nimport com.github.javaparser.ParseResult;\nimport com.github.javaparser.Range;\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.expr.Expression;\nimport com.github.javaparser.ast.stmt.Statement;\nimport org.junit.Test;\n\nimport static com.github.javaparser.ParseStart.COMPILATION_UNIT;\nimport static com.github.javaparser.ParseStart.EXPRESSION;\nimport static com.github.javaparser.ParseStart.STATEMENT;\nimport static com.github.javaparser.Providers.provider;\nimport static com.github.javaparser.utils.TestUtils.assertProblems;\n\npublic class BaseJavaValidatorTest {\n    @Test\n    public void tryWithoutAnything() {\n        ParseResult<Statement> result = new JavaParser().parse(STATEMENT, provider(\"try{}\"));\n        assertProblems(result, \"(line 1,col 1) Try has no finally, no catch, and no resources.\");\n    }\n\n    @Test\n    public void classExtendingMoreThanOne() {\n        ParseResult<CompilationUnit> result = new JavaParser().parse(COMPILATION_UNIT, provider(\"class X extends Y, Z {}\"));\n        assertProblems(result, \"(line 1,col 20) A class cannot extend more than one other class.\");\n    }\n\n    @Test\n    public void interfaceUsingImplements() {\n        ParseResult<CompilationUnit> result = new JavaParser().parse(COMPILATION_UNIT, provider(\"interface X implements Y {}\"));\n        assertProblems(result, \"(line 1,col 24) An interface cannot implement other interfaces.\");\n    }\n\n    @Test\n    public void interfaceWithInitializer() {\n        ParseResult<CompilationUnit> result = new JavaParser().parse(COMPILATION_UNIT, provider(\"interface X {{}}\"));\n        assertProblems(result, \"(line 1,col 14) An interface cannot have initializers.\");\n    }\n\n    @Test\n    public void defaultMethodWithoutBody() {\n        ParseResult<CompilationUnit> result = new JavaParser().parse(COMPILATION_UNIT, provider(\"interface X {default void a();}\"));\n        assertProblems(result, \"(line 1,col 14) 'default' methods must have a body.\");\n    }\n\n    @Test\n    public void defaultInClass() {\n        ParseResult<CompilationUnit> result = new JavaParser().parse(COMPILATION_UNIT, provider(\"class X {default void a(){};}\"));\n        assertProblems(result, \"(line 1,col 10) 'default' is not allowed here.\");\n    }\n\n    @Test\n    public void localInterface() {\n        ParseResult<CompilationUnit> result = new JavaParser().parse(COMPILATION_UNIT, provider(\"class X {void a(){interface I{}};}\"));\n        assertProblems(result, \"(line 1,col 19) There is no such thing as a local interface.\");\n    }\n\n    @Test\n    public void leftHandAssignmentCannotBeAConditional() {\n        ParseResult<Expression> result = new JavaParser().parse(EXPRESSION, provider(\"(1==2)=3\"));\n        assertProblems(result, \"(line 1,col 1) Illegal left hand side of an assignment.\");\n    }\n\n    @Test\n    public void leftHandAssignmentCannotBeEmptyBraces() {\n        ParseResult<Expression> result = new JavaParser().parse(EXPRESSION, provider(\"()=3\"));\n        assertProblems(result, \"(line 1,col 1) Illegal left hand side of an assignment.\");\n    }\n\n    @Test\n    public void leftHandAssignmentCanBeInBraces() {\n        ParseResult<Expression> result = new JavaParser().parse(EXPRESSION, provider(\"(i) += (i) += 1\"));\n        assertProblems(result);\n    }\n}\n",
        "filePathAfter": "javaparser-testing/src/test/java/com/github/javaparser/ast/validator/BaseJavaValidatorTest.java",
        "sourceCodeAfterForWhole": "package com.github.javaparser.ast.validator;\n\nimport com.github.javaparser.JavaParser;\nimport com.github.javaparser.ParseResult;\nimport com.github.javaparser.Range;\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.expr.Expression;\nimport com.github.javaparser.ast.stmt.Statement;\nimport org.junit.Test;\n\nimport static com.github.javaparser.ParseStart.COMPILATION_UNIT;\nimport static com.github.javaparser.ParseStart.EXPRESSION;\nimport static com.github.javaparser.ParseStart.STATEMENT;\nimport static com.github.javaparser.Providers.provider;\nimport static com.github.javaparser.utils.TestUtils.assertNoProblems;\nimport static com.github.javaparser.utils.TestUtils.assertProblems;\n\npublic class BaseJavaValidatorTest {\n    @Test\n    public void tryWithoutAnything() {\n        ParseResult<Statement> result = new JavaParser().parse(STATEMENT, provider(\"try{}\"));\n        assertProblems(result, \"(line 1,col 1) Try has no finally, no catch, and no resources.\");\n    }\n\n    @Test\n    public void classExtendingMoreThanOne() {\n        ParseResult<CompilationUnit> result = new JavaParser().parse(COMPILATION_UNIT, provider(\"class X extends Y, Z {}\"));\n        assertProblems(result, \"(line 1,col 20) A class cannot extend more than one other class.\");\n    }\n\n    @Test\n    public void interfaceUsingImplements() {\n        ParseResult<CompilationUnit> result = new JavaParser().parse(COMPILATION_UNIT, provider(\"interface X implements Y {}\"));\n        assertProblems(result, \"(line 1,col 24) An interface cannot implement other interfaces.\");\n    }\n\n    @Test\n    public void interfaceWithInitializer() {\n        ParseResult<CompilationUnit> result = new JavaParser().parse(COMPILATION_UNIT, provider(\"interface X {{}}\"));\n        assertProblems(result, \"(line 1,col 14) An interface cannot have initializers.\");\n    }\n\n    @Test\n    public void defaultMethodWithoutBody() {\n        ParseResult<CompilationUnit> result = new JavaParser().parse(COMPILATION_UNIT, provider(\"interface X {default void a();}\"));\n        assertProblems(result, \"(line 1,col 14) 'default' methods must have a body.\");\n    }\n\n    @Test\n    public void defaultInClass() {\n        ParseResult<CompilationUnit> result = new JavaParser().parse(COMPILATION_UNIT, provider(\"class X {default void a(){};}\"));\n        assertProblems(result, \"(line 1,col 10) 'default' is not allowed here.\");\n    }\n\n    @Test\n    public void localInterface() {\n        ParseResult<CompilationUnit> result = new JavaParser().parse(COMPILATION_UNIT, provider(\"class X {void a(){interface I{}};}\"));\n        assertProblems(result, \"(line 1,col 19) There is no such thing as a local interface.\");\n    }\n\n    @Test\n    public void leftHandAssignmentCannotBeAConditional() {\n        ParseResult<Expression> result = new JavaParser().parse(EXPRESSION, provider(\"(1==2)=3\"));\n        assertProblems(result, \"(line 1,col 1) Illegal left hand side of an assignment.\");\n    }\n\n    @Test\n    public void leftHandAssignmentCannotBeEmptyBraces() {\n        ParseResult<Expression> result = new JavaParser().parse(EXPRESSION, provider(\"()=3\"));\n        assertProblems(result, \"(line 1,col 1) Illegal left hand side of an assignment.\");\n    }\n\n    @Test\n    public void leftHandAssignmentCanBeInBraces() {\n        ParseResult<Expression> result = new JavaParser().parse(EXPRESSION, provider(\"(i) += (i) += 1\"));\n        assertNoProblems(result);\n    }\n}\n",
        "diffSourceCodeSet": [
            ""
        ],
        "invokedMethodSet": [
            "methodSignature: com.github.javaparser.utils.TestUtils#assertProblems\n methodBody: public static void assertProblems(ParseResult<?> result, String... expectedArg) {\nSet<String> actual=result.getProblems().stream().map(Problem::toString).collect(Collectors.toSet());\nSet<String> expected=new HashSet<>();\nexpected.addAll(Arrays.asList(expectedArg));\nassertCollections(expected,actual);\n}"
        ],
        "sourceCodeAfterRefactoring": "@Test\n    public void leftHandAssignmentCanBeInBraces() {\n        ParseResult<Expression> result = new JavaParser().parse(EXPRESSION, provider(\"(i) += (i) += 1\"));\n        assertNoProblems(result);\n    }\n",
        "diffSourceCode": "-   72:     @Test\n-   73:     public void leftHandAssignmentCanBeInBraces() {\n-   74:         ParseResult<Expression> result = new JavaParser().parse(EXPRESSION, provider(\"(i) += (i) += 1\"));\n-   75:         assertProblems(result);\n-   76:     }\n-   77: }\n+   72: \n+   73:     @Test\n+   74:     public void leftHandAssignmentCanBeInBraces() {\n+   75:         ParseResult<Expression> result = new JavaParser().parse(EXPRESSION, provider(\"(i) += (i) += 1\"));\n+   76:         assertNoProblems(result);\n+   77:     }\n",
        "uniqueId": "034b17a06497b52eb066eaf1ece5f086305ec840_72_76_133_135_73_77",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "testMethod": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 1.8
    },
    {
        "type": "Inline Method",
        "description": "Inline Method\tpublic getRawTypeName() : String inlined to public getTypeName() : String in class com.github.javaparser.metamodel.PropertyMetaModel",
        "diffLocations": [
            {
                "filePath": "javaparser-metamodel/src/main/java/com/github/javaparser/metamodel/PropertyMetaModel.java",
                "startLine": 117,
                "endLine": 122,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "javaparser-metamodel/src/main/java/com/github/javaparser/metamodel/PropertyMetaModel.java",
                "startLine": 153,
                "endLine": 158,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "javaparser-metamodel/src/main/java/com/github/javaparser/metamodel/PropertyMetaModel.java",
                "startLine": 124,
                "endLine": 126,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "public String getRawTypeName() {\n        return type.getSimpleName();\n    }",
        "filePathBefore": "javaparser-metamodel/src/main/java/com/github/javaparser/metamodel/PropertyMetaModel.java",
        "isPureRefactoring": true,
        "commitId": "b12d4d933f76cfe8de43ee919aa8357dcd38afb8",
        "packageNameBefore": "com.github.javaparser.metamodel",
        "classNameBefore": "com.github.javaparser.metamodel.PropertyMetaModel",
        "methodNameBefore": "com.github.javaparser.metamodel.PropertyMetaModel#getRawTypeName",
        "classSignatureBefore": "public class PropertyMetaModel ",
        "methodNameBeforeSet": [
            "com.github.javaparser.metamodel.PropertyMetaModel#getRawTypeName"
        ],
        "classNameBeforeSet": [
            "com.github.javaparser.metamodel.PropertyMetaModel"
        ],
        "classSignatureBeforeSet": [
            "public class PropertyMetaModel "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "package com.github.javaparser.metamodel;\n\nimport java.lang.reflect.Field;\n\nimport static com.github.javaparser.generator.utils.GeneratorUtils.getterName;\nimport static com.github.javaparser.generator.utils.GeneratorUtils.setterName;\n\n/**\n * Meta-data about a property of a node in the AST.\n */\npublic class PropertyMetaModel {\n    private final BaseNodeMetaModel nodeMetaModel;\n    private final String name;\n    private final Class<?> type;\n    //    public Optional<CommentMetaModel> typeReference;\n//    public Optional<Class<Integer>> tpe;\n    private final Field reflectionField;\n    private final boolean isNode;\n    private final boolean isOptional;\n    private final boolean isNodeList;\n    private final boolean isEnumSet;\n    private final boolean hasWildcard;\n\n    public PropertyMetaModel(BaseNodeMetaModel nodeMetaModel, String name, Class<?> type, Field reflectionField, boolean isNode, boolean isOptional, boolean isNodeList, boolean isEnumSet, boolean hasWildcard) {\n        this.nodeMetaModel = nodeMetaModel;\n        this.name = name;\n        this.type = type;\n        this.reflectionField = reflectionField;\n        this.isNode = isNode;\n        this.isOptional = isOptional;\n        this.isNodeList = isNodeList;\n        this.isEnumSet = isEnumSet;\n        this.hasWildcard = hasWildcard;\n    }\n\n    public boolean is(Class<?> c, String fieldName) {\n        return nodeMetaModel.is(c) && name.equals(fieldName);\n    }\n\n    public boolean is(String fieldName) {\n        return name.equals(fieldName);\n    }\n\n    /**\n     * @return the name used in the AST for the setter\n     */\n    public String getSetterMethodName() {\n        return setterName(reflectionField);\n    }\n\n    /**\n     * @return the name used in the AST for the getter\n     */\n    public String getGetterMethodName() {\n        return getterName(reflectionField);\n    }\n\n    public BaseNodeMetaModel getNodeMetaModel() {\n        return nodeMetaModel;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public Class<?> getType() {\n        return type;\n    }\n\n    public Field getReflectionField() {\n        return reflectionField;\n    }\n\n    @Deprecated\n    public boolean isNode() {\n        return isNode;\n    }\n\n    public boolean isOptional() {\n        return isOptional;\n    }\n\n    public boolean isNodeList() {\n        return isNodeList;\n    }\n\n    public boolean isEnumSet() {\n        return isEnumSet;\n    }\n\n    public boolean hasWildcard() {\n        return hasWildcard;\n    }\n\n    @Override\n    public String toString() {\n        return \"(\" + type.getSimpleName() + \")\\t\" + nodeMetaModel + \"#\" + name;\n    }\n\n    @Override\n    public int hashCode() {\n        return reflectionField.hashCode();\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n\n        PropertyMetaModel that = (PropertyMetaModel) o;\n\n        if (!reflectionField.equals(that.reflectionField)) return false;\n\n        return true;\n    }\n\n    public String getTypeName() {\n        if (hasWildcard) {\n            return getRawTypeName() + \"<?>\";\n        }\n        return getRawTypeName();\n    }\n\n    public String getRawTypeName() {\n        return type.getSimpleName();\n    }\n\n    public String getFullTypeNameForGetter() {\n        if (isOptional) {\n            return \"Optional<\" + getFullTypeNameForSetter() + \">\";\n        }\n        return getFullTypeNameForSetter();\n    }\n\n    public String getFullTypeNameForSetter() {\n        if (isNodeList) {\n            return \"NodeList<\" + getTypeName() + \">\";\n        }\n        if (isEnumSet) {\n            return \"EnumSet<\" + getTypeName() + \">\";\n        }\n        return getTypeName();\n    }\n}\n",
        "filePathAfter": "javaparser-metamodel/src/main/java/com/github/javaparser/metamodel/PropertyMetaModel.java",
        "sourceCodeAfterForWhole": "package com.github.javaparser.metamodel;\n\nimport com.github.javaparser.ast.Node;\n\nimport java.util.Optional;\n\nimport static com.github.javaparser.generator.utils.GeneratorUtils.getterName;\nimport static com.github.javaparser.generator.utils.GeneratorUtils.setterName;\n\n/**\n * Meta-data about a property of a node in the AST.\n */\npublic class PropertyMetaModel {\n    private final BaseNodeMetaModel containingNodeMetaModel;\n    private final String name;\n    private final Class<?> type;\n    private final Optional<BaseNodeMetaModel> nodeReference;\n    private final boolean isOptional;\n    private final boolean isNodeList;\n    private final boolean isEnumSet;\n    private final boolean hasWildcard;\n\n    public PropertyMetaModel(BaseNodeMetaModel containingNodeMetaModel, String name, Class<?> type, Optional<BaseNodeMetaModel> nodeReference, boolean isOptional, boolean isNodeList, boolean isEnumSet, boolean hasWildcard) {\n        this.containingNodeMetaModel = containingNodeMetaModel;\n        this.name = name;\n        this.type = type;\n        this.nodeReference = nodeReference;\n        this.isOptional = isOptional;\n        this.isNodeList = isNodeList;\n        this.isEnumSet = isEnumSet;\n        this.hasWildcard = hasWildcard;\n    }\n\n    /**\n     * @return is this the field fieldName on class c?\n     */\n    public boolean is(Class<? extends Node> c, String fieldName) {\n        return containingNodeMetaModel.is(c) && name.equals(fieldName);\n    }\n\n    /**\n     * @return is this fields called fieldName?\n     */\n    public boolean is(String fieldName) {\n        return name.equals(fieldName);\n    }\n\n    /**\n     * @return the name used in the AST for the setter\n     */\n    public String getSetterMethodName() {\n        return setterName(name);\n    }\n\n    /**\n     * @return the name used in the AST for the getter\n     */\n    public String getGetterMethodName() {\n        return getterName(type, name);\n    }\n\n    /**\n     * @return the NodeMetaModel that \"has\" this property.\n     */\n    public BaseNodeMetaModel getContainingNodeMetaModel() {\n        return containingNodeMetaModel;\n    }\n\n    /**\n     * @return the name of the property. This is equal to the name of the field in the AST.\n     */\n    public String getName() {\n        return name;\n    }\n\n    /**\n     * @return the class of the field.\n     */\n    public Class<?> getType() {\n        return type;\n    }\n\n    /**\n     * @return if this property is a Node, this will get the node meta model.\n     */\n    public Optional<BaseNodeMetaModel> getNodeReference() {\n        return nodeReference;\n    }\n\n    /**\n     * @return whether this property is optional.\n     */\n    public boolean isOptional() {\n        return isOptional;\n    }\n\n    /**\n     * @return whether this property is contained in a NodeList.\n     */\n    public boolean isNodeList() {\n        return isNodeList;\n    }\n\n    /**\n     * @return whether this property is contained in an EnumSet.\n     */\n    public boolean isEnumSet() {\n        return isEnumSet;\n    }\n\n    /**\n     * @return whether this property has a wildcard following it, like BodyDeclaration&lt;?&gt;.\n     */\n    public boolean hasWildcard() {\n        return hasWildcard;\n    }\n\n    @Override\n    public String toString() {\n        return \"(\" + getTypeName() + \")\\t\" + containingNodeMetaModel + \"#\" + name;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n\n        PropertyMetaModel that = (PropertyMetaModel) o;\n\n        if (!name.equals(that.name)) return false;\n        if (!type.equals(that.type)) return false;\n\n        return true;\n    }\n\n    @Override\n    public int hashCode() {\n        int result = name.hashCode();\n        result = 31 * result + type.hashCode();\n        return result;\n    }\n\n    /**\n     * @return the type of a single element of this property, so no Optional or NodeList or EnumSet.\n     */\n    public String getTypeNameGenericsed() {\n        if (hasWildcard) {\n            return getTypeName() + \"<?>\";\n        }\n        return getTypeName();\n    }\n\n    /**\n     * @return the raw type of a single element of this property, so nothing but the name.\n     */\n    public String getTypeName() {\n        return type.getSimpleName();\n    }\n\n    /**\n     * @return the type that is returned from getters in the AST.\n     */\n    public String getTypeNameForGetter() {\n        if (isOptional) {\n            return \"Optional<\" + getTypeNameForSetter() + \">\";\n        }\n        return getTypeNameForSetter();\n    }\n\n    /**\n     * @return the type that is passed to setters in the AST.\n     */\n    public String getTypeNameForSetter() {\n        if (isNodeList) {\n            return \"NodeList<\" + getTypeNameGenericsed() + \">\";\n        }\n        if (isEnumSet) {\n            return \"EnumSet<\" + getTypeNameGenericsed() + \">\";\n        }\n        return getTypeNameGenericsed();\n    }\n}\n",
        "diffSourceCodeSet": [],
        "invokedMethodSet": [],
        "sourceCodeAfterRefactoring": "/**\n     * @return the raw type of a single element of this property, so nothing but the name.\n     */\n    public String getTypeName() {\n        return type.getSimpleName();\n    }",
        "diffSourceCode": "-  117:     public String getTypeName() {\n-  118:         if (hasWildcard) {\n-  119:             return getRawTypeName() + \"<?>\";\n-  120:         }\n-  121:         return getRawTypeName();\n-  122:     }\n-  124:     public String getRawTypeName() {\n-  125:         return type.getSimpleName();\n-  126:     }\n+  117: \n+  118:     @Override\n+  119:     public String toString() {\n+  120:         return \"(\" + getTypeName() + \")\\t\" + containingNodeMetaModel + \"#\" + name;\n+  121:     }\n+  122: \n+  124:     public boolean equals(Object o) {\n+  125:         if (this == o) return true;\n+  126:         if (o == null || getClass() != o.getClass()) return false;\n+  153:     /**\n+  154:      * @return the raw type of a single element of this property, so nothing but the name.\n+  155:      */\n+  156:     public String getTypeName() {\n+  157:         return type.getSimpleName();\n+  158:     }\n",
        "uniqueId": "b12d4d933f76cfe8de43ee919aa8357dcd38afb8_117_122__153_158_124_126",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 0,
                "covered": 4
            },
            "LINE": {
                "missed": 0,
                "covered": 1
            },
            "COMPLEXITY": {
                "missed": 0,
                "covered": 1
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 1.8
    },
    {
        "type": "Move Method",
        "description": "Move Method\tpublic visit(n ImportDeclaration, arg Object) : void from class com.github.javaparser.bdd.visitors.PositionTestVisitor to public visit(n BlockComment, arg Void) : void from class com.github.javaparser.bdd.steps.ExistenceOfParentNodeVerifier.Verifier",
        "diffLocations": [
            {
                "filePath": "javaparser-testing/src/test/java/com/github/javaparser/bdd/visitors/PositionTestVisitor.java",
                "startLine": 250,
                "endLine": 253,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "javaparser-testing/src/test/java/com/github/javaparser/bdd/steps/ExistenceOfParentNodeVerifier.java",
                "startLine": 101,
                "endLine": 104,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "@Override public void visit(final ImportDeclaration n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }",
        "filePathBefore": "javaparser-testing/src/test/java/com/github/javaparser/bdd/visitors/PositionTestVisitor.java",
        "isPureRefactoring": true,
        "commitId": "731c46d3bd61cc1e3e4733570dd80ab00cd63c87",
        "packageNameBefore": "com.github.javaparser.bdd.visitors",
        "classNameBefore": "com.github.javaparser.bdd.visitors.PositionTestVisitor",
        "methodNameBefore": "com.github.javaparser.bdd.visitors.PositionTestVisitor#visit",
        "invokedMethod": "methodSignature: com.github.javaparser.ast.visitor.GenericVisitor#visit\n methodBody: R visit(ArrayBracketPair arrayBracketPair, A arg);\nmethodSignature: com.github.javaparser.ast.visitor.ModifierVisitorAdapter#visit\n methodBody: public Node visit(final LineComment n, final A arg) {\nreturn n;\n}\nmethodSignature: com.github.javaparser.bdd.steps.ExistenceOfParentNodeVerifier.Verifier#visit\n methodBody: public void visit(WildcardType n, Void arg) {\nassertParentIsSet(n);\nsuper.visit(n,arg);\n}\nmethodSignature: com.github.javaparser.ast.visitor.DumpVisitor#visit\n methodBody: public void visit(ArrayBracketPair arrayBracketPair, Object arg) {\nprintAnnotations(arrayBracketPair.getAnnotations(),true,arg);\nprinter.print(\"[]\");\n}\nmethodSignature: com.github.javaparser.ast.visitor.CloneVisitor#visit\n methodBody: public <T extends Node> List<T> visit(List<T> _nodes, Object _arg) {\nif(_nodes == null)return null;\nList<T> r=new ArrayList<>(_nodes.size());\nfor(T n: _nodes){T rN=cloneNodes(n,_arg);\nif(rN != null)r.add(rN);\n}return r;\n}\nmethodSignature: com.github.javaparser.bdd.visitors.PositionTestVisitor#doTest\n methodBody: void doTest(final Node node) {\nassertThat(node.getBegin().line,is(greaterThanOrEqualTo(0)));\nassertThat(node.getBegin().column,is(greaterThanOrEqualTo(0)));\nassertThat(node.getEnd().line,is(greaterThanOrEqualTo(0)));\nassertThat(node.getEnd().column,is(greaterThanOrEqualTo(0)));\nif(node.getBegin().line == node.getEnd().line){assertThat(node.getBegin().column,is(lessThanOrEqualTo(node.getEnd().column)));\n}{assertThat(node.getBegin().line,is(lessThanOrEqualTo(node.getEnd().line)));\n}numberOfNodesVisited++;\n}\nmethodSignature: com.github.javaparser.ast.visitor.EqualsVisitor#visit\n methodBody: public Boolean visit(ArrayBracketPair n1, Node arg) {\nArrayBracketPair n2=(ArrayBracketPair)arg;\nif(!nodesEquals(n1.getAnnotations(),n2.getAnnotations())){return false;\n}return true;\n}\nmethodSignature: com.github.javaparser.bdd.visitors.PositionTestVisitor#visit\n methodBody: public void visit(UnknownType n, Object arg) {\ndoTest(n);\nsuper.visit(n,arg);\n}\nmethodSignature: com.github.javaparser.ast.visitor.VoidVisitorAdapter#visit\n methodBody: public void visit(ArrayBracketPair n, A arg) {\nvisitAnnotations(n,arg);\n}\nmethodSignature: com.github.javaparser.ast.visitor.GenericVisitorAdapter#visit\n methodBody: public R visit(final LineComment n, final A arg) {\nreturn null;\n}\nmethodSignature: com.github.javaparser.ast.visitor.VoidVisitor#visit\n methodBody: void visit(ArrayBracketPair arrayBracketPair, A arg);",
        "classSignatureBefore": "public class PositionTestVisitor extends VoidVisitorAdapter<Object> ",
        "methodNameBeforeSet": [
            "com.github.javaparser.bdd.visitors.PositionTestVisitor#visit"
        ],
        "classNameBeforeSet": [
            "com.github.javaparser.bdd.visitors.PositionTestVisitor"
        ],
        "classSignatureBeforeSet": [
            "public class PositionTestVisitor extends VoidVisitorAdapter<Object> "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "",
                "description": "Extra print lines - with non-mapped leaves",
                "mappingState": 5
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Copyright (C) 2007-2010 J\u00falio Vilmar Gesser.\n * Copyright (C) 2011, 2013-2016 The JavaParser Team.\n *\n * This file is part of JavaParser.\n * \n * JavaParser can be used either under the terms of\n * a) the GNU Lesser General Public License as published by\n *     the Free Software Foundation, either version 3 of the License, or\n *     (at your option) any later version.\n * b) the terms of the Apache License \n *\n * You should have received a copy of both licenses in LICENCE.LGPL and\n * LICENCE.APACHE. Please refer to those files for details.\n *\n * JavaParser is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n */\n \npackage com.github.javaparser.bdd.visitors;\n\nimport com.github.javaparser.ast.*;\nimport com.github.javaparser.ast.body.*;\nimport com.github.javaparser.ast.comments.BlockComment;\nimport com.github.javaparser.ast.comments.JavadocComment;\nimport com.github.javaparser.ast.comments.LineComment;\nimport com.github.javaparser.ast.expr.*;\nimport com.github.javaparser.ast.stmt.*;\nimport com.github.javaparser.ast.type.*;\nimport com.github.javaparser.ast.visitor.VoidVisitorAdapter;\n\nimport static org.hamcrest.MatcherAssert.assertThat;\nimport static org.hamcrest.Matchers.greaterThanOrEqualTo;\nimport static org.hamcrest.Matchers.lessThanOrEqualTo;\nimport static org.hamcrest.core.Is.is;\n\n\npublic class PositionTestVisitor extends VoidVisitorAdapter<Object> {\n\n    private int numberOfNodesVisited;\n\n    @Override public void visit(final AnnotationDeclaration n, final Object arg) {\n        doTest(n);\n        doTest(n.getNameExpr());\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final AnnotationMemberDeclaration n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final ArrayAccessExpr n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final ArrayCreationExpr n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final ArrayInitializerExpr n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final AssertStmt n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final AssignExpr n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final BinaryExpr n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final BlockComment n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final BlockStmt n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final BooleanLiteralExpr n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final BreakStmt n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final CastExpr n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final CatchClause n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(LambdaExpr n, Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(MethodReferenceExpr n, Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(TypeExpr n, Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final CharLiteralExpr n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final ClassExpr n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final ClassOrInterfaceDeclaration n, final Object arg) {\n        doTest(n);\n        doTest(n.getNameExpr());\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final ClassOrInterfaceType n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final CompilationUnit n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final ConditionalExpr n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final ConstructorDeclaration n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final ContinueStmt n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final DoStmt n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final DoubleLiteralExpr n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final EmptyMemberDeclaration n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final EmptyStmt n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final EmptyTypeDeclaration n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final EnclosedExpr n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final EnumConstantDeclaration n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final EnumDeclaration n, final Object arg) {\n        doTest(n);\n        doTest(n.getNameExpr());\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final ExplicitConstructorInvocationStmt n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final ExpressionStmt n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final FieldAccessExpr n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final FieldDeclaration n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final ForeachStmt n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final ForStmt n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final IfStmt n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final ImportDeclaration n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final InitializerDeclaration n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final InstanceOfExpr n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final IntegerLiteralExpr n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final IntegerLiteralMinValueExpr n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final JavadocComment n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final LabeledStmt n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final LineComment n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final LongLiteralExpr n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final LongLiteralMinValueExpr n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final MarkerAnnotationExpr n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final MemberValuePair n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final MethodCallExpr n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final MethodDeclaration n, final Object arg) {\n        doTest(n);\n        doTest(n.getNameExpr());\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final NameExpr n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final NormalAnnotationExpr n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final NullLiteralExpr n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final ObjectCreationExpr n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final PackageDeclaration n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final Parameter n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final PrimitiveType n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final QualifiedNameExpr n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(ArrayType n, Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(ArrayCreationLevel n, Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final IntersectionType n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(UnionType n, Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final ReturnStmt n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final SingleMemberAnnotationExpr n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final StringLiteralExpr n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final SuperExpr n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final SwitchEntryStmt n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final SwitchStmt n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final SynchronizedStmt n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final ThisExpr n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final ThrowStmt n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final TryStmt n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final TypeDeclarationStmt n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final TypeParameter n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final UnaryExpr n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final VariableDeclarationExpr n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final VariableDeclarator n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final VariableDeclaratorId n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final VoidType n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final WhileStmt n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override public void visit(final WildcardType n, final Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    @Override\n    public void visit(UnknownType n, Object arg) {\n        doTest(n);\n        super.visit(n, arg);\n    }\n\n    void doTest(final Node node) {\n        assertThat(node.getBegin().line, is(greaterThanOrEqualTo(0)));\n        assertThat(node.getBegin().column, is(greaterThanOrEqualTo(0)));\n        assertThat(node.getEnd().line, is(greaterThanOrEqualTo(0)));\n        assertThat(node.getEnd().column, is(greaterThanOrEqualTo(0)));\n\n        if (node.getBegin().line == node.getEnd().line) {\n            assertThat(node.getBegin().column, is(lessThanOrEqualTo(node.getEnd().column)));\n        } else {\n            assertThat(node.getBegin().line, is(lessThanOrEqualTo(node.getEnd().line)));\n        }\n        numberOfNodesVisited++;\n    }\n\n    public int getNumberOfNodesVisited() {\n        return numberOfNodesVisited;\n    }\n}\n",
        "filePathAfter": "javaparser-testing/src/test/java/com/github/javaparser/bdd/steps/ExistenceOfParentNodeVerifier.java",
        "sourceCodeAfterForWhole": "/*\n * Copyright (C) 2007-2010 J\u00falio Vilmar Gesser.\n * Copyright (C) 2011, 2013-2016 The JavaParser Team.\n *\n * This file is part of JavaParser.\n * \n * JavaParser can be used either under the terms of\n * a) the GNU Lesser General Public License as published by\n *     the Free Software Foundation, either version 3 of the License, or\n *     (at your option) any later version.\n * b) the terms of the Apache License \n *\n * You should have received a copy of both licenses in LICENCE.LGPL and\n * LICENCE.APACHE. Please refer to those files for details.\n *\n * JavaParser is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n */\n \npackage com.github.javaparser.bdd.steps;\n\nimport com.github.javaparser.ast.*;\nimport com.github.javaparser.ast.body.*;\nimport com.github.javaparser.ast.comments.BlockComment;\nimport com.github.javaparser.ast.comments.JavadocComment;\nimport com.github.javaparser.ast.comments.LineComment;\nimport com.github.javaparser.ast.expr.*;\nimport com.github.javaparser.ast.imports.*;\nimport com.github.javaparser.ast.stmt.*;\nimport com.github.javaparser.ast.type.*;\nimport com.github.javaparser.ast.visitor.VoidVisitorAdapter;\n\nimport static org.hamcrest.Matchers.notNullValue;\nimport static org.hamcrest.core.Is.is;\nimport static org.junit.Assert.assertThat;\n\n/**\n * The <code>ExistenceOfParentNodeVerifier</code> verifies that each node of the compilation unit has a parent set.\n */\nclass ExistenceOfParentNodeVerifier {\n\n    public void verify(CompilationUnit compilationUnit) throws AssertionError {\n        new Verifier().visit(compilationUnit, null);\n    }\n\n    private static class Verifier extends VoidVisitorAdapter<Void> {\n        private static void assertParentIsSet(Node n) {\n            assertThat(n + \" has no parent set!\", n.getParentNode(), is(notNullValue()));\n        }\n\n        @Override\n        public void visit(AnnotationDeclaration n, Void arg) {\n            assertParentIsSet(n);\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(AnnotationMemberDeclaration n, Void arg) {\n            assertParentIsSet(n);\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(ArrayAccessExpr n, Void arg) {\n            assertParentIsSet(n);\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(ArrayCreationExpr n, Void arg) {\n            assertParentIsSet(n);\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(ArrayInitializerExpr n, Void arg) {\n            assertParentIsSet(n);\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(AssertStmt n, Void arg) {\n            assertParentIsSet(n);\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(AssignExpr n, Void arg) {\n            assertParentIsSet(n);\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(BinaryExpr n, Void arg) {\n            assertParentIsSet(n);\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(BlockComment n, Void arg) {\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(BlockStmt n, Void arg) {\n            assertParentIsSet(n);\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(BooleanLiteralExpr n, Void arg) {\n            assertParentIsSet(n);\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(BreakStmt n, Void arg) {\n            assertParentIsSet(n);\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(CastExpr n, Void arg) {\n            assertParentIsSet(n);\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(CatchClause n, Void arg) {\n            assertParentIsSet(n);\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(CharLiteralExpr n, Void arg) {\n            assertParentIsSet(n);\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(ClassExpr n, Void arg) {\n            assertParentIsSet(n);\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(ClassOrInterfaceDeclaration n, Void arg) {\n            assertParentIsSet(n);\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(ClassOrInterfaceType n, Void arg) {\n            assertParentIsSet(n);\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(CompilationUnit n, Void arg) {\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(ConditionalExpr n, Void arg) {\n            assertParentIsSet(n);\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(ConstructorDeclaration n, Void arg) {\n            assertParentIsSet(n);\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(ContinueStmt n, Void arg) {\n            assertParentIsSet(n);\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(DoStmt n, Void arg) {\n            assertParentIsSet(n);\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(DoubleLiteralExpr n, Void arg) {\n            assertParentIsSet(n);\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(EmptyMemberDeclaration n, Void arg) {\n            assertParentIsSet(n);\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(EmptyStmt n, Void arg) {\n            assertParentIsSet(n);\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(EmptyTypeDeclaration n, Void arg) {\n            assertParentIsSet(n);\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(EnclosedExpr n, Void arg) {\n            assertParentIsSet(n);\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(EnumConstantDeclaration n, Void arg) {\n            assertParentIsSet(n);\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(EnumDeclaration n, Void arg) {\n            assertParentIsSet(n);\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(ExplicitConstructorInvocationStmt n, Void arg) {\n            assertParentIsSet(n);\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(ExpressionStmt n, Void arg) {\n            assertParentIsSet(n);\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(FieldAccessExpr n, Void arg) {\n            assertParentIsSet(n);\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(FieldDeclaration n, Void arg) {\n            assertParentIsSet(n);\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(ForeachStmt n, Void arg) {\n            assertParentIsSet(n);\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(ForStmt n, Void arg) {\n            assertParentIsSet(n);\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(IfStmt n, Void arg) {\n            assertParentIsSet(n);\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(InitializerDeclaration n, Void arg) {\n            assertParentIsSet(n);\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(InstanceOfExpr n, Void arg) {\n            assertParentIsSet(n);\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(IntegerLiteralExpr n, Void arg) {\n            assertParentIsSet(n);\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(IntegerLiteralMinValueExpr n, Void arg) {\n            assertParentIsSet(n);\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(JavadocComment n, Void arg) {\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(LabeledStmt n, Void arg) {\n            assertParentIsSet(n);\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(LineComment n, Void arg) {\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(LambdaExpr n, Void arg) {\n            assertParentIsSet(n);\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(LongLiteralExpr n, Void arg) {\n            assertParentIsSet(n);\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(LongLiteralMinValueExpr n, Void arg) {\n            assertParentIsSet(n);\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(MarkerAnnotationExpr n, Void arg) {\n            assertParentIsSet(n);\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(MemberValuePair n, Void arg) {\n            assertParentIsSet(n);\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(MethodCallExpr n, Void arg) {\n            assertParentIsSet(n);\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(MethodDeclaration n, Void arg) {\n            assertParentIsSet(n);\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(MethodReferenceExpr n, Void arg) {\n            assertParentIsSet(n);\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(NameExpr n, Void arg) {\n            assertParentIsSet(n);\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(NormalAnnotationExpr n, Void arg) {\n            assertParentIsSet(n);\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(NullLiteralExpr n, Void arg) {\n            assertParentIsSet(n);\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(ObjectCreationExpr n, Void arg) {\n            assertParentIsSet(n);\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(PackageDeclaration n, Void arg) {\n            assertParentIsSet(n);\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(Parameter n, Void arg) {\n            assertParentIsSet(n);\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(PrimitiveType n, Void arg) {\n            assertParentIsSet(n);\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(QualifiedNameExpr n, Void arg) {\n            assertParentIsSet(n);\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(ArrayType n, Void arg) {\n            assertParentIsSet(n);\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(ArrayCreationLevel n, Void arg) {\n            assertParentIsSet(n);\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(IntersectionType n, Void arg) {\n            assertParentIsSet(n);\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(UnionType n, Void arg) {\n            assertParentIsSet(n);\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(ReturnStmt n, Void arg) {\n            assertParentIsSet(n);\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(SingleMemberAnnotationExpr n, Void arg) {\n            assertParentIsSet(n);\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(StringLiteralExpr n, Void arg) {\n            assertParentIsSet(n);\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(SuperExpr n, Void arg) {\n            assertParentIsSet(n);\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(SwitchEntryStmt n, Void arg) {\n            assertParentIsSet(n);\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(SwitchStmt n, Void arg) {\n            assertParentIsSet(n);\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(SynchronizedStmt n, Void arg) {\n            assertParentIsSet(n);\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(ThisExpr n, Void arg) {\n            assertParentIsSet(n);\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(ThrowStmt n, Void arg) {\n            assertParentIsSet(n);\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(TryStmt n, Void arg) {\n            assertParentIsSet(n);\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(TypeDeclarationStmt n, Void arg) {\n            assertParentIsSet(n);\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(TypeExpr n, Void arg) {\n            assertParentIsSet(n);\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(ArrayBracketPair n, Void arg) {\n            assertParentIsSet(n);\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(EmptyImportDeclaration n, Void arg) {\n            assertParentIsSet(n);\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(SingleStaticImportDeclaration n, Void arg) {\n            assertParentIsSet(n);\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(SingleTypeImportDeclaration n, Void arg) {\n            assertParentIsSet(n);\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(StaticImportOnDemandDeclaration n, Void arg) {\n            assertParentIsSet(n);\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(TypeImportOnDemandDeclaration n, Void arg) {\n            assertParentIsSet(n);\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(TypeParameter n, Void arg) {\n            assertParentIsSet(n);\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(UnaryExpr n, Void arg) {\n            assertParentIsSet(n);\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(UnknownType n, Void arg) {\n            assertParentIsSet(n);\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(VariableDeclarationExpr n, Void arg) {\n            assertParentIsSet(n);\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(VariableDeclarator n, Void arg) {\n            assertParentIsSet(n);\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(VariableDeclaratorId n, Void arg) {\n            assertParentIsSet(n);\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(VoidType n, Void arg) {\n            assertParentIsSet(n);\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(WhileStmt n, Void arg) {\n            assertParentIsSet(n);\n            super.visit(n, arg);\n        }\n\n        @Override\n        public void visit(WildcardType n, Void arg) {\n            assertParentIsSet(n);\n            super.visit(n, arg);\n        }\n    }\n\n}\n",
        "diffSourceCodeSet": [],
        "invokedMethodSet": [
            "methodSignature: com.github.javaparser.ast.visitor.GenericVisitor#visit\n methodBody: R visit(ArrayBracketPair arrayBracketPair, A arg);",
            "methodSignature: com.github.javaparser.ast.visitor.ModifierVisitorAdapter#visit\n methodBody: public Node visit(final LineComment n, final A arg) {\nreturn n;\n}",
            "methodSignature: com.github.javaparser.bdd.steps.ExistenceOfParentNodeVerifier.Verifier#visit\n methodBody: public void visit(WildcardType n, Void arg) {\nassertParentIsSet(n);\nsuper.visit(n,arg);\n}",
            "methodSignature: com.github.javaparser.ast.visitor.DumpVisitor#visit\n methodBody: public void visit(ArrayBracketPair arrayBracketPair, Object arg) {\nprintAnnotations(arrayBracketPair.getAnnotations(),true,arg);\nprinter.print(\"[]\");\n}",
            "methodSignature: com.github.javaparser.ast.visitor.CloneVisitor#visit\n methodBody: public <T extends Node> List<T> visit(List<T> _nodes, Object _arg) {\nif(_nodes == null)return null;\nList<T> r=new ArrayList<>(_nodes.size());\nfor(T n: _nodes){T rN=cloneNodes(n,_arg);\nif(rN != null)r.add(rN);\n}return r;\n}",
            "methodSignature: com.github.javaparser.bdd.visitors.PositionTestVisitor#doTest\n methodBody: void doTest(final Node node) {\nassertThat(node.getBegin().line,is(greaterThanOrEqualTo(0)));\nassertThat(node.getBegin().column,is(greaterThanOrEqualTo(0)));\nassertThat(node.getEnd().line,is(greaterThanOrEqualTo(0)));\nassertThat(node.getEnd().column,is(greaterThanOrEqualTo(0)));\nif(node.getBegin().line == node.getEnd().line){assertThat(node.getBegin().column,is(lessThanOrEqualTo(node.getEnd().column)));\n}{assertThat(node.getBegin().line,is(lessThanOrEqualTo(node.getEnd().line)));\n}numberOfNodesVisited++;\n}",
            "methodSignature: com.github.javaparser.ast.visitor.EqualsVisitor#visit\n methodBody: public Boolean visit(ArrayBracketPair n1, Node arg) {\nArrayBracketPair n2=(ArrayBracketPair)arg;\nif(!nodesEquals(n1.getAnnotations(),n2.getAnnotations())){return false;\n}return true;\n}",
            "methodSignature: com.github.javaparser.bdd.visitors.PositionTestVisitor#visit\n methodBody: public void visit(UnknownType n, Object arg) {\ndoTest(n);\nsuper.visit(n,arg);\n}",
            "methodSignature: com.github.javaparser.ast.visitor.VoidVisitorAdapter#visit\n methodBody: public void visit(ArrayBracketPair n, A arg) {\nvisitAnnotations(n,arg);\n}",
            "methodSignature: com.github.javaparser.ast.visitor.GenericVisitorAdapter#visit\n methodBody: public R visit(final LineComment n, final A arg) {\nreturn null;\n}",
            "methodSignature: com.github.javaparser.ast.visitor.VoidVisitor#visit\n methodBody: void visit(ArrayBracketPair arrayBracketPair, A arg);"
        ],
        "sourceCodeAfterRefactoring": "@Override\n        public void visit(BlockComment n, Void arg) {\n            super.visit(n, arg);\n        }",
        "diffSourceCode": "-  101:         doTest(n);\n-  102:         super.visit(n, arg);\n-  103:     }\n-  104: \n-  250:     @Override public void visit(final ImportDeclaration n, final Object arg) {\n-  251:         doTest(n);\n-  252:         super.visit(n, arg);\n-  253:     }\n+  101:         @Override\n+  102:         public void visit(BlockComment n, Void arg) {\n+  103:             super.visit(n, arg);\n+  104:         }\n+  250:         public void visit(FieldDeclaration n, Void arg) {\n+  251:             assertParentIsSet(n);\n+  252:             super.visit(n, arg);\n+  253:         }\n",
        "uniqueId": "731c46d3bd61cc1e3e4733570dd80ab00cd63c87_250_253__101_104",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "testMethod": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 1.8
    },
    {
        "type": "Move And Inline Method",
        "description": "Move And Inline Method\tpublic setDoNotConsiderAnnotationsAsNodeStartForCodeAttribution(newValue boolean) : void moved from class com.github.javaparser.CommentsInserter to class com.github.javaparser.bdd.steps.CommentParsingSteps & inlined to public whenTheDoNotConsiderAnnotationsAsNodeStartForCodeAttributionIsTrueOnTheJavaParser(value boolean) : void",
        "diffLocations": [
            {
                "filePath": "javaparser-testing/src/test/java/com/github/javaparser/bdd/steps/CommentParsingSteps.java",
                "startLine": 88,
                "endLine": 91,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "javaparser-testing/src/test/java/com/github/javaparser/bdd/steps/CommentParsingSteps.java",
                "startLine": 77,
                "endLine": 80,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "javaparser-testing/src/test/java/com/github/javaparser/bdd/steps/CommentParsingSteps.java",
                "startLine": 66,
                "endLine": 68,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "public class CommentParsingSteps {\n\n    private CompilationUnit compilationUnit;",
        "filePathBefore": "javaparser-testing/src/test/java/com/github/javaparser/bdd/steps/CommentParsingSteps.java",
        "isPureRefactoring": true,
        "commitId": "ead1412d06bf2ba7eaec982231023aef4aed370a",
        "packageNameBefore": "com.github.javaparser",
        "classNameBefore": "com.github.javaparser.CommentsInserter",
        "methodNameBefore": "com.github.javaparser.CommentsInserter#setDoNotConsiderAnnotationsAsNodeStartForCodeAttribution",
        "classSignatureBefore": "class CommentsInserter ",
        "methodNameBeforeSet": [
            "com.github.javaparser.CommentsInserter#setDoNotConsiderAnnotationsAsNodeStartForCodeAttribution"
        ],
        "classNameBeforeSet": [
            "com.github.javaparser.CommentsInserter"
        ],
        "classSignatureBeforeSet": [
            "class CommentsInserter "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Copyright (C) 2007-2010 J\u00falio Vilmar Gesser.\n * Copyright (C) 2011, 2013-2016 The JavaParser Team.\n *\n * This file is part of JavaParser.\n * \n * JavaParser can be used either under the terms of\n * a) the GNU Lesser General Public License as published by\n *     the Free Software Foundation, either version 3 of the License, or\n *     (at your option) any later version.\n * b) the terms of the Apache License \n *\n * You should have received a copy of both licenses in LICENCE.LGPL and\n * LICENCE.APACHE. Please refer to those files for details.\n *\n * JavaParser is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n */\n \npackage com.github.javaparser.bdd.steps;\n\nimport static com.github.javaparser.Range.range;\nimport static com.github.javaparser.bdd.steps.SharedSteps.getMemberByTypeAndPosition;\nimport static org.hamcrest.CoreMatchers.instanceOf;\nimport static org.hamcrest.CoreMatchers.is;\nimport static org.hamcrest.CoreMatchers.nullValue;\nimport static org.hamcrest.text.IsEqualIgnoringWhiteSpace.equalToIgnoringWhiteSpace;\nimport static org.junit.Assert.assertThat;\nimport static org.junit.Assert.fail;\n\nimport java.io.IOException;\nimport java.io.StringReader;\n\nimport org.jbehave.core.annotations.Alias;\nimport org.jbehave.core.annotations.Given;\nimport org.jbehave.core.annotations.Then;\nimport org.jbehave.core.annotations.When;\nimport org.jbehave.core.model.ExamplesTable;\nimport org.jbehave.core.steps.Parameters;\n\nimport com.github.javaparser.JavaParser;\nimport com.github.javaparser.ParseException;\nimport com.github.javaparser.TokenMgrException;\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;\nimport com.github.javaparser.ast.body.FieldDeclaration;\nimport com.github.javaparser.ast.body.MethodDeclaration;\nimport com.github.javaparser.ast.body.TypeDeclaration;\nimport com.github.javaparser.ast.body.VariableDeclarator;\nimport com.github.javaparser.ast.comments.BlockComment;\nimport com.github.javaparser.ast.comments.Comment;\nimport com.github.javaparser.ast.comments.CommentsCollection;\nimport com.github.javaparser.ast.comments.CommentsParser;\nimport com.github.javaparser.ast.comments.JavadocComment;\nimport com.github.javaparser.ast.comments.LineComment;\nimport com.github.javaparser.ast.expr.Expression;\nimport com.github.javaparser.ast.expr.IntegerLiteralExpr;\nimport com.github.javaparser.ast.stmt.BlockStmt;\nimport com.github.javaparser.ast.stmt.ExpressionStmt;\nimport com.github.javaparser.ast.type.PrimitiveType;\nimport com.github.javaparser.ast.visitor.DumpVisitor;\nimport com.github.javaparser.bdd.TestUtils;\n\npublic class CommentParsingSteps {\n\n    private CompilationUnit compilationUnit;\n    private CommentsCollection commentsCollection;\n    private String sourceUnderTest;\n\n    @Given(\"the class:$classSrc\")\n    public void givenTheClass(String classSrc) {\n        this.sourceUnderTest = classSrc.trim();\n    }\n\n    @When(\"read sample \\\"$sampleName\\\" using encoding \\\"$encoding\\\"\")\n    public void givenTheClassWithEncoding(String sampleName, String encoding) throws IOException {\n        sourceUnderTest = null;\n        commentsCollection = new CommentsParser().parse(TestUtils.getSampleStream(sampleName), encoding);\n    }\n\n    @When(\"the class is parsed by the comment parser\")\n    public void whenTheClassIsParsedByTheCommentParser() throws IOException {\n        commentsCollection = new CommentsParser().parse(sourceUnderTest);\n    }\n\n    @When(\"the do not consider annotations as node start for code attribution is $value on the Java parser\")\n    public void whenTheDoNotConsiderAnnotationsAsNodeStartForCodeAttributionIsTrueOnTheJavaParser(boolean value) {\n        JavaParser.setDoNotConsiderAnnotationsAsNodeStartForCodeAttribution(value);\n    }\n\n    @When(\"the class is parsed by the Java parser\")\n    public void whenTheClassIsParsedByTheJavaParser() throws ParseException {\n        compilationUnit = JavaParser.parse(sourceUnderTest);\n    }\n\n    @Then(\"the Java parser cannot parse it because of lexical errors\")\n    public void javaParserCannotParseBecauseOfLexicalErrors() throws ParseException {\n        try {\n            compilationUnit = JavaParser.parse(sourceUnderTest);\n            fail(\"Lexical error expected\");\n        } catch (TokenMgrException e) {\n            // ok\n        }\n    }\n\n    @Then(\"the total number of comments is $expectedCount\")\n    public void thenTheTotalNumberOfCommentsIs(int expectedCount) {\n        assertThat(commentsCollection.size(), is(expectedCount));\n    }\n\n    @Then(\"line comment $position is \\\"$expectedContent\\\"\")\n    public void thenLineCommentIs(int position, String expectedContent) {\n        LineComment lineCommentUnderTest = commentsCollection.getLineComments().get(position-1);\n\n        assertThat(lineCommentUnderTest.getContent(), is(expectedContent));\n    }\n\n    @Then(\"block comment $position is \\\"$expectedContent\\\"\")\n    public void thenBlockCommentIs(int position, String expectedContent) {\n        BlockComment lineCommentUnderTest = commentsCollection.getBlockComments().get(position - 1);\n\n        assertThat(lineCommentUnderTest.getContent(), is(equalToIgnoringWhiteSpace(expectedContent)));\n    }\n\n    @Then(\"Javadoc comment $position is \\\"$expectedContent\\\"\")\n    public void thenJavadocCommentIs(int position, String expectedContent) {\n        JavadocComment commentUnderTest = commentsCollection.getJavadocComments().get(position- 1);\n\n        assertThat(commentUnderTest.getContent(), is(equalToIgnoringWhiteSpace(expectedContent)));\n    }\n\n    @Then(\"the line comments have the following positions: $table\")\n    public void thenTheLineCommentsHaveTheFollowingPositions(ExamplesTable examplesTable) {\n        int index = 0;\n        for(Parameters exampleRow : examplesTable.getRowsAsParameters()){\n            Comment expectedLineComment = toComment(exampleRow, new LineComment());\n            Comment lineCommentUnderTest = commentsCollection.getLineComments().get(index);\n\n            assertThat(lineCommentUnderTest.getBegin().line, is(expectedLineComment.getBegin().line));\n            assertThat(lineCommentUnderTest.getBegin().column, is(expectedLineComment.getBegin().column));\n            assertThat(lineCommentUnderTest.getEnd().line, is(expectedLineComment.getEnd().line));\n            assertThat(lineCommentUnderTest.getEnd().column, is(expectedLineComment.getEnd().column));\n            index ++;\n        }\n    }\n\n    @Then(\"the block comments have the following positions: $table\")\n    public void thenTheBlockCommentsHaveTheFollowingPositions(ExamplesTable examplesTable) {\n        int index = 0;\n        for(Parameters exampleRow : examplesTable.getRowsAsParameters()){\n            Comment expectedLineComment = toComment(exampleRow, new BlockComment());\n            Comment lineCommentUnderTest = commentsCollection.getBlockComments().get(index);\n\n            assertThat(lineCommentUnderTest.getBegin().line, is(expectedLineComment.getBegin().line));\n            assertThat(lineCommentUnderTest.getBegin().column, is(expectedLineComment.getBegin().column));\n            assertThat(lineCommentUnderTest.getEnd().line, is(expectedLineComment.getEnd().line));\n            assertThat(lineCommentUnderTest.getEnd().column, is(expectedLineComment.getEnd().column));\n            index ++;\n        }\n    }\n\n    @Then(\"the Javadoc comments have the following positions: $table\")\n    public void thenTheJavadocCommentsHaveTheFollowingPositions(ExamplesTable examplesTable) {\n        int index = 0;\n        for(Parameters exampleRow : examplesTable.getRowsAsParameters()){\n            Comment expectedLineComment = toComment(exampleRow, new BlockComment());\n            Comment lineCommentUnderTest = commentsCollection.getJavadocComments().get(index);\n\n            assertThat(lineCommentUnderTest.getBegin().line, is(expectedLineComment.getBegin().line));\n            assertThat(lineCommentUnderTest.getBegin().column, is(expectedLineComment.getBegin().column));\n            assertThat(lineCommentUnderTest.getEnd().line, is(expectedLineComment.getEnd().line));\n            assertThat(lineCommentUnderTest.getEnd().column, is(expectedLineComment.getEnd().column));\n            index ++;\n        }\n    }\n\n    @Then(\"it is dumped to:$dumpSrc\")\n    public void isDumpedTo(String dumpSrc) {\n        DumpVisitor dumpVisitor = new DumpVisitor();\n        dumpVisitor.visit(compilationUnit, null);\n        assertThat(dumpVisitor.getSource().trim(), is(dumpSrc.trim()));\n    }\n\n    @Then(\"the compilation unit is not commented\")\n    public void thenTheCompilationUnitIsNotCommented() {\n        assertThat(compilationUnit.getComment(), is(nullValue()));\n    }\n\n    @Then(\"the compilation is commented \\\"$expectedContent\\\"\")\n    public void thenTheCompilationIsCommentedCompilationUnitComment(String expectedContent) {\n        assertThat(compilationUnit.getComment().getContent(), is(expectedContent));\n    }\n\n    @Then(\"the compilation unit has $expectedCount contained comments\")\n    public void thenTheCompilationUnitHasContainedComments(int expectedCount) {\n        assertThat(compilationUnit.getComments().size(), is(expectedCount));\n    }\n\n    @Then(\"the compilation unit has $expectedCount orphan comments\")\n    public void thenTheCompilationUnitHasExpectedCountOrphanComments(int expectedCount) {\n        assertThat(compilationUnit.getOrphanComments().size(), is(expectedCount));\n    }\n\n    @Then(\"the compilation unit orphan comment $position is \\\"$expectedContent\\\"\")\n    public void thenTheCompilationUnitOrphanCommentIs(int position, String expectedContent) {\n        Comment commentUnderTest = compilationUnit.getOrphanComments().get(position - 1);\n        assertThat(commentUnderTest.getContent(), is(equalToIgnoringWhiteSpace(expectedContent)));\n    }\n\n    @Then(\"comment $commentPosition in compilation unit is not an orphan\")\n    public void thenCommentInCompilationUnitIsNotAnOrphan(int commentPosition) {\n        Comment commentUnderTest = compilationUnit.getAllContainedComments().get(commentPosition - 1);\n        assertThat(commentUnderTest.isOrphan(), is(false));\n    }\n\n    @Then(\"comment $commentPosition in compilation unit is an orphan\")\n    public void thenCommentInCompilationUnitIsAnOrphan(int commentPosition) {\n        Comment commentUnderTest = compilationUnit.getAllContainedComments().get(commentPosition - 1);\n        assertThat(commentUnderTest.isOrphan(), is(true));\n    }\n\n    @Then(\"comment $commentPosition in compilation unit is \\\"$expectedContent\\\"\")\n    public void thenCommentInCompilationUnitIs(int position, String expectedContent) {\n        Comment commentUnderTest = compilationUnit.getAllContainedComments().get(position - 1);\n        assertThat(commentUnderTest.getContent(), is(equalToIgnoringWhiteSpace(expectedContent)));\n    }\n\n    @Then(\"class $position is not commented\")\n    public void thenClassIsNotCommented(int position) {\n\t\tTypeDeclaration<?> classUnderTest = compilationUnit.getTypes().get(position - 1);\n        assertThat(classUnderTest.getComment(), is(nullValue()));\n    }\n\n    @Then(\"class $position is commented \\\"$expectedContent\\\"\")\n    public void thenClassIsCommented(int position, String expectedContent) {\n\t\tTypeDeclaration<?> classUnderTest = compilationUnit.getTypes().get(position - 1);\n        assertThat(classUnderTest.getComment().getContent(), is(expectedContent));\n    }\n\n    @Then(\"class $position has $expectedCount total contained comments\")\n    public void thenClassHasTotalContainedComments(int position, int expectedCount) {\n\t\tTypeDeclaration<?> classUnderTest = compilationUnit.getTypes().get(position - 1);\n        assertThat(classUnderTest.getAllContainedComments().size(), is(expectedCount));\n    }\n\n    @Then(\"class $position has $expectedCount orphan comment\")\n    @Alias(\"class $position has $expectedCount orphan comments\")\n    public void thenClassHasOrphanComments(int position, int expectedCount) {\n\t\tTypeDeclaration<?> classUnderTest = compilationUnit.getTypes().get(position - 1);\n        assertThat(classUnderTest.getOrphanComments().size(), is(expectedCount));\n    }\n\n    @Then(\"class $classPosition orphan comment $commentPosition is \\\"$expectedContent\\\"\")\n    public void thenClassOrphanCommentIs(int classPosition, int commentPosition, String expectedContent) {\n\t\tTypeDeclaration<?> classUnderTest = compilationUnit.getTypes().get(classPosition - 1);\n        Comment commentUnderTest = classUnderTest.getOrphanComments().get(commentPosition -1 );\n        assertThat(commentUnderTest.getContent(), is(equalToIgnoringWhiteSpace(expectedContent)));\n    }\n\n    @Then(\"method $methodPosition in class $classPosition is commented \\\"$expectedContent\\\"\")\n    public void thenMethodInClassIsCommented(int methodPosition, int classPosition, String expectedContent) {\n\t\tTypeDeclaration<?> classUnderTest = compilationUnit.getTypes().get(classPosition - 1);\n        MethodDeclaration methodUnderTest = (MethodDeclaration) getMemberByTypeAndPosition(classUnderTest, methodPosition - 1,\n                MethodDeclaration.class);\n        assertThat(methodUnderTest.getComment().getContent(), equalToIgnoringWhiteSpace(expectedContent));\n    }\n\n    @Then(\"method $methodPosition in class $classPosition has $expectedCount total contained comments\")\n    public void thenMethodInClassHasTotalContainedComments(int methodPosition, int classPosition, int expectedCount) {\n\t\tTypeDeclaration<?> classUnderTest = compilationUnit.getTypes().get(classPosition - 1);\n        MethodDeclaration methodUnderTest = (MethodDeclaration) getMemberByTypeAndPosition(classUnderTest, methodPosition - 1,\n                MethodDeclaration.class);\n        assertThat(methodUnderTest.getAllContainedComments().size(), is(expectedCount));\n    }\n\n    @Then(\"comment $commentPosition in method $methodPosition in class $classPosition is \\\"$expectedContent\\\"\")\n    public void thenCommentInMethodInClassIs(int commentPosition, int methodPosition, int classPosition, String expectedContent) {\n\t\tTypeDeclaration<?> classUnderTest = compilationUnit.getTypes().get(classPosition - 1);\n        MethodDeclaration methodUnderTest = (MethodDeclaration) getMemberByTypeAndPosition(classUnderTest, methodPosition - 1,\n                MethodDeclaration.class);\n        Comment commentUnderTest = methodUnderTest.getAllContainedComments().get(commentPosition - 1);\n        assertThat(commentUnderTest.getContent(), is(equalToIgnoringWhiteSpace(expectedContent)));\n    }\n\n    @Then(\"method $methodPosition in class $classPosition has $expectedCount orphan comments\")\n    public void thenMethodInClassHasOrphanComments(int methodPosition, int classPosition, int expectedCount) {\n\t\tTypeDeclaration<?> classUnderTest = compilationUnit.getTypes().get(classPosition - 1);\n        MethodDeclaration methodUnderTest = (MethodDeclaration) getMemberByTypeAndPosition(classUnderTest, methodPosition - 1,\n                MethodDeclaration.class);\n        assertThat(methodUnderTest.getOrphanComments().size(), is(expectedCount));\n    }\n\n    @Then(\"block statement in method $methodPosition in class $classPosition has $expectedCount total contained comments\")\n    public void thenBlockStatementInMethodInClassHasTotalContainedComments(int methodPosition, int classPosition, int expectedCount) {\n\t\tTypeDeclaration<?> classUnderTest = compilationUnit.getTypes().get(classPosition - 1);\n        MethodDeclaration methodUnderTest = (MethodDeclaration) getMemberByTypeAndPosition(classUnderTest, methodPosition - 1,\n                MethodDeclaration.class);\n        BlockStmt blockStmtUnderTest = methodUnderTest.getBody();\n        assertThat(blockStmtUnderTest.getAllContainedComments().size(), is(expectedCount));\n    }\n\n    @Then(\"block statement in method $methodPosition in class $classPosition has $expectedCount orphan comments\")\n    public void thenBlockStatementInMethodInClassHasOrphanComments(int methodPosition, int classPosition, int expectedCount) {\n\t\tTypeDeclaration<?> classUnderTest = compilationUnit.getTypes().get(classPosition - 1);\n        MethodDeclaration methodUnderTest = (MethodDeclaration) getMemberByTypeAndPosition(classUnderTest, methodPosition - 1,\n                MethodDeclaration.class);\n        BlockStmt blockStmtUnderTest = methodUnderTest.getBody();\n        assertThat(blockStmtUnderTest.getOrphanComments().size(), is(expectedCount));\n    }\n\n    @Then(\"block statement in method $methodPosition in class $classPosition orphan comment $commentPosition is \\\"$expectedContent\\\"\")\n    public void thenBlockStatementInMethodInClassIs(int methodPosition, int classPosition, int commentPosition, String expectedContent) {\n\t\tTypeDeclaration<?> classUnderTest = compilationUnit.getTypes().get(classPosition - 1);\n        MethodDeclaration methodUnderTest = (MethodDeclaration) getMemberByTypeAndPosition(classUnderTest, methodPosition -1,\n                MethodDeclaration.class);\n        BlockStmt blockStmtUnderTest = methodUnderTest.getBody();\n        Comment commentUnderTest = blockStmtUnderTest.getOrphanComments().get(commentPosition - 1);\n        assertThat(commentUnderTest.getContent(), is(equalToIgnoringWhiteSpace(expectedContent)));\n    }\n\n    @Then(\"type of method $methodPosition in class $classPosition is commented \\\"$expectedContent\\\"\")\n    public void thenTypeOfMethodInClassIsCommented(int methodPosition, int classPosition, String expectedContent) {\n\t\tTypeDeclaration<?> classUnderTest = compilationUnit.getTypes().get(classPosition - 1);\n        MethodDeclaration methodUnderTest = (MethodDeclaration) getMemberByTypeAndPosition(classUnderTest, methodPosition -1,\n                MethodDeclaration.class);\n        Comment commentUnderTest = methodUnderTest.getType().getComment();\n        assertThat(commentUnderTest.getContent(), is(equalToIgnoringWhiteSpace(expectedContent)));\n    }\n\n    @Then(\"field $fieldPosition in class $classPosition contains $expectedCount comments\")\n    public void thenFieldInClassContainsComments(int fieldPosition, int classPosition, int expectedCount) {\n\t\tTypeDeclaration<?> classUnderTest = compilationUnit.getTypes().get(classPosition - 1);\n        FieldDeclaration fieldUnderTest = (FieldDeclaration) getMemberByTypeAndPosition(classUnderTest, fieldPosition - 1,\n                FieldDeclaration.class);\n        assertThat(fieldUnderTest.getAllContainedComments().size(), is(expectedCount));\n    }\n\n    @Then(\"field $fieldPosition in class $classPosition is not commented\")\n    public void thenFieldInClassIsNotCommented(int fieldPosition, int classPosition) {\n\t\tTypeDeclaration<?> classUnderTest = compilationUnit.getTypes().get(classPosition - 1);\n        FieldDeclaration fieldUnderTest = (FieldDeclaration) getMemberByTypeAndPosition(classUnderTest, fieldPosition - 1,\n                FieldDeclaration.class);\n        assertThat(fieldUnderTest.getComment(), is(nullValue()));\n    }\n\n    @Then(\"field $fieldPosition in class $classPosition is commented \\\"$expectedContent\\\"\")\n    public void thenFieldInClassIsCommented(int fieldPosition, int classPosition, String expectedContent) {\n\t\tTypeDeclaration<?> classUnderTest = compilationUnit.getTypes().get(classPosition - 1);\n        FieldDeclaration fieldUnderTest = (FieldDeclaration) getMemberByTypeAndPosition(classUnderTest, fieldPosition - 1,\n                FieldDeclaration.class);\n        Comment commentUnderTest = fieldUnderTest.getComment();\n        assertThat(commentUnderTest.getContent(), is(equalToIgnoringWhiteSpace(expectedContent)));\n    }\n\n    @Then(\"variable $variablePosition value of field $fieldPosition in class $classPosition is commented \\\"$expectedContent\\\"\")\n    public void thenVariableValueOfFieldInClassIsCommented(int variablePosition, int fieldPosition, int classPosition, String expectedContent) {\n\t\tTypeDeclaration<?> classUnderTest = compilationUnit.getTypes().get(classPosition - 1);\n        FieldDeclaration fieldUnderTest = (FieldDeclaration) getMemberByTypeAndPosition(classUnderTest, fieldPosition - 1,\n                FieldDeclaration.class);\n        VariableDeclarator variableUnderTest = fieldUnderTest.getVariables().get(variablePosition - 1);\n        Expression valueUnderTest = variableUnderTest.getInit();\n        Comment commentUnderTest = valueUnderTest.getComment();\n        assertThat(commentUnderTest.getContent(), is(expectedContent));\n    }\n\n    @Then(\"comment $commentPosition in compilation unit parent is ClassOrInterfaceDeclaration\")\n    public void thenCommentInCompilationUnitParentIsClassOrInterfaceDeclaration(int commentPosition) {\n        Comment commentUnderTest = compilationUnit.getAllContainedComments().get(commentPosition - 1);\n        assertThat(commentUnderTest.getParentNode(), instanceOf(ClassOrInterfaceDeclaration.class));\n    }\n\n    @Then(\"comment $commentPosition in compilation unit commented node is ClassOrInterfaceDeclaration\")\n    public void thenCommentInCompilationUnitCommentedNodeIsClassOrInterfaceDeclaration(int commentPosition) {\n        Comment commentUnderTest = compilationUnit.getAllContainedComments().get(commentPosition - 1);\n        assertThat(commentUnderTest.getCommentedNode(), instanceOf(ClassOrInterfaceDeclaration.class));\n    }\n\n    @Then(\"comment $commentPosition in compilation unit commented node is FieldDeclaration\")\n    public void thenCommentInCompilationUnitCommentedNodeIsFieldDeclaration(int commentPosition) {\n        Comment commentUnderTest = compilationUnit.getAllContainedComments().get(commentPosition - 1);\n        assertThat(commentUnderTest.getCommentedNode(), instanceOf(FieldDeclaration.class));\n    }\n\n    @Then(\"comment $commentPosition in compilation unit commented node is IntegerLiteralExpr\")\n    public void thenCommentInCompilationUnitCommentedNodeIsIntegerLiteralExpr(int commentPosition) {\n        Comment commentUnderTest = compilationUnit.getAllContainedComments().get(commentPosition - 1);\n        assertThat(commentUnderTest.getCommentedNode(), instanceOf(IntegerLiteralExpr.class));\n    }\n\n    @Then(\"comment $commentPosition in compilation unit commented node is ExpressionStmt\")\n    public void thenCommentInCompilationUnitCommentedNodeIsIntegerExpressionStmt(int commentPosition) {\n        Comment commentUnderTest = compilationUnit.getAllContainedComments().get(commentPosition - 1);\n        assertThat(commentUnderTest.getCommentedNode(), instanceOf(ExpressionStmt.class));\n    }\n\n    @Then(\"comment $commentPosition in compilation unit commented node is PrimitiveType\")\n    public void thenCommentInCompilationUnitCommentedNodeIsIntegerPrimitiveType(int commentPosition) {\n        Comment commentUnderTest = compilationUnit.getAllContainedComments().get(commentPosition - 1);\n        assertThat(commentUnderTest.getCommentedNode(), instanceOf(PrimitiveType.class));\n    }\n\n    private Comment toComment(Parameters row, Comment comment) {\n        comment.setRange(range(Integer.parseInt(row.values().get(\"beginLine\")),\n                Integer.parseInt(row.values().get(\"beginColumn\")),\n                Integer.parseInt(row.values().get(\"endLine\")),\n                Integer.parseInt(row.values().get(\"endColumn\"))));\n        return comment;\n    }\n}\n",
        "filePathAfter": "javaparser-testing/src/test/java/com/github/javaparser/bdd/steps/CommentParsingSteps.java",
        "sourceCodeAfterForWhole": "/*\n * Copyright (C) 2007-2010 J\u00falio Vilmar Gesser.\n * Copyright (C) 2011, 2013-2016 The JavaParser Team.\n *\n * This file is part of JavaParser.\n * \n * JavaParser can be used either under the terms of\n * a) the GNU Lesser General Public License as published by\n *     the Free Software Foundation, either version 3 of the License, or\n *     (at your option) any later version.\n * b) the terms of the Apache License \n *\n * You should have received a copy of both licenses in LICENCE.LGPL and\n * LICENCE.APACHE. Please refer to those files for details.\n *\n * JavaParser is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n */\n \npackage com.github.javaparser.bdd.steps;\n\nimport com.github.javaparser.JavaParser;\nimport com.github.javaparser.ParseResult;\nimport com.github.javaparser.ParserConfiguration;\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.body.*;\nimport com.github.javaparser.ast.comments.*;\nimport com.github.javaparser.ast.expr.Expression;\nimport com.github.javaparser.ast.expr.IntegerLiteralExpr;\nimport com.github.javaparser.ast.stmt.BlockStmt;\nimport com.github.javaparser.ast.stmt.ExpressionStmt;\nimport com.github.javaparser.ast.type.PrimitiveType;\nimport com.github.javaparser.ast.visitor.DumpVisitor;\nimport com.github.javaparser.bdd.TestUtils;\nimport org.jbehave.core.annotations.Alias;\nimport org.jbehave.core.annotations.Given;\nimport org.jbehave.core.annotations.Then;\nimport org.jbehave.core.annotations.When;\nimport org.jbehave.core.model.ExamplesTable;\nimport org.jbehave.core.steps.Parameters;\n\nimport java.io.IOException;\n\nimport static com.github.javaparser.Providers.provider;\nimport static com.github.javaparser.Range.range;\nimport static com.github.javaparser.bdd.steps.SharedSteps.getMemberByTypeAndPosition;\nimport static org.hamcrest.CoreMatchers.*;\nimport static org.hamcrest.text.IsEqualIgnoringWhiteSpace.equalToIgnoringWhiteSpace;\nimport static org.junit.Assert.assertThat;\nimport static org.junit.Assert.fail;\n\npublic class CommentParsingSteps {\n\n    private CompilationUnit compilationUnit;\n    private CommentsCollection commentsCollection;\n    private String sourceUnderTest;\n    private ParserConfiguration configuration = new ParserConfiguration();\n\n    @Given(\"the class:$classSrc\")\n    public void givenTheClass(String classSrc) {\n        this.sourceUnderTest = classSrc.trim();\n    }\n\n    @When(\"read sample \\\"$sampleName\\\" using encoding \\\"$encoding\\\"\")\n    public void givenTheClassWithEncoding(String sampleName, String encoding) throws IOException {\n        sourceUnderTest = null;\n        commentsCollection = new CommentsParser().parse(TestUtils.getSampleStream(sampleName), encoding);\n    }\n\n    @When(\"the class is parsed by the comment parser\")\n    public void whenTheClassIsParsedByTheCommentParser() throws IOException {\n        commentsCollection = new CommentsParser().parse(sourceUnderTest);\n    }\n\n    @When(\"the do not consider annotations as node start for code attribution is $value on the Java parser\")\n    public void whenTheDoNotConsiderAnnotationsAsNodeStartForCodeAttributionIsTrueOnTheJavaParser(boolean value) {\n        configuration.doNotConsiderAnnotationsAsNodeStartForCodeAttribution = value;\n    }\n\n    @When(\"the do not assign comments preceding empty lines is $value on the Java parser\")\n    public void whenTheDoNotAssignCommentsPrecedingEmptyLinesIsTrueOnTheJavaParser(boolean value) {\n        configuration.doNotAssignCommentsPrecedingEmptyLines = value;\n    }\n\n    @When(\"the class is parsed by the Java parser\")\n    public void whenTheClassIsParsedByTheJavaParser() {\n        compilationUnit = new JavaParser(configuration).parseFull(provider(sourceUnderTest)).result.get();\n    }\n\n    @Then(\"the Java parser cannot parse it because of lexical errors\")\n    public void javaParserCannotParseBecauseOfLexicalErrors() {\n        ParseResult<CompilationUnit> result = new JavaParser(configuration).parseFull(provider(sourceUnderTest));\n        if(result.isSuccessful()){\n            fail(\"Lexical error expected\");\n        }\n    }\n\n    @Then(\"the total number of comments is $expectedCount\")\n    public void thenTheTotalNumberOfCommentsIs(int expectedCount) {\n        assertThat(commentsCollection.size(), is(expectedCount));\n    }\n\n    @Then(\"line comment $position is \\\"$expectedContent\\\"\")\n    public void thenLineCommentIs(int position, String expectedContent) {\n        LineComment lineCommentUnderTest = commentsCollection.getLineComments().get(position-1);\n\n        assertThat(lineCommentUnderTest.getContent(), is(expectedContent));\n    }\n\n    @Then(\"block comment $position is \\\"$expectedContent\\\"\")\n    public void thenBlockCommentIs(int position, String expectedContent) {\n        BlockComment lineCommentUnderTest = commentsCollection.getBlockComments().get(position - 1);\n\n        assertThat(lineCommentUnderTest.getContent(), is(equalToIgnoringWhiteSpace(expectedContent)));\n    }\n\n    @Then(\"Javadoc comment $position is \\\"$expectedContent\\\"\")\n    public void thenJavadocCommentIs(int position, String expectedContent) {\n        JavadocComment commentUnderTest = commentsCollection.getJavadocComments().get(position- 1);\n\n        assertThat(commentUnderTest.getContent(), is(equalToIgnoringWhiteSpace(expectedContent)));\n    }\n\n    @Then(\"the line comments have the following positions: $table\")\n    public void thenTheLineCommentsHaveTheFollowingPositions(ExamplesTable examplesTable) {\n        int index = 0;\n        for(Parameters exampleRow : examplesTable.getRowsAsParameters()){\n            Comment expectedLineComment = toComment(exampleRow, new LineComment());\n            Comment lineCommentUnderTest = commentsCollection.getLineComments().get(index);\n\n            assertThat(lineCommentUnderTest.getBegin().line, is(expectedLineComment.getBegin().line));\n            assertThat(lineCommentUnderTest.getBegin().column, is(expectedLineComment.getBegin().column));\n            assertThat(lineCommentUnderTest.getEnd().line, is(expectedLineComment.getEnd().line));\n            assertThat(lineCommentUnderTest.getEnd().column, is(expectedLineComment.getEnd().column));\n            index ++;\n        }\n    }\n\n    @Then(\"the block comments have the following positions: $table\")\n    public void thenTheBlockCommentsHaveTheFollowingPositions(ExamplesTable examplesTable) {\n        int index = 0;\n        for(Parameters exampleRow : examplesTable.getRowsAsParameters()){\n            Comment expectedLineComment = toComment(exampleRow, new BlockComment());\n            Comment lineCommentUnderTest = commentsCollection.getBlockComments().get(index);\n\n            assertThat(lineCommentUnderTest.getBegin().line, is(expectedLineComment.getBegin().line));\n            assertThat(lineCommentUnderTest.getBegin().column, is(expectedLineComment.getBegin().column));\n            assertThat(lineCommentUnderTest.getEnd().line, is(expectedLineComment.getEnd().line));\n            assertThat(lineCommentUnderTest.getEnd().column, is(expectedLineComment.getEnd().column));\n            index ++;\n        }\n    }\n\n    @Then(\"the Javadoc comments have the following positions: $table\")\n    public void thenTheJavadocCommentsHaveTheFollowingPositions(ExamplesTable examplesTable) {\n        int index = 0;\n        for(Parameters exampleRow : examplesTable.getRowsAsParameters()){\n            Comment expectedLineComment = toComment(exampleRow, new BlockComment());\n            Comment lineCommentUnderTest = commentsCollection.getJavadocComments().get(index);\n\n            assertThat(lineCommentUnderTest.getBegin().line, is(expectedLineComment.getBegin().line));\n            assertThat(lineCommentUnderTest.getBegin().column, is(expectedLineComment.getBegin().column));\n            assertThat(lineCommentUnderTest.getEnd().line, is(expectedLineComment.getEnd().line));\n            assertThat(lineCommentUnderTest.getEnd().column, is(expectedLineComment.getEnd().column));\n            index ++;\n        }\n    }\n\n    @Then(\"it is dumped to:$dumpSrc\")\n    public void isDumpedTo(String dumpSrc) {\n        DumpVisitor dumpVisitor = new DumpVisitor();\n        dumpVisitor.visit(compilationUnit, null);\n        assertThat(dumpVisitor.getSource().trim(), is(dumpSrc.trim()));\n    }\n\n    @Then(\"the compilation unit is not commented\")\n    public void thenTheCompilationUnitIsNotCommented() {\n        assertThat(compilationUnit.getComment(), is(nullValue()));\n    }\n\n    @Then(\"the compilation is commented \\\"$expectedContent\\\"\")\n    public void thenTheCompilationIsCommentedCompilationUnitComment(String expectedContent) {\n        assertThat(compilationUnit.getComment().getContent(), is(expectedContent));\n    }\n\n    @Then(\"the compilation unit has $expectedCount contained comments\")\n    public void thenTheCompilationUnitHasContainedComments(int expectedCount) {\n        assertThat(compilationUnit.getComments().size(), is(expectedCount));\n    }\n\n    @Then(\"the compilation unit has $expectedCount orphan comments\")\n    public void thenTheCompilationUnitHasExpectedCountOrphanComments(int expectedCount) {\n        assertThat(compilationUnit.getOrphanComments().size(), is(expectedCount));\n    }\n\n    @Then(\"the compilation unit orphan comment $position is \\\"$expectedContent\\\"\")\n    public void thenTheCompilationUnitOrphanCommentIs(int position, String expectedContent) {\n        Comment commentUnderTest = compilationUnit.getOrphanComments().get(position - 1);\n        assertThat(commentUnderTest.getContent(), is(equalToIgnoringWhiteSpace(expectedContent)));\n    }\n\n    @Then(\"comment $commentPosition in compilation unit is not an orphan\")\n    public void thenCommentInCompilationUnitIsNotAnOrphan(int commentPosition) {\n        Comment commentUnderTest = compilationUnit.getAllContainedComments().get(commentPosition - 1);\n        assertThat(commentUnderTest.isOrphan(), is(false));\n    }\n\n    @Then(\"comment $commentPosition in compilation unit is an orphan\")\n    public void thenCommentInCompilationUnitIsAnOrphan(int commentPosition) {\n        Comment commentUnderTest = compilationUnit.getAllContainedComments().get(commentPosition - 1);\n        assertThat(commentUnderTest.isOrphan(), is(true));\n    }\n\n    @Then(\"comment $commentPosition in compilation unit is \\\"$expectedContent\\\"\")\n    public void thenCommentInCompilationUnitIs(int position, String expectedContent) {\n        Comment commentUnderTest = compilationUnit.getAllContainedComments().get(position - 1);\n        assertThat(commentUnderTest.getContent(), is(equalToIgnoringWhiteSpace(expectedContent)));\n    }\n\n    @Then(\"class $position is not commented\")\n    public void thenClassIsNotCommented(int position) {\n\t\tTypeDeclaration<?> classUnderTest = compilationUnit.getTypes().get(position - 1);\n        assertThat(classUnderTest.getComment(), is(nullValue()));\n    }\n\n    @Then(\"class $position is commented \\\"$expectedContent\\\"\")\n    public void thenClassIsCommented(int position, String expectedContent) {\n\t\tTypeDeclaration<?> classUnderTest = compilationUnit.getTypes().get(position - 1);\n        assertThat(classUnderTest.getComment().getContent(), is(expectedContent));\n    }\n\n    @Then(\"class $position has $expectedCount total contained comments\")\n    public void thenClassHasTotalContainedComments(int position, int expectedCount) {\n\t\tTypeDeclaration<?> classUnderTest = compilationUnit.getTypes().get(position - 1);\n        assertThat(classUnderTest.getAllContainedComments().size(), is(expectedCount));\n    }\n\n    @Then(\"class $position has $expectedCount orphan comment\")\n    @Alias(\"class $position has $expectedCount orphan comments\")\n    public void thenClassHasOrphanComments(int position, int expectedCount) {\n\t\tTypeDeclaration<?> classUnderTest = compilationUnit.getTypes().get(position - 1);\n        assertThat(classUnderTest.getOrphanComments().size(), is(expectedCount));\n    }\n\n    @Then(\"class $classPosition orphan comment $commentPosition is \\\"$expectedContent\\\"\")\n    public void thenClassOrphanCommentIs(int classPosition, int commentPosition, String expectedContent) {\n\t\tTypeDeclaration<?> classUnderTest = compilationUnit.getTypes().get(classPosition - 1);\n        Comment commentUnderTest = classUnderTest.getOrphanComments().get(commentPosition -1 );\n        assertThat(commentUnderTest.getContent(), is(equalToIgnoringWhiteSpace(expectedContent)));\n    }\n\n    @Then(\"method $methodPosition in class $classPosition is commented \\\"$expectedContent\\\"\")\n    public void thenMethodInClassIsCommented(int methodPosition, int classPosition, String expectedContent) {\n\t\tTypeDeclaration<?> classUnderTest = compilationUnit.getTypes().get(classPosition - 1);\n        MethodDeclaration methodUnderTest = (MethodDeclaration) getMemberByTypeAndPosition(classUnderTest, methodPosition - 1,\n                MethodDeclaration.class);\n        assertThat(methodUnderTest.getComment().getContent(), equalToIgnoringWhiteSpace(expectedContent));\n    }\n\n    @Then(\"method $methodPosition in class $classPosition has $expectedCount total contained comments\")\n    public void thenMethodInClassHasTotalContainedComments(int methodPosition, int classPosition, int expectedCount) {\n\t\tTypeDeclaration<?> classUnderTest = compilationUnit.getTypes().get(classPosition - 1);\n        MethodDeclaration methodUnderTest = (MethodDeclaration) getMemberByTypeAndPosition(classUnderTest, methodPosition - 1,\n                MethodDeclaration.class);\n        assertThat(methodUnderTest.getAllContainedComments().size(), is(expectedCount));\n    }\n\n    @Then(\"comment $commentPosition in method $methodPosition in class $classPosition is \\\"$expectedContent\\\"\")\n    public void thenCommentInMethodInClassIs(int commentPosition, int methodPosition, int classPosition, String expectedContent) {\n\t\tTypeDeclaration<?> classUnderTest = compilationUnit.getTypes().get(classPosition - 1);\n        MethodDeclaration methodUnderTest = (MethodDeclaration) getMemberByTypeAndPosition(classUnderTest, methodPosition - 1,\n                MethodDeclaration.class);\n        Comment commentUnderTest = methodUnderTest.getAllContainedComments().get(commentPosition - 1);\n        assertThat(commentUnderTest.getContent(), is(equalToIgnoringWhiteSpace(expectedContent)));\n    }\n\n    @Then(\"method $methodPosition in class $classPosition has $expectedCount orphan comments\")\n    public void thenMethodInClassHasOrphanComments(int methodPosition, int classPosition, int expectedCount) {\n\t\tTypeDeclaration<?> classUnderTest = compilationUnit.getTypes().get(classPosition - 1);\n        MethodDeclaration methodUnderTest = (MethodDeclaration) getMemberByTypeAndPosition(classUnderTest, methodPosition - 1,\n                MethodDeclaration.class);\n        assertThat(methodUnderTest.getOrphanComments().size(), is(expectedCount));\n    }\n\n    @Then(\"block statement in method $methodPosition in class $classPosition has $expectedCount total contained comments\")\n    public void thenBlockStatementInMethodInClassHasTotalContainedComments(int methodPosition, int classPosition, int expectedCount) {\n\t\tTypeDeclaration<?> classUnderTest = compilationUnit.getTypes().get(classPosition - 1);\n        MethodDeclaration methodUnderTest = (MethodDeclaration) getMemberByTypeAndPosition(classUnderTest, methodPosition - 1,\n                MethodDeclaration.class);\n        BlockStmt blockStmtUnderTest = methodUnderTest.getBody();\n        assertThat(blockStmtUnderTest.getAllContainedComments().size(), is(expectedCount));\n    }\n\n    @Then(\"block statement in method $methodPosition in class $classPosition has $expectedCount orphan comments\")\n    public void thenBlockStatementInMethodInClassHasOrphanComments(int methodPosition, int classPosition, int expectedCount) {\n\t\tTypeDeclaration<?> classUnderTest = compilationUnit.getTypes().get(classPosition - 1);\n        MethodDeclaration methodUnderTest = (MethodDeclaration) getMemberByTypeAndPosition(classUnderTest, methodPosition - 1,\n                MethodDeclaration.class);\n        BlockStmt blockStmtUnderTest = methodUnderTest.getBody();\n        assertThat(blockStmtUnderTest.getOrphanComments().size(), is(expectedCount));\n    }\n\n    @Then(\"block statement in method $methodPosition in class $classPosition orphan comment $commentPosition is \\\"$expectedContent\\\"\")\n    public void thenBlockStatementInMethodInClassIs(int methodPosition, int classPosition, int commentPosition, String expectedContent) {\n\t\tTypeDeclaration<?> classUnderTest = compilationUnit.getTypes().get(classPosition - 1);\n        MethodDeclaration methodUnderTest = (MethodDeclaration) getMemberByTypeAndPosition(classUnderTest, methodPosition -1,\n                MethodDeclaration.class);\n        BlockStmt blockStmtUnderTest = methodUnderTest.getBody();\n        Comment commentUnderTest = blockStmtUnderTest.getOrphanComments().get(commentPosition - 1);\n        assertThat(commentUnderTest.getContent(), is(equalToIgnoringWhiteSpace(expectedContent)));\n    }\n\n    @Then(\"type of method $methodPosition in class $classPosition is commented \\\"$expectedContent\\\"\")\n    public void thenTypeOfMethodInClassIsCommented(int methodPosition, int classPosition, String expectedContent) {\n\t\tTypeDeclaration<?> classUnderTest = compilationUnit.getTypes().get(classPosition - 1);\n        MethodDeclaration methodUnderTest = (MethodDeclaration) getMemberByTypeAndPosition(classUnderTest, methodPosition -1,\n                MethodDeclaration.class);\n        Comment commentUnderTest = methodUnderTest.getType().getComment();\n        assertThat(commentUnderTest.getContent(), is(equalToIgnoringWhiteSpace(expectedContent)));\n    }\n\n    @Then(\"field $fieldPosition in class $classPosition contains $expectedCount comments\")\n    public void thenFieldInClassContainsComments(int fieldPosition, int classPosition, int expectedCount) {\n\t\tTypeDeclaration<?> classUnderTest = compilationUnit.getTypes().get(classPosition - 1);\n        FieldDeclaration fieldUnderTest = (FieldDeclaration) getMemberByTypeAndPosition(classUnderTest, fieldPosition - 1,\n                FieldDeclaration.class);\n        assertThat(fieldUnderTest.getAllContainedComments().size(), is(expectedCount));\n    }\n\n    @Then(\"field $fieldPosition in class $classPosition is not commented\")\n    public void thenFieldInClassIsNotCommented(int fieldPosition, int classPosition) {\n\t\tTypeDeclaration<?> classUnderTest = compilationUnit.getTypes().get(classPosition - 1);\n        FieldDeclaration fieldUnderTest = (FieldDeclaration) getMemberByTypeAndPosition(classUnderTest, fieldPosition - 1,\n                FieldDeclaration.class);\n        assertThat(fieldUnderTest.getComment(), is(nullValue()));\n    }\n\n    @Then(\"field $fieldPosition in class $classPosition is commented \\\"$expectedContent\\\"\")\n    public void thenFieldInClassIsCommented(int fieldPosition, int classPosition, String expectedContent) {\n\t\tTypeDeclaration<?> classUnderTest = compilationUnit.getTypes().get(classPosition - 1);\n        FieldDeclaration fieldUnderTest = (FieldDeclaration) getMemberByTypeAndPosition(classUnderTest, fieldPosition - 1,\n                FieldDeclaration.class);\n        Comment commentUnderTest = fieldUnderTest.getComment();\n        assertThat(commentUnderTest.getContent(), is(equalToIgnoringWhiteSpace(expectedContent)));\n    }\n\n    @Then(\"variable $variablePosition value of field $fieldPosition in class $classPosition is commented \\\"$expectedContent\\\"\")\n    public void thenVariableValueOfFieldInClassIsCommented(int variablePosition, int fieldPosition, int classPosition, String expectedContent) {\n\t\tTypeDeclaration<?> classUnderTest = compilationUnit.getTypes().get(classPosition - 1);\n        FieldDeclaration fieldUnderTest = (FieldDeclaration) getMemberByTypeAndPosition(classUnderTest, fieldPosition - 1,\n                FieldDeclaration.class);\n        VariableDeclarator variableUnderTest = fieldUnderTest.getVariables().get(variablePosition - 1);\n        Expression valueUnderTest = variableUnderTest.getInit();\n        Comment commentUnderTest = valueUnderTest.getComment();\n        assertThat(commentUnderTest.getContent(), is(expectedContent));\n    }\n\n    @Then(\"comment $commentPosition in compilation unit parent is ClassOrInterfaceDeclaration\")\n    public void thenCommentInCompilationUnitParentIsClassOrInterfaceDeclaration(int commentPosition) {\n        Comment commentUnderTest = compilationUnit.getAllContainedComments().get(commentPosition - 1);\n        assertThat(commentUnderTest.getParentNode(), instanceOf(ClassOrInterfaceDeclaration.class));\n    }\n\n    @Then(\"comment $commentPosition in compilation unit commented node is ClassOrInterfaceDeclaration\")\n    public void thenCommentInCompilationUnitCommentedNodeIsClassOrInterfaceDeclaration(int commentPosition) {\n        Comment commentUnderTest = compilationUnit.getAllContainedComments().get(commentPosition - 1);\n        assertThat(commentUnderTest.getCommentedNode(), instanceOf(ClassOrInterfaceDeclaration.class));\n    }\n\n    @Then(\"comment $commentPosition in compilation unit commented node is FieldDeclaration\")\n    public void thenCommentInCompilationUnitCommentedNodeIsFieldDeclaration(int commentPosition) {\n        Comment commentUnderTest = compilationUnit.getAllContainedComments().get(commentPosition - 1);\n        assertThat(commentUnderTest.getCommentedNode(), instanceOf(FieldDeclaration.class));\n    }\n\n    @Then(\"comment $commentPosition in compilation unit commented node is IntegerLiteralExpr\")\n    public void thenCommentInCompilationUnitCommentedNodeIsIntegerLiteralExpr(int commentPosition) {\n        Comment commentUnderTest = compilationUnit.getAllContainedComments().get(commentPosition - 1);\n        assertThat(commentUnderTest.getCommentedNode(), instanceOf(IntegerLiteralExpr.class));\n    }\n\n    @Then(\"comment $commentPosition in compilation unit commented node is ExpressionStmt\")\n    public void thenCommentInCompilationUnitCommentedNodeIsIntegerExpressionStmt(int commentPosition) {\n        Comment commentUnderTest = compilationUnit.getAllContainedComments().get(commentPosition - 1);\n        assertThat(commentUnderTest.getCommentedNode(), instanceOf(ExpressionStmt.class));\n    }\n\n    @Then(\"comment $commentPosition in compilation unit commented node is PrimitiveType\")\n    public void thenCommentInCompilationUnitCommentedNodeIsIntegerPrimitiveType(int commentPosition) {\n        Comment commentUnderTest = compilationUnit.getAllContainedComments().get(commentPosition - 1);\n        assertThat(commentUnderTest.getCommentedNode(), instanceOf(PrimitiveType.class));\n    }\n\n    private Comment toComment(Parameters row, Comment comment) {\n        comment.setRange(range(Integer.parseInt(row.values().get(\"beginLine\")),\n                Integer.parseInt(row.values().get(\"beginColumn\")),\n                Integer.parseInt(row.values().get(\"endLine\")),\n                Integer.parseInt(row.values().get(\"endColumn\"))));\n        return comment;\n    }\n}\n",
        "diffSourceCodeSet": [],
        "invokedMethodSet": [],
        "sourceCodeAfterRefactoring": "@When(\"the do not consider annotations as node start for code attribution is $value on the Java parser\")\n    public void whenTheDoNotConsiderAnnotationsAsNodeStartForCodeAttributionIsTrueOnTheJavaParser(boolean value) {\n        configuration.doNotConsiderAnnotationsAsNodeStartForCodeAttribution = value;\n    }",
        "diffSourceCode": "-   66: public class CommentParsingSteps {\n-   67: \n-   68:     private CompilationUnit compilationUnit;\n-   77:     @When(\"read sample \\\"$sampleName\\\" using encoding \\\"$encoding\\\"\")\n-   78:     public void givenTheClassWithEncoding(String sampleName, String encoding) throws IOException {\n-   79:         sourceUnderTest = null;\n-   80:         commentsCollection = new CommentsParser().parse(TestUtils.getSampleStream(sampleName), encoding);\n-   88:     @When(\"the do not consider annotations as node start for code attribution is $value on the Java parser\")\n-   89:     public void whenTheDoNotConsiderAnnotationsAsNodeStartForCodeAttributionIsTrueOnTheJavaParser(boolean value) {\n-   90:         JavaParser.setDoNotConsiderAnnotationsAsNodeStartForCodeAttribution(value);\n-   91:     }\n+   66:     @When(\"read sample \\\"$sampleName\\\" using encoding \\\"$encoding\\\"\")\n+   67:     public void givenTheClassWithEncoding(String sampleName, String encoding) throws IOException {\n+   68:         sourceUnderTest = null;\n+   77:     @When(\"the do not consider annotations as node start for code attribution is $value on the Java parser\")\n+   78:     public void whenTheDoNotConsiderAnnotationsAsNodeStartForCodeAttributionIsTrueOnTheJavaParser(boolean value) {\n+   79:         configuration.doNotConsiderAnnotationsAsNodeStartForCodeAttribution = value;\n+   80:     }\n+   88:     public void whenTheClassIsParsedByTheJavaParser() {\n+   89:         compilationUnit = new JavaParser(configuration).parseFull(provider(sourceUnderTest)).result.get();\n+   90:     }\n+   91: \n",
        "uniqueId": "ead1412d06bf2ba7eaec982231023aef4aed370a_88_91__77_80_66_68",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "testMethod": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 1.8
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprotected convertToUsage(classOrInterfaceType ClassOrInterfaceType, context Context) : ResolvedType extracted from protected convertToUsage(type Type, context Context) : ResolvedType in class com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade",
        "diffLocations": [
            {
                "filePath": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java",
                "startLine": 673,
                "endLine": 732,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java",
                "startLine": 677,
                "endLine": 716,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java",
                "startLine": 718,
                "endLine": 739,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "protected ResolvedType convertToUsage(Type type, Context context) {\n        if (context == null) {\n            throw new NullPointerException(\"Context should not be null\");\n        }\n        if (type instanceof ClassOrInterfaceType) {\n            ClassOrInterfaceType classOrInterfaceType = (ClassOrInterfaceType) type;\n            String name = qName(classOrInterfaceType);\n            SymbolReference<ResolvedTypeDeclaration> ref = context.solveType(name);\n            if (!ref.isSolved()) {\n                throw new UnsolvedSymbolException(name);\n            }\n            ResolvedTypeDeclaration typeDeclaration = ref.getCorrespondingDeclaration();\n            List<ResolvedType> typeParameters = Collections.emptyList();\n            if (classOrInterfaceType.getTypeArguments().isPresent()) {\n                typeParameters = classOrInterfaceType.getTypeArguments().get().stream().map((pt) -> convertToUsage(pt, context)).collect(Collectors.toList());\n            }\n            if (typeDeclaration.isTypeParameter()) {\n                if (typeDeclaration instanceof ResolvedTypeParameterDeclaration) {\n                    return new ResolvedTypeVariable((ResolvedTypeParameterDeclaration) typeDeclaration);\n                } else {\n                    JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration = (JavaParserTypeVariableDeclaration) typeDeclaration;\n                    return new ResolvedTypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n                }\n            } else {\n                return new ReferenceTypeImpl((ResolvedReferenceTypeDeclaration) typeDeclaration, typeParameters, typeSolver);\n            }\n        } else if (type instanceof PrimitiveType) {\n            return ResolvedPrimitiveType.byName(((PrimitiveType) type).getType().name());\n        } else if (type instanceof WildcardType) {\n            WildcardType wildcardType = (WildcardType) type;\n            if (wildcardType.getExtendedType().isPresent() && !wildcardType.getSuperType().isPresent()) {\n                return ResolvedWildcard.extendsBound(convertToUsage(wildcardType.getExtendedType().get(), context)); // removed (ReferenceTypeImpl)\n            } else if (!wildcardType.getExtendedType().isPresent() && wildcardType.getSuperType().isPresent()) {\n                return ResolvedWildcard.superBound(convertToUsage(wildcardType.getSuperType().get(), context)); // removed (ReferenceTypeImpl)\n            } else if (!wildcardType.getExtendedType().isPresent() && !wildcardType.getSuperType().isPresent()) {\n                return ResolvedWildcard.UNBOUNDED;\n            } else {\n                throw new UnsupportedOperationException(wildcardType.toString());\n            }\n        } else if (type instanceof VoidType) {\n            return ResolvedVoidType.INSTANCE;\n        } else if (type instanceof ArrayType) {\n            ArrayType jpArrayType = (ArrayType) type;\n            return new ResolvedArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n        } else if (type instanceof UnionType) {\n            UnionType unionType = (UnionType) type;\n            return new ResolvedUnionType(unionType.getElements().stream().map(el -> convertToUsage(el, context)).collect(Collectors.toList()));\n        } else if (type instanceof VarType) {\n            Node parent = type.getParentNode().get();\n            if (!(parent instanceof VariableDeclarator)) {\n                throw new IllegalStateException(\"Trying to resolve a `var` which is not in a variable declaration.\");\n            }\n            final VariableDeclarator variableDeclarator = (VariableDeclarator) parent;\n            return variableDeclarator.getInitializer()\n                    .map(Expression::calculateResolvedType)\n                    .orElseThrow(() -> new IllegalStateException(\"Cannot resolve `var` which has no initializer.\"));\n        } else {\n            throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n        }\n    }",
        "filePathBefore": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java",
        "isPureRefactoring": true,
        "commitId": "b79893b5786313fd661db8395cb7fabe44960877",
        "packageNameBefore": "com.github.javaparser.symbolsolver.javaparsermodel",
        "classNameBefore": "com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade",
        "methodNameBefore": "com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade#convertToUsage",
        "invokedMethod": "methodSignature: com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade#getType\n methodBody: public ResolvedType getType(Node node, boolean solveLambdas) {\nif(solveLambdas){if(!node.containsData(TYPE_WITH_LAMBDAS_RESOLVED)){ResolvedType res=getTypeConcrete(node,solveLambdas);\nnode.setData(TYPE_WITH_LAMBDAS_RESOLVED,res);\nboolean secondPassNecessary=false;\nif(node instanceof MethodCallExpr){MethodCallExpr methodCallExpr=(MethodCallExpr)node;\nfor(Node arg: methodCallExpr.getArguments()){if(!arg.containsData(TYPE_WITH_LAMBDAS_RESOLVED)){getType(arg,true);\nsecondPassNecessary=true;\n}}}if(secondPassNecessary){node.removeData(TYPE_WITH_LAMBDAS_RESOLVED);\nResolvedType type=getType(node,true);\nnode.setData(TYPE_WITH_LAMBDAS_RESOLVED,type);\n}Log.trace(\"getType on %s  -> %s\",() -> node,() -> res);\n}return node.getData(TYPE_WITH_LAMBDAS_RESOLVED);\n}{Optional<ResolvedType> res=find(TYPE_WITH_LAMBDAS_RESOLVED,node);\nif(res.isPresent()){return res.get();\n}res=find(TYPE_WITHOUT_LAMBDAS_RESOLVED,node);\nif(!res.isPresent()){ResolvedType resType=getTypeConcrete(node,solveLambdas);\nnode.setData(TYPE_WITHOUT_LAMBDAS_RESOLVED,resType);\nOptional<ResolvedType> finalRes=res;\nLog.trace(\"getType on %s (no solveLambdas) -> %s\",() -> node,() -> finalRes);\nreturn resType;\n}return res.get();\n}}\nmethodSignature: com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade#qName\n methodBody: private String qName(ClassOrInterfaceType classOrInterfaceType) {\nString name=classOrInterfaceType.getName().getId();\nif(classOrInterfaceType.getScope().isPresent()){return qName(classOrInterfaceType.getScope().get()) + \".\" + name;\n}return name;\n}\nmethodSignature: com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade#get\n methodBody: public synchronized static JavaParserFacade get(TypeSolver typeSolver) {\nreturn instances.computeIfAbsent(typeSolver,JavaParserFacade::new);\n}\nmethodSignature: com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade#convertToUsage\n methodBody: protected ResolvedType convertToUsage(Type type, Context context) {\nif(context == null){throw new NullPointerException(\"Context should not be null\");\n}if(type instanceof ClassOrInterfaceType){ClassOrInterfaceType classOrInterfaceType=(ClassOrInterfaceType)type;\nString name=qName(classOrInterfaceType);\nSymbolReference<ResolvedTypeDeclaration> ref=context.solveType(name);\nif(!ref.isSolved()){throw new UnsolvedSymbolException(name);\n}ResolvedTypeDeclaration typeDeclaration=ref.getCorrespondingDeclaration();\nList<ResolvedType> typeParameters=Collections.emptyList();\nif(classOrInterfaceType.getTypeArguments().isPresent()){typeParameters=classOrInterfaceType.getTypeArguments().get().stream().map((pt) -> convertToUsage(pt,context)).collect(Collectors.toList());\n}if(typeDeclaration.isTypeParameter()){if(typeDeclaration instanceof ResolvedTypeParameterDeclaration){return new ResolvedTypeVariable((ResolvedTypeParameterDeclaration)typeDeclaration);\n}{JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration=(JavaParserTypeVariableDeclaration)typeDeclaration;\nreturn new ResolvedTypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n}}{return new ReferenceTypeImpl((ResolvedReferenceTypeDeclaration)typeDeclaration,typeParameters,typeSolver);\n}}if(type instanceof PrimitiveType){return ResolvedPrimitiveType.byName(((PrimitiveType)type).getType().name());\n}if(type instanceof WildcardType){WildcardType wildcardType=(WildcardType)type;\nif(wildcardType.getExtendedType().isPresent() && !wildcardType.getSuperType().isPresent()){return ResolvedWildcard.extendsBound(convertToUsage(wildcardType.getExtendedType().get(),context));\n}if(!wildcardType.getExtendedType().isPresent() && wildcardType.getSuperType().isPresent()){return ResolvedWildcard.superBound(convertToUsage(wildcardType.getSuperType().get(),context));\n}if(!wildcardType.getExtendedType().isPresent() && !wildcardType.getSuperType().isPresent()){return ResolvedWildcard.UNBOUNDED;\n}{throw new UnsupportedOperationException(wildcardType.toString());\n}}if(type instanceof VoidType){return ResolvedVoidType.INSTANCE;\n}if(type instanceof ArrayType){ArrayType jpArrayType=(ArrayType)type;\nreturn new ResolvedArrayType(convertToUsage(jpArrayType.getComponentType(),context));\n}if(type instanceof UnionType){UnionType unionType=(UnionType)type;\nreturn new ResolvedUnionType(unionType.getElements().stream().map(el -> convertToUsage(el,context)).collect(Collectors.toList()));\n}if(type instanceof VarType){Node parent=type.getParentNode().get();\nif(!(parent instanceof VariableDeclarator)){throw new IllegalStateException(\"Trying to resolve a `var` which is not in a variable declaration.\");\n}final VariableDeclarator variableDeclarator=(VariableDeclarator)parent;\nreturn variableDeclarator.getInitializer().map(Expression::calculateResolvedType).orElseThrow(() -> new IllegalStateException(\"Cannot resolve `var` which has no initializer.\"));\n}{throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n}}",
        "classSignatureBefore": "public class JavaParserFacade ",
        "methodNameBeforeSet": [
            "com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade#convertToUsage"
        ],
        "classNameBeforeSet": [
            "com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade"
        ],
        "classSignatureBeforeSet": [
            "public class JavaParserFacade "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Copyright (C) 2015-2016 Federico Tomassetti\n * Copyright (C) 2017-2020 The JavaParser Team.\n *\n * This file is part of JavaParser.\n *\n * JavaParser can be used either under the terms of\n * a) the GNU Lesser General Public License as published by\n *     the Free Software Foundation, either version 3 of the License, or\n *     (at your option) any later version.\n * b) the terms of the Apache License\n *\n * You should have received a copy of both licenses in LICENCE.LGPL and\n * LICENCE.APACHE. Please refer to those files for details.\n *\n * JavaParser is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n */\n\npackage com.github.javaparser.symbolsolver.javaparsermodel;\n\nimport static com.github.javaparser.symbolsolver.javaparser.Navigator.demandParentNode;\nimport static com.github.javaparser.symbolsolver.model.resolution.SymbolReference.solved;\nimport static com.github.javaparser.symbolsolver.model.resolution.SymbolReference.unsolved;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.Set;\nimport java.util.WeakHashMap;\nimport java.util.stream.Collectors;\n\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.DataKey;\nimport com.github.javaparser.ast.Node;\nimport com.github.javaparser.ast.NodeList;\nimport com.github.javaparser.ast.body.*;\nimport com.github.javaparser.ast.expr.AnnotationExpr;\nimport com.github.javaparser.ast.expr.BinaryExpr;\nimport com.github.javaparser.ast.expr.Expression;\nimport com.github.javaparser.ast.expr.FieldAccessExpr;\nimport com.github.javaparser.ast.expr.LambdaExpr;\nimport com.github.javaparser.ast.expr.MethodCallExpr;\nimport com.github.javaparser.ast.expr.MethodReferenceExpr;\nimport com.github.javaparser.ast.expr.NameExpr;\nimport com.github.javaparser.ast.expr.ObjectCreationExpr;\nimport com.github.javaparser.ast.expr.SimpleName;\nimport com.github.javaparser.ast.expr.ThisExpr;\nimport com.github.javaparser.ast.expr.TypeExpr;\nimport com.github.javaparser.ast.stmt.ExplicitConstructorInvocationStmt;\nimport com.github.javaparser.ast.type.ArrayType;\nimport com.github.javaparser.ast.type.ClassOrInterfaceType;\nimport com.github.javaparser.ast.type.PrimitiveType;\nimport com.github.javaparser.ast.type.Type;\nimport com.github.javaparser.ast.type.UnionType;\nimport com.github.javaparser.ast.type.VarType;\nimport com.github.javaparser.ast.type.VoidType;\nimport com.github.javaparser.ast.type.WildcardType;\nimport com.github.javaparser.resolution.MethodAmbiguityException;\nimport com.github.javaparser.resolution.MethodUsage;\nimport com.github.javaparser.resolution.UnsolvedSymbolException;\nimport com.github.javaparser.resolution.declarations.ResolvedAnnotationDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedClassDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedConstructorDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedMethodDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedReferenceTypeDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedTypeDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedTypeParameterDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedValueDeclaration;\nimport com.github.javaparser.resolution.types.ResolvedArrayType;\nimport com.github.javaparser.resolution.types.ResolvedPrimitiveType;\nimport com.github.javaparser.resolution.types.ResolvedReferenceType;\nimport com.github.javaparser.resolution.types.ResolvedType;\nimport com.github.javaparser.resolution.types.ResolvedTypeVariable;\nimport com.github.javaparser.resolution.types.ResolvedUnionType;\nimport com.github.javaparser.resolution.types.ResolvedVoidType;\nimport com.github.javaparser.resolution.types.ResolvedWildcard;\nimport com.github.javaparser.symbolsolver.core.resolution.Context;\nimport com.github.javaparser.symbolsolver.javaparsermodel.contexts.FieldAccessContext;\nimport com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserAnonymousClassDeclaration;\nimport com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserEnumDeclaration;\nimport com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserTypeVariableDeclaration;\nimport com.github.javaparser.symbolsolver.model.resolution.SymbolReference;\nimport com.github.javaparser.symbolsolver.model.resolution.TypeSolver;\nimport com.github.javaparser.symbolsolver.model.typesystem.ReferenceTypeImpl;\nimport com.github.javaparser.symbolsolver.reflectionmodel.ReflectionAnnotationDeclaration;\nimport com.github.javaparser.symbolsolver.reflectionmodel.ReflectionClassDeclaration;\nimport com.github.javaparser.symbolsolver.reflectionmodel.ReflectionEnumDeclaration;\nimport com.github.javaparser.symbolsolver.reflectionmodel.ReflectionInterfaceDeclaration;\nimport com.github.javaparser.symbolsolver.resolution.ConstructorResolutionLogic;\nimport com.github.javaparser.symbolsolver.resolution.MethodResolutionLogic;\nimport com.github.javaparser.symbolsolver.resolution.SymbolSolver;\nimport com.github.javaparser.utils.Log;\n\n/**\n * Class to be used by final users to solve symbols for JavaParser ASTs.\n *\n * @author Federico Tomassetti\n */\npublic class JavaParserFacade {\n\n    private static final DataKey<ResolvedType> TYPE_WITH_LAMBDAS_RESOLVED = new DataKey<ResolvedType>() {\n    };\n    private static final DataKey<ResolvedType> TYPE_WITHOUT_LAMBDAS_RESOLVED = new DataKey<ResolvedType>() {\n    };\n\n    private static final Map<TypeSolver, JavaParserFacade> instances = new WeakHashMap<>();\n    \n    private static String JAVA_LANG_STRING = String.class.getCanonicalName();\n    \n    private final TypeSolver typeSolver;\n    private final TypeExtractor typeExtractor;\n    private final SymbolSolver symbolSolver;\n\n    private JavaParserFacade(TypeSolver typeSolver) {\n        this.typeSolver = typeSolver.getRoot();\n        this.symbolSolver = new SymbolSolver(typeSolver);\n        this.typeExtractor = new TypeExtractor(typeSolver, this);\n    }\n\n    public TypeSolver getTypeSolver() {\n        return typeSolver;\n    }\n\n    public SymbolSolver getSymbolSolver() {\n        return symbolSolver;\n    }\n\n    /**\n     * Note that the addition of the modifier {@code synchronized} is specific and directly in response to issue #2668.\n     * <br>This <strong>MUST NOT</strong> be misinterpreted as a signal that JavaParser is safe to use within a multi-threaded environment.\n     * <br>\n     * <br>Additional discussion and context from a user attempting multithreading can be found within issue #2671 .\n     * <br>\n     *\n     * @see <a href=\"https://github.com/javaparser/javaparser/issues/2668\">https://github.com/javaparser/javaparser/issues/2668</a>\n     * @see <a href=\"https://github.com/javaparser/javaparser/issues/2671\">https://github.com/javaparser/javaparser/issues/2671</a>\n     */\n    public synchronized static JavaParserFacade get(TypeSolver typeSolver) {\n        return instances.computeIfAbsent(typeSolver, JavaParserFacade::new);\n    }\n\n    /**\n     * This method is used to clear internal caches for the sake of releasing memory.\n     */\n    public static void clearInstances() {\n        instances.clear();\n    }\n\n    protected static ResolvedType solveGenericTypes(ResolvedType type, Context context) {\n        if (type.isTypeVariable()) {\n            return context.solveGenericType(type.describe()).orElse(type);\n        }\n        if (type.isWildcard()) {\n            if (type.asWildcard().isExtends() || type.asWildcard().isSuper()) {\n                ResolvedWildcard wildcardUsage = type.asWildcard();\n                ResolvedType boundResolved = solveGenericTypes(wildcardUsage.getBoundedType(), context);\n                if (wildcardUsage.isExtends()) {\n                    return ResolvedWildcard.extendsBound(boundResolved);\n                } else {\n                    return ResolvedWildcard.superBound(boundResolved);\n                }\n            }\n        }\n        return type;\n    }\n\n    public SymbolReference<? extends ResolvedValueDeclaration> solve(NameExpr nameExpr) {\n        return symbolSolver.solveSymbol(nameExpr.getName().getId(), nameExpr);\n    }\n\n    public SymbolReference<? extends ResolvedValueDeclaration> solve(SimpleName nameExpr) {\n        return symbolSolver.solveSymbol(nameExpr.getId(), nameExpr);\n    }\n\n    public SymbolReference<? extends ResolvedValueDeclaration> solve(Expression expr) {\n        return expr.toNameExpr().map(this::solve).orElseThrow(() -> new IllegalArgumentException(expr.getClass().getCanonicalName()));\n    }\n\n    public SymbolReference<ResolvedMethodDeclaration> solve(MethodCallExpr methodCallExpr) {\n        return solve(methodCallExpr, true);\n    }\n\n    public SymbolReference<ResolvedMethodDeclaration> solve(MethodReferenceExpr methodReferenceExpr) {\n        return solve(methodReferenceExpr, true);\n    }\n\n    public SymbolReference<ResolvedConstructorDeclaration> solve(ObjectCreationExpr objectCreationExpr) {\n        return solve(objectCreationExpr, true);\n    }\n\n    public SymbolReference<ResolvedConstructorDeclaration> solve(ExplicitConstructorInvocationStmt explicitConstructorInvocationStmt) {\n        return solve(explicitConstructorInvocationStmt, true);\n    }\n\n    public SymbolReference<ResolvedConstructorDeclaration> solve(ExplicitConstructorInvocationStmt explicitConstructorInvocationStmt, boolean solveLambdas) {\n        // Constructor invocation must exist within a class (not interface).\n        Optional<ClassOrInterfaceDeclaration> optAncestorClassOrInterfaceNode = explicitConstructorInvocationStmt.findAncestor(ClassOrInterfaceDeclaration.class);\n        if (!optAncestorClassOrInterfaceNode.isPresent()) {\n            return unsolved(ResolvedConstructorDeclaration.class);\n        }\n\n        ClassOrInterfaceDeclaration classOrInterfaceNode = optAncestorClassOrInterfaceNode.get();\n        ResolvedReferenceTypeDeclaration resolvedClassNode = classOrInterfaceNode.resolve();\n        if (!resolvedClassNode.isClass()) {\n            throw new IllegalStateException(\"Expected to be a class -- cannot call this() or super() within an interface.\");\n        }\n\n        ResolvedTypeDeclaration typeDecl = null;\n        if (explicitConstructorInvocationStmt.isThis()) {\n            // this()\n            typeDecl = resolvedClassNode.asReferenceType();\n        } else {\n            // super()\n            Optional<ResolvedReferenceType> superClass = resolvedClassNode.asClass().getSuperClass();\n            if (superClass.isPresent() && superClass.get().getTypeDeclaration().isPresent()) {\n                typeDecl = superClass.get().getTypeDeclaration().get();\n            }\n        }\n        if (typeDecl == null) {\n            return unsolved(ResolvedConstructorDeclaration.class);\n        }\n\n        // Solve each of the arguments being passed into this constructor invocation.\n        List<ResolvedType> argumentTypes = new LinkedList<>();\n        List<LambdaArgumentTypePlaceholder> placeholders = new LinkedList<>();\n        solveArguments(explicitConstructorInvocationStmt, explicitConstructorInvocationStmt.getArguments(), solveLambdas, argumentTypes, placeholders);\n\n        // Determine which constructor is referred to, and return it.\n        SymbolReference<ResolvedConstructorDeclaration> res = ConstructorResolutionLogic.findMostApplicable(((ResolvedClassDeclaration) typeDecl).getConstructors(), argumentTypes, typeSolver);\n        for (LambdaArgumentTypePlaceholder placeholder : placeholders) {\n            placeholder.setMethod(res);\n        }\n\n        return res;\n    }\n\n    public SymbolReference<ResolvedTypeDeclaration> solve(ThisExpr node) {\n        // If 'this' is prefixed by a class eg. MyClass.this\n        if (node.getTypeName().isPresent()) {\n            // Get the class name\n            String className = node.getTypeName().get().asString();\n            // Attempt to resolve using a typeSolver\n            SymbolReference<ResolvedReferenceTypeDeclaration> clazz = typeSolver.tryToSolveType(className);\n            if (clazz.isSolved()) {\n                return solved(clazz.getCorrespondingDeclaration());\n            }\n            // Attempt to resolve locally in Compilation unit\n            Optional<CompilationUnit> cu = node.findAncestor(CompilationUnit.class);\n            if (cu.isPresent()) {\n                Optional<ClassOrInterfaceDeclaration> classByName = cu.get().getClassByName(className);\n                if (classByName.isPresent()) {\n                    return solved(getTypeDeclaration(classByName.get()));\n                }\n            }\n        }\n        return solved(getTypeDeclaration(findContainingTypeDeclOrObjectCreationExpr(node)));\n    }\n\n    /**\n     * Given a constructor call find out to which constructor declaration it corresponds.\n     */\n    public SymbolReference<ResolvedConstructorDeclaration> solve(ObjectCreationExpr objectCreationExpr, boolean solveLambdas) {\n        List<ResolvedType> argumentTypes = new LinkedList<>();\n        List<LambdaArgumentTypePlaceholder> placeholders = new LinkedList<>();\n\n        solveArguments(objectCreationExpr, objectCreationExpr.getArguments(), solveLambdas, argumentTypes, placeholders);\n\n        ResolvedReferenceTypeDeclaration typeDecl = null;\n        if (objectCreationExpr.getAnonymousClassBody().isPresent()) {\n            typeDecl = new JavaParserAnonymousClassDeclaration(objectCreationExpr, typeSolver);\n        } else {\n            ResolvedType classDecl = JavaParserFacade.get(typeSolver).convert(objectCreationExpr.getType(), objectCreationExpr);\n            if (classDecl.isReferenceType() && classDecl.asReferenceType().getTypeDeclaration().isPresent()) {\n                typeDecl = classDecl.asReferenceType().getTypeDeclaration().get();\n            }\n        }\n        if (typeDecl == null) {\n            return unsolved(ResolvedConstructorDeclaration.class);\n        }\n        SymbolReference<ResolvedConstructorDeclaration> res = ConstructorResolutionLogic.findMostApplicable(typeDecl.getConstructors(), argumentTypes, typeSolver);\n        for (LambdaArgumentTypePlaceholder placeholder : placeholders) {\n            placeholder.setMethod(res);\n        }\n        return res;\n    }\n\n    private void solveArguments(Node node, NodeList<Expression> args, boolean solveLambdas, List<ResolvedType> argumentTypes,\n                                List<LambdaArgumentTypePlaceholder> placeholders) {\n        int i = 0;\n        for (Expression parameterValue : args) {\n            if (parameterValue instanceof LambdaExpr || parameterValue instanceof MethodReferenceExpr) {\n                LambdaArgumentTypePlaceholder placeholder = new LambdaArgumentTypePlaceholder(i);\n                argumentTypes.add(placeholder);\n                placeholders.add(placeholder);\n            } else {\n                try {\n                    argumentTypes.add(JavaParserFacade.get(typeSolver).getType(parameterValue, solveLambdas));\n                } catch (UnsolvedSymbolException e) {\n                    throw e;\n                } catch (Exception e) {\n                    throw new RuntimeException(String.format(\"Unable to calculate the type of a parameter of a method call. Method call: %s, Parameter: %s\",\n                            node, parameterValue), e);\n                }\n            }\n            i++;\n        }\n    }\n\n    /**\n     * Given a method call find out to which method declaration it corresponds.\n     */\n    public SymbolReference<ResolvedMethodDeclaration> solve(MethodCallExpr methodCallExpr, boolean solveLambdas) {\n        List<ResolvedType> argumentTypes = new LinkedList<>();\n        List<LambdaArgumentTypePlaceholder> placeholders = new LinkedList<>();\n\n        solveArguments(methodCallExpr, methodCallExpr.getArguments(), solveLambdas, argumentTypes, placeholders);\n\n        SymbolReference<ResolvedMethodDeclaration> res = JavaParserFactory.getContext(methodCallExpr, typeSolver).solveMethod(methodCallExpr.getName().getId(), argumentTypes, false);\n        for (LambdaArgumentTypePlaceholder placeholder : placeholders) {\n            placeholder.setMethod(res);\n        }\n        return res;\n    }\n\n    /**\n     * Given a method reference find out to which method declaration it corresponds.\n     */\n    public SymbolReference<ResolvedMethodDeclaration> solve(MethodReferenceExpr methodReferenceExpr, boolean solveLambdas) {\n        // pass empty argument list to be populated\n        List<ResolvedType> argumentTypes = new LinkedList<>();\n        return JavaParserFactory.getContext(methodReferenceExpr, typeSolver).solveMethod(methodReferenceExpr.getIdentifier(), argumentTypes, false);\n    }\n\n    public SymbolReference<ResolvedAnnotationDeclaration> solve(AnnotationExpr annotationExpr) {\n        Context context = JavaParserFactory.getContext(annotationExpr, typeSolver);\n        SymbolReference<ResolvedTypeDeclaration> typeDeclarationSymbolReference = context.solveType(annotationExpr.getNameAsString());\n        if (typeDeclarationSymbolReference.isSolved()) {\n            ResolvedAnnotationDeclaration annotationDeclaration = (ResolvedAnnotationDeclaration) typeDeclarationSymbolReference.getCorrespondingDeclaration();\n            return solved(annotationDeclaration);\n        } else {\n            return unsolved(ResolvedAnnotationDeclaration.class);\n        }\n    }\n\n    public SymbolReference<ResolvedValueDeclaration> solve(FieldAccessExpr fieldAccessExpr) {\n        return ((FieldAccessContext) JavaParserFactory.getContext(fieldAccessExpr, typeSolver)).solveField(fieldAccessExpr.getName().getId());\n    }\n\n    /**\n     * Get the type associated with the node.\n     * <p>\n     * This method was originally intended to get the type of a value: any value has a type.\n     * <p>\n     * For example:\n     * <pre>\n     * int foo(int a) {\n     *     return a; // when getType is invoked on \"a\" it returns the type \"int\"\n     * }\n     * </pre>\n     * <p>\n     * Now, users started using also of names of types itself, which do not have a type.\n     * <p>\n     * For example:\n     * <pre>\n     * class A {\n     *     int foo(int a) {\n     *         return A.someStaticField; // when getType is invoked on \"A\", which represents a class, it returns\n     *             // the type \"A\" itself while it used to throw UnsolvedSymbolException\n     * }\n     * </pre>\n     * <p>\n     * To accommodate this usage and avoid confusion this method return\n     * the type itself when used on the name of type.\n     */\n    public ResolvedType getType(Node node) {\n        try {\n            return getType(node, true);\n        } catch (UnsolvedSymbolException e) {\n            if (node instanceof NameExpr) {\n                NameExpr nameExpr = (NameExpr) node;\n                SymbolReference<ResolvedTypeDeclaration> typeDeclaration = JavaParserFactory.getContext(node, typeSolver)\n                        .solveType(nameExpr.getNameAsString());\n                if (typeDeclaration.isSolved() && typeDeclaration.getCorrespondingDeclaration() instanceof ResolvedReferenceTypeDeclaration) {\n                    ResolvedReferenceTypeDeclaration resolvedReferenceTypeDeclaration = (ResolvedReferenceTypeDeclaration) typeDeclaration.getCorrespondingDeclaration();\n                    return ReferenceTypeImpl.undeterminedParameters(resolvedReferenceTypeDeclaration, typeSolver);\n                }\n            }\n            throw e;\n        }\n    }\n\n    public ResolvedType getType(Node node, boolean solveLambdas) {\n        if (solveLambdas) {\n            if (!node.containsData(TYPE_WITH_LAMBDAS_RESOLVED)) {\n                ResolvedType res = getTypeConcrete(node, solveLambdas);\n\n                node.setData(TYPE_WITH_LAMBDAS_RESOLVED, res);\n\n                boolean secondPassNecessary = false;\n                if (node instanceof MethodCallExpr) {\n                    MethodCallExpr methodCallExpr = (MethodCallExpr) node;\n                    for (Node arg : methodCallExpr.getArguments()) {\n                        if (!arg.containsData(TYPE_WITH_LAMBDAS_RESOLVED)) {\n                            getType(arg, true);\n                            secondPassNecessary = true;\n                        }\n                    }\n                }\n                if (secondPassNecessary) {\n                    node.removeData(TYPE_WITH_LAMBDAS_RESOLVED);\n                    ResolvedType type = getType(node, true);\n                    node.setData(TYPE_WITH_LAMBDAS_RESOLVED, type);\n\n                }\n                Log.trace(\"getType on %s  -> %s\", () -> node, () -> res);\n            }\n            return node.getData(TYPE_WITH_LAMBDAS_RESOLVED);\n        } else {\n            Optional<ResolvedType> res = find(TYPE_WITH_LAMBDAS_RESOLVED, node);\n            if (res.isPresent()) {\n                return res.get();\n            }\n            res = find(TYPE_WITHOUT_LAMBDAS_RESOLVED, node);\n            if (!res.isPresent()) {\n                ResolvedType resType = getTypeConcrete(node, solveLambdas);\n                node.setData(TYPE_WITHOUT_LAMBDAS_RESOLVED, resType);\n                Optional<ResolvedType> finalRes = res;\n                Log.trace(\"getType on %s (no solveLambdas) -> %s\", () -> node, () -> finalRes);\n                return resType;\n            }\n            return res.get();\n        }\n    }\n\n    private Optional<ResolvedType> find(DataKey<ResolvedType> dataKey, Node node) {\n        if (node.containsData(dataKey)) {\n            return Optional.of(node.getData(dataKey));\n        }\n        return Optional.empty();\n    }\n\n    protected MethodUsage toMethodUsage(MethodReferenceExpr methodReferenceExpr, List<ResolvedType> paramTypes) {\n        Expression scope = methodReferenceExpr.getScope();\n        ResolvedType typeOfScope = getType(methodReferenceExpr.getScope());\n        if (!typeOfScope.isReferenceType()) {\n            throw new UnsupportedOperationException(typeOfScope.getClass().getCanonicalName());\n        }\n\n        Optional<MethodUsage> result;\n        Set<MethodUsage> allMethods = typeOfScope.asReferenceType().getTypeDeclaration()\n                .orElseThrow(() -> new RuntimeException(\"TypeDeclaration unexpectedly empty.\"))\n                .getAllMethods();\n\n        if (scope instanceof TypeExpr) {\n            // static methods should match all params\n            List<MethodUsage> staticMethodUsages = allMethods.stream()\n                    .filter(it -> it.getDeclaration().isStatic())\n                    .collect(Collectors.toList());\n\n            result = MethodResolutionLogic.findMostApplicableUsage(staticMethodUsages, methodReferenceExpr.getIdentifier(), paramTypes, typeSolver);\n\n            if (!paramTypes.isEmpty()) {\n                // instance methods are called on the first param and should match all other params\n                List<MethodUsage> instanceMethodUsages = allMethods.stream()\n                        .filter(it -> !it.getDeclaration().isStatic())\n                        .collect(Collectors.toList());\n\n                List<ResolvedType> instanceMethodParamTypes = new ArrayList<>(paramTypes);\n                instanceMethodParamTypes.remove(0); // remove the first one\n\n                Optional<MethodUsage> instanceResult = MethodResolutionLogic.findMostApplicableUsage(\n                        instanceMethodUsages, methodReferenceExpr.getIdentifier(), instanceMethodParamTypes, typeSolver);\n                if (result.isPresent() && instanceResult.isPresent()) {\n                    throw new MethodAmbiguityException(\"Ambiguous method call: cannot find a most applicable method for \" + methodReferenceExpr.getIdentifier());\n                }\n\n                if (instanceResult.isPresent()) {\n                    result = instanceResult;\n                }\n            }\n        } else {\n            result = MethodResolutionLogic.findMostApplicableUsage(new ArrayList<>(allMethods), methodReferenceExpr.getIdentifier(), paramTypes, typeSolver);\n\n            if (result.isPresent() && result.get().getDeclaration().isStatic()) {\n                throw new RuntimeException(\"Invalid static method reference \" + methodReferenceExpr.getIdentifier());\n            }\n        }\n\n        if (!result.isPresent()) {\n            throw new UnsupportedOperationException();\n        }\n\n        return result.get();\n    }\n\n    protected ResolvedType getBinaryTypeConcrete(Node left, Node right, boolean solveLambdas, BinaryExpr.Operator operator) {\n        ResolvedType leftType = getTypeConcrete(left, solveLambdas);\n        ResolvedType rightType = getTypeConcrete(right, solveLambdas);\n\n        // JLS 15.18.1. String Concatenation Operator +\n        // If only one operand expression is of type String, then string conversion (\u00a75.1.11) is performed on the other\n        // operand to produce a string at run time.\n        //\n        // The result of string concatenation is a reference to a String object that is the concatenation of the two\n        // operand strings. The characters of the left-hand operand precede the characters of the right-hand operand in\n        // the newly created string.\n\n        if (operator == BinaryExpr.Operator.PLUS) {\n            boolean isLeftString = leftType.isReferenceType() && leftType.asReferenceType()\n                    .getQualifiedName().equals(JAVA_LANG_STRING);\n            boolean isRightString = rightType.isReferenceType() && rightType.asReferenceType()\n                    .getQualifiedName().equals(JAVA_LANG_STRING);\n            if (isLeftString || isRightString) {\n                return isLeftString ? leftType : rightType;\n            }\n        }\n\n        // JLS 5.6.2. Binary Numeric Promotion\n        //\n        // Widening primitive conversion (\u00a75.1.2) is applied to convert either or both operands as specified by the\n        // following rules:\n        //\n        // * If either operand is of type double, the other is converted to double.\n        // * Otherwise, if either operand is of type float, the other is converted to float.\n        // * Otherwise, if either operand is of type long, the other is converted to long.\n        // * Otherwise, both operands are converted to type int.\n\n        boolean isLeftNumeric = leftType.isPrimitive() && leftType.asPrimitive().isNumeric();\n        boolean isRightNumeric = rightType.isPrimitive() && rightType.asPrimitive().isNumeric();\n\n        if (isLeftNumeric && isRightNumeric) {\n            return leftType.asPrimitive().bnp(rightType.asPrimitive());\n        }\n\n        if (rightType.isAssignableBy(leftType)) {\n            return rightType;\n        }\n        return leftType;\n    }\n\n\n    /**\n     * Should return more like a TypeApplication: a TypeDeclaration and possible typeParametersValues or array\n     * modifiers.\n     */\n    private ResolvedType getTypeConcrete(Node node, boolean solveLambdas) {\n        if (node == null) throw new IllegalArgumentException();\n        return node.accept(typeExtractor, solveLambdas);\n    }\n\n    /**\n     * Where a node has an interface/class/enum declaration as its ancestor, return the nearest one.\n     * <p>\n     * NOTE: See {@link #findContainingTypeDeclOrObjectCreationExpr} if wanting to include anonymous inner classes.\n     * <p>\n     * For example, these all return X:\n     * {@code public interface X { ... node here ... }}\n     * {@code public class X { ... node here ... }}\n     * {@code public enum X { ... node here ... }}\n     *\n     * @param node The Node whose ancestors will be traversed,\n     * @return The first class/interface/enum declaration in the Node's ancestry.\n     */\n    protected TypeDeclaration<?> findContainingTypeDecl(Node node) {\n        Node parent = node;\n        while (true) {\n            parent = demandParentNode(parent);\n            if (parent instanceof TypeDeclaration) {\n                return (TypeDeclaration<?>) parent;\n            }\n        }\n    }\n\n    /**\n     * Where a node has an interface/class/enum declaration -- or an object creation expression (anonymous inner class)\n     * -- as its ancestor, return the nearest one.\n     * <p>\n     * NOTE: See {@link #findContainingTypeDecl} if wanting to not include anonymous inner classes.\n     * <p>\n     * For example, these all return X:\n     * <ul>\n     *     <li>{@code public interface X { ... node here ... }}</li>\n     *     <li>{@code public class X { ... node here ... }}</li>\n     *     <li>{@code public enum X { ... node here ... }}</li>\n     *     <li><pre>{@code\n     *     new ActionListener() {\n     *          ... node here ...\n     *          public void actionPerformed(ActionEvent e) {\n     *               ... or node here ...\n     *          }\n     *     }\n     *     }</pre></li>\n     * </ul>\n     * <p>\n     *\n     * @param node The Node whose ancestors will be traversed,\n     * @return The first class/interface/enum declaration -- or object creation expression (anonymous inner class) -- in\n     * the Node's ancestry.\n     */\n    protected Node findContainingTypeDeclOrObjectCreationExpr(Node node) {\n        Node parent = node;\n        boolean detachFlag = false;\n        while (true) {\n            parent = demandParentNode(parent);\n            if (parent instanceof BodyDeclaration) {\n                if (parent instanceof TypeDeclaration) {\n                    return parent;\n                } else {\n                    detachFlag = true;\n                }\n            } else if (parent instanceof ObjectCreationExpr) {\n                if (detachFlag) {\n                    return parent;\n                }\n            }\n        }\n    }\n\n    /**\n     * Where a node has an interface/class/enum declaration -- or an object creation expression in an inner class\n     * references an outer class -- as its ancestor, return the declaration corresponding to the class name specified.\n     */\n    protected Node findContainingTypeDeclOrObjectCreationExpr(Node node, String className) {\n        Node parent = node;\n        boolean detachFlag = false;\n        while (true) {\n            parent = demandParentNode(parent);\n            if (parent instanceof BodyDeclaration) {\n                if (parent instanceof TypeDeclaration && ((TypeDeclaration<?>) parent).getFullyQualifiedName().get().endsWith(className)) {\n                    return parent;\n                } else {\n                    detachFlag = true;\n                }\n            } else if (parent instanceof ObjectCreationExpr) {\n                if (detachFlag) {\n                    return parent;\n                }\n            }\n        }\n    }\n\n\n    public ResolvedType convertToUsageVariableType(VariableDeclarator var) {\n        return get(typeSolver).convertToUsage(var.getType(), var);\n    }\n\n    public ResolvedType convertToUsage(Type type, Node context) {\n        if (type.isUnknownType()) {\n            throw new IllegalArgumentException(\"Inferred lambda parameter type\");\n        }\n        return convertToUsage(type, JavaParserFactory.getContext(context, typeSolver));\n    }\n\n    public ResolvedType convertToUsage(Type type) {\n        return convertToUsage(type, type);\n    }\n\n    // This is an hack around an issue in JavaParser\n    private String qName(ClassOrInterfaceType classOrInterfaceType) {\n        String name = classOrInterfaceType.getName().getId();\n        if (classOrInterfaceType.getScope().isPresent()) {\n            return qName(classOrInterfaceType.getScope().get()) + \".\" + name;\n        }\n        return name;\n    }\n\n    protected ResolvedType convertToUsage(Type type, Context context) {\n        if (context == null) {\n            throw new NullPointerException(\"Context should not be null\");\n        }\n        if (type instanceof ClassOrInterfaceType) {\n            ClassOrInterfaceType classOrInterfaceType = (ClassOrInterfaceType) type;\n            String name = qName(classOrInterfaceType);\n            SymbolReference<ResolvedTypeDeclaration> ref = context.solveType(name);\n            if (!ref.isSolved()) {\n                throw new UnsolvedSymbolException(name);\n            }\n            ResolvedTypeDeclaration typeDeclaration = ref.getCorrespondingDeclaration();\n            List<ResolvedType> typeParameters = Collections.emptyList();\n            if (classOrInterfaceType.getTypeArguments().isPresent()) {\n                typeParameters = classOrInterfaceType.getTypeArguments().get().stream().map((pt) -> convertToUsage(pt, context)).collect(Collectors.toList());\n            }\n            if (typeDeclaration.isTypeParameter()) {\n                if (typeDeclaration instanceof ResolvedTypeParameterDeclaration) {\n                    return new ResolvedTypeVariable((ResolvedTypeParameterDeclaration) typeDeclaration);\n                } else {\n                    JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration = (JavaParserTypeVariableDeclaration) typeDeclaration;\n                    return new ResolvedTypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n                }\n            } else {\n                return new ReferenceTypeImpl((ResolvedReferenceTypeDeclaration) typeDeclaration, typeParameters, typeSolver);\n            }\n        } else if (type instanceof PrimitiveType) {\n            return ResolvedPrimitiveType.byName(((PrimitiveType) type).getType().name());\n        } else if (type instanceof WildcardType) {\n            WildcardType wildcardType = (WildcardType) type;\n            if (wildcardType.getExtendedType().isPresent() && !wildcardType.getSuperType().isPresent()) {\n                return ResolvedWildcard.extendsBound(convertToUsage(wildcardType.getExtendedType().get(), context)); // removed (ReferenceTypeImpl)\n            } else if (!wildcardType.getExtendedType().isPresent() && wildcardType.getSuperType().isPresent()) {\n                return ResolvedWildcard.superBound(convertToUsage(wildcardType.getSuperType().get(), context)); // removed (ReferenceTypeImpl)\n            } else if (!wildcardType.getExtendedType().isPresent() && !wildcardType.getSuperType().isPresent()) {\n                return ResolvedWildcard.UNBOUNDED;\n            } else {\n                throw new UnsupportedOperationException(wildcardType.toString());\n            }\n        } else if (type instanceof VoidType) {\n            return ResolvedVoidType.INSTANCE;\n        } else if (type instanceof ArrayType) {\n            ArrayType jpArrayType = (ArrayType) type;\n            return new ResolvedArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n        } else if (type instanceof UnionType) {\n            UnionType unionType = (UnionType) type;\n            return new ResolvedUnionType(unionType.getElements().stream().map(el -> convertToUsage(el, context)).collect(Collectors.toList()));\n        } else if (type instanceof VarType) {\n            Node parent = type.getParentNode().get();\n            if (!(parent instanceof VariableDeclarator)) {\n                throw new IllegalStateException(\"Trying to resolve a `var` which is not in a variable declaration.\");\n            }\n            final VariableDeclarator variableDeclarator = (VariableDeclarator) parent;\n            return variableDeclarator.getInitializer()\n                    .map(Expression::calculateResolvedType)\n                    .orElseThrow(() -> new IllegalStateException(\"Cannot resolve `var` which has no initializer.\"));\n        } else {\n            throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n        }\n    }\n\n\n    public ResolvedType convert(Type type, Node node) {\n        return convert(type, JavaParserFactory.getContext(node, typeSolver));\n    }\n\n    public ResolvedType convert(Type type, Context context) {\n        return convertToUsage(type, context);\n    }\n\n    public MethodUsage solveMethodAsUsage(MethodCallExpr call) {\n        List<ResolvedType> params = new ArrayList<>();\n        if (call.getArguments() != null) {\n            for (Expression param : call.getArguments()) {\n                //getTypeConcrete(Node node, boolean solveLambdas)\n                try {\n                    params.add(getType(param, false));\n                } catch (Exception e) {\n                    throw new RuntimeException(String.format(\"Error calculating the type of parameter %s of method call %s\", param, call), e);\n                }\n                //params.add(getTypeConcrete(param, false));\n            }\n        }\n        Context context = JavaParserFactory.getContext(call, typeSolver);\n        Optional<MethodUsage> methodUsage = context.solveMethodAsUsage(call.getName().getId(), params);\n        if (!methodUsage.isPresent()) {\n            throw new RuntimeException(\"Method '\" + call.getName() + \"' cannot be resolved in context \"\n                    + call + \" (line: \" + call.getRange().map(r -> \"\" + r.begin.line).orElse(\"??\") + \") \" + context + \". Parameter types: \" + params);\n        }\n        return methodUsage.get();\n    }\n\n    public ResolvedReferenceTypeDeclaration getTypeDeclaration(Node node) {\n        if (node instanceof TypeDeclaration) {\n            return getTypeDeclaration((TypeDeclaration) node);\n        } else if (node instanceof ObjectCreationExpr) {\n            return new JavaParserAnonymousClassDeclaration((ObjectCreationExpr) node, typeSolver);\n        } else {\n            throw new IllegalArgumentException();\n        }\n    }\n\n    public ResolvedReferenceTypeDeclaration getTypeDeclaration(ClassOrInterfaceDeclaration classOrInterfaceDeclaration) {\n        return JavaParserFactory.toTypeDeclaration(classOrInterfaceDeclaration, typeSolver);\n    }\n\n    /**\n     * \"this\" inserted in the given point, which type would have?\n     */\n    public ResolvedType getTypeOfThisIn(Node node) {\n        // TODO consider static methods\n        if (node instanceof ClassOrInterfaceDeclaration) {\n            return new ReferenceTypeImpl(getTypeDeclaration((ClassOrInterfaceDeclaration) node), typeSolver);\n        } else if (node instanceof EnumDeclaration) {\n            JavaParserEnumDeclaration enumDeclaration = new JavaParserEnumDeclaration((EnumDeclaration) node, typeSolver);\n            return new ReferenceTypeImpl(enumDeclaration, typeSolver);\n        } else if (node instanceof ObjectCreationExpr && ((ObjectCreationExpr) node).getAnonymousClassBody().isPresent()) {\n            JavaParserAnonymousClassDeclaration anonymousDeclaration = new JavaParserAnonymousClassDeclaration((ObjectCreationExpr) node, typeSolver);\n            return new ReferenceTypeImpl(anonymousDeclaration, typeSolver);\n        }\n        return getTypeOfThisIn(demandParentNode(node));\n    }\n\n    public ResolvedReferenceTypeDeclaration getTypeDeclaration(TypeDeclaration<?> typeDeclaration) {\n        return JavaParserFactory.toTypeDeclaration(typeDeclaration, typeSolver);\n    }\n\n    public ResolvedType classToResolvedType(Class<?> clazz) {\n        if (clazz.isPrimitive()) {\n            return ResolvedPrimitiveType.byName(clazz.getName());\n        }\n\n        ResolvedReferenceTypeDeclaration declaration;\n        if (clazz.isAnnotation()) {\n            declaration = new ReflectionAnnotationDeclaration(clazz, typeSolver);\n        } else if (clazz.isEnum()) {\n            declaration = new ReflectionEnumDeclaration(clazz, typeSolver);\n        } else if (clazz.isInterface()) {\n            declaration = new ReflectionInterfaceDeclaration(clazz, typeSolver);\n        } else {\n            declaration = new ReflectionClassDeclaration(clazz, typeSolver);\n        }\n        return new ReferenceTypeImpl(declaration, typeSolver);\n    }\n\n}\n",
        "filePathAfter": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java",
        "sourceCodeAfterForWhole": "/*\n * Copyright (C) 2015-2016 Federico Tomassetti\n * Copyright (C) 2017-2020 The JavaParser Team.\n *\n * This file is part of JavaParser.\n *\n * JavaParser can be used either under the terms of\n * a) the GNU Lesser General Public License as published by\n *     the Free Software Foundation, either version 3 of the License, or\n *     (at your option) any later version.\n * b) the terms of the Apache License\n *\n * You should have received a copy of both licenses in LICENCE.LGPL and\n * LICENCE.APACHE. Please refer to those files for details.\n *\n * JavaParser is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n */\n\npackage com.github.javaparser.symbolsolver.javaparsermodel;\n\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.DataKey;\nimport com.github.javaparser.ast.Node;\nimport com.github.javaparser.ast.NodeList;\nimport com.github.javaparser.ast.body.BodyDeclaration;\nimport com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;\nimport com.github.javaparser.ast.body.EnumDeclaration;\nimport com.github.javaparser.ast.body.TypeDeclaration;\nimport com.github.javaparser.ast.body.VariableDeclarator;\nimport com.github.javaparser.ast.expr.AnnotationExpr;\nimport com.github.javaparser.ast.expr.BinaryExpr;\nimport com.github.javaparser.ast.expr.Expression;\nimport com.github.javaparser.ast.expr.FieldAccessExpr;\nimport com.github.javaparser.ast.expr.LambdaExpr;\nimport com.github.javaparser.ast.expr.MethodCallExpr;\nimport com.github.javaparser.ast.expr.MethodReferenceExpr;\nimport com.github.javaparser.ast.expr.NameExpr;\nimport com.github.javaparser.ast.expr.ObjectCreationExpr;\nimport com.github.javaparser.ast.expr.SimpleName;\nimport com.github.javaparser.ast.expr.ThisExpr;\nimport com.github.javaparser.ast.expr.TypeExpr;\nimport com.github.javaparser.ast.stmt.ExplicitConstructorInvocationStmt;\nimport com.github.javaparser.ast.type.ArrayType;\nimport com.github.javaparser.ast.type.ClassOrInterfaceType;\nimport com.github.javaparser.ast.type.PrimitiveType;\nimport com.github.javaparser.ast.type.Type;\nimport com.github.javaparser.ast.type.UnionType;\nimport com.github.javaparser.ast.type.VarType;\nimport com.github.javaparser.ast.type.VoidType;\nimport com.github.javaparser.ast.type.WildcardType;\nimport com.github.javaparser.resolution.MethodAmbiguityException;\nimport com.github.javaparser.resolution.MethodUsage;\nimport com.github.javaparser.resolution.UnsolvedSymbolException;\nimport com.github.javaparser.resolution.declarations.ResolvedAnnotationDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedClassDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedConstructorDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedMethodDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedReferenceTypeDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedTypeDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedTypeParameterDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedValueDeclaration;\nimport com.github.javaparser.resolution.types.ResolvedArrayType;\nimport com.github.javaparser.resolution.types.ResolvedPrimitiveType;\nimport com.github.javaparser.resolution.types.ResolvedReferenceType;\nimport com.github.javaparser.resolution.types.ResolvedType;\nimport com.github.javaparser.resolution.types.ResolvedTypeVariable;\nimport com.github.javaparser.resolution.types.ResolvedUnionType;\nimport com.github.javaparser.resolution.types.ResolvedVoidType;\nimport com.github.javaparser.resolution.types.ResolvedWildcard;\nimport com.github.javaparser.symbolsolver.core.resolution.Context;\nimport com.github.javaparser.symbolsolver.javaparsermodel.contexts.FieldAccessContext;\nimport com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserAnonymousClassDeclaration;\nimport com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserEnumDeclaration;\nimport com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserTypeVariableDeclaration;\nimport com.github.javaparser.symbolsolver.model.resolution.SymbolReference;\nimport com.github.javaparser.symbolsolver.model.resolution.TypeSolver;\nimport com.github.javaparser.symbolsolver.model.typesystem.ReferenceTypeImpl;\nimport com.github.javaparser.symbolsolver.reflectionmodel.ReflectionAnnotationDeclaration;\nimport com.github.javaparser.symbolsolver.reflectionmodel.ReflectionClassDeclaration;\nimport com.github.javaparser.symbolsolver.reflectionmodel.ReflectionEnumDeclaration;\nimport com.github.javaparser.symbolsolver.reflectionmodel.ReflectionInterfaceDeclaration;\nimport com.github.javaparser.symbolsolver.resolution.ConstructorResolutionLogic;\nimport com.github.javaparser.symbolsolver.resolution.MethodResolutionLogic;\nimport com.github.javaparser.symbolsolver.resolution.SymbolSolver;\nimport com.github.javaparser.utils.Log;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.Set;\nimport java.util.WeakHashMap;\nimport java.util.stream.Collectors;\n\nimport static com.github.javaparser.symbolsolver.javaparser.Navigator.demandParentNode;\nimport static com.github.javaparser.symbolsolver.model.resolution.SymbolReference.solved;\nimport static com.github.javaparser.symbolsolver.model.resolution.SymbolReference.unsolved;\n\n/**\n * Class to be used by final users to solve symbols for JavaParser ASTs.\n *\n * @author Federico Tomassetti\n */\npublic class JavaParserFacade {\n\n    private static final DataKey<ResolvedType> TYPE_WITH_LAMBDAS_RESOLVED = new DataKey<ResolvedType>() {\n    };\n    private static final DataKey<ResolvedType> TYPE_WITHOUT_LAMBDAS_RESOLVED = new DataKey<ResolvedType>() {\n    };\n\n    private static final Map<TypeSolver, JavaParserFacade> instances = new WeakHashMap<>();\n    \n    private static String JAVA_LANG_STRING = String.class.getCanonicalName();\n    \n    private final TypeSolver typeSolver;\n    private final TypeExtractor typeExtractor;\n    private final SymbolSolver symbolSolver;\n\n    private JavaParserFacade(TypeSolver typeSolver) {\n        this.typeSolver = typeSolver.getRoot();\n        this.symbolSolver = new SymbolSolver(typeSolver);\n        this.typeExtractor = new TypeExtractor(typeSolver, this);\n    }\n\n    public TypeSolver getTypeSolver() {\n        return typeSolver;\n    }\n\n    public SymbolSolver getSymbolSolver() {\n        return symbolSolver;\n    }\n\n    /**\n     * Note that the addition of the modifier {@code synchronized} is specific and directly in response to issue #2668.\n     * <br>This <strong>MUST NOT</strong> be misinterpreted as a signal that JavaParser is safe to use within a multi-threaded environment.\n     * <br>\n     * <br>Additional discussion and context from a user attempting multithreading can be found within issue #2671 .\n     * <br>\n     *\n     * @see <a href=\"https://github.com/javaparser/javaparser/issues/2668\">https://github.com/javaparser/javaparser/issues/2668</a>\n     * @see <a href=\"https://github.com/javaparser/javaparser/issues/2671\">https://github.com/javaparser/javaparser/issues/2671</a>\n     */\n    public synchronized static JavaParserFacade get(TypeSolver typeSolver) {\n        return instances.computeIfAbsent(typeSolver, JavaParserFacade::new);\n    }\n\n    /**\n     * This method is used to clear internal caches for the sake of releasing memory.\n     */\n    public static void clearInstances() {\n        instances.clear();\n    }\n\n    protected static ResolvedType solveGenericTypes(ResolvedType type, Context context) {\n        if (type.isTypeVariable()) {\n            return context.solveGenericType(type.describe()).orElse(type);\n        }\n        if (type.isWildcard()) {\n            if (type.asWildcard().isExtends() || type.asWildcard().isSuper()) {\n                ResolvedWildcard wildcardUsage = type.asWildcard();\n                ResolvedType boundResolved = solveGenericTypes(wildcardUsage.getBoundedType(), context);\n                if (wildcardUsage.isExtends()) {\n                    return ResolvedWildcard.extendsBound(boundResolved);\n                } else {\n                    return ResolvedWildcard.superBound(boundResolved);\n                }\n            }\n        }\n        return type;\n    }\n\n    public SymbolReference<? extends ResolvedValueDeclaration> solve(NameExpr nameExpr) {\n        return symbolSolver.solveSymbol(nameExpr.getName().getId(), nameExpr);\n    }\n\n    public SymbolReference<? extends ResolvedValueDeclaration> solve(SimpleName nameExpr) {\n        return symbolSolver.solveSymbol(nameExpr.getId(), nameExpr);\n    }\n\n    public SymbolReference<? extends ResolvedValueDeclaration> solve(Expression expr) {\n        return expr.toNameExpr().map(this::solve).orElseThrow(() -> new IllegalArgumentException(expr.getClass().getCanonicalName()));\n    }\n\n    public SymbolReference<ResolvedMethodDeclaration> solve(MethodCallExpr methodCallExpr) {\n        return solve(methodCallExpr, true);\n    }\n\n    public SymbolReference<ResolvedMethodDeclaration> solve(MethodReferenceExpr methodReferenceExpr) {\n        return solve(methodReferenceExpr, true);\n    }\n\n    public SymbolReference<ResolvedConstructorDeclaration> solve(ObjectCreationExpr objectCreationExpr) {\n        return solve(objectCreationExpr, true);\n    }\n\n    public SymbolReference<ResolvedConstructorDeclaration> solve(ExplicitConstructorInvocationStmt explicitConstructorInvocationStmt) {\n        return solve(explicitConstructorInvocationStmt, true);\n    }\n\n    public SymbolReference<ResolvedConstructorDeclaration> solve(ExplicitConstructorInvocationStmt explicitConstructorInvocationStmt, boolean solveLambdas) {\n        // Constructor invocation must exist within a class (not interface).\n        Optional<ClassOrInterfaceDeclaration> optAncestorClassOrInterfaceNode = explicitConstructorInvocationStmt.findAncestor(ClassOrInterfaceDeclaration.class);\n        if (!optAncestorClassOrInterfaceNode.isPresent()) {\n            return unsolved(ResolvedConstructorDeclaration.class);\n        }\n\n        ClassOrInterfaceDeclaration classOrInterfaceNode = optAncestorClassOrInterfaceNode.get();\n        ResolvedReferenceTypeDeclaration resolvedClassNode = classOrInterfaceNode.resolve();\n        if (!resolvedClassNode.isClass()) {\n            throw new IllegalStateException(\"Expected to be a class -- cannot call this() or super() within an interface.\");\n        }\n\n        ResolvedTypeDeclaration typeDecl = null;\n        if (explicitConstructorInvocationStmt.isThis()) {\n            // this()\n            typeDecl = resolvedClassNode.asReferenceType();\n        } else {\n            // super()\n            Optional<ResolvedReferenceType> superClass = resolvedClassNode.asClass().getSuperClass();\n            if (superClass.isPresent() && superClass.get().getTypeDeclaration().isPresent()) {\n                typeDecl = superClass.get().getTypeDeclaration().get();\n            }\n        }\n        if (typeDecl == null) {\n            return unsolved(ResolvedConstructorDeclaration.class);\n        }\n\n        // Solve each of the arguments being passed into this constructor invocation.\n        List<ResolvedType> argumentTypes = new LinkedList<>();\n        List<LambdaArgumentTypePlaceholder> placeholders = new LinkedList<>();\n        solveArguments(explicitConstructorInvocationStmt, explicitConstructorInvocationStmt.getArguments(), solveLambdas, argumentTypes, placeholders);\n\n        // Determine which constructor is referred to, and return it.\n        SymbolReference<ResolvedConstructorDeclaration> res = ConstructorResolutionLogic.findMostApplicable(((ResolvedClassDeclaration) typeDecl).getConstructors(), argumentTypes, typeSolver);\n        for (LambdaArgumentTypePlaceholder placeholder : placeholders) {\n            placeholder.setMethod(res);\n        }\n\n        return res;\n    }\n\n    public SymbolReference<ResolvedTypeDeclaration> solve(ThisExpr node) {\n        // If 'this' is prefixed by a class eg. MyClass.this\n        if (node.getTypeName().isPresent()) {\n            // Get the class name\n            String className = node.getTypeName().get().asString();\n            // Attempt to resolve using a typeSolver\n            SymbolReference<ResolvedReferenceTypeDeclaration> clazz = typeSolver.tryToSolveType(className);\n            if (clazz.isSolved()) {\n                return solved(clazz.getCorrespondingDeclaration());\n            }\n            // Attempt to resolve locally in Compilation unit\n            Optional<CompilationUnit> cu = node.findAncestor(CompilationUnit.class);\n            if (cu.isPresent()) {\n                Optional<ClassOrInterfaceDeclaration> classByName = cu.get().getClassByName(className);\n                if (classByName.isPresent()) {\n                    return solved(getTypeDeclaration(classByName.get()));\n                }\n            }\n        }\n        return solved(getTypeDeclaration(findContainingTypeDeclOrObjectCreationExpr(node)));\n    }\n\n    /**\n     * Given a constructor call find out to which constructor declaration it corresponds.\n     */\n    public SymbolReference<ResolvedConstructorDeclaration> solve(ObjectCreationExpr objectCreationExpr, boolean solveLambdas) {\n        List<ResolvedType> argumentTypes = new LinkedList<>();\n        List<LambdaArgumentTypePlaceholder> placeholders = new LinkedList<>();\n\n        solveArguments(objectCreationExpr, objectCreationExpr.getArguments(), solveLambdas, argumentTypes, placeholders);\n\n        ResolvedReferenceTypeDeclaration typeDecl = null;\n        if (objectCreationExpr.getAnonymousClassBody().isPresent()) {\n            typeDecl = new JavaParserAnonymousClassDeclaration(objectCreationExpr, typeSolver);\n        } else {\n            ResolvedType classDecl = JavaParserFacade.get(typeSolver).convert(objectCreationExpr.getType(), objectCreationExpr);\n            if (classDecl.isReferenceType() && classDecl.asReferenceType().getTypeDeclaration().isPresent()) {\n                typeDecl = classDecl.asReferenceType().getTypeDeclaration().get();\n            }\n        }\n        if (typeDecl == null) {\n            return unsolved(ResolvedConstructorDeclaration.class);\n        }\n        SymbolReference<ResolvedConstructorDeclaration> res = ConstructorResolutionLogic.findMostApplicable(typeDecl.getConstructors(), argumentTypes, typeSolver);\n        for (LambdaArgumentTypePlaceholder placeholder : placeholders) {\n            placeholder.setMethod(res);\n        }\n        return res;\n    }\n\n    private void solveArguments(Node node, NodeList<Expression> args, boolean solveLambdas, List<ResolvedType> argumentTypes,\n                                List<LambdaArgumentTypePlaceholder> placeholders) {\n        int i = 0;\n        for (Expression parameterValue : args) {\n            if (parameterValue instanceof LambdaExpr || parameterValue instanceof MethodReferenceExpr) {\n                LambdaArgumentTypePlaceholder placeholder = new LambdaArgumentTypePlaceholder(i);\n                argumentTypes.add(placeholder);\n                placeholders.add(placeholder);\n            } else {\n                try {\n                    argumentTypes.add(JavaParserFacade.get(typeSolver).getType(parameterValue, solveLambdas));\n                } catch (UnsolvedSymbolException e) {\n                    throw e;\n                } catch (Exception e) {\n                    throw new RuntimeException(String.format(\"Unable to calculate the type of a parameter of a method call. Method call: %s, Parameter: %s\",\n                            node, parameterValue), e);\n                }\n            }\n            i++;\n        }\n    }\n\n    /**\n     * Given a method call find out to which method declaration it corresponds.\n     */\n    public SymbolReference<ResolvedMethodDeclaration> solve(MethodCallExpr methodCallExpr, boolean solveLambdas) {\n        List<ResolvedType> argumentTypes = new LinkedList<>();\n        List<LambdaArgumentTypePlaceholder> placeholders = new LinkedList<>();\n\n        solveArguments(methodCallExpr, methodCallExpr.getArguments(), solveLambdas, argumentTypes, placeholders);\n\n        SymbolReference<ResolvedMethodDeclaration> res = JavaParserFactory.getContext(methodCallExpr, typeSolver).solveMethod(methodCallExpr.getName().getId(), argumentTypes, false);\n        for (LambdaArgumentTypePlaceholder placeholder : placeholders) {\n            placeholder.setMethod(res);\n        }\n        return res;\n    }\n\n    /**\n     * Given a method reference find out to which method declaration it corresponds.\n     */\n    public SymbolReference<ResolvedMethodDeclaration> solve(MethodReferenceExpr methodReferenceExpr, boolean solveLambdas) {\n        // pass empty argument list to be populated\n        List<ResolvedType> argumentTypes = new LinkedList<>();\n        return JavaParserFactory.getContext(methodReferenceExpr, typeSolver).solveMethod(methodReferenceExpr.getIdentifier(), argumentTypes, false);\n    }\n\n    public SymbolReference<ResolvedAnnotationDeclaration> solve(AnnotationExpr annotationExpr) {\n        Context context = JavaParserFactory.getContext(annotationExpr, typeSolver);\n        SymbolReference<ResolvedTypeDeclaration> typeDeclarationSymbolReference = context.solveType(annotationExpr.getNameAsString());\n        if (typeDeclarationSymbolReference.isSolved()) {\n            ResolvedAnnotationDeclaration annotationDeclaration = (ResolvedAnnotationDeclaration) typeDeclarationSymbolReference.getCorrespondingDeclaration();\n            return solved(annotationDeclaration);\n        } else {\n            return unsolved(ResolvedAnnotationDeclaration.class);\n        }\n    }\n\n    public SymbolReference<ResolvedValueDeclaration> solve(FieldAccessExpr fieldAccessExpr) {\n        return ((FieldAccessContext) JavaParserFactory.getContext(fieldAccessExpr, typeSolver)).solveField(fieldAccessExpr.getName().getId());\n    }\n\n    /**\n     * Get the type associated with the node.\n     * <p>\n     * This method was originally intended to get the type of a value: any value has a type.\n     * <p>\n     * For example:\n     * <pre>\n     * int foo(int a) {\n     *     return a; // when getType is invoked on \"a\" it returns the type \"int\"\n     * }\n     * </pre>\n     * <p>\n     * Now, users started using also of names of types itself, which do not have a type.\n     * <p>\n     * For example:\n     * <pre>\n     * class A {\n     *     int foo(int a) {\n     *         return A.someStaticField; // when getType is invoked on \"A\", which represents a class, it returns\n     *             // the type \"A\" itself while it used to throw UnsolvedSymbolException\n     * }\n     * </pre>\n     * <p>\n     * To accommodate this usage and avoid confusion this method return\n     * the type itself when used on the name of type.\n     */\n    public ResolvedType getType(Node node) {\n        try {\n            return getType(node, true);\n        } catch (UnsolvedSymbolException e) {\n            if (node instanceof NameExpr) {\n                NameExpr nameExpr = (NameExpr) node;\n                SymbolReference<ResolvedTypeDeclaration> typeDeclaration = JavaParserFactory.getContext(node, typeSolver)\n                        .solveType(nameExpr.getNameAsString());\n                if (typeDeclaration.isSolved() && typeDeclaration.getCorrespondingDeclaration() instanceof ResolvedReferenceTypeDeclaration) {\n                    ResolvedReferenceTypeDeclaration resolvedReferenceTypeDeclaration = (ResolvedReferenceTypeDeclaration) typeDeclaration.getCorrespondingDeclaration();\n                    return ReferenceTypeImpl.undeterminedParameters(resolvedReferenceTypeDeclaration, typeSolver);\n                }\n            }\n            throw e;\n        }\n    }\n\n    public ResolvedType getType(Node node, boolean solveLambdas) {\n        if (solveLambdas) {\n            if (!node.containsData(TYPE_WITH_LAMBDAS_RESOLVED)) {\n                ResolvedType res = getTypeConcrete(node, solveLambdas);\n\n                node.setData(TYPE_WITH_LAMBDAS_RESOLVED, res);\n\n                boolean secondPassNecessary = false;\n                if (node instanceof MethodCallExpr) {\n                    MethodCallExpr methodCallExpr = (MethodCallExpr) node;\n                    for (Node arg : methodCallExpr.getArguments()) {\n                        if (!arg.containsData(TYPE_WITH_LAMBDAS_RESOLVED)) {\n                            getType(arg, true);\n                            secondPassNecessary = true;\n                        }\n                    }\n                }\n                if (secondPassNecessary) {\n                    node.removeData(TYPE_WITH_LAMBDAS_RESOLVED);\n                    ResolvedType type = getType(node, true);\n                    node.setData(TYPE_WITH_LAMBDAS_RESOLVED, type);\n\n                }\n                Log.trace(\"getType on %s  -> %s\", () -> node, () -> res);\n            }\n            return node.getData(TYPE_WITH_LAMBDAS_RESOLVED);\n        } else {\n            Optional<ResolvedType> res = find(TYPE_WITH_LAMBDAS_RESOLVED, node);\n            if (res.isPresent()) {\n                return res.get();\n            }\n            res = find(TYPE_WITHOUT_LAMBDAS_RESOLVED, node);\n            if (!res.isPresent()) {\n                ResolvedType resType = getTypeConcrete(node, solveLambdas);\n                node.setData(TYPE_WITHOUT_LAMBDAS_RESOLVED, resType);\n                Optional<ResolvedType> finalRes = res;\n                Log.trace(\"getType on %s (no solveLambdas) -> %s\", () -> node, () -> finalRes);\n                return resType;\n            }\n            return res.get();\n        }\n    }\n\n    private Optional<ResolvedType> find(DataKey<ResolvedType> dataKey, Node node) {\n        if (node.containsData(dataKey)) {\n            return Optional.of(node.getData(dataKey));\n        }\n        return Optional.empty();\n    }\n\n    protected MethodUsage toMethodUsage(MethodReferenceExpr methodReferenceExpr, List<ResolvedType> paramTypes) {\n        Expression scope = methodReferenceExpr.getScope();\n        ResolvedType typeOfScope = getType(methodReferenceExpr.getScope());\n        if (!typeOfScope.isReferenceType()) {\n            throw new UnsupportedOperationException(typeOfScope.getClass().getCanonicalName());\n        }\n\n        Optional<MethodUsage> result;\n        Set<MethodUsage> allMethods = typeOfScope.asReferenceType().getTypeDeclaration()\n                .orElseThrow(() -> new RuntimeException(\"TypeDeclaration unexpectedly empty.\"))\n                .getAllMethods();\n\n        if (scope instanceof TypeExpr) {\n            // static methods should match all params\n            List<MethodUsage> staticMethodUsages = allMethods.stream()\n                    .filter(it -> it.getDeclaration().isStatic())\n                    .collect(Collectors.toList());\n\n            result = MethodResolutionLogic.findMostApplicableUsage(staticMethodUsages, methodReferenceExpr.getIdentifier(), paramTypes, typeSolver);\n\n            if (!paramTypes.isEmpty()) {\n                // instance methods are called on the first param and should match all other params\n                List<MethodUsage> instanceMethodUsages = allMethods.stream()\n                        .filter(it -> !it.getDeclaration().isStatic())\n                        .collect(Collectors.toList());\n\n                List<ResolvedType> instanceMethodParamTypes = new ArrayList<>(paramTypes);\n                instanceMethodParamTypes.remove(0); // remove the first one\n\n                Optional<MethodUsage> instanceResult = MethodResolutionLogic.findMostApplicableUsage(\n                        instanceMethodUsages, methodReferenceExpr.getIdentifier(), instanceMethodParamTypes, typeSolver);\n                if (result.isPresent() && instanceResult.isPresent()) {\n                    throw new MethodAmbiguityException(\"Ambiguous method call: cannot find a most applicable method for \" + methodReferenceExpr.getIdentifier());\n                }\n\n                if (instanceResult.isPresent()) {\n                    result = instanceResult;\n                }\n            }\n        } else {\n            result = MethodResolutionLogic.findMostApplicableUsage(new ArrayList<>(allMethods), methodReferenceExpr.getIdentifier(), paramTypes, typeSolver);\n\n            if (result.isPresent() && result.get().getDeclaration().isStatic()) {\n                throw new RuntimeException(\"Invalid static method reference \" + methodReferenceExpr.getIdentifier());\n            }\n        }\n\n        if (!result.isPresent()) {\n            throw new UnsupportedOperationException();\n        }\n\n        return result.get();\n    }\n\n    protected ResolvedType getBinaryTypeConcrete(Node left, Node right, boolean solveLambdas, BinaryExpr.Operator operator) {\n        ResolvedType leftType = getTypeConcrete(left, solveLambdas);\n        ResolvedType rightType = getTypeConcrete(right, solveLambdas);\n\n        // JLS 15.18.1. String Concatenation Operator +\n        // If only one operand expression is of type String, then string conversion (\u00a75.1.11) is performed on the other\n        // operand to produce a string at run time.\n        //\n        // The result of string concatenation is a reference to a String object that is the concatenation of the two\n        // operand strings. The characters of the left-hand operand precede the characters of the right-hand operand in\n        // the newly created string.\n\n        if (operator == BinaryExpr.Operator.PLUS) {\n            boolean isLeftString = leftType.isReferenceType() && leftType.asReferenceType()\n                    .getQualifiedName().equals(JAVA_LANG_STRING);\n            boolean isRightString = rightType.isReferenceType() && rightType.asReferenceType()\n                    .getQualifiedName().equals(JAVA_LANG_STRING);\n            if (isLeftString || isRightString) {\n                return isLeftString ? leftType : rightType;\n            }\n        }\n\n        // JLS 5.6.2. Binary Numeric Promotion\n        //\n        // Widening primitive conversion (\u00a75.1.2) is applied to convert either or both operands as specified by the\n        // following rules:\n        //\n        // * If either operand is of type double, the other is converted to double.\n        // * Otherwise, if either operand is of type float, the other is converted to float.\n        // * Otherwise, if either operand is of type long, the other is converted to long.\n        // * Otherwise, both operands are converted to type int.\n\n        boolean isLeftNumeric = leftType.isPrimitive() && leftType.asPrimitive().isNumeric();\n        boolean isRightNumeric = rightType.isPrimitive() && rightType.asPrimitive().isNumeric();\n\n        if (isLeftNumeric && isRightNumeric) {\n            return leftType.asPrimitive().bnp(rightType.asPrimitive());\n        }\n\n        if (rightType.isAssignableBy(leftType)) {\n            return rightType;\n        }\n        return leftType;\n    }\n\n\n    /**\n     * Should return more like a TypeApplication: a TypeDeclaration and possible typeParametersValues or array\n     * modifiers.\n     */\n    private ResolvedType getTypeConcrete(Node node, boolean solveLambdas) {\n        if (node == null) throw new IllegalArgumentException();\n        return node.accept(typeExtractor, solveLambdas);\n    }\n\n    /**\n     * Where a node has an interface/class/enum declaration as its ancestor, return the nearest one.\n     * <p>\n     * NOTE: See {@link #findContainingTypeDeclOrObjectCreationExpr} if wanting to include anonymous inner classes.\n     * <p>\n     * For example, these all return X:\n     * {@code public interface X { ... node here ... }}\n     * {@code public class X { ... node here ... }}\n     * {@code public enum X { ... node here ... }}\n     *\n     * @param node The Node whose ancestors will be traversed,\n     * @return The first class/interface/enum declaration in the Node's ancestry.\n     */\n    protected TypeDeclaration<?> findContainingTypeDecl(Node node) {\n        Node parent = node;\n        while (true) {\n            parent = demandParentNode(parent);\n            if (parent instanceof TypeDeclaration) {\n                return (TypeDeclaration<?>) parent;\n            }\n        }\n    }\n\n    /**\n     * Where a node has an interface/class/enum declaration -- or an object creation expression (anonymous inner class)\n     * -- as its ancestor, return the nearest one.\n     * <p>\n     * NOTE: See {@link #findContainingTypeDecl} if wanting to not include anonymous inner classes.\n     * <p>\n     * For example, these all return X:\n     * <ul>\n     *     <li>{@code public interface X { ... node here ... }}</li>\n     *     <li>{@code public class X { ... node here ... }}</li>\n     *     <li>{@code public enum X { ... node here ... }}</li>\n     *     <li><pre>{@code\n     *     new ActionListener() {\n     *          ... node here ...\n     *          public void actionPerformed(ActionEvent e) {\n     *               ... or node here ...\n     *          }\n     *     }\n     *     }</pre></li>\n     * </ul>\n     * <p>\n     *\n     * @param node The Node whose ancestors will be traversed,\n     * @return The first class/interface/enum declaration -- or object creation expression (anonymous inner class) -- in\n     * the Node's ancestry.\n     */\n    protected Node findContainingTypeDeclOrObjectCreationExpr(Node node) {\n        Node parent = node;\n        boolean detachFlag = false;\n        while (true) {\n            parent = demandParentNode(parent);\n            if (parent instanceof BodyDeclaration) {\n                if (parent instanceof TypeDeclaration) {\n                    return parent;\n                } else {\n                    detachFlag = true;\n                }\n            } else if (parent instanceof ObjectCreationExpr) {\n                if (detachFlag) {\n                    return parent;\n                }\n            }\n        }\n    }\n\n    /**\n     * Where a node has an interface/class/enum declaration -- or an object creation expression in an inner class\n     * references an outer class -- as its ancestor, return the declaration corresponding to the class name specified.\n     */\n    protected Node findContainingTypeDeclOrObjectCreationExpr(Node node, String className) {\n        Node parent = node;\n        boolean detachFlag = false;\n        while (true) {\n            parent = demandParentNode(parent);\n            if (parent instanceof BodyDeclaration) {\n                if (parent instanceof TypeDeclaration && ((TypeDeclaration<?>) parent).getFullyQualifiedName().get().endsWith(className)) {\n                    return parent;\n                } else {\n                    detachFlag = true;\n                }\n            } else if (parent instanceof ObjectCreationExpr) {\n                if (detachFlag) {\n                    return parent;\n                }\n            }\n        }\n    }\n\n\n    public ResolvedType convertToUsageVariableType(VariableDeclarator var) {\n        return get(typeSolver).convertToUsage(var.getType(), var);\n    }\n\n    public ResolvedType convertToUsage(Type type, Node context) {\n        if (type.isUnknownType()) {\n            throw new IllegalArgumentException(\"Inferred lambda parameter type\");\n        }\n        return convertToUsage(type, JavaParserFactory.getContext(context, typeSolver));\n    }\n\n    public ResolvedType convertToUsage(Type type) {\n        return convertToUsage(type, type);\n    }\n\n    // This is an hack around an issue in JavaParser\n    private String qName(ClassOrInterfaceType classOrInterfaceType) {\n        String name = classOrInterfaceType.getName().getId();\n        if (classOrInterfaceType.getScope().isPresent()) {\n            return qName(classOrInterfaceType.getScope().get()) + \".\" + name;\n        }\n        return name;\n    }\n\n    protected ResolvedType convertToUsage(Type type, Context context) {\n        if (context == null) {\n            throw new NullPointerException(\"Context should not be null\");\n        }\n        if (type instanceof ClassOrInterfaceType) {\n            return convertToUsage((ClassOrInterfaceType) type, context);\n        } else if (type instanceof PrimitiveType) {\n            return ResolvedPrimitiveType.byName(((PrimitiveType) type).getType().name());\n        } else if (type instanceof WildcardType) {\n            WildcardType wildcardType = (WildcardType) type;\n            if (wildcardType.getExtendedType().isPresent() && !wildcardType.getSuperType().isPresent()) {\n                return ResolvedWildcard.extendsBound(convertToUsage(wildcardType.getExtendedType().get(), context)); // removed (ReferenceTypeImpl)\n            } else if (!wildcardType.getExtendedType().isPresent() && wildcardType.getSuperType().isPresent()) {\n                return ResolvedWildcard.superBound(convertToUsage(wildcardType.getSuperType().get(), context)); // removed (ReferenceTypeImpl)\n            } else if (!wildcardType.getExtendedType().isPresent() && !wildcardType.getSuperType().isPresent()) {\n                return ResolvedWildcard.UNBOUNDED;\n            } else {\n                throw new UnsupportedOperationException(wildcardType.toString());\n            }\n        } else if (type instanceof VoidType) {\n            return ResolvedVoidType.INSTANCE;\n        } else if (type instanceof ArrayType) {\n            ArrayType jpArrayType = (ArrayType) type;\n            return new ResolvedArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n        } else if (type instanceof UnionType) {\n            UnionType unionType = (UnionType) type;\n            return new ResolvedUnionType(unionType.getElements().stream().map(el -> convertToUsage(el, context)).collect(Collectors.toList()));\n        } else if (type instanceof VarType) {\n            Node parent = type.getParentNode().get();\n            if (!(parent instanceof VariableDeclarator)) {\n                throw new IllegalStateException(\"Trying to resolve a `var` which is not in a variable declaration.\");\n            }\n            final VariableDeclarator variableDeclarator = (VariableDeclarator) parent;\n            return variableDeclarator.getInitializer()\n                    .map(Expression::calculateResolvedType)\n                    .orElseThrow(() -> new IllegalStateException(\"Cannot resolve `var` which has no initializer.\"));\n        } else {\n            throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n        }\n    }\n\n    protected ResolvedType convertToUsage(ClassOrInterfaceType classOrInterfaceType, Context context) {\n        String name = qName(classOrInterfaceType);\n        SymbolReference<ResolvedTypeDeclaration> ref = context.solveType(name);\n        if (!ref.isSolved()) {\n            throw new UnsolvedSymbolException(name);\n        }\n        ResolvedTypeDeclaration typeDeclaration = ref.getCorrespondingDeclaration();\n        List<ResolvedType> typeParameters = Collections.emptyList();\n        if (classOrInterfaceType.getTypeArguments().isPresent()) {\n            typeParameters = classOrInterfaceType.getTypeArguments().get().stream().map((pt) -> convertToUsage(pt, context)).collect(Collectors.toList());\n        }\n        if (typeDeclaration.isTypeParameter()) {\n            if (typeDeclaration instanceof ResolvedTypeParameterDeclaration) {\n                return new ResolvedTypeVariable((ResolvedTypeParameterDeclaration) typeDeclaration);\n            } else {\n                JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration = (JavaParserTypeVariableDeclaration) typeDeclaration;\n                return new ResolvedTypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n            }\n        } else {\n            return new ReferenceTypeImpl((ResolvedReferenceTypeDeclaration) typeDeclaration, typeParameters, typeSolver);\n        }\n    }\n\n    public ResolvedType convert(Type type, Node node) {\n        return convert(type, JavaParserFactory.getContext(node, typeSolver));\n    }\n\n    public ResolvedType convert(Type type, Context context) {\n        return convertToUsage(type, context);\n    }\n\n    public MethodUsage solveMethodAsUsage(MethodCallExpr call) {\n        List<ResolvedType> params = new ArrayList<>();\n        if (call.getArguments() != null) {\n            for (Expression param : call.getArguments()) {\n                //getTypeConcrete(Node node, boolean solveLambdas)\n                try {\n                    params.add(getType(param, false));\n                } catch (Exception e) {\n                    throw new RuntimeException(String.format(\"Error calculating the type of parameter %s of method call %s\", param, call), e);\n                }\n                //params.add(getTypeConcrete(param, false));\n            }\n        }\n        Context context = JavaParserFactory.getContext(call, typeSolver);\n        Optional<MethodUsage> methodUsage = context.solveMethodAsUsage(call.getName().getId(), params);\n        if (!methodUsage.isPresent()) {\n            throw new RuntimeException(\"Method '\" + call.getName() + \"' cannot be resolved in context \"\n                    + call + \" (line: \" + call.getRange().map(r -> \"\" + r.begin.line).orElse(\"??\") + \") \" + context + \". Parameter types: \" + params);\n        }\n        return methodUsage.get();\n    }\n\n    public ResolvedReferenceTypeDeclaration getTypeDeclaration(Node node) {\n        if (node instanceof TypeDeclaration) {\n            return getTypeDeclaration((TypeDeclaration) node);\n        } else if (node instanceof ObjectCreationExpr) {\n            return new JavaParserAnonymousClassDeclaration((ObjectCreationExpr) node, typeSolver);\n        } else {\n            throw new IllegalArgumentException();\n        }\n    }\n\n    public ResolvedReferenceTypeDeclaration getTypeDeclaration(ClassOrInterfaceDeclaration classOrInterfaceDeclaration) {\n        return JavaParserFactory.toTypeDeclaration(classOrInterfaceDeclaration, typeSolver);\n    }\n\n    /**\n     * \"this\" inserted in the given point, which type would have?\n     */\n    public ResolvedType getTypeOfThisIn(Node node) {\n        // TODO consider static methods\n        if (node instanceof ClassOrInterfaceDeclaration) {\n            return new ReferenceTypeImpl(getTypeDeclaration((ClassOrInterfaceDeclaration) node), typeSolver);\n        } else if (node instanceof EnumDeclaration) {\n            JavaParserEnumDeclaration enumDeclaration = new JavaParserEnumDeclaration((EnumDeclaration) node, typeSolver);\n            return new ReferenceTypeImpl(enumDeclaration, typeSolver);\n        } else if (node instanceof ObjectCreationExpr && ((ObjectCreationExpr) node).getAnonymousClassBody().isPresent()) {\n            JavaParserAnonymousClassDeclaration anonymousDeclaration = new JavaParserAnonymousClassDeclaration((ObjectCreationExpr) node, typeSolver);\n            return new ReferenceTypeImpl(anonymousDeclaration, typeSolver);\n        }\n        return getTypeOfThisIn(demandParentNode(node));\n    }\n\n    public ResolvedReferenceTypeDeclaration getTypeDeclaration(TypeDeclaration<?> typeDeclaration) {\n        return JavaParserFactory.toTypeDeclaration(typeDeclaration, typeSolver);\n    }\n\n    public ResolvedType classToResolvedType(Class<?> clazz) {\n        if (clazz.isPrimitive()) {\n            return ResolvedPrimitiveType.byName(clazz.getName());\n        }\n\n        ResolvedReferenceTypeDeclaration declaration;\n        if (clazz.isAnnotation()) {\n            declaration = new ReflectionAnnotationDeclaration(clazz, typeSolver);\n        } else if (clazz.isEnum()) {\n            declaration = new ReflectionEnumDeclaration(clazz, typeSolver);\n        } else if (clazz.isInterface()) {\n            declaration = new ReflectionInterfaceDeclaration(clazz, typeSolver);\n        } else {\n            declaration = new ReflectionClassDeclaration(clazz, typeSolver);\n        }\n        return new ReferenceTypeImpl(declaration, typeSolver);\n    }\n\n}\n",
        "diffSourceCodeSet": [
            "protected ResolvedType convertToUsage(ClassOrInterfaceType classOrInterfaceType, Context context) {\n        String name = qName(classOrInterfaceType);\n        SymbolReference<ResolvedTypeDeclaration> ref = context.solveType(name);\n        if (!ref.isSolved()) {\n            throw new UnsolvedSymbolException(name);\n        }\n        ResolvedTypeDeclaration typeDeclaration = ref.getCorrespondingDeclaration();\n        List<ResolvedType> typeParameters = Collections.emptyList();\n        if (classOrInterfaceType.getTypeArguments().isPresent()) {\n            typeParameters = classOrInterfaceType.getTypeArguments().get().stream().map((pt) -> convertToUsage(pt, context)).collect(Collectors.toList());\n        }\n        if (typeDeclaration.isTypeParameter()) {\n            if (typeDeclaration instanceof ResolvedTypeParameterDeclaration) {\n                return new ResolvedTypeVariable((ResolvedTypeParameterDeclaration) typeDeclaration);\n            } else {\n                JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration = (JavaParserTypeVariableDeclaration) typeDeclaration;\n                return new ResolvedTypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n            }\n        } else {\n            return new ReferenceTypeImpl((ResolvedReferenceTypeDeclaration) typeDeclaration, typeParameters, typeSolver);\n        }\n    }"
        ],
        "invokedMethodSet": [
            "methodSignature: com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade#getType\n methodBody: public ResolvedType getType(Node node, boolean solveLambdas) {\nif(solveLambdas){if(!node.containsData(TYPE_WITH_LAMBDAS_RESOLVED)){ResolvedType res=getTypeConcrete(node,solveLambdas);\nnode.setData(TYPE_WITH_LAMBDAS_RESOLVED,res);\nboolean secondPassNecessary=false;\nif(node instanceof MethodCallExpr){MethodCallExpr methodCallExpr=(MethodCallExpr)node;\nfor(Node arg: methodCallExpr.getArguments()){if(!arg.containsData(TYPE_WITH_LAMBDAS_RESOLVED)){getType(arg,true);\nsecondPassNecessary=true;\n}}}if(secondPassNecessary){node.removeData(TYPE_WITH_LAMBDAS_RESOLVED);\nResolvedType type=getType(node,true);\nnode.setData(TYPE_WITH_LAMBDAS_RESOLVED,type);\n}Log.trace(\"getType on %s  -> %s\",() -> node,() -> res);\n}return node.getData(TYPE_WITH_LAMBDAS_RESOLVED);\n}{Optional<ResolvedType> res=find(TYPE_WITH_LAMBDAS_RESOLVED,node);\nif(res.isPresent()){return res.get();\n}res=find(TYPE_WITHOUT_LAMBDAS_RESOLVED,node);\nif(!res.isPresent()){ResolvedType resType=getTypeConcrete(node,solveLambdas);\nnode.setData(TYPE_WITHOUT_LAMBDAS_RESOLVED,resType);\nOptional<ResolvedType> finalRes=res;\nLog.trace(\"getType on %s (no solveLambdas) -> %s\",() -> node,() -> finalRes);\nreturn resType;\n}return res.get();\n}}",
            "methodSignature: com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade#qName\n methodBody: private String qName(ClassOrInterfaceType classOrInterfaceType) {\nString name=classOrInterfaceType.getName().getId();\nif(classOrInterfaceType.getScope().isPresent()){return qName(classOrInterfaceType.getScope().get()) + \".\" + name;\n}return name;\n}",
            "methodSignature: com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade#get\n methodBody: public synchronized static JavaParserFacade get(TypeSolver typeSolver) {\nreturn instances.computeIfAbsent(typeSolver,JavaParserFacade::new);\n}",
            "methodSignature: com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade#convertToUsage\n methodBody: protected ResolvedType convertToUsage(Type type, Context context) {\nif(context == null){throw new NullPointerException(\"Context should not be null\");\n}if(type instanceof ClassOrInterfaceType){ClassOrInterfaceType classOrInterfaceType=(ClassOrInterfaceType)type;\nString name=qName(classOrInterfaceType);\nSymbolReference<ResolvedTypeDeclaration> ref=context.solveType(name);\nif(!ref.isSolved()){throw new UnsolvedSymbolException(name);\n}ResolvedTypeDeclaration typeDeclaration=ref.getCorrespondingDeclaration();\nList<ResolvedType> typeParameters=Collections.emptyList();\nif(classOrInterfaceType.getTypeArguments().isPresent()){typeParameters=classOrInterfaceType.getTypeArguments().get().stream().map((pt) -> convertToUsage(pt,context)).collect(Collectors.toList());\n}if(typeDeclaration.isTypeParameter()){if(typeDeclaration instanceof ResolvedTypeParameterDeclaration){return new ResolvedTypeVariable((ResolvedTypeParameterDeclaration)typeDeclaration);\n}{JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration=(JavaParserTypeVariableDeclaration)typeDeclaration;\nreturn new ResolvedTypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n}}{return new ReferenceTypeImpl((ResolvedReferenceTypeDeclaration)typeDeclaration,typeParameters,typeSolver);\n}}if(type instanceof PrimitiveType){return ResolvedPrimitiveType.byName(((PrimitiveType)type).getType().name());\n}if(type instanceof WildcardType){WildcardType wildcardType=(WildcardType)type;\nif(wildcardType.getExtendedType().isPresent() && !wildcardType.getSuperType().isPresent()){return ResolvedWildcard.extendsBound(convertToUsage(wildcardType.getExtendedType().get(),context));\n}if(!wildcardType.getExtendedType().isPresent() && wildcardType.getSuperType().isPresent()){return ResolvedWildcard.superBound(convertToUsage(wildcardType.getSuperType().get(),context));\n}if(!wildcardType.getExtendedType().isPresent() && !wildcardType.getSuperType().isPresent()){return ResolvedWildcard.UNBOUNDED;\n}{throw new UnsupportedOperationException(wildcardType.toString());\n}}if(type instanceof VoidType){return ResolvedVoidType.INSTANCE;\n}if(type instanceof ArrayType){ArrayType jpArrayType=(ArrayType)type;\nreturn new ResolvedArrayType(convertToUsage(jpArrayType.getComponentType(),context));\n}if(type instanceof UnionType){UnionType unionType=(UnionType)type;\nreturn new ResolvedUnionType(unionType.getElements().stream().map(el -> convertToUsage(el,context)).collect(Collectors.toList()));\n}if(type instanceof VarType){Node parent=type.getParentNode().get();\nif(!(parent instanceof VariableDeclarator)){throw new IllegalStateException(\"Trying to resolve a `var` which is not in a variable declaration.\");\n}final VariableDeclarator variableDeclarator=(VariableDeclarator)parent;\nreturn variableDeclarator.getInitializer().map(Expression::calculateResolvedType).orElseThrow(() -> new IllegalStateException(\"Cannot resolve `var` which has no initializer.\"));\n}{throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n}}"
        ],
        "sourceCodeAfterRefactoring": "protected ResolvedType convertToUsage(Type type, Context context) {\n        if (context == null) {\n            throw new NullPointerException(\"Context should not be null\");\n        }\n        if (type instanceof ClassOrInterfaceType) {\n            return convertToUsage((ClassOrInterfaceType) type, context);\n        } else if (type instanceof PrimitiveType) {\n            return ResolvedPrimitiveType.byName(((PrimitiveType) type).getType().name());\n        } else if (type instanceof WildcardType) {\n            WildcardType wildcardType = (WildcardType) type;\n            if (wildcardType.getExtendedType().isPresent() && !wildcardType.getSuperType().isPresent()) {\n                return ResolvedWildcard.extendsBound(convertToUsage(wildcardType.getExtendedType().get(), context)); // removed (ReferenceTypeImpl)\n            } else if (!wildcardType.getExtendedType().isPresent() && wildcardType.getSuperType().isPresent()) {\n                return ResolvedWildcard.superBound(convertToUsage(wildcardType.getSuperType().get(), context)); // removed (ReferenceTypeImpl)\n            } else if (!wildcardType.getExtendedType().isPresent() && !wildcardType.getSuperType().isPresent()) {\n                return ResolvedWildcard.UNBOUNDED;\n            } else {\n                throw new UnsupportedOperationException(wildcardType.toString());\n            }\n        } else if (type instanceof VoidType) {\n            return ResolvedVoidType.INSTANCE;\n        } else if (type instanceof ArrayType) {\n            ArrayType jpArrayType = (ArrayType) type;\n            return new ResolvedArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n        } else if (type instanceof UnionType) {\n            UnionType unionType = (UnionType) type;\n            return new ResolvedUnionType(unionType.getElements().stream().map(el -> convertToUsage(el, context)).collect(Collectors.toList()));\n        } else if (type instanceof VarType) {\n            Node parent = type.getParentNode().get();\n            if (!(parent instanceof VariableDeclarator)) {\n                throw new IllegalStateException(\"Trying to resolve a `var` which is not in a variable declaration.\");\n            }\n            final VariableDeclarator variableDeclarator = (VariableDeclarator) parent;\n            return variableDeclarator.getInitializer()\n                    .map(Expression::calculateResolvedType)\n                    .orElseThrow(() -> new IllegalStateException(\"Cannot resolve `var` which has no initializer.\"));\n        } else {\n            throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n        }\n    }\nprotected ResolvedType convertToUsage(ClassOrInterfaceType classOrInterfaceType, Context context) {\n        String name = qName(classOrInterfaceType);\n        SymbolReference<ResolvedTypeDeclaration> ref = context.solveType(name);\n        if (!ref.isSolved()) {\n            throw new UnsolvedSymbolException(name);\n        }\n        ResolvedTypeDeclaration typeDeclaration = ref.getCorrespondingDeclaration();\n        List<ResolvedType> typeParameters = Collections.emptyList();\n        if (classOrInterfaceType.getTypeArguments().isPresent()) {\n            typeParameters = classOrInterfaceType.getTypeArguments().get().stream().map((pt) -> convertToUsage(pt, context)).collect(Collectors.toList());\n        }\n        if (typeDeclaration.isTypeParameter()) {\n            if (typeDeclaration instanceof ResolvedTypeParameterDeclaration) {\n                return new ResolvedTypeVariable((ResolvedTypeParameterDeclaration) typeDeclaration);\n            } else {\n                JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration = (JavaParserTypeVariableDeclaration) typeDeclaration;\n                return new ResolvedTypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n            }\n        } else {\n            return new ReferenceTypeImpl((ResolvedReferenceTypeDeclaration) typeDeclaration, typeParameters, typeSolver);\n        }\n    }",
        "diffSourceCode": "-  673:     protected ResolvedType convertToUsage(Type type, Context context) {\n-  674:         if (context == null) {\n-  675:             throw new NullPointerException(\"Context should not be null\");\n-  676:         }\n-  677:         if (type instanceof ClassOrInterfaceType) {\n-  678:             ClassOrInterfaceType classOrInterfaceType = (ClassOrInterfaceType) type;\n-  679:             String name = qName(classOrInterfaceType);\n-  680:             SymbolReference<ResolvedTypeDeclaration> ref = context.solveType(name);\n-  681:             if (!ref.isSolved()) {\n-  682:                 throw new UnsolvedSymbolException(name);\n-  683:             }\n-  684:             ResolvedTypeDeclaration typeDeclaration = ref.getCorrespondingDeclaration();\n-  685:             List<ResolvedType> typeParameters = Collections.emptyList();\n-  686:             if (classOrInterfaceType.getTypeArguments().isPresent()) {\n-  687:                 typeParameters = classOrInterfaceType.getTypeArguments().get().stream().map((pt) -> convertToUsage(pt, context)).collect(Collectors.toList());\n-  688:             }\n-  689:             if (typeDeclaration.isTypeParameter()) {\n-  690:                 if (typeDeclaration instanceof ResolvedTypeParameterDeclaration) {\n-  691:                     return new ResolvedTypeVariable((ResolvedTypeParameterDeclaration) typeDeclaration);\n-  692:                 } else {\n-  693:                     JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration = (JavaParserTypeVariableDeclaration) typeDeclaration;\n-  694:                     return new ResolvedTypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n-  695:                 }\n-  696:             } else {\n-  697:                 return new ReferenceTypeImpl((ResolvedReferenceTypeDeclaration) typeDeclaration, typeParameters, typeSolver);\n-  698:             }\n-  699:         } else if (type instanceof PrimitiveType) {\n-  700:             return ResolvedPrimitiveType.byName(((PrimitiveType) type).getType().name());\n-  701:         } else if (type instanceof WildcardType) {\n-  702:             WildcardType wildcardType = (WildcardType) type;\n-  703:             if (wildcardType.getExtendedType().isPresent() && !wildcardType.getSuperType().isPresent()) {\n-  704:                 return ResolvedWildcard.extendsBound(convertToUsage(wildcardType.getExtendedType().get(), context)); // removed (ReferenceTypeImpl)\n-  705:             } else if (!wildcardType.getExtendedType().isPresent() && wildcardType.getSuperType().isPresent()) {\n-  706:                 return ResolvedWildcard.superBound(convertToUsage(wildcardType.getSuperType().get(), context)); // removed (ReferenceTypeImpl)\n-  707:             } else if (!wildcardType.getExtendedType().isPresent() && !wildcardType.getSuperType().isPresent()) {\n-  708:                 return ResolvedWildcard.UNBOUNDED;\n-  709:             } else {\n-  710:                 throw new UnsupportedOperationException(wildcardType.toString());\n-  711:             }\n-  712:         } else if (type instanceof VoidType) {\n-  713:             return ResolvedVoidType.INSTANCE;\n-  714:         } else if (type instanceof ArrayType) {\n-  715:             ArrayType jpArrayType = (ArrayType) type;\n-  716:             return new ResolvedArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n-  717:         } else if (type instanceof UnionType) {\n-  718:             UnionType unionType = (UnionType) type;\n-  719:             return new ResolvedUnionType(unionType.getElements().stream().map(el -> convertToUsage(el, context)).collect(Collectors.toList()));\n-  720:         } else if (type instanceof VarType) {\n-  721:             Node parent = type.getParentNode().get();\n-  722:             if (!(parent instanceof VariableDeclarator)) {\n-  723:                 throw new IllegalStateException(\"Trying to resolve a `var` which is not in a variable declaration.\");\n-  724:             }\n-  725:             final VariableDeclarator variableDeclarator = (VariableDeclarator) parent;\n-  726:             return variableDeclarator.getInitializer()\n-  727:                     .map(Expression::calculateResolvedType)\n-  728:                     .orElseThrow(() -> new IllegalStateException(\"Cannot resolve `var` which has no initializer.\"));\n-  729:         } else {\n-  730:             throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n-  731:         }\n-  732:     }\n-  733: \n-  734: \n-  735:     public ResolvedType convert(Type type, Node node) {\n-  736:         return convert(type, JavaParserFactory.getContext(node, typeSolver));\n-  737:     }\n-  738: \n-  739:     public ResolvedType convert(Type type, Context context) {\n+  673:         }\n+  674:         return name;\n+  675:     }\n+  676: \n+  677:     protected ResolvedType convertToUsage(Type type, Context context) {\n+  678:         if (context == null) {\n+  679:             throw new NullPointerException(\"Context should not be null\");\n+  680:         }\n+  681:         if (type instanceof ClassOrInterfaceType) {\n+  682:             return convertToUsage((ClassOrInterfaceType) type, context);\n+  683:         } else if (type instanceof PrimitiveType) {\n+  684:             return ResolvedPrimitiveType.byName(((PrimitiveType) type).getType().name());\n+  685:         } else if (type instanceof WildcardType) {\n+  686:             WildcardType wildcardType = (WildcardType) type;\n+  687:             if (wildcardType.getExtendedType().isPresent() && !wildcardType.getSuperType().isPresent()) {\n+  688:                 return ResolvedWildcard.extendsBound(convertToUsage(wildcardType.getExtendedType().get(), context)); // removed (ReferenceTypeImpl)\n+  689:             } else if (!wildcardType.getExtendedType().isPresent() && wildcardType.getSuperType().isPresent()) {\n+  690:                 return ResolvedWildcard.superBound(convertToUsage(wildcardType.getSuperType().get(), context)); // removed (ReferenceTypeImpl)\n+  691:             } else if (!wildcardType.getExtendedType().isPresent() && !wildcardType.getSuperType().isPresent()) {\n+  692:                 return ResolvedWildcard.UNBOUNDED;\n+  693:             } else {\n+  694:                 throw new UnsupportedOperationException(wildcardType.toString());\n+  695:             }\n+  696:         } else if (type instanceof VoidType) {\n+  697:             return ResolvedVoidType.INSTANCE;\n+  698:         } else if (type instanceof ArrayType) {\n+  699:             ArrayType jpArrayType = (ArrayType) type;\n+  700:             return new ResolvedArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n+  701:         } else if (type instanceof UnionType) {\n+  702:             UnionType unionType = (UnionType) type;\n+  703:             return new ResolvedUnionType(unionType.getElements().stream().map(el -> convertToUsage(el, context)).collect(Collectors.toList()));\n+  704:         } else if (type instanceof VarType) {\n+  705:             Node parent = type.getParentNode().get();\n+  706:             if (!(parent instanceof VariableDeclarator)) {\n+  707:                 throw new IllegalStateException(\"Trying to resolve a `var` which is not in a variable declaration.\");\n+  708:             }\n+  709:             final VariableDeclarator variableDeclarator = (VariableDeclarator) parent;\n+  710:             return variableDeclarator.getInitializer()\n+  711:                     .map(Expression::calculateResolvedType)\n+  712:                     .orElseThrow(() -> new IllegalStateException(\"Cannot resolve `var` which has no initializer.\"));\n+  713:         } else {\n+  714:             throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n+  715:         }\n+  716:     }\n+  717: \n+  718:     protected ResolvedType convertToUsage(ClassOrInterfaceType classOrInterfaceType, Context context) {\n+  719:         String name = qName(classOrInterfaceType);\n+  720:         SymbolReference<ResolvedTypeDeclaration> ref = context.solveType(name);\n+  721:         if (!ref.isSolved()) {\n+  722:             throw new UnsolvedSymbolException(name);\n+  723:         }\n+  724:         ResolvedTypeDeclaration typeDeclaration = ref.getCorrespondingDeclaration();\n+  725:         List<ResolvedType> typeParameters = Collections.emptyList();\n+  726:         if (classOrInterfaceType.getTypeArguments().isPresent()) {\n+  727:             typeParameters = classOrInterfaceType.getTypeArguments().get().stream().map((pt) -> convertToUsage(pt, context)).collect(Collectors.toList());\n+  728:         }\n+  729:         if (typeDeclaration.isTypeParameter()) {\n+  730:             if (typeDeclaration instanceof ResolvedTypeParameterDeclaration) {\n+  731:                 return new ResolvedTypeVariable((ResolvedTypeParameterDeclaration) typeDeclaration);\n+  732:             } else {\n+  733:                 JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration = (JavaParserTypeVariableDeclaration) typeDeclaration;\n+  734:                 return new ResolvedTypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n+  735:             }\n+  736:         } else {\n+  737:             return new ReferenceTypeImpl((ResolvedReferenceTypeDeclaration) typeDeclaration, typeParameters, typeSolver);\n+  738:         }\n+  739:     }\n",
        "uniqueId": "b79893b5786313fd661db8395cb7fabe44960877_673_732_718_739_677_716",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 32,
                "covered": 189
            },
            "BRANCH": {
                "missed": 8,
                "covered": 30
            },
            "LINE": {
                "missed": 6,
                "covered": 40
            },
            "COMPLEXITY": {
                "missed": 8,
                "covered": 12
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 17
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprivate assertOneRecordDeclaration(cu CompilationUnit) : void extracted from package record_allowComponentAccessorWithMatchingType() : void in class com.github.javaparser.ast.body.RecordDeclarationTest",
        "diffLocations": [
            {
                "filePath": "javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/RecordDeclarationTest.java",
                "startLine": 276,
                "endLine": 287,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/RecordDeclarationTest.java",
                "startLine": 273,
                "endLine": 283,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/RecordDeclarationTest.java",
                "startLine": 313,
                "endLine": 316,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "@Test\n    void record_allowComponentAccessorWithMatchingType() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return 10;\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }",
        "filePathBefore": "javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/RecordDeclarationTest.java",
        "isPureRefactoring": true,
        "commitId": "a73aba7b8cef7c52666d25169a3f6e495c65bcd2",
        "packageNameBefore": "com.github.javaparser.ast.body",
        "classNameBefore": "com.github.javaparser.ast.body.RecordDeclarationTest",
        "methodNameBefore": "com.github.javaparser.ast.body.RecordDeclarationTest#record_allowComponentAccessorWithMatchingType",
        "classSignatureBefore": "public class RecordDeclarationTest ",
        "methodNameBeforeSet": [
            "com.github.javaparser.ast.body.RecordDeclarationTest#record_allowComponentAccessorWithMatchingType"
        ],
        "classNameBeforeSet": [
            "com.github.javaparser.ast.body.RecordDeclarationTest"
        ],
        "classSignatureBeforeSet": [
            "public class RecordDeclarationTest "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "package com.github.javaparser.ast.body;\n\nimport com.github.javaparser.ParserConfiguration;\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.Modifier;\nimport com.github.javaparser.ast.NodeList;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.EnumSource;\nimport org.opentest4j.AssertionFailedError;\n\nimport java.util.List;\n\nimport static com.github.javaparser.utils.TestParser.parseCompilationUnit;\nimport static com.github.javaparser.utils.TestUtils.assertEqualsStringIgnoringEol;\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\npublic class RecordDeclarationTest {\n\n    @ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_13\", \"JAVA_13_PREVIEW\", \"JAVA_14\", \"JAVA_15\"})\n    void basicGrammarCompiles_languageLevelValidation_forbidden(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"record Point(int x, int y) { }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(languageLevel, s);\n        });\n    }\n\n    @ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_14_PREVIEW\", \"JAVA_15_PREVIEW\", \"JAVA_16\", \"JAVA_16_PREVIEW\"})\n    void basicGrammarCompiles_languageLevelValidation_permitted(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(languageLevel, s);\n    }\n\n    @Test\n    void basicGrammarCompiles() {\n        /* https://openjdk.java.net/jeps/395#Description */\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    @Test\n    void basicGrammar() {\n        /* https://openjdk.java.net/jeps/395#Description */\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        assertTrue(recordDeclaration.isRecordDeclaration());\n        assertTrue(recordDeclaration.getImplementedTypes().isEmpty());\n        assertTrue(recordDeclaration.getTypeParameters().isEmpty());\n        assertTrue(recordDeclaration.getFullyQualifiedName().isPresent());\n        assertEquals(\"Point\", recordDeclaration.getFullyQualifiedName().get());\n        assertTrue(recordDeclaration.isRecordDeclaration());\n\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"x\", parameter0.getNameAsString());\n        assertEquals(\"int\", parameter0.getTypeAsString());\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"y\", parameter1.getNameAsString());\n        assertEquals(\"int\", parameter1.getTypeAsString());\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Description\n     */\n    @Test\n    void basicRecordPrints() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        String expected = \"\" +\n                \"record Point(int x, int y) {\\n\" +\n                \"}\\n\" +\n                \"\";\n        assertEqualsStringIgnoringEol(expected, cu.toString());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-record\n     */\n    @Test\n    void record_cannotExtend() {\n        String s = \"record Point(int x, int y) extends OtherThing { }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_cannotBeAbstract() {\n        String s = \"abstract record Point(int x, int y) { }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n    }\n\n    @Test\n    void recordWithVarArgs() {\n        String s = \"record R(T1 c1, Tn... cn){ }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"c1\", parameter0.getNameAsString());\n        assertEquals(\"T1\", parameter0.getTypeAsString());\n        assertFalse(parameter0.isVarArgs());\n\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"cn\", parameter1.getNameAsString());\n        assertEquals(\"Tn\", parameter1.getTypeAsString());\n        assertTrue(parameter1.isVarArgs());\n    }\n\n    @Test\n    void recordWithAnnotationedParameters() {\n        String s = \"record Card(@MyAnno Rank rank, @MyAnno Suit suit) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"rank\", parameter0.getNameAsString());\n        assertEquals(\"Rank\", parameter0.getTypeAsString());\n        assertEquals(1, parameter0.getAnnotations().size());\n\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"suit\", parameter1.getNameAsString());\n        assertEquals(\"Suit\", parameter1.getTypeAsString());\n        assertEquals(1, parameter1.getAnnotations().size());\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    @Test\n    void record_emptyMembers() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    @Test\n    void record_permitStaticFields() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    static int z;\\n\" +\n                \"\\n\" +\n                \"    static {\\n\" +\n                \"        int z = 10;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    @Test\n    void record_permitMethods() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    public String xyz() {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    @Test\n    void record_mustNotAllowNonStaticFields() {\n        String s = \"record Point(int x, int y) { int z; }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n    }\n\n    @Test\n    void record_mustAllowStaticFields() {\n        String s = \"record Point(int x, int y) { static int z; }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n\n    @Test\n    void record_mustNotAllowMismatchedComponentAccessorReturnType() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public String x() {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n\n    }\n\n    @Test\n    void record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public String x(int a) {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    @Test\n    void record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod2() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public int x(int a) {\\n\" +\n                \"        return 10;\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n\n    @Test\n    void record_allowComponentAccessorWithMatchingType() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return 10;\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    // https://bugs.openjdk.java.net/browse/JDK-8222777\n    @Test\n    void recordDeclarationFromTheJDK8222777() {\n        CompilationUnit cu = parseCompilationUnit(\"\" +\n                \"public record Range(int lo, int hi) {\\n\" +\n                \"\\n\" +\n                \"  public Range {\\n\" +\n                \"    if (lo > hi)  /* referring here to the implicit constructor parameters */\\n\" +\n                \"      throw new IllegalArgumentException(String.format(\\\"(%d,%d)\\\", lo, hi));\\n\" +\n                \"  }\\n\" +\n                \"}\"\n        );\n\n        RecordDeclaration record = cu.findFirst(RecordDeclaration.class).get();\n        assertThat(record.getNameAsString()).isEqualTo(\"Range\");\n        assertThat(record.getModifiers()).containsExactly(Modifier.publicModifier());\n        // test parameters\n        // get constructor\n        // test parameters (none)\n    }\n}\n",
        "filePathAfter": "javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/RecordDeclarationTest.java",
        "sourceCodeAfterForWhole": "package com.github.javaparser.ast.body;\n\nimport com.github.javaparser.ParserConfiguration;\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.Modifier;\nimport com.github.javaparser.ast.NodeList;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.EnumSource;\nimport org.opentest4j.AssertionFailedError;\n\nimport java.util.List;\n\nimport static com.github.javaparser.utils.TestParser.parseCompilationUnit;\nimport static com.github.javaparser.utils.TestUtils.assertEqualsStringIgnoringEol;\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\npublic class RecordDeclarationTest {\n\n    @ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_13\", \"JAVA_13_PREVIEW\", \"JAVA_14\", \"JAVA_15\"})\n    void basicGrammarCompiles_languageLevelValidation_forbidden(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"record Point(int x, int y) { }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(languageLevel, s);\n        });\n    }\n\n    @ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_14_PREVIEW\", \"JAVA_15_PREVIEW\", \"JAVA_16\", \"JAVA_16_PREVIEW\"})\n    void basicGrammarCompiles_languageLevelValidation_permitted(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(languageLevel, s);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Description\n     */\n    @Test\n    void basicGrammarCompiles() {\n        String s = \"record Point(int x, int y) { }\";\n        assertOneRecordDeclaration(parseCompilationUnit(s));\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Description\n     */\n    @Test\n    void basicGrammar() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        RecordDeclaration recordDeclaration = cu.findAll(RecordDeclaration.class).get(0);\n\n        assertTrue(recordDeclaration.isRecordDeclaration());\n        assertTrue(recordDeclaration.getImplementedTypes().isEmpty());\n        assertTrue(recordDeclaration.getTypeParameters().isEmpty());\n        assertTrue(recordDeclaration.getFullyQualifiedName().isPresent());\n        assertEquals(\"Point\", recordDeclaration.getFullyQualifiedName().get());\n        assertTrue(recordDeclaration.isRecordDeclaration());\n\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"x\", parameter0.getNameAsString());\n        assertEquals(\"int\", parameter0.getTypeAsString());\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"y\", parameter1.getNameAsString());\n        assertEquals(\"int\", parameter1.getTypeAsString());\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Description\n     */\n    @Test\n    void basicRecordPrints() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        String expected = \"\" +\n                \"record Point(int x, int y) {\\n\" +\n                \"}\\n\" +\n                \"\";\n        assertEqualsStringIgnoringEol(expected, cu.toString());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-record\n     */\n    @Test\n    void record_cannotExtend() {\n        String s = \"record Point(int x, int y) extends OtherThing { }\";\n        assertCompilationFails(s);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_cannotBeAbstract() {\n        String s = \"abstract record Point(int x, int y) { }\";\n        assertCompilationFails(s);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_mayImplementInterfaces() {\n        String s = \"record Point(int x, int y) implements OtherInterface { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void recordWithVarArgs() {\n        String s = \"record R(T1 c1, Tn... cn){ }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"c1\", parameter0.getNameAsString());\n        assertEquals(\"T1\", parameter0.getTypeAsString());\n        assertFalse(parameter0.isVarArgs());\n\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"cn\", parameter1.getNameAsString());\n        assertEquals(\"Tn\", parameter1.getTypeAsString());\n        assertTrue(parameter1.isVarArgs());\n    }\n\n    @Test\n    void recordWithAnnotationedParameters() {\n        String s = \"record Card(@MyAnno Rank rank, @MyAnno Suit suit) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"rank\", parameter0.getNameAsString());\n        assertEquals(\"Rank\", parameter0.getTypeAsString());\n        assertEquals(1, parameter0.getAnnotations().size());\n\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"suit\", parameter1.getNameAsString());\n        assertEquals(\"Suit\", parameter1.getTypeAsString());\n        assertEquals(1, parameter1.getAnnotations().size());\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    @Test\n    void record_emptyMembers() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    @Test\n    void record_permitStaticFields() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    static int z;\\n\" +\n                \"\\n\" +\n                \"    static {\\n\" +\n                \"        int z = 10;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_permitMethods() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    public String xyz() {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_mustNotAllowNonStaticFields() {\n        String s = \"record Point(int x, int y) { int z; }\";\n        assertCompilationFails(s);\n    }\n\n    @Test\n    void record_mustAllowStaticFields() {\n        String s = \"record Point(int x, int y) { static int z; }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n\n    @Test\n    void record_mustNotAllowMismatchedComponentAccessorReturnType() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public String x() {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \" }\";\n        assertCompilationFails(s);\n    }\n\n    @Test\n    void record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public String x(int a) {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod2() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public int x(int a) {\\n\" +\n                \"        return 10;\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_allowComponentAccessorWithMatchingType() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return 10;\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    // https://bugs.openjdk.java.net/browse/JDK-8222777\n    @Test\n    void recordDeclarationFromTheJDK8222777() {\n        CompilationUnit cu = parseCompilationUnit(\"\" +\n                \"public record Range(int lo, int hi) {\\n\" +\n                \"\\n\" +\n                \"  public Range {\\n\" +\n                \"    if (lo > hi)  /* referring here to the implicit constructor parameters */\\n\" +\n                \"      throw new IllegalArgumentException(String.format(\\\"(%d,%d)\\\", lo, hi));\\n\" +\n                \"  }\\n\" +\n                \"}\"\n        );\n\n        RecordDeclaration record = cu.findFirst(RecordDeclaration.class).get();\n        assertThat(record.getNameAsString()).isEqualTo(\"Range\");\n        assertThat(record.getModifiers()).containsExactly(Modifier.publicModifier());\n        // test parameters\n        // get constructor\n        // test parameters (none)\n    }\n\n\n    private void assertCompilationFails(String s) {\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n    }\n\n    private void assertOneRecordDeclaration(CompilationUnit cu) {\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n}\n",
        "diffSourceCodeSet": [
            "private void assertOneRecordDeclaration(CompilationUnit cu) {\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }"
        ],
        "invokedMethodSet": [],
        "sourceCodeAfterRefactoring": "@Test\n    void record_allowComponentAccessorWithMatchingType() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return 10;\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\nprivate void assertOneRecordDeclaration(CompilationUnit cu) {\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }",
        "diffSourceCode": "-  273:     }\n-  274: \n-  275: \n-  276:     @Test\n-  277:     void record_allowComponentAccessorWithMatchingType() {\n-  278:         String s = \"record Point(int x, int y) {\\n\" +\n-  279:                 \"    public int x() {\\n\" +\n-  280:                 \"        return 10;\\n\" +\n-  281:                 \"    }\\n\" +\n-  282:                 \" }\";\n-  283: \n-  284:         CompilationUnit cu = parseCompilationUnit(s);\n-  285:         List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n-  286:         assertEquals(1, recordDeclarations.size());\n-  287:     }\n+  273:     @Test\n+  274:     void record_allowComponentAccessorWithMatchingType() {\n+  275:         String s = \"record Point(int x, int y) {\\n\" +\n+  276:                 \"    public int x() {\\n\" +\n+  277:                 \"        return 10;\\n\" +\n+  278:                 \"    }\\n\" +\n+  279:                 \" }\";\n+  280: \n+  281:         CompilationUnit cu = parseCompilationUnit(s);\n+  282:         assertOneRecordDeclaration(cu);\n+  283:     }\n+  284: \n+  285:     // https://bugs.openjdk.java.net/browse/JDK-8222777\n+  286:     @Test\n+  287:     void recordDeclarationFromTheJDK8222777() {\n+  313:     private void assertOneRecordDeclaration(CompilationUnit cu) {\n+  314:         List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n+  315:         assertEquals(1, recordDeclarations.size());\n+  316:     }\n",
        "uniqueId": "a73aba7b8cef7c52666d25169a3f6e495c65bcd2_276_287_313_316_273_283",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "testMethod": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 1.8
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprivate assertOneRecordDeclaration(cu CompilationUnit) : void extracted from package record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod2() : void in class com.github.javaparser.ast.body.RecordDeclarationTest",
        "diffLocations": [
            {
                "filePath": "javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/RecordDeclarationTest.java",
                "startLine": 262,
                "endLine": 273,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/RecordDeclarationTest.java",
                "startLine": 261,
                "endLine": 271,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/RecordDeclarationTest.java",
                "startLine": 313,
                "endLine": 316,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "@Test\n    void record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod2() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public int x(int a) {\\n\" +\n                \"        return 10;\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }",
        "filePathBefore": "javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/RecordDeclarationTest.java",
        "isPureRefactoring": true,
        "commitId": "a73aba7b8cef7c52666d25169a3f6e495c65bcd2",
        "packageNameBefore": "com.github.javaparser.ast.body",
        "classNameBefore": "com.github.javaparser.ast.body.RecordDeclarationTest",
        "methodNameBefore": "com.github.javaparser.ast.body.RecordDeclarationTest#record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod2",
        "classSignatureBefore": "public class RecordDeclarationTest ",
        "methodNameBeforeSet": [
            "com.github.javaparser.ast.body.RecordDeclarationTest#record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod2"
        ],
        "classNameBeforeSet": [
            "com.github.javaparser.ast.body.RecordDeclarationTest"
        ],
        "classSignatureBeforeSet": [
            "public class RecordDeclarationTest "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "package com.github.javaparser.ast.body;\n\nimport com.github.javaparser.ParserConfiguration;\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.Modifier;\nimport com.github.javaparser.ast.NodeList;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.EnumSource;\nimport org.opentest4j.AssertionFailedError;\n\nimport java.util.List;\n\nimport static com.github.javaparser.utils.TestParser.parseCompilationUnit;\nimport static com.github.javaparser.utils.TestUtils.assertEqualsStringIgnoringEol;\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\npublic class RecordDeclarationTest {\n\n    @ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_13\", \"JAVA_13_PREVIEW\", \"JAVA_14\", \"JAVA_15\"})\n    void basicGrammarCompiles_languageLevelValidation_forbidden(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"record Point(int x, int y) { }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(languageLevel, s);\n        });\n    }\n\n    @ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_14_PREVIEW\", \"JAVA_15_PREVIEW\", \"JAVA_16\", \"JAVA_16_PREVIEW\"})\n    void basicGrammarCompiles_languageLevelValidation_permitted(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(languageLevel, s);\n    }\n\n    @Test\n    void basicGrammarCompiles() {\n        /* https://openjdk.java.net/jeps/395#Description */\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    @Test\n    void basicGrammar() {\n        /* https://openjdk.java.net/jeps/395#Description */\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        assertTrue(recordDeclaration.isRecordDeclaration());\n        assertTrue(recordDeclaration.getImplementedTypes().isEmpty());\n        assertTrue(recordDeclaration.getTypeParameters().isEmpty());\n        assertTrue(recordDeclaration.getFullyQualifiedName().isPresent());\n        assertEquals(\"Point\", recordDeclaration.getFullyQualifiedName().get());\n        assertTrue(recordDeclaration.isRecordDeclaration());\n\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"x\", parameter0.getNameAsString());\n        assertEquals(\"int\", parameter0.getTypeAsString());\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"y\", parameter1.getNameAsString());\n        assertEquals(\"int\", parameter1.getTypeAsString());\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Description\n     */\n    @Test\n    void basicRecordPrints() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        String expected = \"\" +\n                \"record Point(int x, int y) {\\n\" +\n                \"}\\n\" +\n                \"\";\n        assertEqualsStringIgnoringEol(expected, cu.toString());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-record\n     */\n    @Test\n    void record_cannotExtend() {\n        String s = \"record Point(int x, int y) extends OtherThing { }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_cannotBeAbstract() {\n        String s = \"abstract record Point(int x, int y) { }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n    }\n\n    @Test\n    void recordWithVarArgs() {\n        String s = \"record R(T1 c1, Tn... cn){ }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"c1\", parameter0.getNameAsString());\n        assertEquals(\"T1\", parameter0.getTypeAsString());\n        assertFalse(parameter0.isVarArgs());\n\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"cn\", parameter1.getNameAsString());\n        assertEquals(\"Tn\", parameter1.getTypeAsString());\n        assertTrue(parameter1.isVarArgs());\n    }\n\n    @Test\n    void recordWithAnnotationedParameters() {\n        String s = \"record Card(@MyAnno Rank rank, @MyAnno Suit suit) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"rank\", parameter0.getNameAsString());\n        assertEquals(\"Rank\", parameter0.getTypeAsString());\n        assertEquals(1, parameter0.getAnnotations().size());\n\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"suit\", parameter1.getNameAsString());\n        assertEquals(\"Suit\", parameter1.getTypeAsString());\n        assertEquals(1, parameter1.getAnnotations().size());\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    @Test\n    void record_emptyMembers() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    @Test\n    void record_permitStaticFields() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    static int z;\\n\" +\n                \"\\n\" +\n                \"    static {\\n\" +\n                \"        int z = 10;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    @Test\n    void record_permitMethods() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    public String xyz() {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    @Test\n    void record_mustNotAllowNonStaticFields() {\n        String s = \"record Point(int x, int y) { int z; }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n    }\n\n    @Test\n    void record_mustAllowStaticFields() {\n        String s = \"record Point(int x, int y) { static int z; }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n\n    @Test\n    void record_mustNotAllowMismatchedComponentAccessorReturnType() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public String x() {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n\n    }\n\n    @Test\n    void record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public String x(int a) {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    @Test\n    void record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod2() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public int x(int a) {\\n\" +\n                \"        return 10;\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n\n    @Test\n    void record_allowComponentAccessorWithMatchingType() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return 10;\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    // https://bugs.openjdk.java.net/browse/JDK-8222777\n    @Test\n    void recordDeclarationFromTheJDK8222777() {\n        CompilationUnit cu = parseCompilationUnit(\"\" +\n                \"public record Range(int lo, int hi) {\\n\" +\n                \"\\n\" +\n                \"  public Range {\\n\" +\n                \"    if (lo > hi)  /* referring here to the implicit constructor parameters */\\n\" +\n                \"      throw new IllegalArgumentException(String.format(\\\"(%d,%d)\\\", lo, hi));\\n\" +\n                \"  }\\n\" +\n                \"}\"\n        );\n\n        RecordDeclaration record = cu.findFirst(RecordDeclaration.class).get();\n        assertThat(record.getNameAsString()).isEqualTo(\"Range\");\n        assertThat(record.getModifiers()).containsExactly(Modifier.publicModifier());\n        // test parameters\n        // get constructor\n        // test parameters (none)\n    }\n}\n",
        "filePathAfter": "javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/RecordDeclarationTest.java",
        "sourceCodeAfterForWhole": "package com.github.javaparser.ast.body;\n\nimport com.github.javaparser.ParserConfiguration;\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.Modifier;\nimport com.github.javaparser.ast.NodeList;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.EnumSource;\nimport org.opentest4j.AssertionFailedError;\n\nimport java.util.List;\n\nimport static com.github.javaparser.utils.TestParser.parseCompilationUnit;\nimport static com.github.javaparser.utils.TestUtils.assertEqualsStringIgnoringEol;\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\npublic class RecordDeclarationTest {\n\n    @ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_13\", \"JAVA_13_PREVIEW\", \"JAVA_14\", \"JAVA_15\"})\n    void basicGrammarCompiles_languageLevelValidation_forbidden(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"record Point(int x, int y) { }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(languageLevel, s);\n        });\n    }\n\n    @ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_14_PREVIEW\", \"JAVA_15_PREVIEW\", \"JAVA_16\", \"JAVA_16_PREVIEW\"})\n    void basicGrammarCompiles_languageLevelValidation_permitted(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(languageLevel, s);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Description\n     */\n    @Test\n    void basicGrammarCompiles() {\n        String s = \"record Point(int x, int y) { }\";\n        assertOneRecordDeclaration(parseCompilationUnit(s));\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Description\n     */\n    @Test\n    void basicGrammar() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        RecordDeclaration recordDeclaration = cu.findAll(RecordDeclaration.class).get(0);\n\n        assertTrue(recordDeclaration.isRecordDeclaration());\n        assertTrue(recordDeclaration.getImplementedTypes().isEmpty());\n        assertTrue(recordDeclaration.getTypeParameters().isEmpty());\n        assertTrue(recordDeclaration.getFullyQualifiedName().isPresent());\n        assertEquals(\"Point\", recordDeclaration.getFullyQualifiedName().get());\n        assertTrue(recordDeclaration.isRecordDeclaration());\n\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"x\", parameter0.getNameAsString());\n        assertEquals(\"int\", parameter0.getTypeAsString());\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"y\", parameter1.getNameAsString());\n        assertEquals(\"int\", parameter1.getTypeAsString());\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Description\n     */\n    @Test\n    void basicRecordPrints() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        String expected = \"\" +\n                \"record Point(int x, int y) {\\n\" +\n                \"}\\n\" +\n                \"\";\n        assertEqualsStringIgnoringEol(expected, cu.toString());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-record\n     */\n    @Test\n    void record_cannotExtend() {\n        String s = \"record Point(int x, int y) extends OtherThing { }\";\n        assertCompilationFails(s);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_cannotBeAbstract() {\n        String s = \"abstract record Point(int x, int y) { }\";\n        assertCompilationFails(s);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_mayImplementInterfaces() {\n        String s = \"record Point(int x, int y) implements OtherInterface { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void recordWithVarArgs() {\n        String s = \"record R(T1 c1, Tn... cn){ }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"c1\", parameter0.getNameAsString());\n        assertEquals(\"T1\", parameter0.getTypeAsString());\n        assertFalse(parameter0.isVarArgs());\n\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"cn\", parameter1.getNameAsString());\n        assertEquals(\"Tn\", parameter1.getTypeAsString());\n        assertTrue(parameter1.isVarArgs());\n    }\n\n    @Test\n    void recordWithAnnotationedParameters() {\n        String s = \"record Card(@MyAnno Rank rank, @MyAnno Suit suit) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"rank\", parameter0.getNameAsString());\n        assertEquals(\"Rank\", parameter0.getTypeAsString());\n        assertEquals(1, parameter0.getAnnotations().size());\n\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"suit\", parameter1.getNameAsString());\n        assertEquals(\"Suit\", parameter1.getTypeAsString());\n        assertEquals(1, parameter1.getAnnotations().size());\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    @Test\n    void record_emptyMembers() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    @Test\n    void record_permitStaticFields() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    static int z;\\n\" +\n                \"\\n\" +\n                \"    static {\\n\" +\n                \"        int z = 10;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_permitMethods() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    public String xyz() {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_mustNotAllowNonStaticFields() {\n        String s = \"record Point(int x, int y) { int z; }\";\n        assertCompilationFails(s);\n    }\n\n    @Test\n    void record_mustAllowStaticFields() {\n        String s = \"record Point(int x, int y) { static int z; }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n\n    @Test\n    void record_mustNotAllowMismatchedComponentAccessorReturnType() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public String x() {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \" }\";\n        assertCompilationFails(s);\n    }\n\n    @Test\n    void record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public String x(int a) {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod2() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public int x(int a) {\\n\" +\n                \"        return 10;\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_allowComponentAccessorWithMatchingType() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return 10;\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    // https://bugs.openjdk.java.net/browse/JDK-8222777\n    @Test\n    void recordDeclarationFromTheJDK8222777() {\n        CompilationUnit cu = parseCompilationUnit(\"\" +\n                \"public record Range(int lo, int hi) {\\n\" +\n                \"\\n\" +\n                \"  public Range {\\n\" +\n                \"    if (lo > hi)  /* referring here to the implicit constructor parameters */\\n\" +\n                \"      throw new IllegalArgumentException(String.format(\\\"(%d,%d)\\\", lo, hi));\\n\" +\n                \"  }\\n\" +\n                \"}\"\n        );\n\n        RecordDeclaration record = cu.findFirst(RecordDeclaration.class).get();\n        assertThat(record.getNameAsString()).isEqualTo(\"Range\");\n        assertThat(record.getModifiers()).containsExactly(Modifier.publicModifier());\n        // test parameters\n        // get constructor\n        // test parameters (none)\n    }\n\n\n    private void assertCompilationFails(String s) {\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n    }\n\n    private void assertOneRecordDeclaration(CompilationUnit cu) {\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n}\n",
        "diffSourceCodeSet": [
            "private void assertOneRecordDeclaration(CompilationUnit cu) {\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }"
        ],
        "invokedMethodSet": [],
        "sourceCodeAfterRefactoring": "@Test\n    void record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod2() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public int x(int a) {\\n\" +\n                \"        return 10;\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\nprivate void assertOneRecordDeclaration(CompilationUnit cu) {\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }",
        "diffSourceCode": "-  261: \n-  262:     @Test\n-  263:     void record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod2() {\n-  264:         String s = \"record Point(int x, int y) {\\n\" +\n-  265:                 \"    public int x(int a) {\\n\" +\n-  266:                 \"        return 10;\\n\" +\n-  267:                 \"    }\\n\" +\n-  268:                 \" }\";\n-  269: \n-  270:         CompilationUnit cu = parseCompilationUnit(s);\n-  271:         List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n-  272:         assertEquals(1, recordDeclarations.size());\n-  273:     }\n+  261:     @Test\n+  262:     void record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod2() {\n+  263:         String s = \"record Point(int x, int y) {\\n\" +\n+  264:                 \"    public int x(int a) {\\n\" +\n+  265:                 \"        return 10;\\n\" +\n+  266:                 \"    }\\n\" +\n+  267:                 \" }\";\n+  268: \n+  269:         CompilationUnit cu = parseCompilationUnit(s);\n+  270:         assertOneRecordDeclaration(cu);\n+  271:     }\n+  272: \n+  273:     @Test\n+  313:     private void assertOneRecordDeclaration(CompilationUnit cu) {\n+  314:         List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n+  315:         assertEquals(1, recordDeclarations.size());\n+  316:     }\n",
        "uniqueId": "a73aba7b8cef7c52666d25169a3f6e495c65bcd2_262_273_313_316_261_271",
        "moveFileExist": true,
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 1.8,
        "testResult": true,
        "coverageInfo": {
            "testMethod": {
                "missed": 0,
                "covered": 1
            }
        }
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprivate assertOneRecordDeclaration(cu CompilationUnit) : void extracted from package record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod() : void in class com.github.javaparser.ast.body.RecordDeclarationTest",
        "diffLocations": [
            {
                "filePath": "javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/RecordDeclarationTest.java",
                "startLine": 249,
                "endLine": 260,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/RecordDeclarationTest.java",
                "startLine": 249,
                "endLine": 259,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/RecordDeclarationTest.java",
                "startLine": 313,
                "endLine": 316,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "@Test\n    void record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public String x(int a) {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }",
        "filePathBefore": "javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/RecordDeclarationTest.java",
        "isPureRefactoring": true,
        "commitId": "a73aba7b8cef7c52666d25169a3f6e495c65bcd2",
        "packageNameBefore": "com.github.javaparser.ast.body",
        "classNameBefore": "com.github.javaparser.ast.body.RecordDeclarationTest",
        "methodNameBefore": "com.github.javaparser.ast.body.RecordDeclarationTest#record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod",
        "classSignatureBefore": "public class RecordDeclarationTest ",
        "methodNameBeforeSet": [
            "com.github.javaparser.ast.body.RecordDeclarationTest#record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod"
        ],
        "classNameBeforeSet": [
            "com.github.javaparser.ast.body.RecordDeclarationTest"
        ],
        "classSignatureBeforeSet": [
            "public class RecordDeclarationTest "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "package com.github.javaparser.ast.body;\n\nimport com.github.javaparser.ParserConfiguration;\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.Modifier;\nimport com.github.javaparser.ast.NodeList;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.EnumSource;\nimport org.opentest4j.AssertionFailedError;\n\nimport java.util.List;\n\nimport static com.github.javaparser.utils.TestParser.parseCompilationUnit;\nimport static com.github.javaparser.utils.TestUtils.assertEqualsStringIgnoringEol;\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\npublic class RecordDeclarationTest {\n\n    @ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_13\", \"JAVA_13_PREVIEW\", \"JAVA_14\", \"JAVA_15\"})\n    void basicGrammarCompiles_languageLevelValidation_forbidden(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"record Point(int x, int y) { }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(languageLevel, s);\n        });\n    }\n\n    @ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_14_PREVIEW\", \"JAVA_15_PREVIEW\", \"JAVA_16\", \"JAVA_16_PREVIEW\"})\n    void basicGrammarCompiles_languageLevelValidation_permitted(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(languageLevel, s);\n    }\n\n    @Test\n    void basicGrammarCompiles() {\n        /* https://openjdk.java.net/jeps/395#Description */\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    @Test\n    void basicGrammar() {\n        /* https://openjdk.java.net/jeps/395#Description */\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        assertTrue(recordDeclaration.isRecordDeclaration());\n        assertTrue(recordDeclaration.getImplementedTypes().isEmpty());\n        assertTrue(recordDeclaration.getTypeParameters().isEmpty());\n        assertTrue(recordDeclaration.getFullyQualifiedName().isPresent());\n        assertEquals(\"Point\", recordDeclaration.getFullyQualifiedName().get());\n        assertTrue(recordDeclaration.isRecordDeclaration());\n\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"x\", parameter0.getNameAsString());\n        assertEquals(\"int\", parameter0.getTypeAsString());\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"y\", parameter1.getNameAsString());\n        assertEquals(\"int\", parameter1.getTypeAsString());\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Description\n     */\n    @Test\n    void basicRecordPrints() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        String expected = \"\" +\n                \"record Point(int x, int y) {\\n\" +\n                \"}\\n\" +\n                \"\";\n        assertEqualsStringIgnoringEol(expected, cu.toString());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-record\n     */\n    @Test\n    void record_cannotExtend() {\n        String s = \"record Point(int x, int y) extends OtherThing { }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_cannotBeAbstract() {\n        String s = \"abstract record Point(int x, int y) { }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n    }\n\n    @Test\n    void recordWithVarArgs() {\n        String s = \"record R(T1 c1, Tn... cn){ }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"c1\", parameter0.getNameAsString());\n        assertEquals(\"T1\", parameter0.getTypeAsString());\n        assertFalse(parameter0.isVarArgs());\n\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"cn\", parameter1.getNameAsString());\n        assertEquals(\"Tn\", parameter1.getTypeAsString());\n        assertTrue(parameter1.isVarArgs());\n    }\n\n    @Test\n    void recordWithAnnotationedParameters() {\n        String s = \"record Card(@MyAnno Rank rank, @MyAnno Suit suit) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"rank\", parameter0.getNameAsString());\n        assertEquals(\"Rank\", parameter0.getTypeAsString());\n        assertEquals(1, parameter0.getAnnotations().size());\n\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"suit\", parameter1.getNameAsString());\n        assertEquals(\"Suit\", parameter1.getTypeAsString());\n        assertEquals(1, parameter1.getAnnotations().size());\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    @Test\n    void record_emptyMembers() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    @Test\n    void record_permitStaticFields() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    static int z;\\n\" +\n                \"\\n\" +\n                \"    static {\\n\" +\n                \"        int z = 10;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    @Test\n    void record_permitMethods() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    public String xyz() {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    @Test\n    void record_mustNotAllowNonStaticFields() {\n        String s = \"record Point(int x, int y) { int z; }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n    }\n\n    @Test\n    void record_mustAllowStaticFields() {\n        String s = \"record Point(int x, int y) { static int z; }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n\n    @Test\n    void record_mustNotAllowMismatchedComponentAccessorReturnType() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public String x() {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n\n    }\n\n    @Test\n    void record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public String x(int a) {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    @Test\n    void record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod2() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public int x(int a) {\\n\" +\n                \"        return 10;\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n\n    @Test\n    void record_allowComponentAccessorWithMatchingType() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return 10;\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    // https://bugs.openjdk.java.net/browse/JDK-8222777\n    @Test\n    void recordDeclarationFromTheJDK8222777() {\n        CompilationUnit cu = parseCompilationUnit(\"\" +\n                \"public record Range(int lo, int hi) {\\n\" +\n                \"\\n\" +\n                \"  public Range {\\n\" +\n                \"    if (lo > hi)  /* referring here to the implicit constructor parameters */\\n\" +\n                \"      throw new IllegalArgumentException(String.format(\\\"(%d,%d)\\\", lo, hi));\\n\" +\n                \"  }\\n\" +\n                \"}\"\n        );\n\n        RecordDeclaration record = cu.findFirst(RecordDeclaration.class).get();\n        assertThat(record.getNameAsString()).isEqualTo(\"Range\");\n        assertThat(record.getModifiers()).containsExactly(Modifier.publicModifier());\n        // test parameters\n        // get constructor\n        // test parameters (none)\n    }\n}\n",
        "filePathAfter": "javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/RecordDeclarationTest.java",
        "sourceCodeAfterForWhole": "package com.github.javaparser.ast.body;\n\nimport com.github.javaparser.ParserConfiguration;\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.Modifier;\nimport com.github.javaparser.ast.NodeList;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.EnumSource;\nimport org.opentest4j.AssertionFailedError;\n\nimport java.util.List;\n\nimport static com.github.javaparser.utils.TestParser.parseCompilationUnit;\nimport static com.github.javaparser.utils.TestUtils.assertEqualsStringIgnoringEol;\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\npublic class RecordDeclarationTest {\n\n    @ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_13\", \"JAVA_13_PREVIEW\", \"JAVA_14\", \"JAVA_15\"})\n    void basicGrammarCompiles_languageLevelValidation_forbidden(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"record Point(int x, int y) { }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(languageLevel, s);\n        });\n    }\n\n    @ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_14_PREVIEW\", \"JAVA_15_PREVIEW\", \"JAVA_16\", \"JAVA_16_PREVIEW\"})\n    void basicGrammarCompiles_languageLevelValidation_permitted(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(languageLevel, s);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Description\n     */\n    @Test\n    void basicGrammarCompiles() {\n        String s = \"record Point(int x, int y) { }\";\n        assertOneRecordDeclaration(parseCompilationUnit(s));\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Description\n     */\n    @Test\n    void basicGrammar() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        RecordDeclaration recordDeclaration = cu.findAll(RecordDeclaration.class).get(0);\n\n        assertTrue(recordDeclaration.isRecordDeclaration());\n        assertTrue(recordDeclaration.getImplementedTypes().isEmpty());\n        assertTrue(recordDeclaration.getTypeParameters().isEmpty());\n        assertTrue(recordDeclaration.getFullyQualifiedName().isPresent());\n        assertEquals(\"Point\", recordDeclaration.getFullyQualifiedName().get());\n        assertTrue(recordDeclaration.isRecordDeclaration());\n\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"x\", parameter0.getNameAsString());\n        assertEquals(\"int\", parameter0.getTypeAsString());\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"y\", parameter1.getNameAsString());\n        assertEquals(\"int\", parameter1.getTypeAsString());\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Description\n     */\n    @Test\n    void basicRecordPrints() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        String expected = \"\" +\n                \"record Point(int x, int y) {\\n\" +\n                \"}\\n\" +\n                \"\";\n        assertEqualsStringIgnoringEol(expected, cu.toString());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-record\n     */\n    @Test\n    void record_cannotExtend() {\n        String s = \"record Point(int x, int y) extends OtherThing { }\";\n        assertCompilationFails(s);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_cannotBeAbstract() {\n        String s = \"abstract record Point(int x, int y) { }\";\n        assertCompilationFails(s);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_mayImplementInterfaces() {\n        String s = \"record Point(int x, int y) implements OtherInterface { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void recordWithVarArgs() {\n        String s = \"record R(T1 c1, Tn... cn){ }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"c1\", parameter0.getNameAsString());\n        assertEquals(\"T1\", parameter0.getTypeAsString());\n        assertFalse(parameter0.isVarArgs());\n\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"cn\", parameter1.getNameAsString());\n        assertEquals(\"Tn\", parameter1.getTypeAsString());\n        assertTrue(parameter1.isVarArgs());\n    }\n\n    @Test\n    void recordWithAnnotationedParameters() {\n        String s = \"record Card(@MyAnno Rank rank, @MyAnno Suit suit) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"rank\", parameter0.getNameAsString());\n        assertEquals(\"Rank\", parameter0.getTypeAsString());\n        assertEquals(1, parameter0.getAnnotations().size());\n\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"suit\", parameter1.getNameAsString());\n        assertEquals(\"Suit\", parameter1.getTypeAsString());\n        assertEquals(1, parameter1.getAnnotations().size());\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    @Test\n    void record_emptyMembers() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    @Test\n    void record_permitStaticFields() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    static int z;\\n\" +\n                \"\\n\" +\n                \"    static {\\n\" +\n                \"        int z = 10;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_permitMethods() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    public String xyz() {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_mustNotAllowNonStaticFields() {\n        String s = \"record Point(int x, int y) { int z; }\";\n        assertCompilationFails(s);\n    }\n\n    @Test\n    void record_mustAllowStaticFields() {\n        String s = \"record Point(int x, int y) { static int z; }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n\n    @Test\n    void record_mustNotAllowMismatchedComponentAccessorReturnType() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public String x() {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \" }\";\n        assertCompilationFails(s);\n    }\n\n    @Test\n    void record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public String x(int a) {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod2() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public int x(int a) {\\n\" +\n                \"        return 10;\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_allowComponentAccessorWithMatchingType() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return 10;\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    // https://bugs.openjdk.java.net/browse/JDK-8222777\n    @Test\n    void recordDeclarationFromTheJDK8222777() {\n        CompilationUnit cu = parseCompilationUnit(\"\" +\n                \"public record Range(int lo, int hi) {\\n\" +\n                \"\\n\" +\n                \"  public Range {\\n\" +\n                \"    if (lo > hi)  /* referring here to the implicit constructor parameters */\\n\" +\n                \"      throw new IllegalArgumentException(String.format(\\\"(%d,%d)\\\", lo, hi));\\n\" +\n                \"  }\\n\" +\n                \"}\"\n        );\n\n        RecordDeclaration record = cu.findFirst(RecordDeclaration.class).get();\n        assertThat(record.getNameAsString()).isEqualTo(\"Range\");\n        assertThat(record.getModifiers()).containsExactly(Modifier.publicModifier());\n        // test parameters\n        // get constructor\n        // test parameters (none)\n    }\n\n\n    private void assertCompilationFails(String s) {\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n    }\n\n    private void assertOneRecordDeclaration(CompilationUnit cu) {\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n}\n",
        "diffSourceCodeSet": [
            "private void assertOneRecordDeclaration(CompilationUnit cu) {\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }"
        ],
        "invokedMethodSet": [],
        "sourceCodeAfterRefactoring": "@Test\n    void record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public String x(int a) {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\nprivate void assertOneRecordDeclaration(CompilationUnit cu) {\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }",
        "diffSourceCode": "   249:     @Test\n   250:     void record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod() {\n   251:         String s = \"record Point(int x, int y) {\\n\" +\n   252:                 \"    public String x(int a) {\\n\" +\n   253:                 \"        return \\\"10\\\";\\n\" +\n   254:                 \"    }\\n\" +\n   255:                 \" }\";\n   256: \n   257:         CompilationUnit cu = parseCompilationUnit(s);\n-  258:         List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n-  259:         assertEquals(1, recordDeclarations.size());\n-  260:     }\n+  258:         assertOneRecordDeclaration(cu);\n+  259:     }\n+  260: \n+  313:     private void assertOneRecordDeclaration(CompilationUnit cu) {\n+  314:         List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n+  315:         assertEquals(1, recordDeclarations.size());\n+  316:     }\n",
        "uniqueId": "a73aba7b8cef7c52666d25169a3f6e495c65bcd2_249_260_313_316_249_259",
        "moveFileExist": true,
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 1.8,
        "testResult": true,
        "coverageInfo": {
            "testMethod": {
                "missed": 0,
                "covered": 1
            }
        }
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprivate assertCompilationFails(s String) : void extracted from package record_mustNotAllowMismatchedComponentAccessorReturnType() : void in class com.github.javaparser.ast.body.RecordDeclarationTest",
        "diffLocations": [
            {
                "filePath": "javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/RecordDeclarationTest.java",
                "startLine": 235,
                "endLine": 247,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/RecordDeclarationTest.java",
                "startLine": 239,
                "endLine": 247,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/RecordDeclarationTest.java",
                "startLine": 307,
                "endLine": 311,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "@Test\n    void record_mustNotAllowMismatchedComponentAccessorReturnType() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public String x() {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n\n    }",
        "filePathBefore": "javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/RecordDeclarationTest.java",
        "isPureRefactoring": true,
        "commitId": "a73aba7b8cef7c52666d25169a3f6e495c65bcd2",
        "packageNameBefore": "com.github.javaparser.ast.body",
        "classNameBefore": "com.github.javaparser.ast.body.RecordDeclarationTest",
        "methodNameBefore": "com.github.javaparser.ast.body.RecordDeclarationTest#record_mustNotAllowMismatchedComponentAccessorReturnType",
        "classSignatureBefore": "public class RecordDeclarationTest ",
        "methodNameBeforeSet": [
            "com.github.javaparser.ast.body.RecordDeclarationTest#record_mustNotAllowMismatchedComponentAccessorReturnType"
        ],
        "classNameBeforeSet": [
            "com.github.javaparser.ast.body.RecordDeclarationTest"
        ],
        "classSignatureBeforeSet": [
            "public class RecordDeclarationTest "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "package com.github.javaparser.ast.body;\n\nimport com.github.javaparser.ParserConfiguration;\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.Modifier;\nimport com.github.javaparser.ast.NodeList;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.EnumSource;\nimport org.opentest4j.AssertionFailedError;\n\nimport java.util.List;\n\nimport static com.github.javaparser.utils.TestParser.parseCompilationUnit;\nimport static com.github.javaparser.utils.TestUtils.assertEqualsStringIgnoringEol;\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\npublic class RecordDeclarationTest {\n\n    @ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_13\", \"JAVA_13_PREVIEW\", \"JAVA_14\", \"JAVA_15\"})\n    void basicGrammarCompiles_languageLevelValidation_forbidden(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"record Point(int x, int y) { }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(languageLevel, s);\n        });\n    }\n\n    @ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_14_PREVIEW\", \"JAVA_15_PREVIEW\", \"JAVA_16\", \"JAVA_16_PREVIEW\"})\n    void basicGrammarCompiles_languageLevelValidation_permitted(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(languageLevel, s);\n    }\n\n    @Test\n    void basicGrammarCompiles() {\n        /* https://openjdk.java.net/jeps/395#Description */\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    @Test\n    void basicGrammar() {\n        /* https://openjdk.java.net/jeps/395#Description */\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        assertTrue(recordDeclaration.isRecordDeclaration());\n        assertTrue(recordDeclaration.getImplementedTypes().isEmpty());\n        assertTrue(recordDeclaration.getTypeParameters().isEmpty());\n        assertTrue(recordDeclaration.getFullyQualifiedName().isPresent());\n        assertEquals(\"Point\", recordDeclaration.getFullyQualifiedName().get());\n        assertTrue(recordDeclaration.isRecordDeclaration());\n\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"x\", parameter0.getNameAsString());\n        assertEquals(\"int\", parameter0.getTypeAsString());\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"y\", parameter1.getNameAsString());\n        assertEquals(\"int\", parameter1.getTypeAsString());\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Description\n     */\n    @Test\n    void basicRecordPrints() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        String expected = \"\" +\n                \"record Point(int x, int y) {\\n\" +\n                \"}\\n\" +\n                \"\";\n        assertEqualsStringIgnoringEol(expected, cu.toString());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-record\n     */\n    @Test\n    void record_cannotExtend() {\n        String s = \"record Point(int x, int y) extends OtherThing { }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_cannotBeAbstract() {\n        String s = \"abstract record Point(int x, int y) { }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n    }\n\n    @Test\n    void recordWithVarArgs() {\n        String s = \"record R(T1 c1, Tn... cn){ }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"c1\", parameter0.getNameAsString());\n        assertEquals(\"T1\", parameter0.getTypeAsString());\n        assertFalse(parameter0.isVarArgs());\n\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"cn\", parameter1.getNameAsString());\n        assertEquals(\"Tn\", parameter1.getTypeAsString());\n        assertTrue(parameter1.isVarArgs());\n    }\n\n    @Test\n    void recordWithAnnotationedParameters() {\n        String s = \"record Card(@MyAnno Rank rank, @MyAnno Suit suit) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"rank\", parameter0.getNameAsString());\n        assertEquals(\"Rank\", parameter0.getTypeAsString());\n        assertEquals(1, parameter0.getAnnotations().size());\n\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"suit\", parameter1.getNameAsString());\n        assertEquals(\"Suit\", parameter1.getTypeAsString());\n        assertEquals(1, parameter1.getAnnotations().size());\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    @Test\n    void record_emptyMembers() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    @Test\n    void record_permitStaticFields() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    static int z;\\n\" +\n                \"\\n\" +\n                \"    static {\\n\" +\n                \"        int z = 10;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    @Test\n    void record_permitMethods() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    public String xyz() {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    @Test\n    void record_mustNotAllowNonStaticFields() {\n        String s = \"record Point(int x, int y) { int z; }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n    }\n\n    @Test\n    void record_mustAllowStaticFields() {\n        String s = \"record Point(int x, int y) { static int z; }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n\n    @Test\n    void record_mustNotAllowMismatchedComponentAccessorReturnType() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public String x() {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n\n    }\n\n    @Test\n    void record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public String x(int a) {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    @Test\n    void record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod2() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public int x(int a) {\\n\" +\n                \"        return 10;\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n\n    @Test\n    void record_allowComponentAccessorWithMatchingType() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return 10;\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n\n    // https://bugs.openjdk.java.net/browse/JDK-8222777\n    @Test\n    void recordDeclarationFromTheJDK8222777() {\n        CompilationUnit cu = parseCompilationUnit(\"\" +\n                \"public record Range(int lo, int hi) {\\n\" +\n                \"\\n\" +\n                \"  public Range {\\n\" +\n                \"    if (lo > hi)  /* referring here to the implicit constructor parameters */\\n\" +\n                \"      throw new IllegalArgumentException(String.format(\\\"(%d,%d)\\\", lo, hi));\\n\" +\n                \"  }\\n\" +\n                \"}\"\n        );\n\n        RecordDeclaration record = cu.findFirst(RecordDeclaration.class).get();\n        assertThat(record.getNameAsString()).isEqualTo(\"Range\");\n        assertThat(record.getModifiers()).containsExactly(Modifier.publicModifier());\n        // test parameters\n        // get constructor\n        // test parameters (none)\n    }\n}\n",
        "filePathAfter": "javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/RecordDeclarationTest.java",
        "sourceCodeAfterForWhole": "package com.github.javaparser.ast.body;\n\nimport com.github.javaparser.ParserConfiguration;\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.Modifier;\nimport com.github.javaparser.ast.NodeList;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.EnumSource;\nimport org.opentest4j.AssertionFailedError;\n\nimport java.util.List;\n\nimport static com.github.javaparser.utils.TestParser.parseCompilationUnit;\nimport static com.github.javaparser.utils.TestUtils.assertEqualsStringIgnoringEol;\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\npublic class RecordDeclarationTest {\n\n    @ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_13\", \"JAVA_13_PREVIEW\", \"JAVA_14\", \"JAVA_15\"})\n    void basicGrammarCompiles_languageLevelValidation_forbidden(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"record Point(int x, int y) { }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(languageLevel, s);\n        });\n    }\n\n    @ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_14_PREVIEW\", \"JAVA_15_PREVIEW\", \"JAVA_16\", \"JAVA_16_PREVIEW\"})\n    void basicGrammarCompiles_languageLevelValidation_permitted(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(languageLevel, s);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Description\n     */\n    @Test\n    void basicGrammarCompiles() {\n        String s = \"record Point(int x, int y) { }\";\n        assertOneRecordDeclaration(parseCompilationUnit(s));\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Description\n     */\n    @Test\n    void basicGrammar() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        RecordDeclaration recordDeclaration = cu.findAll(RecordDeclaration.class).get(0);\n\n        assertTrue(recordDeclaration.isRecordDeclaration());\n        assertTrue(recordDeclaration.getImplementedTypes().isEmpty());\n        assertTrue(recordDeclaration.getTypeParameters().isEmpty());\n        assertTrue(recordDeclaration.getFullyQualifiedName().isPresent());\n        assertEquals(\"Point\", recordDeclaration.getFullyQualifiedName().get());\n        assertTrue(recordDeclaration.isRecordDeclaration());\n\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"x\", parameter0.getNameAsString());\n        assertEquals(\"int\", parameter0.getTypeAsString());\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"y\", parameter1.getNameAsString());\n        assertEquals(\"int\", parameter1.getTypeAsString());\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Description\n     */\n    @Test\n    void basicRecordPrints() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        String expected = \"\" +\n                \"record Point(int x, int y) {\\n\" +\n                \"}\\n\" +\n                \"\";\n        assertEqualsStringIgnoringEol(expected, cu.toString());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-record\n     */\n    @Test\n    void record_cannotExtend() {\n        String s = \"record Point(int x, int y) extends OtherThing { }\";\n        assertCompilationFails(s);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_cannotBeAbstract() {\n        String s = \"abstract record Point(int x, int y) { }\";\n        assertCompilationFails(s);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_mayImplementInterfaces() {\n        String s = \"record Point(int x, int y) implements OtherInterface { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void recordWithVarArgs() {\n        String s = \"record R(T1 c1, Tn... cn){ }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"c1\", parameter0.getNameAsString());\n        assertEquals(\"T1\", parameter0.getTypeAsString());\n        assertFalse(parameter0.isVarArgs());\n\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"cn\", parameter1.getNameAsString());\n        assertEquals(\"Tn\", parameter1.getTypeAsString());\n        assertTrue(parameter1.isVarArgs());\n    }\n\n    @Test\n    void recordWithAnnotationedParameters() {\n        String s = \"record Card(@MyAnno Rank rank, @MyAnno Suit suit) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"rank\", parameter0.getNameAsString());\n        assertEquals(\"Rank\", parameter0.getTypeAsString());\n        assertEquals(1, parameter0.getAnnotations().size());\n\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"suit\", parameter1.getNameAsString());\n        assertEquals(\"Suit\", parameter1.getTypeAsString());\n        assertEquals(1, parameter1.getAnnotations().size());\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    @Test\n    void record_emptyMembers() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    @Test\n    void record_permitStaticFields() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    static int z;\\n\" +\n                \"\\n\" +\n                \"    static {\\n\" +\n                \"        int z = 10;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_permitMethods() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    public String xyz() {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_mustNotAllowNonStaticFields() {\n        String s = \"record Point(int x, int y) { int z; }\";\n        assertCompilationFails(s);\n    }\n\n    @Test\n    void record_mustAllowStaticFields() {\n        String s = \"record Point(int x, int y) { static int z; }\";\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n\n    @Test\n    void record_mustNotAllowMismatchedComponentAccessorReturnType() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public String x() {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \" }\";\n        assertCompilationFails(s);\n    }\n\n    @Test\n    void record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public String x(int a) {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod2() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public int x(int a) {\\n\" +\n                \"        return 10;\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_allowComponentAccessorWithMatchingType() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return 10;\\n\" +\n                \"    }\\n\" +\n                \" }\";\n\n        CompilationUnit cu = parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    // https://bugs.openjdk.java.net/browse/JDK-8222777\n    @Test\n    void recordDeclarationFromTheJDK8222777() {\n        CompilationUnit cu = parseCompilationUnit(\"\" +\n                \"public record Range(int lo, int hi) {\\n\" +\n                \"\\n\" +\n                \"  public Range {\\n\" +\n                \"    if (lo > hi)  /* referring here to the implicit constructor parameters */\\n\" +\n                \"      throw new IllegalArgumentException(String.format(\\\"(%d,%d)\\\", lo, hi));\\n\" +\n                \"  }\\n\" +\n                \"}\"\n        );\n\n        RecordDeclaration record = cu.findFirst(RecordDeclaration.class).get();\n        assertThat(record.getNameAsString()).isEqualTo(\"Range\");\n        assertThat(record.getModifiers()).containsExactly(Modifier.publicModifier());\n        // test parameters\n        // get constructor\n        // test parameters (none)\n    }\n\n\n    private void assertCompilationFails(String s) {\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n    }\n\n    private void assertOneRecordDeclaration(CompilationUnit cu) {\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n}\n",
        "diffSourceCodeSet": [
            "private void assertCompilationFails(String s) {\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n    }"
        ],
        "invokedMethodSet": [],
        "sourceCodeAfterRefactoring": "@Test\n    void record_mustNotAllowMismatchedComponentAccessorReturnType() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public String x() {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \" }\";\n        assertCompilationFails(s);\n    }\nprivate void assertCompilationFails(String s) {\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = parseCompilationUnit(s);\n        });\n    }",
        "diffSourceCode": "-  235:     @Test\n-  236:     void record_mustNotAllowMismatchedComponentAccessorReturnType() {\n-  237:         String s = \"record Point(int x, int y) {\\n\" +\n-  238:                 \"    public String x() {\\n\" +\n-  239:                 \"        return \\\"10\\\";\\n\" +\n-  240:                 \"    }\\n\" +\n-  241:                 \" }\";\n-  242: \n-  243:         assertThrows(AssertionFailedError.class, () -> {\n-  244:             CompilationUnit cu = parseCompilationUnit(s);\n-  245:         });\n-  246: \n+  235:         assertOneRecordDeclaration(cu);\n+  236:     }\n+  237: \n+  238: \n+  239:     @Test\n+  240:     void record_mustNotAllowMismatchedComponentAccessorReturnType() {\n+  241:         String s = \"record Point(int x, int y) {\\n\" +\n+  242:                 \"    public String x() {\\n\" +\n+  243:                 \"        return \\\"10\\\";\\n\" +\n+  244:                 \"    }\\n\" +\n+  245:                 \" }\";\n+  246:         assertCompilationFails(s);\n   247:     }\n-  307:         // test parameters (none)\n-  308:     }\n-  309: }\n+  307:     private void assertCompilationFails(String s) {\n+  308:         assertThrows(AssertionFailedError.class, () -> {\n+  309:             CompilationUnit cu = parseCompilationUnit(s);\n+  310:         });\n+  311:     }\n",
        "uniqueId": "a73aba7b8cef7c52666d25169a3f6e495c65bcd2_235_247_307_311_239_247",
        "moveFileExist": true,
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 1.8,
        "testResult": true,
        "coverageInfo": {
            "testMethod": {
                "missed": 0,
                "covered": 1
            }
        }
    },
    {
        "type": "Extract And Move Method",
        "description": "Extract And Move Method\tpublic parse(code String, considerComments boolean) : CompilationUnit extracted from public whenTheClassIsParsedByTheJavaParser() : void in class com.github.javaparser.bdd.steps.DumpingSteps & moved to class com.github.javaparser.JavaParser",
        "diffLocations": [
            {
                "filePath": "javaparser-testing/src/test/java/com/github/javaparser/bdd/steps/DumpingSteps.java",
                "startLine": 60,
                "endLine": 63,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "javaparser-testing/src/test/java/com/github/javaparser/bdd/steps/DumpingSteps.java",
                "startLine": 60,
                "endLine": 63,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "javaparser-testing/src/test/java/com/github/javaparser/bdd/steps/DumpingSteps.java",
                "startLine": 178,
                "endLine": 189,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "@When(\"the {class|compilation unit} is parsed by the Java parser\")\n    public void whenTheClassIsParsedByTheJavaParser() throws ParseException {\n        resultNode = JavaParser.parse(new StringReader(sourceUnderTest), true);\n    }",
        "filePathBefore": "javaparser-testing/src/test/java/com/github/javaparser/bdd/steps/DumpingSteps.java",
        "isPureRefactoring": true,
        "commitId": "547da782d2ea7f1abc35e5c1e5852928962a11ef",
        "packageNameBefore": "com.github.javaparser.bdd.steps",
        "classNameBefore": "com.github.javaparser.bdd.steps.DumpingSteps",
        "methodNameBefore": "com.github.javaparser.bdd.steps.DumpingSteps#whenTheClassIsParsedByTheJavaParser",
        "invokedMethod": "methodSignature: com.github.javaparser.JavaParser#parse\n methodBody: public static CompilationUnit parse(final Reader reader, boolean considerComments)\n            throws ParseException {\ntryString comments=readerToString(reader);\nCompilationUnit cu=new InstanceJavaParser(comments).parse();\nif(considerComments){commentsInserter.insertComments(cu,comments);\n}return cu;\ncatch(IOException ioe)throw new ParseException(ioe.getMessage());\n}",
        "classSignatureBefore": "public class DumpingSteps ",
        "methodNameBeforeSet": [
            "com.github.javaparser.bdd.steps.DumpingSteps#whenTheClassIsParsedByTheJavaParser"
        ],
        "classNameBeforeSet": [
            "com.github.javaparser.bdd.steps.DumpingSteps"
        ],
        "classSignatureBeforeSet": [
            "public class DumpingSteps "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Changes are within the Extract Method refactoring mechanics",
                "description": "All replacements have been justified - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Copyright (C) 2007-2010 J\u00falio Vilmar Gesser.\n * Copyright (C) 2011, 2013-2016 The JavaParser Team.\n *\n * This file is part of JavaParser.\n * \n * JavaParser can be used either under the terms of\n * a) the GNU Lesser General Public License as published by\n *     the Free Software Foundation, either version 3 of the License, or\n *     (at your option) any later version.\n * b) the terms of the Apache License \n *\n * You should have received a copy of both licenses in LICENCE.LGPL and\n * LICENCE.APACHE. Please refer to those files for details.\n *\n * JavaParser is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n */\n\npackage com.github.javaparser.bdd.steps;\n\nimport static com.github.javaparser.utils.Utils.readerToString;\nimport static org.junit.Assert.assertEquals;\n\nimport java.io.File;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.StringReader;\nimport java.net.URISyntaxException;\nimport java.net.URL;\n\nimport org.jbehave.core.annotations.Given;\nimport org.jbehave.core.annotations.Then;\nimport org.jbehave.core.annotations.When;\n\nimport com.github.javaparser.JavaParser;\nimport com.github.javaparser.ParseException;\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.Node;\nimport com.github.javaparser.ast.visitor.ModifierVisitorAdapter;\n\npublic class DumpingSteps {\n\n    private Node resultNode;\n    private String sourceUnderTest;\n\n    @Given(\"the {class|compilation unit|expression|block|statement|import|annotation|body|class body|interface body}:$classSrc\")\n    public void givenTheClass(String classSrc) {\n        this.sourceUnderTest = classSrc.trim();\n    }\n\n    @Given(\"the {class|compilation unit|expression|block|statement|import|annotation|body|class body|interface body} in the file \\\"$classFile\\\"\")\n    public void givenTheClassInTheFile(String classFile) throws URISyntaxException, IOException, ParseException {\n        URL url = getClass().getResource(\"../samples/\" + classFile);\n        sourceUnderTest = readerToString(new FileReader(new File(url.toURI()))).trim();\n    }\n\n    @When(\"the {class|compilation unit} is parsed by the Java parser\")\n    public void whenTheClassIsParsedByTheJavaParser() throws ParseException {\n        resultNode = JavaParser.parse(new StringReader(sourceUnderTest), true);\n    }\n\n    @When(\"the expression is parsed by the Java parser\")\n    public void whenTheExpressionIsParsedByTheJavaParser() throws ParseException {\n        resultNode = JavaParser.parseExpression(sourceUnderTest);\n    }\n\n    @When(\"the block is parsed by the Java parser\")\n    public void whenTheBlockIsParsedByTheJavaParser() throws ParseException {\n        resultNode = JavaParser.parseBlock(sourceUnderTest);\n    }\n\n    @When(\"the statement is parsed by the Java parser\")\n    public void whenTheStatementIsParsedByTheJavaParser() throws ParseException {\n        resultNode = JavaParser.parseStatement(sourceUnderTest);\n    }\n\n    @When(\"the import is parsed by the Java parser\")\n    public void whenTheImportIsParsedByTheJavaParser() throws ParseException {\n        resultNode = JavaParser.parseImport(sourceUnderTest);\n    }\n\n    @When(\"the annotation is parsed by the Java parser\")\n    public void whenTheAnnotationIsParsedByTheJavaParser() throws ParseException {\n        resultNode = JavaParser.parseAnnotation(sourceUnderTest);\n    }\n\n    @When(\"the body declaration is parsed by the Java parser\")\n    public void whenTheBodyDeclarationIsParsedByTheJavaParser() throws ParseException {\n        resultNode = JavaParser.parseBodyDeclaration(sourceUnderTest);\n    }\n\n    @When(\"the class body declaration is parsed by the Java parser\")\n    public void whenTheClassBodyDeclarationIsParsedByTheJavaParser() throws ParseException {\n        resultNode = JavaParser.parseClassBodyDeclaration(sourceUnderTest);\n    }\n\n    @When(\"the interface body declaration is parsed by the Java parser\")\n    public void whenTheInterfaceBodyDeclarationIsParsedByTheJavaParser() throws ParseException {\n        resultNode = JavaParser.parseInterfaceBodyDeclaration(sourceUnderTest);\n    }\n\n    @When(\"the class is visited by an empty ModifierVisitorAdapter\")\n    public void whenTheClassIsVisitedByAnEmptyModifierVisitorAdapter() throws ParseException {\n        (new ModifierVisitorAdapter() {\n        }).visit((CompilationUnit) resultNode, null);\n    }\n\n    @Then(\"it is dumped to:$dumpSrc\")\n    public void isDumpedTo(String dumpSrc) {\n        assertEquals(dumpSrc.trim(), resultNode.toString().trim());\n    }\n\n}\n",
        "filePathAfter": "javaparser-testing/src/test/java/com/github/javaparser/bdd/steps/DumpingSteps.java",
        "sourceCodeAfterForWhole": "/*\n * Copyright (C) 2007-2010 J\u00falio Vilmar Gesser.\n * Copyright (C) 2011, 2013-2016 The JavaParser Team.\n *\n * This file is part of JavaParser.\n * \n * JavaParser can be used either under the terms of\n * a) the GNU Lesser General Public License as published by\n *     the Free Software Foundation, either version 3 of the License, or\n *     (at your option) any later version.\n * b) the terms of the Apache License \n *\n * You should have received a copy of both licenses in LICENCE.LGPL and\n * LICENCE.APACHE. Please refer to those files for details.\n *\n * JavaParser is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n */\n\npackage com.github.javaparser.bdd.steps;\n\nimport static com.github.javaparser.utils.Utils.readerToString;\nimport static org.junit.Assert.assertEquals;\n\nimport java.io.File;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.StringReader;\nimport java.net.URISyntaxException;\nimport java.net.URL;\n\nimport org.jbehave.core.annotations.Given;\nimport org.jbehave.core.annotations.Then;\nimport org.jbehave.core.annotations.When;\n\nimport com.github.javaparser.JavaParser;\nimport com.github.javaparser.ParseException;\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.Node;\nimport com.github.javaparser.ast.visitor.ModifierVisitorAdapter;\n\npublic class DumpingSteps {\n\n    private Node resultNode;\n    private String sourceUnderTest;\n\n    @Given(\"the {class|compilation unit|expression|block|statement|import|annotation|body|class body|interface body}:$classSrc\")\n    public void givenTheClass(String classSrc) {\n        this.sourceUnderTest = classSrc.trim();\n    }\n\n    @Given(\"the {class|compilation unit|expression|block|statement|import|annotation|body|class body|interface body} in the file \\\"$classFile\\\"\")\n    public void givenTheClassInTheFile(String classFile) throws URISyntaxException, IOException, ParseException {\n        URL url = getClass().getResource(\"../samples/\" + classFile);\n        sourceUnderTest = readerToString(new FileReader(new File(url.toURI()))).trim();\n    }\n\n    @When(\"the {class|compilation unit} is parsed by the Java parser\")\n    public void whenTheClassIsParsedByTheJavaParser() throws ParseException {\n        resultNode = JavaParser.parse(sourceUnderTest, true);\n    }\n\n    @When(\"the expression is parsed by the Java parser\")\n    public void whenTheExpressionIsParsedByTheJavaParser() throws ParseException {\n        resultNode = JavaParser.parseExpression(sourceUnderTest);\n    }\n\n    @When(\"the block is parsed by the Java parser\")\n    public void whenTheBlockIsParsedByTheJavaParser() throws ParseException {\n        resultNode = JavaParser.parseBlock(sourceUnderTest);\n    }\n\n    @When(\"the statement is parsed by the Java parser\")\n    public void whenTheStatementIsParsedByTheJavaParser() throws ParseException {\n        resultNode = JavaParser.parseStatement(sourceUnderTest);\n    }\n\n    @When(\"the import is parsed by the Java parser\")\n    public void whenTheImportIsParsedByTheJavaParser() throws ParseException {\n        resultNode = JavaParser.parseImport(sourceUnderTest);\n    }\n\n    @When(\"the annotation is parsed by the Java parser\")\n    public void whenTheAnnotationIsParsedByTheJavaParser() throws ParseException {\n        resultNode = JavaParser.parseAnnotation(sourceUnderTest);\n    }\n\n    @When(\"the body declaration is parsed by the Java parser\")\n    public void whenTheBodyDeclarationIsParsedByTheJavaParser() throws ParseException {\n        resultNode = JavaParser.parseBodyDeclaration(sourceUnderTest);\n    }\n\n    @When(\"the class body declaration is parsed by the Java parser\")\n    public void whenTheClassBodyDeclarationIsParsedByTheJavaParser() throws ParseException {\n        resultNode = JavaParser.parseClassBodyDeclaration(sourceUnderTest);\n    }\n\n    @When(\"the interface body declaration is parsed by the Java parser\")\n    public void whenTheInterfaceBodyDeclarationIsParsedByTheJavaParser() throws ParseException {\n        resultNode = JavaParser.parseInterfaceBodyDeclaration(sourceUnderTest);\n    }\n\n    @When(\"the class is visited by an empty ModifierVisitorAdapter\")\n    public void whenTheClassIsVisitedByAnEmptyModifierVisitorAdapter() throws ParseException {\n        (new ModifierVisitorAdapter() {\n        }).visit((CompilationUnit) resultNode, null);\n    }\n\n    @Then(\"it is dumped to:$dumpSrc\")\n    public void isDumpedTo(String dumpSrc) {\n        assertEquals(dumpSrc.trim(), resultNode.toString().trim());\n    }\n\n}\n",
        "diffSourceCodeSet": [
            ""
        ],
        "invokedMethodSet": [
            "methodSignature: com.github.javaparser.JavaParser#parse\n methodBody: public static CompilationUnit parse(final Reader reader, boolean considerComments)\n            throws ParseException {\ntryString comments=readerToString(reader);\nCompilationUnit cu=new InstanceJavaParser(comments).parse();\nif(considerComments){commentsInserter.insertComments(cu,comments);\n}return cu;\ncatch(IOException ioe)throw new ParseException(ioe.getMessage());\n}"
        ],
        "sourceCodeAfterRefactoring": "@When(\"the {class|compilation unit} is parsed by the Java parser\")\n    public void whenTheClassIsParsedByTheJavaParser() throws ParseException {\n        resultNode = JavaParser.parse(sourceUnderTest, true);\n    }\n",
        "diffSourceCode": "    60:     @When(\"the {class|compilation unit} is parsed by the Java parser\")\n    61:     public void whenTheClassIsParsedByTheJavaParser() throws ParseException {\n-   62:         resultNode = JavaParser.parse(new StringReader(sourceUnderTest), true);\n+   62:         resultNode = JavaParser.parse(sourceUnderTest, true);\n    63:     }\n",
        "uniqueId": "547da782d2ea7f1abc35e5c1e5852928962a11ef_60_63_178_189_60_63",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "testMethod": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 1.8
    },
    {
        "type": "Move Method",
        "description": "Move Method\tpublic solveMethodAsUsage(name String, parameterTypes List<TypeUsage>, typeSolver TypeSolver, invokationContext Context) : Optional<MethodUsage> from class me.tomassetti.symbolsolver.model.typesystem.TypeUsageOfTypeParameter to private solveMethodAsUsage(tp TypeUsageOfTypeParameter, name String, parameterTypes List<TypeUsage>, typeSolver TypeSolver, invokationContext Context) : Optional<MethodUsage> from class me.tomassetti.symbolsolver.resolution.javaparser.contexts.MethodCallExprContext",
        "diffLocations": [
            {
                "filePath": "src/main/java/me/tomassetti/symbolsolver/model/typesystem/TypeUsageOfTypeParameter.java",
                "startLine": 61,
                "endLine": 70,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "src/main/java/me/tomassetti/symbolsolver/resolution/javaparser/contexts/MethodCallExprContext.java",
                "startLine": 56,
                "endLine": 64,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "@Override\n    public Optional<MethodUsage> solveMethodAsUsage(String name, List<TypeUsage> parameterTypes, TypeSolver typeSolver, Context invokationContext) {\n        for (TypeParameter.Bound bound : typeParameter.getBounds(typeSolver)) {\n            Optional<MethodUsage> methodUsage = bound.getType().solveMethodAsUsage(name, parameterTypes, typeSolver, invokationContext);\n            if (methodUsage.isPresent()) {\n                return methodUsage;\n            }\n        }\n        return Optional.empty();\n    }",
        "filePathBefore": "src/main/java/me/tomassetti/symbolsolver/model/typesystem/TypeUsageOfTypeParameter.java",
        "isPureRefactoring": true,
        "commitId": "0e81f51c40996b42cb262dc2397126cee8f60965",
        "packageNameBefore": "me.tomassetti.symbolsolver.model.typesystem",
        "classNameBefore": "me.tomassetti.symbolsolver.model.typesystem.TypeUsageOfTypeParameter",
        "methodNameBefore": "me.tomassetti.symbolsolver.model.typesystem.TypeUsageOfTypeParameter#solveMethodAsUsage",
        "invokedMethod": "methodSignature: me.tomassetti.symbolsolver.model.declarations.TypeDeclaration#solveMethodAsUsage\n methodBody: default Optional<MethodUsage> solveMethodAsUsage(String name, List<TypeUsage> parameterTypes, TypeSolver typeSolver, Context invokationContext, List<TypeUsage> typeParameterValues) {\nreturn getContext().solveMethodAsUsage(name,parameterTypes,typeSolver);\n}\nmethodSignature: me.tomassetti.symbolsolver.resolution.reflection.ReflectionInterfaceDeclaration#solveMethodAsUsage\n methodBody: public Optional<MethodUsage> solveMethodAsUsage(String name, List<TypeUsage> parameterTypes, TypeSolver typeSolver, Context invokationContext, List<TypeUsage> typeParameterValues) {\nif(typeParameterValues.size() != getTypeParameters().size()){if(this.getTypeParameters().size() != 0){typeParameterValues=new ArrayList<>();\nfor(int i=0; i < getTypeParameters().size(); i++){typeParameterValues.add(new ReferenceTypeUsage(new ReflectionClassDeclaration(Object.class)));\n}}}List<MethodUsage> methods=new ArrayList<>();\nfor(Method method: clazz.getMethods()){if(method.getName().equals(name) && !method.isBridge() && !method.isSynthetic()){MethodDeclaration methodDeclaration=new ReflectionMethodDeclaration(method);\nMethodUsage methodUsage=new MethodUsage(methodDeclaration,typeSolver);\nint i=0;\nfor(TypeParameter tp: getTypeParameters()){methodUsage=methodUsage.replaceNameParam(tp.getName(),typeParameterValues.get(i));\ni++;\n}methods.add(methodUsage);\n}}return MethodResolutionLogic.findMostApplicableUsage(methods,name,parameterTypes,typeSolver);\n}\nmethodSignature: me.tomassetti.symbolsolver.JavaParserFacade#solveMethodAsUsage\n methodBody: public MethodUsage solveMethodAsUsage(MethodCallExpr call) {\nList<TypeUsage> params=new ArrayList<>();\nif(call.getArgs() != null){for(Expression param: call.getArgs()){params.add(getType(param,false));\n}}Context context=JavaParserFactory.getContext(call);\nOptional<MethodUsage> methodUsage=context.solveMethodAsUsage(call.getName(),params,typeSolver);\nif(!methodUsage.isPresent()){throw new RuntimeException(\"Method\" + \" '\" + call.getName() + \"' cannot be resolved in context \" + call + \" (line: \" + call.getBeginLine() + \") \" + context);\n}return methodUsage.get();\n}\nmethodSignature: me.tomassetti.symbolsolver.model.typesystem.TypeUsage#solveMethodAsUsage\n methodBody: default Optional<MethodUsage> solveMethodAsUsage(String name, List<TypeUsage> parameterTypes, TypeSolver typeSolver, Context invokationContext) {\nthrow new UnsupportedOperationException(this.getClass().getCanonicalName());\n}\nmethodSignature: me.tomassetti.symbolsolver.resolution.reflection.ReflectionFieldDeclaration#getType\n methodBody: public TypeUsage getType(TypeSolver typeSolver) {\nreturn ReflectionFactory.typeUsageFor(field.getType());\n}\nmethodSignature: me.tomassetti.symbolsolver.resolution.javassist.JavassistFieldDeclaration#getType\n methodBody: public TypeUsage getType(TypeSolver typeSolver) {\ntryreturn JavassistFactory.typeUsageFor(ctField.getType());\ncatch(NotFoundException e)throw new RuntimeException(e);\n}\nmethodSignature: me.tomassetti.symbolsolver.JavaParserFacade#getType\n methodBody: public TypeUsage getType(Node node, boolean solveLambdas) {\nif(solveLambdas){if(!cacheWithLambadsSolved.containsKey(node)){TypeUsage res=getTypeConcrete(node,solveLambdas);\ncacheWithLambadsSolved.put(node,res);\nlogger.finer(\"getType on \" + node + \" -> \" + res);\n}return cacheWithLambadsSolved.get(node);\n}{if(!cacheWithoutLambadsSolved.containsKey(node)){TypeUsage res=getTypeConcrete(node,solveLambdas);\ncacheWithoutLambadsSolved.put(node,res);\nlogger.finer(\"getType on \" + node + \" (no solveLambdas) -> \" + res);\n}return cacheWithoutLambadsSolved.get(node);\n}}\nmethodSignature: me.tomassetti.symbolsolver.resolution.reflection.ReflectionParameterDeclaration#getType\n methodBody: public TypeUsage getType(TypeSolver typeSolver) {\nreturn ReflectionFactory.typeUsageFor(genericType);\n}\nmethodSignature: me.tomassetti.symbolsolver.model.typesystem.ReferenceTypeUsage#solveMethodAsUsage\n methodBody: public Optional<MethodUsage> solveMethodAsUsage(String name, List<TypeUsage> parameterTypes, TypeSolver typeSolver, Context invokationContext) {\nOptional<MethodUsage> ref=typeDeclaration.solveMethodAsUsage(name,parameterTypes,typeSolver,invokationContext,typeParameters);\nif(ref.isPresent()){MethodUsage methodUsage=ref.get();\nTypeUsage returnType=replaceTypeParams(methodUsage.returnType());\nif(returnType != methodUsage.returnType()){methodUsage=methodUsage.replaceReturnType(returnType);\n}for(int i=0; i < methodUsage.getParamTypes().size(); i++){TypeUsage replaced=replaceTypeParams(methodUsage.getParamTypes().get(i));\nmethodUsage=methodUsage.replaceParamType(i,replaced);\n}return Optional.of(methodUsage);\n}{return ref;\n}}\nmethodSignature: me.tomassetti.symbolsolver.resolution.javaparser.declarations.JavaParserEnumConstantDeclaration#getType\n methodBody: public TypeUsage getType(TypeSolver typeSolver) {\nreturn new ReferenceTypeUsage(new JavaParserEnumDeclaration((EnumDeclaration)wrappedNode.getParentNode()));\n}\nmethodSignature: me.tomassetti.symbolsolver.resolution.javaparser.contexts.CompilationUnitContext#getType\n methodBody: private String getType(String qName){\nint index=qName.lastIndexOf('.');\nif(index == -1){throw new UnsupportedOperationException();\n}String typeName=qName.substring(0,index);\nreturn typeName;\n}\nmethodSignature: me.tomassetti.symbolsolver.resolution.reflection.ReflectionClassDeclaration#solveMethodAsUsage\n methodBody: public Optional<MethodUsage> solveMethodAsUsage(String name, List<TypeUsage> parameterTypes, TypeSolver typeSolver, Context invokationContext, List<TypeUsage> typeParameterValues) {\nList<MethodUsage> methods=new ArrayList<>();\nfor(Method method: Arrays.stream(clazz.getDeclaredMethods()).filter((m) -> m.getName().equals(name)).sorted(new MethodComparator()).collect(Collectors.toList())){if(method.isBridge() || method.isSynthetic())continue;\nMethodDeclaration methodDeclaration=new ReflectionMethodDeclaration(method);\nMethodUsage methodUsage=new MethodUsage(methodDeclaration,typeSolver);\nfor(int i=0; i < getTypeParameters().size(); i++){String nameToReplace=getTypeParameters().get(i).getName();\nTypeUsage newValue=typeParameterValues.get(i);\nmethodUsage=methodUsage.replaceNameParam(nameToReplace,newValue);\n}methods.add(methodUsage);\n}ClassDeclaration superClass=getSuperClass(typeSolver);\nif(superClass != null){Optional<MethodUsage> ref=superClass.solveMethodAsUsage(name,parameterTypes,typeSolver,invokationContext,typeParameterValues);\nif(ref.isPresent()){methods.add(ref.get());\n}}for(InterfaceDeclaration interfaceDeclaration: getInterfaces(typeSolver)){Optional<MethodUsage> ref=interfaceDeclaration.solveMethodAsUsage(name,parameterTypes,typeSolver,invokationContext,typeParameterValues);\nif(ref.isPresent()){methods.add(ref.get());\n}}Optional<MethodUsage> ref=MethodResolutionLogic.findMostApplicableUsage(methods,name,parameterTypes,typeSolver);\nreturn ref;\n}\nmethodSignature: me.tomassetti.symbolsolver.resolution.reflection.ReflectionTypeParameter#getBounds\n methodBody: public List<Bound> getBounds(TypeSolver typeSolver) {\nreturn Arrays.stream(typeVariable.getBounds()).map((refB) -> Bound.extendsBound(ReflectionFactory.typeUsageFor(refB))).collect(Collectors.toList());\n}\nmethodSignature: me.tomassetti.symbolsolver.resolution.javaparser.declarations.JavaParserFieldDeclaration#getType\n methodBody: public TypeUsage getType(TypeSolver typeSolver) {\nif(enumConstantDeclaration != null){com.github.javaparser.ast.body.EnumDeclaration enumDeclaration=(com.github.javaparser.ast.body.EnumDeclaration)enumConstantDeclaration.getParentNode();\nreturn new ReferenceTypeUsage(new JavaParserEnumDeclaration(enumDeclaration));\n}{return JavaParserFacade.get(typeSolver).convert(fieldDeclaration.getType(),fieldDeclaration);\n}}\nmethodSignature: me.tomassetti.symbolsolver.resolution.javaparser.contexts.MethodCallExprContext#solveMethodAsUsage\n methodBody: public Optional<MethodUsage> solveMethodAsUsage(String name, List<TypeUsage> parameterTypes, TypeSolver typeSolver) {\nif(wrappedNode.getScope() != null){tryTypeUsage typeOfScope=JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\nreturn typeOfScope.solveMethodAsUsage(name,parameterTypes,typeSolver,this);\ncatch(UnsolvedSymbolException e)if(wrappedNode.getScope() instanceof NameExpr){String className=((NameExpr)wrappedNode.getScope()).getName();\nSymbolReference<TypeDeclaration> ref=solveType(className,typeSolver);\nif(ref.isSolved()){SymbolReference<MethodDeclaration> m=ref.getCorrespondingDeclaration().solveMethod(name,parameterTypes,typeSolver);\nif(m.isSolved()){return Optional.of(new MethodUsage(m.getCorrespondingDeclaration(),typeSolver));\n}{throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(),\"Method '\" + name + \"' with parameterTypes \" + parameterTypes);\n}}{throw e;\n}}{throw e;\n}}{if(wrappedNode.getParentNode() instanceof MethodCallExpr){MethodCallExpr parent=(MethodCallExpr)wrappedNode.getParentNode();\nif(parent.getScope() == wrappedNode){return getParent().getParent().solveMethodAsUsage(name,parameterTypes,typeSolver);\n}}Context parentContext=getParent();\nreturn parentContext.solveMethodAsUsage(name,parameterTypes,typeSolver);\n}}\nmethodSignature: me.tomassetti.symbolsolver.resolution.javassist.JavassistClassDeclaration#solveMethodAsUsage\n methodBody: public Optional<MethodUsage> solveMethodAsUsage(String name, List<TypeUsage> parameterTypes, TypeSolver typeSolver,\n                                                    Context invokationContext, List<TypeUsage> typeParameterValues) {\nfor(CtMethod method: ctClass.getDeclaredMethods()){if(method.getName().equals(name)){MethodUsage methodUsage=new MethodUsage(new JavassistMethodDeclaration(method,typeSolver),typeSolver);\ntryif(method.getGenericSignature() != null){SignatureAttribute.MethodSignature classSignature=SignatureAttribute.toMethodSignature(method.getGenericSignature());\nList<TypeUsage> parametersOfReturnType=parseTypeParameters(classSignature.getReturnType().toString(),typeSolver,new JavassistMethodContext(method),invokationContext);\nTypeUsage newReturnType=methodUsage.returnType();\nfor(int i=0; i < parametersOfReturnType.size(); i++){newReturnType=newReturnType.asReferenceTypeUsage().replaceParam(i,parametersOfReturnType.get(i));\n}methodUsage=methodUsage.replaceReturnType(newReturnType);\n}return Optional.of(methodUsage);\ncatch(BadBytecode e)throw new RuntimeException(e);\n}}tryCtClass superClass=ctClass.getSuperclass();\nif(superClass != null){Optional<MethodUsage> ref=new JavassistClassDeclaration(superClass).solveMethodAsUsage(name,parameterTypes,typeSolver,invokationContext,null);\nif(ref.isPresent()){return ref;\n}}catch(NotFoundException e)throw new RuntimeException(e);\ntryfor(CtClass interfaze: ctClass.getInterfaces()){Optional<MethodUsage> ref=new JavassistClassDeclaration(interfaze).solveMethodAsUsage(name,parameterTypes,typeSolver,invokationContext,null);\nif(ref.isPresent()){return ref;\n}}catch(NotFoundException e)throw new RuntimeException(e);\nreturn Optional.empty();\n}\nmethodSignature: me.tomassetti.symbolsolver.resolution.javaparser.declarations.JavaParserEnumDeclaration#solveMethodAsUsage\n methodBody: public Optional<MethodUsage> solveMethodAsUsage(String name, List<TypeUsage> parameterTypes, TypeSolver typeSolver, Context invokationContext, List<TypeUsage> typeParameterValues) {\nif(name.equals(\"values\") && parameterTypes.size() == 0){return Optional.of(new ValuesMethod().getUsage(null));\n}return getContext().solveMethodAsUsage(name,parameterTypes,typeSolver);\n}\nmethodSignature: me.tomassetti.symbolsolver.resolution.javaparser.declarations.JavaParserTypeParameter#getBounds\n methodBody: public List<Bound> getBounds(TypeSolver typeSolver) {\nif(wrappedNode.getTypeBound() == null){return Collections.emptyList();\n}return wrappedNode.getTypeBound().stream().map((astB) -> toBound(astB,typeSolver)).collect(Collectors.toList());\n}\nmethodSignature: me.tomassetti.symbolsolver.model.typesystem.TypeUsageOfTypeParameter#solveMethodAsUsage\n methodBody: public Optional<MethodUsage> solveMethodAsUsage(String name, List<TypeUsage> parameterTypes, TypeSolver typeSolver, Context invokationContext) {\nfor(TypeParameter.Bound bound: typeParameter.getBounds(typeSolver)){Optional<MethodUsage> methodUsage=bound.getType().solveMethodAsUsage(name,parameterTypes,typeSolver,invokationContext);\nif(methodUsage.isPresent()){return methodUsage;\n}}return Optional.empty();\n}\nmethodSignature: me.tomassetti.symbolsolver.resolution.javaparser.declarations.JavaParserSymbolDeclaration#getType\n methodBody: public TypeUsage getType(TypeSolver typeSolver) {\nif(wrappedNode instanceof Parameter){Parameter parameter=(Parameter)wrappedNode;\nif(wrappedNode.getParentNode() instanceof LambdaExpr){int pos=getParamPos(parameter);\nTypeUsage lambdaType=JavaParserFacade.get(typeSolver).getType(wrappedNode.getParentNode());\nthrow new UnsupportedOperationException(wrappedNode.getClass().getCanonicalName());\n}{if(parameter.getType() instanceof PrimitiveType){return PrimitiveTypeUsage.byName(((PrimitiveType)parameter.getType()).getType().name());\n}{return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(),wrappedNode);\n}}}if(wrappedNode instanceof VariableDeclarator){VariableDeclarator variableDeclarator=(VariableDeclarator)wrappedNode;\nif(wrappedNode.getParentNode() instanceof VariableDeclarationExpr){VariableDeclarationExpr variableDeclarationExpr=(VariableDeclarationExpr)variableDeclarator.getParentNode();\nreturn JavaParserFacade.get(typeSolver).convert(variableDeclarationExpr.getType(),JavaParserFactory.getContext(wrappedNode));\n}if(wrappedNode.getParentNode() instanceof FieldDeclaration){FieldDeclaration fieldDeclaration=(FieldDeclaration)variableDeclarator.getParentNode();\nreturn JavaParserFacade.get(typeSolver).convert(fieldDeclaration.getType(),JavaParserFactory.getContext(wrappedNode));\n}{throw new UnsupportedOperationException(wrappedNode.getParentNode().getClass().getCanonicalName());\n}}{throw new UnsupportedOperationException(wrappedNode.getClass().getCanonicalName());\n}}\nmethodSignature: me.tomassetti.symbolsolver.resolution.javassist.JavassistTypeParameter#getBounds\n methodBody: public List<Bound> getBounds(TypeSolver typeSolver) {\nList<Bound> bounds=new ArrayList<>();\nif(wrapped.getClassBound() != null){throw new UnsupportedOperationException(wrapped.getClassBound().toString());\n}for(SignatureAttribute.ObjectType ot: wrapped.getInterfaceBound()){throw new UnsupportedOperationException(ot.toString());\n}return bounds;\n}\nmethodSignature: me.tomassetti.symbolsolver.resolution.javassist.JavassistParameterDeclaration#getType\n methodBody: public TypeUsage getType(TypeSolver typeSolver) {\nreturn JavassistFactory.typeUsageFor(type);\n}",
        "classSignatureBefore": "public class TypeUsageOfTypeParameter implements TypeUsage ",
        "methodNameBeforeSet": [
            "me.tomassetti.symbolsolver.model.typesystem.TypeUsageOfTypeParameter#solveMethodAsUsage"
        ],
        "classNameBeforeSet": [
            "me.tomassetti.symbolsolver.model.typesystem.TypeUsageOfTypeParameter"
        ],
        "classSignatureBeforeSet": [
            "public class TypeUsageOfTypeParameter implements TypeUsage "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Overlapped refactoring - can be identical by undoing the overlapped refactoring\n- Add Parameter-",
                "description": "Parametrization or Add Parameter on top of the moved method - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "package me.tomassetti.symbolsolver.model.typesystem;\n\nimport me.tomassetti.symbolsolver.resolution.Context;\nimport me.tomassetti.symbolsolver.resolution.TypeParameter;\nimport me.tomassetti.symbolsolver.resolution.TypeSolver;\n\nimport java.util.List;\nimport java.util.Optional;\n\npublic class TypeUsageOfTypeParameter implements TypeUsage {\n\n    private TypeParameter typeParameter;\n\n    @Override\n    public String toString() {\n        return \"TypeUsageOfTypeParameter{\" +\n                \"typeParameter=\" + typeParameter +\n                '}';\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n\n        TypeUsageOfTypeParameter that = (TypeUsageOfTypeParameter) o;\n\n        if (!typeParameter.equals(that.typeParameter)) return false;\n\n        return true;\n    }\n\n    @Override\n    public int hashCode() {\n        return typeParameter.hashCode();\n    }\n\n    public TypeUsageOfTypeParameter(TypeParameter typeParameter) {\n        this.typeParameter = typeParameter;\n    }\n\n    @Override\n    public boolean isArray() {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public boolean isPrimitive() {\n        return false;\n    }\n\n    @Override\n    public TypeUsage replaceParam(String name, TypeUsage replaced) {\n        if (name.equals(typeParameter.getName())) {\n            return replaced;\n        } else {\n            return this;\n        }\n    }\n\n    @Override\n    public Optional<MethodUsage> solveMethodAsUsage(String name, List<TypeUsage> parameterTypes, TypeSolver typeSolver, Context invokationContext) {\n        for (TypeParameter.Bound bound : typeParameter.getBounds(typeSolver)) {\n            Optional<MethodUsage> methodUsage = bound.getType().solveMethodAsUsage(name, parameterTypes, typeSolver, invokationContext);\n            if (methodUsage.isPresent()) {\n                return methodUsage;\n            }\n        }\n        return Optional.empty();\n    }\n\n    @Override\n    public boolean isReferenceType() {\n        return false;\n    }\n\n    @Override\n    public String describe() {\n        return typeParameter.getName();\n    }\n\n    @Override\n    public TypeParameter asTypeParameter() {\n        return typeParameter;\n    }\n\n    @Override\n    public boolean isTypeVariable() {\n        return true;\n    }\n\n    @Override\n    public boolean isAssignableBy(TypeUsage other, TypeSolver typeSolver) {\n        if (other.isTypeVariable()) {\n            return describe().equals(other.describe());\n        } else {\n            return false;\n        }\n    }\n\n}\n",
        "filePathAfter": "src/main/java/me/tomassetti/symbolsolver/resolution/javaparser/contexts/MethodCallExprContext.java",
        "sourceCodeAfterForWhole": "package me.tomassetti.symbolsolver.resolution.javaparser.contexts;\n\nimport com.github.javaparser.ast.expr.MethodCallExpr;\nimport com.github.javaparser.ast.expr.NameExpr;\nimport me.tomassetti.symbolsolver.JavaParserFacade;\nimport me.tomassetti.symbolsolver.model.typesystem.ReferenceTypeUsage;\nimport me.tomassetti.symbolsolver.model.typesystem.TypeUsageOfTypeParameter;\nimport me.tomassetti.symbolsolver.resolution.*;\nimport me.tomassetti.symbolsolver.model.declarations.MethodDeclaration;\nimport me.tomassetti.symbolsolver.model.declarations.TypeDeclaration;\nimport me.tomassetti.symbolsolver.model.declarations.ValueDeclaration;\n\nimport me.tomassetti.symbolsolver.resolution.javaparser.UnsolvedSymbolException;\nimport me.tomassetti.symbolsolver.model.typesystem.MethodUsage;\nimport me.tomassetti.symbolsolver.model.typesystem.TypeUsage;\n\nimport java.util.List;\nimport java.util.Optional;\n\n/**\n * Created by federico on 31/07/15.\n */\npublic class MethodCallExprContext extends AbstractJavaParserContext<MethodCallExpr> {\n\n    public MethodCallExprContext(MethodCallExpr wrappedNode, TypeSolver typeSolver) {\n        super(wrappedNode, typeSolver);\n    }\n\n    @Override\n    public Optional<TypeUsage> solveGenericType(String name, TypeSolver typeSolver) {\n        if (wrappedNode.getTypeArgs() != null) {\n            throw new UnsupportedOperationException(name);\n        }\n        TypeUsage typeOfScope = JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n        return typeOfScope.asReferenceTypeUsage().solveGenericType(name);\n    }\n\n    private Optional<MethodUsage> solveMethodAsUsage(ReferenceTypeUsage refType, String name, List<TypeUsage> parameterTypes, TypeSolver typeSolver, Context invokationContext) {\n        Optional<MethodUsage> ref = refType.getTypeDeclaration().solveMethodAsUsage(name, parameterTypes, typeSolver, invokationContext, refType.parameters());\n        if (ref.isPresent()) {\n            MethodUsage methodUsage = ref.get();\n            TypeUsage returnType = refType.replaceTypeParams(methodUsage.returnType());\n            if (returnType != methodUsage.returnType()){\n                methodUsage = methodUsage.replaceReturnType(returnType);\n            }\n            for (int i=0;i<methodUsage.getParamTypes().size();i++){\n                TypeUsage replaced = refType.replaceTypeParams(methodUsage.getParamTypes().get(i));\n                methodUsage = methodUsage.replaceParamType(i, replaced);\n            }\n            return Optional.of(methodUsage);\n        } else {\n            return ref;\n        }\n    }\n\n    private Optional<MethodUsage> solveMethodAsUsage(TypeUsageOfTypeParameter tp, String name, List<TypeUsage> parameterTypes, TypeSolver typeSolver, Context invokationContext) {\n        for (TypeParameter.Bound bound : tp.asTypeParameter().getBounds(typeSolver)) {\n            Optional<MethodUsage> methodUsage = solveMethodAsUsage(bound.getType(), name, parameterTypes, typeSolver, invokationContext);\n            if (methodUsage.isPresent()) {\n                return methodUsage;\n            }\n        }\n        return Optional.empty();\n    }\n\n    private Optional<MethodUsage> solveMethodAsUsage(TypeUsage typeUsage, String name, List<TypeUsage> parameterTypes, TypeSolver typeSolver, Context invokationContext) {\n        if (typeUsage instanceof ReferenceTypeUsage) {\n            return solveMethodAsUsage((ReferenceTypeUsage)typeUsage, name, parameterTypes, typeSolver, invokationContext);\n        } else if (typeUsage instanceof TypeUsageOfTypeParameter) {\n            return solveMethodAsUsage((TypeUsageOfTypeParameter)typeUsage, name, parameterTypes, typeSolver, invokationContext);\n        } else {\n            throw new UnsupportedOperationException();\n        }\n    }\n\n    @Override\n    public Optional<MethodUsage> solveMethodAsUsage(String name, List<TypeUsage> parameterTypes, TypeSolver typeSolver) {\n        // TODO consider call of static methods\n        if (wrappedNode.getScope() != null) {\n            try {\n                TypeUsage typeOfScope = JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n                return solveMethodAsUsage(typeOfScope, name, parameterTypes, typeSolver, this);\n            } catch (UnsolvedSymbolException e){\n                // ok, maybe it was instead a static access, so let's look for a type\n                if (wrappedNode.getScope() instanceof NameExpr){\n                    String className = ((NameExpr)wrappedNode.getScope()).getName();\n                    SymbolReference<TypeDeclaration> ref = solveType(className, typeSolver);\n                    if (ref.isSolved()) {\n                        SymbolReference<MethodDeclaration> m = ref.getCorrespondingDeclaration().solveMethod(name, parameterTypes, typeSolver);\n                        if (m.isSolved()) {\n                            return Optional.of(new MethodUsage(m.getCorrespondingDeclaration(), typeSolver));\n                        } else {\n                            throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method '\"+name+\"' with parameterTypes \"+parameterTypes);\n                        }\n                    } else {\n                        throw e;\n                    }\n                } else {\n                    throw e;\n                }\n            }\n        } else {\n            if (wrappedNode.getParentNode() instanceof MethodCallExpr) {\n                MethodCallExpr parent = (MethodCallExpr)wrappedNode.getParentNode();\n                if (parent.getScope() == wrappedNode) {\n                    return getParent().getParent().solveMethodAsUsage(name, parameterTypes, typeSolver);\n                }\n            }\n            Context parentContext = getParent();\n            return parentContext.solveMethodAsUsage(name, parameterTypes, typeSolver);\n        }\n    }\n\n    @Override\n    public SymbolReference<? extends ValueDeclaration> solveSymbol(String name, TypeSolver typeSolver) {\n        return getParent().solveSymbol(name, typeSolver);\n    }\n\n    @Override\n    public Optional<Value> solveSymbolAsValue(String name, TypeSolver typeSolver) {\n        Context parentContext = getParent();\n        return parentContext.solveSymbolAsValue(name, typeSolver);\n    }\n\n    @Override\n    public SymbolReference<MethodDeclaration> solveMethod(String name, List<TypeUsage> parameterTypes, TypeSolver typeSolver) {\n        if (wrappedNode.getScope() != null) {\n            TypeUsage typeOfScope = JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n            return typeOfScope.asReferenceTypeUsage().solveMethod(name, parameterTypes, typeSolver);\n        } else {\n            TypeUsage typeOfScope = JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n            return typeOfScope.asReferenceTypeUsage().solveMethod(name, parameterTypes, typeSolver);\n        }\n    }\n}\n",
        "diffSourceCodeSet": [],
        "invokedMethodSet": [
            "methodSignature: me.tomassetti.symbolsolver.model.declarations.TypeDeclaration#solveMethodAsUsage\n methodBody: default Optional<MethodUsage> solveMethodAsUsage(String name, List<TypeUsage> parameterTypes, TypeSolver typeSolver, Context invokationContext, List<TypeUsage> typeParameterValues) {\nreturn getContext().solveMethodAsUsage(name,parameterTypes,typeSolver);\n}",
            "methodSignature: me.tomassetti.symbolsolver.resolution.reflection.ReflectionInterfaceDeclaration#solveMethodAsUsage\n methodBody: public Optional<MethodUsage> solveMethodAsUsage(String name, List<TypeUsage> parameterTypes, TypeSolver typeSolver, Context invokationContext, List<TypeUsage> typeParameterValues) {\nif(typeParameterValues.size() != getTypeParameters().size()){if(this.getTypeParameters().size() != 0){typeParameterValues=new ArrayList<>();\nfor(int i=0; i < getTypeParameters().size(); i++){typeParameterValues.add(new ReferenceTypeUsage(new ReflectionClassDeclaration(Object.class)));\n}}}List<MethodUsage> methods=new ArrayList<>();\nfor(Method method: clazz.getMethods()){if(method.getName().equals(name) && !method.isBridge() && !method.isSynthetic()){MethodDeclaration methodDeclaration=new ReflectionMethodDeclaration(method);\nMethodUsage methodUsage=new MethodUsage(methodDeclaration,typeSolver);\nint i=0;\nfor(TypeParameter tp: getTypeParameters()){methodUsage=methodUsage.replaceNameParam(tp.getName(),typeParameterValues.get(i));\ni++;\n}methods.add(methodUsage);\n}}return MethodResolutionLogic.findMostApplicableUsage(methods,name,parameterTypes,typeSolver);\n}",
            "methodSignature: me.tomassetti.symbolsolver.JavaParserFacade#solveMethodAsUsage\n methodBody: public MethodUsage solveMethodAsUsage(MethodCallExpr call) {\nList<TypeUsage> params=new ArrayList<>();\nif(call.getArgs() != null){for(Expression param: call.getArgs()){params.add(getType(param,false));\n}}Context context=JavaParserFactory.getContext(call);\nOptional<MethodUsage> methodUsage=context.solveMethodAsUsage(call.getName(),params,typeSolver);\nif(!methodUsage.isPresent()){throw new RuntimeException(\"Method\" + \" '\" + call.getName() + \"' cannot be resolved in context \" + call + \" (line: \" + call.getBeginLine() + \") \" + context);\n}return methodUsage.get();\n}",
            "methodSignature: me.tomassetti.symbolsolver.model.typesystem.TypeUsage#solveMethodAsUsage\n methodBody: default Optional<MethodUsage> solveMethodAsUsage(String name, List<TypeUsage> parameterTypes, TypeSolver typeSolver, Context invokationContext) {\nthrow new UnsupportedOperationException(this.getClass().getCanonicalName());\n}",
            "methodSignature: me.tomassetti.symbolsolver.resolution.reflection.ReflectionFieldDeclaration#getType\n methodBody: public TypeUsage getType(TypeSolver typeSolver) {\nreturn ReflectionFactory.typeUsageFor(field.getType());\n}",
            "methodSignature: me.tomassetti.symbolsolver.resolution.javassist.JavassistFieldDeclaration#getType\n methodBody: public TypeUsage getType(TypeSolver typeSolver) {\ntryreturn JavassistFactory.typeUsageFor(ctField.getType());\ncatch(NotFoundException e)throw new RuntimeException(e);\n}",
            "methodSignature: me.tomassetti.symbolsolver.JavaParserFacade#getType\n methodBody: public TypeUsage getType(Node node, boolean solveLambdas) {\nif(solveLambdas){if(!cacheWithLambadsSolved.containsKey(node)){TypeUsage res=getTypeConcrete(node,solveLambdas);\ncacheWithLambadsSolved.put(node,res);\nlogger.finer(\"getType on \" + node + \" -> \" + res);\n}return cacheWithLambadsSolved.get(node);\n}{if(!cacheWithoutLambadsSolved.containsKey(node)){TypeUsage res=getTypeConcrete(node,solveLambdas);\ncacheWithoutLambadsSolved.put(node,res);\nlogger.finer(\"getType on \" + node + \" (no solveLambdas) -> \" + res);\n}return cacheWithoutLambadsSolved.get(node);\n}}",
            "methodSignature: me.tomassetti.symbolsolver.resolution.reflection.ReflectionParameterDeclaration#getType\n methodBody: public TypeUsage getType(TypeSolver typeSolver) {\nreturn ReflectionFactory.typeUsageFor(genericType);\n}",
            "methodSignature: me.tomassetti.symbolsolver.model.typesystem.ReferenceTypeUsage#solveMethodAsUsage\n methodBody: public Optional<MethodUsage> solveMethodAsUsage(String name, List<TypeUsage> parameterTypes, TypeSolver typeSolver, Context invokationContext) {\nOptional<MethodUsage> ref=typeDeclaration.solveMethodAsUsage(name,parameterTypes,typeSolver,invokationContext,typeParameters);\nif(ref.isPresent()){MethodUsage methodUsage=ref.get();\nTypeUsage returnType=replaceTypeParams(methodUsage.returnType());\nif(returnType != methodUsage.returnType()){methodUsage=methodUsage.replaceReturnType(returnType);\n}for(int i=0; i < methodUsage.getParamTypes().size(); i++){TypeUsage replaced=replaceTypeParams(methodUsage.getParamTypes().get(i));\nmethodUsage=methodUsage.replaceParamType(i,replaced);\n}return Optional.of(methodUsage);\n}{return ref;\n}}",
            "methodSignature: me.tomassetti.symbolsolver.resolution.javaparser.declarations.JavaParserEnumConstantDeclaration#getType\n methodBody: public TypeUsage getType(TypeSolver typeSolver) {\nreturn new ReferenceTypeUsage(new JavaParserEnumDeclaration((EnumDeclaration)wrappedNode.getParentNode()));\n}",
            "methodSignature: me.tomassetti.symbolsolver.resolution.javaparser.contexts.CompilationUnitContext#getType\n methodBody: private String getType(String qName){\nint index=qName.lastIndexOf('.');\nif(index == -1){throw new UnsupportedOperationException();\n}String typeName=qName.substring(0,index);\nreturn typeName;\n}",
            "methodSignature: me.tomassetti.symbolsolver.resolution.reflection.ReflectionClassDeclaration#solveMethodAsUsage\n methodBody: public Optional<MethodUsage> solveMethodAsUsage(String name, List<TypeUsage> parameterTypes, TypeSolver typeSolver, Context invokationContext, List<TypeUsage> typeParameterValues) {\nList<MethodUsage> methods=new ArrayList<>();\nfor(Method method: Arrays.stream(clazz.getDeclaredMethods()).filter((m) -> m.getName().equals(name)).sorted(new MethodComparator()).collect(Collectors.toList())){if(method.isBridge() || method.isSynthetic())continue;\nMethodDeclaration methodDeclaration=new ReflectionMethodDeclaration(method);\nMethodUsage methodUsage=new MethodUsage(methodDeclaration,typeSolver);\nfor(int i=0; i < getTypeParameters().size(); i++){String nameToReplace=getTypeParameters().get(i).getName();\nTypeUsage newValue=typeParameterValues.get(i);\nmethodUsage=methodUsage.replaceNameParam(nameToReplace,newValue);\n}methods.add(methodUsage);\n}ClassDeclaration superClass=getSuperClass(typeSolver);\nif(superClass != null){Optional<MethodUsage> ref=superClass.solveMethodAsUsage(name,parameterTypes,typeSolver,invokationContext,typeParameterValues);\nif(ref.isPresent()){methods.add(ref.get());\n}}for(InterfaceDeclaration interfaceDeclaration: getInterfaces(typeSolver)){Optional<MethodUsage> ref=interfaceDeclaration.solveMethodAsUsage(name,parameterTypes,typeSolver,invokationContext,typeParameterValues);\nif(ref.isPresent()){methods.add(ref.get());\n}}Optional<MethodUsage> ref=MethodResolutionLogic.findMostApplicableUsage(methods,name,parameterTypes,typeSolver);\nreturn ref;\n}",
            "methodSignature: me.tomassetti.symbolsolver.resolution.reflection.ReflectionTypeParameter#getBounds\n methodBody: public List<Bound> getBounds(TypeSolver typeSolver) {\nreturn Arrays.stream(typeVariable.getBounds()).map((refB) -> Bound.extendsBound(ReflectionFactory.typeUsageFor(refB))).collect(Collectors.toList());\n}",
            "methodSignature: me.tomassetti.symbolsolver.resolution.javaparser.declarations.JavaParserFieldDeclaration#getType\n methodBody: public TypeUsage getType(TypeSolver typeSolver) {\nif(enumConstantDeclaration != null){com.github.javaparser.ast.body.EnumDeclaration enumDeclaration=(com.github.javaparser.ast.body.EnumDeclaration)enumConstantDeclaration.getParentNode();\nreturn new ReferenceTypeUsage(new JavaParserEnumDeclaration(enumDeclaration));\n}{return JavaParserFacade.get(typeSolver).convert(fieldDeclaration.getType(),fieldDeclaration);\n}}",
            "methodSignature: me.tomassetti.symbolsolver.resolution.javaparser.contexts.MethodCallExprContext#solveMethodAsUsage\n methodBody: public Optional<MethodUsage> solveMethodAsUsage(String name, List<TypeUsage> parameterTypes, TypeSolver typeSolver) {\nif(wrappedNode.getScope() != null){tryTypeUsage typeOfScope=JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\nreturn typeOfScope.solveMethodAsUsage(name,parameterTypes,typeSolver,this);\ncatch(UnsolvedSymbolException e)if(wrappedNode.getScope() instanceof NameExpr){String className=((NameExpr)wrappedNode.getScope()).getName();\nSymbolReference<TypeDeclaration> ref=solveType(className,typeSolver);\nif(ref.isSolved()){SymbolReference<MethodDeclaration> m=ref.getCorrespondingDeclaration().solveMethod(name,parameterTypes,typeSolver);\nif(m.isSolved()){return Optional.of(new MethodUsage(m.getCorrespondingDeclaration(),typeSolver));\n}{throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(),\"Method '\" + name + \"' with parameterTypes \" + parameterTypes);\n}}{throw e;\n}}{throw e;\n}}{if(wrappedNode.getParentNode() instanceof MethodCallExpr){MethodCallExpr parent=(MethodCallExpr)wrappedNode.getParentNode();\nif(parent.getScope() == wrappedNode){return getParent().getParent().solveMethodAsUsage(name,parameterTypes,typeSolver);\n}}Context parentContext=getParent();\nreturn parentContext.solveMethodAsUsage(name,parameterTypes,typeSolver);\n}}",
            "methodSignature: me.tomassetti.symbolsolver.resolution.javassist.JavassistClassDeclaration#solveMethodAsUsage\n methodBody: public Optional<MethodUsage> solveMethodAsUsage(String name, List<TypeUsage> parameterTypes, TypeSolver typeSolver,\n                                                    Context invokationContext, List<TypeUsage> typeParameterValues) {\nfor(CtMethod method: ctClass.getDeclaredMethods()){if(method.getName().equals(name)){MethodUsage methodUsage=new MethodUsage(new JavassistMethodDeclaration(method,typeSolver),typeSolver);\ntryif(method.getGenericSignature() != null){SignatureAttribute.MethodSignature classSignature=SignatureAttribute.toMethodSignature(method.getGenericSignature());\nList<TypeUsage> parametersOfReturnType=parseTypeParameters(classSignature.getReturnType().toString(),typeSolver,new JavassistMethodContext(method),invokationContext);\nTypeUsage newReturnType=methodUsage.returnType();\nfor(int i=0; i < parametersOfReturnType.size(); i++){newReturnType=newReturnType.asReferenceTypeUsage().replaceParam(i,parametersOfReturnType.get(i));\n}methodUsage=methodUsage.replaceReturnType(newReturnType);\n}return Optional.of(methodUsage);\ncatch(BadBytecode e)throw new RuntimeException(e);\n}}tryCtClass superClass=ctClass.getSuperclass();\nif(superClass != null){Optional<MethodUsage> ref=new JavassistClassDeclaration(superClass).solveMethodAsUsage(name,parameterTypes,typeSolver,invokationContext,null);\nif(ref.isPresent()){return ref;\n}}catch(NotFoundException e)throw new RuntimeException(e);\ntryfor(CtClass interfaze: ctClass.getInterfaces()){Optional<MethodUsage> ref=new JavassistClassDeclaration(interfaze).solveMethodAsUsage(name,parameterTypes,typeSolver,invokationContext,null);\nif(ref.isPresent()){return ref;\n}}catch(NotFoundException e)throw new RuntimeException(e);\nreturn Optional.empty();\n}",
            "methodSignature: me.tomassetti.symbolsolver.resolution.javaparser.declarations.JavaParserEnumDeclaration#solveMethodAsUsage\n methodBody: public Optional<MethodUsage> solveMethodAsUsage(String name, List<TypeUsage> parameterTypes, TypeSolver typeSolver, Context invokationContext, List<TypeUsage> typeParameterValues) {\nif(name.equals(\"values\") && parameterTypes.size() == 0){return Optional.of(new ValuesMethod().getUsage(null));\n}return getContext().solveMethodAsUsage(name,parameterTypes,typeSolver);\n}",
            "methodSignature: me.tomassetti.symbolsolver.resolution.javaparser.declarations.JavaParserTypeParameter#getBounds\n methodBody: public List<Bound> getBounds(TypeSolver typeSolver) {\nif(wrappedNode.getTypeBound() == null){return Collections.emptyList();\n}return wrappedNode.getTypeBound().stream().map((astB) -> toBound(astB,typeSolver)).collect(Collectors.toList());\n}",
            "methodSignature: me.tomassetti.symbolsolver.model.typesystem.TypeUsageOfTypeParameter#solveMethodAsUsage\n methodBody: public Optional<MethodUsage> solveMethodAsUsage(String name, List<TypeUsage> parameterTypes, TypeSolver typeSolver, Context invokationContext) {\nfor(TypeParameter.Bound bound: typeParameter.getBounds(typeSolver)){Optional<MethodUsage> methodUsage=bound.getType().solveMethodAsUsage(name,parameterTypes,typeSolver,invokationContext);\nif(methodUsage.isPresent()){return methodUsage;\n}}return Optional.empty();\n}",
            "methodSignature: me.tomassetti.symbolsolver.resolution.javaparser.declarations.JavaParserSymbolDeclaration#getType\n methodBody: public TypeUsage getType(TypeSolver typeSolver) {\nif(wrappedNode instanceof Parameter){Parameter parameter=(Parameter)wrappedNode;\nif(wrappedNode.getParentNode() instanceof LambdaExpr){int pos=getParamPos(parameter);\nTypeUsage lambdaType=JavaParserFacade.get(typeSolver).getType(wrappedNode.getParentNode());\nthrow new UnsupportedOperationException(wrappedNode.getClass().getCanonicalName());\n}{if(parameter.getType() instanceof PrimitiveType){return PrimitiveTypeUsage.byName(((PrimitiveType)parameter.getType()).getType().name());\n}{return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType(),wrappedNode);\n}}}if(wrappedNode instanceof VariableDeclarator){VariableDeclarator variableDeclarator=(VariableDeclarator)wrappedNode;\nif(wrappedNode.getParentNode() instanceof VariableDeclarationExpr){VariableDeclarationExpr variableDeclarationExpr=(VariableDeclarationExpr)variableDeclarator.getParentNode();\nreturn JavaParserFacade.get(typeSolver).convert(variableDeclarationExpr.getType(),JavaParserFactory.getContext(wrappedNode));\n}if(wrappedNode.getParentNode() instanceof FieldDeclaration){FieldDeclaration fieldDeclaration=(FieldDeclaration)variableDeclarator.getParentNode();\nreturn JavaParserFacade.get(typeSolver).convert(fieldDeclaration.getType(),JavaParserFactory.getContext(wrappedNode));\n}{throw new UnsupportedOperationException(wrappedNode.getParentNode().getClass().getCanonicalName());\n}}{throw new UnsupportedOperationException(wrappedNode.getClass().getCanonicalName());\n}}",
            "methodSignature: me.tomassetti.symbolsolver.resolution.javassist.JavassistTypeParameter#getBounds\n methodBody: public List<Bound> getBounds(TypeSolver typeSolver) {\nList<Bound> bounds=new ArrayList<>();\nif(wrapped.getClassBound() != null){throw new UnsupportedOperationException(wrapped.getClassBound().toString());\n}for(SignatureAttribute.ObjectType ot: wrapped.getInterfaceBound()){throw new UnsupportedOperationException(ot.toString());\n}return bounds;\n}",
            "methodSignature: me.tomassetti.symbolsolver.resolution.javassist.JavassistParameterDeclaration#getType\n methodBody: public TypeUsage getType(TypeSolver typeSolver) {\nreturn JavassistFactory.typeUsageFor(type);\n}"
        ],
        "sourceCodeAfterRefactoring": "private Optional<MethodUsage> solveMethodAsUsage(TypeUsageOfTypeParameter tp, String name, List<TypeUsage> parameterTypes, TypeSolver typeSolver, Context invokationContext) {\n        for (TypeParameter.Bound bound : tp.asTypeParameter().getBounds(typeSolver)) {\n            Optional<MethodUsage> methodUsage = solveMethodAsUsage(bound.getType(), name, parameterTypes, typeSolver, invokationContext);\n            if (methodUsage.isPresent()) {\n                return methodUsage;\n            }\n        }\n        return Optional.empty();\n    }",
        "diffSourceCode": "-   56:         } else {\n-   57:             return this;\n-   58:         }\n-   59:     }\n-   60: \n-   61:     @Override\n-   62:     public Optional<MethodUsage> solveMethodAsUsage(String name, List<TypeUsage> parameterTypes, TypeSolver typeSolver, Context invokationContext) {\n-   63:         for (TypeParameter.Bound bound : typeParameter.getBounds(typeSolver)) {\n-   64:             Optional<MethodUsage> methodUsage = bound.getType().solveMethodAsUsage(name, parameterTypes, typeSolver, invokationContext);\n-   65:             if (methodUsage.isPresent()) {\n-   66:                 return methodUsage;\n-   67:             }\n-   68:         }\n-   69:         return Optional.empty();\n-   70:     }\n+   56:     private Optional<MethodUsage> solveMethodAsUsage(TypeUsageOfTypeParameter tp, String name, List<TypeUsage> parameterTypes, TypeSolver typeSolver, Context invokationContext) {\n+   57:         for (TypeParameter.Bound bound : tp.asTypeParameter().getBounds(typeSolver)) {\n+   58:             Optional<MethodUsage> methodUsage = solveMethodAsUsage(bound.getType(), name, parameterTypes, typeSolver, invokationContext);\n+   59:             if (methodUsage.isPresent()) {\n+   60:                 return methodUsage;\n+   61:             }\n+   62:         }\n+   63:         return Optional.empty();\n+   64:     }\n+   65: \n+   66:     private Optional<MethodUsage> solveMethodAsUsage(TypeUsage typeUsage, String name, List<TypeUsage> parameterTypes, TypeSolver typeSolver, Context invokationContext) {\n+   67:         if (typeUsage instanceof ReferenceTypeUsage) {\n+   68:             return solveMethodAsUsage((ReferenceTypeUsage)typeUsage, name, parameterTypes, typeSolver, invokationContext);\n+   69:         } else if (typeUsage instanceof TypeUsageOfTypeParameter) {\n+   70:             return solveMethodAsUsage((TypeUsageOfTypeParameter)typeUsage, name, parameterTypes, typeSolver, invokationContext);\n",
        "uniqueId": "0e81f51c40996b42cb262dc2397126cee8f60965_61_70__56_64",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 3,
                "covered": 26
            },
            "BRANCH": {
                "missed": 2,
                "covered": 2
            },
            "LINE": {
                "missed": 2,
                "covered": 4
            },
            "COMPLEXITY": {
                "missed": 2,
                "covered": 1
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 1.8
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprivate getTypeConcrete(node Node, solveLambdas boolean) : TypeUsage extracted from public getType(node Node, solveLambdas boolean) : TypeUsage in class me.tomassetti.symbolsolver.JavaParserFacade",
        "diffLocations": [
            {
                "filePath": "src/main/java/me/tomassetti/symbolsolver/JavaParserFacade.java",
                "startLine": 93,
                "endLine": 164,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "src/main/java/me/tomassetti/symbolsolver/JavaParserFacade.java",
                "startLine": 106,
                "endLine": 118,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "src/main/java/me/tomassetti/symbolsolver/JavaParserFacade.java",
                "startLine": 120,
                "endLine": 191,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "/**\n     * Should return more like a TypeApplication: a TypeDeclaration and possible parameters or array modifiers.\n     * @return\n     */\n    public TypeUsage getType(Node node, boolean solveLambdas) {\n        if (node == null) throw new IllegalArgumentException();\n        if (node instanceof NameExpr) {\n            NameExpr nameExpr = (NameExpr) node;\n            logger.finest(\"getType on name expr \" + node);\n            return new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr).get().getUsage();\n        } else if (node instanceof MethodCallExpr) {\n            logger.finest(\"getType on method call \" + node);\n            // first solve the method\n            MethodUsage ref = new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n            logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n            logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n            return ref.returnType();\n            // the type is the return type of the method\n        } else if (node instanceof LambdaExpr) {\n            if (node.getParentNode() instanceof MethodCallExpr) {\n                MethodCallExpr callExpr = (MethodCallExpr) node.getParentNode();\n                int pos = JavaParserSymbolDeclaration.getParamPos(node);\n                SymbolReference<MethodDeclaration> refMethod = new JavaParserFacade(typeSolver).solve(callExpr);\n                if (!refMethod.isSolved()) {\n                    throw new UnsolvedSymbolException(null, callExpr.getName());\n                }\n                logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                if (solveLambdas) {\n                    return refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver).getUsage(node);\n                } else {\n                    return new TypeUsageOfTypeDeclaration(refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver));\n                }\n                //System.out.println(\"LAMBDA \" + node.getParentNode());\n                //System.out.println(\"LAMBDA CLASS \" + node.getParentNode().getClass().getCanonicalName());\n                //TypeUsage typeOfMethod = new JavaParserFacade(typeSolver).getType(node.getParentNode());\n                //throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n            } else {\n                throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n            }\n        } else if (node instanceof VariableDeclarator) {\n            if (node.getParentNode() instanceof FieldDeclaration) {\n                FieldDeclaration parent = (FieldDeclaration) node.getParentNode();\n                return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n            } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n                VariableDeclarationExpr parent = (VariableDeclarationExpr) node.getParentNode();\n                return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n            } else {\n                throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n            }\n        } else if (node instanceof Parameter) {\n            Parameter parameter = (Parameter)node;\n            if (parameter.getType() instanceof UnknownType){\n                throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n            }\n            return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n        } else if (node instanceof FieldAccessExpr) {\n            FieldAccessExpr fieldAccessExpr = (FieldAccessExpr) node;\n            Optional<Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n            if (value.isPresent()) {\n                return value.get().getUsage();\n            } else {\n                throw new UnsolvedSymbolException(null, fieldAccessExpr.getField());\n            }\n        } else if (node instanceof ObjectCreationExpr) {\n            ObjectCreationExpr objectCreationExpr = (ObjectCreationExpr)node;\n            TypeUsage typeUsage = new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n            return typeUsage;\n        } else {\n            throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n        }\n    }",
        "filePathBefore": "src/main/java/me/tomassetti/symbolsolver/JavaParserFacade.java",
        "isPureRefactoring": true,
        "commitId": "627b56302d259409e9bc50b20d77803484f18b5c",
        "packageNameBefore": "me.tomassetti.symbolsolver",
        "classNameBefore": "me.tomassetti.symbolsolver.JavaParserFacade",
        "methodNameBefore": "me.tomassetti.symbolsolver.JavaParserFacade#getType",
        "invokedMethod": "methodSignature: me.tomassetti.symbolsolver.model.reflection.ReflectionClassDeclaration#getName\n methodBody: public String getName() {\nreturn clazz.getSimpleName();\n}\nmethodSignature: me.tomassetti.symbolsolver.model.javassist.JavassistParameterDeclaration#getType\n methodBody: public TypeDeclaration getType(TypeSolver typeSolver) {\nreturn new JavassistClassDeclaration(type);\n}\nmethodSignature: me.tomassetti.symbolsolver.model.reflection.ReflectionClassDeclaration#getUsage\n methodBody: public TypeUsage getUsage(Node node) {\nfor(TypeParameter tp: this.getTypeParameters()){throw new UnsupportedOperationException(\"Find parameters of \" + this + \" in \" + node);\n}return new TypeUsageOfTypeDeclaration(this);\n}\nmethodSignature: me.tomassetti.symbolsolver.model.reflection.ReflectionClassDeclaration#getField\n methodBody: public FieldDeclaration getField(String name) {\nthrow new UnsupportedOperationException();\n}\nmethodSignature: me.tomassetti.symbolsolver.model.javaparser.contexts.MethodCallExprContext#solveMethodAsUsage\n methodBody: public Optional<MethodUsage> solveMethodAsUsage(String name, List<TypeUsage> parameterTypes, TypeSolver typeSolver) {\nif(wrappedNode.getScope() != null){TypeUsage typeOfScope=new JavaParserFacade(typeSolver).getType(wrappedNode.getScope());\nreturn typeOfScope.solveMethodAsUsage(name,parameterTypes,typeSolver);\n}{throw new UnsupportedOperationException();\n}}\nmethodSignature: me.tomassetti.symbolsolver.JavaParserFacade#solve\n methodBody: public SymbolReference<MethodDeclaration> solve(MethodCallExpr methodCallExpr) {\nList<TypeUsage> params=new LinkedList<>();\nList<LambdaTypeUsagePlaceholder> placeholders=new LinkedList<>();\nint i=0;\nfor(Expression expression: methodCallExpr.getArgs()){if(expression instanceof LambdaExpr){LambdaTypeUsagePlaceholder placeholder=new LambdaTypeUsagePlaceholder(i);\nparams.add(placeholder);\nplaceholders.add(placeholder);\n}{params.add(new JavaParserFacade(typeSolver).getType(expression));\n}i++;\n}SymbolReference<MethodDeclaration> res=JavaParserFactory.getContext(methodCallExpr).solveMethod(methodCallExpr.getName(),params,typeSolver);\nfor(LambdaTypeUsagePlaceholder placeholder: placeholders){placeholder.setMethod(res);\n}return res;\n}\nmethodSignature: me.tomassetti.symbolsolver.model.reflection.ReflectionClassDeclaration#solveMethodAsUsage\n methodBody: public Optional<MethodUsage> solveMethodAsUsage(String name, List<TypeUsage> parameterTypes, TypeSolver typeSolver) {\nList<MethodDeclaration> methods=new ArrayList<>();\nfor(Method method: clazz.getMethods()){MethodDeclaration methodDeclaration=new ReflectionMethodDeclaration(method);\nmethods.add(methodDeclaration);\n}SymbolReference<MethodDeclaration> ref=MethodResolutionLogic.findMostApplicable(methods,name,parameterTypes,typeSolver);\nif(ref.isSolved()){return Optional.of(new JavaParserFacade(typeSolver).convertToUsage(ref.getCorrespondingDeclaration(),getContext()));\n}{return Optional.empty();\n}}\nmethodSignature: me.tomassetti.symbolsolver.model.javassist.JavassistParameterDeclaration#getName\n methodBody: public String getName() {\nthrow new UnsupportedOperationException();\n}\nmethodSignature: me.tomassetti.symbolsolver.model.javaparser.declarations.JavaParserFieldDeclaration#getType\n methodBody: public TypeDeclaration getType(TypeSolver typeSolver) {\nreturn new JavaParserFacade(typeSolver).convert(fieldDeclaration.getType(),fieldDeclaration);\n}\nmethodSignature: me.tomassetti.symbolsolver.JavaParserFacade#solveMethodAsUsage\n methodBody: public MethodUsage solveMethodAsUsage(MethodCallExpr call) {\nList<TypeUsage> params=new ArrayList<>();\nif(call.getArgs() != null){for(Expression param: call.getArgs()){params.add(getType(param,false));\n}}TypeUsage typeOfScope=getType(call.getScope());\nlogger.finest(\"facade solveMethodAsUsage, params \" + params);\nlogger.finest(\"facade solveMethodAsUsage, scope \" + typeOfScope);\nOptional<MethodUsage> ref=new MethodCallExprContext(call).solveMethodAsUsage(call.getName(),params,typeSolver);\nif(!ref.isPresent()){throw new UnsolvedSymbolException(null,call.getName());\n}{logger.finest(\"facade solveMethodAsUsage, ref \" + ref.get());\nMethodUsage methodUsage=ref.get();\nmethodUsage=replaceParams(methodUsage,typeOfScope);\nTypeUsage returnType=replaceParams(methodUsage.returnType(),typeOfScope);\nmethodUsage=methodUsage.replaceReturnType(returnType);\nreturn methodUsage;\n}}\nmethodSignature: me.tomassetti.symbolsolver.model.javaparser.declarations.JavaParserSymbolDeclaration#getParamPos\n methodBody: public static int getParamPos(Node node) {\nif(node.getParentNode() instanceof MethodCallExpr){MethodCallExpr call=(MethodCallExpr)node.getParentNode();\nfor(int i=0; i < call.getArgs().size(); i++){if(call.getArgs().get(i) == node)return i;\n}throw new IllegalStateException();\n}{throw new IllegalArgumentException();\n}}\nmethodSignature: me.tomassetti.symbolsolver.model.javaparser.declarations.JavaParserSymbolDeclaration#getType\n methodBody: public TypeDeclaration getType(TypeSolver typeSolver) {\nif(wrappedNode instanceof Parameter){Parameter parameter=(Parameter)wrappedNode;\nif(wrappedNode.getParentNode() instanceof LambdaExpr){int pos=getParamPos(parameter);\nTypeUsage lambdaType=new JavaParserFacade(typeSolver).getType(wrappedNode.getParentNode());\nthrow new UnsupportedOperationException(wrappedNode.getClass().getCanonicalName());\n}{return new SymbolSolver(typeSolver).solveType(parameter.getType());\n}}if(wrappedNode instanceof VariableDeclarator){VariableDeclarator variableDeclarator=(VariableDeclarator)wrappedNode;\nif(wrappedNode.getParentNode() instanceof VariableDeclarationExpr){VariableDeclarationExpr variableDeclarationExpr=(VariableDeclarationExpr)variableDeclarator.getParentNode();\nreturn new JavaParserFacade(typeSolver).convert(variableDeclarationExpr.getType(),JavaParserFactory.getContext(wrappedNode));\n}if(wrappedNode.getParentNode() instanceof FieldDeclaration){FieldDeclaration fieldDeclaration=(FieldDeclaration)variableDeclarator.getParentNode();\nreturn new JavaParserFacade(typeSolver).convert(fieldDeclaration.getType(),JavaParserFactory.getContext(wrappedNode));\n}{throw new UnsupportedOperationException(wrappedNode.getParentNode().getClass().getCanonicalName());\n}}{throw new UnsupportedOperationException(wrappedNode.getClass().getCanonicalName());\n}}\nmethodSignature: me.tomassetti.symbolsolver.model.javaparser.contexts.FieldAccessContext#solveSymbolAsValue\n methodBody: public Optional<Value> solveSymbolAsValue(String name, TypeSolver typeSolver) {\nExpression scope=wrappedNode.getScope();\nTypeUsage typeOfScope=new JavaParserFacade(typeSolver).getType(scope);\nreturn typeOfScope.getField(name,typeSolver);\n}\nmethodSignature: me.tomassetti.symbolsolver.model.javaparser.contexts.MethodCallExprContext#solveSymbolAsValue\n methodBody: public Optional<Value> solveSymbolAsValue(String name, TypeSolver typeSolver) {\nreturn JavaParserFactory.getContext(wrappedNode.getParentNode()).solveSymbolAsValue(name,typeSolver);\n}\nmethodSignature: me.tomassetti.symbolsolver.JavaParserFacade#getType\n methodBody: public TypeUsage getType(Node node, boolean solveLambdas) {\nif(node == null)throw new IllegalArgumentException();\nif(node instanceof NameExpr){NameExpr nameExpr=(NameExpr)node;\nlogger.finest(\"getType on name expr \" + node);\nreturn new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(),nameExpr).get().getUsage();\n}if(node instanceof MethodCallExpr){logger.finest(\"getType on method call \" + node);\nMethodUsage ref=new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr)node);\nlogger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\nlogger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\nreturn ref.returnType();\n}if(node instanceof LambdaExpr){if(node.getParentNode() instanceof MethodCallExpr){MethodCallExpr callExpr=(MethodCallExpr)node.getParentNode();\nint pos=JavaParserSymbolDeclaration.getParamPos(node);\nSymbolReference<MethodDeclaration> refMethod=new JavaParserFacade(typeSolver).solve(callExpr);\nif(!refMethod.isSolved()){throw new UnsolvedSymbolException(null,callExpr.getName());\n}logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\nif(solveLambdas){return refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver).getUsage(node);\n}{return new TypeUsageOfTypeDeclaration(refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver));\n}}{throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n}}if(node instanceof VariableDeclarator){if(node.getParentNode() instanceof FieldDeclaration){FieldDeclaration parent=(FieldDeclaration)node.getParentNode();\nreturn new JavaParserFacade(typeSolver).convertToUsage(parent.getType(),parent);\n}if(node.getParentNode() instanceof VariableDeclarationExpr){VariableDeclarationExpr parent=(VariableDeclarationExpr)node.getParentNode();\nreturn new JavaParserFacade(typeSolver).convertToUsage(parent.getType(),parent);\n}{throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n}}if(node instanceof Parameter){Parameter parameter=(Parameter)node;\nif(parameter.getType() instanceof UnknownType){throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n}return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(),parameter);\n}if(node instanceof FieldAccessExpr){FieldAccessExpr fieldAccessExpr=(FieldAccessExpr)node;\nOptional<Value> value=new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(),fieldAccessExpr);\nif(value.isPresent()){return value.get().getUsage();\n}{throw new UnsolvedSymbolException(null,fieldAccessExpr.getField());\n}}if(node instanceof ObjectCreationExpr){ObjectCreationExpr objectCreationExpr=(ObjectCreationExpr)node;\nTypeUsage typeUsage=new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(),node);\nreturn typeUsage;\n}{throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n}}\nmethodSignature: me.tomassetti.symbolsolver.model.javaparser.declarations.JavaParserFieldDeclaration#getName\n methodBody: public String getName() {\nthrow new UnsupportedOperationException();\n}\nmethodSignature: me.tomassetti.symbolsolver.model.javaparser.contexts.LambdaExprContext#solveSymbolAsValue\n methodBody: public Optional<Value> solveSymbolAsValue(String name, TypeSolver typeSolver) {\nfor(Parameter parameter: wrappedNode.getParameters()){SymbolDeclarator sb=JavaParserFactory.getSymbolDeclarator(parameter,typeSolver);\nif(wrappedNode.getParentNode() instanceof MethodCallExpr){MethodCallExpr methodCallExpr=(MethodCallExpr)wrappedNode.getParentNode();\nMethodUsage methodUsage=new JavaParserFacade(typeSolver).solveMethodAsUsage(methodCallExpr);\nint i=pos(methodCallExpr,wrappedNode);\nTypeUsage lambdaType=methodUsage.getParamTypes().get(i);\nValue value=new Value(lambdaType.parameters().get(0),name,false);\nreturn Optional.of(value);\n}{throw new UnsupportedOperationException();\n}}return getParent().solveSymbolAsValue(name,typeSolver);\n}\nmethodSignature: me.tomassetti.symbolsolver.JavaParserFacade#convertToUsage\n methodBody: public MethodUsage convertToUsage(MethodDeclaration methodDeclaration, Context context) {\nreturn new MethodUsage(methodDeclaration,typeSolver);\n}\nmethodSignature: me.tomassetti.symbolsolver.model.javaparser.declarations.JavaParserSymbolDeclaration#getName\n methodBody: public String getName() {\nreturn name;\n}",
        "classSignatureBefore": "public class JavaParserFacade ",
        "methodNameBeforeSet": [
            "me.tomassetti.symbolsolver.JavaParserFacade#getType"
        ],
        "classNameBeforeSet": [
            "me.tomassetti.symbolsolver.JavaParserFacade"
        ],
        "classSignatureBeforeSet": [
            "public class JavaParserFacade "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "package me.tomassetti.symbolsolver;\n\nimport com.github.javaparser.ast.Node;\nimport com.github.javaparser.ast.body.FieldDeclaration;\nimport com.github.javaparser.ast.body.Parameter;\nimport com.github.javaparser.ast.body.VariableDeclarator;\nimport com.github.javaparser.ast.expr.*;\nimport com.github.javaparser.ast.type.ClassOrInterfaceType;\nimport com.github.javaparser.ast.type.ReferenceType;\nimport com.github.javaparser.ast.type.Type;\nimport com.github.javaparser.ast.type.UnknownType;\nimport jdk.nashorn.internal.ir.Symbol;\nimport me.tomassetti.symbolsolver.model.*;\nimport me.tomassetti.symbolsolver.model.declarations.MethodDeclaration;\nimport me.tomassetti.symbolsolver.model.declarations.ValueDeclaration;\nimport me.tomassetti.symbolsolver.model.declarations.TypeDeclaration;\nimport me.tomassetti.symbolsolver.model.usages.MethodUsage;\nimport me.tomassetti.symbolsolver.model.usages.TypeUsageOfTypeDeclaration;\nimport me.tomassetti.symbolsolver.model.javaparser.JavaParserFactory;\nimport me.tomassetti.symbolsolver.model.javaparser.UnsolvedSymbolException;\nimport me.tomassetti.symbolsolver.model.javaparser.contexts.MethodCallExprContext;\nimport me.tomassetti.symbolsolver.model.javaparser.declarations.JavaParserSymbolDeclaration;\nimport me.tomassetti.symbolsolver.model.usages.TypeUsage;\n\nimport java.lang.reflect.Method;\nimport java.util.*;\nimport java.util.logging.ConsoleHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.stream.Collectors;\n\n/**\n * Class to be used by final users to solve symbols for JavaParser ASTs.\n */\npublic class JavaParserFacade {\n\n    private TypeSolver typeSolver;\n    private SymbolSolver symbolSolver;\n\n    private static Logger logger = Logger.getLogger(JavaParserFacade.class.getCanonicalName());\n    static {\n        logger.setLevel(Level.FINEST);\n        ConsoleHandler consoleHandler = new ConsoleHandler();\n        consoleHandler.setLevel(Level.FINEST);\n        logger.addHandler(consoleHandler);\n    }\n\n    public JavaParserFacade(TypeSolver typeSolver) {\n        this.typeSolver = typeSolver;\n        this.symbolSolver = new SymbolSolver(typeSolver);\n    }\n\n    public SymbolReference solve(NameExpr nameExpr) {\n        return symbolSolver.solveSymbol(nameExpr.getName(), nameExpr);\n    }\n\n    public SymbolReference solve(Expression expr) {\n        if (expr instanceof NameExpr) {\n            return solve((NameExpr)expr);\n        } else {\n            throw new IllegalArgumentException(expr.getClass().getCanonicalName());\n        }\n    }\n\n    /**\n     * Given a method call find out to which method declaration it corresponds.\n     */\n    public SymbolReference<MethodDeclaration> solve(MethodCallExpr methodCallExpr) {\n        List<TypeUsage> params = new LinkedList<>();\n        List<LambdaTypeUsagePlaceholder> placeholders = new LinkedList<>();\n        int i = 0;\n        for (Expression expression : methodCallExpr.getArgs()) {\n            if (expression instanceof LambdaExpr) {\n                LambdaTypeUsagePlaceholder placeholder = new LambdaTypeUsagePlaceholder(i);\n                params.add(placeholder);\n                placeholders.add(placeholder);\n            } else {\n                params.add(new JavaParserFacade(typeSolver).getType(expression));\n            }\n            i++;\n        }\n        SymbolReference<MethodDeclaration> res = JavaParserFactory.getContext(methodCallExpr).solveMethod(methodCallExpr.getName(), params, typeSolver);\n        for (LambdaTypeUsagePlaceholder placeholder : placeholders) {\n            placeholder.setMethod(res);\n        }\n        return res;\n    }\n\n    public TypeUsage getType(Node node) {\n        return getType(node, true);\n    }\n\n    /**\n     * Should return more like a TypeApplication: a TypeDeclaration and possible parameters or array modifiers.\n     * @return\n     */\n    public TypeUsage getType(Node node, boolean solveLambdas) {\n        if (node == null) throw new IllegalArgumentException();\n        if (node instanceof NameExpr) {\n            NameExpr nameExpr = (NameExpr) node;\n            logger.finest(\"getType on name expr \" + node);\n            return new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr).get().getUsage();\n        } else if (node instanceof MethodCallExpr) {\n            logger.finest(\"getType on method call \" + node);\n            // first solve the method\n            MethodUsage ref = new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n            logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n            logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n            return ref.returnType();\n            // the type is the return type of the method\n        } else if (node instanceof LambdaExpr) {\n            if (node.getParentNode() instanceof MethodCallExpr) {\n                MethodCallExpr callExpr = (MethodCallExpr) node.getParentNode();\n                int pos = JavaParserSymbolDeclaration.getParamPos(node);\n                SymbolReference<MethodDeclaration> refMethod = new JavaParserFacade(typeSolver).solve(callExpr);\n                if (!refMethod.isSolved()) {\n                    throw new UnsolvedSymbolException(null, callExpr.getName());\n                }\n                logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                if (solveLambdas) {\n                    return refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver).getUsage(node);\n                } else {\n                    return new TypeUsageOfTypeDeclaration(refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver));\n                }\n                //System.out.println(\"LAMBDA \" + node.getParentNode());\n                //System.out.println(\"LAMBDA CLASS \" + node.getParentNode().getClass().getCanonicalName());\n                //TypeUsage typeOfMethod = new JavaParserFacade(typeSolver).getType(node.getParentNode());\n                //throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n            } else {\n                throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n            }\n        } else if (node instanceof VariableDeclarator) {\n            if (node.getParentNode() instanceof FieldDeclaration) {\n                FieldDeclaration parent = (FieldDeclaration) node.getParentNode();\n                return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n            } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n                VariableDeclarationExpr parent = (VariableDeclarationExpr) node.getParentNode();\n                return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n            } else {\n                throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n            }\n        } else if (node instanceof Parameter) {\n            Parameter parameter = (Parameter)node;\n            if (parameter.getType() instanceof UnknownType){\n                throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n            }\n            return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n        } else if (node instanceof FieldAccessExpr) {\n            FieldAccessExpr fieldAccessExpr = (FieldAccessExpr) node;\n            Optional<Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n            if (value.isPresent()) {\n                return value.get().getUsage();\n            } else {\n                throw new UnsolvedSymbolException(null, fieldAccessExpr.getField());\n            }\n        } else if (node instanceof ObjectCreationExpr) {\n            ObjectCreationExpr objectCreationExpr = (ObjectCreationExpr)node;\n            TypeUsage typeUsage = new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n            return typeUsage;\n        } else {\n            throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n        }\n    }\n\n    public TypeUsage convertToUsage(Type type, Node context) {\n        if (type instanceof UnknownType){\n            throw new IllegalArgumentException(\"Unknown type\");\n        }\n        return convertToUsage(type, JavaParserFactory.getContext(context));\n    }\n\n    public TypeUsage convertToUsage(Type type, Context context) {\n        if (type instanceof ReferenceType) {\n            ReferenceType referenceType = (ReferenceType) type;\n            // TODO consider array modifiers\n            return convertToUsage(referenceType.getType(), context);\n        } else if (type instanceof ClassOrInterfaceType) {\n            ClassOrInterfaceType classOrInterfaceType = (ClassOrInterfaceType)type;\n            SymbolReference<TypeDeclaration> ref = context.solveType(classOrInterfaceType.getName(), typeSolver);\n            if (!ref.isSolved()) {\n                throw new UnsolvedSymbolException(null, classOrInterfaceType.getName());\n            }\n            TypeDeclaration typeDeclaration = ref.getCorrespondingDeclaration();\n            List<TypeUsage> typeParameters = Collections.emptyList();\n            if (classOrInterfaceType.getTypeArgs() != null) {\n                typeParameters = classOrInterfaceType.getTypeArgs().stream().map((pt)->convertToUsage(pt, context)).collect(Collectors.toList());\n            }\n            return new TypeUsageOfTypeDeclaration(typeDeclaration, typeParameters);\n        } else {\n            throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n        }\n    }\n\n    private SymbolReference<MethodDeclaration> solveMethod(MethodCallExpr methodCallExpr) {\n        List<TypeUsage> params = new ArrayList<>();\n        if (methodCallExpr.getArgs() != null) {\n            for (Expression param : methodCallExpr.getArgs()) {\n                params.add(getType(param));\n            }\n        }\n        return new MethodCallExprContext(methodCallExpr).solveMethod(methodCallExpr.getName(), params, typeSolver);\n    }\n\n    public TypeDeclaration convert(Type type, Node node) {\n        return convert(type, JavaParserFactory.getContext(node));\n    }\n\n    public TypeDeclaration convert(Type type, Context context) {\n        if (type instanceof ReferenceType) {\n            ReferenceType referenceType = (ReferenceType) type;\n            // TODO consider array modifiers\n            return convert(referenceType.getType(), context);\n        } else if (type instanceof ClassOrInterfaceType) {\n            ClassOrInterfaceType classOrInterfaceType = (ClassOrInterfaceType)type;\n            SymbolReference<TypeDeclaration> ref = context.solveType(classOrInterfaceType.getName(), typeSolver);\n            if (!ref.isSolved()) {\n                throw new UnsolvedSymbolException(null, classOrInterfaceType.getName());\n            }\n            return ref.getCorrespondingDeclaration();\n        } else {\n            throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n        }\n    }\n\n    public MethodUsage solveMethodAsUsage(MethodCallExpr call) {\n        List<TypeUsage> params = new ArrayList<>();\n        if (call.getArgs() != null) {\n            for (Expression param : call.getArgs()) {\n                params.add(getType(param, false));\n            }\n        }\n        TypeUsage typeOfScope = getType(call.getScope());\n        logger.finest(\"facade solveMethodAsUsage, params \" + params);\n        logger.finest(\"facade solveMethodAsUsage, scope \" + typeOfScope);\n\n        // TODO take params from scope and substitute them in ref\n\n        Optional<MethodUsage> ref = new MethodCallExprContext(call).solveMethodAsUsage(call.getName(), params, typeSolver);\n\n        if (!ref.isPresent()){\n            throw new UnsolvedSymbolException(null, call.getName());\n        } else {\n            logger.finest(\"facade solveMethodAsUsage, ref \" + ref.get());\n            MethodUsage methodUsage = ref.get();\n            methodUsage = replaceParams(methodUsage, typeOfScope);\n            TypeUsage returnType = replaceParams(methodUsage.returnType(), typeOfScope);\n            methodUsage = methodUsage.replaceReturnType(returnType);\n            return methodUsage;\n        }\n    }\n\n    private MethodUsage replaceParams(MethodUsage methodUsage, TypeUsage typeOfScope) {\n        logger.finest(\"ReplaceParams \" + methodUsage);\n        logger.finest(\"ReplaceParams N params \" + methodUsage.getParamTypes().size());\n        for (int i=0;i<methodUsage.getParamTypes().size();i++) {\n            TypeUsage typeUsage = methodUsage.getParamTypes().get(i);\n            TypeUsage replaced = replaceParams(typeUsage, typeOfScope);\n            logger.finest(\"ReplaceParams param type \" + typeUsage);\n            if (replaced != typeUsage) {\n                logger.finest(\"ReplaceParams param -> \" + replaced);\n                methodUsage = methodUsage.replaceParamType(i, replaced);\n            }\n\n        }\n        logger.finest(\"Final method usage \"+methodUsage);\n        return methodUsage;\n    }\n\n    private TypeUsage replaceParams(TypeUsage typeToReplace, TypeUsage typeOfScope) {\n        if (typeToReplace.isTypeVariable()) {\n            Optional<TypeUsage> replacement = typeOfScope.parameterByName(typeToReplace.getTypeName());\n            if (replacement.isPresent()) {\n                return replacement.get();\n            } else {\n                return typeToReplace;\n            }\n        } else {\n            for (int i=0;i<typeToReplace.parameters().size();i++){\n                TypeUsage typeUsage = typeToReplace.parameters().get(i);\n                TypeUsage replaced = replaceParams(typeUsage, typeOfScope);\n                if (replaced != typeUsage) {\n                    typeToReplace = typeToReplace.replaceParam(i, replaced);\n                }\n            }\n            return typeToReplace;\n        }\n    }\n\n    public MethodUsage convertToUsage(MethodDeclaration methodDeclaration, Context context) {\n        return new MethodUsage(methodDeclaration, typeSolver);\n    }\n}\n",
        "filePathAfter": "src/main/java/me/tomassetti/symbolsolver/JavaParserFacade.java",
        "sourceCodeAfterForWhole": "package me.tomassetti.symbolsolver;\n\nimport com.github.javaparser.ast.Node;\nimport com.github.javaparser.ast.body.FieldDeclaration;\nimport com.github.javaparser.ast.body.Parameter;\nimport com.github.javaparser.ast.body.VariableDeclarator;\nimport com.github.javaparser.ast.expr.*;\nimport com.github.javaparser.ast.type.ClassOrInterfaceType;\nimport com.github.javaparser.ast.type.ReferenceType;\nimport com.github.javaparser.ast.type.Type;\nimport com.github.javaparser.ast.type.UnknownType;\nimport jdk.nashorn.internal.ir.Symbol;\nimport me.tomassetti.symbolsolver.model.*;\nimport me.tomassetti.symbolsolver.model.declarations.MethodDeclaration;\nimport me.tomassetti.symbolsolver.model.declarations.ValueDeclaration;\nimport me.tomassetti.symbolsolver.model.declarations.TypeDeclaration;\nimport me.tomassetti.symbolsolver.model.usages.MethodUsage;\nimport me.tomassetti.symbolsolver.model.usages.TypeUsageOfTypeDeclaration;\nimport me.tomassetti.symbolsolver.model.javaparser.JavaParserFactory;\nimport me.tomassetti.symbolsolver.model.javaparser.UnsolvedSymbolException;\nimport me.tomassetti.symbolsolver.model.javaparser.contexts.MethodCallExprContext;\nimport me.tomassetti.symbolsolver.model.javaparser.declarations.JavaParserSymbolDeclaration;\nimport me.tomassetti.symbolsolver.model.usages.TypeUsage;\n\nimport java.lang.reflect.Method;\nimport java.util.*;\nimport java.util.logging.ConsoleHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.stream.Collectors;\n\n/**\n * Class to be used by final users to solve symbols for JavaParser ASTs.\n */\npublic class JavaParserFacade {\n\n    private TypeSolver typeSolver;\n    private SymbolSolver symbolSolver;\n\n    private static Logger logger = Logger.getLogger(JavaParserFacade.class.getCanonicalName());\n    static {\n        logger.setLevel(Level.FINEST);\n        ConsoleHandler consoleHandler = new ConsoleHandler();\n        consoleHandler.setLevel(Level.FINEST);\n        logger.addHandler(consoleHandler);\n    }\n\n    private JavaParserFacade(TypeSolver typeSolver) {\n        this.typeSolver = typeSolver;\n        this.symbolSolver = new SymbolSolver(typeSolver);\n    }\n\n    public static JavaParserFacade get(TypeSolver typeSolver){\n        if (!instances.containsKey(typeSolver)){\n            instances.put(typeSolver, new JavaParserFacade(typeSolver));\n        }\n        return instances.get(typeSolver);\n    }\n\n\n    public SymbolReference solve(NameExpr nameExpr) {\n        return symbolSolver.solveSymbol(nameExpr.getName(), nameExpr);\n    }\n\n    public SymbolReference solve(Expression expr) {\n        if (expr instanceof NameExpr) {\n            return solve((NameExpr)expr);\n        } else {\n            throw new IllegalArgumentException(expr.getClass().getCanonicalName());\n        }\n    }\n\n    /**\n     * Given a method call find out to which method declaration it corresponds.\n     */\n    public SymbolReference<MethodDeclaration> solve(MethodCallExpr methodCallExpr) {\n        List<TypeUsage> params = new LinkedList<>();\n        List<LambdaTypeUsagePlaceholder> placeholders = new LinkedList<>();\n        int i = 0;\n        for (Expression expression : methodCallExpr.getArgs()) {\n            if (expression instanceof LambdaExpr) {\n                LambdaTypeUsagePlaceholder placeholder = new LambdaTypeUsagePlaceholder(i);\n                params.add(placeholder);\n                placeholders.add(placeholder);\n            } else {\n                params.add(new JavaParserFacade(typeSolver).getType(expression));\n            }\n            i++;\n        }\n        SymbolReference<MethodDeclaration> res = JavaParserFactory.getContext(methodCallExpr).solveMethod(methodCallExpr.getName(), params, typeSolver);\n        for (LambdaTypeUsagePlaceholder placeholder : placeholders) {\n            placeholder.setMethod(res);\n        }\n        return res;\n    }\n\n    public TypeUsage getType(Node node) {\n        return getType(node, true);\n    }\n\n    private Map<Node, TypeUsage> cacheWithLambadsSolved = new WeakHashMap<>();\n    private Map<Node, TypeUsage> cacheWithoutLambadsSolved = new WeakHashMap<>();\n\n    private static Map<TypeSolver, JavaParserFacade> instances = new HashMap<>();\n\n    public TypeUsage getType(Node node, boolean solveLambdas) {\n        if (solveLambdas){\n            if (!cacheWithLambadsSolved.containsKey(node)){\n                cacheWithLambadsSolved.put(node, getTypeConcrete(node, solveLambdas));\n            }\n            return cacheWithLambadsSolved.get(node);\n        } else {\n            if (!cacheWithoutLambadsSolved.containsKey(node)){\n                cacheWithoutLambadsSolved.put(node, getTypeConcrete(node, solveLambdas));\n            }\n            return cacheWithoutLambadsSolved.get(node);\n        }\n    }\n\n    /**\n     * Should return more like a TypeApplication: a TypeDeclaration and possible parameters or array modifiers.\n     * @return\n     */\n    private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n        if (node == null) throw new IllegalArgumentException();\n        if (node instanceof NameExpr) {\n            NameExpr nameExpr = (NameExpr) node;\n            logger.finest(\"getType on name expr \" + node);\n            return new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr).get().getUsage();\n        } else if (node instanceof MethodCallExpr) {\n            logger.finest(\"getType on method call \" + node);\n            // first solve the method\n            MethodUsage ref = new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n            logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n            logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n            return ref.returnType();\n            // the type is the return type of the method\n        } else if (node instanceof LambdaExpr) {\n            if (node.getParentNode() instanceof MethodCallExpr) {\n                MethodCallExpr callExpr = (MethodCallExpr) node.getParentNode();\n                int pos = JavaParserSymbolDeclaration.getParamPos(node);\n                SymbolReference<MethodDeclaration> refMethod = new JavaParserFacade(typeSolver).solve(callExpr);\n                if (!refMethod.isSolved()) {\n                    throw new UnsolvedSymbolException(null, callExpr.getName());\n                }\n                logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                if (solveLambdas) {\n                    return refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver).getUsage(node);\n                } else {\n                    return new TypeUsageOfTypeDeclaration(refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver));\n                }\n                //System.out.println(\"LAMBDA \" + node.getParentNode());\n                //System.out.println(\"LAMBDA CLASS \" + node.getParentNode().getClass().getCanonicalName());\n                //TypeUsage typeOfMethod = new JavaParserFacade(typeSolver).getType(node.getParentNode());\n                //throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n            } else {\n                throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n            }\n        } else if (node instanceof VariableDeclarator) {\n            if (node.getParentNode() instanceof FieldDeclaration) {\n                FieldDeclaration parent = (FieldDeclaration) node.getParentNode();\n                return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n            } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n                VariableDeclarationExpr parent = (VariableDeclarationExpr) node.getParentNode();\n                return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n            } else {\n                throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n            }\n        } else if (node instanceof Parameter) {\n            Parameter parameter = (Parameter)node;\n            if (parameter.getType() instanceof UnknownType){\n                throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n            }\n            return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n        } else if (node instanceof FieldAccessExpr) {\n            FieldAccessExpr fieldAccessExpr = (FieldAccessExpr) node;\n            Optional<Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n            if (value.isPresent()) {\n                return value.get().getUsage();\n            } else {\n                throw new UnsolvedSymbolException(null, fieldAccessExpr.getField());\n            }\n        } else if (node instanceof ObjectCreationExpr) {\n            ObjectCreationExpr objectCreationExpr = (ObjectCreationExpr)node;\n            TypeUsage typeUsage = new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n            return typeUsage;\n        } else {\n            throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n        }\n    }\n\n    public TypeUsage convertToUsage(Type type, Node context) {\n        if (type instanceof UnknownType){\n            throw new IllegalArgumentException(\"Unknown type\");\n        }\n        return convertToUsage(type, JavaParserFactory.getContext(context));\n    }\n\n    public TypeUsage convertToUsage(Type type, Context context) {\n        if (type instanceof ReferenceType) {\n            ReferenceType referenceType = (ReferenceType) type;\n            // TODO consider array modifiers\n            return convertToUsage(referenceType.getType(), context);\n        } else if (type instanceof ClassOrInterfaceType) {\n            ClassOrInterfaceType classOrInterfaceType = (ClassOrInterfaceType)type;\n            SymbolReference<TypeDeclaration> ref = context.solveType(classOrInterfaceType.getName(), typeSolver);\n            if (!ref.isSolved()) {\n                throw new UnsolvedSymbolException(null, classOrInterfaceType.getName());\n            }\n            TypeDeclaration typeDeclaration = ref.getCorrespondingDeclaration();\n            List<TypeUsage> typeParameters = Collections.emptyList();\n            if (classOrInterfaceType.getTypeArgs() != null) {\n                typeParameters = classOrInterfaceType.getTypeArgs().stream().map((pt)->convertToUsage(pt, context)).collect(Collectors.toList());\n            }\n            return new TypeUsageOfTypeDeclaration(typeDeclaration, typeParameters);\n        } else {\n            throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n        }\n    }\n\n    private SymbolReference<MethodDeclaration> solveMethod(MethodCallExpr methodCallExpr) {\n        List<TypeUsage> params = new ArrayList<>();\n        if (methodCallExpr.getArgs() != null) {\n            for (Expression param : methodCallExpr.getArgs()) {\n                params.add(getType(param));\n            }\n        }\n        return new MethodCallExprContext(methodCallExpr).solveMethod(methodCallExpr.getName(), params, typeSolver);\n    }\n\n    public TypeDeclaration convert(Type type, Node node) {\n        return convert(type, JavaParserFactory.getContext(node));\n    }\n\n    public TypeDeclaration convert(Type type, Context context) {\n        if (type instanceof ReferenceType) {\n            ReferenceType referenceType = (ReferenceType) type;\n            // TODO consider array modifiers\n            return convert(referenceType.getType(), context);\n        } else if (type instanceof ClassOrInterfaceType) {\n            ClassOrInterfaceType classOrInterfaceType = (ClassOrInterfaceType)type;\n            SymbolReference<TypeDeclaration> ref = context.solveType(classOrInterfaceType.getName(), typeSolver);\n            if (!ref.isSolved()) {\n                throw new UnsolvedSymbolException(null, classOrInterfaceType.getName());\n            }\n            return ref.getCorrespondingDeclaration();\n        } else {\n            throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n        }\n    }\n\n    public MethodUsage solveMethodAsUsage(MethodCallExpr call) {\n        List<TypeUsage> params = new ArrayList<>();\n        if (call.getArgs() != null) {\n            for (Expression param : call.getArgs()) {\n                params.add(getType(param, false));\n            }\n        }\n        TypeUsage typeOfScope = getType(call.getScope());\n        logger.finest(\"facade solveMethodAsUsage, params \" + params);\n        logger.finest(\"facade solveMethodAsUsage, scope \" + typeOfScope);\n\n        // TODO take params from scope and substitute them in ref\n\n        Optional<MethodUsage> ref = new MethodCallExprContext(call).solveMethodAsUsage(call.getName(), params, typeSolver);\n\n        if (!ref.isPresent()){\n            throw new UnsolvedSymbolException(null, call.getName());\n        } else {\n            logger.finest(\"facade solveMethodAsUsage, ref \" + ref.get());\n            MethodUsage methodUsage = ref.get();\n            methodUsage = replaceParams(methodUsage, typeOfScope);\n            TypeUsage returnType = replaceParams(methodUsage.returnType(), typeOfScope);\n            methodUsage = methodUsage.replaceReturnType(returnType);\n            return methodUsage;\n        }\n    }\n\n    private MethodUsage replaceParams(MethodUsage methodUsage, TypeUsage typeOfScope) {\n        logger.finest(\"ReplaceParams \" + methodUsage);\n        logger.finest(\"ReplaceParams N params \" + methodUsage.getParamTypes().size());\n        for (int i=0;i<methodUsage.getParamTypes().size();i++) {\n            TypeUsage typeUsage = methodUsage.getParamTypes().get(i);\n            TypeUsage replaced = replaceParams(typeUsage, typeOfScope);\n            logger.finest(\"ReplaceParams param type \" + typeUsage);\n            if (replaced != typeUsage) {\n                logger.finest(\"ReplaceParams param -> \" + replaced);\n                methodUsage = methodUsage.replaceParamType(i, replaced);\n            }\n\n        }\n        logger.finest(\"Final method usage \"+methodUsage);\n        return methodUsage;\n    }\n\n    private TypeUsage replaceParams(TypeUsage typeToReplace, TypeUsage typeOfScope) {\n        if (typeToReplace.isTypeVariable()) {\n            Optional<TypeUsage> replacement = typeOfScope.parameterByName(typeToReplace.getTypeName());\n            if (replacement.isPresent()) {\n                return replacement.get();\n            } else {\n                return typeToReplace;\n            }\n        } else {\n            for (int i=0;i<typeToReplace.parameters().size();i++){\n                TypeUsage typeUsage = typeToReplace.parameters().get(i);\n                TypeUsage replaced = replaceParams(typeUsage, typeOfScope);\n                if (replaced != typeUsage) {\n                    typeToReplace = typeToReplace.replaceParam(i, replaced);\n                }\n            }\n            return typeToReplace;\n        }\n    }\n\n    public MethodUsage convertToUsage(MethodDeclaration methodDeclaration, Context context) {\n        return new MethodUsage(methodDeclaration, typeSolver);\n    }\n}\n",
        "diffSourceCodeSet": [
            "/**\n     * Should return more like a TypeApplication: a TypeDeclaration and possible parameters or array modifiers.\n     * @return\n     */\n    private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n        if (node == null) throw new IllegalArgumentException();\n        if (node instanceof NameExpr) {\n            NameExpr nameExpr = (NameExpr) node;\n            logger.finest(\"getType on name expr \" + node);\n            return new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr).get().getUsage();\n        } else if (node instanceof MethodCallExpr) {\n            logger.finest(\"getType on method call \" + node);\n            // first solve the method\n            MethodUsage ref = new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n            logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n            logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n            return ref.returnType();\n            // the type is the return type of the method\n        } else if (node instanceof LambdaExpr) {\n            if (node.getParentNode() instanceof MethodCallExpr) {\n                MethodCallExpr callExpr = (MethodCallExpr) node.getParentNode();\n                int pos = JavaParserSymbolDeclaration.getParamPos(node);\n                SymbolReference<MethodDeclaration> refMethod = new JavaParserFacade(typeSolver).solve(callExpr);\n                if (!refMethod.isSolved()) {\n                    throw new UnsolvedSymbolException(null, callExpr.getName());\n                }\n                logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                if (solveLambdas) {\n                    return refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver).getUsage(node);\n                } else {\n                    return new TypeUsageOfTypeDeclaration(refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver));\n                }\n                //System.out.println(\"LAMBDA \" + node.getParentNode());\n                //System.out.println(\"LAMBDA CLASS \" + node.getParentNode().getClass().getCanonicalName());\n                //TypeUsage typeOfMethod = new JavaParserFacade(typeSolver).getType(node.getParentNode());\n                //throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n            } else {\n                throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n            }\n        } else if (node instanceof VariableDeclarator) {\n            if (node.getParentNode() instanceof FieldDeclaration) {\n                FieldDeclaration parent = (FieldDeclaration) node.getParentNode();\n                return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n            } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n                VariableDeclarationExpr parent = (VariableDeclarationExpr) node.getParentNode();\n                return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n            } else {\n                throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n            }\n        } else if (node instanceof Parameter) {\n            Parameter parameter = (Parameter)node;\n            if (parameter.getType() instanceof UnknownType){\n                throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n            }\n            return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n        } else if (node instanceof FieldAccessExpr) {\n            FieldAccessExpr fieldAccessExpr = (FieldAccessExpr) node;\n            Optional<Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n            if (value.isPresent()) {\n                return value.get().getUsage();\n            } else {\n                throw new UnsolvedSymbolException(null, fieldAccessExpr.getField());\n            }\n        } else if (node instanceof ObjectCreationExpr) {\n            ObjectCreationExpr objectCreationExpr = (ObjectCreationExpr)node;\n            TypeUsage typeUsage = new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n            return typeUsage;\n        } else {\n            throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n        }\n    }"
        ],
        "invokedMethodSet": [
            "methodSignature: me.tomassetti.symbolsolver.model.reflection.ReflectionClassDeclaration#getName\n methodBody: public String getName() {\nreturn clazz.getSimpleName();\n}",
            "methodSignature: me.tomassetti.symbolsolver.model.javassist.JavassistParameterDeclaration#getType\n methodBody: public TypeDeclaration getType(TypeSolver typeSolver) {\nreturn new JavassistClassDeclaration(type);\n}",
            "methodSignature: me.tomassetti.symbolsolver.model.reflection.ReflectionClassDeclaration#getUsage\n methodBody: public TypeUsage getUsage(Node node) {\nfor(TypeParameter tp: this.getTypeParameters()){throw new UnsupportedOperationException(\"Find parameters of \" + this + \" in \" + node);\n}return new TypeUsageOfTypeDeclaration(this);\n}",
            "methodSignature: me.tomassetti.symbolsolver.model.reflection.ReflectionClassDeclaration#getField\n methodBody: public FieldDeclaration getField(String name) {\nthrow new UnsupportedOperationException();\n}",
            "methodSignature: me.tomassetti.symbolsolver.model.javaparser.contexts.MethodCallExprContext#solveMethodAsUsage\n methodBody: public Optional<MethodUsage> solveMethodAsUsage(String name, List<TypeUsage> parameterTypes, TypeSolver typeSolver) {\nif(wrappedNode.getScope() != null){TypeUsage typeOfScope=new JavaParserFacade(typeSolver).getType(wrappedNode.getScope());\nreturn typeOfScope.solveMethodAsUsage(name,parameterTypes,typeSolver);\n}{throw new UnsupportedOperationException();\n}}",
            "methodSignature: me.tomassetti.symbolsolver.JavaParserFacade#solve\n methodBody: public SymbolReference<MethodDeclaration> solve(MethodCallExpr methodCallExpr) {\nList<TypeUsage> params=new LinkedList<>();\nList<LambdaTypeUsagePlaceholder> placeholders=new LinkedList<>();\nint i=0;\nfor(Expression expression: methodCallExpr.getArgs()){if(expression instanceof LambdaExpr){LambdaTypeUsagePlaceholder placeholder=new LambdaTypeUsagePlaceholder(i);\nparams.add(placeholder);\nplaceholders.add(placeholder);\n}{params.add(new JavaParserFacade(typeSolver).getType(expression));\n}i++;\n}SymbolReference<MethodDeclaration> res=JavaParserFactory.getContext(methodCallExpr).solveMethod(methodCallExpr.getName(),params,typeSolver);\nfor(LambdaTypeUsagePlaceholder placeholder: placeholders){placeholder.setMethod(res);\n}return res;\n}",
            "methodSignature: me.tomassetti.symbolsolver.model.reflection.ReflectionClassDeclaration#solveMethodAsUsage\n methodBody: public Optional<MethodUsage> solveMethodAsUsage(String name, List<TypeUsage> parameterTypes, TypeSolver typeSolver) {\nList<MethodDeclaration> methods=new ArrayList<>();\nfor(Method method: clazz.getMethods()){MethodDeclaration methodDeclaration=new ReflectionMethodDeclaration(method);\nmethods.add(methodDeclaration);\n}SymbolReference<MethodDeclaration> ref=MethodResolutionLogic.findMostApplicable(methods,name,parameterTypes,typeSolver);\nif(ref.isSolved()){return Optional.of(new JavaParserFacade(typeSolver).convertToUsage(ref.getCorrespondingDeclaration(),getContext()));\n}{return Optional.empty();\n}}",
            "methodSignature: me.tomassetti.symbolsolver.model.javassist.JavassistParameterDeclaration#getName\n methodBody: public String getName() {\nthrow new UnsupportedOperationException();\n}",
            "methodSignature: me.tomassetti.symbolsolver.model.javaparser.declarations.JavaParserFieldDeclaration#getType\n methodBody: public TypeDeclaration getType(TypeSolver typeSolver) {\nreturn new JavaParserFacade(typeSolver).convert(fieldDeclaration.getType(),fieldDeclaration);\n}",
            "methodSignature: me.tomassetti.symbolsolver.JavaParserFacade#solveMethodAsUsage\n methodBody: public MethodUsage solveMethodAsUsage(MethodCallExpr call) {\nList<TypeUsage> params=new ArrayList<>();\nif(call.getArgs() != null){for(Expression param: call.getArgs()){params.add(getType(param,false));\n}}TypeUsage typeOfScope=getType(call.getScope());\nlogger.finest(\"facade solveMethodAsUsage, params \" + params);\nlogger.finest(\"facade solveMethodAsUsage, scope \" + typeOfScope);\nOptional<MethodUsage> ref=new MethodCallExprContext(call).solveMethodAsUsage(call.getName(),params,typeSolver);\nif(!ref.isPresent()){throw new UnsolvedSymbolException(null,call.getName());\n}{logger.finest(\"facade solveMethodAsUsage, ref \" + ref.get());\nMethodUsage methodUsage=ref.get();\nmethodUsage=replaceParams(methodUsage,typeOfScope);\nTypeUsage returnType=replaceParams(methodUsage.returnType(),typeOfScope);\nmethodUsage=methodUsage.replaceReturnType(returnType);\nreturn methodUsage;\n}}",
            "methodSignature: me.tomassetti.symbolsolver.model.javaparser.declarations.JavaParserSymbolDeclaration#getParamPos\n methodBody: public static int getParamPos(Node node) {\nif(node.getParentNode() instanceof MethodCallExpr){MethodCallExpr call=(MethodCallExpr)node.getParentNode();\nfor(int i=0; i < call.getArgs().size(); i++){if(call.getArgs().get(i) == node)return i;\n}throw new IllegalStateException();\n}{throw new IllegalArgumentException();\n}}",
            "methodSignature: me.tomassetti.symbolsolver.model.javaparser.declarations.JavaParserSymbolDeclaration#getType\n methodBody: public TypeDeclaration getType(TypeSolver typeSolver) {\nif(wrappedNode instanceof Parameter){Parameter parameter=(Parameter)wrappedNode;\nif(wrappedNode.getParentNode() instanceof LambdaExpr){int pos=getParamPos(parameter);\nTypeUsage lambdaType=new JavaParserFacade(typeSolver).getType(wrappedNode.getParentNode());\nthrow new UnsupportedOperationException(wrappedNode.getClass().getCanonicalName());\n}{return new SymbolSolver(typeSolver).solveType(parameter.getType());\n}}if(wrappedNode instanceof VariableDeclarator){VariableDeclarator variableDeclarator=(VariableDeclarator)wrappedNode;\nif(wrappedNode.getParentNode() instanceof VariableDeclarationExpr){VariableDeclarationExpr variableDeclarationExpr=(VariableDeclarationExpr)variableDeclarator.getParentNode();\nreturn new JavaParserFacade(typeSolver).convert(variableDeclarationExpr.getType(),JavaParserFactory.getContext(wrappedNode));\n}if(wrappedNode.getParentNode() instanceof FieldDeclaration){FieldDeclaration fieldDeclaration=(FieldDeclaration)variableDeclarator.getParentNode();\nreturn new JavaParserFacade(typeSolver).convert(fieldDeclaration.getType(),JavaParserFactory.getContext(wrappedNode));\n}{throw new UnsupportedOperationException(wrappedNode.getParentNode().getClass().getCanonicalName());\n}}{throw new UnsupportedOperationException(wrappedNode.getClass().getCanonicalName());\n}}",
            "methodSignature: me.tomassetti.symbolsolver.model.javaparser.contexts.FieldAccessContext#solveSymbolAsValue\n methodBody: public Optional<Value> solveSymbolAsValue(String name, TypeSolver typeSolver) {\nExpression scope=wrappedNode.getScope();\nTypeUsage typeOfScope=new JavaParserFacade(typeSolver).getType(scope);\nreturn typeOfScope.getField(name,typeSolver);\n}",
            "methodSignature: me.tomassetti.symbolsolver.model.javaparser.contexts.MethodCallExprContext#solveSymbolAsValue\n methodBody: public Optional<Value> solveSymbolAsValue(String name, TypeSolver typeSolver) {\nreturn JavaParserFactory.getContext(wrappedNode.getParentNode()).solveSymbolAsValue(name,typeSolver);\n}",
            "methodSignature: me.tomassetti.symbolsolver.JavaParserFacade#getType\n methodBody: public TypeUsage getType(Node node, boolean solveLambdas) {\nif(node == null)throw new IllegalArgumentException();\nif(node instanceof NameExpr){NameExpr nameExpr=(NameExpr)node;\nlogger.finest(\"getType on name expr \" + node);\nreturn new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(),nameExpr).get().getUsage();\n}if(node instanceof MethodCallExpr){logger.finest(\"getType on method call \" + node);\nMethodUsage ref=new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr)node);\nlogger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\nlogger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\nreturn ref.returnType();\n}if(node instanceof LambdaExpr){if(node.getParentNode() instanceof MethodCallExpr){MethodCallExpr callExpr=(MethodCallExpr)node.getParentNode();\nint pos=JavaParserSymbolDeclaration.getParamPos(node);\nSymbolReference<MethodDeclaration> refMethod=new JavaParserFacade(typeSolver).solve(callExpr);\nif(!refMethod.isSolved()){throw new UnsolvedSymbolException(null,callExpr.getName());\n}logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\nif(solveLambdas){return refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver).getUsage(node);\n}{return new TypeUsageOfTypeDeclaration(refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver));\n}}{throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n}}if(node instanceof VariableDeclarator){if(node.getParentNode() instanceof FieldDeclaration){FieldDeclaration parent=(FieldDeclaration)node.getParentNode();\nreturn new JavaParserFacade(typeSolver).convertToUsage(parent.getType(),parent);\n}if(node.getParentNode() instanceof VariableDeclarationExpr){VariableDeclarationExpr parent=(VariableDeclarationExpr)node.getParentNode();\nreturn new JavaParserFacade(typeSolver).convertToUsage(parent.getType(),parent);\n}{throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n}}if(node instanceof Parameter){Parameter parameter=(Parameter)node;\nif(parameter.getType() instanceof UnknownType){throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n}return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(),parameter);\n}if(node instanceof FieldAccessExpr){FieldAccessExpr fieldAccessExpr=(FieldAccessExpr)node;\nOptional<Value> value=new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(),fieldAccessExpr);\nif(value.isPresent()){return value.get().getUsage();\n}{throw new UnsolvedSymbolException(null,fieldAccessExpr.getField());\n}}if(node instanceof ObjectCreationExpr){ObjectCreationExpr objectCreationExpr=(ObjectCreationExpr)node;\nTypeUsage typeUsage=new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(),node);\nreturn typeUsage;\n}{throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n}}",
            "methodSignature: me.tomassetti.symbolsolver.model.javaparser.declarations.JavaParserFieldDeclaration#getName\n methodBody: public String getName() {\nthrow new UnsupportedOperationException();\n}",
            "methodSignature: me.tomassetti.symbolsolver.model.javaparser.contexts.LambdaExprContext#solveSymbolAsValue\n methodBody: public Optional<Value> solveSymbolAsValue(String name, TypeSolver typeSolver) {\nfor(Parameter parameter: wrappedNode.getParameters()){SymbolDeclarator sb=JavaParserFactory.getSymbolDeclarator(parameter,typeSolver);\nif(wrappedNode.getParentNode() instanceof MethodCallExpr){MethodCallExpr methodCallExpr=(MethodCallExpr)wrappedNode.getParentNode();\nMethodUsage methodUsage=new JavaParserFacade(typeSolver).solveMethodAsUsage(methodCallExpr);\nint i=pos(methodCallExpr,wrappedNode);\nTypeUsage lambdaType=methodUsage.getParamTypes().get(i);\nValue value=new Value(lambdaType.parameters().get(0),name,false);\nreturn Optional.of(value);\n}{throw new UnsupportedOperationException();\n}}return getParent().solveSymbolAsValue(name,typeSolver);\n}",
            "methodSignature: me.tomassetti.symbolsolver.JavaParserFacade#convertToUsage\n methodBody: public MethodUsage convertToUsage(MethodDeclaration methodDeclaration, Context context) {\nreturn new MethodUsage(methodDeclaration,typeSolver);\n}",
            "methodSignature: me.tomassetti.symbolsolver.model.javaparser.declarations.JavaParserSymbolDeclaration#getName\n methodBody: public String getName() {\nreturn name;\n}"
        ],
        "sourceCodeAfterRefactoring": "public TypeUsage getType(Node node, boolean solveLambdas) {\n        if (solveLambdas){\n            if (!cacheWithLambadsSolved.containsKey(node)){\n                cacheWithLambadsSolved.put(node, getTypeConcrete(node, solveLambdas));\n            }\n            return cacheWithLambadsSolved.get(node);\n        } else {\n            if (!cacheWithoutLambadsSolved.containsKey(node)){\n                cacheWithoutLambadsSolved.put(node, getTypeConcrete(node, solveLambdas));\n            }\n            return cacheWithoutLambadsSolved.get(node);\n        }\n    }\n/**\n     * Should return more like a TypeApplication: a TypeDeclaration and possible parameters or array modifiers.\n     * @return\n     */\n    private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n        if (node == null) throw new IllegalArgumentException();\n        if (node instanceof NameExpr) {\n            NameExpr nameExpr = (NameExpr) node;\n            logger.finest(\"getType on name expr \" + node);\n            return new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr).get().getUsage();\n        } else if (node instanceof MethodCallExpr) {\n            logger.finest(\"getType on method call \" + node);\n            // first solve the method\n            MethodUsage ref = new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n            logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n            logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n            return ref.returnType();\n            // the type is the return type of the method\n        } else if (node instanceof LambdaExpr) {\n            if (node.getParentNode() instanceof MethodCallExpr) {\n                MethodCallExpr callExpr = (MethodCallExpr) node.getParentNode();\n                int pos = JavaParserSymbolDeclaration.getParamPos(node);\n                SymbolReference<MethodDeclaration> refMethod = new JavaParserFacade(typeSolver).solve(callExpr);\n                if (!refMethod.isSolved()) {\n                    throw new UnsolvedSymbolException(null, callExpr.getName());\n                }\n                logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n                //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n                if (solveLambdas) {\n                    return refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver).getUsage(node);\n                } else {\n                    return new TypeUsageOfTypeDeclaration(refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver));\n                }\n                //System.out.println(\"LAMBDA \" + node.getParentNode());\n                //System.out.println(\"LAMBDA CLASS \" + node.getParentNode().getClass().getCanonicalName());\n                //TypeUsage typeOfMethod = new JavaParserFacade(typeSolver).getType(node.getParentNode());\n                //throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n            } else {\n                throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n            }\n        } else if (node instanceof VariableDeclarator) {\n            if (node.getParentNode() instanceof FieldDeclaration) {\n                FieldDeclaration parent = (FieldDeclaration) node.getParentNode();\n                return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n            } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n                VariableDeclarationExpr parent = (VariableDeclarationExpr) node.getParentNode();\n                return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n            } else {\n                throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n            }\n        } else if (node instanceof Parameter) {\n            Parameter parameter = (Parameter)node;\n            if (parameter.getType() instanceof UnknownType){\n                throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n            }\n            return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n        } else if (node instanceof FieldAccessExpr) {\n            FieldAccessExpr fieldAccessExpr = (FieldAccessExpr) node;\n            Optional<Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n            if (value.isPresent()) {\n                return value.get().getUsage();\n            } else {\n                throw new UnsolvedSymbolException(null, fieldAccessExpr.getField());\n            }\n        } else if (node instanceof ObjectCreationExpr) {\n            ObjectCreationExpr objectCreationExpr = (ObjectCreationExpr)node;\n            TypeUsage typeUsage = new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n            return typeUsage;\n        } else {\n            throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n        }\n    }",
        "diffSourceCode": "-   93:     /**\n-   94:      * Should return more like a TypeApplication: a TypeDeclaration and possible parameters or array modifiers.\n-   95:      * @return\n-   96:      */\n-   97:     public TypeUsage getType(Node node, boolean solveLambdas) {\n-   98:         if (node == null) throw new IllegalArgumentException();\n-   99:         if (node instanceof NameExpr) {\n-  100:             NameExpr nameExpr = (NameExpr) node;\n-  101:             logger.finest(\"getType on name expr \" + node);\n-  102:             return new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr).get().getUsage();\n-  103:         } else if (node instanceof MethodCallExpr) {\n-  104:             logger.finest(\"getType on method call \" + node);\n-  105:             // first solve the method\n-  106:             MethodUsage ref = new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n-  107:             logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n-  108:             logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n-  109:             return ref.returnType();\n-  110:             // the type is the return type of the method\n-  111:         } else if (node instanceof LambdaExpr) {\n-  112:             if (node.getParentNode() instanceof MethodCallExpr) {\n-  113:                 MethodCallExpr callExpr = (MethodCallExpr) node.getParentNode();\n-  114:                 int pos = JavaParserSymbolDeclaration.getParamPos(node);\n-  115:                 SymbolReference<MethodDeclaration> refMethod = new JavaParserFacade(typeSolver).solve(callExpr);\n-  116:                 if (!refMethod.isSolved()) {\n-  117:                     throw new UnsolvedSymbolException(null, callExpr.getName());\n-  118:                 }\n-  119:                 logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n-  120:                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n-  121:                 if (solveLambdas) {\n-  122:                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver).getUsage(node);\n-  123:                 } else {\n-  124:                     return new TypeUsageOfTypeDeclaration(refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver));\n-  125:                 }\n-  126:                 //System.out.println(\"LAMBDA \" + node.getParentNode());\n-  127:                 //System.out.println(\"LAMBDA CLASS \" + node.getParentNode().getClass().getCanonicalName());\n-  128:                 //TypeUsage typeOfMethod = new JavaParserFacade(typeSolver).getType(node.getParentNode());\n-  129:                 //throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n-  130:             } else {\n-  131:                 throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n-  132:             }\n-  133:         } else if (node instanceof VariableDeclarator) {\n-  134:             if (node.getParentNode() instanceof FieldDeclaration) {\n-  135:                 FieldDeclaration parent = (FieldDeclaration) node.getParentNode();\n-  136:                 return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n-  137:             } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n-  138:                 VariableDeclarationExpr parent = (VariableDeclarationExpr) node.getParentNode();\n-  139:                 return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n-  140:             } else {\n-  141:                 throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n-  142:             }\n-  143:         } else if (node instanceof Parameter) {\n-  144:             Parameter parameter = (Parameter)node;\n-  145:             if (parameter.getType() instanceof UnknownType){\n-  146:                 throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n-  147:             }\n-  148:             return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n-  149:         } else if (node instanceof FieldAccessExpr) {\n-  150:             FieldAccessExpr fieldAccessExpr = (FieldAccessExpr) node;\n-  151:             Optional<Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n-  152:             if (value.isPresent()) {\n-  153:                 return value.get().getUsage();\n-  154:             } else {\n-  155:                 throw new UnsolvedSymbolException(null, fieldAccessExpr.getField());\n-  156:             }\n-  157:         } else if (node instanceof ObjectCreationExpr) {\n-  158:             ObjectCreationExpr objectCreationExpr = (ObjectCreationExpr)node;\n-  159:             TypeUsage typeUsage = new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n-  160:             return typeUsage;\n-  161:         } else {\n-  162:             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n-  163:         }\n-  164:     }\n-  165: \n-  166:     public TypeUsage convertToUsage(Type type, Node context) {\n-  167:         if (type instanceof UnknownType){\n-  168:             throw new IllegalArgumentException(\"Unknown type\");\n-  169:         }\n-  170:         return convertToUsage(type, JavaParserFactory.getContext(context));\n-  171:     }\n-  172: \n-  173:     public TypeUsage convertToUsage(Type type, Context context) {\n-  174:         if (type instanceof ReferenceType) {\n-  175:             ReferenceType referenceType = (ReferenceType) type;\n-  176:             // TODO consider array modifiers\n-  177:             return convertToUsage(referenceType.getType(), context);\n-  178:         } else if (type instanceof ClassOrInterfaceType) {\n-  179:             ClassOrInterfaceType classOrInterfaceType = (ClassOrInterfaceType)type;\n-  180:             SymbolReference<TypeDeclaration> ref = context.solveType(classOrInterfaceType.getName(), typeSolver);\n-  181:             if (!ref.isSolved()) {\n-  182:                 throw new UnsolvedSymbolException(null, classOrInterfaceType.getName());\n+   93:         }\n+   94:         return res;\n+   95:     }\n+   96: \n+   97:     public TypeUsage getType(Node node) {\n+   98:         return getType(node, true);\n+   99:     }\n+  100: \n+  101:     private Map<Node, TypeUsage> cacheWithLambadsSolved = new WeakHashMap<>();\n+  102:     private Map<Node, TypeUsage> cacheWithoutLambadsSolved = new WeakHashMap<>();\n+  103: \n+  104:     private static Map<TypeSolver, JavaParserFacade> instances = new HashMap<>();\n+  105: \n+  106:     public TypeUsage getType(Node node, boolean solveLambdas) {\n+  107:         if (solveLambdas){\n+  108:             if (!cacheWithLambadsSolved.containsKey(node)){\n+  109:                 cacheWithLambadsSolved.put(node, getTypeConcrete(node, solveLambdas));\n+  110:             }\n+  111:             return cacheWithLambadsSolved.get(node);\n+  112:         } else {\n+  113:             if (!cacheWithoutLambadsSolved.containsKey(node)){\n+  114:                 cacheWithoutLambadsSolved.put(node, getTypeConcrete(node, solveLambdas));\n+  115:             }\n+  116:             return cacheWithoutLambadsSolved.get(node);\n+  117:         }\n+  118:     }\n+  119: \n+  120:     /**\n+  121:      * Should return more like a TypeApplication: a TypeDeclaration and possible parameters or array modifiers.\n+  122:      * @return\n+  123:      */\n+  124:     private TypeUsage getTypeConcrete(Node node, boolean solveLambdas) {\n+  125:         if (node == null) throw new IllegalArgumentException();\n+  126:         if (node instanceof NameExpr) {\n+  127:             NameExpr nameExpr = (NameExpr) node;\n+  128:             logger.finest(\"getType on name expr \" + node);\n+  129:             return new SymbolSolver(typeSolver).solveSymbolAsValue(nameExpr.getName(), nameExpr).get().getUsage();\n+  130:         } else if (node instanceof MethodCallExpr) {\n+  131:             logger.finest(\"getType on method call \" + node);\n+  132:             // first solve the method\n+  133:             MethodUsage ref = new JavaParserFacade(typeSolver).solveMethodAsUsage((MethodCallExpr) node);\n+  134:             logger.finest(\"getType on method call \" + node + \" resolved to \" + ref);\n+  135:             logger.finest(\"getType on method call \" + node + \" return type is \" + ref.returnType());\n+  136:             return ref.returnType();\n+  137:             // the type is the return type of the method\n+  138:         } else if (node instanceof LambdaExpr) {\n+  139:             if (node.getParentNode() instanceof MethodCallExpr) {\n+  140:                 MethodCallExpr callExpr = (MethodCallExpr) node.getParentNode();\n+  141:                 int pos = JavaParserSymbolDeclaration.getParamPos(node);\n+  142:                 SymbolReference<MethodDeclaration> refMethod = new JavaParserFacade(typeSolver).solve(callExpr);\n+  143:                 if (!refMethod.isSolved()) {\n+  144:                     throw new UnsolvedSymbolException(null, callExpr.getName());\n+  145:                 }\n+  146:                 logger.finest(\"getType on lambda expr \" + refMethod.getCorrespondingDeclaration().getName());\n+  147:                 //logger.finest(\"Method param \" + refMethod.getCorrespondingDeclaration().getParam(pos));\n+  148:                 if (solveLambdas) {\n+  149:                     return refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver).getUsage(node);\n+  150:                 } else {\n+  151:                     return new TypeUsageOfTypeDeclaration(refMethod.getCorrespondingDeclaration().getParam(pos).getType(typeSolver));\n+  152:                 }\n+  153:                 //System.out.println(\"LAMBDA \" + node.getParentNode());\n+  154:                 //System.out.println(\"LAMBDA CLASS \" + node.getParentNode().getClass().getCanonicalName());\n+  155:                 //TypeUsage typeOfMethod = new JavaParserFacade(typeSolver).getType(node.getParentNode());\n+  156:                 //throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n+  157:             } else {\n+  158:                 throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n+  159:             }\n+  160:         } else if (node instanceof VariableDeclarator) {\n+  161:             if (node.getParentNode() instanceof FieldDeclaration) {\n+  162:                 FieldDeclaration parent = (FieldDeclaration) node.getParentNode();\n+  163:                 return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n+  164:             } else if (node.getParentNode() instanceof VariableDeclarationExpr) {\n+  165:                 VariableDeclarationExpr parent = (VariableDeclarationExpr) node.getParentNode();\n+  166:                 return new JavaParserFacade(typeSolver).convertToUsage(parent.getType(), parent);\n+  167:             } else {\n+  168:                 throw new UnsupportedOperationException(node.getParentNode().getClass().getCanonicalName());\n+  169:             }\n+  170:         } else if (node instanceof Parameter) {\n+  171:             Parameter parameter = (Parameter)node;\n+  172:             if (parameter.getType() instanceof UnknownType){\n+  173:                 throw new IllegalStateException(\"Parameter has unknown type: \" + parameter);\n+  174:             }\n+  175:             return new JavaParserFacade(typeSolver).convertToUsage(parameter.getType(), parameter);\n+  176:         } else if (node instanceof FieldAccessExpr) {\n+  177:             FieldAccessExpr fieldAccessExpr = (FieldAccessExpr) node;\n+  178:             Optional<Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(fieldAccessExpr.getField(), fieldAccessExpr);\n+  179:             if (value.isPresent()) {\n+  180:                 return value.get().getUsage();\n+  181:             } else {\n+  182:                 throw new UnsolvedSymbolException(null, fieldAccessExpr.getField());\n   183:             }\n-  184:             TypeDeclaration typeDeclaration = ref.getCorrespondingDeclaration();\n-  185:             List<TypeUsage> typeParameters = Collections.emptyList();\n-  186:             if (classOrInterfaceType.getTypeArgs() != null) {\n-  187:                 typeParameters = classOrInterfaceType.getTypeArgs().stream().map((pt)->convertToUsage(pt, context)).collect(Collectors.toList());\n-  188:             }\n-  189:             return new TypeUsageOfTypeDeclaration(typeDeclaration, typeParameters);\n-  190:         } else {\n-  191:             throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n+  184:         } else if (node instanceof ObjectCreationExpr) {\n+  185:             ObjectCreationExpr objectCreationExpr = (ObjectCreationExpr)node;\n+  186:             TypeUsage typeUsage = new JavaParserFacade(typeSolver).convertToUsage(objectCreationExpr.getType(), node);\n+  187:             return typeUsage;\n+  188:         } else {\n+  189:             throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n+  190:         }\n+  191:     }\n",
        "uniqueId": "627b56302d259409e9bc50b20d77803484f18b5c_93_164_120_191_106_118",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 61,
                "covered": 238
            },
            "BRANCH": {
                "missed": 8,
                "covered": 22
            },
            "LINE": {
                "missed": 7,
                "covered": 40
            },
            "COMPLEXITY": {
                "missed": 8,
                "covered": 8
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 11
    },
    {
        "type": "Move Method",
        "description": "Move Method\tpackage basicGrammarCompiles_languageLevelValidation_permitted(languageLevel ParserConfiguration.LanguageLevel) : void from class com.github.javaparser.ast.body.RecordDeclarationTest to package basicGrammarCompiles_languageLevelValidation_permitted(languageLevel ParserConfiguration.LanguageLevel) : void from class com.github.javaparser.ast.body.RecordDeclarationTest.LanguageLevels",
        "diffLocations": [
            {
                "filePath": "javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/RecordDeclarationTest.java",
                "startLine": 34,
                "endLine": 39,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/RecordDeclarationTest.java",
                "startLine": 37,
                "endLine": 42,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "@ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_14_PREVIEW\", \"JAVA_15_PREVIEW\", \"JAVA_16\", \"JAVA_16_PREVIEW\"})\n    void basicGrammarCompiles_languageLevelValidation_permitted(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(languageLevel, s);\n    }",
        "filePathBefore": "javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/RecordDeclarationTest.java",
        "isPureRefactoring": true,
        "commitId": "9e55bc54539d393e1948c8d4a89b1511ed379fad",
        "packageNameBefore": "com.github.javaparser.ast.body",
        "classNameBefore": "com.github.javaparser.ast.body.RecordDeclarationTest",
        "methodNameBefore": "com.github.javaparser.ast.body.RecordDeclarationTest#basicGrammarCompiles_languageLevelValidation_permitted",
        "classSignatureBefore": "public class RecordDeclarationTest ",
        "methodNameBeforeSet": [
            "com.github.javaparser.ast.body.RecordDeclarationTest#basicGrammarCompiles_languageLevelValidation_permitted"
        ],
        "classNameBeforeSet": [
            "com.github.javaparser.ast.body.RecordDeclarationTest"
        ],
        "classSignatureBeforeSet": [
            "public class RecordDeclarationTest "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "package com.github.javaparser.ast.body;\n\nimport com.github.javaparser.ParserConfiguration;\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.Modifier;\nimport com.github.javaparser.ast.NodeList;\nimport com.github.javaparser.ast.expr.ObjectCreationExpr;\nimport com.github.javaparser.utils.TestParser;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.EnumSource;\nimport org.opentest4j.AssertionFailedError;\n\nimport java.util.List;\n\nimport static com.github.javaparser.utils.TestUtils.assertEqualsStringIgnoringEol;\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\npublic class RecordDeclarationTest {\n\n    @ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_13\", \"JAVA_13_PREVIEW\", \"JAVA_14\", \"JAVA_15\"})\n    void basicGrammarCompiles_languageLevelValidation_forbidden(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"record Point(int x, int y) { }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = TestParser.parseCompilationUnit(languageLevel, s);\n        });\n    }\n\n    @ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_14_PREVIEW\", \"JAVA_15_PREVIEW\", \"JAVA_16\", \"JAVA_16_PREVIEW\"})\n    void basicGrammarCompiles_languageLevelValidation_permitted(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(languageLevel, s);\n    }\n\n    @ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_14_PREVIEW\", \"JAVA_15_PREVIEW\", \"JAVA_16\", \"JAVA_16_PREVIEW\"})\n    void languageLevelValidation_recordAsTypeIdentifier_permitted(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"class record {}\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = TestParser.parseCompilationUnit(languageLevel, s);\n        });\n    }\n\n    @ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_13\", \"JAVA_13_PREVIEW\", \"JAVA_14\", \"JAVA_15\"})\n    void languageLevelValidation_recordAsTypeIdentifier_forbidden(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"class record {}\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(languageLevel, s);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Description\n     */\n    @Test\n    void basicGrammarCompiles() {\n        String s = \"record Point(int x, int y) { }\";\n        assertOneRecordDeclaration(TestParser.parseCompilationUnit(s));\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Description\n     */\n    @Test\n    void basicGrammar() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        RecordDeclaration recordDeclaration = cu.findAll(RecordDeclaration.class).get(0);\n\n        assertTrue(recordDeclaration.isRecordDeclaration());\n        assertTrue(recordDeclaration.getImplementedTypes().isEmpty());\n        assertTrue(recordDeclaration.getTypeParameters().isEmpty());\n        assertTrue(recordDeclaration.getFullyQualifiedName().isPresent());\n        assertEquals(\"Point\", recordDeclaration.getFullyQualifiedName().get());\n        assertTrue(recordDeclaration.isRecordDeclaration());\n\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"x\", parameter0.getNameAsString());\n        assertEquals(\"int\", parameter0.getTypeAsString());\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"y\", parameter1.getNameAsString());\n        assertEquals(\"int\", parameter1.getTypeAsString());\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Description\n     */\n    @Test\n    void basicRecordPrints() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        String expected = \"\" +\n                \"record Point(int x, int y) {\\n\" +\n                \"}\\n\" +\n                \"\";\n        assertEqualsStringIgnoringEol(expected, cu.toString());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-record\n     */\n    @Test\n    void record_cannotExtend() {\n        String s = \"record Point(int x, int y) extends OtherThing { }\";\n        assertCompilationFails(s);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_cannotBeAbstract() {\n        String s = \"abstract record Point(int x, int y) { }\";\n        assertCompilationFails(s);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_mayImplementInterfaces() {\n        String s = \"record Point(int x, int y) implements OtherInterface { }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n\n        assertOneRecordDeclaration(cu);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_mayBeStatic() {\n        String s = \"static record Point(int x, int y) { }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void recordWithVarArgs() {\n        String s = \"record R(T1 c1, Tn... cn){ }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"c1\", parameter0.getNameAsString());\n        assertEquals(\"T1\", parameter0.getTypeAsString());\n        assertFalse(parameter0.isVarArgs());\n\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"cn\", parameter1.getNameAsString());\n        assertEquals(\"Tn\", parameter1.getTypeAsString());\n        assertTrue(parameter1.isVarArgs());\n    }\n\n    @Test\n    void recordWithAnnotationedParameters() {\n        String s = \"record Card(@MyAnno Rank rank, @MyAnno Suit suit) { }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"rank\", parameter0.getNameAsString());\n        assertEquals(\"Rank\", parameter0.getTypeAsString());\n        assertEquals(1, parameter0.getAnnotations().size());\n\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"suit\", parameter1.getNameAsString());\n        assertEquals(\"Suit\", parameter1.getTypeAsString());\n        assertEquals(1, parameter1.getAnnotations().size());\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    @Test\n    void record_emptyMembers() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    @Test\n    void record_permitStaticFields() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    static int z;\\n\" +\n                \"\\n\" +\n                \"    static {\\n\" +\n                \"        int z = 10;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_permitStaticMethods() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    static public int abc() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_permitMethods() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    public String xyz() {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_mustNotAllowNonStaticFields() {\n        String s = \"record Point(int x, int y) { int z; }\";\n        assertCompilationFails(s);\n    }\n\n    @Test\n    void record_mustAllowStaticFields() {\n        String s = \"record Point(int x, int y) { static int z; }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_isImplicitlyFinal() {\n        String s = \"record Point(int x, int y) { static int z; }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        RecordDeclaration recordDeclaration = cu.findFirst(RecordDeclaration.class).get();\n        assertFalse(recordDeclaration.hasModifier(Modifier.Keyword.FINAL));\n        assertTrue(recordDeclaration.isFinal(), \"Records are implicitly final.\");\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_canHaveGenerics() {\n        String s = \"record Point <T> (T x, int y) { }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        RecordDeclaration recordDeclaration = cu.findFirst(RecordDeclaration.class).get();\n        assertFalse(recordDeclaration.getTypeParameters().isEmpty());\n        assertEquals(\"T\", recordDeclaration.getTypeParameters().get(0).getNameAsString());\n    }\n\n\n    @Test\n    void record_mustNotAllowMismatchedComponentAccessorReturnType() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public String x() {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \"}\";\n        assertCompilationFails(s);\n    }\n\n    @Test\n    void record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public String x(int a) {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \"}\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod2() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public int x(int a) {\\n\" +\n                \"        return 10;\\n\" +\n                \"    }\\n\" +\n                \"}\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_allowComponentAccessorWithMatchingType() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return 10;\\n\" +\n                \"    }\\n\" +\n                \"}\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_allowNestedWithinClass() {\n        String s = \"\\n\" +\n                \"class X {\\n\" +\n                \"    record Point(int x, int y) {\\n\" +\n                \"    }\\n\" +\n                \"}\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_componentsAreImplicitlyFinal() {\n        String s = \"record Point(int x, int y) { }\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        RecordDeclaration recordDeclaration = cu.findAll(RecordDeclaration.class).get(0);\n\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertTrue(parameters.get(0).isFinal());\n        assertTrue(parameters.get(1).isFinal());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_allowClassWithinRecord() {\n        String s = \"\\n\" +\n                \"record Point(int x, int y) {\\n\" +\n                \"    class X {\\n\" +\n                \"    }\\n\" +\n                \"}\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        BodyDeclaration<?> member = recordDeclaration.getMember(0);\n\n        assertTrue(member.isClassOrInterfaceDeclaration());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_allowNestedWithinInterface() {\n        String s = \"\\n\" +\n                \"interface X {\\n\" +\n                \"    record Point(int x, int y) {\\n\" +\n                \"    }\\n\" +\n                \"}\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_allowNestedWithinEnum() {\n        String s = \"\\n\" +\n                \"enum ABC {\\n\" +\n                \"    ABC;\\n\" +\n                \"    \\n\" +\n                \"    record Point(int x, int y) {\\n\" +\n                \"    }\\n\" +\n                \"}\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_allowNestedMultiple() {\n        String s = \"\\n\" +\n                \"interface Y {\\n\" +\n                \"    class X {\\n\" +\n                \"        record Point(int x, int y) {\\n\" +\n                \"        }\\n\" +\n                \"    }\\n\" +\n                \"}\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_allowNestedMultiple2() {\n        String s = \"\\n\" +\n                \"interface Y {\\n\" +\n                \"    class X {\\n\" +\n                \"        record Point(int x, int y) {\\n\" +\n                \"        }\\n\" +\n                \"        record PointB(int x, int y) {\\n\" +\n                \"        }\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    record PointC(int x, int y) {\\n\" +\n                \"    }\\n\" +\n                \"}\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(3, recordDeclarations.size());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_topLevelRecordsAreNotStatic() {\n        String s = \"record Point(int x, int y) { }\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        RecordDeclaration recordDeclaration = cu.findAll(RecordDeclaration.class).get(0);\n        assertFalse(recordDeclaration.hasModifier(Modifier.Keyword.STATIC));\n        assertFalse(recordDeclaration.isStatic(), \"Top level Records are NOT implicitly static.\");\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_nestedRecordsAreImplicitlyStatic() {\n        String s = \"\\n\" +\n                \"class X {\\n\" +\n                \"    record Point(int x, int y) {\\n\" +\n                \"    }\\n\" +\n                \"}\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        RecordDeclaration recordDeclaration = cu.findAll(RecordDeclaration.class).get(0);\n        assertFalse(recordDeclaration.hasModifier(Modifier.Keyword.STATIC));\n        assertTrue(recordDeclaration.isStatic(), \"Nested Records are implicitly static.\");\n\n    }\n\n\n    @Test\n    void record_canBeCreatedUsingKeywordNew() {\n        String s = \"\\n\" +\n                \"\\n\" +\n                \"record Point(int x, int y) {\\n\" +\n                \"}\\n\" +\n                \"\\n\" +\n                \"class X {\\n\" +\n                \"    public static void main(String[] args) {\\n\" +\n                \"        new Point(10, 3);\\n\" +\n                \"    }\\n\" +\n                \"}\\n\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        ClassOrInterfaceDeclaration coid = cu.findAll(ClassOrInterfaceDeclaration.class).get(0);\n        List<ObjectCreationExpr> objectCreationExprs = coid.findAll(ObjectCreationExpr.class);\n\n        assertEquals(1, objectCreationExprs.size());\n        ObjectCreationExpr objectCreationExpr = objectCreationExprs.get(0);\n        assertEquals(\"Point\", objectCreationExpr.getTypeAsString());\n    }\n\n    /**\n     * Note the Record Declaration Constructor does not include parameters.\n     * (parameters are, instead, included within the record declaration)\n     * <p>\n     * https://bugs.openjdk.java.net/browse/JDK-8222777\n     */\n    @Test\n    void recordDeclarationFromTheJDK8222777() {\n        CompilationUnit cu = TestParser.parseCompilationUnit(\"\" +\n                \"public record Range(int lo, int hi) {\\n\" +\n                \"\\n\" +\n                \"  public Range {\\n\" +\n                \"    if (lo > hi)  /* referring here to the implicit constructor parameters */\\n\" +\n                \"      throw new IllegalArgumentException(String.format(\\\"(%d,%d)\\\", lo, hi));\\n\" +\n                \"  }\\n\" +\n                \"}\"\n        );\n\n        RecordDeclaration recordDeclaration = cu.findFirst(RecordDeclaration.class).get();\n        assertThat(recordDeclaration.getNameAsString()).isEqualTo(\"Range\");\n        assertThat(recordDeclaration.getModifiers()).containsExactly(Modifier.publicModifier());\n        // test parameters\n        // get constructor\n        // test parameters (none)\n    }\n\n    @Test\n    void recordDeclaration_exampleFromJls_8_10_4_1_normalCanonicalConstructors() {\n        CompilationUnit cu = TestParser.parseCompilationUnit(\"\" +\n                \"import java.lang.annotation.Target;\\n\" +\n                \"import java.lang.annotation.ElementType;\\n\" +\n                \"\\n\" +\n                \"@interface Foo {}\\n\" +\n                \"@interface Bar {}\\n\" +\n                \"\\n\" +\n                \"record Person(@Foo String name) {\\n\" +\n                \"    Person(String name2) {\\n\" +\n                \"    }\\n\" +\n                \"}\"\n        );\n\n        RecordDeclaration recordDeclaration = cu.findFirst(RecordDeclaration.class).get();\n        assertThat(recordDeclaration.getNameAsString()).isEqualTo(\"Person\");\n        assertThat(recordDeclaration.getModifiers()).isEmpty();\n\n        assertThat(recordDeclaration.getConstructors()).hasSize(1);\n        assertThat(recordDeclaration.getCompactConstructors()).hasSize(0);\n\n        // test parameters\n        // get constructor\n        // test parameters (none)\n\n    }\n\n    @Test\n    void compactConstructor_exampleFromJls_8_10_4_2_compactConstructors() {\n        CompilationUnit cu = TestParser.parseCompilationUnit(\"\" +\n                \"record Rational(int num, int denom) {\\n\" +\n                \"    private static int gcd(int a, int b) {\\n\" +\n                \"        if (b == 0) return Math.abs(a);\\n\" +\n                \"        else return gcd(b, a % b);\\n\" +\n                \"    }\\n\" +\n                \"   \\n\" +\n                \"    Rational {\\n\" +\n                \"        int gcd = gcd(num, denom);\\n\" +\n                \"        num    /= gcd;\\n\" +\n                \"        denom  /= gcd;\\n\" +\n                \"    }\\n\" +\n                \"}\\n\"\n        );\n\n        RecordDeclaration recordDeclaration = cu.findFirst(RecordDeclaration.class).get();\n        assertThat(recordDeclaration.getNameAsString()).isEqualTo(\"Rational\");\n        assertThat(recordDeclaration.getModifiers()).isEmpty();\n\n        assertThat(recordDeclaration.getConstructors()).hasSize(0);\n        assertThat(recordDeclaration.getCompactConstructors()).hasSize(1);\n\n        // test parameters\n        // get constructor\n        // test parameters (none)\n\n    }\n\n    @Test\n    void nonCompactConstructor_exampleFromJls_8_10_4_2_compactConstructors() {\n        CompilationUnit cu = TestParser.parseCompilationUnit(\"\" +\n                \"record Rational(int num, int denom) {\\n\" +\n                \"    private static int gcd(int a, int b) {\\n\" +\n                \"        if (b == 0) return Math.abs(a);\\n\" +\n                \"        else return gcd(b, a % b);\\n\" +\n                \"    }\\n\" +\n                \"   \\n\" +\n                \"    Rational(int num, int demon) {\\n\" +\n                \"        int gcd = gcd(num, denom);\\n\" +\n                \"        num    /= gcd;\\n\" +\n                \"        denom  /= gcd;\\n\" +\n                \"        this.num   = num;\\n\" +\n                \"        this.denom = denom;\\n\" +\n                \"    }\\n\" +\n                \"}\\n\"\n        );\n\n        RecordDeclaration recordDeclaration = cu.findFirst(RecordDeclaration.class).get();\n        assertThat(recordDeclaration.getNameAsString()).isEqualTo(\"Rational\");\n        assertThat(recordDeclaration.getModifiers()).isEmpty();\n\n        assertThat(recordDeclaration.getConstructors()).hasSize(1);\n        assertThat(recordDeclaration.getCompactConstructors()).hasSize(0);\n\n        // test parameters\n        // get constructor\n        // test parameters (none)\n\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395\n     */\n    @Test\n    void localRecords() {\n        CompilationUnit cu = TestParser.parseCompilationUnit(\"\" +\n                \"class Scratch {\\n\" +\n                \"    List<Merchant> findTopMerchants(List<Merchant> merchants, int month) {\\n\" +\n                \"        // Local record\\n\" +\n                \"        record MerchantSales(Merchant merchant, double sales) {}\\n\" +\n                \"\\n\" +\n                \"        return merchants.stream()\\n\" +\n                \"                .map(merchant -> new MerchantSales(merchant, computeSales(merchant, month)))\\n\" +\n                \"                .sorted((m1, m2) -> Double.compare(m2.sales(), m1.sales()))\\n\" +\n                \"                .map(MerchantSales::merchant)\\n\" +\n                \"                .collect(toList());\\n\" +\n                \"    }\\n\" +\n                \"}\\n\"\n        );\n\n        RecordDeclaration recordDeclaration = cu.findFirst(RecordDeclaration.class).get();\n        assertThat(recordDeclaration.getNameAsString()).isEqualTo(\"MerchantSales\");\n\n    }\n\n    private void assertCompilationFails(String s) {\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        });\n    }\n\n    private void assertOneRecordDeclaration(CompilationUnit cu) {\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n}\n",
        "filePathAfter": "javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/RecordDeclarationTest.java",
        "sourceCodeAfterForWhole": "package com.github.javaparser.ast.body;\n\nimport com.github.javaparser.ParserConfiguration;\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.Modifier;\nimport com.github.javaparser.ast.NodeList;\nimport com.github.javaparser.ast.expr.ObjectCreationExpr;\nimport com.github.javaparser.utils.TestParser;\nimport org.junit.jupiter.api.Nested;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.EnumSource;\nimport org.opentest4j.AssertionFailedError;\n\nimport java.util.List;\n\nimport static com.github.javaparser.utils.TestUtils.assertEqualsStringIgnoringEol;\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\npublic class RecordDeclarationTest {\n\n    @Nested\n    class LanguageLevels {\n        @ParameterizedTest\n        @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_13\", \"JAVA_13_PREVIEW\", \"JAVA_14\", \"JAVA_15\"})\n        void basicGrammarCompiles_languageLevelValidation_forbidden(ParserConfiguration.LanguageLevel languageLevel) {\n            String s = \"record Point(int x, int y) { }\";\n            assertThrows(AssertionFailedError.class, () -> {\n                CompilationUnit cu = TestParser.parseCompilationUnit(languageLevel, s);\n            });\n        }\n\n        @ParameterizedTest\n        @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_14_PREVIEW\", \"JAVA_15_PREVIEW\", \"JAVA_16\", \"JAVA_16_PREVIEW\"})\n        void basicGrammarCompiles_languageLevelValidation_permitted(ParserConfiguration.LanguageLevel languageLevel) {\n            String s = \"record Point(int x, int y) { }\";\n            CompilationUnit cu = TestParser.parseCompilationUnit(languageLevel, s);\n        }\n\n        @ParameterizedTest\n        @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_14_PREVIEW\", \"JAVA_15_PREVIEW\", \"JAVA_16\", \"JAVA_16_PREVIEW\"})\n        void languageLevelValidation_recordAsTypeIdentifier_permitted(ParserConfiguration.LanguageLevel languageLevel) {\n            String s = \"class record {}\";\n            assertThrows(AssertionFailedError.class, () -> {\n                CompilationUnit cu = TestParser.parseCompilationUnit(languageLevel, s);\n            });\n        }\n\n        @ParameterizedTest\n        @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_13\", \"JAVA_13_PREVIEW\", \"JAVA_14\", \"JAVA_15\"})\n        void languageLevelValidation_recordAsTypeIdentifier_forbidden(ParserConfiguration.LanguageLevel languageLevel) {\n            String s = \"class record {}\";\n            CompilationUnit cu = TestParser.parseCompilationUnit(languageLevel, s);\n        }\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Description\n     */\n    @Test\n    void basicGrammarCompiles() {\n        String s = \"record Point(int x, int y) { }\";\n        assertOneRecordDeclaration(TestParser.parseCompilationUnit(s));\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Description\n     */\n    @Test\n    void basicGrammar() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        RecordDeclaration recordDeclaration = cu.findAll(RecordDeclaration.class).get(0);\n\n        assertTrue(recordDeclaration.isRecordDeclaration());\n        assertTrue(recordDeclaration.getImplementedTypes().isEmpty());\n        assertTrue(recordDeclaration.getTypeParameters().isEmpty());\n        assertTrue(recordDeclaration.getFullyQualifiedName().isPresent());\n        assertEquals(\"Point\", recordDeclaration.getFullyQualifiedName().get());\n        assertTrue(recordDeclaration.isRecordDeclaration());\n\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"x\", parameter0.getNameAsString());\n        assertEquals(\"int\", parameter0.getTypeAsString());\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"y\", parameter1.getNameAsString());\n        assertEquals(\"int\", parameter1.getTypeAsString());\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Description\n     */\n    @Test\n    void basicRecordPrints() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        String expected = \"\" +\n                \"record Point(int x, int y) {\\n\" +\n                \"}\\n\" +\n                \"\";\n        assertEqualsStringIgnoringEol(expected, cu.toString());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-record\n     */\n    @Test\n    void record_cannotExtend() {\n        String s = \"record Point(int x, int y) extends OtherThing { }\";\n        assertCompilationFails(s);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_cannotBeAbstract() {\n        String s = \"abstract record Point(int x, int y) { }\";\n        assertCompilationFails(s);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_mayImplementInterfaces() {\n        String s = \"record Point(int x, int y) implements OtherInterface { }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n\n        assertOneRecordDeclaration(cu);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_mayBeStatic() {\n        String s = \"static record Point(int x, int y) { }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void recordWithVarArgs() {\n        String s = \"record R(T1 c1, Tn... cn){ }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"c1\", parameter0.getNameAsString());\n        assertEquals(\"T1\", parameter0.getTypeAsString());\n        assertFalse(parameter0.isVarArgs());\n\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"cn\", parameter1.getNameAsString());\n        assertEquals(\"Tn\", parameter1.getTypeAsString());\n        assertTrue(parameter1.isVarArgs());\n    }\n\n    @Test\n    void recordWithAnnotationedParameters() {\n        String s = \"record Card(@MyAnno Rank rank, @MyAnno Suit suit) { }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"rank\", parameter0.getNameAsString());\n        assertEquals(\"Rank\", parameter0.getTypeAsString());\n        assertEquals(1, parameter0.getAnnotations().size());\n\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"suit\", parameter1.getNameAsString());\n        assertEquals(\"Suit\", parameter1.getTypeAsString());\n        assertEquals(1, parameter1.getAnnotations().size());\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    @Test\n    void record_emptyMembers() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    @Test\n    void record_permitStaticMethods() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    static public int abc() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_permitMethods() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    public String xyz() {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_forbidNonStaticFields() {\n        String s = \"record Point(int x, int y) { int z; }\";\n        assertCompilationFails(s);\n    }\n\n    @Test\n    void record_permitStaticFields() {\n        String s = \"record Point(int x, int y) { static int z; }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_permitStaticFields2() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    static int z;\\n\" +\n                \"\\n\" +\n                \"    static {\\n\" +\n                \"        int z = 10;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_isImplicitlyFinal() {\n        String s = \"record Point(int x, int y) { static int z; }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        RecordDeclaration recordDeclaration = cu.findFirst(RecordDeclaration.class).get();\n        assertFalse(recordDeclaration.hasModifier(Modifier.Keyword.FINAL));\n        assertTrue(recordDeclaration.isFinal(), \"Records are implicitly final.\");\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_isImplicitlyFinalWithoutExplicit() {\n        String s = \"record Point(int x, int y) { static int z; }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        RecordDeclaration recordDeclaration = cu.findFirst(RecordDeclaration.class).get();\n        assertFalse(recordDeclaration.hasModifier(Modifier.Keyword.FINAL));\n        assertTrue(recordDeclaration.isFinal(), \"Records are implicitly final.\");\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_canHaveGenerics() {\n        String s = \"record Point <T> (T x, int y) { }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        RecordDeclaration recordDeclaration = cu.findFirst(RecordDeclaration.class).get();\n        assertFalse(recordDeclaration.getTypeParameters().isEmpty());\n        assertEquals(\"T\", recordDeclaration.getTypeParameters().get(0).getNameAsString());\n    }\n\n\n    @Test\n    void record_mustNotAllowMismatchedComponentAccessorReturnType() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public String x() {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \"}\";\n        assertCompilationFails(s);\n    }\n\n    @Test\n    void record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public String x(int a) {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \"}\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod2() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public int x(int a) {\\n\" +\n                \"        return 10;\\n\" +\n                \"    }\\n\" +\n                \"}\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_allowComponentAccessorWithMatchingType() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return 10;\\n\" +\n                \"    }\\n\" +\n                \"}\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_allowNestedWithinClass() {\n        String s = \"\\n\" +\n                \"class X {\\n\" +\n                \"    record Point(int x, int y) {\\n\" +\n                \"    }\\n\" +\n                \"}\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_componentsAreImplicitlyFinal() {\n        String s = \"record Point(int x, int y) { }\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        RecordDeclaration recordDeclaration = cu.findAll(RecordDeclaration.class).get(0);\n\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertTrue(parameters.get(0).isFinal());\n        assertTrue(parameters.get(1).isFinal());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_allowClassWithinRecord() {\n        String s = \"\\n\" +\n                \"record Point(int x, int y) {\\n\" +\n                \"    class X {\\n\" +\n                \"    }\\n\" +\n                \"}\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        BodyDeclaration<?> member = recordDeclaration.getMember(0);\n\n        assertTrue(member.isClassOrInterfaceDeclaration());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_allowNestedWithinInterface() {\n        String s = \"\\n\" +\n                \"interface X {\\n\" +\n                \"    record Point(int x, int y) {\\n\" +\n                \"    }\\n\" +\n                \"}\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_allowNestedWithinEnum() {\n        String s = \"\\n\" +\n                \"enum ABC {\\n\" +\n                \"    ABC;\\n\" +\n                \"    \\n\" +\n                \"    record Point(int x, int y) {\\n\" +\n                \"    }\\n\" +\n                \"}\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_allowNestedMultiple() {\n        String s = \"\\n\" +\n                \"interface Y {\\n\" +\n                \"    class X {\\n\" +\n                \"        record Point(int x, int y) {\\n\" +\n                \"        }\\n\" +\n                \"    }\\n\" +\n                \"}\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_allowNestedMultiple2() {\n        String s = \"\\n\" +\n                \"interface Y {\\n\" +\n                \"    class X {\\n\" +\n                \"        record Point(int x, int y) {\\n\" +\n                \"        }\\n\" +\n                \"        record PointB(int x, int y) {\\n\" +\n                \"        }\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    record PointC(int x, int y) {\\n\" +\n                \"    }\\n\" +\n                \"}\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(3, recordDeclarations.size());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_topLevelRecordsAreNotStatic() {\n        String s = \"record Point(int x, int y) { }\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        RecordDeclaration recordDeclaration = cu.findAll(RecordDeclaration.class).get(0);\n        assertFalse(recordDeclaration.hasModifier(Modifier.Keyword.STATIC));\n        assertFalse(recordDeclaration.isStatic(), \"Top level Records are NOT implicitly static.\");\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_nestedRecordsAreImplicitlyStatic() {\n        String s = \"\\n\" +\n                \"class X {\\n\" +\n                \"    record Point(int x, int y) {\\n\" +\n                \"    }\\n\" +\n                \"}\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        RecordDeclaration recordDeclaration = cu.findAll(RecordDeclaration.class).get(0);\n        assertFalse(recordDeclaration.hasModifier(Modifier.Keyword.STATIC));\n        assertTrue(recordDeclaration.isStatic(), \"Nested Records are implicitly static.\");\n\n    }\n\n\n    @Test\n    void record_canBeCreatedUsingKeywordNew() {\n        String s = \"\\n\" +\n                \"\\n\" +\n                \"record Point(int x, int y) {\\n\" +\n                \"}\\n\" +\n                \"\\n\" +\n                \"class X {\\n\" +\n                \"    public static void main(String[] args) {\\n\" +\n                \"        new Point(10, 3);\\n\" +\n                \"    }\\n\" +\n                \"}\\n\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        ClassOrInterfaceDeclaration coid = cu.findAll(ClassOrInterfaceDeclaration.class).get(0);\n        List<ObjectCreationExpr> objectCreationExprs = coid.findAll(ObjectCreationExpr.class);\n\n        assertEquals(1, objectCreationExprs.size());\n        ObjectCreationExpr objectCreationExpr = objectCreationExprs.get(0);\n        assertEquals(\"Point\", objectCreationExpr.getTypeAsString());\n    }\n\n    /**\n     * Note the Record Declaration Constructor does not include parameters.\n     * (parameters are, instead, included within the record declaration)\n     * <p>\n     * https://bugs.openjdk.java.net/browse/JDK-8222777\n     */\n    @Test\n    void recordDeclarationFromTheJDK8222777() {\n        CompilationUnit cu = TestParser.parseCompilationUnit(\"\" +\n                \"public record Range(int lo, int hi) {\\n\" +\n                \"\\n\" +\n                \"  public Range {\\n\" +\n                \"    if (lo > hi)  /* referring here to the implicit constructor parameters */\\n\" +\n                \"      throw new IllegalArgumentException(String.format(\\\"(%d,%d)\\\", lo, hi));\\n\" +\n                \"  }\\n\" +\n                \"}\"\n        );\n\n        RecordDeclaration recordDeclaration = cu.findFirst(RecordDeclaration.class).get();\n        assertThat(recordDeclaration.getNameAsString()).isEqualTo(\"Range\");\n        assertThat(recordDeclaration.getModifiers()).containsExactly(Modifier.publicModifier());\n        // test parameters\n        // get constructor\n        // test parameters (none)\n    }\n\n    @Test\n    void recordDeclaration_exampleFromJls_8_10_4_1_normalCanonicalConstructors() {\n        CompilationUnit cu = TestParser.parseCompilationUnit(\"\" +\n                \"import java.lang.annotation.Target;\\n\" +\n                \"import java.lang.annotation.ElementType;\\n\" +\n                \"\\n\" +\n                \"@interface Foo {}\\n\" +\n                \"@interface Bar {}\\n\" +\n                \"\\n\" +\n                \"record Person(@Foo String name) {\\n\" +\n                \"    Person(String name2) {\\n\" +\n                \"    }\\n\" +\n                \"}\"\n        );\n\n        RecordDeclaration recordDeclaration = cu.findFirst(RecordDeclaration.class).get();\n        assertThat(recordDeclaration.getNameAsString()).isEqualTo(\"Person\");\n        assertThat(recordDeclaration.getModifiers()).isEmpty();\n\n        assertThat(recordDeclaration.getConstructors()).hasSize(1);\n        assertThat(recordDeclaration.getCompactConstructors()).hasSize(0);\n\n    }\n\n    @Test\n    void compactConstructor_exampleFromJls_8_10_4_2_compactConstructors() {\n        CompilationUnit cu = TestParser.parseCompilationUnit(\"\" +\n                \"record Rational(int num, int denom) {\\n\" +\n                \"    private static int gcd(int a, int b) {\\n\" +\n                \"        if (b == 0) return Math.abs(a);\\n\" +\n                \"        else return gcd(b, a % b);\\n\" +\n                \"    }\\n\" +\n                \"   \\n\" +\n                \"    Rational {\\n\" +\n                \"        int gcd = gcd(num, denom);\\n\" +\n                \"        num    /= gcd;\\n\" +\n                \"        denom  /= gcd;\\n\" +\n                \"    }\\n\" +\n                \"}\\n\"\n        );\n\n        RecordDeclaration recordDeclaration = cu.findFirst(RecordDeclaration.class).get();\n        assertThat(recordDeclaration.getNameAsString()).isEqualTo(\"Rational\");\n        assertThat(recordDeclaration.getModifiers()).isEmpty();\n\n        assertThat(recordDeclaration.getConstructors()).hasSize(0);\n        assertThat(recordDeclaration.getCompactConstructors()).hasSize(1);\n\n    }\n\n    @Test\n    void nonCompactConstructor_exampleFromJls_8_10_4_2_compactConstructors() {\n        CompilationUnit cu = TestParser.parseCompilationUnit(\"\" +\n                \"record Rational(int num, int denom) {\\n\" +\n                \"    private static int gcd(int a, int b) {\\n\" +\n                \"        if (b == 0) return Math.abs(a);\\n\" +\n                \"        else return gcd(b, a % b);\\n\" +\n                \"    }\\n\" +\n                \"   \\n\" +\n                \"    Rational(int num, int demon) {\\n\" +\n                \"        int gcd = gcd(num, denom);\\n\" +\n                \"        num    /= gcd;\\n\" +\n                \"        denom  /= gcd;\\n\" +\n                \"        this.num   = num;\\n\" +\n                \"        this.denom = denom;\\n\" +\n                \"    }\\n\" +\n                \"}\\n\"\n        );\n\n        RecordDeclaration recordDeclaration = cu.findFirst(RecordDeclaration.class).get();\n        assertThat(recordDeclaration.getNameAsString()).isEqualTo(\"Rational\");\n        assertThat(recordDeclaration.getModifiers()).isEmpty();\n\n        assertThat(recordDeclaration.getConstructors()).hasSize(1);\n        assertThat(recordDeclaration.getCompactConstructors()).hasSize(0);\n\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395\n     */\n    @Test\n    void localRecords() {\n        CompilationUnit cu = TestParser.parseCompilationUnit(\"\" +\n                \"class Scratch {\\n\" +\n                \"    List<Merchant> findTopMerchants(List<Merchant> merchants, int month) {\\n\" +\n                \"        // Local record\\n\" +\n                \"        record MerchantSales(Merchant merchant, double sales) {}\\n\" +\n                \"\\n\" +\n                \"        return merchants.stream()\\n\" +\n                \"                .map(merchant -> new MerchantSales(merchant, computeSales(merchant, month)))\\n\" +\n                \"                .sorted((m1, m2) -> Double.compare(m2.sales(), m1.sales()))\\n\" +\n                \"                .map(MerchantSales::merchant)\\n\" +\n                \"                .collect(toList());\\n\" +\n                \"    }\\n\" +\n                \"}\\n\"\n        );\n\n        RecordDeclaration recordDeclaration = cu.findFirst(RecordDeclaration.class).get();\n        assertThat(recordDeclaration.getNameAsString()).isEqualTo(\"MerchantSales\");\n\n    }\n\n    private void assertCompilationFails(String s) {\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        });\n    }\n\n    private void assertOneRecordDeclaration(CompilationUnit cu) {\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n}\n",
        "diffSourceCodeSet": [],
        "invokedMethodSet": [],
        "sourceCodeAfterRefactoring": "@ParameterizedTest\n        @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_14_PREVIEW\", \"JAVA_15_PREVIEW\", \"JAVA_16\", \"JAVA_16_PREVIEW\"})\n        void basicGrammarCompiles_languageLevelValidation_permitted(ParserConfiguration.LanguageLevel languageLevel) {\n            String s = \"record Point(int x, int y) { }\";\n            CompilationUnit cu = TestParser.parseCompilationUnit(languageLevel, s);\n        }",
        "diffSourceCode": "-   34:     @ParameterizedTest\n-   35:     @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_14_PREVIEW\", \"JAVA_15_PREVIEW\", \"JAVA_16\", \"JAVA_16_PREVIEW\"})\n-   36:     void basicGrammarCompiles_languageLevelValidation_permitted(ParserConfiguration.LanguageLevel languageLevel) {\n-   37:         String s = \"record Point(int x, int y) { }\";\n-   38:         CompilationUnit cu = TestParser.parseCompilationUnit(languageLevel, s);\n-   39:     }\n-   40: \n-   41:     @ParameterizedTest\n-   42:     @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_14_PREVIEW\", \"JAVA_15_PREVIEW\", \"JAVA_16\", \"JAVA_16_PREVIEW\"})\n+   34:             });\n+   35:         }\n+   36: \n+   37:         @ParameterizedTest\n+   38:         @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_14_PREVIEW\", \"JAVA_15_PREVIEW\", \"JAVA_16\", \"JAVA_16_PREVIEW\"})\n+   39:         void basicGrammarCompiles_languageLevelValidation_permitted(ParserConfiguration.LanguageLevel languageLevel) {\n+   40:             String s = \"record Point(int x, int y) { }\";\n+   41:             CompilationUnit cu = TestParser.parseCompilationUnit(languageLevel, s);\n+   42:         }\n",
        "uniqueId": "9e55bc54539d393e1948c8d4a89b1511ed379fad_34_39__37_42",
        "moveFileExist": true,
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 17,
        "testResult": true,
        "coverageInfo": {
            "testMethod": {
                "missed": 0,
                "covered": 1
            }
        }
    },
    {
        "type": "Move Method",
        "description": "Move Method\tpackage basicGrammarCompiles_languageLevelValidation_forbidden(languageLevel ParserConfiguration.LanguageLevel) : void from class com.github.javaparser.ast.body.RecordDeclarationTest to package basicGrammarCompiles_languageLevelValidation_forbidden(languageLevel ParserConfiguration.LanguageLevel) : void from class com.github.javaparser.ast.body.RecordDeclarationTest.LanguageLevels",
        "diffLocations": [
            {
                "filePath": "javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/RecordDeclarationTest.java",
                "startLine": 25,
                "endLine": 32,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/RecordDeclarationTest.java",
                "startLine": 28,
                "endLine": 35,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "@ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_13\", \"JAVA_13_PREVIEW\", \"JAVA_14\", \"JAVA_15\"})\n    void basicGrammarCompiles_languageLevelValidation_forbidden(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"record Point(int x, int y) { }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = TestParser.parseCompilationUnit(languageLevel, s);\n        });\n    }",
        "filePathBefore": "javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/RecordDeclarationTest.java",
        "isPureRefactoring": true,
        "commitId": "9e55bc54539d393e1948c8d4a89b1511ed379fad",
        "packageNameBefore": "com.github.javaparser.ast.body",
        "classNameBefore": "com.github.javaparser.ast.body.RecordDeclarationTest",
        "methodNameBefore": "com.github.javaparser.ast.body.RecordDeclarationTest#basicGrammarCompiles_languageLevelValidation_forbidden",
        "classSignatureBefore": "public class RecordDeclarationTest ",
        "methodNameBeforeSet": [
            "com.github.javaparser.ast.body.RecordDeclarationTest#basicGrammarCompiles_languageLevelValidation_forbidden"
        ],
        "classNameBeforeSet": [
            "com.github.javaparser.ast.body.RecordDeclarationTest"
        ],
        "classSignatureBeforeSet": [
            "public class RecordDeclarationTest "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "package com.github.javaparser.ast.body;\n\nimport com.github.javaparser.ParserConfiguration;\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.Modifier;\nimport com.github.javaparser.ast.NodeList;\nimport com.github.javaparser.ast.expr.ObjectCreationExpr;\nimport com.github.javaparser.utils.TestParser;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.EnumSource;\nimport org.opentest4j.AssertionFailedError;\n\nimport java.util.List;\n\nimport static com.github.javaparser.utils.TestUtils.assertEqualsStringIgnoringEol;\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\npublic class RecordDeclarationTest {\n\n    @ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_13\", \"JAVA_13_PREVIEW\", \"JAVA_14\", \"JAVA_15\"})\n    void basicGrammarCompiles_languageLevelValidation_forbidden(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"record Point(int x, int y) { }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = TestParser.parseCompilationUnit(languageLevel, s);\n        });\n    }\n\n    @ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_14_PREVIEW\", \"JAVA_15_PREVIEW\", \"JAVA_16\", \"JAVA_16_PREVIEW\"})\n    void basicGrammarCompiles_languageLevelValidation_permitted(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(languageLevel, s);\n    }\n\n    @ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_14_PREVIEW\", \"JAVA_15_PREVIEW\", \"JAVA_16\", \"JAVA_16_PREVIEW\"})\n    void languageLevelValidation_recordAsTypeIdentifier_permitted(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"class record {}\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = TestParser.parseCompilationUnit(languageLevel, s);\n        });\n    }\n\n    @ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_13\", \"JAVA_13_PREVIEW\", \"JAVA_14\", \"JAVA_15\"})\n    void languageLevelValidation_recordAsTypeIdentifier_forbidden(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"class record {}\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(languageLevel, s);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Description\n     */\n    @Test\n    void basicGrammarCompiles() {\n        String s = \"record Point(int x, int y) { }\";\n        assertOneRecordDeclaration(TestParser.parseCompilationUnit(s));\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Description\n     */\n    @Test\n    void basicGrammar() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        RecordDeclaration recordDeclaration = cu.findAll(RecordDeclaration.class).get(0);\n\n        assertTrue(recordDeclaration.isRecordDeclaration());\n        assertTrue(recordDeclaration.getImplementedTypes().isEmpty());\n        assertTrue(recordDeclaration.getTypeParameters().isEmpty());\n        assertTrue(recordDeclaration.getFullyQualifiedName().isPresent());\n        assertEquals(\"Point\", recordDeclaration.getFullyQualifiedName().get());\n        assertTrue(recordDeclaration.isRecordDeclaration());\n\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"x\", parameter0.getNameAsString());\n        assertEquals(\"int\", parameter0.getTypeAsString());\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"y\", parameter1.getNameAsString());\n        assertEquals(\"int\", parameter1.getTypeAsString());\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Description\n     */\n    @Test\n    void basicRecordPrints() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        String expected = \"\" +\n                \"record Point(int x, int y) {\\n\" +\n                \"}\\n\" +\n                \"\";\n        assertEqualsStringIgnoringEol(expected, cu.toString());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-record\n     */\n    @Test\n    void record_cannotExtend() {\n        String s = \"record Point(int x, int y) extends OtherThing { }\";\n        assertCompilationFails(s);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_cannotBeAbstract() {\n        String s = \"abstract record Point(int x, int y) { }\";\n        assertCompilationFails(s);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_mayImplementInterfaces() {\n        String s = \"record Point(int x, int y) implements OtherInterface { }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n\n        assertOneRecordDeclaration(cu);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_mayBeStatic() {\n        String s = \"static record Point(int x, int y) { }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void recordWithVarArgs() {\n        String s = \"record R(T1 c1, Tn... cn){ }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"c1\", parameter0.getNameAsString());\n        assertEquals(\"T1\", parameter0.getTypeAsString());\n        assertFalse(parameter0.isVarArgs());\n\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"cn\", parameter1.getNameAsString());\n        assertEquals(\"Tn\", parameter1.getTypeAsString());\n        assertTrue(parameter1.isVarArgs());\n    }\n\n    @Test\n    void recordWithAnnotationedParameters() {\n        String s = \"record Card(@MyAnno Rank rank, @MyAnno Suit suit) { }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"rank\", parameter0.getNameAsString());\n        assertEquals(\"Rank\", parameter0.getTypeAsString());\n        assertEquals(1, parameter0.getAnnotations().size());\n\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"suit\", parameter1.getNameAsString());\n        assertEquals(\"Suit\", parameter1.getTypeAsString());\n        assertEquals(1, parameter1.getAnnotations().size());\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    @Test\n    void record_emptyMembers() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    @Test\n    void record_permitStaticFields() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    static int z;\\n\" +\n                \"\\n\" +\n                \"    static {\\n\" +\n                \"        int z = 10;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_permitStaticMethods() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    static public int abc() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_permitMethods() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    public String xyz() {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_mustNotAllowNonStaticFields() {\n        String s = \"record Point(int x, int y) { int z; }\";\n        assertCompilationFails(s);\n    }\n\n    @Test\n    void record_mustAllowStaticFields() {\n        String s = \"record Point(int x, int y) { static int z; }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_isImplicitlyFinal() {\n        String s = \"record Point(int x, int y) { static int z; }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        RecordDeclaration recordDeclaration = cu.findFirst(RecordDeclaration.class).get();\n        assertFalse(recordDeclaration.hasModifier(Modifier.Keyword.FINAL));\n        assertTrue(recordDeclaration.isFinal(), \"Records are implicitly final.\");\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_canHaveGenerics() {\n        String s = \"record Point <T> (T x, int y) { }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        RecordDeclaration recordDeclaration = cu.findFirst(RecordDeclaration.class).get();\n        assertFalse(recordDeclaration.getTypeParameters().isEmpty());\n        assertEquals(\"T\", recordDeclaration.getTypeParameters().get(0).getNameAsString());\n    }\n\n\n    @Test\n    void record_mustNotAllowMismatchedComponentAccessorReturnType() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public String x() {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \"}\";\n        assertCompilationFails(s);\n    }\n\n    @Test\n    void record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public String x(int a) {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \"}\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod2() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public int x(int a) {\\n\" +\n                \"        return 10;\\n\" +\n                \"    }\\n\" +\n                \"}\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_allowComponentAccessorWithMatchingType() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return 10;\\n\" +\n                \"    }\\n\" +\n                \"}\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_allowNestedWithinClass() {\n        String s = \"\\n\" +\n                \"class X {\\n\" +\n                \"    record Point(int x, int y) {\\n\" +\n                \"    }\\n\" +\n                \"}\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_componentsAreImplicitlyFinal() {\n        String s = \"record Point(int x, int y) { }\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        RecordDeclaration recordDeclaration = cu.findAll(RecordDeclaration.class).get(0);\n\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertTrue(parameters.get(0).isFinal());\n        assertTrue(parameters.get(1).isFinal());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_allowClassWithinRecord() {\n        String s = \"\\n\" +\n                \"record Point(int x, int y) {\\n\" +\n                \"    class X {\\n\" +\n                \"    }\\n\" +\n                \"}\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        BodyDeclaration<?> member = recordDeclaration.getMember(0);\n\n        assertTrue(member.isClassOrInterfaceDeclaration());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_allowNestedWithinInterface() {\n        String s = \"\\n\" +\n                \"interface X {\\n\" +\n                \"    record Point(int x, int y) {\\n\" +\n                \"    }\\n\" +\n                \"}\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_allowNestedWithinEnum() {\n        String s = \"\\n\" +\n                \"enum ABC {\\n\" +\n                \"    ABC;\\n\" +\n                \"    \\n\" +\n                \"    record Point(int x, int y) {\\n\" +\n                \"    }\\n\" +\n                \"}\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_allowNestedMultiple() {\n        String s = \"\\n\" +\n                \"interface Y {\\n\" +\n                \"    class X {\\n\" +\n                \"        record Point(int x, int y) {\\n\" +\n                \"        }\\n\" +\n                \"    }\\n\" +\n                \"}\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_allowNestedMultiple2() {\n        String s = \"\\n\" +\n                \"interface Y {\\n\" +\n                \"    class X {\\n\" +\n                \"        record Point(int x, int y) {\\n\" +\n                \"        }\\n\" +\n                \"        record PointB(int x, int y) {\\n\" +\n                \"        }\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    record PointC(int x, int y) {\\n\" +\n                \"    }\\n\" +\n                \"}\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(3, recordDeclarations.size());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_topLevelRecordsAreNotStatic() {\n        String s = \"record Point(int x, int y) { }\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        RecordDeclaration recordDeclaration = cu.findAll(RecordDeclaration.class).get(0);\n        assertFalse(recordDeclaration.hasModifier(Modifier.Keyword.STATIC));\n        assertFalse(recordDeclaration.isStatic(), \"Top level Records are NOT implicitly static.\");\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_nestedRecordsAreImplicitlyStatic() {\n        String s = \"\\n\" +\n                \"class X {\\n\" +\n                \"    record Point(int x, int y) {\\n\" +\n                \"    }\\n\" +\n                \"}\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        RecordDeclaration recordDeclaration = cu.findAll(RecordDeclaration.class).get(0);\n        assertFalse(recordDeclaration.hasModifier(Modifier.Keyword.STATIC));\n        assertTrue(recordDeclaration.isStatic(), \"Nested Records are implicitly static.\");\n\n    }\n\n\n    @Test\n    void record_canBeCreatedUsingKeywordNew() {\n        String s = \"\\n\" +\n                \"\\n\" +\n                \"record Point(int x, int y) {\\n\" +\n                \"}\\n\" +\n                \"\\n\" +\n                \"class X {\\n\" +\n                \"    public static void main(String[] args) {\\n\" +\n                \"        new Point(10, 3);\\n\" +\n                \"    }\\n\" +\n                \"}\\n\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        ClassOrInterfaceDeclaration coid = cu.findAll(ClassOrInterfaceDeclaration.class).get(0);\n        List<ObjectCreationExpr> objectCreationExprs = coid.findAll(ObjectCreationExpr.class);\n\n        assertEquals(1, objectCreationExprs.size());\n        ObjectCreationExpr objectCreationExpr = objectCreationExprs.get(0);\n        assertEquals(\"Point\", objectCreationExpr.getTypeAsString());\n    }\n\n    /**\n     * Note the Record Declaration Constructor does not include parameters.\n     * (parameters are, instead, included within the record declaration)\n     * <p>\n     * https://bugs.openjdk.java.net/browse/JDK-8222777\n     */\n    @Test\n    void recordDeclarationFromTheJDK8222777() {\n        CompilationUnit cu = TestParser.parseCompilationUnit(\"\" +\n                \"public record Range(int lo, int hi) {\\n\" +\n                \"\\n\" +\n                \"  public Range {\\n\" +\n                \"    if (lo > hi)  /* referring here to the implicit constructor parameters */\\n\" +\n                \"      throw new IllegalArgumentException(String.format(\\\"(%d,%d)\\\", lo, hi));\\n\" +\n                \"  }\\n\" +\n                \"}\"\n        );\n\n        RecordDeclaration recordDeclaration = cu.findFirst(RecordDeclaration.class).get();\n        assertThat(recordDeclaration.getNameAsString()).isEqualTo(\"Range\");\n        assertThat(recordDeclaration.getModifiers()).containsExactly(Modifier.publicModifier());\n        // test parameters\n        // get constructor\n        // test parameters (none)\n    }\n\n    @Test\n    void recordDeclaration_exampleFromJls_8_10_4_1_normalCanonicalConstructors() {\n        CompilationUnit cu = TestParser.parseCompilationUnit(\"\" +\n                \"import java.lang.annotation.Target;\\n\" +\n                \"import java.lang.annotation.ElementType;\\n\" +\n                \"\\n\" +\n                \"@interface Foo {}\\n\" +\n                \"@interface Bar {}\\n\" +\n                \"\\n\" +\n                \"record Person(@Foo String name) {\\n\" +\n                \"    Person(String name2) {\\n\" +\n                \"    }\\n\" +\n                \"}\"\n        );\n\n        RecordDeclaration recordDeclaration = cu.findFirst(RecordDeclaration.class).get();\n        assertThat(recordDeclaration.getNameAsString()).isEqualTo(\"Person\");\n        assertThat(recordDeclaration.getModifiers()).isEmpty();\n\n        assertThat(recordDeclaration.getConstructors()).hasSize(1);\n        assertThat(recordDeclaration.getCompactConstructors()).hasSize(0);\n\n        // test parameters\n        // get constructor\n        // test parameters (none)\n\n    }\n\n    @Test\n    void compactConstructor_exampleFromJls_8_10_4_2_compactConstructors() {\n        CompilationUnit cu = TestParser.parseCompilationUnit(\"\" +\n                \"record Rational(int num, int denom) {\\n\" +\n                \"    private static int gcd(int a, int b) {\\n\" +\n                \"        if (b == 0) return Math.abs(a);\\n\" +\n                \"        else return gcd(b, a % b);\\n\" +\n                \"    }\\n\" +\n                \"   \\n\" +\n                \"    Rational {\\n\" +\n                \"        int gcd = gcd(num, denom);\\n\" +\n                \"        num    /= gcd;\\n\" +\n                \"        denom  /= gcd;\\n\" +\n                \"    }\\n\" +\n                \"}\\n\"\n        );\n\n        RecordDeclaration recordDeclaration = cu.findFirst(RecordDeclaration.class).get();\n        assertThat(recordDeclaration.getNameAsString()).isEqualTo(\"Rational\");\n        assertThat(recordDeclaration.getModifiers()).isEmpty();\n\n        assertThat(recordDeclaration.getConstructors()).hasSize(0);\n        assertThat(recordDeclaration.getCompactConstructors()).hasSize(1);\n\n        // test parameters\n        // get constructor\n        // test parameters (none)\n\n    }\n\n    @Test\n    void nonCompactConstructor_exampleFromJls_8_10_4_2_compactConstructors() {\n        CompilationUnit cu = TestParser.parseCompilationUnit(\"\" +\n                \"record Rational(int num, int denom) {\\n\" +\n                \"    private static int gcd(int a, int b) {\\n\" +\n                \"        if (b == 0) return Math.abs(a);\\n\" +\n                \"        else return gcd(b, a % b);\\n\" +\n                \"    }\\n\" +\n                \"   \\n\" +\n                \"    Rational(int num, int demon) {\\n\" +\n                \"        int gcd = gcd(num, denom);\\n\" +\n                \"        num    /= gcd;\\n\" +\n                \"        denom  /= gcd;\\n\" +\n                \"        this.num   = num;\\n\" +\n                \"        this.denom = denom;\\n\" +\n                \"    }\\n\" +\n                \"}\\n\"\n        );\n\n        RecordDeclaration recordDeclaration = cu.findFirst(RecordDeclaration.class).get();\n        assertThat(recordDeclaration.getNameAsString()).isEqualTo(\"Rational\");\n        assertThat(recordDeclaration.getModifiers()).isEmpty();\n\n        assertThat(recordDeclaration.getConstructors()).hasSize(1);\n        assertThat(recordDeclaration.getCompactConstructors()).hasSize(0);\n\n        // test parameters\n        // get constructor\n        // test parameters (none)\n\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395\n     */\n    @Test\n    void localRecords() {\n        CompilationUnit cu = TestParser.parseCompilationUnit(\"\" +\n                \"class Scratch {\\n\" +\n                \"    List<Merchant> findTopMerchants(List<Merchant> merchants, int month) {\\n\" +\n                \"        // Local record\\n\" +\n                \"        record MerchantSales(Merchant merchant, double sales) {}\\n\" +\n                \"\\n\" +\n                \"        return merchants.stream()\\n\" +\n                \"                .map(merchant -> new MerchantSales(merchant, computeSales(merchant, month)))\\n\" +\n                \"                .sorted((m1, m2) -> Double.compare(m2.sales(), m1.sales()))\\n\" +\n                \"                .map(MerchantSales::merchant)\\n\" +\n                \"                .collect(toList());\\n\" +\n                \"    }\\n\" +\n                \"}\\n\"\n        );\n\n        RecordDeclaration recordDeclaration = cu.findFirst(RecordDeclaration.class).get();\n        assertThat(recordDeclaration.getNameAsString()).isEqualTo(\"MerchantSales\");\n\n    }\n\n    private void assertCompilationFails(String s) {\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        });\n    }\n\n    private void assertOneRecordDeclaration(CompilationUnit cu) {\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n}\n",
        "filePathAfter": "javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/RecordDeclarationTest.java",
        "sourceCodeAfterForWhole": "package com.github.javaparser.ast.body;\n\nimport com.github.javaparser.ParserConfiguration;\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.Modifier;\nimport com.github.javaparser.ast.NodeList;\nimport com.github.javaparser.ast.expr.ObjectCreationExpr;\nimport com.github.javaparser.utils.TestParser;\nimport org.junit.jupiter.api.Nested;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.EnumSource;\nimport org.opentest4j.AssertionFailedError;\n\nimport java.util.List;\n\nimport static com.github.javaparser.utils.TestUtils.assertEqualsStringIgnoringEol;\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\npublic class RecordDeclarationTest {\n\n    @Nested\n    class LanguageLevels {\n        @ParameterizedTest\n        @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_13\", \"JAVA_13_PREVIEW\", \"JAVA_14\", \"JAVA_15\"})\n        void basicGrammarCompiles_languageLevelValidation_forbidden(ParserConfiguration.LanguageLevel languageLevel) {\n            String s = \"record Point(int x, int y) { }\";\n            assertThrows(AssertionFailedError.class, () -> {\n                CompilationUnit cu = TestParser.parseCompilationUnit(languageLevel, s);\n            });\n        }\n\n        @ParameterizedTest\n        @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_14_PREVIEW\", \"JAVA_15_PREVIEW\", \"JAVA_16\", \"JAVA_16_PREVIEW\"})\n        void basicGrammarCompiles_languageLevelValidation_permitted(ParserConfiguration.LanguageLevel languageLevel) {\n            String s = \"record Point(int x, int y) { }\";\n            CompilationUnit cu = TestParser.parseCompilationUnit(languageLevel, s);\n        }\n\n        @ParameterizedTest\n        @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_14_PREVIEW\", \"JAVA_15_PREVIEW\", \"JAVA_16\", \"JAVA_16_PREVIEW\"})\n        void languageLevelValidation_recordAsTypeIdentifier_permitted(ParserConfiguration.LanguageLevel languageLevel) {\n            String s = \"class record {}\";\n            assertThrows(AssertionFailedError.class, () -> {\n                CompilationUnit cu = TestParser.parseCompilationUnit(languageLevel, s);\n            });\n        }\n\n        @ParameterizedTest\n        @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_13\", \"JAVA_13_PREVIEW\", \"JAVA_14\", \"JAVA_15\"})\n        void languageLevelValidation_recordAsTypeIdentifier_forbidden(ParserConfiguration.LanguageLevel languageLevel) {\n            String s = \"class record {}\";\n            CompilationUnit cu = TestParser.parseCompilationUnit(languageLevel, s);\n        }\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Description\n     */\n    @Test\n    void basicGrammarCompiles() {\n        String s = \"record Point(int x, int y) { }\";\n        assertOneRecordDeclaration(TestParser.parseCompilationUnit(s));\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Description\n     */\n    @Test\n    void basicGrammar() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        RecordDeclaration recordDeclaration = cu.findAll(RecordDeclaration.class).get(0);\n\n        assertTrue(recordDeclaration.isRecordDeclaration());\n        assertTrue(recordDeclaration.getImplementedTypes().isEmpty());\n        assertTrue(recordDeclaration.getTypeParameters().isEmpty());\n        assertTrue(recordDeclaration.getFullyQualifiedName().isPresent());\n        assertEquals(\"Point\", recordDeclaration.getFullyQualifiedName().get());\n        assertTrue(recordDeclaration.isRecordDeclaration());\n\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"x\", parameter0.getNameAsString());\n        assertEquals(\"int\", parameter0.getTypeAsString());\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"y\", parameter1.getNameAsString());\n        assertEquals(\"int\", parameter1.getTypeAsString());\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Description\n     */\n    @Test\n    void basicRecordPrints() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        String expected = \"\" +\n                \"record Point(int x, int y) {\\n\" +\n                \"}\\n\" +\n                \"\";\n        assertEqualsStringIgnoringEol(expected, cu.toString());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-record\n     */\n    @Test\n    void record_cannotExtend() {\n        String s = \"record Point(int x, int y) extends OtherThing { }\";\n        assertCompilationFails(s);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_cannotBeAbstract() {\n        String s = \"abstract record Point(int x, int y) { }\";\n        assertCompilationFails(s);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_mayImplementInterfaces() {\n        String s = \"record Point(int x, int y) implements OtherInterface { }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n\n        assertOneRecordDeclaration(cu);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_mayBeStatic() {\n        String s = \"static record Point(int x, int y) { }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void recordWithVarArgs() {\n        String s = \"record R(T1 c1, Tn... cn){ }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"c1\", parameter0.getNameAsString());\n        assertEquals(\"T1\", parameter0.getTypeAsString());\n        assertFalse(parameter0.isVarArgs());\n\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"cn\", parameter1.getNameAsString());\n        assertEquals(\"Tn\", parameter1.getTypeAsString());\n        assertTrue(parameter1.isVarArgs());\n    }\n\n    @Test\n    void recordWithAnnotationedParameters() {\n        String s = \"record Card(@MyAnno Rank rank, @MyAnno Suit suit) { }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"rank\", parameter0.getNameAsString());\n        assertEquals(\"Rank\", parameter0.getTypeAsString());\n        assertEquals(1, parameter0.getAnnotations().size());\n\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"suit\", parameter1.getNameAsString());\n        assertEquals(\"Suit\", parameter1.getTypeAsString());\n        assertEquals(1, parameter1.getAnnotations().size());\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    @Test\n    void record_emptyMembers() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    @Test\n    void record_permitStaticMethods() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    static public int abc() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_permitMethods() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    public String xyz() {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_forbidNonStaticFields() {\n        String s = \"record Point(int x, int y) { int z; }\";\n        assertCompilationFails(s);\n    }\n\n    @Test\n    void record_permitStaticFields() {\n        String s = \"record Point(int x, int y) { static int z; }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_permitStaticFields2() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    static int z;\\n\" +\n                \"\\n\" +\n                \"    static {\\n\" +\n                \"        int z = 10;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_isImplicitlyFinal() {\n        String s = \"record Point(int x, int y) { static int z; }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        RecordDeclaration recordDeclaration = cu.findFirst(RecordDeclaration.class).get();\n        assertFalse(recordDeclaration.hasModifier(Modifier.Keyword.FINAL));\n        assertTrue(recordDeclaration.isFinal(), \"Records are implicitly final.\");\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_isImplicitlyFinalWithoutExplicit() {\n        String s = \"record Point(int x, int y) { static int z; }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        RecordDeclaration recordDeclaration = cu.findFirst(RecordDeclaration.class).get();\n        assertFalse(recordDeclaration.hasModifier(Modifier.Keyword.FINAL));\n        assertTrue(recordDeclaration.isFinal(), \"Records are implicitly final.\");\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_canHaveGenerics() {\n        String s = \"record Point <T> (T x, int y) { }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        RecordDeclaration recordDeclaration = cu.findFirst(RecordDeclaration.class).get();\n        assertFalse(recordDeclaration.getTypeParameters().isEmpty());\n        assertEquals(\"T\", recordDeclaration.getTypeParameters().get(0).getNameAsString());\n    }\n\n\n    @Test\n    void record_mustNotAllowMismatchedComponentAccessorReturnType() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public String x() {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \"}\";\n        assertCompilationFails(s);\n    }\n\n    @Test\n    void record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public String x(int a) {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \"}\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod2() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public int x(int a) {\\n\" +\n                \"        return 10;\\n\" +\n                \"    }\\n\" +\n                \"}\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_allowComponentAccessorWithMatchingType() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return 10;\\n\" +\n                \"    }\\n\" +\n                \"}\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_allowNestedWithinClass() {\n        String s = \"\\n\" +\n                \"class X {\\n\" +\n                \"    record Point(int x, int y) {\\n\" +\n                \"    }\\n\" +\n                \"}\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_componentsAreImplicitlyFinal() {\n        String s = \"record Point(int x, int y) { }\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        RecordDeclaration recordDeclaration = cu.findAll(RecordDeclaration.class).get(0);\n\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertTrue(parameters.get(0).isFinal());\n        assertTrue(parameters.get(1).isFinal());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_allowClassWithinRecord() {\n        String s = \"\\n\" +\n                \"record Point(int x, int y) {\\n\" +\n                \"    class X {\\n\" +\n                \"    }\\n\" +\n                \"}\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        BodyDeclaration<?> member = recordDeclaration.getMember(0);\n\n        assertTrue(member.isClassOrInterfaceDeclaration());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_allowNestedWithinInterface() {\n        String s = \"\\n\" +\n                \"interface X {\\n\" +\n                \"    record Point(int x, int y) {\\n\" +\n                \"    }\\n\" +\n                \"}\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_allowNestedWithinEnum() {\n        String s = \"\\n\" +\n                \"enum ABC {\\n\" +\n                \"    ABC;\\n\" +\n                \"    \\n\" +\n                \"    record Point(int x, int y) {\\n\" +\n                \"    }\\n\" +\n                \"}\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_allowNestedMultiple() {\n        String s = \"\\n\" +\n                \"interface Y {\\n\" +\n                \"    class X {\\n\" +\n                \"        record Point(int x, int y) {\\n\" +\n                \"        }\\n\" +\n                \"    }\\n\" +\n                \"}\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_allowNestedMultiple2() {\n        String s = \"\\n\" +\n                \"interface Y {\\n\" +\n                \"    class X {\\n\" +\n                \"        record Point(int x, int y) {\\n\" +\n                \"        }\\n\" +\n                \"        record PointB(int x, int y) {\\n\" +\n                \"        }\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    record PointC(int x, int y) {\\n\" +\n                \"    }\\n\" +\n                \"}\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(3, recordDeclarations.size());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_topLevelRecordsAreNotStatic() {\n        String s = \"record Point(int x, int y) { }\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        RecordDeclaration recordDeclaration = cu.findAll(RecordDeclaration.class).get(0);\n        assertFalse(recordDeclaration.hasModifier(Modifier.Keyword.STATIC));\n        assertFalse(recordDeclaration.isStatic(), \"Top level Records are NOT implicitly static.\");\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_nestedRecordsAreImplicitlyStatic() {\n        String s = \"\\n\" +\n                \"class X {\\n\" +\n                \"    record Point(int x, int y) {\\n\" +\n                \"    }\\n\" +\n                \"}\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        RecordDeclaration recordDeclaration = cu.findAll(RecordDeclaration.class).get(0);\n        assertFalse(recordDeclaration.hasModifier(Modifier.Keyword.STATIC));\n        assertTrue(recordDeclaration.isStatic(), \"Nested Records are implicitly static.\");\n\n    }\n\n\n    @Test\n    void record_canBeCreatedUsingKeywordNew() {\n        String s = \"\\n\" +\n                \"\\n\" +\n                \"record Point(int x, int y) {\\n\" +\n                \"}\\n\" +\n                \"\\n\" +\n                \"class X {\\n\" +\n                \"    public static void main(String[] args) {\\n\" +\n                \"        new Point(10, 3);\\n\" +\n                \"    }\\n\" +\n                \"}\\n\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        ClassOrInterfaceDeclaration coid = cu.findAll(ClassOrInterfaceDeclaration.class).get(0);\n        List<ObjectCreationExpr> objectCreationExprs = coid.findAll(ObjectCreationExpr.class);\n\n        assertEquals(1, objectCreationExprs.size());\n        ObjectCreationExpr objectCreationExpr = objectCreationExprs.get(0);\n        assertEquals(\"Point\", objectCreationExpr.getTypeAsString());\n    }\n\n    /**\n     * Note the Record Declaration Constructor does not include parameters.\n     * (parameters are, instead, included within the record declaration)\n     * <p>\n     * https://bugs.openjdk.java.net/browse/JDK-8222777\n     */\n    @Test\n    void recordDeclarationFromTheJDK8222777() {\n        CompilationUnit cu = TestParser.parseCompilationUnit(\"\" +\n                \"public record Range(int lo, int hi) {\\n\" +\n                \"\\n\" +\n                \"  public Range {\\n\" +\n                \"    if (lo > hi)  /* referring here to the implicit constructor parameters */\\n\" +\n                \"      throw new IllegalArgumentException(String.format(\\\"(%d,%d)\\\", lo, hi));\\n\" +\n                \"  }\\n\" +\n                \"}\"\n        );\n\n        RecordDeclaration recordDeclaration = cu.findFirst(RecordDeclaration.class).get();\n        assertThat(recordDeclaration.getNameAsString()).isEqualTo(\"Range\");\n        assertThat(recordDeclaration.getModifiers()).containsExactly(Modifier.publicModifier());\n        // test parameters\n        // get constructor\n        // test parameters (none)\n    }\n\n    @Test\n    void recordDeclaration_exampleFromJls_8_10_4_1_normalCanonicalConstructors() {\n        CompilationUnit cu = TestParser.parseCompilationUnit(\"\" +\n                \"import java.lang.annotation.Target;\\n\" +\n                \"import java.lang.annotation.ElementType;\\n\" +\n                \"\\n\" +\n                \"@interface Foo {}\\n\" +\n                \"@interface Bar {}\\n\" +\n                \"\\n\" +\n                \"record Person(@Foo String name) {\\n\" +\n                \"    Person(String name2) {\\n\" +\n                \"    }\\n\" +\n                \"}\"\n        );\n\n        RecordDeclaration recordDeclaration = cu.findFirst(RecordDeclaration.class).get();\n        assertThat(recordDeclaration.getNameAsString()).isEqualTo(\"Person\");\n        assertThat(recordDeclaration.getModifiers()).isEmpty();\n\n        assertThat(recordDeclaration.getConstructors()).hasSize(1);\n        assertThat(recordDeclaration.getCompactConstructors()).hasSize(0);\n\n    }\n\n    @Test\n    void compactConstructor_exampleFromJls_8_10_4_2_compactConstructors() {\n        CompilationUnit cu = TestParser.parseCompilationUnit(\"\" +\n                \"record Rational(int num, int denom) {\\n\" +\n                \"    private static int gcd(int a, int b) {\\n\" +\n                \"        if (b == 0) return Math.abs(a);\\n\" +\n                \"        else return gcd(b, a % b);\\n\" +\n                \"    }\\n\" +\n                \"   \\n\" +\n                \"    Rational {\\n\" +\n                \"        int gcd = gcd(num, denom);\\n\" +\n                \"        num    /= gcd;\\n\" +\n                \"        denom  /= gcd;\\n\" +\n                \"    }\\n\" +\n                \"}\\n\"\n        );\n\n        RecordDeclaration recordDeclaration = cu.findFirst(RecordDeclaration.class).get();\n        assertThat(recordDeclaration.getNameAsString()).isEqualTo(\"Rational\");\n        assertThat(recordDeclaration.getModifiers()).isEmpty();\n\n        assertThat(recordDeclaration.getConstructors()).hasSize(0);\n        assertThat(recordDeclaration.getCompactConstructors()).hasSize(1);\n\n    }\n\n    @Test\n    void nonCompactConstructor_exampleFromJls_8_10_4_2_compactConstructors() {\n        CompilationUnit cu = TestParser.parseCompilationUnit(\"\" +\n                \"record Rational(int num, int denom) {\\n\" +\n                \"    private static int gcd(int a, int b) {\\n\" +\n                \"        if (b == 0) return Math.abs(a);\\n\" +\n                \"        else return gcd(b, a % b);\\n\" +\n                \"    }\\n\" +\n                \"   \\n\" +\n                \"    Rational(int num, int demon) {\\n\" +\n                \"        int gcd = gcd(num, denom);\\n\" +\n                \"        num    /= gcd;\\n\" +\n                \"        denom  /= gcd;\\n\" +\n                \"        this.num   = num;\\n\" +\n                \"        this.denom = denom;\\n\" +\n                \"    }\\n\" +\n                \"}\\n\"\n        );\n\n        RecordDeclaration recordDeclaration = cu.findFirst(RecordDeclaration.class).get();\n        assertThat(recordDeclaration.getNameAsString()).isEqualTo(\"Rational\");\n        assertThat(recordDeclaration.getModifiers()).isEmpty();\n\n        assertThat(recordDeclaration.getConstructors()).hasSize(1);\n        assertThat(recordDeclaration.getCompactConstructors()).hasSize(0);\n\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395\n     */\n    @Test\n    void localRecords() {\n        CompilationUnit cu = TestParser.parseCompilationUnit(\"\" +\n                \"class Scratch {\\n\" +\n                \"    List<Merchant> findTopMerchants(List<Merchant> merchants, int month) {\\n\" +\n                \"        // Local record\\n\" +\n                \"        record MerchantSales(Merchant merchant, double sales) {}\\n\" +\n                \"\\n\" +\n                \"        return merchants.stream()\\n\" +\n                \"                .map(merchant -> new MerchantSales(merchant, computeSales(merchant, month)))\\n\" +\n                \"                .sorted((m1, m2) -> Double.compare(m2.sales(), m1.sales()))\\n\" +\n                \"                .map(MerchantSales::merchant)\\n\" +\n                \"                .collect(toList());\\n\" +\n                \"    }\\n\" +\n                \"}\\n\"\n        );\n\n        RecordDeclaration recordDeclaration = cu.findFirst(RecordDeclaration.class).get();\n        assertThat(recordDeclaration.getNameAsString()).isEqualTo(\"MerchantSales\");\n\n    }\n\n    private void assertCompilationFails(String s) {\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        });\n    }\n\n    private void assertOneRecordDeclaration(CompilationUnit cu) {\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n}\n",
        "diffSourceCodeSet": [],
        "invokedMethodSet": [],
        "sourceCodeAfterRefactoring": "@ParameterizedTest\n        @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_13\", \"JAVA_13_PREVIEW\", \"JAVA_14\", \"JAVA_15\"})\n        void basicGrammarCompiles_languageLevelValidation_forbidden(ParserConfiguration.LanguageLevel languageLevel) {\n            String s = \"record Point(int x, int y) { }\";\n            assertThrows(AssertionFailedError.class, () -> {\n                CompilationUnit cu = TestParser.parseCompilationUnit(languageLevel, s);\n            });\n        }",
        "diffSourceCode": "-   25:     @ParameterizedTest\n-   26:     @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_13\", \"JAVA_13_PREVIEW\", \"JAVA_14\", \"JAVA_15\"})\n-   27:     void basicGrammarCompiles_languageLevelValidation_forbidden(ParserConfiguration.LanguageLevel languageLevel) {\n-   28:         String s = \"record Point(int x, int y) { }\";\n-   29:         assertThrows(AssertionFailedError.class, () -> {\n-   30:             CompilationUnit cu = TestParser.parseCompilationUnit(languageLevel, s);\n-   31:         });\n-   32:     }\n-   33: \n-   34:     @ParameterizedTest\n-   35:     @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_14_PREVIEW\", \"JAVA_15_PREVIEW\", \"JAVA_16\", \"JAVA_16_PREVIEW\"})\n+   25: \n+   26:     @Nested\n+   27:     class LanguageLevels {\n+   28:         @ParameterizedTest\n+   29:         @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_13\", \"JAVA_13_PREVIEW\", \"JAVA_14\", \"JAVA_15\"})\n+   30:         void basicGrammarCompiles_languageLevelValidation_forbidden(ParserConfiguration.LanguageLevel languageLevel) {\n+   31:             String s = \"record Point(int x, int y) { }\";\n+   32:             assertThrows(AssertionFailedError.class, () -> {\n+   33:                 CompilationUnit cu = TestParser.parseCompilationUnit(languageLevel, s);\n+   34:             });\n+   35:         }\n",
        "uniqueId": "9e55bc54539d393e1948c8d4a89b1511ed379fad_25_32__28_35",
        "moveFileExist": true,
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 17,
        "testResult": true,
        "coverageInfo": {
            "testMethod": {
                "missed": 0,
                "covered": 1
            }
        }
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprotected convertToUsage(unionType UnionType, context Context) : ResolvedType extracted from protected convertToUsage(type Type, context Context) : ResolvedType in class com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade",
        "diffLocations": [
            {
                "filePath": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java",
                "startLine": 677,
                "endLine": 706,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java",
                "startLine": 677,
                "endLine": 705,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java",
                "startLine": 746,
                "endLine": 751,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "protected ResolvedType convertToUsage(Type type, Context context) {\n        if (context == null) {\n            throw new NullPointerException(\"Context should not be null\");\n        }\n        if (type instanceof ClassOrInterfaceType) {\n            return convertToUsage((ClassOrInterfaceType) type, context);\n        } else if (type instanceof PrimitiveType) {\n            return ResolvedPrimitiveType.byName(((PrimitiveType) type).getType().name());\n        } else if (type instanceof WildcardType) {\n            return convertToUsage((WildcardType) type, context);\n        } else if (type instanceof VoidType) {\n            return ResolvedVoidType.INSTANCE;\n        } else if (type instanceof ArrayType) {\n            return convertToUsage((ArrayType) type, context);\n        } else if (type instanceof UnionType) {\n            UnionType unionType = (UnionType) type;\n            return new ResolvedUnionType(unionType.getElements().stream().map(el -> convertToUsage(el, context)).collect(Collectors.toList()));\n        } else if (type instanceof VarType) {\n            Node parent = type.getParentNode().get();\n            if (!(parent instanceof VariableDeclarator)) {\n                throw new IllegalStateException(\"Trying to resolve a `var` which is not in a variable declaration.\");\n            }\n            final VariableDeclarator variableDeclarator = (VariableDeclarator) parent;\n            return variableDeclarator.getInitializer()\n                    .map(Expression::calculateResolvedType)\n                    .orElseThrow(() -> new IllegalStateException(\"Cannot resolve `var` which has no initializer.\"));\n        } else {\n            throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n        }\n    }",
        "filePathBefore": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java",
        "isPureRefactoring": true,
        "commitId": "e3ae340534ecf7406a548723488059b947a9f298",
        "packageNameBefore": "com.github.javaparser.symbolsolver.javaparsermodel",
        "classNameBefore": "com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade",
        "methodNameBefore": "com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade#convertToUsage",
        "invokedMethod": "methodSignature: com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade#convertToUsage\n methodBody: protected ResolvedType convertToUsage(ArrayType arrayType, Context context) {\nreturn new ResolvedArrayType(convertToUsage(arrayType.getComponentType(),context));\n}\nmethodSignature: com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade#getType\n methodBody: public ResolvedType getType(Node node, boolean solveLambdas) {\nif(solveLambdas){if(!node.containsData(TYPE_WITH_LAMBDAS_RESOLVED)){ResolvedType res=getTypeConcrete(node,solveLambdas);\nnode.setData(TYPE_WITH_LAMBDAS_RESOLVED,res);\nboolean secondPassNecessary=false;\nif(node instanceof MethodCallExpr){MethodCallExpr methodCallExpr=(MethodCallExpr)node;\nfor(Node arg: methodCallExpr.getArguments()){if(!arg.containsData(TYPE_WITH_LAMBDAS_RESOLVED)){getType(arg,true);\nsecondPassNecessary=true;\n}}}if(secondPassNecessary){node.removeData(TYPE_WITH_LAMBDAS_RESOLVED);\nResolvedType type=getType(node,true);\nnode.setData(TYPE_WITH_LAMBDAS_RESOLVED,type);\n}Log.trace(\"getType on %s  -> %s\",() -> node,() -> res);\n}return node.getData(TYPE_WITH_LAMBDAS_RESOLVED);\n}{Optional<ResolvedType> res=find(TYPE_WITH_LAMBDAS_RESOLVED,node);\nif(res.isPresent()){return res.get();\n}res=find(TYPE_WITHOUT_LAMBDAS_RESOLVED,node);\nif(!res.isPresent()){ResolvedType resType=getTypeConcrete(node,solveLambdas);\nnode.setData(TYPE_WITHOUT_LAMBDAS_RESOLVED,resType);\nOptional<ResolvedType> finalRes=res;\nLog.trace(\"getType on %s (no solveLambdas) -> %s\",() -> node,() -> finalRes);\nreturn resType;\n}return res.get();\n}}\nmethodSignature: com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade#get\n methodBody: public synchronized static JavaParserFacade get(TypeSolver typeSolver) {\nreturn instances.computeIfAbsent(typeSolver,JavaParserFacade::new);\n}",
        "classSignatureBefore": "public class JavaParserFacade ",
        "methodNameBeforeSet": [
            "com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade#convertToUsage"
        ],
        "classNameBeforeSet": [
            "com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade"
        ],
        "classSignatureBeforeSet": [
            "public class JavaParserFacade "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": " Severe changes",
                "description": "Return expression has been added within the Extract Method mechanics - with non-mapped leaves",
                "mappingState": 2
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Copyright (C) 2015-2016 Federico Tomassetti\n * Copyright (C) 2017-2020 The JavaParser Team.\n *\n * This file is part of JavaParser.\n *\n * JavaParser can be used either under the terms of\n * a) the GNU Lesser General Public License as published by\n *     the Free Software Foundation, either version 3 of the License, or\n *     (at your option) any later version.\n * b) the terms of the Apache License\n *\n * You should have received a copy of both licenses in LICENCE.LGPL and\n * LICENCE.APACHE. Please refer to those files for details.\n *\n * JavaParser is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n */\n\npackage com.github.javaparser.symbolsolver.javaparsermodel;\n\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.DataKey;\nimport com.github.javaparser.ast.Node;\nimport com.github.javaparser.ast.NodeList;\nimport com.github.javaparser.ast.body.BodyDeclaration;\nimport com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;\nimport com.github.javaparser.ast.body.EnumDeclaration;\nimport com.github.javaparser.ast.body.TypeDeclaration;\nimport com.github.javaparser.ast.body.VariableDeclarator;\nimport com.github.javaparser.ast.expr.AnnotationExpr;\nimport com.github.javaparser.ast.expr.BinaryExpr;\nimport com.github.javaparser.ast.expr.Expression;\nimport com.github.javaparser.ast.expr.FieldAccessExpr;\nimport com.github.javaparser.ast.expr.LambdaExpr;\nimport com.github.javaparser.ast.expr.MethodCallExpr;\nimport com.github.javaparser.ast.expr.MethodReferenceExpr;\nimport com.github.javaparser.ast.expr.NameExpr;\nimport com.github.javaparser.ast.expr.ObjectCreationExpr;\nimport com.github.javaparser.ast.expr.SimpleName;\nimport com.github.javaparser.ast.expr.ThisExpr;\nimport com.github.javaparser.ast.expr.TypeExpr;\nimport com.github.javaparser.ast.stmt.ExplicitConstructorInvocationStmt;\nimport com.github.javaparser.ast.type.ArrayType;\nimport com.github.javaparser.ast.type.ClassOrInterfaceType;\nimport com.github.javaparser.ast.type.PrimitiveType;\nimport com.github.javaparser.ast.type.Type;\nimport com.github.javaparser.ast.type.UnionType;\nimport com.github.javaparser.ast.type.VarType;\nimport com.github.javaparser.ast.type.VoidType;\nimport com.github.javaparser.ast.type.WildcardType;\nimport com.github.javaparser.resolution.MethodAmbiguityException;\nimport com.github.javaparser.resolution.MethodUsage;\nimport com.github.javaparser.resolution.UnsolvedSymbolException;\nimport com.github.javaparser.resolution.declarations.ResolvedAnnotationDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedClassDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedConstructorDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedMethodDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedReferenceTypeDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedTypeDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedTypeParameterDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedValueDeclaration;\nimport com.github.javaparser.resolution.types.ResolvedArrayType;\nimport com.github.javaparser.resolution.types.ResolvedPrimitiveType;\nimport com.github.javaparser.resolution.types.ResolvedReferenceType;\nimport com.github.javaparser.resolution.types.ResolvedType;\nimport com.github.javaparser.resolution.types.ResolvedTypeVariable;\nimport com.github.javaparser.resolution.types.ResolvedUnionType;\nimport com.github.javaparser.resolution.types.ResolvedVoidType;\nimport com.github.javaparser.resolution.types.ResolvedWildcard;\nimport com.github.javaparser.symbolsolver.core.resolution.Context;\nimport com.github.javaparser.symbolsolver.javaparsermodel.contexts.FieldAccessContext;\nimport com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserAnonymousClassDeclaration;\nimport com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserEnumDeclaration;\nimport com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserTypeVariableDeclaration;\nimport com.github.javaparser.symbolsolver.model.resolution.SymbolReference;\nimport com.github.javaparser.symbolsolver.model.resolution.TypeSolver;\nimport com.github.javaparser.symbolsolver.model.typesystem.ReferenceTypeImpl;\nimport com.github.javaparser.symbolsolver.reflectionmodel.ReflectionAnnotationDeclaration;\nimport com.github.javaparser.symbolsolver.reflectionmodel.ReflectionClassDeclaration;\nimport com.github.javaparser.symbolsolver.reflectionmodel.ReflectionEnumDeclaration;\nimport com.github.javaparser.symbolsolver.reflectionmodel.ReflectionInterfaceDeclaration;\nimport com.github.javaparser.symbolsolver.resolution.ConstructorResolutionLogic;\nimport com.github.javaparser.symbolsolver.resolution.MethodResolutionLogic;\nimport com.github.javaparser.symbolsolver.resolution.SymbolSolver;\nimport com.github.javaparser.utils.Log;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.Set;\nimport java.util.WeakHashMap;\nimport java.util.stream.Collectors;\n\nimport static com.github.javaparser.symbolsolver.javaparser.Navigator.demandParentNode;\nimport static com.github.javaparser.symbolsolver.model.resolution.SymbolReference.solved;\nimport static com.github.javaparser.symbolsolver.model.resolution.SymbolReference.unsolved;\n\n/**\n * Class to be used by final users to solve symbols for JavaParser ASTs.\n *\n * @author Federico Tomassetti\n */\npublic class JavaParserFacade {\n\n    private static final DataKey<ResolvedType> TYPE_WITH_LAMBDAS_RESOLVED = new DataKey<ResolvedType>() {\n    };\n    private static final DataKey<ResolvedType> TYPE_WITHOUT_LAMBDAS_RESOLVED = new DataKey<ResolvedType>() {\n    };\n\n    private static final Map<TypeSolver, JavaParserFacade> instances = new WeakHashMap<>();\n    \n    private static String JAVA_LANG_STRING = String.class.getCanonicalName();\n    \n    private final TypeSolver typeSolver;\n    private final TypeExtractor typeExtractor;\n    private final SymbolSolver symbolSolver;\n\n    private JavaParserFacade(TypeSolver typeSolver) {\n        this.typeSolver = typeSolver.getRoot();\n        this.symbolSolver = new SymbolSolver(typeSolver);\n        this.typeExtractor = new TypeExtractor(typeSolver, this);\n    }\n\n    public TypeSolver getTypeSolver() {\n        return typeSolver;\n    }\n\n    public SymbolSolver getSymbolSolver() {\n        return symbolSolver;\n    }\n\n    /**\n     * Note that the addition of the modifier {@code synchronized} is specific and directly in response to issue #2668.\n     * <br>This <strong>MUST NOT</strong> be misinterpreted as a signal that JavaParser is safe to use within a multi-threaded environment.\n     * <br>\n     * <br>Additional discussion and context from a user attempting multithreading can be found within issue #2671 .\n     * <br>\n     *\n     * @see <a href=\"https://github.com/javaparser/javaparser/issues/2668\">https://github.com/javaparser/javaparser/issues/2668</a>\n     * @see <a href=\"https://github.com/javaparser/javaparser/issues/2671\">https://github.com/javaparser/javaparser/issues/2671</a>\n     */\n    public synchronized static JavaParserFacade get(TypeSolver typeSolver) {\n        return instances.computeIfAbsent(typeSolver, JavaParserFacade::new);\n    }\n\n    /**\n     * This method is used to clear internal caches for the sake of releasing memory.\n     */\n    public static void clearInstances() {\n        instances.clear();\n    }\n\n    protected static ResolvedType solveGenericTypes(ResolvedType type, Context context) {\n        if (type.isTypeVariable()) {\n            return context.solveGenericType(type.describe()).orElse(type);\n        }\n        if (type.isWildcard()) {\n            if (type.asWildcard().isExtends() || type.asWildcard().isSuper()) {\n                ResolvedWildcard wildcardUsage = type.asWildcard();\n                ResolvedType boundResolved = solveGenericTypes(wildcardUsage.getBoundedType(), context);\n                if (wildcardUsage.isExtends()) {\n                    return ResolvedWildcard.extendsBound(boundResolved);\n                } else {\n                    return ResolvedWildcard.superBound(boundResolved);\n                }\n            }\n        }\n        return type;\n    }\n\n    public SymbolReference<? extends ResolvedValueDeclaration> solve(NameExpr nameExpr) {\n        return symbolSolver.solveSymbol(nameExpr.getName().getId(), nameExpr);\n    }\n\n    public SymbolReference<? extends ResolvedValueDeclaration> solve(SimpleName nameExpr) {\n        return symbolSolver.solveSymbol(nameExpr.getId(), nameExpr);\n    }\n\n    public SymbolReference<? extends ResolvedValueDeclaration> solve(Expression expr) {\n        return expr.toNameExpr().map(this::solve).orElseThrow(() -> new IllegalArgumentException(expr.getClass().getCanonicalName()));\n    }\n\n    public SymbolReference<ResolvedMethodDeclaration> solve(MethodCallExpr methodCallExpr) {\n        return solve(methodCallExpr, true);\n    }\n\n    public SymbolReference<ResolvedMethodDeclaration> solve(MethodReferenceExpr methodReferenceExpr) {\n        return solve(methodReferenceExpr, true);\n    }\n\n    public SymbolReference<ResolvedConstructorDeclaration> solve(ObjectCreationExpr objectCreationExpr) {\n        return solve(objectCreationExpr, true);\n    }\n\n    public SymbolReference<ResolvedConstructorDeclaration> solve(ExplicitConstructorInvocationStmt explicitConstructorInvocationStmt) {\n        return solve(explicitConstructorInvocationStmt, true);\n    }\n\n    public SymbolReference<ResolvedConstructorDeclaration> solve(ExplicitConstructorInvocationStmt explicitConstructorInvocationStmt, boolean solveLambdas) {\n        // Constructor invocation must exist within a class (not interface).\n        Optional<ClassOrInterfaceDeclaration> optAncestorClassOrInterfaceNode = explicitConstructorInvocationStmt.findAncestor(ClassOrInterfaceDeclaration.class);\n        if (!optAncestorClassOrInterfaceNode.isPresent()) {\n            return unsolved(ResolvedConstructorDeclaration.class);\n        }\n\n        ClassOrInterfaceDeclaration classOrInterfaceNode = optAncestorClassOrInterfaceNode.get();\n        ResolvedReferenceTypeDeclaration resolvedClassNode = classOrInterfaceNode.resolve();\n        if (!resolvedClassNode.isClass()) {\n            throw new IllegalStateException(\"Expected to be a class -- cannot call this() or super() within an interface.\");\n        }\n\n        ResolvedTypeDeclaration typeDecl = null;\n        if (explicitConstructorInvocationStmt.isThis()) {\n            // this()\n            typeDecl = resolvedClassNode.asReferenceType();\n        } else {\n            // super()\n            Optional<ResolvedReferenceType> superClass = resolvedClassNode.asClass().getSuperClass();\n            if (superClass.isPresent() && superClass.get().getTypeDeclaration().isPresent()) {\n                typeDecl = superClass.get().getTypeDeclaration().get();\n            }\n        }\n        if (typeDecl == null) {\n            return unsolved(ResolvedConstructorDeclaration.class);\n        }\n\n        // Solve each of the arguments being passed into this constructor invocation.\n        List<ResolvedType> argumentTypes = new LinkedList<>();\n        List<LambdaArgumentTypePlaceholder> placeholders = new LinkedList<>();\n        solveArguments(explicitConstructorInvocationStmt, explicitConstructorInvocationStmt.getArguments(), solveLambdas, argumentTypes, placeholders);\n\n        // Determine which constructor is referred to, and return it.\n        SymbolReference<ResolvedConstructorDeclaration> res = ConstructorResolutionLogic.findMostApplicable(((ResolvedClassDeclaration) typeDecl).getConstructors(), argumentTypes, typeSolver);\n        for (LambdaArgumentTypePlaceholder placeholder : placeholders) {\n            placeholder.setMethod(res);\n        }\n\n        return res;\n    }\n\n    public SymbolReference<ResolvedTypeDeclaration> solve(ThisExpr node) {\n        // If 'this' is prefixed by a class eg. MyClass.this\n        if (node.getTypeName().isPresent()) {\n            // Get the class name\n            String className = node.getTypeName().get().asString();\n            // Attempt to resolve using a typeSolver\n            SymbolReference<ResolvedReferenceTypeDeclaration> clazz = typeSolver.tryToSolveType(className);\n            if (clazz.isSolved()) {\n                return solved(clazz.getCorrespondingDeclaration());\n            }\n            // Attempt to resolve locally in Compilation unit\n            Optional<CompilationUnit> cu = node.findAncestor(CompilationUnit.class);\n            if (cu.isPresent()) {\n                Optional<ClassOrInterfaceDeclaration> classByName = cu.get().getClassByName(className);\n                if (classByName.isPresent()) {\n                    return solved(getTypeDeclaration(classByName.get()));\n                }\n            }\n        }\n        return solved(getTypeDeclaration(findContainingTypeDeclOrObjectCreationExpr(node)));\n    }\n\n    /**\n     * Given a constructor call find out to which constructor declaration it corresponds.\n     */\n    public SymbolReference<ResolvedConstructorDeclaration> solve(ObjectCreationExpr objectCreationExpr, boolean solveLambdas) {\n        List<ResolvedType> argumentTypes = new LinkedList<>();\n        List<LambdaArgumentTypePlaceholder> placeholders = new LinkedList<>();\n\n        solveArguments(objectCreationExpr, objectCreationExpr.getArguments(), solveLambdas, argumentTypes, placeholders);\n\n        ResolvedReferenceTypeDeclaration typeDecl = null;\n        if (objectCreationExpr.getAnonymousClassBody().isPresent()) {\n            typeDecl = new JavaParserAnonymousClassDeclaration(objectCreationExpr, typeSolver);\n        } else {\n            ResolvedType classDecl = JavaParserFacade.get(typeSolver).convert(objectCreationExpr.getType(), objectCreationExpr);\n            if (classDecl.isReferenceType() && classDecl.asReferenceType().getTypeDeclaration().isPresent()) {\n                typeDecl = classDecl.asReferenceType().getTypeDeclaration().get();\n            }\n        }\n        if (typeDecl == null) {\n            return unsolved(ResolvedConstructorDeclaration.class);\n        }\n        SymbolReference<ResolvedConstructorDeclaration> res = ConstructorResolutionLogic.findMostApplicable(typeDecl.getConstructors(), argumentTypes, typeSolver);\n        for (LambdaArgumentTypePlaceholder placeholder : placeholders) {\n            placeholder.setMethod(res);\n        }\n        return res;\n    }\n\n    private void solveArguments(Node node, NodeList<Expression> args, boolean solveLambdas, List<ResolvedType> argumentTypes,\n                                List<LambdaArgumentTypePlaceholder> placeholders) {\n        int i = 0;\n        for (Expression parameterValue : args) {\n            if (parameterValue instanceof LambdaExpr || parameterValue instanceof MethodReferenceExpr) {\n                LambdaArgumentTypePlaceholder placeholder = new LambdaArgumentTypePlaceholder(i);\n                argumentTypes.add(placeholder);\n                placeholders.add(placeholder);\n            } else {\n                try {\n                    argumentTypes.add(JavaParserFacade.get(typeSolver).getType(parameterValue, solveLambdas));\n                } catch (UnsolvedSymbolException e) {\n                    throw e;\n                } catch (Exception e) {\n                    throw new RuntimeException(String.format(\"Unable to calculate the type of a parameter of a method call. Method call: %s, Parameter: %s\",\n                            node, parameterValue), e);\n                }\n            }\n            i++;\n        }\n    }\n\n    /**\n     * Given a method call find out to which method declaration it corresponds.\n     */\n    public SymbolReference<ResolvedMethodDeclaration> solve(MethodCallExpr methodCallExpr, boolean solveLambdas) {\n        List<ResolvedType> argumentTypes = new LinkedList<>();\n        List<LambdaArgumentTypePlaceholder> placeholders = new LinkedList<>();\n\n        solveArguments(methodCallExpr, methodCallExpr.getArguments(), solveLambdas, argumentTypes, placeholders);\n\n        SymbolReference<ResolvedMethodDeclaration> res = JavaParserFactory.getContext(methodCallExpr, typeSolver).solveMethod(methodCallExpr.getName().getId(), argumentTypes, false);\n        for (LambdaArgumentTypePlaceholder placeholder : placeholders) {\n            placeholder.setMethod(res);\n        }\n        return res;\n    }\n\n    /**\n     * Given a method reference find out to which method declaration it corresponds.\n     */\n    public SymbolReference<ResolvedMethodDeclaration> solve(MethodReferenceExpr methodReferenceExpr, boolean solveLambdas) {\n        // pass empty argument list to be populated\n        List<ResolvedType> argumentTypes = new LinkedList<>();\n        return JavaParserFactory.getContext(methodReferenceExpr, typeSolver).solveMethod(methodReferenceExpr.getIdentifier(), argumentTypes, false);\n    }\n\n    public SymbolReference<ResolvedAnnotationDeclaration> solve(AnnotationExpr annotationExpr) {\n        Context context = JavaParserFactory.getContext(annotationExpr, typeSolver);\n        SymbolReference<ResolvedTypeDeclaration> typeDeclarationSymbolReference = context.solveType(annotationExpr.getNameAsString());\n        if (typeDeclarationSymbolReference.isSolved()) {\n            ResolvedAnnotationDeclaration annotationDeclaration = (ResolvedAnnotationDeclaration) typeDeclarationSymbolReference.getCorrespondingDeclaration();\n            return solved(annotationDeclaration);\n        } else {\n            return unsolved(ResolvedAnnotationDeclaration.class);\n        }\n    }\n\n    public SymbolReference<ResolvedValueDeclaration> solve(FieldAccessExpr fieldAccessExpr) {\n        return ((FieldAccessContext) JavaParserFactory.getContext(fieldAccessExpr, typeSolver)).solveField(fieldAccessExpr.getName().getId());\n    }\n\n    /**\n     * Get the type associated with the node.\n     * <p>\n     * This method was originally intended to get the type of a value: any value has a type.\n     * <p>\n     * For example:\n     * <pre>\n     * int foo(int a) {\n     *     return a; // when getType is invoked on \"a\" it returns the type \"int\"\n     * }\n     * </pre>\n     * <p>\n     * Now, users started using also of names of types itself, which do not have a type.\n     * <p>\n     * For example:\n     * <pre>\n     * class A {\n     *     int foo(int a) {\n     *         return A.someStaticField; // when getType is invoked on \"A\", which represents a class, it returns\n     *             // the type \"A\" itself while it used to throw UnsolvedSymbolException\n     * }\n     * </pre>\n     * <p>\n     * To accommodate this usage and avoid confusion this method return\n     * the type itself when used on the name of type.\n     */\n    public ResolvedType getType(Node node) {\n        try {\n            return getType(node, true);\n        } catch (UnsolvedSymbolException e) {\n            if (node instanceof NameExpr) {\n                NameExpr nameExpr = (NameExpr) node;\n                SymbolReference<ResolvedTypeDeclaration> typeDeclaration = JavaParserFactory.getContext(node, typeSolver)\n                        .solveType(nameExpr.getNameAsString());\n                if (typeDeclaration.isSolved() && typeDeclaration.getCorrespondingDeclaration() instanceof ResolvedReferenceTypeDeclaration) {\n                    ResolvedReferenceTypeDeclaration resolvedReferenceTypeDeclaration = (ResolvedReferenceTypeDeclaration) typeDeclaration.getCorrespondingDeclaration();\n                    return ReferenceTypeImpl.undeterminedParameters(resolvedReferenceTypeDeclaration, typeSolver);\n                }\n            }\n            throw e;\n        }\n    }\n\n    public ResolvedType getType(Node node, boolean solveLambdas) {\n        if (solveLambdas) {\n            if (!node.containsData(TYPE_WITH_LAMBDAS_RESOLVED)) {\n                ResolvedType res = getTypeConcrete(node, solveLambdas);\n\n                node.setData(TYPE_WITH_LAMBDAS_RESOLVED, res);\n\n                boolean secondPassNecessary = false;\n                if (node instanceof MethodCallExpr) {\n                    MethodCallExpr methodCallExpr = (MethodCallExpr) node;\n                    for (Node arg : methodCallExpr.getArguments()) {\n                        if (!arg.containsData(TYPE_WITH_LAMBDAS_RESOLVED)) {\n                            getType(arg, true);\n                            secondPassNecessary = true;\n                        }\n                    }\n                }\n                if (secondPassNecessary) {\n                    node.removeData(TYPE_WITH_LAMBDAS_RESOLVED);\n                    ResolvedType type = getType(node, true);\n                    node.setData(TYPE_WITH_LAMBDAS_RESOLVED, type);\n\n                }\n                Log.trace(\"getType on %s  -> %s\", () -> node, () -> res);\n            }\n            return node.getData(TYPE_WITH_LAMBDAS_RESOLVED);\n        } else {\n            Optional<ResolvedType> res = find(TYPE_WITH_LAMBDAS_RESOLVED, node);\n            if (res.isPresent()) {\n                return res.get();\n            }\n            res = find(TYPE_WITHOUT_LAMBDAS_RESOLVED, node);\n            if (!res.isPresent()) {\n                ResolvedType resType = getTypeConcrete(node, solveLambdas);\n                node.setData(TYPE_WITHOUT_LAMBDAS_RESOLVED, resType);\n                Optional<ResolvedType> finalRes = res;\n                Log.trace(\"getType on %s (no solveLambdas) -> %s\", () -> node, () -> finalRes);\n                return resType;\n            }\n            return res.get();\n        }\n    }\n\n    private Optional<ResolvedType> find(DataKey<ResolvedType> dataKey, Node node) {\n        if (node.containsData(dataKey)) {\n            return Optional.of(node.getData(dataKey));\n        }\n        return Optional.empty();\n    }\n\n    protected MethodUsage toMethodUsage(MethodReferenceExpr methodReferenceExpr, List<ResolvedType> paramTypes) {\n        Expression scope = methodReferenceExpr.getScope();\n        ResolvedType typeOfScope = getType(methodReferenceExpr.getScope());\n        if (!typeOfScope.isReferenceType()) {\n            throw new UnsupportedOperationException(typeOfScope.getClass().getCanonicalName());\n        }\n\n        Optional<MethodUsage> result;\n        Set<MethodUsage> allMethods = typeOfScope.asReferenceType().getTypeDeclaration()\n                .orElseThrow(() -> new RuntimeException(\"TypeDeclaration unexpectedly empty.\"))\n                .getAllMethods();\n\n        if (scope instanceof TypeExpr) {\n            // static methods should match all params\n            List<MethodUsage> staticMethodUsages = allMethods.stream()\n                    .filter(it -> it.getDeclaration().isStatic())\n                    .collect(Collectors.toList());\n\n            result = MethodResolutionLogic.findMostApplicableUsage(staticMethodUsages, methodReferenceExpr.getIdentifier(), paramTypes, typeSolver);\n\n            if (!paramTypes.isEmpty()) {\n                // instance methods are called on the first param and should match all other params\n                List<MethodUsage> instanceMethodUsages = allMethods.stream()\n                        .filter(it -> !it.getDeclaration().isStatic())\n                        .collect(Collectors.toList());\n\n                List<ResolvedType> instanceMethodParamTypes = new ArrayList<>(paramTypes);\n                instanceMethodParamTypes.remove(0); // remove the first one\n\n                Optional<MethodUsage> instanceResult = MethodResolutionLogic.findMostApplicableUsage(\n                        instanceMethodUsages, methodReferenceExpr.getIdentifier(), instanceMethodParamTypes, typeSolver);\n                if (result.isPresent() && instanceResult.isPresent()) {\n                    throw new MethodAmbiguityException(\"Ambiguous method call: cannot find a most applicable method for \" + methodReferenceExpr.getIdentifier());\n                }\n\n                if (instanceResult.isPresent()) {\n                    result = instanceResult;\n                }\n            }\n        } else {\n            result = MethodResolutionLogic.findMostApplicableUsage(new ArrayList<>(allMethods), methodReferenceExpr.getIdentifier(), paramTypes, typeSolver);\n\n            if (result.isPresent() && result.get().getDeclaration().isStatic()) {\n                throw new RuntimeException(\"Invalid static method reference \" + methodReferenceExpr.getIdentifier());\n            }\n        }\n\n        if (!result.isPresent()) {\n            throw new UnsupportedOperationException();\n        }\n\n        return result.get();\n    }\n\n    protected ResolvedType getBinaryTypeConcrete(Node left, Node right, boolean solveLambdas, BinaryExpr.Operator operator) {\n        ResolvedType leftType = getTypeConcrete(left, solveLambdas);\n        ResolvedType rightType = getTypeConcrete(right, solveLambdas);\n\n        // JLS 15.18.1. String Concatenation Operator +\n        // If only one operand expression is of type String, then string conversion (\u00a75.1.11) is performed on the other\n        // operand to produce a string at run time.\n        //\n        // The result of string concatenation is a reference to a String object that is the concatenation of the two\n        // operand strings. The characters of the left-hand operand precede the characters of the right-hand operand in\n        // the newly created string.\n\n        if (operator == BinaryExpr.Operator.PLUS) {\n            boolean isLeftString = leftType.isReferenceType() && leftType.asReferenceType()\n                    .getQualifiedName().equals(JAVA_LANG_STRING);\n            boolean isRightString = rightType.isReferenceType() && rightType.asReferenceType()\n                    .getQualifiedName().equals(JAVA_LANG_STRING);\n            if (isLeftString || isRightString) {\n                return isLeftString ? leftType : rightType;\n            }\n        }\n\n        // JLS 5.6.2. Binary Numeric Promotion\n        //\n        // Widening primitive conversion (\u00a75.1.2) is applied to convert either or both operands as specified by the\n        // following rules:\n        //\n        // * If either operand is of type double, the other is converted to double.\n        // * Otherwise, if either operand is of type float, the other is converted to float.\n        // * Otherwise, if either operand is of type long, the other is converted to long.\n        // * Otherwise, both operands are converted to type int.\n\n        boolean isLeftNumeric = leftType.isPrimitive() && leftType.asPrimitive().isNumeric();\n        boolean isRightNumeric = rightType.isPrimitive() && rightType.asPrimitive().isNumeric();\n\n        if (isLeftNumeric && isRightNumeric) {\n            return leftType.asPrimitive().bnp(rightType.asPrimitive());\n        }\n\n        if (rightType.isAssignableBy(leftType)) {\n            return rightType;\n        }\n        return leftType;\n    }\n\n\n    /**\n     * Should return more like a TypeApplication: a TypeDeclaration and possible typeParametersValues or array\n     * modifiers.\n     */\n    private ResolvedType getTypeConcrete(Node node, boolean solveLambdas) {\n        if (node == null) throw new IllegalArgumentException();\n        return node.accept(typeExtractor, solveLambdas);\n    }\n\n    /**\n     * Where a node has an interface/class/enum declaration as its ancestor, return the nearest one.\n     * <p>\n     * NOTE: See {@link #findContainingTypeDeclOrObjectCreationExpr} if wanting to include anonymous inner classes.\n     * <p>\n     * For example, these all return X:\n     * {@code public interface X { ... node here ... }}\n     * {@code public class X { ... node here ... }}\n     * {@code public enum X { ... node here ... }}\n     *\n     * @param node The Node whose ancestors will be traversed,\n     * @return The first class/interface/enum declaration in the Node's ancestry.\n     */\n    protected TypeDeclaration<?> findContainingTypeDecl(Node node) {\n        Node parent = node;\n        while (true) {\n            parent = demandParentNode(parent);\n            if (parent instanceof TypeDeclaration) {\n                return (TypeDeclaration<?>) parent;\n            }\n        }\n    }\n\n    /**\n     * Where a node has an interface/class/enum declaration -- or an object creation expression (anonymous inner class)\n     * -- as its ancestor, return the nearest one.\n     * <p>\n     * NOTE: See {@link #findContainingTypeDecl} if wanting to not include anonymous inner classes.\n     * <p>\n     * For example, these all return X:\n     * <ul>\n     *     <li>{@code public interface X { ... node here ... }}</li>\n     *     <li>{@code public class X { ... node here ... }}</li>\n     *     <li>{@code public enum X { ... node here ... }}</li>\n     *     <li><pre>{@code\n     *     new ActionListener() {\n     *          ... node here ...\n     *          public void actionPerformed(ActionEvent e) {\n     *               ... or node here ...\n     *          }\n     *     }\n     *     }</pre></li>\n     * </ul>\n     * <p>\n     *\n     * @param node The Node whose ancestors will be traversed,\n     * @return The first class/interface/enum declaration -- or object creation expression (anonymous inner class) -- in\n     * the Node's ancestry.\n     */\n    protected Node findContainingTypeDeclOrObjectCreationExpr(Node node) {\n        Node parent = node;\n        boolean detachFlag = false;\n        while (true) {\n            parent = demandParentNode(parent);\n            if (parent instanceof BodyDeclaration) {\n                if (parent instanceof TypeDeclaration) {\n                    return parent;\n                } else {\n                    detachFlag = true;\n                }\n            } else if (parent instanceof ObjectCreationExpr) {\n                if (detachFlag) {\n                    return parent;\n                }\n            }\n        }\n    }\n\n    /**\n     * Where a node has an interface/class/enum declaration -- or an object creation expression in an inner class\n     * references an outer class -- as its ancestor, return the declaration corresponding to the class name specified.\n     */\n    protected Node findContainingTypeDeclOrObjectCreationExpr(Node node, String className) {\n        Node parent = node;\n        boolean detachFlag = false;\n        while (true) {\n            parent = demandParentNode(parent);\n            if (parent instanceof BodyDeclaration) {\n                if (parent instanceof TypeDeclaration && ((TypeDeclaration<?>) parent).getFullyQualifiedName().get().endsWith(className)) {\n                    return parent;\n                } else {\n                    detachFlag = true;\n                }\n            } else if (parent instanceof ObjectCreationExpr) {\n                if (detachFlag) {\n                    return parent;\n                }\n            }\n        }\n    }\n\n\n    public ResolvedType convertToUsageVariableType(VariableDeclarator var) {\n        return get(typeSolver).convertToUsage(var.getType(), var);\n    }\n\n    public ResolvedType convertToUsage(Type type, Node context) {\n        if (type.isUnknownType()) {\n            throw new IllegalArgumentException(\"Inferred lambda parameter type\");\n        }\n        return convertToUsage(type, JavaParserFactory.getContext(context, typeSolver));\n    }\n\n    public ResolvedType convertToUsage(Type type) {\n        return convertToUsage(type, type);\n    }\n\n    // This is an hack around an issue in JavaParser\n    private String qName(ClassOrInterfaceType classOrInterfaceType) {\n        String name = classOrInterfaceType.getName().getId();\n        if (classOrInterfaceType.getScope().isPresent()) {\n            return qName(classOrInterfaceType.getScope().get()) + \".\" + name;\n        }\n        return name;\n    }\n\n    protected ResolvedType convertToUsage(Type type, Context context) {\n        if (context == null) {\n            throw new NullPointerException(\"Context should not be null\");\n        }\n        if (type instanceof ClassOrInterfaceType) {\n            return convertToUsage((ClassOrInterfaceType) type, context);\n        } else if (type instanceof PrimitiveType) {\n            return ResolvedPrimitiveType.byName(((PrimitiveType) type).getType().name());\n        } else if (type instanceof WildcardType) {\n            return convertToUsage((WildcardType) type, context);\n        } else if (type instanceof VoidType) {\n            return ResolvedVoidType.INSTANCE;\n        } else if (type instanceof ArrayType) {\n            return convertToUsage((ArrayType) type, context);\n        } else if (type instanceof UnionType) {\n            UnionType unionType = (UnionType) type;\n            return new ResolvedUnionType(unionType.getElements().stream().map(el -> convertToUsage(el, context)).collect(Collectors.toList()));\n        } else if (type instanceof VarType) {\n            Node parent = type.getParentNode().get();\n            if (!(parent instanceof VariableDeclarator)) {\n                throw new IllegalStateException(\"Trying to resolve a `var` which is not in a variable declaration.\");\n            }\n            final VariableDeclarator variableDeclarator = (VariableDeclarator) parent;\n            return variableDeclarator.getInitializer()\n                    .map(Expression::calculateResolvedType)\n                    .orElseThrow(() -> new IllegalStateException(\"Cannot resolve `var` which has no initializer.\"));\n        } else {\n            throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n        }\n    }\n\n    protected ResolvedType convertToUsage(ClassOrInterfaceType classOrInterfaceType, Context context) {\n        String name = qName(classOrInterfaceType);\n        SymbolReference<ResolvedTypeDeclaration> ref = context.solveType(name);\n        if (!ref.isSolved()) {\n            throw new UnsolvedSymbolException(name);\n        }\n        ResolvedTypeDeclaration typeDeclaration = ref.getCorrespondingDeclaration();\n        List<ResolvedType> typeParameters = Collections.emptyList();\n        if (classOrInterfaceType.getTypeArguments().isPresent()) {\n            typeParameters = classOrInterfaceType.getTypeArguments().get().stream().map((pt) -> convertToUsage(pt, context)).collect(Collectors.toList());\n        }\n        if (typeDeclaration.isTypeParameter()) {\n            if (typeDeclaration instanceof ResolvedTypeParameterDeclaration) {\n                return new ResolvedTypeVariable((ResolvedTypeParameterDeclaration) typeDeclaration);\n            } else {\n                JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration = (JavaParserTypeVariableDeclaration) typeDeclaration;\n                return new ResolvedTypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n            }\n        } else {\n            return new ReferenceTypeImpl((ResolvedReferenceTypeDeclaration) typeDeclaration, typeParameters, typeSolver);\n        }\n    }\n\n    protected ResolvedType convertToUsage(WildcardType wildcardType, Context context) {\n        if (wildcardType.getExtendedType().isPresent() && !wildcardType.getSuperType().isPresent()) {\n            return ResolvedWildcard.extendsBound(convertToUsage(wildcardType.getExtendedType().get(), context)); // removed (ReferenceTypeImpl)\n        } else if (!wildcardType.getExtendedType().isPresent() && wildcardType.getSuperType().isPresent()) {\n            return ResolvedWildcard.superBound(convertToUsage(wildcardType.getSuperType().get(), context)); // removed (ReferenceTypeImpl)\n        } else if (!wildcardType.getExtendedType().isPresent() && !wildcardType.getSuperType().isPresent()) {\n            return ResolvedWildcard.UNBOUNDED;\n        } else {\n            throw new UnsupportedOperationException(wildcardType.toString());\n        }\n    }\n\n    protected ResolvedType convertToUsage(ArrayType arrayType, Context context) {\n        return new ResolvedArrayType(convertToUsage(arrayType.getComponentType(), context));\n    }\n\n    public ResolvedType convert(Type type, Node node) {\n        return convert(type, JavaParserFactory.getContext(node, typeSolver));\n    }\n\n    public ResolvedType convert(Type type, Context context) {\n        return convertToUsage(type, context);\n    }\n\n    public MethodUsage solveMethodAsUsage(MethodCallExpr call) {\n        List<ResolvedType> params = new ArrayList<>();\n        if (call.getArguments() != null) {\n            for (Expression param : call.getArguments()) {\n                //getTypeConcrete(Node node, boolean solveLambdas)\n                try {\n                    params.add(getType(param, false));\n                } catch (Exception e) {\n                    throw new RuntimeException(String.format(\"Error calculating the type of parameter %s of method call %s\", param, call), e);\n                }\n                //params.add(getTypeConcrete(param, false));\n            }\n        }\n        Context context = JavaParserFactory.getContext(call, typeSolver);\n        Optional<MethodUsage> methodUsage = context.solveMethodAsUsage(call.getName().getId(), params);\n        if (!methodUsage.isPresent()) {\n            throw new RuntimeException(\"Method '\" + call.getName() + \"' cannot be resolved in context \"\n                    + call + \" (line: \" + call.getRange().map(r -> \"\" + r.begin.line).orElse(\"??\") + \") \" + context + \". Parameter types: \" + params);\n        }\n        return methodUsage.get();\n    }\n\n    public ResolvedReferenceTypeDeclaration getTypeDeclaration(Node node) {\n        if (node instanceof TypeDeclaration) {\n            return getTypeDeclaration((TypeDeclaration) node);\n        } else if (node instanceof ObjectCreationExpr) {\n            return new JavaParserAnonymousClassDeclaration((ObjectCreationExpr) node, typeSolver);\n        } else {\n            throw new IllegalArgumentException();\n        }\n    }\n\n    public ResolvedReferenceTypeDeclaration getTypeDeclaration(ClassOrInterfaceDeclaration classOrInterfaceDeclaration) {\n        return JavaParserFactory.toTypeDeclaration(classOrInterfaceDeclaration, typeSolver);\n    }\n\n    /**\n     * \"this\" inserted in the given point, which type would have?\n     */\n    public ResolvedType getTypeOfThisIn(Node node) {\n        // TODO consider static methods\n        if (node instanceof ClassOrInterfaceDeclaration) {\n            return new ReferenceTypeImpl(getTypeDeclaration((ClassOrInterfaceDeclaration) node), typeSolver);\n        } else if (node instanceof EnumDeclaration) {\n            JavaParserEnumDeclaration enumDeclaration = new JavaParserEnumDeclaration((EnumDeclaration) node, typeSolver);\n            return new ReferenceTypeImpl(enumDeclaration, typeSolver);\n        } else if (node instanceof ObjectCreationExpr && ((ObjectCreationExpr) node).getAnonymousClassBody().isPresent()) {\n            JavaParserAnonymousClassDeclaration anonymousDeclaration = new JavaParserAnonymousClassDeclaration((ObjectCreationExpr) node, typeSolver);\n            return new ReferenceTypeImpl(anonymousDeclaration, typeSolver);\n        }\n        return getTypeOfThisIn(demandParentNode(node));\n    }\n\n    public ResolvedReferenceTypeDeclaration getTypeDeclaration(TypeDeclaration<?> typeDeclaration) {\n        return JavaParserFactory.toTypeDeclaration(typeDeclaration, typeSolver);\n    }\n\n    public ResolvedType classToResolvedType(Class<?> clazz) {\n        if (clazz.isPrimitive()) {\n            return ResolvedPrimitiveType.byName(clazz.getName());\n        }\n\n        ResolvedReferenceTypeDeclaration declaration;\n        if (clazz.isAnnotation()) {\n            declaration = new ReflectionAnnotationDeclaration(clazz, typeSolver);\n        } else if (clazz.isEnum()) {\n            declaration = new ReflectionEnumDeclaration(clazz, typeSolver);\n        } else if (clazz.isInterface()) {\n            declaration = new ReflectionInterfaceDeclaration(clazz, typeSolver);\n        } else {\n            declaration = new ReflectionClassDeclaration(clazz, typeSolver);\n        }\n        return new ReferenceTypeImpl(declaration, typeSolver);\n    }\n\n}\n",
        "filePathAfter": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java",
        "sourceCodeAfterForWhole": "/*\n * Copyright (C) 2015-2016 Federico Tomassetti\n * Copyright (C) 2017-2020 The JavaParser Team.\n *\n * This file is part of JavaParser.\n *\n * JavaParser can be used either under the terms of\n * a) the GNU Lesser General Public License as published by\n *     the Free Software Foundation, either version 3 of the License, or\n *     (at your option) any later version.\n * b) the terms of the Apache License\n *\n * You should have received a copy of both licenses in LICENCE.LGPL and\n * LICENCE.APACHE. Please refer to those files for details.\n *\n * JavaParser is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n */\n\npackage com.github.javaparser.symbolsolver.javaparsermodel;\n\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.DataKey;\nimport com.github.javaparser.ast.Node;\nimport com.github.javaparser.ast.NodeList;\nimport com.github.javaparser.ast.body.BodyDeclaration;\nimport com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;\nimport com.github.javaparser.ast.body.EnumDeclaration;\nimport com.github.javaparser.ast.body.TypeDeclaration;\nimport com.github.javaparser.ast.body.VariableDeclarator;\nimport com.github.javaparser.ast.expr.AnnotationExpr;\nimport com.github.javaparser.ast.expr.BinaryExpr;\nimport com.github.javaparser.ast.expr.Expression;\nimport com.github.javaparser.ast.expr.FieldAccessExpr;\nimport com.github.javaparser.ast.expr.LambdaExpr;\nimport com.github.javaparser.ast.expr.MethodCallExpr;\nimport com.github.javaparser.ast.expr.MethodReferenceExpr;\nimport com.github.javaparser.ast.expr.NameExpr;\nimport com.github.javaparser.ast.expr.ObjectCreationExpr;\nimport com.github.javaparser.ast.expr.SimpleName;\nimport com.github.javaparser.ast.expr.ThisExpr;\nimport com.github.javaparser.ast.expr.TypeExpr;\nimport com.github.javaparser.ast.stmt.ExplicitConstructorInvocationStmt;\nimport com.github.javaparser.ast.type.ArrayType;\nimport com.github.javaparser.ast.type.ClassOrInterfaceType;\nimport com.github.javaparser.ast.type.PrimitiveType;\nimport com.github.javaparser.ast.type.Type;\nimport com.github.javaparser.ast.type.UnionType;\nimport com.github.javaparser.ast.type.VarType;\nimport com.github.javaparser.ast.type.VoidType;\nimport com.github.javaparser.ast.type.WildcardType;\nimport com.github.javaparser.resolution.MethodAmbiguityException;\nimport com.github.javaparser.resolution.MethodUsage;\nimport com.github.javaparser.resolution.UnsolvedSymbolException;\nimport com.github.javaparser.resolution.declarations.ResolvedAnnotationDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedClassDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedConstructorDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedMethodDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedReferenceTypeDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedTypeDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedTypeParameterDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedValueDeclaration;\nimport com.github.javaparser.resolution.types.ResolvedArrayType;\nimport com.github.javaparser.resolution.types.ResolvedPrimitiveType;\nimport com.github.javaparser.resolution.types.ResolvedReferenceType;\nimport com.github.javaparser.resolution.types.ResolvedType;\nimport com.github.javaparser.resolution.types.ResolvedTypeVariable;\nimport com.github.javaparser.resolution.types.ResolvedUnionType;\nimport com.github.javaparser.resolution.types.ResolvedVoidType;\nimport com.github.javaparser.resolution.types.ResolvedWildcard;\nimport com.github.javaparser.symbolsolver.core.resolution.Context;\nimport com.github.javaparser.symbolsolver.javaparsermodel.contexts.FieldAccessContext;\nimport com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserAnonymousClassDeclaration;\nimport com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserEnumDeclaration;\nimport com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserTypeVariableDeclaration;\nimport com.github.javaparser.symbolsolver.model.resolution.SymbolReference;\nimport com.github.javaparser.symbolsolver.model.resolution.TypeSolver;\nimport com.github.javaparser.symbolsolver.model.typesystem.ReferenceTypeImpl;\nimport com.github.javaparser.symbolsolver.reflectionmodel.ReflectionAnnotationDeclaration;\nimport com.github.javaparser.symbolsolver.reflectionmodel.ReflectionClassDeclaration;\nimport com.github.javaparser.symbolsolver.reflectionmodel.ReflectionEnumDeclaration;\nimport com.github.javaparser.symbolsolver.reflectionmodel.ReflectionInterfaceDeclaration;\nimport com.github.javaparser.symbolsolver.resolution.ConstructorResolutionLogic;\nimport com.github.javaparser.symbolsolver.resolution.MethodResolutionLogic;\nimport com.github.javaparser.symbolsolver.resolution.SymbolSolver;\nimport com.github.javaparser.utils.Log;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.Set;\nimport java.util.WeakHashMap;\nimport java.util.stream.Collectors;\n\nimport static com.github.javaparser.symbolsolver.javaparser.Navigator.demandParentNode;\nimport static com.github.javaparser.symbolsolver.model.resolution.SymbolReference.solved;\nimport static com.github.javaparser.symbolsolver.model.resolution.SymbolReference.unsolved;\n\n/**\n * Class to be used by final users to solve symbols for JavaParser ASTs.\n *\n * @author Federico Tomassetti\n */\npublic class JavaParserFacade {\n\n    private static final DataKey<ResolvedType> TYPE_WITH_LAMBDAS_RESOLVED = new DataKey<ResolvedType>() {\n    };\n    private static final DataKey<ResolvedType> TYPE_WITHOUT_LAMBDAS_RESOLVED = new DataKey<ResolvedType>() {\n    };\n\n    private static final Map<TypeSolver, JavaParserFacade> instances = new WeakHashMap<>();\n    \n    private static String JAVA_LANG_STRING = String.class.getCanonicalName();\n    \n    private final TypeSolver typeSolver;\n    private final TypeExtractor typeExtractor;\n    private final SymbolSolver symbolSolver;\n\n    private JavaParserFacade(TypeSolver typeSolver) {\n        this.typeSolver = typeSolver.getRoot();\n        this.symbolSolver = new SymbolSolver(typeSolver);\n        this.typeExtractor = new TypeExtractor(typeSolver, this);\n    }\n\n    public TypeSolver getTypeSolver() {\n        return typeSolver;\n    }\n\n    public SymbolSolver getSymbolSolver() {\n        return symbolSolver;\n    }\n\n    /**\n     * Note that the addition of the modifier {@code synchronized} is specific and directly in response to issue #2668.\n     * <br>This <strong>MUST NOT</strong> be misinterpreted as a signal that JavaParser is safe to use within a multi-threaded environment.\n     * <br>\n     * <br>Additional discussion and context from a user attempting multithreading can be found within issue #2671 .\n     * <br>\n     *\n     * @see <a href=\"https://github.com/javaparser/javaparser/issues/2668\">https://github.com/javaparser/javaparser/issues/2668</a>\n     * @see <a href=\"https://github.com/javaparser/javaparser/issues/2671\">https://github.com/javaparser/javaparser/issues/2671</a>\n     */\n    public synchronized static JavaParserFacade get(TypeSolver typeSolver) {\n        return instances.computeIfAbsent(typeSolver, JavaParserFacade::new);\n    }\n\n    /**\n     * This method is used to clear internal caches for the sake of releasing memory.\n     */\n    public static void clearInstances() {\n        instances.clear();\n    }\n\n    protected static ResolvedType solveGenericTypes(ResolvedType type, Context context) {\n        if (type.isTypeVariable()) {\n            return context.solveGenericType(type.describe()).orElse(type);\n        }\n        if (type.isWildcard()) {\n            if (type.asWildcard().isExtends() || type.asWildcard().isSuper()) {\n                ResolvedWildcard wildcardUsage = type.asWildcard();\n                ResolvedType boundResolved = solveGenericTypes(wildcardUsage.getBoundedType(), context);\n                if (wildcardUsage.isExtends()) {\n                    return ResolvedWildcard.extendsBound(boundResolved);\n                } else {\n                    return ResolvedWildcard.superBound(boundResolved);\n                }\n            }\n        }\n        return type;\n    }\n\n    public SymbolReference<? extends ResolvedValueDeclaration> solve(NameExpr nameExpr) {\n        return symbolSolver.solveSymbol(nameExpr.getName().getId(), nameExpr);\n    }\n\n    public SymbolReference<? extends ResolvedValueDeclaration> solve(SimpleName nameExpr) {\n        return symbolSolver.solveSymbol(nameExpr.getId(), nameExpr);\n    }\n\n    public SymbolReference<? extends ResolvedValueDeclaration> solve(Expression expr) {\n        return expr.toNameExpr().map(this::solve).orElseThrow(() -> new IllegalArgumentException(expr.getClass().getCanonicalName()));\n    }\n\n    public SymbolReference<ResolvedMethodDeclaration> solve(MethodCallExpr methodCallExpr) {\n        return solve(methodCallExpr, true);\n    }\n\n    public SymbolReference<ResolvedMethodDeclaration> solve(MethodReferenceExpr methodReferenceExpr) {\n        return solve(methodReferenceExpr, true);\n    }\n\n    public SymbolReference<ResolvedConstructorDeclaration> solve(ObjectCreationExpr objectCreationExpr) {\n        return solve(objectCreationExpr, true);\n    }\n\n    public SymbolReference<ResolvedConstructorDeclaration> solve(ExplicitConstructorInvocationStmt explicitConstructorInvocationStmt) {\n        return solve(explicitConstructorInvocationStmt, true);\n    }\n\n    public SymbolReference<ResolvedConstructorDeclaration> solve(ExplicitConstructorInvocationStmt explicitConstructorInvocationStmt, boolean solveLambdas) {\n        // Constructor invocation must exist within a class (not interface).\n        Optional<ClassOrInterfaceDeclaration> optAncestorClassOrInterfaceNode = explicitConstructorInvocationStmt.findAncestor(ClassOrInterfaceDeclaration.class);\n        if (!optAncestorClassOrInterfaceNode.isPresent()) {\n            return unsolved(ResolvedConstructorDeclaration.class);\n        }\n\n        ClassOrInterfaceDeclaration classOrInterfaceNode = optAncestorClassOrInterfaceNode.get();\n        ResolvedReferenceTypeDeclaration resolvedClassNode = classOrInterfaceNode.resolve();\n        if (!resolvedClassNode.isClass()) {\n            throw new IllegalStateException(\"Expected to be a class -- cannot call this() or super() within an interface.\");\n        }\n\n        ResolvedTypeDeclaration typeDecl = null;\n        if (explicitConstructorInvocationStmt.isThis()) {\n            // this()\n            typeDecl = resolvedClassNode.asReferenceType();\n        } else {\n            // super()\n            Optional<ResolvedReferenceType> superClass = resolvedClassNode.asClass().getSuperClass();\n            if (superClass.isPresent() && superClass.get().getTypeDeclaration().isPresent()) {\n                typeDecl = superClass.get().getTypeDeclaration().get();\n            }\n        }\n        if (typeDecl == null) {\n            return unsolved(ResolvedConstructorDeclaration.class);\n        }\n\n        // Solve each of the arguments being passed into this constructor invocation.\n        List<ResolvedType> argumentTypes = new LinkedList<>();\n        List<LambdaArgumentTypePlaceholder> placeholders = new LinkedList<>();\n        solveArguments(explicitConstructorInvocationStmt, explicitConstructorInvocationStmt.getArguments(), solveLambdas, argumentTypes, placeholders);\n\n        // Determine which constructor is referred to, and return it.\n        SymbolReference<ResolvedConstructorDeclaration> res = ConstructorResolutionLogic.findMostApplicable(((ResolvedClassDeclaration) typeDecl).getConstructors(), argumentTypes, typeSolver);\n        for (LambdaArgumentTypePlaceholder placeholder : placeholders) {\n            placeholder.setMethod(res);\n        }\n\n        return res;\n    }\n\n    public SymbolReference<ResolvedTypeDeclaration> solve(ThisExpr node) {\n        // If 'this' is prefixed by a class eg. MyClass.this\n        if (node.getTypeName().isPresent()) {\n            // Get the class name\n            String className = node.getTypeName().get().asString();\n            // Attempt to resolve using a typeSolver\n            SymbolReference<ResolvedReferenceTypeDeclaration> clazz = typeSolver.tryToSolveType(className);\n            if (clazz.isSolved()) {\n                return solved(clazz.getCorrespondingDeclaration());\n            }\n            // Attempt to resolve locally in Compilation unit\n            Optional<CompilationUnit> cu = node.findAncestor(CompilationUnit.class);\n            if (cu.isPresent()) {\n                Optional<ClassOrInterfaceDeclaration> classByName = cu.get().getClassByName(className);\n                if (classByName.isPresent()) {\n                    return solved(getTypeDeclaration(classByName.get()));\n                }\n            }\n        }\n        return solved(getTypeDeclaration(findContainingTypeDeclOrObjectCreationExpr(node)));\n    }\n\n    /**\n     * Given a constructor call find out to which constructor declaration it corresponds.\n     */\n    public SymbolReference<ResolvedConstructorDeclaration> solve(ObjectCreationExpr objectCreationExpr, boolean solveLambdas) {\n        List<ResolvedType> argumentTypes = new LinkedList<>();\n        List<LambdaArgumentTypePlaceholder> placeholders = new LinkedList<>();\n\n        solveArguments(objectCreationExpr, objectCreationExpr.getArguments(), solveLambdas, argumentTypes, placeholders);\n\n        ResolvedReferenceTypeDeclaration typeDecl = null;\n        if (objectCreationExpr.getAnonymousClassBody().isPresent()) {\n            typeDecl = new JavaParserAnonymousClassDeclaration(objectCreationExpr, typeSolver);\n        } else {\n            ResolvedType classDecl = JavaParserFacade.get(typeSolver).convert(objectCreationExpr.getType(), objectCreationExpr);\n            if (classDecl.isReferenceType() && classDecl.asReferenceType().getTypeDeclaration().isPresent()) {\n                typeDecl = classDecl.asReferenceType().getTypeDeclaration().get();\n            }\n        }\n        if (typeDecl == null) {\n            return unsolved(ResolvedConstructorDeclaration.class);\n        }\n        SymbolReference<ResolvedConstructorDeclaration> res = ConstructorResolutionLogic.findMostApplicable(typeDecl.getConstructors(), argumentTypes, typeSolver);\n        for (LambdaArgumentTypePlaceholder placeholder : placeholders) {\n            placeholder.setMethod(res);\n        }\n        return res;\n    }\n\n    private void solveArguments(Node node, NodeList<Expression> args, boolean solveLambdas, List<ResolvedType> argumentTypes,\n                                List<LambdaArgumentTypePlaceholder> placeholders) {\n        int i = 0;\n        for (Expression parameterValue : args) {\n            if (parameterValue instanceof LambdaExpr || parameterValue instanceof MethodReferenceExpr) {\n                LambdaArgumentTypePlaceholder placeholder = new LambdaArgumentTypePlaceholder(i);\n                argumentTypes.add(placeholder);\n                placeholders.add(placeholder);\n            } else {\n                try {\n                    argumentTypes.add(JavaParserFacade.get(typeSolver).getType(parameterValue, solveLambdas));\n                } catch (UnsolvedSymbolException e) {\n                    throw e;\n                } catch (Exception e) {\n                    throw new RuntimeException(String.format(\"Unable to calculate the type of a parameter of a method call. Method call: %s, Parameter: %s\",\n                            node, parameterValue), e);\n                }\n            }\n            i++;\n        }\n    }\n\n    /**\n     * Given a method call find out to which method declaration it corresponds.\n     */\n    public SymbolReference<ResolvedMethodDeclaration> solve(MethodCallExpr methodCallExpr, boolean solveLambdas) {\n        List<ResolvedType> argumentTypes = new LinkedList<>();\n        List<LambdaArgumentTypePlaceholder> placeholders = new LinkedList<>();\n\n        solveArguments(methodCallExpr, methodCallExpr.getArguments(), solveLambdas, argumentTypes, placeholders);\n\n        SymbolReference<ResolvedMethodDeclaration> res = JavaParserFactory.getContext(methodCallExpr, typeSolver).solveMethod(methodCallExpr.getName().getId(), argumentTypes, false);\n        for (LambdaArgumentTypePlaceholder placeholder : placeholders) {\n            placeholder.setMethod(res);\n        }\n        return res;\n    }\n\n    /**\n     * Given a method reference find out to which method declaration it corresponds.\n     */\n    public SymbolReference<ResolvedMethodDeclaration> solve(MethodReferenceExpr methodReferenceExpr, boolean solveLambdas) {\n        // pass empty argument list to be populated\n        List<ResolvedType> argumentTypes = new LinkedList<>();\n        return JavaParserFactory.getContext(methodReferenceExpr, typeSolver).solveMethod(methodReferenceExpr.getIdentifier(), argumentTypes, false);\n    }\n\n    public SymbolReference<ResolvedAnnotationDeclaration> solve(AnnotationExpr annotationExpr) {\n        Context context = JavaParserFactory.getContext(annotationExpr, typeSolver);\n        SymbolReference<ResolvedTypeDeclaration> typeDeclarationSymbolReference = context.solveType(annotationExpr.getNameAsString());\n        if (typeDeclarationSymbolReference.isSolved()) {\n            ResolvedAnnotationDeclaration annotationDeclaration = (ResolvedAnnotationDeclaration) typeDeclarationSymbolReference.getCorrespondingDeclaration();\n            return solved(annotationDeclaration);\n        } else {\n            return unsolved(ResolvedAnnotationDeclaration.class);\n        }\n    }\n\n    public SymbolReference<ResolvedValueDeclaration> solve(FieldAccessExpr fieldAccessExpr) {\n        return ((FieldAccessContext) JavaParserFactory.getContext(fieldAccessExpr, typeSolver)).solveField(fieldAccessExpr.getName().getId());\n    }\n\n    /**\n     * Get the type associated with the node.\n     * <p>\n     * This method was originally intended to get the type of a value: any value has a type.\n     * <p>\n     * For example:\n     * <pre>\n     * int foo(int a) {\n     *     return a; // when getType is invoked on \"a\" it returns the type \"int\"\n     * }\n     * </pre>\n     * <p>\n     * Now, users started using also of names of types itself, which do not have a type.\n     * <p>\n     * For example:\n     * <pre>\n     * class A {\n     *     int foo(int a) {\n     *         return A.someStaticField; // when getType is invoked on \"A\", which represents a class, it returns\n     *             // the type \"A\" itself while it used to throw UnsolvedSymbolException\n     * }\n     * </pre>\n     * <p>\n     * To accommodate this usage and avoid confusion this method return\n     * the type itself when used on the name of type.\n     */\n    public ResolvedType getType(Node node) {\n        try {\n            return getType(node, true);\n        } catch (UnsolvedSymbolException e) {\n            if (node instanceof NameExpr) {\n                NameExpr nameExpr = (NameExpr) node;\n                SymbolReference<ResolvedTypeDeclaration> typeDeclaration = JavaParserFactory.getContext(node, typeSolver)\n                        .solveType(nameExpr.getNameAsString());\n                if (typeDeclaration.isSolved() && typeDeclaration.getCorrespondingDeclaration() instanceof ResolvedReferenceTypeDeclaration) {\n                    ResolvedReferenceTypeDeclaration resolvedReferenceTypeDeclaration = (ResolvedReferenceTypeDeclaration) typeDeclaration.getCorrespondingDeclaration();\n                    return ReferenceTypeImpl.undeterminedParameters(resolvedReferenceTypeDeclaration, typeSolver);\n                }\n            }\n            throw e;\n        }\n    }\n\n    public ResolvedType getType(Node node, boolean solveLambdas) {\n        if (solveLambdas) {\n            if (!node.containsData(TYPE_WITH_LAMBDAS_RESOLVED)) {\n                ResolvedType res = getTypeConcrete(node, solveLambdas);\n\n                node.setData(TYPE_WITH_LAMBDAS_RESOLVED, res);\n\n                boolean secondPassNecessary = false;\n                if (node instanceof MethodCallExpr) {\n                    MethodCallExpr methodCallExpr = (MethodCallExpr) node;\n                    for (Node arg : methodCallExpr.getArguments()) {\n                        if (!arg.containsData(TYPE_WITH_LAMBDAS_RESOLVED)) {\n                            getType(arg, true);\n                            secondPassNecessary = true;\n                        }\n                    }\n                }\n                if (secondPassNecessary) {\n                    node.removeData(TYPE_WITH_LAMBDAS_RESOLVED);\n                    ResolvedType type = getType(node, true);\n                    node.setData(TYPE_WITH_LAMBDAS_RESOLVED, type);\n\n                }\n                Log.trace(\"getType on %s  -> %s\", () -> node, () -> res);\n            }\n            return node.getData(TYPE_WITH_LAMBDAS_RESOLVED);\n        } else {\n            Optional<ResolvedType> res = find(TYPE_WITH_LAMBDAS_RESOLVED, node);\n            if (res.isPresent()) {\n                return res.get();\n            }\n            res = find(TYPE_WITHOUT_LAMBDAS_RESOLVED, node);\n            if (!res.isPresent()) {\n                ResolvedType resType = getTypeConcrete(node, solveLambdas);\n                node.setData(TYPE_WITHOUT_LAMBDAS_RESOLVED, resType);\n                Optional<ResolvedType> finalRes = res;\n                Log.trace(\"getType on %s (no solveLambdas) -> %s\", () -> node, () -> finalRes);\n                return resType;\n            }\n            return res.get();\n        }\n    }\n\n    private Optional<ResolvedType> find(DataKey<ResolvedType> dataKey, Node node) {\n        if (node.containsData(dataKey)) {\n            return Optional.of(node.getData(dataKey));\n        }\n        return Optional.empty();\n    }\n\n    protected MethodUsage toMethodUsage(MethodReferenceExpr methodReferenceExpr, List<ResolvedType> paramTypes) {\n        Expression scope = methodReferenceExpr.getScope();\n        ResolvedType typeOfScope = getType(methodReferenceExpr.getScope());\n        if (!typeOfScope.isReferenceType()) {\n            throw new UnsupportedOperationException(typeOfScope.getClass().getCanonicalName());\n        }\n\n        Optional<MethodUsage> result;\n        Set<MethodUsage> allMethods = typeOfScope.asReferenceType().getTypeDeclaration()\n                .orElseThrow(() -> new RuntimeException(\"TypeDeclaration unexpectedly empty.\"))\n                .getAllMethods();\n\n        if (scope instanceof TypeExpr) {\n            // static methods should match all params\n            List<MethodUsage> staticMethodUsages = allMethods.stream()\n                    .filter(it -> it.getDeclaration().isStatic())\n                    .collect(Collectors.toList());\n\n            result = MethodResolutionLogic.findMostApplicableUsage(staticMethodUsages, methodReferenceExpr.getIdentifier(), paramTypes, typeSolver);\n\n            if (!paramTypes.isEmpty()) {\n                // instance methods are called on the first param and should match all other params\n                List<MethodUsage> instanceMethodUsages = allMethods.stream()\n                        .filter(it -> !it.getDeclaration().isStatic())\n                        .collect(Collectors.toList());\n\n                List<ResolvedType> instanceMethodParamTypes = new ArrayList<>(paramTypes);\n                instanceMethodParamTypes.remove(0); // remove the first one\n\n                Optional<MethodUsage> instanceResult = MethodResolutionLogic.findMostApplicableUsage(\n                        instanceMethodUsages, methodReferenceExpr.getIdentifier(), instanceMethodParamTypes, typeSolver);\n                if (result.isPresent() && instanceResult.isPresent()) {\n                    throw new MethodAmbiguityException(\"Ambiguous method call: cannot find a most applicable method for \" + methodReferenceExpr.getIdentifier());\n                }\n\n                if (instanceResult.isPresent()) {\n                    result = instanceResult;\n                }\n            }\n        } else {\n            result = MethodResolutionLogic.findMostApplicableUsage(new ArrayList<>(allMethods), methodReferenceExpr.getIdentifier(), paramTypes, typeSolver);\n\n            if (result.isPresent() && result.get().getDeclaration().isStatic()) {\n                throw new RuntimeException(\"Invalid static method reference \" + methodReferenceExpr.getIdentifier());\n            }\n        }\n\n        if (!result.isPresent()) {\n            throw new UnsupportedOperationException();\n        }\n\n        return result.get();\n    }\n\n    protected ResolvedType getBinaryTypeConcrete(Node left, Node right, boolean solveLambdas, BinaryExpr.Operator operator) {\n        ResolvedType leftType = getTypeConcrete(left, solveLambdas);\n        ResolvedType rightType = getTypeConcrete(right, solveLambdas);\n\n        // JLS 15.18.1. String Concatenation Operator +\n        // If only one operand expression is of type String, then string conversion (\u00a75.1.11) is performed on the other\n        // operand to produce a string at run time.\n        //\n        // The result of string concatenation is a reference to a String object that is the concatenation of the two\n        // operand strings. The characters of the left-hand operand precede the characters of the right-hand operand in\n        // the newly created string.\n\n        if (operator == BinaryExpr.Operator.PLUS) {\n            boolean isLeftString = leftType.isReferenceType() && leftType.asReferenceType()\n                    .getQualifiedName().equals(JAVA_LANG_STRING);\n            boolean isRightString = rightType.isReferenceType() && rightType.asReferenceType()\n                    .getQualifiedName().equals(JAVA_LANG_STRING);\n            if (isLeftString || isRightString) {\n                return isLeftString ? leftType : rightType;\n            }\n        }\n\n        // JLS 5.6.2. Binary Numeric Promotion\n        //\n        // Widening primitive conversion (\u00a75.1.2) is applied to convert either or both operands as specified by the\n        // following rules:\n        //\n        // * If either operand is of type double, the other is converted to double.\n        // * Otherwise, if either operand is of type float, the other is converted to float.\n        // * Otherwise, if either operand is of type long, the other is converted to long.\n        // * Otherwise, both operands are converted to type int.\n\n        boolean isLeftNumeric = leftType.isPrimitive() && leftType.asPrimitive().isNumeric();\n        boolean isRightNumeric = rightType.isPrimitive() && rightType.asPrimitive().isNumeric();\n\n        if (isLeftNumeric && isRightNumeric) {\n            return leftType.asPrimitive().bnp(rightType.asPrimitive());\n        }\n\n        if (rightType.isAssignableBy(leftType)) {\n            return rightType;\n        }\n        return leftType;\n    }\n\n\n    /**\n     * Should return more like a TypeApplication: a TypeDeclaration and possible typeParametersValues or array\n     * modifiers.\n     */\n    private ResolvedType getTypeConcrete(Node node, boolean solveLambdas) {\n        if (node == null) throw new IllegalArgumentException();\n        return node.accept(typeExtractor, solveLambdas);\n    }\n\n    /**\n     * Where a node has an interface/class/enum declaration as its ancestor, return the nearest one.\n     * <p>\n     * NOTE: See {@link #findContainingTypeDeclOrObjectCreationExpr} if wanting to include anonymous inner classes.\n     * <p>\n     * For example, these all return X:\n     * {@code public interface X { ... node here ... }}\n     * {@code public class X { ... node here ... }}\n     * {@code public enum X { ... node here ... }}\n     *\n     * @param node The Node whose ancestors will be traversed,\n     * @return The first class/interface/enum declaration in the Node's ancestry.\n     */\n    protected TypeDeclaration<?> findContainingTypeDecl(Node node) {\n        Node parent = node;\n        while (true) {\n            parent = demandParentNode(parent);\n            if (parent instanceof TypeDeclaration) {\n                return (TypeDeclaration<?>) parent;\n            }\n        }\n    }\n\n    /**\n     * Where a node has an interface/class/enum declaration -- or an object creation expression (anonymous inner class)\n     * -- as its ancestor, return the nearest one.\n     * <p>\n     * NOTE: See {@link #findContainingTypeDecl} if wanting to not include anonymous inner classes.\n     * <p>\n     * For example, these all return X:\n     * <ul>\n     *     <li>{@code public interface X { ... node here ... }}</li>\n     *     <li>{@code public class X { ... node here ... }}</li>\n     *     <li>{@code public enum X { ... node here ... }}</li>\n     *     <li><pre>{@code\n     *     new ActionListener() {\n     *          ... node here ...\n     *          public void actionPerformed(ActionEvent e) {\n     *               ... or node here ...\n     *          }\n     *     }\n     *     }</pre></li>\n     * </ul>\n     * <p>\n     *\n     * @param node The Node whose ancestors will be traversed,\n     * @return The first class/interface/enum declaration -- or object creation expression (anonymous inner class) -- in\n     * the Node's ancestry.\n     */\n    protected Node findContainingTypeDeclOrObjectCreationExpr(Node node) {\n        Node parent = node;\n        boolean detachFlag = false;\n        while (true) {\n            parent = demandParentNode(parent);\n            if (parent instanceof BodyDeclaration) {\n                if (parent instanceof TypeDeclaration) {\n                    return parent;\n                } else {\n                    detachFlag = true;\n                }\n            } else if (parent instanceof ObjectCreationExpr) {\n                if (detachFlag) {\n                    return parent;\n                }\n            }\n        }\n    }\n\n    /**\n     * Where a node has an interface/class/enum declaration -- or an object creation expression in an inner class\n     * references an outer class -- as its ancestor, return the declaration corresponding to the class name specified.\n     */\n    protected Node findContainingTypeDeclOrObjectCreationExpr(Node node, String className) {\n        Node parent = node;\n        boolean detachFlag = false;\n        while (true) {\n            parent = demandParentNode(parent);\n            if (parent instanceof BodyDeclaration) {\n                if (parent instanceof TypeDeclaration && ((TypeDeclaration<?>) parent).getFullyQualifiedName().get().endsWith(className)) {\n                    return parent;\n                } else {\n                    detachFlag = true;\n                }\n            } else if (parent instanceof ObjectCreationExpr) {\n                if (detachFlag) {\n                    return parent;\n                }\n            }\n        }\n    }\n\n\n    public ResolvedType convertToUsageVariableType(VariableDeclarator var) {\n        return get(typeSolver).convertToUsage(var.getType(), var);\n    }\n\n    public ResolvedType convertToUsage(Type type, Node context) {\n        if (type.isUnknownType()) {\n            throw new IllegalArgumentException(\"Inferred lambda parameter type\");\n        }\n        return convertToUsage(type, JavaParserFactory.getContext(context, typeSolver));\n    }\n\n    public ResolvedType convertToUsage(Type type) {\n        return convertToUsage(type, type);\n    }\n\n    // This is an hack around an issue in JavaParser\n    private String qName(ClassOrInterfaceType classOrInterfaceType) {\n        String name = classOrInterfaceType.getName().getId();\n        if (classOrInterfaceType.getScope().isPresent()) {\n            return qName(classOrInterfaceType.getScope().get()) + \".\" + name;\n        }\n        return name;\n    }\n\n    protected ResolvedType convertToUsage(Type type, Context context) {\n        if (context == null) {\n            throw new NullPointerException(\"Context should not be null\");\n        }\n        if (type instanceof ClassOrInterfaceType) {\n            return convertToUsage((ClassOrInterfaceType) type, context);\n        } else if (type instanceof PrimitiveType) {\n            return ResolvedPrimitiveType.byName(((PrimitiveType) type).getType().name());\n        } else if (type instanceof WildcardType) {\n            return convertToUsage((WildcardType) type, context);\n        } else if (type instanceof VoidType) {\n            return ResolvedVoidType.INSTANCE;\n        } else if (type instanceof ArrayType) {\n            return convertToUsage((ArrayType) type, context);\n        } else if (type instanceof UnionType) {\n            return convertToUsage((UnionType) type, context);\n        } else if (type instanceof VarType) {\n            Node parent = type.getParentNode().get();\n            if (!(parent instanceof VariableDeclarator)) {\n                throw new IllegalStateException(\"Trying to resolve a `var` which is not in a variable declaration.\");\n            }\n            final VariableDeclarator variableDeclarator = (VariableDeclarator) parent;\n            return variableDeclarator.getInitializer()\n                    .map(Expression::calculateResolvedType)\n                    .orElseThrow(() -> new IllegalStateException(\"Cannot resolve `var` which has no initializer.\"));\n        } else {\n            throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n        }\n    }\n\n    protected ResolvedType convertToUsage(ClassOrInterfaceType classOrInterfaceType, Context context) {\n        String name = qName(classOrInterfaceType);\n        SymbolReference<ResolvedTypeDeclaration> ref = context.solveType(name);\n        if (!ref.isSolved()) {\n            throw new UnsolvedSymbolException(name);\n        }\n        ResolvedTypeDeclaration typeDeclaration = ref.getCorrespondingDeclaration();\n        List<ResolvedType> typeParameters = Collections.emptyList();\n        if (classOrInterfaceType.getTypeArguments().isPresent()) {\n            typeParameters = classOrInterfaceType.getTypeArguments().get().stream().map((pt) -> convertToUsage(pt, context)).collect(Collectors.toList());\n        }\n        if (typeDeclaration.isTypeParameter()) {\n            if (typeDeclaration instanceof ResolvedTypeParameterDeclaration) {\n                return new ResolvedTypeVariable((ResolvedTypeParameterDeclaration) typeDeclaration);\n            } else {\n                JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration = (JavaParserTypeVariableDeclaration) typeDeclaration;\n                return new ResolvedTypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n            }\n        } else {\n            return new ReferenceTypeImpl((ResolvedReferenceTypeDeclaration) typeDeclaration, typeParameters, typeSolver);\n        }\n    }\n\n    protected ResolvedType convertToUsage(WildcardType wildcardType, Context context) {\n        if (wildcardType.getExtendedType().isPresent() && !wildcardType.getSuperType().isPresent()) {\n            return ResolvedWildcard.extendsBound(convertToUsage(wildcardType.getExtendedType().get(), context)); // removed (ReferenceTypeImpl)\n        } else if (!wildcardType.getExtendedType().isPresent() && wildcardType.getSuperType().isPresent()) {\n            return ResolvedWildcard.superBound(convertToUsage(wildcardType.getSuperType().get(), context)); // removed (ReferenceTypeImpl)\n        } else if (!wildcardType.getExtendedType().isPresent() && !wildcardType.getSuperType().isPresent()) {\n            return ResolvedWildcard.UNBOUNDED;\n        } else {\n            throw new UnsupportedOperationException(wildcardType.toString());\n        }\n    }\n\n    protected ResolvedType convertToUsage(ArrayType arrayType, Context context) {\n        return new ResolvedArrayType(convertToUsage(arrayType.getComponentType(), context));\n    }\n\n    protected ResolvedType convertToUsage(UnionType unionType, Context context) {\n        List<ResolvedType> resolvedElements = unionType.getElements().stream()\n                .map(el -> convertToUsage(el, context))\n                .collect(Collectors.toList());\n        return new ResolvedUnionType(resolvedElements);\n    }\n\n    public ResolvedType convert(Type type, Node node) {\n        return convert(type, JavaParserFactory.getContext(node, typeSolver));\n    }\n\n    public ResolvedType convert(Type type, Context context) {\n        return convertToUsage(type, context);\n    }\n\n    public MethodUsage solveMethodAsUsage(MethodCallExpr call) {\n        List<ResolvedType> params = new ArrayList<>();\n        if (call.getArguments() != null) {\n            for (Expression param : call.getArguments()) {\n                //getTypeConcrete(Node node, boolean solveLambdas)\n                try {\n                    params.add(getType(param, false));\n                } catch (Exception e) {\n                    throw new RuntimeException(String.format(\"Error calculating the type of parameter %s of method call %s\", param, call), e);\n                }\n                //params.add(getTypeConcrete(param, false));\n            }\n        }\n        Context context = JavaParserFactory.getContext(call, typeSolver);\n        Optional<MethodUsage> methodUsage = context.solveMethodAsUsage(call.getName().getId(), params);\n        if (!methodUsage.isPresent()) {\n            throw new RuntimeException(\"Method '\" + call.getName() + \"' cannot be resolved in context \"\n                    + call + \" (line: \" + call.getRange().map(r -> \"\" + r.begin.line).orElse(\"??\") + \") \" + context + \". Parameter types: \" + params);\n        }\n        return methodUsage.get();\n    }\n\n    public ResolvedReferenceTypeDeclaration getTypeDeclaration(Node node) {\n        if (node instanceof TypeDeclaration) {\n            return getTypeDeclaration((TypeDeclaration) node);\n        } else if (node instanceof ObjectCreationExpr) {\n            return new JavaParserAnonymousClassDeclaration((ObjectCreationExpr) node, typeSolver);\n        } else {\n            throw new IllegalArgumentException();\n        }\n    }\n\n    public ResolvedReferenceTypeDeclaration getTypeDeclaration(ClassOrInterfaceDeclaration classOrInterfaceDeclaration) {\n        return JavaParserFactory.toTypeDeclaration(classOrInterfaceDeclaration, typeSolver);\n    }\n\n    /**\n     * \"this\" inserted in the given point, which type would have?\n     */\n    public ResolvedType getTypeOfThisIn(Node node) {\n        // TODO consider static methods\n        if (node instanceof ClassOrInterfaceDeclaration) {\n            return new ReferenceTypeImpl(getTypeDeclaration((ClassOrInterfaceDeclaration) node), typeSolver);\n        } else if (node instanceof EnumDeclaration) {\n            JavaParserEnumDeclaration enumDeclaration = new JavaParserEnumDeclaration((EnumDeclaration) node, typeSolver);\n            return new ReferenceTypeImpl(enumDeclaration, typeSolver);\n        } else if (node instanceof ObjectCreationExpr && ((ObjectCreationExpr) node).getAnonymousClassBody().isPresent()) {\n            JavaParserAnonymousClassDeclaration anonymousDeclaration = new JavaParserAnonymousClassDeclaration((ObjectCreationExpr) node, typeSolver);\n            return new ReferenceTypeImpl(anonymousDeclaration, typeSolver);\n        }\n        return getTypeOfThisIn(demandParentNode(node));\n    }\n\n    public ResolvedReferenceTypeDeclaration getTypeDeclaration(TypeDeclaration<?> typeDeclaration) {\n        return JavaParserFactory.toTypeDeclaration(typeDeclaration, typeSolver);\n    }\n\n    public ResolvedType classToResolvedType(Class<?> clazz) {\n        if (clazz.isPrimitive()) {\n            return ResolvedPrimitiveType.byName(clazz.getName());\n        }\n\n        ResolvedReferenceTypeDeclaration declaration;\n        if (clazz.isAnnotation()) {\n            declaration = new ReflectionAnnotationDeclaration(clazz, typeSolver);\n        } else if (clazz.isEnum()) {\n            declaration = new ReflectionEnumDeclaration(clazz, typeSolver);\n        } else if (clazz.isInterface()) {\n            declaration = new ReflectionInterfaceDeclaration(clazz, typeSolver);\n        } else {\n            declaration = new ReflectionClassDeclaration(clazz, typeSolver);\n        }\n        return new ReferenceTypeImpl(declaration, typeSolver);\n    }\n\n}\n",
        "diffSourceCodeSet": [
            "protected ResolvedType convertToUsage(UnionType unionType, Context context) {\n        List<ResolvedType> resolvedElements = unionType.getElements().stream()\n                .map(el -> convertToUsage(el, context))\n                .collect(Collectors.toList());\n        return new ResolvedUnionType(resolvedElements);\n    }"
        ],
        "invokedMethodSet": [
            "methodSignature: com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade#convertToUsage\n methodBody: protected ResolvedType convertToUsage(ArrayType arrayType, Context context) {\nreturn new ResolvedArrayType(convertToUsage(arrayType.getComponentType(),context));\n}",
            "methodSignature: com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade#getType\n methodBody: public ResolvedType getType(Node node, boolean solveLambdas) {\nif(solveLambdas){if(!node.containsData(TYPE_WITH_LAMBDAS_RESOLVED)){ResolvedType res=getTypeConcrete(node,solveLambdas);\nnode.setData(TYPE_WITH_LAMBDAS_RESOLVED,res);\nboolean secondPassNecessary=false;\nif(node instanceof MethodCallExpr){MethodCallExpr methodCallExpr=(MethodCallExpr)node;\nfor(Node arg: methodCallExpr.getArguments()){if(!arg.containsData(TYPE_WITH_LAMBDAS_RESOLVED)){getType(arg,true);\nsecondPassNecessary=true;\n}}}if(secondPassNecessary){node.removeData(TYPE_WITH_LAMBDAS_RESOLVED);\nResolvedType type=getType(node,true);\nnode.setData(TYPE_WITH_LAMBDAS_RESOLVED,type);\n}Log.trace(\"getType on %s  -> %s\",() -> node,() -> res);\n}return node.getData(TYPE_WITH_LAMBDAS_RESOLVED);\n}{Optional<ResolvedType> res=find(TYPE_WITH_LAMBDAS_RESOLVED,node);\nif(res.isPresent()){return res.get();\n}res=find(TYPE_WITHOUT_LAMBDAS_RESOLVED,node);\nif(!res.isPresent()){ResolvedType resType=getTypeConcrete(node,solveLambdas);\nnode.setData(TYPE_WITHOUT_LAMBDAS_RESOLVED,resType);\nOptional<ResolvedType> finalRes=res;\nLog.trace(\"getType on %s (no solveLambdas) -> %s\",() -> node,() -> finalRes);\nreturn resType;\n}return res.get();\n}}",
            "methodSignature: com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade#get\n methodBody: public synchronized static JavaParserFacade get(TypeSolver typeSolver) {\nreturn instances.computeIfAbsent(typeSolver,JavaParserFacade::new);\n}"
        ],
        "sourceCodeAfterRefactoring": "protected ResolvedType convertToUsage(Type type, Context context) {\n        if (context == null) {\n            throw new NullPointerException(\"Context should not be null\");\n        }\n        if (type instanceof ClassOrInterfaceType) {\n            return convertToUsage((ClassOrInterfaceType) type, context);\n        } else if (type instanceof PrimitiveType) {\n            return ResolvedPrimitiveType.byName(((PrimitiveType) type).getType().name());\n        } else if (type instanceof WildcardType) {\n            return convertToUsage((WildcardType) type, context);\n        } else if (type instanceof VoidType) {\n            return ResolvedVoidType.INSTANCE;\n        } else if (type instanceof ArrayType) {\n            return convertToUsage((ArrayType) type, context);\n        } else if (type instanceof UnionType) {\n            return convertToUsage((UnionType) type, context);\n        } else if (type instanceof VarType) {\n            Node parent = type.getParentNode().get();\n            if (!(parent instanceof VariableDeclarator)) {\n                throw new IllegalStateException(\"Trying to resolve a `var` which is not in a variable declaration.\");\n            }\n            final VariableDeclarator variableDeclarator = (VariableDeclarator) parent;\n            return variableDeclarator.getInitializer()\n                    .map(Expression::calculateResolvedType)\n                    .orElseThrow(() -> new IllegalStateException(\"Cannot resolve `var` which has no initializer.\"));\n        } else {\n            throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n        }\n    }\nprotected ResolvedType convertToUsage(UnionType unionType, Context context) {\n        List<ResolvedType> resolvedElements = unionType.getElements().stream()\n                .map(el -> convertToUsage(el, context))\n                .collect(Collectors.toList());\n        return new ResolvedUnionType(resolvedElements);\n    }",
        "diffSourceCode": "   677:     protected ResolvedType convertToUsage(Type type, Context context) {\n   678:         if (context == null) {\n   679:             throw new NullPointerException(\"Context should not be null\");\n   680:         }\n   681:         if (type instanceof ClassOrInterfaceType) {\n   682:             return convertToUsage((ClassOrInterfaceType) type, context);\n   683:         } else if (type instanceof PrimitiveType) {\n   684:             return ResolvedPrimitiveType.byName(((PrimitiveType) type).getType().name());\n   685:         } else if (type instanceof WildcardType) {\n   686:             return convertToUsage((WildcardType) type, context);\n   687:         } else if (type instanceof VoidType) {\n   688:             return ResolvedVoidType.INSTANCE;\n   689:         } else if (type instanceof ArrayType) {\n   690:             return convertToUsage((ArrayType) type, context);\n   691:         } else if (type instanceof UnionType) {\n-  692:             UnionType unionType = (UnionType) type;\n-  693:             return new ResolvedUnionType(unionType.getElements().stream().map(el -> convertToUsage(el, context)).collect(Collectors.toList()));\n-  694:         } else if (type instanceof VarType) {\n-  695:             Node parent = type.getParentNode().get();\n-  696:             if (!(parent instanceof VariableDeclarator)) {\n-  697:                 throw new IllegalStateException(\"Trying to resolve a `var` which is not in a variable declaration.\");\n-  698:             }\n-  699:             final VariableDeclarator variableDeclarator = (VariableDeclarator) parent;\n-  700:             return variableDeclarator.getInitializer()\n-  701:                     .map(Expression::calculateResolvedType)\n-  702:                     .orElseThrow(() -> new IllegalStateException(\"Cannot resolve `var` which has no initializer.\"));\n-  703:         } else {\n-  704:             throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n-  705:         }\n-  706:     }\n-  746: \n-  747:     public ResolvedType convert(Type type, Node node) {\n-  748:         return convert(type, JavaParserFactory.getContext(node, typeSolver));\n-  749:     }\n-  750: \n-  751:     public ResolvedType convert(Type type, Context context) {\n+  692:             return convertToUsage((UnionType) type, context);\n+  693:         } else if (type instanceof VarType) {\n+  694:             Node parent = type.getParentNode().get();\n+  695:             if (!(parent instanceof VariableDeclarator)) {\n+  696:                 throw new IllegalStateException(\"Trying to resolve a `var` which is not in a variable declaration.\");\n+  697:             }\n+  698:             final VariableDeclarator variableDeclarator = (VariableDeclarator) parent;\n+  699:             return variableDeclarator.getInitializer()\n+  700:                     .map(Expression::calculateResolvedType)\n+  701:                     .orElseThrow(() -> new IllegalStateException(\"Cannot resolve `var` which has no initializer.\"));\n+  702:         } else {\n+  703:             throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n+  704:         }\n+  705:     }\n+  706: \n+  746:     protected ResolvedType convertToUsage(UnionType unionType, Context context) {\n+  747:         List<ResolvedType> resolvedElements = unionType.getElements().stream()\n+  748:                 .map(el -> convertToUsage(el, context))\n+  749:                 .collect(Collectors.toList());\n+  750:         return new ResolvedUnionType(resolvedElements);\n+  751:     }\n",
        "uniqueId": "e3ae340534ecf7406a548723488059b947a9f298_677_706_746_751_677_705",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 0,
                "covered": 9
            },
            "LINE": {
                "missed": 0,
                "covered": 1
            },
            "COMPLEXITY": {
                "missed": 0,
                "covered": 1
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 17
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprotected convertToUsage(arrayType ArrayType, context Context) : ResolvedType extracted from protected convertToUsage(type Type, context Context) : ResolvedType in class com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade",
        "diffLocations": [
            {
                "filePath": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java",
                "startLine": 677,
                "endLine": 707,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java",
                "startLine": 677,
                "endLine": 706,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java",
                "startLine": 743,
                "endLine": 745,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "protected ResolvedType convertToUsage(Type type, Context context) {\n        if (context == null) {\n            throw new NullPointerException(\"Context should not be null\");\n        }\n        if (type instanceof ClassOrInterfaceType) {\n            return convertToUsage((ClassOrInterfaceType) type, context);\n        } else if (type instanceof PrimitiveType) {\n            return ResolvedPrimitiveType.byName(((PrimitiveType) type).getType().name());\n        } else if (type instanceof WildcardType) {\n            return convertToUsage((WildcardType) type, context);\n        } else if (type instanceof VoidType) {\n            return ResolvedVoidType.INSTANCE;\n        } else if (type instanceof ArrayType) {\n            ArrayType jpArrayType = (ArrayType) type;\n            return new ResolvedArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n        } else if (type instanceof UnionType) {\n            UnionType unionType = (UnionType) type;\n            return new ResolvedUnionType(unionType.getElements().stream().map(el -> convertToUsage(el, context)).collect(Collectors.toList()));\n        } else if (type instanceof VarType) {\n            Node parent = type.getParentNode().get();\n            if (!(parent instanceof VariableDeclarator)) {\n                throw new IllegalStateException(\"Trying to resolve a `var` which is not in a variable declaration.\");\n            }\n            final VariableDeclarator variableDeclarator = (VariableDeclarator) parent;\n            return variableDeclarator.getInitializer()\n                    .map(Expression::calculateResolvedType)\n                    .orElseThrow(() -> new IllegalStateException(\"Cannot resolve `var` which has no initializer.\"));\n        } else {\n            throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n        }\n    }",
        "filePathBefore": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java",
        "isPureRefactoring": true,
        "commitId": "454cc575960fdb902d93b21a56a071e31d3f81d7",
        "packageNameBefore": "com.github.javaparser.symbolsolver.javaparsermodel",
        "classNameBefore": "com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade",
        "methodNameBefore": "com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade#convertToUsage",
        "invokedMethod": "methodSignature: com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade#getType\n methodBody: public ResolvedType getType(Node node, boolean solveLambdas) {\nif(solveLambdas){if(!node.containsData(TYPE_WITH_LAMBDAS_RESOLVED)){ResolvedType res=getTypeConcrete(node,solveLambdas);\nnode.setData(TYPE_WITH_LAMBDAS_RESOLVED,res);\nboolean secondPassNecessary=false;\nif(node instanceof MethodCallExpr){MethodCallExpr methodCallExpr=(MethodCallExpr)node;\nfor(Node arg: methodCallExpr.getArguments()){if(!arg.containsData(TYPE_WITH_LAMBDAS_RESOLVED)){getType(arg,true);\nsecondPassNecessary=true;\n}}}if(secondPassNecessary){node.removeData(TYPE_WITH_LAMBDAS_RESOLVED);\nResolvedType type=getType(node,true);\nnode.setData(TYPE_WITH_LAMBDAS_RESOLVED,type);\n}Log.trace(\"getType on %s  -> %s\",() -> node,() -> res);\n}return node.getData(TYPE_WITH_LAMBDAS_RESOLVED);\n}{Optional<ResolvedType> res=find(TYPE_WITH_LAMBDAS_RESOLVED,node);\nif(res.isPresent()){return res.get();\n}res=find(TYPE_WITHOUT_LAMBDAS_RESOLVED,node);\nif(!res.isPresent()){ResolvedType resType=getTypeConcrete(node,solveLambdas);\nnode.setData(TYPE_WITHOUT_LAMBDAS_RESOLVED,resType);\nOptional<ResolvedType> finalRes=res;\nLog.trace(\"getType on %s (no solveLambdas) -> %s\",() -> node,() -> finalRes);\nreturn resType;\n}return res.get();\n}}\nmethodSignature: com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade#get\n methodBody: public synchronized static JavaParserFacade get(TypeSolver typeSolver) {\nreturn instances.computeIfAbsent(typeSolver,JavaParserFacade::new);\n}\nmethodSignature: com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade#convertToUsage\n methodBody: protected ResolvedType convertToUsage(WildcardType wildcardType, Context context) {\nif(wildcardType.getExtendedType().isPresent() && !wildcardType.getSuperType().isPresent()){return ResolvedWildcard.extendsBound(convertToUsage(wildcardType.getExtendedType().get(),context));\n}if(!wildcardType.getExtendedType().isPresent() && wildcardType.getSuperType().isPresent()){return ResolvedWildcard.superBound(convertToUsage(wildcardType.getSuperType().get(),context));\n}if(!wildcardType.getExtendedType().isPresent() && !wildcardType.getSuperType().isPresent()){return ResolvedWildcard.UNBOUNDED;\n}{throw new UnsupportedOperationException(wildcardType.toString());\n}}",
        "classSignatureBefore": "public class JavaParserFacade ",
        "methodNameBeforeSet": [
            "com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade#convertToUsage"
        ],
        "classNameBeforeSet": [
            "com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade"
        ],
        "classSignatureBeforeSet": [
            "public class JavaParserFacade "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Tolerable changes in the body\n",
                "description": "All replacements have been justified - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Copyright (C) 2015-2016 Federico Tomassetti\n * Copyright (C) 2017-2020 The JavaParser Team.\n *\n * This file is part of JavaParser.\n *\n * JavaParser can be used either under the terms of\n * a) the GNU Lesser General Public License as published by\n *     the Free Software Foundation, either version 3 of the License, or\n *     (at your option) any later version.\n * b) the terms of the Apache License\n *\n * You should have received a copy of both licenses in LICENCE.LGPL and\n * LICENCE.APACHE. Please refer to those files for details.\n *\n * JavaParser is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n */\n\npackage com.github.javaparser.symbolsolver.javaparsermodel;\n\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.DataKey;\nimport com.github.javaparser.ast.Node;\nimport com.github.javaparser.ast.NodeList;\nimport com.github.javaparser.ast.body.BodyDeclaration;\nimport com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;\nimport com.github.javaparser.ast.body.EnumDeclaration;\nimport com.github.javaparser.ast.body.TypeDeclaration;\nimport com.github.javaparser.ast.body.VariableDeclarator;\nimport com.github.javaparser.ast.expr.AnnotationExpr;\nimport com.github.javaparser.ast.expr.BinaryExpr;\nimport com.github.javaparser.ast.expr.Expression;\nimport com.github.javaparser.ast.expr.FieldAccessExpr;\nimport com.github.javaparser.ast.expr.LambdaExpr;\nimport com.github.javaparser.ast.expr.MethodCallExpr;\nimport com.github.javaparser.ast.expr.MethodReferenceExpr;\nimport com.github.javaparser.ast.expr.NameExpr;\nimport com.github.javaparser.ast.expr.ObjectCreationExpr;\nimport com.github.javaparser.ast.expr.SimpleName;\nimport com.github.javaparser.ast.expr.ThisExpr;\nimport com.github.javaparser.ast.expr.TypeExpr;\nimport com.github.javaparser.ast.stmt.ExplicitConstructorInvocationStmt;\nimport com.github.javaparser.ast.type.ArrayType;\nimport com.github.javaparser.ast.type.ClassOrInterfaceType;\nimport com.github.javaparser.ast.type.PrimitiveType;\nimport com.github.javaparser.ast.type.Type;\nimport com.github.javaparser.ast.type.UnionType;\nimport com.github.javaparser.ast.type.VarType;\nimport com.github.javaparser.ast.type.VoidType;\nimport com.github.javaparser.ast.type.WildcardType;\nimport com.github.javaparser.resolution.MethodAmbiguityException;\nimport com.github.javaparser.resolution.MethodUsage;\nimport com.github.javaparser.resolution.UnsolvedSymbolException;\nimport com.github.javaparser.resolution.declarations.ResolvedAnnotationDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedClassDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedConstructorDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedMethodDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedReferenceTypeDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedTypeDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedTypeParameterDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedValueDeclaration;\nimport com.github.javaparser.resolution.types.ResolvedArrayType;\nimport com.github.javaparser.resolution.types.ResolvedPrimitiveType;\nimport com.github.javaparser.resolution.types.ResolvedReferenceType;\nimport com.github.javaparser.resolution.types.ResolvedType;\nimport com.github.javaparser.resolution.types.ResolvedTypeVariable;\nimport com.github.javaparser.resolution.types.ResolvedUnionType;\nimport com.github.javaparser.resolution.types.ResolvedVoidType;\nimport com.github.javaparser.resolution.types.ResolvedWildcard;\nimport com.github.javaparser.symbolsolver.core.resolution.Context;\nimport com.github.javaparser.symbolsolver.javaparsermodel.contexts.FieldAccessContext;\nimport com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserAnonymousClassDeclaration;\nimport com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserEnumDeclaration;\nimport com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserTypeVariableDeclaration;\nimport com.github.javaparser.symbolsolver.model.resolution.SymbolReference;\nimport com.github.javaparser.symbolsolver.model.resolution.TypeSolver;\nimport com.github.javaparser.symbolsolver.model.typesystem.ReferenceTypeImpl;\nimport com.github.javaparser.symbolsolver.reflectionmodel.ReflectionAnnotationDeclaration;\nimport com.github.javaparser.symbolsolver.reflectionmodel.ReflectionClassDeclaration;\nimport com.github.javaparser.symbolsolver.reflectionmodel.ReflectionEnumDeclaration;\nimport com.github.javaparser.symbolsolver.reflectionmodel.ReflectionInterfaceDeclaration;\nimport com.github.javaparser.symbolsolver.resolution.ConstructorResolutionLogic;\nimport com.github.javaparser.symbolsolver.resolution.MethodResolutionLogic;\nimport com.github.javaparser.symbolsolver.resolution.SymbolSolver;\nimport com.github.javaparser.utils.Log;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.Set;\nimport java.util.WeakHashMap;\nimport java.util.stream.Collectors;\n\nimport static com.github.javaparser.symbolsolver.javaparser.Navigator.demandParentNode;\nimport static com.github.javaparser.symbolsolver.model.resolution.SymbolReference.solved;\nimport static com.github.javaparser.symbolsolver.model.resolution.SymbolReference.unsolved;\n\n/**\n * Class to be used by final users to solve symbols for JavaParser ASTs.\n *\n * @author Federico Tomassetti\n */\npublic class JavaParserFacade {\n\n    private static final DataKey<ResolvedType> TYPE_WITH_LAMBDAS_RESOLVED = new DataKey<ResolvedType>() {\n    };\n    private static final DataKey<ResolvedType> TYPE_WITHOUT_LAMBDAS_RESOLVED = new DataKey<ResolvedType>() {\n    };\n\n    private static final Map<TypeSolver, JavaParserFacade> instances = new WeakHashMap<>();\n    \n    private static String JAVA_LANG_STRING = String.class.getCanonicalName();\n    \n    private final TypeSolver typeSolver;\n    private final TypeExtractor typeExtractor;\n    private final SymbolSolver symbolSolver;\n\n    private JavaParserFacade(TypeSolver typeSolver) {\n        this.typeSolver = typeSolver.getRoot();\n        this.symbolSolver = new SymbolSolver(typeSolver);\n        this.typeExtractor = new TypeExtractor(typeSolver, this);\n    }\n\n    public TypeSolver getTypeSolver() {\n        return typeSolver;\n    }\n\n    public SymbolSolver getSymbolSolver() {\n        return symbolSolver;\n    }\n\n    /**\n     * Note that the addition of the modifier {@code synchronized} is specific and directly in response to issue #2668.\n     * <br>This <strong>MUST NOT</strong> be misinterpreted as a signal that JavaParser is safe to use within a multi-threaded environment.\n     * <br>\n     * <br>Additional discussion and context from a user attempting multithreading can be found within issue #2671 .\n     * <br>\n     *\n     * @see <a href=\"https://github.com/javaparser/javaparser/issues/2668\">https://github.com/javaparser/javaparser/issues/2668</a>\n     * @see <a href=\"https://github.com/javaparser/javaparser/issues/2671\">https://github.com/javaparser/javaparser/issues/2671</a>\n     */\n    public synchronized static JavaParserFacade get(TypeSolver typeSolver) {\n        return instances.computeIfAbsent(typeSolver, JavaParserFacade::new);\n    }\n\n    /**\n     * This method is used to clear internal caches for the sake of releasing memory.\n     */\n    public static void clearInstances() {\n        instances.clear();\n    }\n\n    protected static ResolvedType solveGenericTypes(ResolvedType type, Context context) {\n        if (type.isTypeVariable()) {\n            return context.solveGenericType(type.describe()).orElse(type);\n        }\n        if (type.isWildcard()) {\n            if (type.asWildcard().isExtends() || type.asWildcard().isSuper()) {\n                ResolvedWildcard wildcardUsage = type.asWildcard();\n                ResolvedType boundResolved = solveGenericTypes(wildcardUsage.getBoundedType(), context);\n                if (wildcardUsage.isExtends()) {\n                    return ResolvedWildcard.extendsBound(boundResolved);\n                } else {\n                    return ResolvedWildcard.superBound(boundResolved);\n                }\n            }\n        }\n        return type;\n    }\n\n    public SymbolReference<? extends ResolvedValueDeclaration> solve(NameExpr nameExpr) {\n        return symbolSolver.solveSymbol(nameExpr.getName().getId(), nameExpr);\n    }\n\n    public SymbolReference<? extends ResolvedValueDeclaration> solve(SimpleName nameExpr) {\n        return symbolSolver.solveSymbol(nameExpr.getId(), nameExpr);\n    }\n\n    public SymbolReference<? extends ResolvedValueDeclaration> solve(Expression expr) {\n        return expr.toNameExpr().map(this::solve).orElseThrow(() -> new IllegalArgumentException(expr.getClass().getCanonicalName()));\n    }\n\n    public SymbolReference<ResolvedMethodDeclaration> solve(MethodCallExpr methodCallExpr) {\n        return solve(methodCallExpr, true);\n    }\n\n    public SymbolReference<ResolvedMethodDeclaration> solve(MethodReferenceExpr methodReferenceExpr) {\n        return solve(methodReferenceExpr, true);\n    }\n\n    public SymbolReference<ResolvedConstructorDeclaration> solve(ObjectCreationExpr objectCreationExpr) {\n        return solve(objectCreationExpr, true);\n    }\n\n    public SymbolReference<ResolvedConstructorDeclaration> solve(ExplicitConstructorInvocationStmt explicitConstructorInvocationStmt) {\n        return solve(explicitConstructorInvocationStmt, true);\n    }\n\n    public SymbolReference<ResolvedConstructorDeclaration> solve(ExplicitConstructorInvocationStmt explicitConstructorInvocationStmt, boolean solveLambdas) {\n        // Constructor invocation must exist within a class (not interface).\n        Optional<ClassOrInterfaceDeclaration> optAncestorClassOrInterfaceNode = explicitConstructorInvocationStmt.findAncestor(ClassOrInterfaceDeclaration.class);\n        if (!optAncestorClassOrInterfaceNode.isPresent()) {\n            return unsolved(ResolvedConstructorDeclaration.class);\n        }\n\n        ClassOrInterfaceDeclaration classOrInterfaceNode = optAncestorClassOrInterfaceNode.get();\n        ResolvedReferenceTypeDeclaration resolvedClassNode = classOrInterfaceNode.resolve();\n        if (!resolvedClassNode.isClass()) {\n            throw new IllegalStateException(\"Expected to be a class -- cannot call this() or super() within an interface.\");\n        }\n\n        ResolvedTypeDeclaration typeDecl = null;\n        if (explicitConstructorInvocationStmt.isThis()) {\n            // this()\n            typeDecl = resolvedClassNode.asReferenceType();\n        } else {\n            // super()\n            Optional<ResolvedReferenceType> superClass = resolvedClassNode.asClass().getSuperClass();\n            if (superClass.isPresent() && superClass.get().getTypeDeclaration().isPresent()) {\n                typeDecl = superClass.get().getTypeDeclaration().get();\n            }\n        }\n        if (typeDecl == null) {\n            return unsolved(ResolvedConstructorDeclaration.class);\n        }\n\n        // Solve each of the arguments being passed into this constructor invocation.\n        List<ResolvedType> argumentTypes = new LinkedList<>();\n        List<LambdaArgumentTypePlaceholder> placeholders = new LinkedList<>();\n        solveArguments(explicitConstructorInvocationStmt, explicitConstructorInvocationStmt.getArguments(), solveLambdas, argumentTypes, placeholders);\n\n        // Determine which constructor is referred to, and return it.\n        SymbolReference<ResolvedConstructorDeclaration> res = ConstructorResolutionLogic.findMostApplicable(((ResolvedClassDeclaration) typeDecl).getConstructors(), argumentTypes, typeSolver);\n        for (LambdaArgumentTypePlaceholder placeholder : placeholders) {\n            placeholder.setMethod(res);\n        }\n\n        return res;\n    }\n\n    public SymbolReference<ResolvedTypeDeclaration> solve(ThisExpr node) {\n        // If 'this' is prefixed by a class eg. MyClass.this\n        if (node.getTypeName().isPresent()) {\n            // Get the class name\n            String className = node.getTypeName().get().asString();\n            // Attempt to resolve using a typeSolver\n            SymbolReference<ResolvedReferenceTypeDeclaration> clazz = typeSolver.tryToSolveType(className);\n            if (clazz.isSolved()) {\n                return solved(clazz.getCorrespondingDeclaration());\n            }\n            // Attempt to resolve locally in Compilation unit\n            Optional<CompilationUnit> cu = node.findAncestor(CompilationUnit.class);\n            if (cu.isPresent()) {\n                Optional<ClassOrInterfaceDeclaration> classByName = cu.get().getClassByName(className);\n                if (classByName.isPresent()) {\n                    return solved(getTypeDeclaration(classByName.get()));\n                }\n            }\n        }\n        return solved(getTypeDeclaration(findContainingTypeDeclOrObjectCreationExpr(node)));\n    }\n\n    /**\n     * Given a constructor call find out to which constructor declaration it corresponds.\n     */\n    public SymbolReference<ResolvedConstructorDeclaration> solve(ObjectCreationExpr objectCreationExpr, boolean solveLambdas) {\n        List<ResolvedType> argumentTypes = new LinkedList<>();\n        List<LambdaArgumentTypePlaceholder> placeholders = new LinkedList<>();\n\n        solveArguments(objectCreationExpr, objectCreationExpr.getArguments(), solveLambdas, argumentTypes, placeholders);\n\n        ResolvedReferenceTypeDeclaration typeDecl = null;\n        if (objectCreationExpr.getAnonymousClassBody().isPresent()) {\n            typeDecl = new JavaParserAnonymousClassDeclaration(objectCreationExpr, typeSolver);\n        } else {\n            ResolvedType classDecl = JavaParserFacade.get(typeSolver).convert(objectCreationExpr.getType(), objectCreationExpr);\n            if (classDecl.isReferenceType() && classDecl.asReferenceType().getTypeDeclaration().isPresent()) {\n                typeDecl = classDecl.asReferenceType().getTypeDeclaration().get();\n            }\n        }\n        if (typeDecl == null) {\n            return unsolved(ResolvedConstructorDeclaration.class);\n        }\n        SymbolReference<ResolvedConstructorDeclaration> res = ConstructorResolutionLogic.findMostApplicable(typeDecl.getConstructors(), argumentTypes, typeSolver);\n        for (LambdaArgumentTypePlaceholder placeholder : placeholders) {\n            placeholder.setMethod(res);\n        }\n        return res;\n    }\n\n    private void solveArguments(Node node, NodeList<Expression> args, boolean solveLambdas, List<ResolvedType> argumentTypes,\n                                List<LambdaArgumentTypePlaceholder> placeholders) {\n        int i = 0;\n        for (Expression parameterValue : args) {\n            if (parameterValue instanceof LambdaExpr || parameterValue instanceof MethodReferenceExpr) {\n                LambdaArgumentTypePlaceholder placeholder = new LambdaArgumentTypePlaceholder(i);\n                argumentTypes.add(placeholder);\n                placeholders.add(placeholder);\n            } else {\n                try {\n                    argumentTypes.add(JavaParserFacade.get(typeSolver).getType(parameterValue, solveLambdas));\n                } catch (UnsolvedSymbolException e) {\n                    throw e;\n                } catch (Exception e) {\n                    throw new RuntimeException(String.format(\"Unable to calculate the type of a parameter of a method call. Method call: %s, Parameter: %s\",\n                            node, parameterValue), e);\n                }\n            }\n            i++;\n        }\n    }\n\n    /**\n     * Given a method call find out to which method declaration it corresponds.\n     */\n    public SymbolReference<ResolvedMethodDeclaration> solve(MethodCallExpr methodCallExpr, boolean solveLambdas) {\n        List<ResolvedType> argumentTypes = new LinkedList<>();\n        List<LambdaArgumentTypePlaceholder> placeholders = new LinkedList<>();\n\n        solveArguments(methodCallExpr, methodCallExpr.getArguments(), solveLambdas, argumentTypes, placeholders);\n\n        SymbolReference<ResolvedMethodDeclaration> res = JavaParserFactory.getContext(methodCallExpr, typeSolver).solveMethod(methodCallExpr.getName().getId(), argumentTypes, false);\n        for (LambdaArgumentTypePlaceholder placeholder : placeholders) {\n            placeholder.setMethod(res);\n        }\n        return res;\n    }\n\n    /**\n     * Given a method reference find out to which method declaration it corresponds.\n     */\n    public SymbolReference<ResolvedMethodDeclaration> solve(MethodReferenceExpr methodReferenceExpr, boolean solveLambdas) {\n        // pass empty argument list to be populated\n        List<ResolvedType> argumentTypes = new LinkedList<>();\n        return JavaParserFactory.getContext(methodReferenceExpr, typeSolver).solveMethod(methodReferenceExpr.getIdentifier(), argumentTypes, false);\n    }\n\n    public SymbolReference<ResolvedAnnotationDeclaration> solve(AnnotationExpr annotationExpr) {\n        Context context = JavaParserFactory.getContext(annotationExpr, typeSolver);\n        SymbolReference<ResolvedTypeDeclaration> typeDeclarationSymbolReference = context.solveType(annotationExpr.getNameAsString());\n        if (typeDeclarationSymbolReference.isSolved()) {\n            ResolvedAnnotationDeclaration annotationDeclaration = (ResolvedAnnotationDeclaration) typeDeclarationSymbolReference.getCorrespondingDeclaration();\n            return solved(annotationDeclaration);\n        } else {\n            return unsolved(ResolvedAnnotationDeclaration.class);\n        }\n    }\n\n    public SymbolReference<ResolvedValueDeclaration> solve(FieldAccessExpr fieldAccessExpr) {\n        return ((FieldAccessContext) JavaParserFactory.getContext(fieldAccessExpr, typeSolver)).solveField(fieldAccessExpr.getName().getId());\n    }\n\n    /**\n     * Get the type associated with the node.\n     * <p>\n     * This method was originally intended to get the type of a value: any value has a type.\n     * <p>\n     * For example:\n     * <pre>\n     * int foo(int a) {\n     *     return a; // when getType is invoked on \"a\" it returns the type \"int\"\n     * }\n     * </pre>\n     * <p>\n     * Now, users started using also of names of types itself, which do not have a type.\n     * <p>\n     * For example:\n     * <pre>\n     * class A {\n     *     int foo(int a) {\n     *         return A.someStaticField; // when getType is invoked on \"A\", which represents a class, it returns\n     *             // the type \"A\" itself while it used to throw UnsolvedSymbolException\n     * }\n     * </pre>\n     * <p>\n     * To accommodate this usage and avoid confusion this method return\n     * the type itself when used on the name of type.\n     */\n    public ResolvedType getType(Node node) {\n        try {\n            return getType(node, true);\n        } catch (UnsolvedSymbolException e) {\n            if (node instanceof NameExpr) {\n                NameExpr nameExpr = (NameExpr) node;\n                SymbolReference<ResolvedTypeDeclaration> typeDeclaration = JavaParserFactory.getContext(node, typeSolver)\n                        .solveType(nameExpr.getNameAsString());\n                if (typeDeclaration.isSolved() && typeDeclaration.getCorrespondingDeclaration() instanceof ResolvedReferenceTypeDeclaration) {\n                    ResolvedReferenceTypeDeclaration resolvedReferenceTypeDeclaration = (ResolvedReferenceTypeDeclaration) typeDeclaration.getCorrespondingDeclaration();\n                    return ReferenceTypeImpl.undeterminedParameters(resolvedReferenceTypeDeclaration, typeSolver);\n                }\n            }\n            throw e;\n        }\n    }\n\n    public ResolvedType getType(Node node, boolean solveLambdas) {\n        if (solveLambdas) {\n            if (!node.containsData(TYPE_WITH_LAMBDAS_RESOLVED)) {\n                ResolvedType res = getTypeConcrete(node, solveLambdas);\n\n                node.setData(TYPE_WITH_LAMBDAS_RESOLVED, res);\n\n                boolean secondPassNecessary = false;\n                if (node instanceof MethodCallExpr) {\n                    MethodCallExpr methodCallExpr = (MethodCallExpr) node;\n                    for (Node arg : methodCallExpr.getArguments()) {\n                        if (!arg.containsData(TYPE_WITH_LAMBDAS_RESOLVED)) {\n                            getType(arg, true);\n                            secondPassNecessary = true;\n                        }\n                    }\n                }\n                if (secondPassNecessary) {\n                    node.removeData(TYPE_WITH_LAMBDAS_RESOLVED);\n                    ResolvedType type = getType(node, true);\n                    node.setData(TYPE_WITH_LAMBDAS_RESOLVED, type);\n\n                }\n                Log.trace(\"getType on %s  -> %s\", () -> node, () -> res);\n            }\n            return node.getData(TYPE_WITH_LAMBDAS_RESOLVED);\n        } else {\n            Optional<ResolvedType> res = find(TYPE_WITH_LAMBDAS_RESOLVED, node);\n            if (res.isPresent()) {\n                return res.get();\n            }\n            res = find(TYPE_WITHOUT_LAMBDAS_RESOLVED, node);\n            if (!res.isPresent()) {\n                ResolvedType resType = getTypeConcrete(node, solveLambdas);\n                node.setData(TYPE_WITHOUT_LAMBDAS_RESOLVED, resType);\n                Optional<ResolvedType> finalRes = res;\n                Log.trace(\"getType on %s (no solveLambdas) -> %s\", () -> node, () -> finalRes);\n                return resType;\n            }\n            return res.get();\n        }\n    }\n\n    private Optional<ResolvedType> find(DataKey<ResolvedType> dataKey, Node node) {\n        if (node.containsData(dataKey)) {\n            return Optional.of(node.getData(dataKey));\n        }\n        return Optional.empty();\n    }\n\n    protected MethodUsage toMethodUsage(MethodReferenceExpr methodReferenceExpr, List<ResolvedType> paramTypes) {\n        Expression scope = methodReferenceExpr.getScope();\n        ResolvedType typeOfScope = getType(methodReferenceExpr.getScope());\n        if (!typeOfScope.isReferenceType()) {\n            throw new UnsupportedOperationException(typeOfScope.getClass().getCanonicalName());\n        }\n\n        Optional<MethodUsage> result;\n        Set<MethodUsage> allMethods = typeOfScope.asReferenceType().getTypeDeclaration()\n                .orElseThrow(() -> new RuntimeException(\"TypeDeclaration unexpectedly empty.\"))\n                .getAllMethods();\n\n        if (scope instanceof TypeExpr) {\n            // static methods should match all params\n            List<MethodUsage> staticMethodUsages = allMethods.stream()\n                    .filter(it -> it.getDeclaration().isStatic())\n                    .collect(Collectors.toList());\n\n            result = MethodResolutionLogic.findMostApplicableUsage(staticMethodUsages, methodReferenceExpr.getIdentifier(), paramTypes, typeSolver);\n\n            if (!paramTypes.isEmpty()) {\n                // instance methods are called on the first param and should match all other params\n                List<MethodUsage> instanceMethodUsages = allMethods.stream()\n                        .filter(it -> !it.getDeclaration().isStatic())\n                        .collect(Collectors.toList());\n\n                List<ResolvedType> instanceMethodParamTypes = new ArrayList<>(paramTypes);\n                instanceMethodParamTypes.remove(0); // remove the first one\n\n                Optional<MethodUsage> instanceResult = MethodResolutionLogic.findMostApplicableUsage(\n                        instanceMethodUsages, methodReferenceExpr.getIdentifier(), instanceMethodParamTypes, typeSolver);\n                if (result.isPresent() && instanceResult.isPresent()) {\n                    throw new MethodAmbiguityException(\"Ambiguous method call: cannot find a most applicable method for \" + methodReferenceExpr.getIdentifier());\n                }\n\n                if (instanceResult.isPresent()) {\n                    result = instanceResult;\n                }\n            }\n        } else {\n            result = MethodResolutionLogic.findMostApplicableUsage(new ArrayList<>(allMethods), methodReferenceExpr.getIdentifier(), paramTypes, typeSolver);\n\n            if (result.isPresent() && result.get().getDeclaration().isStatic()) {\n                throw new RuntimeException(\"Invalid static method reference \" + methodReferenceExpr.getIdentifier());\n            }\n        }\n\n        if (!result.isPresent()) {\n            throw new UnsupportedOperationException();\n        }\n\n        return result.get();\n    }\n\n    protected ResolvedType getBinaryTypeConcrete(Node left, Node right, boolean solveLambdas, BinaryExpr.Operator operator) {\n        ResolvedType leftType = getTypeConcrete(left, solveLambdas);\n        ResolvedType rightType = getTypeConcrete(right, solveLambdas);\n\n        // JLS 15.18.1. String Concatenation Operator +\n        // If only one operand expression is of type String, then string conversion (\u00a75.1.11) is performed on the other\n        // operand to produce a string at run time.\n        //\n        // The result of string concatenation is a reference to a String object that is the concatenation of the two\n        // operand strings. The characters of the left-hand operand precede the characters of the right-hand operand in\n        // the newly created string.\n\n        if (operator == BinaryExpr.Operator.PLUS) {\n            boolean isLeftString = leftType.isReferenceType() && leftType.asReferenceType()\n                    .getQualifiedName().equals(JAVA_LANG_STRING);\n            boolean isRightString = rightType.isReferenceType() && rightType.asReferenceType()\n                    .getQualifiedName().equals(JAVA_LANG_STRING);\n            if (isLeftString || isRightString) {\n                return isLeftString ? leftType : rightType;\n            }\n        }\n\n        // JLS 5.6.2. Binary Numeric Promotion\n        //\n        // Widening primitive conversion (\u00a75.1.2) is applied to convert either or both operands as specified by the\n        // following rules:\n        //\n        // * If either operand is of type double, the other is converted to double.\n        // * Otherwise, if either operand is of type float, the other is converted to float.\n        // * Otherwise, if either operand is of type long, the other is converted to long.\n        // * Otherwise, both operands are converted to type int.\n\n        boolean isLeftNumeric = leftType.isPrimitive() && leftType.asPrimitive().isNumeric();\n        boolean isRightNumeric = rightType.isPrimitive() && rightType.asPrimitive().isNumeric();\n\n        if (isLeftNumeric && isRightNumeric) {\n            return leftType.asPrimitive().bnp(rightType.asPrimitive());\n        }\n\n        if (rightType.isAssignableBy(leftType)) {\n            return rightType;\n        }\n        return leftType;\n    }\n\n\n    /**\n     * Should return more like a TypeApplication: a TypeDeclaration and possible typeParametersValues or array\n     * modifiers.\n     */\n    private ResolvedType getTypeConcrete(Node node, boolean solveLambdas) {\n        if (node == null) throw new IllegalArgumentException();\n        return node.accept(typeExtractor, solveLambdas);\n    }\n\n    /**\n     * Where a node has an interface/class/enum declaration as its ancestor, return the nearest one.\n     * <p>\n     * NOTE: See {@link #findContainingTypeDeclOrObjectCreationExpr} if wanting to include anonymous inner classes.\n     * <p>\n     * For example, these all return X:\n     * {@code public interface X { ... node here ... }}\n     * {@code public class X { ... node here ... }}\n     * {@code public enum X { ... node here ... }}\n     *\n     * @param node The Node whose ancestors will be traversed,\n     * @return The first class/interface/enum declaration in the Node's ancestry.\n     */\n    protected TypeDeclaration<?> findContainingTypeDecl(Node node) {\n        Node parent = node;\n        while (true) {\n            parent = demandParentNode(parent);\n            if (parent instanceof TypeDeclaration) {\n                return (TypeDeclaration<?>) parent;\n            }\n        }\n    }\n\n    /**\n     * Where a node has an interface/class/enum declaration -- or an object creation expression (anonymous inner class)\n     * -- as its ancestor, return the nearest one.\n     * <p>\n     * NOTE: See {@link #findContainingTypeDecl} if wanting to not include anonymous inner classes.\n     * <p>\n     * For example, these all return X:\n     * <ul>\n     *     <li>{@code public interface X { ... node here ... }}</li>\n     *     <li>{@code public class X { ... node here ... }}</li>\n     *     <li>{@code public enum X { ... node here ... }}</li>\n     *     <li><pre>{@code\n     *     new ActionListener() {\n     *          ... node here ...\n     *          public void actionPerformed(ActionEvent e) {\n     *               ... or node here ...\n     *          }\n     *     }\n     *     }</pre></li>\n     * </ul>\n     * <p>\n     *\n     * @param node The Node whose ancestors will be traversed,\n     * @return The first class/interface/enum declaration -- or object creation expression (anonymous inner class) -- in\n     * the Node's ancestry.\n     */\n    protected Node findContainingTypeDeclOrObjectCreationExpr(Node node) {\n        Node parent = node;\n        boolean detachFlag = false;\n        while (true) {\n            parent = demandParentNode(parent);\n            if (parent instanceof BodyDeclaration) {\n                if (parent instanceof TypeDeclaration) {\n                    return parent;\n                } else {\n                    detachFlag = true;\n                }\n            } else if (parent instanceof ObjectCreationExpr) {\n                if (detachFlag) {\n                    return parent;\n                }\n            }\n        }\n    }\n\n    /**\n     * Where a node has an interface/class/enum declaration -- or an object creation expression in an inner class\n     * references an outer class -- as its ancestor, return the declaration corresponding to the class name specified.\n     */\n    protected Node findContainingTypeDeclOrObjectCreationExpr(Node node, String className) {\n        Node parent = node;\n        boolean detachFlag = false;\n        while (true) {\n            parent = demandParentNode(parent);\n            if (parent instanceof BodyDeclaration) {\n                if (parent instanceof TypeDeclaration && ((TypeDeclaration<?>) parent).getFullyQualifiedName().get().endsWith(className)) {\n                    return parent;\n                } else {\n                    detachFlag = true;\n                }\n            } else if (parent instanceof ObjectCreationExpr) {\n                if (detachFlag) {\n                    return parent;\n                }\n            }\n        }\n    }\n\n\n    public ResolvedType convertToUsageVariableType(VariableDeclarator var) {\n        return get(typeSolver).convertToUsage(var.getType(), var);\n    }\n\n    public ResolvedType convertToUsage(Type type, Node context) {\n        if (type.isUnknownType()) {\n            throw new IllegalArgumentException(\"Inferred lambda parameter type\");\n        }\n        return convertToUsage(type, JavaParserFactory.getContext(context, typeSolver));\n    }\n\n    public ResolvedType convertToUsage(Type type) {\n        return convertToUsage(type, type);\n    }\n\n    // This is an hack around an issue in JavaParser\n    private String qName(ClassOrInterfaceType classOrInterfaceType) {\n        String name = classOrInterfaceType.getName().getId();\n        if (classOrInterfaceType.getScope().isPresent()) {\n            return qName(classOrInterfaceType.getScope().get()) + \".\" + name;\n        }\n        return name;\n    }\n\n    protected ResolvedType convertToUsage(Type type, Context context) {\n        if (context == null) {\n            throw new NullPointerException(\"Context should not be null\");\n        }\n        if (type instanceof ClassOrInterfaceType) {\n            return convertToUsage((ClassOrInterfaceType) type, context);\n        } else if (type instanceof PrimitiveType) {\n            return ResolvedPrimitiveType.byName(((PrimitiveType) type).getType().name());\n        } else if (type instanceof WildcardType) {\n            return convertToUsage((WildcardType) type, context);\n        } else if (type instanceof VoidType) {\n            return ResolvedVoidType.INSTANCE;\n        } else if (type instanceof ArrayType) {\n            ArrayType jpArrayType = (ArrayType) type;\n            return new ResolvedArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n        } else if (type instanceof UnionType) {\n            UnionType unionType = (UnionType) type;\n            return new ResolvedUnionType(unionType.getElements().stream().map(el -> convertToUsage(el, context)).collect(Collectors.toList()));\n        } else if (type instanceof VarType) {\n            Node parent = type.getParentNode().get();\n            if (!(parent instanceof VariableDeclarator)) {\n                throw new IllegalStateException(\"Trying to resolve a `var` which is not in a variable declaration.\");\n            }\n            final VariableDeclarator variableDeclarator = (VariableDeclarator) parent;\n            return variableDeclarator.getInitializer()\n                    .map(Expression::calculateResolvedType)\n                    .orElseThrow(() -> new IllegalStateException(\"Cannot resolve `var` which has no initializer.\"));\n        } else {\n            throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n        }\n    }\n\n    protected ResolvedType convertToUsage(ClassOrInterfaceType classOrInterfaceType, Context context) {\n        String name = qName(classOrInterfaceType);\n        SymbolReference<ResolvedTypeDeclaration> ref = context.solveType(name);\n        if (!ref.isSolved()) {\n            throw new UnsolvedSymbolException(name);\n        }\n        ResolvedTypeDeclaration typeDeclaration = ref.getCorrespondingDeclaration();\n        List<ResolvedType> typeParameters = Collections.emptyList();\n        if (classOrInterfaceType.getTypeArguments().isPresent()) {\n            typeParameters = classOrInterfaceType.getTypeArguments().get().stream().map((pt) -> convertToUsage(pt, context)).collect(Collectors.toList());\n        }\n        if (typeDeclaration.isTypeParameter()) {\n            if (typeDeclaration instanceof ResolvedTypeParameterDeclaration) {\n                return new ResolvedTypeVariable((ResolvedTypeParameterDeclaration) typeDeclaration);\n            } else {\n                JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration = (JavaParserTypeVariableDeclaration) typeDeclaration;\n                return new ResolvedTypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n            }\n        } else {\n            return new ReferenceTypeImpl((ResolvedReferenceTypeDeclaration) typeDeclaration, typeParameters, typeSolver);\n        }\n    }\n\n    protected ResolvedType convertToUsage(WildcardType wildcardType, Context context) {\n        if (wildcardType.getExtendedType().isPresent() && !wildcardType.getSuperType().isPresent()) {\n            return ResolvedWildcard.extendsBound(convertToUsage(wildcardType.getExtendedType().get(), context)); // removed (ReferenceTypeImpl)\n        } else if (!wildcardType.getExtendedType().isPresent() && wildcardType.getSuperType().isPresent()) {\n            return ResolvedWildcard.superBound(convertToUsage(wildcardType.getSuperType().get(), context)); // removed (ReferenceTypeImpl)\n        } else if (!wildcardType.getExtendedType().isPresent() && !wildcardType.getSuperType().isPresent()) {\n            return ResolvedWildcard.UNBOUNDED;\n        } else {\n            throw new UnsupportedOperationException(wildcardType.toString());\n        }\n    }\n\n    public ResolvedType convert(Type type, Node node) {\n        return convert(type, JavaParserFactory.getContext(node, typeSolver));\n    }\n\n    public ResolvedType convert(Type type, Context context) {\n        return convertToUsage(type, context);\n    }\n\n    public MethodUsage solveMethodAsUsage(MethodCallExpr call) {\n        List<ResolvedType> params = new ArrayList<>();\n        if (call.getArguments() != null) {\n            for (Expression param : call.getArguments()) {\n                //getTypeConcrete(Node node, boolean solveLambdas)\n                try {\n                    params.add(getType(param, false));\n                } catch (Exception e) {\n                    throw new RuntimeException(String.format(\"Error calculating the type of parameter %s of method call %s\", param, call), e);\n                }\n                //params.add(getTypeConcrete(param, false));\n            }\n        }\n        Context context = JavaParserFactory.getContext(call, typeSolver);\n        Optional<MethodUsage> methodUsage = context.solveMethodAsUsage(call.getName().getId(), params);\n        if (!methodUsage.isPresent()) {\n            throw new RuntimeException(\"Method '\" + call.getName() + \"' cannot be resolved in context \"\n                    + call + \" (line: \" + call.getRange().map(r -> \"\" + r.begin.line).orElse(\"??\") + \") \" + context + \". Parameter types: \" + params);\n        }\n        return methodUsage.get();\n    }\n\n    public ResolvedReferenceTypeDeclaration getTypeDeclaration(Node node) {\n        if (node instanceof TypeDeclaration) {\n            return getTypeDeclaration((TypeDeclaration) node);\n        } else if (node instanceof ObjectCreationExpr) {\n            return new JavaParserAnonymousClassDeclaration((ObjectCreationExpr) node, typeSolver);\n        } else {\n            throw new IllegalArgumentException();\n        }\n    }\n\n    public ResolvedReferenceTypeDeclaration getTypeDeclaration(ClassOrInterfaceDeclaration classOrInterfaceDeclaration) {\n        return JavaParserFactory.toTypeDeclaration(classOrInterfaceDeclaration, typeSolver);\n    }\n\n    /**\n     * \"this\" inserted in the given point, which type would have?\n     */\n    public ResolvedType getTypeOfThisIn(Node node) {\n        // TODO consider static methods\n        if (node instanceof ClassOrInterfaceDeclaration) {\n            return new ReferenceTypeImpl(getTypeDeclaration((ClassOrInterfaceDeclaration) node), typeSolver);\n        } else if (node instanceof EnumDeclaration) {\n            JavaParserEnumDeclaration enumDeclaration = new JavaParserEnumDeclaration((EnumDeclaration) node, typeSolver);\n            return new ReferenceTypeImpl(enumDeclaration, typeSolver);\n        } else if (node instanceof ObjectCreationExpr && ((ObjectCreationExpr) node).getAnonymousClassBody().isPresent()) {\n            JavaParserAnonymousClassDeclaration anonymousDeclaration = new JavaParserAnonymousClassDeclaration((ObjectCreationExpr) node, typeSolver);\n            return new ReferenceTypeImpl(anonymousDeclaration, typeSolver);\n        }\n        return getTypeOfThisIn(demandParentNode(node));\n    }\n\n    public ResolvedReferenceTypeDeclaration getTypeDeclaration(TypeDeclaration<?> typeDeclaration) {\n        return JavaParserFactory.toTypeDeclaration(typeDeclaration, typeSolver);\n    }\n\n    public ResolvedType classToResolvedType(Class<?> clazz) {\n        if (clazz.isPrimitive()) {\n            return ResolvedPrimitiveType.byName(clazz.getName());\n        }\n\n        ResolvedReferenceTypeDeclaration declaration;\n        if (clazz.isAnnotation()) {\n            declaration = new ReflectionAnnotationDeclaration(clazz, typeSolver);\n        } else if (clazz.isEnum()) {\n            declaration = new ReflectionEnumDeclaration(clazz, typeSolver);\n        } else if (clazz.isInterface()) {\n            declaration = new ReflectionInterfaceDeclaration(clazz, typeSolver);\n        } else {\n            declaration = new ReflectionClassDeclaration(clazz, typeSolver);\n        }\n        return new ReferenceTypeImpl(declaration, typeSolver);\n    }\n\n}\n",
        "filePathAfter": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java",
        "sourceCodeAfterForWhole": "/*\n * Copyright (C) 2015-2016 Federico Tomassetti\n * Copyright (C) 2017-2020 The JavaParser Team.\n *\n * This file is part of JavaParser.\n *\n * JavaParser can be used either under the terms of\n * a) the GNU Lesser General Public License as published by\n *     the Free Software Foundation, either version 3 of the License, or\n *     (at your option) any later version.\n * b) the terms of the Apache License\n *\n * You should have received a copy of both licenses in LICENCE.LGPL and\n * LICENCE.APACHE. Please refer to those files for details.\n *\n * JavaParser is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n */\n\npackage com.github.javaparser.symbolsolver.javaparsermodel;\n\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.DataKey;\nimport com.github.javaparser.ast.Node;\nimport com.github.javaparser.ast.NodeList;\nimport com.github.javaparser.ast.body.BodyDeclaration;\nimport com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;\nimport com.github.javaparser.ast.body.EnumDeclaration;\nimport com.github.javaparser.ast.body.TypeDeclaration;\nimport com.github.javaparser.ast.body.VariableDeclarator;\nimport com.github.javaparser.ast.expr.AnnotationExpr;\nimport com.github.javaparser.ast.expr.BinaryExpr;\nimport com.github.javaparser.ast.expr.Expression;\nimport com.github.javaparser.ast.expr.FieldAccessExpr;\nimport com.github.javaparser.ast.expr.LambdaExpr;\nimport com.github.javaparser.ast.expr.MethodCallExpr;\nimport com.github.javaparser.ast.expr.MethodReferenceExpr;\nimport com.github.javaparser.ast.expr.NameExpr;\nimport com.github.javaparser.ast.expr.ObjectCreationExpr;\nimport com.github.javaparser.ast.expr.SimpleName;\nimport com.github.javaparser.ast.expr.ThisExpr;\nimport com.github.javaparser.ast.expr.TypeExpr;\nimport com.github.javaparser.ast.stmt.ExplicitConstructorInvocationStmt;\nimport com.github.javaparser.ast.type.ArrayType;\nimport com.github.javaparser.ast.type.ClassOrInterfaceType;\nimport com.github.javaparser.ast.type.PrimitiveType;\nimport com.github.javaparser.ast.type.Type;\nimport com.github.javaparser.ast.type.UnionType;\nimport com.github.javaparser.ast.type.VarType;\nimport com.github.javaparser.ast.type.VoidType;\nimport com.github.javaparser.ast.type.WildcardType;\nimport com.github.javaparser.resolution.MethodAmbiguityException;\nimport com.github.javaparser.resolution.MethodUsage;\nimport com.github.javaparser.resolution.UnsolvedSymbolException;\nimport com.github.javaparser.resolution.declarations.ResolvedAnnotationDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedClassDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedConstructorDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedMethodDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedReferenceTypeDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedTypeDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedTypeParameterDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedValueDeclaration;\nimport com.github.javaparser.resolution.types.ResolvedArrayType;\nimport com.github.javaparser.resolution.types.ResolvedPrimitiveType;\nimport com.github.javaparser.resolution.types.ResolvedReferenceType;\nimport com.github.javaparser.resolution.types.ResolvedType;\nimport com.github.javaparser.resolution.types.ResolvedTypeVariable;\nimport com.github.javaparser.resolution.types.ResolvedUnionType;\nimport com.github.javaparser.resolution.types.ResolvedVoidType;\nimport com.github.javaparser.resolution.types.ResolvedWildcard;\nimport com.github.javaparser.symbolsolver.core.resolution.Context;\nimport com.github.javaparser.symbolsolver.javaparsermodel.contexts.FieldAccessContext;\nimport com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserAnonymousClassDeclaration;\nimport com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserEnumDeclaration;\nimport com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserTypeVariableDeclaration;\nimport com.github.javaparser.symbolsolver.model.resolution.SymbolReference;\nimport com.github.javaparser.symbolsolver.model.resolution.TypeSolver;\nimport com.github.javaparser.symbolsolver.model.typesystem.ReferenceTypeImpl;\nimport com.github.javaparser.symbolsolver.reflectionmodel.ReflectionAnnotationDeclaration;\nimport com.github.javaparser.symbolsolver.reflectionmodel.ReflectionClassDeclaration;\nimport com.github.javaparser.symbolsolver.reflectionmodel.ReflectionEnumDeclaration;\nimport com.github.javaparser.symbolsolver.reflectionmodel.ReflectionInterfaceDeclaration;\nimport com.github.javaparser.symbolsolver.resolution.ConstructorResolutionLogic;\nimport com.github.javaparser.symbolsolver.resolution.MethodResolutionLogic;\nimport com.github.javaparser.symbolsolver.resolution.SymbolSolver;\nimport com.github.javaparser.utils.Log;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.Set;\nimport java.util.WeakHashMap;\nimport java.util.stream.Collectors;\n\nimport static com.github.javaparser.symbolsolver.javaparser.Navigator.demandParentNode;\nimport static com.github.javaparser.symbolsolver.model.resolution.SymbolReference.solved;\nimport static com.github.javaparser.symbolsolver.model.resolution.SymbolReference.unsolved;\n\n/**\n * Class to be used by final users to solve symbols for JavaParser ASTs.\n *\n * @author Federico Tomassetti\n */\npublic class JavaParserFacade {\n\n    private static final DataKey<ResolvedType> TYPE_WITH_LAMBDAS_RESOLVED = new DataKey<ResolvedType>() {\n    };\n    private static final DataKey<ResolvedType> TYPE_WITHOUT_LAMBDAS_RESOLVED = new DataKey<ResolvedType>() {\n    };\n\n    private static final Map<TypeSolver, JavaParserFacade> instances = new WeakHashMap<>();\n    \n    private static String JAVA_LANG_STRING = String.class.getCanonicalName();\n    \n    private final TypeSolver typeSolver;\n    private final TypeExtractor typeExtractor;\n    private final SymbolSolver symbolSolver;\n\n    private JavaParserFacade(TypeSolver typeSolver) {\n        this.typeSolver = typeSolver.getRoot();\n        this.symbolSolver = new SymbolSolver(typeSolver);\n        this.typeExtractor = new TypeExtractor(typeSolver, this);\n    }\n\n    public TypeSolver getTypeSolver() {\n        return typeSolver;\n    }\n\n    public SymbolSolver getSymbolSolver() {\n        return symbolSolver;\n    }\n\n    /**\n     * Note that the addition of the modifier {@code synchronized} is specific and directly in response to issue #2668.\n     * <br>This <strong>MUST NOT</strong> be misinterpreted as a signal that JavaParser is safe to use within a multi-threaded environment.\n     * <br>\n     * <br>Additional discussion and context from a user attempting multithreading can be found within issue #2671 .\n     * <br>\n     *\n     * @see <a href=\"https://github.com/javaparser/javaparser/issues/2668\">https://github.com/javaparser/javaparser/issues/2668</a>\n     * @see <a href=\"https://github.com/javaparser/javaparser/issues/2671\">https://github.com/javaparser/javaparser/issues/2671</a>\n     */\n    public synchronized static JavaParserFacade get(TypeSolver typeSolver) {\n        return instances.computeIfAbsent(typeSolver, JavaParserFacade::new);\n    }\n\n    /**\n     * This method is used to clear internal caches for the sake of releasing memory.\n     */\n    public static void clearInstances() {\n        instances.clear();\n    }\n\n    protected static ResolvedType solveGenericTypes(ResolvedType type, Context context) {\n        if (type.isTypeVariable()) {\n            return context.solveGenericType(type.describe()).orElse(type);\n        }\n        if (type.isWildcard()) {\n            if (type.asWildcard().isExtends() || type.asWildcard().isSuper()) {\n                ResolvedWildcard wildcardUsage = type.asWildcard();\n                ResolvedType boundResolved = solveGenericTypes(wildcardUsage.getBoundedType(), context);\n                if (wildcardUsage.isExtends()) {\n                    return ResolvedWildcard.extendsBound(boundResolved);\n                } else {\n                    return ResolvedWildcard.superBound(boundResolved);\n                }\n            }\n        }\n        return type;\n    }\n\n    public SymbolReference<? extends ResolvedValueDeclaration> solve(NameExpr nameExpr) {\n        return symbolSolver.solveSymbol(nameExpr.getName().getId(), nameExpr);\n    }\n\n    public SymbolReference<? extends ResolvedValueDeclaration> solve(SimpleName nameExpr) {\n        return symbolSolver.solveSymbol(nameExpr.getId(), nameExpr);\n    }\n\n    public SymbolReference<? extends ResolvedValueDeclaration> solve(Expression expr) {\n        return expr.toNameExpr().map(this::solve).orElseThrow(() -> new IllegalArgumentException(expr.getClass().getCanonicalName()));\n    }\n\n    public SymbolReference<ResolvedMethodDeclaration> solve(MethodCallExpr methodCallExpr) {\n        return solve(methodCallExpr, true);\n    }\n\n    public SymbolReference<ResolvedMethodDeclaration> solve(MethodReferenceExpr methodReferenceExpr) {\n        return solve(methodReferenceExpr, true);\n    }\n\n    public SymbolReference<ResolvedConstructorDeclaration> solve(ObjectCreationExpr objectCreationExpr) {\n        return solve(objectCreationExpr, true);\n    }\n\n    public SymbolReference<ResolvedConstructorDeclaration> solve(ExplicitConstructorInvocationStmt explicitConstructorInvocationStmt) {\n        return solve(explicitConstructorInvocationStmt, true);\n    }\n\n    public SymbolReference<ResolvedConstructorDeclaration> solve(ExplicitConstructorInvocationStmt explicitConstructorInvocationStmt, boolean solveLambdas) {\n        // Constructor invocation must exist within a class (not interface).\n        Optional<ClassOrInterfaceDeclaration> optAncestorClassOrInterfaceNode = explicitConstructorInvocationStmt.findAncestor(ClassOrInterfaceDeclaration.class);\n        if (!optAncestorClassOrInterfaceNode.isPresent()) {\n            return unsolved(ResolvedConstructorDeclaration.class);\n        }\n\n        ClassOrInterfaceDeclaration classOrInterfaceNode = optAncestorClassOrInterfaceNode.get();\n        ResolvedReferenceTypeDeclaration resolvedClassNode = classOrInterfaceNode.resolve();\n        if (!resolvedClassNode.isClass()) {\n            throw new IllegalStateException(\"Expected to be a class -- cannot call this() or super() within an interface.\");\n        }\n\n        ResolvedTypeDeclaration typeDecl = null;\n        if (explicitConstructorInvocationStmt.isThis()) {\n            // this()\n            typeDecl = resolvedClassNode.asReferenceType();\n        } else {\n            // super()\n            Optional<ResolvedReferenceType> superClass = resolvedClassNode.asClass().getSuperClass();\n            if (superClass.isPresent() && superClass.get().getTypeDeclaration().isPresent()) {\n                typeDecl = superClass.get().getTypeDeclaration().get();\n            }\n        }\n        if (typeDecl == null) {\n            return unsolved(ResolvedConstructorDeclaration.class);\n        }\n\n        // Solve each of the arguments being passed into this constructor invocation.\n        List<ResolvedType> argumentTypes = new LinkedList<>();\n        List<LambdaArgumentTypePlaceholder> placeholders = new LinkedList<>();\n        solveArguments(explicitConstructorInvocationStmt, explicitConstructorInvocationStmt.getArguments(), solveLambdas, argumentTypes, placeholders);\n\n        // Determine which constructor is referred to, and return it.\n        SymbolReference<ResolvedConstructorDeclaration> res = ConstructorResolutionLogic.findMostApplicable(((ResolvedClassDeclaration) typeDecl).getConstructors(), argumentTypes, typeSolver);\n        for (LambdaArgumentTypePlaceholder placeholder : placeholders) {\n            placeholder.setMethod(res);\n        }\n\n        return res;\n    }\n\n    public SymbolReference<ResolvedTypeDeclaration> solve(ThisExpr node) {\n        // If 'this' is prefixed by a class eg. MyClass.this\n        if (node.getTypeName().isPresent()) {\n            // Get the class name\n            String className = node.getTypeName().get().asString();\n            // Attempt to resolve using a typeSolver\n            SymbolReference<ResolvedReferenceTypeDeclaration> clazz = typeSolver.tryToSolveType(className);\n            if (clazz.isSolved()) {\n                return solved(clazz.getCorrespondingDeclaration());\n            }\n            // Attempt to resolve locally in Compilation unit\n            Optional<CompilationUnit> cu = node.findAncestor(CompilationUnit.class);\n            if (cu.isPresent()) {\n                Optional<ClassOrInterfaceDeclaration> classByName = cu.get().getClassByName(className);\n                if (classByName.isPresent()) {\n                    return solved(getTypeDeclaration(classByName.get()));\n                }\n            }\n        }\n        return solved(getTypeDeclaration(findContainingTypeDeclOrObjectCreationExpr(node)));\n    }\n\n    /**\n     * Given a constructor call find out to which constructor declaration it corresponds.\n     */\n    public SymbolReference<ResolvedConstructorDeclaration> solve(ObjectCreationExpr objectCreationExpr, boolean solveLambdas) {\n        List<ResolvedType> argumentTypes = new LinkedList<>();\n        List<LambdaArgumentTypePlaceholder> placeholders = new LinkedList<>();\n\n        solveArguments(objectCreationExpr, objectCreationExpr.getArguments(), solveLambdas, argumentTypes, placeholders);\n\n        ResolvedReferenceTypeDeclaration typeDecl = null;\n        if (objectCreationExpr.getAnonymousClassBody().isPresent()) {\n            typeDecl = new JavaParserAnonymousClassDeclaration(objectCreationExpr, typeSolver);\n        } else {\n            ResolvedType classDecl = JavaParserFacade.get(typeSolver).convert(objectCreationExpr.getType(), objectCreationExpr);\n            if (classDecl.isReferenceType() && classDecl.asReferenceType().getTypeDeclaration().isPresent()) {\n                typeDecl = classDecl.asReferenceType().getTypeDeclaration().get();\n            }\n        }\n        if (typeDecl == null) {\n            return unsolved(ResolvedConstructorDeclaration.class);\n        }\n        SymbolReference<ResolvedConstructorDeclaration> res = ConstructorResolutionLogic.findMostApplicable(typeDecl.getConstructors(), argumentTypes, typeSolver);\n        for (LambdaArgumentTypePlaceholder placeholder : placeholders) {\n            placeholder.setMethod(res);\n        }\n        return res;\n    }\n\n    private void solveArguments(Node node, NodeList<Expression> args, boolean solveLambdas, List<ResolvedType> argumentTypes,\n                                List<LambdaArgumentTypePlaceholder> placeholders) {\n        int i = 0;\n        for (Expression parameterValue : args) {\n            if (parameterValue instanceof LambdaExpr || parameterValue instanceof MethodReferenceExpr) {\n                LambdaArgumentTypePlaceholder placeholder = new LambdaArgumentTypePlaceholder(i);\n                argumentTypes.add(placeholder);\n                placeholders.add(placeholder);\n            } else {\n                try {\n                    argumentTypes.add(JavaParserFacade.get(typeSolver).getType(parameterValue, solveLambdas));\n                } catch (UnsolvedSymbolException e) {\n                    throw e;\n                } catch (Exception e) {\n                    throw new RuntimeException(String.format(\"Unable to calculate the type of a parameter of a method call. Method call: %s, Parameter: %s\",\n                            node, parameterValue), e);\n                }\n            }\n            i++;\n        }\n    }\n\n    /**\n     * Given a method call find out to which method declaration it corresponds.\n     */\n    public SymbolReference<ResolvedMethodDeclaration> solve(MethodCallExpr methodCallExpr, boolean solveLambdas) {\n        List<ResolvedType> argumentTypes = new LinkedList<>();\n        List<LambdaArgumentTypePlaceholder> placeholders = new LinkedList<>();\n\n        solveArguments(methodCallExpr, methodCallExpr.getArguments(), solveLambdas, argumentTypes, placeholders);\n\n        SymbolReference<ResolvedMethodDeclaration> res = JavaParserFactory.getContext(methodCallExpr, typeSolver).solveMethod(methodCallExpr.getName().getId(), argumentTypes, false);\n        for (LambdaArgumentTypePlaceholder placeholder : placeholders) {\n            placeholder.setMethod(res);\n        }\n        return res;\n    }\n\n    /**\n     * Given a method reference find out to which method declaration it corresponds.\n     */\n    public SymbolReference<ResolvedMethodDeclaration> solve(MethodReferenceExpr methodReferenceExpr, boolean solveLambdas) {\n        // pass empty argument list to be populated\n        List<ResolvedType> argumentTypes = new LinkedList<>();\n        return JavaParserFactory.getContext(methodReferenceExpr, typeSolver).solveMethod(methodReferenceExpr.getIdentifier(), argumentTypes, false);\n    }\n\n    public SymbolReference<ResolvedAnnotationDeclaration> solve(AnnotationExpr annotationExpr) {\n        Context context = JavaParserFactory.getContext(annotationExpr, typeSolver);\n        SymbolReference<ResolvedTypeDeclaration> typeDeclarationSymbolReference = context.solveType(annotationExpr.getNameAsString());\n        if (typeDeclarationSymbolReference.isSolved()) {\n            ResolvedAnnotationDeclaration annotationDeclaration = (ResolvedAnnotationDeclaration) typeDeclarationSymbolReference.getCorrespondingDeclaration();\n            return solved(annotationDeclaration);\n        } else {\n            return unsolved(ResolvedAnnotationDeclaration.class);\n        }\n    }\n\n    public SymbolReference<ResolvedValueDeclaration> solve(FieldAccessExpr fieldAccessExpr) {\n        return ((FieldAccessContext) JavaParserFactory.getContext(fieldAccessExpr, typeSolver)).solveField(fieldAccessExpr.getName().getId());\n    }\n\n    /**\n     * Get the type associated with the node.\n     * <p>\n     * This method was originally intended to get the type of a value: any value has a type.\n     * <p>\n     * For example:\n     * <pre>\n     * int foo(int a) {\n     *     return a; // when getType is invoked on \"a\" it returns the type \"int\"\n     * }\n     * </pre>\n     * <p>\n     * Now, users started using also of names of types itself, which do not have a type.\n     * <p>\n     * For example:\n     * <pre>\n     * class A {\n     *     int foo(int a) {\n     *         return A.someStaticField; // when getType is invoked on \"A\", which represents a class, it returns\n     *             // the type \"A\" itself while it used to throw UnsolvedSymbolException\n     * }\n     * </pre>\n     * <p>\n     * To accommodate this usage and avoid confusion this method return\n     * the type itself when used on the name of type.\n     */\n    public ResolvedType getType(Node node) {\n        try {\n            return getType(node, true);\n        } catch (UnsolvedSymbolException e) {\n            if (node instanceof NameExpr) {\n                NameExpr nameExpr = (NameExpr) node;\n                SymbolReference<ResolvedTypeDeclaration> typeDeclaration = JavaParserFactory.getContext(node, typeSolver)\n                        .solveType(nameExpr.getNameAsString());\n                if (typeDeclaration.isSolved() && typeDeclaration.getCorrespondingDeclaration() instanceof ResolvedReferenceTypeDeclaration) {\n                    ResolvedReferenceTypeDeclaration resolvedReferenceTypeDeclaration = (ResolvedReferenceTypeDeclaration) typeDeclaration.getCorrespondingDeclaration();\n                    return ReferenceTypeImpl.undeterminedParameters(resolvedReferenceTypeDeclaration, typeSolver);\n                }\n            }\n            throw e;\n        }\n    }\n\n    public ResolvedType getType(Node node, boolean solveLambdas) {\n        if (solveLambdas) {\n            if (!node.containsData(TYPE_WITH_LAMBDAS_RESOLVED)) {\n                ResolvedType res = getTypeConcrete(node, solveLambdas);\n\n                node.setData(TYPE_WITH_LAMBDAS_RESOLVED, res);\n\n                boolean secondPassNecessary = false;\n                if (node instanceof MethodCallExpr) {\n                    MethodCallExpr methodCallExpr = (MethodCallExpr) node;\n                    for (Node arg : methodCallExpr.getArguments()) {\n                        if (!arg.containsData(TYPE_WITH_LAMBDAS_RESOLVED)) {\n                            getType(arg, true);\n                            secondPassNecessary = true;\n                        }\n                    }\n                }\n                if (secondPassNecessary) {\n                    node.removeData(TYPE_WITH_LAMBDAS_RESOLVED);\n                    ResolvedType type = getType(node, true);\n                    node.setData(TYPE_WITH_LAMBDAS_RESOLVED, type);\n\n                }\n                Log.trace(\"getType on %s  -> %s\", () -> node, () -> res);\n            }\n            return node.getData(TYPE_WITH_LAMBDAS_RESOLVED);\n        } else {\n            Optional<ResolvedType> res = find(TYPE_WITH_LAMBDAS_RESOLVED, node);\n            if (res.isPresent()) {\n                return res.get();\n            }\n            res = find(TYPE_WITHOUT_LAMBDAS_RESOLVED, node);\n            if (!res.isPresent()) {\n                ResolvedType resType = getTypeConcrete(node, solveLambdas);\n                node.setData(TYPE_WITHOUT_LAMBDAS_RESOLVED, resType);\n                Optional<ResolvedType> finalRes = res;\n                Log.trace(\"getType on %s (no solveLambdas) -> %s\", () -> node, () -> finalRes);\n                return resType;\n            }\n            return res.get();\n        }\n    }\n\n    private Optional<ResolvedType> find(DataKey<ResolvedType> dataKey, Node node) {\n        if (node.containsData(dataKey)) {\n            return Optional.of(node.getData(dataKey));\n        }\n        return Optional.empty();\n    }\n\n    protected MethodUsage toMethodUsage(MethodReferenceExpr methodReferenceExpr, List<ResolvedType> paramTypes) {\n        Expression scope = methodReferenceExpr.getScope();\n        ResolvedType typeOfScope = getType(methodReferenceExpr.getScope());\n        if (!typeOfScope.isReferenceType()) {\n            throw new UnsupportedOperationException(typeOfScope.getClass().getCanonicalName());\n        }\n\n        Optional<MethodUsage> result;\n        Set<MethodUsage> allMethods = typeOfScope.asReferenceType().getTypeDeclaration()\n                .orElseThrow(() -> new RuntimeException(\"TypeDeclaration unexpectedly empty.\"))\n                .getAllMethods();\n\n        if (scope instanceof TypeExpr) {\n            // static methods should match all params\n            List<MethodUsage> staticMethodUsages = allMethods.stream()\n                    .filter(it -> it.getDeclaration().isStatic())\n                    .collect(Collectors.toList());\n\n            result = MethodResolutionLogic.findMostApplicableUsage(staticMethodUsages, methodReferenceExpr.getIdentifier(), paramTypes, typeSolver);\n\n            if (!paramTypes.isEmpty()) {\n                // instance methods are called on the first param and should match all other params\n                List<MethodUsage> instanceMethodUsages = allMethods.stream()\n                        .filter(it -> !it.getDeclaration().isStatic())\n                        .collect(Collectors.toList());\n\n                List<ResolvedType> instanceMethodParamTypes = new ArrayList<>(paramTypes);\n                instanceMethodParamTypes.remove(0); // remove the first one\n\n                Optional<MethodUsage> instanceResult = MethodResolutionLogic.findMostApplicableUsage(\n                        instanceMethodUsages, methodReferenceExpr.getIdentifier(), instanceMethodParamTypes, typeSolver);\n                if (result.isPresent() && instanceResult.isPresent()) {\n                    throw new MethodAmbiguityException(\"Ambiguous method call: cannot find a most applicable method for \" + methodReferenceExpr.getIdentifier());\n                }\n\n                if (instanceResult.isPresent()) {\n                    result = instanceResult;\n                }\n            }\n        } else {\n            result = MethodResolutionLogic.findMostApplicableUsage(new ArrayList<>(allMethods), methodReferenceExpr.getIdentifier(), paramTypes, typeSolver);\n\n            if (result.isPresent() && result.get().getDeclaration().isStatic()) {\n                throw new RuntimeException(\"Invalid static method reference \" + methodReferenceExpr.getIdentifier());\n            }\n        }\n\n        if (!result.isPresent()) {\n            throw new UnsupportedOperationException();\n        }\n\n        return result.get();\n    }\n\n    protected ResolvedType getBinaryTypeConcrete(Node left, Node right, boolean solveLambdas, BinaryExpr.Operator operator) {\n        ResolvedType leftType = getTypeConcrete(left, solveLambdas);\n        ResolvedType rightType = getTypeConcrete(right, solveLambdas);\n\n        // JLS 15.18.1. String Concatenation Operator +\n        // If only one operand expression is of type String, then string conversion (\u00a75.1.11) is performed on the other\n        // operand to produce a string at run time.\n        //\n        // The result of string concatenation is a reference to a String object that is the concatenation of the two\n        // operand strings. The characters of the left-hand operand precede the characters of the right-hand operand in\n        // the newly created string.\n\n        if (operator == BinaryExpr.Operator.PLUS) {\n            boolean isLeftString = leftType.isReferenceType() && leftType.asReferenceType()\n                    .getQualifiedName().equals(JAVA_LANG_STRING);\n            boolean isRightString = rightType.isReferenceType() && rightType.asReferenceType()\n                    .getQualifiedName().equals(JAVA_LANG_STRING);\n            if (isLeftString || isRightString) {\n                return isLeftString ? leftType : rightType;\n            }\n        }\n\n        // JLS 5.6.2. Binary Numeric Promotion\n        //\n        // Widening primitive conversion (\u00a75.1.2) is applied to convert either or both operands as specified by the\n        // following rules:\n        //\n        // * If either operand is of type double, the other is converted to double.\n        // * Otherwise, if either operand is of type float, the other is converted to float.\n        // * Otherwise, if either operand is of type long, the other is converted to long.\n        // * Otherwise, both operands are converted to type int.\n\n        boolean isLeftNumeric = leftType.isPrimitive() && leftType.asPrimitive().isNumeric();\n        boolean isRightNumeric = rightType.isPrimitive() && rightType.asPrimitive().isNumeric();\n\n        if (isLeftNumeric && isRightNumeric) {\n            return leftType.asPrimitive().bnp(rightType.asPrimitive());\n        }\n\n        if (rightType.isAssignableBy(leftType)) {\n            return rightType;\n        }\n        return leftType;\n    }\n\n\n    /**\n     * Should return more like a TypeApplication: a TypeDeclaration and possible typeParametersValues or array\n     * modifiers.\n     */\n    private ResolvedType getTypeConcrete(Node node, boolean solveLambdas) {\n        if (node == null) throw new IllegalArgumentException();\n        return node.accept(typeExtractor, solveLambdas);\n    }\n\n    /**\n     * Where a node has an interface/class/enum declaration as its ancestor, return the nearest one.\n     * <p>\n     * NOTE: See {@link #findContainingTypeDeclOrObjectCreationExpr} if wanting to include anonymous inner classes.\n     * <p>\n     * For example, these all return X:\n     * {@code public interface X { ... node here ... }}\n     * {@code public class X { ... node here ... }}\n     * {@code public enum X { ... node here ... }}\n     *\n     * @param node The Node whose ancestors will be traversed,\n     * @return The first class/interface/enum declaration in the Node's ancestry.\n     */\n    protected TypeDeclaration<?> findContainingTypeDecl(Node node) {\n        Node parent = node;\n        while (true) {\n            parent = demandParentNode(parent);\n            if (parent instanceof TypeDeclaration) {\n                return (TypeDeclaration<?>) parent;\n            }\n        }\n    }\n\n    /**\n     * Where a node has an interface/class/enum declaration -- or an object creation expression (anonymous inner class)\n     * -- as its ancestor, return the nearest one.\n     * <p>\n     * NOTE: See {@link #findContainingTypeDecl} if wanting to not include anonymous inner classes.\n     * <p>\n     * For example, these all return X:\n     * <ul>\n     *     <li>{@code public interface X { ... node here ... }}</li>\n     *     <li>{@code public class X { ... node here ... }}</li>\n     *     <li>{@code public enum X { ... node here ... }}</li>\n     *     <li><pre>{@code\n     *     new ActionListener() {\n     *          ... node here ...\n     *          public void actionPerformed(ActionEvent e) {\n     *               ... or node here ...\n     *          }\n     *     }\n     *     }</pre></li>\n     * </ul>\n     * <p>\n     *\n     * @param node The Node whose ancestors will be traversed,\n     * @return The first class/interface/enum declaration -- or object creation expression (anonymous inner class) -- in\n     * the Node's ancestry.\n     */\n    protected Node findContainingTypeDeclOrObjectCreationExpr(Node node) {\n        Node parent = node;\n        boolean detachFlag = false;\n        while (true) {\n            parent = demandParentNode(parent);\n            if (parent instanceof BodyDeclaration) {\n                if (parent instanceof TypeDeclaration) {\n                    return parent;\n                } else {\n                    detachFlag = true;\n                }\n            } else if (parent instanceof ObjectCreationExpr) {\n                if (detachFlag) {\n                    return parent;\n                }\n            }\n        }\n    }\n\n    /**\n     * Where a node has an interface/class/enum declaration -- or an object creation expression in an inner class\n     * references an outer class -- as its ancestor, return the declaration corresponding to the class name specified.\n     */\n    protected Node findContainingTypeDeclOrObjectCreationExpr(Node node, String className) {\n        Node parent = node;\n        boolean detachFlag = false;\n        while (true) {\n            parent = demandParentNode(parent);\n            if (parent instanceof BodyDeclaration) {\n                if (parent instanceof TypeDeclaration && ((TypeDeclaration<?>) parent).getFullyQualifiedName().get().endsWith(className)) {\n                    return parent;\n                } else {\n                    detachFlag = true;\n                }\n            } else if (parent instanceof ObjectCreationExpr) {\n                if (detachFlag) {\n                    return parent;\n                }\n            }\n        }\n    }\n\n\n    public ResolvedType convertToUsageVariableType(VariableDeclarator var) {\n        return get(typeSolver).convertToUsage(var.getType(), var);\n    }\n\n    public ResolvedType convertToUsage(Type type, Node context) {\n        if (type.isUnknownType()) {\n            throw new IllegalArgumentException(\"Inferred lambda parameter type\");\n        }\n        return convertToUsage(type, JavaParserFactory.getContext(context, typeSolver));\n    }\n\n    public ResolvedType convertToUsage(Type type) {\n        return convertToUsage(type, type);\n    }\n\n    // This is an hack around an issue in JavaParser\n    private String qName(ClassOrInterfaceType classOrInterfaceType) {\n        String name = classOrInterfaceType.getName().getId();\n        if (classOrInterfaceType.getScope().isPresent()) {\n            return qName(classOrInterfaceType.getScope().get()) + \".\" + name;\n        }\n        return name;\n    }\n\n    protected ResolvedType convertToUsage(Type type, Context context) {\n        if (context == null) {\n            throw new NullPointerException(\"Context should not be null\");\n        }\n        if (type instanceof ClassOrInterfaceType) {\n            return convertToUsage((ClassOrInterfaceType) type, context);\n        } else if (type instanceof PrimitiveType) {\n            return ResolvedPrimitiveType.byName(((PrimitiveType) type).getType().name());\n        } else if (type instanceof WildcardType) {\n            return convertToUsage((WildcardType) type, context);\n        } else if (type instanceof VoidType) {\n            return ResolvedVoidType.INSTANCE;\n        } else if (type instanceof ArrayType) {\n            return convertToUsage((ArrayType) type, context);\n        } else if (type instanceof UnionType) {\n            UnionType unionType = (UnionType) type;\n            return new ResolvedUnionType(unionType.getElements().stream().map(el -> convertToUsage(el, context)).collect(Collectors.toList()));\n        } else if (type instanceof VarType) {\n            Node parent = type.getParentNode().get();\n            if (!(parent instanceof VariableDeclarator)) {\n                throw new IllegalStateException(\"Trying to resolve a `var` which is not in a variable declaration.\");\n            }\n            final VariableDeclarator variableDeclarator = (VariableDeclarator) parent;\n            return variableDeclarator.getInitializer()\n                    .map(Expression::calculateResolvedType)\n                    .orElseThrow(() -> new IllegalStateException(\"Cannot resolve `var` which has no initializer.\"));\n        } else {\n            throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n        }\n    }\n\n    protected ResolvedType convertToUsage(ClassOrInterfaceType classOrInterfaceType, Context context) {\n        String name = qName(classOrInterfaceType);\n        SymbolReference<ResolvedTypeDeclaration> ref = context.solveType(name);\n        if (!ref.isSolved()) {\n            throw new UnsolvedSymbolException(name);\n        }\n        ResolvedTypeDeclaration typeDeclaration = ref.getCorrespondingDeclaration();\n        List<ResolvedType> typeParameters = Collections.emptyList();\n        if (classOrInterfaceType.getTypeArguments().isPresent()) {\n            typeParameters = classOrInterfaceType.getTypeArguments().get().stream().map((pt) -> convertToUsage(pt, context)).collect(Collectors.toList());\n        }\n        if (typeDeclaration.isTypeParameter()) {\n            if (typeDeclaration instanceof ResolvedTypeParameterDeclaration) {\n                return new ResolvedTypeVariable((ResolvedTypeParameterDeclaration) typeDeclaration);\n            } else {\n                JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration = (JavaParserTypeVariableDeclaration) typeDeclaration;\n                return new ResolvedTypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n            }\n        } else {\n            return new ReferenceTypeImpl((ResolvedReferenceTypeDeclaration) typeDeclaration, typeParameters, typeSolver);\n        }\n    }\n\n    protected ResolvedType convertToUsage(WildcardType wildcardType, Context context) {\n        if (wildcardType.getExtendedType().isPresent() && !wildcardType.getSuperType().isPresent()) {\n            return ResolvedWildcard.extendsBound(convertToUsage(wildcardType.getExtendedType().get(), context)); // removed (ReferenceTypeImpl)\n        } else if (!wildcardType.getExtendedType().isPresent() && wildcardType.getSuperType().isPresent()) {\n            return ResolvedWildcard.superBound(convertToUsage(wildcardType.getSuperType().get(), context)); // removed (ReferenceTypeImpl)\n        } else if (!wildcardType.getExtendedType().isPresent() && !wildcardType.getSuperType().isPresent()) {\n            return ResolvedWildcard.UNBOUNDED;\n        } else {\n            throw new UnsupportedOperationException(wildcardType.toString());\n        }\n    }\n\n    protected ResolvedType convertToUsage(ArrayType arrayType, Context context) {\n        return new ResolvedArrayType(convertToUsage(arrayType.getComponentType(), context));\n    }\n\n    public ResolvedType convert(Type type, Node node) {\n        return convert(type, JavaParserFactory.getContext(node, typeSolver));\n    }\n\n    public ResolvedType convert(Type type, Context context) {\n        return convertToUsage(type, context);\n    }\n\n    public MethodUsage solveMethodAsUsage(MethodCallExpr call) {\n        List<ResolvedType> params = new ArrayList<>();\n        if (call.getArguments() != null) {\n            for (Expression param : call.getArguments()) {\n                //getTypeConcrete(Node node, boolean solveLambdas)\n                try {\n                    params.add(getType(param, false));\n                } catch (Exception e) {\n                    throw new RuntimeException(String.format(\"Error calculating the type of parameter %s of method call %s\", param, call), e);\n                }\n                //params.add(getTypeConcrete(param, false));\n            }\n        }\n        Context context = JavaParserFactory.getContext(call, typeSolver);\n        Optional<MethodUsage> methodUsage = context.solveMethodAsUsage(call.getName().getId(), params);\n        if (!methodUsage.isPresent()) {\n            throw new RuntimeException(\"Method '\" + call.getName() + \"' cannot be resolved in context \"\n                    + call + \" (line: \" + call.getRange().map(r -> \"\" + r.begin.line).orElse(\"??\") + \") \" + context + \". Parameter types: \" + params);\n        }\n        return methodUsage.get();\n    }\n\n    public ResolvedReferenceTypeDeclaration getTypeDeclaration(Node node) {\n        if (node instanceof TypeDeclaration) {\n            return getTypeDeclaration((TypeDeclaration) node);\n        } else if (node instanceof ObjectCreationExpr) {\n            return new JavaParserAnonymousClassDeclaration((ObjectCreationExpr) node, typeSolver);\n        } else {\n            throw new IllegalArgumentException();\n        }\n    }\n\n    public ResolvedReferenceTypeDeclaration getTypeDeclaration(ClassOrInterfaceDeclaration classOrInterfaceDeclaration) {\n        return JavaParserFactory.toTypeDeclaration(classOrInterfaceDeclaration, typeSolver);\n    }\n\n    /**\n     * \"this\" inserted in the given point, which type would have?\n     */\n    public ResolvedType getTypeOfThisIn(Node node) {\n        // TODO consider static methods\n        if (node instanceof ClassOrInterfaceDeclaration) {\n            return new ReferenceTypeImpl(getTypeDeclaration((ClassOrInterfaceDeclaration) node), typeSolver);\n        } else if (node instanceof EnumDeclaration) {\n            JavaParserEnumDeclaration enumDeclaration = new JavaParserEnumDeclaration((EnumDeclaration) node, typeSolver);\n            return new ReferenceTypeImpl(enumDeclaration, typeSolver);\n        } else if (node instanceof ObjectCreationExpr && ((ObjectCreationExpr) node).getAnonymousClassBody().isPresent()) {\n            JavaParserAnonymousClassDeclaration anonymousDeclaration = new JavaParserAnonymousClassDeclaration((ObjectCreationExpr) node, typeSolver);\n            return new ReferenceTypeImpl(anonymousDeclaration, typeSolver);\n        }\n        return getTypeOfThisIn(demandParentNode(node));\n    }\n\n    public ResolvedReferenceTypeDeclaration getTypeDeclaration(TypeDeclaration<?> typeDeclaration) {\n        return JavaParserFactory.toTypeDeclaration(typeDeclaration, typeSolver);\n    }\n\n    public ResolvedType classToResolvedType(Class<?> clazz) {\n        if (clazz.isPrimitive()) {\n            return ResolvedPrimitiveType.byName(clazz.getName());\n        }\n\n        ResolvedReferenceTypeDeclaration declaration;\n        if (clazz.isAnnotation()) {\n            declaration = new ReflectionAnnotationDeclaration(clazz, typeSolver);\n        } else if (clazz.isEnum()) {\n            declaration = new ReflectionEnumDeclaration(clazz, typeSolver);\n        } else if (clazz.isInterface()) {\n            declaration = new ReflectionInterfaceDeclaration(clazz, typeSolver);\n        } else {\n            declaration = new ReflectionClassDeclaration(clazz, typeSolver);\n        }\n        return new ReferenceTypeImpl(declaration, typeSolver);\n    }\n\n}\n",
        "diffSourceCodeSet": [
            "protected ResolvedType convertToUsage(ArrayType arrayType, Context context) {\n        return new ResolvedArrayType(convertToUsage(arrayType.getComponentType(), context));\n    }"
        ],
        "invokedMethodSet": [
            "methodSignature: com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade#getType\n methodBody: public ResolvedType getType(Node node, boolean solveLambdas) {\nif(solveLambdas){if(!node.containsData(TYPE_WITH_LAMBDAS_RESOLVED)){ResolvedType res=getTypeConcrete(node,solveLambdas);\nnode.setData(TYPE_WITH_LAMBDAS_RESOLVED,res);\nboolean secondPassNecessary=false;\nif(node instanceof MethodCallExpr){MethodCallExpr methodCallExpr=(MethodCallExpr)node;\nfor(Node arg: methodCallExpr.getArguments()){if(!arg.containsData(TYPE_WITH_LAMBDAS_RESOLVED)){getType(arg,true);\nsecondPassNecessary=true;\n}}}if(secondPassNecessary){node.removeData(TYPE_WITH_LAMBDAS_RESOLVED);\nResolvedType type=getType(node,true);\nnode.setData(TYPE_WITH_LAMBDAS_RESOLVED,type);\n}Log.trace(\"getType on %s  -> %s\",() -> node,() -> res);\n}return node.getData(TYPE_WITH_LAMBDAS_RESOLVED);\n}{Optional<ResolvedType> res=find(TYPE_WITH_LAMBDAS_RESOLVED,node);\nif(res.isPresent()){return res.get();\n}res=find(TYPE_WITHOUT_LAMBDAS_RESOLVED,node);\nif(!res.isPresent()){ResolvedType resType=getTypeConcrete(node,solveLambdas);\nnode.setData(TYPE_WITHOUT_LAMBDAS_RESOLVED,resType);\nOptional<ResolvedType> finalRes=res;\nLog.trace(\"getType on %s (no solveLambdas) -> %s\",() -> node,() -> finalRes);\nreturn resType;\n}return res.get();\n}}",
            "methodSignature: com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade#get\n methodBody: public synchronized static JavaParserFacade get(TypeSolver typeSolver) {\nreturn instances.computeIfAbsent(typeSolver,JavaParserFacade::new);\n}",
            "methodSignature: com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade#convertToUsage\n methodBody: protected ResolvedType convertToUsage(WildcardType wildcardType, Context context) {\nif(wildcardType.getExtendedType().isPresent() && !wildcardType.getSuperType().isPresent()){return ResolvedWildcard.extendsBound(convertToUsage(wildcardType.getExtendedType().get(),context));\n}if(!wildcardType.getExtendedType().isPresent() && wildcardType.getSuperType().isPresent()){return ResolvedWildcard.superBound(convertToUsage(wildcardType.getSuperType().get(),context));\n}if(!wildcardType.getExtendedType().isPresent() && !wildcardType.getSuperType().isPresent()){return ResolvedWildcard.UNBOUNDED;\n}{throw new UnsupportedOperationException(wildcardType.toString());\n}}"
        ],
        "sourceCodeAfterRefactoring": "protected ResolvedType convertToUsage(Type type, Context context) {\n        if (context == null) {\n            throw new NullPointerException(\"Context should not be null\");\n        }\n        if (type instanceof ClassOrInterfaceType) {\n            return convertToUsage((ClassOrInterfaceType) type, context);\n        } else if (type instanceof PrimitiveType) {\n            return ResolvedPrimitiveType.byName(((PrimitiveType) type).getType().name());\n        } else if (type instanceof WildcardType) {\n            return convertToUsage((WildcardType) type, context);\n        } else if (type instanceof VoidType) {\n            return ResolvedVoidType.INSTANCE;\n        } else if (type instanceof ArrayType) {\n            return convertToUsage((ArrayType) type, context);\n        } else if (type instanceof UnionType) {\n            UnionType unionType = (UnionType) type;\n            return new ResolvedUnionType(unionType.getElements().stream().map(el -> convertToUsage(el, context)).collect(Collectors.toList()));\n        } else if (type instanceof VarType) {\n            Node parent = type.getParentNode().get();\n            if (!(parent instanceof VariableDeclarator)) {\n                throw new IllegalStateException(\"Trying to resolve a `var` which is not in a variable declaration.\");\n            }\n            final VariableDeclarator variableDeclarator = (VariableDeclarator) parent;\n            return variableDeclarator.getInitializer()\n                    .map(Expression::calculateResolvedType)\n                    .orElseThrow(() -> new IllegalStateException(\"Cannot resolve `var` which has no initializer.\"));\n        } else {\n            throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n        }\n    }\nprotected ResolvedType convertToUsage(ArrayType arrayType, Context context) {\n        return new ResolvedArrayType(convertToUsage(arrayType.getComponentType(), context));\n    }",
        "diffSourceCode": "   677:     protected ResolvedType convertToUsage(Type type, Context context) {\n   678:         if (context == null) {\n   679:             throw new NullPointerException(\"Context should not be null\");\n   680:         }\n   681:         if (type instanceof ClassOrInterfaceType) {\n   682:             return convertToUsage((ClassOrInterfaceType) type, context);\n   683:         } else if (type instanceof PrimitiveType) {\n   684:             return ResolvedPrimitiveType.byName(((PrimitiveType) type).getType().name());\n   685:         } else if (type instanceof WildcardType) {\n   686:             return convertToUsage((WildcardType) type, context);\n   687:         } else if (type instanceof VoidType) {\n   688:             return ResolvedVoidType.INSTANCE;\n   689:         } else if (type instanceof ArrayType) {\n-  690:             ArrayType jpArrayType = (ArrayType) type;\n-  691:             return new ResolvedArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n-  692:         } else if (type instanceof UnionType) {\n-  693:             UnionType unionType = (UnionType) type;\n-  694:             return new ResolvedUnionType(unionType.getElements().stream().map(el -> convertToUsage(el, context)).collect(Collectors.toList()));\n-  695:         } else if (type instanceof VarType) {\n-  696:             Node parent = type.getParentNode().get();\n-  697:             if (!(parent instanceof VariableDeclarator)) {\n-  698:                 throw new IllegalStateException(\"Trying to resolve a `var` which is not in a variable declaration.\");\n-  699:             }\n-  700:             final VariableDeclarator variableDeclarator = (VariableDeclarator) parent;\n-  701:             return variableDeclarator.getInitializer()\n-  702:                     .map(Expression::calculateResolvedType)\n-  703:                     .orElseThrow(() -> new IllegalStateException(\"Cannot resolve `var` which has no initializer.\"));\n-  704:         } else {\n-  705:             throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n-  706:         }\n-  707:     }\n-  743: \n-  744:     public ResolvedType convert(Type type, Node node) {\n-  745:         return convert(type, JavaParserFactory.getContext(node, typeSolver));\n+  690:             return convertToUsage((ArrayType) type, context);\n+  691:         } else if (type instanceof UnionType) {\n+  692:             UnionType unionType = (UnionType) type;\n+  693:             return new ResolvedUnionType(unionType.getElements().stream().map(el -> convertToUsage(el, context)).collect(Collectors.toList()));\n+  694:         } else if (type instanceof VarType) {\n+  695:             Node parent = type.getParentNode().get();\n+  696:             if (!(parent instanceof VariableDeclarator)) {\n+  697:                 throw new IllegalStateException(\"Trying to resolve a `var` which is not in a variable declaration.\");\n+  698:             }\n+  699:             final VariableDeclarator variableDeclarator = (VariableDeclarator) parent;\n+  700:             return variableDeclarator.getInitializer()\n+  701:                     .map(Expression::calculateResolvedType)\n+  702:                     .orElseThrow(() -> new IllegalStateException(\"Cannot resolve `var` which has no initializer.\"));\n+  703:         } else {\n+  704:             throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n+  705:         }\n+  706:     }\n+  707: \n+  743:     protected ResolvedType convertToUsage(ArrayType arrayType, Context context) {\n+  744:         return new ResolvedArrayType(convertToUsage(arrayType.getComponentType(), context));\n+  745:     }\n",
        "uniqueId": "454cc575960fdb902d93b21a56a071e31d3f81d7_677_707_743_745_677_706",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 6,
                "covered": 44
            },
            "BRANCH": {
                "missed": 4,
                "covered": 8
            },
            "LINE": {
                "missed": 1,
                "covered": 6
            },
            "COMPLEXITY": {
                "missed": 4,
                "covered": 3
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 17
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprotected convertToUsage(wildcardType WildcardType, context Context) : ResolvedType extracted from protected convertToUsage(type Type, context Context) : ResolvedType in class com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade",
        "diffLocations": [
            {
                "filePath": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java",
                "startLine": 677,
                "endLine": 716,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java",
                "startLine": 677,
                "endLine": 707,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java",
                "startLine": 732,
                "endLine": 742,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "protected ResolvedType convertToUsage(Type type, Context context) {\n        if (context == null) {\n            throw new NullPointerException(\"Context should not be null\");\n        }\n        if (type instanceof ClassOrInterfaceType) {\n            return convertToUsage((ClassOrInterfaceType) type, context);\n        } else if (type instanceof PrimitiveType) {\n            return ResolvedPrimitiveType.byName(((PrimitiveType) type).getType().name());\n        } else if (type instanceof WildcardType) {\n            WildcardType wildcardType = (WildcardType) type;\n            if (wildcardType.getExtendedType().isPresent() && !wildcardType.getSuperType().isPresent()) {\n                return ResolvedWildcard.extendsBound(convertToUsage(wildcardType.getExtendedType().get(), context)); // removed (ReferenceTypeImpl)\n            } else if (!wildcardType.getExtendedType().isPresent() && wildcardType.getSuperType().isPresent()) {\n                return ResolvedWildcard.superBound(convertToUsage(wildcardType.getSuperType().get(), context)); // removed (ReferenceTypeImpl)\n            } else if (!wildcardType.getExtendedType().isPresent() && !wildcardType.getSuperType().isPresent()) {\n                return ResolvedWildcard.UNBOUNDED;\n            } else {\n                throw new UnsupportedOperationException(wildcardType.toString());\n            }\n        } else if (type instanceof VoidType) {\n            return ResolvedVoidType.INSTANCE;\n        } else if (type instanceof ArrayType) {\n            ArrayType jpArrayType = (ArrayType) type;\n            return new ResolvedArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n        } else if (type instanceof UnionType) {\n            UnionType unionType = (UnionType) type;\n            return new ResolvedUnionType(unionType.getElements().stream().map(el -> convertToUsage(el, context)).collect(Collectors.toList()));\n        } else if (type instanceof VarType) {\n            Node parent = type.getParentNode().get();\n            if (!(parent instanceof VariableDeclarator)) {\n                throw new IllegalStateException(\"Trying to resolve a `var` which is not in a variable declaration.\");\n            }\n            final VariableDeclarator variableDeclarator = (VariableDeclarator) parent;\n            return variableDeclarator.getInitializer()\n                    .map(Expression::calculateResolvedType)\n                    .orElseThrow(() -> new IllegalStateException(\"Cannot resolve `var` which has no initializer.\"));\n        } else {\n            throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n        }\n    }",
        "filePathBefore": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java",
        "isPureRefactoring": true,
        "commitId": "02410715bad58480d6ce66f64db8c11a4fa607b4",
        "packageNameBefore": "com.github.javaparser.symbolsolver.javaparsermodel",
        "classNameBefore": "com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade",
        "methodNameBefore": "com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade#convertToUsage",
        "invokedMethod": "methodSignature: com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade#getType\n methodBody: public ResolvedType getType(Node node, boolean solveLambdas) {\nif(solveLambdas){if(!node.containsData(TYPE_WITH_LAMBDAS_RESOLVED)){ResolvedType res=getTypeConcrete(node,solveLambdas);\nnode.setData(TYPE_WITH_LAMBDAS_RESOLVED,res);\nboolean secondPassNecessary=false;\nif(node instanceof MethodCallExpr){MethodCallExpr methodCallExpr=(MethodCallExpr)node;\nfor(Node arg: methodCallExpr.getArguments()){if(!arg.containsData(TYPE_WITH_LAMBDAS_RESOLVED)){getType(arg,true);\nsecondPassNecessary=true;\n}}}if(secondPassNecessary){node.removeData(TYPE_WITH_LAMBDAS_RESOLVED);\nResolvedType type=getType(node,true);\nnode.setData(TYPE_WITH_LAMBDAS_RESOLVED,type);\n}Log.trace(\"getType on %s  -> %s\",() -> node,() -> res);\n}return node.getData(TYPE_WITH_LAMBDAS_RESOLVED);\n}{Optional<ResolvedType> res=find(TYPE_WITH_LAMBDAS_RESOLVED,node);\nif(res.isPresent()){return res.get();\n}res=find(TYPE_WITHOUT_LAMBDAS_RESOLVED,node);\nif(!res.isPresent()){ResolvedType resType=getTypeConcrete(node,solveLambdas);\nnode.setData(TYPE_WITHOUT_LAMBDAS_RESOLVED,resType);\nOptional<ResolvedType> finalRes=res;\nLog.trace(\"getType on %s (no solveLambdas) -> %s\",() -> node,() -> finalRes);\nreturn resType;\n}return res.get();\n}}\nmethodSignature: com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade#get\n methodBody: public synchronized static JavaParserFacade get(TypeSolver typeSolver) {\nreturn instances.computeIfAbsent(typeSolver,JavaParserFacade::new);\n}\nmethodSignature: com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade#convertToUsage\n methodBody: protected ResolvedType convertToUsage(ClassOrInterfaceType classOrInterfaceType, Context context) {\nString name=qName(classOrInterfaceType);\nSymbolReference<ResolvedTypeDeclaration> ref=context.solveType(name);\nif(!ref.isSolved()){throw new UnsolvedSymbolException(name);\n}ResolvedTypeDeclaration typeDeclaration=ref.getCorrespondingDeclaration();\nList<ResolvedType> typeParameters=Collections.emptyList();\nif(classOrInterfaceType.getTypeArguments().isPresent()){typeParameters=classOrInterfaceType.getTypeArguments().get().stream().map((pt) -> convertToUsage(pt,context)).collect(Collectors.toList());\n}if(typeDeclaration.isTypeParameter()){if(typeDeclaration instanceof ResolvedTypeParameterDeclaration){return new ResolvedTypeVariable((ResolvedTypeParameterDeclaration)typeDeclaration);\n}{JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration=(JavaParserTypeVariableDeclaration)typeDeclaration;\nreturn new ResolvedTypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n}}{return new ReferenceTypeImpl((ResolvedReferenceTypeDeclaration)typeDeclaration,typeParameters,typeSolver);\n}}",
        "classSignatureBefore": "public class JavaParserFacade ",
        "methodNameBeforeSet": [
            "com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade#convertToUsage"
        ],
        "classNameBeforeSet": [
            "com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade"
        ],
        "classSignatureBeforeSet": [
            "public class JavaParserFacade "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Copyright (C) 2015-2016 Federico Tomassetti\n * Copyright (C) 2017-2020 The JavaParser Team.\n *\n * This file is part of JavaParser.\n *\n * JavaParser can be used either under the terms of\n * a) the GNU Lesser General Public License as published by\n *     the Free Software Foundation, either version 3 of the License, or\n *     (at your option) any later version.\n * b) the terms of the Apache License\n *\n * You should have received a copy of both licenses in LICENCE.LGPL and\n * LICENCE.APACHE. Please refer to those files for details.\n *\n * JavaParser is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n */\n\npackage com.github.javaparser.symbolsolver.javaparsermodel;\n\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.DataKey;\nimport com.github.javaparser.ast.Node;\nimport com.github.javaparser.ast.NodeList;\nimport com.github.javaparser.ast.body.BodyDeclaration;\nimport com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;\nimport com.github.javaparser.ast.body.EnumDeclaration;\nimport com.github.javaparser.ast.body.TypeDeclaration;\nimport com.github.javaparser.ast.body.VariableDeclarator;\nimport com.github.javaparser.ast.expr.AnnotationExpr;\nimport com.github.javaparser.ast.expr.BinaryExpr;\nimport com.github.javaparser.ast.expr.Expression;\nimport com.github.javaparser.ast.expr.FieldAccessExpr;\nimport com.github.javaparser.ast.expr.LambdaExpr;\nimport com.github.javaparser.ast.expr.MethodCallExpr;\nimport com.github.javaparser.ast.expr.MethodReferenceExpr;\nimport com.github.javaparser.ast.expr.NameExpr;\nimport com.github.javaparser.ast.expr.ObjectCreationExpr;\nimport com.github.javaparser.ast.expr.SimpleName;\nimport com.github.javaparser.ast.expr.ThisExpr;\nimport com.github.javaparser.ast.expr.TypeExpr;\nimport com.github.javaparser.ast.stmt.ExplicitConstructorInvocationStmt;\nimport com.github.javaparser.ast.type.ArrayType;\nimport com.github.javaparser.ast.type.ClassOrInterfaceType;\nimport com.github.javaparser.ast.type.PrimitiveType;\nimport com.github.javaparser.ast.type.Type;\nimport com.github.javaparser.ast.type.UnionType;\nimport com.github.javaparser.ast.type.VarType;\nimport com.github.javaparser.ast.type.VoidType;\nimport com.github.javaparser.ast.type.WildcardType;\nimport com.github.javaparser.resolution.MethodAmbiguityException;\nimport com.github.javaparser.resolution.MethodUsage;\nimport com.github.javaparser.resolution.UnsolvedSymbolException;\nimport com.github.javaparser.resolution.declarations.ResolvedAnnotationDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedClassDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedConstructorDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedMethodDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedReferenceTypeDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedTypeDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedTypeParameterDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedValueDeclaration;\nimport com.github.javaparser.resolution.types.ResolvedArrayType;\nimport com.github.javaparser.resolution.types.ResolvedPrimitiveType;\nimport com.github.javaparser.resolution.types.ResolvedReferenceType;\nimport com.github.javaparser.resolution.types.ResolvedType;\nimport com.github.javaparser.resolution.types.ResolvedTypeVariable;\nimport com.github.javaparser.resolution.types.ResolvedUnionType;\nimport com.github.javaparser.resolution.types.ResolvedVoidType;\nimport com.github.javaparser.resolution.types.ResolvedWildcard;\nimport com.github.javaparser.symbolsolver.core.resolution.Context;\nimport com.github.javaparser.symbolsolver.javaparsermodel.contexts.FieldAccessContext;\nimport com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserAnonymousClassDeclaration;\nimport com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserEnumDeclaration;\nimport com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserTypeVariableDeclaration;\nimport com.github.javaparser.symbolsolver.model.resolution.SymbolReference;\nimport com.github.javaparser.symbolsolver.model.resolution.TypeSolver;\nimport com.github.javaparser.symbolsolver.model.typesystem.ReferenceTypeImpl;\nimport com.github.javaparser.symbolsolver.reflectionmodel.ReflectionAnnotationDeclaration;\nimport com.github.javaparser.symbolsolver.reflectionmodel.ReflectionClassDeclaration;\nimport com.github.javaparser.symbolsolver.reflectionmodel.ReflectionEnumDeclaration;\nimport com.github.javaparser.symbolsolver.reflectionmodel.ReflectionInterfaceDeclaration;\nimport com.github.javaparser.symbolsolver.resolution.ConstructorResolutionLogic;\nimport com.github.javaparser.symbolsolver.resolution.MethodResolutionLogic;\nimport com.github.javaparser.symbolsolver.resolution.SymbolSolver;\nimport com.github.javaparser.utils.Log;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.Set;\nimport java.util.WeakHashMap;\nimport java.util.stream.Collectors;\n\nimport static com.github.javaparser.symbolsolver.javaparser.Navigator.demandParentNode;\nimport static com.github.javaparser.symbolsolver.model.resolution.SymbolReference.solved;\nimport static com.github.javaparser.symbolsolver.model.resolution.SymbolReference.unsolved;\n\n/**\n * Class to be used by final users to solve symbols for JavaParser ASTs.\n *\n * @author Federico Tomassetti\n */\npublic class JavaParserFacade {\n\n    private static final DataKey<ResolvedType> TYPE_WITH_LAMBDAS_RESOLVED = new DataKey<ResolvedType>() {\n    };\n    private static final DataKey<ResolvedType> TYPE_WITHOUT_LAMBDAS_RESOLVED = new DataKey<ResolvedType>() {\n    };\n\n    private static final Map<TypeSolver, JavaParserFacade> instances = new WeakHashMap<>();\n    \n    private static String JAVA_LANG_STRING = String.class.getCanonicalName();\n    \n    private final TypeSolver typeSolver;\n    private final TypeExtractor typeExtractor;\n    private final SymbolSolver symbolSolver;\n\n    private JavaParserFacade(TypeSolver typeSolver) {\n        this.typeSolver = typeSolver.getRoot();\n        this.symbolSolver = new SymbolSolver(typeSolver);\n        this.typeExtractor = new TypeExtractor(typeSolver, this);\n    }\n\n    public TypeSolver getTypeSolver() {\n        return typeSolver;\n    }\n\n    public SymbolSolver getSymbolSolver() {\n        return symbolSolver;\n    }\n\n    /**\n     * Note that the addition of the modifier {@code synchronized} is specific and directly in response to issue #2668.\n     * <br>This <strong>MUST NOT</strong> be misinterpreted as a signal that JavaParser is safe to use within a multi-threaded environment.\n     * <br>\n     * <br>Additional discussion and context from a user attempting multithreading can be found within issue #2671 .\n     * <br>\n     *\n     * @see <a href=\"https://github.com/javaparser/javaparser/issues/2668\">https://github.com/javaparser/javaparser/issues/2668</a>\n     * @see <a href=\"https://github.com/javaparser/javaparser/issues/2671\">https://github.com/javaparser/javaparser/issues/2671</a>\n     */\n    public synchronized static JavaParserFacade get(TypeSolver typeSolver) {\n        return instances.computeIfAbsent(typeSolver, JavaParserFacade::new);\n    }\n\n    /**\n     * This method is used to clear internal caches for the sake of releasing memory.\n     */\n    public static void clearInstances() {\n        instances.clear();\n    }\n\n    protected static ResolvedType solveGenericTypes(ResolvedType type, Context context) {\n        if (type.isTypeVariable()) {\n            return context.solveGenericType(type.describe()).orElse(type);\n        }\n        if (type.isWildcard()) {\n            if (type.asWildcard().isExtends() || type.asWildcard().isSuper()) {\n                ResolvedWildcard wildcardUsage = type.asWildcard();\n                ResolvedType boundResolved = solveGenericTypes(wildcardUsage.getBoundedType(), context);\n                if (wildcardUsage.isExtends()) {\n                    return ResolvedWildcard.extendsBound(boundResolved);\n                } else {\n                    return ResolvedWildcard.superBound(boundResolved);\n                }\n            }\n        }\n        return type;\n    }\n\n    public SymbolReference<? extends ResolvedValueDeclaration> solve(NameExpr nameExpr) {\n        return symbolSolver.solveSymbol(nameExpr.getName().getId(), nameExpr);\n    }\n\n    public SymbolReference<? extends ResolvedValueDeclaration> solve(SimpleName nameExpr) {\n        return symbolSolver.solveSymbol(nameExpr.getId(), nameExpr);\n    }\n\n    public SymbolReference<? extends ResolvedValueDeclaration> solve(Expression expr) {\n        return expr.toNameExpr().map(this::solve).orElseThrow(() -> new IllegalArgumentException(expr.getClass().getCanonicalName()));\n    }\n\n    public SymbolReference<ResolvedMethodDeclaration> solve(MethodCallExpr methodCallExpr) {\n        return solve(methodCallExpr, true);\n    }\n\n    public SymbolReference<ResolvedMethodDeclaration> solve(MethodReferenceExpr methodReferenceExpr) {\n        return solve(methodReferenceExpr, true);\n    }\n\n    public SymbolReference<ResolvedConstructorDeclaration> solve(ObjectCreationExpr objectCreationExpr) {\n        return solve(objectCreationExpr, true);\n    }\n\n    public SymbolReference<ResolvedConstructorDeclaration> solve(ExplicitConstructorInvocationStmt explicitConstructorInvocationStmt) {\n        return solve(explicitConstructorInvocationStmt, true);\n    }\n\n    public SymbolReference<ResolvedConstructorDeclaration> solve(ExplicitConstructorInvocationStmt explicitConstructorInvocationStmt, boolean solveLambdas) {\n        // Constructor invocation must exist within a class (not interface).\n        Optional<ClassOrInterfaceDeclaration> optAncestorClassOrInterfaceNode = explicitConstructorInvocationStmt.findAncestor(ClassOrInterfaceDeclaration.class);\n        if (!optAncestorClassOrInterfaceNode.isPresent()) {\n            return unsolved(ResolvedConstructorDeclaration.class);\n        }\n\n        ClassOrInterfaceDeclaration classOrInterfaceNode = optAncestorClassOrInterfaceNode.get();\n        ResolvedReferenceTypeDeclaration resolvedClassNode = classOrInterfaceNode.resolve();\n        if (!resolvedClassNode.isClass()) {\n            throw new IllegalStateException(\"Expected to be a class -- cannot call this() or super() within an interface.\");\n        }\n\n        ResolvedTypeDeclaration typeDecl = null;\n        if (explicitConstructorInvocationStmt.isThis()) {\n            // this()\n            typeDecl = resolvedClassNode.asReferenceType();\n        } else {\n            // super()\n            Optional<ResolvedReferenceType> superClass = resolvedClassNode.asClass().getSuperClass();\n            if (superClass.isPresent() && superClass.get().getTypeDeclaration().isPresent()) {\n                typeDecl = superClass.get().getTypeDeclaration().get();\n            }\n        }\n        if (typeDecl == null) {\n            return unsolved(ResolvedConstructorDeclaration.class);\n        }\n\n        // Solve each of the arguments being passed into this constructor invocation.\n        List<ResolvedType> argumentTypes = new LinkedList<>();\n        List<LambdaArgumentTypePlaceholder> placeholders = new LinkedList<>();\n        solveArguments(explicitConstructorInvocationStmt, explicitConstructorInvocationStmt.getArguments(), solveLambdas, argumentTypes, placeholders);\n\n        // Determine which constructor is referred to, and return it.\n        SymbolReference<ResolvedConstructorDeclaration> res = ConstructorResolutionLogic.findMostApplicable(((ResolvedClassDeclaration) typeDecl).getConstructors(), argumentTypes, typeSolver);\n        for (LambdaArgumentTypePlaceholder placeholder : placeholders) {\n            placeholder.setMethod(res);\n        }\n\n        return res;\n    }\n\n    public SymbolReference<ResolvedTypeDeclaration> solve(ThisExpr node) {\n        // If 'this' is prefixed by a class eg. MyClass.this\n        if (node.getTypeName().isPresent()) {\n            // Get the class name\n            String className = node.getTypeName().get().asString();\n            // Attempt to resolve using a typeSolver\n            SymbolReference<ResolvedReferenceTypeDeclaration> clazz = typeSolver.tryToSolveType(className);\n            if (clazz.isSolved()) {\n                return solved(clazz.getCorrespondingDeclaration());\n            }\n            // Attempt to resolve locally in Compilation unit\n            Optional<CompilationUnit> cu = node.findAncestor(CompilationUnit.class);\n            if (cu.isPresent()) {\n                Optional<ClassOrInterfaceDeclaration> classByName = cu.get().getClassByName(className);\n                if (classByName.isPresent()) {\n                    return solved(getTypeDeclaration(classByName.get()));\n                }\n            }\n        }\n        return solved(getTypeDeclaration(findContainingTypeDeclOrObjectCreationExpr(node)));\n    }\n\n    /**\n     * Given a constructor call find out to which constructor declaration it corresponds.\n     */\n    public SymbolReference<ResolvedConstructorDeclaration> solve(ObjectCreationExpr objectCreationExpr, boolean solveLambdas) {\n        List<ResolvedType> argumentTypes = new LinkedList<>();\n        List<LambdaArgumentTypePlaceholder> placeholders = new LinkedList<>();\n\n        solveArguments(objectCreationExpr, objectCreationExpr.getArguments(), solveLambdas, argumentTypes, placeholders);\n\n        ResolvedReferenceTypeDeclaration typeDecl = null;\n        if (objectCreationExpr.getAnonymousClassBody().isPresent()) {\n            typeDecl = new JavaParserAnonymousClassDeclaration(objectCreationExpr, typeSolver);\n        } else {\n            ResolvedType classDecl = JavaParserFacade.get(typeSolver).convert(objectCreationExpr.getType(), objectCreationExpr);\n            if (classDecl.isReferenceType() && classDecl.asReferenceType().getTypeDeclaration().isPresent()) {\n                typeDecl = classDecl.asReferenceType().getTypeDeclaration().get();\n            }\n        }\n        if (typeDecl == null) {\n            return unsolved(ResolvedConstructorDeclaration.class);\n        }\n        SymbolReference<ResolvedConstructorDeclaration> res = ConstructorResolutionLogic.findMostApplicable(typeDecl.getConstructors(), argumentTypes, typeSolver);\n        for (LambdaArgumentTypePlaceholder placeholder : placeholders) {\n            placeholder.setMethod(res);\n        }\n        return res;\n    }\n\n    private void solveArguments(Node node, NodeList<Expression> args, boolean solveLambdas, List<ResolvedType> argumentTypes,\n                                List<LambdaArgumentTypePlaceholder> placeholders) {\n        int i = 0;\n        for (Expression parameterValue : args) {\n            if (parameterValue instanceof LambdaExpr || parameterValue instanceof MethodReferenceExpr) {\n                LambdaArgumentTypePlaceholder placeholder = new LambdaArgumentTypePlaceholder(i);\n                argumentTypes.add(placeholder);\n                placeholders.add(placeholder);\n            } else {\n                try {\n                    argumentTypes.add(JavaParserFacade.get(typeSolver).getType(parameterValue, solveLambdas));\n                } catch (UnsolvedSymbolException e) {\n                    throw e;\n                } catch (Exception e) {\n                    throw new RuntimeException(String.format(\"Unable to calculate the type of a parameter of a method call. Method call: %s, Parameter: %s\",\n                            node, parameterValue), e);\n                }\n            }\n            i++;\n        }\n    }\n\n    /**\n     * Given a method call find out to which method declaration it corresponds.\n     */\n    public SymbolReference<ResolvedMethodDeclaration> solve(MethodCallExpr methodCallExpr, boolean solveLambdas) {\n        List<ResolvedType> argumentTypes = new LinkedList<>();\n        List<LambdaArgumentTypePlaceholder> placeholders = new LinkedList<>();\n\n        solveArguments(methodCallExpr, methodCallExpr.getArguments(), solveLambdas, argumentTypes, placeholders);\n\n        SymbolReference<ResolvedMethodDeclaration> res = JavaParserFactory.getContext(methodCallExpr, typeSolver).solveMethod(methodCallExpr.getName().getId(), argumentTypes, false);\n        for (LambdaArgumentTypePlaceholder placeholder : placeholders) {\n            placeholder.setMethod(res);\n        }\n        return res;\n    }\n\n    /**\n     * Given a method reference find out to which method declaration it corresponds.\n     */\n    public SymbolReference<ResolvedMethodDeclaration> solve(MethodReferenceExpr methodReferenceExpr, boolean solveLambdas) {\n        // pass empty argument list to be populated\n        List<ResolvedType> argumentTypes = new LinkedList<>();\n        return JavaParserFactory.getContext(methodReferenceExpr, typeSolver).solveMethod(methodReferenceExpr.getIdentifier(), argumentTypes, false);\n    }\n\n    public SymbolReference<ResolvedAnnotationDeclaration> solve(AnnotationExpr annotationExpr) {\n        Context context = JavaParserFactory.getContext(annotationExpr, typeSolver);\n        SymbolReference<ResolvedTypeDeclaration> typeDeclarationSymbolReference = context.solveType(annotationExpr.getNameAsString());\n        if (typeDeclarationSymbolReference.isSolved()) {\n            ResolvedAnnotationDeclaration annotationDeclaration = (ResolvedAnnotationDeclaration) typeDeclarationSymbolReference.getCorrespondingDeclaration();\n            return solved(annotationDeclaration);\n        } else {\n            return unsolved(ResolvedAnnotationDeclaration.class);\n        }\n    }\n\n    public SymbolReference<ResolvedValueDeclaration> solve(FieldAccessExpr fieldAccessExpr) {\n        return ((FieldAccessContext) JavaParserFactory.getContext(fieldAccessExpr, typeSolver)).solveField(fieldAccessExpr.getName().getId());\n    }\n\n    /**\n     * Get the type associated with the node.\n     * <p>\n     * This method was originally intended to get the type of a value: any value has a type.\n     * <p>\n     * For example:\n     * <pre>\n     * int foo(int a) {\n     *     return a; // when getType is invoked on \"a\" it returns the type \"int\"\n     * }\n     * </pre>\n     * <p>\n     * Now, users started using also of names of types itself, which do not have a type.\n     * <p>\n     * For example:\n     * <pre>\n     * class A {\n     *     int foo(int a) {\n     *         return A.someStaticField; // when getType is invoked on \"A\", which represents a class, it returns\n     *             // the type \"A\" itself while it used to throw UnsolvedSymbolException\n     * }\n     * </pre>\n     * <p>\n     * To accommodate this usage and avoid confusion this method return\n     * the type itself when used on the name of type.\n     */\n    public ResolvedType getType(Node node) {\n        try {\n            return getType(node, true);\n        } catch (UnsolvedSymbolException e) {\n            if (node instanceof NameExpr) {\n                NameExpr nameExpr = (NameExpr) node;\n                SymbolReference<ResolvedTypeDeclaration> typeDeclaration = JavaParserFactory.getContext(node, typeSolver)\n                        .solveType(nameExpr.getNameAsString());\n                if (typeDeclaration.isSolved() && typeDeclaration.getCorrespondingDeclaration() instanceof ResolvedReferenceTypeDeclaration) {\n                    ResolvedReferenceTypeDeclaration resolvedReferenceTypeDeclaration = (ResolvedReferenceTypeDeclaration) typeDeclaration.getCorrespondingDeclaration();\n                    return ReferenceTypeImpl.undeterminedParameters(resolvedReferenceTypeDeclaration, typeSolver);\n                }\n            }\n            throw e;\n        }\n    }\n\n    public ResolvedType getType(Node node, boolean solveLambdas) {\n        if (solveLambdas) {\n            if (!node.containsData(TYPE_WITH_LAMBDAS_RESOLVED)) {\n                ResolvedType res = getTypeConcrete(node, solveLambdas);\n\n                node.setData(TYPE_WITH_LAMBDAS_RESOLVED, res);\n\n                boolean secondPassNecessary = false;\n                if (node instanceof MethodCallExpr) {\n                    MethodCallExpr methodCallExpr = (MethodCallExpr) node;\n                    for (Node arg : methodCallExpr.getArguments()) {\n                        if (!arg.containsData(TYPE_WITH_LAMBDAS_RESOLVED)) {\n                            getType(arg, true);\n                            secondPassNecessary = true;\n                        }\n                    }\n                }\n                if (secondPassNecessary) {\n                    node.removeData(TYPE_WITH_LAMBDAS_RESOLVED);\n                    ResolvedType type = getType(node, true);\n                    node.setData(TYPE_WITH_LAMBDAS_RESOLVED, type);\n\n                }\n                Log.trace(\"getType on %s  -> %s\", () -> node, () -> res);\n            }\n            return node.getData(TYPE_WITH_LAMBDAS_RESOLVED);\n        } else {\n            Optional<ResolvedType> res = find(TYPE_WITH_LAMBDAS_RESOLVED, node);\n            if (res.isPresent()) {\n                return res.get();\n            }\n            res = find(TYPE_WITHOUT_LAMBDAS_RESOLVED, node);\n            if (!res.isPresent()) {\n                ResolvedType resType = getTypeConcrete(node, solveLambdas);\n                node.setData(TYPE_WITHOUT_LAMBDAS_RESOLVED, resType);\n                Optional<ResolvedType> finalRes = res;\n                Log.trace(\"getType on %s (no solveLambdas) -> %s\", () -> node, () -> finalRes);\n                return resType;\n            }\n            return res.get();\n        }\n    }\n\n    private Optional<ResolvedType> find(DataKey<ResolvedType> dataKey, Node node) {\n        if (node.containsData(dataKey)) {\n            return Optional.of(node.getData(dataKey));\n        }\n        return Optional.empty();\n    }\n\n    protected MethodUsage toMethodUsage(MethodReferenceExpr methodReferenceExpr, List<ResolvedType> paramTypes) {\n        Expression scope = methodReferenceExpr.getScope();\n        ResolvedType typeOfScope = getType(methodReferenceExpr.getScope());\n        if (!typeOfScope.isReferenceType()) {\n            throw new UnsupportedOperationException(typeOfScope.getClass().getCanonicalName());\n        }\n\n        Optional<MethodUsage> result;\n        Set<MethodUsage> allMethods = typeOfScope.asReferenceType().getTypeDeclaration()\n                .orElseThrow(() -> new RuntimeException(\"TypeDeclaration unexpectedly empty.\"))\n                .getAllMethods();\n\n        if (scope instanceof TypeExpr) {\n            // static methods should match all params\n            List<MethodUsage> staticMethodUsages = allMethods.stream()\n                    .filter(it -> it.getDeclaration().isStatic())\n                    .collect(Collectors.toList());\n\n            result = MethodResolutionLogic.findMostApplicableUsage(staticMethodUsages, methodReferenceExpr.getIdentifier(), paramTypes, typeSolver);\n\n            if (!paramTypes.isEmpty()) {\n                // instance methods are called on the first param and should match all other params\n                List<MethodUsage> instanceMethodUsages = allMethods.stream()\n                        .filter(it -> !it.getDeclaration().isStatic())\n                        .collect(Collectors.toList());\n\n                List<ResolvedType> instanceMethodParamTypes = new ArrayList<>(paramTypes);\n                instanceMethodParamTypes.remove(0); // remove the first one\n\n                Optional<MethodUsage> instanceResult = MethodResolutionLogic.findMostApplicableUsage(\n                        instanceMethodUsages, methodReferenceExpr.getIdentifier(), instanceMethodParamTypes, typeSolver);\n                if (result.isPresent() && instanceResult.isPresent()) {\n                    throw new MethodAmbiguityException(\"Ambiguous method call: cannot find a most applicable method for \" + methodReferenceExpr.getIdentifier());\n                }\n\n                if (instanceResult.isPresent()) {\n                    result = instanceResult;\n                }\n            }\n        } else {\n            result = MethodResolutionLogic.findMostApplicableUsage(new ArrayList<>(allMethods), methodReferenceExpr.getIdentifier(), paramTypes, typeSolver);\n\n            if (result.isPresent() && result.get().getDeclaration().isStatic()) {\n                throw new RuntimeException(\"Invalid static method reference \" + methodReferenceExpr.getIdentifier());\n            }\n        }\n\n        if (!result.isPresent()) {\n            throw new UnsupportedOperationException();\n        }\n\n        return result.get();\n    }\n\n    protected ResolvedType getBinaryTypeConcrete(Node left, Node right, boolean solveLambdas, BinaryExpr.Operator operator) {\n        ResolvedType leftType = getTypeConcrete(left, solveLambdas);\n        ResolvedType rightType = getTypeConcrete(right, solveLambdas);\n\n        // JLS 15.18.1. String Concatenation Operator +\n        // If only one operand expression is of type String, then string conversion (\u00a75.1.11) is performed on the other\n        // operand to produce a string at run time.\n        //\n        // The result of string concatenation is a reference to a String object that is the concatenation of the two\n        // operand strings. The characters of the left-hand operand precede the characters of the right-hand operand in\n        // the newly created string.\n\n        if (operator == BinaryExpr.Operator.PLUS) {\n            boolean isLeftString = leftType.isReferenceType() && leftType.asReferenceType()\n                    .getQualifiedName().equals(JAVA_LANG_STRING);\n            boolean isRightString = rightType.isReferenceType() && rightType.asReferenceType()\n                    .getQualifiedName().equals(JAVA_LANG_STRING);\n            if (isLeftString || isRightString) {\n                return isLeftString ? leftType : rightType;\n            }\n        }\n\n        // JLS 5.6.2. Binary Numeric Promotion\n        //\n        // Widening primitive conversion (\u00a75.1.2) is applied to convert either or both operands as specified by the\n        // following rules:\n        //\n        // * If either operand is of type double, the other is converted to double.\n        // * Otherwise, if either operand is of type float, the other is converted to float.\n        // * Otherwise, if either operand is of type long, the other is converted to long.\n        // * Otherwise, both operands are converted to type int.\n\n        boolean isLeftNumeric = leftType.isPrimitive() && leftType.asPrimitive().isNumeric();\n        boolean isRightNumeric = rightType.isPrimitive() && rightType.asPrimitive().isNumeric();\n\n        if (isLeftNumeric && isRightNumeric) {\n            return leftType.asPrimitive().bnp(rightType.asPrimitive());\n        }\n\n        if (rightType.isAssignableBy(leftType)) {\n            return rightType;\n        }\n        return leftType;\n    }\n\n\n    /**\n     * Should return more like a TypeApplication: a TypeDeclaration and possible typeParametersValues or array\n     * modifiers.\n     */\n    private ResolvedType getTypeConcrete(Node node, boolean solveLambdas) {\n        if (node == null) throw new IllegalArgumentException();\n        return node.accept(typeExtractor, solveLambdas);\n    }\n\n    /**\n     * Where a node has an interface/class/enum declaration as its ancestor, return the nearest one.\n     * <p>\n     * NOTE: See {@link #findContainingTypeDeclOrObjectCreationExpr} if wanting to include anonymous inner classes.\n     * <p>\n     * For example, these all return X:\n     * {@code public interface X { ... node here ... }}\n     * {@code public class X { ... node here ... }}\n     * {@code public enum X { ... node here ... }}\n     *\n     * @param node The Node whose ancestors will be traversed,\n     * @return The first class/interface/enum declaration in the Node's ancestry.\n     */\n    protected TypeDeclaration<?> findContainingTypeDecl(Node node) {\n        Node parent = node;\n        while (true) {\n            parent = demandParentNode(parent);\n            if (parent instanceof TypeDeclaration) {\n                return (TypeDeclaration<?>) parent;\n            }\n        }\n    }\n\n    /**\n     * Where a node has an interface/class/enum declaration -- or an object creation expression (anonymous inner class)\n     * -- as its ancestor, return the nearest one.\n     * <p>\n     * NOTE: See {@link #findContainingTypeDecl} if wanting to not include anonymous inner classes.\n     * <p>\n     * For example, these all return X:\n     * <ul>\n     *     <li>{@code public interface X { ... node here ... }}</li>\n     *     <li>{@code public class X { ... node here ... }}</li>\n     *     <li>{@code public enum X { ... node here ... }}</li>\n     *     <li><pre>{@code\n     *     new ActionListener() {\n     *          ... node here ...\n     *          public void actionPerformed(ActionEvent e) {\n     *               ... or node here ...\n     *          }\n     *     }\n     *     }</pre></li>\n     * </ul>\n     * <p>\n     *\n     * @param node The Node whose ancestors will be traversed,\n     * @return The first class/interface/enum declaration -- or object creation expression (anonymous inner class) -- in\n     * the Node's ancestry.\n     */\n    protected Node findContainingTypeDeclOrObjectCreationExpr(Node node) {\n        Node parent = node;\n        boolean detachFlag = false;\n        while (true) {\n            parent = demandParentNode(parent);\n            if (parent instanceof BodyDeclaration) {\n                if (parent instanceof TypeDeclaration) {\n                    return parent;\n                } else {\n                    detachFlag = true;\n                }\n            } else if (parent instanceof ObjectCreationExpr) {\n                if (detachFlag) {\n                    return parent;\n                }\n            }\n        }\n    }\n\n    /**\n     * Where a node has an interface/class/enum declaration -- or an object creation expression in an inner class\n     * references an outer class -- as its ancestor, return the declaration corresponding to the class name specified.\n     */\n    protected Node findContainingTypeDeclOrObjectCreationExpr(Node node, String className) {\n        Node parent = node;\n        boolean detachFlag = false;\n        while (true) {\n            parent = demandParentNode(parent);\n            if (parent instanceof BodyDeclaration) {\n                if (parent instanceof TypeDeclaration && ((TypeDeclaration<?>) parent).getFullyQualifiedName().get().endsWith(className)) {\n                    return parent;\n                } else {\n                    detachFlag = true;\n                }\n            } else if (parent instanceof ObjectCreationExpr) {\n                if (detachFlag) {\n                    return parent;\n                }\n            }\n        }\n    }\n\n\n    public ResolvedType convertToUsageVariableType(VariableDeclarator var) {\n        return get(typeSolver).convertToUsage(var.getType(), var);\n    }\n\n    public ResolvedType convertToUsage(Type type, Node context) {\n        if (type.isUnknownType()) {\n            throw new IllegalArgumentException(\"Inferred lambda parameter type\");\n        }\n        return convertToUsage(type, JavaParserFactory.getContext(context, typeSolver));\n    }\n\n    public ResolvedType convertToUsage(Type type) {\n        return convertToUsage(type, type);\n    }\n\n    // This is an hack around an issue in JavaParser\n    private String qName(ClassOrInterfaceType classOrInterfaceType) {\n        String name = classOrInterfaceType.getName().getId();\n        if (classOrInterfaceType.getScope().isPresent()) {\n            return qName(classOrInterfaceType.getScope().get()) + \".\" + name;\n        }\n        return name;\n    }\n\n    protected ResolvedType convertToUsage(Type type, Context context) {\n        if (context == null) {\n            throw new NullPointerException(\"Context should not be null\");\n        }\n        if (type instanceof ClassOrInterfaceType) {\n            return convertToUsage((ClassOrInterfaceType) type, context);\n        } else if (type instanceof PrimitiveType) {\n            return ResolvedPrimitiveType.byName(((PrimitiveType) type).getType().name());\n        } else if (type instanceof WildcardType) {\n            WildcardType wildcardType = (WildcardType) type;\n            if (wildcardType.getExtendedType().isPresent() && !wildcardType.getSuperType().isPresent()) {\n                return ResolvedWildcard.extendsBound(convertToUsage(wildcardType.getExtendedType().get(), context)); // removed (ReferenceTypeImpl)\n            } else if (!wildcardType.getExtendedType().isPresent() && wildcardType.getSuperType().isPresent()) {\n                return ResolvedWildcard.superBound(convertToUsage(wildcardType.getSuperType().get(), context)); // removed (ReferenceTypeImpl)\n            } else if (!wildcardType.getExtendedType().isPresent() && !wildcardType.getSuperType().isPresent()) {\n                return ResolvedWildcard.UNBOUNDED;\n            } else {\n                throw new UnsupportedOperationException(wildcardType.toString());\n            }\n        } else if (type instanceof VoidType) {\n            return ResolvedVoidType.INSTANCE;\n        } else if (type instanceof ArrayType) {\n            ArrayType jpArrayType = (ArrayType) type;\n            return new ResolvedArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n        } else if (type instanceof UnionType) {\n            UnionType unionType = (UnionType) type;\n            return new ResolvedUnionType(unionType.getElements().stream().map(el -> convertToUsage(el, context)).collect(Collectors.toList()));\n        } else if (type instanceof VarType) {\n            Node parent = type.getParentNode().get();\n            if (!(parent instanceof VariableDeclarator)) {\n                throw new IllegalStateException(\"Trying to resolve a `var` which is not in a variable declaration.\");\n            }\n            final VariableDeclarator variableDeclarator = (VariableDeclarator) parent;\n            return variableDeclarator.getInitializer()\n                    .map(Expression::calculateResolvedType)\n                    .orElseThrow(() -> new IllegalStateException(\"Cannot resolve `var` which has no initializer.\"));\n        } else {\n            throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n        }\n    }\n\n    protected ResolvedType convertToUsage(ClassOrInterfaceType classOrInterfaceType, Context context) {\n        String name = qName(classOrInterfaceType);\n        SymbolReference<ResolvedTypeDeclaration> ref = context.solveType(name);\n        if (!ref.isSolved()) {\n            throw new UnsolvedSymbolException(name);\n        }\n        ResolvedTypeDeclaration typeDeclaration = ref.getCorrespondingDeclaration();\n        List<ResolvedType> typeParameters = Collections.emptyList();\n        if (classOrInterfaceType.getTypeArguments().isPresent()) {\n            typeParameters = classOrInterfaceType.getTypeArguments().get().stream().map((pt) -> convertToUsage(pt, context)).collect(Collectors.toList());\n        }\n        if (typeDeclaration.isTypeParameter()) {\n            if (typeDeclaration instanceof ResolvedTypeParameterDeclaration) {\n                return new ResolvedTypeVariable((ResolvedTypeParameterDeclaration) typeDeclaration);\n            } else {\n                JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration = (JavaParserTypeVariableDeclaration) typeDeclaration;\n                return new ResolvedTypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n            }\n        } else {\n            return new ReferenceTypeImpl((ResolvedReferenceTypeDeclaration) typeDeclaration, typeParameters, typeSolver);\n        }\n    }\n\n    public ResolvedType convert(Type type, Node node) {\n        return convert(type, JavaParserFactory.getContext(node, typeSolver));\n    }\n\n    public ResolvedType convert(Type type, Context context) {\n        return convertToUsage(type, context);\n    }\n\n    public MethodUsage solveMethodAsUsage(MethodCallExpr call) {\n        List<ResolvedType> params = new ArrayList<>();\n        if (call.getArguments() != null) {\n            for (Expression param : call.getArguments()) {\n                //getTypeConcrete(Node node, boolean solveLambdas)\n                try {\n                    params.add(getType(param, false));\n                } catch (Exception e) {\n                    throw new RuntimeException(String.format(\"Error calculating the type of parameter %s of method call %s\", param, call), e);\n                }\n                //params.add(getTypeConcrete(param, false));\n            }\n        }\n        Context context = JavaParserFactory.getContext(call, typeSolver);\n        Optional<MethodUsage> methodUsage = context.solveMethodAsUsage(call.getName().getId(), params);\n        if (!methodUsage.isPresent()) {\n            throw new RuntimeException(\"Method '\" + call.getName() + \"' cannot be resolved in context \"\n                    + call + \" (line: \" + call.getRange().map(r -> \"\" + r.begin.line).orElse(\"??\") + \") \" + context + \". Parameter types: \" + params);\n        }\n        return methodUsage.get();\n    }\n\n    public ResolvedReferenceTypeDeclaration getTypeDeclaration(Node node) {\n        if (node instanceof TypeDeclaration) {\n            return getTypeDeclaration((TypeDeclaration) node);\n        } else if (node instanceof ObjectCreationExpr) {\n            return new JavaParserAnonymousClassDeclaration((ObjectCreationExpr) node, typeSolver);\n        } else {\n            throw new IllegalArgumentException();\n        }\n    }\n\n    public ResolvedReferenceTypeDeclaration getTypeDeclaration(ClassOrInterfaceDeclaration classOrInterfaceDeclaration) {\n        return JavaParserFactory.toTypeDeclaration(classOrInterfaceDeclaration, typeSolver);\n    }\n\n    /**\n     * \"this\" inserted in the given point, which type would have?\n     */\n    public ResolvedType getTypeOfThisIn(Node node) {\n        // TODO consider static methods\n        if (node instanceof ClassOrInterfaceDeclaration) {\n            return new ReferenceTypeImpl(getTypeDeclaration((ClassOrInterfaceDeclaration) node), typeSolver);\n        } else if (node instanceof EnumDeclaration) {\n            JavaParserEnumDeclaration enumDeclaration = new JavaParserEnumDeclaration((EnumDeclaration) node, typeSolver);\n            return new ReferenceTypeImpl(enumDeclaration, typeSolver);\n        } else if (node instanceof ObjectCreationExpr && ((ObjectCreationExpr) node).getAnonymousClassBody().isPresent()) {\n            JavaParserAnonymousClassDeclaration anonymousDeclaration = new JavaParserAnonymousClassDeclaration((ObjectCreationExpr) node, typeSolver);\n            return new ReferenceTypeImpl(anonymousDeclaration, typeSolver);\n        }\n        return getTypeOfThisIn(demandParentNode(node));\n    }\n\n    public ResolvedReferenceTypeDeclaration getTypeDeclaration(TypeDeclaration<?> typeDeclaration) {\n        return JavaParserFactory.toTypeDeclaration(typeDeclaration, typeSolver);\n    }\n\n    public ResolvedType classToResolvedType(Class<?> clazz) {\n        if (clazz.isPrimitive()) {\n            return ResolvedPrimitiveType.byName(clazz.getName());\n        }\n\n        ResolvedReferenceTypeDeclaration declaration;\n        if (clazz.isAnnotation()) {\n            declaration = new ReflectionAnnotationDeclaration(clazz, typeSolver);\n        } else if (clazz.isEnum()) {\n            declaration = new ReflectionEnumDeclaration(clazz, typeSolver);\n        } else if (clazz.isInterface()) {\n            declaration = new ReflectionInterfaceDeclaration(clazz, typeSolver);\n        } else {\n            declaration = new ReflectionClassDeclaration(clazz, typeSolver);\n        }\n        return new ReferenceTypeImpl(declaration, typeSolver);\n    }\n\n}\n",
        "filePathAfter": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java",
        "sourceCodeAfterForWhole": "/*\n * Copyright (C) 2015-2016 Federico Tomassetti\n * Copyright (C) 2017-2020 The JavaParser Team.\n *\n * This file is part of JavaParser.\n *\n * JavaParser can be used either under the terms of\n * a) the GNU Lesser General Public License as published by\n *     the Free Software Foundation, either version 3 of the License, or\n *     (at your option) any later version.\n * b) the terms of the Apache License\n *\n * You should have received a copy of both licenses in LICENCE.LGPL and\n * LICENCE.APACHE. Please refer to those files for details.\n *\n * JavaParser is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n */\n\npackage com.github.javaparser.symbolsolver.javaparsermodel;\n\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.DataKey;\nimport com.github.javaparser.ast.Node;\nimport com.github.javaparser.ast.NodeList;\nimport com.github.javaparser.ast.body.BodyDeclaration;\nimport com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;\nimport com.github.javaparser.ast.body.EnumDeclaration;\nimport com.github.javaparser.ast.body.TypeDeclaration;\nimport com.github.javaparser.ast.body.VariableDeclarator;\nimport com.github.javaparser.ast.expr.AnnotationExpr;\nimport com.github.javaparser.ast.expr.BinaryExpr;\nimport com.github.javaparser.ast.expr.Expression;\nimport com.github.javaparser.ast.expr.FieldAccessExpr;\nimport com.github.javaparser.ast.expr.LambdaExpr;\nimport com.github.javaparser.ast.expr.MethodCallExpr;\nimport com.github.javaparser.ast.expr.MethodReferenceExpr;\nimport com.github.javaparser.ast.expr.NameExpr;\nimport com.github.javaparser.ast.expr.ObjectCreationExpr;\nimport com.github.javaparser.ast.expr.SimpleName;\nimport com.github.javaparser.ast.expr.ThisExpr;\nimport com.github.javaparser.ast.expr.TypeExpr;\nimport com.github.javaparser.ast.stmt.ExplicitConstructorInvocationStmt;\nimport com.github.javaparser.ast.type.ArrayType;\nimport com.github.javaparser.ast.type.ClassOrInterfaceType;\nimport com.github.javaparser.ast.type.PrimitiveType;\nimport com.github.javaparser.ast.type.Type;\nimport com.github.javaparser.ast.type.UnionType;\nimport com.github.javaparser.ast.type.VarType;\nimport com.github.javaparser.ast.type.VoidType;\nimport com.github.javaparser.ast.type.WildcardType;\nimport com.github.javaparser.resolution.MethodAmbiguityException;\nimport com.github.javaparser.resolution.MethodUsage;\nimport com.github.javaparser.resolution.UnsolvedSymbolException;\nimport com.github.javaparser.resolution.declarations.ResolvedAnnotationDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedClassDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedConstructorDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedMethodDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedReferenceTypeDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedTypeDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedTypeParameterDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedValueDeclaration;\nimport com.github.javaparser.resolution.types.ResolvedArrayType;\nimport com.github.javaparser.resolution.types.ResolvedPrimitiveType;\nimport com.github.javaparser.resolution.types.ResolvedReferenceType;\nimport com.github.javaparser.resolution.types.ResolvedType;\nimport com.github.javaparser.resolution.types.ResolvedTypeVariable;\nimport com.github.javaparser.resolution.types.ResolvedUnionType;\nimport com.github.javaparser.resolution.types.ResolvedVoidType;\nimport com.github.javaparser.resolution.types.ResolvedWildcard;\nimport com.github.javaparser.symbolsolver.core.resolution.Context;\nimport com.github.javaparser.symbolsolver.javaparsermodel.contexts.FieldAccessContext;\nimport com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserAnonymousClassDeclaration;\nimport com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserEnumDeclaration;\nimport com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserTypeVariableDeclaration;\nimport com.github.javaparser.symbolsolver.model.resolution.SymbolReference;\nimport com.github.javaparser.symbolsolver.model.resolution.TypeSolver;\nimport com.github.javaparser.symbolsolver.model.typesystem.ReferenceTypeImpl;\nimport com.github.javaparser.symbolsolver.reflectionmodel.ReflectionAnnotationDeclaration;\nimport com.github.javaparser.symbolsolver.reflectionmodel.ReflectionClassDeclaration;\nimport com.github.javaparser.symbolsolver.reflectionmodel.ReflectionEnumDeclaration;\nimport com.github.javaparser.symbolsolver.reflectionmodel.ReflectionInterfaceDeclaration;\nimport com.github.javaparser.symbolsolver.resolution.ConstructorResolutionLogic;\nimport com.github.javaparser.symbolsolver.resolution.MethodResolutionLogic;\nimport com.github.javaparser.symbolsolver.resolution.SymbolSolver;\nimport com.github.javaparser.utils.Log;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.Set;\nimport java.util.WeakHashMap;\nimport java.util.stream.Collectors;\n\nimport static com.github.javaparser.symbolsolver.javaparser.Navigator.demandParentNode;\nimport static com.github.javaparser.symbolsolver.model.resolution.SymbolReference.solved;\nimport static com.github.javaparser.symbolsolver.model.resolution.SymbolReference.unsolved;\n\n/**\n * Class to be used by final users to solve symbols for JavaParser ASTs.\n *\n * @author Federico Tomassetti\n */\npublic class JavaParserFacade {\n\n    private static final DataKey<ResolvedType> TYPE_WITH_LAMBDAS_RESOLVED = new DataKey<ResolvedType>() {\n    };\n    private static final DataKey<ResolvedType> TYPE_WITHOUT_LAMBDAS_RESOLVED = new DataKey<ResolvedType>() {\n    };\n\n    private static final Map<TypeSolver, JavaParserFacade> instances = new WeakHashMap<>();\n    \n    private static String JAVA_LANG_STRING = String.class.getCanonicalName();\n    \n    private final TypeSolver typeSolver;\n    private final TypeExtractor typeExtractor;\n    private final SymbolSolver symbolSolver;\n\n    private JavaParserFacade(TypeSolver typeSolver) {\n        this.typeSolver = typeSolver.getRoot();\n        this.symbolSolver = new SymbolSolver(typeSolver);\n        this.typeExtractor = new TypeExtractor(typeSolver, this);\n    }\n\n    public TypeSolver getTypeSolver() {\n        return typeSolver;\n    }\n\n    public SymbolSolver getSymbolSolver() {\n        return symbolSolver;\n    }\n\n    /**\n     * Note that the addition of the modifier {@code synchronized} is specific and directly in response to issue #2668.\n     * <br>This <strong>MUST NOT</strong> be misinterpreted as a signal that JavaParser is safe to use within a multi-threaded environment.\n     * <br>\n     * <br>Additional discussion and context from a user attempting multithreading can be found within issue #2671 .\n     * <br>\n     *\n     * @see <a href=\"https://github.com/javaparser/javaparser/issues/2668\">https://github.com/javaparser/javaparser/issues/2668</a>\n     * @see <a href=\"https://github.com/javaparser/javaparser/issues/2671\">https://github.com/javaparser/javaparser/issues/2671</a>\n     */\n    public synchronized static JavaParserFacade get(TypeSolver typeSolver) {\n        return instances.computeIfAbsent(typeSolver, JavaParserFacade::new);\n    }\n\n    /**\n     * This method is used to clear internal caches for the sake of releasing memory.\n     */\n    public static void clearInstances() {\n        instances.clear();\n    }\n\n    protected static ResolvedType solveGenericTypes(ResolvedType type, Context context) {\n        if (type.isTypeVariable()) {\n            return context.solveGenericType(type.describe()).orElse(type);\n        }\n        if (type.isWildcard()) {\n            if (type.asWildcard().isExtends() || type.asWildcard().isSuper()) {\n                ResolvedWildcard wildcardUsage = type.asWildcard();\n                ResolvedType boundResolved = solveGenericTypes(wildcardUsage.getBoundedType(), context);\n                if (wildcardUsage.isExtends()) {\n                    return ResolvedWildcard.extendsBound(boundResolved);\n                } else {\n                    return ResolvedWildcard.superBound(boundResolved);\n                }\n            }\n        }\n        return type;\n    }\n\n    public SymbolReference<? extends ResolvedValueDeclaration> solve(NameExpr nameExpr) {\n        return symbolSolver.solveSymbol(nameExpr.getName().getId(), nameExpr);\n    }\n\n    public SymbolReference<? extends ResolvedValueDeclaration> solve(SimpleName nameExpr) {\n        return symbolSolver.solveSymbol(nameExpr.getId(), nameExpr);\n    }\n\n    public SymbolReference<? extends ResolvedValueDeclaration> solve(Expression expr) {\n        return expr.toNameExpr().map(this::solve).orElseThrow(() -> new IllegalArgumentException(expr.getClass().getCanonicalName()));\n    }\n\n    public SymbolReference<ResolvedMethodDeclaration> solve(MethodCallExpr methodCallExpr) {\n        return solve(methodCallExpr, true);\n    }\n\n    public SymbolReference<ResolvedMethodDeclaration> solve(MethodReferenceExpr methodReferenceExpr) {\n        return solve(methodReferenceExpr, true);\n    }\n\n    public SymbolReference<ResolvedConstructorDeclaration> solve(ObjectCreationExpr objectCreationExpr) {\n        return solve(objectCreationExpr, true);\n    }\n\n    public SymbolReference<ResolvedConstructorDeclaration> solve(ExplicitConstructorInvocationStmt explicitConstructorInvocationStmt) {\n        return solve(explicitConstructorInvocationStmt, true);\n    }\n\n    public SymbolReference<ResolvedConstructorDeclaration> solve(ExplicitConstructorInvocationStmt explicitConstructorInvocationStmt, boolean solveLambdas) {\n        // Constructor invocation must exist within a class (not interface).\n        Optional<ClassOrInterfaceDeclaration> optAncestorClassOrInterfaceNode = explicitConstructorInvocationStmt.findAncestor(ClassOrInterfaceDeclaration.class);\n        if (!optAncestorClassOrInterfaceNode.isPresent()) {\n            return unsolved(ResolvedConstructorDeclaration.class);\n        }\n\n        ClassOrInterfaceDeclaration classOrInterfaceNode = optAncestorClassOrInterfaceNode.get();\n        ResolvedReferenceTypeDeclaration resolvedClassNode = classOrInterfaceNode.resolve();\n        if (!resolvedClassNode.isClass()) {\n            throw new IllegalStateException(\"Expected to be a class -- cannot call this() or super() within an interface.\");\n        }\n\n        ResolvedTypeDeclaration typeDecl = null;\n        if (explicitConstructorInvocationStmt.isThis()) {\n            // this()\n            typeDecl = resolvedClassNode.asReferenceType();\n        } else {\n            // super()\n            Optional<ResolvedReferenceType> superClass = resolvedClassNode.asClass().getSuperClass();\n            if (superClass.isPresent() && superClass.get().getTypeDeclaration().isPresent()) {\n                typeDecl = superClass.get().getTypeDeclaration().get();\n            }\n        }\n        if (typeDecl == null) {\n            return unsolved(ResolvedConstructorDeclaration.class);\n        }\n\n        // Solve each of the arguments being passed into this constructor invocation.\n        List<ResolvedType> argumentTypes = new LinkedList<>();\n        List<LambdaArgumentTypePlaceholder> placeholders = new LinkedList<>();\n        solveArguments(explicitConstructorInvocationStmt, explicitConstructorInvocationStmt.getArguments(), solveLambdas, argumentTypes, placeholders);\n\n        // Determine which constructor is referred to, and return it.\n        SymbolReference<ResolvedConstructorDeclaration> res = ConstructorResolutionLogic.findMostApplicable(((ResolvedClassDeclaration) typeDecl).getConstructors(), argumentTypes, typeSolver);\n        for (LambdaArgumentTypePlaceholder placeholder : placeholders) {\n            placeholder.setMethod(res);\n        }\n\n        return res;\n    }\n\n    public SymbolReference<ResolvedTypeDeclaration> solve(ThisExpr node) {\n        // If 'this' is prefixed by a class eg. MyClass.this\n        if (node.getTypeName().isPresent()) {\n            // Get the class name\n            String className = node.getTypeName().get().asString();\n            // Attempt to resolve using a typeSolver\n            SymbolReference<ResolvedReferenceTypeDeclaration> clazz = typeSolver.tryToSolveType(className);\n            if (clazz.isSolved()) {\n                return solved(clazz.getCorrespondingDeclaration());\n            }\n            // Attempt to resolve locally in Compilation unit\n            Optional<CompilationUnit> cu = node.findAncestor(CompilationUnit.class);\n            if (cu.isPresent()) {\n                Optional<ClassOrInterfaceDeclaration> classByName = cu.get().getClassByName(className);\n                if (classByName.isPresent()) {\n                    return solved(getTypeDeclaration(classByName.get()));\n                }\n            }\n        }\n        return solved(getTypeDeclaration(findContainingTypeDeclOrObjectCreationExpr(node)));\n    }\n\n    /**\n     * Given a constructor call find out to which constructor declaration it corresponds.\n     */\n    public SymbolReference<ResolvedConstructorDeclaration> solve(ObjectCreationExpr objectCreationExpr, boolean solveLambdas) {\n        List<ResolvedType> argumentTypes = new LinkedList<>();\n        List<LambdaArgumentTypePlaceholder> placeholders = new LinkedList<>();\n\n        solveArguments(objectCreationExpr, objectCreationExpr.getArguments(), solveLambdas, argumentTypes, placeholders);\n\n        ResolvedReferenceTypeDeclaration typeDecl = null;\n        if (objectCreationExpr.getAnonymousClassBody().isPresent()) {\n            typeDecl = new JavaParserAnonymousClassDeclaration(objectCreationExpr, typeSolver);\n        } else {\n            ResolvedType classDecl = JavaParserFacade.get(typeSolver).convert(objectCreationExpr.getType(), objectCreationExpr);\n            if (classDecl.isReferenceType() && classDecl.asReferenceType().getTypeDeclaration().isPresent()) {\n                typeDecl = classDecl.asReferenceType().getTypeDeclaration().get();\n            }\n        }\n        if (typeDecl == null) {\n            return unsolved(ResolvedConstructorDeclaration.class);\n        }\n        SymbolReference<ResolvedConstructorDeclaration> res = ConstructorResolutionLogic.findMostApplicable(typeDecl.getConstructors(), argumentTypes, typeSolver);\n        for (LambdaArgumentTypePlaceholder placeholder : placeholders) {\n            placeholder.setMethod(res);\n        }\n        return res;\n    }\n\n    private void solveArguments(Node node, NodeList<Expression> args, boolean solveLambdas, List<ResolvedType> argumentTypes,\n                                List<LambdaArgumentTypePlaceholder> placeholders) {\n        int i = 0;\n        for (Expression parameterValue : args) {\n            if (parameterValue instanceof LambdaExpr || parameterValue instanceof MethodReferenceExpr) {\n                LambdaArgumentTypePlaceholder placeholder = new LambdaArgumentTypePlaceholder(i);\n                argumentTypes.add(placeholder);\n                placeholders.add(placeholder);\n            } else {\n                try {\n                    argumentTypes.add(JavaParserFacade.get(typeSolver).getType(parameterValue, solveLambdas));\n                } catch (UnsolvedSymbolException e) {\n                    throw e;\n                } catch (Exception e) {\n                    throw new RuntimeException(String.format(\"Unable to calculate the type of a parameter of a method call. Method call: %s, Parameter: %s\",\n                            node, parameterValue), e);\n                }\n            }\n            i++;\n        }\n    }\n\n    /**\n     * Given a method call find out to which method declaration it corresponds.\n     */\n    public SymbolReference<ResolvedMethodDeclaration> solve(MethodCallExpr methodCallExpr, boolean solveLambdas) {\n        List<ResolvedType> argumentTypes = new LinkedList<>();\n        List<LambdaArgumentTypePlaceholder> placeholders = new LinkedList<>();\n\n        solveArguments(methodCallExpr, methodCallExpr.getArguments(), solveLambdas, argumentTypes, placeholders);\n\n        SymbolReference<ResolvedMethodDeclaration> res = JavaParserFactory.getContext(methodCallExpr, typeSolver).solveMethod(methodCallExpr.getName().getId(), argumentTypes, false);\n        for (LambdaArgumentTypePlaceholder placeholder : placeholders) {\n            placeholder.setMethod(res);\n        }\n        return res;\n    }\n\n    /**\n     * Given a method reference find out to which method declaration it corresponds.\n     */\n    public SymbolReference<ResolvedMethodDeclaration> solve(MethodReferenceExpr methodReferenceExpr, boolean solveLambdas) {\n        // pass empty argument list to be populated\n        List<ResolvedType> argumentTypes = new LinkedList<>();\n        return JavaParserFactory.getContext(methodReferenceExpr, typeSolver).solveMethod(methodReferenceExpr.getIdentifier(), argumentTypes, false);\n    }\n\n    public SymbolReference<ResolvedAnnotationDeclaration> solve(AnnotationExpr annotationExpr) {\n        Context context = JavaParserFactory.getContext(annotationExpr, typeSolver);\n        SymbolReference<ResolvedTypeDeclaration> typeDeclarationSymbolReference = context.solveType(annotationExpr.getNameAsString());\n        if (typeDeclarationSymbolReference.isSolved()) {\n            ResolvedAnnotationDeclaration annotationDeclaration = (ResolvedAnnotationDeclaration) typeDeclarationSymbolReference.getCorrespondingDeclaration();\n            return solved(annotationDeclaration);\n        } else {\n            return unsolved(ResolvedAnnotationDeclaration.class);\n        }\n    }\n\n    public SymbolReference<ResolvedValueDeclaration> solve(FieldAccessExpr fieldAccessExpr) {\n        return ((FieldAccessContext) JavaParserFactory.getContext(fieldAccessExpr, typeSolver)).solveField(fieldAccessExpr.getName().getId());\n    }\n\n    /**\n     * Get the type associated with the node.\n     * <p>\n     * This method was originally intended to get the type of a value: any value has a type.\n     * <p>\n     * For example:\n     * <pre>\n     * int foo(int a) {\n     *     return a; // when getType is invoked on \"a\" it returns the type \"int\"\n     * }\n     * </pre>\n     * <p>\n     * Now, users started using also of names of types itself, which do not have a type.\n     * <p>\n     * For example:\n     * <pre>\n     * class A {\n     *     int foo(int a) {\n     *         return A.someStaticField; // when getType is invoked on \"A\", which represents a class, it returns\n     *             // the type \"A\" itself while it used to throw UnsolvedSymbolException\n     * }\n     * </pre>\n     * <p>\n     * To accommodate this usage and avoid confusion this method return\n     * the type itself when used on the name of type.\n     */\n    public ResolvedType getType(Node node) {\n        try {\n            return getType(node, true);\n        } catch (UnsolvedSymbolException e) {\n            if (node instanceof NameExpr) {\n                NameExpr nameExpr = (NameExpr) node;\n                SymbolReference<ResolvedTypeDeclaration> typeDeclaration = JavaParserFactory.getContext(node, typeSolver)\n                        .solveType(nameExpr.getNameAsString());\n                if (typeDeclaration.isSolved() && typeDeclaration.getCorrespondingDeclaration() instanceof ResolvedReferenceTypeDeclaration) {\n                    ResolvedReferenceTypeDeclaration resolvedReferenceTypeDeclaration = (ResolvedReferenceTypeDeclaration) typeDeclaration.getCorrespondingDeclaration();\n                    return ReferenceTypeImpl.undeterminedParameters(resolvedReferenceTypeDeclaration, typeSolver);\n                }\n            }\n            throw e;\n        }\n    }\n\n    public ResolvedType getType(Node node, boolean solveLambdas) {\n        if (solveLambdas) {\n            if (!node.containsData(TYPE_WITH_LAMBDAS_RESOLVED)) {\n                ResolvedType res = getTypeConcrete(node, solveLambdas);\n\n                node.setData(TYPE_WITH_LAMBDAS_RESOLVED, res);\n\n                boolean secondPassNecessary = false;\n                if (node instanceof MethodCallExpr) {\n                    MethodCallExpr methodCallExpr = (MethodCallExpr) node;\n                    for (Node arg : methodCallExpr.getArguments()) {\n                        if (!arg.containsData(TYPE_WITH_LAMBDAS_RESOLVED)) {\n                            getType(arg, true);\n                            secondPassNecessary = true;\n                        }\n                    }\n                }\n                if (secondPassNecessary) {\n                    node.removeData(TYPE_WITH_LAMBDAS_RESOLVED);\n                    ResolvedType type = getType(node, true);\n                    node.setData(TYPE_WITH_LAMBDAS_RESOLVED, type);\n\n                }\n                Log.trace(\"getType on %s  -> %s\", () -> node, () -> res);\n            }\n            return node.getData(TYPE_WITH_LAMBDAS_RESOLVED);\n        } else {\n            Optional<ResolvedType> res = find(TYPE_WITH_LAMBDAS_RESOLVED, node);\n            if (res.isPresent()) {\n                return res.get();\n            }\n            res = find(TYPE_WITHOUT_LAMBDAS_RESOLVED, node);\n            if (!res.isPresent()) {\n                ResolvedType resType = getTypeConcrete(node, solveLambdas);\n                node.setData(TYPE_WITHOUT_LAMBDAS_RESOLVED, resType);\n                Optional<ResolvedType> finalRes = res;\n                Log.trace(\"getType on %s (no solveLambdas) -> %s\", () -> node, () -> finalRes);\n                return resType;\n            }\n            return res.get();\n        }\n    }\n\n    private Optional<ResolvedType> find(DataKey<ResolvedType> dataKey, Node node) {\n        if (node.containsData(dataKey)) {\n            return Optional.of(node.getData(dataKey));\n        }\n        return Optional.empty();\n    }\n\n    protected MethodUsage toMethodUsage(MethodReferenceExpr methodReferenceExpr, List<ResolvedType> paramTypes) {\n        Expression scope = methodReferenceExpr.getScope();\n        ResolvedType typeOfScope = getType(methodReferenceExpr.getScope());\n        if (!typeOfScope.isReferenceType()) {\n            throw new UnsupportedOperationException(typeOfScope.getClass().getCanonicalName());\n        }\n\n        Optional<MethodUsage> result;\n        Set<MethodUsage> allMethods = typeOfScope.asReferenceType().getTypeDeclaration()\n                .orElseThrow(() -> new RuntimeException(\"TypeDeclaration unexpectedly empty.\"))\n                .getAllMethods();\n\n        if (scope instanceof TypeExpr) {\n            // static methods should match all params\n            List<MethodUsage> staticMethodUsages = allMethods.stream()\n                    .filter(it -> it.getDeclaration().isStatic())\n                    .collect(Collectors.toList());\n\n            result = MethodResolutionLogic.findMostApplicableUsage(staticMethodUsages, methodReferenceExpr.getIdentifier(), paramTypes, typeSolver);\n\n            if (!paramTypes.isEmpty()) {\n                // instance methods are called on the first param and should match all other params\n                List<MethodUsage> instanceMethodUsages = allMethods.stream()\n                        .filter(it -> !it.getDeclaration().isStatic())\n                        .collect(Collectors.toList());\n\n                List<ResolvedType> instanceMethodParamTypes = new ArrayList<>(paramTypes);\n                instanceMethodParamTypes.remove(0); // remove the first one\n\n                Optional<MethodUsage> instanceResult = MethodResolutionLogic.findMostApplicableUsage(\n                        instanceMethodUsages, methodReferenceExpr.getIdentifier(), instanceMethodParamTypes, typeSolver);\n                if (result.isPresent() && instanceResult.isPresent()) {\n                    throw new MethodAmbiguityException(\"Ambiguous method call: cannot find a most applicable method for \" + methodReferenceExpr.getIdentifier());\n                }\n\n                if (instanceResult.isPresent()) {\n                    result = instanceResult;\n                }\n            }\n        } else {\n            result = MethodResolutionLogic.findMostApplicableUsage(new ArrayList<>(allMethods), methodReferenceExpr.getIdentifier(), paramTypes, typeSolver);\n\n            if (result.isPresent() && result.get().getDeclaration().isStatic()) {\n                throw new RuntimeException(\"Invalid static method reference \" + methodReferenceExpr.getIdentifier());\n            }\n        }\n\n        if (!result.isPresent()) {\n            throw new UnsupportedOperationException();\n        }\n\n        return result.get();\n    }\n\n    protected ResolvedType getBinaryTypeConcrete(Node left, Node right, boolean solveLambdas, BinaryExpr.Operator operator) {\n        ResolvedType leftType = getTypeConcrete(left, solveLambdas);\n        ResolvedType rightType = getTypeConcrete(right, solveLambdas);\n\n        // JLS 15.18.1. String Concatenation Operator +\n        // If only one operand expression is of type String, then string conversion (\u00a75.1.11) is performed on the other\n        // operand to produce a string at run time.\n        //\n        // The result of string concatenation is a reference to a String object that is the concatenation of the two\n        // operand strings. The characters of the left-hand operand precede the characters of the right-hand operand in\n        // the newly created string.\n\n        if (operator == BinaryExpr.Operator.PLUS) {\n            boolean isLeftString = leftType.isReferenceType() && leftType.asReferenceType()\n                    .getQualifiedName().equals(JAVA_LANG_STRING);\n            boolean isRightString = rightType.isReferenceType() && rightType.asReferenceType()\n                    .getQualifiedName().equals(JAVA_LANG_STRING);\n            if (isLeftString || isRightString) {\n                return isLeftString ? leftType : rightType;\n            }\n        }\n\n        // JLS 5.6.2. Binary Numeric Promotion\n        //\n        // Widening primitive conversion (\u00a75.1.2) is applied to convert either or both operands as specified by the\n        // following rules:\n        //\n        // * If either operand is of type double, the other is converted to double.\n        // * Otherwise, if either operand is of type float, the other is converted to float.\n        // * Otherwise, if either operand is of type long, the other is converted to long.\n        // * Otherwise, both operands are converted to type int.\n\n        boolean isLeftNumeric = leftType.isPrimitive() && leftType.asPrimitive().isNumeric();\n        boolean isRightNumeric = rightType.isPrimitive() && rightType.asPrimitive().isNumeric();\n\n        if (isLeftNumeric && isRightNumeric) {\n            return leftType.asPrimitive().bnp(rightType.asPrimitive());\n        }\n\n        if (rightType.isAssignableBy(leftType)) {\n            return rightType;\n        }\n        return leftType;\n    }\n\n\n    /**\n     * Should return more like a TypeApplication: a TypeDeclaration and possible typeParametersValues or array\n     * modifiers.\n     */\n    private ResolvedType getTypeConcrete(Node node, boolean solveLambdas) {\n        if (node == null) throw new IllegalArgumentException();\n        return node.accept(typeExtractor, solveLambdas);\n    }\n\n    /**\n     * Where a node has an interface/class/enum declaration as its ancestor, return the nearest one.\n     * <p>\n     * NOTE: See {@link #findContainingTypeDeclOrObjectCreationExpr} if wanting to include anonymous inner classes.\n     * <p>\n     * For example, these all return X:\n     * {@code public interface X { ... node here ... }}\n     * {@code public class X { ... node here ... }}\n     * {@code public enum X { ... node here ... }}\n     *\n     * @param node The Node whose ancestors will be traversed,\n     * @return The first class/interface/enum declaration in the Node's ancestry.\n     */\n    protected TypeDeclaration<?> findContainingTypeDecl(Node node) {\n        Node parent = node;\n        while (true) {\n            parent = demandParentNode(parent);\n            if (parent instanceof TypeDeclaration) {\n                return (TypeDeclaration<?>) parent;\n            }\n        }\n    }\n\n    /**\n     * Where a node has an interface/class/enum declaration -- or an object creation expression (anonymous inner class)\n     * -- as its ancestor, return the nearest one.\n     * <p>\n     * NOTE: See {@link #findContainingTypeDecl} if wanting to not include anonymous inner classes.\n     * <p>\n     * For example, these all return X:\n     * <ul>\n     *     <li>{@code public interface X { ... node here ... }}</li>\n     *     <li>{@code public class X { ... node here ... }}</li>\n     *     <li>{@code public enum X { ... node here ... }}</li>\n     *     <li><pre>{@code\n     *     new ActionListener() {\n     *          ... node here ...\n     *          public void actionPerformed(ActionEvent e) {\n     *               ... or node here ...\n     *          }\n     *     }\n     *     }</pre></li>\n     * </ul>\n     * <p>\n     *\n     * @param node The Node whose ancestors will be traversed,\n     * @return The first class/interface/enum declaration -- or object creation expression (anonymous inner class) -- in\n     * the Node's ancestry.\n     */\n    protected Node findContainingTypeDeclOrObjectCreationExpr(Node node) {\n        Node parent = node;\n        boolean detachFlag = false;\n        while (true) {\n            parent = demandParentNode(parent);\n            if (parent instanceof BodyDeclaration) {\n                if (parent instanceof TypeDeclaration) {\n                    return parent;\n                } else {\n                    detachFlag = true;\n                }\n            } else if (parent instanceof ObjectCreationExpr) {\n                if (detachFlag) {\n                    return parent;\n                }\n            }\n        }\n    }\n\n    /**\n     * Where a node has an interface/class/enum declaration -- or an object creation expression in an inner class\n     * references an outer class -- as its ancestor, return the declaration corresponding to the class name specified.\n     */\n    protected Node findContainingTypeDeclOrObjectCreationExpr(Node node, String className) {\n        Node parent = node;\n        boolean detachFlag = false;\n        while (true) {\n            parent = demandParentNode(parent);\n            if (parent instanceof BodyDeclaration) {\n                if (parent instanceof TypeDeclaration && ((TypeDeclaration<?>) parent).getFullyQualifiedName().get().endsWith(className)) {\n                    return parent;\n                } else {\n                    detachFlag = true;\n                }\n            } else if (parent instanceof ObjectCreationExpr) {\n                if (detachFlag) {\n                    return parent;\n                }\n            }\n        }\n    }\n\n\n    public ResolvedType convertToUsageVariableType(VariableDeclarator var) {\n        return get(typeSolver).convertToUsage(var.getType(), var);\n    }\n\n    public ResolvedType convertToUsage(Type type, Node context) {\n        if (type.isUnknownType()) {\n            throw new IllegalArgumentException(\"Inferred lambda parameter type\");\n        }\n        return convertToUsage(type, JavaParserFactory.getContext(context, typeSolver));\n    }\n\n    public ResolvedType convertToUsage(Type type) {\n        return convertToUsage(type, type);\n    }\n\n    // This is an hack around an issue in JavaParser\n    private String qName(ClassOrInterfaceType classOrInterfaceType) {\n        String name = classOrInterfaceType.getName().getId();\n        if (classOrInterfaceType.getScope().isPresent()) {\n            return qName(classOrInterfaceType.getScope().get()) + \".\" + name;\n        }\n        return name;\n    }\n\n    protected ResolvedType convertToUsage(Type type, Context context) {\n        if (context == null) {\n            throw new NullPointerException(\"Context should not be null\");\n        }\n        if (type instanceof ClassOrInterfaceType) {\n            return convertToUsage((ClassOrInterfaceType) type, context);\n        } else if (type instanceof PrimitiveType) {\n            return ResolvedPrimitiveType.byName(((PrimitiveType) type).getType().name());\n        } else if (type instanceof WildcardType) {\n            return convertToUsage((WildcardType) type, context);\n        } else if (type instanceof VoidType) {\n            return ResolvedVoidType.INSTANCE;\n        } else if (type instanceof ArrayType) {\n            ArrayType jpArrayType = (ArrayType) type;\n            return new ResolvedArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n        } else if (type instanceof UnionType) {\n            UnionType unionType = (UnionType) type;\n            return new ResolvedUnionType(unionType.getElements().stream().map(el -> convertToUsage(el, context)).collect(Collectors.toList()));\n        } else if (type instanceof VarType) {\n            Node parent = type.getParentNode().get();\n            if (!(parent instanceof VariableDeclarator)) {\n                throw new IllegalStateException(\"Trying to resolve a `var` which is not in a variable declaration.\");\n            }\n            final VariableDeclarator variableDeclarator = (VariableDeclarator) parent;\n            return variableDeclarator.getInitializer()\n                    .map(Expression::calculateResolvedType)\n                    .orElseThrow(() -> new IllegalStateException(\"Cannot resolve `var` which has no initializer.\"));\n        } else {\n            throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n        }\n    }\n\n    protected ResolvedType convertToUsage(ClassOrInterfaceType classOrInterfaceType, Context context) {\n        String name = qName(classOrInterfaceType);\n        SymbolReference<ResolvedTypeDeclaration> ref = context.solveType(name);\n        if (!ref.isSolved()) {\n            throw new UnsolvedSymbolException(name);\n        }\n        ResolvedTypeDeclaration typeDeclaration = ref.getCorrespondingDeclaration();\n        List<ResolvedType> typeParameters = Collections.emptyList();\n        if (classOrInterfaceType.getTypeArguments().isPresent()) {\n            typeParameters = classOrInterfaceType.getTypeArguments().get().stream().map((pt) -> convertToUsage(pt, context)).collect(Collectors.toList());\n        }\n        if (typeDeclaration.isTypeParameter()) {\n            if (typeDeclaration instanceof ResolvedTypeParameterDeclaration) {\n                return new ResolvedTypeVariable((ResolvedTypeParameterDeclaration) typeDeclaration);\n            } else {\n                JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration = (JavaParserTypeVariableDeclaration) typeDeclaration;\n                return new ResolvedTypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n            }\n        } else {\n            return new ReferenceTypeImpl((ResolvedReferenceTypeDeclaration) typeDeclaration, typeParameters, typeSolver);\n        }\n    }\n\n    protected ResolvedType convertToUsage(WildcardType wildcardType, Context context) {\n        if (wildcardType.getExtendedType().isPresent() && !wildcardType.getSuperType().isPresent()) {\n            return ResolvedWildcard.extendsBound(convertToUsage(wildcardType.getExtendedType().get(), context)); // removed (ReferenceTypeImpl)\n        } else if (!wildcardType.getExtendedType().isPresent() && wildcardType.getSuperType().isPresent()) {\n            return ResolvedWildcard.superBound(convertToUsage(wildcardType.getSuperType().get(), context)); // removed (ReferenceTypeImpl)\n        } else if (!wildcardType.getExtendedType().isPresent() && !wildcardType.getSuperType().isPresent()) {\n            return ResolvedWildcard.UNBOUNDED;\n        } else {\n            throw new UnsupportedOperationException(wildcardType.toString());\n        }\n    }\n\n    public ResolvedType convert(Type type, Node node) {\n        return convert(type, JavaParserFactory.getContext(node, typeSolver));\n    }\n\n    public ResolvedType convert(Type type, Context context) {\n        return convertToUsage(type, context);\n    }\n\n    public MethodUsage solveMethodAsUsage(MethodCallExpr call) {\n        List<ResolvedType> params = new ArrayList<>();\n        if (call.getArguments() != null) {\n            for (Expression param : call.getArguments()) {\n                //getTypeConcrete(Node node, boolean solveLambdas)\n                try {\n                    params.add(getType(param, false));\n                } catch (Exception e) {\n                    throw new RuntimeException(String.format(\"Error calculating the type of parameter %s of method call %s\", param, call), e);\n                }\n                //params.add(getTypeConcrete(param, false));\n            }\n        }\n        Context context = JavaParserFactory.getContext(call, typeSolver);\n        Optional<MethodUsage> methodUsage = context.solveMethodAsUsage(call.getName().getId(), params);\n        if (!methodUsage.isPresent()) {\n            throw new RuntimeException(\"Method '\" + call.getName() + \"' cannot be resolved in context \"\n                    + call + \" (line: \" + call.getRange().map(r -> \"\" + r.begin.line).orElse(\"??\") + \") \" + context + \". Parameter types: \" + params);\n        }\n        return methodUsage.get();\n    }\n\n    public ResolvedReferenceTypeDeclaration getTypeDeclaration(Node node) {\n        if (node instanceof TypeDeclaration) {\n            return getTypeDeclaration((TypeDeclaration) node);\n        } else if (node instanceof ObjectCreationExpr) {\n            return new JavaParserAnonymousClassDeclaration((ObjectCreationExpr) node, typeSolver);\n        } else {\n            throw new IllegalArgumentException();\n        }\n    }\n\n    public ResolvedReferenceTypeDeclaration getTypeDeclaration(ClassOrInterfaceDeclaration classOrInterfaceDeclaration) {\n        return JavaParserFactory.toTypeDeclaration(classOrInterfaceDeclaration, typeSolver);\n    }\n\n    /**\n     * \"this\" inserted in the given point, which type would have?\n     */\n    public ResolvedType getTypeOfThisIn(Node node) {\n        // TODO consider static methods\n        if (node instanceof ClassOrInterfaceDeclaration) {\n            return new ReferenceTypeImpl(getTypeDeclaration((ClassOrInterfaceDeclaration) node), typeSolver);\n        } else if (node instanceof EnumDeclaration) {\n            JavaParserEnumDeclaration enumDeclaration = new JavaParserEnumDeclaration((EnumDeclaration) node, typeSolver);\n            return new ReferenceTypeImpl(enumDeclaration, typeSolver);\n        } else if (node instanceof ObjectCreationExpr && ((ObjectCreationExpr) node).getAnonymousClassBody().isPresent()) {\n            JavaParserAnonymousClassDeclaration anonymousDeclaration = new JavaParserAnonymousClassDeclaration((ObjectCreationExpr) node, typeSolver);\n            return new ReferenceTypeImpl(anonymousDeclaration, typeSolver);\n        }\n        return getTypeOfThisIn(demandParentNode(node));\n    }\n\n    public ResolvedReferenceTypeDeclaration getTypeDeclaration(TypeDeclaration<?> typeDeclaration) {\n        return JavaParserFactory.toTypeDeclaration(typeDeclaration, typeSolver);\n    }\n\n    public ResolvedType classToResolvedType(Class<?> clazz) {\n        if (clazz.isPrimitive()) {\n            return ResolvedPrimitiveType.byName(clazz.getName());\n        }\n\n        ResolvedReferenceTypeDeclaration declaration;\n        if (clazz.isAnnotation()) {\n            declaration = new ReflectionAnnotationDeclaration(clazz, typeSolver);\n        } else if (clazz.isEnum()) {\n            declaration = new ReflectionEnumDeclaration(clazz, typeSolver);\n        } else if (clazz.isInterface()) {\n            declaration = new ReflectionInterfaceDeclaration(clazz, typeSolver);\n        } else {\n            declaration = new ReflectionClassDeclaration(clazz, typeSolver);\n        }\n        return new ReferenceTypeImpl(declaration, typeSolver);\n    }\n\n}\n",
        "diffSourceCodeSet": [
            "protected ResolvedType convertToUsage(WildcardType wildcardType, Context context) {\n        if (wildcardType.getExtendedType().isPresent() && !wildcardType.getSuperType().isPresent()) {\n            return ResolvedWildcard.extendsBound(convertToUsage(wildcardType.getExtendedType().get(), context)); // removed (ReferenceTypeImpl)\n        } else if (!wildcardType.getExtendedType().isPresent() && wildcardType.getSuperType().isPresent()) {\n            return ResolvedWildcard.superBound(convertToUsage(wildcardType.getSuperType().get(), context)); // removed (ReferenceTypeImpl)\n        } else if (!wildcardType.getExtendedType().isPresent() && !wildcardType.getSuperType().isPresent()) {\n            return ResolvedWildcard.UNBOUNDED;\n        } else {\n            throw new UnsupportedOperationException(wildcardType.toString());\n        }\n    }"
        ],
        "invokedMethodSet": [
            "methodSignature: com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade#getType\n methodBody: public ResolvedType getType(Node node, boolean solveLambdas) {\nif(solveLambdas){if(!node.containsData(TYPE_WITH_LAMBDAS_RESOLVED)){ResolvedType res=getTypeConcrete(node,solveLambdas);\nnode.setData(TYPE_WITH_LAMBDAS_RESOLVED,res);\nboolean secondPassNecessary=false;\nif(node instanceof MethodCallExpr){MethodCallExpr methodCallExpr=(MethodCallExpr)node;\nfor(Node arg: methodCallExpr.getArguments()){if(!arg.containsData(TYPE_WITH_LAMBDAS_RESOLVED)){getType(arg,true);\nsecondPassNecessary=true;\n}}}if(secondPassNecessary){node.removeData(TYPE_WITH_LAMBDAS_RESOLVED);\nResolvedType type=getType(node,true);\nnode.setData(TYPE_WITH_LAMBDAS_RESOLVED,type);\n}Log.trace(\"getType on %s  -> %s\",() -> node,() -> res);\n}return node.getData(TYPE_WITH_LAMBDAS_RESOLVED);\n}{Optional<ResolvedType> res=find(TYPE_WITH_LAMBDAS_RESOLVED,node);\nif(res.isPresent()){return res.get();\n}res=find(TYPE_WITHOUT_LAMBDAS_RESOLVED,node);\nif(!res.isPresent()){ResolvedType resType=getTypeConcrete(node,solveLambdas);\nnode.setData(TYPE_WITHOUT_LAMBDAS_RESOLVED,resType);\nOptional<ResolvedType> finalRes=res;\nLog.trace(\"getType on %s (no solveLambdas) -> %s\",() -> node,() -> finalRes);\nreturn resType;\n}return res.get();\n}}",
            "methodSignature: com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade#get\n methodBody: public synchronized static JavaParserFacade get(TypeSolver typeSolver) {\nreturn instances.computeIfAbsent(typeSolver,JavaParserFacade::new);\n}",
            "methodSignature: com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade#convertToUsage\n methodBody: protected ResolvedType convertToUsage(ClassOrInterfaceType classOrInterfaceType, Context context) {\nString name=qName(classOrInterfaceType);\nSymbolReference<ResolvedTypeDeclaration> ref=context.solveType(name);\nif(!ref.isSolved()){throw new UnsolvedSymbolException(name);\n}ResolvedTypeDeclaration typeDeclaration=ref.getCorrespondingDeclaration();\nList<ResolvedType> typeParameters=Collections.emptyList();\nif(classOrInterfaceType.getTypeArguments().isPresent()){typeParameters=classOrInterfaceType.getTypeArguments().get().stream().map((pt) -> convertToUsage(pt,context)).collect(Collectors.toList());\n}if(typeDeclaration.isTypeParameter()){if(typeDeclaration instanceof ResolvedTypeParameterDeclaration){return new ResolvedTypeVariable((ResolvedTypeParameterDeclaration)typeDeclaration);\n}{JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration=(JavaParserTypeVariableDeclaration)typeDeclaration;\nreturn new ResolvedTypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n}}{return new ReferenceTypeImpl((ResolvedReferenceTypeDeclaration)typeDeclaration,typeParameters,typeSolver);\n}}"
        ],
        "sourceCodeAfterRefactoring": "protected ResolvedType convertToUsage(Type type, Context context) {\n        if (context == null) {\n            throw new NullPointerException(\"Context should not be null\");\n        }\n        if (type instanceof ClassOrInterfaceType) {\n            return convertToUsage((ClassOrInterfaceType) type, context);\n        } else if (type instanceof PrimitiveType) {\n            return ResolvedPrimitiveType.byName(((PrimitiveType) type).getType().name());\n        } else if (type instanceof WildcardType) {\n            return convertToUsage((WildcardType) type, context);\n        } else if (type instanceof VoidType) {\n            return ResolvedVoidType.INSTANCE;\n        } else if (type instanceof ArrayType) {\n            ArrayType jpArrayType = (ArrayType) type;\n            return new ResolvedArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n        } else if (type instanceof UnionType) {\n            UnionType unionType = (UnionType) type;\n            return new ResolvedUnionType(unionType.getElements().stream().map(el -> convertToUsage(el, context)).collect(Collectors.toList()));\n        } else if (type instanceof VarType) {\n            Node parent = type.getParentNode().get();\n            if (!(parent instanceof VariableDeclarator)) {\n                throw new IllegalStateException(\"Trying to resolve a `var` which is not in a variable declaration.\");\n            }\n            final VariableDeclarator variableDeclarator = (VariableDeclarator) parent;\n            return variableDeclarator.getInitializer()\n                    .map(Expression::calculateResolvedType)\n                    .orElseThrow(() -> new IllegalStateException(\"Cannot resolve `var` which has no initializer.\"));\n        } else {\n            throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n        }\n    }\nprotected ResolvedType convertToUsage(WildcardType wildcardType, Context context) {\n        if (wildcardType.getExtendedType().isPresent() && !wildcardType.getSuperType().isPresent()) {\n            return ResolvedWildcard.extendsBound(convertToUsage(wildcardType.getExtendedType().get(), context)); // removed (ReferenceTypeImpl)\n        } else if (!wildcardType.getExtendedType().isPresent() && wildcardType.getSuperType().isPresent()) {\n            return ResolvedWildcard.superBound(convertToUsage(wildcardType.getSuperType().get(), context)); // removed (ReferenceTypeImpl)\n        } else if (!wildcardType.getExtendedType().isPresent() && !wildcardType.getSuperType().isPresent()) {\n            return ResolvedWildcard.UNBOUNDED;\n        } else {\n            throw new UnsupportedOperationException(wildcardType.toString());\n        }\n    }",
        "diffSourceCode": "   677:     protected ResolvedType convertToUsage(Type type, Context context) {\n   678:         if (context == null) {\n   679:             throw new NullPointerException(\"Context should not be null\");\n   680:         }\n   681:         if (type instanceof ClassOrInterfaceType) {\n   682:             return convertToUsage((ClassOrInterfaceType) type, context);\n   683:         } else if (type instanceof PrimitiveType) {\n   684:             return ResolvedPrimitiveType.byName(((PrimitiveType) type).getType().name());\n   685:         } else if (type instanceof WildcardType) {\n-  686:             WildcardType wildcardType = (WildcardType) type;\n-  687:             if (wildcardType.getExtendedType().isPresent() && !wildcardType.getSuperType().isPresent()) {\n-  688:                 return ResolvedWildcard.extendsBound(convertToUsage(wildcardType.getExtendedType().get(), context)); // removed (ReferenceTypeImpl)\n-  689:             } else if (!wildcardType.getExtendedType().isPresent() && wildcardType.getSuperType().isPresent()) {\n-  690:                 return ResolvedWildcard.superBound(convertToUsage(wildcardType.getSuperType().get(), context)); // removed (ReferenceTypeImpl)\n-  691:             } else if (!wildcardType.getExtendedType().isPresent() && !wildcardType.getSuperType().isPresent()) {\n-  692:                 return ResolvedWildcard.UNBOUNDED;\n-  693:             } else {\n-  694:                 throw new UnsupportedOperationException(wildcardType.toString());\n-  695:             }\n-  696:         } else if (type instanceof VoidType) {\n-  697:             return ResolvedVoidType.INSTANCE;\n-  698:         } else if (type instanceof ArrayType) {\n-  699:             ArrayType jpArrayType = (ArrayType) type;\n-  700:             return new ResolvedArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n-  701:         } else if (type instanceof UnionType) {\n-  702:             UnionType unionType = (UnionType) type;\n-  703:             return new ResolvedUnionType(unionType.getElements().stream().map(el -> convertToUsage(el, context)).collect(Collectors.toList()));\n-  704:         } else if (type instanceof VarType) {\n-  705:             Node parent = type.getParentNode().get();\n-  706:             if (!(parent instanceof VariableDeclarator)) {\n-  707:                 throw new IllegalStateException(\"Trying to resolve a `var` which is not in a variable declaration.\");\n-  708:             }\n-  709:             final VariableDeclarator variableDeclarator = (VariableDeclarator) parent;\n-  710:             return variableDeclarator.getInitializer()\n-  711:                     .map(Expression::calculateResolvedType)\n-  712:                     .orElseThrow(() -> new IllegalStateException(\"Cannot resolve `var` which has no initializer.\"));\n-  713:         } else {\n-  714:             throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n-  715:         }\n-  716:     }\n-  732:             } else {\n-  733:                 JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration = (JavaParserTypeVariableDeclaration) typeDeclaration;\n-  734:                 return new ResolvedTypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n-  735:             }\n-  736:         } else {\n-  737:             return new ReferenceTypeImpl((ResolvedReferenceTypeDeclaration) typeDeclaration, typeParameters, typeSolver);\n-  738:         }\n-  739:     }\n-  740: \n-  741:     public ResolvedType convert(Type type, Node node) {\n-  742:         return convert(type, JavaParserFactory.getContext(node, typeSolver));\n+  686:             return convertToUsage((WildcardType) type, context);\n+  687:         } else if (type instanceof VoidType) {\n+  688:             return ResolvedVoidType.INSTANCE;\n+  689:         } else if (type instanceof ArrayType) {\n+  690:             ArrayType jpArrayType = (ArrayType) type;\n+  691:             return new ResolvedArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n+  692:         } else if (type instanceof UnionType) {\n+  693:             UnionType unionType = (UnionType) type;\n+  694:             return new ResolvedUnionType(unionType.getElements().stream().map(el -> convertToUsage(el, context)).collect(Collectors.toList()));\n+  695:         } else if (type instanceof VarType) {\n+  696:             Node parent = type.getParentNode().get();\n+  697:             if (!(parent instanceof VariableDeclarator)) {\n+  698:                 throw new IllegalStateException(\"Trying to resolve a `var` which is not in a variable declaration.\");\n+  699:             }\n+  700:             final VariableDeclarator variableDeclarator = (VariableDeclarator) parent;\n+  701:             return variableDeclarator.getInitializer()\n+  702:                     .map(Expression::calculateResolvedType)\n+  703:                     .orElseThrow(() -> new IllegalStateException(\"Cannot resolve `var` which has no initializer.\"));\n+  704:         } else {\n+  705:             throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n+  706:         }\n+  707:     }\n+  708: \n+  709:     protected ResolvedType convertToUsage(ClassOrInterfaceType classOrInterfaceType, Context context) {\n+  710:         String name = qName(classOrInterfaceType);\n+  711:         SymbolReference<ResolvedTypeDeclaration> ref = context.solveType(name);\n+  712:         if (!ref.isSolved()) {\n+  713:             throw new UnsolvedSymbolException(name);\n+  714:         }\n+  715:         ResolvedTypeDeclaration typeDeclaration = ref.getCorrespondingDeclaration();\n+  716:         List<ResolvedType> typeParameters = Collections.emptyList();\n+  732:     protected ResolvedType convertToUsage(WildcardType wildcardType, Context context) {\n+  733:         if (wildcardType.getExtendedType().isPresent() && !wildcardType.getSuperType().isPresent()) {\n+  734:             return ResolvedWildcard.extendsBound(convertToUsage(wildcardType.getExtendedType().get(), context)); // removed (ReferenceTypeImpl)\n+  735:         } else if (!wildcardType.getExtendedType().isPresent() && wildcardType.getSuperType().isPresent()) {\n+  736:             return ResolvedWildcard.superBound(convertToUsage(wildcardType.getSuperType().get(), context)); // removed (ReferenceTypeImpl)\n+  737:         } else if (!wildcardType.getExtendedType().isPresent() && !wildcardType.getSuperType().isPresent()) {\n+  738:             return ResolvedWildcard.UNBOUNDED;\n+  739:         } else {\n+  740:             throw new UnsupportedOperationException(wildcardType.toString());\n+  741:         }\n+  742:     }\n",
        "uniqueId": "02410715bad58480d6ce66f64db8c11a4fa607b4_677_716_732_742_677_707",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 9,
                "covered": 60
            },
            "BRANCH": {
                "missed": 1,
                "covered": 7
            },
            "LINE": {
                "missed": 2,
                "covered": 12
            },
            "COMPLEXITY": {
                "missed": 1,
                "covered": 4
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 17
    },
    {
        "type": "Inline Method",
        "description": "Inline Method\tprivate createDefaultVisitor(configuration PrinterConfiguration) : Function<PrinterConfiguration,VoidVisitor<Void>> inlined to private createDefaultVisitor() : Function<PrinterConfiguration,VoidVisitor<Void>> in class com.github.javaparser.printer.DefaultPrettyPrinter",
        "diffLocations": [
            {
                "filePath": "javaparser-core/src/main/java/com/github/javaparser/printer/DefaultPrettyPrinter.java",
                "startLine": 43,
                "endLine": 46,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "javaparser-core/src/main/java/com/github/javaparser/printer/DefaultPrettyPrinter.java",
                "startLine": 43,
                "endLine": 45,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "javaparser-core/src/main/java/com/github/javaparser/printer/DefaultPrettyPrinter.java",
                "startLine": 48,
                "endLine": 50,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "private static Function<PrinterConfiguration, VoidVisitor<Void>> createDefaultVisitor(PrinterConfiguration configuration) {\n        return (config) -> new DefaultPrettyPrinterVisitor(config, new SourcePrinter(config));\n    }",
        "filePathBefore": "javaparser-core/src/main/java/com/github/javaparser/printer/DefaultPrettyPrinter.java",
        "isPureRefactoring": true,
        "commitId": "97240408d5c48e602a5a277a0af8e98137d32800",
        "packageNameBefore": "com.github.javaparser.printer",
        "classNameBefore": "com.github.javaparser.printer.DefaultPrettyPrinter",
        "methodNameBefore": "com.github.javaparser.printer.DefaultPrettyPrinter#createDefaultVisitor",
        "classSignatureBefore": "public class DefaultPrettyPrinter implements Printer ",
        "methodNameBeforeSet": [
            "com.github.javaparser.printer.DefaultPrettyPrinter#createDefaultVisitor"
        ],
        "classNameBeforeSet": [
            "com.github.javaparser.printer.DefaultPrettyPrinter"
        ],
        "classSignatureBeforeSet": [
            "public class DefaultPrettyPrinter implements Printer "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Copyright (C) 2007-2010 J\u00falio Vilmar Gesser.\n * Copyright (C) 2011, 2013-2021 The JavaParser Team.\n *\n * This file is part of JavaParser.\n *\n * JavaParser can be used either under the terms of\n * a) the GNU Lesser General Public License as published by\n *     the Free Software Foundation, either version 3 of the License, or\n *     (at your option) any later version.\n * b) the terms of the Apache License\n *\n * You should have received a copy of both licenses in LICENCE.LGPL and\n * LICENCE.APACHE. Please refer to those files for details.\n *\n * JavaParser is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n */\n\npackage com.github.javaparser.printer;\n\nimport java.util.function.Function;\n\nimport com.github.javaparser.ast.Node;\nimport com.github.javaparser.ast.visitor.VoidVisitor;\nimport com.github.javaparser.printer.configuration.PrinterConfiguration;\nimport com.github.javaparser.printer.configuration.DefaultPrinterConfiguration;\n\n/**\n * Pretty printer for AST nodes.\n */\npublic class DefaultPrettyPrinter implements Printer {\n    \n    private PrinterConfiguration configuration;\n    \n    // visitor factory\n    Function<PrinterConfiguration, VoidVisitor<Void>> visitorFactory;\n    \n    // static methods \n    \n    private static Function<PrinterConfiguration, VoidVisitor<Void>> createDefaultVisitor() {\n        PrinterConfiguration configuration = createDefaultConfiguration();\n        return createDefaultVisitor(configuration);\n    }\n    \n    private static Function<PrinterConfiguration, VoidVisitor<Void>> createDefaultVisitor(PrinterConfiguration configuration) {\n        return (config) -> new DefaultPrettyPrinterVisitor(config, new SourcePrinter(config));\n    }\n    \n    private static PrinterConfiguration createDefaultConfiguration() {\n        return new DefaultPrinterConfiguration();\n    }\n    \n    // Constructors\n\n    /**\n     * Build a new DefaultPrettyPrinter with a default configuration and a default factory\n     */\n    public DefaultPrettyPrinter() {\n        this(createDefaultVisitor(), createDefaultConfiguration() );\n    }\n    \n    /**\n     * Build a new DefaultPrettyPrinter with a configuration and a default factory\n     * @param configuration\n     */\n    public DefaultPrettyPrinter(PrinterConfiguration configuration) {\n        this(createDefaultVisitor(configuration), configuration );\n    }\n    \n    /**\n     * Build a new DefaultPrettyPrinter with a configuration and a factory to create a visitor to browse the nodes of the AST\n     * @param visitorFactory \n     * @param configuration Configuration to apply\n     */\n    public DefaultPrettyPrinter(Function<PrinterConfiguration, VoidVisitor<Void>> visitorFactory, PrinterConfiguration configuration) {\n        this.configuration = configuration;\n        this.visitorFactory = visitorFactory;\n    }\n    \n    // Methods\n    \n    /*\n     * Returns the Printer configuration\n     */\n    public PrinterConfiguration getConfiguration() {\n        return configuration;\n    }\n\n    /*\n     * set or update the PrettyPrinter configuration\n     */\n    public Printer setConfiguration(PrinterConfiguration configuration) {\n        this.configuration = configuration;\n        return this;\n    }\n\n    @Override\n    public String print(Node node) {\n        // lazy initialization of visitor which can have a state (like a buffer)\n        VoidVisitor<Void> visitor = visitorFactory.apply(configuration);\n        node.accept(visitor, null);\n        return visitor.toString();\n    }\n}\n",
        "filePathAfter": "javaparser-core/src/main/java/com/github/javaparser/printer/DefaultPrettyPrinter.java",
        "sourceCodeAfterForWhole": "/*\n * Copyright (C) 2007-2010 J\u00falio Vilmar Gesser.\n * Copyright (C) 2011, 2013-2021 The JavaParser Team.\n *\n * This file is part of JavaParser.\n *\n * JavaParser can be used either under the terms of\n * a) the GNU Lesser General Public License as published by\n *     the Free Software Foundation, either version 3 of the License, or\n *     (at your option) any later version.\n * b) the terms of the Apache License\n *\n * You should have received a copy of both licenses in LICENCE.LGPL and\n * LICENCE.APACHE. Please refer to those files for details.\n *\n * JavaParser is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n */\n\npackage com.github.javaparser.printer;\n\nimport java.util.function.Function;\n\nimport com.github.javaparser.ast.Node;\nimport com.github.javaparser.ast.visitor.VoidVisitor;\nimport com.github.javaparser.printer.configuration.DefaultPrinterConfiguration;\nimport com.github.javaparser.printer.configuration.PrinterConfiguration;\n\n/**\n * Pretty printer for AST nodes.\n */\npublic class DefaultPrettyPrinter implements Printer {\n    \n    private PrinterConfiguration configuration;\n    \n    // visitor factory\n    Function<PrinterConfiguration, VoidVisitor<Void>> visitorFactory;\n    \n    // static methods \n    \n    private static Function<PrinterConfiguration, VoidVisitor<Void>> createDefaultVisitor() {\n        return (config) -> new DefaultPrettyPrinterVisitor(config, new SourcePrinter(config));\n    }\n    \n    private static PrinterConfiguration createDefaultConfiguration() {\n        return new DefaultPrinterConfiguration();\n    }\n    \n    // Constructors\n\n    /**\n     * Build a new DefaultPrettyPrinter with a default configuration and a default factory\n     */\n    public DefaultPrettyPrinter() {\n        this(createDefaultConfiguration() );\n    }\n    \n    /**\n     * Build a new DefaultPrettyPrinter with a configuration and a default factory\n     * @param configuration\n     */\n    public DefaultPrettyPrinter(PrinterConfiguration configuration) {\n        this(createDefaultVisitor(), configuration );\n    }\n    \n    /**\n     * Build a new DefaultPrettyPrinter with a configuration and a factory to create a visitor to browse the nodes of the AST\n     * @param visitorFactory \n     * @param configuration Configuration to apply\n     */\n    public DefaultPrettyPrinter(Function<PrinterConfiguration, VoidVisitor<Void>> visitorFactory, PrinterConfiguration configuration) {\n        this.configuration = configuration;\n        this.visitorFactory = visitorFactory;\n    }\n    \n    // Methods\n    \n    /*\n     * Returns the Printer configuration\n     */\n    public PrinterConfiguration getConfiguration() {\n        return configuration;\n    }\n\n    /*\n     * set or update the PrettyPrinter configuration\n     */\n    public Printer setConfiguration(PrinterConfiguration configuration) {\n        this.configuration = configuration;\n        return this;\n    }\n\n    @Override\n    public String print(Node node) {\n        // lazy initialization of visitor which can have a state (like a buffer)\n        VoidVisitor<Void> visitor = visitorFactory.apply(configuration);\n        node.accept(visitor, null);\n        return visitor.toString();\n    }\n}\n",
        "diffSourceCodeSet": [],
        "invokedMethodSet": [],
        "sourceCodeAfterRefactoring": "private static Function<PrinterConfiguration, VoidVisitor<Void>> createDefaultVisitor() {\n        return (config) -> new DefaultPrettyPrinterVisitor(config, new SourcePrinter(config));\n    }",
        "diffSourceCode": "    43:     private static Function<PrinterConfiguration, VoidVisitor<Void>> createDefaultVisitor() {\n-   44:         PrinterConfiguration configuration = createDefaultConfiguration();\n-   45:         return createDefaultVisitor(configuration);\n-   46:     }\n-   48:     private static Function<PrinterConfiguration, VoidVisitor<Void>> createDefaultVisitor(PrinterConfiguration configuration) {\n-   49:         return (config) -> new DefaultPrettyPrinterVisitor(config, new SourcePrinter(config));\n-   50:     }\n+   44:         return (config) -> new DefaultPrettyPrinterVisitor(config, new SourcePrinter(config));\n+   45:     }\n+   46:     \n+   48:         return new DefaultPrinterConfiguration();\n+   49:     }\n+   50:     \n",
        "uniqueId": "97240408d5c48e602a5a277a0af8e98137d32800_43_46__43_45_48_50",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 0,
                "covered": 2
            },
            "LINE": {
                "missed": 0,
                "covered": 1
            },
            "COMPLEXITY": {
                "missed": 0,
                "covered": 1
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 17
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprotected createSolver() : SymbolSolver extracted from public visit(node FieldAccessExpr, solveLambdas Boolean) : ResolvedType in class com.github.javaparser.symbolsolver.javaparsermodel.TypeExtractor",
        "diffLocations": [
            {
                "filePath": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/TypeExtractor.java",
                "startLine": 234,
                "endLine": 280,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/TypeExtractor.java",
                "startLine": 234,
                "endLine": 280,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/TypeExtractor.java",
                "startLine": 652,
                "endLine": 654,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "@Override\n    public ResolvedType visit(FieldAccessExpr node, Boolean solveLambdas) {\n        // We should understand if this is a static access\n        if (node.getScope() instanceof NameExpr ||\n                node.getScope() instanceof FieldAccessExpr) {\n            Expression staticValue = node.getScope();\n            SymbolReference<ResolvedTypeDeclaration> typeAccessedStatically = JavaParserFactory.getContext(node, typeSolver).solveType(staticValue.toString());\n            if (typeAccessedStatically.isSolved()) {\n                // TODO here maybe we have to substitute type typeParametersValues\n                return solveDotExpressionType(\n                        typeAccessedStatically.getCorrespondingDeclaration().asReferenceType(), node);\n            }\n        } else if (node.getScope() instanceof ThisExpr) {\n            // If we are accessing through a 'this' expression, first resolve the type\n            // corresponding to 'this'\n            SymbolReference<ResolvedTypeDeclaration> solve = facade.solve((ThisExpr) node.getScope());\n            // If found get it's declaration and get the field in there\n            if (solve.isSolved()) {\n                ResolvedTypeDeclaration correspondingDeclaration = solve.getCorrespondingDeclaration();\n                if (correspondingDeclaration instanceof ResolvedReferenceTypeDeclaration) {\n                    return solveDotExpressionType(correspondingDeclaration.asReferenceType(), node);\n                }\n            }\n\n        } else if (node.getScope().toString().indexOf('.') > 0) {\n            // try to find fully qualified name\n            SymbolReference<ResolvedReferenceTypeDeclaration> sr = typeSolver.tryToSolveType(node.getScope().toString());\n            if (sr.isSolved()) {\n                return solveDotExpressionType(sr.getCorrespondingDeclaration(), node);\n            }\n        }\n        Optional<Value> value = Optional.empty();\n        try {\n            value = new SymbolSolver(typeSolver).solveSymbolAsValue(node.getName().getId(), node);\n        } catch (UnsolvedSymbolException use) {\n            // This node may have a package name as part of its fully qualified name.\n            // We should solve for the type declaration inside this package.\n            SymbolReference<ResolvedReferenceTypeDeclaration> sref = typeSolver.tryToSolveType(node.toString());\n            if (sref.isSolved()) {\n                return new ReferenceTypeImpl(sref.getCorrespondingDeclaration(), typeSolver);\n            }\n        }\n        if (value.isPresent()) {\n            return value.get().getType();\n        }\n        throw new UnsolvedSymbolException(node.getName().getId());\n    }",
        "filePathBefore": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/TypeExtractor.java",
        "isPureRefactoring": true,
        "commitId": "b22ebb29abb4e6dcc1d22ca9823e5b2a3473b6a8",
        "packageNameBefore": "com.github.javaparser.symbolsolver.javaparsermodel",
        "classNameBefore": "com.github.javaparser.symbolsolver.javaparsermodel.TypeExtractor",
        "methodNameBefore": "com.github.javaparser.symbolsolver.javaparsermodel.TypeExtractor#visit",
        "invokedMethod": "methodSignature: com.github.javaparser.symbolsolver.javaparsermodel.TypeExtractor#solveDotExpressionType\n methodBody: private ResolvedType solveDotExpressionType(ResolvedReferenceTypeDeclaration parentType, FieldAccessExpr node) {\nif(parentType.isEnum() && parentType.asEnum().hasEnumConstant(node.getName().getId())){return parentType.asEnum().getEnumConstant(node.getName().getId()).getType();\n}if(parentType.hasField(node.getName().getId())){return parentType.getField(node.getName().getId()).getType();\n}if(parentType.hasInternalType(node.getName().getId())){return new ReferenceTypeImpl(parentType.getInternalType(node.getName().getId()),typeSolver);\n}{throw new UnsolvedSymbolException(node.getName().getId());\n}}",
        "classSignatureBefore": "public class TypeExtractor extends DefaultVisitorAdapter ",
        "methodNameBeforeSet": [
            "com.github.javaparser.symbolsolver.javaparsermodel.TypeExtractor#visit"
        ],
        "classNameBeforeSet": [
            "com.github.javaparser.symbolsolver.javaparsermodel.TypeExtractor"
        ],
        "classSignatureBeforeSet": [
            "public class TypeExtractor extends DefaultVisitorAdapter "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Tolerable changes in the body\n",
                "description": "All replacements have been justified - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Copyright (C) 2015-2016 Federico Tomassetti\n * Copyright (C) 2017-2020 The JavaParser Team.\n *\n * This file is part of JavaParser.\n *\n * JavaParser can be used either under the terms of\n * a) the GNU Lesser General Public License as published by\n *     the Free Software Foundation, either version 3 of the License, or\n *     (at your option) any later version.\n * b) the terms of the Apache License\n *\n * You should have received a copy of both licenses in LICENCE.LGPL and\n * LICENCE.APACHE. Please refer to those files for details.\n *\n * JavaParser is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n */\n\npackage com.github.javaparser.symbolsolver.javaparsermodel;\n\nimport static com.github.javaparser.symbolsolver.javaparser.Navigator.demandParentNode;\nimport static com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade.solveGenericTypes;\n\nimport java.util.List;\nimport java.util.Optional;\n\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.body.FieldDeclaration;\nimport com.github.javaparser.ast.body.Parameter;\nimport com.github.javaparser.ast.body.VariableDeclarator;\nimport com.github.javaparser.ast.expr.*;\nimport com.github.javaparser.ast.stmt.BlockStmt;\nimport com.github.javaparser.ast.stmt.ExpressionStmt;\nimport com.github.javaparser.ast.stmt.ReturnStmt;\nimport com.github.javaparser.ast.type.ClassOrInterfaceType;\nimport com.github.javaparser.ast.type.Type;\nimport com.github.javaparser.ast.type.UnknownType;\nimport com.github.javaparser.resolution.MethodUsage;\nimport com.github.javaparser.resolution.UnsolvedSymbolException;\nimport com.github.javaparser.resolution.declarations.ResolvedClassDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedMethodDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedReferenceTypeDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedTypeDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedTypeParameterDeclaration;\nimport com.github.javaparser.resolution.types.ResolvedArrayType;\nimport com.github.javaparser.resolution.types.ResolvedPrimitiveType;\nimport com.github.javaparser.resolution.types.ResolvedType;\nimport com.github.javaparser.resolution.types.ResolvedVoidType;\nimport com.github.javaparser.symbolsolver.core.resolution.Context;\nimport com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserSymbolDeclaration;\nimport com.github.javaparser.symbolsolver.logic.FunctionalInterfaceLogic;\nimport com.github.javaparser.symbolsolver.logic.InferenceContext;\nimport com.github.javaparser.symbolsolver.model.resolution.SymbolReference;\nimport com.github.javaparser.symbolsolver.model.resolution.TypeSolver;\nimport com.github.javaparser.symbolsolver.model.resolution.Value;\nimport com.github.javaparser.symbolsolver.model.typesystem.NullType;\nimport com.github.javaparser.symbolsolver.model.typesystem.ReferenceTypeImpl;\nimport com.github.javaparser.symbolsolver.reflectionmodel.MyObjectProvider;\nimport com.github.javaparser.symbolsolver.reflectionmodel.ReflectionClassDeclaration;\nimport com.github.javaparser.symbolsolver.resolution.SymbolSolver;\nimport com.github.javaparser.symbolsolver.resolution.promotion.ConditionalExprHandler;\nimport com.github.javaparser.symbolsolver.resolution.promotion.ConditionalExprResolver;\nimport com.github.javaparser.symbolsolver.resolution.typesolvers.ReflectionTypeSolver;\nimport com.github.javaparser.utils.Log;\nimport com.github.javaparser.utils.Pair;\nimport com.google.common.collect.ImmutableList;\n\npublic class TypeExtractor extends DefaultVisitorAdapter {\n\n    private static final String JAVA_LANG_STRING = String.class.getCanonicalName();\n    \n    private TypeSolver typeSolver;\n    private JavaParserFacade facade;\n    \n    private ReferenceTypeImpl StringReferenceType;\n\n    public TypeExtractor(TypeSolver typeSolver, JavaParserFacade facade) {\n        this.typeSolver = typeSolver;\n        this.facade = facade;\n        //pre-calculate the String reference (optimization)\n        StringReferenceType = new ReferenceTypeImpl(new ReflectionTypeSolver().solveType(JAVA_LANG_STRING), typeSolver);\n    }\n\n    @Override\n    public ResolvedType visit(VariableDeclarator node, Boolean solveLambdas) {\n        if (demandParentNode(node) instanceof FieldDeclaration) {\n            return facade.convertToUsageVariableType(node);\n        } else if (demandParentNode(node) instanceof VariableDeclarationExpr) {\n            return facade.convertToUsageVariableType(node);\n        }\n        throw new UnsupportedOperationException(demandParentNode(node).getClass().getCanonicalName());\n    }\n\n    @Override\n    public ResolvedType visit(Parameter node, Boolean solveLambdas) {\n        if (node.getType() instanceof UnknownType) {\n            throw new IllegalStateException(\"Parameter has unknown type: \" + node);\n        }\n        return facade.convertToUsage(node.getType(), node);\n    }\n\n\n    @Override\n    public ResolvedType visit(ArrayAccessExpr node, Boolean solveLambdas) {\n        ResolvedType arrayUsageType = node.getName().accept(this, solveLambdas);\n        if (arrayUsageType.isArray()) {\n            return ((ResolvedArrayType) arrayUsageType).getComponentType();\n        }\n        return arrayUsageType;\n    }\n\n    @Override\n    public ResolvedType visit(ArrayCreationExpr node, Boolean solveLambdas) {\n        ResolvedType res = facade.convertToUsage(node.getElementType(), JavaParserFactory.getContext(node, typeSolver));\n        for (int i = 0; i < node.getLevels().size(); i++) {\n            res = new ResolvedArrayType(res);\n        }\n        return res;\n    }\n\n    @Override\n    public ResolvedType visit(ArrayInitializerExpr node, Boolean solveLambdas) {\n        throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n    }\n\n    @Override\n    public ResolvedType visit(AssignExpr node, Boolean solveLambdas) {\n        return node.getTarget().accept(this, solveLambdas);\n    }\n\n    @Override\n    public ResolvedType visit(BinaryExpr node, Boolean solveLambdas) {\n        switch (node.getOperator()) {\n            case PLUS:\n            case MINUS:\n            case DIVIDE:\n            case MULTIPLY:\n            case REMAINDER:\n            case BINARY_AND:\n            case BINARY_OR:\n            case XOR:\n                return facade.getBinaryTypeConcrete(node.getLeft(), node.getRight(), solveLambdas, node.getOperator());\n            case LESS_EQUALS:\n            case LESS:\n            case GREATER:\n            case GREATER_EQUALS:\n            case EQUALS:\n            case NOT_EQUALS:\n            case OR:\n            case AND:\n                return ResolvedPrimitiveType.BOOLEAN;\n            case SIGNED_RIGHT_SHIFT:\n            case UNSIGNED_RIGHT_SHIFT:\n            case LEFT_SHIFT:\n                ResolvedType rt = node.getLeft().accept(this, solveLambdas);\n                // apply unary primitive promotion\n                return ResolvedPrimitiveType.unp(rt);\n            default:\n                throw new UnsupportedOperationException(\"Operator \" + node.getOperator().name());\n        }\n    }\n\n    @Override\n    public ResolvedType visit(CastExpr node, Boolean solveLambdas) {\n        return facade.convertToUsage(node.getType(), JavaParserFactory.getContext(node, typeSolver));\n    }\n\n    @Override\n    public ResolvedType visit(ClassExpr node, Boolean solveLambdas) {\n        // This implementation does not regard the actual type argument of the ClassExpr.\n        Type astType = node.getType();\n        ResolvedType jssType = facade.convertToUsage(astType, node.getType());\n        return new ReferenceTypeImpl(new ReflectionClassDeclaration(Class.class, typeSolver), ImmutableList.of(jssType), typeSolver);\n    }\n\n    /*\n     * The conditional operator has three operand expressions. ? appears between the first and second expressions, and\n     * : appears between the second and third expressions.\n     * There are three kinds of conditional expressions, classified according to the second and third operand\n     * expressions: boolean conditional expressions, numeric conditional expressions, and reference conditional\n     * expressions.\n     * The classification rules are as follows:\n     * 1/ If both the second and the third operand expressions are boolean expressions, the conditional expression is a\n     * boolean conditional expression.\n     * 2/ If both the second and the third operand expressions are numeric expressions, the conditional expression is a\n     * numeric conditional expression.\n     * 3/ Otherwise, the conditional expression is a reference conditional expression\n     */\n    @Override\n    public ResolvedType visit(ConditionalExpr node, Boolean solveLambdas) {\n        ResolvedType thenExpr = node.getThenExpr().accept(this, solveLambdas);\n        ResolvedType elseExpr = node.getElseExpr().accept(this, solveLambdas);\n\n        ConditionalExprHandler rce = ConditionalExprResolver.getConditionExprHandler(thenExpr, elseExpr);\n        try {\n            return rce.resolveType();\n        } catch (UnsupportedOperationException e) {\n            // There is nothing to do because, for the moment, we want to run actual implementation\n        }\n        return node.getThenExpr().accept(this, solveLambdas);\n    }\n    \n    private boolean isCompatible(ResolvedType resolvedType, ResolvedPrimitiveType primitiveType) {\n        return (resolvedType.isPrimitive() && resolvedType.asPrimitive().equals(primitiveType))\n        || (resolvedType.isReferenceType() && resolvedType.asReferenceType().isUnboxableTo(primitiveType));\n    }\n\n    @Override\n    public ResolvedType visit(EnclosedExpr node, Boolean solveLambdas) {\n        return node.getInner().accept(this, solveLambdas);\n    }\n\n    /**\n     * Java Parser can't differentiate between packages, internal types, and fields.\n     * All three are lumped together into FieldAccessExpr. We need to differentiate them.\n     */\n    private ResolvedType solveDotExpressionType(ResolvedReferenceTypeDeclaration parentType, FieldAccessExpr node) {\n        // Fields and internal type declarations cannot have the same name.\n        // Thus, these checks will always be mutually exclusive.\n        if (parentType.isEnum() && parentType.asEnum().hasEnumConstant(node.getName().getId())) {\n            return parentType.asEnum().getEnumConstant(node.getName().getId()).getType();\n        } else if (parentType.hasField(node.getName().getId())) {\n            return parentType.getField(node.getName().getId()).getType();\n        } else if (parentType.hasInternalType(node.getName().getId())) {\n            return new ReferenceTypeImpl(parentType.getInternalType(node.getName().getId()), typeSolver);\n        } else {\n            throw new UnsolvedSymbolException(node.getName().getId());\n        }\n    }\n\n    @Override\n    public ResolvedType visit(FieldAccessExpr node, Boolean solveLambdas) {\n        // We should understand if this is a static access\n        if (node.getScope() instanceof NameExpr ||\n                node.getScope() instanceof FieldAccessExpr) {\n            Expression staticValue = node.getScope();\n            SymbolReference<ResolvedTypeDeclaration> typeAccessedStatically = JavaParserFactory.getContext(node, typeSolver).solveType(staticValue.toString());\n            if (typeAccessedStatically.isSolved()) {\n                // TODO here maybe we have to substitute type typeParametersValues\n                return solveDotExpressionType(\n                        typeAccessedStatically.getCorrespondingDeclaration().asReferenceType(), node);\n            }\n        } else if (node.getScope() instanceof ThisExpr) {\n            // If we are accessing through a 'this' expression, first resolve the type\n            // corresponding to 'this'\n            SymbolReference<ResolvedTypeDeclaration> solve = facade.solve((ThisExpr) node.getScope());\n            // If found get it's declaration and get the field in there\n            if (solve.isSolved()) {\n                ResolvedTypeDeclaration correspondingDeclaration = solve.getCorrespondingDeclaration();\n                if (correspondingDeclaration instanceof ResolvedReferenceTypeDeclaration) {\n                    return solveDotExpressionType(correspondingDeclaration.asReferenceType(), node);\n                }\n            }\n\n        } else if (node.getScope().toString().indexOf('.') > 0) {\n            // try to find fully qualified name\n            SymbolReference<ResolvedReferenceTypeDeclaration> sr = typeSolver.tryToSolveType(node.getScope().toString());\n            if (sr.isSolved()) {\n                return solveDotExpressionType(sr.getCorrespondingDeclaration(), node);\n            }\n        }\n        Optional<Value> value = Optional.empty();\n        try {\n            value = new SymbolSolver(typeSolver).solveSymbolAsValue(node.getName().getId(), node);\n        } catch (UnsolvedSymbolException use) {\n            // This node may have a package name as part of its fully qualified name.\n            // We should solve for the type declaration inside this package.\n            SymbolReference<ResolvedReferenceTypeDeclaration> sref = typeSolver.tryToSolveType(node.toString());\n            if (sref.isSolved()) {\n                return new ReferenceTypeImpl(sref.getCorrespondingDeclaration(), typeSolver);\n            }\n        }\n        if (value.isPresent()) {\n            return value.get().getType();\n        }\n        throw new UnsolvedSymbolException(node.getName().getId());\n    }\n\n    @Override\n    public ResolvedType visit(InstanceOfExpr node, Boolean solveLambdas) {\n        return ResolvedPrimitiveType.BOOLEAN;\n    }\n\n    @Override\n    public ResolvedType visit(StringLiteralExpr node, Boolean solveLambdas) {\n        return StringReferenceType;\n    }\n\n    @Override\n    public ResolvedType visit(IntegerLiteralExpr node, Boolean solveLambdas) {\n        return ResolvedPrimitiveType.INT;\n    }\n\n    @Override\n    public ResolvedType visit(LongLiteralExpr node, Boolean solveLambdas) {\n        return ResolvedPrimitiveType.LONG;\n    }\n\n    @Override\n    public ResolvedType visit(CharLiteralExpr node, Boolean solveLambdas) {\n        return ResolvedPrimitiveType.CHAR;\n    }\n\n    @Override\n    public ResolvedType visit(DoubleLiteralExpr node, Boolean solveLambdas) {\n        if (node.getValue().toLowerCase().endsWith(\"f\")) {\n            return ResolvedPrimitiveType.FLOAT;\n        }\n        return ResolvedPrimitiveType.DOUBLE;\n    }\n\n    @Override\n    public ResolvedType visit(BooleanLiteralExpr node, Boolean solveLambdas) {\n        return ResolvedPrimitiveType.BOOLEAN;\n    }\n\n    @Override\n    public ResolvedType visit(NullLiteralExpr node, Boolean solveLambdas) {\n        return NullType.INSTANCE;\n    }\n\n    @Override\n    public ResolvedType visit(MethodCallExpr node, Boolean solveLambdas) {\n        Log.trace(\"getType on method call %s\", ()-> node);\n        // first solve the method\n        MethodUsage ref = facade.solveMethodAsUsage(node);\n        Log.trace(\"getType on method call %s resolved to %s\", ()-> node, ()-> ref);\n        Log.trace(\"getType on method call %s return type is %s\", ()-> node, ref::returnType);\n        return ref.returnType();\n        // the type is the return type of the method\n    }\n\n    @Override\n    public ResolvedType visit(NameExpr node, Boolean solveLambdas) {\n        Log.trace(\"getType on name expr %s\", ()-> node);\n        Optional<Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(node.getName().getId(), node);\n        if (!value.isPresent()) {\n            throw new UnsolvedSymbolException(\"Solving \" + node, node.getName().getId());\n        } else {\n            return value.get().getType();\n        }\n    }\n\n    @Override\n    public ResolvedType visit(TypeExpr node, Boolean solveLambdas) {\n        Log.trace(\"getType on type expr %s\", ()-> node);\n        if (!(node.getType() instanceof ClassOrInterfaceType)) {\n            throw new UnsupportedOperationException(node.getType().getClass().getCanonicalName());\n        }\n\n        ClassOrInterfaceType classOrInterfaceType = (ClassOrInterfaceType) node.getType();\n        String nameWithScope = classOrInterfaceType.getNameWithScope();\n\n        // JLS 15.13 - ReferenceType :: [TypeArguments] Identifier\n        SymbolReference<ResolvedTypeDeclaration> typeDeclarationSymbolReference = JavaParserFactory\n                .getContext(classOrInterfaceType, typeSolver)\n                .solveType(nameWithScope);\n        if (typeDeclarationSymbolReference.isSolved()) {\n            return new ReferenceTypeImpl(typeDeclarationSymbolReference.getCorrespondingDeclaration().asReferenceType(), typeSolver);\n        }\n\n        // JLS 15.13 - ExpressionName :: [TypeArguments] Identifier\n        Optional<Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(nameWithScope, node);\n        if (value.isPresent()) {\n            return value.get().getType();\n        }\n\n        throw new UnsolvedSymbolException(\"Solving \" + node, classOrInterfaceType.getName().getId());\n    }\n\n    @Override\n    public ResolvedType visit(ObjectCreationExpr node, Boolean solveLambdas) {\n        return facade.convertToUsage(node.getType(), node);\n    }\n\n    @Override\n    public ResolvedType visit(ThisExpr node, Boolean solveLambdas) {\n        // If 'this' is prefixed by a class eg. MyClass.this\n        if (node.getTypeName().isPresent()) {\n            // Get the class name\n            String className = node.getTypeName().get().asString();\n            // Attempt to resolve locally in Compilation unit\n            // first try a buttom/up approach\n            try {\n                return new ReferenceTypeImpl(\n                        facade.getTypeDeclaration(facade.findContainingTypeDeclOrObjectCreationExpr(node, className)),\n                        typeSolver);\n            } catch (IllegalStateException e) {\n                // trying another approach from type solver\n                Optional<CompilationUnit> cu = node.findAncestor(CompilationUnit.class);\n                SymbolReference<ResolvedReferenceTypeDeclaration> clazz = typeSolver.tryToSolveType(className);\n                if (clazz.isSolved()) {\n                    return new ReferenceTypeImpl(clazz.getCorrespondingDeclaration(), typeSolver);\n                }\n            }\n        }\n        return new ReferenceTypeImpl(facade.getTypeDeclaration(facade.findContainingTypeDeclOrObjectCreationExpr(node)), typeSolver);\n    }\n\n    @Override\n    public ResolvedType visit(SuperExpr node, Boolean solveLambdas) {\n        // If 'super' is prefixed by a class eg. MyClass.this\n        if (node.getTypeName().isPresent()) {\n            String className = node.getTypeName().get().asString();\n            SymbolReference<ResolvedTypeDeclaration> resolvedTypeNameRef = JavaParserFactory.getContext(node, typeSolver).solveType(className);\n            if (resolvedTypeNameRef.isSolved()) {\n                // Cfr JLS $15.12.1\n                ResolvedTypeDeclaration resolvedTypeName = resolvedTypeNameRef.getCorrespondingDeclaration();\n                if (resolvedTypeName.isInterface()) {\n                    return new ReferenceTypeImpl(resolvedTypeName.asInterface(), typeSolver);\n                } else if (resolvedTypeName.isClass()) {\n                    // TODO: Maybe include a presence check? e.g. in the case of `java.lang.Object` there will be no superclass.\n                    return resolvedTypeName.asClass().getSuperClass().orElseThrow(() -> new RuntimeException(\"super class unexpectedly empty\"));\n                } else {\n                    throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n                }\n            } else {\n                throw new UnsolvedSymbolException(className);\n            }\n        }\n\n        ResolvedTypeDeclaration typeOfNode = facade.getTypeDeclaration(facade.findContainingTypeDeclOrObjectCreationExpr(node));\n        if (typeOfNode instanceof ResolvedClassDeclaration) {\n            // TODO: Maybe include a presence check? e.g. in the case of `java.lang.Object` there will be no superclass.\n            return ((ResolvedClassDeclaration) typeOfNode).getSuperClass().orElseThrow(() -> new RuntimeException(\"super class unexpectedly empty\"));\n        } else {\n            throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n        }\n    }\n\n    @Override\n    public ResolvedType visit(UnaryExpr node, Boolean solveLambdas) {\n        switch (node.getOperator()) {\n            case MINUS:\n            case PLUS:\n                return ResolvedPrimitiveType.unp(node.getExpression().accept(this, solveLambdas));\n            case LOGICAL_COMPLEMENT:\n                return ResolvedPrimitiveType.BOOLEAN;\n            case POSTFIX_DECREMENT:\n            case PREFIX_DECREMENT:\n            case POSTFIX_INCREMENT:\n            case PREFIX_INCREMENT:\n            case BITWISE_COMPLEMENT:\n                return node.getExpression().accept(this, solveLambdas);\n            default:\n                throw new UnsupportedOperationException(node.getOperator().name());\n        }\n    }\n\n    @Override\n    public ResolvedType visit(VariableDeclarationExpr node, Boolean solveLambdas) {\n        if (node.getVariables().size() != 1) {\n            throw new UnsupportedOperationException();\n        }\n        return facade.convertToUsageVariableType(node.getVariables().get(0));\n    }\n\n\n    @Override\n    public ResolvedType visit(LambdaExpr node, Boolean solveLambdas) {\n        if (demandParentNode(node) instanceof MethodCallExpr) {\n            MethodCallExpr callExpr = (MethodCallExpr) demandParentNode(node);\n            int pos = JavaParserSymbolDeclaration.getParamPos(node);\n            SymbolReference<ResolvedMethodDeclaration> refMethod = facade.solve(callExpr);\n            if (!refMethod.isSolved()) {\n                throw new UnsolvedSymbolException(demandParentNode(node).toString(), callExpr.getName().getId());\n            }\n            Log.trace(\"getType on lambda expr %s\", ()-> refMethod.getCorrespondingDeclaration().getName());\n\n            // The type parameter referred here should be the java.util.stream.Stream.T\n            ResolvedType result = refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n\n            if (solveLambdas) {\n                if (callExpr.hasScope()) {\n                    Expression scope = callExpr.getScope().get();\n\n                    // If it is a static call we should not try to get the type of the scope\n                    boolean staticCall = false;\n                    if (scope instanceof NameExpr) {\n                        NameExpr nameExpr = (NameExpr) scope;\n                        try {\n                            SymbolReference<ResolvedTypeDeclaration> type = JavaParserFactory.getContext(nameExpr, typeSolver).solveType(nameExpr.getName().getId());\n                            if (type.isSolved()) {\n                                staticCall = true;\n                            }\n                        } catch (Exception e) {\n\n                        }\n                    }\n\n                    if (!staticCall) {\n                        ResolvedType scopeType = facade.getType(scope);\n                        if (scopeType.isReferenceType()) {\n                            result = scopeType.asReferenceType().useThisTypeParametersOnTheGivenType(result);\n                        }\n                    }\n                }\n\n                result = resolveLambda(node, result);\n            }\n            return result;\n        } else if (demandParentNode(node) instanceof VariableDeclarator)\n        {\n            VariableDeclarator decExpr = (VariableDeclarator) demandParentNode(node);\n            ResolvedType result = decExpr.getType().resolve();\n\n            if (solveLambdas) {\n                result = resolveLambda(node, result);\n            }\n            return result;\n        } else if (demandParentNode(node) instanceof AssignExpr) {\n            AssignExpr assExpr = (AssignExpr) demandParentNode(node);\n            ResolvedType result = assExpr.calculateResolvedType();\n\n            if (solveLambdas) {\n                result = resolveLambda(node, result);\n            }\n            return result;\n        } else {\n            throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n        }\n    }\n\n    private ResolvedType resolveLambda(LambdaExpr node, ResolvedType result) {\n        // We need to replace the type variables\n        Context ctx = JavaParserFactory.getContext(node, typeSolver);\n        result = solveGenericTypes(result, ctx);\n\n        //We should find out which is the functional method (e.g., apply) and replace the params of the\n        //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n        //lambdas\n        Optional<MethodUsage> functionalMethod = FunctionalInterfaceLogic.getFunctionalMethod(result);\n        if (functionalMethod.isPresent()) {\n            LambdaExpr lambdaExpr = node;\n\n            InferenceContext lambdaCtx = new InferenceContext(MyObjectProvider.INSTANCE);\n            InferenceContext funcInterfaceCtx = new InferenceContext(MyObjectProvider.INSTANCE);\n\n            // At this point parameterType\n            // if Function<T=? super Stream.T, ? extends map.R>\n            // we should replace Stream.T\n            ResolvedType functionalInterfaceType = ReferenceTypeImpl.undeterminedParameters(functionalMethod.get().getDeclaration().declaringType(), typeSolver);\n\n            lambdaCtx.addPair(result, functionalInterfaceType);\n\n            ResolvedType actualType;\n\n            if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                actualType = facade.getType(((ExpressionStmt) lambdaExpr.getBody()).getExpression());\n            } else if (lambdaExpr.getBody() instanceof BlockStmt) {\n                BlockStmt blockStmt = (BlockStmt) lambdaExpr.getBody();\n\n                // Get all the return statements in the lambda block\n                List<ReturnStmt> returnStmts = blockStmt.findAll(ReturnStmt.class);\n\n                if (returnStmts.size() > 0) {\n                    actualType = returnStmts.stream()\n                            .map(returnStmt -> returnStmt.getExpression().map(e -> facade.getType(e)).orElse(ResolvedVoidType.INSTANCE))\n                            .filter(x -> x != null && !x.isVoid() && !x.isNull())\n                            .findFirst()\n                            .orElse(ResolvedVoidType.INSTANCE);\n\n                } else {\n                    actualType = ResolvedVoidType.INSTANCE;\n                }\n\n\n            } else {\n                throw new UnsupportedOperationException();\n            }\n\n            ResolvedType formalType = functionalMethod.get().returnType();\n\n            // Infer the functional interfaces' return vs actual type\n            funcInterfaceCtx.addPair(formalType, actualType);\n            // Substitute to obtain a new type\n            ResolvedType functionalTypeWithReturn = funcInterfaceCtx.resolve(funcInterfaceCtx.addSingle(functionalInterfaceType));\n\n            // if the functional method returns void anyway\n            // we don't need to bother inferring types\n            if (!(formalType instanceof ResolvedVoidType)) {\n                lambdaCtx.addPair(result, functionalTypeWithReturn);\n                result = lambdaCtx.resolve(lambdaCtx.addSingle(result));\n            }\n        }\n        return result;\n    }\n\n    @Override\n    public ResolvedType visit(MethodReferenceExpr node, Boolean solveLambdas) {\n        if (demandParentNode(node) instanceof MethodCallExpr) {\n            MethodCallExpr callExpr = (MethodCallExpr) demandParentNode(node);\n            int pos = JavaParserSymbolDeclaration.getParamPos(node);\n            SymbolReference<ResolvedMethodDeclaration> refMethod = facade.solve(callExpr, false);\n            if (!refMethod.isSolved()) {\n                throw new UnsolvedSymbolException(demandParentNode(node).toString(), callExpr.getName().getId());\n            }\n            Log.trace(\"getType on method reference expr %s\", ()-> refMethod.getCorrespondingDeclaration().getName());\n            if (solveLambdas) {\n                MethodUsage usage = facade.solveMethodAsUsage(callExpr);\n                ResolvedType result = usage.getParamType(pos);\n                // We need to replace the type variables\n                Context ctx = JavaParserFactory.getContext(node, typeSolver);\n                result = solveGenericTypes(result, ctx);\n\n                //We should find out which is the functional method (e.g., apply) and replace the params of the\n                //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                //lambdas\n                Optional<MethodUsage> functionalMethodOpt = FunctionalInterfaceLogic.getFunctionalMethod(result);\n                if (functionalMethodOpt.isPresent()) {\n                    MethodUsage functionalMethod = functionalMethodOpt.get();\n\n                    for (Pair<ResolvedTypeParameterDeclaration, ResolvedType> typeParamDecl : result.asReferenceType().getTypeParametersMap()) {\n                        functionalMethod = functionalMethod.replaceTypeParameter(typeParamDecl.a, typeParamDecl.b);\n                    }\n\n                    // replace wildcards\n                    for (int i = 0; i < functionalMethod.getNoParams(); i++) {\n                        ResolvedType type = functionalMethod.getParamType(i);\n                        if (type.isWildcard()) {\n                            ResolvedType boundedType = type.asWildcard().getBoundedType();\n                            functionalMethod = functionalMethod.replaceParamType(i, boundedType);\n                        }\n                    }\n\n                    ResolvedType actualType = facade.toMethodUsage(node, functionalMethod.getParamTypes()).returnType();\n                    ResolvedType formalType = functionalMethod.returnType();\n\n                    InferenceContext inferenceContext = new InferenceContext(MyObjectProvider.INSTANCE);\n                    inferenceContext.addPair(formalType, actualType);\n                    result = inferenceContext.resolve(inferenceContext.addSingle(result));\n                }\n\n                return result;\n            }\n            return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n        }\n        throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n    }\n\n    @Override\n    public ResolvedType visit(FieldDeclaration node, Boolean solveLambdas) {\n        if (node.getVariables().size() == 1) {\n            return node.getVariables().get(0).accept(this, solveLambdas);\n        }\n        throw new IllegalArgumentException(\"Cannot resolve the type of a field with multiple variable declarations. Pick one\");\n    }\n}\n",
        "filePathAfter": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/TypeExtractor.java",
        "sourceCodeAfterForWhole": "/*\n * Copyright (C) 2015-2016 Federico Tomassetti\n * Copyright (C) 2017-2020 The JavaParser Team.\n *\n * This file is part of JavaParser.\n *\n * JavaParser can be used either under the terms of\n * a) the GNU Lesser General Public License as published by\n *     the Free Software Foundation, either version 3 of the License, or\n *     (at your option) any later version.\n * b) the terms of the Apache License\n *\n * You should have received a copy of both licenses in LICENCE.LGPL and\n * LICENCE.APACHE. Please refer to those files for details.\n *\n * JavaParser is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n */\n\npackage com.github.javaparser.symbolsolver.javaparsermodel;\n\nimport static com.github.javaparser.symbolsolver.javaparser.Navigator.demandParentNode;\nimport static com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade.solveGenericTypes;\n\nimport java.util.List;\nimport java.util.Optional;\n\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.body.FieldDeclaration;\nimport com.github.javaparser.ast.body.Parameter;\nimport com.github.javaparser.ast.body.VariableDeclarator;\nimport com.github.javaparser.ast.expr.*;\nimport com.github.javaparser.ast.stmt.BlockStmt;\nimport com.github.javaparser.ast.stmt.ExpressionStmt;\nimport com.github.javaparser.ast.stmt.ReturnStmt;\nimport com.github.javaparser.ast.type.ClassOrInterfaceType;\nimport com.github.javaparser.ast.type.Type;\nimport com.github.javaparser.ast.type.UnknownType;\nimport com.github.javaparser.resolution.MethodUsage;\nimport com.github.javaparser.resolution.UnsolvedSymbolException;\nimport com.github.javaparser.resolution.declarations.ResolvedClassDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedMethodDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedReferenceTypeDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedTypeDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedTypeParameterDeclaration;\nimport com.github.javaparser.resolution.types.ResolvedArrayType;\nimport com.github.javaparser.resolution.types.ResolvedPrimitiveType;\nimport com.github.javaparser.resolution.types.ResolvedType;\nimport com.github.javaparser.resolution.types.ResolvedVoidType;\nimport com.github.javaparser.symbolsolver.core.resolution.Context;\nimport com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserSymbolDeclaration;\nimport com.github.javaparser.symbolsolver.logic.FunctionalInterfaceLogic;\nimport com.github.javaparser.symbolsolver.logic.InferenceContext;\nimport com.github.javaparser.symbolsolver.model.resolution.SymbolReference;\nimport com.github.javaparser.symbolsolver.model.resolution.TypeSolver;\nimport com.github.javaparser.symbolsolver.model.resolution.Value;\nimport com.github.javaparser.symbolsolver.model.typesystem.NullType;\nimport com.github.javaparser.symbolsolver.model.typesystem.ReferenceTypeImpl;\nimport com.github.javaparser.symbolsolver.reflectionmodel.MyObjectProvider;\nimport com.github.javaparser.symbolsolver.reflectionmodel.ReflectionClassDeclaration;\nimport com.github.javaparser.symbolsolver.resolution.SymbolSolver;\nimport com.github.javaparser.symbolsolver.resolution.promotion.ConditionalExprHandler;\nimport com.github.javaparser.symbolsolver.resolution.promotion.ConditionalExprResolver;\nimport com.github.javaparser.symbolsolver.resolution.typesolvers.ReflectionTypeSolver;\nimport com.github.javaparser.utils.Log;\nimport com.github.javaparser.utils.Pair;\nimport com.google.common.collect.ImmutableList;\n\npublic class TypeExtractor extends DefaultVisitorAdapter {\n\n    private static final String JAVA_LANG_STRING = String.class.getCanonicalName();\n    private final ReferenceTypeImpl stringReferenceType;\n\n    private TypeSolver typeSolver;\n    private JavaParserFacade facade;\n    \n\n    public TypeExtractor(TypeSolver typeSolver, JavaParserFacade facade) {\n        this.typeSolver = typeSolver;\n        this.facade = facade;\n        //pre-calculate the String reference (optimization)\n        stringReferenceType = new ReferenceTypeImpl(new ReflectionTypeSolver().solveType(JAVA_LANG_STRING), typeSolver);\n    }\n\n    @Override\n    public ResolvedType visit(VariableDeclarator node, Boolean solveLambdas) {\n        if (demandParentNode(node) instanceof FieldDeclaration) {\n            return facade.convertToUsageVariableType(node);\n        } else if (demandParentNode(node) instanceof VariableDeclarationExpr) {\n            return facade.convertToUsageVariableType(node);\n        }\n        throw new UnsupportedOperationException(demandParentNode(node).getClass().getCanonicalName());\n    }\n\n    @Override\n    public ResolvedType visit(Parameter node, Boolean solveLambdas) {\n        if (node.getType() instanceof UnknownType) {\n            throw new IllegalStateException(\"Parameter has unknown type: \" + node);\n        }\n        return facade.convertToUsage(node.getType(), node);\n    }\n\n\n    @Override\n    public ResolvedType visit(ArrayAccessExpr node, Boolean solveLambdas) {\n        ResolvedType arrayUsageType = node.getName().accept(this, solveLambdas);\n        if (arrayUsageType.isArray()) {\n            return ((ResolvedArrayType) arrayUsageType).getComponentType();\n        }\n        return arrayUsageType;\n    }\n\n    @Override\n    public ResolvedType visit(ArrayCreationExpr node, Boolean solveLambdas) {\n        ResolvedType res = facade.convertToUsage(node.getElementType(), JavaParserFactory.getContext(node, typeSolver));\n        for (int i = 0; i < node.getLevels().size(); i++) {\n            res = new ResolvedArrayType(res);\n        }\n        return res;\n    }\n\n    @Override\n    public ResolvedType visit(ArrayInitializerExpr node, Boolean solveLambdas) {\n        throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n    }\n\n    @Override\n    public ResolvedType visit(AssignExpr node, Boolean solveLambdas) {\n        return node.getTarget().accept(this, solveLambdas);\n    }\n\n    @Override\n    public ResolvedType visit(BinaryExpr node, Boolean solveLambdas) {\n        switch (node.getOperator()) {\n            case PLUS:\n            case MINUS:\n            case DIVIDE:\n            case MULTIPLY:\n            case REMAINDER:\n            case BINARY_AND:\n            case BINARY_OR:\n            case XOR:\n                return facade.getBinaryTypeConcrete(node.getLeft(), node.getRight(), solveLambdas, node.getOperator());\n            case LESS_EQUALS:\n            case LESS:\n            case GREATER:\n            case GREATER_EQUALS:\n            case EQUALS:\n            case NOT_EQUALS:\n            case OR:\n            case AND:\n                return ResolvedPrimitiveType.BOOLEAN;\n            case SIGNED_RIGHT_SHIFT:\n            case UNSIGNED_RIGHT_SHIFT:\n            case LEFT_SHIFT:\n                ResolvedType rt = node.getLeft().accept(this, solveLambdas);\n                // apply unary primitive promotion\n                return ResolvedPrimitiveType.unp(rt);\n            default:\n                throw new UnsupportedOperationException(\"Operator \" + node.getOperator().name());\n        }\n    }\n\n    @Override\n    public ResolvedType visit(CastExpr node, Boolean solveLambdas) {\n        return facade.convertToUsage(node.getType(), JavaParserFactory.getContext(node, typeSolver));\n    }\n\n    @Override\n    public ResolvedType visit(ClassExpr node, Boolean solveLambdas) {\n        // This implementation does not regard the actual type argument of the ClassExpr.\n        Type astType = node.getType();\n        ResolvedType jssType = facade.convertToUsage(astType, node.getType());\n        return new ReferenceTypeImpl(new ReflectionClassDeclaration(Class.class, typeSolver), ImmutableList.of(jssType), typeSolver);\n    }\n\n    /*\n     * The conditional operator has three operand expressions. ? appears between the first and second expressions, and\n     * : appears between the second and third expressions.\n     * There are three kinds of conditional expressions, classified according to the second and third operand\n     * expressions: boolean conditional expressions, numeric conditional expressions, and reference conditional\n     * expressions.\n     * The classification rules are as follows:\n     * 1/ If both the second and the third operand expressions are boolean expressions, the conditional expression is a\n     * boolean conditional expression.\n     * 2/ If both the second and the third operand expressions are numeric expressions, the conditional expression is a\n     * numeric conditional expression.\n     * 3/ Otherwise, the conditional expression is a reference conditional expression\n     */\n    @Override\n    public ResolvedType visit(ConditionalExpr node, Boolean solveLambdas) {\n        ResolvedType thenExpr = node.getThenExpr().accept(this, solveLambdas);\n        ResolvedType elseExpr = node.getElseExpr().accept(this, solveLambdas);\n\n        ConditionalExprHandler rce = ConditionalExprResolver.getConditionExprHandler(thenExpr, elseExpr);\n        try {\n            return rce.resolveType();\n        } catch (UnsupportedOperationException e) {\n            // There is nothing to do because, for the moment, we want to run actual implementation\n        }\n        return node.getThenExpr().accept(this, solveLambdas);\n    }\n    \n    private boolean isCompatible(ResolvedType resolvedType, ResolvedPrimitiveType primitiveType) {\n        return (resolvedType.isPrimitive() && resolvedType.asPrimitive().equals(primitiveType))\n        || (resolvedType.isReferenceType() && resolvedType.asReferenceType().isUnboxableTo(primitiveType));\n    }\n\n    @Override\n    public ResolvedType visit(EnclosedExpr node, Boolean solveLambdas) {\n        return node.getInner().accept(this, solveLambdas);\n    }\n\n    /**\n     * Java Parser can't differentiate between packages, internal types, and fields.\n     * All three are lumped together into FieldAccessExpr. We need to differentiate them.\n     */\n    private ResolvedType solveDotExpressionType(ResolvedReferenceTypeDeclaration parentType, FieldAccessExpr node) {\n        // Fields and internal type declarations cannot have the same name.\n        // Thus, these checks will always be mutually exclusive.\n        if (parentType.isEnum() && parentType.asEnum().hasEnumConstant(node.getName().getId())) {\n            return parentType.asEnum().getEnumConstant(node.getName().getId()).getType();\n        } else if (parentType.hasField(node.getName().getId())) {\n            return parentType.getField(node.getName().getId()).getType();\n        } else if (parentType.hasInternalType(node.getName().getId())) {\n            return new ReferenceTypeImpl(parentType.getInternalType(node.getName().getId()), typeSolver);\n        } else {\n            throw new UnsolvedSymbolException(node.getName().getId());\n        }\n    }\n\n    @Override\n    public ResolvedType visit(FieldAccessExpr node, Boolean solveLambdas) {\n        // We should understand if this is a static access\n        if (node.getScope() instanceof NameExpr ||\n                node.getScope() instanceof FieldAccessExpr) {\n            Expression staticValue = node.getScope();\n            SymbolReference<ResolvedTypeDeclaration> typeAccessedStatically = JavaParserFactory.getContext(node, typeSolver).solveType(staticValue.toString());\n            if (typeAccessedStatically.isSolved()) {\n                // TODO here maybe we have to substitute type typeParametersValues\n                return solveDotExpressionType(\n                        typeAccessedStatically.getCorrespondingDeclaration().asReferenceType(), node);\n            }\n        } else if (node.getScope() instanceof ThisExpr) {\n            // If we are accessing through a 'this' expression, first resolve the type\n            // corresponding to 'this'\n            SymbolReference<ResolvedTypeDeclaration> solve = facade.solve((ThisExpr) node.getScope());\n            // If found get it's declaration and get the field in there\n            if (solve.isSolved()) {\n                ResolvedTypeDeclaration correspondingDeclaration = solve.getCorrespondingDeclaration();\n                if (correspondingDeclaration instanceof ResolvedReferenceTypeDeclaration) {\n                    return solveDotExpressionType(correspondingDeclaration.asReferenceType(), node);\n                }\n            }\n\n        } else if (node.getScope().toString().indexOf('.') > 0) {\n            // try to find fully qualified name\n            SymbolReference<ResolvedReferenceTypeDeclaration> sr = typeSolver.tryToSolveType(node.getScope().toString());\n            if (sr.isSolved()) {\n                return solveDotExpressionType(sr.getCorrespondingDeclaration(), node);\n            }\n        }\n        Optional<Value> value = Optional.empty();\n        try {\n            value = createSolver().solveSymbolAsValue(node.getName().getId(), node);\n        } catch (UnsolvedSymbolException use) {\n            // This node may have a package name as part of its fully qualified name.\n            // We should solve for the type declaration inside this package.\n            SymbolReference<ResolvedReferenceTypeDeclaration> sref = typeSolver.tryToSolveType(node.toString());\n            if (sref.isSolved()) {\n                return new ReferenceTypeImpl(sref.getCorrespondingDeclaration(), typeSolver);\n            }\n        }\n        if (value.isPresent()) {\n            return value.get().getType();\n        }\n        throw new UnsolvedSymbolException(node.getName().getId());\n    }\n\n    @Override\n    public ResolvedType visit(InstanceOfExpr node, Boolean solveLambdas) {\n        return ResolvedPrimitiveType.BOOLEAN;\n    }\n\n    @Override\n    public ResolvedType visit(StringLiteralExpr node, Boolean solveLambdas) {\n        return stringReferenceType;\n    }\n\n    @Override\n    public ResolvedType visit(IntegerLiteralExpr node, Boolean solveLambdas) {\n        return ResolvedPrimitiveType.INT;\n    }\n\n    @Override\n    public ResolvedType visit(LongLiteralExpr node, Boolean solveLambdas) {\n        return ResolvedPrimitiveType.LONG;\n    }\n\n    @Override\n    public ResolvedType visit(CharLiteralExpr node, Boolean solveLambdas) {\n        return ResolvedPrimitiveType.CHAR;\n    }\n\n    @Override\n    public ResolvedType visit(DoubleLiteralExpr node, Boolean solveLambdas) {\n        if (node.getValue().toLowerCase().endsWith(\"f\")) {\n            return ResolvedPrimitiveType.FLOAT;\n        }\n        return ResolvedPrimitiveType.DOUBLE;\n    }\n\n    @Override\n    public ResolvedType visit(BooleanLiteralExpr node, Boolean solveLambdas) {\n        return ResolvedPrimitiveType.BOOLEAN;\n    }\n\n    @Override\n    public ResolvedType visit(NullLiteralExpr node, Boolean solveLambdas) {\n        return NullType.INSTANCE;\n    }\n\n    @Override\n    public ResolvedType visit(MethodCallExpr node, Boolean solveLambdas) {\n        Log.trace(\"getType on method call %s\", ()-> node);\n        // first solve the method\n        MethodUsage ref = facade.solveMethodAsUsage(node);\n        Log.trace(\"getType on method call %s resolved to %s\", ()-> node, ()-> ref);\n        Log.trace(\"getType on method call %s return type is %s\", ()-> node, ref::returnType);\n        return ref.returnType();\n        // the type is the return type of the method\n    }\n\n    @Override\n    public ResolvedType visit(NameExpr node, Boolean solveLambdas) {\n        Log.trace(\"getType on name expr %s\", ()-> node);\n        Optional<Value> value = createSolver().solveSymbolAsValue(node.getName().getId(), node);\n        if (!value.isPresent()) {\n            throw new UnsolvedSymbolException(\"Solving \" + node, node.getName().getId());\n        } else {\n            return value.get().getType();\n        }\n    }\n\n    @Override\n    public ResolvedType visit(TypeExpr node, Boolean solveLambdas) {\n        Log.trace(\"getType on type expr %s\", ()-> node);\n        if (!(node.getType() instanceof ClassOrInterfaceType)) {\n            throw new UnsupportedOperationException(node.getType().getClass().getCanonicalName());\n        }\n\n        ClassOrInterfaceType classOrInterfaceType = (ClassOrInterfaceType) node.getType();\n        String nameWithScope = classOrInterfaceType.getNameWithScope();\n\n        // JLS 15.13 - ReferenceType :: [TypeArguments] Identifier\n        SymbolReference<ResolvedTypeDeclaration> typeDeclarationSymbolReference = JavaParserFactory\n                .getContext(classOrInterfaceType, typeSolver)\n                .solveType(nameWithScope);\n        if (typeDeclarationSymbolReference.isSolved()) {\n            return new ReferenceTypeImpl(typeDeclarationSymbolReference.getCorrespondingDeclaration().asReferenceType(), typeSolver);\n        }\n\n        // JLS 15.13 - ExpressionName :: [TypeArguments] Identifier\n        Optional<Value> value = createSolver().solveSymbolAsValue(nameWithScope, node);\n        if (value.isPresent()) {\n            return value.get().getType();\n        }\n\n        throw new UnsolvedSymbolException(\"Solving \" + node, classOrInterfaceType.getName().getId());\n    }\n\n    @Override\n    public ResolvedType visit(ObjectCreationExpr node, Boolean solveLambdas) {\n        return facade.convertToUsage(node.getType(), node);\n    }\n\n    @Override\n    public ResolvedType visit(ThisExpr node, Boolean solveLambdas) {\n        // If 'this' is prefixed by a class eg. MyClass.this\n        if (node.getTypeName().isPresent()) {\n            // Get the class name\n            String className = node.getTypeName().get().asString();\n            // Attempt to resolve locally in Compilation unit\n            // first try a buttom/up approach\n            try {\n                return new ReferenceTypeImpl(\n                        facade.getTypeDeclaration(facade.findContainingTypeDeclOrObjectCreationExpr(node, className)),\n                        typeSolver);\n            } catch (IllegalStateException e) {\n                // trying another approach from type solver\n                Optional<CompilationUnit> cu = node.findAncestor(CompilationUnit.class);\n                SymbolReference<ResolvedReferenceTypeDeclaration> clazz = typeSolver.tryToSolveType(className);\n                if (clazz.isSolved()) {\n                    return new ReferenceTypeImpl(clazz.getCorrespondingDeclaration(), typeSolver);\n                }\n            }\n        }\n        return new ReferenceTypeImpl(facade.getTypeDeclaration(facade.findContainingTypeDeclOrObjectCreationExpr(node)), typeSolver);\n    }\n\n    @Override\n    public ResolvedType visit(SuperExpr node, Boolean solveLambdas) {\n        // If 'super' is prefixed by a class eg. MyClass.this\n        if (node.getTypeName().isPresent()) {\n            String className = node.getTypeName().get().asString();\n            SymbolReference<ResolvedTypeDeclaration> resolvedTypeNameRef = JavaParserFactory.getContext(node, typeSolver).solveType(className);\n            if (resolvedTypeNameRef.isSolved()) {\n                // Cfr JLS $15.12.1\n                ResolvedTypeDeclaration resolvedTypeName = resolvedTypeNameRef.getCorrespondingDeclaration();\n                if (resolvedTypeName.isInterface()) {\n                    return new ReferenceTypeImpl(resolvedTypeName.asInterface(), typeSolver);\n                } else if (resolvedTypeName.isClass()) {\n                    // TODO: Maybe include a presence check? e.g. in the case of `java.lang.Object` there will be no superclass.\n                    return resolvedTypeName.asClass().getSuperClass().orElseThrow(() -> new RuntimeException(\"super class unexpectedly empty\"));\n                } else {\n                    throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n                }\n            } else {\n                throw new UnsolvedSymbolException(className);\n            }\n        }\n\n        ResolvedTypeDeclaration typeOfNode = facade.getTypeDeclaration(facade.findContainingTypeDeclOrObjectCreationExpr(node));\n        if (typeOfNode instanceof ResolvedClassDeclaration) {\n            // TODO: Maybe include a presence check? e.g. in the case of `java.lang.Object` there will be no superclass.\n            return ((ResolvedClassDeclaration) typeOfNode).getSuperClass().orElseThrow(() -> new RuntimeException(\"super class unexpectedly empty\"));\n        } else {\n            throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n        }\n    }\n\n    @Override\n    public ResolvedType visit(UnaryExpr node, Boolean solveLambdas) {\n        switch (node.getOperator()) {\n            case MINUS:\n            case PLUS:\n                return ResolvedPrimitiveType.unp(node.getExpression().accept(this, solveLambdas));\n            case LOGICAL_COMPLEMENT:\n                return ResolvedPrimitiveType.BOOLEAN;\n            case POSTFIX_DECREMENT:\n            case PREFIX_DECREMENT:\n            case POSTFIX_INCREMENT:\n            case PREFIX_INCREMENT:\n            case BITWISE_COMPLEMENT:\n                return node.getExpression().accept(this, solveLambdas);\n            default:\n                throw new UnsupportedOperationException(node.getOperator().name());\n        }\n    }\n\n    @Override\n    public ResolvedType visit(VariableDeclarationExpr node, Boolean solveLambdas) {\n        if (node.getVariables().size() != 1) {\n            throw new UnsupportedOperationException();\n        }\n        return facade.convertToUsageVariableType(node.getVariables().get(0));\n    }\n\n\n    @Override\n    public ResolvedType visit(LambdaExpr node, Boolean solveLambdas) {\n        if (demandParentNode(node) instanceof MethodCallExpr) {\n            MethodCallExpr callExpr = (MethodCallExpr) demandParentNode(node);\n            int pos = JavaParserSymbolDeclaration.getParamPos(node);\n            SymbolReference<ResolvedMethodDeclaration> refMethod = facade.solve(callExpr);\n            if (!refMethod.isSolved()) {\n                throw new UnsolvedSymbolException(demandParentNode(node).toString(), callExpr.getName().getId());\n            }\n            Log.trace(\"getType on lambda expr %s\", ()-> refMethod.getCorrespondingDeclaration().getName());\n\n            // The type parameter referred here should be the java.util.stream.Stream.T\n            ResolvedType result = refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n\n            if (solveLambdas) {\n                if (callExpr.hasScope()) {\n                    Expression scope = callExpr.getScope().get();\n\n                    // If it is a static call we should not try to get the type of the scope\n                    boolean staticCall = false;\n                    if (scope instanceof NameExpr) {\n                        NameExpr nameExpr = (NameExpr) scope;\n                        try {\n                            SymbolReference<ResolvedTypeDeclaration> type = JavaParserFactory.getContext(nameExpr, typeSolver).solveType(nameExpr.getName().getId());\n                            if (type.isSolved()) {\n                                staticCall = true;\n                            }\n                        } catch (Exception e) {\n\n                        }\n                    }\n\n                    if (!staticCall) {\n                        ResolvedType scopeType = facade.getType(scope);\n                        if (scopeType.isReferenceType()) {\n                            result = scopeType.asReferenceType().useThisTypeParametersOnTheGivenType(result);\n                        }\n                    }\n                }\n\n                result = resolveLambda(node, result);\n            }\n            return result;\n        } else if (demandParentNode(node) instanceof VariableDeclarator)\n        {\n            VariableDeclarator decExpr = (VariableDeclarator) demandParentNode(node);\n            ResolvedType result = decExpr.getType().resolve();\n\n            if (solveLambdas) {\n                result = resolveLambda(node, result);\n            }\n            return result;\n        } else if (demandParentNode(node) instanceof AssignExpr) {\n            AssignExpr assExpr = (AssignExpr) demandParentNode(node);\n            ResolvedType result = assExpr.calculateResolvedType();\n\n            if (solveLambdas) {\n                result = resolveLambda(node, result);\n            }\n            return result;\n        } else {\n            throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n        }\n    }\n\n    private ResolvedType resolveLambda(LambdaExpr node, ResolvedType result) {\n        // We need to replace the type variables\n        Context ctx = JavaParserFactory.getContext(node, typeSolver);\n        result = solveGenericTypes(result, ctx);\n\n        //We should find out which is the functional method (e.g., apply) and replace the params of the\n        //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n        //lambdas\n        Optional<MethodUsage> functionalMethod = FunctionalInterfaceLogic.getFunctionalMethod(result);\n        if (functionalMethod.isPresent()) {\n            LambdaExpr lambdaExpr = node;\n\n            InferenceContext lambdaCtx = new InferenceContext(MyObjectProvider.INSTANCE);\n            InferenceContext funcInterfaceCtx = new InferenceContext(MyObjectProvider.INSTANCE);\n\n            // At this point parameterType\n            // if Function<T=? super Stream.T, ? extends map.R>\n            // we should replace Stream.T\n            ResolvedType functionalInterfaceType = ReferenceTypeImpl.undeterminedParameters(functionalMethod.get().getDeclaration().declaringType(), typeSolver);\n\n            lambdaCtx.addPair(result, functionalInterfaceType);\n\n            ResolvedType actualType;\n\n            if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                actualType = facade.getType(((ExpressionStmt) lambdaExpr.getBody()).getExpression());\n            } else if (lambdaExpr.getBody() instanceof BlockStmt) {\n                BlockStmt blockStmt = (BlockStmt) lambdaExpr.getBody();\n\n                // Get all the return statements in the lambda block\n                List<ReturnStmt> returnStmts = blockStmt.findAll(ReturnStmt.class);\n\n                if (returnStmts.size() > 0) {\n                    actualType = returnStmts.stream()\n                            .map(returnStmt -> returnStmt.getExpression().map(e -> facade.getType(e)).orElse(ResolvedVoidType.INSTANCE))\n                            .filter(x -> x != null && !x.isVoid() && !x.isNull())\n                            .findFirst()\n                            .orElse(ResolvedVoidType.INSTANCE);\n\n                } else {\n                    actualType = ResolvedVoidType.INSTANCE;\n                }\n\n\n            } else {\n                throw new UnsupportedOperationException();\n            }\n\n            ResolvedType formalType = functionalMethod.get().returnType();\n\n            // Infer the functional interfaces' return vs actual type\n            funcInterfaceCtx.addPair(formalType, actualType);\n            // Substitute to obtain a new type\n            ResolvedType functionalTypeWithReturn = funcInterfaceCtx.resolve(funcInterfaceCtx.addSingle(functionalInterfaceType));\n\n            // if the functional method returns void anyway\n            // we don't need to bother inferring types\n            if (!(formalType instanceof ResolvedVoidType)) {\n                lambdaCtx.addPair(result, functionalTypeWithReturn);\n                result = lambdaCtx.resolve(lambdaCtx.addSingle(result));\n            }\n        }\n        return result;\n    }\n\n    @Override\n    public ResolvedType visit(MethodReferenceExpr node, Boolean solveLambdas) {\n        if (demandParentNode(node) instanceof MethodCallExpr) {\n            MethodCallExpr callExpr = (MethodCallExpr) demandParentNode(node);\n            int pos = JavaParserSymbolDeclaration.getParamPos(node);\n            SymbolReference<ResolvedMethodDeclaration> refMethod = facade.solve(callExpr, false);\n            if (!refMethod.isSolved()) {\n                throw new UnsolvedSymbolException(demandParentNode(node).toString(), callExpr.getName().getId());\n            }\n            Log.trace(\"getType on method reference expr %s\", ()-> refMethod.getCorrespondingDeclaration().getName());\n            if (solveLambdas) {\n                MethodUsage usage = facade.solveMethodAsUsage(callExpr);\n                ResolvedType result = usage.getParamType(pos);\n                // We need to replace the type variables\n                Context ctx = JavaParserFactory.getContext(node, typeSolver);\n                result = solveGenericTypes(result, ctx);\n\n                //We should find out which is the functional method (e.g., apply) and replace the params of the\n                //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                //lambdas\n                Optional<MethodUsage> functionalMethodOpt = FunctionalInterfaceLogic.getFunctionalMethod(result);\n                if (functionalMethodOpt.isPresent()) {\n                    MethodUsage functionalMethod = functionalMethodOpt.get();\n\n                    for (Pair<ResolvedTypeParameterDeclaration, ResolvedType> typeParamDecl : result.asReferenceType().getTypeParametersMap()) {\n                        functionalMethod = functionalMethod.replaceTypeParameter(typeParamDecl.a, typeParamDecl.b);\n                    }\n\n                    // replace wildcards\n                    for (int i = 0; i < functionalMethod.getNoParams(); i++) {\n                        ResolvedType type = functionalMethod.getParamType(i);\n                        if (type.isWildcard()) {\n                            ResolvedType boundedType = type.asWildcard().getBoundedType();\n                            functionalMethod = functionalMethod.replaceParamType(i, boundedType);\n                        }\n                    }\n\n                    ResolvedType actualType = facade.toMethodUsage(node, functionalMethod.getParamTypes()).returnType();\n                    ResolvedType formalType = functionalMethod.returnType();\n\n                    InferenceContext inferenceContext = new InferenceContext(MyObjectProvider.INSTANCE);\n                    inferenceContext.addPair(formalType, actualType);\n                    result = inferenceContext.resolve(inferenceContext.addSingle(result));\n                }\n\n                return result;\n            }\n            return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n        }\n        throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n    }\n\n    @Override\n    public ResolvedType visit(FieldDeclaration node, Boolean solveLambdas) {\n        if (node.getVariables().size() == 1) {\n            return node.getVariables().get(0).accept(this, solveLambdas);\n        }\n        throw new IllegalArgumentException(\"Cannot resolve the type of a field with multiple variable declarations. Pick one\");\n    }\n\n    protected SymbolSolver createSolver() {\n        return new SymbolSolver(typeSolver);\n    }\n}\n",
        "diffSourceCodeSet": [
            "protected SymbolSolver createSolver() {\n        return new SymbolSolver(typeSolver);\n    }"
        ],
        "invokedMethodSet": [
            "methodSignature: com.github.javaparser.symbolsolver.javaparsermodel.TypeExtractor#solveDotExpressionType\n methodBody: private ResolvedType solveDotExpressionType(ResolvedReferenceTypeDeclaration parentType, FieldAccessExpr node) {\nif(parentType.isEnum() && parentType.asEnum().hasEnumConstant(node.getName().getId())){return parentType.asEnum().getEnumConstant(node.getName().getId()).getType();\n}if(parentType.hasField(node.getName().getId())){return parentType.getField(node.getName().getId()).getType();\n}if(parentType.hasInternalType(node.getName().getId())){return new ReferenceTypeImpl(parentType.getInternalType(node.getName().getId()),typeSolver);\n}{throw new UnsolvedSymbolException(node.getName().getId());\n}}"
        ],
        "sourceCodeAfterRefactoring": "@Override\n    public ResolvedType visit(FieldAccessExpr node, Boolean solveLambdas) {\n        // We should understand if this is a static access\n        if (node.getScope() instanceof NameExpr ||\n                node.getScope() instanceof FieldAccessExpr) {\n            Expression staticValue = node.getScope();\n            SymbolReference<ResolvedTypeDeclaration> typeAccessedStatically = JavaParserFactory.getContext(node, typeSolver).solveType(staticValue.toString());\n            if (typeAccessedStatically.isSolved()) {\n                // TODO here maybe we have to substitute type typeParametersValues\n                return solveDotExpressionType(\n                        typeAccessedStatically.getCorrespondingDeclaration().asReferenceType(), node);\n            }\n        } else if (node.getScope() instanceof ThisExpr) {\n            // If we are accessing through a 'this' expression, first resolve the type\n            // corresponding to 'this'\n            SymbolReference<ResolvedTypeDeclaration> solve = facade.solve((ThisExpr) node.getScope());\n            // If found get it's declaration and get the field in there\n            if (solve.isSolved()) {\n                ResolvedTypeDeclaration correspondingDeclaration = solve.getCorrespondingDeclaration();\n                if (correspondingDeclaration instanceof ResolvedReferenceTypeDeclaration) {\n                    return solveDotExpressionType(correspondingDeclaration.asReferenceType(), node);\n                }\n            }\n\n        } else if (node.getScope().toString().indexOf('.') > 0) {\n            // try to find fully qualified name\n            SymbolReference<ResolvedReferenceTypeDeclaration> sr = typeSolver.tryToSolveType(node.getScope().toString());\n            if (sr.isSolved()) {\n                return solveDotExpressionType(sr.getCorrespondingDeclaration(), node);\n            }\n        }\n        Optional<Value> value = Optional.empty();\n        try {\n            value = createSolver().solveSymbolAsValue(node.getName().getId(), node);\n        } catch (UnsolvedSymbolException use) {\n            // This node may have a package name as part of its fully qualified name.\n            // We should solve for the type declaration inside this package.\n            SymbolReference<ResolvedReferenceTypeDeclaration> sref = typeSolver.tryToSolveType(node.toString());\n            if (sref.isSolved()) {\n                return new ReferenceTypeImpl(sref.getCorrespondingDeclaration(), typeSolver);\n            }\n        }\n        if (value.isPresent()) {\n            return value.get().getType();\n        }\n        throw new UnsolvedSymbolException(node.getName().getId());\n    }\nprotected SymbolSolver createSolver() {\n        return new SymbolSolver(typeSolver);\n    }",
        "diffSourceCode": "   234:     @Override\n   235:     public ResolvedType visit(FieldAccessExpr node, Boolean solveLambdas) {\n   236:         // We should understand if this is a static access\n   237:         if (node.getScope() instanceof NameExpr ||\n   238:                 node.getScope() instanceof FieldAccessExpr) {\n   239:             Expression staticValue = node.getScope();\n   240:             SymbolReference<ResolvedTypeDeclaration> typeAccessedStatically = JavaParserFactory.getContext(node, typeSolver).solveType(staticValue.toString());\n   241:             if (typeAccessedStatically.isSolved()) {\n   242:                 // TODO here maybe we have to substitute type typeParametersValues\n   243:                 return solveDotExpressionType(\n   244:                         typeAccessedStatically.getCorrespondingDeclaration().asReferenceType(), node);\n   245:             }\n   246:         } else if (node.getScope() instanceof ThisExpr) {\n   247:             // If we are accessing through a 'this' expression, first resolve the type\n   248:             // corresponding to 'this'\n   249:             SymbolReference<ResolvedTypeDeclaration> solve = facade.solve((ThisExpr) node.getScope());\n   250:             // If found get it's declaration and get the field in there\n   251:             if (solve.isSolved()) {\n   252:                 ResolvedTypeDeclaration correspondingDeclaration = solve.getCorrespondingDeclaration();\n   253:                 if (correspondingDeclaration instanceof ResolvedReferenceTypeDeclaration) {\n   254:                     return solveDotExpressionType(correspondingDeclaration.asReferenceType(), node);\n   255:                 }\n   256:             }\n   257: \n   258:         } else if (node.getScope().toString().indexOf('.') > 0) {\n   259:             // try to find fully qualified name\n   260:             SymbolReference<ResolvedReferenceTypeDeclaration> sr = typeSolver.tryToSolveType(node.getScope().toString());\n   261:             if (sr.isSolved()) {\n   262:                 return solveDotExpressionType(sr.getCorrespondingDeclaration(), node);\n   263:             }\n   264:         }\n   265:         Optional<Value> value = Optional.empty();\n   266:         try {\n-  267:             value = new SymbolSolver(typeSolver).solveSymbolAsValue(node.getName().getId(), node);\n+  267:             value = createSolver().solveSymbolAsValue(node.getName().getId(), node);\n   268:         } catch (UnsolvedSymbolException use) {\n   269:             // This node may have a package name as part of its fully qualified name.\n   270:             // We should solve for the type declaration inside this package.\n   271:             SymbolReference<ResolvedReferenceTypeDeclaration> sref = typeSolver.tryToSolveType(node.toString());\n   272:             if (sref.isSolved()) {\n   273:                 return new ReferenceTypeImpl(sref.getCorrespondingDeclaration(), typeSolver);\n   274:             }\n   275:         }\n   276:         if (value.isPresent()) {\n   277:             return value.get().getType();\n   278:         }\n   279:         throw new UnsolvedSymbolException(node.getName().getId());\n   280:     }\n+  652:     protected SymbolSolver createSolver() {\n+  653:         return new SymbolSolver(typeSolver);\n+  654:     }\n",
        "uniqueId": "b22ebb29abb4e6dcc1d22ca9823e5b2a3473b6a8_234_280_652_654_234_280",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 5,
                "covered": 15
            },
            "BRANCH": {
                "missed": 1,
                "covered": 1
            },
            "LINE": {
                "missed": 1,
                "covered": 2
            },
            "COMPLEXITY": {
                "missed": 1,
                "covered": 1
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 17
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprivate getNewLineToken(lineSeparator LineSeparator) : CsmElement extracted from private replaceEolTokens(differenceElements List<DifferenceElement>, lineSeparator LineSeparator) : void in class com.github.javaparser.printer.lexicalpreservation.LexicalDifferenceCalculator",
        "diffLocations": [
            {
                "filePath": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/LexicalDifferenceCalculator.java",
                "startLine": 147,
                "endLine": 158,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/LexicalDifferenceCalculator.java",
                "startLine": 150,
                "endLine": 156,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/LexicalDifferenceCalculator.java",
                "startLine": 161,
                "endLine": 163,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "private void replaceEolTokens(List<DifferenceElement> differenceElements, LineSeparator lineSeparator) {\n        for (int i = 0; i < differenceElements.size(); i++) {\n            DifferenceElement differenceElement = differenceElements.get(i);\n            if (differenceElement.isAdded()) {\n                CsmElement element = differenceElement.getElement();\n                boolean isWhitespaceToken = element instanceof CsmToken && ((CsmToken) element).isNewLine();\n                if (isWhitespaceToken) {\n                    differenceElements.set(i, new Added(CsmElement.newline(lineSeparator)));\n                }\n            }\n        }\n    }",
        "filePathBefore": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/LexicalDifferenceCalculator.java",
        "isPureRefactoring": true,
        "commitId": "ed79beb63e87f3a58322aee34b1a2e80cfafbd18",
        "packageNameBefore": "com.github.javaparser.printer.lexicalpreservation",
        "classNameBefore": "com.github.javaparser.printer.lexicalpreservation.LexicalDifferenceCalculator",
        "methodNameBefore": "com.github.javaparser.printer.lexicalpreservation.LexicalDifferenceCalculator#replaceEolTokens",
        "invokedMethod": "methodSignature: com.github.javaparser.printer.lexicalpreservation.Reshuffled#getElement\n methodBody: public CsmMix getElement() {\nreturn nextOrder;\n}\nmethodSignature: com.github.javaparser.printer.lexicalpreservation.Added#isAdded\n methodBody: public boolean isAdded() {\nreturn true;\n}\nmethodSignature: com.github.javaparser.printer.lexicalpreservation.DifferenceElement#getElement\n methodBody: CsmElement getElement();\nmethodSignature: com.github.javaparser.printer.lexicalpreservation.DifferenceElement#isAdded\n methodBody: boolean isAdded();\nmethodSignature: com.github.javaparser.printer.lexicalpreservation.Reshuffled#isAdded\n methodBody: public boolean isAdded() {\nreturn false;\n}\nmethodSignature: com.github.javaparser.printer.lexicalpreservation.Added#getElement\n methodBody: public CsmElement getElement() {\nreturn element;\n}",
        "classSignatureBefore": "class LexicalDifferenceCalculator ",
        "methodNameBeforeSet": [
            "com.github.javaparser.printer.lexicalpreservation.LexicalDifferenceCalculator#replaceEolTokens"
        ],
        "classNameBeforeSet": [
            "com.github.javaparser.printer.lexicalpreservation.LexicalDifferenceCalculator"
        ],
        "classSignatureBeforeSet": [
            "class LexicalDifferenceCalculator "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Copyright (C) 2007-2010 J\u00falio Vilmar Gesser.\n * Copyright (C) 2011, 2013-2021 The JavaParser Team.\n *\n * This file is part of JavaParser.\n *\n * JavaParser can be used either under the terms of\n * a) the GNU Lesser General Public License as published by\n *     the Free Software Foundation, either version 3 of the License, or\n *     (at your option) any later version.\n * b) the terms of the Apache License\n *\n * You should have received a copy of both licenses in LICENCE.LGPL and\n * LICENCE.APACHE. Please refer to those files for details.\n *\n * JavaParser is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n */\n\npackage com.github.javaparser.printer.lexicalpreservation;\n\nimport com.github.javaparser.GeneratedJavaParserConstants;\nimport com.github.javaparser.ast.Modifier;\nimport com.github.javaparser.ast.Node;\nimport com.github.javaparser.ast.NodeList;\nimport com.github.javaparser.ast.expr.CharLiteralExpr;\nimport com.github.javaparser.ast.expr.StringLiteralExpr;\nimport com.github.javaparser.ast.expr.TextBlockLiteralExpr;\nimport com.github.javaparser.ast.observer.ObservableProperty;\nimport com.github.javaparser.ast.stmt.ExpressionStmt;\nimport com.github.javaparser.printer.ConcreteSyntaxModel;\nimport com.github.javaparser.printer.Stringable;\nimport com.github.javaparser.printer.SourcePrinter;\nimport com.github.javaparser.printer.concretesyntaxmodel.*;\nimport com.github.javaparser.printer.lexicalpreservation.changes.Change;\nimport com.github.javaparser.printer.lexicalpreservation.changes.ListAdditionChange;\nimport com.github.javaparser.printer.lexicalpreservation.changes.ListRemovalChange;\nimport com.github.javaparser.printer.lexicalpreservation.changes.ListReplacementChange;\nimport com.github.javaparser.printer.lexicalpreservation.changes.NoChange;\nimport com.github.javaparser.printer.lexicalpreservation.changes.PropertyChange;\nimport com.github.javaparser.utils.LineSeparator;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Optional;\n\nimport static com.github.javaparser.TokenTypes.eolTokenKind;\n\nclass LexicalDifferenceCalculator {\n\n    /**\n     * The ConcreteSyntaxModel represents the general format. This model is a calculated version of the ConcreteSyntaxModel,\n     * with no condition, no lists, just tokens and node children.\n     */\n    static class CalculatedSyntaxModel {\n        final List<CsmElement> elements;\n\n        CalculatedSyntaxModel(List<CsmElement> elements) {\n            this.elements = elements;\n        }\n\n        public CalculatedSyntaxModel from(int index) {\n            return new CalculatedSyntaxModel(new ArrayList<>(elements.subList(index, elements.size())));\n        }\n\n        @Override\n        public String toString() {\n            return \"CalculatedSyntaxModel{\" +\n                    \"elements=\" + elements +\n                    '}';\n        }\n\n        CalculatedSyntaxModel sub(int start, int end) {\n            return new CalculatedSyntaxModel(elements.subList(start, end));\n        }\n\n        void removeIndentationElements() {\n            elements.removeIf(el -> el instanceof CsmIndent || el instanceof CsmUnindent);\n        }\n    }\n\n    static class CsmChild implements CsmElement {\n        private final Node child;\n\n        public Node getChild() {\n            return child;\n        }\n\n        CsmChild(Node child) {\n            this.child = child;\n        }\n\n        @Override\n        public void prettyPrint(Node node, SourcePrinter printer) {\n            throw new UnsupportedOperationException();\n        }\n\n        @Override\n        public String toString() {\n            return \"child(\" + child.getClass().getSimpleName()+\")\";\n        }\n\n        @Override\n        public boolean equals(Object o) {\n            if (this == o) return true;\n            if (o == null || getClass() != o.getClass()) return false;\n\n            CsmChild csmChild = (CsmChild) o;\n\n            return child.equals(csmChild.child);\n        }\n\n        @Override\n        public int hashCode() {\n            return child.hashCode();\n        }\n    }\n\n    List<DifferenceElement> calculateListRemovalDifference(ObservableProperty observableProperty, NodeList<?> nodeList, int index) {\n        Node container = nodeList.getParentNodeForChildren();\n        CsmElement element = ConcreteSyntaxModel.forClass(container.getClass());\n        CalculatedSyntaxModel original = calculatedSyntaxModelForNode(element, container);\n        CalculatedSyntaxModel after = calculatedSyntaxModelAfterListRemoval(element, observableProperty, nodeList, index);\n        return DifferenceElementCalculator.calculate(original, after);\n    }\n\n    List<DifferenceElement> calculateListAdditionDifference(ObservableProperty observableProperty, NodeList<?> nodeList, int index, Node nodeAdded) {\n        Node container = nodeList.getParentNodeForChildren();\n        CsmElement element = ConcreteSyntaxModel.forClass(container.getClass());\n        CalculatedSyntaxModel original = calculatedSyntaxModelForNode(element, container);\n        CalculatedSyntaxModel after = calculatedSyntaxModelAfterListAddition(element, observableProperty, nodeList, index, nodeAdded);\n\n        List<DifferenceElement> differenceElements = DifferenceElementCalculator.calculate(original, after);\n\n        // Set the line separator character tokens\n        LineSeparator lineSeparator = container.getLineEndingStyleOrDefault(LineSeparator.SYSTEM);\n        replaceEolTokens(differenceElements, lineSeparator);\n\n        return differenceElements;\n    }\n\n    private void replaceEolTokens(List<DifferenceElement> differenceElements, LineSeparator lineSeparator) {\n        for (int i = 0; i < differenceElements.size(); i++) {\n            DifferenceElement differenceElement = differenceElements.get(i);\n            if (differenceElement.isAdded()) {\n                CsmElement element = differenceElement.getElement();\n                boolean isWhitespaceToken = element instanceof CsmToken && ((CsmToken) element).isNewLine();\n                if (isWhitespaceToken) {\n                    differenceElements.set(i, new Added(CsmElement.newline(lineSeparator)));\n                }\n            }\n        }\n    }\n\n    List<DifferenceElement> calculateListReplacementDifference(ObservableProperty observableProperty, NodeList<?> nodeList, int index, Node newValue) {\n        Node container = nodeList.getParentNodeForChildren();\n        CsmElement element = ConcreteSyntaxModel.forClass(container.getClass());\n        CalculatedSyntaxModel original = calculatedSyntaxModelForNode(element, container);\n        CalculatedSyntaxModel after = calculatedSyntaxModelAfterListReplacement(element, observableProperty, nodeList, index, newValue);\n        return DifferenceElementCalculator.calculate(original, after);\n    }\n\n    void calculatePropertyChange(NodeText nodeText, Node observedNode, ObservableProperty property, Object oldValue, Object newValue) {\n        if (nodeText == null) {\n            throw new NullPointerException();\n        }\n        CsmElement element = ConcreteSyntaxModel.forClass(observedNode.getClass());\n        CalculatedSyntaxModel original = calculatedSyntaxModelForNode(element, observedNode);\n        CalculatedSyntaxModel after = calculatedSyntaxModelAfterPropertyChange(element, observedNode, property, oldValue, newValue);\n        List<DifferenceElement> differenceElements = DifferenceElementCalculator.calculate(original, after);\n        Difference difference = new Difference(differenceElements, nodeText, observedNode);\n        difference.apply();\n    }\n\n    // Visible for testing\n    CalculatedSyntaxModel calculatedSyntaxModelForNode(CsmElement csm, Node node) {\n        List<CsmElement> elements = new LinkedList<>();\n        calculatedSyntaxModelForNode(csm, node, elements, new NoChange());\n        return new CalculatedSyntaxModel(elements);\n    }\n\n    CalculatedSyntaxModel calculatedSyntaxModelForNode(Node node) {\n        return calculatedSyntaxModelForNode(ConcreteSyntaxModel.forClass(node.getClass()), node);\n    }\n\n    private void calculatedSyntaxModelForNode(CsmElement csm, Node node, List<CsmElement> elements, Change change) {\n        if (csm instanceof CsmSequence) {\n            CsmSequence csmSequence = (CsmSequence) csm;\n            csmSequence.getElements().forEach(e -> calculatedSyntaxModelForNode(e, node, elements, change));\n        } else if (csm instanceof CsmComment) {\n            // nothing to do\n        } else if (csm instanceof CsmSingleReference) {\n            CsmSingleReference csmSingleReference = (CsmSingleReference)csm;\n            Node child;\n            if (change instanceof PropertyChange && ((PropertyChange)change).getProperty() == csmSingleReference.getProperty()) {\n                child = (Node)((PropertyChange)change).getNewValue();\n            } else {\n                child = csmSingleReference.getProperty().getValueAsSingleReference(node);\n            }\n            if (child != null) {\n                // fix issue #2374\n                // Add node comment if needed (it's not very elegant but it works)\n                // We need to be sure that the node is an ExpressionStmt because we can meet\n                // this class definition\n                // a line comment <This is my class, with my comment> followed by\n                // class A {}\n                // In this case keyworld [class] is considered as a token and [A] is a child element\n                // So if we don't care that the node is an ExpressionStmt we could try to generate a wrong definition\n                // like this [class // This is my class, with my comment A {}]\n                if (node.getComment().isPresent() && node instanceof ExpressionStmt) {\n                    LineSeparator lineSeparator = node.getLineEndingStyleOrDefault(LineSeparator.SYSTEM);\n                    elements.add(new CsmChild(node.getComment().get()));\n                    elements.add(new CsmToken(eolTokenKind(lineSeparator), lineSeparator.asRawString()));\n                }\n                elements.add(new CsmChild(child));\n            }\n        } else if (csm instanceof CsmNone) {\n            // nothing to do\n        } else if (csm instanceof CsmToken) {\n            elements.add(csm);\n        } else if (csm instanceof CsmOrphanCommentsEnding) {\n            // nothing to do\n        } else if (csm instanceof CsmList) {\n            CsmList csmList = (CsmList) csm;\n            if (csmList.getProperty().isAboutNodes()) {\n                Object rawValue = change.getValue(csmList.getProperty(), node);\n                NodeList<?> nodeList;\n                if (rawValue instanceof Optional) {\n                    Optional<?> optional = (Optional<?>)rawValue;\n                    if (optional.isPresent()) {\n                        if (!(optional.get() instanceof NodeList)) {\n                            throw new IllegalStateException(\"Expected NodeList, found \" + optional.get().getClass().getCanonicalName());\n                        }\n                        nodeList = (NodeList<?>) optional.get();\n                    } else {\n                        nodeList = new NodeList<>();\n                    }\n                } else {\n                    if (!(rawValue instanceof NodeList)) {\n                        throw new IllegalStateException(\"Expected NodeList, found \" + rawValue.getClass().getCanonicalName());\n                    }\n                    nodeList = (NodeList<?>) rawValue;\n                }\n                if (!nodeList.isEmpty()) {\n                    calculatedSyntaxModelForNode(csmList.getPreceeding(), node, elements, change);\n                    for (int i = 0; i < nodeList.size(); i++) {\n                        if (i != 0) {\n                            calculatedSyntaxModelForNode(csmList.getSeparatorPre(), node, elements, change);\n                        }\n                        elements.add(new CsmChild(nodeList.get(i)));\n                        if (i != (nodeList.size() - 1)) {\n                            calculatedSyntaxModelForNode(csmList.getSeparatorPost(), node, elements, change);\n                        }\n\n                    }\n                    calculatedSyntaxModelForNode(csmList.getFollowing(), node, elements, change);\n                }\n            } else {\n                Collection<?> collection = (Collection<?>) change.getValue(csmList.getProperty(), node);\n                if (!collection.isEmpty()) {\n                    calculatedSyntaxModelForNode(csmList.getPreceeding(), node, elements, change);\n\n                    boolean first = true;\n                    for (Iterator<?> it = collection.iterator(); it.hasNext(); ) {\n                        if (!first) {\n                            calculatedSyntaxModelForNode(csmList.getSeparatorPre(), node, elements, change);\n                        }\n                        Object value = it.next();\n                        if (value instanceof Modifier) {\n                            Modifier modifier = (Modifier)value;\n                            elements.add(new CsmToken(toToken(modifier)));\n                        } else {\n                            throw new UnsupportedOperationException(it.next().getClass().getSimpleName());\n                        }\n                        if (it.hasNext()) {\n                            calculatedSyntaxModelForNode(csmList.getSeparatorPost(), node, elements, change);\n                        }\n                        first = false;\n                    }\n                    calculatedSyntaxModelForNode(csmList.getFollowing(), node, elements, change);\n                }\n            }\n        } else if (csm instanceof CsmConditional) {\n            CsmConditional csmConditional = (CsmConditional) csm;\n            boolean satisfied = change.evaluate(csmConditional, node);\n            if (satisfied) {\n                calculatedSyntaxModelForNode(csmConditional.getThenElement(), node, elements, change);\n            } else {\n                calculatedSyntaxModelForNode(csmConditional.getElseElement(), node, elements, change);\n            }\n        } else if (csm instanceof CsmIndent) {\n            elements.add(csm);\n        } else if (csm instanceof CsmUnindent) {\n            elements.add(csm);\n        } else if (csm instanceof CsmAttribute) {\n            CsmAttribute csmAttribute = (CsmAttribute) csm;\n            Object value = change.getValue(csmAttribute.getProperty(), node);\n            String text = value.toString();\n            if (value instanceof Stringable) {\n                text = ((Stringable) value).asString();\n            }\n            elements.add(new CsmToken(csmAttribute.getTokenType(node, value.toString(), text), text));\n        } else if ((csm instanceof CsmString) && (node instanceof StringLiteralExpr)) {\n            // fix #2382:\n            // This method calculates the syntax model _after_ the change has been applied.\n            // If the given change is a PropertyChange, the returned model should\n            // contain the new value, otherwise the original/current value should be used.\n            if (change instanceof PropertyChange) {\n                elements.add(new CsmToken(GeneratedJavaParserConstants.STRING_LITERAL,\n                        \"\\\"\" + ((PropertyChange) change).getNewValue() + \"\\\"\"));\n            } else {\n                elements.add(new CsmToken(GeneratedJavaParserConstants.STRING_LITERAL,\n                        \"\\\"\" + ((StringLiteralExpr) node).getValue() + \"\\\"\"));\n            }\n        } else if ((csm instanceof CsmString) && (node instanceof TextBlockLiteralExpr)) {\n            // FIXME: csm should be CsmTextBlock -- See also #2677\n            if (change instanceof PropertyChange) {\n                elements.add(new CsmToken(GeneratedJavaParserConstants.TEXT_BLOCK_LITERAL,\n                        \"\\\"\\\"\\\"\" + ((PropertyChange) change).getNewValue() + \"\\\"\\\"\\\"\"));\n            } else {\n                elements.add(new CsmToken(GeneratedJavaParserConstants.TEXT_BLOCK_LITERAL,\n                        \"\\\"\\\"\\\"\" + ((TextBlockLiteralExpr) node).getValue() + \"\\\"\\\"\\\"\"));\n            }\n        } else if ((csm instanceof CsmChar) && (node instanceof CharLiteralExpr)) {\n            if (change instanceof PropertyChange) {\n                elements.add(new CsmToken(GeneratedJavaParserConstants.CHAR,\n                        \"'\" + ((PropertyChange) change).getNewValue() + \"'\"));\n            } else {\n                elements.add(new CsmToken(GeneratedJavaParserConstants.CHAR,\n                        \"'\" + ((CharLiteralExpr) node).getValue() + \"'\"));\n            }\n        } else if (csm instanceof CsmMix) {\n            CsmMix csmMix = (CsmMix)csm;\n            List<CsmElement> mixElements = new LinkedList<>();\n            csmMix.getElements().forEach(e -> calculatedSyntaxModelForNode(e, node, mixElements, change));\n            elements.add(new CsmMix(mixElements));\n        } else if (csm instanceof CsmChild) {\n            elements.add(csm);\n        } else {\n            throw new UnsupportedOperationException(csm.getClass().getSimpleName()+ \" \" + csm);\n        }\n    }\n\n    public static int toToken(Modifier modifier) {\n        switch (modifier.getKeyword()) {\n            case PUBLIC:\n                return GeneratedJavaParserConstants.PUBLIC;\n            case PRIVATE:\n                return GeneratedJavaParserConstants.PRIVATE;\n            case PROTECTED:\n                return GeneratedJavaParserConstants.PROTECTED;\n            case STATIC:\n                return GeneratedJavaParserConstants.STATIC;\n            case FINAL:\n                return GeneratedJavaParserConstants.FINAL;\n            case ABSTRACT:\n                return GeneratedJavaParserConstants.ABSTRACT;\n            case TRANSIENT:\n                return GeneratedJavaParserConstants.TRANSIENT;\n            case SYNCHRONIZED:\n                return GeneratedJavaParserConstants.SYNCHRONIZED;\n            case VOLATILE:\n                return GeneratedJavaParserConstants.VOLATILE;\n            case NATIVE:\n                return GeneratedJavaParserConstants.NATIVE;\n            case STRICTFP:\n                return GeneratedJavaParserConstants.STRICTFP;\n            case TRANSITIVE:\n                return GeneratedJavaParserConstants.TRANSITIVE;\n            default:\n                throw new UnsupportedOperationException(modifier.getKeyword().name());\n        }\n    }\n\n    ///\n    /// Methods that calculate CalculatedSyntaxModel\n    ///\n\n    // Visible for testing\n    CalculatedSyntaxModel calculatedSyntaxModelAfterPropertyChange(Node node, ObservableProperty property, Object oldValue, Object newValue) {\n        return calculatedSyntaxModelAfterPropertyChange(ConcreteSyntaxModel.forClass(node.getClass()), node, property, oldValue, newValue);\n    }\n\n    // Visible for testing\n    CalculatedSyntaxModel calculatedSyntaxModelAfterPropertyChange(CsmElement csm, Node node, ObservableProperty property, Object oldValue, Object newValue) {\n        List<CsmElement> elements = new LinkedList<>();\n        calculatedSyntaxModelForNode(csm, node, elements, new PropertyChange(property, oldValue, newValue));\n        return new CalculatedSyntaxModel(elements);\n    }\n\n    // Visible for testing\n    CalculatedSyntaxModel calculatedSyntaxModelAfterListRemoval(CsmElement csm, ObservableProperty observableProperty, NodeList<?> nodeList, int index) {\n        List<CsmElement> elements = new LinkedList<>();\n        Node container = nodeList.getParentNodeForChildren();\n        calculatedSyntaxModelForNode(csm, container, elements, new ListRemovalChange(observableProperty, index));\n        return new CalculatedSyntaxModel(elements);\n    }\n\n    // Visible for testing\n    CalculatedSyntaxModel calculatedSyntaxModelAfterListAddition(CsmElement csm, ObservableProperty observableProperty, NodeList<?> nodeList, int index, Node nodeAdded) {\n        List<CsmElement> elements = new LinkedList<>();\n        Node container = nodeList.getParentNodeForChildren();\n        calculatedSyntaxModelForNode(csm, container, elements, new ListAdditionChange(observableProperty, index, nodeAdded));\n        return new CalculatedSyntaxModel(elements);\n    }\n\n    // Visible for testing\n    CalculatedSyntaxModel calculatedSyntaxModelAfterListAddition(Node container, ObservableProperty observableProperty, int index, Node nodeAdded) {\n        CsmElement csm = ConcreteSyntaxModel.forClass(container.getClass());\n        Object rawValue = observableProperty.getRawValue(container);\n        if (!(rawValue instanceof NodeList)) {\n            throw new IllegalStateException(\"Expected NodeList, found \" + rawValue.getClass().getCanonicalName());\n        }\n        NodeList<?> nodeList = (NodeList<?>)rawValue;\n        return calculatedSyntaxModelAfterListAddition(csm, observableProperty, nodeList, index, nodeAdded);\n    }\n\n    // Visible for testing\n    CalculatedSyntaxModel calculatedSyntaxModelAfterListRemoval(Node container, ObservableProperty observableProperty, int index) {\n        CsmElement csm = ConcreteSyntaxModel.forClass(container.getClass());\n        Object rawValue = observableProperty.getRawValue(container);\n        if (!(rawValue instanceof NodeList)) {\n            throw new IllegalStateException(\"Expected NodeList, found \" + rawValue.getClass().getCanonicalName());\n        }\n        NodeList<?> nodeList = (NodeList<?>)rawValue;\n        return calculatedSyntaxModelAfterListRemoval(csm, observableProperty, nodeList, index);\n    }\n\n    // Visible for testing\n    private CalculatedSyntaxModel calculatedSyntaxModelAfterListReplacement(CsmElement csm, ObservableProperty observableProperty, NodeList<?> nodeList, int index, Node newValue) {\n        List<CsmElement> elements = new LinkedList<>();\n        Node container = nodeList.getParentNodeForChildren();\n        calculatedSyntaxModelForNode(csm, container, elements, new ListReplacementChange(observableProperty, index, newValue));\n        return new CalculatedSyntaxModel(elements);\n    }\n\n}\n",
        "filePathAfter": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/LexicalDifferenceCalculator.java",
        "sourceCodeAfterForWhole": "/*\n * Copyright (C) 2007-2010 J\u00falio Vilmar Gesser.\n * Copyright (C) 2011, 2013-2021 The JavaParser Team.\n *\n * This file is part of JavaParser.\n *\n * JavaParser can be used either under the terms of\n * a) the GNU Lesser General Public License as published by\n *     the Free Software Foundation, either version 3 of the License, or\n *     (at your option) any later version.\n * b) the terms of the Apache License\n *\n * You should have received a copy of both licenses in LICENCE.LGPL and\n * LICENCE.APACHE. Please refer to those files for details.\n *\n * JavaParser is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n */\n\npackage com.github.javaparser.printer.lexicalpreservation;\n\nimport static com.github.javaparser.TokenTypes.eolTokenKind;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Optional;\n\nimport com.github.javaparser.GeneratedJavaParserConstants;\nimport com.github.javaparser.ast.Modifier;\nimport com.github.javaparser.ast.Node;\nimport com.github.javaparser.ast.NodeList;\nimport com.github.javaparser.ast.expr.CharLiteralExpr;\nimport com.github.javaparser.ast.expr.StringLiteralExpr;\nimport com.github.javaparser.ast.expr.TextBlockLiteralExpr;\nimport com.github.javaparser.ast.observer.ObservableProperty;\nimport com.github.javaparser.ast.stmt.ExpressionStmt;\nimport com.github.javaparser.printer.ConcreteSyntaxModel;\nimport com.github.javaparser.printer.SourcePrinter;\nimport com.github.javaparser.printer.Stringable;\nimport com.github.javaparser.printer.concretesyntaxmodel.*;\nimport com.github.javaparser.printer.lexicalpreservation.changes.Change;\nimport com.github.javaparser.printer.lexicalpreservation.changes.ListAdditionChange;\nimport com.github.javaparser.printer.lexicalpreservation.changes.ListRemovalChange;\nimport com.github.javaparser.printer.lexicalpreservation.changes.ListReplacementChange;\nimport com.github.javaparser.printer.lexicalpreservation.changes.NoChange;\nimport com.github.javaparser.printer.lexicalpreservation.changes.PropertyChange;\nimport com.github.javaparser.utils.LineSeparator;\n\nclass LexicalDifferenceCalculator {\n\n    /**\n     * The ConcreteSyntaxModel represents the general format. This model is a calculated version of the ConcreteSyntaxModel,\n     * with no condition, no lists, just tokens and node children.\n     */\n    static class CalculatedSyntaxModel {\n        final List<CsmElement> elements;\n\n        CalculatedSyntaxModel(List<CsmElement> elements) {\n            this.elements = elements;\n        }\n\n        public CalculatedSyntaxModel from(int index) {\n            return new CalculatedSyntaxModel(new ArrayList<>(elements.subList(index, elements.size())));\n        }\n\n        @Override\n        public String toString() {\n            return \"CalculatedSyntaxModel{\" +\n                    \"elements=\" + elements +\n                    '}';\n        }\n\n        CalculatedSyntaxModel sub(int start, int end) {\n            return new CalculatedSyntaxModel(elements.subList(start, end));\n        }\n\n        void removeIndentationElements() {\n            elements.removeIf(el -> el instanceof CsmIndent || el instanceof CsmUnindent);\n        }\n    }\n\n    static class CsmChild implements CsmElement {\n        private final Node child;\n\n        public Node getChild() {\n            return child;\n        }\n\n        CsmChild(Node child) {\n            this.child = child;\n        }\n\n        @Override\n        public void prettyPrint(Node node, SourcePrinter printer) {\n            throw new UnsupportedOperationException();\n        }\n\n        @Override\n        public String toString() {\n            return \"child(\" + child.getClass().getSimpleName()+\")\";\n        }\n\n        @Override\n        public boolean equals(Object o) {\n            if (this == o) return true;\n            if (o == null || getClass() != o.getClass()) return false;\n\n            CsmChild csmChild = (CsmChild) o;\n\n            return child.equals(csmChild.child);\n        }\n\n        @Override\n        public int hashCode() {\n            return child.hashCode();\n        }\n    }\n\n    List<DifferenceElement> calculateListRemovalDifference(ObservableProperty observableProperty, NodeList<?> nodeList, int index) {\n        Node container = nodeList.getParentNodeForChildren();\n        CsmElement element = ConcreteSyntaxModel.forClass(container.getClass());\n        CalculatedSyntaxModel original = calculatedSyntaxModelForNode(element, container);\n        CalculatedSyntaxModel after = calculatedSyntaxModelAfterListRemoval(element, observableProperty, nodeList, index);\n        return DifferenceElementCalculator.calculate(original, after);\n    }\n\n    List<DifferenceElement> calculateListAdditionDifference(ObservableProperty observableProperty, NodeList<?> nodeList, int index, Node nodeAdded) {\n        Node container = nodeList.getParentNodeForChildren();\n        CsmElement element = ConcreteSyntaxModel.forClass(container.getClass());\n        CalculatedSyntaxModel original = calculatedSyntaxModelForNode(element, container);\n        CalculatedSyntaxModel after = calculatedSyntaxModelAfterListAddition(element, observableProperty, nodeList, index, nodeAdded);\n\n        List<DifferenceElement> differenceElements = DifferenceElementCalculator.calculate(original, after);\n\n        // Set the line separator character tokens\n        LineSeparator lineSeparator = container.getLineEndingStyleOrDefault(LineSeparator.SYSTEM);\n        replaceEolTokens(differenceElements, lineSeparator);\n\n        return differenceElements;\n    }\n\n    /*\n     * Replace EOL token in the list of {@code DifferenceElement} by the specified line separator\n     */\n    private void replaceEolTokens(List<DifferenceElement> differenceElements, LineSeparator lineSeparator) {\n        CsmElement eol = getNewLineToken(lineSeparator);\n        for (int i = 0; i < differenceElements.size(); i++) {\n            DifferenceElement differenceElement = differenceElements.get(i);\n            differenceElements.set(i, differenceElement.replaceEolTokens(eol));\n        }\n    }\n    \n    /*\n     * Returns a new line token \n     */\n    private CsmElement getNewLineToken(LineSeparator lineSeparator) {\n        return CsmElement.newline(lineSeparator);\n    }\n    \n    List<DifferenceElement> calculateListReplacementDifference(ObservableProperty observableProperty, NodeList<?> nodeList, int index, Node newValue) {\n        Node container = nodeList.getParentNodeForChildren();\n        CsmElement element = ConcreteSyntaxModel.forClass(container.getClass());\n        CalculatedSyntaxModel original = calculatedSyntaxModelForNode(element, container);\n        CalculatedSyntaxModel after = calculatedSyntaxModelAfterListReplacement(element, observableProperty, nodeList, index, newValue);\n        return DifferenceElementCalculator.calculate(original, after);\n    }\n\n    void calculatePropertyChange(NodeText nodeText, Node observedNode, ObservableProperty property, Object oldValue, Object newValue) {\n        if (nodeText == null) {\n            throw new NullPointerException();\n        }\n        CsmElement element = ConcreteSyntaxModel.forClass(observedNode.getClass());\n        CalculatedSyntaxModel original = calculatedSyntaxModelForNode(element, observedNode);\n        CalculatedSyntaxModel after = calculatedSyntaxModelAfterPropertyChange(element, observedNode, property, oldValue, newValue);\n        List<DifferenceElement> differenceElements = DifferenceElementCalculator.calculate(original, after);\n        Difference difference = new Difference(differenceElements, nodeText, observedNode);\n        difference.apply();\n    }\n\n    // Visible for testing\n    CalculatedSyntaxModel calculatedSyntaxModelForNode(CsmElement csm, Node node) {\n        List<CsmElement> elements = new LinkedList<>();\n        calculatedSyntaxModelForNode(csm, node, elements, new NoChange());\n        return new CalculatedSyntaxModel(elements);\n    }\n\n    CalculatedSyntaxModel calculatedSyntaxModelForNode(Node node) {\n        return calculatedSyntaxModelForNode(ConcreteSyntaxModel.forClass(node.getClass()), node);\n    }\n\n    private void calculatedSyntaxModelForNode(CsmElement csm, Node node, List<CsmElement> elements, Change change) {\n        if (csm instanceof CsmSequence) {\n            CsmSequence csmSequence = (CsmSequence) csm;\n            csmSequence.getElements().forEach(e -> calculatedSyntaxModelForNode(e, node, elements, change));\n        } else if (csm instanceof CsmComment) {\n            // nothing to do\n        } else if (csm instanceof CsmSingleReference) {\n            CsmSingleReference csmSingleReference = (CsmSingleReference)csm;\n            Node child;\n            if (change instanceof PropertyChange && ((PropertyChange)change).getProperty() == csmSingleReference.getProperty()) {\n                child = (Node)((PropertyChange)change).getNewValue();\n            } else {\n                child = csmSingleReference.getProperty().getValueAsSingleReference(node);\n            }\n            if (child != null) {\n                // fix issue #2374\n                // Add node comment if needed (it's not very elegant but it works)\n                // We need to be sure that the node is an ExpressionStmt because we can meet\n                // this class definition\n                // a line comment <This is my class, with my comment> followed by\n                // class A {}\n                // In this case keyworld [class] is considered as a token and [A] is a child element\n                // So if we don't care that the node is an ExpressionStmt we could try to generate a wrong definition\n                // like this [class // This is my class, with my comment A {}]\n                if (node.getComment().isPresent() && node instanceof ExpressionStmt) {\n                    LineSeparator lineSeparator = node.getLineEndingStyleOrDefault(LineSeparator.SYSTEM);\n                    elements.add(new CsmChild(node.getComment().get()));\n                    elements.add(new CsmToken(eolTokenKind(lineSeparator), lineSeparator.asRawString()));\n                }\n                elements.add(new CsmChild(child));\n            }\n        } else if (csm instanceof CsmNone) {\n            // nothing to do\n        } else if (csm instanceof CsmToken) {\n            elements.add(csm);\n        } else if (csm instanceof CsmOrphanCommentsEnding) {\n            // nothing to do\n        } else if (csm instanceof CsmList) {\n            CsmList csmList = (CsmList) csm;\n            if (csmList.getProperty().isAboutNodes()) {\n                Object rawValue = change.getValue(csmList.getProperty(), node);\n                NodeList<?> nodeList;\n                if (rawValue instanceof Optional) {\n                    Optional<?> optional = (Optional<?>)rawValue;\n                    if (optional.isPresent()) {\n                        if (!(optional.get() instanceof NodeList)) {\n                            throw new IllegalStateException(\"Expected NodeList, found \" + optional.get().getClass().getCanonicalName());\n                        }\n                        nodeList = (NodeList<?>) optional.get();\n                    } else {\n                        nodeList = new NodeList<>();\n                    }\n                } else {\n                    if (!(rawValue instanceof NodeList)) {\n                        throw new IllegalStateException(\"Expected NodeList, found \" + rawValue.getClass().getCanonicalName());\n                    }\n                    nodeList = (NodeList<?>) rawValue;\n                }\n                if (!nodeList.isEmpty()) {\n                    calculatedSyntaxModelForNode(csmList.getPreceeding(), node, elements, change);\n                    for (int i = 0; i < nodeList.size(); i++) {\n                        if (i != 0) {\n                            calculatedSyntaxModelForNode(csmList.getSeparatorPre(), node, elements, change);\n                        }\n                        elements.add(new CsmChild(nodeList.get(i)));\n                        if (i != (nodeList.size() - 1)) {\n                            calculatedSyntaxModelForNode(csmList.getSeparatorPost(), node, elements, change);\n                        }\n\n                    }\n                    calculatedSyntaxModelForNode(csmList.getFollowing(), node, elements, change);\n                }\n            } else {\n                Collection<?> collection = (Collection<?>) change.getValue(csmList.getProperty(), node);\n                if (!collection.isEmpty()) {\n                    calculatedSyntaxModelForNode(csmList.getPreceeding(), node, elements, change);\n\n                    boolean first = true;\n                    for (Iterator<?> it = collection.iterator(); it.hasNext(); ) {\n                        if (!first) {\n                            calculatedSyntaxModelForNode(csmList.getSeparatorPre(), node, elements, change);\n                        }\n                        Object value = it.next();\n                        if (value instanceof Modifier) {\n                            Modifier modifier = (Modifier)value;\n                            elements.add(new CsmToken(toToken(modifier)));\n                        } else {\n                            throw new UnsupportedOperationException(it.next().getClass().getSimpleName());\n                        }\n                        if (it.hasNext()) {\n                            calculatedSyntaxModelForNode(csmList.getSeparatorPost(), node, elements, change);\n                        }\n                        first = false;\n                    }\n                    calculatedSyntaxModelForNode(csmList.getFollowing(), node, elements, change);\n                }\n            }\n        } else if (csm instanceof CsmConditional) {\n            CsmConditional csmConditional = (CsmConditional) csm;\n            boolean satisfied = change.evaluate(csmConditional, node);\n            if (satisfied) {\n                calculatedSyntaxModelForNode(csmConditional.getThenElement(), node, elements, change);\n            } else {\n                calculatedSyntaxModelForNode(csmConditional.getElseElement(), node, elements, change);\n            }\n        } else if (csm instanceof CsmIndent) {\n            elements.add(csm);\n        } else if (csm instanceof CsmUnindent) {\n            elements.add(csm);\n        } else if (csm instanceof CsmAttribute) {\n            CsmAttribute csmAttribute = (CsmAttribute) csm;\n            Object value = change.getValue(csmAttribute.getProperty(), node);\n            String text = value.toString();\n            if (value instanceof Stringable) {\n                text = ((Stringable) value).asString();\n            }\n            elements.add(new CsmToken(csmAttribute.getTokenType(node, value.toString(), text), text));\n        } else if ((csm instanceof CsmString) && (node instanceof StringLiteralExpr)) {\n            // fix #2382:\n            // This method calculates the syntax model _after_ the change has been applied.\n            // If the given change is a PropertyChange, the returned model should\n            // contain the new value, otherwise the original/current value should be used.\n            if (change instanceof PropertyChange) {\n                elements.add(new CsmToken(GeneratedJavaParserConstants.STRING_LITERAL,\n                        \"\\\"\" + ((PropertyChange) change).getNewValue() + \"\\\"\"));\n            } else {\n                elements.add(new CsmToken(GeneratedJavaParserConstants.STRING_LITERAL,\n                        \"\\\"\" + ((StringLiteralExpr) node).getValue() + \"\\\"\"));\n            }\n        } else if ((csm instanceof CsmString) && (node instanceof TextBlockLiteralExpr)) {\n            // FIXME: csm should be CsmTextBlock -- See also #2677\n            if (change instanceof PropertyChange) {\n                elements.add(new CsmToken(GeneratedJavaParserConstants.TEXT_BLOCK_LITERAL,\n                        \"\\\"\\\"\\\"\" + ((PropertyChange) change).getNewValue() + \"\\\"\\\"\\\"\"));\n            } else {\n                elements.add(new CsmToken(GeneratedJavaParserConstants.TEXT_BLOCK_LITERAL,\n                        \"\\\"\\\"\\\"\" + ((TextBlockLiteralExpr) node).getValue() + \"\\\"\\\"\\\"\"));\n            }\n        } else if ((csm instanceof CsmChar) && (node instanceof CharLiteralExpr)) {\n            if (change instanceof PropertyChange) {\n                elements.add(new CsmToken(GeneratedJavaParserConstants.CHAR,\n                        \"'\" + ((PropertyChange) change).getNewValue() + \"'\"));\n            } else {\n                elements.add(new CsmToken(GeneratedJavaParserConstants.CHAR,\n                        \"'\" + ((CharLiteralExpr) node).getValue() + \"'\"));\n            }\n        } else if (csm instanceof CsmMix) {\n            CsmMix csmMix = (CsmMix)csm;\n            List<CsmElement> mixElements = new LinkedList<>();\n            csmMix.getElements().forEach(e -> calculatedSyntaxModelForNode(e, node, mixElements, change));\n            elements.add(new CsmMix(mixElements));\n        } else if (csm instanceof CsmChild) {\n            elements.add(csm);\n        } else {\n            throw new UnsupportedOperationException(csm.getClass().getSimpleName()+ \" \" + csm);\n        }\n    }\n\n    public static int toToken(Modifier modifier) {\n        switch (modifier.getKeyword()) {\n            case PUBLIC:\n                return GeneratedJavaParserConstants.PUBLIC;\n            case PRIVATE:\n                return GeneratedJavaParserConstants.PRIVATE;\n            case PROTECTED:\n                return GeneratedJavaParserConstants.PROTECTED;\n            case STATIC:\n                return GeneratedJavaParserConstants.STATIC;\n            case FINAL:\n                return GeneratedJavaParserConstants.FINAL;\n            case ABSTRACT:\n                return GeneratedJavaParserConstants.ABSTRACT;\n            case TRANSIENT:\n                return GeneratedJavaParserConstants.TRANSIENT;\n            case SYNCHRONIZED:\n                return GeneratedJavaParserConstants.SYNCHRONIZED;\n            case VOLATILE:\n                return GeneratedJavaParserConstants.VOLATILE;\n            case NATIVE:\n                return GeneratedJavaParserConstants.NATIVE;\n            case STRICTFP:\n                return GeneratedJavaParserConstants.STRICTFP;\n            case TRANSITIVE:\n                return GeneratedJavaParserConstants.TRANSITIVE;\n            default:\n                throw new UnsupportedOperationException(modifier.getKeyword().name());\n        }\n    }\n\n    ///\n    /// Methods that calculate CalculatedSyntaxModel\n    ///\n\n    // Visible for testing\n    CalculatedSyntaxModel calculatedSyntaxModelAfterPropertyChange(Node node, ObservableProperty property, Object oldValue, Object newValue) {\n        return calculatedSyntaxModelAfterPropertyChange(ConcreteSyntaxModel.forClass(node.getClass()), node, property, oldValue, newValue);\n    }\n\n    // Visible for testing\n    CalculatedSyntaxModel calculatedSyntaxModelAfterPropertyChange(CsmElement csm, Node node, ObservableProperty property, Object oldValue, Object newValue) {\n        List<CsmElement> elements = new LinkedList<>();\n        calculatedSyntaxModelForNode(csm, node, elements, new PropertyChange(property, oldValue, newValue));\n        return new CalculatedSyntaxModel(elements);\n    }\n\n    // Visible for testing\n    CalculatedSyntaxModel calculatedSyntaxModelAfterListRemoval(CsmElement csm, ObservableProperty observableProperty, NodeList<?> nodeList, int index) {\n        List<CsmElement> elements = new LinkedList<>();\n        Node container = nodeList.getParentNodeForChildren();\n        calculatedSyntaxModelForNode(csm, container, elements, new ListRemovalChange(observableProperty, index));\n        return new CalculatedSyntaxModel(elements);\n    }\n\n    // Visible for testing\n    CalculatedSyntaxModel calculatedSyntaxModelAfterListAddition(CsmElement csm, ObservableProperty observableProperty, NodeList<?> nodeList, int index, Node nodeAdded) {\n        List<CsmElement> elements = new LinkedList<>();\n        Node container = nodeList.getParentNodeForChildren();\n        calculatedSyntaxModelForNode(csm, container, elements, new ListAdditionChange(observableProperty, index, nodeAdded));\n        return new CalculatedSyntaxModel(elements);\n    }\n\n    // Visible for testing\n    CalculatedSyntaxModel calculatedSyntaxModelAfterListAddition(Node container, ObservableProperty observableProperty, int index, Node nodeAdded) {\n        CsmElement csm = ConcreteSyntaxModel.forClass(container.getClass());\n        Object rawValue = observableProperty.getRawValue(container);\n        if (!(rawValue instanceof NodeList)) {\n            throw new IllegalStateException(\"Expected NodeList, found \" + rawValue.getClass().getCanonicalName());\n        }\n        NodeList<?> nodeList = (NodeList<?>)rawValue;\n        return calculatedSyntaxModelAfterListAddition(csm, observableProperty, nodeList, index, nodeAdded);\n    }\n\n    // Visible for testing\n    CalculatedSyntaxModel calculatedSyntaxModelAfterListRemoval(Node container, ObservableProperty observableProperty, int index) {\n        CsmElement csm = ConcreteSyntaxModel.forClass(container.getClass());\n        Object rawValue = observableProperty.getRawValue(container);\n        if (!(rawValue instanceof NodeList)) {\n            throw new IllegalStateException(\"Expected NodeList, found \" + rawValue.getClass().getCanonicalName());\n        }\n        NodeList<?> nodeList = (NodeList<?>)rawValue;\n        return calculatedSyntaxModelAfterListRemoval(csm, observableProperty, nodeList, index);\n    }\n\n    // Visible for testing\n    private CalculatedSyntaxModel calculatedSyntaxModelAfterListReplacement(CsmElement csm, ObservableProperty observableProperty, NodeList<?> nodeList, int index, Node newValue) {\n        List<CsmElement> elements = new LinkedList<>();\n        Node container = nodeList.getParentNodeForChildren();\n        calculatedSyntaxModelForNode(csm, container, elements, new ListReplacementChange(observableProperty, index, newValue));\n        return new CalculatedSyntaxModel(elements);\n    }\n\n}\n",
        "diffSourceCodeSet": [
            "private CsmElement getNewLineToken(LineSeparator lineSeparator) {\n        return CsmElement.newline(lineSeparator);\n    }"
        ],
        "invokedMethodSet": [
            "methodSignature: com.github.javaparser.printer.lexicalpreservation.Reshuffled#getElement\n methodBody: public CsmMix getElement() {\nreturn nextOrder;\n}",
            "methodSignature: com.github.javaparser.printer.lexicalpreservation.Added#isAdded\n methodBody: public boolean isAdded() {\nreturn true;\n}",
            "methodSignature: com.github.javaparser.printer.lexicalpreservation.DifferenceElement#getElement\n methodBody: CsmElement getElement();",
            "methodSignature: com.github.javaparser.printer.lexicalpreservation.DifferenceElement#isAdded\n methodBody: boolean isAdded();",
            "methodSignature: com.github.javaparser.printer.lexicalpreservation.Reshuffled#isAdded\n methodBody: public boolean isAdded() {\nreturn false;\n}",
            "methodSignature: com.github.javaparser.printer.lexicalpreservation.Added#getElement\n methodBody: public CsmElement getElement() {\nreturn element;\n}"
        ],
        "sourceCodeAfterRefactoring": "private void replaceEolTokens(List<DifferenceElement> differenceElements, LineSeparator lineSeparator) {\n        CsmElement eol = getNewLineToken(lineSeparator);\n        for (int i = 0; i < differenceElements.size(); i++) {\n            DifferenceElement differenceElement = differenceElements.get(i);\n            differenceElements.set(i, differenceElement.replaceEolTokens(eol));\n        }\n    }\nprivate CsmElement getNewLineToken(LineSeparator lineSeparator) {\n        return CsmElement.newline(lineSeparator);\n    }",
        "diffSourceCode": "-  147:     private void replaceEolTokens(List<DifferenceElement> differenceElements, LineSeparator lineSeparator) {\n-  148:         for (int i = 0; i < differenceElements.size(); i++) {\n-  149:             DifferenceElement differenceElement = differenceElements.get(i);\n-  150:             if (differenceElement.isAdded()) {\n-  151:                 CsmElement element = differenceElement.getElement();\n-  152:                 boolean isWhitespaceToken = element instanceof CsmToken && ((CsmToken) element).isNewLine();\n-  153:                 if (isWhitespaceToken) {\n-  154:                     differenceElements.set(i, new Added(CsmElement.newline(lineSeparator)));\n-  155:                 }\n-  156:             }\n-  157:         }\n-  158:     }\n-  161:         Node container = nodeList.getParentNodeForChildren();\n-  162:         CsmElement element = ConcreteSyntaxModel.forClass(container.getClass());\n-  163:         CalculatedSyntaxModel original = calculatedSyntaxModelForNode(element, container);\n+  147:     /*\n+  148:      * Replace EOL token in the list of {@code DifferenceElement} by the specified line separator\n+  149:      */\n+  150:     private void replaceEolTokens(List<DifferenceElement> differenceElements, LineSeparator lineSeparator) {\n+  151:         CsmElement eol = getNewLineToken(lineSeparator);\n+  152:         for (int i = 0; i < differenceElements.size(); i++) {\n+  153:             DifferenceElement differenceElement = differenceElements.get(i);\n+  154:             differenceElements.set(i, differenceElement.replaceEolTokens(eol));\n+  155:         }\n+  156:     }\n+  157:     \n+  158:     /*\n+  161:     private CsmElement getNewLineToken(LineSeparator lineSeparator) {\n+  162:         return CsmElement.newline(lineSeparator);\n+  163:     }\n",
        "uniqueId": "ed79beb63e87f3a58322aee34b1a2e80cfafbd18_147_158_161_163_150_156",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 0,
                "covered": 42
            },
            "BRANCH": {
                "missed": 0,
                "covered": 10
            },
            "LINE": {
                "missed": 0,
                "covered": 8
            },
            "COMPLEXITY": {
                "missed": 0,
                "covered": 6
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 17
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprivate getLastParameterIndex(countOfMethodParametersDeclared int) : int extracted from public isApplicable(methodUsage MethodUsage, needleName String, needleParameterTypes List<ResolvedType>, typeSolver TypeSolver) : boolean in class com.github.javaparser.symbolsolver.resolution.MethodResolutionLogic",
        "diffLocations": [
            {
                "filePath": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/MethodResolutionLogic.java",
                "startLine": 354,
                "endLine": 488,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/MethodResolutionLogic.java",
                "startLine": 380,
                "endLine": 514,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/MethodResolutionLogic.java",
                "startLine": 210,
                "endLine": 212,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "/**\n     * Note the specific naming here -- parameters are part of the method declaration,\n     * while arguments are the values passed when calling a method.\n     * Note that \"needle\" refers to that value being used as a search/query term to match against.\n     *\n     * @return true, if the given MethodUsage matches the given name/types (normally obtained from a ResolvedMethodDeclaration)\n     *\n     * @see {@link MethodResolutionLogic#isApplicable(ResolvedMethodDeclaration, String, List, TypeSolver)}  }\n     * @see {@link MethodResolutionLogic#isApplicable(ResolvedMethodDeclaration, String, List, TypeSolver, boolean)}\n     */\n    public static boolean isApplicable(MethodUsage methodUsage, String needleName, List<ResolvedType> needleParameterTypes, TypeSolver typeSolver) {\n        if (!methodUsage.getName().equals(needleName)) {\n            return false;\n        }\n\n        // The index of the final method parameter (on the method declaration).\n        int countOfMethodUsageArgumentsPassed = methodUsage.getNoParams();\n        int lastMethodUsageArgumentIndex = Math.max(0, countOfMethodUsageArgumentsPassed - 1);\n\n        // The index of the final argument passed (on the method usage).\n        int needleParameterCount = needleParameterTypes.size();\n        int lastNeedleParameterIndex = Math.max(0, needleParameterCount - 1);\n\n        // TODO: Does the method usage have a declaration at this point..?\n        boolean methodIsDeclaredWithVariadicParameter = methodUsage.getDeclaration().hasVariadicParameter();\n\n        // If the counts do not match and the method is not variadic, this is not a match.\n        if (!methodIsDeclaredWithVariadicParameter && !(needleParameterCount == countOfMethodUsageArgumentsPassed)) {\n            return false;\n        }\n\n        // If the counts do not match and we have provided too few arguments, this is not a match. Note that variadic parameters\n        // allow you to omit the vararg, which would allow a difference of one, but a difference in count of 2 or more is not a match.\n        if (!(needleParameterCount == countOfMethodUsageArgumentsPassed) && needleParameterCount < lastMethodUsageArgumentIndex) {\n            return false;\n        }\n\n        // Iterate over the arguments given to the method, and compare their types against the given method's declared parameter types\n        for (int i = 0; i < needleParameterCount; i++) {\n            ResolvedType actualArgumentType = needleParameterTypes.get(i);\n\n            ResolvedType expectedArgumentType;\n            boolean reachedVariadicParam = methodIsDeclaredWithVariadicParameter && i >= lastMethodUsageArgumentIndex;\n            if (!reachedVariadicParam) {\n                // Not yet reached the variadic parameters -- the expected type is just whatever is at that position.\n                expectedArgumentType = methodUsage.getParamType(i);\n            } else {\n                // We have reached the variadic parameters -- the expected type is the type of the last declared parameter.\n                expectedArgumentType = methodUsage.getParamType(lastMethodUsageArgumentIndex);\n                // Note that the given variadic value might be an array - if so, use the array's component type rather.\n                // This is only valid if ONE argument has been given to the vararg parameter.\n                // Example: {@code void test(String... s) {}} and {@code test(stringArray)} -- {@code String... is assignable by stringArray}\n                // Example: {@code void test(String[]... s) {}} and {@code test(stringArrayArray)} -- {@code String[]... is assignable by stringArrayArray}\n                boolean argumentIsArray = (needleParameterCount == countOfMethodUsageArgumentsPassed) && expectedArgumentType.isAssignableBy(actualArgumentType);\n                if (!argumentIsArray) {\n                    // Get the component type of the declared parameter type.\n                    expectedArgumentType = expectedArgumentType.asArrayType().getComponentType();\n                }\n            }\n\n            // Consider type parameters directly on the method declaration, and ALSO on the enclosing type (e.g. a class)\n            List<ResolvedTypeParameterDeclaration> typeParameters = methodUsage.getDeclaration().getTypeParameters();\n            typeParameters.addAll(methodUsage.declaringType().getTypeParameters());\n\n            ResolvedType expectedTypeWithoutSubstitutions = expectedArgumentType;\n            ResolvedType expectedTypeWithInference = expectedArgumentType;\n            Map<ResolvedTypeParameterDeclaration, ResolvedType> derivedValues = new HashMap<>();\n\n            // For each declared parameter, infer the types that will replace generics (type parameters)\n            for (int j = 0; j < countOfMethodUsageArgumentsPassed; j++) {\n                ResolvedParameterDeclaration parameter = methodUsage.getDeclaration().getParam(j);\n                ResolvedType parameterType = parameter.getType();\n                if (parameter.isVariadic()) {\n                    // Don't continue if a vararg parameter is reached and there are no arguments left\n                    if (needleParameterCount == j) {\n                        break;\n                    }\n                    parameterType = parameterType.asArrayType().getComponentType();\n                }\n                inferTypes(needleParameterTypes.get(j), parameterType, derivedValues);\n            }\n\n            for (Map.Entry<ResolvedTypeParameterDeclaration, ResolvedType> entry : derivedValues.entrySet()) {\n                ResolvedTypeParameterDeclaration tp = entry.getKey();\n                expectedTypeWithInference = expectedTypeWithInference.replaceTypeVariables(tp, entry.getValue());\n            }\n\n            // Consider cases where type variables can be replaced (e.g. add(E element) vs add(String element))\n            for (ResolvedTypeParameterDeclaration tp : typeParameters) {\n                if (tp.getBounds().isEmpty()) {\n                    //expectedArgumentType = expectedArgumentType.replaceTypeVariables(tp.getName(), new ReferenceTypeUsageImpl(typeSolver.solveType(JAVA_LANG_OBJECT), typeSolver));\n                    expectedArgumentType = expectedArgumentType.replaceTypeVariables(tp, ResolvedWildcard.extendsBound(new ReferenceTypeImpl(typeSolver.solveType(JAVA_LANG_OBJECT), typeSolver)));\n                } else if (tp.getBounds().size() == 1) {\n                    ResolvedTypeParameterDeclaration.Bound bound = tp.getBounds().get(0);\n                    if (bound.isExtends()) {\n                        //expectedArgumentType = expectedArgumentType.replaceTypeVariables(tp.getName(), bound.getType());\n                        expectedArgumentType = expectedArgumentType.replaceTypeVariables(tp, ResolvedWildcard.extendsBound(bound.getType()));\n                    } else {\n                        //expectedArgumentType = expectedArgumentType.replaceTypeVariables(tp.getName(), new ReferenceTypeUsageImpl(typeSolver.solveType(JAVA_LANG_OBJECT), typeSolver));\n                        expectedArgumentType = expectedArgumentType.replaceTypeVariables(tp, ResolvedWildcard.superBound(bound.getType()));\n                    }\n                } else {\n                    throw new UnsupportedOperationException();\n                }\n            }\n\n            // Consider cases where type variables involve bounds e.g. super/extends\n            ResolvedType expectedTypeWithSubstitutions = expectedTypeWithoutSubstitutions;\n            for (ResolvedTypeParameterDeclaration tp : typeParameters) {\n                if (tp.getBounds().isEmpty()) {\n                    expectedTypeWithSubstitutions = expectedTypeWithSubstitutions.replaceTypeVariables(tp, new ReferenceTypeImpl(typeSolver.solveType(JAVA_LANG_OBJECT), typeSolver));\n                } else if (tp.getBounds().size() == 1) {\n                    ResolvedTypeParameterDeclaration.Bound bound = tp.getBounds().get(0);\n                    if (bound.isExtends()) {\n                        expectedTypeWithSubstitutions = expectedTypeWithSubstitutions.replaceTypeVariables(tp, bound.getType());\n                    } else {\n                        expectedTypeWithSubstitutions = expectedTypeWithSubstitutions.replaceTypeVariables(tp, new ReferenceTypeImpl(typeSolver.solveType(JAVA_LANG_OBJECT), typeSolver));\n                    }\n                } else {\n                    throw new UnsupportedOperationException();\n                }\n            }\n\n            // If the given argument still isn't applicable even after considering type arguments/generics, this is not a match.\n            if (!expectedArgumentType.isAssignableBy(actualArgumentType)\n                    && !expectedTypeWithSubstitutions.isAssignableBy(actualArgumentType)\n                    && !expectedTypeWithInference.isAssignableBy(actualArgumentType)\n                    && !expectedTypeWithoutSubstitutions.isAssignableBy(actualArgumentType)) {\n                return false;\n            }\n        }\n\n        // If the checks above haven't failed, then we've found a match.\n        return true;\n    }",
        "filePathBefore": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/MethodResolutionLogic.java",
        "isPureRefactoring": true,
        "commitId": "5aabb7480625e5dba2d32a8efab95a35f8c2e04c",
        "packageNameBefore": "com.github.javaparser.symbolsolver.resolution",
        "classNameBefore": "com.github.javaparser.symbolsolver.resolution.MethodResolutionLogic",
        "methodNameBefore": "com.github.javaparser.symbolsolver.resolution.MethodResolutionLogic#isApplicable",
        "invokedMethod": "methodSignature: com.github.javaparser.symbolsolver.resolution.MethodResolutionLogic#inferTypes\n methodBody: private static void inferTypes(ResolvedType source, ResolvedType target, Map<ResolvedTypeParameterDeclaration, ResolvedType> mappings) {\nif(source.equals(target)){return;\n}if(source.isReferenceType() && target.isReferenceType()){ResolvedReferenceType sourceRefType=source.asReferenceType();\nResolvedReferenceType targetRefType=target.asReferenceType();\nif(sourceRefType.getQualifiedName().equals(targetRefType.getQualifiedName())){if(!sourceRefType.isRawType() && !targetRefType.isRawType()){for(int i=0; i < sourceRefType.typeParametersValues().size(); i++){inferTypes(sourceRefType.typeParametersValues().get(i),targetRefType.typeParametersValues().get(i),mappings);\n}}}return;\n}if(source.isReferenceType() && target.isWildcard()){if(target.asWildcard().isBounded()){inferTypes(source,target.asWildcard().getBoundedType(),mappings);\nreturn;\n}return;\n}if(source.isWildcard() && target.isWildcard()){return;\n}if(source.isReferenceType() && target.isTypeVariable()){mappings.put(target.asTypeParameter(),source);\nreturn;\n}if(source.isWildcard() && target.isReferenceType()){if(source.asWildcard().isBounded()){inferTypes(source.asWildcard().getBoundedType(),target,mappings);\n}return;\n}if(source.isWildcard() && target.isTypeVariable()){mappings.put(target.asTypeParameter(),source);\nreturn;\n}if(source.isTypeVariable() && target.isTypeVariable()){mappings.put(target.asTypeParameter(),source);\nreturn;\n}if(source.isPrimitive() || target.isPrimitive()){return;\n}if(source.isNull()){return;\n}}",
        "classSignatureBefore": "public class MethodResolutionLogic ",
        "methodNameBeforeSet": [
            "com.github.javaparser.symbolsolver.resolution.MethodResolutionLogic#isApplicable"
        ],
        "classNameBeforeSet": [
            "com.github.javaparser.symbolsolver.resolution.MethodResolutionLogic"
        ],
        "classSignatureBeforeSet": [
            "public class MethodResolutionLogic "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Changes are within the Extract Method refactoring mechanics",
                "description": "All replacements have been justified - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Copyright (C) 2015-2016 Federico Tomassetti\n * Copyright (C) 2017-2020 The JavaParser Team.\n *\n * This file is part of JavaParser.\n *\n * JavaParser can be used either under the terms of\n * a) the GNU Lesser General Public License as published by\n *     the Free Software Foundation, either version 3 of the License, or\n *     (at your option) any later version.\n * b) the terms of the Apache License\n *\n * You should have received a copy of both licenses in LICENCE.LGPL and\n * LICENCE.APACHE. Please refer to those files for details.\n *\n * JavaParser is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n */\n\npackage com.github.javaparser.symbolsolver.resolution;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.Set;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.function.Function;\nimport java.util.function.Predicate;\nimport java.util.stream.Collectors;\n\nimport com.github.javaparser.resolution.MethodAmbiguityException;\nimport com.github.javaparser.resolution.MethodUsage;\nimport com.github.javaparser.resolution.declarations.ResolvedMethodDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedMethodLikeDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedParameterDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedTypeDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedTypeParameterDeclaration;\nimport com.github.javaparser.resolution.types.ResolvedArrayType;\nimport com.github.javaparser.resolution.types.ResolvedReferenceType;\nimport com.github.javaparser.resolution.types.ResolvedType;\nimport com.github.javaparser.resolution.types.ResolvedTypeVariable;\nimport com.github.javaparser.resolution.types.ResolvedWildcard;\nimport com.github.javaparser.symbolsolver.logic.MethodResolutionCapability;\nimport com.github.javaparser.symbolsolver.model.resolution.SymbolReference;\nimport com.github.javaparser.symbolsolver.model.resolution.TypeSolver;\nimport com.github.javaparser.symbolsolver.model.typesystem.ReferenceTypeImpl;\n\n/**\n * @author Federico Tomassetti\n */\npublic class MethodResolutionLogic {\n    \n    private static String JAVA_LANG_OBJECT = Object.class.getCanonicalName();\n\n    private static List<ResolvedType> groupVariadicParamValues(List<ResolvedType> argumentsTypes, int startVariadic, ResolvedType variadicType) {\n        List<ResolvedType> res = new ArrayList<>(argumentsTypes.subList(0, startVariadic));\n        List<ResolvedType> variadicValues = argumentsTypes.subList(startVariadic, argumentsTypes.size());\n        if (variadicValues.isEmpty()) {\n            // TODO if there are no variadic values we should default to the bound of the formal type\n            res.add(variadicType);\n        } else {\n            ResolvedType componentType = findCommonType(variadicValues);\n            res.add(new ResolvedArrayType(componentType));\n        }\n        return res;\n    }\n\n    private static ResolvedType findCommonType(List<ResolvedType> variadicValues) {\n        if (variadicValues.isEmpty()) {\n            throw new IllegalArgumentException();\n        }\n        // TODO implement this decently\n        return variadicValues.get(0);\n    }\n\n    public static boolean isApplicable(ResolvedMethodDeclaration method, String name, List<ResolvedType> argumentsTypes, TypeSolver typeSolver) {\n        return isApplicable(method, name, argumentsTypes, typeSolver, false);\n    }\n\n    /**\n     * Note the specific naming here -- parameters are part of the method declaration,\n     * while arguments are the values passed when calling a method.\n     * Note that \"needle\" refers to that value being used as a search/query term to match against.\n     *\n     * @return true, if the given ResolvedMethodDeclaration matches the given name/types (normally obtained from a MethodUsage)\n     *\n     * @see {@link MethodResolutionLogic#isApplicable(MethodUsage, String, List, TypeSolver)}\n     */\n    private static boolean isApplicable(ResolvedMethodDeclaration methodDeclaration, String needleName, List<ResolvedType> needleArgumentTypes, TypeSolver typeSolver, boolean withWildcardTolerance) {\n        if (!methodDeclaration.getName().equals(needleName)) {\n            return false;\n        }\n\n        // The index of the final method parameter (on the method declaration).\n        int countOfMethodParametersDeclared = methodDeclaration.getNumberOfParams();\n        int lastMethodParameterIndex = Math.max(0, countOfMethodParametersDeclared - 1);\n\n        // The index of the final argument passed (on the method usage).\n        int countOfNeedleArgumentsPassed = needleArgumentTypes.size();\n        int lastNeedleArgumentIndex = Math.max(0, countOfNeedleArgumentsPassed - 1);\n\n        boolean methodIsDeclaredWithVariadicParameter = methodDeclaration.hasVariadicParameter();\n\n        if (!methodIsDeclaredWithVariadicParameter && (countOfNeedleArgumentsPassed != countOfMethodParametersDeclared)) {\n            // If it is not variadic, and the number of parameters/arguments are unequal -- this is not a match.\n            return false;\n        }\n\n        if (methodIsDeclaredWithVariadicParameter) {\n            // If the method declaration we're considering has a variadic parameter,\n            // attempt to convert the given list of arguments to fit this pattern\n            // e.g. foo(String s, String... s2) {} --- consider the first argument, then group the remainder as an array\n\n            ResolvedType expectedVariadicParameterType = methodDeclaration.getLastParam().getType();\n            for (ResolvedTypeParameterDeclaration tp : methodDeclaration.getTypeParameters()) {\n                expectedVariadicParameterType = replaceTypeParam(expectedVariadicParameterType, tp, typeSolver);\n            }\n\n            if(countOfNeedleArgumentsPassed <= (countOfMethodParametersDeclared - 2)) {\n                // If it is variadic, and the number of arguments are short by **two or more** -- this is not a match.\n                // Note that omitting the variadic parameter is treated as an empty array\n                //  (thus being short of only 1 argument is fine, but being short of 2 or more is not).\n                return false;\n            }\n            if (countOfNeedleArgumentsPassed > countOfMethodParametersDeclared) {\n                // If it is variadic, and we have an \"excess\" of arguments, group the \"trailing\" arguments into an array.\n                // Confirm all of these grouped \"trailing\" arguments have the required type -- if not, this is not a valid type. (Maybe this is also done later..?)\n                for(int variadicArgumentIndex = countOfMethodParametersDeclared; variadicArgumentIndex < countOfNeedleArgumentsPassed; variadicArgumentIndex++) {\n                    ResolvedType currentArgumentType = needleArgumentTypes.get(variadicArgumentIndex);\n                    boolean argumentIsAssignableToVariadicComponentType = expectedVariadicParameterType.asArrayType().getComponentType().isAssignableBy(currentArgumentType);\n                    if(!argumentIsAssignableToVariadicComponentType) {\n                        // If any of the arguments are not assignable to the expected variadic type, this is not a match.\n                        return false;\n                    }\n                }\n                needleArgumentTypes = groupVariadicParamValues(needleArgumentTypes, lastMethodParameterIndex, methodDeclaration.getLastParam().getType());\n            }\n            if (countOfNeedleArgumentsPassed == (countOfMethodParametersDeclared - 1)) {\n                // If it is variadic and we are short of **exactly one** parameter, this is a match.\n                // Note that omitting the variadic parameter is treated as an empty array\n                //  (thus being short of only 1 argument is fine, but being short of 2 or more is not).\n\n                // thus group the \"empty\" value into an empty array...\n                needleArgumentTypes = groupVariadicParamValues(needleArgumentTypes, lastMethodParameterIndex, methodDeclaration.getLastParam().getType());\n            } else if (countOfNeedleArgumentsPassed == countOfMethodParametersDeclared) {\n                ResolvedType actualArgumentType = needleArgumentTypes.get(lastNeedleArgumentIndex);\n                boolean finalArgumentIsArray = actualArgumentType.isArray() && expectedVariadicParameterType.isAssignableBy(actualArgumentType.asArrayType().getComponentType());\n                if(finalArgumentIsArray) {\n                    // Treat as an array of values -- in which case the expected parameter type is the common type of this array.\n                    // no need to do anything\n//                    expectedVariadicParameterType = actualArgumentType.asArrayType().getComponentType();\n                } else {\n                    // Treat as a single value -- in which case, the expected parameter type is the same as the single value.\n                    needleArgumentTypes = groupVariadicParamValues(needleArgumentTypes, lastMethodParameterIndex, methodDeclaration.getLastParam().getType());\n                }\n            } else {\n                // Should be unreachable.\n            }\n        }\n\n\n        // The index of the final argument passed (on the method usage).\n        int countOfNeedleArgumentsPassedAfterGrouping = needleArgumentTypes.size();\n        int lastNeedleArgumentIndexAfterGrouping = Math.max(0, countOfNeedleArgumentsPassed - 1);\n\n        // If variadic parameters are possible then they will have been \"grouped\" into a single argument.\n        // At this point, therefore, the number of arguments must be equal -- if they're not, then there is no match.\n        if (countOfNeedleArgumentsPassedAfterGrouping != countOfMethodParametersDeclared) {\n            return false;\n        }\n\n\n        Map<String, ResolvedType> matchedParameters = new HashMap<>();\n        boolean needForWildCardTolerance = false;\n        for (int i = 0; i < countOfMethodParametersDeclared; i++) {\n            ResolvedType expectedDeclaredType = methodDeclaration.getParam(i).getType();\n            ResolvedType actualArgumentType = needleArgumentTypes.get(i);\n            if ((expectedDeclaredType.isTypeVariable() && !(expectedDeclaredType.isWildcard())) && expectedDeclaredType.asTypeParameter().declaredOnMethod()) {\n                matchedParameters.put(expectedDeclaredType.asTypeParameter().getName(), actualArgumentType);\n                continue;\n            }\n            \n            boolean isAssignableWithoutSubstitution = expectedDeclaredType.isAssignableBy(actualArgumentType) ||\n                    (methodDeclaration.getParam(i).isVariadic() && new ResolvedArrayType(expectedDeclaredType).isAssignableBy(actualArgumentType));\n\n            if (!isAssignableWithoutSubstitution && expectedDeclaredType.isReferenceType() && actualArgumentType.isReferenceType()) {\n                isAssignableWithoutSubstitution = isAssignableMatchTypeParameters(\n                        expectedDeclaredType.asReferenceType(),\n                        actualArgumentType.asReferenceType(),\n                        matchedParameters);\n            }\n            if (!isAssignableWithoutSubstitution) {\n                List<ResolvedTypeParameterDeclaration> typeParameters = methodDeclaration.getTypeParameters();\n                typeParameters.addAll(methodDeclaration.declaringType().getTypeParameters());\n                for (ResolvedTypeParameterDeclaration tp : typeParameters) {\n                    expectedDeclaredType = replaceTypeParam(expectedDeclaredType, tp, typeSolver);\n                }\n\n                if (!expectedDeclaredType.isAssignableBy(actualArgumentType)) {\n                    if (actualArgumentType.isWildcard() && withWildcardTolerance && !expectedDeclaredType.isPrimitive()) {\n                        needForWildCardTolerance = true;\n                        continue;\n                    }\n                    // if the expected is java.lang.Math.max(double,double) and the type parameters are defined with constrain\n                    // for example LambdaConstraintType{bound=TypeVariable {ReflectionTypeParameter{typeVariable=T}}}, LambdaConstraintType{bound=TypeVariable {ReflectionTypeParameter{typeVariable=U}}}\n                    // we want to keep this method for future resolution\n                    if (actualArgumentType.isConstraint() && withWildcardTolerance && expectedDeclaredType.isPrimitive()) {\n                        needForWildCardTolerance = true;\n                        continue;\n                    }\n                    if (methodIsDeclaredWithVariadicParameter && i == countOfMethodParametersDeclared - 1) {\n                        if (new ResolvedArrayType(expectedDeclaredType).isAssignableBy(actualArgumentType)) {\n                            continue;\n                        }\n                    }\n                    return false;\n                }\n            }\n        }\n        return !withWildcardTolerance || needForWildCardTolerance;\n    }\n\n    public static boolean isAssignableMatchTypeParameters(ResolvedType expected, ResolvedType actual,\n                                                          Map<String, ResolvedType> matchedParameters) {\n        if (expected.isReferenceType() && actual.isReferenceType()) {\n            return isAssignableMatchTypeParameters(expected.asReferenceType(), actual.asReferenceType(), matchedParameters);\n        }\n        if (expected.isTypeVariable()) {\n            matchedParameters.put(expected.asTypeParameter().getName(), actual);\n            return true;\n        }\n        if (expected.isArray()) {\n            matchedParameters.put(expected.asArrayType().getComponentType().toString(), actual);\n            return true;\n        }\n        throw new UnsupportedOperationException(expected.getClass().getCanonicalName() + \" \" + actual.getClass().getCanonicalName());\n    }\n\n    public static boolean isAssignableMatchTypeParameters(ResolvedReferenceType expected, ResolvedReferenceType actual,\n                                                          Map<String, ResolvedType> matchedParameters) {\n        if (actual.getQualifiedName().equals(expected.getQualifiedName())) {\n            return isAssignableMatchTypeParametersMatchingQName(expected, actual, matchedParameters);\n        } else {\n            List<ResolvedReferenceType> ancestors = actual.getAllAncestors();\n            for (ResolvedReferenceType ancestor : ancestors) {\n                if (isAssignableMatchTypeParametersMatchingQName(expected, ancestor, matchedParameters)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    private static boolean isAssignableMatchTypeParametersMatchingQName(ResolvedReferenceType expected, ResolvedReferenceType actual,\n                                                                        Map<String, ResolvedType> matchedParameters) {\n\n        if (!expected.getQualifiedName().equals(actual.getQualifiedName())) {\n            return false;\n        }\n        if (expected.typeParametersValues().size() != actual.typeParametersValues().size()) {\n            throw new UnsupportedOperationException();\n            //return true;\n        }\n        for (int i = 0; i < expected.typeParametersValues().size(); i++) {\n            ResolvedType expectedParam = expected.typeParametersValues().get(i);\n            ResolvedType actualParam = actual.typeParametersValues().get(i);\n\n            // In the case of nested parameterizations eg. List<R> <-> List<Integer>\n            // we should peel off one layer and ensure R <-> Integer\n            if (expectedParam.isReferenceType() && actualParam.isReferenceType()) {\n                ResolvedReferenceType r1 = expectedParam.asReferenceType();\n                ResolvedReferenceType r2 = actualParam.asReferenceType();\n                // we can have r1=A and r2=A.B (with B extends A and B is an inner class of A)\n                // in this case we want to verify expected parameter from the actual parameter ancestors \n                return isAssignableMatchTypeParameters(r1, r2, matchedParameters);\n            }\n\n            if (expectedParam.isTypeVariable()) {\n                String expectedParamName = expectedParam.asTypeParameter().getName();\n                if (!actualParam.isTypeVariable() || !actualParam.asTypeParameter().getName().equals(expectedParamName)) {\n                    return matchTypeVariable(expectedParam.asTypeVariable(), actualParam, matchedParameters);\n                }\n            } else if (expectedParam.isReferenceType()) {\n                if (actualParam.isTypeVariable()) {\n                    return matchTypeVariable(actualParam.asTypeVariable(), expectedParam, matchedParameters);\n                }\n                if (!expectedParam.equals(actualParam)) {\n                    return false;\n                }\n            } else if (expectedParam.isWildcard()) {\n                if (expectedParam.asWildcard().isExtends()) {\n                    return isAssignableMatchTypeParameters(expectedParam.asWildcard().getBoundedType(), actual, matchedParameters);\n                }\n                // TODO verify super bound\n                return true;\n            } else {\n                throw new UnsupportedOperationException(expectedParam.describe());\n            }\n        }\n        return true;\n    }\n\n    private static boolean matchTypeVariable(ResolvedTypeVariable typeVariable, ResolvedType type, Map<String, ResolvedType> matchedParameters) {\n        String typeParameterName = typeVariable.asTypeParameter().getName();\n        if (matchedParameters.containsKey(typeParameterName)) {\n            ResolvedType matchedParameter = matchedParameters.get(typeParameterName);\n            if (matchedParameter.isAssignableBy(type)) {\n                return true;\n            } else if (type.isAssignableBy(matchedParameter)) {\n                // update matchedParameters to contain the more general type\n                matchedParameters.put(typeParameterName, type);\n                return true;\n            }\n            return false;\n        } else {\n            matchedParameters.put(typeParameterName, type);\n        }\n        return true;\n    }\n\n    public static ResolvedType replaceTypeParam(ResolvedType type, ResolvedTypeParameterDeclaration tp, TypeSolver typeSolver) {\n        if (type.isTypeVariable() || type.isWildcard()) {\n            if (type.describe().equals(tp.getName())) {\n                List<ResolvedTypeParameterDeclaration.Bound> bounds = tp.getBounds();\n                if (bounds.size() > 1) {\n                    throw new UnsupportedOperationException();\n                }\n                if (bounds.size() == 1) {\n                    return bounds.get(0).getType();\n                }\n                return new ReferenceTypeImpl(typeSolver.solveType(JAVA_LANG_OBJECT), typeSolver);\n            }\n            return type;\n        }\n        if (type.isPrimitive()) {\n            return type;\n        }\n        if (type.isArray()) {\n            return new ResolvedArrayType(replaceTypeParam(type.asArrayType().getComponentType(), tp, typeSolver));\n        }\n        if (type.isReferenceType()) {\n            ResolvedReferenceType result = type.asReferenceType();\n            result = result.transformTypeParameters(typeParam -> replaceTypeParam(typeParam, tp, typeSolver)).asReferenceType();\n            return result;\n        }\n        throw new UnsupportedOperationException(\"Replacing \" + type + \", param \" + tp + \" with \" + type.getClass().getCanonicalName());\n    }\n\n    /**\n     * Note the specific naming here -- parameters are part of the method declaration,\n     * while arguments are the values passed when calling a method.\n     * Note that \"needle\" refers to that value being used as a search/query term to match against.\n     *\n     * @return true, if the given MethodUsage matches the given name/types (normally obtained from a ResolvedMethodDeclaration)\n     *\n     * @see {@link MethodResolutionLogic#isApplicable(ResolvedMethodDeclaration, String, List, TypeSolver)}  }\n     * @see {@link MethodResolutionLogic#isApplicable(ResolvedMethodDeclaration, String, List, TypeSolver, boolean)}\n     */\n    public static boolean isApplicable(MethodUsage methodUsage, String needleName, List<ResolvedType> needleParameterTypes, TypeSolver typeSolver) {\n        if (!methodUsage.getName().equals(needleName)) {\n            return false;\n        }\n\n        // The index of the final method parameter (on the method declaration).\n        int countOfMethodUsageArgumentsPassed = methodUsage.getNoParams();\n        int lastMethodUsageArgumentIndex = Math.max(0, countOfMethodUsageArgumentsPassed - 1);\n\n        // The index of the final argument passed (on the method usage).\n        int needleParameterCount = needleParameterTypes.size();\n        int lastNeedleParameterIndex = Math.max(0, needleParameterCount - 1);\n\n        // TODO: Does the method usage have a declaration at this point..?\n        boolean methodIsDeclaredWithVariadicParameter = methodUsage.getDeclaration().hasVariadicParameter();\n\n        // If the counts do not match and the method is not variadic, this is not a match.\n        if (!methodIsDeclaredWithVariadicParameter && !(needleParameterCount == countOfMethodUsageArgumentsPassed)) {\n            return false;\n        }\n\n        // If the counts do not match and we have provided too few arguments, this is not a match. Note that variadic parameters\n        // allow you to omit the vararg, which would allow a difference of one, but a difference in count of 2 or more is not a match.\n        if (!(needleParameterCount == countOfMethodUsageArgumentsPassed) && needleParameterCount < lastMethodUsageArgumentIndex) {\n            return false;\n        }\n\n        // Iterate over the arguments given to the method, and compare their types against the given method's declared parameter types\n        for (int i = 0; i < needleParameterCount; i++) {\n            ResolvedType actualArgumentType = needleParameterTypes.get(i);\n\n            ResolvedType expectedArgumentType;\n            boolean reachedVariadicParam = methodIsDeclaredWithVariadicParameter && i >= lastMethodUsageArgumentIndex;\n            if (!reachedVariadicParam) {\n                // Not yet reached the variadic parameters -- the expected type is just whatever is at that position.\n                expectedArgumentType = methodUsage.getParamType(i);\n            } else {\n                // We have reached the variadic parameters -- the expected type is the type of the last declared parameter.\n                expectedArgumentType = methodUsage.getParamType(lastMethodUsageArgumentIndex);\n                // Note that the given variadic value might be an array - if so, use the array's component type rather.\n                // This is only valid if ONE argument has been given to the vararg parameter.\n                // Example: {@code void test(String... s) {}} and {@code test(stringArray)} -- {@code String... is assignable by stringArray}\n                // Example: {@code void test(String[]... s) {}} and {@code test(stringArrayArray)} -- {@code String[]... is assignable by stringArrayArray}\n                boolean argumentIsArray = (needleParameterCount == countOfMethodUsageArgumentsPassed) && expectedArgumentType.isAssignableBy(actualArgumentType);\n                if (!argumentIsArray) {\n                    // Get the component type of the declared parameter type.\n                    expectedArgumentType = expectedArgumentType.asArrayType().getComponentType();\n                }\n            }\n\n            // Consider type parameters directly on the method declaration, and ALSO on the enclosing type (e.g. a class)\n            List<ResolvedTypeParameterDeclaration> typeParameters = methodUsage.getDeclaration().getTypeParameters();\n            typeParameters.addAll(methodUsage.declaringType().getTypeParameters());\n\n            ResolvedType expectedTypeWithoutSubstitutions = expectedArgumentType;\n            ResolvedType expectedTypeWithInference = expectedArgumentType;\n            Map<ResolvedTypeParameterDeclaration, ResolvedType> derivedValues = new HashMap<>();\n\n            // For each declared parameter, infer the types that will replace generics (type parameters)\n            for (int j = 0; j < countOfMethodUsageArgumentsPassed; j++) {\n                ResolvedParameterDeclaration parameter = methodUsage.getDeclaration().getParam(j);\n                ResolvedType parameterType = parameter.getType();\n                if (parameter.isVariadic()) {\n                    // Don't continue if a vararg parameter is reached and there are no arguments left\n                    if (needleParameterCount == j) {\n                        break;\n                    }\n                    parameterType = parameterType.asArrayType().getComponentType();\n                }\n                inferTypes(needleParameterTypes.get(j), parameterType, derivedValues);\n            }\n\n            for (Map.Entry<ResolvedTypeParameterDeclaration, ResolvedType> entry : derivedValues.entrySet()) {\n                ResolvedTypeParameterDeclaration tp = entry.getKey();\n                expectedTypeWithInference = expectedTypeWithInference.replaceTypeVariables(tp, entry.getValue());\n            }\n\n            // Consider cases where type variables can be replaced (e.g. add(E element) vs add(String element))\n            for (ResolvedTypeParameterDeclaration tp : typeParameters) {\n                if (tp.getBounds().isEmpty()) {\n                    //expectedArgumentType = expectedArgumentType.replaceTypeVariables(tp.getName(), new ReferenceTypeUsageImpl(typeSolver.solveType(JAVA_LANG_OBJECT), typeSolver));\n                    expectedArgumentType = expectedArgumentType.replaceTypeVariables(tp, ResolvedWildcard.extendsBound(new ReferenceTypeImpl(typeSolver.solveType(JAVA_LANG_OBJECT), typeSolver)));\n                } else if (tp.getBounds().size() == 1) {\n                    ResolvedTypeParameterDeclaration.Bound bound = tp.getBounds().get(0);\n                    if (bound.isExtends()) {\n                        //expectedArgumentType = expectedArgumentType.replaceTypeVariables(tp.getName(), bound.getType());\n                        expectedArgumentType = expectedArgumentType.replaceTypeVariables(tp, ResolvedWildcard.extendsBound(bound.getType()));\n                    } else {\n                        //expectedArgumentType = expectedArgumentType.replaceTypeVariables(tp.getName(), new ReferenceTypeUsageImpl(typeSolver.solveType(JAVA_LANG_OBJECT), typeSolver));\n                        expectedArgumentType = expectedArgumentType.replaceTypeVariables(tp, ResolvedWildcard.superBound(bound.getType()));\n                    }\n                } else {\n                    throw new UnsupportedOperationException();\n                }\n            }\n\n            // Consider cases where type variables involve bounds e.g. super/extends\n            ResolvedType expectedTypeWithSubstitutions = expectedTypeWithoutSubstitutions;\n            for (ResolvedTypeParameterDeclaration tp : typeParameters) {\n                if (tp.getBounds().isEmpty()) {\n                    expectedTypeWithSubstitutions = expectedTypeWithSubstitutions.replaceTypeVariables(tp, new ReferenceTypeImpl(typeSolver.solveType(JAVA_LANG_OBJECT), typeSolver));\n                } else if (tp.getBounds().size() == 1) {\n                    ResolvedTypeParameterDeclaration.Bound bound = tp.getBounds().get(0);\n                    if (bound.isExtends()) {\n                        expectedTypeWithSubstitutions = expectedTypeWithSubstitutions.replaceTypeVariables(tp, bound.getType());\n                    } else {\n                        expectedTypeWithSubstitutions = expectedTypeWithSubstitutions.replaceTypeVariables(tp, new ReferenceTypeImpl(typeSolver.solveType(JAVA_LANG_OBJECT), typeSolver));\n                    }\n                } else {\n                    throw new UnsupportedOperationException();\n                }\n            }\n\n            // If the given argument still isn't applicable even after considering type arguments/generics, this is not a match.\n            if (!expectedArgumentType.isAssignableBy(actualArgumentType)\n                    && !expectedTypeWithSubstitutions.isAssignableBy(actualArgumentType)\n                    && !expectedTypeWithInference.isAssignableBy(actualArgumentType)\n                    && !expectedTypeWithoutSubstitutions.isAssignableBy(actualArgumentType)) {\n                return false;\n            }\n        }\n\n        // If the checks above haven't failed, then we've found a match.\n        return true;\n    }\n\n    /**\n     * Filters by given function {@param keyExtractor} using a stateful filter mechanism.\n     *\n     * <pre>\n     *      persons.stream().filter(distinctByKey(Person::getName))\n     * </pre>\n     * <p>\n     * The example above would return a distinct list of persons containing only one person per name.\n     */\n    private static <T> Predicate<T> distinctByKey(Function<? super T, ?> keyExtractor) {\n        Set<Object> seen = ConcurrentHashMap.newKeySet();\n        return t -> seen.add(keyExtractor.apply(t));\n    }\n\n    /**\n     * @param methods we expect the methods to be ordered such that inherited methods are later in the list\n     */\n    public static SymbolReference<ResolvedMethodDeclaration> findMostApplicable(List<ResolvedMethodDeclaration> methods,\n                                                                                String name, List<ResolvedType> argumentsTypes, TypeSolver typeSolver) {\n        SymbolReference<ResolvedMethodDeclaration> res = findMostApplicable(methods, name, argumentsTypes, typeSolver, false);\n        if (res.isSolved()) {\n            return res;\n        }\n        return findMostApplicable(methods, name, argumentsTypes, typeSolver, true);\n    }\n\n    public static SymbolReference<ResolvedMethodDeclaration> findMostApplicable(List<ResolvedMethodDeclaration> methods,\n                                                                                String name, List<ResolvedType> argumentsTypes,\n                                                                                TypeSolver typeSolver,\n                                                                                boolean wildcardTolerance\n    ) {\n\n        List<ResolvedMethodDeclaration> applicableMethods = methods.stream()\n                // Only consider methods with a matching name\n                .filter(m -> m.getName().equals(name))\n                // Filters out duplicate ResolvedMethodDeclaration by their signature.\n                .filter(distinctByKey(ResolvedMethodDeclaration::getQualifiedSignature))\n                // Checks if ResolvedMethodDeclaration is applicable to argumentsTypes.\n                .filter((m) -> isApplicable(m, name, argumentsTypes, typeSolver, wildcardTolerance))\n                .collect(Collectors.toList());\n\n        // If no applicable methods found, return as unsolved.\n        if (applicableMethods.isEmpty()) {\n            return SymbolReference.unsolved(ResolvedMethodDeclaration.class);\n        }\n\n        // If there are multiple possible methods found, null arguments can help to eliminate some matches.\n        if (applicableMethods.size() > 1) {\n            List<Integer> nullParamIndexes = new ArrayList<>();\n            for (int i = 0; i < argumentsTypes.size(); i++) {\n                if (argumentsTypes.get(i).isNull()) {\n                    nullParamIndexes.add(i);\n                }\n            }\n\n            // If some null arguments have been provided, use this to eliminate some opitons.\n            if (!nullParamIndexes.isEmpty()) {\n                // remove method with array param if a non array exists and arg is null\n                Set<ResolvedMethodDeclaration> removeCandidates = new HashSet<>();\n                for (Integer nullParamIndex : nullParamIndexes) {\n                    for (ResolvedMethodDeclaration methDecl : applicableMethods) {\n                        if (methDecl.getParam(nullParamIndex).getType().isArray()) {\n                            removeCandidates.add(methDecl);\n                        }\n                    }\n                }\n\n                // Where candidiates for removal are found, remove them.\n                if (!removeCandidates.isEmpty() && removeCandidates.size() < applicableMethods.size()) {\n                    applicableMethods.removeAll(removeCandidates);\n                }\n            }\n        }\n\n        // If only one applicable method found, short-circuit and return it here.\n        if (applicableMethods.size() == 1) {\n            return SymbolReference.solved(applicableMethods.get(0));\n        }\n        \n        // Examine the applicable methods found, and evaluate each to determine the \"best\" one\n        ResolvedMethodDeclaration winningCandidate = applicableMethods.get(0);\n        ResolvedMethodDeclaration other = null;\n        boolean possibleAmbiguity = false;\n        for (int i = 1; i < applicableMethods.size(); i++) {\n            other = applicableMethods.get(i);\n            if (isMoreSpecific(winningCandidate, other, argumentsTypes)) {\n                possibleAmbiguity = false;\n            } else if (isMoreSpecific(other, winningCandidate, argumentsTypes)) {\n                possibleAmbiguity = false;\n                winningCandidate = other;\n            } else {\n                // 15.12.2.5. Choosing the Most Specific Method\n                // One applicable method m1 is more specific than another applicable method m2, for an invocation with argument\n                // expressions e1, ..., ek, if any of the following are true:\n                // m2 is generic, and m1 is inferred to be more specific than m2 for argument expressions e1, ..., ek by \u00a718.5.4.\n                // 18.5.4. More Specific Method Inference should be verified \n                // ...\n                if (winningCandidate.isGeneric() && !other.isGeneric()) {\n                    winningCandidate = other;\n                } else if (!winningCandidate.isGeneric() && other.isGeneric()) {\n                    // nothing to do at this stage winningCandidate is the winner\n                } else if (winningCandidate.declaringType().getQualifiedName().equals(other.declaringType().getQualifiedName())) {\n                    possibleAmbiguity = true;\n                } else {\n                    // we expect the methods to be ordered such that inherited methods are later in the list\n                }\n            }\n        }\n        \n        if (possibleAmbiguity) {\n            // pick the first exact match if it exists\n            if (!isExactMatch(winningCandidate, argumentsTypes)) {\n                if (isExactMatch(other, argumentsTypes)) {\n                    winningCandidate = other;\n                } else {\n                    throw new MethodAmbiguityException(\n                            \"Ambiguous method call: cannot find a most applicable method: \" + winningCandidate\n                                    + \", \" + other);\n                }\n            }\n        }\n\n        return SymbolReference.solved(winningCandidate);\n    }\n\n    protected static boolean isExactMatch(ResolvedMethodLikeDeclaration method, List<ResolvedType> argumentsTypes) {\n        for (int i = 0; i < method.getNumberOfParams(); i++) {\n            if (!method.getParam(i).getType().equals(argumentsTypes.get(i))) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private static ResolvedType getMethodsExplicitAndVariadicParameterType(ResolvedMethodDeclaration method, int i) {\n        int numberOfParams = method.getNumberOfParams();\n\n        if (i < numberOfParams) {\n            return method.getParam(i).getType();\n        }\n        if (method.hasVariadicParameter()) {\n            return method.getParam(numberOfParams - 1).getType();\n        }\n        return null;\n    }\n\n    private static boolean isMoreSpecific(ResolvedMethodDeclaration methodA, ResolvedMethodDeclaration methodB,\n                                          List<ResolvedType> argumentTypes) {\n\n        final boolean aVariadic = methodA.hasVariadicParameter();\n        final boolean bVariadic = methodB.hasVariadicParameter();\n        final int aNumberOfParams = methodA.getNumberOfParams();\n        final int bNumberOfParams = methodB.getNumberOfParams();\n        final int numberOfArgs = argumentTypes.size();\n        final ResolvedType lastArgType = numberOfArgs > 0 ? argumentTypes.get(numberOfArgs - 1) : null;\n        final boolean isLastArgArray = lastArgType != null && lastArgType.isArray();\n        int omittedArgs = 0;\n        boolean isMethodAMoreSpecific = false;\n\n        // If one method declaration has exactly the correct amount of parameters and is not variadic then it is always\n        // preferred to a declaration that is variadic (and hence possibly also has a different amount of parameters).\n        if (!aVariadic && aNumberOfParams == numberOfArgs && (bVariadic && (bNumberOfParams != numberOfArgs ||\n                !isLastArgArray))) {\n            return true;\n        }\n        if (!bVariadic && bNumberOfParams == numberOfArgs && (aVariadic && (aNumberOfParams != numberOfArgs ||\n                !isLastArgArray))) {\n            return false;\n        }\n        \n        // If both methods are variadic but the calling method omits any varArgs, bump the omitted args to\n        // ensure the varargs type is considered when determining which method is more specific\n        if (aVariadic && bVariadic && aNumberOfParams == bNumberOfParams && numberOfArgs == aNumberOfParams - 1) {\n        \tomittedArgs++;\n        }\n\n        // Either both methods are variadic or neither is. So we must compare the parameter types.\n        for (int i = 0; i < numberOfArgs + omittedArgs; i++) {\n            ResolvedType paramTypeA = getMethodsExplicitAndVariadicParameterType(methodA, i);\n            ResolvedType paramTypeB = getMethodsExplicitAndVariadicParameterType(methodB, i);\n            \n            ResolvedType argType = null;\n            if (i < argumentTypes.size()) {\n            \targType = argumentTypes.get(i);\n            }\n\n            // Safety: if a type is null it means a signature with too few parameters managed to get to this point.\n            // This should not happen but it also means that this signature is immediately disqualified.\n            if (paramTypeA == null) {\n                return false;\n            }\n            if (paramTypeB == null) {\n                return true;\n            }\n            // Widening primitive conversions have priority over boxing/unboxing conversions when finding the most\n            // applicable method. E.g. assume we have method call foo(1) and declarations foo(long) and foo(Integer).\n            // The method call will call foo(long), as it requires a widening primitive conversion from int to long\n            // instead of a boxing conversion from int to Integer. See JLS \u00a715.12.2.\n            // This is what we check here.\n            if (argType != null &&\n            \t\tparamTypeA.isPrimitive() == argType.isPrimitive() &&\n                    paramTypeB.isPrimitive() != argType.isPrimitive() &&\n                    paramTypeA.isAssignableBy(argType)) {\n\n                return true;\n            }\n            if (argType != null &&\n            \t\tparamTypeB.isPrimitive() == argType.isPrimitive() &&\n                    paramTypeA.isPrimitive() != argType.isPrimitive() &&\n                    paramTypeB.isAssignableBy(argType)) {\n\n                return false;\n            // if paramA and paramB are not the last parameters\n            // and the type of paramA or paramB (which are not more specific at this stage) is java.lang.Object\n            // then we have to consider others parameters before concluding\n            }\n            if ((i < numberOfArgs - 1)\n                    && (isJavaLangObject(paramTypeB) || (isJavaLangObject(paramTypeA)))) {\n                // consider others parameters\n                // but eventually mark the method A as more specific if the methodB has an argument of type java.lang.Object\n                isMethodAMoreSpecific = isMethodAMoreSpecific || isJavaLangObject(paramTypeB);\n            }\n            // If we get to this point then we check whether one of the methods contains a parameter type that is more\n            // specific. If it does, we can assume the entire declaration is more specific as we would otherwise have\n            // a situation where the declarations are ambiguous in the given context.\n            else {\n                boolean aAssignableFromB = paramTypeA.isAssignableBy(paramTypeB);\n                boolean bAssignableFromA = paramTypeB.isAssignableBy(paramTypeA);\n\n                if (bAssignableFromA && !aAssignableFromB) {\n                    // A's parameter is more specific\n                    return true;\n                }\n                if (aAssignableFromB && !bAssignableFromA) {\n                    // B's parameter is more specific\n                    return false;\n                }\n            }\n        }\n\n        if (aVariadic && !bVariadic) {\n            // if the last argument is an array then m1 is more specific\n            return isLastArgArray;\n        }\n        if (!aVariadic && bVariadic) {\n            // if the last argument is an array and m1 is not variadic then\n            // it is not more specific\n            return !isLastArgArray;\n        }\n\n        return isMethodAMoreSpecific;\n    }\n    \n    private static boolean isJavaLangObject(ResolvedType paramType ) {\n        return paramType.isReferenceType() && paramType.asReferenceType().getQualifiedName().equals(\"java.lang.Object\");\n    }\n\n    private static boolean isMoreSpecific(MethodUsage methodA, MethodUsage methodB) {\n        boolean oneMoreSpecificFound = false;\n        for (int i = 0; i < methodA.getNoParams(); i++) {\n            ResolvedType tdA = methodA.getParamType(i);\n            ResolvedType tdB = methodB.getParamType(i);\n\n            boolean aIsAssignableByB = tdA.isAssignableBy(tdB);\n            boolean bIsAssignableByA = tdB.isAssignableBy(tdA);\n\n            // A is more specific\n            if (bIsAssignableByA && !aIsAssignableByB) {\n                oneMoreSpecificFound = true;\n            }\n            // B is more specific\n            if (aIsAssignableByB && !bIsAssignableByA) {\n                return false;\n            }\n\n            // If B is vararg and A is not, A is more specific\n            if (tdB.isArray() && tdB.asArrayType().getComponentType().isAssignableBy(tdA)) {\n                oneMoreSpecificFound = true;\n            }\n        }\n        return oneMoreSpecificFound;\n    }\n\n    public static Optional<MethodUsage> findMostApplicableUsage(List<MethodUsage> methods, String name, List<ResolvedType> argumentsTypes, TypeSolver typeSolver) {\n        List<MethodUsage> applicableMethods = methods.stream().filter((m) -> isApplicable(m, name, argumentsTypes, typeSolver)).collect(Collectors.toList());\n\n        if (applicableMethods.isEmpty()) {\n            return Optional.empty();\n        }\n        if (applicableMethods.size() == 1) {\n            return Optional.of(applicableMethods.get(0));\n        } else {\n            MethodUsage winningCandidate = applicableMethods.get(0);\n            for (int i = 1; i < applicableMethods.size(); i++) {\n                MethodUsage other = applicableMethods.get(i);\n                if (isMoreSpecific(winningCandidate, other)) {\n                    // nothing to do\n                } else if (isMoreSpecific(other, winningCandidate)) {\n                    winningCandidate = other;\n                } else {\n                    if (winningCandidate.declaringType().getQualifiedName().equals(other.declaringType().getQualifiedName())) {\n                        if (!areOverride(winningCandidate, other)) {\n                            throw new MethodAmbiguityException(\"Ambiguous method call: cannot find a most applicable method: \" + winningCandidate + \", \" + other + \". First declared in \" + winningCandidate.declaringType().getQualifiedName());\n                        }\n                    } else {\n                        // we expect the methods to be ordered such that inherited methods are later in the list\n                        //throw new UnsupportedOperationException();\n                    }\n                }\n            }\n            return Optional.of(winningCandidate);\n        }\n    }\n\n    private static boolean areOverride(MethodUsage winningCandidate, MethodUsage other) {\n        if (!winningCandidate.getName().equals(other.getName())) {\n            return false;\n        }\n        if (winningCandidate.getNoParams() != other.getNoParams()) {\n            return false;\n        }\n        for (int i = 0; i < winningCandidate.getNoParams(); i++) {\n            if (!winningCandidate.getParamTypes().get(i).equals(other.getParamTypes().get(i))) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static SymbolReference<ResolvedMethodDeclaration> solveMethodInType(ResolvedTypeDeclaration typeDeclaration,\n                                                                               String name,\n                                                                               List<ResolvedType> argumentsTypes) {\n        return solveMethodInType(typeDeclaration, name, argumentsTypes, false);\n    }\n\n    // TODO: Replace TypeDeclaration.solveMethod\n    public static SymbolReference<ResolvedMethodDeclaration> solveMethodInType(ResolvedTypeDeclaration typeDeclaration,\n                                                                               String name,\n                                                                               List<ResolvedType> argumentsTypes,\n                                                                               boolean staticOnly) {\n\n        if (typeDeclaration instanceof MethodResolutionCapability) {\n            return ((MethodResolutionCapability) typeDeclaration).solveMethod(name, argumentsTypes,\n                    staticOnly);\n        }\n        throw new UnsupportedOperationException(typeDeclaration.getClass().getCanonicalName());\n    }\n\n    private static void inferTypes(ResolvedType source, ResolvedType target, Map<ResolvedTypeParameterDeclaration, ResolvedType> mappings) {\n        if (source.equals(target)) {\n            return;\n        }\n        if (source.isReferenceType() && target.isReferenceType()) {\n            ResolvedReferenceType sourceRefType = source.asReferenceType();\n            ResolvedReferenceType targetRefType = target.asReferenceType();\n            if (sourceRefType.getQualifiedName().equals(targetRefType.getQualifiedName())) {\n                if (!sourceRefType.isRawType() && !targetRefType.isRawType()) {\n                    for (int i = 0; i < sourceRefType.typeParametersValues().size(); i++) {\n                        inferTypes(sourceRefType.typeParametersValues().get(i), targetRefType.typeParametersValues().get(i), mappings);\n                    }\n                }\n            }\n            return;\n        }\n        if (source.isReferenceType() && target.isWildcard()) {\n            if (target.asWildcard().isBounded()) {\n                inferTypes(source, target.asWildcard().getBoundedType(), mappings);\n                return;\n            }\n            return;\n        }\n        if (source.isWildcard() && target.isWildcard()) {\n            return;\n        }\n        if (source.isReferenceType() && target.isTypeVariable()) {\n            mappings.put(target.asTypeParameter(), source);\n            return;\n        }\n\n        if (source.isWildcard() && target.isReferenceType()) {\n            if (source.asWildcard().isBounded()) {\n                inferTypes(source.asWildcard().getBoundedType(), target, mappings);\n            }\n            return;\n        }\n\n        if (source.isWildcard() && target.isTypeVariable()) {\n            mappings.put(target.asTypeParameter(), source);\n            return;\n        }\n        if (source.isTypeVariable() && target.isTypeVariable()) {\n            mappings.put(target.asTypeParameter(), source);\n            return;\n        }\n        if (source.isPrimitive() || target.isPrimitive()) {\n            return;\n        }\n        if (source.isNull()) {\n            return;\n        }\n    }\n\n}\n",
        "filePathAfter": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/MethodResolutionLogic.java",
        "sourceCodeAfterForWhole": "/*\n * Copyright (C) 2015-2016 Federico Tomassetti\n * Copyright (C) 2017-2020 The JavaParser Team.\n *\n * This file is part of JavaParser.\n *\n * JavaParser can be used either under the terms of\n * a) the GNU Lesser General Public License as published by\n *     the Free Software Foundation, either version 3 of the License, or\n *     (at your option) any later version.\n * b) the terms of the Apache License\n *\n * You should have received a copy of both licenses in LICENCE.LGPL and\n * LICENCE.APACHE. Please refer to those files for details.\n *\n * JavaParser is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n */\n\npackage com.github.javaparser.symbolsolver.resolution;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.Set;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.function.Function;\nimport java.util.function.Predicate;\nimport java.util.stream.Collectors;\n\nimport com.github.javaparser.resolution.MethodAmbiguityException;\nimport com.github.javaparser.resolution.MethodUsage;\nimport com.github.javaparser.resolution.declarations.ResolvedMethodDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedMethodLikeDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedParameterDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedTypeDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedTypeParameterDeclaration;\nimport com.github.javaparser.resolution.types.ResolvedArrayType;\nimport com.github.javaparser.resolution.types.ResolvedReferenceType;\nimport com.github.javaparser.resolution.types.ResolvedType;\nimport com.github.javaparser.resolution.types.ResolvedTypeVariable;\nimport com.github.javaparser.resolution.types.ResolvedWildcard;\nimport com.github.javaparser.symbolsolver.logic.MethodResolutionCapability;\nimport com.github.javaparser.symbolsolver.model.resolution.SymbolReference;\nimport com.github.javaparser.symbolsolver.model.resolution.TypeSolver;\nimport com.github.javaparser.symbolsolver.model.typesystem.ReferenceTypeImpl;\n\n/**\n * @author Federico Tomassetti\n */\npublic class MethodResolutionLogic {\n    \n    private static String JAVA_LANG_OBJECT = Object.class.getCanonicalName();\n\n    private static List<ResolvedType> groupVariadicParamValues(List<ResolvedType> argumentsTypes, int startVariadic, ResolvedType variadicType) {\n        List<ResolvedType> res = new ArrayList<>(argumentsTypes.subList(0, startVariadic));\n        List<ResolvedType> variadicValues = argumentsTypes.subList(startVariadic, argumentsTypes.size());\n        if (variadicValues.isEmpty()) {\n            // TODO if there are no variadic values we should default to the bound of the formal type\n            res.add(variadicType);\n        } else {\n            ResolvedType componentType = findCommonType(variadicValues);\n            res.add(new ResolvedArrayType(componentType));\n        }\n        return res;\n    }\n\n    private static ResolvedType findCommonType(List<ResolvedType> variadicValues) {\n        if (variadicValues.isEmpty()) {\n            throw new IllegalArgumentException();\n        }\n        // TODO implement this decently\n        return variadicValues.get(0);\n    }\n\n    public static boolean isApplicable(ResolvedMethodDeclaration method, String name, List<ResolvedType> argumentsTypes, TypeSolver typeSolver) {\n        return isApplicable(method, name, argumentsTypes, typeSolver, false);\n    }\n\n    /**\n     * Note the specific naming here -- parameters are part of the method declaration,\n     * while arguments are the values passed when calling a method.\n     * Note that \"needle\" refers to that value being used as a search/query term to match against.\n     *\n     * @return true, if the given ResolvedMethodDeclaration matches the given name/types (normally obtained from a MethodUsage)\n     *\n     * @see {@link MethodResolutionLogic#isApplicable(MethodUsage, String, List, TypeSolver)}\n     */\n    private static boolean isApplicable(ResolvedMethodDeclaration methodDeclaration, String needleName, List<ResolvedType> needleArgumentTypes, TypeSolver typeSolver, boolean withWildcardTolerance) {\n        if (!methodDeclaration.getName().equals(needleName)) {\n            return false;\n        }\n\n        // The index of the final method parameter (on the method declaration).\n        int countOfMethodParametersDeclared = methodDeclaration.getNumberOfParams();\n\n        // The index of the final argument passed (on the method usage).\n        int countOfNeedleArgumentsPassed = needleArgumentTypes.size();\n\n        boolean methodIsDeclaredWithVariadicParameter = methodDeclaration.hasVariadicParameter();\n\n        if (!methodIsDeclaredWithVariadicParameter && (countOfNeedleArgumentsPassed != countOfMethodParametersDeclared)) {\n            // If it is not variadic, and the number of parameters/arguments are unequal -- this is not a match.\n            return false;\n        }\n\n        if (methodIsDeclaredWithVariadicParameter) {\n\n            if(countOfNeedleArgumentsPassed <= (countOfMethodParametersDeclared - 2)) {\n                // If it is variadic, and the number of arguments are short by **two or more** -- this is not a match.\n                // Note that omitting the variadic parameter is treated as an empty array\n                //  (thus being short of only 1 argument is fine, but being short of 2 or more is not).\n                return false;\n            }\n            \n            // If the method declaration we're considering has a variadic parameter,\n            // attempt to convert the given list of arguments to fit this pattern\n            // e.g. foo(String s, String... s2) {} --- consider the first argument, then group the remainder as an array\n\n            ResolvedType expectedVariadicParameterType = methodDeclaration.getLastParam().getType();\n            for (ResolvedTypeParameterDeclaration tp : methodDeclaration.getTypeParameters()) {\n                expectedVariadicParameterType = replaceTypeParam(expectedVariadicParameterType, tp, typeSolver);\n            }\n            \n            if (countOfNeedleArgumentsPassed > countOfMethodParametersDeclared) {\n                // If it is variadic, and we have an \"excess\" of arguments, group the \"trailing\" arguments into an array.\n                // Confirm all of these grouped \"trailing\" arguments have the required type -- if not, this is not a valid type. (Maybe this is also done later..?)\n                for(int variadicArgumentIndex = countOfMethodParametersDeclared; variadicArgumentIndex < countOfNeedleArgumentsPassed; variadicArgumentIndex++) {\n                    ResolvedType currentArgumentType = needleArgumentTypes.get(variadicArgumentIndex);\n                    boolean argumentIsAssignableToVariadicComponentType = expectedVariadicParameterType.asArrayType().getComponentType().isAssignableBy(currentArgumentType);\n                    if(!argumentIsAssignableToVariadicComponentType) {\n                        // If any of the arguments are not assignable to the expected variadic type, this is not a match.\n                        return false;\n                    }\n                }\n            }\n            needleArgumentTypes = groupTrailingArgumentsIntoArray(methodDeclaration, needleArgumentTypes, expectedVariadicParameterType);\n        }\n\n\n        // The index of the final argument passed (on the method usage).\n        int countOfNeedleArgumentsPassedAfterGrouping = needleArgumentTypes.size();\n        int lastNeedleArgumentIndexAfterGrouping = getLastParameterIndex(countOfNeedleArgumentsPassed);\n\n        // If variadic parameters are possible then they will have been \"grouped\" into a single argument.\n        // At this point, therefore, the number of arguments must be equal -- if they're not, then there is no match.\n        if (countOfNeedleArgumentsPassedAfterGrouping != countOfMethodParametersDeclared) {\n            return false;\n        }\n\n\n        Map<String, ResolvedType> matchedParameters = new HashMap<>();\n        boolean needForWildCardTolerance = false;\n        for (int i = 0; i < countOfMethodParametersDeclared; i++) {\n            ResolvedType expectedDeclaredType = methodDeclaration.getParam(i).getType();\n            ResolvedType actualArgumentType = needleArgumentTypes.get(i);\n            if ((expectedDeclaredType.isTypeVariable() && !(expectedDeclaredType.isWildcard())) && expectedDeclaredType.asTypeParameter().declaredOnMethod()) {\n                matchedParameters.put(expectedDeclaredType.asTypeParameter().getName(), actualArgumentType);\n                continue;\n            }\n            \n            boolean isAssignableWithoutSubstitution = expectedDeclaredType.isAssignableBy(actualArgumentType) ||\n                    (methodDeclaration.getParam(i).isVariadic() && new ResolvedArrayType(expectedDeclaredType).isAssignableBy(actualArgumentType));\n\n            if (!isAssignableWithoutSubstitution && expectedDeclaredType.isReferenceType() && actualArgumentType.isReferenceType()) {\n                isAssignableWithoutSubstitution = isAssignableMatchTypeParameters(\n                        expectedDeclaredType.asReferenceType(),\n                        actualArgumentType.asReferenceType(),\n                        matchedParameters);\n            }\n            if (!isAssignableWithoutSubstitution) {\n                List<ResolvedTypeParameterDeclaration> typeParameters = methodDeclaration.getTypeParameters();\n                typeParameters.addAll(methodDeclaration.declaringType().getTypeParameters());\n                for (ResolvedTypeParameterDeclaration tp : typeParameters) {\n                    expectedDeclaredType = replaceTypeParam(expectedDeclaredType, tp, typeSolver);\n                }\n\n                if (!expectedDeclaredType.isAssignableBy(actualArgumentType)) {\n                    if (actualArgumentType.isWildcard() && withWildcardTolerance && !expectedDeclaredType.isPrimitive()) {\n                        needForWildCardTolerance = true;\n                        continue;\n                    }\n                    // if the expected is java.lang.Math.max(double,double) and the type parameters are defined with constrain\n                    // for example LambdaConstraintType{bound=TypeVariable {ReflectionTypeParameter{typeVariable=T}}}, LambdaConstraintType{bound=TypeVariable {ReflectionTypeParameter{typeVariable=U}}}\n                    // we want to keep this method for future resolution\n                    if (actualArgumentType.isConstraint() && withWildcardTolerance && expectedDeclaredType.isPrimitive()) {\n                        needForWildCardTolerance = true;\n                        continue;\n                    }\n                    if (methodIsDeclaredWithVariadicParameter && i == countOfMethodParametersDeclared - 1) {\n                        if (new ResolvedArrayType(expectedDeclaredType).isAssignableBy(actualArgumentType)) {\n                            continue;\n                        }\n                    }\n                    return false;\n                }\n            }\n        }\n        return !withWildcardTolerance || needForWildCardTolerance;\n    }\n\n    /*\n     * Returns the last parameter index\n     */\n    private static int getLastParameterIndex(int countOfMethodParametersDeclared) {\n        return Math.max(0, countOfMethodParametersDeclared - 1);\n    }\n\n    private static List<ResolvedType> groupTrailingArgumentsIntoArray(ResolvedMethodDeclaration methodDeclaration,\n                                                                      List<ResolvedType> needleArgumentTypes,\n                                                                      ResolvedType expectedVariadicParameterType) {\n        // The index of the final method parameter (on the method declaration).\n        int countOfMethodParametersDeclared = methodDeclaration.getNumberOfParams();\n        int lastMethodParameterIndex = getLastParameterIndex(countOfMethodParametersDeclared);\n\n        // The index of the final argument passed (on the method usage).\n        int countOfNeedleArgumentsPassed = needleArgumentTypes.size();\n        int lastNeedleArgumentIndex = getLastParameterIndex(countOfNeedleArgumentsPassed);\n        \n        if (countOfNeedleArgumentsPassed > countOfMethodParametersDeclared) {\n            // If it is variadic, and we have an \"excess\" of arguments, group the \"trailing\" arguments into an array.\n            // Here we are sure that all of these grouped \"trailing\" arguments have the required type\n            needleArgumentTypes = groupVariadicParamValues(needleArgumentTypes, lastMethodParameterIndex, methodDeclaration.getLastParam().getType());\n        }\n        if (countOfNeedleArgumentsPassed == (countOfMethodParametersDeclared - 1)) {\n            // If it is variadic and we are short of **exactly one** parameter, this is a match.\n            // Note that omitting the variadic parameter is treated as an empty array\n            //  (thus being short of only 1 argument is fine, but being short of 2 or more is not).\n\n            // thus group the \"empty\" value into an empty array...\n            needleArgumentTypes = groupVariadicParamValues(needleArgumentTypes, lastMethodParameterIndex, methodDeclaration.getLastParam().getType());\n        } else if (countOfNeedleArgumentsPassed == countOfMethodParametersDeclared) {\n            ResolvedType actualArgumentType = needleArgumentTypes.get(lastNeedleArgumentIndex);\n            boolean finalArgumentIsArray = actualArgumentType.isArray() && expectedVariadicParameterType.isAssignableBy(actualArgumentType.asArrayType().getComponentType());\n            if(finalArgumentIsArray) {\n                // Treat as an array of values -- in which case the expected parameter type is the common type of this array.\n                // no need to do anything\n                // expectedVariadicParameterType = actualArgumentType.asArrayType().getComponentType();\n            } else {\n                // Treat as a single value -- in which case, the expected parameter type is the same as the single value.\n                needleArgumentTypes = groupVariadicParamValues(needleArgumentTypes, lastMethodParameterIndex, methodDeclaration.getLastParam().getType());\n            }\n        } else {\n            // Should be unreachable.\n        }\n        return needleArgumentTypes;\n    }\n\n    public static boolean isAssignableMatchTypeParameters(ResolvedType expected, ResolvedType actual,\n                                                          Map<String, ResolvedType> matchedParameters) {\n        if (expected.isReferenceType() && actual.isReferenceType()) {\n            return isAssignableMatchTypeParameters(expected.asReferenceType(), actual.asReferenceType(), matchedParameters);\n        }\n        if (expected.isTypeVariable()) {\n            matchedParameters.put(expected.asTypeParameter().getName(), actual);\n            return true;\n        }\n        if (expected.isArray()) {\n            matchedParameters.put(expected.asArrayType().getComponentType().toString(), actual);\n            return true;\n        }\n        throw new UnsupportedOperationException(expected.getClass().getCanonicalName() + \" \" + actual.getClass().getCanonicalName());\n    }\n\n    public static boolean isAssignableMatchTypeParameters(ResolvedReferenceType expected, ResolvedReferenceType actual,\n                                                          Map<String, ResolvedType> matchedParameters) {\n        if (actual.getQualifiedName().equals(expected.getQualifiedName())) {\n            return isAssignableMatchTypeParametersMatchingQName(expected, actual, matchedParameters);\n        } else {\n            List<ResolvedReferenceType> ancestors = actual.getAllAncestors();\n            for (ResolvedReferenceType ancestor : ancestors) {\n                if (isAssignableMatchTypeParametersMatchingQName(expected, ancestor, matchedParameters)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    private static boolean isAssignableMatchTypeParametersMatchingQName(ResolvedReferenceType expected, ResolvedReferenceType actual,\n                                                                        Map<String, ResolvedType> matchedParameters) {\n\n        if (!expected.getQualifiedName().equals(actual.getQualifiedName())) {\n            return false;\n        }\n        if (expected.typeParametersValues().size() != actual.typeParametersValues().size()) {\n            throw new UnsupportedOperationException();\n            //return true;\n        }\n        for (int i = 0; i < expected.typeParametersValues().size(); i++) {\n            ResolvedType expectedParam = expected.typeParametersValues().get(i);\n            ResolvedType actualParam = actual.typeParametersValues().get(i);\n\n            // In the case of nested parameterizations eg. List<R> <-> List<Integer>\n            // we should peel off one layer and ensure R <-> Integer\n            if (expectedParam.isReferenceType() && actualParam.isReferenceType()) {\n                ResolvedReferenceType r1 = expectedParam.asReferenceType();\n                ResolvedReferenceType r2 = actualParam.asReferenceType();\n                // we can have r1=A and r2=A.B (with B extends A and B is an inner class of A)\n                // in this case we want to verify expected parameter from the actual parameter ancestors \n                return isAssignableMatchTypeParameters(r1, r2, matchedParameters);\n            }\n\n            if (expectedParam.isTypeVariable()) {\n                String expectedParamName = expectedParam.asTypeParameter().getName();\n                if (!actualParam.isTypeVariable() || !actualParam.asTypeParameter().getName().equals(expectedParamName)) {\n                    return matchTypeVariable(expectedParam.asTypeVariable(), actualParam, matchedParameters);\n                }\n            } else if (expectedParam.isReferenceType()) {\n                if (actualParam.isTypeVariable()) {\n                    return matchTypeVariable(actualParam.asTypeVariable(), expectedParam, matchedParameters);\n                }\n                if (!expectedParam.equals(actualParam)) {\n                    return false;\n                }\n            } else if (expectedParam.isWildcard()) {\n                if (expectedParam.asWildcard().isExtends()) {\n                    return isAssignableMatchTypeParameters(expectedParam.asWildcard().getBoundedType(), actual, matchedParameters);\n                }\n                // TODO verify super bound\n                return true;\n            } else {\n                throw new UnsupportedOperationException(expectedParam.describe());\n            }\n        }\n        return true;\n    }\n\n    private static boolean matchTypeVariable(ResolvedTypeVariable typeVariable, ResolvedType type, Map<String, ResolvedType> matchedParameters) {\n        String typeParameterName = typeVariable.asTypeParameter().getName();\n        if (matchedParameters.containsKey(typeParameterName)) {\n            ResolvedType matchedParameter = matchedParameters.get(typeParameterName);\n            if (matchedParameter.isAssignableBy(type)) {\n                return true;\n            } else if (type.isAssignableBy(matchedParameter)) {\n                // update matchedParameters to contain the more general type\n                matchedParameters.put(typeParameterName, type);\n                return true;\n            }\n            return false;\n        } else {\n            matchedParameters.put(typeParameterName, type);\n        }\n        return true;\n    }\n\n    public static ResolvedType replaceTypeParam(ResolvedType type, ResolvedTypeParameterDeclaration tp, TypeSolver typeSolver) {\n        if (type.isTypeVariable() || type.isWildcard()) {\n            if (type.describe().equals(tp.getName())) {\n                List<ResolvedTypeParameterDeclaration.Bound> bounds = tp.getBounds();\n                if (bounds.size() > 1) {\n                    throw new UnsupportedOperationException();\n                }\n                if (bounds.size() == 1) {\n                    return bounds.get(0).getType();\n                }\n                return new ReferenceTypeImpl(typeSolver.solveType(JAVA_LANG_OBJECT), typeSolver);\n            }\n            return type;\n        }\n        if (type.isPrimitive()) {\n            return type;\n        }\n        if (type.isArray()) {\n            return new ResolvedArrayType(replaceTypeParam(type.asArrayType().getComponentType(), tp, typeSolver));\n        }\n        if (type.isReferenceType()) {\n            ResolvedReferenceType result = type.asReferenceType();\n            result = result.transformTypeParameters(typeParam -> replaceTypeParam(typeParam, tp, typeSolver)).asReferenceType();\n            return result;\n        }\n        throw new UnsupportedOperationException(\"Replacing \" + type + \", param \" + tp + \" with \" + type.getClass().getCanonicalName());\n    }\n\n    /**\n     * Note the specific naming here -- parameters are part of the method declaration,\n     * while arguments are the values passed when calling a method.\n     * Note that \"needle\" refers to that value being used as a search/query term to match against.\n     *\n     * @return true, if the given MethodUsage matches the given name/types (normally obtained from a ResolvedMethodDeclaration)\n     *\n     * @see {@link MethodResolutionLogic#isApplicable(ResolvedMethodDeclaration, String, List, TypeSolver)}  }\n     * @see {@link MethodResolutionLogic#isApplicable(ResolvedMethodDeclaration, String, List, TypeSolver, boolean)}\n     */\n    public static boolean isApplicable(MethodUsage methodUsage, String needleName, List<ResolvedType> needleParameterTypes, TypeSolver typeSolver) {\n        if (!methodUsage.getName().equals(needleName)) {\n            return false;\n        }\n\n        // The index of the final method parameter (on the method declaration).\n        int countOfMethodUsageArgumentsPassed = methodUsage.getNoParams();\n        int lastMethodUsageArgumentIndex = getLastParameterIndex(countOfMethodUsageArgumentsPassed);\n\n        // The index of the final argument passed (on the method usage).\n        int needleParameterCount = needleParameterTypes.size();\n        int lastNeedleParameterIndex = getLastParameterIndex(needleParameterCount);\n\n        // TODO: Does the method usage have a declaration at this point..?\n        boolean methodIsDeclaredWithVariadicParameter = methodUsage.getDeclaration().hasVariadicParameter();\n\n        // If the counts do not match and the method is not variadic, this is not a match.\n        if (!methodIsDeclaredWithVariadicParameter && !(needleParameterCount == countOfMethodUsageArgumentsPassed)) {\n            return false;\n        }\n\n        // If the counts do not match and we have provided too few arguments, this is not a match. Note that variadic parameters\n        // allow you to omit the vararg, which would allow a difference of one, but a difference in count of 2 or more is not a match.\n        if (!(needleParameterCount == countOfMethodUsageArgumentsPassed) && needleParameterCount < lastMethodUsageArgumentIndex) {\n            return false;\n        }\n\n        // Iterate over the arguments given to the method, and compare their types against the given method's declared parameter types\n        for (int i = 0; i < needleParameterCount; i++) {\n            ResolvedType actualArgumentType = needleParameterTypes.get(i);\n\n            ResolvedType expectedArgumentType;\n            boolean reachedVariadicParam = methodIsDeclaredWithVariadicParameter && i >= lastMethodUsageArgumentIndex;\n            if (!reachedVariadicParam) {\n                // Not yet reached the variadic parameters -- the expected type is just whatever is at that position.\n                expectedArgumentType = methodUsage.getParamType(i);\n            } else {\n                // We have reached the variadic parameters -- the expected type is the type of the last declared parameter.\n                expectedArgumentType = methodUsage.getParamType(lastMethodUsageArgumentIndex);\n                // Note that the given variadic value might be an array - if so, use the array's component type rather.\n                // This is only valid if ONE argument has been given to the vararg parameter.\n                // Example: {@code void test(String... s) {}} and {@code test(stringArray)} -- {@code String... is assignable by stringArray}\n                // Example: {@code void test(String[]... s) {}} and {@code test(stringArrayArray)} -- {@code String[]... is assignable by stringArrayArray}\n                boolean argumentIsArray = (needleParameterCount == countOfMethodUsageArgumentsPassed) && expectedArgumentType.isAssignableBy(actualArgumentType);\n                if (!argumentIsArray) {\n                    // Get the component type of the declared parameter type.\n                    expectedArgumentType = expectedArgumentType.asArrayType().getComponentType();\n                }\n            }\n\n            // Consider type parameters directly on the method declaration, and ALSO on the enclosing type (e.g. a class)\n            List<ResolvedTypeParameterDeclaration> typeParameters = methodUsage.getDeclaration().getTypeParameters();\n            typeParameters.addAll(methodUsage.declaringType().getTypeParameters());\n\n            ResolvedType expectedTypeWithoutSubstitutions = expectedArgumentType;\n            ResolvedType expectedTypeWithInference = expectedArgumentType;\n            Map<ResolvedTypeParameterDeclaration, ResolvedType> derivedValues = new HashMap<>();\n\n            // For each declared parameter, infer the types that will replace generics (type parameters)\n            for (int j = 0; j < countOfMethodUsageArgumentsPassed; j++) {\n                ResolvedParameterDeclaration parameter = methodUsage.getDeclaration().getParam(j);\n                ResolvedType parameterType = parameter.getType();\n                if (parameter.isVariadic()) {\n                    // Don't continue if a vararg parameter is reached and there are no arguments left\n                    if (needleParameterCount == j) {\n                        break;\n                    }\n                    parameterType = parameterType.asArrayType().getComponentType();\n                }\n                inferTypes(needleParameterTypes.get(j), parameterType, derivedValues);\n            }\n\n            for (Map.Entry<ResolvedTypeParameterDeclaration, ResolvedType> entry : derivedValues.entrySet()) {\n                ResolvedTypeParameterDeclaration tp = entry.getKey();\n                expectedTypeWithInference = expectedTypeWithInference.replaceTypeVariables(tp, entry.getValue());\n            }\n\n            // Consider cases where type variables can be replaced (e.g. add(E element) vs add(String element))\n            for (ResolvedTypeParameterDeclaration tp : typeParameters) {\n                if (tp.getBounds().isEmpty()) {\n                    //expectedArgumentType = expectedArgumentType.replaceTypeVariables(tp.getName(), new ReferenceTypeUsageImpl(typeSolver.solveType(JAVA_LANG_OBJECT), typeSolver));\n                    expectedArgumentType = expectedArgumentType.replaceTypeVariables(tp, ResolvedWildcard.extendsBound(new ReferenceTypeImpl(typeSolver.solveType(JAVA_LANG_OBJECT), typeSolver)));\n                } else if (tp.getBounds().size() == 1) {\n                    ResolvedTypeParameterDeclaration.Bound bound = tp.getBounds().get(0);\n                    if (bound.isExtends()) {\n                        //expectedArgumentType = expectedArgumentType.replaceTypeVariables(tp.getName(), bound.getType());\n                        expectedArgumentType = expectedArgumentType.replaceTypeVariables(tp, ResolvedWildcard.extendsBound(bound.getType()));\n                    } else {\n                        //expectedArgumentType = expectedArgumentType.replaceTypeVariables(tp.getName(), new ReferenceTypeUsageImpl(typeSolver.solveType(JAVA_LANG_OBJECT), typeSolver));\n                        expectedArgumentType = expectedArgumentType.replaceTypeVariables(tp, ResolvedWildcard.superBound(bound.getType()));\n                    }\n                } else {\n                    throw new UnsupportedOperationException();\n                }\n            }\n\n            // Consider cases where type variables involve bounds e.g. super/extends\n            ResolvedType expectedTypeWithSubstitutions = expectedTypeWithoutSubstitutions;\n            for (ResolvedTypeParameterDeclaration tp : typeParameters) {\n                if (tp.getBounds().isEmpty()) {\n                    expectedTypeWithSubstitutions = expectedTypeWithSubstitutions.replaceTypeVariables(tp, new ReferenceTypeImpl(typeSolver.solveType(JAVA_LANG_OBJECT), typeSolver));\n                } else if (tp.getBounds().size() == 1) {\n                    ResolvedTypeParameterDeclaration.Bound bound = tp.getBounds().get(0);\n                    if (bound.isExtends()) {\n                        expectedTypeWithSubstitutions = expectedTypeWithSubstitutions.replaceTypeVariables(tp, bound.getType());\n                    } else {\n                        expectedTypeWithSubstitutions = expectedTypeWithSubstitutions.replaceTypeVariables(tp, new ReferenceTypeImpl(typeSolver.solveType(JAVA_LANG_OBJECT), typeSolver));\n                    }\n                } else {\n                    throw new UnsupportedOperationException();\n                }\n            }\n\n            // If the given argument still isn't applicable even after considering type arguments/generics, this is not a match.\n            if (!expectedArgumentType.isAssignableBy(actualArgumentType)\n                    && !expectedTypeWithSubstitutions.isAssignableBy(actualArgumentType)\n                    && !expectedTypeWithInference.isAssignableBy(actualArgumentType)\n                    && !expectedTypeWithoutSubstitutions.isAssignableBy(actualArgumentType)) {\n                return false;\n            }\n        }\n\n        // If the checks above haven't failed, then we've found a match.\n        return true;\n    }\n\n    /**\n     * Filters by given function {@param keyExtractor} using a stateful filter mechanism.\n     *\n     * <pre>\n     *      persons.stream().filter(distinctByKey(Person::getName))\n     * </pre>\n     * <p>\n     * The example above would return a distinct list of persons containing only one person per name.\n     */\n    private static <T> Predicate<T> distinctByKey(Function<? super T, ?> keyExtractor) {\n        Set<Object> seen = ConcurrentHashMap.newKeySet();\n        return t -> seen.add(keyExtractor.apply(t));\n    }\n\n    /**\n     * @param methods we expect the methods to be ordered such that inherited methods are later in the list\n     */\n    public static SymbolReference<ResolvedMethodDeclaration> findMostApplicable(List<ResolvedMethodDeclaration> methods,\n                                                                                String name, List<ResolvedType> argumentsTypes, TypeSolver typeSolver) {\n        SymbolReference<ResolvedMethodDeclaration> res = findMostApplicable(methods, name, argumentsTypes, typeSolver, false);\n        if (res.isSolved()) {\n            return res;\n        }\n        return findMostApplicable(methods, name, argumentsTypes, typeSolver, true);\n    }\n\n    public static SymbolReference<ResolvedMethodDeclaration> findMostApplicable(List<ResolvedMethodDeclaration> methods,\n                                                                                String name, List<ResolvedType> argumentsTypes,\n                                                                                TypeSolver typeSolver,\n                                                                                boolean wildcardTolerance\n    ) {\n\n        List<ResolvedMethodDeclaration> applicableMethods = methods.stream()\n                // Only consider methods with a matching name\n                .filter(m -> m.getName().equals(name))\n                // Filters out duplicate ResolvedMethodDeclaration by their signature.\n                .filter(distinctByKey(ResolvedMethodDeclaration::getQualifiedSignature))\n                // Checks if ResolvedMethodDeclaration is applicable to argumentsTypes.\n                .filter((m) -> isApplicable(m, name, argumentsTypes, typeSolver, wildcardTolerance))\n                .collect(Collectors.toList());\n\n        // If no applicable methods found, return as unsolved.\n        if (applicableMethods.isEmpty()) {\n            return SymbolReference.unsolved(ResolvedMethodDeclaration.class);\n        }\n\n        // If there are multiple possible methods found, null arguments can help to eliminate some matches.\n        if (applicableMethods.size() > 1) {\n            List<Integer> nullParamIndexes = new ArrayList<>();\n            for (int i = 0; i < argumentsTypes.size(); i++) {\n                if (argumentsTypes.get(i).isNull()) {\n                    nullParamIndexes.add(i);\n                }\n            }\n\n            // If some null arguments have been provided, use this to eliminate some opitons.\n            if (!nullParamIndexes.isEmpty()) {\n                // remove method with array param if a non array exists and arg is null\n                Set<ResolvedMethodDeclaration> removeCandidates = new HashSet<>();\n                for (Integer nullParamIndex : nullParamIndexes) {\n                    for (ResolvedMethodDeclaration methDecl : applicableMethods) {\n                        if (methDecl.getParam(nullParamIndex).getType().isArray()) {\n                            removeCandidates.add(methDecl);\n                        }\n                    }\n                }\n\n                // Where candidiates for removal are found, remove them.\n                if (!removeCandidates.isEmpty() && removeCandidates.size() < applicableMethods.size()) {\n                    applicableMethods.removeAll(removeCandidates);\n                }\n            }\n        }\n\n        // If only one applicable method found, short-circuit and return it here.\n        if (applicableMethods.size() == 1) {\n            return SymbolReference.solved(applicableMethods.get(0));\n        }\n        \n        // Examine the applicable methods found, and evaluate each to determine the \"best\" one\n        ResolvedMethodDeclaration winningCandidate = applicableMethods.get(0);\n        ResolvedMethodDeclaration other = null;\n        boolean possibleAmbiguity = false;\n        for (int i = 1; i < applicableMethods.size(); i++) {\n            other = applicableMethods.get(i);\n            if (isMoreSpecific(winningCandidate, other, argumentsTypes)) {\n                possibleAmbiguity = false;\n            } else if (isMoreSpecific(other, winningCandidate, argumentsTypes)) {\n                possibleAmbiguity = false;\n                winningCandidate = other;\n            } else {\n                // 15.12.2.5. Choosing the Most Specific Method\n                // One applicable method m1 is more specific than another applicable method m2, for an invocation with argument\n                // expressions e1, ..., ek, if any of the following are true:\n                // m2 is generic, and m1 is inferred to be more specific than m2 for argument expressions e1, ..., ek by \u00a718.5.4.\n                // 18.5.4. More Specific Method Inference should be verified \n                // ...\n                if (winningCandidate.isGeneric() && !other.isGeneric()) {\n                    winningCandidate = other;\n                } else if (!winningCandidate.isGeneric() && other.isGeneric()) {\n                    // nothing to do at this stage winningCandidate is the winner\n                } else if (winningCandidate.declaringType().getQualifiedName().equals(other.declaringType().getQualifiedName())) {\n                    possibleAmbiguity = true;\n                } else {\n                    // we expect the methods to be ordered such that inherited methods are later in the list\n                }\n            }\n        }\n        \n        if (possibleAmbiguity) {\n            // pick the first exact match if it exists\n            if (!isExactMatch(winningCandidate, argumentsTypes)) {\n                if (isExactMatch(other, argumentsTypes)) {\n                    winningCandidate = other;\n                } else {\n                    throw new MethodAmbiguityException(\n                            \"Ambiguous method call: cannot find a most applicable method: \" + winningCandidate\n                                    + \", \" + other);\n                }\n            }\n        }\n\n        return SymbolReference.solved(winningCandidate);\n    }\n\n    protected static boolean isExactMatch(ResolvedMethodLikeDeclaration method, List<ResolvedType> argumentsTypes) {\n        for (int i = 0; i < method.getNumberOfParams(); i++) {\n            if (!method.getParam(i).getType().equals(argumentsTypes.get(i))) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private static ResolvedType getMethodsExplicitAndVariadicParameterType(ResolvedMethodDeclaration method, int i) {\n        int numberOfParams = method.getNumberOfParams();\n\n        if (i < numberOfParams) {\n            return method.getParam(i).getType();\n        }\n        if (method.hasVariadicParameter()) {\n            return method.getParam(numberOfParams - 1).getType();\n        }\n        return null;\n    }\n\n    private static boolean isMoreSpecific(ResolvedMethodDeclaration methodA, ResolvedMethodDeclaration methodB,\n                                          List<ResolvedType> argumentTypes) {\n\n        final boolean aVariadic = methodA.hasVariadicParameter();\n        final boolean bVariadic = methodB.hasVariadicParameter();\n        final int aNumberOfParams = methodA.getNumberOfParams();\n        final int bNumberOfParams = methodB.getNumberOfParams();\n        final int numberOfArgs = argumentTypes.size();\n        final ResolvedType lastArgType = numberOfArgs > 0 ? argumentTypes.get(numberOfArgs - 1) : null;\n        final boolean isLastArgArray = lastArgType != null && lastArgType.isArray();\n        int omittedArgs = 0;\n        boolean isMethodAMoreSpecific = false;\n\n        // If one method declaration has exactly the correct amount of parameters and is not variadic then it is always\n        // preferred to a declaration that is variadic (and hence possibly also has a different amount of parameters).\n        if (!aVariadic && aNumberOfParams == numberOfArgs && (bVariadic && (bNumberOfParams != numberOfArgs ||\n                !isLastArgArray))) {\n            return true;\n        }\n        if (!bVariadic && bNumberOfParams == numberOfArgs && (aVariadic && (aNumberOfParams != numberOfArgs ||\n                !isLastArgArray))) {\n            return false;\n        }\n        \n        // If both methods are variadic but the calling method omits any varArgs, bump the omitted args to\n        // ensure the varargs type is considered when determining which method is more specific\n        if (aVariadic && bVariadic && aNumberOfParams == bNumberOfParams && numberOfArgs == aNumberOfParams - 1) {\n        \tomittedArgs++;\n        }\n\n        // Either both methods are variadic or neither is. So we must compare the parameter types.\n        for (int i = 0; i < numberOfArgs + omittedArgs; i++) {\n            ResolvedType paramTypeA = getMethodsExplicitAndVariadicParameterType(methodA, i);\n            ResolvedType paramTypeB = getMethodsExplicitAndVariadicParameterType(methodB, i);\n            \n            ResolvedType argType = null;\n            if (i < argumentTypes.size()) {\n            \targType = argumentTypes.get(i);\n            }\n\n            // Safety: if a type is null it means a signature with too few parameters managed to get to this point.\n            // This should not happen but it also means that this signature is immediately disqualified.\n            if (paramTypeA == null) {\n                return false;\n            }\n            if (paramTypeB == null) {\n                return true;\n            }\n            // Widening primitive conversions have priority over boxing/unboxing conversions when finding the most\n            // applicable method. E.g. assume we have method call foo(1) and declarations foo(long) and foo(Integer).\n            // The method call will call foo(long), as it requires a widening primitive conversion from int to long\n            // instead of a boxing conversion from int to Integer. See JLS \u00a715.12.2.\n            // This is what we check here.\n            if (argType != null &&\n            \t\tparamTypeA.isPrimitive() == argType.isPrimitive() &&\n                    paramTypeB.isPrimitive() != argType.isPrimitive() &&\n                    paramTypeA.isAssignableBy(argType)) {\n\n                return true;\n            }\n            if (argType != null &&\n            \t\tparamTypeB.isPrimitive() == argType.isPrimitive() &&\n                    paramTypeA.isPrimitive() != argType.isPrimitive() &&\n                    paramTypeB.isAssignableBy(argType)) {\n\n                return false;\n            // if paramA and paramB are not the last parameters\n            // and the type of paramA or paramB (which are not more specific at this stage) is java.lang.Object\n            // then we have to consider others parameters before concluding\n            }\n            if ((i < numberOfArgs - 1)\n                    && (isJavaLangObject(paramTypeB) || (isJavaLangObject(paramTypeA)))) {\n                // consider others parameters\n                // but eventually mark the method A as more specific if the methodB has an argument of type java.lang.Object\n                isMethodAMoreSpecific = isMethodAMoreSpecific || isJavaLangObject(paramTypeB);\n            }\n            // If we get to this point then we check whether one of the methods contains a parameter type that is more\n            // specific. If it does, we can assume the entire declaration is more specific as we would otherwise have\n            // a situation where the declarations are ambiguous in the given context.\n            else {\n                boolean aAssignableFromB = paramTypeA.isAssignableBy(paramTypeB);\n                boolean bAssignableFromA = paramTypeB.isAssignableBy(paramTypeA);\n\n                if (bAssignableFromA && !aAssignableFromB) {\n                    // A's parameter is more specific\n                    return true;\n                }\n                if (aAssignableFromB && !bAssignableFromA) {\n                    // B's parameter is more specific\n                    return false;\n                }\n            }\n        }\n\n        if (aVariadic && !bVariadic) {\n            // if the last argument is an array then m1 is more specific\n            return isLastArgArray;\n        }\n        if (!aVariadic && bVariadic) {\n            // if the last argument is an array and m1 is not variadic then\n            // it is not more specific\n            return !isLastArgArray;\n        }\n\n        return isMethodAMoreSpecific;\n    }\n    \n    private static boolean isJavaLangObject(ResolvedType paramType ) {\n        return paramType.isReferenceType() && paramType.asReferenceType().getQualifiedName().equals(\"java.lang.Object\");\n    }\n\n    private static boolean isMoreSpecific(MethodUsage methodA, MethodUsage methodB) {\n        boolean oneMoreSpecificFound = false;\n        for (int i = 0; i < methodA.getNoParams(); i++) {\n            ResolvedType tdA = methodA.getParamType(i);\n            ResolvedType tdB = methodB.getParamType(i);\n\n            boolean aIsAssignableByB = tdA.isAssignableBy(tdB);\n            boolean bIsAssignableByA = tdB.isAssignableBy(tdA);\n\n            // A is more specific\n            if (bIsAssignableByA && !aIsAssignableByB) {\n                oneMoreSpecificFound = true;\n            }\n            // B is more specific\n            if (aIsAssignableByB && !bIsAssignableByA) {\n                return false;\n            }\n\n            // If B is vararg and A is not, A is more specific\n            if (tdB.isArray() && tdB.asArrayType().getComponentType().isAssignableBy(tdA)) {\n                oneMoreSpecificFound = true;\n            }\n        }\n        return oneMoreSpecificFound;\n    }\n\n    public static Optional<MethodUsage> findMostApplicableUsage(List<MethodUsage> methods, String name, List<ResolvedType> argumentsTypes, TypeSolver typeSolver) {\n        List<MethodUsage> applicableMethods = methods.stream().filter((m) -> isApplicable(m, name, argumentsTypes, typeSolver)).collect(Collectors.toList());\n\n        if (applicableMethods.isEmpty()) {\n            return Optional.empty();\n        }\n        if (applicableMethods.size() == 1) {\n            return Optional.of(applicableMethods.get(0));\n        } else {\n            MethodUsage winningCandidate = applicableMethods.get(0);\n            for (int i = 1; i < applicableMethods.size(); i++) {\n                MethodUsage other = applicableMethods.get(i);\n                if (isMoreSpecific(winningCandidate, other)) {\n                    // nothing to do\n                } else if (isMoreSpecific(other, winningCandidate)) {\n                    winningCandidate = other;\n                } else {\n                    if (winningCandidate.declaringType().getQualifiedName().equals(other.declaringType().getQualifiedName())) {\n                        if (!areOverride(winningCandidate, other)) {\n                            throw new MethodAmbiguityException(\"Ambiguous method call: cannot find a most applicable method: \" + winningCandidate + \", \" + other + \". First declared in \" + winningCandidate.declaringType().getQualifiedName());\n                        }\n                    } else {\n                        // we expect the methods to be ordered such that inherited methods are later in the list\n                        //throw new UnsupportedOperationException();\n                    }\n                }\n            }\n            return Optional.of(winningCandidate);\n        }\n    }\n\n    private static boolean areOverride(MethodUsage winningCandidate, MethodUsage other) {\n        if (!winningCandidate.getName().equals(other.getName())) {\n            return false;\n        }\n        if (winningCandidate.getNoParams() != other.getNoParams()) {\n            return false;\n        }\n        for (int i = 0; i < winningCandidate.getNoParams(); i++) {\n            if (!winningCandidate.getParamTypes().get(i).equals(other.getParamTypes().get(i))) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static SymbolReference<ResolvedMethodDeclaration> solveMethodInType(ResolvedTypeDeclaration typeDeclaration,\n                                                                               String name,\n                                                                               List<ResolvedType> argumentsTypes) {\n        return solveMethodInType(typeDeclaration, name, argumentsTypes, false);\n    }\n\n    // TODO: Replace TypeDeclaration.solveMethod\n    public static SymbolReference<ResolvedMethodDeclaration> solveMethodInType(ResolvedTypeDeclaration typeDeclaration,\n                                                                               String name,\n                                                                               List<ResolvedType> argumentsTypes,\n                                                                               boolean staticOnly) {\n\n        if (typeDeclaration instanceof MethodResolutionCapability) {\n            return ((MethodResolutionCapability) typeDeclaration).solveMethod(name, argumentsTypes,\n                    staticOnly);\n        }\n        throw new UnsupportedOperationException(typeDeclaration.getClass().getCanonicalName());\n    }\n\n    private static void inferTypes(ResolvedType source, ResolvedType target, Map<ResolvedTypeParameterDeclaration, ResolvedType> mappings) {\n        if (source.equals(target)) {\n            return;\n        }\n        if (source.isReferenceType() && target.isReferenceType()) {\n            ResolvedReferenceType sourceRefType = source.asReferenceType();\n            ResolvedReferenceType targetRefType = target.asReferenceType();\n            if (sourceRefType.getQualifiedName().equals(targetRefType.getQualifiedName())) {\n                if (!sourceRefType.isRawType() && !targetRefType.isRawType()) {\n                    for (int i = 0; i < sourceRefType.typeParametersValues().size(); i++) {\n                        inferTypes(sourceRefType.typeParametersValues().get(i), targetRefType.typeParametersValues().get(i), mappings);\n                    }\n                }\n            }\n            return;\n        }\n        if (source.isReferenceType() && target.isWildcard()) {\n            if (target.asWildcard().isBounded()) {\n                inferTypes(source, target.asWildcard().getBoundedType(), mappings);\n                return;\n            }\n            return;\n        }\n        if (source.isWildcard() && target.isWildcard()) {\n            return;\n        }\n        if (source.isReferenceType() && target.isTypeVariable()) {\n            mappings.put(target.asTypeParameter(), source);\n            return;\n        }\n\n        if (source.isWildcard() && target.isReferenceType()) {\n            if (source.asWildcard().isBounded()) {\n                inferTypes(source.asWildcard().getBoundedType(), target, mappings);\n            }\n            return;\n        }\n\n        if (source.isWildcard() && target.isTypeVariable()) {\n            mappings.put(target.asTypeParameter(), source);\n            return;\n        }\n        if (source.isTypeVariable() && target.isTypeVariable()) {\n            mappings.put(target.asTypeParameter(), source);\n            return;\n        }\n        if (source.isPrimitive() || target.isPrimitive()) {\n            return;\n        }\n        if (source.isNull()) {\n            return;\n        }\n    }\n\n}\n",
        "diffSourceCodeSet": [
            "private static int getLastParameterIndex(int countOfMethodParametersDeclared) {\n        return Math.max(0, countOfMethodParametersDeclared - 1);\n    }"
        ],
        "invokedMethodSet": [
            "methodSignature: com.github.javaparser.symbolsolver.resolution.MethodResolutionLogic#inferTypes\n methodBody: private static void inferTypes(ResolvedType source, ResolvedType target, Map<ResolvedTypeParameterDeclaration, ResolvedType> mappings) {\nif(source.equals(target)){return;\n}if(source.isReferenceType() && target.isReferenceType()){ResolvedReferenceType sourceRefType=source.asReferenceType();\nResolvedReferenceType targetRefType=target.asReferenceType();\nif(sourceRefType.getQualifiedName().equals(targetRefType.getQualifiedName())){if(!sourceRefType.isRawType() && !targetRefType.isRawType()){for(int i=0; i < sourceRefType.typeParametersValues().size(); i++){inferTypes(sourceRefType.typeParametersValues().get(i),targetRefType.typeParametersValues().get(i),mappings);\n}}}return;\n}if(source.isReferenceType() && target.isWildcard()){if(target.asWildcard().isBounded()){inferTypes(source,target.asWildcard().getBoundedType(),mappings);\nreturn;\n}return;\n}if(source.isWildcard() && target.isWildcard()){return;\n}if(source.isReferenceType() && target.isTypeVariable()){mappings.put(target.asTypeParameter(),source);\nreturn;\n}if(source.isWildcard() && target.isReferenceType()){if(source.asWildcard().isBounded()){inferTypes(source.asWildcard().getBoundedType(),target,mappings);\n}return;\n}if(source.isWildcard() && target.isTypeVariable()){mappings.put(target.asTypeParameter(),source);\nreturn;\n}if(source.isTypeVariable() && target.isTypeVariable()){mappings.put(target.asTypeParameter(),source);\nreturn;\n}if(source.isPrimitive() || target.isPrimitive()){return;\n}if(source.isNull()){return;\n}}"
        ],
        "sourceCodeAfterRefactoring": "/**\n     * Note the specific naming here -- parameters are part of the method declaration,\n     * while arguments are the values passed when calling a method.\n     * Note that \"needle\" refers to that value being used as a search/query term to match against.\n     *\n     * @return true, if the given MethodUsage matches the given name/types (normally obtained from a ResolvedMethodDeclaration)\n     *\n     * @see {@link MethodResolutionLogic#isApplicable(ResolvedMethodDeclaration, String, List, TypeSolver)}  }\n     * @see {@link MethodResolutionLogic#isApplicable(ResolvedMethodDeclaration, String, List, TypeSolver, boolean)}\n     */\n    public static boolean isApplicable(MethodUsage methodUsage, String needleName, List<ResolvedType> needleParameterTypes, TypeSolver typeSolver) {\n        if (!methodUsage.getName().equals(needleName)) {\n            return false;\n        }\n\n        // The index of the final method parameter (on the method declaration).\n        int countOfMethodUsageArgumentsPassed = methodUsage.getNoParams();\n        int lastMethodUsageArgumentIndex = getLastParameterIndex(countOfMethodUsageArgumentsPassed);\n\n        // The index of the final argument passed (on the method usage).\n        int needleParameterCount = needleParameterTypes.size();\n        int lastNeedleParameterIndex = getLastParameterIndex(needleParameterCount);\n\n        // TODO: Does the method usage have a declaration at this point..?\n        boolean methodIsDeclaredWithVariadicParameter = methodUsage.getDeclaration().hasVariadicParameter();\n\n        // If the counts do not match and the method is not variadic, this is not a match.\n        if (!methodIsDeclaredWithVariadicParameter && !(needleParameterCount == countOfMethodUsageArgumentsPassed)) {\n            return false;\n        }\n\n        // If the counts do not match and we have provided too few arguments, this is not a match. Note that variadic parameters\n        // allow you to omit the vararg, which would allow a difference of one, but a difference in count of 2 or more is not a match.\n        if (!(needleParameterCount == countOfMethodUsageArgumentsPassed) && needleParameterCount < lastMethodUsageArgumentIndex) {\n            return false;\n        }\n\n        // Iterate over the arguments given to the method, and compare their types against the given method's declared parameter types\n        for (int i = 0; i < needleParameterCount; i++) {\n            ResolvedType actualArgumentType = needleParameterTypes.get(i);\n\n            ResolvedType expectedArgumentType;\n            boolean reachedVariadicParam = methodIsDeclaredWithVariadicParameter && i >= lastMethodUsageArgumentIndex;\n            if (!reachedVariadicParam) {\n                // Not yet reached the variadic parameters -- the expected type is just whatever is at that position.\n                expectedArgumentType = methodUsage.getParamType(i);\n            } else {\n                // We have reached the variadic parameters -- the expected type is the type of the last declared parameter.\n                expectedArgumentType = methodUsage.getParamType(lastMethodUsageArgumentIndex);\n                // Note that the given variadic value might be an array - if so, use the array's component type rather.\n                // This is only valid if ONE argument has been given to the vararg parameter.\n                // Example: {@code void test(String... s) {}} and {@code test(stringArray)} -- {@code String... is assignable by stringArray}\n                // Example: {@code void test(String[]... s) {}} and {@code test(stringArrayArray)} -- {@code String[]... is assignable by stringArrayArray}\n                boolean argumentIsArray = (needleParameterCount == countOfMethodUsageArgumentsPassed) && expectedArgumentType.isAssignableBy(actualArgumentType);\n                if (!argumentIsArray) {\n                    // Get the component type of the declared parameter type.\n                    expectedArgumentType = expectedArgumentType.asArrayType().getComponentType();\n                }\n            }\n\n            // Consider type parameters directly on the method declaration, and ALSO on the enclosing type (e.g. a class)\n            List<ResolvedTypeParameterDeclaration> typeParameters = methodUsage.getDeclaration().getTypeParameters();\n            typeParameters.addAll(methodUsage.declaringType().getTypeParameters());\n\n            ResolvedType expectedTypeWithoutSubstitutions = expectedArgumentType;\n            ResolvedType expectedTypeWithInference = expectedArgumentType;\n            Map<ResolvedTypeParameterDeclaration, ResolvedType> derivedValues = new HashMap<>();\n\n            // For each declared parameter, infer the types that will replace generics (type parameters)\n            for (int j = 0; j < countOfMethodUsageArgumentsPassed; j++) {\n                ResolvedParameterDeclaration parameter = methodUsage.getDeclaration().getParam(j);\n                ResolvedType parameterType = parameter.getType();\n                if (parameter.isVariadic()) {\n                    // Don't continue if a vararg parameter is reached and there are no arguments left\n                    if (needleParameterCount == j) {\n                        break;\n                    }\n                    parameterType = parameterType.asArrayType().getComponentType();\n                }\n                inferTypes(needleParameterTypes.get(j), parameterType, derivedValues);\n            }\n\n            for (Map.Entry<ResolvedTypeParameterDeclaration, ResolvedType> entry : derivedValues.entrySet()) {\n                ResolvedTypeParameterDeclaration tp = entry.getKey();\n                expectedTypeWithInference = expectedTypeWithInference.replaceTypeVariables(tp, entry.getValue());\n            }\n\n            // Consider cases where type variables can be replaced (e.g. add(E element) vs add(String element))\n            for (ResolvedTypeParameterDeclaration tp : typeParameters) {\n                if (tp.getBounds().isEmpty()) {\n                    //expectedArgumentType = expectedArgumentType.replaceTypeVariables(tp.getName(), new ReferenceTypeUsageImpl(typeSolver.solveType(JAVA_LANG_OBJECT), typeSolver));\n                    expectedArgumentType = expectedArgumentType.replaceTypeVariables(tp, ResolvedWildcard.extendsBound(new ReferenceTypeImpl(typeSolver.solveType(JAVA_LANG_OBJECT), typeSolver)));\n                } else if (tp.getBounds().size() == 1) {\n                    ResolvedTypeParameterDeclaration.Bound bound = tp.getBounds().get(0);\n                    if (bound.isExtends()) {\n                        //expectedArgumentType = expectedArgumentType.replaceTypeVariables(tp.getName(), bound.getType());\n                        expectedArgumentType = expectedArgumentType.replaceTypeVariables(tp, ResolvedWildcard.extendsBound(bound.getType()));\n                    } else {\n                        //expectedArgumentType = expectedArgumentType.replaceTypeVariables(tp.getName(), new ReferenceTypeUsageImpl(typeSolver.solveType(JAVA_LANG_OBJECT), typeSolver));\n                        expectedArgumentType = expectedArgumentType.replaceTypeVariables(tp, ResolvedWildcard.superBound(bound.getType()));\n                    }\n                } else {\n                    throw new UnsupportedOperationException();\n                }\n            }\n\n            // Consider cases where type variables involve bounds e.g. super/extends\n            ResolvedType expectedTypeWithSubstitutions = expectedTypeWithoutSubstitutions;\n            for (ResolvedTypeParameterDeclaration tp : typeParameters) {\n                if (tp.getBounds().isEmpty()) {\n                    expectedTypeWithSubstitutions = expectedTypeWithSubstitutions.replaceTypeVariables(tp, new ReferenceTypeImpl(typeSolver.solveType(JAVA_LANG_OBJECT), typeSolver));\n                } else if (tp.getBounds().size() == 1) {\n                    ResolvedTypeParameterDeclaration.Bound bound = tp.getBounds().get(0);\n                    if (bound.isExtends()) {\n                        expectedTypeWithSubstitutions = expectedTypeWithSubstitutions.replaceTypeVariables(tp, bound.getType());\n                    } else {\n                        expectedTypeWithSubstitutions = expectedTypeWithSubstitutions.replaceTypeVariables(tp, new ReferenceTypeImpl(typeSolver.solveType(JAVA_LANG_OBJECT), typeSolver));\n                    }\n                } else {\n                    throw new UnsupportedOperationException();\n                }\n            }\n\n            // If the given argument still isn't applicable even after considering type arguments/generics, this is not a match.\n            if (!expectedArgumentType.isAssignableBy(actualArgumentType)\n                    && !expectedTypeWithSubstitutions.isAssignableBy(actualArgumentType)\n                    && !expectedTypeWithInference.isAssignableBy(actualArgumentType)\n                    && !expectedTypeWithoutSubstitutions.isAssignableBy(actualArgumentType)) {\n                return false;\n            }\n        }\n\n        // If the checks above haven't failed, then we've found a match.\n        return true;\n    }\nprivate static int getLastParameterIndex(int countOfMethodParametersDeclared) {\n        return Math.max(0, countOfMethodParametersDeclared - 1);\n    }",
        "diffSourceCode": "-  210:                     // for example LambdaConstraintType{bound=TypeVariable {ReflectionTypeParameter{typeVariable=T}}}, LambdaConstraintType{bound=TypeVariable {ReflectionTypeParameter{typeVariable=U}}}\n-  211:                     // we want to keep this method for future resolution\n-  212:                     if (actualArgumentType.isConstraint() && withWildcardTolerance && expectedDeclaredType.isPrimitive()) {\n-  354:     /**\n-  355:      * Note the specific naming here -- parameters are part of the method declaration,\n-  356:      * while arguments are the values passed when calling a method.\n-  357:      * Note that \"needle\" refers to that value being used as a search/query term to match against.\n-  358:      *\n-  359:      * @return true, if the given MethodUsage matches the given name/types (normally obtained from a ResolvedMethodDeclaration)\n-  360:      *\n-  361:      * @see {@link MethodResolutionLogic#isApplicable(ResolvedMethodDeclaration, String, List, TypeSolver)}  }\n-  362:      * @see {@link MethodResolutionLogic#isApplicable(ResolvedMethodDeclaration, String, List, TypeSolver, boolean)}\n-  363:      */\n-  364:     public static boolean isApplicable(MethodUsage methodUsage, String needleName, List<ResolvedType> needleParameterTypes, TypeSolver typeSolver) {\n-  365:         if (!methodUsage.getName().equals(needleName)) {\n-  366:             return false;\n-  367:         }\n-  368: \n-  369:         // The index of the final method parameter (on the method declaration).\n-  370:         int countOfMethodUsageArgumentsPassed = methodUsage.getNoParams();\n-  371:         int lastMethodUsageArgumentIndex = Math.max(0, countOfMethodUsageArgumentsPassed - 1);\n-  372: \n-  373:         // The index of the final argument passed (on the method usage).\n-  374:         int needleParameterCount = needleParameterTypes.size();\n-  375:         int lastNeedleParameterIndex = Math.max(0, needleParameterCount - 1);\n-  376: \n-  377:         // TODO: Does the method usage have a declaration at this point..?\n-  378:         boolean methodIsDeclaredWithVariadicParameter = methodUsage.getDeclaration().hasVariadicParameter();\n+  210:     private static int getLastParameterIndex(int countOfMethodParametersDeclared) {\n+  211:         return Math.max(0, countOfMethodParametersDeclared - 1);\n+  212:     }\n+  354:             if (type.describe().equals(tp.getName())) {\n+  355:                 List<ResolvedTypeParameterDeclaration.Bound> bounds = tp.getBounds();\n+  356:                 if (bounds.size() > 1) {\n+  357:                     throw new UnsupportedOperationException();\n+  358:                 }\n+  359:                 if (bounds.size() == 1) {\n+  360:                     return bounds.get(0).getType();\n+  361:                 }\n+  362:                 return new ReferenceTypeImpl(typeSolver.solveType(JAVA_LANG_OBJECT), typeSolver);\n+  363:             }\n+  364:             return type;\n+  365:         }\n+  366:         if (type.isPrimitive()) {\n+  367:             return type;\n+  368:         }\n+  369:         if (type.isArray()) {\n+  370:             return new ResolvedArrayType(replaceTypeParam(type.asArrayType().getComponentType(), tp, typeSolver));\n+  371:         }\n+  372:         if (type.isReferenceType()) {\n+  373:             ResolvedReferenceType result = type.asReferenceType();\n+  374:             result = result.transformTypeParameters(typeParam -> replaceTypeParam(typeParam, tp, typeSolver)).asReferenceType();\n+  375:             return result;\n+  376:         }\n+  377:         throw new UnsupportedOperationException(\"Replacing \" + type + \", param \" + tp + \" with \" + type.getClass().getCanonicalName());\n+  378:     }\n   379: \n-  380:         // If the counts do not match and the method is not variadic, this is not a match.\n-  381:         if (!methodIsDeclaredWithVariadicParameter && !(needleParameterCount == countOfMethodUsageArgumentsPassed)) {\n-  382:             return false;\n-  383:         }\n-  384: \n-  385:         // If the counts do not match and we have provided too few arguments, this is not a match. Note that variadic parameters\n-  386:         // allow you to omit the vararg, which would allow a difference of one, but a difference in count of 2 or more is not a match.\n-  387:         if (!(needleParameterCount == countOfMethodUsageArgumentsPassed) && needleParameterCount < lastMethodUsageArgumentIndex) {\n-  388:             return false;\n-  389:         }\n-  390: \n-  391:         // Iterate over the arguments given to the method, and compare their types against the given method's declared parameter types\n-  392:         for (int i = 0; i < needleParameterCount; i++) {\n-  393:             ResolvedType actualArgumentType = needleParameterTypes.get(i);\n+  380:     /**\n+  381:      * Note the specific naming here -- parameters are part of the method declaration,\n+  382:      * while arguments are the values passed when calling a method.\n+  383:      * Note that \"needle\" refers to that value being used as a search/query term to match against.\n+  384:      *\n+  385:      * @return true, if the given MethodUsage matches the given name/types (normally obtained from a ResolvedMethodDeclaration)\n+  386:      *\n+  387:      * @see {@link MethodResolutionLogic#isApplicable(ResolvedMethodDeclaration, String, List, TypeSolver)}  }\n+  388:      * @see {@link MethodResolutionLogic#isApplicable(ResolvedMethodDeclaration, String, List, TypeSolver, boolean)}\n+  389:      */\n+  390:     public static boolean isApplicable(MethodUsage methodUsage, String needleName, List<ResolvedType> needleParameterTypes, TypeSolver typeSolver) {\n+  391:         if (!methodUsage.getName().equals(needleName)) {\n+  392:             return false;\n+  393:         }\n   394: \n-  395:             ResolvedType expectedArgumentType;\n-  396:             boolean reachedVariadicParam = methodIsDeclaredWithVariadicParameter && i >= lastMethodUsageArgumentIndex;\n-  397:             if (!reachedVariadicParam) {\n-  398:                 // Not yet reached the variadic parameters -- the expected type is just whatever is at that position.\n-  399:                 expectedArgumentType = methodUsage.getParamType(i);\n-  400:             } else {\n-  401:                 // We have reached the variadic parameters -- the expected type is the type of the last declared parameter.\n-  402:                 expectedArgumentType = methodUsage.getParamType(lastMethodUsageArgumentIndex);\n-  403:                 // Note that the given variadic value might be an array - if so, use the array's component type rather.\n-  404:                 // This is only valid if ONE argument has been given to the vararg parameter.\n-  405:                 // Example: {@code void test(String... s) {}} and {@code test(stringArray)} -- {@code String... is assignable by stringArray}\n-  406:                 // Example: {@code void test(String[]... s) {}} and {@code test(stringArrayArray)} -- {@code String[]... is assignable by stringArrayArray}\n-  407:                 boolean argumentIsArray = (needleParameterCount == countOfMethodUsageArgumentsPassed) && expectedArgumentType.isAssignableBy(actualArgumentType);\n-  408:                 if (!argumentIsArray) {\n-  409:                     // Get the component type of the declared parameter type.\n-  410:                     expectedArgumentType = expectedArgumentType.asArrayType().getComponentType();\n-  411:                 }\n-  412:             }\n-  413: \n-  414:             // Consider type parameters directly on the method declaration, and ALSO on the enclosing type (e.g. a class)\n-  415:             List<ResolvedTypeParameterDeclaration> typeParameters = methodUsage.getDeclaration().getTypeParameters();\n-  416:             typeParameters.addAll(methodUsage.declaringType().getTypeParameters());\n-  417: \n-  418:             ResolvedType expectedTypeWithoutSubstitutions = expectedArgumentType;\n-  419:             ResolvedType expectedTypeWithInference = expectedArgumentType;\n-  420:             Map<ResolvedTypeParameterDeclaration, ResolvedType> derivedValues = new HashMap<>();\n-  421: \n-  422:             // For each declared parameter, infer the types that will replace generics (type parameters)\n-  423:             for (int j = 0; j < countOfMethodUsageArgumentsPassed; j++) {\n-  424:                 ResolvedParameterDeclaration parameter = methodUsage.getDeclaration().getParam(j);\n-  425:                 ResolvedType parameterType = parameter.getType();\n-  426:                 if (parameter.isVariadic()) {\n-  427:                     // Don't continue if a vararg parameter is reached and there are no arguments left\n-  428:                     if (needleParameterCount == j) {\n-  429:                         break;\n-  430:                     }\n-  431:                     parameterType = parameterType.asArrayType().getComponentType();\n-  432:                 }\n-  433:                 inferTypes(needleParameterTypes.get(j), parameterType, derivedValues);\n-  434:             }\n-  435: \n-  436:             for (Map.Entry<ResolvedTypeParameterDeclaration, ResolvedType> entry : derivedValues.entrySet()) {\n-  437:                 ResolvedTypeParameterDeclaration tp = entry.getKey();\n-  438:                 expectedTypeWithInference = expectedTypeWithInference.replaceTypeVariables(tp, entry.getValue());\n-  439:             }\n-  440: \n-  441:             // Consider cases where type variables can be replaced (e.g. add(E element) vs add(String element))\n-  442:             for (ResolvedTypeParameterDeclaration tp : typeParameters) {\n-  443:                 if (tp.getBounds().isEmpty()) {\n-  444:                     //expectedArgumentType = expectedArgumentType.replaceTypeVariables(tp.getName(), new ReferenceTypeUsageImpl(typeSolver.solveType(JAVA_LANG_OBJECT), typeSolver));\n-  445:                     expectedArgumentType = expectedArgumentType.replaceTypeVariables(tp, ResolvedWildcard.extendsBound(new ReferenceTypeImpl(typeSolver.solveType(JAVA_LANG_OBJECT), typeSolver)));\n-  446:                 } else if (tp.getBounds().size() == 1) {\n-  447:                     ResolvedTypeParameterDeclaration.Bound bound = tp.getBounds().get(0);\n-  448:                     if (bound.isExtends()) {\n-  449:                         //expectedArgumentType = expectedArgumentType.replaceTypeVariables(tp.getName(), bound.getType());\n-  450:                         expectedArgumentType = expectedArgumentType.replaceTypeVariables(tp, ResolvedWildcard.extendsBound(bound.getType()));\n-  451:                     } else {\n-  452:                         //expectedArgumentType = expectedArgumentType.replaceTypeVariables(tp.getName(), new ReferenceTypeUsageImpl(typeSolver.solveType(JAVA_LANG_OBJECT), typeSolver));\n-  453:                         expectedArgumentType = expectedArgumentType.replaceTypeVariables(tp, ResolvedWildcard.superBound(bound.getType()));\n-  454:                     }\n-  455:                 } else {\n-  456:                     throw new UnsupportedOperationException();\n-  457:                 }\n-  458:             }\n-  459: \n-  460:             // Consider cases where type variables involve bounds e.g. super/extends\n-  461:             ResolvedType expectedTypeWithSubstitutions = expectedTypeWithoutSubstitutions;\n-  462:             for (ResolvedTypeParameterDeclaration tp : typeParameters) {\n-  463:                 if (tp.getBounds().isEmpty()) {\n-  464:                     expectedTypeWithSubstitutions = expectedTypeWithSubstitutions.replaceTypeVariables(tp, new ReferenceTypeImpl(typeSolver.solveType(JAVA_LANG_OBJECT), typeSolver));\n-  465:                 } else if (tp.getBounds().size() == 1) {\n-  466:                     ResolvedTypeParameterDeclaration.Bound bound = tp.getBounds().get(0);\n-  467:                     if (bound.isExtends()) {\n-  468:                         expectedTypeWithSubstitutions = expectedTypeWithSubstitutions.replaceTypeVariables(tp, bound.getType());\n-  469:                     } else {\n-  470:                         expectedTypeWithSubstitutions = expectedTypeWithSubstitutions.replaceTypeVariables(tp, new ReferenceTypeImpl(typeSolver.solveType(JAVA_LANG_OBJECT), typeSolver));\n-  471:                     }\n-  472:                 } else {\n-  473:                     throw new UnsupportedOperationException();\n-  474:                 }\n-  475:             }\n-  476: \n-  477:             // If the given argument still isn't applicable even after considering type arguments/generics, this is not a match.\n-  478:             if (!expectedArgumentType.isAssignableBy(actualArgumentType)\n-  479:                     && !expectedTypeWithSubstitutions.isAssignableBy(actualArgumentType)\n-  480:                     && !expectedTypeWithInference.isAssignableBy(actualArgumentType)\n-  481:                     && !expectedTypeWithoutSubstitutions.isAssignableBy(actualArgumentType)) {\n-  482:                 return false;\n-  483:             }\n-  484:         }\n+  395:         // The index of the final method parameter (on the method declaration).\n+  396:         int countOfMethodUsageArgumentsPassed = methodUsage.getNoParams();\n+  397:         int lastMethodUsageArgumentIndex = getLastParameterIndex(countOfMethodUsageArgumentsPassed);\n+  398: \n+  399:         // The index of the final argument passed (on the method usage).\n+  400:         int needleParameterCount = needleParameterTypes.size();\n+  401:         int lastNeedleParameterIndex = getLastParameterIndex(needleParameterCount);\n+  402: \n+  403:         // TODO: Does the method usage have a declaration at this point..?\n+  404:         boolean methodIsDeclaredWithVariadicParameter = methodUsage.getDeclaration().hasVariadicParameter();\n+  405: \n+  406:         // If the counts do not match and the method is not variadic, this is not a match.\n+  407:         if (!methodIsDeclaredWithVariadicParameter && !(needleParameterCount == countOfMethodUsageArgumentsPassed)) {\n+  408:             return false;\n+  409:         }\n+  410: \n+  411:         // If the counts do not match and we have provided too few arguments, this is not a match. Note that variadic parameters\n+  412:         // allow you to omit the vararg, which would allow a difference of one, but a difference in count of 2 or more is not a match.\n+  413:         if (!(needleParameterCount == countOfMethodUsageArgumentsPassed) && needleParameterCount < lastMethodUsageArgumentIndex) {\n+  414:             return false;\n+  415:         }\n+  416: \n+  417:         // Iterate over the arguments given to the method, and compare their types against the given method's declared parameter types\n+  418:         for (int i = 0; i < needleParameterCount; i++) {\n+  419:             ResolvedType actualArgumentType = needleParameterTypes.get(i);\n+  420: \n+  421:             ResolvedType expectedArgumentType;\n+  422:             boolean reachedVariadicParam = methodIsDeclaredWithVariadicParameter && i >= lastMethodUsageArgumentIndex;\n+  423:             if (!reachedVariadicParam) {\n+  424:                 // Not yet reached the variadic parameters -- the expected type is just whatever is at that position.\n+  425:                 expectedArgumentType = methodUsage.getParamType(i);\n+  426:             } else {\n+  427:                 // We have reached the variadic parameters -- the expected type is the type of the last declared parameter.\n+  428:                 expectedArgumentType = methodUsage.getParamType(lastMethodUsageArgumentIndex);\n+  429:                 // Note that the given variadic value might be an array - if so, use the array's component type rather.\n+  430:                 // This is only valid if ONE argument has been given to the vararg parameter.\n+  431:                 // Example: {@code void test(String... s) {}} and {@code test(stringArray)} -- {@code String... is assignable by stringArray}\n+  432:                 // Example: {@code void test(String[]... s) {}} and {@code test(stringArrayArray)} -- {@code String[]... is assignable by stringArrayArray}\n+  433:                 boolean argumentIsArray = (needleParameterCount == countOfMethodUsageArgumentsPassed) && expectedArgumentType.isAssignableBy(actualArgumentType);\n+  434:                 if (!argumentIsArray) {\n+  435:                     // Get the component type of the declared parameter type.\n+  436:                     expectedArgumentType = expectedArgumentType.asArrayType().getComponentType();\n+  437:                 }\n+  438:             }\n+  439: \n+  440:             // Consider type parameters directly on the method declaration, and ALSO on the enclosing type (e.g. a class)\n+  441:             List<ResolvedTypeParameterDeclaration> typeParameters = methodUsage.getDeclaration().getTypeParameters();\n+  442:             typeParameters.addAll(methodUsage.declaringType().getTypeParameters());\n+  443: \n+  444:             ResolvedType expectedTypeWithoutSubstitutions = expectedArgumentType;\n+  445:             ResolvedType expectedTypeWithInference = expectedArgumentType;\n+  446:             Map<ResolvedTypeParameterDeclaration, ResolvedType> derivedValues = new HashMap<>();\n+  447: \n+  448:             // For each declared parameter, infer the types that will replace generics (type parameters)\n+  449:             for (int j = 0; j < countOfMethodUsageArgumentsPassed; j++) {\n+  450:                 ResolvedParameterDeclaration parameter = methodUsage.getDeclaration().getParam(j);\n+  451:                 ResolvedType parameterType = parameter.getType();\n+  452:                 if (parameter.isVariadic()) {\n+  453:                     // Don't continue if a vararg parameter is reached and there are no arguments left\n+  454:                     if (needleParameterCount == j) {\n+  455:                         break;\n+  456:                     }\n+  457:                     parameterType = parameterType.asArrayType().getComponentType();\n+  458:                 }\n+  459:                 inferTypes(needleParameterTypes.get(j), parameterType, derivedValues);\n+  460:             }\n+  461: \n+  462:             for (Map.Entry<ResolvedTypeParameterDeclaration, ResolvedType> entry : derivedValues.entrySet()) {\n+  463:                 ResolvedTypeParameterDeclaration tp = entry.getKey();\n+  464:                 expectedTypeWithInference = expectedTypeWithInference.replaceTypeVariables(tp, entry.getValue());\n+  465:             }\n+  466: \n+  467:             // Consider cases where type variables can be replaced (e.g. add(E element) vs add(String element))\n+  468:             for (ResolvedTypeParameterDeclaration tp : typeParameters) {\n+  469:                 if (tp.getBounds().isEmpty()) {\n+  470:                     //expectedArgumentType = expectedArgumentType.replaceTypeVariables(tp.getName(), new ReferenceTypeUsageImpl(typeSolver.solveType(JAVA_LANG_OBJECT), typeSolver));\n+  471:                     expectedArgumentType = expectedArgumentType.replaceTypeVariables(tp, ResolvedWildcard.extendsBound(new ReferenceTypeImpl(typeSolver.solveType(JAVA_LANG_OBJECT), typeSolver)));\n+  472:                 } else if (tp.getBounds().size() == 1) {\n+  473:                     ResolvedTypeParameterDeclaration.Bound bound = tp.getBounds().get(0);\n+  474:                     if (bound.isExtends()) {\n+  475:                         //expectedArgumentType = expectedArgumentType.replaceTypeVariables(tp.getName(), bound.getType());\n+  476:                         expectedArgumentType = expectedArgumentType.replaceTypeVariables(tp, ResolvedWildcard.extendsBound(bound.getType()));\n+  477:                     } else {\n+  478:                         //expectedArgumentType = expectedArgumentType.replaceTypeVariables(tp.getName(), new ReferenceTypeUsageImpl(typeSolver.solveType(JAVA_LANG_OBJECT), typeSolver));\n+  479:                         expectedArgumentType = expectedArgumentType.replaceTypeVariables(tp, ResolvedWildcard.superBound(bound.getType()));\n+  480:                     }\n+  481:                 } else {\n+  482:                     throw new UnsupportedOperationException();\n+  483:                 }\n+  484:             }\n   485: \n-  486:         // If the checks above haven't failed, then we've found a match.\n-  487:         return true;\n-  488:     }\n-  489: \n-  490:     /**\n-  491:      * Filters by given function {@param keyExtractor} using a stateful filter mechanism.\n-  492:      *\n-  493:      * <pre>\n-  494:      *      persons.stream().filter(distinctByKey(Person::getName))\n-  495:      * </pre>\n-  496:      * <p>\n-  497:      * The example above would return a distinct list of persons containing only one person per name.\n-  498:      */\n-  499:     private static <T> Predicate<T> distinctByKey(Function<? super T, ?> keyExtractor) {\n-  500:         Set<Object> seen = ConcurrentHashMap.newKeySet();\n-  501:         return t -> seen.add(keyExtractor.apply(t));\n-  502:     }\n-  503: \n-  504:     /**\n-  505:      * @param methods we expect the methods to be ordered such that inherited methods are later in the list\n-  506:      */\n-  507:     public static SymbolReference<ResolvedMethodDeclaration> findMostApplicable(List<ResolvedMethodDeclaration> methods,\n-  508:                                                                                 String name, List<ResolvedType> argumentsTypes, TypeSolver typeSolver) {\n-  509:         SymbolReference<ResolvedMethodDeclaration> res = findMostApplicable(methods, name, argumentsTypes, typeSolver, false);\n-  510:         if (res.isSolved()) {\n-  511:             return res;\n-  512:         }\n-  513:         return findMostApplicable(methods, name, argumentsTypes, typeSolver, true);\n+  486:             // Consider cases where type variables involve bounds e.g. super/extends\n+  487:             ResolvedType expectedTypeWithSubstitutions = expectedTypeWithoutSubstitutions;\n+  488:             for (ResolvedTypeParameterDeclaration tp : typeParameters) {\n+  489:                 if (tp.getBounds().isEmpty()) {\n+  490:                     expectedTypeWithSubstitutions = expectedTypeWithSubstitutions.replaceTypeVariables(tp, new ReferenceTypeImpl(typeSolver.solveType(JAVA_LANG_OBJECT), typeSolver));\n+  491:                 } else if (tp.getBounds().size() == 1) {\n+  492:                     ResolvedTypeParameterDeclaration.Bound bound = tp.getBounds().get(0);\n+  493:                     if (bound.isExtends()) {\n+  494:                         expectedTypeWithSubstitutions = expectedTypeWithSubstitutions.replaceTypeVariables(tp, bound.getType());\n+  495:                     } else {\n+  496:                         expectedTypeWithSubstitutions = expectedTypeWithSubstitutions.replaceTypeVariables(tp, new ReferenceTypeImpl(typeSolver.solveType(JAVA_LANG_OBJECT), typeSolver));\n+  497:                     }\n+  498:                 } else {\n+  499:                     throw new UnsupportedOperationException();\n+  500:                 }\n+  501:             }\n+  502: \n+  503:             // If the given argument still isn't applicable even after considering type arguments/generics, this is not a match.\n+  504:             if (!expectedArgumentType.isAssignableBy(actualArgumentType)\n+  505:                     && !expectedTypeWithSubstitutions.isAssignableBy(actualArgumentType)\n+  506:                     && !expectedTypeWithInference.isAssignableBy(actualArgumentType)\n+  507:                     && !expectedTypeWithoutSubstitutions.isAssignableBy(actualArgumentType)) {\n+  508:                 return false;\n+  509:             }\n+  510:         }\n+  511: \n+  512:         // If the checks above haven't failed, then we've found a match.\n+  513:         return true;\n   514:     }\n",
        "uniqueId": "5aabb7480625e5dba2d32a8efab95a35f8c2e04c_354_488_210_212_380_514",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 29,
                "covered": 286
            },
            "BRANCH": {
                "missed": 9,
                "covered": 47
            },
            "LINE": {
                "missed": 6,
                "covered": 60
            },
            "COMPLEXITY": {
                "missed": 9,
                "covered": 20
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 17
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprivate isAncestor(candidateAncestor ResolvedReferenceType, ownQualifiedName String) : boolean extracted from public getAncestors(acceptIncompleteList boolean) : List<ResolvedReferenceType> in class com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserClassDeclaration",
        "diffLocations": [
            {
                "filePath": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/declarations/JavaParserClassDeclaration.java",
                "startLine": 333,
                "endLine": 385,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/declarations/JavaParserClassDeclaration.java",
                "startLine": 333,
                "endLine": 385,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/declarations/JavaParserClassDeclaration.java",
                "startLine": 387,
                "endLine": 395,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "@Override\n    public List<ResolvedReferenceType> getAncestors(boolean acceptIncompleteList) {\n        List<ResolvedReferenceType> ancestors = new ArrayList<>();\n\n        // We want to avoid infinite recursion in case of Object having Object as ancestor\n        if (this.isJavaLangObject()) {\n            return ancestors;\n        }\n\n        try {\n            // If a superclass is found, add it as an ancestor\n            getSuperClass().ifPresent(ancestors::add);\n        } catch (UnsolvedSymbolException e) {\n            // in case we could not resolve the super class, we may still be able to resolve (some of) the\n            // implemented interfaces and so we continue gracefully with an (incomplete) list of ancestors\n\n            if (!acceptIncompleteList) {\n                // Only throw if an incomplete ancestor list is unacceptable.\n                throw e;\n            }\n        }\n\n        for (ClassOrInterfaceType implemented : wrappedNode.getImplementedTypes()) {\n            try {\n                // If an implemented interface is found, add it as an ancestor\n                ResolvedReferenceType rrt = toReferenceType(implemented);\n                Optional<ResolvedReferenceTypeDeclaration> resolvedReferenceTypeDeclaration = rrt.getTypeDeclaration();\n                if (resolvedReferenceTypeDeclaration.isPresent()) {\n\n                    ResolvedTypeDeclaration rtd = resolvedReferenceTypeDeclaration.get().asType();\n                    Optional<String> qualifiedName = wrappedNode.getFullyQualifiedName();\n                    if (qualifiedName.isPresent()) {\n\n                        // do not consider an inner or nested class as an ancestor\n                        if (!rtd.getQualifiedName().contains(qualifiedName.get())) {\n                            ancestors.add(rrt);\n                        }\n                    }\n                }\n            } catch (UnsolvedSymbolException e) {\n                // in case we could not resolve some implemented interface, we may still be able to resolve the\n                // extended class or (some of) the other implemented interfaces and so we continue gracefully\n                // with an (incomplete) list of ancestors\n\n                if (!acceptIncompleteList) {\n                    // Only throw if an incomplete ancestor list is unacceptable.\n                    throw e;\n                }\n            }\n        }\n\n        return ancestors;\n    }",
        "filePathBefore": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/declarations/JavaParserClassDeclaration.java",
        "isPureRefactoring": true,
        "commitId": "df18fcb41f73c5223b9952a0ede13e410b0e16b9",
        "packageNameBefore": "com.github.javaparser.symbolsolver.javaparsermodel.declarations",
        "classNameBefore": "com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserClassDeclaration",
        "methodNameBefore": "com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserClassDeclaration#getAncestors",
        "invokedMethod": "methodSignature: com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserClassDeclaration#getQualifiedName\n methodBody: public String getQualifiedName() {\nreturn javaParserTypeAdapter.getQualifiedName();\n}\nmethodSignature: com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserClassDeclaration#toReferenceType\n methodBody: private ResolvedReferenceType toReferenceType(ClassOrInterfaceType classOrInterfaceType) {\nString className=classOrInterfaceType.getName().getId();\nif(classOrInterfaceType.getScope().isPresent()){className=classOrInterfaceType.getScope().get().toString() + \".\" + className;\n}SymbolReference<ResolvedTypeDeclaration> ref=solveType(className);\nif(!ref.isSolved()){Optional<ClassOrInterfaceType> localScope=classOrInterfaceType.getScope();\nif(localScope.isPresent()){String localName=localScope.get().getName().getId() + \".\" + classOrInterfaceType.getName().getId();\nref=solveType(localName);\n}}if(!ref.isSolved()){throw new UnsolvedSymbolException(classOrInterfaceType.getName().getId());\n}if(!classOrInterfaceType.getTypeArguments().isPresent()){return new ReferenceTypeImpl(ref.getCorrespondingDeclaration().asReferenceType(),typeSolver);\n}List<ResolvedType> superClassTypeParameters=classOrInterfaceType.getTypeArguments().get().stream().map(ta -> new LazyType(v -> JavaParserFacade.get(typeSolver).convert(ta,ta))).collect(Collectors.toList());\nreturn new ReferenceTypeImpl(ref.getCorrespondingDeclaration().asReferenceType(),superClassTypeParameters,typeSolver);\n}\nmethodSignature: com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserClassDeclaration#getSuperClass\n methodBody: public Optional<ResolvedReferenceType> getSuperClass() {\nif(isJavaLangObject()){return Optional.empty();\n}if(wrappedNode.getExtendedTypes().isEmpty()){return Optional.of(object());\n}{return Optional.of(toReferenceType(wrappedNode.getExtendedTypes().getFirst().get()));\n}}",
        "classSignatureBefore": "public class JavaParserClassDeclaration extends AbstractClassDeclaration implements MethodUsageResolutionCapability ",
        "methodNameBeforeSet": [
            "com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserClassDeclaration#getAncestors"
        ],
        "classNameBeforeSet": [
            "com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserClassDeclaration"
        ],
        "classSignatureBeforeSet": [
            "public class JavaParserClassDeclaration extends AbstractClassDeclaration implements MethodUsageResolutionCapability "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Changes are within the Extract Method refactoring mechanics \n Severe changes",
                "description": "Return expression has been added within the Extract Method mechanics - with non-mapped leaves",
                "mappingState": 2
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Copyright (C) 2015-2016 Federico Tomassetti\n * Copyright (C) 2017-2020 The JavaParser Team.\n *\n * This file is part of JavaParser.\n *\n * JavaParser can be used either under the terms of\n * a) the GNU Lesser General Public License as published by\n *     the Free Software Foundation, either version 3 of the License, or\n *     (at your option) any later version.\n * b) the terms of the Apache License\n *\n * You should have received a copy of both licenses in LICENCE.LGPL and\n * LICENCE.APACHE. Please refer to those files for details.\n *\n * JavaParser is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n */\n\npackage com.github.javaparser.symbolsolver.javaparsermodel.declarations;\n\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Optional;\nimport java.util.Set;\nimport java.util.stream.Collectors;\n\nimport com.github.javaparser.ast.AccessSpecifier;\nimport com.github.javaparser.ast.Node;\nimport com.github.javaparser.ast.body.BodyDeclaration;\nimport com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;\nimport com.github.javaparser.ast.body.FieldDeclaration;\nimport com.github.javaparser.ast.body.MethodDeclaration;\nimport com.github.javaparser.ast.type.ClassOrInterfaceType;\nimport com.github.javaparser.resolution.MethodUsage;\nimport com.github.javaparser.resolution.UnsolvedSymbolException;\nimport com.github.javaparser.resolution.declarations.ResolvedConstructorDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedFieldDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedMethodDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedReferenceTypeDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedTypeDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedTypeParameterDeclaration;\nimport com.github.javaparser.resolution.types.ResolvedReferenceType;\nimport com.github.javaparser.resolution.types.ResolvedType;\nimport com.github.javaparser.symbolsolver.core.resolution.Context;\nimport com.github.javaparser.symbolsolver.core.resolution.MethodUsageResolutionCapability;\nimport com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade;\nimport com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFactory;\nimport com.github.javaparser.symbolsolver.logic.AbstractClassDeclaration;\nimport com.github.javaparser.symbolsolver.model.resolution.SymbolReference;\nimport com.github.javaparser.symbolsolver.model.resolution.TypeSolver;\nimport com.github.javaparser.symbolsolver.model.typesystem.LazyType;\nimport com.github.javaparser.symbolsolver.model.typesystem.ReferenceTypeImpl;\nimport com.github.javaparser.symbolsolver.resolution.SymbolSolver;\n\n/**\n * @author Federico Tomassetti\n */\npublic class JavaParserClassDeclaration extends AbstractClassDeclaration implements MethodUsageResolutionCapability {\n\n    ///\n    /// Fields\n    ///\n\n    private TypeSolver typeSolver;\n    private ClassOrInterfaceDeclaration wrappedNode;\n    private JavaParserTypeAdapter<ClassOrInterfaceDeclaration> javaParserTypeAdapter;\n\n    ///\n    /// Constructors\n    ///\n\n    public JavaParserClassDeclaration(ClassOrInterfaceDeclaration wrappedNode,\n                                      TypeSolver typeSolver) {\n        if (wrappedNode.isInterface()) {\n            throw new IllegalArgumentException(\"Interface given\");\n        }\n        this.wrappedNode = wrappedNode;\n        this.typeSolver = typeSolver;\n        this.javaParserTypeAdapter = new JavaParserTypeAdapter<>(wrappedNode, typeSolver);\n    }\n\n    ///\n    /// Public methods: from Object\n    ///\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n\n        JavaParserClassDeclaration that = (JavaParserClassDeclaration) o;\n\n        return wrappedNode.equals(that.wrappedNode);\n    }\n\n    @Override\n    public int hashCode() {\n        return wrappedNode.hashCode();\n    }\n\n    @Override\n    public String toString() {\n        return \"JavaParserClassDeclaration{\" +\n                \"wrappedNode=\" + wrappedNode +\n                '}';\n    }\n\n    ///\n    /// Public methods: fields\n    ///\n    \n    @Override\n    public List<ResolvedFieldDeclaration> getAllFields() {\n        List<ResolvedFieldDeclaration> fields = javaParserTypeAdapter.getFieldsForDeclaredVariables();\n\n        getAncestors(true).stream().filter(ancestor -> ancestor.getTypeDeclaration().isPresent())\n                .forEach(ancestor -> ancestor.getTypeDeclaration().get().getAllFields()\n                        .forEach(f -> {\n                            fields.add(new ResolvedFieldDeclaration() {\n\n                                @Override\n                                public AccessSpecifier accessSpecifier() {\n                                    return f.accessSpecifier();\n                                }\n\n                                @Override\n                                public String getName() {\n                                    return f.getName();\n                                }\n\n                                @Override\n                                public ResolvedType getType() {\n                                    return ancestor.useThisTypeParametersOnTheGivenType(f.getType());\n                                }\n\n                                @Override\n                                public boolean isStatic() {\n                                    return f.isStatic();\n                                }\n                                \n                                @Override\n                                public boolean isVolatile() {\n                                    return f.isVolatile();\n                                }\n\n                                @Override\n                                public ResolvedTypeDeclaration declaringType() {\n                                    return f.declaringType();\n                                }\n                                \n                                @Override\n                                public Optional<FieldDeclaration> toAst() {\n                                    return f.toAst();\n                                }\n                            });\n                        }));\n\n        return fields;\n    }\n\n    ///\n    /// Public methods\n    ///\n\n    public SymbolReference<ResolvedMethodDeclaration> solveMethod(String name, List<ResolvedType> parameterTypes) {\n        Context ctx = getContext();\n        return ctx.solveMethod(name, parameterTypes, false);\n    }\n\n    @Override\n    public Optional<MethodUsage> solveMethodAsUsage(String name, List<ResolvedType> argumentTypes,\n                                                    Context invocationContext, List<ResolvedType> typeParameters) {\n        return getContext().solveMethodAsUsage(name, argumentTypes);\n    }\n\n    /**\n     * This method is deprecated because the context is an implementation detail that should not be exposed.\n     * Ideally this method should become private. For this reason all further usages of this method are discouraged.\n     */\n    @Deprecated\n    public Context getContext() {\n        return JavaParserFactory.getContext(wrappedNode, typeSolver);\n    }\n\n    public ResolvedType getUsage(Node node) {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public String getName() {\n        return wrappedNode.getName().getId();\n    }\n\n    @Override\n    public Optional<ResolvedReferenceType> getSuperClass() {\n        if(isJavaLangObject()) {\n            // If this is java.lang.Object, it has no super class.\n            return Optional.empty();\n        } else if (wrappedNode.getExtendedTypes().isEmpty()) {\n            // All objects implicitly extend java.lang.Object -- inject it here (only when this isn't java.lang.Object)\n            return Optional.of(object());\n        } else {\n            // Otherwise, return the first ancestor (n.b.: we know it's not empty due to check above).\n            return Optional.of(toReferenceType(wrappedNode.getExtendedTypes().getFirst().get()));\n        }\n    }\n\n    @Override\n    public List<ResolvedReferenceType> getInterfaces() {\n        List<ResolvedReferenceType> interfaces = new ArrayList<>();\n        // TODO FIXME: Remove null check -- should be an empty list...\n        if (wrappedNode.getImplementedTypes() != null) {\n            for (ClassOrInterfaceType t : wrappedNode.getImplementedTypes()) {\n                interfaces.add(toReferenceType(t));\n            }\n        }\n        return interfaces;\n    }\n\n    @Override\n    public List<ResolvedConstructorDeclaration> getConstructors() {\n        return AstResolutionUtils.getConstructors(this.wrappedNode, typeSolver, this);\n    }\n\n    @Override\n    public boolean hasDirectlyAnnotation(String canonicalName) {\n        return AstResolutionUtils.hasDirectlyAnnotation(wrappedNode, typeSolver, canonicalName);\n    }\n\n    @Override\n    public boolean isInterface() {\n        return wrappedNode.isInterface();\n    }\n\n    @Override\n    public String getPackageName() {\n        return javaParserTypeAdapter.getPackageName();\n    }\n\n    @Override\n    public String getClassName() {\n        return javaParserTypeAdapter.getClassName();\n    }\n\n    @Override\n    public String getQualifiedName() {\n        return javaParserTypeAdapter.getQualifiedName();\n    }\n\n    @Override\n    public boolean isAssignableBy(ResolvedReferenceTypeDeclaration other) {\n        return javaParserTypeAdapter.isAssignableBy(other);\n    }\n\n    @Override\n    public boolean isAssignableBy(ResolvedType type) {\n        return javaParserTypeAdapter.isAssignableBy(type);\n    }\n\n    @Override\n    public boolean canBeAssignedTo(ResolvedReferenceTypeDeclaration other) {\n        // TODO consider generic types\n        if (this.getQualifiedName().equals(other.getQualifiedName())) {\n            return true;\n        }\n\n        Optional<ResolvedReferenceType> optionalSuperClass = getSuperClass();\n        if (optionalSuperClass.isPresent()) {\n            Optional<ResolvedReferenceTypeDeclaration> optionalSuperclassTypeDeclaration = optionalSuperClass.get().getTypeDeclaration();\n            if (optionalSuperclassTypeDeclaration.isPresent()) {\n                ResolvedReferenceTypeDeclaration superclassTypeDeclaration = optionalSuperclassTypeDeclaration.get();\n                if (superclassTypeDeclaration != this && superclassTypeDeclaration.isClass()) {\n                    if (superclassTypeDeclaration.asClass().canBeAssignedTo(other)) {\n                        return true;\n                    }\n                }\n            }\n        }\n\n        // TODO FIXME: Remove null check -- should be an empty list...\n        if (this.wrappedNode.getImplementedTypes() != null) {\n            for (ClassOrInterfaceType type : wrappedNode.getImplementedTypes()) {\n                ResolvedReferenceTypeDeclaration ancestor = (ResolvedReferenceTypeDeclaration) new SymbolSolver(typeSolver).solveType(type);\n                if (ancestor.canBeAssignedTo(other)) {\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n\n    @Override\n    public boolean isTypeParameter() {\n        return false;\n    }\n\n    /**\n     * Resolution should move out of declarations, so that they are pure declarations and the resolution should\n     * work for JavaParser, Reflection and Javassist classes in the same way and not be specific to the three\n     * implementations.\n     */\n    @Deprecated\n    public SymbolReference<ResolvedTypeDeclaration> solveType(String name) {\n        if (this.wrappedNode.getName().getId().equals(name)) {\n            return SymbolReference.solved(this);\n        }\n        SymbolReference<ResolvedTypeDeclaration> ref = javaParserTypeAdapter.solveType(name);\n        if (ref.isSolved()) {\n            return ref;\n        }\n\n        String prefix = wrappedNode.getName() + \".\";\n        if (name.startsWith(prefix) && name.length() > prefix.length()) {\n            return new JavaParserClassDeclaration(this.wrappedNode, typeSolver).solveType(name.substring(prefix.length()));\n        }\n\n        return getContext().getParent()\n                .orElseThrow(() -> new RuntimeException(\"Parent context unexpectedly empty.\"))\n                .solveType(name);\n    }\n\n    @Override\n    public SymbolReference<ResolvedMethodDeclaration> solveMethod(String name, List<ResolvedType> argumentsTypes,\n                                                                  boolean staticOnly) {\n        return getContext().solveMethod(name, argumentsTypes, staticOnly);\n    }\n\n    @Override\n    public List<ResolvedReferenceType> getAncestors(boolean acceptIncompleteList) {\n        List<ResolvedReferenceType> ancestors = new ArrayList<>();\n\n        // We want to avoid infinite recursion in case of Object having Object as ancestor\n        if (this.isJavaLangObject()) {\n            return ancestors;\n        }\n\n        try {\n            // If a superclass is found, add it as an ancestor\n            getSuperClass().ifPresent(ancestors::add);\n        } catch (UnsolvedSymbolException e) {\n            // in case we could not resolve the super class, we may still be able to resolve (some of) the\n            // implemented interfaces and so we continue gracefully with an (incomplete) list of ancestors\n\n            if (!acceptIncompleteList) {\n                // Only throw if an incomplete ancestor list is unacceptable.\n                throw e;\n            }\n        }\n\n        for (ClassOrInterfaceType implemented : wrappedNode.getImplementedTypes()) {\n            try {\n                // If an implemented interface is found, add it as an ancestor\n                ResolvedReferenceType rrt = toReferenceType(implemented);\n                Optional<ResolvedReferenceTypeDeclaration> resolvedReferenceTypeDeclaration = rrt.getTypeDeclaration();\n                if (resolvedReferenceTypeDeclaration.isPresent()) {\n\n                    ResolvedTypeDeclaration rtd = resolvedReferenceTypeDeclaration.get().asType();\n                    Optional<String> qualifiedName = wrappedNode.getFullyQualifiedName();\n                    if (qualifiedName.isPresent()) {\n\n                        // do not consider an inner or nested class as an ancestor\n                        if (!rtd.getQualifiedName().contains(qualifiedName.get())) {\n                            ancestors.add(rrt);\n                        }\n                    }\n                }\n            } catch (UnsolvedSymbolException e) {\n                // in case we could not resolve some implemented interface, we may still be able to resolve the\n                // extended class or (some of) the other implemented interfaces and so we continue gracefully\n                // with an (incomplete) list of ancestors\n\n                if (!acceptIncompleteList) {\n                    // Only throw if an incomplete ancestor list is unacceptable.\n                    throw e;\n                }\n            }\n        }\n\n        return ancestors;\n    }\n\n    @Override\n    public Set<ResolvedMethodDeclaration> getDeclaredMethods() {\n        Set<ResolvedMethodDeclaration> methods = new HashSet<>();\n        for (BodyDeclaration<?> member : wrappedNode.getMembers()) {\n            if (member instanceof MethodDeclaration) {\n                methods.add(new JavaParserMethodDeclaration((MethodDeclaration) member, typeSolver));\n            }\n        }\n        return methods;\n    }\n\n    @Override\n    public List<ResolvedTypeParameterDeclaration> getTypeParameters() {\n        return this.wrappedNode.getTypeParameters().stream().map(\n                (tp) -> new JavaParserTypeParameter(tp, typeSolver)\n        ).collect(Collectors.toList());\n    }\n\n    /**\n     * Returns the JavaParser node associated with this JavaParserClassDeclaration.\n     *\n     * @return A visitable JavaParser node wrapped by this object.\n     */\n    public ClassOrInterfaceDeclaration getWrappedNode() {\n        return wrappedNode;\n    }\n\n    @Override\n    public AccessSpecifier accessSpecifier() {\n        return wrappedNode.getAccessSpecifier();\n    }\n\n    @Override\n    public Optional<Node> toAst() {\n        return Optional.of(wrappedNode);\n    }\n\n    ///\n    /// Protected methods\n    ///\n\n    @Override\n    protected ResolvedReferenceType object() {\n        ResolvedReferenceTypeDeclaration solvedJavaLangObject = typeSolver.getSolvedJavaLangObject();\n        return new ReferenceTypeImpl(solvedJavaLangObject, typeSolver);\n    }\n\n    @Override\n    public Set<ResolvedReferenceTypeDeclaration> internalTypes() {\n        return javaParserTypeAdapter.internalTypes();\n    }\n\n    @Override\n    public Optional<ResolvedReferenceTypeDeclaration> containerType() {\n        return javaParserTypeAdapter.containerType();\n    }\n\n    ///\n    /// Private methods\n    ///\n\n    private ResolvedReferenceType toReferenceType(ClassOrInterfaceType classOrInterfaceType) {\n        String className = classOrInterfaceType.getName().getId();\n        if (classOrInterfaceType.getScope().isPresent()) {\n            // look for the qualified name (for example class of type Rectangle2D.Double)\n            className = classOrInterfaceType.getScope().get().toString() + \".\" + className;\n        }\n        SymbolReference<ResolvedTypeDeclaration> ref = solveType(className);\n\n        // If unable to solve by the class name alone, attempt to qualify it.\n        if (!ref.isSolved()) {\n            Optional<ClassOrInterfaceType> localScope = classOrInterfaceType.getScope();\n            if (localScope.isPresent()) {\n                String localName = localScope.get().getName().getId() + \".\" + classOrInterfaceType.getName().getId();\n                ref = solveType(localName);\n            }\n        }\n\n        // If still unable to resolve, throw an exception.\n        if (!ref.isSolved()) {\n            throw new UnsolvedSymbolException(classOrInterfaceType.getName().getId());\n        }\n\n        if (!classOrInterfaceType.getTypeArguments().isPresent()) {\n            return new ReferenceTypeImpl(ref.getCorrespondingDeclaration().asReferenceType(), typeSolver);\n        }\n\n        List<ResolvedType> superClassTypeParameters = classOrInterfaceType.getTypeArguments().get()\n                .stream()\n                .map(ta -> new LazyType(v -> JavaParserFacade.get(typeSolver).convert(ta, ta)))\n                .collect(Collectors.toList());\n\n        return new ReferenceTypeImpl(ref.getCorrespondingDeclaration().asReferenceType(), superClassTypeParameters, typeSolver);\n    }\n}\n",
        "filePathAfter": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/declarations/JavaParserClassDeclaration.java",
        "sourceCodeAfterForWhole": "/*\n * Copyright (C) 2015-2016 Federico Tomassetti\n * Copyright (C) 2017-2020 The JavaParser Team.\n *\n * This file is part of JavaParser.\n *\n * JavaParser can be used either under the terms of\n * a) the GNU Lesser General Public License as published by\n *     the Free Software Foundation, either version 3 of the License, or\n *     (at your option) any later version.\n * b) the terms of the Apache License\n *\n * You should have received a copy of both licenses in LICENCE.LGPL and\n * LICENCE.APACHE. Please refer to those files for details.\n *\n * JavaParser is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n */\n\npackage com.github.javaparser.symbolsolver.javaparsermodel.declarations;\n\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Optional;\nimport java.util.Set;\nimport java.util.stream.Collectors;\n\nimport com.github.javaparser.ast.AccessSpecifier;\nimport com.github.javaparser.ast.Node;\nimport com.github.javaparser.ast.body.BodyDeclaration;\nimport com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;\nimport com.github.javaparser.ast.body.FieldDeclaration;\nimport com.github.javaparser.ast.body.MethodDeclaration;\nimport com.github.javaparser.ast.type.ClassOrInterfaceType;\nimport com.github.javaparser.resolution.MethodUsage;\nimport com.github.javaparser.resolution.UnsolvedSymbolException;\nimport com.github.javaparser.resolution.declarations.ResolvedConstructorDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedFieldDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedMethodDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedReferenceTypeDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedTypeDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedTypeParameterDeclaration;\nimport com.github.javaparser.resolution.types.ResolvedReferenceType;\nimport com.github.javaparser.resolution.types.ResolvedType;\nimport com.github.javaparser.symbolsolver.core.resolution.Context;\nimport com.github.javaparser.symbolsolver.core.resolution.MethodUsageResolutionCapability;\nimport com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade;\nimport com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFactory;\nimport com.github.javaparser.symbolsolver.logic.AbstractClassDeclaration;\nimport com.github.javaparser.symbolsolver.model.resolution.SymbolReference;\nimport com.github.javaparser.symbolsolver.model.resolution.TypeSolver;\nimport com.github.javaparser.symbolsolver.model.typesystem.LazyType;\nimport com.github.javaparser.symbolsolver.model.typesystem.ReferenceTypeImpl;\nimport com.github.javaparser.symbolsolver.resolution.SymbolSolver;\n\n/**\n * @author Federico Tomassetti\n */\npublic class JavaParserClassDeclaration extends AbstractClassDeclaration implements MethodUsageResolutionCapability {\n\n    ///\n    /// Fields\n    ///\n\n    private TypeSolver typeSolver;\n    private ClassOrInterfaceDeclaration wrappedNode;\n    private JavaParserTypeAdapter<ClassOrInterfaceDeclaration> javaParserTypeAdapter;\n\n    ///\n    /// Constructors\n    ///\n\n    public JavaParserClassDeclaration(ClassOrInterfaceDeclaration wrappedNode,\n                                      TypeSolver typeSolver) {\n        if (wrappedNode.isInterface()) {\n            throw new IllegalArgumentException(\"Interface given\");\n        }\n        this.wrappedNode = wrappedNode;\n        this.typeSolver = typeSolver;\n        this.javaParserTypeAdapter = new JavaParserTypeAdapter<>(wrappedNode, typeSolver);\n    }\n\n    ///\n    /// Public methods: from Object\n    ///\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n\n        JavaParserClassDeclaration that = (JavaParserClassDeclaration) o;\n\n        return wrappedNode.equals(that.wrappedNode);\n    }\n\n    @Override\n    public int hashCode() {\n        return wrappedNode.hashCode();\n    }\n\n    @Override\n    public String toString() {\n        return \"JavaParserClassDeclaration{\" +\n                \"wrappedNode=\" + wrappedNode +\n                '}';\n    }\n\n    ///\n    /// Public methods: fields\n    ///\n    \n    @Override\n    public List<ResolvedFieldDeclaration> getAllFields() {\n        List<ResolvedFieldDeclaration> fields = javaParserTypeAdapter.getFieldsForDeclaredVariables();\n\n        getAncestors(true).stream().filter(ancestor -> ancestor.getTypeDeclaration().isPresent())\n                .forEach(ancestor -> ancestor.getTypeDeclaration().get().getAllFields()\n                        .forEach(f -> {\n                            fields.add(new ResolvedFieldDeclaration() {\n\n                                @Override\n                                public AccessSpecifier accessSpecifier() {\n                                    return f.accessSpecifier();\n                                }\n\n                                @Override\n                                public String getName() {\n                                    return f.getName();\n                                }\n\n                                @Override\n                                public ResolvedType getType() {\n                                    return ancestor.useThisTypeParametersOnTheGivenType(f.getType());\n                                }\n\n                                @Override\n                                public boolean isStatic() {\n                                    return f.isStatic();\n                                }\n                                \n                                @Override\n                                public boolean isVolatile() {\n                                    return f.isVolatile();\n                                }\n\n                                @Override\n                                public ResolvedTypeDeclaration declaringType() {\n                                    return f.declaringType();\n                                }\n                                \n                                @Override\n                                public Optional<FieldDeclaration> toAst() {\n                                    return f.toAst();\n                                }\n                            });\n                        }));\n\n        return fields;\n    }\n\n    ///\n    /// Public methods\n    ///\n\n    public SymbolReference<ResolvedMethodDeclaration> solveMethod(String name, List<ResolvedType> parameterTypes) {\n        Context ctx = getContext();\n        return ctx.solveMethod(name, parameterTypes, false);\n    }\n\n    @Override\n    public Optional<MethodUsage> solveMethodAsUsage(String name, List<ResolvedType> argumentTypes,\n                                                    Context invocationContext, List<ResolvedType> typeParameters) {\n        return getContext().solveMethodAsUsage(name, argumentTypes);\n    }\n\n    /**\n     * This method is deprecated because the context is an implementation detail that should not be exposed.\n     * Ideally this method should become private. For this reason all further usages of this method are discouraged.\n     */\n    @Deprecated\n    public Context getContext() {\n        return JavaParserFactory.getContext(wrappedNode, typeSolver);\n    }\n\n    public ResolvedType getUsage(Node node) {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public String getName() {\n        return wrappedNode.getName().getId();\n    }\n\n    @Override\n    public Optional<ResolvedReferenceType> getSuperClass() {\n        if(isJavaLangObject()) {\n            // If this is java.lang.Object, it has no super class.\n            return Optional.empty();\n        } else if (wrappedNode.getExtendedTypes().isEmpty()) {\n            // All objects implicitly extend java.lang.Object -- inject it here (only when this isn't java.lang.Object)\n            return Optional.of(object());\n        } else {\n            // Otherwise, return the first ancestor (n.b.: we know it's not empty due to check above).\n            return Optional.of(toReferenceType(wrappedNode.getExtendedTypes().getFirst().get()));\n        }\n    }\n\n    @Override\n    public List<ResolvedReferenceType> getInterfaces() {\n        List<ResolvedReferenceType> interfaces = new ArrayList<>();\n        // TODO FIXME: Remove null check -- should be an empty list...\n        if (wrappedNode.getImplementedTypes() != null) {\n            for (ClassOrInterfaceType t : wrappedNode.getImplementedTypes()) {\n                interfaces.add(toReferenceType(t));\n            }\n        }\n        return interfaces;\n    }\n\n    @Override\n    public List<ResolvedConstructorDeclaration> getConstructors() {\n        return AstResolutionUtils.getConstructors(this.wrappedNode, typeSolver, this);\n    }\n\n    @Override\n    public boolean hasDirectlyAnnotation(String canonicalName) {\n        return AstResolutionUtils.hasDirectlyAnnotation(wrappedNode, typeSolver, canonicalName);\n    }\n\n    @Override\n    public boolean isInterface() {\n        return wrappedNode.isInterface();\n    }\n\n    @Override\n    public String getPackageName() {\n        return javaParserTypeAdapter.getPackageName();\n    }\n\n    @Override\n    public String getClassName() {\n        return javaParserTypeAdapter.getClassName();\n    }\n\n    @Override\n    public String getQualifiedName() {\n        return javaParserTypeAdapter.getQualifiedName();\n    }\n\n    @Override\n    public boolean isAssignableBy(ResolvedReferenceTypeDeclaration other) {\n        return javaParserTypeAdapter.isAssignableBy(other);\n    }\n\n    @Override\n    public boolean isAssignableBy(ResolvedType type) {\n        return javaParserTypeAdapter.isAssignableBy(type);\n    }\n\n    @Override\n    public boolean canBeAssignedTo(ResolvedReferenceTypeDeclaration other) {\n        // TODO consider generic types\n        if (this.getQualifiedName().equals(other.getQualifiedName())) {\n            return true;\n        }\n\n        Optional<ResolvedReferenceType> optionalSuperClass = getSuperClass();\n        if (optionalSuperClass.isPresent()) {\n            Optional<ResolvedReferenceTypeDeclaration> optionalSuperclassTypeDeclaration = optionalSuperClass.get().getTypeDeclaration();\n            if (optionalSuperclassTypeDeclaration.isPresent()) {\n                ResolvedReferenceTypeDeclaration superclassTypeDeclaration = optionalSuperclassTypeDeclaration.get();\n                if (superclassTypeDeclaration != this && superclassTypeDeclaration.isClass()) {\n                    if (superclassTypeDeclaration.asClass().canBeAssignedTo(other)) {\n                        return true;\n                    }\n                }\n            }\n        }\n\n        // TODO FIXME: Remove null check -- should be an empty list...\n        if (this.wrappedNode.getImplementedTypes() != null) {\n            for (ClassOrInterfaceType type : wrappedNode.getImplementedTypes()) {\n                ResolvedReferenceTypeDeclaration ancestor = (ResolvedReferenceTypeDeclaration) new SymbolSolver(typeSolver).solveType(type);\n                if (ancestor.canBeAssignedTo(other)) {\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n\n    @Override\n    public boolean isTypeParameter() {\n        return false;\n    }\n\n    /**\n     * Resolution should move out of declarations, so that they are pure declarations and the resolution should\n     * work for JavaParser, Reflection and Javassist classes in the same way and not be specific to the three\n     * implementations.\n     */\n    @Deprecated\n    public SymbolReference<ResolvedTypeDeclaration> solveType(String name) {\n        if (this.wrappedNode.getName().getId().equals(name)) {\n            return SymbolReference.solved(this);\n        }\n        SymbolReference<ResolvedTypeDeclaration> ref = javaParserTypeAdapter.solveType(name);\n        if (ref.isSolved()) {\n            return ref;\n        }\n\n        String prefix = wrappedNode.getName() + \".\";\n        if (name.startsWith(prefix) && name.length() > prefix.length()) {\n            return new JavaParserClassDeclaration(this.wrappedNode, typeSolver).solveType(name.substring(prefix.length()));\n        }\n\n        return getContext().getParent()\n                .orElseThrow(() -> new RuntimeException(\"Parent context unexpectedly empty.\"))\n                .solveType(name);\n    }\n\n    @Override\n    public SymbolReference<ResolvedMethodDeclaration> solveMethod(String name, List<ResolvedType> argumentsTypes,\n                                                                  boolean staticOnly) {\n        return getContext().solveMethod(name, argumentsTypes, staticOnly);\n    }\n\n    @Override\n    public List<ResolvedReferenceType> getAncestors(boolean acceptIncompleteList) {\n        List<ResolvedReferenceType> ancestors = new ArrayList<>();\n\n        // We want to avoid infinite recursion in case of Object having Object as ancestor\n        if (this.isJavaLangObject()) {\n            return ancestors;\n        }\n\n        Optional<String> qualifiedName = wrappedNode.getFullyQualifiedName();\n        if (!qualifiedName.isPresent()) {\n            return ancestors;\n        }\n\n        try {\n            // If a superclass is found, add it as an ancestor\n            Optional<ResolvedReferenceType> superClass = getSuperClass();\n            if (superClass.isPresent()) {\n                if (isAncestor(superClass.get(), qualifiedName.get())) {\n                    ancestors.add(superClass.get());\n                }\n            }\n        } catch (UnsolvedSymbolException e) {\n            // in case we could not resolve the super class, we may still be able to resolve (some of) the\n            // implemented interfaces and so we continue gracefully with an (incomplete) list of ancestors\n\n            if (!acceptIncompleteList) {\n                // Only throw if an incomplete ancestor list is unacceptable.\n                throw e;\n            }\n        }\n\n        for (ClassOrInterfaceType implemented : wrappedNode.getImplementedTypes()) {\n            try {\n                // If an implemented interface is found, add it as an ancestor\n                ResolvedReferenceType rrt = toReferenceType(implemented);\n                if (isAncestor(rrt, qualifiedName.get())) {\n                    ancestors.add(rrt);\n                }\n            } catch (UnsolvedSymbolException e) {\n                // in case we could not resolve some implemented interface, we may still be able to resolve the\n                // extended class or (some of) the other implemented interfaces and so we continue gracefully\n                // with an (incomplete) list of ancestors\n\n                if (!acceptIncompleteList) {\n                    // Only throw if an incomplete ancestor list is unacceptable.\n                    throw e;\n                }\n            }\n        }\n\n        return ancestors;\n    }\n\n    private boolean isAncestor(ResolvedReferenceType candidateAncestor, String ownQualifiedName) {\n        Optional<ResolvedReferenceTypeDeclaration> resolvedReferenceTypeDeclaration = candidateAncestor.getTypeDeclaration();\n        if (resolvedReferenceTypeDeclaration.isPresent()) {\n            ResolvedTypeDeclaration rtd = resolvedReferenceTypeDeclaration.get().asType();\n            // do not consider an inner or nested class as an ancestor\n            return !rtd.getQualifiedName().contains(ownQualifiedName);\n        }\n        return false;\n    }\n\n    @Override\n    public Set<ResolvedMethodDeclaration> getDeclaredMethods() {\n        Set<ResolvedMethodDeclaration> methods = new HashSet<>();\n        for (BodyDeclaration<?> member : wrappedNode.getMembers()) {\n            if (member instanceof MethodDeclaration) {\n                methods.add(new JavaParserMethodDeclaration((MethodDeclaration) member, typeSolver));\n            }\n        }\n        return methods;\n    }\n\n    @Override\n    public List<ResolvedTypeParameterDeclaration> getTypeParameters() {\n        return this.wrappedNode.getTypeParameters().stream().map(\n                (tp) -> new JavaParserTypeParameter(tp, typeSolver)\n        ).collect(Collectors.toList());\n    }\n\n    /**\n     * Returns the JavaParser node associated with this JavaParserClassDeclaration.\n     *\n     * @return A visitable JavaParser node wrapped by this object.\n     */\n    public ClassOrInterfaceDeclaration getWrappedNode() {\n        return wrappedNode;\n    }\n\n    @Override\n    public AccessSpecifier accessSpecifier() {\n        return wrappedNode.getAccessSpecifier();\n    }\n\n    @Override\n    public Optional<Node> toAst() {\n        return Optional.of(wrappedNode);\n    }\n\n    ///\n    /// Protected methods\n    ///\n\n    @Override\n    protected ResolvedReferenceType object() {\n        ResolvedReferenceTypeDeclaration solvedJavaLangObject = typeSolver.getSolvedJavaLangObject();\n        return new ReferenceTypeImpl(solvedJavaLangObject, typeSolver);\n    }\n\n    @Override\n    public Set<ResolvedReferenceTypeDeclaration> internalTypes() {\n        return javaParserTypeAdapter.internalTypes();\n    }\n\n    @Override\n    public Optional<ResolvedReferenceTypeDeclaration> containerType() {\n        return javaParserTypeAdapter.containerType();\n    }\n\n    ///\n    /// Private methods\n    ///\n\n    private ResolvedReferenceType toReferenceType(ClassOrInterfaceType classOrInterfaceType) {\n        String className = classOrInterfaceType.getName().getId();\n        if (classOrInterfaceType.getScope().isPresent()) {\n            // look for the qualified name (for example class of type Rectangle2D.Double)\n            className = classOrInterfaceType.getScope().get().toString() + \".\" + className;\n        }\n        SymbolReference<ResolvedTypeDeclaration> ref = solveType(className);\n\n        // If unable to solve by the class name alone, attempt to qualify it.\n        if (!ref.isSolved()) {\n            Optional<ClassOrInterfaceType> localScope = classOrInterfaceType.getScope();\n            if (localScope.isPresent()) {\n                String localName = localScope.get().getName().getId() + \".\" + classOrInterfaceType.getName().getId();\n                ref = solveType(localName);\n            }\n        }\n\n        // If still unable to resolve, throw an exception.\n        if (!ref.isSolved()) {\n            throw new UnsolvedSymbolException(classOrInterfaceType.getName().getId());\n        }\n\n        if (!classOrInterfaceType.getTypeArguments().isPresent()) {\n            return new ReferenceTypeImpl(ref.getCorrespondingDeclaration().asReferenceType(), typeSolver);\n        }\n\n        List<ResolvedType> superClassTypeParameters = classOrInterfaceType.getTypeArguments().get()\n                .stream()\n                .map(ta -> new LazyType(v -> JavaParserFacade.get(typeSolver).convert(ta, ta)))\n                .collect(Collectors.toList());\n\n        return new ReferenceTypeImpl(ref.getCorrespondingDeclaration().asReferenceType(), superClassTypeParameters, typeSolver);\n    }\n}\n",
        "diffSourceCodeSet": [
            "private boolean isAncestor(ResolvedReferenceType candidateAncestor, String ownQualifiedName) {\n        Optional<ResolvedReferenceTypeDeclaration> resolvedReferenceTypeDeclaration = candidateAncestor.getTypeDeclaration();\n        if (resolvedReferenceTypeDeclaration.isPresent()) {\n            ResolvedTypeDeclaration rtd = resolvedReferenceTypeDeclaration.get().asType();\n            // do not consider an inner or nested class as an ancestor\n            return !rtd.getQualifiedName().contains(ownQualifiedName);\n        }\n        return false;\n    }"
        ],
        "invokedMethodSet": [
            "methodSignature: com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserClassDeclaration#getQualifiedName\n methodBody: public String getQualifiedName() {\nreturn javaParserTypeAdapter.getQualifiedName();\n}",
            "methodSignature: com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserClassDeclaration#toReferenceType\n methodBody: private ResolvedReferenceType toReferenceType(ClassOrInterfaceType classOrInterfaceType) {\nString className=classOrInterfaceType.getName().getId();\nif(classOrInterfaceType.getScope().isPresent()){className=classOrInterfaceType.getScope().get().toString() + \".\" + className;\n}SymbolReference<ResolvedTypeDeclaration> ref=solveType(className);\nif(!ref.isSolved()){Optional<ClassOrInterfaceType> localScope=classOrInterfaceType.getScope();\nif(localScope.isPresent()){String localName=localScope.get().getName().getId() + \".\" + classOrInterfaceType.getName().getId();\nref=solveType(localName);\n}}if(!ref.isSolved()){throw new UnsolvedSymbolException(classOrInterfaceType.getName().getId());\n}if(!classOrInterfaceType.getTypeArguments().isPresent()){return new ReferenceTypeImpl(ref.getCorrespondingDeclaration().asReferenceType(),typeSolver);\n}List<ResolvedType> superClassTypeParameters=classOrInterfaceType.getTypeArguments().get().stream().map(ta -> new LazyType(v -> JavaParserFacade.get(typeSolver).convert(ta,ta))).collect(Collectors.toList());\nreturn new ReferenceTypeImpl(ref.getCorrespondingDeclaration().asReferenceType(),superClassTypeParameters,typeSolver);\n}",
            "methodSignature: com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserClassDeclaration#getSuperClass\n methodBody: public Optional<ResolvedReferenceType> getSuperClass() {\nif(isJavaLangObject()){return Optional.empty();\n}if(wrappedNode.getExtendedTypes().isEmpty()){return Optional.of(object());\n}{return Optional.of(toReferenceType(wrappedNode.getExtendedTypes().getFirst().get()));\n}}"
        ],
        "sourceCodeAfterRefactoring": "@Override\n    public List<ResolvedReferenceType> getAncestors(boolean acceptIncompleteList) {\n        List<ResolvedReferenceType> ancestors = new ArrayList<>();\n\n        // We want to avoid infinite recursion in case of Object having Object as ancestor\n        if (this.isJavaLangObject()) {\n            return ancestors;\n        }\n\n        Optional<String> qualifiedName = wrappedNode.getFullyQualifiedName();\n        if (!qualifiedName.isPresent()) {\n            return ancestors;\n        }\n\n        try {\n            // If a superclass is found, add it as an ancestor\n            Optional<ResolvedReferenceType> superClass = getSuperClass();\n            if (superClass.isPresent()) {\n                if (isAncestor(superClass.get(), qualifiedName.get())) {\n                    ancestors.add(superClass.get());\n                }\n            }\n        } catch (UnsolvedSymbolException e) {\n            // in case we could not resolve the super class, we may still be able to resolve (some of) the\n            // implemented interfaces and so we continue gracefully with an (incomplete) list of ancestors\n\n            if (!acceptIncompleteList) {\n                // Only throw if an incomplete ancestor list is unacceptable.\n                throw e;\n            }\n        }\n\n        for (ClassOrInterfaceType implemented : wrappedNode.getImplementedTypes()) {\n            try {\n                // If an implemented interface is found, add it as an ancestor\n                ResolvedReferenceType rrt = toReferenceType(implemented);\n                if (isAncestor(rrt, qualifiedName.get())) {\n                    ancestors.add(rrt);\n                }\n            } catch (UnsolvedSymbolException e) {\n                // in case we could not resolve some implemented interface, we may still be able to resolve the\n                // extended class or (some of) the other implemented interfaces and so we continue gracefully\n                // with an (incomplete) list of ancestors\n\n                if (!acceptIncompleteList) {\n                    // Only throw if an incomplete ancestor list is unacceptable.\n                    throw e;\n                }\n            }\n        }\n\n        return ancestors;\n    }\nprivate boolean isAncestor(ResolvedReferenceType candidateAncestor, String ownQualifiedName) {\n        Optional<ResolvedReferenceTypeDeclaration> resolvedReferenceTypeDeclaration = candidateAncestor.getTypeDeclaration();\n        if (resolvedReferenceTypeDeclaration.isPresent()) {\n            ResolvedTypeDeclaration rtd = resolvedReferenceTypeDeclaration.get().asType();\n            // do not consider an inner or nested class as an ancestor\n            return !rtd.getQualifiedName().contains(ownQualifiedName);\n        }\n        return false;\n    }",
        "diffSourceCode": "   333:     @Override\n   334:     public List<ResolvedReferenceType> getAncestors(boolean acceptIncompleteList) {\n   335:         List<ResolvedReferenceType> ancestors = new ArrayList<>();\n   336: \n   337:         // We want to avoid infinite recursion in case of Object having Object as ancestor\n   338:         if (this.isJavaLangObject()) {\n   339:             return ancestors;\n   340:         }\n   341: \n-  342:         try {\n-  343:             // If a superclass is found, add it as an ancestor\n-  344:             getSuperClass().ifPresent(ancestors::add);\n-  345:         } catch (UnsolvedSymbolException e) {\n-  346:             // in case we could not resolve the super class, we may still be able to resolve (some of) the\n-  347:             // implemented interfaces and so we continue gracefully with an (incomplete) list of ancestors\n-  348: \n-  349:             if (!acceptIncompleteList) {\n-  350:                 // Only throw if an incomplete ancestor list is unacceptable.\n-  351:                 throw e;\n-  352:             }\n-  353:         }\n-  354: \n-  355:         for (ClassOrInterfaceType implemented : wrappedNode.getImplementedTypes()) {\n-  356:             try {\n-  357:                 // If an implemented interface is found, add it as an ancestor\n-  358:                 ResolvedReferenceType rrt = toReferenceType(implemented);\n-  359:                 Optional<ResolvedReferenceTypeDeclaration> resolvedReferenceTypeDeclaration = rrt.getTypeDeclaration();\n-  360:                 if (resolvedReferenceTypeDeclaration.isPresent()) {\n-  361: \n-  362:                     ResolvedTypeDeclaration rtd = resolvedReferenceTypeDeclaration.get().asType();\n-  363:                     Optional<String> qualifiedName = wrappedNode.getFullyQualifiedName();\n-  364:                     if (qualifiedName.isPresent()) {\n-  365: \n-  366:                         // do not consider an inner or nested class as an ancestor\n-  367:                         if (!rtd.getQualifiedName().contains(qualifiedName.get())) {\n-  368:                             ancestors.add(rrt);\n-  369:                         }\n-  370:                     }\n+  342:         Optional<String> qualifiedName = wrappedNode.getFullyQualifiedName();\n+  343:         if (!qualifiedName.isPresent()) {\n+  344:             return ancestors;\n+  345:         }\n+  346: \n+  347:         try {\n+  348:             // If a superclass is found, add it as an ancestor\n+  349:             Optional<ResolvedReferenceType> superClass = getSuperClass();\n+  350:             if (superClass.isPresent()) {\n+  351:                 if (isAncestor(superClass.get(), qualifiedName.get())) {\n+  352:                     ancestors.add(superClass.get());\n+  353:                 }\n+  354:             }\n+  355:         } catch (UnsolvedSymbolException e) {\n+  356:             // in case we could not resolve the super class, we may still be able to resolve (some of) the\n+  357:             // implemented interfaces and so we continue gracefully with an (incomplete) list of ancestors\n+  358: \n+  359:             if (!acceptIncompleteList) {\n+  360:                 // Only throw if an incomplete ancestor list is unacceptable.\n+  361:                 throw e;\n+  362:             }\n+  363:         }\n+  364: \n+  365:         for (ClassOrInterfaceType implemented : wrappedNode.getImplementedTypes()) {\n+  366:             try {\n+  367:                 // If an implemented interface is found, add it as an ancestor\n+  368:                 ResolvedReferenceType rrt = toReferenceType(implemented);\n+  369:                 if (isAncestor(rrt, qualifiedName.get())) {\n+  370:                     ancestors.add(rrt);\n   371:                 }\n   372:             } catch (UnsolvedSymbolException e) {\n   373:                 // in case we could not resolve some implemented interface, we may still be able to resolve the\n   374:                 // extended class or (some of) the other implemented interfaces and so we continue gracefully\n   375:                 // with an (incomplete) list of ancestors\n   376: \n   377:                 if (!acceptIncompleteList) {\n   378:                     // Only throw if an incomplete ancestor list is unacceptable.\n   379:                     throw e;\n   380:                 }\n   381:             }\n   382:         }\n   383: \n   384:         return ancestors;\n   385:     }\n-  387:     @Override\n-  388:     public Set<ResolvedMethodDeclaration> getDeclaredMethods() {\n-  389:         Set<ResolvedMethodDeclaration> methods = new HashSet<>();\n-  390:         for (BodyDeclaration<?> member : wrappedNode.getMembers()) {\n-  391:             if (member instanceof MethodDeclaration) {\n-  392:                 methods.add(new JavaParserMethodDeclaration((MethodDeclaration) member, typeSolver));\n-  393:             }\n-  394:         }\n-  395:         return methods;\n+  387:     private boolean isAncestor(ResolvedReferenceType candidateAncestor, String ownQualifiedName) {\n+  388:         Optional<ResolvedReferenceTypeDeclaration> resolvedReferenceTypeDeclaration = candidateAncestor.getTypeDeclaration();\n+  389:         if (resolvedReferenceTypeDeclaration.isPresent()) {\n+  390:             ResolvedTypeDeclaration rtd = resolvedReferenceTypeDeclaration.get().asType();\n+  391:             // do not consider an inner or nested class as an ancestor\n+  392:             return !rtd.getQualifiedName().contains(ownQualifiedName);\n+  393:         }\n+  394:         return false;\n+  395:     }\n",
        "uniqueId": "df18fcb41f73c5223b9952a0ede13e410b0e16b9_333_385_387_395_333_385",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 5,
                "covered": 72
            },
            "BRANCH": {
                "missed": 3,
                "covered": 11
            },
            "LINE": {
                "missed": 3,
                "covered": 20
            },
            "COMPLEXITY": {
                "missed": 2,
                "covered": 6
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 17
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprivate resolveLambda(node LambdaExpr, result ResolvedType) : ResolvedType extracted from public visit(node LambdaExpr, solveLambdas Boolean) : ResolvedType in class com.github.javaparser.symbolsolver.javaparsermodel.TypeExtractor",
        "diffLocations": [
            {
                "filePath": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/TypeExtractor.java",
                "startLine": 647,
                "endLine": 756,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/TypeExtractor.java",
                "startLine": 647,
                "endLine": 710,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/TypeExtractor.java",
                "startLine": 712,
                "endLine": 775,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "@Override\n    public ResolvedType visit(LambdaExpr node, Boolean solveLambdas) {\n        if (demandParentNode(node) instanceof MethodCallExpr) {\n            MethodCallExpr callExpr = (MethodCallExpr) demandParentNode(node);\n            int pos = JavaParserSymbolDeclaration.getParamPos(node);\n            SymbolReference<ResolvedMethodDeclaration> refMethod = facade.solve(callExpr);\n            if (!refMethod.isSolved()) {\n                throw new UnsolvedSymbolException(demandParentNode(node).toString(), callExpr.getName().getId());\n            }\n            Log.trace(\"getType on lambda expr %s\", ()-> refMethod.getCorrespondingDeclaration().getName());\n            if (solveLambdas) {\n\n                // The type parameter referred here should be the java.util.stream.Stream.T\n                ResolvedType result = refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n\n                if (callExpr.hasScope()) {\n                    Expression scope = callExpr.getScope().get();\n\n                    // If it is a static call we should not try to get the type of the scope\n                    boolean staticCall = false;\n                    if (scope instanceof NameExpr) {\n                        NameExpr nameExpr = (NameExpr) scope;\n                        try {\n                            SymbolReference<ResolvedTypeDeclaration> type = JavaParserFactory.getContext(nameExpr, typeSolver).solveType(nameExpr.getName().getId());\n                            if (type.isSolved()) {\n                                staticCall = true;\n                            }\n                        } catch (Exception e) {\n\n                        }\n                    }\n\n                    if (!staticCall) {\n                        ResolvedType scopeType = facade.getType(scope);\n                        if (scopeType.isReferenceType()) {\n                            result = scopeType.asReferenceType().useThisTypeParametersOnTheGivenType(result);\n                        }\n                    }\n                }\n\n                // We need to replace the type variables\n                Context ctx = JavaParserFactory.getContext(node, typeSolver);\n                result = solveGenericTypes(result, ctx);\n\n                //We should find out which is the functional method (e.g., apply) and replace the params of the\n                //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                //lambdas\n                Optional<MethodUsage> functionalMethod = FunctionalInterfaceLogic.getFunctionalMethod(result);\n                if (functionalMethod.isPresent()) {\n                    LambdaExpr lambdaExpr = node;\n\n                    InferenceContext lambdaCtx = new InferenceContext(MyObjectProvider.INSTANCE);\n                    InferenceContext funcInterfaceCtx = new InferenceContext(MyObjectProvider.INSTANCE);\n\n                    // At this point parameterType\n                    // if Function<T=? super Stream.T, ? extends map.R>\n                    // we should replace Stream.T\n                    ResolvedType functionalInterfaceType = ReferenceTypeImpl.undeterminedParameters(functionalMethod.get().getDeclaration().declaringType(), typeSolver);\n\n                    lambdaCtx.addPair(result, functionalInterfaceType);\n\n                    ResolvedType actualType;\n\n                    if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                        actualType = facade.getType(((ExpressionStmt) lambdaExpr.getBody()).getExpression());\n                    } else if (lambdaExpr.getBody() instanceof BlockStmt) {\n                        BlockStmt blockStmt = (BlockStmt) lambdaExpr.getBody();\n\n                        // Get all the return statements in the lambda block\n                        List<ReturnStmt> returnStmts = blockStmt.findAll(ReturnStmt.class);\n\n                        if (returnStmts.size() > 0) {\n                            actualType = returnStmts.stream()\n                                    .map(returnStmt -> returnStmt.getExpression().map(e -> facade.getType(e)).orElse(ResolvedVoidType.INSTANCE))\n                                    .filter(x -> x != null && !x.isVoid() && !x.isNull())\n                                    .findFirst()\n                                    .orElse(ResolvedVoidType.INSTANCE);\n\n                        } else {\n                            actualType = ResolvedVoidType.INSTANCE;\n                        }\n\n\n                    } else {\n                        throw new UnsupportedOperationException();\n                    }\n\n                    ResolvedType formalType = functionalMethod.get().returnType();\n\n                    // Infer the functional interfaces' return vs actual type\n                    funcInterfaceCtx.addPair(formalType, actualType);\n                    // Substitute to obtain a new type\n                    ResolvedType functionalTypeWithReturn = funcInterfaceCtx.resolve(funcInterfaceCtx.addSingle(functionalInterfaceType));\n\n                    // if the functional method returns void anyway\n                    // we don't need to bother inferring types\n                    if (!(formalType instanceof ResolvedVoidType)) {\n                        lambdaCtx.addPair(result, functionalTypeWithReturn);\n                        result = lambdaCtx.resolve(lambdaCtx.addSingle(result));\n                    }\n                }\n\n                return result;\n            } else {\n                return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n            }\n        } else {\n            throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n        }\n    }",
        "filePathBefore": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/TypeExtractor.java",
        "isPureRefactoring": true,
        "commitId": "a9adfa6c86ba236edeaa2be318c337f98e5c6720",
        "packageNameBefore": "com.github.javaparser.symbolsolver.javaparsermodel",
        "classNameBefore": "com.github.javaparser.symbolsolver.javaparsermodel.TypeExtractor",
        "methodNameBefore": "com.github.javaparser.symbolsolver.javaparsermodel.TypeExtractor#visit",
        "classSignatureBefore": "public class TypeExtractor extends DefaultVisitorAdapter ",
        "methodNameBeforeSet": [
            "com.github.javaparser.symbolsolver.javaparsermodel.TypeExtractor#visit"
        ],
        "classNameBeforeSet": [
            "com.github.javaparser.symbolsolver.javaparsermodel.TypeExtractor"
        ],
        "classSignatureBeforeSet": [
            "public class TypeExtractor extends DefaultVisitorAdapter "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Copyright (C) 2015-2016 Federico Tomassetti\n * Copyright (C) 2017-2020 The JavaParser Team.\n *\n * This file is part of JavaParser.\n *\n * JavaParser can be used either under the terms of\n * a) the GNU Lesser General Public License as published by\n *     the Free Software Foundation, either version 3 of the License, or\n *     (at your option) any later version.\n * b) the terms of the Apache License\n *\n * You should have received a copy of both licenses in LICENCE.LGPL and\n * LICENCE.APACHE. Please refer to those files for details.\n *\n * JavaParser is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n */\n\npackage com.github.javaparser.symbolsolver.javaparsermodel;\n\nimport static com.github.javaparser.symbolsolver.javaparser.Navigator.demandParentNode;\nimport static com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade.solveGenericTypes;\n\nimport java.util.List;\nimport java.util.Optional;\n\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.Node;\nimport com.github.javaparser.ast.body.FieldDeclaration;\nimport com.github.javaparser.ast.body.Parameter;\nimport com.github.javaparser.ast.body.VariableDeclarator;\nimport com.github.javaparser.ast.expr.ArrayAccessExpr;\nimport com.github.javaparser.ast.expr.ArrayCreationExpr;\nimport com.github.javaparser.ast.expr.ArrayInitializerExpr;\nimport com.github.javaparser.ast.expr.AssignExpr;\nimport com.github.javaparser.ast.expr.BinaryExpr;\nimport com.github.javaparser.ast.expr.BooleanLiteralExpr;\nimport com.github.javaparser.ast.expr.CastExpr;\nimport com.github.javaparser.ast.expr.CharLiteralExpr;\nimport com.github.javaparser.ast.expr.ClassExpr;\nimport com.github.javaparser.ast.expr.ConditionalExpr;\nimport com.github.javaparser.ast.expr.DoubleLiteralExpr;\nimport com.github.javaparser.ast.expr.EnclosedExpr;\nimport com.github.javaparser.ast.expr.Expression;\nimport com.github.javaparser.ast.expr.FieldAccessExpr;\nimport com.github.javaparser.ast.expr.InstanceOfExpr;\nimport com.github.javaparser.ast.expr.IntegerLiteralExpr;\nimport com.github.javaparser.ast.expr.LambdaExpr;\nimport com.github.javaparser.ast.expr.LongLiteralExpr;\nimport com.github.javaparser.ast.expr.MethodCallExpr;\nimport com.github.javaparser.ast.expr.MethodReferenceExpr;\nimport com.github.javaparser.ast.expr.NameExpr;\nimport com.github.javaparser.ast.expr.NullLiteralExpr;\nimport com.github.javaparser.ast.expr.ObjectCreationExpr;\nimport com.github.javaparser.ast.expr.StringLiteralExpr;\nimport com.github.javaparser.ast.expr.SuperExpr;\nimport com.github.javaparser.ast.expr.ThisExpr;\nimport com.github.javaparser.ast.expr.TypeExpr;\nimport com.github.javaparser.ast.expr.UnaryExpr;\nimport com.github.javaparser.ast.expr.VariableDeclarationExpr;\nimport com.github.javaparser.ast.stmt.BlockStmt;\nimport com.github.javaparser.ast.stmt.ExpressionStmt;\nimport com.github.javaparser.ast.stmt.ReturnStmt;\nimport com.github.javaparser.ast.type.ClassOrInterfaceType;\nimport com.github.javaparser.ast.type.Type;\nimport com.github.javaparser.ast.type.UnknownType;\nimport com.github.javaparser.resolution.MethodUsage;\nimport com.github.javaparser.resolution.UnsolvedSymbolException;\nimport com.github.javaparser.resolution.declarations.ResolvedClassDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedMethodDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedReferenceTypeDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedTypeDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedTypeParameterDeclaration;\nimport com.github.javaparser.resolution.types.ResolvedArrayType;\nimport com.github.javaparser.resolution.types.ResolvedPrimitiveType;\nimport com.github.javaparser.resolution.types.ResolvedType;\nimport com.github.javaparser.resolution.types.ResolvedVoidType;\nimport com.github.javaparser.symbolsolver.core.resolution.Context;\nimport com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserSymbolDeclaration;\nimport com.github.javaparser.symbolsolver.logic.FunctionalInterfaceLogic;\nimport com.github.javaparser.symbolsolver.logic.InferenceContext;\nimport com.github.javaparser.symbolsolver.model.resolution.SymbolReference;\nimport com.github.javaparser.symbolsolver.model.resolution.TypeSolver;\nimport com.github.javaparser.symbolsolver.model.resolution.Value;\nimport com.github.javaparser.symbolsolver.model.typesystem.NullType;\nimport com.github.javaparser.symbolsolver.model.typesystem.ReferenceTypeImpl;\nimport com.github.javaparser.symbolsolver.reflectionmodel.MyObjectProvider;\nimport com.github.javaparser.symbolsolver.reflectionmodel.ReflectionClassDeclaration;\nimport com.github.javaparser.symbolsolver.resolution.SymbolSolver;\nimport com.github.javaparser.symbolsolver.resolution.typeinference.TypeHelper;\nimport com.github.javaparser.symbolsolver.resolution.typesolvers.ReflectionTypeSolver;\nimport com.github.javaparser.utils.Log;\nimport com.github.javaparser.utils.Pair;\nimport com.google.common.collect.ImmutableList;\n\npublic class TypeExtractor extends DefaultVisitorAdapter {\n\n    private static final String JAVA_LANG_STRING = String.class.getCanonicalName();\n    \n    private TypeSolver typeSolver;\n    private JavaParserFacade facade;\n    \n    private ReferenceTypeImpl StringReferenceType;\n\n    public TypeExtractor(TypeSolver typeSolver, JavaParserFacade facade) {\n        this.typeSolver = typeSolver;\n        this.facade = facade;\n        //pre-calculate the String reference (optimization)\n        StringReferenceType = new ReferenceTypeImpl(new ReflectionTypeSolver().solveType(JAVA_LANG_STRING), typeSolver);\n    }\n\n    @Override\n    public ResolvedType visit(VariableDeclarator node, Boolean solveLambdas) {\n        if (demandParentNode(node) instanceof FieldDeclaration) {\n            return facade.convertToUsageVariableType(node);\n        } else if (demandParentNode(node) instanceof VariableDeclarationExpr) {\n            return facade.convertToUsageVariableType(node);\n        }\n        throw new UnsupportedOperationException(demandParentNode(node).getClass().getCanonicalName());\n    }\n\n    @Override\n    public ResolvedType visit(Parameter node, Boolean solveLambdas) {\n        if (node.getType() instanceof UnknownType) {\n            throw new IllegalStateException(\"Parameter has unknown type: \" + node);\n        }\n        return facade.convertToUsage(node.getType(), node);\n    }\n\n\n    @Override\n    public ResolvedType visit(ArrayAccessExpr node, Boolean solveLambdas) {\n        ResolvedType arrayUsageType = node.getName().accept(this, solveLambdas);\n        if (arrayUsageType.isArray()) {\n            return ((ResolvedArrayType) arrayUsageType).getComponentType();\n        }\n        return arrayUsageType;\n    }\n\n    @Override\n    public ResolvedType visit(ArrayCreationExpr node, Boolean solveLambdas) {\n        ResolvedType res = facade.convertToUsage(node.getElementType(), JavaParserFactory.getContext(node, typeSolver));\n        for (int i = 0; i < node.getLevels().size(); i++) {\n            res = new ResolvedArrayType(res);\n        }\n        return res;\n    }\n\n    @Override\n    public ResolvedType visit(ArrayInitializerExpr node, Boolean solveLambdas) {\n        throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n    }\n\n    @Override\n    public ResolvedType visit(AssignExpr node, Boolean solveLambdas) {\n        return node.getTarget().accept(this, solveLambdas);\n    }\n\n    @Override\n    public ResolvedType visit(BinaryExpr node, Boolean solveLambdas) {\n        switch (node.getOperator()) {\n            case PLUS:\n            case MINUS:\n            case DIVIDE:\n            case MULTIPLY:\n            case REMAINDER:\n            case BINARY_AND:\n            case BINARY_OR:\n            case XOR:\n                return facade.getBinaryTypeConcrete(node.getLeft(), node.getRight(), solveLambdas, node.getOperator());\n            case LESS_EQUALS:\n            case LESS:\n            case GREATER:\n            case GREATER_EQUALS:\n            case EQUALS:\n            case NOT_EQUALS:\n            case OR:\n            case AND:\n                return ResolvedPrimitiveType.BOOLEAN;\n            case SIGNED_RIGHT_SHIFT:\n            case UNSIGNED_RIGHT_SHIFT:\n            case LEFT_SHIFT:\n                ResolvedType rt = node.getLeft().accept(this, solveLambdas);\n                // apply unary primitive promotion\n                return ResolvedPrimitiveType.unp(rt);\n            default:\n                throw new UnsupportedOperationException(\"Operator \" + node.getOperator().name());\n        }\n    }\n\n    @Override\n    public ResolvedType visit(CastExpr node, Boolean solveLambdas) {\n        return facade.convertToUsage(node.getType(), JavaParserFactory.getContext(node, typeSolver));\n    }\n\n    @Override\n    public ResolvedType visit(ClassExpr node, Boolean solveLambdas) {\n        // This implementation does not regard the actual type argument of the ClassExpr.\n        Type astType = node.getType();\n        ResolvedType jssType = facade.convertToUsage(astType, node.getType());\n        return new ReferenceTypeImpl(new ReflectionClassDeclaration(Class.class, typeSolver), ImmutableList.of(jssType), typeSolver);\n    }\n\n    /*\n     * The conditional operator has three operand expressions. ? appears between the first and second expressions, and\n     * : appears between the second and third expressions.\n     * There are three kinds of conditional expressions, classified according to the second and third operand\n     * expressions: boolean conditional expressions, numeric conditional expressions, and reference conditional\n     * expressions.\n     * The classification rules are as follows:\n     * 1/ If both the second and the third operand expressions are boolean expressions, the conditional expression is a\n     * boolean conditional expression.\n     * 2/ If both the second and the third operand expressions are numeric expressions, the conditional expression is a\n     * numeric conditional expression.\n     * 3/ Otherwise, the conditional expression is a reference conditional expression\n     */\n    @Override\n    public ResolvedType visit(ConditionalExpr node, Boolean solveLambdas) {\n        ResolvedType thenExpr = node.getThenExpr().accept(this, solveLambdas);\n        ResolvedType elseExpr = node.getElseExpr().accept(this, solveLambdas);\n        \n        // manage null expression\n        if ( thenExpr.isNull()) {\n            return  elseExpr;\n        }\n        if ( elseExpr.isNull()) {\n            return  thenExpr;\n        }\n        /*\n         * Boolean conditional expressions are standalone expressions\n         * The type of a boolean conditional expression is determined as follows:\n         * If the second and third operands are both of type Boolean, the conditional expression has type Boolean.\n         * Otherwise, the conditional expression has type boolean.\n         */\n        if ( thenExpr.isAssignableBy(ResolvedPrimitiveType.BOOLEAN) \n                && elseExpr.isAssignableBy(ResolvedPrimitiveType.BOOLEAN)) {\n            if (thenExpr.isReferenceType() && elseExpr.isReferenceType()) {\n                return thenExpr.asReferenceType();\n            }\n            return thenExpr.isPrimitive() ? thenExpr : elseExpr;\n        }\n        \n        /*\n         * Numeric conditional expressions are standalone expressions (\u00a715.2).\n         * The type of a numeric conditional expression is determined as follows:\n         * If the second and third operands have the same type, then that is the type of the conditional expression.\n         * If one of the second and third operands is of primitive type T, and the type of the other is the result of\n         * applying boxing conversion (\u00a75.1.7) to T, then the type of the conditional expression is T.\n         * If one of the operands is of type byte or Byte and the other is of type short or Short, then the type of the\n         * conditional expression is short.\n         * If one of the operands is of type T where T is byte, short, or char, and the other operand is a constant\n         * expression (\u00a715.28) of type int whose value is representable in type T, then the type of the conditional\n         * expression is T.\n         * If one of the operands is of type T, where T is Byte, Short, or Character, and the other operand is a\n         * constant expression of type int whose value is representable in the type U which is the result of applying\n         * unboxing conversion to T, then the type of the conditional expression is U.\n         * Otherwise, binary numeric promotion (\u00a75.6.2) is applied to the operand types, and the type of the\n         * conditional expression is the promoted type of the second and third operands.\n         */\n        if (thenExpr.isNumericType() && elseExpr.isNumericType()) {\n            ResolvedPrimitiveType[] resolvedPrimitiveTypeSubList = new ResolvedPrimitiveType[] {ResolvedPrimitiveType.BYTE, ResolvedPrimitiveType.SHORT, ResolvedPrimitiveType.CHAR};\n            /*\n             *  If the second and third operands have the same type, then that is the type of the conditional expression.\n             */\n            String qnameTypeThenExpr = thenExpr.isPrimitive() ? thenExpr.asPrimitive().describe()\n                    : thenExpr.asReferenceType().describe();\n            String qnameTypeElseExpr = elseExpr.isPrimitive() ? elseExpr.asPrimitive().describe()\n                    : elseExpr.asReferenceType().describe();\n            if (qnameTypeThenExpr.equals(qnameTypeElseExpr)) {\n                return thenExpr;\n            }\n            /*\n             * If one of the second and third operands is of primitive type T, and the type of the other is the result of\n             * applying boxing conversion (\u00a75.1.7) to T, then the type of the conditional expression is T.\n             */\n            else if ((thenExpr.isPrimitive() && elseExpr.isReferenceType()\n                    && isCompatible(elseExpr.asReferenceType(), thenExpr.asPrimitive()))) {\n                return thenExpr;\n            } else if ((elseExpr.isPrimitive() && thenExpr.isReferenceType()\n                    && isCompatible(thenExpr.asReferenceType(), elseExpr.asPrimitive()))) {\n                return elseExpr;\n            }\n            /*\n             * If one of the operands is of type byte or Byte and the other is of type short or Short, then the type of the\n             * conditional expression is short.\n             */\n            else if ((isCompatible(thenExpr, ResolvedPrimitiveType.BYTE) && isCompatible(elseExpr, ResolvedPrimitiveType.SHORT))\n                    || (isCompatible(elseExpr, ResolvedPrimitiveType.BYTE) && isCompatible(thenExpr, ResolvedPrimitiveType.SHORT))) {\n                return ResolvedPrimitiveType.SHORT;\n            }\n            /*\n             *  If one of the operands is of type T where T is byte, short, or char, and the\n             *  other operand is a constant expression (\u00a715.28) of type int whose value is\n             *  representable in type T, then the type of the conditional expression is T\n             *  How can we know if the constant expression of type int is representable in type T ?\n             *  \"The constant expression of type int is representable in type T\" is a runtime decision!\n             */\n            else if (thenExpr.isPrimitive() && elseExpr.isPrimitive()) {\n                if (((ResolvedPrimitiveType)thenExpr).in(resolvedPrimitiveTypeSubList)\n                    && ((ResolvedPrimitiveType)elseExpr).equals(ResolvedPrimitiveType.INT)) {\n                    return thenExpr;\n                } else if (((ResolvedPrimitiveType)elseExpr).in(resolvedPrimitiveTypeSubList)\n                    && ((ResolvedPrimitiveType)thenExpr).equals(ResolvedPrimitiveType.INT)) {\n                    return elseExpr;\n                }\n            }\n             /*  If one of the operands is of type T, where T is Byte, Short, or Character,\n             * and the other operand is a constant expression of type int whose value is\n             * representable in the type U which is the result of applying unboxing\n             * conversion to T, then the type of the conditional expression is U.\n             * A priori this is a runtime decision!\n             */\n            else if (thenExpr.isReference() && elseExpr.isPrimitive()\n                    && thenExpr.asReferenceType().isUnboxable()\n                    && thenExpr.asReferenceType().toUnboxedType().get().in(resolvedPrimitiveTypeSubList)\n                    && ((ResolvedPrimitiveType)elseExpr).equals(ResolvedPrimitiveType.INT)) {\n                return thenExpr.asReferenceType().toUnboxedType().get();\n            } else if (elseExpr.isReference() && thenExpr.isPrimitive()\n                    && elseExpr.asReferenceType().isUnboxable()\n                    && elseExpr.asReferenceType().toUnboxedType().get().in(resolvedPrimitiveTypeSubList)\n                    && ((ResolvedPrimitiveType)thenExpr).equals(ResolvedPrimitiveType.INT)) {\n                return elseExpr.asReferenceType().toUnboxedType().get();\n            }\n             \n            /* Otherwise, binary numeric promotion (\u00a75.6.2) is applied to the operand types,\n             * and the type of the conditional expression is the promoted type of the second\n             * and third operands.\n             */\n            ResolvedPrimitiveType PrimitiveThenExpr = thenExpr.isPrimitive() ? thenExpr.asPrimitive()\n                    : thenExpr.asReferenceType().toUnboxedType().get();\n            ResolvedPrimitiveType PrimitiveElseExpr = elseExpr.isPrimitive() ? elseExpr.asPrimitive()\n                    : elseExpr.asReferenceType().toUnboxedType().get();\n            return PrimitiveThenExpr.bnp(PrimitiveElseExpr);\n        }\n        \n        /*\n         * Otherwise, the conditional expression is a reference conditional expression.\n         * A reference conditional expression is a poly expression if it appears in an assignment context or an\n         * invocation context (\u00a75.2. \u00a75.3).\n         * Otherwise, it is a standalone expression.\n         * The type of a poly reference conditional expression is the same as its target type.\n         * The type of a standalone reference conditional expression is determined as follows:\n         * If the second and third operands have the same type (which may be the null type), then that is the type of\n         * the conditional expression.\n         * If the type of one of the second and third operands is the null type, and the type of the other operand is a\n         * reference type, then the type of the conditional expression is that reference type.\n         * Otherwise, the second and third operands are of types S1 and S2 respectively. Let T1 be the type that\n         * results from applying boxing conversion to S1, and let T2 be the type that results from applying boxing\n         * conversion to S2. The type of the conditional expression is the result of applying capture conversion\n         * (\u00a75.1.10) to lub(T1, T2).\n         * TODO : must be implemented\n         */\n        if (node.isPolyExpression()) {\n            // The type of a poly reference conditional expression is the same as its target type.\n            Optional<Node> parentNode = node.getParentNode();\n            if (parentNode.isPresent()) {\n                Node parent = parentNode.get();\n                if (parent instanceof AssignExpr) {\n                    return visit((AssignExpr)parent, solveLambdas);\n                } else if (parent instanceof MethodCallExpr) {\n                    // how to define the target type?\n                    // a priori it is the type of the parameter of the method which takes the value of the conditional expression\n                    // TODO for the moment we keep the original return type\n                    return thenExpr;\n                }\n                throw new RuntimeException(\"Cannot resolve type of poly expression \"+ node.toString());\n            } else {\n                throw new RuntimeException(\"Parent node unexpectedly empty\");\n            }\n            \n        }\n        \n        // The type of a standalone reference conditional expression is determined as follows:\n        \n        // If the second and third operands have the same type (which may be the null type), then that is the type of\n        // the conditional expression.\n        if (thenExpr.equals(elseExpr)) {\n            return thenExpr;\n        }\n        // If the type of one of the second and third operands is the null type, and the type of the other operand is a\n        // reference type, then the type of the conditional expression is that reference type.\n        // this case is already supported above\n        \n        // Otherwise, the second and third operands are of types S1 and S2 respectively. Let T1 be the type that\n        // results from applying boxing conversion to S1, and let T2 be the type that results from applying boxing\n        // conversion to S2. The type of the conditional expression is the result of applying capture conversion\n        // (\u00a75.1.10) to lub(T1, T2).\n        ResolvedType resolvedThenType = thenExpr.isPrimitive() ? TypeHelper.toBoxedType(thenExpr.asPrimitive(), typeSolver) : thenExpr;\n        ResolvedType resolvedElseType = elseExpr.isPrimitive() ? TypeHelper.toBoxedType(elseExpr.asPrimitive(), typeSolver) : elseExpr;\n        \n        // TypeHelper.leastUpperBound method is not yet implemented so for the moment we keep the original return type of this method\n        // TODO implement TypeHelper.leastUpperBound method\n        // return TypeHelper.leastUpperBound(new HashSet<ResolvedType>(Arrays.asList(resolvedThenType, resolvedElseType)));\n        return node.getThenExpr().accept(this, solveLambdas);\n    }\n    \n    private boolean isCompatible(ResolvedType resolvedType, ResolvedPrimitiveType primitiveType) {\n        return (resolvedType.isPrimitive() && resolvedType.asPrimitive().equals(primitiveType))\n        || (resolvedType.isReferenceType() && resolvedType.asReferenceType().isUnboxableTo(primitiveType));\n    }\n\n    @Override\n    public ResolvedType visit(EnclosedExpr node, Boolean solveLambdas) {\n        return node.getInner().accept(this, solveLambdas);\n    }\n\n    /**\n     * Java Parser can't differentiate between packages, internal types, and fields.\n     * All three are lumped together into FieldAccessExpr. We need to differentiate them.\n     */\n    private ResolvedType solveDotExpressionType(ResolvedReferenceTypeDeclaration parentType, FieldAccessExpr node) {\n        // Fields and internal type declarations cannot have the same name.\n        // Thus, these checks will always be mutually exclusive.\n        if (parentType.isEnum() && parentType.asEnum().hasEnumConstant(node.getName().getId())) {\n            return parentType.asEnum().getEnumConstant(node.getName().getId()).getType();\n        } else if (parentType.hasField(node.getName().getId())) {\n            return parentType.getField(node.getName().getId()).getType();\n        } else if (parentType.hasInternalType(node.getName().getId())) {\n            return new ReferenceTypeImpl(parentType.getInternalType(node.getName().getId()), typeSolver);\n        } else {\n            throw new UnsolvedSymbolException(node.getName().getId());\n        }\n    }\n\n    @Override\n    public ResolvedType visit(FieldAccessExpr node, Boolean solveLambdas) {\n        // We should understand if this is a static access\n        if (node.getScope() instanceof NameExpr ||\n                node.getScope() instanceof FieldAccessExpr) {\n            Expression staticValue = node.getScope();\n            SymbolReference<ResolvedTypeDeclaration> typeAccessedStatically = JavaParserFactory.getContext(node, typeSolver).solveType(staticValue.toString());\n            if (typeAccessedStatically.isSolved()) {\n                // TODO here maybe we have to substitute type typeParametersValues\n                return solveDotExpressionType(\n                        typeAccessedStatically.getCorrespondingDeclaration().asReferenceType(), node);\n            }\n        } else if (node.getScope() instanceof ThisExpr) {\n            // If we are accessing through a 'this' expression, first resolve the type\n            // corresponding to 'this'\n            SymbolReference<ResolvedTypeDeclaration> solve = facade.solve((ThisExpr) node.getScope());\n            // If found get it's declaration and get the field in there\n            if (solve.isSolved()) {\n                ResolvedTypeDeclaration correspondingDeclaration = solve.getCorrespondingDeclaration();\n                if (correspondingDeclaration instanceof ResolvedReferenceTypeDeclaration) {\n                    return solveDotExpressionType(correspondingDeclaration.asReferenceType(), node);\n                }\n            }\n\n        } else if (node.getScope().toString().indexOf('.') > 0) {\n            // try to find fully qualified name\n            SymbolReference<ResolvedReferenceTypeDeclaration> sr = typeSolver.tryToSolveType(node.getScope().toString());\n            if (sr.isSolved()) {\n                return solveDotExpressionType(sr.getCorrespondingDeclaration(), node);\n            }\n        }\n        Optional<Value> value = Optional.empty();\n        try {\n            value = new SymbolSolver(typeSolver).solveSymbolAsValue(node.getName().getId(), node);\n        } catch (UnsolvedSymbolException use) {\n            // This node may have a package name as part of its fully qualified name.\n            // We should solve for the type declaration inside this package.\n            SymbolReference<ResolvedReferenceTypeDeclaration> sref = typeSolver.tryToSolveType(node.toString());\n            if (sref.isSolved()) {\n                return new ReferenceTypeImpl(sref.getCorrespondingDeclaration(), typeSolver);\n            }\n        }\n        if (value.isPresent()) {\n            return value.get().getType();\n        }\n        throw new UnsolvedSymbolException(node.getName().getId());\n    }\n\n    @Override\n    public ResolvedType visit(InstanceOfExpr node, Boolean solveLambdas) {\n        return ResolvedPrimitiveType.BOOLEAN;\n    }\n\n    @Override\n    public ResolvedType visit(StringLiteralExpr node, Boolean solveLambdas) {\n        return StringReferenceType;\n    }\n\n    @Override\n    public ResolvedType visit(IntegerLiteralExpr node, Boolean solveLambdas) {\n        return ResolvedPrimitiveType.INT;\n    }\n\n    @Override\n    public ResolvedType visit(LongLiteralExpr node, Boolean solveLambdas) {\n        return ResolvedPrimitiveType.LONG;\n    }\n\n    @Override\n    public ResolvedType visit(CharLiteralExpr node, Boolean solveLambdas) {\n        return ResolvedPrimitiveType.CHAR;\n    }\n\n    @Override\n    public ResolvedType visit(DoubleLiteralExpr node, Boolean solveLambdas) {\n        if (node.getValue().toLowerCase().endsWith(\"f\")) {\n            return ResolvedPrimitiveType.FLOAT;\n        }\n        return ResolvedPrimitiveType.DOUBLE;\n    }\n\n    @Override\n    public ResolvedType visit(BooleanLiteralExpr node, Boolean solveLambdas) {\n        return ResolvedPrimitiveType.BOOLEAN;\n    }\n\n    @Override\n    public ResolvedType visit(NullLiteralExpr node, Boolean solveLambdas) {\n        return NullType.INSTANCE;\n    }\n\n    @Override\n    public ResolvedType visit(MethodCallExpr node, Boolean solveLambdas) {\n        Log.trace(\"getType on method call %s\", ()-> node);\n        // first solve the method\n        MethodUsage ref = facade.solveMethodAsUsage(node);\n        Log.trace(\"getType on method call %s resolved to %s\", ()-> node, ()-> ref);\n        Log.trace(\"getType on method call %s return type is %s\", ()-> node, ref::returnType);\n        return ref.returnType();\n        // the type is the return type of the method\n    }\n\n    @Override\n    public ResolvedType visit(NameExpr node, Boolean solveLambdas) {\n        Log.trace(\"getType on name expr %s\", ()-> node);\n        Optional<Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(node.getName().getId(), node);\n        if (!value.isPresent()) {\n            throw new UnsolvedSymbolException(\"Solving \" + node, node.getName().getId());\n        } else {\n            return value.get().getType();\n        }\n    }\n\n    @Override\n    public ResolvedType visit(TypeExpr node, Boolean solveLambdas) {\n        Log.trace(\"getType on type expr %s\", ()-> node);\n        if (!(node.getType() instanceof ClassOrInterfaceType)) {\n            // TODO / FIXME... e.g. System.out::println\n            throw new UnsupportedOperationException(node.getType().getClass().getCanonicalName());\n        }\n        ClassOrInterfaceType classOrInterfaceType = (ClassOrInterfaceType) node.getType();\n        SymbolReference<ResolvedTypeDeclaration> typeDeclarationSymbolReference = JavaParserFactory\n                .getContext(classOrInterfaceType, typeSolver)\n                .solveType(classOrInterfaceType.getName().getId());\n        if (!typeDeclarationSymbolReference.isSolved()) {\n            throw new UnsolvedSymbolException(\"Solving \" + node, classOrInterfaceType.getName().getId());\n        } else {\n            return new ReferenceTypeImpl(typeDeclarationSymbolReference.getCorrespondingDeclaration().asReferenceType(), typeSolver);\n        }\n    }\n\n    @Override\n    public ResolvedType visit(ObjectCreationExpr node, Boolean solveLambdas) {\n        return facade.convertToUsage(node.getType(), node);\n    }\n\n    @Override\n    public ResolvedType visit(ThisExpr node, Boolean solveLambdas) {\n        // If 'this' is prefixed by a class eg. MyClass.this\n        if (node.getTypeName().isPresent()) {\n            // Get the class name\n            String className = node.getTypeName().get().asString();\n            // Attempt to resolve locally in Compilation unit\n            // first try a buttom/up approach\n            try {\n                return new ReferenceTypeImpl(\n                        facade.getTypeDeclaration(facade.findContainingTypeDeclOrObjectCreationExpr(node, className)),\n                        typeSolver);\n            } catch (IllegalStateException e) {\n                // trying another approach from type solver\n                Optional<CompilationUnit> cu = node.findAncestor(CompilationUnit.class);\n                SymbolReference<ResolvedReferenceTypeDeclaration> clazz = typeSolver.tryToSolveType(className);\n                if (clazz.isSolved()) {\n                    return new ReferenceTypeImpl(clazz.getCorrespondingDeclaration(), typeSolver);\n                }\n            }\n        }\n        return new ReferenceTypeImpl(facade.getTypeDeclaration(facade.findContainingTypeDeclOrObjectCreationExpr(node)), typeSolver);\n    }\n\n    @Override\n    public ResolvedType visit(SuperExpr node, Boolean solveLambdas) {\n        // If 'super' is prefixed by a class eg. MyClass.this\n        if (node.getTypeName().isPresent()) {\n            String className = node.getTypeName().get().asString();\n            SymbolReference<ResolvedTypeDeclaration> resolvedTypeNameRef = JavaParserFactory.getContext(node, typeSolver).solveType(className);\n            if (resolvedTypeNameRef.isSolved()) {\n                // Cfr JLS $15.12.1\n                ResolvedTypeDeclaration resolvedTypeName = resolvedTypeNameRef.getCorrespondingDeclaration();\n                if (resolvedTypeName.isInterface()) {\n                    return new ReferenceTypeImpl(resolvedTypeName.asInterface(), typeSolver);\n                } else if (resolvedTypeName.isClass()) {\n                    // TODO: Maybe include a presence check? e.g. in the case of `java.lang.Object` there will be no superclass.\n                    return resolvedTypeName.asClass().getSuperClass().orElseThrow(() -> new RuntimeException(\"super class unexpectedly empty\"));\n                } else {\n                    throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n                }\n            } else {\n                throw new UnsolvedSymbolException(className);\n            }\n        }\n\n        ResolvedTypeDeclaration typeOfNode = facade.getTypeDeclaration(facade.findContainingTypeDeclOrObjectCreationExpr(node));\n        if (typeOfNode instanceof ResolvedClassDeclaration) {\n            // TODO: Maybe include a presence check? e.g. in the case of `java.lang.Object` there will be no superclass.\n            return ((ResolvedClassDeclaration) typeOfNode).getSuperClass().orElseThrow(() -> new RuntimeException(\"super class unexpectedly empty\"));\n        } else {\n            throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n        }\n    }\n\n    @Override\n    public ResolvedType visit(UnaryExpr node, Boolean solveLambdas) {\n        switch (node.getOperator()) {\n            case MINUS:\n            case PLUS:\n                return node.getExpression().accept(this, solveLambdas);\n            case LOGICAL_COMPLEMENT:\n                return ResolvedPrimitiveType.BOOLEAN;\n            case POSTFIX_DECREMENT:\n            case PREFIX_DECREMENT:\n            case POSTFIX_INCREMENT:\n            case PREFIX_INCREMENT:\n            case BITWISE_COMPLEMENT:\n                return node.getExpression().accept(this, solveLambdas);\n            default:\n                throw new UnsupportedOperationException(node.getOperator().name());\n        }\n    }\n\n    @Override\n    public ResolvedType visit(VariableDeclarationExpr node, Boolean solveLambdas) {\n        if (node.getVariables().size() != 1) {\n            throw new UnsupportedOperationException();\n        }\n        return facade.convertToUsageVariableType(node.getVariables().get(0));\n    }\n\n\n    @Override\n    public ResolvedType visit(LambdaExpr node, Boolean solveLambdas) {\n        if (demandParentNode(node) instanceof MethodCallExpr) {\n            MethodCallExpr callExpr = (MethodCallExpr) demandParentNode(node);\n            int pos = JavaParserSymbolDeclaration.getParamPos(node);\n            SymbolReference<ResolvedMethodDeclaration> refMethod = facade.solve(callExpr);\n            if (!refMethod.isSolved()) {\n                throw new UnsolvedSymbolException(demandParentNode(node).toString(), callExpr.getName().getId());\n            }\n            Log.trace(\"getType on lambda expr %s\", ()-> refMethod.getCorrespondingDeclaration().getName());\n            if (solveLambdas) {\n\n                // The type parameter referred here should be the java.util.stream.Stream.T\n                ResolvedType result = refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n\n                if (callExpr.hasScope()) {\n                    Expression scope = callExpr.getScope().get();\n\n                    // If it is a static call we should not try to get the type of the scope\n                    boolean staticCall = false;\n                    if (scope instanceof NameExpr) {\n                        NameExpr nameExpr = (NameExpr) scope;\n                        try {\n                            SymbolReference<ResolvedTypeDeclaration> type = JavaParserFactory.getContext(nameExpr, typeSolver).solveType(nameExpr.getName().getId());\n                            if (type.isSolved()) {\n                                staticCall = true;\n                            }\n                        } catch (Exception e) {\n\n                        }\n                    }\n\n                    if (!staticCall) {\n                        ResolvedType scopeType = facade.getType(scope);\n                        if (scopeType.isReferenceType()) {\n                            result = scopeType.asReferenceType().useThisTypeParametersOnTheGivenType(result);\n                        }\n                    }\n                }\n\n                // We need to replace the type variables\n                Context ctx = JavaParserFactory.getContext(node, typeSolver);\n                result = solveGenericTypes(result, ctx);\n\n                //We should find out which is the functional method (e.g., apply) and replace the params of the\n                //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                //lambdas\n                Optional<MethodUsage> functionalMethod = FunctionalInterfaceLogic.getFunctionalMethod(result);\n                if (functionalMethod.isPresent()) {\n                    LambdaExpr lambdaExpr = node;\n\n                    InferenceContext lambdaCtx = new InferenceContext(MyObjectProvider.INSTANCE);\n                    InferenceContext funcInterfaceCtx = new InferenceContext(MyObjectProvider.INSTANCE);\n\n                    // At this point parameterType\n                    // if Function<T=? super Stream.T, ? extends map.R>\n                    // we should replace Stream.T\n                    ResolvedType functionalInterfaceType = ReferenceTypeImpl.undeterminedParameters(functionalMethod.get().getDeclaration().declaringType(), typeSolver);\n\n                    lambdaCtx.addPair(result, functionalInterfaceType);\n\n                    ResolvedType actualType;\n\n                    if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                        actualType = facade.getType(((ExpressionStmt) lambdaExpr.getBody()).getExpression());\n                    } else if (lambdaExpr.getBody() instanceof BlockStmt) {\n                        BlockStmt blockStmt = (BlockStmt) lambdaExpr.getBody();\n\n                        // Get all the return statements in the lambda block\n                        List<ReturnStmt> returnStmts = blockStmt.findAll(ReturnStmt.class);\n\n                        if (returnStmts.size() > 0) {\n                            actualType = returnStmts.stream()\n                                    .map(returnStmt -> returnStmt.getExpression().map(e -> facade.getType(e)).orElse(ResolvedVoidType.INSTANCE))\n                                    .filter(x -> x != null && !x.isVoid() && !x.isNull())\n                                    .findFirst()\n                                    .orElse(ResolvedVoidType.INSTANCE);\n\n                        } else {\n                            actualType = ResolvedVoidType.INSTANCE;\n                        }\n\n\n                    } else {\n                        throw new UnsupportedOperationException();\n                    }\n\n                    ResolvedType formalType = functionalMethod.get().returnType();\n\n                    // Infer the functional interfaces' return vs actual type\n                    funcInterfaceCtx.addPair(formalType, actualType);\n                    // Substitute to obtain a new type\n                    ResolvedType functionalTypeWithReturn = funcInterfaceCtx.resolve(funcInterfaceCtx.addSingle(functionalInterfaceType));\n\n                    // if the functional method returns void anyway\n                    // we don't need to bother inferring types\n                    if (!(formalType instanceof ResolvedVoidType)) {\n                        lambdaCtx.addPair(result, functionalTypeWithReturn);\n                        result = lambdaCtx.resolve(lambdaCtx.addSingle(result));\n                    }\n                }\n\n                return result;\n            } else {\n                return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n            }\n        } else {\n            throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n        }\n    }\n\n    @Override\n    public ResolvedType visit(MethodReferenceExpr node, Boolean solveLambdas) {\n        if (demandParentNode(node) instanceof MethodCallExpr) {\n            MethodCallExpr callExpr = (MethodCallExpr) demandParentNode(node);\n            int pos = JavaParserSymbolDeclaration.getParamPos(node);\n            SymbolReference<ResolvedMethodDeclaration> refMethod = facade.solve(callExpr, false);\n            if (!refMethod.isSolved()) {\n                throw new UnsolvedSymbolException(demandParentNode(node).toString(), callExpr.getName().getId());\n            }\n            Log.trace(\"getType on method reference expr %s\", ()-> refMethod.getCorrespondingDeclaration().getName());\n            if (solveLambdas) {\n                MethodUsage usage = facade.solveMethodAsUsage(callExpr);\n                ResolvedType result = usage.getParamType(pos);\n                // We need to replace the type variables\n                Context ctx = JavaParserFactory.getContext(node, typeSolver);\n                result = solveGenericTypes(result, ctx);\n\n                //We should find out which is the functional method (e.g., apply) and replace the params of the\n                //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                //lambdas\n                Optional<MethodUsage> functionalMethodOpt = FunctionalInterfaceLogic.getFunctionalMethod(result);\n                if (functionalMethodOpt.isPresent()) {\n                    MethodUsage functionalMethod = functionalMethodOpt.get();\n\n                    for (Pair<ResolvedTypeParameterDeclaration, ResolvedType> typeParamDecl : result.asReferenceType().getTypeParametersMap()) {\n                        functionalMethod = functionalMethod.replaceTypeParameter(typeParamDecl.a, typeParamDecl.b);\n                    }\n\n                    // replace wildcards\n                    for (int i = 0; i < functionalMethod.getNoParams(); i++) {\n                        ResolvedType type = functionalMethod.getParamType(i);\n                        if (type.isWildcard()) {\n                            ResolvedType boundedType = type.asWildcard().getBoundedType();\n                            functionalMethod = functionalMethod.replaceParamType(i, boundedType);\n                        }\n                    }\n\n                    ResolvedType actualType = facade.toMethodUsage(node, functionalMethod.getParamTypes()).returnType();\n                    ResolvedType formalType = functionalMethod.returnType();\n\n                    InferenceContext inferenceContext = new InferenceContext(MyObjectProvider.INSTANCE);\n                    inferenceContext.addPair(formalType, actualType);\n                    result = inferenceContext.resolve(inferenceContext.addSingle(result));\n                }\n\n                return result;\n            }\n            return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n        }\n        throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n    }\n\n    @Override\n    public ResolvedType visit(FieldDeclaration node, Boolean solveLambdas) {\n        if (node.getVariables().size() == 1) {\n            return node.getVariables().get(0).accept(this, solveLambdas);\n        }\n        throw new IllegalArgumentException(\"Cannot resolve the type of a field with multiple variable declarations. Pick one\");\n    }\n}\n",
        "filePathAfter": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/TypeExtractor.java",
        "sourceCodeAfterForWhole": "/*\n * Copyright (C) 2015-2016 Federico Tomassetti\n * Copyright (C) 2017-2020 The JavaParser Team.\n *\n * This file is part of JavaParser.\n *\n * JavaParser can be used either under the terms of\n * a) the GNU Lesser General Public License as published by\n *     the Free Software Foundation, either version 3 of the License, or\n *     (at your option) any later version.\n * b) the terms of the Apache License\n *\n * You should have received a copy of both licenses in LICENCE.LGPL and\n * LICENCE.APACHE. Please refer to those files for details.\n *\n * JavaParser is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n */\n\npackage com.github.javaparser.symbolsolver.javaparsermodel;\n\nimport static com.github.javaparser.symbolsolver.javaparser.Navigator.demandParentNode;\nimport static com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade.solveGenericTypes;\n\nimport java.util.List;\nimport java.util.Optional;\n\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.Node;\nimport com.github.javaparser.ast.body.FieldDeclaration;\nimport com.github.javaparser.ast.body.Parameter;\nimport com.github.javaparser.ast.body.VariableDeclarator;\nimport com.github.javaparser.ast.expr.ArrayAccessExpr;\nimport com.github.javaparser.ast.expr.ArrayCreationExpr;\nimport com.github.javaparser.ast.expr.ArrayInitializerExpr;\nimport com.github.javaparser.ast.expr.AssignExpr;\nimport com.github.javaparser.ast.expr.BinaryExpr;\nimport com.github.javaparser.ast.expr.BooleanLiteralExpr;\nimport com.github.javaparser.ast.expr.CastExpr;\nimport com.github.javaparser.ast.expr.CharLiteralExpr;\nimport com.github.javaparser.ast.expr.ClassExpr;\nimport com.github.javaparser.ast.expr.ConditionalExpr;\nimport com.github.javaparser.ast.expr.DoubleLiteralExpr;\nimport com.github.javaparser.ast.expr.EnclosedExpr;\nimport com.github.javaparser.ast.expr.Expression;\nimport com.github.javaparser.ast.expr.FieldAccessExpr;\nimport com.github.javaparser.ast.expr.InstanceOfExpr;\nimport com.github.javaparser.ast.expr.IntegerLiteralExpr;\nimport com.github.javaparser.ast.expr.LambdaExpr;\nimport com.github.javaparser.ast.expr.LongLiteralExpr;\nimport com.github.javaparser.ast.expr.MethodCallExpr;\nimport com.github.javaparser.ast.expr.MethodReferenceExpr;\nimport com.github.javaparser.ast.expr.NameExpr;\nimport com.github.javaparser.ast.expr.NullLiteralExpr;\nimport com.github.javaparser.ast.expr.ObjectCreationExpr;\nimport com.github.javaparser.ast.expr.StringLiteralExpr;\nimport com.github.javaparser.ast.expr.SuperExpr;\nimport com.github.javaparser.ast.expr.ThisExpr;\nimport com.github.javaparser.ast.expr.TypeExpr;\nimport com.github.javaparser.ast.expr.UnaryExpr;\nimport com.github.javaparser.ast.expr.VariableDeclarationExpr;\nimport com.github.javaparser.ast.stmt.BlockStmt;\nimport com.github.javaparser.ast.stmt.ExpressionStmt;\nimport com.github.javaparser.ast.stmt.ReturnStmt;\nimport com.github.javaparser.ast.type.ClassOrInterfaceType;\nimport com.github.javaparser.ast.type.Type;\nimport com.github.javaparser.ast.type.UnknownType;\nimport com.github.javaparser.resolution.MethodUsage;\nimport com.github.javaparser.resolution.UnsolvedSymbolException;\nimport com.github.javaparser.resolution.declarations.ResolvedClassDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedMethodDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedReferenceTypeDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedTypeDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedTypeParameterDeclaration;\nimport com.github.javaparser.resolution.types.ResolvedArrayType;\nimport com.github.javaparser.resolution.types.ResolvedPrimitiveType;\nimport com.github.javaparser.resolution.types.ResolvedType;\nimport com.github.javaparser.resolution.types.ResolvedVoidType;\nimport com.github.javaparser.symbolsolver.core.resolution.Context;\nimport com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserSymbolDeclaration;\nimport com.github.javaparser.symbolsolver.logic.FunctionalInterfaceLogic;\nimport com.github.javaparser.symbolsolver.logic.InferenceContext;\nimport com.github.javaparser.symbolsolver.model.resolution.SymbolReference;\nimport com.github.javaparser.symbolsolver.model.resolution.TypeSolver;\nimport com.github.javaparser.symbolsolver.model.resolution.Value;\nimport com.github.javaparser.symbolsolver.model.typesystem.NullType;\nimport com.github.javaparser.symbolsolver.model.typesystem.ReferenceTypeImpl;\nimport com.github.javaparser.symbolsolver.reflectionmodel.MyObjectProvider;\nimport com.github.javaparser.symbolsolver.reflectionmodel.ReflectionClassDeclaration;\nimport com.github.javaparser.symbolsolver.resolution.SymbolSolver;\nimport com.github.javaparser.symbolsolver.resolution.typeinference.TypeHelper;\nimport com.github.javaparser.symbolsolver.resolution.typesolvers.ReflectionTypeSolver;\nimport com.github.javaparser.utils.Log;\nimport com.github.javaparser.utils.Pair;\nimport com.google.common.collect.ImmutableList;\n\npublic class TypeExtractor extends DefaultVisitorAdapter {\n\n    private static final String JAVA_LANG_STRING = String.class.getCanonicalName();\n    \n    private TypeSolver typeSolver;\n    private JavaParserFacade facade;\n    \n    private ReferenceTypeImpl StringReferenceType;\n\n    public TypeExtractor(TypeSolver typeSolver, JavaParserFacade facade) {\n        this.typeSolver = typeSolver;\n        this.facade = facade;\n        //pre-calculate the String reference (optimization)\n        StringReferenceType = new ReferenceTypeImpl(new ReflectionTypeSolver().solveType(JAVA_LANG_STRING), typeSolver);\n    }\n\n    @Override\n    public ResolvedType visit(VariableDeclarator node, Boolean solveLambdas) {\n        if (demandParentNode(node) instanceof FieldDeclaration) {\n            return facade.convertToUsageVariableType(node);\n        } else if (demandParentNode(node) instanceof VariableDeclarationExpr) {\n            return facade.convertToUsageVariableType(node);\n        }\n        throw new UnsupportedOperationException(demandParentNode(node).getClass().getCanonicalName());\n    }\n\n    @Override\n    public ResolvedType visit(Parameter node, Boolean solveLambdas) {\n        if (node.getType() instanceof UnknownType) {\n            throw new IllegalStateException(\"Parameter has unknown type: \" + node);\n        }\n        return facade.convertToUsage(node.getType(), node);\n    }\n\n\n    @Override\n    public ResolvedType visit(ArrayAccessExpr node, Boolean solveLambdas) {\n        ResolvedType arrayUsageType = node.getName().accept(this, solveLambdas);\n        if (arrayUsageType.isArray()) {\n            return ((ResolvedArrayType) arrayUsageType).getComponentType();\n        }\n        return arrayUsageType;\n    }\n\n    @Override\n    public ResolvedType visit(ArrayCreationExpr node, Boolean solveLambdas) {\n        ResolvedType res = facade.convertToUsage(node.getElementType(), JavaParserFactory.getContext(node, typeSolver));\n        for (int i = 0; i < node.getLevels().size(); i++) {\n            res = new ResolvedArrayType(res);\n        }\n        return res;\n    }\n\n    @Override\n    public ResolvedType visit(ArrayInitializerExpr node, Boolean solveLambdas) {\n        throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n    }\n\n    @Override\n    public ResolvedType visit(AssignExpr node, Boolean solveLambdas) {\n        return node.getTarget().accept(this, solveLambdas);\n    }\n\n    @Override\n    public ResolvedType visit(BinaryExpr node, Boolean solveLambdas) {\n        switch (node.getOperator()) {\n            case PLUS:\n            case MINUS:\n            case DIVIDE:\n            case MULTIPLY:\n            case REMAINDER:\n            case BINARY_AND:\n            case BINARY_OR:\n            case XOR:\n                return facade.getBinaryTypeConcrete(node.getLeft(), node.getRight(), solveLambdas, node.getOperator());\n            case LESS_EQUALS:\n            case LESS:\n            case GREATER:\n            case GREATER_EQUALS:\n            case EQUALS:\n            case NOT_EQUALS:\n            case OR:\n            case AND:\n                return ResolvedPrimitiveType.BOOLEAN;\n            case SIGNED_RIGHT_SHIFT:\n            case UNSIGNED_RIGHT_SHIFT:\n            case LEFT_SHIFT:\n                ResolvedType rt = node.getLeft().accept(this, solveLambdas);\n                // apply unary primitive promotion\n                return ResolvedPrimitiveType.unp(rt);\n            default:\n                throw new UnsupportedOperationException(\"Operator \" + node.getOperator().name());\n        }\n    }\n\n    @Override\n    public ResolvedType visit(CastExpr node, Boolean solveLambdas) {\n        return facade.convertToUsage(node.getType(), JavaParserFactory.getContext(node, typeSolver));\n    }\n\n    @Override\n    public ResolvedType visit(ClassExpr node, Boolean solveLambdas) {\n        // This implementation does not regard the actual type argument of the ClassExpr.\n        Type astType = node.getType();\n        ResolvedType jssType = facade.convertToUsage(astType, node.getType());\n        return new ReferenceTypeImpl(new ReflectionClassDeclaration(Class.class, typeSolver), ImmutableList.of(jssType), typeSolver);\n    }\n\n    /*\n     * The conditional operator has three operand expressions. ? appears between the first and second expressions, and\n     * : appears between the second and third expressions.\n     * There are three kinds of conditional expressions, classified according to the second and third operand\n     * expressions: boolean conditional expressions, numeric conditional expressions, and reference conditional\n     * expressions.\n     * The classification rules are as follows:\n     * 1/ If both the second and the third operand expressions are boolean expressions, the conditional expression is a\n     * boolean conditional expression.\n     * 2/ If both the second and the third operand expressions are numeric expressions, the conditional expression is a\n     * numeric conditional expression.\n     * 3/ Otherwise, the conditional expression is a reference conditional expression\n     */\n    @Override\n    public ResolvedType visit(ConditionalExpr node, Boolean solveLambdas) {\n        ResolvedType thenExpr = node.getThenExpr().accept(this, solveLambdas);\n        ResolvedType elseExpr = node.getElseExpr().accept(this, solveLambdas);\n        \n        // manage null expression\n        if ( thenExpr.isNull()) {\n            return  elseExpr;\n        }\n        if ( elseExpr.isNull()) {\n            return  thenExpr;\n        }\n        /*\n         * Boolean conditional expressions are standalone expressions\n         * The type of a boolean conditional expression is determined as follows:\n         * If the second and third operands are both of type Boolean, the conditional expression has type Boolean.\n         * Otherwise, the conditional expression has type boolean.\n         */\n        if ( thenExpr.isAssignableBy(ResolvedPrimitiveType.BOOLEAN) \n                && elseExpr.isAssignableBy(ResolvedPrimitiveType.BOOLEAN)) {\n            if (thenExpr.isReferenceType() && elseExpr.isReferenceType()) {\n                return thenExpr.asReferenceType();\n            }\n            return thenExpr.isPrimitive() ? thenExpr : elseExpr;\n        }\n        \n        /*\n         * Numeric conditional expressions are standalone expressions (\u00a715.2).\n         * The type of a numeric conditional expression is determined as follows:\n         * If the second and third operands have the same type, then that is the type of the conditional expression.\n         * If one of the second and third operands is of primitive type T, and the type of the other is the result of\n         * applying boxing conversion (\u00a75.1.7) to T, then the type of the conditional expression is T.\n         * If one of the operands is of type byte or Byte and the other is of type short or Short, then the type of the\n         * conditional expression is short.\n         * If one of the operands is of type T where T is byte, short, or char, and the other operand is a constant\n         * expression (\u00a715.28) of type int whose value is representable in type T, then the type of the conditional\n         * expression is T.\n         * If one of the operands is of type T, where T is Byte, Short, or Character, and the other operand is a\n         * constant expression of type int whose value is representable in the type U which is the result of applying\n         * unboxing conversion to T, then the type of the conditional expression is U.\n         * Otherwise, binary numeric promotion (\u00a75.6.2) is applied to the operand types, and the type of the\n         * conditional expression is the promoted type of the second and third operands.\n         */\n        if (thenExpr.isNumericType() && elseExpr.isNumericType()) {\n            ResolvedPrimitiveType[] resolvedPrimitiveTypeSubList = new ResolvedPrimitiveType[] {ResolvedPrimitiveType.BYTE, ResolvedPrimitiveType.SHORT, ResolvedPrimitiveType.CHAR};\n            /*\n             *  If the second and third operands have the same type, then that is the type of the conditional expression.\n             */\n            String qnameTypeThenExpr = thenExpr.isPrimitive() ? thenExpr.asPrimitive().describe()\n                    : thenExpr.asReferenceType().describe();\n            String qnameTypeElseExpr = elseExpr.isPrimitive() ? elseExpr.asPrimitive().describe()\n                    : elseExpr.asReferenceType().describe();\n            if (qnameTypeThenExpr.equals(qnameTypeElseExpr)) {\n                return thenExpr;\n            }\n            /*\n             * If one of the second and third operands is of primitive type T, and the type of the other is the result of\n             * applying boxing conversion (\u00a75.1.7) to T, then the type of the conditional expression is T.\n             */\n            else if ((thenExpr.isPrimitive() && elseExpr.isReferenceType()\n                    && isCompatible(elseExpr.asReferenceType(), thenExpr.asPrimitive()))) {\n                return thenExpr;\n            } else if ((elseExpr.isPrimitive() && thenExpr.isReferenceType()\n                    && isCompatible(thenExpr.asReferenceType(), elseExpr.asPrimitive()))) {\n                return elseExpr;\n            }\n            /*\n             * If one of the operands is of type byte or Byte and the other is of type short or Short, then the type of the\n             * conditional expression is short.\n             */\n            else if ((isCompatible(thenExpr, ResolvedPrimitiveType.BYTE) && isCompatible(elseExpr, ResolvedPrimitiveType.SHORT))\n                    || (isCompatible(elseExpr, ResolvedPrimitiveType.BYTE) && isCompatible(thenExpr, ResolvedPrimitiveType.SHORT))) {\n                return ResolvedPrimitiveType.SHORT;\n            }\n            /*\n             *  If one of the operands is of type T where T is byte, short, or char, and the\n             *  other operand is a constant expression (\u00a715.28) of type int whose value is\n             *  representable in type T, then the type of the conditional expression is T\n             *  How can we know if the constant expression of type int is representable in type T ?\n             *  \"The constant expression of type int is representable in type T\" is a runtime decision!\n             */\n            else if (thenExpr.isPrimitive() && elseExpr.isPrimitive()) {\n                if (((ResolvedPrimitiveType)thenExpr).in(resolvedPrimitiveTypeSubList)\n                    && ((ResolvedPrimitiveType)elseExpr).equals(ResolvedPrimitiveType.INT)) {\n                    return thenExpr;\n                } else if (((ResolvedPrimitiveType)elseExpr).in(resolvedPrimitiveTypeSubList)\n                    && ((ResolvedPrimitiveType)thenExpr).equals(ResolvedPrimitiveType.INT)) {\n                    return elseExpr;\n                }\n            }\n             /*  If one of the operands is of type T, where T is Byte, Short, or Character,\n             * and the other operand is a constant expression of type int whose value is\n             * representable in the type U which is the result of applying unboxing\n             * conversion to T, then the type of the conditional expression is U.\n             * A priori this is a runtime decision!\n             */\n            else if (thenExpr.isReference() && elseExpr.isPrimitive()\n                    && thenExpr.asReferenceType().isUnboxable()\n                    && thenExpr.asReferenceType().toUnboxedType().get().in(resolvedPrimitiveTypeSubList)\n                    && ((ResolvedPrimitiveType)elseExpr).equals(ResolvedPrimitiveType.INT)) {\n                return thenExpr.asReferenceType().toUnboxedType().get();\n            } else if (elseExpr.isReference() && thenExpr.isPrimitive()\n                    && elseExpr.asReferenceType().isUnboxable()\n                    && elseExpr.asReferenceType().toUnboxedType().get().in(resolvedPrimitiveTypeSubList)\n                    && ((ResolvedPrimitiveType)thenExpr).equals(ResolvedPrimitiveType.INT)) {\n                return elseExpr.asReferenceType().toUnboxedType().get();\n            }\n             \n            /* Otherwise, binary numeric promotion (\u00a75.6.2) is applied to the operand types,\n             * and the type of the conditional expression is the promoted type of the second\n             * and third operands.\n             */\n            ResolvedPrimitiveType PrimitiveThenExpr = thenExpr.isPrimitive() ? thenExpr.asPrimitive()\n                    : thenExpr.asReferenceType().toUnboxedType().get();\n            ResolvedPrimitiveType PrimitiveElseExpr = elseExpr.isPrimitive() ? elseExpr.asPrimitive()\n                    : elseExpr.asReferenceType().toUnboxedType().get();\n            return PrimitiveThenExpr.bnp(PrimitiveElseExpr);\n        }\n        \n        /*\n         * Otherwise, the conditional expression is a reference conditional expression.\n         * A reference conditional expression is a poly expression if it appears in an assignment context or an\n         * invocation context (\u00a75.2. \u00a75.3).\n         * Otherwise, it is a standalone expression.\n         * The type of a poly reference conditional expression is the same as its target type.\n         * The type of a standalone reference conditional expression is determined as follows:\n         * If the second and third operands have the same type (which may be the null type), then that is the type of\n         * the conditional expression.\n         * If the type of one of the second and third operands is the null type, and the type of the other operand is a\n         * reference type, then the type of the conditional expression is that reference type.\n         * Otherwise, the second and third operands are of types S1 and S2 respectively. Let T1 be the type that\n         * results from applying boxing conversion to S1, and let T2 be the type that results from applying boxing\n         * conversion to S2. The type of the conditional expression is the result of applying capture conversion\n         * (\u00a75.1.10) to lub(T1, T2).\n         * TODO : must be implemented\n         */\n        if (node.isPolyExpression()) {\n            // The type of a poly reference conditional expression is the same as its target type.\n            Optional<Node> parentNode = node.getParentNode();\n            if (parentNode.isPresent()) {\n                Node parent = parentNode.get();\n                if (parent instanceof AssignExpr) {\n                    return visit((AssignExpr)parent, solveLambdas);\n                } else if (parent instanceof MethodCallExpr) {\n                    // how to define the target type?\n                    // a priori it is the type of the parameter of the method which takes the value of the conditional expression\n                    // TODO for the moment we keep the original return type\n                    return thenExpr;\n                }\n                throw new RuntimeException(\"Cannot resolve type of poly expression \"+ node.toString());\n            } else {\n                throw new RuntimeException(\"Parent node unexpectedly empty\");\n            }\n            \n        }\n        \n        // The type of a standalone reference conditional expression is determined as follows:\n        \n        // If the second and third operands have the same type (which may be the null type), then that is the type of\n        // the conditional expression.\n        if (thenExpr.equals(elseExpr)) {\n            return thenExpr;\n        }\n        // If the type of one of the second and third operands is the null type, and the type of the other operand is a\n        // reference type, then the type of the conditional expression is that reference type.\n        // this case is already supported above\n        \n        // Otherwise, the second and third operands are of types S1 and S2 respectively. Let T1 be the type that\n        // results from applying boxing conversion to S1, and let T2 be the type that results from applying boxing\n        // conversion to S2. The type of the conditional expression is the result of applying capture conversion\n        // (\u00a75.1.10) to lub(T1, T2).\n        ResolvedType resolvedThenType = thenExpr.isPrimitive() ? TypeHelper.toBoxedType(thenExpr.asPrimitive(), typeSolver) : thenExpr;\n        ResolvedType resolvedElseType = elseExpr.isPrimitive() ? TypeHelper.toBoxedType(elseExpr.asPrimitive(), typeSolver) : elseExpr;\n        \n        // TypeHelper.leastUpperBound method is not yet implemented so for the moment we keep the original return type of this method\n        // TODO implement TypeHelper.leastUpperBound method\n        // return TypeHelper.leastUpperBound(new HashSet<ResolvedType>(Arrays.asList(resolvedThenType, resolvedElseType)));\n        return node.getThenExpr().accept(this, solveLambdas);\n    }\n    \n    private boolean isCompatible(ResolvedType resolvedType, ResolvedPrimitiveType primitiveType) {\n        return (resolvedType.isPrimitive() && resolvedType.asPrimitive().equals(primitiveType))\n        || (resolvedType.isReferenceType() && resolvedType.asReferenceType().isUnboxableTo(primitiveType));\n    }\n\n    @Override\n    public ResolvedType visit(EnclosedExpr node, Boolean solveLambdas) {\n        return node.getInner().accept(this, solveLambdas);\n    }\n\n    /**\n     * Java Parser can't differentiate between packages, internal types, and fields.\n     * All three are lumped together into FieldAccessExpr. We need to differentiate them.\n     */\n    private ResolvedType solveDotExpressionType(ResolvedReferenceTypeDeclaration parentType, FieldAccessExpr node) {\n        // Fields and internal type declarations cannot have the same name.\n        // Thus, these checks will always be mutually exclusive.\n        if (parentType.isEnum() && parentType.asEnum().hasEnumConstant(node.getName().getId())) {\n            return parentType.asEnum().getEnumConstant(node.getName().getId()).getType();\n        } else if (parentType.hasField(node.getName().getId())) {\n            return parentType.getField(node.getName().getId()).getType();\n        } else if (parentType.hasInternalType(node.getName().getId())) {\n            return new ReferenceTypeImpl(parentType.getInternalType(node.getName().getId()), typeSolver);\n        } else {\n            throw new UnsolvedSymbolException(node.getName().getId());\n        }\n    }\n\n    @Override\n    public ResolvedType visit(FieldAccessExpr node, Boolean solveLambdas) {\n        // We should understand if this is a static access\n        if (node.getScope() instanceof NameExpr ||\n                node.getScope() instanceof FieldAccessExpr) {\n            Expression staticValue = node.getScope();\n            SymbolReference<ResolvedTypeDeclaration> typeAccessedStatically = JavaParserFactory.getContext(node, typeSolver).solveType(staticValue.toString());\n            if (typeAccessedStatically.isSolved()) {\n                // TODO here maybe we have to substitute type typeParametersValues\n                return solveDotExpressionType(\n                        typeAccessedStatically.getCorrespondingDeclaration().asReferenceType(), node);\n            }\n        } else if (node.getScope() instanceof ThisExpr) {\n            // If we are accessing through a 'this' expression, first resolve the type\n            // corresponding to 'this'\n            SymbolReference<ResolvedTypeDeclaration> solve = facade.solve((ThisExpr) node.getScope());\n            // If found get it's declaration and get the field in there\n            if (solve.isSolved()) {\n                ResolvedTypeDeclaration correspondingDeclaration = solve.getCorrespondingDeclaration();\n                if (correspondingDeclaration instanceof ResolvedReferenceTypeDeclaration) {\n                    return solveDotExpressionType(correspondingDeclaration.asReferenceType(), node);\n                }\n            }\n\n        } else if (node.getScope().toString().indexOf('.') > 0) {\n            // try to find fully qualified name\n            SymbolReference<ResolvedReferenceTypeDeclaration> sr = typeSolver.tryToSolveType(node.getScope().toString());\n            if (sr.isSolved()) {\n                return solveDotExpressionType(sr.getCorrespondingDeclaration(), node);\n            }\n        }\n        Optional<Value> value = Optional.empty();\n        try {\n            value = new SymbolSolver(typeSolver).solveSymbolAsValue(node.getName().getId(), node);\n        } catch (UnsolvedSymbolException use) {\n            // This node may have a package name as part of its fully qualified name.\n            // We should solve for the type declaration inside this package.\n            SymbolReference<ResolvedReferenceTypeDeclaration> sref = typeSolver.tryToSolveType(node.toString());\n            if (sref.isSolved()) {\n                return new ReferenceTypeImpl(sref.getCorrespondingDeclaration(), typeSolver);\n            }\n        }\n        if (value.isPresent()) {\n            return value.get().getType();\n        }\n        throw new UnsolvedSymbolException(node.getName().getId());\n    }\n\n    @Override\n    public ResolvedType visit(InstanceOfExpr node, Boolean solveLambdas) {\n        return ResolvedPrimitiveType.BOOLEAN;\n    }\n\n    @Override\n    public ResolvedType visit(StringLiteralExpr node, Boolean solveLambdas) {\n        return StringReferenceType;\n    }\n\n    @Override\n    public ResolvedType visit(IntegerLiteralExpr node, Boolean solveLambdas) {\n        return ResolvedPrimitiveType.INT;\n    }\n\n    @Override\n    public ResolvedType visit(LongLiteralExpr node, Boolean solveLambdas) {\n        return ResolvedPrimitiveType.LONG;\n    }\n\n    @Override\n    public ResolvedType visit(CharLiteralExpr node, Boolean solveLambdas) {\n        return ResolvedPrimitiveType.CHAR;\n    }\n\n    @Override\n    public ResolvedType visit(DoubleLiteralExpr node, Boolean solveLambdas) {\n        if (node.getValue().toLowerCase().endsWith(\"f\")) {\n            return ResolvedPrimitiveType.FLOAT;\n        }\n        return ResolvedPrimitiveType.DOUBLE;\n    }\n\n    @Override\n    public ResolvedType visit(BooleanLiteralExpr node, Boolean solveLambdas) {\n        return ResolvedPrimitiveType.BOOLEAN;\n    }\n\n    @Override\n    public ResolvedType visit(NullLiteralExpr node, Boolean solveLambdas) {\n        return NullType.INSTANCE;\n    }\n\n    @Override\n    public ResolvedType visit(MethodCallExpr node, Boolean solveLambdas) {\n        Log.trace(\"getType on method call %s\", ()-> node);\n        // first solve the method\n        MethodUsage ref = facade.solveMethodAsUsage(node);\n        Log.trace(\"getType on method call %s resolved to %s\", ()-> node, ()-> ref);\n        Log.trace(\"getType on method call %s return type is %s\", ()-> node, ref::returnType);\n        return ref.returnType();\n        // the type is the return type of the method\n    }\n\n    @Override\n    public ResolvedType visit(NameExpr node, Boolean solveLambdas) {\n        Log.trace(\"getType on name expr %s\", ()-> node);\n        Optional<Value> value = new SymbolSolver(typeSolver).solveSymbolAsValue(node.getName().getId(), node);\n        if (!value.isPresent()) {\n            throw new UnsolvedSymbolException(\"Solving \" + node, node.getName().getId());\n        } else {\n            return value.get().getType();\n        }\n    }\n\n    @Override\n    public ResolvedType visit(TypeExpr node, Boolean solveLambdas) {\n        Log.trace(\"getType on type expr %s\", ()-> node);\n        if (!(node.getType() instanceof ClassOrInterfaceType)) {\n            // TODO / FIXME... e.g. System.out::println\n            throw new UnsupportedOperationException(node.getType().getClass().getCanonicalName());\n        }\n        ClassOrInterfaceType classOrInterfaceType = (ClassOrInterfaceType) node.getType();\n        SymbolReference<ResolvedTypeDeclaration> typeDeclarationSymbolReference = JavaParserFactory\n                .getContext(classOrInterfaceType, typeSolver)\n                .solveType(classOrInterfaceType.getName().getId());\n        if (!typeDeclarationSymbolReference.isSolved()) {\n            throw new UnsolvedSymbolException(\"Solving \" + node, classOrInterfaceType.getName().getId());\n        } else {\n            return new ReferenceTypeImpl(typeDeclarationSymbolReference.getCorrespondingDeclaration().asReferenceType(), typeSolver);\n        }\n    }\n\n    @Override\n    public ResolvedType visit(ObjectCreationExpr node, Boolean solveLambdas) {\n        return facade.convertToUsage(node.getType(), node);\n    }\n\n    @Override\n    public ResolvedType visit(ThisExpr node, Boolean solveLambdas) {\n        // If 'this' is prefixed by a class eg. MyClass.this\n        if (node.getTypeName().isPresent()) {\n            // Get the class name\n            String className = node.getTypeName().get().asString();\n            // Attempt to resolve locally in Compilation unit\n            // first try a buttom/up approach\n            try {\n                return new ReferenceTypeImpl(\n                        facade.getTypeDeclaration(facade.findContainingTypeDeclOrObjectCreationExpr(node, className)),\n                        typeSolver);\n            } catch (IllegalStateException e) {\n                // trying another approach from type solver\n                Optional<CompilationUnit> cu = node.findAncestor(CompilationUnit.class);\n                SymbolReference<ResolvedReferenceTypeDeclaration> clazz = typeSolver.tryToSolveType(className);\n                if (clazz.isSolved()) {\n                    return new ReferenceTypeImpl(clazz.getCorrespondingDeclaration(), typeSolver);\n                }\n            }\n        }\n        return new ReferenceTypeImpl(facade.getTypeDeclaration(facade.findContainingTypeDeclOrObjectCreationExpr(node)), typeSolver);\n    }\n\n    @Override\n    public ResolvedType visit(SuperExpr node, Boolean solveLambdas) {\n        // If 'super' is prefixed by a class eg. MyClass.this\n        if (node.getTypeName().isPresent()) {\n            String className = node.getTypeName().get().asString();\n            SymbolReference<ResolvedTypeDeclaration> resolvedTypeNameRef = JavaParserFactory.getContext(node, typeSolver).solveType(className);\n            if (resolvedTypeNameRef.isSolved()) {\n                // Cfr JLS $15.12.1\n                ResolvedTypeDeclaration resolvedTypeName = resolvedTypeNameRef.getCorrespondingDeclaration();\n                if (resolvedTypeName.isInterface()) {\n                    return new ReferenceTypeImpl(resolvedTypeName.asInterface(), typeSolver);\n                } else if (resolvedTypeName.isClass()) {\n                    // TODO: Maybe include a presence check? e.g. in the case of `java.lang.Object` there will be no superclass.\n                    return resolvedTypeName.asClass().getSuperClass().orElseThrow(() -> new RuntimeException(\"super class unexpectedly empty\"));\n                } else {\n                    throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n                }\n            } else {\n                throw new UnsolvedSymbolException(className);\n            }\n        }\n\n        ResolvedTypeDeclaration typeOfNode = facade.getTypeDeclaration(facade.findContainingTypeDeclOrObjectCreationExpr(node));\n        if (typeOfNode instanceof ResolvedClassDeclaration) {\n            // TODO: Maybe include a presence check? e.g. in the case of `java.lang.Object` there will be no superclass.\n            return ((ResolvedClassDeclaration) typeOfNode).getSuperClass().orElseThrow(() -> new RuntimeException(\"super class unexpectedly empty\"));\n        } else {\n            throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n        }\n    }\n\n    @Override\n    public ResolvedType visit(UnaryExpr node, Boolean solveLambdas) {\n        switch (node.getOperator()) {\n            case MINUS:\n            case PLUS:\n                return node.getExpression().accept(this, solveLambdas);\n            case LOGICAL_COMPLEMENT:\n                return ResolvedPrimitiveType.BOOLEAN;\n            case POSTFIX_DECREMENT:\n            case PREFIX_DECREMENT:\n            case POSTFIX_INCREMENT:\n            case PREFIX_INCREMENT:\n            case BITWISE_COMPLEMENT:\n                return node.getExpression().accept(this, solveLambdas);\n            default:\n                throw new UnsupportedOperationException(node.getOperator().name());\n        }\n    }\n\n    @Override\n    public ResolvedType visit(VariableDeclarationExpr node, Boolean solveLambdas) {\n        if (node.getVariables().size() != 1) {\n            throw new UnsupportedOperationException();\n        }\n        return facade.convertToUsageVariableType(node.getVariables().get(0));\n    }\n\n\n    @Override\n    public ResolvedType visit(LambdaExpr node, Boolean solveLambdas) {\n        if (demandParentNode(node) instanceof MethodCallExpr) {\n            MethodCallExpr callExpr = (MethodCallExpr) demandParentNode(node);\n            int pos = JavaParserSymbolDeclaration.getParamPos(node);\n            SymbolReference<ResolvedMethodDeclaration> refMethod = facade.solve(callExpr);\n            if (!refMethod.isSolved()) {\n                throw new UnsolvedSymbolException(demandParentNode(node).toString(), callExpr.getName().getId());\n            }\n            Log.trace(\"getType on lambda expr %s\", ()-> refMethod.getCorrespondingDeclaration().getName());\n\n            // The type parameter referred here should be the java.util.stream.Stream.T\n            ResolvedType result = refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n\n            if (solveLambdas) {\n                if (callExpr.hasScope()) {\n                    Expression scope = callExpr.getScope().get();\n\n                    // If it is a static call we should not try to get the type of the scope\n                    boolean staticCall = false;\n                    if (scope instanceof NameExpr) {\n                        NameExpr nameExpr = (NameExpr) scope;\n                        try {\n                            SymbolReference<ResolvedTypeDeclaration> type = JavaParserFactory.getContext(nameExpr, typeSolver).solveType(nameExpr.getName().getId());\n                            if (type.isSolved()) {\n                                staticCall = true;\n                            }\n                        } catch (Exception e) {\n\n                        }\n                    }\n\n                    if (!staticCall) {\n                        ResolvedType scopeType = facade.getType(scope);\n                        if (scopeType.isReferenceType()) {\n                            result = scopeType.asReferenceType().useThisTypeParametersOnTheGivenType(result);\n                        }\n                    }\n                }\n\n                result = resolveLambda(node, result);\n            }\n            return result;\n        } else if (demandParentNode(node) instanceof VariableDeclarator)\n        {\n            VariableDeclarator decExpr = (VariableDeclarator) demandParentNode(node);\n            ResolvedType result = decExpr.getType().resolve();\n\n            if (solveLambdas) {\n                result = resolveLambda(node, result);\n            }\n            return result;\n        } else if (demandParentNode(node) instanceof AssignExpr) {\n            AssignExpr assExpr = (AssignExpr) demandParentNode(node);\n            ResolvedType result = assExpr.calculateResolvedType();\n\n            if (solveLambdas) {\n                result = resolveLambda(node, result);\n            }\n            return result;\n        } else {\n            throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n        }\n    }\n\n    private ResolvedType resolveLambda(LambdaExpr node, ResolvedType result) {\n        // We need to replace the type variables\n        Context ctx = JavaParserFactory.getContext(node, typeSolver);\n        result = solveGenericTypes(result, ctx);\n\n        //We should find out which is the functional method (e.g., apply) and replace the params of the\n        //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n        //lambdas\n        Optional<MethodUsage> functionalMethod = FunctionalInterfaceLogic.getFunctionalMethod(result);\n        if (functionalMethod.isPresent()) {\n            LambdaExpr lambdaExpr = node;\n\n            InferenceContext lambdaCtx = new InferenceContext(MyObjectProvider.INSTANCE);\n            InferenceContext funcInterfaceCtx = new InferenceContext(MyObjectProvider.INSTANCE);\n\n            // At this point parameterType\n            // if Function<T=? super Stream.T, ? extends map.R>\n            // we should replace Stream.T\n            ResolvedType functionalInterfaceType = ReferenceTypeImpl.undeterminedParameters(functionalMethod.get().getDeclaration().declaringType(), typeSolver);\n\n            lambdaCtx.addPair(result, functionalInterfaceType);\n\n            ResolvedType actualType;\n\n            if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                actualType = facade.getType(((ExpressionStmt) lambdaExpr.getBody()).getExpression());\n            } else if (lambdaExpr.getBody() instanceof BlockStmt) {\n                BlockStmt blockStmt = (BlockStmt) lambdaExpr.getBody();\n\n                // Get all the return statements in the lambda block\n                List<ReturnStmt> returnStmts = blockStmt.findAll(ReturnStmt.class);\n\n                if (returnStmts.size() > 0) {\n                    actualType = returnStmts.stream()\n                            .map(returnStmt -> returnStmt.getExpression().map(e -> facade.getType(e)).orElse(ResolvedVoidType.INSTANCE))\n                            .filter(x -> x != null && !x.isVoid() && !x.isNull())\n                            .findFirst()\n                            .orElse(ResolvedVoidType.INSTANCE);\n\n                } else {\n                    actualType = ResolvedVoidType.INSTANCE;\n                }\n\n\n            } else {\n                throw new UnsupportedOperationException();\n            }\n\n            ResolvedType formalType = functionalMethod.get().returnType();\n\n            // Infer the functional interfaces' return vs actual type\n            funcInterfaceCtx.addPair(formalType, actualType);\n            // Substitute to obtain a new type\n            ResolvedType functionalTypeWithReturn = funcInterfaceCtx.resolve(funcInterfaceCtx.addSingle(functionalInterfaceType));\n\n            // if the functional method returns void anyway\n            // we don't need to bother inferring types\n            if (!(formalType instanceof ResolvedVoidType)) {\n                lambdaCtx.addPair(result, functionalTypeWithReturn);\n                result = lambdaCtx.resolve(lambdaCtx.addSingle(result));\n            }\n        }\n        return result;\n    }\n\n    @Override\n    public ResolvedType visit(MethodReferenceExpr node, Boolean solveLambdas) {\n        if (demandParentNode(node) instanceof MethodCallExpr) {\n            MethodCallExpr callExpr = (MethodCallExpr) demandParentNode(node);\n            int pos = JavaParserSymbolDeclaration.getParamPos(node);\n            SymbolReference<ResolvedMethodDeclaration> refMethod = facade.solve(callExpr, false);\n            if (!refMethod.isSolved()) {\n                throw new UnsolvedSymbolException(demandParentNode(node).toString(), callExpr.getName().getId());\n            }\n            Log.trace(\"getType on method reference expr %s\", ()-> refMethod.getCorrespondingDeclaration().getName());\n            if (solveLambdas) {\n                MethodUsage usage = facade.solveMethodAsUsage(callExpr);\n                ResolvedType result = usage.getParamType(pos);\n                // We need to replace the type variables\n                Context ctx = JavaParserFactory.getContext(node, typeSolver);\n                result = solveGenericTypes(result, ctx);\n\n                //We should find out which is the functional method (e.g., apply) and replace the params of the\n                //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                //lambdas\n                Optional<MethodUsage> functionalMethodOpt = FunctionalInterfaceLogic.getFunctionalMethod(result);\n                if (functionalMethodOpt.isPresent()) {\n                    MethodUsage functionalMethod = functionalMethodOpt.get();\n\n                    for (Pair<ResolvedTypeParameterDeclaration, ResolvedType> typeParamDecl : result.asReferenceType().getTypeParametersMap()) {\n                        functionalMethod = functionalMethod.replaceTypeParameter(typeParamDecl.a, typeParamDecl.b);\n                    }\n\n                    // replace wildcards\n                    for (int i = 0; i < functionalMethod.getNoParams(); i++) {\n                        ResolvedType type = functionalMethod.getParamType(i);\n                        if (type.isWildcard()) {\n                            ResolvedType boundedType = type.asWildcard().getBoundedType();\n                            functionalMethod = functionalMethod.replaceParamType(i, boundedType);\n                        }\n                    }\n\n                    ResolvedType actualType = facade.toMethodUsage(node, functionalMethod.getParamTypes()).returnType();\n                    ResolvedType formalType = functionalMethod.returnType();\n\n                    InferenceContext inferenceContext = new InferenceContext(MyObjectProvider.INSTANCE);\n                    inferenceContext.addPair(formalType, actualType);\n                    result = inferenceContext.resolve(inferenceContext.addSingle(result));\n                }\n\n                return result;\n            }\n            return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n        }\n        throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n    }\n\n    @Override\n    public ResolvedType visit(FieldDeclaration node, Boolean solveLambdas) {\n        if (node.getVariables().size() == 1) {\n            return node.getVariables().get(0).accept(this, solveLambdas);\n        }\n        throw new IllegalArgumentException(\"Cannot resolve the type of a field with multiple variable declarations. Pick one\");\n    }\n}\n",
        "diffSourceCodeSet": [
            "private ResolvedType resolveLambda(LambdaExpr node, ResolvedType result) {\n        // We need to replace the type variables\n        Context ctx = JavaParserFactory.getContext(node, typeSolver);\n        result = solveGenericTypes(result, ctx);\n\n        //We should find out which is the functional method (e.g., apply) and replace the params of the\n        //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n        //lambdas\n        Optional<MethodUsage> functionalMethod = FunctionalInterfaceLogic.getFunctionalMethod(result);\n        if (functionalMethod.isPresent()) {\n            LambdaExpr lambdaExpr = node;\n\n            InferenceContext lambdaCtx = new InferenceContext(MyObjectProvider.INSTANCE);\n            InferenceContext funcInterfaceCtx = new InferenceContext(MyObjectProvider.INSTANCE);\n\n            // At this point parameterType\n            // if Function<T=? super Stream.T, ? extends map.R>\n            // we should replace Stream.T\n            ResolvedType functionalInterfaceType = ReferenceTypeImpl.undeterminedParameters(functionalMethod.get().getDeclaration().declaringType(), typeSolver);\n\n            lambdaCtx.addPair(result, functionalInterfaceType);\n\n            ResolvedType actualType;\n\n            if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                actualType = facade.getType(((ExpressionStmt) lambdaExpr.getBody()).getExpression());\n            } else if (lambdaExpr.getBody() instanceof BlockStmt) {\n                BlockStmt blockStmt = (BlockStmt) lambdaExpr.getBody();\n\n                // Get all the return statements in the lambda block\n                List<ReturnStmt> returnStmts = blockStmt.findAll(ReturnStmt.class);\n\n                if (returnStmts.size() > 0) {\n                    actualType = returnStmts.stream()\n                            .map(returnStmt -> returnStmt.getExpression().map(e -> facade.getType(e)).orElse(ResolvedVoidType.INSTANCE))\n                            .filter(x -> x != null && !x.isVoid() && !x.isNull())\n                            .findFirst()\n                            .orElse(ResolvedVoidType.INSTANCE);\n\n                } else {\n                    actualType = ResolvedVoidType.INSTANCE;\n                }\n\n\n            } else {\n                throw new UnsupportedOperationException();\n            }\n\n            ResolvedType formalType = functionalMethod.get().returnType();\n\n            // Infer the functional interfaces' return vs actual type\n            funcInterfaceCtx.addPair(formalType, actualType);\n            // Substitute to obtain a new type\n            ResolvedType functionalTypeWithReturn = funcInterfaceCtx.resolve(funcInterfaceCtx.addSingle(functionalInterfaceType));\n\n            // if the functional method returns void anyway\n            // we don't need to bother inferring types\n            if (!(formalType instanceof ResolvedVoidType)) {\n                lambdaCtx.addPair(result, functionalTypeWithReturn);\n                result = lambdaCtx.resolve(lambdaCtx.addSingle(result));\n            }\n        }\n        return result;\n    }"
        ],
        "invokedMethodSet": [],
        "sourceCodeAfterRefactoring": "@Override\n    public ResolvedType visit(LambdaExpr node, Boolean solveLambdas) {\n        if (demandParentNode(node) instanceof MethodCallExpr) {\n            MethodCallExpr callExpr = (MethodCallExpr) demandParentNode(node);\n            int pos = JavaParserSymbolDeclaration.getParamPos(node);\n            SymbolReference<ResolvedMethodDeclaration> refMethod = facade.solve(callExpr);\n            if (!refMethod.isSolved()) {\n                throw new UnsolvedSymbolException(demandParentNode(node).toString(), callExpr.getName().getId());\n            }\n            Log.trace(\"getType on lambda expr %s\", ()-> refMethod.getCorrespondingDeclaration().getName());\n\n            // The type parameter referred here should be the java.util.stream.Stream.T\n            ResolvedType result = refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n\n            if (solveLambdas) {\n                if (callExpr.hasScope()) {\n                    Expression scope = callExpr.getScope().get();\n\n                    // If it is a static call we should not try to get the type of the scope\n                    boolean staticCall = false;\n                    if (scope instanceof NameExpr) {\n                        NameExpr nameExpr = (NameExpr) scope;\n                        try {\n                            SymbolReference<ResolvedTypeDeclaration> type = JavaParserFactory.getContext(nameExpr, typeSolver).solveType(nameExpr.getName().getId());\n                            if (type.isSolved()) {\n                                staticCall = true;\n                            }\n                        } catch (Exception e) {\n\n                        }\n                    }\n\n                    if (!staticCall) {\n                        ResolvedType scopeType = facade.getType(scope);\n                        if (scopeType.isReferenceType()) {\n                            result = scopeType.asReferenceType().useThisTypeParametersOnTheGivenType(result);\n                        }\n                    }\n                }\n\n                result = resolveLambda(node, result);\n            }\n            return result;\n        } else if (demandParentNode(node) instanceof VariableDeclarator)\n        {\n            VariableDeclarator decExpr = (VariableDeclarator) demandParentNode(node);\n            ResolvedType result = decExpr.getType().resolve();\n\n            if (solveLambdas) {\n                result = resolveLambda(node, result);\n            }\n            return result;\n        } else if (demandParentNode(node) instanceof AssignExpr) {\n            AssignExpr assExpr = (AssignExpr) demandParentNode(node);\n            ResolvedType result = assExpr.calculateResolvedType();\n\n            if (solveLambdas) {\n                result = resolveLambda(node, result);\n            }\n            return result;\n        } else {\n            throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n        }\n    }\nprivate ResolvedType resolveLambda(LambdaExpr node, ResolvedType result) {\n        // We need to replace the type variables\n        Context ctx = JavaParserFactory.getContext(node, typeSolver);\n        result = solveGenericTypes(result, ctx);\n\n        //We should find out which is the functional method (e.g., apply) and replace the params of the\n        //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n        //lambdas\n        Optional<MethodUsage> functionalMethod = FunctionalInterfaceLogic.getFunctionalMethod(result);\n        if (functionalMethod.isPresent()) {\n            LambdaExpr lambdaExpr = node;\n\n            InferenceContext lambdaCtx = new InferenceContext(MyObjectProvider.INSTANCE);\n            InferenceContext funcInterfaceCtx = new InferenceContext(MyObjectProvider.INSTANCE);\n\n            // At this point parameterType\n            // if Function<T=? super Stream.T, ? extends map.R>\n            // we should replace Stream.T\n            ResolvedType functionalInterfaceType = ReferenceTypeImpl.undeterminedParameters(functionalMethod.get().getDeclaration().declaringType(), typeSolver);\n\n            lambdaCtx.addPair(result, functionalInterfaceType);\n\n            ResolvedType actualType;\n\n            if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                actualType = facade.getType(((ExpressionStmt) lambdaExpr.getBody()).getExpression());\n            } else if (lambdaExpr.getBody() instanceof BlockStmt) {\n                BlockStmt blockStmt = (BlockStmt) lambdaExpr.getBody();\n\n                // Get all the return statements in the lambda block\n                List<ReturnStmt> returnStmts = blockStmt.findAll(ReturnStmt.class);\n\n                if (returnStmts.size() > 0) {\n                    actualType = returnStmts.stream()\n                            .map(returnStmt -> returnStmt.getExpression().map(e -> facade.getType(e)).orElse(ResolvedVoidType.INSTANCE))\n                            .filter(x -> x != null && !x.isVoid() && !x.isNull())\n                            .findFirst()\n                            .orElse(ResolvedVoidType.INSTANCE);\n\n                } else {\n                    actualType = ResolvedVoidType.INSTANCE;\n                }\n\n\n            } else {\n                throw new UnsupportedOperationException();\n            }\n\n            ResolvedType formalType = functionalMethod.get().returnType();\n\n            // Infer the functional interfaces' return vs actual type\n            funcInterfaceCtx.addPair(formalType, actualType);\n            // Substitute to obtain a new type\n            ResolvedType functionalTypeWithReturn = funcInterfaceCtx.resolve(funcInterfaceCtx.addSingle(functionalInterfaceType));\n\n            // if the functional method returns void anyway\n            // we don't need to bother inferring types\n            if (!(formalType instanceof ResolvedVoidType)) {\n                lambdaCtx.addPair(result, functionalTypeWithReturn);\n                result = lambdaCtx.resolve(lambdaCtx.addSingle(result));\n            }\n        }\n        return result;\n    }",
        "diffSourceCode": "   647:     @Override\n   648:     public ResolvedType visit(LambdaExpr node, Boolean solveLambdas) {\n   649:         if (demandParentNode(node) instanceof MethodCallExpr) {\n   650:             MethodCallExpr callExpr = (MethodCallExpr) demandParentNode(node);\n   651:             int pos = JavaParserSymbolDeclaration.getParamPos(node);\n   652:             SymbolReference<ResolvedMethodDeclaration> refMethod = facade.solve(callExpr);\n   653:             if (!refMethod.isSolved()) {\n   654:                 throw new UnsolvedSymbolException(demandParentNode(node).toString(), callExpr.getName().getId());\n   655:             }\n   656:             Log.trace(\"getType on lambda expr %s\", ()-> refMethod.getCorrespondingDeclaration().getName());\n-  657:             if (solveLambdas) {\n-  658: \n-  659:                 // The type parameter referred here should be the java.util.stream.Stream.T\n-  660:                 ResolvedType result = refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n-  661: \n+  657: \n+  658:             // The type parameter referred here should be the java.util.stream.Stream.T\n+  659:             ResolvedType result = refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n+  660: \n+  661:             if (solveLambdas) {\n   662:                 if (callExpr.hasScope()) {\n   663:                     Expression scope = callExpr.getScope().get();\n   664: \n   665:                     // If it is a static call we should not try to get the type of the scope\n   666:                     boolean staticCall = false;\n   667:                     if (scope instanceof NameExpr) {\n   668:                         NameExpr nameExpr = (NameExpr) scope;\n   669:                         try {\n   670:                             SymbolReference<ResolvedTypeDeclaration> type = JavaParserFactory.getContext(nameExpr, typeSolver).solveType(nameExpr.getName().getId());\n   671:                             if (type.isSolved()) {\n   672:                                 staticCall = true;\n   673:                             }\n   674:                         } catch (Exception e) {\n   675: \n   676:                         }\n   677:                     }\n   678: \n   679:                     if (!staticCall) {\n   680:                         ResolvedType scopeType = facade.getType(scope);\n   681:                         if (scopeType.isReferenceType()) {\n   682:                             result = scopeType.asReferenceType().useThisTypeParametersOnTheGivenType(result);\n   683:                         }\n   684:                     }\n   685:                 }\n   686: \n-  687:                 // We need to replace the type variables\n-  688:                 Context ctx = JavaParserFactory.getContext(node, typeSolver);\n-  689:                 result = solveGenericTypes(result, ctx);\n-  690: \n-  691:                 //We should find out which is the functional method (e.g., apply) and replace the params of the\n-  692:                 //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n-  693:                 //lambdas\n-  694:                 Optional<MethodUsage> functionalMethod = FunctionalInterfaceLogic.getFunctionalMethod(result);\n-  695:                 if (functionalMethod.isPresent()) {\n-  696:                     LambdaExpr lambdaExpr = node;\n-  697: \n-  698:                     InferenceContext lambdaCtx = new InferenceContext(MyObjectProvider.INSTANCE);\n-  699:                     InferenceContext funcInterfaceCtx = new InferenceContext(MyObjectProvider.INSTANCE);\n-  700: \n-  701:                     // At this point parameterType\n-  702:                     // if Function<T=? super Stream.T, ? extends map.R>\n-  703:                     // we should replace Stream.T\n-  704:                     ResolvedType functionalInterfaceType = ReferenceTypeImpl.undeterminedParameters(functionalMethod.get().getDeclaration().declaringType(), typeSolver);\n-  705: \n-  706:                     lambdaCtx.addPair(result, functionalInterfaceType);\n-  707: \n-  708:                     ResolvedType actualType;\n-  709: \n-  710:                     if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n-  711:                         actualType = facade.getType(((ExpressionStmt) lambdaExpr.getBody()).getExpression());\n-  712:                     } else if (lambdaExpr.getBody() instanceof BlockStmt) {\n-  713:                         BlockStmt blockStmt = (BlockStmt) lambdaExpr.getBody();\n-  714: \n-  715:                         // Get all the return statements in the lambda block\n-  716:                         List<ReturnStmt> returnStmts = blockStmt.findAll(ReturnStmt.class);\n-  717: \n-  718:                         if (returnStmts.size() > 0) {\n-  719:                             actualType = returnStmts.stream()\n-  720:                                     .map(returnStmt -> returnStmt.getExpression().map(e -> facade.getType(e)).orElse(ResolvedVoidType.INSTANCE))\n-  721:                                     .filter(x -> x != null && !x.isVoid() && !x.isNull())\n-  722:                                     .findFirst()\n-  723:                                     .orElse(ResolvedVoidType.INSTANCE);\n-  724: \n-  725:                         } else {\n-  726:                             actualType = ResolvedVoidType.INSTANCE;\n-  727:                         }\n-  728: \n-  729: \n-  730:                     } else {\n-  731:                         throw new UnsupportedOperationException();\n-  732:                     }\n+  687:                 result = resolveLambda(node, result);\n+  688:             }\n+  689:             return result;\n+  690:         } else if (demandParentNode(node) instanceof VariableDeclarator)\n+  691:         {\n+  692:             VariableDeclarator decExpr = (VariableDeclarator) demandParentNode(node);\n+  693:             ResolvedType result = decExpr.getType().resolve();\n+  694: \n+  695:             if (solveLambdas) {\n+  696:                 result = resolveLambda(node, result);\n+  697:             }\n+  698:             return result;\n+  699:         } else if (demandParentNode(node) instanceof AssignExpr) {\n+  700:             AssignExpr assExpr = (AssignExpr) demandParentNode(node);\n+  701:             ResolvedType result = assExpr.calculateResolvedType();\n+  702: \n+  703:             if (solveLambdas) {\n+  704:                 result = resolveLambda(node, result);\n+  705:             }\n+  706:             return result;\n+  707:         } else {\n+  708:             throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n+  709:         }\n+  710:     }\n+  711: \n+  712:     private ResolvedType resolveLambda(LambdaExpr node, ResolvedType result) {\n+  713:         // We need to replace the type variables\n+  714:         Context ctx = JavaParserFactory.getContext(node, typeSolver);\n+  715:         result = solveGenericTypes(result, ctx);\n+  716: \n+  717:         //We should find out which is the functional method (e.g., apply) and replace the params of the\n+  718:         //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n+  719:         //lambdas\n+  720:         Optional<MethodUsage> functionalMethod = FunctionalInterfaceLogic.getFunctionalMethod(result);\n+  721:         if (functionalMethod.isPresent()) {\n+  722:             LambdaExpr lambdaExpr = node;\n+  723: \n+  724:             InferenceContext lambdaCtx = new InferenceContext(MyObjectProvider.INSTANCE);\n+  725:             InferenceContext funcInterfaceCtx = new InferenceContext(MyObjectProvider.INSTANCE);\n+  726: \n+  727:             // At this point parameterType\n+  728:             // if Function<T=? super Stream.T, ? extends map.R>\n+  729:             // we should replace Stream.T\n+  730:             ResolvedType functionalInterfaceType = ReferenceTypeImpl.undeterminedParameters(functionalMethod.get().getDeclaration().declaringType(), typeSolver);\n+  731: \n+  732:             lambdaCtx.addPair(result, functionalInterfaceType);\n   733: \n-  734:                     ResolvedType formalType = functionalMethod.get().returnType();\n+  734:             ResolvedType actualType;\n   735: \n-  736:                     // Infer the functional interfaces' return vs actual type\n-  737:                     funcInterfaceCtx.addPair(formalType, actualType);\n-  738:                     // Substitute to obtain a new type\n-  739:                     ResolvedType functionalTypeWithReturn = funcInterfaceCtx.resolve(funcInterfaceCtx.addSingle(functionalInterfaceType));\n+  736:             if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n+  737:                 actualType = facade.getType(((ExpressionStmt) lambdaExpr.getBody()).getExpression());\n+  738:             } else if (lambdaExpr.getBody() instanceof BlockStmt) {\n+  739:                 BlockStmt blockStmt = (BlockStmt) lambdaExpr.getBody();\n   740: \n-  741:                     // if the functional method returns void anyway\n-  742:                     // we don't need to bother inferring types\n-  743:                     if (!(formalType instanceof ResolvedVoidType)) {\n-  744:                         lambdaCtx.addPair(result, functionalTypeWithReturn);\n-  745:                         result = lambdaCtx.resolve(lambdaCtx.addSingle(result));\n-  746:                     }\n-  747:                 }\n-  748: \n-  749:                 return result;\n-  750:             } else {\n-  751:                 return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n-  752:             }\n-  753:         } else {\n-  754:             throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n-  755:         }\n-  756:     }\n-  757: \n-  758:     @Override\n-  759:     public ResolvedType visit(MethodReferenceExpr node, Boolean solveLambdas) {\n-  760:         if (demandParentNode(node) instanceof MethodCallExpr) {\n-  761:             MethodCallExpr callExpr = (MethodCallExpr) demandParentNode(node);\n-  762:             int pos = JavaParserSymbolDeclaration.getParamPos(node);\n-  763:             SymbolReference<ResolvedMethodDeclaration> refMethod = facade.solve(callExpr, false);\n-  764:             if (!refMethod.isSolved()) {\n-  765:                 throw new UnsolvedSymbolException(demandParentNode(node).toString(), callExpr.getName().getId());\n-  766:             }\n-  767:             Log.trace(\"getType on method reference expr %s\", ()-> refMethod.getCorrespondingDeclaration().getName());\n-  768:             if (solveLambdas) {\n-  769:                 MethodUsage usage = facade.solveMethodAsUsage(callExpr);\n-  770:                 ResolvedType result = usage.getParamType(pos);\n-  771:                 // We need to replace the type variables\n-  772:                 Context ctx = JavaParserFactory.getContext(node, typeSolver);\n-  773:                 result = solveGenericTypes(result, ctx);\n-  774: \n-  775:                 //We should find out which is the functional method (e.g., apply) and replace the params of the\n+  741:                 // Get all the return statements in the lambda block\n+  742:                 List<ReturnStmt> returnStmts = blockStmt.findAll(ReturnStmt.class);\n+  743: \n+  744:                 if (returnStmts.size() > 0) {\n+  745:                     actualType = returnStmts.stream()\n+  746:                             .map(returnStmt -> returnStmt.getExpression().map(e -> facade.getType(e)).orElse(ResolvedVoidType.INSTANCE))\n+  747:                             .filter(x -> x != null && !x.isVoid() && !x.isNull())\n+  748:                             .findFirst()\n+  749:                             .orElse(ResolvedVoidType.INSTANCE);\n+  750: \n+  751:                 } else {\n+  752:                     actualType = ResolvedVoidType.INSTANCE;\n+  753:                 }\n+  754: \n+  755: \n+  756:             } else {\n+  757:                 throw new UnsupportedOperationException();\n+  758:             }\n+  759: \n+  760:             ResolvedType formalType = functionalMethod.get().returnType();\n+  761: \n+  762:             // Infer the functional interfaces' return vs actual type\n+  763:             funcInterfaceCtx.addPair(formalType, actualType);\n+  764:             // Substitute to obtain a new type\n+  765:             ResolvedType functionalTypeWithReturn = funcInterfaceCtx.resolve(funcInterfaceCtx.addSingle(functionalInterfaceType));\n+  766: \n+  767:             // if the functional method returns void anyway\n+  768:             // we don't need to bother inferring types\n+  769:             if (!(formalType instanceof ResolvedVoidType)) {\n+  770:                 lambdaCtx.addPair(result, functionalTypeWithReturn);\n+  771:                 result = lambdaCtx.resolve(lambdaCtx.addSingle(result));\n+  772:             }\n+  773:         }\n+  774:         return result;\n+  775:     }\n",
        "uniqueId": "a9adfa6c86ba236edeaa2be318c337f98e5c6720_647_756_712_775_647_710",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 5,
                "covered": 15
            },
            "BRANCH": {
                "missed": 1,
                "covered": 1
            },
            "LINE": {
                "missed": 1,
                "covered": 2
            },
            "COMPLEXITY": {
                "missed": 1,
                "covered": 1
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 17
    },
    {
        "type": "Extract And Move Method",
        "description": "Extract And Move Method\tpublic internalTypes() : Set<ResolvedReferenceTypeDeclaration> extracted from public internalTypes() : Set<ResolvedReferenceTypeDeclaration> in class com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserInterfaceDeclaration & moved to class com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserTypeAdapter",
        "diffLocations": [
            {
                "filePath": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/declarations/JavaParserInterfaceDeclaration.java",
                "startLine": 359,
                "endLine": 371,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/declarations/JavaParserInterfaceDeclaration.java",
                "startLine": 357,
                "endLine": 360,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/declarations/JavaParserInterfaceDeclaration.java",
                "startLine": 187,
                "endLine": 198,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "@Override\n    public Set<ResolvedReferenceTypeDeclaration> internalTypes() {\n        // Use a special Set implementation that avoids calculating the hashCode of the node,\n        // since this can be very time-consuming for big node trees, and we are sure there are\n        // no duplicates in the members list.\n        Set<ResolvedReferenceTypeDeclaration> res = Collections.newSetFromMap(new IdentityHashMap<>());\n        for (BodyDeclaration<?> member : this.wrappedNode.getMembers()) {\n            if (member instanceof TypeDeclaration) {\n                res.add(JavaParserFacade.get(typeSolver).getTypeDeclaration((TypeDeclaration) member));\n            }\n        }\n        return res;\n    }",
        "filePathBefore": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/declarations/JavaParserInterfaceDeclaration.java",
        "isPureRefactoring": true,
        "commitId": "c378a677ebcd999d853b3e5867ac7ca7cd8e73cb",
        "packageNameBefore": "com.github.javaparser.symbolsolver.javaparsermodel.declarations",
        "classNameBefore": "com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserInterfaceDeclaration",
        "methodNameBefore": "com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserInterfaceDeclaration#internalTypes",
        "classSignatureBefore": "public class JavaParserInterfaceDeclaration extends AbstractTypeDeclaration\n        implements ResolvedInterfaceDeclaration, MethodResolutionCapability, MethodUsageResolutionCapability ",
        "methodNameBeforeSet": [
            "com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserInterfaceDeclaration#internalTypes"
        ],
        "classNameBeforeSet": [
            "com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserInterfaceDeclaration"
        ],
        "classSignatureBeforeSet": [
            "public class JavaParserInterfaceDeclaration extends AbstractTypeDeclaration\n        implements ResolvedInterfaceDeclaration, MethodResolutionCapability, MethodUsageResolutionCapability "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Copyright (C) 2015-2016 Federico Tomassetti\n * Copyright (C) 2017-2020 The JavaParser Team.\n *\n * This file is part of JavaParser.\n *\n * JavaParser can be used either under the terms of\n * a) the GNU Lesser General Public License as published by\n *     the Free Software Foundation, either version 3 of the License, or\n *     (at your option) any later version.\n * b) the terms of the Apache License\n *\n * You should have received a copy of both licenses in LICENCE.LGPL and\n * LICENCE.APACHE. Please refer to those files for details.\n *\n * JavaParser is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n */\n\npackage com.github.javaparser.symbolsolver.javaparsermodel.declarations;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.IdentityHashMap;\nimport java.util.List;\nimport java.util.Optional;\nimport java.util.Set;\nimport java.util.stream.Collectors;\n\nimport com.github.javaparser.ast.AccessSpecifier;\nimport com.github.javaparser.ast.Node;\nimport com.github.javaparser.ast.body.BodyDeclaration;\nimport com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;\nimport com.github.javaparser.ast.body.FieldDeclaration;\nimport com.github.javaparser.ast.body.TypeDeclaration;\nimport com.github.javaparser.ast.type.ClassOrInterfaceType;\nimport com.github.javaparser.resolution.MethodUsage;\nimport com.github.javaparser.resolution.UnsolvedSymbolException;\nimport com.github.javaparser.resolution.declarations.ResolvedConstructorDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedFieldDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedInterfaceDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedMethodDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedReferenceTypeDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedTypeDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedTypeParameterDeclaration;\nimport com.github.javaparser.resolution.types.ResolvedReferenceType;\nimport com.github.javaparser.resolution.types.ResolvedType;\nimport com.github.javaparser.symbolsolver.core.resolution.Context;\nimport com.github.javaparser.symbolsolver.core.resolution.MethodUsageResolutionCapability;\nimport com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade;\nimport com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFactory;\nimport com.github.javaparser.symbolsolver.logic.AbstractTypeDeclaration;\nimport com.github.javaparser.symbolsolver.logic.MethodResolutionCapability;\nimport com.github.javaparser.symbolsolver.model.resolution.SymbolReference;\nimport com.github.javaparser.symbolsolver.model.resolution.TypeSolver;\nimport com.github.javaparser.symbolsolver.model.typesystem.LazyType;\nimport com.github.javaparser.symbolsolver.model.typesystem.ReferenceTypeImpl;\nimport com.github.javaparser.symbolsolver.resolution.SymbolSolver;\n\n/**\n * @author Federico Tomassetti\n */\npublic class JavaParserInterfaceDeclaration extends AbstractTypeDeclaration\n        implements ResolvedInterfaceDeclaration, MethodResolutionCapability, MethodUsageResolutionCapability {\n\n    private TypeSolver typeSolver;\n    private ClassOrInterfaceDeclaration wrappedNode;\n    private JavaParserTypeAdapter<ClassOrInterfaceDeclaration> javaParserTypeAdapter;\n\n    public JavaParserInterfaceDeclaration(ClassOrInterfaceDeclaration wrappedNode, TypeSolver typeSolver) {\n        if (!wrappedNode.isInterface()) {\n            throw new IllegalArgumentException();\n        }\n        this.wrappedNode = wrappedNode;\n        this.typeSolver = typeSolver;\n        this.javaParserTypeAdapter = new JavaParserTypeAdapter<>(wrappedNode, typeSolver);\n    }\n\n    @Override\n    public Set<ResolvedMethodDeclaration> getDeclaredMethods() {\n        Set<ResolvedMethodDeclaration> methods = new HashSet<>();\n        for (BodyDeclaration<?> member : wrappedNode.getMembers()) {\n            if (member instanceof com.github.javaparser.ast.body.MethodDeclaration) {\n                methods.add(new JavaParserMethodDeclaration((com.github.javaparser.ast.body.MethodDeclaration) member, typeSolver));\n            }\n        }\n        return methods;\n    }\n\n    public Context getContext() {\n        return JavaParserFactory.getContext(wrappedNode, typeSolver);\n    }\n\n    public ResolvedType getUsage(Node node) {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n\n        JavaParserInterfaceDeclaration that = (JavaParserInterfaceDeclaration) o;\n\n        if (!wrappedNode.equals(that.wrappedNode)) return false;\n\n        return true;\n    }\n\n    @Override\n    public int hashCode() {\n        return wrappedNode.hashCode();\n    }\n\n    @Override\n    public String getName() {\n        return wrappedNode.getName().getId();\n    }\n\n    @Override\n    public ResolvedInterfaceDeclaration asInterface() {\n        return this;\n    }\n\n    @Override\n    public boolean hasDirectlyAnnotation(String canonicalName) {\n        return AstResolutionUtils.hasDirectlyAnnotation(wrappedNode, typeSolver, canonicalName);\n    }\n\n    @Override\n    public boolean isInterface() {\n        return true;\n    }\n\n    @Override\n    public List<ResolvedReferenceType> getInterfacesExtended() {\n        List<ResolvedReferenceType> interfaces = new ArrayList<>();\n        for (ClassOrInterfaceType t : wrappedNode.getExtendedTypes()) {\n            interfaces.add(new ReferenceTypeImpl(\n                    solveType(t.getName().getId()).getCorrespondingDeclaration().asInterface(), typeSolver));\n        }\n        return interfaces;\n    }\n\n    @Override\n    public String getPackageName() {\n        return javaParserTypeAdapter.getPackageName();\n    }\n\n    @Override\n    public String getClassName() {\n        return javaParserTypeAdapter.getClassName();\n    }\n\n    @Override\n    public String getQualifiedName() {\n        return javaParserTypeAdapter.getQualifiedName();\n    }\n\n    @Override\n    public boolean isAssignableBy(ResolvedReferenceTypeDeclaration other) {\n        return javaParserTypeAdapter.isAssignableBy(other);\n    }\n\n    @Override\n    public boolean isAssignableBy(ResolvedType type) {\n        return javaParserTypeAdapter.isAssignableBy(type);\n    }\n\n    @Override\n    public boolean canBeAssignedTo(ResolvedReferenceTypeDeclaration other) {\n        // TODO consider generic types\n        if (this.getQualifiedName().equals(other.getQualifiedName())) {\n            return true;\n        }\n        if (this.wrappedNode.getExtendedTypes() != null) {\n            for (ClassOrInterfaceType type : wrappedNode.getExtendedTypes()) {\n                ResolvedReferenceTypeDeclaration ancestor = (ResolvedReferenceTypeDeclaration) new SymbolSolver(typeSolver).solveType(type);\n                if (ancestor.canBeAssignedTo(other)) {\n                    return true;\n                }\n            }\n        }\n\n        // TODO FIXME: Remove null check -- should be an empty list...\n        if (this.wrappedNode.getImplementedTypes() != null) {\n            for (ClassOrInterfaceType type : wrappedNode.getImplementedTypes()) {\n                ResolvedReferenceTypeDeclaration ancestor = (ResolvedReferenceTypeDeclaration) new SymbolSolver(typeSolver).solveType(type);\n                if (ancestor.canBeAssignedTo(other)) {\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n\n    @Override\n    public boolean isTypeParameter() {\n        return false;\n    }\n\n    @Override\n    public List<ResolvedFieldDeclaration> getAllFields() {\n        List<ResolvedFieldDeclaration> fields = javaParserTypeAdapter.getFieldsForDeclaredVariables();\n\n        getAncestors()\n                .stream()\n                .filter(ancestor -> ancestor.getTypeDeclaration().isPresent())\n                .forEach(ancestor -> ancestor.getTypeDeclaration().get()\n                        .getAllFields()\n                        .forEach(f -> {\n                            fields.add(new ResolvedFieldDeclaration() {\n\n                                @Override\n                                public AccessSpecifier accessSpecifier() {\n                                    return f.accessSpecifier();\n                                }\n\n                                @Override\n                                public String getName() {\n                                    return f.getName();\n                                }\n\n                                @Override\n                                public ResolvedType getType() {\n                                    return ancestor.useThisTypeParametersOnTheGivenType(f.getType());\n                                }\n\n                                @Override\n                                public boolean isStatic() {\n                                    return f.isStatic();\n                                }\n\n                                @Override\n                                public ResolvedTypeDeclaration declaringType() {\n                                    return f.declaringType();\n                                }\n                                \n                                @Override\n                                public Optional<FieldDeclaration> toAst() {\n                                    return f.toAst();\n                                }\n                            });\n                        })\n                );\n        \n        return fields;\n    }\n\n\n    @Override\n    public String toString() {\n        return \"JavaParserInterfaceDeclaration{\" +\n                \"wrappedNode=\" + wrappedNode +\n                '}';\n    }\n\n    /**\n     * This method is deprecated because it receives the TypesSolver as a parameter.\n     * Eventually we would like to remove all usages of TypeSolver as a parameter.\n     *\n     * Also, resolution should move out of declarations, so that they are pure declarations and the resolution should\n     * work for JavaParser, Reflection and Javassist classes in the same way and not be specific to the three\n     * implementations.\n     */\n    @Deprecated\n    public SymbolReference<ResolvedTypeDeclaration> solveType(String name) {\n        if (this.wrappedNode.getName().getId().equals(name)) {\n            return SymbolReference.solved(this);\n        }\n        SymbolReference<ResolvedTypeDeclaration> ref = javaParserTypeAdapter.solveType(name);\n        if (ref.isSolved()) {\n            return ref;\n        }\n\n        String prefix = wrappedNode.getName() + \".\";\n        if (name.startsWith(prefix) && name.length() > prefix.length()) {\n            return new JavaParserInterfaceDeclaration(this.wrappedNode, typeSolver).solveType(name.substring(prefix.length()));\n        }\n\n        return getContext().getParent()\n                .orElseThrow(() -> new RuntimeException(\"Parent context unexpectedly empty.\"))\n                .solveType(name);\n    }\n\n    @Override\n    public SymbolReference<ResolvedMethodDeclaration> solveMethod(String name, List<ResolvedType> argumentsTypes,\n                                                                  boolean staticOnly) {\n        return getContext().solveMethod(name, argumentsTypes, staticOnly);\n    }\n\n    @Override\n    public Optional<MethodUsage> solveMethodAsUsage(String name, List<ResolvedType> argumentTypes,\n                                                    Context invocationContext, List<ResolvedType> typeParameters) {\n        return getContext().solveMethodAsUsage(name, argumentTypes);\n    }\n\n    @Override\n    public List<ResolvedReferenceType> getAncestors(boolean acceptIncompleteList) {\n        List<ResolvedReferenceType> ancestors = new ArrayList<>();\n        if (wrappedNode.getExtendedTypes() != null) {\n            for (ClassOrInterfaceType extended : wrappedNode.getExtendedTypes()) {\n                try {\n                    ancestors.add(toReferenceType(extended));\n                } catch (UnsolvedSymbolException e) {\n                    if (!acceptIncompleteList) {\n                        // we only throw an exception if we require a complete list; otherwise, we attempt to continue gracefully\n                        throw e;\n                    }\n                }\n            }\n        }\n\n        // TODO FIXME: Remove null check -- should be an empty list...\n        if (wrappedNode.getImplementedTypes() != null) {\n            for (ClassOrInterfaceType implemented : wrappedNode.getImplementedTypes()) {\n                try {\n                    ancestors.add(toReferenceType(implemented));\n                } catch (UnsolvedSymbolException e) {\n                    if (!acceptIncompleteList) {\n                        // we only throw an exception if we require a complete list; otherwise, we attempt to continue gracefully\n                        throw e;\n                    }\n                }\n            }\n        }\n        return ancestors;\n    }\n\n    @Override\n    public List<ResolvedTypeParameterDeclaration> getTypeParameters() {\n        if (this.wrappedNode.getTypeParameters() == null) {\n            return Collections.emptyList();\n        } else {\n            return this.wrappedNode.getTypeParameters().stream().map(\n                    (tp) -> new JavaParserTypeParameter(tp, typeSolver)\n            ).collect(Collectors.toList());\n        }\n    }\n\n    /**\n     * Returns the JavaParser node associated with this JavaParserInterfaceDeclaration.\n     *\n     * @return A visitable JavaParser node wrapped by this object.\n     */\n    public ClassOrInterfaceDeclaration getWrappedNode() {\n        return wrappedNode;\n    }\n\n    @Override\n    public AccessSpecifier accessSpecifier() {\n        return wrappedNode.getAccessSpecifier();\n    }\n\n    @Override\n    public Set<ResolvedReferenceTypeDeclaration> internalTypes() {\n        // Use a special Set implementation that avoids calculating the hashCode of the node,\n        // since this can be very time-consuming for big node trees, and we are sure there are\n        // no duplicates in the members list.\n        Set<ResolvedReferenceTypeDeclaration> res = Collections.newSetFromMap(new IdentityHashMap<>());\n        for (BodyDeclaration<?> member : this.wrappedNode.getMembers()) {\n            if (member instanceof TypeDeclaration) {\n                res.add(JavaParserFacade.get(typeSolver).getTypeDeclaration((TypeDeclaration) member));\n            }\n        }\n        return res;\n    }\n\n    @Override\n    public Optional<ResolvedReferenceTypeDeclaration> containerType() {\n        return javaParserTypeAdapter.containerType();\n    }\n\n    @Override\n    public List<ResolvedConstructorDeclaration> getConstructors() {\n        return Collections.emptyList();\n    }\n\n    @Override\n    public Optional<ClassOrInterfaceDeclaration> toAst() {\n        return Optional.of(wrappedNode);\n    }\n\n    ///\n    /// Private methods\n    ///\n\n    private ResolvedReferenceType toReferenceType(ClassOrInterfaceType classOrInterfaceType) {\n        SymbolReference<? extends ResolvedTypeDeclaration> ref = null;\n        String typeName = classOrInterfaceType.getName().getId();\n        if (classOrInterfaceType.getScope().isPresent()) {\n            typeName = classOrInterfaceType.getScope().get().asString() + \".\" + typeName;\n        }\n\n        if (typeName.indexOf('.') > -1) {\n            ref = typeSolver.tryToSolveType(typeName);\n        }\n        if (ref == null || !ref.isSolved()) {\n            ref = solveType(typeName);\n        }\n        if (!ref.isSolved()) {\n            throw new UnsolvedSymbolException(classOrInterfaceType.getName().getId());\n        }\n        if (!classOrInterfaceType.getTypeArguments().isPresent()) {\n            return new ReferenceTypeImpl(ref.getCorrespondingDeclaration().asReferenceType(), typeSolver);\n        }\n        List<ResolvedType> superClassTypeParameters = classOrInterfaceType.getTypeArguments().get()\n                .stream().map(ta -> new LazyType(v -> JavaParserFacade.get(typeSolver).convert(ta, ta)))\n                .collect(Collectors.toList());\n        return new ReferenceTypeImpl(ref.getCorrespondingDeclaration().asReferenceType(), superClassTypeParameters, typeSolver);\n    }\n}\n",
        "filePathAfter": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/declarations/JavaParserInterfaceDeclaration.java",
        "sourceCodeAfterForWhole": "/*\n * Copyright (C) 2015-2016 Federico Tomassetti\n * Copyright (C) 2017-2020 The JavaParser Team.\n *\n * This file is part of JavaParser.\n *\n * JavaParser can be used either under the terms of\n * a) the GNU Lesser General Public License as published by\n *     the Free Software Foundation, either version 3 of the License, or\n *     (at your option) any later version.\n * b) the terms of the Apache License\n *\n * You should have received a copy of both licenses in LICENCE.LGPL and\n * LICENCE.APACHE. Please refer to those files for details.\n *\n * JavaParser is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n */\n\npackage com.github.javaparser.symbolsolver.javaparsermodel.declarations;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Optional;\nimport java.util.Set;\nimport java.util.stream.Collectors;\n\nimport com.github.javaparser.ast.AccessSpecifier;\nimport com.github.javaparser.ast.Node;\nimport com.github.javaparser.ast.body.BodyDeclaration;\nimport com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;\nimport com.github.javaparser.ast.body.FieldDeclaration;\nimport com.github.javaparser.ast.type.ClassOrInterfaceType;\nimport com.github.javaparser.resolution.MethodUsage;\nimport com.github.javaparser.resolution.UnsolvedSymbolException;\nimport com.github.javaparser.resolution.declarations.ResolvedConstructorDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedFieldDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedInterfaceDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedMethodDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedReferenceTypeDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedTypeDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedTypeParameterDeclaration;\nimport com.github.javaparser.resolution.types.ResolvedReferenceType;\nimport com.github.javaparser.resolution.types.ResolvedType;\nimport com.github.javaparser.symbolsolver.core.resolution.Context;\nimport com.github.javaparser.symbolsolver.core.resolution.MethodUsageResolutionCapability;\nimport com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade;\nimport com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFactory;\nimport com.github.javaparser.symbolsolver.logic.AbstractTypeDeclaration;\nimport com.github.javaparser.symbolsolver.logic.MethodResolutionCapability;\nimport com.github.javaparser.symbolsolver.model.resolution.SymbolReference;\nimport com.github.javaparser.symbolsolver.model.resolution.TypeSolver;\nimport com.github.javaparser.symbolsolver.model.typesystem.LazyType;\nimport com.github.javaparser.symbolsolver.model.typesystem.ReferenceTypeImpl;\nimport com.github.javaparser.symbolsolver.resolution.SymbolSolver;\n\n/**\n * @author Federico Tomassetti\n */\npublic class JavaParserInterfaceDeclaration extends AbstractTypeDeclaration\n        implements ResolvedInterfaceDeclaration, MethodResolutionCapability, MethodUsageResolutionCapability {\n\n    private TypeSolver typeSolver;\n    private ClassOrInterfaceDeclaration wrappedNode;\n    private JavaParserTypeAdapter<ClassOrInterfaceDeclaration> javaParserTypeAdapter;\n\n    public JavaParserInterfaceDeclaration(ClassOrInterfaceDeclaration wrappedNode, TypeSolver typeSolver) {\n        if (!wrappedNode.isInterface()) {\n            throw new IllegalArgumentException();\n        }\n        this.wrappedNode = wrappedNode;\n        this.typeSolver = typeSolver;\n        this.javaParserTypeAdapter = new JavaParserTypeAdapter<>(wrappedNode, typeSolver);\n    }\n\n    @Override\n    public Set<ResolvedMethodDeclaration> getDeclaredMethods() {\n        Set<ResolvedMethodDeclaration> methods = new HashSet<>();\n        for (BodyDeclaration<?> member : wrappedNode.getMembers()) {\n            if (member instanceof com.github.javaparser.ast.body.MethodDeclaration) {\n                methods.add(new JavaParserMethodDeclaration((com.github.javaparser.ast.body.MethodDeclaration) member, typeSolver));\n            }\n        }\n        return methods;\n    }\n\n    public Context getContext() {\n        return JavaParserFactory.getContext(wrappedNode, typeSolver);\n    }\n\n    public ResolvedType getUsage(Node node) {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n\n        JavaParserInterfaceDeclaration that = (JavaParserInterfaceDeclaration) o;\n\n        if (!wrappedNode.equals(that.wrappedNode)) return false;\n\n        return true;\n    }\n\n    @Override\n    public int hashCode() {\n        return wrappedNode.hashCode();\n    }\n\n    @Override\n    public String getName() {\n        return wrappedNode.getName().getId();\n    }\n\n    @Override\n    public ResolvedInterfaceDeclaration asInterface() {\n        return this;\n    }\n\n    @Override\n    public boolean hasDirectlyAnnotation(String canonicalName) {\n        return AstResolutionUtils.hasDirectlyAnnotation(wrappedNode, typeSolver, canonicalName);\n    }\n\n    @Override\n    public boolean isInterface() {\n        return true;\n    }\n\n    @Override\n    public List<ResolvedReferenceType> getInterfacesExtended() {\n        List<ResolvedReferenceType> interfaces = new ArrayList<>();\n        for (ClassOrInterfaceType t : wrappedNode.getExtendedTypes()) {\n            interfaces.add(new ReferenceTypeImpl(\n                    solveType(t.getName().getId()).getCorrespondingDeclaration().asInterface(), typeSolver));\n        }\n        return interfaces;\n    }\n\n    @Override\n    public String getPackageName() {\n        return javaParserTypeAdapter.getPackageName();\n    }\n\n    @Override\n    public String getClassName() {\n        return javaParserTypeAdapter.getClassName();\n    }\n\n    @Override\n    public String getQualifiedName() {\n        return javaParserTypeAdapter.getQualifiedName();\n    }\n\n    @Override\n    public boolean isAssignableBy(ResolvedReferenceTypeDeclaration other) {\n        return javaParserTypeAdapter.isAssignableBy(other);\n    }\n\n    @Override\n    public boolean isAssignableBy(ResolvedType type) {\n        return javaParserTypeAdapter.isAssignableBy(type);\n    }\n\n    @Override\n    public boolean canBeAssignedTo(ResolvedReferenceTypeDeclaration other) {\n        // TODO consider generic types\n        if (this.getQualifiedName().equals(other.getQualifiedName())) {\n            return true;\n        }\n        if (this.wrappedNode.getExtendedTypes() != null) {\n            for (ClassOrInterfaceType type : wrappedNode.getExtendedTypes()) {\n                ResolvedReferenceTypeDeclaration ancestor = (ResolvedReferenceTypeDeclaration) new SymbolSolver(typeSolver).solveType(type);\n                if (ancestor.canBeAssignedTo(other)) {\n                    return true;\n                }\n            }\n        }\n\n        // TODO FIXME: Remove null check -- should be an empty list...\n        if (this.wrappedNode.getImplementedTypes() != null) {\n            for (ClassOrInterfaceType type : wrappedNode.getImplementedTypes()) {\n                ResolvedReferenceTypeDeclaration ancestor = (ResolvedReferenceTypeDeclaration) new SymbolSolver(typeSolver).solveType(type);\n                if (ancestor.canBeAssignedTo(other)) {\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n\n    @Override\n    public boolean isTypeParameter() {\n        return false;\n    }\n\n    @Override\n    public List<ResolvedFieldDeclaration> getAllFields() {\n        List<ResolvedFieldDeclaration> fields = javaParserTypeAdapter.getFieldsForDeclaredVariables();\n\n        getAncestors()\n                .stream()\n                .filter(ancestor -> ancestor.getTypeDeclaration().isPresent())\n                .forEach(ancestor -> ancestor.getTypeDeclaration().get()\n                        .getAllFields()\n                        .forEach(f -> {\n                            fields.add(new ResolvedFieldDeclaration() {\n\n                                @Override\n                                public AccessSpecifier accessSpecifier() {\n                                    return f.accessSpecifier();\n                                }\n\n                                @Override\n                                public String getName() {\n                                    return f.getName();\n                                }\n\n                                @Override\n                                public ResolvedType getType() {\n                                    return ancestor.useThisTypeParametersOnTheGivenType(f.getType());\n                                }\n\n                                @Override\n                                public boolean isStatic() {\n                                    return f.isStatic();\n                                }\n\n                                @Override\n                                public ResolvedTypeDeclaration declaringType() {\n                                    return f.declaringType();\n                                }\n                                \n                                @Override\n                                public Optional<FieldDeclaration> toAst() {\n                                    return f.toAst();\n                                }\n                            });\n                        })\n                );\n        \n        return fields;\n    }\n\n\n    @Override\n    public String toString() {\n        return \"JavaParserInterfaceDeclaration{\" +\n                \"wrappedNode=\" + wrappedNode +\n                '}';\n    }\n\n    /**\n     * This method is deprecated because it receives the TypesSolver as a parameter.\n     * Eventually we would like to remove all usages of TypeSolver as a parameter.\n     *\n     * Also, resolution should move out of declarations, so that they are pure declarations and the resolution should\n     * work for JavaParser, Reflection and Javassist classes in the same way and not be specific to the three\n     * implementations.\n     */\n    @Deprecated\n    public SymbolReference<ResolvedTypeDeclaration> solveType(String name) {\n        if (this.wrappedNode.getName().getId().equals(name)) {\n            return SymbolReference.solved(this);\n        }\n        SymbolReference<ResolvedTypeDeclaration> ref = javaParserTypeAdapter.solveType(name);\n        if (ref.isSolved()) {\n            return ref;\n        }\n\n        String prefix = wrappedNode.getName() + \".\";\n        if (name.startsWith(prefix) && name.length() > prefix.length()) {\n            return new JavaParserInterfaceDeclaration(this.wrappedNode, typeSolver).solveType(name.substring(prefix.length()));\n        }\n\n        return getContext().getParent()\n                .orElseThrow(() -> new RuntimeException(\"Parent context unexpectedly empty.\"))\n                .solveType(name);\n    }\n\n    @Override\n    public SymbolReference<ResolvedMethodDeclaration> solveMethod(String name, List<ResolvedType> argumentsTypes,\n                                                                  boolean staticOnly) {\n        return getContext().solveMethod(name, argumentsTypes, staticOnly);\n    }\n\n    @Override\n    public Optional<MethodUsage> solveMethodAsUsage(String name, List<ResolvedType> argumentTypes,\n                                                    Context invocationContext, List<ResolvedType> typeParameters) {\n        return getContext().solveMethodAsUsage(name, argumentTypes);\n    }\n\n    @Override\n    public List<ResolvedReferenceType> getAncestors(boolean acceptIncompleteList) {\n        List<ResolvedReferenceType> ancestors = new ArrayList<>();\n        if (wrappedNode.getExtendedTypes() != null) {\n            for (ClassOrInterfaceType extended : wrappedNode.getExtendedTypes()) {\n                try {\n                    ancestors.add(toReferenceType(extended));\n                } catch (UnsolvedSymbolException e) {\n                    if (!acceptIncompleteList) {\n                        // we only throw an exception if we require a complete list; otherwise, we attempt to continue gracefully\n                        throw e;\n                    }\n                }\n            }\n        }\n\n        // TODO FIXME: Remove null check -- should be an empty list...\n        if (wrappedNode.getImplementedTypes() != null) {\n            for (ClassOrInterfaceType implemented : wrappedNode.getImplementedTypes()) {\n                try {\n                    ancestors.add(toReferenceType(implemented));\n                } catch (UnsolvedSymbolException e) {\n                    if (!acceptIncompleteList) {\n                        // we only throw an exception if we require a complete list; otherwise, we attempt to continue gracefully\n                        throw e;\n                    }\n                }\n            }\n        }\n        return ancestors;\n    }\n\n    @Override\n    public List<ResolvedTypeParameterDeclaration> getTypeParameters() {\n        if (this.wrappedNode.getTypeParameters() == null) {\n            return Collections.emptyList();\n        } else {\n            return this.wrappedNode.getTypeParameters().stream().map(\n                    (tp) -> new JavaParserTypeParameter(tp, typeSolver)\n            ).collect(Collectors.toList());\n        }\n    }\n\n    /**\n     * Returns the JavaParser node associated with this JavaParserInterfaceDeclaration.\n     *\n     * @return A visitable JavaParser node wrapped by this object.\n     */\n    public ClassOrInterfaceDeclaration getWrappedNode() {\n        return wrappedNode;\n    }\n\n    @Override\n    public AccessSpecifier accessSpecifier() {\n        return wrappedNode.getAccessSpecifier();\n    }\n\n    @Override\n    public Set<ResolvedReferenceTypeDeclaration> internalTypes() {\n        return javaParserTypeAdapter.internalTypes();\n    }\n\n    @Override\n    public Optional<ResolvedReferenceTypeDeclaration> containerType() {\n        return javaParserTypeAdapter.containerType();\n    }\n\n    @Override\n    public List<ResolvedConstructorDeclaration> getConstructors() {\n        return Collections.emptyList();\n    }\n\n    @Override\n    public Optional<ClassOrInterfaceDeclaration> toAst() {\n        return Optional.of(wrappedNode);\n    }\n\n    ///\n    /// Private methods\n    ///\n\n    private ResolvedReferenceType toReferenceType(ClassOrInterfaceType classOrInterfaceType) {\n        SymbolReference<? extends ResolvedTypeDeclaration> ref = null;\n        String typeName = classOrInterfaceType.getName().getId();\n        if (classOrInterfaceType.getScope().isPresent()) {\n            typeName = classOrInterfaceType.getScope().get().asString() + \".\" + typeName;\n        }\n\n        if (typeName.indexOf('.') > -1) {\n            ref = typeSolver.tryToSolveType(typeName);\n        }\n        if (ref == null || !ref.isSolved()) {\n            ref = solveType(typeName);\n        }\n        if (!ref.isSolved()) {\n            throw new UnsolvedSymbolException(classOrInterfaceType.getName().getId());\n        }\n        if (!classOrInterfaceType.getTypeArguments().isPresent()) {\n            return new ReferenceTypeImpl(ref.getCorrespondingDeclaration().asReferenceType(), typeSolver);\n        }\n        List<ResolvedType> superClassTypeParameters = classOrInterfaceType.getTypeArguments().get()\n                .stream().map(ta -> new LazyType(v -> JavaParserFacade.get(typeSolver).convert(ta, ta)))\n                .collect(Collectors.toList());\n        return new ReferenceTypeImpl(ref.getCorrespondingDeclaration().asReferenceType(), superClassTypeParameters, typeSolver);\n    }\n}\n",
        "diffSourceCodeSet": [
            "if (this.wrappedNode.getImplementedTypes() != null) {\n            for (ClassOrInterfaceType type : wrappedNode.getImplementedTypes()) {\n                ResolvedReferenceTypeDeclaration ancestor = (ResolvedReferenceTypeDeclaration) new SymbolSolver(typeSolver).solveType(type);\n                if (ancestor.canBeAssignedTo(other)) {\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }"
        ],
        "invokedMethodSet": [],
        "sourceCodeAfterRefactoring": "@Override\n    public Set<ResolvedReferenceTypeDeclaration> internalTypes() {\n        return javaParserTypeAdapter.internalTypes();\n    }\nif (this.wrappedNode.getImplementedTypes() != null) {\n            for (ClassOrInterfaceType type : wrappedNode.getImplementedTypes()) {\n                ResolvedReferenceTypeDeclaration ancestor = (ResolvedReferenceTypeDeclaration) new SymbolSolver(typeSolver).solveType(type);\n                if (ancestor.canBeAssignedTo(other)) {\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }",
        "diffSourceCode": "-  187: \n-  188:         // TODO FIXME: Remove null check -- should be an empty list...\n-  189:         if (this.wrappedNode.getImplementedTypes() != null) {\n-  190:             for (ClassOrInterfaceType type : wrappedNode.getImplementedTypes()) {\n-  191:                 ResolvedReferenceTypeDeclaration ancestor = (ResolvedReferenceTypeDeclaration) new SymbolSolver(typeSolver).solveType(type);\n-  192:                 if (ancestor.canBeAssignedTo(other)) {\n-  193:                     return true;\n-  194:                 }\n-  195:             }\n-  196:         }\n-  197: \n-  198:         return false;\n-  357:     }\n-  358: \n-  359:     @Override\n-  360:     public Set<ResolvedReferenceTypeDeclaration> internalTypes() {\n-  361:         // Use a special Set implementation that avoids calculating the hashCode of the node,\n-  362:         // since this can be very time-consuming for big node trees, and we are sure there are\n-  363:         // no duplicates in the members list.\n-  364:         Set<ResolvedReferenceTypeDeclaration> res = Collections.newSetFromMap(new IdentityHashMap<>());\n-  365:         for (BodyDeclaration<?> member : this.wrappedNode.getMembers()) {\n-  366:             if (member instanceof TypeDeclaration) {\n-  367:                 res.add(JavaParserFacade.get(typeSolver).getTypeDeclaration((TypeDeclaration) member));\n-  368:             }\n-  369:         }\n-  370:         return res;\n-  371:     }\n+  187:         if (this.wrappedNode.getImplementedTypes() != null) {\n+  188:             for (ClassOrInterfaceType type : wrappedNode.getImplementedTypes()) {\n+  189:                 ResolvedReferenceTypeDeclaration ancestor = (ResolvedReferenceTypeDeclaration) new SymbolSolver(typeSolver).solveType(type);\n+  190:                 if (ancestor.canBeAssignedTo(other)) {\n+  191:                     return true;\n+  192:                 }\n+  193:             }\n+  194:         }\n+  195: \n+  196:         return false;\n+  197:     }\n+  198: \n+  357:     @Override\n+  358:     public Set<ResolvedReferenceTypeDeclaration> internalTypes() {\n+  359:         return javaParserTypeAdapter.internalTypes();\n+  360:     }\n+  361: \n+  362:     @Override\n+  363:     public Optional<ResolvedReferenceTypeDeclaration> containerType() {\n+  364:         return javaParserTypeAdapter.containerType();\n+  365:     }\n+  366: \n+  367:     @Override\n+  368:     public List<ResolvedConstructorDeclaration> getConstructors() {\n+  369:         return Collections.emptyList();\n+  370:     }\n+  371: \n",
        "uniqueId": "c378a677ebcd999d853b3e5867ac7ca7cd8e73cb_359_371_187_198_357_360",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 0,
                "covered": 32
            },
            "BRANCH": {
                "missed": 0,
                "covered": 4
            },
            "LINE": {
                "missed": 0,
                "covered": 6
            },
            "COMPLEXITY": {
                "missed": 0,
                "covered": 3
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 17
    },
    {
        "type": "Move Method",
        "description": "Move Method\tpackage languageLevelValidation_recordAsTypeIdentifier_forbidden(languageLevel ParserConfiguration.LanguageLevel) : void from class com.github.javaparser.ast.body.RecordDeclarationTest to package languageLevelValidation_recordAsTypeIdentifier_forbidden(languageLevel ParserConfiguration.LanguageLevel) : void from class com.github.javaparser.ast.body.RecordDeclarationTest.LanguageLevels",
        "diffLocations": [
            {
                "filePath": "javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/RecordDeclarationTest.java",
                "startLine": 50,
                "endLine": 55,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/RecordDeclarationTest.java",
                "startLine": 53,
                "endLine": 58,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "@ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_13\", \"JAVA_13_PREVIEW\", \"JAVA_14\", \"JAVA_15\"})\n    void languageLevelValidation_recordAsTypeIdentifier_forbidden(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"class record {}\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(languageLevel, s);\n    }",
        "filePathBefore": "javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/RecordDeclarationTest.java",
        "isPureRefactoring": true,
        "commitId": "9e55bc54539d393e1948c8d4a89b1511ed379fad",
        "packageNameBefore": "com.github.javaparser.ast.body",
        "classNameBefore": "com.github.javaparser.ast.body.RecordDeclarationTest",
        "methodNameBefore": "com.github.javaparser.ast.body.RecordDeclarationTest#languageLevelValidation_recordAsTypeIdentifier_forbidden",
        "classSignatureBefore": "public class RecordDeclarationTest ",
        "methodNameBeforeSet": [
            "com.github.javaparser.ast.body.RecordDeclarationTest#languageLevelValidation_recordAsTypeIdentifier_forbidden"
        ],
        "classNameBeforeSet": [
            "com.github.javaparser.ast.body.RecordDeclarationTest"
        ],
        "classSignatureBeforeSet": [
            "public class RecordDeclarationTest "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "package com.github.javaparser.ast.body;\n\nimport com.github.javaparser.ParserConfiguration;\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.Modifier;\nimport com.github.javaparser.ast.NodeList;\nimport com.github.javaparser.ast.expr.ObjectCreationExpr;\nimport com.github.javaparser.utils.TestParser;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.EnumSource;\nimport org.opentest4j.AssertionFailedError;\n\nimport java.util.List;\n\nimport static com.github.javaparser.utils.TestUtils.assertEqualsStringIgnoringEol;\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\npublic class RecordDeclarationTest {\n\n    @ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_13\", \"JAVA_13_PREVIEW\", \"JAVA_14\", \"JAVA_15\"})\n    void basicGrammarCompiles_languageLevelValidation_forbidden(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"record Point(int x, int y) { }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = TestParser.parseCompilationUnit(languageLevel, s);\n        });\n    }\n\n    @ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_14_PREVIEW\", \"JAVA_15_PREVIEW\", \"JAVA_16\", \"JAVA_16_PREVIEW\"})\n    void basicGrammarCompiles_languageLevelValidation_permitted(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(languageLevel, s);\n    }\n\n    @ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_14_PREVIEW\", \"JAVA_15_PREVIEW\", \"JAVA_16\", \"JAVA_16_PREVIEW\"})\n    void languageLevelValidation_recordAsTypeIdentifier_permitted(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"class record {}\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = TestParser.parseCompilationUnit(languageLevel, s);\n        });\n    }\n\n    @ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_13\", \"JAVA_13_PREVIEW\", \"JAVA_14\", \"JAVA_15\"})\n    void languageLevelValidation_recordAsTypeIdentifier_forbidden(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"class record {}\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(languageLevel, s);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Description\n     */\n    @Test\n    void basicGrammarCompiles() {\n        String s = \"record Point(int x, int y) { }\";\n        assertOneRecordDeclaration(TestParser.parseCompilationUnit(s));\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Description\n     */\n    @Test\n    void basicGrammar() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        RecordDeclaration recordDeclaration = cu.findAll(RecordDeclaration.class).get(0);\n\n        assertTrue(recordDeclaration.isRecordDeclaration());\n        assertTrue(recordDeclaration.getImplementedTypes().isEmpty());\n        assertTrue(recordDeclaration.getTypeParameters().isEmpty());\n        assertTrue(recordDeclaration.getFullyQualifiedName().isPresent());\n        assertEquals(\"Point\", recordDeclaration.getFullyQualifiedName().get());\n        assertTrue(recordDeclaration.isRecordDeclaration());\n\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"x\", parameter0.getNameAsString());\n        assertEquals(\"int\", parameter0.getTypeAsString());\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"y\", parameter1.getNameAsString());\n        assertEquals(\"int\", parameter1.getTypeAsString());\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Description\n     */\n    @Test\n    void basicRecordPrints() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        String expected = \"\" +\n                \"record Point(int x, int y) {\\n\" +\n                \"}\\n\" +\n                \"\";\n        assertEqualsStringIgnoringEol(expected, cu.toString());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-record\n     */\n    @Test\n    void record_cannotExtend() {\n        String s = \"record Point(int x, int y) extends OtherThing { }\";\n        assertCompilationFails(s);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_cannotBeAbstract() {\n        String s = \"abstract record Point(int x, int y) { }\";\n        assertCompilationFails(s);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_mayImplementInterfaces() {\n        String s = \"record Point(int x, int y) implements OtherInterface { }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n\n        assertOneRecordDeclaration(cu);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_mayBeStatic() {\n        String s = \"static record Point(int x, int y) { }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void recordWithVarArgs() {\n        String s = \"record R(T1 c1, Tn... cn){ }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"c1\", parameter0.getNameAsString());\n        assertEquals(\"T1\", parameter0.getTypeAsString());\n        assertFalse(parameter0.isVarArgs());\n\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"cn\", parameter1.getNameAsString());\n        assertEquals(\"Tn\", parameter1.getTypeAsString());\n        assertTrue(parameter1.isVarArgs());\n    }\n\n    @Test\n    void recordWithAnnotationedParameters() {\n        String s = \"record Card(@MyAnno Rank rank, @MyAnno Suit suit) { }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"rank\", parameter0.getNameAsString());\n        assertEquals(\"Rank\", parameter0.getTypeAsString());\n        assertEquals(1, parameter0.getAnnotations().size());\n\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"suit\", parameter1.getNameAsString());\n        assertEquals(\"Suit\", parameter1.getTypeAsString());\n        assertEquals(1, parameter1.getAnnotations().size());\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    @Test\n    void record_emptyMembers() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    @Test\n    void record_permitStaticFields() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    static int z;\\n\" +\n                \"\\n\" +\n                \"    static {\\n\" +\n                \"        int z = 10;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_permitStaticMethods() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    static public int abc() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_permitMethods() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    public String xyz() {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_mustNotAllowNonStaticFields() {\n        String s = \"record Point(int x, int y) { int z; }\";\n        assertCompilationFails(s);\n    }\n\n    @Test\n    void record_mustAllowStaticFields() {\n        String s = \"record Point(int x, int y) { static int z; }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_isImplicitlyFinal() {\n        String s = \"record Point(int x, int y) { static int z; }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        RecordDeclaration recordDeclaration = cu.findFirst(RecordDeclaration.class).get();\n        assertFalse(recordDeclaration.hasModifier(Modifier.Keyword.FINAL));\n        assertTrue(recordDeclaration.isFinal(), \"Records are implicitly final.\");\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_canHaveGenerics() {\n        String s = \"record Point <T> (T x, int y) { }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        RecordDeclaration recordDeclaration = cu.findFirst(RecordDeclaration.class).get();\n        assertFalse(recordDeclaration.getTypeParameters().isEmpty());\n        assertEquals(\"T\", recordDeclaration.getTypeParameters().get(0).getNameAsString());\n    }\n\n\n    @Test\n    void record_mustNotAllowMismatchedComponentAccessorReturnType() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public String x() {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \"}\";\n        assertCompilationFails(s);\n    }\n\n    @Test\n    void record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public String x(int a) {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \"}\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod2() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public int x(int a) {\\n\" +\n                \"        return 10;\\n\" +\n                \"    }\\n\" +\n                \"}\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_allowComponentAccessorWithMatchingType() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return 10;\\n\" +\n                \"    }\\n\" +\n                \"}\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_allowNestedWithinClass() {\n        String s = \"\\n\" +\n                \"class X {\\n\" +\n                \"    record Point(int x, int y) {\\n\" +\n                \"    }\\n\" +\n                \"}\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_componentsAreImplicitlyFinal() {\n        String s = \"record Point(int x, int y) { }\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        RecordDeclaration recordDeclaration = cu.findAll(RecordDeclaration.class).get(0);\n\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertTrue(parameters.get(0).isFinal());\n        assertTrue(parameters.get(1).isFinal());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_allowClassWithinRecord() {\n        String s = \"\\n\" +\n                \"record Point(int x, int y) {\\n\" +\n                \"    class X {\\n\" +\n                \"    }\\n\" +\n                \"}\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        BodyDeclaration<?> member = recordDeclaration.getMember(0);\n\n        assertTrue(member.isClassOrInterfaceDeclaration());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_allowNestedWithinInterface() {\n        String s = \"\\n\" +\n                \"interface X {\\n\" +\n                \"    record Point(int x, int y) {\\n\" +\n                \"    }\\n\" +\n                \"}\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_allowNestedWithinEnum() {\n        String s = \"\\n\" +\n                \"enum ABC {\\n\" +\n                \"    ABC;\\n\" +\n                \"    \\n\" +\n                \"    record Point(int x, int y) {\\n\" +\n                \"    }\\n\" +\n                \"}\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_allowNestedMultiple() {\n        String s = \"\\n\" +\n                \"interface Y {\\n\" +\n                \"    class X {\\n\" +\n                \"        record Point(int x, int y) {\\n\" +\n                \"        }\\n\" +\n                \"    }\\n\" +\n                \"}\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_allowNestedMultiple2() {\n        String s = \"\\n\" +\n                \"interface Y {\\n\" +\n                \"    class X {\\n\" +\n                \"        record Point(int x, int y) {\\n\" +\n                \"        }\\n\" +\n                \"        record PointB(int x, int y) {\\n\" +\n                \"        }\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    record PointC(int x, int y) {\\n\" +\n                \"    }\\n\" +\n                \"}\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(3, recordDeclarations.size());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_topLevelRecordsAreNotStatic() {\n        String s = \"record Point(int x, int y) { }\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        RecordDeclaration recordDeclaration = cu.findAll(RecordDeclaration.class).get(0);\n        assertFalse(recordDeclaration.hasModifier(Modifier.Keyword.STATIC));\n        assertFalse(recordDeclaration.isStatic(), \"Top level Records are NOT implicitly static.\");\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_nestedRecordsAreImplicitlyStatic() {\n        String s = \"\\n\" +\n                \"class X {\\n\" +\n                \"    record Point(int x, int y) {\\n\" +\n                \"    }\\n\" +\n                \"}\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        RecordDeclaration recordDeclaration = cu.findAll(RecordDeclaration.class).get(0);\n        assertFalse(recordDeclaration.hasModifier(Modifier.Keyword.STATIC));\n        assertTrue(recordDeclaration.isStatic(), \"Nested Records are implicitly static.\");\n\n    }\n\n\n    @Test\n    void record_canBeCreatedUsingKeywordNew() {\n        String s = \"\\n\" +\n                \"\\n\" +\n                \"record Point(int x, int y) {\\n\" +\n                \"}\\n\" +\n                \"\\n\" +\n                \"class X {\\n\" +\n                \"    public static void main(String[] args) {\\n\" +\n                \"        new Point(10, 3);\\n\" +\n                \"    }\\n\" +\n                \"}\\n\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        ClassOrInterfaceDeclaration coid = cu.findAll(ClassOrInterfaceDeclaration.class).get(0);\n        List<ObjectCreationExpr> objectCreationExprs = coid.findAll(ObjectCreationExpr.class);\n\n        assertEquals(1, objectCreationExprs.size());\n        ObjectCreationExpr objectCreationExpr = objectCreationExprs.get(0);\n        assertEquals(\"Point\", objectCreationExpr.getTypeAsString());\n    }\n\n    /**\n     * Note the Record Declaration Constructor does not include parameters.\n     * (parameters are, instead, included within the record declaration)\n     * <p>\n     * https://bugs.openjdk.java.net/browse/JDK-8222777\n     */\n    @Test\n    void recordDeclarationFromTheJDK8222777() {\n        CompilationUnit cu = TestParser.parseCompilationUnit(\"\" +\n                \"public record Range(int lo, int hi) {\\n\" +\n                \"\\n\" +\n                \"  public Range {\\n\" +\n                \"    if (lo > hi)  /* referring here to the implicit constructor parameters */\\n\" +\n                \"      throw new IllegalArgumentException(String.format(\\\"(%d,%d)\\\", lo, hi));\\n\" +\n                \"  }\\n\" +\n                \"}\"\n        );\n\n        RecordDeclaration recordDeclaration = cu.findFirst(RecordDeclaration.class).get();\n        assertThat(recordDeclaration.getNameAsString()).isEqualTo(\"Range\");\n        assertThat(recordDeclaration.getModifiers()).containsExactly(Modifier.publicModifier());\n        // test parameters\n        // get constructor\n        // test parameters (none)\n    }\n\n    @Test\n    void recordDeclaration_exampleFromJls_8_10_4_1_normalCanonicalConstructors() {\n        CompilationUnit cu = TestParser.parseCompilationUnit(\"\" +\n                \"import java.lang.annotation.Target;\\n\" +\n                \"import java.lang.annotation.ElementType;\\n\" +\n                \"\\n\" +\n                \"@interface Foo {}\\n\" +\n                \"@interface Bar {}\\n\" +\n                \"\\n\" +\n                \"record Person(@Foo String name) {\\n\" +\n                \"    Person(String name2) {\\n\" +\n                \"    }\\n\" +\n                \"}\"\n        );\n\n        RecordDeclaration recordDeclaration = cu.findFirst(RecordDeclaration.class).get();\n        assertThat(recordDeclaration.getNameAsString()).isEqualTo(\"Person\");\n        assertThat(recordDeclaration.getModifiers()).isEmpty();\n\n        assertThat(recordDeclaration.getConstructors()).hasSize(1);\n        assertThat(recordDeclaration.getCompactConstructors()).hasSize(0);\n\n        // test parameters\n        // get constructor\n        // test parameters (none)\n\n    }\n\n    @Test\n    void compactConstructor_exampleFromJls_8_10_4_2_compactConstructors() {\n        CompilationUnit cu = TestParser.parseCompilationUnit(\"\" +\n                \"record Rational(int num, int denom) {\\n\" +\n                \"    private static int gcd(int a, int b) {\\n\" +\n                \"        if (b == 0) return Math.abs(a);\\n\" +\n                \"        else return gcd(b, a % b);\\n\" +\n                \"    }\\n\" +\n                \"   \\n\" +\n                \"    Rational {\\n\" +\n                \"        int gcd = gcd(num, denom);\\n\" +\n                \"        num    /= gcd;\\n\" +\n                \"        denom  /= gcd;\\n\" +\n                \"    }\\n\" +\n                \"}\\n\"\n        );\n\n        RecordDeclaration recordDeclaration = cu.findFirst(RecordDeclaration.class).get();\n        assertThat(recordDeclaration.getNameAsString()).isEqualTo(\"Rational\");\n        assertThat(recordDeclaration.getModifiers()).isEmpty();\n\n        assertThat(recordDeclaration.getConstructors()).hasSize(0);\n        assertThat(recordDeclaration.getCompactConstructors()).hasSize(1);\n\n        // test parameters\n        // get constructor\n        // test parameters (none)\n\n    }\n\n    @Test\n    void nonCompactConstructor_exampleFromJls_8_10_4_2_compactConstructors() {\n        CompilationUnit cu = TestParser.parseCompilationUnit(\"\" +\n                \"record Rational(int num, int denom) {\\n\" +\n                \"    private static int gcd(int a, int b) {\\n\" +\n                \"        if (b == 0) return Math.abs(a);\\n\" +\n                \"        else return gcd(b, a % b);\\n\" +\n                \"    }\\n\" +\n                \"   \\n\" +\n                \"    Rational(int num, int demon) {\\n\" +\n                \"        int gcd = gcd(num, denom);\\n\" +\n                \"        num    /= gcd;\\n\" +\n                \"        denom  /= gcd;\\n\" +\n                \"        this.num   = num;\\n\" +\n                \"        this.denom = denom;\\n\" +\n                \"    }\\n\" +\n                \"}\\n\"\n        );\n\n        RecordDeclaration recordDeclaration = cu.findFirst(RecordDeclaration.class).get();\n        assertThat(recordDeclaration.getNameAsString()).isEqualTo(\"Rational\");\n        assertThat(recordDeclaration.getModifiers()).isEmpty();\n\n        assertThat(recordDeclaration.getConstructors()).hasSize(1);\n        assertThat(recordDeclaration.getCompactConstructors()).hasSize(0);\n\n        // test parameters\n        // get constructor\n        // test parameters (none)\n\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395\n     */\n    @Test\n    void localRecords() {\n        CompilationUnit cu = TestParser.parseCompilationUnit(\"\" +\n                \"class Scratch {\\n\" +\n                \"    List<Merchant> findTopMerchants(List<Merchant> merchants, int month) {\\n\" +\n                \"        // Local record\\n\" +\n                \"        record MerchantSales(Merchant merchant, double sales) {}\\n\" +\n                \"\\n\" +\n                \"        return merchants.stream()\\n\" +\n                \"                .map(merchant -> new MerchantSales(merchant, computeSales(merchant, month)))\\n\" +\n                \"                .sorted((m1, m2) -> Double.compare(m2.sales(), m1.sales()))\\n\" +\n                \"                .map(MerchantSales::merchant)\\n\" +\n                \"                .collect(toList());\\n\" +\n                \"    }\\n\" +\n                \"}\\n\"\n        );\n\n        RecordDeclaration recordDeclaration = cu.findFirst(RecordDeclaration.class).get();\n        assertThat(recordDeclaration.getNameAsString()).isEqualTo(\"MerchantSales\");\n\n    }\n\n    private void assertCompilationFails(String s) {\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        });\n    }\n\n    private void assertOneRecordDeclaration(CompilationUnit cu) {\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n}\n",
        "filePathAfter": "javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/RecordDeclarationTest.java",
        "sourceCodeAfterForWhole": "package com.github.javaparser.ast.body;\n\nimport com.github.javaparser.ParserConfiguration;\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.Modifier;\nimport com.github.javaparser.ast.NodeList;\nimport com.github.javaparser.ast.expr.ObjectCreationExpr;\nimport com.github.javaparser.utils.TestParser;\nimport org.junit.jupiter.api.Nested;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.EnumSource;\nimport org.opentest4j.AssertionFailedError;\n\nimport java.util.List;\n\nimport static com.github.javaparser.utils.TestUtils.assertEqualsStringIgnoringEol;\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\npublic class RecordDeclarationTest {\n\n    @Nested\n    class LanguageLevels {\n        @ParameterizedTest\n        @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_13\", \"JAVA_13_PREVIEW\", \"JAVA_14\", \"JAVA_15\"})\n        void basicGrammarCompiles_languageLevelValidation_forbidden(ParserConfiguration.LanguageLevel languageLevel) {\n            String s = \"record Point(int x, int y) { }\";\n            assertThrows(AssertionFailedError.class, () -> {\n                CompilationUnit cu = TestParser.parseCompilationUnit(languageLevel, s);\n            });\n        }\n\n        @ParameterizedTest\n        @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_14_PREVIEW\", \"JAVA_15_PREVIEW\", \"JAVA_16\", \"JAVA_16_PREVIEW\"})\n        void basicGrammarCompiles_languageLevelValidation_permitted(ParserConfiguration.LanguageLevel languageLevel) {\n            String s = \"record Point(int x, int y) { }\";\n            CompilationUnit cu = TestParser.parseCompilationUnit(languageLevel, s);\n        }\n\n        @ParameterizedTest\n        @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_14_PREVIEW\", \"JAVA_15_PREVIEW\", \"JAVA_16\", \"JAVA_16_PREVIEW\"})\n        void languageLevelValidation_recordAsTypeIdentifier_permitted(ParserConfiguration.LanguageLevel languageLevel) {\n            String s = \"class record {}\";\n            assertThrows(AssertionFailedError.class, () -> {\n                CompilationUnit cu = TestParser.parseCompilationUnit(languageLevel, s);\n            });\n        }\n\n        @ParameterizedTest\n        @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_13\", \"JAVA_13_PREVIEW\", \"JAVA_14\", \"JAVA_15\"})\n        void languageLevelValidation_recordAsTypeIdentifier_forbidden(ParserConfiguration.LanguageLevel languageLevel) {\n            String s = \"class record {}\";\n            CompilationUnit cu = TestParser.parseCompilationUnit(languageLevel, s);\n        }\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Description\n     */\n    @Test\n    void basicGrammarCompiles() {\n        String s = \"record Point(int x, int y) { }\";\n        assertOneRecordDeclaration(TestParser.parseCompilationUnit(s));\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Description\n     */\n    @Test\n    void basicGrammar() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        RecordDeclaration recordDeclaration = cu.findAll(RecordDeclaration.class).get(0);\n\n        assertTrue(recordDeclaration.isRecordDeclaration());\n        assertTrue(recordDeclaration.getImplementedTypes().isEmpty());\n        assertTrue(recordDeclaration.getTypeParameters().isEmpty());\n        assertTrue(recordDeclaration.getFullyQualifiedName().isPresent());\n        assertEquals(\"Point\", recordDeclaration.getFullyQualifiedName().get());\n        assertTrue(recordDeclaration.isRecordDeclaration());\n\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"x\", parameter0.getNameAsString());\n        assertEquals(\"int\", parameter0.getTypeAsString());\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"y\", parameter1.getNameAsString());\n        assertEquals(\"int\", parameter1.getTypeAsString());\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Description\n     */\n    @Test\n    void basicRecordPrints() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        String expected = \"\" +\n                \"record Point(int x, int y) {\\n\" +\n                \"}\\n\" +\n                \"\";\n        assertEqualsStringIgnoringEol(expected, cu.toString());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-record\n     */\n    @Test\n    void record_cannotExtend() {\n        String s = \"record Point(int x, int y) extends OtherThing { }\";\n        assertCompilationFails(s);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_cannotBeAbstract() {\n        String s = \"abstract record Point(int x, int y) { }\";\n        assertCompilationFails(s);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_mayImplementInterfaces() {\n        String s = \"record Point(int x, int y) implements OtherInterface { }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n\n        assertOneRecordDeclaration(cu);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_mayBeStatic() {\n        String s = \"static record Point(int x, int y) { }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void recordWithVarArgs() {\n        String s = \"record R(T1 c1, Tn... cn){ }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"c1\", parameter0.getNameAsString());\n        assertEquals(\"T1\", parameter0.getTypeAsString());\n        assertFalse(parameter0.isVarArgs());\n\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"cn\", parameter1.getNameAsString());\n        assertEquals(\"Tn\", parameter1.getTypeAsString());\n        assertTrue(parameter1.isVarArgs());\n    }\n\n    @Test\n    void recordWithAnnotationedParameters() {\n        String s = \"record Card(@MyAnno Rank rank, @MyAnno Suit suit) { }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"rank\", parameter0.getNameAsString());\n        assertEquals(\"Rank\", parameter0.getTypeAsString());\n        assertEquals(1, parameter0.getAnnotations().size());\n\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"suit\", parameter1.getNameAsString());\n        assertEquals(\"Suit\", parameter1.getTypeAsString());\n        assertEquals(1, parameter1.getAnnotations().size());\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    @Test\n    void record_emptyMembers() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    @Test\n    void record_permitStaticMethods() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    static public int abc() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_permitMethods() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    public String xyz() {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_forbidNonStaticFields() {\n        String s = \"record Point(int x, int y) { int z; }\";\n        assertCompilationFails(s);\n    }\n\n    @Test\n    void record_permitStaticFields() {\n        String s = \"record Point(int x, int y) { static int z; }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_permitStaticFields2() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    static int z;\\n\" +\n                \"\\n\" +\n                \"    static {\\n\" +\n                \"        int z = 10;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_isImplicitlyFinal() {\n        String s = \"record Point(int x, int y) { static int z; }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        RecordDeclaration recordDeclaration = cu.findFirst(RecordDeclaration.class).get();\n        assertFalse(recordDeclaration.hasModifier(Modifier.Keyword.FINAL));\n        assertTrue(recordDeclaration.isFinal(), \"Records are implicitly final.\");\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_isImplicitlyFinalWithoutExplicit() {\n        String s = \"record Point(int x, int y) { static int z; }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        RecordDeclaration recordDeclaration = cu.findFirst(RecordDeclaration.class).get();\n        assertFalse(recordDeclaration.hasModifier(Modifier.Keyword.FINAL));\n        assertTrue(recordDeclaration.isFinal(), \"Records are implicitly final.\");\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_canHaveGenerics() {\n        String s = \"record Point <T> (T x, int y) { }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        RecordDeclaration recordDeclaration = cu.findFirst(RecordDeclaration.class).get();\n        assertFalse(recordDeclaration.getTypeParameters().isEmpty());\n        assertEquals(\"T\", recordDeclaration.getTypeParameters().get(0).getNameAsString());\n    }\n\n\n    @Test\n    void record_mustNotAllowMismatchedComponentAccessorReturnType() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public String x() {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \"}\";\n        assertCompilationFails(s);\n    }\n\n    @Test\n    void record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public String x(int a) {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \"}\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod2() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public int x(int a) {\\n\" +\n                \"        return 10;\\n\" +\n                \"    }\\n\" +\n                \"}\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_allowComponentAccessorWithMatchingType() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return 10;\\n\" +\n                \"    }\\n\" +\n                \"}\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_allowNestedWithinClass() {\n        String s = \"\\n\" +\n                \"class X {\\n\" +\n                \"    record Point(int x, int y) {\\n\" +\n                \"    }\\n\" +\n                \"}\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_componentsAreImplicitlyFinal() {\n        String s = \"record Point(int x, int y) { }\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        RecordDeclaration recordDeclaration = cu.findAll(RecordDeclaration.class).get(0);\n\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertTrue(parameters.get(0).isFinal());\n        assertTrue(parameters.get(1).isFinal());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_allowClassWithinRecord() {\n        String s = \"\\n\" +\n                \"record Point(int x, int y) {\\n\" +\n                \"    class X {\\n\" +\n                \"    }\\n\" +\n                \"}\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        BodyDeclaration<?> member = recordDeclaration.getMember(0);\n\n        assertTrue(member.isClassOrInterfaceDeclaration());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_allowNestedWithinInterface() {\n        String s = \"\\n\" +\n                \"interface X {\\n\" +\n                \"    record Point(int x, int y) {\\n\" +\n                \"    }\\n\" +\n                \"}\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_allowNestedWithinEnum() {\n        String s = \"\\n\" +\n                \"enum ABC {\\n\" +\n                \"    ABC;\\n\" +\n                \"    \\n\" +\n                \"    record Point(int x, int y) {\\n\" +\n                \"    }\\n\" +\n                \"}\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_allowNestedMultiple() {\n        String s = \"\\n\" +\n                \"interface Y {\\n\" +\n                \"    class X {\\n\" +\n                \"        record Point(int x, int y) {\\n\" +\n                \"        }\\n\" +\n                \"    }\\n\" +\n                \"}\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_allowNestedMultiple2() {\n        String s = \"\\n\" +\n                \"interface Y {\\n\" +\n                \"    class X {\\n\" +\n                \"        record Point(int x, int y) {\\n\" +\n                \"        }\\n\" +\n                \"        record PointB(int x, int y) {\\n\" +\n                \"        }\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    record PointC(int x, int y) {\\n\" +\n                \"    }\\n\" +\n                \"}\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(3, recordDeclarations.size());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_topLevelRecordsAreNotStatic() {\n        String s = \"record Point(int x, int y) { }\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        RecordDeclaration recordDeclaration = cu.findAll(RecordDeclaration.class).get(0);\n        assertFalse(recordDeclaration.hasModifier(Modifier.Keyword.STATIC));\n        assertFalse(recordDeclaration.isStatic(), \"Top level Records are NOT implicitly static.\");\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_nestedRecordsAreImplicitlyStatic() {\n        String s = \"\\n\" +\n                \"class X {\\n\" +\n                \"    record Point(int x, int y) {\\n\" +\n                \"    }\\n\" +\n                \"}\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        RecordDeclaration recordDeclaration = cu.findAll(RecordDeclaration.class).get(0);\n        assertFalse(recordDeclaration.hasModifier(Modifier.Keyword.STATIC));\n        assertTrue(recordDeclaration.isStatic(), \"Nested Records are implicitly static.\");\n\n    }\n\n\n    @Test\n    void record_canBeCreatedUsingKeywordNew() {\n        String s = \"\\n\" +\n                \"\\n\" +\n                \"record Point(int x, int y) {\\n\" +\n                \"}\\n\" +\n                \"\\n\" +\n                \"class X {\\n\" +\n                \"    public static void main(String[] args) {\\n\" +\n                \"        new Point(10, 3);\\n\" +\n                \"    }\\n\" +\n                \"}\\n\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        ClassOrInterfaceDeclaration coid = cu.findAll(ClassOrInterfaceDeclaration.class).get(0);\n        List<ObjectCreationExpr> objectCreationExprs = coid.findAll(ObjectCreationExpr.class);\n\n        assertEquals(1, objectCreationExprs.size());\n        ObjectCreationExpr objectCreationExpr = objectCreationExprs.get(0);\n        assertEquals(\"Point\", objectCreationExpr.getTypeAsString());\n    }\n\n    /**\n     * Note the Record Declaration Constructor does not include parameters.\n     * (parameters are, instead, included within the record declaration)\n     * <p>\n     * https://bugs.openjdk.java.net/browse/JDK-8222777\n     */\n    @Test\n    void recordDeclarationFromTheJDK8222777() {\n        CompilationUnit cu = TestParser.parseCompilationUnit(\"\" +\n                \"public record Range(int lo, int hi) {\\n\" +\n                \"\\n\" +\n                \"  public Range {\\n\" +\n                \"    if (lo > hi)  /* referring here to the implicit constructor parameters */\\n\" +\n                \"      throw new IllegalArgumentException(String.format(\\\"(%d,%d)\\\", lo, hi));\\n\" +\n                \"  }\\n\" +\n                \"}\"\n        );\n\n        RecordDeclaration recordDeclaration = cu.findFirst(RecordDeclaration.class).get();\n        assertThat(recordDeclaration.getNameAsString()).isEqualTo(\"Range\");\n        assertThat(recordDeclaration.getModifiers()).containsExactly(Modifier.publicModifier());\n        // test parameters\n        // get constructor\n        // test parameters (none)\n    }\n\n    @Test\n    void recordDeclaration_exampleFromJls_8_10_4_1_normalCanonicalConstructors() {\n        CompilationUnit cu = TestParser.parseCompilationUnit(\"\" +\n                \"import java.lang.annotation.Target;\\n\" +\n                \"import java.lang.annotation.ElementType;\\n\" +\n                \"\\n\" +\n                \"@interface Foo {}\\n\" +\n                \"@interface Bar {}\\n\" +\n                \"\\n\" +\n                \"record Person(@Foo String name) {\\n\" +\n                \"    Person(String name2) {\\n\" +\n                \"    }\\n\" +\n                \"}\"\n        );\n\n        RecordDeclaration recordDeclaration = cu.findFirst(RecordDeclaration.class).get();\n        assertThat(recordDeclaration.getNameAsString()).isEqualTo(\"Person\");\n        assertThat(recordDeclaration.getModifiers()).isEmpty();\n\n        assertThat(recordDeclaration.getConstructors()).hasSize(1);\n        assertThat(recordDeclaration.getCompactConstructors()).hasSize(0);\n\n    }\n\n    @Test\n    void compactConstructor_exampleFromJls_8_10_4_2_compactConstructors() {\n        CompilationUnit cu = TestParser.parseCompilationUnit(\"\" +\n                \"record Rational(int num, int denom) {\\n\" +\n                \"    private static int gcd(int a, int b) {\\n\" +\n                \"        if (b == 0) return Math.abs(a);\\n\" +\n                \"        else return gcd(b, a % b);\\n\" +\n                \"    }\\n\" +\n                \"   \\n\" +\n                \"    Rational {\\n\" +\n                \"        int gcd = gcd(num, denom);\\n\" +\n                \"        num    /= gcd;\\n\" +\n                \"        denom  /= gcd;\\n\" +\n                \"    }\\n\" +\n                \"}\\n\"\n        );\n\n        RecordDeclaration recordDeclaration = cu.findFirst(RecordDeclaration.class).get();\n        assertThat(recordDeclaration.getNameAsString()).isEqualTo(\"Rational\");\n        assertThat(recordDeclaration.getModifiers()).isEmpty();\n\n        assertThat(recordDeclaration.getConstructors()).hasSize(0);\n        assertThat(recordDeclaration.getCompactConstructors()).hasSize(1);\n\n    }\n\n    @Test\n    void nonCompactConstructor_exampleFromJls_8_10_4_2_compactConstructors() {\n        CompilationUnit cu = TestParser.parseCompilationUnit(\"\" +\n                \"record Rational(int num, int denom) {\\n\" +\n                \"    private static int gcd(int a, int b) {\\n\" +\n                \"        if (b == 0) return Math.abs(a);\\n\" +\n                \"        else return gcd(b, a % b);\\n\" +\n                \"    }\\n\" +\n                \"   \\n\" +\n                \"    Rational(int num, int demon) {\\n\" +\n                \"        int gcd = gcd(num, denom);\\n\" +\n                \"        num    /= gcd;\\n\" +\n                \"        denom  /= gcd;\\n\" +\n                \"        this.num   = num;\\n\" +\n                \"        this.denom = denom;\\n\" +\n                \"    }\\n\" +\n                \"}\\n\"\n        );\n\n        RecordDeclaration recordDeclaration = cu.findFirst(RecordDeclaration.class).get();\n        assertThat(recordDeclaration.getNameAsString()).isEqualTo(\"Rational\");\n        assertThat(recordDeclaration.getModifiers()).isEmpty();\n\n        assertThat(recordDeclaration.getConstructors()).hasSize(1);\n        assertThat(recordDeclaration.getCompactConstructors()).hasSize(0);\n\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395\n     */\n    @Test\n    void localRecords() {\n        CompilationUnit cu = TestParser.parseCompilationUnit(\"\" +\n                \"class Scratch {\\n\" +\n                \"    List<Merchant> findTopMerchants(List<Merchant> merchants, int month) {\\n\" +\n                \"        // Local record\\n\" +\n                \"        record MerchantSales(Merchant merchant, double sales) {}\\n\" +\n                \"\\n\" +\n                \"        return merchants.stream()\\n\" +\n                \"                .map(merchant -> new MerchantSales(merchant, computeSales(merchant, month)))\\n\" +\n                \"                .sorted((m1, m2) -> Double.compare(m2.sales(), m1.sales()))\\n\" +\n                \"                .map(MerchantSales::merchant)\\n\" +\n                \"                .collect(toList());\\n\" +\n                \"    }\\n\" +\n                \"}\\n\"\n        );\n\n        RecordDeclaration recordDeclaration = cu.findFirst(RecordDeclaration.class).get();\n        assertThat(recordDeclaration.getNameAsString()).isEqualTo(\"MerchantSales\");\n\n    }\n\n    private void assertCompilationFails(String s) {\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        });\n    }\n\n    private void assertOneRecordDeclaration(CompilationUnit cu) {\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n}\n",
        "diffSourceCodeSet": [],
        "invokedMethodSet": [],
        "sourceCodeAfterRefactoring": "@ParameterizedTest\n        @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_13\", \"JAVA_13_PREVIEW\", \"JAVA_14\", \"JAVA_15\"})\n        void languageLevelValidation_recordAsTypeIdentifier_forbidden(ParserConfiguration.LanguageLevel languageLevel) {\n            String s = \"class record {}\";\n            CompilationUnit cu = TestParser.parseCompilationUnit(languageLevel, s);\n        }",
        "diffSourceCode": "-   50:     @ParameterizedTest\n-   51:     @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_13\", \"JAVA_13_PREVIEW\", \"JAVA_14\", \"JAVA_15\"})\n-   52:     void languageLevelValidation_recordAsTypeIdentifier_forbidden(ParserConfiguration.LanguageLevel languageLevel) {\n-   53:         String s = \"class record {}\";\n-   54:         CompilationUnit cu = TestParser.parseCompilationUnit(languageLevel, s);\n-   55:     }\n-   56: \n-   57:     /**\n-   58:      * https://openjdk.java.net/jeps/395#Description\n+   50:             });\n+   51:         }\n+   52: \n+   53:         @ParameterizedTest\n+   54:         @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_13\", \"JAVA_13_PREVIEW\", \"JAVA_14\", \"JAVA_15\"})\n+   55:         void languageLevelValidation_recordAsTypeIdentifier_forbidden(ParserConfiguration.LanguageLevel languageLevel) {\n+   56:             String s = \"class record {}\";\n+   57:             CompilationUnit cu = TestParser.parseCompilationUnit(languageLevel, s);\n+   58:         }\n",
        "uniqueId": "9e55bc54539d393e1948c8d4a89b1511ed379fad_50_55__53_58",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "testMethod": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 17
    },
    {
        "type": "Move Method",
        "description": "Move Method\tpackage languageLevelValidation_recordAsTypeIdentifier_permitted(languageLevel ParserConfiguration.LanguageLevel) : void from class com.github.javaparser.ast.body.RecordDeclarationTest to package languageLevelValidation_recordAsTypeIdentifier_permitted(languageLevel ParserConfiguration.LanguageLevel) : void from class com.github.javaparser.ast.body.RecordDeclarationTest.LanguageLevels",
        "diffLocations": [
            {
                "filePath": "javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/RecordDeclarationTest.java",
                "startLine": 41,
                "endLine": 48,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/RecordDeclarationTest.java",
                "startLine": 44,
                "endLine": 51,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "@ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_14_PREVIEW\", \"JAVA_15_PREVIEW\", \"JAVA_16\", \"JAVA_16_PREVIEW\"})\n    void languageLevelValidation_recordAsTypeIdentifier_permitted(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"class record {}\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = TestParser.parseCompilationUnit(languageLevel, s);\n        });\n    }",
        "filePathBefore": "javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/RecordDeclarationTest.java",
        "isPureRefactoring": true,
        "commitId": "9e55bc54539d393e1948c8d4a89b1511ed379fad",
        "packageNameBefore": "com.github.javaparser.ast.body",
        "classNameBefore": "com.github.javaparser.ast.body.RecordDeclarationTest",
        "methodNameBefore": "com.github.javaparser.ast.body.RecordDeclarationTest#languageLevelValidation_recordAsTypeIdentifier_permitted",
        "classSignatureBefore": "public class RecordDeclarationTest ",
        "methodNameBeforeSet": [
            "com.github.javaparser.ast.body.RecordDeclarationTest#languageLevelValidation_recordAsTypeIdentifier_permitted"
        ],
        "classNameBeforeSet": [
            "com.github.javaparser.ast.body.RecordDeclarationTest"
        ],
        "classSignatureBeforeSet": [
            "public class RecordDeclarationTest "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "package com.github.javaparser.ast.body;\n\nimport com.github.javaparser.ParserConfiguration;\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.Modifier;\nimport com.github.javaparser.ast.NodeList;\nimport com.github.javaparser.ast.expr.ObjectCreationExpr;\nimport com.github.javaparser.utils.TestParser;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.EnumSource;\nimport org.opentest4j.AssertionFailedError;\n\nimport java.util.List;\n\nimport static com.github.javaparser.utils.TestUtils.assertEqualsStringIgnoringEol;\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\npublic class RecordDeclarationTest {\n\n    @ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_13\", \"JAVA_13_PREVIEW\", \"JAVA_14\", \"JAVA_15\"})\n    void basicGrammarCompiles_languageLevelValidation_forbidden(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"record Point(int x, int y) { }\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = TestParser.parseCompilationUnit(languageLevel, s);\n        });\n    }\n\n    @ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_14_PREVIEW\", \"JAVA_15_PREVIEW\", \"JAVA_16\", \"JAVA_16_PREVIEW\"})\n    void basicGrammarCompiles_languageLevelValidation_permitted(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(languageLevel, s);\n    }\n\n    @ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_14_PREVIEW\", \"JAVA_15_PREVIEW\", \"JAVA_16\", \"JAVA_16_PREVIEW\"})\n    void languageLevelValidation_recordAsTypeIdentifier_permitted(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"class record {}\";\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = TestParser.parseCompilationUnit(languageLevel, s);\n        });\n    }\n\n    @ParameterizedTest\n    @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_13\", \"JAVA_13_PREVIEW\", \"JAVA_14\", \"JAVA_15\"})\n    void languageLevelValidation_recordAsTypeIdentifier_forbidden(ParserConfiguration.LanguageLevel languageLevel) {\n        String s = \"class record {}\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(languageLevel, s);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Description\n     */\n    @Test\n    void basicGrammarCompiles() {\n        String s = \"record Point(int x, int y) { }\";\n        assertOneRecordDeclaration(TestParser.parseCompilationUnit(s));\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Description\n     */\n    @Test\n    void basicGrammar() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        RecordDeclaration recordDeclaration = cu.findAll(RecordDeclaration.class).get(0);\n\n        assertTrue(recordDeclaration.isRecordDeclaration());\n        assertTrue(recordDeclaration.getImplementedTypes().isEmpty());\n        assertTrue(recordDeclaration.getTypeParameters().isEmpty());\n        assertTrue(recordDeclaration.getFullyQualifiedName().isPresent());\n        assertEquals(\"Point\", recordDeclaration.getFullyQualifiedName().get());\n        assertTrue(recordDeclaration.isRecordDeclaration());\n\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"x\", parameter0.getNameAsString());\n        assertEquals(\"int\", parameter0.getTypeAsString());\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"y\", parameter1.getNameAsString());\n        assertEquals(\"int\", parameter1.getTypeAsString());\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Description\n     */\n    @Test\n    void basicRecordPrints() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        String expected = \"\" +\n                \"record Point(int x, int y) {\\n\" +\n                \"}\\n\" +\n                \"\";\n        assertEqualsStringIgnoringEol(expected, cu.toString());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-record\n     */\n    @Test\n    void record_cannotExtend() {\n        String s = \"record Point(int x, int y) extends OtherThing { }\";\n        assertCompilationFails(s);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_cannotBeAbstract() {\n        String s = \"abstract record Point(int x, int y) { }\";\n        assertCompilationFails(s);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_mayImplementInterfaces() {\n        String s = \"record Point(int x, int y) implements OtherInterface { }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n\n        assertOneRecordDeclaration(cu);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_mayBeStatic() {\n        String s = \"static record Point(int x, int y) { }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void recordWithVarArgs() {\n        String s = \"record R(T1 c1, Tn... cn){ }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"c1\", parameter0.getNameAsString());\n        assertEquals(\"T1\", parameter0.getTypeAsString());\n        assertFalse(parameter0.isVarArgs());\n\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"cn\", parameter1.getNameAsString());\n        assertEquals(\"Tn\", parameter1.getTypeAsString());\n        assertTrue(parameter1.isVarArgs());\n    }\n\n    @Test\n    void recordWithAnnotationedParameters() {\n        String s = \"record Card(@MyAnno Rank rank, @MyAnno Suit suit) { }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"rank\", parameter0.getNameAsString());\n        assertEquals(\"Rank\", parameter0.getTypeAsString());\n        assertEquals(1, parameter0.getAnnotations().size());\n\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"suit\", parameter1.getNameAsString());\n        assertEquals(\"Suit\", parameter1.getTypeAsString());\n        assertEquals(1, parameter1.getAnnotations().size());\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    @Test\n    void record_emptyMembers() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    @Test\n    void record_permitStaticFields() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    static int z;\\n\" +\n                \"\\n\" +\n                \"    static {\\n\" +\n                \"        int z = 10;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_permitStaticMethods() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    static public int abc() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_permitMethods() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    public String xyz() {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_mustNotAllowNonStaticFields() {\n        String s = \"record Point(int x, int y) { int z; }\";\n        assertCompilationFails(s);\n    }\n\n    @Test\n    void record_mustAllowStaticFields() {\n        String s = \"record Point(int x, int y) { static int z; }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_isImplicitlyFinal() {\n        String s = \"record Point(int x, int y) { static int z; }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        RecordDeclaration recordDeclaration = cu.findFirst(RecordDeclaration.class).get();\n        assertFalse(recordDeclaration.hasModifier(Modifier.Keyword.FINAL));\n        assertTrue(recordDeclaration.isFinal(), \"Records are implicitly final.\");\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_canHaveGenerics() {\n        String s = \"record Point <T> (T x, int y) { }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        RecordDeclaration recordDeclaration = cu.findFirst(RecordDeclaration.class).get();\n        assertFalse(recordDeclaration.getTypeParameters().isEmpty());\n        assertEquals(\"T\", recordDeclaration.getTypeParameters().get(0).getNameAsString());\n    }\n\n\n    @Test\n    void record_mustNotAllowMismatchedComponentAccessorReturnType() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public String x() {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \"}\";\n        assertCompilationFails(s);\n    }\n\n    @Test\n    void record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public String x(int a) {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \"}\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod2() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public int x(int a) {\\n\" +\n                \"        return 10;\\n\" +\n                \"    }\\n\" +\n                \"}\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_allowComponentAccessorWithMatchingType() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return 10;\\n\" +\n                \"    }\\n\" +\n                \"}\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_allowNestedWithinClass() {\n        String s = \"\\n\" +\n                \"class X {\\n\" +\n                \"    record Point(int x, int y) {\\n\" +\n                \"    }\\n\" +\n                \"}\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_componentsAreImplicitlyFinal() {\n        String s = \"record Point(int x, int y) { }\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        RecordDeclaration recordDeclaration = cu.findAll(RecordDeclaration.class).get(0);\n\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertTrue(parameters.get(0).isFinal());\n        assertTrue(parameters.get(1).isFinal());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_allowClassWithinRecord() {\n        String s = \"\\n\" +\n                \"record Point(int x, int y) {\\n\" +\n                \"    class X {\\n\" +\n                \"    }\\n\" +\n                \"}\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        BodyDeclaration<?> member = recordDeclaration.getMember(0);\n\n        assertTrue(member.isClassOrInterfaceDeclaration());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_allowNestedWithinInterface() {\n        String s = \"\\n\" +\n                \"interface X {\\n\" +\n                \"    record Point(int x, int y) {\\n\" +\n                \"    }\\n\" +\n                \"}\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_allowNestedWithinEnum() {\n        String s = \"\\n\" +\n                \"enum ABC {\\n\" +\n                \"    ABC;\\n\" +\n                \"    \\n\" +\n                \"    record Point(int x, int y) {\\n\" +\n                \"    }\\n\" +\n                \"}\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_allowNestedMultiple() {\n        String s = \"\\n\" +\n                \"interface Y {\\n\" +\n                \"    class X {\\n\" +\n                \"        record Point(int x, int y) {\\n\" +\n                \"        }\\n\" +\n                \"    }\\n\" +\n                \"}\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_allowNestedMultiple2() {\n        String s = \"\\n\" +\n                \"interface Y {\\n\" +\n                \"    class X {\\n\" +\n                \"        record Point(int x, int y) {\\n\" +\n                \"        }\\n\" +\n                \"        record PointB(int x, int y) {\\n\" +\n                \"        }\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    record PointC(int x, int y) {\\n\" +\n                \"    }\\n\" +\n                \"}\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(3, recordDeclarations.size());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_topLevelRecordsAreNotStatic() {\n        String s = \"record Point(int x, int y) { }\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        RecordDeclaration recordDeclaration = cu.findAll(RecordDeclaration.class).get(0);\n        assertFalse(recordDeclaration.hasModifier(Modifier.Keyword.STATIC));\n        assertFalse(recordDeclaration.isStatic(), \"Top level Records are NOT implicitly static.\");\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_nestedRecordsAreImplicitlyStatic() {\n        String s = \"\\n\" +\n                \"class X {\\n\" +\n                \"    record Point(int x, int y) {\\n\" +\n                \"    }\\n\" +\n                \"}\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        RecordDeclaration recordDeclaration = cu.findAll(RecordDeclaration.class).get(0);\n        assertFalse(recordDeclaration.hasModifier(Modifier.Keyword.STATIC));\n        assertTrue(recordDeclaration.isStatic(), \"Nested Records are implicitly static.\");\n\n    }\n\n\n    @Test\n    void record_canBeCreatedUsingKeywordNew() {\n        String s = \"\\n\" +\n                \"\\n\" +\n                \"record Point(int x, int y) {\\n\" +\n                \"}\\n\" +\n                \"\\n\" +\n                \"class X {\\n\" +\n                \"    public static void main(String[] args) {\\n\" +\n                \"        new Point(10, 3);\\n\" +\n                \"    }\\n\" +\n                \"}\\n\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        ClassOrInterfaceDeclaration coid = cu.findAll(ClassOrInterfaceDeclaration.class).get(0);\n        List<ObjectCreationExpr> objectCreationExprs = coid.findAll(ObjectCreationExpr.class);\n\n        assertEquals(1, objectCreationExprs.size());\n        ObjectCreationExpr objectCreationExpr = objectCreationExprs.get(0);\n        assertEquals(\"Point\", objectCreationExpr.getTypeAsString());\n    }\n\n    /**\n     * Note the Record Declaration Constructor does not include parameters.\n     * (parameters are, instead, included within the record declaration)\n     * <p>\n     * https://bugs.openjdk.java.net/browse/JDK-8222777\n     */\n    @Test\n    void recordDeclarationFromTheJDK8222777() {\n        CompilationUnit cu = TestParser.parseCompilationUnit(\"\" +\n                \"public record Range(int lo, int hi) {\\n\" +\n                \"\\n\" +\n                \"  public Range {\\n\" +\n                \"    if (lo > hi)  /* referring here to the implicit constructor parameters */\\n\" +\n                \"      throw new IllegalArgumentException(String.format(\\\"(%d,%d)\\\", lo, hi));\\n\" +\n                \"  }\\n\" +\n                \"}\"\n        );\n\n        RecordDeclaration recordDeclaration = cu.findFirst(RecordDeclaration.class).get();\n        assertThat(recordDeclaration.getNameAsString()).isEqualTo(\"Range\");\n        assertThat(recordDeclaration.getModifiers()).containsExactly(Modifier.publicModifier());\n        // test parameters\n        // get constructor\n        // test parameters (none)\n    }\n\n    @Test\n    void recordDeclaration_exampleFromJls_8_10_4_1_normalCanonicalConstructors() {\n        CompilationUnit cu = TestParser.parseCompilationUnit(\"\" +\n                \"import java.lang.annotation.Target;\\n\" +\n                \"import java.lang.annotation.ElementType;\\n\" +\n                \"\\n\" +\n                \"@interface Foo {}\\n\" +\n                \"@interface Bar {}\\n\" +\n                \"\\n\" +\n                \"record Person(@Foo String name) {\\n\" +\n                \"    Person(String name2) {\\n\" +\n                \"    }\\n\" +\n                \"}\"\n        );\n\n        RecordDeclaration recordDeclaration = cu.findFirst(RecordDeclaration.class).get();\n        assertThat(recordDeclaration.getNameAsString()).isEqualTo(\"Person\");\n        assertThat(recordDeclaration.getModifiers()).isEmpty();\n\n        assertThat(recordDeclaration.getConstructors()).hasSize(1);\n        assertThat(recordDeclaration.getCompactConstructors()).hasSize(0);\n\n        // test parameters\n        // get constructor\n        // test parameters (none)\n\n    }\n\n    @Test\n    void compactConstructor_exampleFromJls_8_10_4_2_compactConstructors() {\n        CompilationUnit cu = TestParser.parseCompilationUnit(\"\" +\n                \"record Rational(int num, int denom) {\\n\" +\n                \"    private static int gcd(int a, int b) {\\n\" +\n                \"        if (b == 0) return Math.abs(a);\\n\" +\n                \"        else return gcd(b, a % b);\\n\" +\n                \"    }\\n\" +\n                \"   \\n\" +\n                \"    Rational {\\n\" +\n                \"        int gcd = gcd(num, denom);\\n\" +\n                \"        num    /= gcd;\\n\" +\n                \"        denom  /= gcd;\\n\" +\n                \"    }\\n\" +\n                \"}\\n\"\n        );\n\n        RecordDeclaration recordDeclaration = cu.findFirst(RecordDeclaration.class).get();\n        assertThat(recordDeclaration.getNameAsString()).isEqualTo(\"Rational\");\n        assertThat(recordDeclaration.getModifiers()).isEmpty();\n\n        assertThat(recordDeclaration.getConstructors()).hasSize(0);\n        assertThat(recordDeclaration.getCompactConstructors()).hasSize(1);\n\n        // test parameters\n        // get constructor\n        // test parameters (none)\n\n    }\n\n    @Test\n    void nonCompactConstructor_exampleFromJls_8_10_4_2_compactConstructors() {\n        CompilationUnit cu = TestParser.parseCompilationUnit(\"\" +\n                \"record Rational(int num, int denom) {\\n\" +\n                \"    private static int gcd(int a, int b) {\\n\" +\n                \"        if (b == 0) return Math.abs(a);\\n\" +\n                \"        else return gcd(b, a % b);\\n\" +\n                \"    }\\n\" +\n                \"   \\n\" +\n                \"    Rational(int num, int demon) {\\n\" +\n                \"        int gcd = gcd(num, denom);\\n\" +\n                \"        num    /= gcd;\\n\" +\n                \"        denom  /= gcd;\\n\" +\n                \"        this.num   = num;\\n\" +\n                \"        this.denom = denom;\\n\" +\n                \"    }\\n\" +\n                \"}\\n\"\n        );\n\n        RecordDeclaration recordDeclaration = cu.findFirst(RecordDeclaration.class).get();\n        assertThat(recordDeclaration.getNameAsString()).isEqualTo(\"Rational\");\n        assertThat(recordDeclaration.getModifiers()).isEmpty();\n\n        assertThat(recordDeclaration.getConstructors()).hasSize(1);\n        assertThat(recordDeclaration.getCompactConstructors()).hasSize(0);\n\n        // test parameters\n        // get constructor\n        // test parameters (none)\n\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395\n     */\n    @Test\n    void localRecords() {\n        CompilationUnit cu = TestParser.parseCompilationUnit(\"\" +\n                \"class Scratch {\\n\" +\n                \"    List<Merchant> findTopMerchants(List<Merchant> merchants, int month) {\\n\" +\n                \"        // Local record\\n\" +\n                \"        record MerchantSales(Merchant merchant, double sales) {}\\n\" +\n                \"\\n\" +\n                \"        return merchants.stream()\\n\" +\n                \"                .map(merchant -> new MerchantSales(merchant, computeSales(merchant, month)))\\n\" +\n                \"                .sorted((m1, m2) -> Double.compare(m2.sales(), m1.sales()))\\n\" +\n                \"                .map(MerchantSales::merchant)\\n\" +\n                \"                .collect(toList());\\n\" +\n                \"    }\\n\" +\n                \"}\\n\"\n        );\n\n        RecordDeclaration recordDeclaration = cu.findFirst(RecordDeclaration.class).get();\n        assertThat(recordDeclaration.getNameAsString()).isEqualTo(\"MerchantSales\");\n\n    }\n\n    private void assertCompilationFails(String s) {\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        });\n    }\n\n    private void assertOneRecordDeclaration(CompilationUnit cu) {\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n}\n",
        "filePathAfter": "javaparser-core-testing/src/test/java/com/github/javaparser/ast/body/RecordDeclarationTest.java",
        "sourceCodeAfterForWhole": "package com.github.javaparser.ast.body;\n\nimport com.github.javaparser.ParserConfiguration;\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.Modifier;\nimport com.github.javaparser.ast.NodeList;\nimport com.github.javaparser.ast.expr.ObjectCreationExpr;\nimport com.github.javaparser.utils.TestParser;\nimport org.junit.jupiter.api.Nested;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.EnumSource;\nimport org.opentest4j.AssertionFailedError;\n\nimport java.util.List;\n\nimport static com.github.javaparser.utils.TestUtils.assertEqualsStringIgnoringEol;\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\npublic class RecordDeclarationTest {\n\n    @Nested\n    class LanguageLevels {\n        @ParameterizedTest\n        @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_13\", \"JAVA_13_PREVIEW\", \"JAVA_14\", \"JAVA_15\"})\n        void basicGrammarCompiles_languageLevelValidation_forbidden(ParserConfiguration.LanguageLevel languageLevel) {\n            String s = \"record Point(int x, int y) { }\";\n            assertThrows(AssertionFailedError.class, () -> {\n                CompilationUnit cu = TestParser.parseCompilationUnit(languageLevel, s);\n            });\n        }\n\n        @ParameterizedTest\n        @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_14_PREVIEW\", \"JAVA_15_PREVIEW\", \"JAVA_16\", \"JAVA_16_PREVIEW\"})\n        void basicGrammarCompiles_languageLevelValidation_permitted(ParserConfiguration.LanguageLevel languageLevel) {\n            String s = \"record Point(int x, int y) { }\";\n            CompilationUnit cu = TestParser.parseCompilationUnit(languageLevel, s);\n        }\n\n        @ParameterizedTest\n        @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_14_PREVIEW\", \"JAVA_15_PREVIEW\", \"JAVA_16\", \"JAVA_16_PREVIEW\"})\n        void languageLevelValidation_recordAsTypeIdentifier_permitted(ParserConfiguration.LanguageLevel languageLevel) {\n            String s = \"class record {}\";\n            assertThrows(AssertionFailedError.class, () -> {\n                CompilationUnit cu = TestParser.parseCompilationUnit(languageLevel, s);\n            });\n        }\n\n        @ParameterizedTest\n        @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_13\", \"JAVA_13_PREVIEW\", \"JAVA_14\", \"JAVA_15\"})\n        void languageLevelValidation_recordAsTypeIdentifier_forbidden(ParserConfiguration.LanguageLevel languageLevel) {\n            String s = \"class record {}\";\n            CompilationUnit cu = TestParser.parseCompilationUnit(languageLevel, s);\n        }\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Description\n     */\n    @Test\n    void basicGrammarCompiles() {\n        String s = \"record Point(int x, int y) { }\";\n        assertOneRecordDeclaration(TestParser.parseCompilationUnit(s));\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Description\n     */\n    @Test\n    void basicGrammar() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        RecordDeclaration recordDeclaration = cu.findAll(RecordDeclaration.class).get(0);\n\n        assertTrue(recordDeclaration.isRecordDeclaration());\n        assertTrue(recordDeclaration.getImplementedTypes().isEmpty());\n        assertTrue(recordDeclaration.getTypeParameters().isEmpty());\n        assertTrue(recordDeclaration.getFullyQualifiedName().isPresent());\n        assertEquals(\"Point\", recordDeclaration.getFullyQualifiedName().get());\n        assertTrue(recordDeclaration.isRecordDeclaration());\n\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"x\", parameter0.getNameAsString());\n        assertEquals(\"int\", parameter0.getTypeAsString());\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"y\", parameter1.getNameAsString());\n        assertEquals(\"int\", parameter1.getTypeAsString());\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Description\n     */\n    @Test\n    void basicRecordPrints() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        String expected = \"\" +\n                \"record Point(int x, int y) {\\n\" +\n                \"}\\n\" +\n                \"\";\n        assertEqualsStringIgnoringEol(expected, cu.toString());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-record\n     */\n    @Test\n    void record_cannotExtend() {\n        String s = \"record Point(int x, int y) extends OtherThing { }\";\n        assertCompilationFails(s);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_cannotBeAbstract() {\n        String s = \"abstract record Point(int x, int y) { }\";\n        assertCompilationFails(s);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_mayImplementInterfaces() {\n        String s = \"record Point(int x, int y) implements OtherInterface { }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n\n        assertOneRecordDeclaration(cu);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_mayBeStatic() {\n        String s = \"static record Point(int x, int y) { }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void recordWithVarArgs() {\n        String s = \"record R(T1 c1, Tn... cn){ }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"c1\", parameter0.getNameAsString());\n        assertEquals(\"T1\", parameter0.getTypeAsString());\n        assertFalse(parameter0.isVarArgs());\n\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"cn\", parameter1.getNameAsString());\n        assertEquals(\"Tn\", parameter1.getTypeAsString());\n        assertTrue(parameter1.isVarArgs());\n    }\n\n    @Test\n    void recordWithAnnotationedParameters() {\n        String s = \"record Card(@MyAnno Rank rank, @MyAnno Suit suit) { }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertEquals(2, parameters.size());\n\n        Parameter parameter0 = parameters.get(0);\n        assertEquals(\"rank\", parameter0.getNameAsString());\n        assertEquals(\"Rank\", parameter0.getTypeAsString());\n        assertEquals(1, parameter0.getAnnotations().size());\n\n        Parameter parameter1 = parameters.get(1);\n        assertEquals(\"suit\", parameter1.getNameAsString());\n        assertEquals(\"Suit\", parameter1.getTypeAsString());\n        assertEquals(1, parameter1.getAnnotations().size());\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    @Test\n    void record_emptyMembers() {\n        String s = \"record Point(int x, int y) { }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n\n        assertEquals(0, recordDeclaration.getMembers().size());\n    }\n\n    @Test\n    void record_permitStaticMethods() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    static public int abc() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_permitMethods() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    public String xyz() {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_forbidNonStaticFields() {\n        String s = \"record Point(int x, int y) { int z; }\";\n        assertCompilationFails(s);\n    }\n\n    @Test\n    void record_permitStaticFields() {\n        String s = \"record Point(int x, int y) { static int z; }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_permitStaticFields2() {\n        String s = \"\" +\n                \"record ABC(int x, int y) {\\n\" +\n                \"\\n\" +\n                \"    static int z;\\n\" +\n                \"\\n\" +\n                \"    static {\\n\" +\n                \"        int z = 10;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return x;\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"}\\n\" +\n                \"\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_isImplicitlyFinal() {\n        String s = \"record Point(int x, int y) { static int z; }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        RecordDeclaration recordDeclaration = cu.findFirst(RecordDeclaration.class).get();\n        assertFalse(recordDeclaration.hasModifier(Modifier.Keyword.FINAL));\n        assertTrue(recordDeclaration.isFinal(), \"Records are implicitly final.\");\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_isImplicitlyFinalWithoutExplicit() {\n        String s = \"record Point(int x, int y) { static int z; }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        RecordDeclaration recordDeclaration = cu.findFirst(RecordDeclaration.class).get();\n        assertFalse(recordDeclaration.hasModifier(Modifier.Keyword.FINAL));\n        assertTrue(recordDeclaration.isFinal(), \"Records are implicitly final.\");\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_canHaveGenerics() {\n        String s = \"record Point <T> (T x, int y) { }\";\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        RecordDeclaration recordDeclaration = cu.findFirst(RecordDeclaration.class).get();\n        assertFalse(recordDeclaration.getTypeParameters().isEmpty());\n        assertEquals(\"T\", recordDeclaration.getTypeParameters().get(0).getNameAsString());\n    }\n\n\n    @Test\n    void record_mustNotAllowMismatchedComponentAccessorReturnType() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public String x() {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \"}\";\n        assertCompilationFails(s);\n    }\n\n    @Test\n    void record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public String x(int a) {\\n\" +\n                \"        return \\\"10\\\";\\n\" +\n                \"    }\\n\" +\n                \"}\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_allowMethodsWithSameNameAsRecordComponentButNotAnAccessorMethod2() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public int x(int a) {\\n\" +\n                \"        return 10;\\n\" +\n                \"    }\\n\" +\n                \"}\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    @Test\n    void record_allowComponentAccessorWithMatchingType() {\n        String s = \"record Point(int x, int y) {\\n\" +\n                \"    public int x() {\\n\" +\n                \"        return 10;\\n\" +\n                \"    }\\n\" +\n                \"}\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_allowNestedWithinClass() {\n        String s = \"\\n\" +\n                \"class X {\\n\" +\n                \"    record Point(int x, int y) {\\n\" +\n                \"    }\\n\" +\n                \"}\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_componentsAreImplicitlyFinal() {\n        String s = \"record Point(int x, int y) { }\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        RecordDeclaration recordDeclaration = cu.findAll(RecordDeclaration.class).get(0);\n\n        NodeList<Parameter> parameters = recordDeclaration.getParameters();\n        assertTrue(parameters.get(0).isFinal());\n        assertTrue(parameters.get(1).isFinal());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_allowClassWithinRecord() {\n        String s = \"\\n\" +\n                \"record Point(int x, int y) {\\n\" +\n                \"    class X {\\n\" +\n                \"    }\\n\" +\n                \"}\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n\n        RecordDeclaration recordDeclaration = recordDeclarations.get(0);\n        BodyDeclaration<?> member = recordDeclaration.getMember(0);\n\n        assertTrue(member.isClassOrInterfaceDeclaration());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_allowNestedWithinInterface() {\n        String s = \"\\n\" +\n                \"interface X {\\n\" +\n                \"    record Point(int x, int y) {\\n\" +\n                \"    }\\n\" +\n                \"}\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_allowNestedWithinEnum() {\n        String s = \"\\n\" +\n                \"enum ABC {\\n\" +\n                \"    ABC;\\n\" +\n                \"    \\n\" +\n                \"    record Point(int x, int y) {\\n\" +\n                \"    }\\n\" +\n                \"}\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_allowNestedMultiple() {\n        String s = \"\\n\" +\n                \"interface Y {\\n\" +\n                \"    class X {\\n\" +\n                \"        record Point(int x, int y) {\\n\" +\n                \"        }\\n\" +\n                \"    }\\n\" +\n                \"}\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_allowNestedMultiple2() {\n        String s = \"\\n\" +\n                \"interface Y {\\n\" +\n                \"    class X {\\n\" +\n                \"        record Point(int x, int y) {\\n\" +\n                \"        }\\n\" +\n                \"        record PointB(int x, int y) {\\n\" +\n                \"        }\\n\" +\n                \"    }\\n\" +\n                \"\\n\" +\n                \"    record PointC(int x, int y) {\\n\" +\n                \"    }\\n\" +\n                \"}\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(3, recordDeclarations.size());\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_topLevelRecordsAreNotStatic() {\n        String s = \"record Point(int x, int y) { }\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        RecordDeclaration recordDeclaration = cu.findAll(RecordDeclaration.class).get(0);\n        assertFalse(recordDeclaration.hasModifier(Modifier.Keyword.STATIC));\n        assertFalse(recordDeclaration.isStatic(), \"Top level Records are NOT implicitly static.\");\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395#Restrictions-on-records\n     */\n    @Test\n    void record_nestedRecordsAreImplicitlyStatic() {\n        String s = \"\\n\" +\n                \"class X {\\n\" +\n                \"    record Point(int x, int y) {\\n\" +\n                \"    }\\n\" +\n                \"}\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        RecordDeclaration recordDeclaration = cu.findAll(RecordDeclaration.class).get(0);\n        assertFalse(recordDeclaration.hasModifier(Modifier.Keyword.STATIC));\n        assertTrue(recordDeclaration.isStatic(), \"Nested Records are implicitly static.\");\n\n    }\n\n\n    @Test\n    void record_canBeCreatedUsingKeywordNew() {\n        String s = \"\\n\" +\n                \"\\n\" +\n                \"record Point(int x, int y) {\\n\" +\n                \"}\\n\" +\n                \"\\n\" +\n                \"class X {\\n\" +\n                \"    public static void main(String[] args) {\\n\" +\n                \"        new Point(10, 3);\\n\" +\n                \"    }\\n\" +\n                \"}\\n\\n\";\n\n        CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        assertOneRecordDeclaration(cu);\n\n        ClassOrInterfaceDeclaration coid = cu.findAll(ClassOrInterfaceDeclaration.class).get(0);\n        List<ObjectCreationExpr> objectCreationExprs = coid.findAll(ObjectCreationExpr.class);\n\n        assertEquals(1, objectCreationExprs.size());\n        ObjectCreationExpr objectCreationExpr = objectCreationExprs.get(0);\n        assertEquals(\"Point\", objectCreationExpr.getTypeAsString());\n    }\n\n    /**\n     * Note the Record Declaration Constructor does not include parameters.\n     * (parameters are, instead, included within the record declaration)\n     * <p>\n     * https://bugs.openjdk.java.net/browse/JDK-8222777\n     */\n    @Test\n    void recordDeclarationFromTheJDK8222777() {\n        CompilationUnit cu = TestParser.parseCompilationUnit(\"\" +\n                \"public record Range(int lo, int hi) {\\n\" +\n                \"\\n\" +\n                \"  public Range {\\n\" +\n                \"    if (lo > hi)  /* referring here to the implicit constructor parameters */\\n\" +\n                \"      throw new IllegalArgumentException(String.format(\\\"(%d,%d)\\\", lo, hi));\\n\" +\n                \"  }\\n\" +\n                \"}\"\n        );\n\n        RecordDeclaration recordDeclaration = cu.findFirst(RecordDeclaration.class).get();\n        assertThat(recordDeclaration.getNameAsString()).isEqualTo(\"Range\");\n        assertThat(recordDeclaration.getModifiers()).containsExactly(Modifier.publicModifier());\n        // test parameters\n        // get constructor\n        // test parameters (none)\n    }\n\n    @Test\n    void recordDeclaration_exampleFromJls_8_10_4_1_normalCanonicalConstructors() {\n        CompilationUnit cu = TestParser.parseCompilationUnit(\"\" +\n                \"import java.lang.annotation.Target;\\n\" +\n                \"import java.lang.annotation.ElementType;\\n\" +\n                \"\\n\" +\n                \"@interface Foo {}\\n\" +\n                \"@interface Bar {}\\n\" +\n                \"\\n\" +\n                \"record Person(@Foo String name) {\\n\" +\n                \"    Person(String name2) {\\n\" +\n                \"    }\\n\" +\n                \"}\"\n        );\n\n        RecordDeclaration recordDeclaration = cu.findFirst(RecordDeclaration.class).get();\n        assertThat(recordDeclaration.getNameAsString()).isEqualTo(\"Person\");\n        assertThat(recordDeclaration.getModifiers()).isEmpty();\n\n        assertThat(recordDeclaration.getConstructors()).hasSize(1);\n        assertThat(recordDeclaration.getCompactConstructors()).hasSize(0);\n\n    }\n\n    @Test\n    void compactConstructor_exampleFromJls_8_10_4_2_compactConstructors() {\n        CompilationUnit cu = TestParser.parseCompilationUnit(\"\" +\n                \"record Rational(int num, int denom) {\\n\" +\n                \"    private static int gcd(int a, int b) {\\n\" +\n                \"        if (b == 0) return Math.abs(a);\\n\" +\n                \"        else return gcd(b, a % b);\\n\" +\n                \"    }\\n\" +\n                \"   \\n\" +\n                \"    Rational {\\n\" +\n                \"        int gcd = gcd(num, denom);\\n\" +\n                \"        num    /= gcd;\\n\" +\n                \"        denom  /= gcd;\\n\" +\n                \"    }\\n\" +\n                \"}\\n\"\n        );\n\n        RecordDeclaration recordDeclaration = cu.findFirst(RecordDeclaration.class).get();\n        assertThat(recordDeclaration.getNameAsString()).isEqualTo(\"Rational\");\n        assertThat(recordDeclaration.getModifiers()).isEmpty();\n\n        assertThat(recordDeclaration.getConstructors()).hasSize(0);\n        assertThat(recordDeclaration.getCompactConstructors()).hasSize(1);\n\n    }\n\n    @Test\n    void nonCompactConstructor_exampleFromJls_8_10_4_2_compactConstructors() {\n        CompilationUnit cu = TestParser.parseCompilationUnit(\"\" +\n                \"record Rational(int num, int denom) {\\n\" +\n                \"    private static int gcd(int a, int b) {\\n\" +\n                \"        if (b == 0) return Math.abs(a);\\n\" +\n                \"        else return gcd(b, a % b);\\n\" +\n                \"    }\\n\" +\n                \"   \\n\" +\n                \"    Rational(int num, int demon) {\\n\" +\n                \"        int gcd = gcd(num, denom);\\n\" +\n                \"        num    /= gcd;\\n\" +\n                \"        denom  /= gcd;\\n\" +\n                \"        this.num   = num;\\n\" +\n                \"        this.denom = denom;\\n\" +\n                \"    }\\n\" +\n                \"}\\n\"\n        );\n\n        RecordDeclaration recordDeclaration = cu.findFirst(RecordDeclaration.class).get();\n        assertThat(recordDeclaration.getNameAsString()).isEqualTo(\"Rational\");\n        assertThat(recordDeclaration.getModifiers()).isEmpty();\n\n        assertThat(recordDeclaration.getConstructors()).hasSize(1);\n        assertThat(recordDeclaration.getCompactConstructors()).hasSize(0);\n\n    }\n\n    /**\n     * https://openjdk.java.net/jeps/395\n     */\n    @Test\n    void localRecords() {\n        CompilationUnit cu = TestParser.parseCompilationUnit(\"\" +\n                \"class Scratch {\\n\" +\n                \"    List<Merchant> findTopMerchants(List<Merchant> merchants, int month) {\\n\" +\n                \"        // Local record\\n\" +\n                \"        record MerchantSales(Merchant merchant, double sales) {}\\n\" +\n                \"\\n\" +\n                \"        return merchants.stream()\\n\" +\n                \"                .map(merchant -> new MerchantSales(merchant, computeSales(merchant, month)))\\n\" +\n                \"                .sorted((m1, m2) -> Double.compare(m2.sales(), m1.sales()))\\n\" +\n                \"                .map(MerchantSales::merchant)\\n\" +\n                \"                .collect(toList());\\n\" +\n                \"    }\\n\" +\n                \"}\\n\"\n        );\n\n        RecordDeclaration recordDeclaration = cu.findFirst(RecordDeclaration.class).get();\n        assertThat(recordDeclaration.getNameAsString()).isEqualTo(\"MerchantSales\");\n\n    }\n\n    private void assertCompilationFails(String s) {\n        assertThrows(AssertionFailedError.class, () -> {\n            CompilationUnit cu = TestParser.parseCompilationUnit(s);\n        });\n    }\n\n    private void assertOneRecordDeclaration(CompilationUnit cu) {\n        List<RecordDeclaration> recordDeclarations = cu.findAll(RecordDeclaration.class);\n        assertEquals(1, recordDeclarations.size());\n    }\n}\n",
        "diffSourceCodeSet": [],
        "invokedMethodSet": [],
        "sourceCodeAfterRefactoring": "@ParameterizedTest\n        @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_14_PREVIEW\", \"JAVA_15_PREVIEW\", \"JAVA_16\", \"JAVA_16_PREVIEW\"})\n        void languageLevelValidation_recordAsTypeIdentifier_permitted(ParserConfiguration.LanguageLevel languageLevel) {\n            String s = \"class record {}\";\n            assertThrows(AssertionFailedError.class, () -> {\n                CompilationUnit cu = TestParser.parseCompilationUnit(languageLevel, s);\n            });\n        }",
        "diffSourceCode": "-   41:     @ParameterizedTest\n-   42:     @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_14_PREVIEW\", \"JAVA_15_PREVIEW\", \"JAVA_16\", \"JAVA_16_PREVIEW\"})\n-   43:     void languageLevelValidation_recordAsTypeIdentifier_permitted(ParserConfiguration.LanguageLevel languageLevel) {\n-   44:         String s = \"class record {}\";\n-   45:         assertThrows(AssertionFailedError.class, () -> {\n-   46:             CompilationUnit cu = TestParser.parseCompilationUnit(languageLevel, s);\n-   47:         });\n-   48:     }\n-   49: \n-   50:     @ParameterizedTest\n-   51:     @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_13\", \"JAVA_13_PREVIEW\", \"JAVA_14\", \"JAVA_15\"})\n+   41:             CompilationUnit cu = TestParser.parseCompilationUnit(languageLevel, s);\n+   42:         }\n+   43: \n+   44:         @ParameterizedTest\n+   45:         @EnumSource(value = ParserConfiguration.LanguageLevel.class, names = {\"JAVA_14_PREVIEW\", \"JAVA_15_PREVIEW\", \"JAVA_16\", \"JAVA_16_PREVIEW\"})\n+   46:         void languageLevelValidation_recordAsTypeIdentifier_permitted(ParserConfiguration.LanguageLevel languageLevel) {\n+   47:             String s = \"class record {}\";\n+   48:             assertThrows(AssertionFailedError.class, () -> {\n+   49:                 CompilationUnit cu = TestParser.parseCompilationUnit(languageLevel, s);\n+   50:             });\n+   51:         }\n",
        "uniqueId": "9e55bc54539d393e1948c8d4a89b1511ed379fad_41_48__44_51",
        "moveFileExist": true,
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 17,
        "testResult": true,
        "coverageInfo": {
            "testMethod": {
                "missed": 0,
                "covered": 1
            }
        }
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprivate parametrizedTypeUpperBounded(type String, parameterType String) : ResolvedTypeVariable extracted from private parametrizedType(type String, parameterType String) : ResolvedTypeVariable in class com.github.javaparser.symbolsolver.model.typesystem.ReferenceTypeTest",
        "diffLocations": [
            {
                "filePath": "javaparser-symbol-solver-testing/src/test/java/com/github/javaparser/symbolsolver/model/typesystem/ReferenceTypeTest.java",
                "startLine": 955,
                "endLine": 958,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "javaparser-symbol-solver-testing/src/test/java/com/github/javaparser/symbolsolver/model/typesystem/ReferenceTypeTest.java",
                "startLine": 971,
                "endLine": 973,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "javaparser-symbol-solver-testing/src/test/java/com/github/javaparser/symbolsolver/model/typesystem/ReferenceTypeTest.java",
                "startLine": 975,
                "endLine": 978,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "private ResolvedTypeVariable parametrizedType(String type, String parameterType) {\n        return new ResolvedTypeVariable(ResolvedTypeParameterDeclaration.onType(parameterType, type + \".\" + parameterType,\n                Arrays.asList((extendBound(parameterType)))));\n    }",
        "filePathBefore": "javaparser-symbol-solver-testing/src/test/java/com/github/javaparser/symbolsolver/model/typesystem/ReferenceTypeTest.java",
        "isPureRefactoring": true,
        "commitId": "cc159998ac7c83234e2665cbc479f85dcc27f5d0",
        "packageNameBefore": "com.github.javaparser.symbolsolver.model.typesystem",
        "classNameBefore": "com.github.javaparser.symbolsolver.model.typesystem.ReferenceTypeTest",
        "methodNameBefore": "com.github.javaparser.symbolsolver.model.typesystem.ReferenceTypeTest#parametrizedType",
        "invokedMethod": "methodSignature: com.github.javaparser.symbolsolver.model.typesystem.ReferenceTypeTest#extendBound\n methodBody: private Bound extendBound(String type) {\nreturn Bound.extendsBound(type(type));\n}\nmethodSignature: com.github.javaparser.resolution.declarations.ResolvedTypeParameterDeclaration#onType\n methodBody: static ResolvedTypeParameterDeclaration onType(final String name, String classQName, List<Bound> bounds) {\nreturn new ResolvedTypeParameterDeclaration(){\n  @Override public String getName(){\n    return name;\n  }\n  @Override public boolean declaredOnType(){\n    return true;\n  }\n  @Override public boolean declaredOnMethod(){\n    return false;\n  }\n  @Override public boolean declaredOnConstructor(){\n    return false;\n  }\n  @Override public String getContainerQualifiedName(){\n    return classQName;\n  }\n  @Override public String getContainerId(){\n    return classQName;\n  }\n  @Override public ResolvedTypeParametrizable getContainer(){\n    return null;\n  }\n  @Override public List<Bound> getBounds(){\n    return bounds;\n  }\n  @Override public String toString(){\n    return \"TypeParameter onType \" + name;\n  }\n  @Override public Optional<ResolvedReferenceTypeDeclaration> containerType(){\n    throw new UnsupportedOperationException();\n  }\n  @Override public ResolvedReferenceType object(){\n    throw new UnsupportedOperationException();\n  }\n}\n;\n}",
        "classSignatureBefore": "class ReferenceTypeTest extends AbstractSymbolResolutionTest ",
        "methodNameBeforeSet": [
            "com.github.javaparser.symbolsolver.model.typesystem.ReferenceTypeTest#parametrizedType"
        ],
        "classNameBeforeSet": [
            "com.github.javaparser.symbolsolver.model.typesystem.ReferenceTypeTest"
        ],
        "classSignatureBeforeSet": [
            "class ReferenceTypeTest extends AbstractSymbolResolutionTest "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Copyright (C) 2015-2016 Federico Tomassetti\n * Copyright (C) 2017-2023 The JavaParser Team.\n *\n * This file is part of JavaParser.\n *\n * JavaParser can be used either under the terms of\n * a) the GNU Lesser General Public License as published by\n *     the Free Software Foundation, either version 3 of the License, or\n *     (at your option) any later version.\n * b) the terms of the Apache License\n *\n * You should have received a copy of both licenses in LICENCE.LGPL and\n * LICENCE.APACHE. Please refer to those files for details.\n *\n * JavaParser is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n */\n\npackage com.github.javaparser.symbolsolver.model.typesystem;\n\nimport com.github.javaparser.*;\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;\nimport com.github.javaparser.resolution.TypeSolver;\nimport com.github.javaparser.resolution.declarations.*;\nimport com.github.javaparser.resolution.declarations.ResolvedTypeParameterDeclaration.Bound;\nimport com.github.javaparser.resolution.model.typesystem.NullType;\nimport com.github.javaparser.resolution.model.typesystem.ReferenceTypeImpl;\nimport com.github.javaparser.resolution.types.*;\nimport com.github.javaparser.symbolsolver.AbstractSymbolResolutionTest;\nimport com.github.javaparser.symbolsolver.JavaSymbolSolver;\nimport com.github.javaparser.symbolsolver.reflectionmodel.ReflectionClassDeclaration;\nimport com.github.javaparser.symbolsolver.reflectionmodel.ReflectionInterfaceDeclaration;\nimport com.github.javaparser.symbolsolver.resolution.typesolvers.ReflectionTypeSolver;\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.Lists;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\nimport java.io.IOException;\nimport java.io.Serializable;\nimport java.net.ProtocolException;\nimport java.nio.Buffer;\nimport java.nio.CharBuffer;\nimport java.nio.file.FileSystemException;\nimport java.util.*;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\n\nimport static org.hamcrest.CoreMatchers.*;\nimport static org.hamcrest.MatcherAssert.assertThat;\nimport static org.hamcrest.collection.IsIterableContainingInAnyOrder.containsInAnyOrder;\nimport static org.junit.jupiter.api.Assertions.*;\n\nclass ReferenceTypeTest extends AbstractSymbolResolutionTest {\n\n    private ReferenceTypeImpl listOfA;\n    private ReferenceTypeImpl listOfStrings;\n    private ReferenceTypeImpl linkedListOfString;\n    private ReferenceTypeImpl collectionOfString;\n    private ReferenceTypeImpl listOfWildcardExtendsString;\n    private ReferenceTypeImpl listOfWildcardSuperString;\n    private ReferenceTypeImpl object;\n    private ReferenceTypeImpl string;\n    private TypeSolver typeSolver;\n    private ReferenceTypeImpl ioException;\n    private ResolvedType unionWithIOExceptionAsCommonAncestor;\n    private ResolvedType unionWithThrowableAsCommonAncestor;\n\n    @BeforeEach\n    void setup() {\n        typeSolver = new ReflectionTypeSolver();\n        object = new ReferenceTypeImpl(new ReflectionClassDeclaration(Object.class, typeSolver));\n        string = new ReferenceTypeImpl(new ReflectionClassDeclaration(String.class, typeSolver));\n        listOfA = new ReferenceTypeImpl(\n                new ReflectionInterfaceDeclaration(List.class, typeSolver),\n                ImmutableList.of(new ResolvedTypeVariable(ResolvedTypeParameterDeclaration.onType(\"A\", \"foo.Bar\", Collections.emptyList()))));\n        listOfStrings = new ReferenceTypeImpl(\n                new ReflectionInterfaceDeclaration(List.class, typeSolver),\n                ImmutableList.of(new ReferenceTypeImpl(new ReflectionClassDeclaration(String.class, typeSolver))));\n        linkedListOfString = new ReferenceTypeImpl(\n                new ReflectionClassDeclaration(LinkedList.class, typeSolver),\n                ImmutableList.of(new ReferenceTypeImpl(new ReflectionClassDeclaration(String.class, typeSolver))));\n        collectionOfString = new ReferenceTypeImpl(\n                new ReflectionInterfaceDeclaration(Collection.class, typeSolver),\n                ImmutableList.of(new ReferenceTypeImpl(new ReflectionClassDeclaration(String.class, typeSolver))));\n        listOfWildcardExtendsString = new ReferenceTypeImpl(\n                new ReflectionInterfaceDeclaration(List.class, typeSolver),\n                ImmutableList.of(ResolvedWildcard.extendsBound(string)));\n        listOfWildcardSuperString = new ReferenceTypeImpl(\n                new ReflectionInterfaceDeclaration(List.class, typeSolver),\n                ImmutableList.of(ResolvedWildcard.superBound(string)));\n        ioException = new ReferenceTypeImpl(new ReflectionClassDeclaration(IOException.class, typeSolver));\n        unionWithIOExceptionAsCommonAncestor = new ResolvedUnionType(Arrays.asList(\n                new ReferenceTypeImpl(new ReflectionClassDeclaration(ProtocolException.class, typeSolver)),\n                new ReferenceTypeImpl(new ReflectionClassDeclaration(FileSystemException.class, typeSolver))\n        ));\n        unionWithThrowableAsCommonAncestor = new ResolvedUnionType(Arrays.asList(\n                new ReferenceTypeImpl(new ReflectionClassDeclaration(ClassCastException.class, typeSolver)),\n                new ReferenceTypeImpl(new ReflectionClassDeclaration(AssertionError.class, typeSolver))\n        ));\n        \n        // minimal initialization of JavaParser\n        ParserConfiguration configuration = new ParserConfiguration()\n                .setSymbolResolver(new JavaSymbolSolver(new ReflectionTypeSolver()));\n        // Setup parser\n        StaticJavaParser.setConfiguration(configuration);\n    }\n\n    @Test\n    void testDerivationOfTypeParameters() {\n        ReflectionTypeSolver typeSolver = new ReflectionTypeSolver();\n        ReferenceTypeImpl ref1 = new ReferenceTypeImpl(typeSolver.solveType(LinkedList.class.getCanonicalName()));\n        assertEquals(1, ref1.typeParametersValues().size());\n        assertEquals(true, ref1.typeParametersValues().get(0).isTypeVariable());\n        assertEquals(\"E\", ref1.typeParametersValues().get(0).asTypeParameter().getName());\n    }\n\n    @Test\n    void testIsArray() {\n        assertEquals(false, object.isArray());\n        assertEquals(false, string.isArray());\n        assertEquals(false, listOfA.isArray());\n        assertEquals(false, listOfStrings.isArray());\n    }\n\n    @Test\n    void testIsPrimitive() {\n        assertEquals(false, object.isPrimitive());\n        assertEquals(false, string.isPrimitive());\n        assertEquals(false, listOfA.isPrimitive());\n        assertEquals(false, listOfStrings.isPrimitive());\n    }\n\n    @Test\n    void testIsNull() {\n        assertEquals(false, object.isNull());\n        assertEquals(false, string.isNull());\n        assertEquals(false, listOfA.isNull());\n        assertEquals(false, listOfStrings.isNull());\n    }\n\n    @Test\n    void testIsReference() {\n        assertEquals(true, object.isReference());\n        assertEquals(true, string.isReference());\n        assertEquals(true, listOfA.isReference());\n        assertEquals(true, listOfStrings.isReference());\n    }\n\n    @Test\n    void testIsReferenceType() {\n        assertEquals(true, object.isReferenceType());\n        assertEquals(true, string.isReferenceType());\n        assertEquals(true, listOfA.isReferenceType());\n        assertEquals(true, listOfStrings.isReferenceType());\n    }\n\n    @Test\n    void testIsVoid() {\n        assertEquals(false, object.isVoid());\n        assertEquals(false, string.isVoid());\n        assertEquals(false, listOfA.isVoid());\n        assertEquals(false, listOfStrings.isVoid());\n    }\n\n    @Test\n    void testIsTypeVariable() {\n        assertEquals(false, object.isTypeVariable());\n        assertEquals(false, string.isTypeVariable());\n        assertEquals(false, listOfA.isTypeVariable());\n        assertEquals(false, listOfStrings.isTypeVariable());\n    }\n\n    @Test\n    void testAsReferenceTypeUsage() {\n        assertTrue(object == object.asReferenceType());\n        assertTrue(string == string.asReferenceType());\n        assertTrue(listOfA == listOfA.asReferenceType());\n        assertTrue(listOfStrings == listOfStrings.asReferenceType());\n    }\n\n    @Test\n    void testAsTypeParameter() {\n        assertThrows(UnsupportedOperationException.class, () -> object.asTypeParameter());\n    }\n\n    @Test\n    void testAsArrayTypeUsage() {\n        assertThrows(UnsupportedOperationException.class, () -> object.asArrayType());\n    }\n\n    @Test\n    void testAsDescribe() {\n        assertEquals(\"java.lang.Object\", object.describe());\n        assertEquals(\"java.lang.String\", string.describe());\n        assertEquals(\"java.util.List<A>\", listOfA.describe());\n        assertEquals(\"java.util.List<java.lang.String>\", listOfStrings.describe());\n    }\n\n    @Test\n    void testReplaceParam() {\n        ResolvedTypeParameterDeclaration tpA = ResolvedTypeParameterDeclaration.onType(\"A\", \"foo.Bar\", Collections.emptyList());\n        assertTrue(object == object.replaceTypeVariables(tpA, object));\n        assertTrue(string == string.replaceTypeVariables(tpA, object));\n        assertEquals(listOfStrings, listOfStrings.replaceTypeVariables(tpA, object));\n        assertEquals(listOfStrings, listOfA.replaceTypeVariables(tpA, string));\n    }\n\n    @Test\n    void testIsAssignableBySimple() {\n        assertEquals(true, object.isAssignableBy(string));\n        assertEquals(false, string.isAssignableBy(object));\n        assertEquals(false, listOfStrings.isAssignableBy(listOfA));\n        assertEquals(false, listOfA.isAssignableBy(listOfStrings));\n\n        assertEquals(false, object.isAssignableBy(ResolvedVoidType.INSTANCE));\n        assertEquals(false, string.isAssignableBy(ResolvedVoidType.INSTANCE));\n        assertEquals(false, listOfStrings.isAssignableBy(ResolvedVoidType.INSTANCE));\n        assertEquals(false, listOfA.isAssignableBy(ResolvedVoidType.INSTANCE));\n\n        assertEquals(true, object.isAssignableBy(NullType.INSTANCE));\n        assertEquals(true, string.isAssignableBy(NullType.INSTANCE));\n        assertEquals(true, listOfStrings.isAssignableBy(NullType.INSTANCE));\n        assertEquals(true, listOfA.isAssignableBy(NullType.INSTANCE));\n    }\n\n    @Test\n    void testIsAssignableByBoxedPrimitive() {\n        ResolvedReferenceType numberType = new ReferenceTypeImpl(new ReflectionClassDeclaration(Number.class, typeSolver));\n        ResolvedReferenceType intType = new ReferenceTypeImpl(new ReflectionClassDeclaration(Integer.class, typeSolver));\n        ResolvedReferenceType doubleType = new ReferenceTypeImpl(new ReflectionClassDeclaration(Double.class, typeSolver));\n        ResolvedReferenceType byteType = new ReferenceTypeImpl(new ReflectionClassDeclaration(Byte.class, typeSolver));\n        ResolvedReferenceType shortType = new ReferenceTypeImpl(new ReflectionClassDeclaration(Short.class, typeSolver));\n        ResolvedReferenceType charType = new ReferenceTypeImpl(new ReflectionClassDeclaration(Character.class, typeSolver));\n        ResolvedReferenceType longType = new ReferenceTypeImpl(new ReflectionClassDeclaration(Long.class, typeSolver));\n        ResolvedReferenceType booleanType = new ReferenceTypeImpl(new ReflectionClassDeclaration(Boolean.class, typeSolver));\n        ResolvedReferenceType floatType = new ReferenceTypeImpl(new ReflectionClassDeclaration(Float.class, typeSolver));\n\n        assertEquals(true, numberType.isAssignableBy(ResolvedPrimitiveType.INT));\n        assertEquals(true, numberType.isAssignableBy(ResolvedPrimitiveType.DOUBLE));\n        assertEquals(true, numberType.isAssignableBy(ResolvedPrimitiveType.SHORT));\n        assertEquals(true, numberType.isAssignableBy(ResolvedPrimitiveType.LONG));\n        assertEquals(true, numberType.isAssignableBy(ResolvedPrimitiveType.FLOAT));\n        assertEquals(false, numberType.isAssignableBy(ResolvedPrimitiveType.BOOLEAN));\n        assertEquals(true, intType.isAssignableBy(ResolvedPrimitiveType.INT));\n        assertEquals(true, doubleType.isAssignableBy(ResolvedPrimitiveType.DOUBLE));\n        assertEquals(true, byteType.isAssignableBy(ResolvedPrimitiveType.BYTE));\n        assertEquals(true, shortType.isAssignableBy(ResolvedPrimitiveType.SHORT));\n        assertEquals(true, charType.isAssignableBy(ResolvedPrimitiveType.CHAR));\n        assertEquals(true, longType.isAssignableBy(ResolvedPrimitiveType.LONG));\n        assertEquals(true, booleanType.isAssignableBy(ResolvedPrimitiveType.BOOLEAN));\n        assertEquals(true, floatType.isAssignableBy(ResolvedPrimitiveType.FLOAT));\n    }\n\n    @Test\n    void testIsCorresponding() {\n\n        // ResolvedReferenceTypeTester is defined to allow to test protected method isCorrespondingBoxingType(..)\n        class ResolvedReferenceTypeTester extends ReferenceTypeImpl {\n\n            public ResolvedReferenceTypeTester(ResolvedReferenceTypeDeclaration typeDeclaration,\n                                               TypeSolver typeSolver) {\n                super(typeDeclaration);\n            }\n\n            public boolean isCorrespondingBoxingType(String name) {\n                return super.isCorrespondingBoxingType(name);\n            }\n\n        }\n\n        ResolvedReferenceTypeTester numberType = new ResolvedReferenceTypeTester(\n                new ReflectionClassDeclaration(Number.class, typeSolver), typeSolver);\n        ResolvedReferenceTypeTester intType = new ResolvedReferenceTypeTester(\n                new ReflectionClassDeclaration(Integer.class, typeSolver), typeSolver);\n        ResolvedReferenceTypeTester doubleType = new ResolvedReferenceTypeTester(\n                new ReflectionClassDeclaration(Double.class, typeSolver), typeSolver);\n        ResolvedReferenceTypeTester byteType = new ResolvedReferenceTypeTester(\n                new ReflectionClassDeclaration(Byte.class, typeSolver), typeSolver);\n        ResolvedReferenceTypeTester shortType = new ResolvedReferenceTypeTester(\n                new ReflectionClassDeclaration(Short.class, typeSolver), typeSolver);\n        ResolvedReferenceTypeTester charType = new ResolvedReferenceTypeTester(\n                new ReflectionClassDeclaration(Character.class, typeSolver), typeSolver);\n        ResolvedReferenceTypeTester longType = new ResolvedReferenceTypeTester(\n                new ReflectionClassDeclaration(Long.class, typeSolver), typeSolver);\n        ResolvedReferenceTypeTester booleanType = new ResolvedReferenceTypeTester(\n                new ReflectionClassDeclaration(Boolean.class, typeSolver), typeSolver);\n        ResolvedReferenceTypeTester floatType = new ResolvedReferenceTypeTester(\n                new ReflectionClassDeclaration(Float.class, typeSolver), typeSolver);\n\n        ResolvedReferenceTypeTester otherType = new ResolvedReferenceTypeTester(\n                new ReflectionClassDeclaration(String.class, typeSolver), typeSolver);\n\n        assertEquals(true, intType.isCorrespondingBoxingType(ResolvedPrimitiveType.INT.describe()));\n        assertEquals(true, doubleType.isCorrespondingBoxingType(ResolvedPrimitiveType.DOUBLE.describe()));\n        assertEquals(true, byteType.isCorrespondingBoxingType(ResolvedPrimitiveType.BYTE.describe()));\n        assertEquals(true, shortType.isCorrespondingBoxingType(ResolvedPrimitiveType.SHORT.describe()));\n        assertEquals(true, charType.isCorrespondingBoxingType(ResolvedPrimitiveType.CHAR.describe()));\n        assertEquals(true, longType.isCorrespondingBoxingType(ResolvedPrimitiveType.LONG.describe()));\n        assertEquals(true, booleanType.isCorrespondingBoxingType(ResolvedPrimitiveType.BOOLEAN.describe()));\n        assertEquals(true, floatType.isCorrespondingBoxingType(ResolvedPrimitiveType.FLOAT.describe()));\n\n        assertEquals(false, numberType.isCorrespondingBoxingType(ResolvedPrimitiveType.INT.describe()));\n\n        assertThrows(IllegalArgumentException.class, () -> {\n            intType.isCorrespondingBoxingType(\"String\");\n        });\n    }\n\n    @Test\n    void testIsAssignableByGenerics() {\n        assertEquals(false, listOfStrings.isAssignableBy(listOfWildcardExtendsString));\n        assertEquals(false, listOfStrings.isAssignableBy(listOfWildcardExtendsString));\n        assertEquals(true, listOfWildcardExtendsString.isAssignableBy(listOfStrings));\n        assertEquals(false, listOfWildcardExtendsString.isAssignableBy(listOfWildcardSuperString));\n        assertEquals(true, listOfWildcardSuperString.isAssignableBy(listOfStrings));\n        assertEquals(false, listOfWildcardSuperString.isAssignableBy(listOfWildcardExtendsString));\n    }\n\n    @Test\n    void testIsAssignableByGenericsInheritance() {\n        assertEquals(true, collectionOfString.isAssignableBy(collectionOfString));\n        assertEquals(true, collectionOfString.isAssignableBy(listOfStrings));\n        assertEquals(true, collectionOfString.isAssignableBy(linkedListOfString));\n\n        assertEquals(false, listOfStrings.isAssignableBy(collectionOfString));\n        assertEquals(true, listOfStrings.isAssignableBy(listOfStrings));\n        assertEquals(true, listOfStrings.isAssignableBy(linkedListOfString));\n\n        assertEquals(false, linkedListOfString.isAssignableBy(collectionOfString));\n        assertEquals(false, linkedListOfString.isAssignableBy(listOfStrings));\n        assertEquals(true, linkedListOfString.isAssignableBy(linkedListOfString));\n    }\n    \n    @Test\n    void testIsAssignableByUnionType() {\n        assertEquals(true, ioException.isAssignableBy(unionWithIOExceptionAsCommonAncestor));\n        assertEquals(false, ioException.isAssignableBy(unionWithThrowableAsCommonAncestor));\n    }\n\n    @Test\n    void testGetAllAncestorsConsideringTypeParameters() {\n        assertThat(linkedListOfString.getAllAncestors(), hasItem(object));\n        assertThat(linkedListOfString.getAllAncestors(), hasItem(listOfStrings));\n        assertThat(linkedListOfString.getAllAncestors(), hasItem(collectionOfString));\n        assertThat(linkedListOfString.getAllAncestors(), not(hasItem(listOfA)));\n    }\n\n    class Foo {\n\n    }\n\n    class Bar extends Foo {\n\n    }\n\n    class Bazzer<A, B, C> {\n\n    }\n\n    class MoreBazzing<A, B> extends Bazzer<B, String, A> {\n\n    }\n\n    @Test\n    void testGetAllAncestorsConsideringGenericsCases() {\n        ReferenceTypeImpl foo = new ReferenceTypeImpl(new ReflectionClassDeclaration(Foo.class, typeSolver));\n        ReferenceTypeImpl bar = new ReferenceTypeImpl(new ReflectionClassDeclaration(Bar.class, typeSolver));\n        ReferenceTypeImpl left, right;\n\n        //YES MoreBazzing<Foo, Bar> e1 = new MoreBazzing<Foo, Bar>();\n        assertEquals(true,\n                new ReferenceTypeImpl(\n                        new ReflectionClassDeclaration(MoreBazzing.class, typeSolver),\n                        ImmutableList.of(foo, bar))\n                        .isAssignableBy(new ReferenceTypeImpl(\n                                new ReflectionClassDeclaration(MoreBazzing.class, typeSolver),\n                                ImmutableList.of(foo, bar)))\n        );\n\n        //YES MoreBazzing<? extends Foo, Bar> e2 = new MoreBazzing<Foo, Bar>();\n        assertEquals(true,\n                new ReferenceTypeImpl(\n                        new ReflectionClassDeclaration(MoreBazzing.class, typeSolver),\n                        ImmutableList.of(ResolvedWildcard.extendsBound(foo), bar))\n                        .isAssignableBy(new ReferenceTypeImpl(\n                                new ReflectionClassDeclaration(MoreBazzing.class, typeSolver),\n                                ImmutableList.of(foo, bar)))\n        );\n\n        //YES MoreBazzing<Foo, ? extends Bar> e3 = new MoreBazzing<Foo, Bar>();\n        assertEquals(true,\n                new ReferenceTypeImpl(\n                        new ReflectionClassDeclaration(MoreBazzing.class, typeSolver),\n                        ImmutableList.of(foo, ResolvedWildcard.extendsBound(bar)))\n                        .isAssignableBy(new ReferenceTypeImpl(\n                                new ReflectionClassDeclaration(MoreBazzing.class, typeSolver),\n                                ImmutableList.of(foo, bar)))\n        );\n\n        //YES MoreBazzing<? extends Foo, ? extends Foo> e4 = new MoreBazzing<Foo, Bar>();\n        assertEquals(true,\n                new ReferenceTypeImpl(\n                        new ReflectionClassDeclaration(MoreBazzing.class, typeSolver),\n                        ImmutableList.of(ResolvedWildcard.extendsBound(foo), ResolvedWildcard.extendsBound(foo)))\n                        .isAssignableBy(new ReferenceTypeImpl(\n                                new ReflectionClassDeclaration(MoreBazzing.class, typeSolver),\n                                ImmutableList.of(foo, bar)))\n        );\n\n        //YES MoreBazzing<? extends Foo, ? extends Foo> e5 = new MoreBazzing<Bar, Bar>();\n        left = new ReferenceTypeImpl(\n                new ReflectionClassDeclaration(MoreBazzing.class, typeSolver),\n                ImmutableList.of(ResolvedWildcard.extendsBound(foo), ResolvedWildcard.extendsBound(foo)));\n        right = new ReferenceTypeImpl(\n                new ReflectionClassDeclaration(MoreBazzing.class, typeSolver),\n                ImmutableList.of(bar, bar));\n        assertEquals(true, left.isAssignableBy(right));\n\n        //YES Bazzer<Object, String, String> e6 = new MoreBazzing<String, Object>();\n        left = new ReferenceTypeImpl(\n                new ReflectionClassDeclaration(Bazzer.class, typeSolver),\n                ImmutableList.of(object, string, string));\n        right = new ReferenceTypeImpl(\n                new ReflectionClassDeclaration(MoreBazzing.class, typeSolver),\n                ImmutableList.of(string, object));\n\n        // To debug the following\n        List<ResolvedReferenceType> ancestors = right.getAllAncestors();\n        ResolvedReferenceType moreBazzingAncestor = ancestors.stream()\n                .filter(a -> a.getQualifiedName().endsWith(\"Bazzer\"))\n                .findFirst().get();\n\n        assertEquals(true, left.isAssignableBy(right));\n\n        //YES Bazzer<String,String,String> e7 = new MoreBazzing<String, String>();\n        assertEquals(true,\n                new ReferenceTypeImpl(\n                        new ReflectionClassDeclaration(Bazzer.class, typeSolver),\n                        ImmutableList.of(string, string, string))\n                        .isAssignableBy(new ReferenceTypeImpl(\n                                new ReflectionClassDeclaration(MoreBazzing.class, typeSolver),\n                                ImmutableList.of(string, string)))\n        );\n\n        //YES Bazzer<Bar,String,Foo> e8 = new MoreBazzing<Foo, Bar>();\n        assertEquals(true,\n                new ReferenceTypeImpl(\n                        new ReflectionClassDeclaration(Bazzer.class, typeSolver),\n                        ImmutableList.of(bar, string, foo))\n                        .isAssignableBy(new ReferenceTypeImpl(\n                                new ReflectionClassDeclaration(MoreBazzing.class, typeSolver),\n                                ImmutableList.of(foo, bar)))\n        );\n\n        //YES Bazzer<Foo,String,Bar> e9 = new MoreBazzing<Bar, Foo>();\n        assertEquals(true,\n                new ReferenceTypeImpl(\n                        new ReflectionClassDeclaration(Bazzer.class, typeSolver),\n                        ImmutableList.of(foo, string, bar))\n                        .isAssignableBy(new ReferenceTypeImpl(\n                                new ReflectionClassDeclaration(MoreBazzing.class, typeSolver),\n                                ImmutableList.of(bar, foo)))\n        );\n\n        //NO Bazzer<Bar,String,Foo> n1 = new MoreBazzing<Bar, Foo>();\n        assertEquals(false,\n                new ReferenceTypeImpl(\n                        new ReflectionClassDeclaration(Bazzer.class, typeSolver),\n                        ImmutableList.of(bar, string, foo))\n                        .isAssignableBy(new ReferenceTypeImpl(\n                                new ReflectionClassDeclaration(MoreBazzing.class, typeSolver),\n                                ImmutableList.of(bar, foo)))\n        );\n\n        //NO Bazzer<Bar,String,Bar> n2 = new MoreBazzing<Bar, Foo>();\n        assertEquals(false,\n                new ReferenceTypeImpl(\n                        new ReflectionClassDeclaration(Bazzer.class, typeSolver),\n                        ImmutableList.of(bar, string, foo))\n                        .isAssignableBy(new ReferenceTypeImpl(\n                                new ReflectionClassDeclaration(MoreBazzing.class, typeSolver),\n                                ImmutableList.of(bar, foo)))\n        );\n\n        //NO Bazzer<Foo,Object,Bar> n3 = new MoreBazzing<Bar, Foo>();\n        assertEquals(false,\n                new ReferenceTypeImpl(\n                        new ReflectionClassDeclaration(Bazzer.class, typeSolver),\n                        ImmutableList.of(foo, object, bar))\n                        .isAssignableBy(new ReferenceTypeImpl(\n                                new ReflectionClassDeclaration(MoreBazzing.class, typeSolver),\n                                ImmutableList.of(bar, foo)))\n        );\n    }\n\n    @Test\n    void charSequenceIsAssignableToObject() {\n        TypeSolver typeSolver = new ReflectionTypeSolver();\n        ReferenceTypeImpl charSequence = new ReferenceTypeImpl(new ReflectionInterfaceDeclaration(CharSequence.class, typeSolver));\n        ReferenceTypeImpl object = new ReferenceTypeImpl(new ReflectionClassDeclaration(Object.class, typeSolver));\n        assertEquals(false, charSequence.isAssignableBy(object));\n        assertEquals(true, object.isAssignableBy(charSequence));\n    }\n\n    @Test\n    void testGetFieldTypeExisting() {\n        class Foo<A> {\n\n            List<A> elements;\n        }\n\n        TypeSolver typeSolver = new ReflectionTypeSolver();\n        ReferenceTypeImpl ref = new ReferenceTypeImpl(new ReflectionClassDeclaration(Foo.class, typeSolver));\n\n        assertEquals(true, ref.getFieldType(\"elements\").isPresent());\n        assertEquals(true, ref.getFieldType(\"elements\").get().isReferenceType());\n        assertEquals(List.class.getCanonicalName(), ref.getFieldType(\"elements\").get().asReferenceType().getQualifiedName());\n        assertEquals(1, ref.getFieldType(\"elements\").get().asReferenceType().typeParametersValues().size());\n        assertEquals(true, ref.getFieldType(\"elements\").get().asReferenceType().typeParametersValues().get(0).isTypeVariable());\n        assertEquals(\"A\", ref.getFieldType(\"elements\").get().asReferenceType().typeParametersValues().get(0).asTypeParameter().getName());\n\n        ref = new ReferenceTypeImpl(new ReflectionClassDeclaration(Foo.class, typeSolver),\n                ImmutableList.of(new ReferenceTypeImpl(new ReflectionClassDeclaration(String.class, typeSolver))));\n\n        assertEquals(true, ref.getFieldType(\"elements\").isPresent());\n        assertEquals(true, ref.getFieldType(\"elements\").get().isReferenceType());\n        assertEquals(List.class.getCanonicalName(), ref.getFieldType(\"elements\").get().asReferenceType().getQualifiedName());\n        assertEquals(1, ref.getFieldType(\"elements\").get().asReferenceType().typeParametersValues().size());\n        assertEquals(true, ref.getFieldType(\"elements\").get().asReferenceType().typeParametersValues().get(0).isReferenceType());\n        assertEquals(String.class.getCanonicalName(), ref.getFieldType(\"elements\").get().asReferenceType().typeParametersValues().get(0).asReferenceType().getQualifiedName());\n    }\n\n    @Test\n    void testGetFieldTypeUnexisting() {\n        class Foo<A> {\n\n            List<A> elements;\n        }\n\n        TypeSolver typeSolver = new ReflectionTypeSolver();\n        ReferenceTypeImpl ref = new ReferenceTypeImpl(new ReflectionClassDeclaration(Foo.class, typeSolver));\n\n        assertEquals(false, ref.getFieldType(\"bar\").isPresent());\n\n        ref = new ReferenceTypeImpl(new ReflectionClassDeclaration(Foo.class, typeSolver),\n                ImmutableList.of(new ReferenceTypeImpl(new ReflectionClassDeclaration(String.class, typeSolver))));\n\n        assertEquals(false, ref.getFieldType(\"bar\").isPresent());\n    }\n\n    @Test\n    void testTypeParamValue() {\n        TypeSolver typeResolver = new ReflectionTypeSolver();\n        ResolvedClassDeclaration arraylist = new ReflectionClassDeclaration(ArrayList.class, typeResolver);\n        ResolvedClassDeclaration abstractList = new ReflectionClassDeclaration(AbstractList.class, typeResolver);\n        ResolvedClassDeclaration abstractCollection = new ReflectionClassDeclaration(AbstractCollection.class, typeResolver);\n        ResolvedInterfaceDeclaration list = new ReflectionInterfaceDeclaration(List.class, typeResolver);\n        ResolvedInterfaceDeclaration collection = new ReflectionInterfaceDeclaration(Collection.class, typeResolver);\n        ResolvedInterfaceDeclaration iterable = new ReflectionInterfaceDeclaration(Iterable.class, typeResolver);\n        ResolvedType string = new ReferenceTypeImpl(new ReflectionClassDeclaration(String.class, typeResolver));\n        ResolvedReferenceType arrayListOfString = new ReferenceTypeImpl(arraylist, ImmutableList.of(string));\n        assertEquals(Optional.of(string), arrayListOfString.typeParamValue(arraylist.getTypeParameters().get(0)));\n        assertEquals(Optional.of(string), arrayListOfString.typeParamValue(abstractList.getTypeParameters().get(0)));\n        assertEquals(Optional.of(string), arrayListOfString.typeParamValue(abstractCollection.getTypeParameters().get(0)));\n        assertEquals(Optional.of(string), arrayListOfString.typeParamValue(list.getTypeParameters().get(0)));\n        assertEquals(Optional.of(string), arrayListOfString.typeParamValue(collection.getTypeParameters().get(0)));\n        assertEquals(Optional.of(string), arrayListOfString.typeParamValue(iterable.getTypeParameters().get(0)));\n    }\n\n    @Test\n    void testGetAllAncestorsOnRawType() {\n        TypeSolver typeResolver = new ReflectionTypeSolver();\n        ResolvedClassDeclaration arraylist = new ReflectionClassDeclaration(ArrayList.class, typeResolver);\n        ResolvedReferenceType rawArrayList = new ReferenceTypeImpl(arraylist);\n\n        Map<String, ResolvedReferenceType> ancestors = new HashMap<>();\n        rawArrayList.getAllAncestors().forEach(a -> ancestors.put(a.getQualifiedName(), a));\n        assertEquals(9, ancestors.size());\n\n        ResolvedTypeVariable tv = new ResolvedTypeVariable(arraylist.getTypeParameters().get(0));\n        assertEquals(new ReferenceTypeImpl(new ReflectionInterfaceDeclaration(RandomAccess.class, typeResolver)), ancestors.get(\"java.util.RandomAccess\"));\n        assertEquals(new ReferenceTypeImpl(new ReflectionClassDeclaration(AbstractCollection.class, typeResolver), ImmutableList.of(tv)), ancestors.get(\"java.util.AbstractCollection\"));\n        assertEquals(new ReferenceTypeImpl(new ReflectionInterfaceDeclaration(List.class, typeResolver), ImmutableList.of(tv)), ancestors.get(\"java.util.List\"));\n        assertEquals(new ReferenceTypeImpl(new ReflectionInterfaceDeclaration(Cloneable.class, typeResolver)), ancestors.get(\"java.lang.Cloneable\"));\n        assertEquals(new ReferenceTypeImpl(new ReflectionInterfaceDeclaration(Collection.class, typeResolver), ImmutableList.of(tv)), ancestors.get(\"java.util.Collection\"));\n        assertEquals(new ReferenceTypeImpl(new ReflectionClassDeclaration(AbstractList.class, typeResolver), ImmutableList.of(tv)), ancestors.get(\"java.util.AbstractList\"));\n        assertEquals(new ReferenceTypeImpl(new ReflectionClassDeclaration(Object.class, typeResolver)), ancestors.get(\"java.lang.Object\"));\n        assertEquals(new ReferenceTypeImpl(new ReflectionInterfaceDeclaration(Iterable.class, typeResolver), ImmutableList.of(tv)), ancestors.get(\"java.lang.Iterable\"));\n        assertEquals(new ReferenceTypeImpl(new ReflectionInterfaceDeclaration(Serializable.class, typeResolver)), ancestors.get(\"java.io.Serializable\"));\n    }\n\n    @Test\n    void testGetAllAncestorsOnTypeWithSpecifiedTypeParametersForInterface() {\n        TypeSolver typeResolver = new ReflectionTypeSolver();\n        ResolvedInterfaceDeclaration list = new ReflectionInterfaceDeclaration(List.class, typeResolver);\n        ResolvedType string = new ReferenceTypeImpl(new ReflectionClassDeclaration(String.class, typeResolver));\n        ResolvedReferenceType listOfString = new ReferenceTypeImpl(list, ImmutableList.of(string));\n\n        Map<String, ResolvedReferenceType> ancestors = new HashMap<>();\n        listOfString.getAllAncestors().forEach(a -> ancestors.put(a.getQualifiedName(), a));\n        assertEquals(2, ancestors.size());\n\n        assertEquals(new ReferenceTypeImpl(new ReflectionInterfaceDeclaration(Collection.class, typeResolver), ImmutableList.of(string)), ancestors.get(\"java.util.Collection\"));\n        assertEquals(new ReferenceTypeImpl(new ReflectionInterfaceDeclaration(Iterable.class, typeResolver), ImmutableList.of(string)), ancestors.get(\"java.lang.Iterable\"));\n    }\n\n    @Test\n    void testGetAllAncestorsOnTypeWithSpecifiedTypeParametersForClassAbstractCollection() {\n        TypeSolver typeResolver = new ReflectionTypeSolver();\n        ResolvedClassDeclaration abstractCollection = new ReflectionClassDeclaration(AbstractCollection.class, typeResolver);\n        ResolvedType string = new ReferenceTypeImpl(new ReflectionClassDeclaration(String.class, typeResolver));\n        ResolvedReferenceType abstractCollectionOfString = new ReferenceTypeImpl(abstractCollection, ImmutableList.of(string));\n\n        Map<String, ResolvedReferenceType> ancestors = new HashMap<>();\n        abstractCollectionOfString.getAllAncestors().forEach(a -> ancestors.put(a.getQualifiedName(), a));\n        assertEquals(3, ancestors.size());\n\n        assertEquals(new ReferenceTypeImpl(new ReflectionInterfaceDeclaration(Collection.class, typeResolver), ImmutableList.of(string)), ancestors.get(\"java.util.Collection\"));\n        assertEquals(new ReferenceTypeImpl(new ReflectionClassDeclaration(Object.class, typeResolver)), ancestors.get(\"java.lang.Object\"));\n        assertEquals(new ReferenceTypeImpl(new ReflectionInterfaceDeclaration(Iterable.class, typeResolver), ImmutableList.of(string)), ancestors.get(\"java.lang.Iterable\"));\n    }\n\n    @Test\n    void testGetAllAncestorsOnTypeWithSpecifiedTypeParametersForClassAbstractList() {\n        TypeSolver typeResolver = new ReflectionTypeSolver();\n        ResolvedClassDeclaration abstractList = new ReflectionClassDeclaration(AbstractList.class, typeResolver);\n        ResolvedType string = new ReferenceTypeImpl(new ReflectionClassDeclaration(String.class, typeResolver));\n        ResolvedReferenceType abstractListOfString = new ReferenceTypeImpl(abstractList, ImmutableList.of(string));\n\n        Map<String, ResolvedReferenceType> ancestors = new HashMap<>();\n        abstractListOfString.getAllAncestors().forEach(a -> ancestors.put(a.getQualifiedName(), a));\n        assertEquals(5, ancestors.size());\n\n        assertEquals(new ReferenceTypeImpl(new ReflectionClassDeclaration(AbstractCollection.class, typeResolver), ImmutableList.of(string)), ancestors.get(\"java.util.AbstractCollection\"));\n        assertEquals(new ReferenceTypeImpl(new ReflectionInterfaceDeclaration(List.class, typeResolver), ImmutableList.of(string)), ancestors.get(\"java.util.List\"));\n        assertEquals(new ReferenceTypeImpl(new ReflectionInterfaceDeclaration(Collection.class, typeResolver), ImmutableList.of(string)), ancestors.get(\"java.util.Collection\"));\n        assertEquals(new ReferenceTypeImpl(new ReflectionClassDeclaration(Object.class, typeResolver)), ancestors.get(\"java.lang.Object\"));\n        assertEquals(new ReferenceTypeImpl(new ReflectionInterfaceDeclaration(Iterable.class, typeResolver), ImmutableList.of(string)), ancestors.get(\"java.lang.Iterable\"));\n    }\n\n    @Test\n    void testGetAllAncestorsOnTypeWithSpecifiedTypeParametersForClassArrayList() {\n        TypeSolver typeResolver = new ReflectionTypeSolver();\n        ResolvedClassDeclaration arraylist = new ReflectionClassDeclaration(ArrayList.class, typeResolver);\n        ResolvedType string = new ReferenceTypeImpl(new ReflectionClassDeclaration(String.class, typeResolver));\n        ResolvedReferenceType arrayListOfString = new ReferenceTypeImpl(arraylist, ImmutableList.of(string));\n\n        Map<String, ResolvedReferenceType> ancestors = new HashMap<>();\n        arrayListOfString.getAllAncestors().forEach(a -> ancestors.put(a.getQualifiedName(), a));\n        assertEquals(9, ancestors.size());\n\n        assertEquals(new ReferenceTypeImpl(new ReflectionInterfaceDeclaration(RandomAccess.class, typeResolver)), ancestors.get(\"java.util.RandomAccess\"));\n        assertEquals(new ReferenceTypeImpl(new ReflectionClassDeclaration(AbstractCollection.class, typeResolver), ImmutableList.of(string)), ancestors.get(\"java.util.AbstractCollection\"));\n        assertEquals(new ReferenceTypeImpl(new ReflectionInterfaceDeclaration(List.class, typeResolver), ImmutableList.of(string)), ancestors.get(\"java.util.List\"));\n        assertEquals(new ReferenceTypeImpl(new ReflectionInterfaceDeclaration(Cloneable.class, typeResolver)), ancestors.get(\"java.lang.Cloneable\"));\n        assertEquals(new ReferenceTypeImpl(new ReflectionInterfaceDeclaration(Collection.class, typeResolver), ImmutableList.of(string)), ancestors.get(\"java.util.Collection\"));\n        assertEquals(new ReferenceTypeImpl(new ReflectionClassDeclaration(AbstractList.class, typeResolver), ImmutableList.of(string)), ancestors.get(\"java.util.AbstractList\"));\n        assertEquals(new ReferenceTypeImpl(new ReflectionClassDeclaration(Object.class, typeResolver)), ancestors.get(\"java.lang.Object\"));\n        assertEquals(new ReferenceTypeImpl(new ReflectionInterfaceDeclaration(Iterable.class, typeResolver), ImmutableList.of(string)), ancestors.get(\"java.lang.Iterable\"));\n        assertEquals(new ReferenceTypeImpl(new ReflectionInterfaceDeclaration(Serializable.class, typeResolver)), ancestors.get(\"java.io.Serializable\"));\n    }\n\n    @Test\n    void testTypeParametersValues() {\n        TypeSolver typeResolver = new ReflectionTypeSolver();\n        ResolvedReferenceType stream = new ReferenceTypeImpl(new ReflectionInterfaceDeclaration(Stream.class, typeResolver));\n        assertEquals(1, stream.typeParametersValues().size());\n        assertEquals(new ResolvedTypeVariable(new ReflectionInterfaceDeclaration(Stream.class, typeResolver).getTypeParameters().get(0)), stream.typeParametersValues().get(0));\n    }\n\n    @Test\n    void testReplaceTypeVariables() {\n        TypeSolver typeResolver = new ReflectionTypeSolver();\n        ResolvedInterfaceDeclaration streamInterface = new ReflectionInterfaceDeclaration(Stream.class, typeResolver);\n        ResolvedReferenceType stream = new ReferenceTypeImpl(streamInterface);\n\n        ResolvedMethodDeclaration streamMap = streamInterface.getDeclaredMethods().stream().filter(m -> m.getName().equals(\"map\")).findFirst().get();\n        ResolvedTypeParameterDeclaration streamMapR = streamMap.findTypeParameter(\"T\").get();\n        ResolvedTypeVariable typeVariable = new ResolvedTypeVariable(streamMapR);\n        stream = stream.deriveTypeParameters(stream.typeParametersMap().toBuilder().setValue(stream.getTypeDeclaration().get().getTypeParameters().get(0), typeVariable).build());\n\n        ResolvedTypeParameterDeclaration tpToReplace = streamInterface.getTypeParameters().get(0);\n        ResolvedType replaced = new ReferenceTypeImpl(new ReflectionClassDeclaration(String.class, typeResolver));\n\n        ResolvedType streamReplaced = stream.replaceTypeVariables(tpToReplace, replaced);\n        assertEquals(\"java.util.stream.Stream<java.lang.String>\", streamReplaced.describe());\n    }\n\n    @Test\n    void testReplaceTypeVariablesWithLambdaInBetween() {\n        TypeSolver typeResolver = new ReflectionTypeSolver();\n        ResolvedInterfaceDeclaration streamInterface = new ReflectionInterfaceDeclaration(Stream.class, typeResolver);\n        ResolvedReferenceType stream = new ReferenceTypeImpl(streamInterface);\n\n        ResolvedMethodDeclaration streamMap = streamInterface.getDeclaredMethods().stream().filter(m -> m.getName().equals(\"map\")).findFirst().get();\n        ResolvedTypeParameterDeclaration streamMapR = streamMap.findTypeParameter(\"T\").get();\n        ResolvedTypeVariable typeVariable = new ResolvedTypeVariable(streamMapR);\n        stream = stream.deriveTypeParameters(stream.typeParametersMap().toBuilder().setValue(stream.getTypeDeclaration().get().getTypeParameters().get(0), typeVariable).build());\n\n        ResolvedTypeParameterDeclaration tpToReplace = streamInterface.getTypeParameters().get(0);\n        ResolvedType replaced = new ReferenceTypeImpl(new ReflectionClassDeclaration(String.class, typeResolver));\n\n        ResolvedType streamReplaced = stream.replaceTypeVariables(tpToReplace, replaced);\n        assertEquals(\"java.util.stream.Stream<java.lang.String>\", streamReplaced.describe());\n    }\n\n    @Test\n    void testDirectAncestorsOfObject() {\n        assertEquals(0, object.getDirectAncestors().size());\n    }\n\n    @Test\n    void testDirectAncestorsOfInterface() {\n        ResolvedReferenceType iterableOfString = new ReferenceTypeImpl(\n                new ReflectionInterfaceDeclaration(Iterable.class, typeSolver),\n                ImmutableList.of(new ReferenceTypeImpl(new ReflectionClassDeclaration(String.class, typeSolver))));\n        assertEquals(0, iterableOfString.getDirectAncestors().size());\n    }\n\n    @Test\n    void testDirectAncestorsOfInterfaceExtendingInterface() {\n        assertEquals(1, collectionOfString.getDirectAncestors().size());\n        ResolvedReferenceType ancestor1 = collectionOfString.getDirectAncestors().get(0);\n        assertEquals(\"java.lang.Iterable\", ancestor1.getQualifiedName());\n        assertEquals(1, ancestor1.getTypeParametersMap().size());\n        assertEquals(\"T\", ancestor1.getTypeParametersMap().get(0).a.getName());\n        assertEquals(\"java.lang.String\", ancestor1.getTypeParametersMap().get(0).b.describe());\n    }\n\n    @Test\n    void testDirectAncestorsOfClassWithoutSuperClassOrInterfaces() {\n        ResolvedReferenceType buffer = new ReferenceTypeImpl(new ReflectionClassDeclaration(Buffer.class, typeSolver));\n        Set<String> ancestors = buffer.getDirectAncestors()\n                .stream()\n                .map(ResolvedReferenceType::describe)\n                .collect(Collectors.toSet());\n\n        assertThat(ancestors, equalTo(new HashSet<>(Arrays.asList(\"java.lang.Object\"))));\n    }\n\n    @Test\n    void testDirectAncestorsOfObjectClass() {\n        ResolvedReferenceType object = new ReferenceTypeImpl(new ReflectionClassDeclaration(Object.class, typeSolver));\n        Set<String> ancestors = object.getDirectAncestors()\n                .stream()\n                .map(ResolvedReferenceType::describe)\n                .collect(Collectors.toSet());\n\n        assertEquals(new HashSet<>(), ancestors);\n    }\n\n    @Test\n    void testDirectAncestorsOfClassWithSuperClass() {\n        ResolvedReferenceType charbuffer = new ReferenceTypeImpl(new ReflectionClassDeclaration(CharBuffer.class, typeSolver));\n        Set<String> ancestors = charbuffer.getDirectAncestors()\n                .stream()\n                .map(ResolvedReferenceType::describe)\n                .collect(Collectors.toSet());\n\n        assertThat(ancestors, containsInAnyOrder(\n                \"java.lang.CharSequence\",\n                \"java.lang.Appendable\",\n                \"java.nio.Buffer\",\n                \"java.lang.Readable\",\n                \"java.lang.Comparable<java.nio.CharBuffer>\"\n        ));\n    }\n\n    @Test\n    void testDirectAncestorsOfClassWithInterfaces() {\n        Set<String> ancestors = string.getDirectAncestors()\n                .stream()\n                .map(ResolvedReferenceType::describe)\n                .collect(Collectors.toSet());\n\n        // FIXME: Remove this temporary fix which varies the test based on the detected JDK which is running these tests.\n        TestJdk currentJdk = TestJdk.getCurrentHostJdk();\n        if (currentJdk.getMajorVersion() < 12) {\n            // JDK 12 introduced \"java.lang.constant.Constable\"\n            assertThat(ancestors, containsInAnyOrder(\n                    \"java.lang.CharSequence\",\n                    \"java.lang.Object\",\n                    \"java.lang.Comparable<java.lang.String>\",\n                    \"java.io.Serializable\"\n            ));\n        } else {\n            // JDK 12 introduced \"java.lang.constant.Constable\"\n            assertThat(ancestors, containsInAnyOrder(\n                    \"java.lang.CharSequence\",\n                    \"java.lang.Object\",\n                    \"java.lang.Comparable<java.lang.String>\",\n                    \"java.io.Serializable\",\n                    \"java.lang.constant.Constable\",\n                    \"java.lang.constant.ConstantDesc\"\n            ));\n        }\n    }\n\n    @Test\n    void testDeclaredFields() {\n        TypeSolver typeSolver = new ReflectionTypeSolver();\n        String code = \"class A { private int i; char c; public long l; } class B extends A { private float f; boolean b; };\";\n        ParserConfiguration parserConfiguration = new ParserConfiguration();\n        parserConfiguration.setSymbolResolver(new JavaSymbolSolver(typeSolver));\n\n        CompilationUnit cu = new JavaParser(parserConfiguration)\n                .parse(ParseStart.COMPILATION_UNIT, new StringProvider(code)).getResult().get();\n\n        ClassOrInterfaceDeclaration classA = cu.getClassByName(\"A\").get();\n        ClassOrInterfaceDeclaration classB = cu.getClassByName(\"B\").get();\n\n        ResolvedReferenceType rtA = new ReferenceTypeImpl(classA.resolve());\n        ResolvedReferenceType rtB = new ReferenceTypeImpl(classB.resolve());\n\n        assertEquals(3, rtA.getDeclaredFields().size());\n        assertTrue(rtA.getDeclaredFields().stream().anyMatch(f -> f.getName().equals(\"i\")));\n        assertTrue(rtA.getDeclaredFields().stream().anyMatch(f -> f.getName().equals(\"c\")));\n        assertTrue(rtA.getDeclaredFields().stream().anyMatch(f -> f.getName().equals(\"l\")));\n\n        assertEquals(2, rtB.getDeclaredFields().size());\n        assertTrue(rtB.getDeclaredFields().stream().anyMatch(f -> f.getName().equals(\"f\")));\n        assertTrue(rtB.getDeclaredFields().stream().anyMatch(f -> f.getName().equals(\"b\")));\n    }\n\n    @Test\n    void testGetAllFieldsVisibleToInheritors() {\n        TypeSolver typeSolver = new ReflectionTypeSolver();\n        String code = \"class A { private int i; char c; public long l; } class B extends A { private float f; boolean b; };\";\n        ParserConfiguration parserConfiguration = new ParserConfiguration();\n        parserConfiguration.setSymbolResolver(new JavaSymbolSolver(typeSolver));\n\n        CompilationUnit cu = new JavaParser(parserConfiguration)\n                .parse(ParseStart.COMPILATION_UNIT, new StringProvider(code)).getResult().get();\n\n        ClassOrInterfaceDeclaration classA = cu.getClassByName(\"A\").get();\n        ClassOrInterfaceDeclaration classB = cu.getClassByName(\"B\").get();\n\n        ResolvedReferenceType rtA = new ReferenceTypeImpl(classA.resolve());\n        ResolvedReferenceType rtB = new ReferenceTypeImpl(classB.resolve());\n\n        assertEquals(2, rtA.getAllFieldsVisibleToInheritors().size());\n        assertTrue(rtA.getAllFieldsVisibleToInheritors().stream().anyMatch(f -> f.getName().equals(\"c\")));\n        assertTrue(rtA.getAllFieldsVisibleToInheritors().stream().anyMatch(f -> f.getName().equals(\"l\")));\n\n        assertEquals(3, rtB.getAllFieldsVisibleToInheritors().size());\n        assertTrue(rtB.getAllFieldsVisibleToInheritors().stream().anyMatch(f -> f.getName().equals(\"c\")));\n        assertTrue(rtB.getAllFieldsVisibleToInheritors().stream().anyMatch(f -> f.getName().equals(\"l\")));\n        assertTrue(rtB.getAllFieldsVisibleToInheritors().stream().anyMatch(f -> f.getName().equals(\"b\")));\n    }\n    \n    @Test\n    void erasure_non_generic_type() {\n        List<ResolvedType> types = declaredTypes(\n                \"class A {}\");\n        ResolvedType expected = types.get(0);\n        assertEquals(expected, types.get(0).erasure());\n    }\n    \n    @Test\n    // The erasure of a parameterized type\n    void erasure_rawtype() {\n        List<ResolvedType> types = declaredTypes(\n                \"class A<String> {}\");\n        ResolvedType rt = types.get(0);\n        String expected = \"A\";\n        ResolvedType erasedType = rt.erasure();\n        assertTrue(rt.asReferenceType().isRawType());\n        assertTrue(erasedType.asReferenceType().typeParametersValues().isEmpty());\n        assertEquals(expected, erasedType.describe());\n    }\n\n    @Test\n    // The erasure of an array type T[] is |T|[].\n    void erasure_arraytype() {\n        // create a type : List <String>\n        ResolvedType genericList = array(genericType(List.class.getCanonicalName(), String.class.getCanonicalName()));\n        String expected = \"java.util.List[]\";\n        assertEquals(expected, genericList.erasure().describe());\n    }\n    \n    @Test\n    // The erasure of an array type T[] is |T|[].\n    void erasure_arraytype_with_bound() {\n        // create a type : List <T extends Serializable>\n        ResolvedTypeVariable typeArguments = parametrizedType(\"T\", Serializable.class.getCanonicalName());\n        ResolvedType genericList = array(genericType(List.class.getCanonicalName(), typeArguments));\n        String expected = \"java.util.List<java.io.Serializable>[]\";\n        assertEquals(expected, genericList.erasure().describe());\n    }\n    \n    @Test\n    // The erasure of a type variable (\u00a74.4) is the erasure of its leftmost bound.\n    void erasure_type_variable() {\n        List<ResolvedType> types = declaredTypes(\n                \"class A<T extends Number> {}\");\n        ResolvedType rt = types.get(0);\n        String expected =  \"A<java.lang.Number>\";\n        assertEquals(expected, rt.erasure().describe());\n    }\n    \n    @Test\n    // The erasure of a nested type T.C is |T|.C.\n    void erasure_nested_type() {\n        List<ResolvedType> types = declaredTypes(\n                \"class A<T> {\" +\n                        \"  class C{}\" +\n                        \"}\",\n                \"class A {\" +\n                        \"  class C{}\" +\n                        \"}\");\n        ResolvedType typeA = types.get(0);\n        ResolvedType typeC = types.get(1);\n        // ResolvedType expectedErasedAType= types.get(2);\n        ResolvedType expectedErasedCType = types.get(3);\n        String expectedA = \"A\";\n        String expectedC = \"A.C\";\n        assertEquals(expectedA, typeA.erasure().describe());\n        assertEquals(expectedC, typeC.erasure().describe());\n        // this type declaration are not equals because the type returned by typeA.erasure() always contains original\n        // typeParameters\n        // assertEquals(expectedErasedAType, typeA.erasure());\n        assertEquals(expectedErasedCType, typeC.erasure());\n    }\n    \n    // return a generic type with type arguments (arguments can be bounded)\n    private ResolvedType genericType(String type, ResolvedType... parameterTypes) {\n        return type(type, toList(parameterTypes));\n    }\n    \n    // return a generic type with type arguments\n    private ResolvedType genericType(String type, String... parameterTypes) {\n        return new ReferenceTypeImpl(typeSolver.solveType(type), types(parameterTypes));\n    }\n    \n    // return a list of types\n    private List<ResolvedType> types(String... types) {\n        return Arrays.stream(types).map(type -> type(type)).collect(Collectors.toList());\n    }\n\n    // return the specified type\n    private ResolvedType type(String type) {\n        return type(type, new ArrayList<>());\n    }\n    \n    private ResolvedType type(String type, List<ResolvedType> typeArguments) {\n        return new ReferenceTypeImpl(typeSolver.solveType(type), typeArguments);\n    }\n    \n    // return a type parameter\n    private ResolvedTypeVariable parametrizedType(String type, String parameterType) {\n        return new ResolvedTypeVariable(ResolvedTypeParameterDeclaration.onType(parameterType, type + \".\" + parameterType,\n                Arrays.asList((extendBound(parameterType)))));\n    }\n\n    // rturn an extend bound\n    private Bound extendBound(String type) {\n        return Bound.extendsBound(type(type));\n    }\n\n    private Set<ResolvedType> toSet(ResolvedType... resolvedTypes) {\n        return new HashSet<>(toList(resolvedTypes));\n    }\n    \n    private List<ResolvedType> toList(ResolvedType... resolvedTypes) {\n        return Arrays.asList(resolvedTypes);\n    }\n    \n    // return an array type from the base type\n    private ResolvedType array(ResolvedType baseType) {\n        return new ResolvedArrayType(baseType);\n    }\n    \n    // return a list of types from the declared types (using a static parser) \n    private List<ResolvedType> declaredTypes(String... lines) {\n        CompilationUnit tree = treeOf(lines);\n        List<ResolvedType> results = Lists.newLinkedList();\n        for (ClassOrInterfaceDeclaration classTree : tree.findAll(ClassOrInterfaceDeclaration.class)) {\n            results.add(new ReferenceTypeImpl(classTree.resolve()));\n        }\n        return results;\n    }\n\n    private CompilationUnit treeOf(String... lines) {\n        StringBuilder builder = new StringBuilder();\n        for (String line : lines) {\n            builder.append(line).append(System.lineSeparator());\n        }\n        return StaticJavaParser.parse(builder.toString());\n    }\n    \n}\n",
        "filePathAfter": "javaparser-symbol-solver-testing/src/test/java/com/github/javaparser/symbolsolver/model/typesystem/ReferenceTypeTest.java",
        "sourceCodeAfterForWhole": "/*\n * Copyright (C) 2015-2016 Federico Tomassetti\n * Copyright (C) 2017-2023 The JavaParser Team.\n *\n * This file is part of JavaParser.\n *\n * JavaParser can be used either under the terms of\n * a) the GNU Lesser General Public License as published by\n *     the Free Software Foundation, either version 3 of the License, or\n *     (at your option) any later version.\n * b) the terms of the Apache License\n *\n * You should have received a copy of both licenses in LICENCE.LGPL and\n * LICENCE.APACHE. Please refer to those files for details.\n *\n * JavaParser is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n */\n\npackage com.github.javaparser.symbolsolver.model.typesystem;\n\nimport static org.hamcrest.CoreMatchers.*;\nimport static org.hamcrest.MatcherAssert.assertThat;\nimport static org.hamcrest.collection.IsIterableContainingInAnyOrder.containsInAnyOrder;\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport java.io.IOException;\nimport java.io.Serializable;\nimport java.net.ProtocolException;\nimport java.nio.Buffer;\nimport java.nio.CharBuffer;\nimport java.nio.file.FileSystemException;\nimport java.util.*;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\n\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\nimport com.github.javaparser.*;\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;\nimport com.github.javaparser.resolution.TypeSolver;\nimport com.github.javaparser.resolution.declarations.*;\nimport com.github.javaparser.resolution.declarations.ResolvedTypeParameterDeclaration.Bound;\nimport com.github.javaparser.resolution.model.typesystem.NullType;\nimport com.github.javaparser.resolution.model.typesystem.ReferenceTypeImpl;\nimport com.github.javaparser.resolution.types.*;\nimport com.github.javaparser.symbolsolver.AbstractSymbolResolutionTest;\nimport com.github.javaparser.symbolsolver.JavaSymbolSolver;\nimport com.github.javaparser.symbolsolver.reflectionmodel.ReflectionClassDeclaration;\nimport com.github.javaparser.symbolsolver.reflectionmodel.ReflectionInterfaceDeclaration;\nimport com.github.javaparser.symbolsolver.resolution.typesolvers.ReflectionTypeSolver;\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.Lists;\n\nclass ReferenceTypeTest extends AbstractSymbolResolutionTest {\n\n    private ReferenceTypeImpl listOfA;\n    private ReferenceTypeImpl listOfStrings;\n    private ReferenceTypeImpl linkedListOfString;\n    private ReferenceTypeImpl collectionOfString;\n    private ReferenceTypeImpl listOfWildcardExtendsString;\n    private ReferenceTypeImpl listOfWildcardSuperString;\n    private ReferenceTypeImpl object;\n    private ReferenceTypeImpl string;\n    private TypeSolver typeSolver;\n    private ReferenceTypeImpl ioException;\n    private ResolvedType unionWithIOExceptionAsCommonAncestor;\n    private ResolvedType unionWithThrowableAsCommonAncestor;\n\n    @BeforeEach\n    void setup() {\n        typeSolver = new ReflectionTypeSolver();\n        object = new ReferenceTypeImpl(new ReflectionClassDeclaration(Object.class, typeSolver));\n        string = new ReferenceTypeImpl(new ReflectionClassDeclaration(String.class, typeSolver));\n        listOfA = new ReferenceTypeImpl(\n                new ReflectionInterfaceDeclaration(List.class, typeSolver),\n                ImmutableList.of(new ResolvedTypeVariable(ResolvedTypeParameterDeclaration.onType(\"A\", \"foo.Bar\", Collections.emptyList()))));\n        listOfStrings = new ReferenceTypeImpl(\n                new ReflectionInterfaceDeclaration(List.class, typeSolver),\n                ImmutableList.of(new ReferenceTypeImpl(new ReflectionClassDeclaration(String.class, typeSolver))));\n        linkedListOfString = new ReferenceTypeImpl(\n                new ReflectionClassDeclaration(LinkedList.class, typeSolver),\n                ImmutableList.of(new ReferenceTypeImpl(new ReflectionClassDeclaration(String.class, typeSolver))));\n        collectionOfString = new ReferenceTypeImpl(\n                new ReflectionInterfaceDeclaration(Collection.class, typeSolver),\n                ImmutableList.of(new ReferenceTypeImpl(new ReflectionClassDeclaration(String.class, typeSolver))));\n        listOfWildcardExtendsString = new ReferenceTypeImpl(\n                new ReflectionInterfaceDeclaration(List.class, typeSolver),\n                ImmutableList.of(ResolvedWildcard.extendsBound(string)));\n        listOfWildcardSuperString = new ReferenceTypeImpl(\n                new ReflectionInterfaceDeclaration(List.class, typeSolver),\n                ImmutableList.of(ResolvedWildcard.superBound(string)));\n        ioException = new ReferenceTypeImpl(new ReflectionClassDeclaration(IOException.class, typeSolver));\n        unionWithIOExceptionAsCommonAncestor = new ResolvedUnionType(Arrays.asList(\n                new ReferenceTypeImpl(new ReflectionClassDeclaration(ProtocolException.class, typeSolver)),\n                new ReferenceTypeImpl(new ReflectionClassDeclaration(FileSystemException.class, typeSolver))\n        ));\n        unionWithThrowableAsCommonAncestor = new ResolvedUnionType(Arrays.asList(\n                new ReferenceTypeImpl(new ReflectionClassDeclaration(ClassCastException.class, typeSolver)),\n                new ReferenceTypeImpl(new ReflectionClassDeclaration(AssertionError.class, typeSolver))\n        ));\n\n        // minimal initialization of JavaParser\n        ParserConfiguration configuration = new ParserConfiguration()\n                .setSymbolResolver(new JavaSymbolSolver(new ReflectionTypeSolver()));\n        // Setup parser\n        StaticJavaParser.setConfiguration(configuration);\n    }\n\n    @Test\n    void testDerivationOfTypeParameters() {\n        ReflectionTypeSolver typeSolver = new ReflectionTypeSolver();\n        ReferenceTypeImpl ref1 = new ReferenceTypeImpl(typeSolver.solveType(LinkedList.class.getCanonicalName()));\n        assertEquals(1, ref1.typeParametersValues().size());\n        assertEquals(true, ref1.typeParametersValues().get(0).isTypeVariable());\n        assertEquals(\"E\", ref1.typeParametersValues().get(0).asTypeParameter().getName());\n    }\n\n    @Test\n    void testIsArray() {\n        assertEquals(false, object.isArray());\n        assertEquals(false, string.isArray());\n        assertEquals(false, listOfA.isArray());\n        assertEquals(false, listOfStrings.isArray());\n    }\n\n    @Test\n    void testIsPrimitive() {\n        assertEquals(false, object.isPrimitive());\n        assertEquals(false, string.isPrimitive());\n        assertEquals(false, listOfA.isPrimitive());\n        assertEquals(false, listOfStrings.isPrimitive());\n    }\n\n    @Test\n    void testIsNull() {\n        assertEquals(false, object.isNull());\n        assertEquals(false, string.isNull());\n        assertEquals(false, listOfA.isNull());\n        assertEquals(false, listOfStrings.isNull());\n    }\n\n    @Test\n    void testIsReference() {\n        assertEquals(true, object.isReference());\n        assertEquals(true, string.isReference());\n        assertEquals(true, listOfA.isReference());\n        assertEquals(true, listOfStrings.isReference());\n    }\n\n    @Test\n    void testIsReferenceType() {\n        assertEquals(true, object.isReferenceType());\n        assertEquals(true, string.isReferenceType());\n        assertEquals(true, listOfA.isReferenceType());\n        assertEquals(true, listOfStrings.isReferenceType());\n    }\n\n    @Test\n    void testIsVoid() {\n        assertEquals(false, object.isVoid());\n        assertEquals(false, string.isVoid());\n        assertEquals(false, listOfA.isVoid());\n        assertEquals(false, listOfStrings.isVoid());\n    }\n\n    @Test\n    void testIsTypeVariable() {\n        assertEquals(false, object.isTypeVariable());\n        assertEquals(false, string.isTypeVariable());\n        assertEquals(false, listOfA.isTypeVariable());\n        assertEquals(false, listOfStrings.isTypeVariable());\n    }\n\n    @Test\n    void testAsReferenceTypeUsage() {\n        assertTrue(object == object.asReferenceType());\n        assertTrue(string == string.asReferenceType());\n        assertTrue(listOfA == listOfA.asReferenceType());\n        assertTrue(listOfStrings == listOfStrings.asReferenceType());\n    }\n\n    @Test\n    void testAsTypeParameter() {\n        assertThrows(UnsupportedOperationException.class, () -> object.asTypeParameter());\n    }\n\n    @Test\n    void testAsArrayTypeUsage() {\n        assertThrows(UnsupportedOperationException.class, () -> object.asArrayType());\n    }\n\n    @Test\n    void testAsDescribe() {\n        assertEquals(\"java.lang.Object\", object.describe());\n        assertEquals(\"java.lang.String\", string.describe());\n        assertEquals(\"java.util.List<A>\", listOfA.describe());\n        assertEquals(\"java.util.List<java.lang.String>\", listOfStrings.describe());\n    }\n\n    @Test\n    void testReplaceParam() {\n        ResolvedTypeParameterDeclaration tpA = ResolvedTypeParameterDeclaration.onType(\"A\", \"foo.Bar\", Collections.emptyList());\n        assertTrue(object == object.replaceTypeVariables(tpA, object));\n        assertTrue(string == string.replaceTypeVariables(tpA, object));\n        assertEquals(listOfStrings, listOfStrings.replaceTypeVariables(tpA, object));\n        assertEquals(listOfStrings, listOfA.replaceTypeVariables(tpA, string));\n    }\n\n    @Test\n    void testIsAssignableBySimple() {\n        assertEquals(true, object.isAssignableBy(string));\n        assertEquals(false, string.isAssignableBy(object));\n        assertEquals(false, listOfStrings.isAssignableBy(listOfA));\n        assertEquals(false, listOfA.isAssignableBy(listOfStrings));\n\n        assertEquals(false, object.isAssignableBy(ResolvedVoidType.INSTANCE));\n        assertEquals(false, string.isAssignableBy(ResolvedVoidType.INSTANCE));\n        assertEquals(false, listOfStrings.isAssignableBy(ResolvedVoidType.INSTANCE));\n        assertEquals(false, listOfA.isAssignableBy(ResolvedVoidType.INSTANCE));\n\n        assertEquals(true, object.isAssignableBy(NullType.INSTANCE));\n        assertEquals(true, string.isAssignableBy(NullType.INSTANCE));\n        assertEquals(true, listOfStrings.isAssignableBy(NullType.INSTANCE));\n        assertEquals(true, listOfA.isAssignableBy(NullType.INSTANCE));\n    }\n\n    @Test\n    void testIsAssignableByBoxedPrimitive() {\n        ResolvedReferenceType numberType = new ReferenceTypeImpl(new ReflectionClassDeclaration(Number.class, typeSolver));\n        ResolvedReferenceType intType = new ReferenceTypeImpl(new ReflectionClassDeclaration(Integer.class, typeSolver));\n        ResolvedReferenceType doubleType = new ReferenceTypeImpl(new ReflectionClassDeclaration(Double.class, typeSolver));\n        ResolvedReferenceType byteType = new ReferenceTypeImpl(new ReflectionClassDeclaration(Byte.class, typeSolver));\n        ResolvedReferenceType shortType = new ReferenceTypeImpl(new ReflectionClassDeclaration(Short.class, typeSolver));\n        ResolvedReferenceType charType = new ReferenceTypeImpl(new ReflectionClassDeclaration(Character.class, typeSolver));\n        ResolvedReferenceType longType = new ReferenceTypeImpl(new ReflectionClassDeclaration(Long.class, typeSolver));\n        ResolvedReferenceType booleanType = new ReferenceTypeImpl(new ReflectionClassDeclaration(Boolean.class, typeSolver));\n        ResolvedReferenceType floatType = new ReferenceTypeImpl(new ReflectionClassDeclaration(Float.class, typeSolver));\n\n        assertEquals(true, numberType.isAssignableBy(ResolvedPrimitiveType.INT));\n        assertEquals(true, numberType.isAssignableBy(ResolvedPrimitiveType.DOUBLE));\n        assertEquals(true, numberType.isAssignableBy(ResolvedPrimitiveType.SHORT));\n        assertEquals(true, numberType.isAssignableBy(ResolvedPrimitiveType.LONG));\n        assertEquals(true, numberType.isAssignableBy(ResolvedPrimitiveType.FLOAT));\n        assertEquals(false, numberType.isAssignableBy(ResolvedPrimitiveType.BOOLEAN));\n        assertEquals(true, intType.isAssignableBy(ResolvedPrimitiveType.INT));\n        assertEquals(true, doubleType.isAssignableBy(ResolvedPrimitiveType.DOUBLE));\n        assertEquals(true, byteType.isAssignableBy(ResolvedPrimitiveType.BYTE));\n        assertEquals(true, shortType.isAssignableBy(ResolvedPrimitiveType.SHORT));\n        assertEquals(true, charType.isAssignableBy(ResolvedPrimitiveType.CHAR));\n        assertEquals(true, longType.isAssignableBy(ResolvedPrimitiveType.LONG));\n        assertEquals(true, booleanType.isAssignableBy(ResolvedPrimitiveType.BOOLEAN));\n        assertEquals(true, floatType.isAssignableBy(ResolvedPrimitiveType.FLOAT));\n    }\n\n    @Test\n    void testIsCorresponding() {\n\n        // ResolvedReferenceTypeTester is defined to allow to test protected method isCorrespondingBoxingType(..)\n        class ResolvedReferenceTypeTester extends ReferenceTypeImpl {\n\n            public ResolvedReferenceTypeTester(ResolvedReferenceTypeDeclaration typeDeclaration,\n                                               TypeSolver typeSolver) {\n                super(typeDeclaration);\n            }\n\n            @Override\n\t\t\tpublic boolean isCorrespondingBoxingType(String name) {\n                return super.isCorrespondingBoxingType(name);\n            }\n\n        }\n\n        ResolvedReferenceTypeTester numberType = new ResolvedReferenceTypeTester(\n                new ReflectionClassDeclaration(Number.class, typeSolver), typeSolver);\n        ResolvedReferenceTypeTester intType = new ResolvedReferenceTypeTester(\n                new ReflectionClassDeclaration(Integer.class, typeSolver), typeSolver);\n        ResolvedReferenceTypeTester doubleType = new ResolvedReferenceTypeTester(\n                new ReflectionClassDeclaration(Double.class, typeSolver), typeSolver);\n        ResolvedReferenceTypeTester byteType = new ResolvedReferenceTypeTester(\n                new ReflectionClassDeclaration(Byte.class, typeSolver), typeSolver);\n        ResolvedReferenceTypeTester shortType = new ResolvedReferenceTypeTester(\n                new ReflectionClassDeclaration(Short.class, typeSolver), typeSolver);\n        ResolvedReferenceTypeTester charType = new ResolvedReferenceTypeTester(\n                new ReflectionClassDeclaration(Character.class, typeSolver), typeSolver);\n        ResolvedReferenceTypeTester longType = new ResolvedReferenceTypeTester(\n                new ReflectionClassDeclaration(Long.class, typeSolver), typeSolver);\n        ResolvedReferenceTypeTester booleanType = new ResolvedReferenceTypeTester(\n                new ReflectionClassDeclaration(Boolean.class, typeSolver), typeSolver);\n        ResolvedReferenceTypeTester floatType = new ResolvedReferenceTypeTester(\n                new ReflectionClassDeclaration(Float.class, typeSolver), typeSolver);\n\n        ResolvedReferenceTypeTester otherType = new ResolvedReferenceTypeTester(\n                new ReflectionClassDeclaration(String.class, typeSolver), typeSolver);\n\n        assertEquals(true, intType.isCorrespondingBoxingType(ResolvedPrimitiveType.INT.describe()));\n        assertEquals(true, doubleType.isCorrespondingBoxingType(ResolvedPrimitiveType.DOUBLE.describe()));\n        assertEquals(true, byteType.isCorrespondingBoxingType(ResolvedPrimitiveType.BYTE.describe()));\n        assertEquals(true, shortType.isCorrespondingBoxingType(ResolvedPrimitiveType.SHORT.describe()));\n        assertEquals(true, charType.isCorrespondingBoxingType(ResolvedPrimitiveType.CHAR.describe()));\n        assertEquals(true, longType.isCorrespondingBoxingType(ResolvedPrimitiveType.LONG.describe()));\n        assertEquals(true, booleanType.isCorrespondingBoxingType(ResolvedPrimitiveType.BOOLEAN.describe()));\n        assertEquals(true, floatType.isCorrespondingBoxingType(ResolvedPrimitiveType.FLOAT.describe()));\n\n        assertEquals(false, numberType.isCorrespondingBoxingType(ResolvedPrimitiveType.INT.describe()));\n\n        assertThrows(IllegalArgumentException.class, () -> {\n            intType.isCorrespondingBoxingType(\"String\");\n        });\n    }\n\n    @Test\n    void testIsAssignableByGenerics() {\n        assertEquals(false, listOfStrings.isAssignableBy(listOfWildcardExtendsString));\n        assertEquals(false, listOfStrings.isAssignableBy(listOfWildcardExtendsString));\n        assertEquals(true, listOfWildcardExtendsString.isAssignableBy(listOfStrings));\n        assertEquals(false, listOfWildcardExtendsString.isAssignableBy(listOfWildcardSuperString));\n        assertEquals(true, listOfWildcardSuperString.isAssignableBy(listOfStrings));\n        assertEquals(false, listOfWildcardSuperString.isAssignableBy(listOfWildcardExtendsString));\n    }\n\n    @Test\n    void testIsAssignableByGenericsInheritance() {\n        assertEquals(true, collectionOfString.isAssignableBy(collectionOfString));\n        assertEquals(true, collectionOfString.isAssignableBy(listOfStrings));\n        assertEquals(true, collectionOfString.isAssignableBy(linkedListOfString));\n\n        assertEquals(false, listOfStrings.isAssignableBy(collectionOfString));\n        assertEquals(true, listOfStrings.isAssignableBy(listOfStrings));\n        assertEquals(true, listOfStrings.isAssignableBy(linkedListOfString));\n\n        assertEquals(false, linkedListOfString.isAssignableBy(collectionOfString));\n        assertEquals(false, linkedListOfString.isAssignableBy(listOfStrings));\n        assertEquals(true, linkedListOfString.isAssignableBy(linkedListOfString));\n    }\n\n    @Test\n    void testIsAssignableByUnionType() {\n        assertEquals(true, ioException.isAssignableBy(unionWithIOExceptionAsCommonAncestor));\n        assertEquals(false, ioException.isAssignableBy(unionWithThrowableAsCommonAncestor));\n    }\n\n    @Test\n    void testGetAllAncestorsConsideringTypeParameters() {\n        assertThat(linkedListOfString.getAllAncestors(), hasItem(object));\n        assertThat(linkedListOfString.getAllAncestors(), hasItem(listOfStrings));\n        assertThat(linkedListOfString.getAllAncestors(), hasItem(collectionOfString));\n        assertThat(linkedListOfString.getAllAncestors(), not(hasItem(listOfA)));\n    }\n\n    class Foo {\n\n    }\n\n    class Bar extends Foo {\n\n    }\n\n    class Bazzer<A, B, C> {\n\n    }\n\n    class MoreBazzing<A, B> extends Bazzer<B, String, A> {\n\n    }\n\n    @Test\n    void testGetAllAncestorsConsideringGenericsCases() {\n        ReferenceTypeImpl foo = new ReferenceTypeImpl(new ReflectionClassDeclaration(Foo.class, typeSolver));\n        ReferenceTypeImpl bar = new ReferenceTypeImpl(new ReflectionClassDeclaration(Bar.class, typeSolver));\n        ReferenceTypeImpl left, right;\n\n        //YES MoreBazzing<Foo, Bar> e1 = new MoreBazzing<Foo, Bar>();\n        assertEquals(true,\n                new ReferenceTypeImpl(\n                        new ReflectionClassDeclaration(MoreBazzing.class, typeSolver),\n                        ImmutableList.of(foo, bar))\n                        .isAssignableBy(new ReferenceTypeImpl(\n                                new ReflectionClassDeclaration(MoreBazzing.class, typeSolver),\n                                ImmutableList.of(foo, bar)))\n        );\n\n        //YES MoreBazzing<? extends Foo, Bar> e2 = new MoreBazzing<Foo, Bar>();\n        assertEquals(true,\n                new ReferenceTypeImpl(\n                        new ReflectionClassDeclaration(MoreBazzing.class, typeSolver),\n                        ImmutableList.of(ResolvedWildcard.extendsBound(foo), bar))\n                        .isAssignableBy(new ReferenceTypeImpl(\n                                new ReflectionClassDeclaration(MoreBazzing.class, typeSolver),\n                                ImmutableList.of(foo, bar)))\n        );\n\n        //YES MoreBazzing<Foo, ? extends Bar> e3 = new MoreBazzing<Foo, Bar>();\n        assertEquals(true,\n                new ReferenceTypeImpl(\n                        new ReflectionClassDeclaration(MoreBazzing.class, typeSolver),\n                        ImmutableList.of(foo, ResolvedWildcard.extendsBound(bar)))\n                        .isAssignableBy(new ReferenceTypeImpl(\n                                new ReflectionClassDeclaration(MoreBazzing.class, typeSolver),\n                                ImmutableList.of(foo, bar)))\n        );\n\n        //YES MoreBazzing<? extends Foo, ? extends Foo> e4 = new MoreBazzing<Foo, Bar>();\n        assertEquals(true,\n                new ReferenceTypeImpl(\n                        new ReflectionClassDeclaration(MoreBazzing.class, typeSolver),\n                        ImmutableList.of(ResolvedWildcard.extendsBound(foo), ResolvedWildcard.extendsBound(foo)))\n                        .isAssignableBy(new ReferenceTypeImpl(\n                                new ReflectionClassDeclaration(MoreBazzing.class, typeSolver),\n                                ImmutableList.of(foo, bar)))\n        );\n\n        //YES MoreBazzing<? extends Foo, ? extends Foo> e5 = new MoreBazzing<Bar, Bar>();\n        left = new ReferenceTypeImpl(\n                new ReflectionClassDeclaration(MoreBazzing.class, typeSolver),\n                ImmutableList.of(ResolvedWildcard.extendsBound(foo), ResolvedWildcard.extendsBound(foo)));\n        right = new ReferenceTypeImpl(\n                new ReflectionClassDeclaration(MoreBazzing.class, typeSolver),\n                ImmutableList.of(bar, bar));\n        assertEquals(true, left.isAssignableBy(right));\n\n        //YES Bazzer<Object, String, String> e6 = new MoreBazzing<String, Object>();\n        left = new ReferenceTypeImpl(\n                new ReflectionClassDeclaration(Bazzer.class, typeSolver),\n                ImmutableList.of(object, string, string));\n        right = new ReferenceTypeImpl(\n                new ReflectionClassDeclaration(MoreBazzing.class, typeSolver),\n                ImmutableList.of(string, object));\n\n        // To debug the following\n        List<ResolvedReferenceType> ancestors = right.getAllAncestors();\n        ResolvedReferenceType moreBazzingAncestor = ancestors.stream()\n                .filter(a -> a.getQualifiedName().endsWith(\"Bazzer\"))\n                .findFirst().get();\n\n        assertEquals(true, left.isAssignableBy(right));\n\n        //YES Bazzer<String,String,String> e7 = new MoreBazzing<String, String>();\n        assertEquals(true,\n                new ReferenceTypeImpl(\n                        new ReflectionClassDeclaration(Bazzer.class, typeSolver),\n                        ImmutableList.of(string, string, string))\n                        .isAssignableBy(new ReferenceTypeImpl(\n                                new ReflectionClassDeclaration(MoreBazzing.class, typeSolver),\n                                ImmutableList.of(string, string)))\n        );\n\n        //YES Bazzer<Bar,String,Foo> e8 = new MoreBazzing<Foo, Bar>();\n        assertEquals(true,\n                new ReferenceTypeImpl(\n                        new ReflectionClassDeclaration(Bazzer.class, typeSolver),\n                        ImmutableList.of(bar, string, foo))\n                        .isAssignableBy(new ReferenceTypeImpl(\n                                new ReflectionClassDeclaration(MoreBazzing.class, typeSolver),\n                                ImmutableList.of(foo, bar)))\n        );\n\n        //YES Bazzer<Foo,String,Bar> e9 = new MoreBazzing<Bar, Foo>();\n        assertEquals(true,\n                new ReferenceTypeImpl(\n                        new ReflectionClassDeclaration(Bazzer.class, typeSolver),\n                        ImmutableList.of(foo, string, bar))\n                        .isAssignableBy(new ReferenceTypeImpl(\n                                new ReflectionClassDeclaration(MoreBazzing.class, typeSolver),\n                                ImmutableList.of(bar, foo)))\n        );\n\n        //NO Bazzer<Bar,String,Foo> n1 = new MoreBazzing<Bar, Foo>();\n        assertEquals(false,\n                new ReferenceTypeImpl(\n                        new ReflectionClassDeclaration(Bazzer.class, typeSolver),\n                        ImmutableList.of(bar, string, foo))\n                        .isAssignableBy(new ReferenceTypeImpl(\n                                new ReflectionClassDeclaration(MoreBazzing.class, typeSolver),\n                                ImmutableList.of(bar, foo)))\n        );\n\n        //NO Bazzer<Bar,String,Bar> n2 = new MoreBazzing<Bar, Foo>();\n        assertEquals(false,\n                new ReferenceTypeImpl(\n                        new ReflectionClassDeclaration(Bazzer.class, typeSolver),\n                        ImmutableList.of(bar, string, foo))\n                        .isAssignableBy(new ReferenceTypeImpl(\n                                new ReflectionClassDeclaration(MoreBazzing.class, typeSolver),\n                                ImmutableList.of(bar, foo)))\n        );\n\n        //NO Bazzer<Foo,Object,Bar> n3 = new MoreBazzing<Bar, Foo>();\n        assertEquals(false,\n                new ReferenceTypeImpl(\n                        new ReflectionClassDeclaration(Bazzer.class, typeSolver),\n                        ImmutableList.of(foo, object, bar))\n                        .isAssignableBy(new ReferenceTypeImpl(\n                                new ReflectionClassDeclaration(MoreBazzing.class, typeSolver),\n                                ImmutableList.of(bar, foo)))\n        );\n    }\n\n    @Test\n    void charSequenceIsAssignableToObject() {\n        TypeSolver typeSolver = new ReflectionTypeSolver();\n        ReferenceTypeImpl charSequence = new ReferenceTypeImpl(new ReflectionInterfaceDeclaration(CharSequence.class, typeSolver));\n        ReferenceTypeImpl object = new ReferenceTypeImpl(new ReflectionClassDeclaration(Object.class, typeSolver));\n        assertEquals(false, charSequence.isAssignableBy(object));\n        assertEquals(true, object.isAssignableBy(charSequence));\n    }\n\n    @Test\n    void testGetFieldTypeExisting() {\n        class Foo<A> {\n\n            List<A> elements;\n        }\n\n        TypeSolver typeSolver = new ReflectionTypeSolver();\n        ReferenceTypeImpl ref = new ReferenceTypeImpl(new ReflectionClassDeclaration(Foo.class, typeSolver));\n\n        assertEquals(true, ref.getFieldType(\"elements\").isPresent());\n        assertEquals(true, ref.getFieldType(\"elements\").get().isReferenceType());\n        assertEquals(List.class.getCanonicalName(), ref.getFieldType(\"elements\").get().asReferenceType().getQualifiedName());\n        assertEquals(1, ref.getFieldType(\"elements\").get().asReferenceType().typeParametersValues().size());\n        assertEquals(true, ref.getFieldType(\"elements\").get().asReferenceType().typeParametersValues().get(0).isTypeVariable());\n        assertEquals(\"A\", ref.getFieldType(\"elements\").get().asReferenceType().typeParametersValues().get(0).asTypeParameter().getName());\n\n        ref = new ReferenceTypeImpl(new ReflectionClassDeclaration(Foo.class, typeSolver),\n                ImmutableList.of(new ReferenceTypeImpl(new ReflectionClassDeclaration(String.class, typeSolver))));\n\n        assertEquals(true, ref.getFieldType(\"elements\").isPresent());\n        assertEquals(true, ref.getFieldType(\"elements\").get().isReferenceType());\n        assertEquals(List.class.getCanonicalName(), ref.getFieldType(\"elements\").get().asReferenceType().getQualifiedName());\n        assertEquals(1, ref.getFieldType(\"elements\").get().asReferenceType().typeParametersValues().size());\n        assertEquals(true, ref.getFieldType(\"elements\").get().asReferenceType().typeParametersValues().get(0).isReferenceType());\n        assertEquals(String.class.getCanonicalName(), ref.getFieldType(\"elements\").get().asReferenceType().typeParametersValues().get(0).asReferenceType().getQualifiedName());\n    }\n\n    @Test\n    void testGetFieldTypeUnexisting() {\n        class Foo<A> {\n\n            List<A> elements;\n        }\n\n        TypeSolver typeSolver = new ReflectionTypeSolver();\n        ReferenceTypeImpl ref = new ReferenceTypeImpl(new ReflectionClassDeclaration(Foo.class, typeSolver));\n\n        assertEquals(false, ref.getFieldType(\"bar\").isPresent());\n\n        ref = new ReferenceTypeImpl(new ReflectionClassDeclaration(Foo.class, typeSolver),\n                ImmutableList.of(new ReferenceTypeImpl(new ReflectionClassDeclaration(String.class, typeSolver))));\n\n        assertEquals(false, ref.getFieldType(\"bar\").isPresent());\n    }\n\n    @Test\n    void testTypeParamValue() {\n        TypeSolver typeResolver = new ReflectionTypeSolver();\n        ResolvedClassDeclaration arraylist = new ReflectionClassDeclaration(ArrayList.class, typeResolver);\n        ResolvedClassDeclaration abstractList = new ReflectionClassDeclaration(AbstractList.class, typeResolver);\n        ResolvedClassDeclaration abstractCollection = new ReflectionClassDeclaration(AbstractCollection.class, typeResolver);\n        ResolvedInterfaceDeclaration list = new ReflectionInterfaceDeclaration(List.class, typeResolver);\n        ResolvedInterfaceDeclaration collection = new ReflectionInterfaceDeclaration(Collection.class, typeResolver);\n        ResolvedInterfaceDeclaration iterable = new ReflectionInterfaceDeclaration(Iterable.class, typeResolver);\n        ResolvedType string = new ReferenceTypeImpl(new ReflectionClassDeclaration(String.class, typeResolver));\n        ResolvedReferenceType arrayListOfString = new ReferenceTypeImpl(arraylist, ImmutableList.of(string));\n        assertEquals(Optional.of(string), arrayListOfString.typeParamValue(arraylist.getTypeParameters().get(0)));\n        assertEquals(Optional.of(string), arrayListOfString.typeParamValue(abstractList.getTypeParameters().get(0)));\n        assertEquals(Optional.of(string), arrayListOfString.typeParamValue(abstractCollection.getTypeParameters().get(0)));\n        assertEquals(Optional.of(string), arrayListOfString.typeParamValue(list.getTypeParameters().get(0)));\n        assertEquals(Optional.of(string), arrayListOfString.typeParamValue(collection.getTypeParameters().get(0)));\n        assertEquals(Optional.of(string), arrayListOfString.typeParamValue(iterable.getTypeParameters().get(0)));\n    }\n\n    @Test\n    void testGetAllAncestorsOnRawType() {\n        TypeSolver typeResolver = new ReflectionTypeSolver();\n        ResolvedClassDeclaration arraylist = new ReflectionClassDeclaration(ArrayList.class, typeResolver);\n        ResolvedReferenceType rawArrayList = new ReferenceTypeImpl(arraylist);\n\n        Map<String, ResolvedReferenceType> ancestors = new HashMap<>();\n        rawArrayList.getAllAncestors().forEach(a -> ancestors.put(a.getQualifiedName(), a));\n        assertEquals(9, ancestors.size());\n\n        ResolvedTypeVariable tv = new ResolvedTypeVariable(arraylist.getTypeParameters().get(0));\n        assertEquals(new ReferenceTypeImpl(new ReflectionInterfaceDeclaration(RandomAccess.class, typeResolver)), ancestors.get(\"java.util.RandomAccess\"));\n        assertEquals(new ReferenceTypeImpl(new ReflectionClassDeclaration(AbstractCollection.class, typeResolver), ImmutableList.of(tv)), ancestors.get(\"java.util.AbstractCollection\"));\n        assertEquals(new ReferenceTypeImpl(new ReflectionInterfaceDeclaration(List.class, typeResolver), ImmutableList.of(tv)), ancestors.get(\"java.util.List\"));\n        assertEquals(new ReferenceTypeImpl(new ReflectionInterfaceDeclaration(Cloneable.class, typeResolver)), ancestors.get(\"java.lang.Cloneable\"));\n        assertEquals(new ReferenceTypeImpl(new ReflectionInterfaceDeclaration(Collection.class, typeResolver), ImmutableList.of(tv)), ancestors.get(\"java.util.Collection\"));\n        assertEquals(new ReferenceTypeImpl(new ReflectionClassDeclaration(AbstractList.class, typeResolver), ImmutableList.of(tv)), ancestors.get(\"java.util.AbstractList\"));\n        assertEquals(new ReferenceTypeImpl(new ReflectionClassDeclaration(Object.class, typeResolver)), ancestors.get(\"java.lang.Object\"));\n        assertEquals(new ReferenceTypeImpl(new ReflectionInterfaceDeclaration(Iterable.class, typeResolver), ImmutableList.of(tv)), ancestors.get(\"java.lang.Iterable\"));\n        assertEquals(new ReferenceTypeImpl(new ReflectionInterfaceDeclaration(Serializable.class, typeResolver)), ancestors.get(\"java.io.Serializable\"));\n    }\n\n    @Test\n    void testGetAllAncestorsOnTypeWithSpecifiedTypeParametersForInterface() {\n        TypeSolver typeResolver = new ReflectionTypeSolver();\n        ResolvedInterfaceDeclaration list = new ReflectionInterfaceDeclaration(List.class, typeResolver);\n        ResolvedType string = new ReferenceTypeImpl(new ReflectionClassDeclaration(String.class, typeResolver));\n        ResolvedReferenceType listOfString = new ReferenceTypeImpl(list, ImmutableList.of(string));\n\n        Map<String, ResolvedReferenceType> ancestors = new HashMap<>();\n        listOfString.getAllAncestors().forEach(a -> ancestors.put(a.getQualifiedName(), a));\n        assertEquals(2, ancestors.size());\n\n        assertEquals(new ReferenceTypeImpl(new ReflectionInterfaceDeclaration(Collection.class, typeResolver), ImmutableList.of(string)), ancestors.get(\"java.util.Collection\"));\n        assertEquals(new ReferenceTypeImpl(new ReflectionInterfaceDeclaration(Iterable.class, typeResolver), ImmutableList.of(string)), ancestors.get(\"java.lang.Iterable\"));\n    }\n\n    @Test\n    void testGetAllAncestorsOnTypeWithSpecifiedTypeParametersForClassAbstractCollection() {\n        TypeSolver typeResolver = new ReflectionTypeSolver();\n        ResolvedClassDeclaration abstractCollection = new ReflectionClassDeclaration(AbstractCollection.class, typeResolver);\n        ResolvedType string = new ReferenceTypeImpl(new ReflectionClassDeclaration(String.class, typeResolver));\n        ResolvedReferenceType abstractCollectionOfString = new ReferenceTypeImpl(abstractCollection, ImmutableList.of(string));\n\n        Map<String, ResolvedReferenceType> ancestors = new HashMap<>();\n        abstractCollectionOfString.getAllAncestors().forEach(a -> ancestors.put(a.getQualifiedName(), a));\n        assertEquals(3, ancestors.size());\n\n        assertEquals(new ReferenceTypeImpl(new ReflectionInterfaceDeclaration(Collection.class, typeResolver), ImmutableList.of(string)), ancestors.get(\"java.util.Collection\"));\n        assertEquals(new ReferenceTypeImpl(new ReflectionClassDeclaration(Object.class, typeResolver)), ancestors.get(\"java.lang.Object\"));\n        assertEquals(new ReferenceTypeImpl(new ReflectionInterfaceDeclaration(Iterable.class, typeResolver), ImmutableList.of(string)), ancestors.get(\"java.lang.Iterable\"));\n    }\n\n    @Test\n    void testGetAllAncestorsOnTypeWithSpecifiedTypeParametersForClassAbstractList() {\n        TypeSolver typeResolver = new ReflectionTypeSolver();\n        ResolvedClassDeclaration abstractList = new ReflectionClassDeclaration(AbstractList.class, typeResolver);\n        ResolvedType string = new ReferenceTypeImpl(new ReflectionClassDeclaration(String.class, typeResolver));\n        ResolvedReferenceType abstractListOfString = new ReferenceTypeImpl(abstractList, ImmutableList.of(string));\n\n        Map<String, ResolvedReferenceType> ancestors = new HashMap<>();\n        abstractListOfString.getAllAncestors().forEach(a -> ancestors.put(a.getQualifiedName(), a));\n        assertEquals(5, ancestors.size());\n\n        assertEquals(new ReferenceTypeImpl(new ReflectionClassDeclaration(AbstractCollection.class, typeResolver), ImmutableList.of(string)), ancestors.get(\"java.util.AbstractCollection\"));\n        assertEquals(new ReferenceTypeImpl(new ReflectionInterfaceDeclaration(List.class, typeResolver), ImmutableList.of(string)), ancestors.get(\"java.util.List\"));\n        assertEquals(new ReferenceTypeImpl(new ReflectionInterfaceDeclaration(Collection.class, typeResolver), ImmutableList.of(string)), ancestors.get(\"java.util.Collection\"));\n        assertEquals(new ReferenceTypeImpl(new ReflectionClassDeclaration(Object.class, typeResolver)), ancestors.get(\"java.lang.Object\"));\n        assertEquals(new ReferenceTypeImpl(new ReflectionInterfaceDeclaration(Iterable.class, typeResolver), ImmutableList.of(string)), ancestors.get(\"java.lang.Iterable\"));\n    }\n\n    @Test\n    void testGetAllAncestorsOnTypeWithSpecifiedTypeParametersForClassArrayList() {\n        TypeSolver typeResolver = new ReflectionTypeSolver();\n        ResolvedClassDeclaration arraylist = new ReflectionClassDeclaration(ArrayList.class, typeResolver);\n        ResolvedType string = new ReferenceTypeImpl(new ReflectionClassDeclaration(String.class, typeResolver));\n        ResolvedReferenceType arrayListOfString = new ReferenceTypeImpl(arraylist, ImmutableList.of(string));\n\n        Map<String, ResolvedReferenceType> ancestors = new HashMap<>();\n        arrayListOfString.getAllAncestors().forEach(a -> ancestors.put(a.getQualifiedName(), a));\n        assertEquals(9, ancestors.size());\n\n        assertEquals(new ReferenceTypeImpl(new ReflectionInterfaceDeclaration(RandomAccess.class, typeResolver)), ancestors.get(\"java.util.RandomAccess\"));\n        assertEquals(new ReferenceTypeImpl(new ReflectionClassDeclaration(AbstractCollection.class, typeResolver), ImmutableList.of(string)), ancestors.get(\"java.util.AbstractCollection\"));\n        assertEquals(new ReferenceTypeImpl(new ReflectionInterfaceDeclaration(List.class, typeResolver), ImmutableList.of(string)), ancestors.get(\"java.util.List\"));\n        assertEquals(new ReferenceTypeImpl(new ReflectionInterfaceDeclaration(Cloneable.class, typeResolver)), ancestors.get(\"java.lang.Cloneable\"));\n        assertEquals(new ReferenceTypeImpl(new ReflectionInterfaceDeclaration(Collection.class, typeResolver), ImmutableList.of(string)), ancestors.get(\"java.util.Collection\"));\n        assertEquals(new ReferenceTypeImpl(new ReflectionClassDeclaration(AbstractList.class, typeResolver), ImmutableList.of(string)), ancestors.get(\"java.util.AbstractList\"));\n        assertEquals(new ReferenceTypeImpl(new ReflectionClassDeclaration(Object.class, typeResolver)), ancestors.get(\"java.lang.Object\"));\n        assertEquals(new ReferenceTypeImpl(new ReflectionInterfaceDeclaration(Iterable.class, typeResolver), ImmutableList.of(string)), ancestors.get(\"java.lang.Iterable\"));\n        assertEquals(new ReferenceTypeImpl(new ReflectionInterfaceDeclaration(Serializable.class, typeResolver)), ancestors.get(\"java.io.Serializable\"));\n    }\n\n    @Test\n    void testTypeParametersValues() {\n        TypeSolver typeResolver = new ReflectionTypeSolver();\n        ResolvedReferenceType stream = new ReferenceTypeImpl(new ReflectionInterfaceDeclaration(Stream.class, typeResolver));\n        assertEquals(1, stream.typeParametersValues().size());\n        assertEquals(new ResolvedTypeVariable(new ReflectionInterfaceDeclaration(Stream.class, typeResolver).getTypeParameters().get(0)), stream.typeParametersValues().get(0));\n    }\n\n    @Test\n    void testReplaceTypeVariables() {\n        TypeSolver typeResolver = new ReflectionTypeSolver();\n        ResolvedInterfaceDeclaration streamInterface = new ReflectionInterfaceDeclaration(Stream.class, typeResolver);\n        ResolvedReferenceType stream = new ReferenceTypeImpl(streamInterface);\n\n        ResolvedMethodDeclaration streamMap = streamInterface.getDeclaredMethods().stream().filter(m -> m.getName().equals(\"map\")).findFirst().get();\n        ResolvedTypeParameterDeclaration streamMapR = streamMap.findTypeParameter(\"T\").get();\n        ResolvedTypeVariable typeVariable = new ResolvedTypeVariable(streamMapR);\n        stream = stream.deriveTypeParameters(stream.typeParametersMap().toBuilder().setValue(stream.getTypeDeclaration().get().getTypeParameters().get(0), typeVariable).build());\n\n        ResolvedTypeParameterDeclaration tpToReplace = streamInterface.getTypeParameters().get(0);\n        ResolvedType replaced = new ReferenceTypeImpl(new ReflectionClassDeclaration(String.class, typeResolver));\n\n        ResolvedType streamReplaced = stream.replaceTypeVariables(tpToReplace, replaced);\n        assertEquals(\"java.util.stream.Stream<java.lang.String>\", streamReplaced.describe());\n    }\n\n    @Test\n    void testReplaceTypeVariablesWithLambdaInBetween() {\n        TypeSolver typeResolver = new ReflectionTypeSolver();\n        ResolvedInterfaceDeclaration streamInterface = new ReflectionInterfaceDeclaration(Stream.class, typeResolver);\n        ResolvedReferenceType stream = new ReferenceTypeImpl(streamInterface);\n\n        ResolvedMethodDeclaration streamMap = streamInterface.getDeclaredMethods().stream().filter(m -> m.getName().equals(\"map\")).findFirst().get();\n        ResolvedTypeParameterDeclaration streamMapR = streamMap.findTypeParameter(\"T\").get();\n        ResolvedTypeVariable typeVariable = new ResolvedTypeVariable(streamMapR);\n        stream = stream.deriveTypeParameters(stream.typeParametersMap().toBuilder().setValue(stream.getTypeDeclaration().get().getTypeParameters().get(0), typeVariable).build());\n\n        ResolvedTypeParameterDeclaration tpToReplace = streamInterface.getTypeParameters().get(0);\n        ResolvedType replaced = new ReferenceTypeImpl(new ReflectionClassDeclaration(String.class, typeResolver));\n\n        ResolvedType streamReplaced = stream.replaceTypeVariables(tpToReplace, replaced);\n        assertEquals(\"java.util.stream.Stream<java.lang.String>\", streamReplaced.describe());\n    }\n\n    @Test\n    void testDirectAncestorsOfObject() {\n        assertEquals(0, object.getDirectAncestors().size());\n    }\n\n    @Test\n    void testDirectAncestorsOfInterface() {\n        ResolvedReferenceType iterableOfString = new ReferenceTypeImpl(\n                new ReflectionInterfaceDeclaration(Iterable.class, typeSolver),\n                ImmutableList.of(new ReferenceTypeImpl(new ReflectionClassDeclaration(String.class, typeSolver))));\n        assertEquals(0, iterableOfString.getDirectAncestors().size());\n    }\n\n    @Test\n    void testDirectAncestorsOfInterfaceExtendingInterface() {\n        assertEquals(1, collectionOfString.getDirectAncestors().size());\n        ResolvedReferenceType ancestor1 = collectionOfString.getDirectAncestors().get(0);\n        assertEquals(\"java.lang.Iterable\", ancestor1.getQualifiedName());\n        assertEquals(1, ancestor1.getTypeParametersMap().size());\n        assertEquals(\"T\", ancestor1.getTypeParametersMap().get(0).a.getName());\n        assertEquals(\"java.lang.String\", ancestor1.getTypeParametersMap().get(0).b.describe());\n    }\n\n    @Test\n    void testDirectAncestorsOfClassWithoutSuperClassOrInterfaces() {\n        ResolvedReferenceType buffer = new ReferenceTypeImpl(new ReflectionClassDeclaration(Buffer.class, typeSolver));\n        Set<String> ancestors = buffer.getDirectAncestors()\n                .stream()\n                .map(ResolvedReferenceType::describe)\n                .collect(Collectors.toSet());\n\n        assertThat(ancestors, equalTo(new HashSet<>(Arrays.asList(\"java.lang.Object\"))));\n    }\n\n    @Test\n    void testDirectAncestorsOfObjectClass() {\n        ResolvedReferenceType object = new ReferenceTypeImpl(new ReflectionClassDeclaration(Object.class, typeSolver));\n        Set<String> ancestors = object.getDirectAncestors()\n                .stream()\n                .map(ResolvedReferenceType::describe)\n                .collect(Collectors.toSet());\n\n        assertEquals(new HashSet<>(), ancestors);\n    }\n\n    @Test\n    void testDirectAncestorsOfClassWithSuperClass() {\n        ResolvedReferenceType charbuffer = new ReferenceTypeImpl(new ReflectionClassDeclaration(CharBuffer.class, typeSolver));\n        Set<String> ancestors = charbuffer.getDirectAncestors()\n                .stream()\n                .map(ResolvedReferenceType::describe)\n                .collect(Collectors.toSet());\n\n        assertThat(ancestors, containsInAnyOrder(\n                \"java.lang.CharSequence\",\n                \"java.lang.Appendable\",\n                \"java.nio.Buffer\",\n                \"java.lang.Readable\",\n                \"java.lang.Comparable<java.nio.CharBuffer>\"\n        ));\n    }\n\n    @Test\n    void testDirectAncestorsOfClassWithInterfaces() {\n        Set<String> ancestors = string.getDirectAncestors()\n                .stream()\n                .map(ResolvedReferenceType::describe)\n                .collect(Collectors.toSet());\n\n        // FIXME: Remove this temporary fix which varies the test based on the detected JDK which is running these tests.\n        TestJdk currentJdk = TestJdk.getCurrentHostJdk();\n        if (currentJdk.getMajorVersion() < 12) {\n            // JDK 12 introduced \"java.lang.constant.Constable\"\n            assertThat(ancestors, containsInAnyOrder(\n                    \"java.lang.CharSequence\",\n                    \"java.lang.Object\",\n                    \"java.lang.Comparable<java.lang.String>\",\n                    \"java.io.Serializable\"\n            ));\n        } else {\n            // JDK 12 introduced \"java.lang.constant.Constable\"\n            assertThat(ancestors, containsInAnyOrder(\n                    \"java.lang.CharSequence\",\n                    \"java.lang.Object\",\n                    \"java.lang.Comparable<java.lang.String>\",\n                    \"java.io.Serializable\",\n                    \"java.lang.constant.Constable\",\n                    \"java.lang.constant.ConstantDesc\"\n            ));\n        }\n    }\n\n    @Test\n    void testDeclaredFields() {\n        TypeSolver typeSolver = new ReflectionTypeSolver();\n        String code = \"class A { private int i; char c; public long l; } class B extends A { private float f; boolean b; };\";\n        ParserConfiguration parserConfiguration = new ParserConfiguration();\n        parserConfiguration.setSymbolResolver(new JavaSymbolSolver(typeSolver));\n\n        CompilationUnit cu = new JavaParser(parserConfiguration)\n                .parse(ParseStart.COMPILATION_UNIT, new StringProvider(code)).getResult().get();\n\n        ClassOrInterfaceDeclaration classA = cu.getClassByName(\"A\").get();\n        ClassOrInterfaceDeclaration classB = cu.getClassByName(\"B\").get();\n\n        ResolvedReferenceType rtA = new ReferenceTypeImpl(classA.resolve());\n        ResolvedReferenceType rtB = new ReferenceTypeImpl(classB.resolve());\n\n        assertEquals(3, rtA.getDeclaredFields().size());\n        assertTrue(rtA.getDeclaredFields().stream().anyMatch(f -> f.getName().equals(\"i\")));\n        assertTrue(rtA.getDeclaredFields().stream().anyMatch(f -> f.getName().equals(\"c\")));\n        assertTrue(rtA.getDeclaredFields().stream().anyMatch(f -> f.getName().equals(\"l\")));\n\n        assertEquals(2, rtB.getDeclaredFields().size());\n        assertTrue(rtB.getDeclaredFields().stream().anyMatch(f -> f.getName().equals(\"f\")));\n        assertTrue(rtB.getDeclaredFields().stream().anyMatch(f -> f.getName().equals(\"b\")));\n    }\n\n    @Test\n    void testGetAllFieldsVisibleToInheritors() {\n        TypeSolver typeSolver = new ReflectionTypeSolver();\n        String code = \"class A { private int i; char c; public long l; } class B extends A { private float f; boolean b; };\";\n        ParserConfiguration parserConfiguration = new ParserConfiguration();\n        parserConfiguration.setSymbolResolver(new JavaSymbolSolver(typeSolver));\n\n        CompilationUnit cu = new JavaParser(parserConfiguration)\n                .parse(ParseStart.COMPILATION_UNIT, new StringProvider(code)).getResult().get();\n\n        ClassOrInterfaceDeclaration classA = cu.getClassByName(\"A\").get();\n        ClassOrInterfaceDeclaration classB = cu.getClassByName(\"B\").get();\n\n        ResolvedReferenceType rtA = new ReferenceTypeImpl(classA.resolve());\n        ResolvedReferenceType rtB = new ReferenceTypeImpl(classB.resolve());\n\n        assertEquals(2, rtA.getAllFieldsVisibleToInheritors().size());\n        assertTrue(rtA.getAllFieldsVisibleToInheritors().stream().anyMatch(f -> f.getName().equals(\"c\")));\n        assertTrue(rtA.getAllFieldsVisibleToInheritors().stream().anyMatch(f -> f.getName().equals(\"l\")));\n\n        assertEquals(3, rtB.getAllFieldsVisibleToInheritors().size());\n        assertTrue(rtB.getAllFieldsVisibleToInheritors().stream().anyMatch(f -> f.getName().equals(\"c\")));\n        assertTrue(rtB.getAllFieldsVisibleToInheritors().stream().anyMatch(f -> f.getName().equals(\"l\")));\n        assertTrue(rtB.getAllFieldsVisibleToInheritors().stream().anyMatch(f -> f.getName().equals(\"b\")));\n    }\n\n    @Test\n    void erasure_non_generic_type() {\n        List<ResolvedType> types = declaredTypes(\n                \"class A {}\");\n        ResolvedType expected = types.get(0);\n        assertEquals(expected, types.get(0).erasure());\n    }\n\n    @Test\n    // The erasure of a parameterized type\n    void erasure_rawtype() {\n        List<ResolvedType> types = declaredTypes(\n                \"class A<String> {}\");\n        ResolvedType rt = types.get(0);\n        String expected = \"A\";\n        ResolvedType erasedType = rt.erasure();\n        assertTrue(rt.asReferenceType().isRawType());\n        assertTrue(erasedType.asReferenceType().typeParametersValues().isEmpty());\n        assertEquals(expected, erasedType.describe());\n    }\n\n    @Test\n    // The erasure of an array type T[] is |T|[].\n    void erasure_arraytype() {\n        // create a type : List <String>\n        ResolvedType genericList = array(genericType(List.class.getCanonicalName(), String.class.getCanonicalName()));\n        String expected = \"java.util.List[]\";\n        assertEquals(expected, genericList.erasure().describe());\n    }\n\n    @Test\n    // The erasure of an array type T[] is |T|[].\n    void erasure_arraytype_with_bound() {\n        // create a type : List <T extends Serializable>\n        ResolvedTypeVariable typeArguments = parametrizedType(\"T\", Serializable.class.getCanonicalName());\n        ResolvedType genericList = array(genericType(List.class.getCanonicalName(), typeArguments));\n        String expected = \"java.util.List<java.io.Serializable>[]\";\n        assertEquals(expected, genericList.erasure().describe());\n    }\n\n    @Test\n    // The erasure of a type variable (\u00a74.4) is the erasure of its leftmost bound.\n    void erasure_type_variable() {\n        List<ResolvedType> types = declaredTypes(\n                \"class A<T extends Number> {}\");\n        ResolvedType rt = types.get(0);\n        String expected =  \"A<java.lang.Number>\";\n        assertEquals(expected, rt.erasure().describe());\n    }\n\n    @Test\n    // The erasure of a nested type T.C is |T|.C.\n    void erasure_nested_type() {\n        List<ResolvedType> types = declaredTypes(\n                \"class A<T> {\" +\n                        \"  class C{}\" +\n                        \"}\",\n                \"class A {\" +\n                        \"  class C{}\" +\n                        \"}\");\n        ResolvedType typeA = types.get(0);\n        ResolvedType typeC = types.get(1);\n        // ResolvedType expectedErasedAType= types.get(2);\n        ResolvedType expectedErasedCType = types.get(3);\n        String expectedA = \"A\";\n        String expectedC = \"A.C\";\n        assertEquals(expectedA, typeA.erasure().describe());\n        assertEquals(expectedC, typeC.erasure().describe());\n        // this type declaration are not equals because the type returned by typeA.erasure() always contains original\n        // typeParameters\n        // assertEquals(expectedErasedAType, typeA.erasure());\n        assertEquals(expectedErasedCType, typeC.erasure());\n    }\n\n    @Test\n    void extend_type() {\n    \tResolvedTypeVariable variable = parametrizedType(\"java.util.List\", \"java.lang.String\");\n    \tassertTrue(variable.asTypeParameter().hasUpperBound());\n    \tassertFalse(variable.asTypeParameter().hasLowerBound());\n    }\n\n    @Test\n    void super_type() {\n    \tResolvedTypeVariable variable = parametrizedTypeLowerBounded(\"java.util.List\", \"java.lang.String\");\n    \tassertTrue(variable.asTypeParameter().hasLowerBound());\n    \tassertFalse(variable.asTypeParameter().hasUpperBound());\n    }\n\n    // return a generic type with type arguments (arguments can be bounded)\n    private ResolvedType genericType(String type, ResolvedType... parameterTypes) {\n        return type(type, toList(parameterTypes));\n    }\n\n    // return a generic type with type arguments\n    private ResolvedType genericType(String type, String... parameterTypes) {\n        return new ReferenceTypeImpl(typeSolver.solveType(type), types(parameterTypes));\n    }\n\n    // return a list of types\n    private List<ResolvedType> types(String... types) {\n        return Arrays.stream(types).map(type -> type(type)).collect(Collectors.toList());\n    }\n\n    // return the specified type\n    private ResolvedType type(String type) {\n        return type(type, new ArrayList<>());\n    }\n\n    private ResolvedType type(String type, List<ResolvedType> typeArguments) {\n        return new ReferenceTypeImpl(typeSolver.solveType(type), typeArguments);\n    }\n\n    // return a type parameter\n    private ResolvedTypeVariable parametrizedType(String type, String parameterType) {\n        return parametrizedTypeUpperBounded(type, parameterType);\n    }\n\n    private ResolvedTypeVariable parametrizedTypeUpperBounded(String type, String parameterType) {\n        return new ResolvedTypeVariable(ResolvedTypeParameterDeclaration.onType(parameterType, type + \".\" + parameterType,\n                Arrays.asList((extendBound(parameterType)))));\n    }\n\n    private ResolvedTypeVariable parametrizedTypeLowerBounded(String type, String parameterType) {\n        return new ResolvedTypeVariable(ResolvedTypeParameterDeclaration.onType(parameterType, type + \".\" + parameterType,\n                Arrays.asList((superBound(parameterType)))));\n    }\n\n    // return an extend bound\n    private Bound extendBound(String type) {\n        return Bound.extendsBound(type(type));\n    }\n\n    // return a super bound\n    private Bound superBound(String type) {\n        return Bound.superBound(type(type));\n    }\n\n    private Set<ResolvedType> toSet(ResolvedType... resolvedTypes) {\n        return new HashSet<>(toList(resolvedTypes));\n    }\n\n    private List<ResolvedType> toList(ResolvedType... resolvedTypes) {\n        return Arrays.asList(resolvedTypes);\n    }\n\n    // return an array type from the base type\n    private ResolvedType array(ResolvedType baseType) {\n        return new ResolvedArrayType(baseType);\n    }\n\n    // return a list of types from the declared types (using a static parser)\n    private List<ResolvedType> declaredTypes(String... lines) {\n        CompilationUnit tree = treeOf(lines);\n        List<ResolvedType> results = Lists.newLinkedList();\n        for (ClassOrInterfaceDeclaration classTree : tree.findAll(ClassOrInterfaceDeclaration.class)) {\n            results.add(new ReferenceTypeImpl(classTree.resolve()));\n        }\n        return results;\n    }\n\n    private CompilationUnit treeOf(String... lines) {\n        StringBuilder builder = new StringBuilder();\n        for (String line : lines) {\n            builder.append(line).append(System.lineSeparator());\n        }\n        return StaticJavaParser.parse(builder.toString());\n    }\n\n}\n",
        "diffSourceCodeSet": [
            "private ResolvedTypeVariable parametrizedTypeUpperBounded(String type, String parameterType) {\n        return new ResolvedTypeVariable(ResolvedTypeParameterDeclaration.onType(parameterType, type + \".\" + parameterType,\n                Arrays.asList((extendBound(parameterType)))));\n    }"
        ],
        "invokedMethodSet": [
            "methodSignature: com.github.javaparser.symbolsolver.model.typesystem.ReferenceTypeTest#extendBound\n methodBody: private Bound extendBound(String type) {\nreturn Bound.extendsBound(type(type));\n}",
            "methodSignature: com.github.javaparser.resolution.declarations.ResolvedTypeParameterDeclaration#onType\n methodBody: static ResolvedTypeParameterDeclaration onType(final String name, String classQName, List<Bound> bounds) {\nreturn new ResolvedTypeParameterDeclaration(){\n  @Override public String getName(){\n    return name;\n  }\n  @Override public boolean declaredOnType(){\n    return true;\n  }\n  @Override public boolean declaredOnMethod(){\n    return false;\n  }\n  @Override public boolean declaredOnConstructor(){\n    return false;\n  }\n  @Override public String getContainerQualifiedName(){\n    return classQName;\n  }\n  @Override public String getContainerId(){\n    return classQName;\n  }\n  @Override public ResolvedTypeParametrizable getContainer(){\n    return null;\n  }\n  @Override public List<Bound> getBounds(){\n    return bounds;\n  }\n  @Override public String toString(){\n    return \"TypeParameter onType \" + name;\n  }\n  @Override public Optional<ResolvedReferenceTypeDeclaration> containerType(){\n    throw new UnsupportedOperationException();\n  }\n  @Override public ResolvedReferenceType object(){\n    throw new UnsupportedOperationException();\n  }\n}\n;\n}"
        ],
        "sourceCodeAfterRefactoring": "private ResolvedTypeVariable parametrizedType(String type, String parameterType) {\n        return parametrizedTypeUpperBounded(type, parameterType);\n    }\nprivate ResolvedTypeVariable parametrizedTypeUpperBounded(String type, String parameterType) {\n        return new ResolvedTypeVariable(ResolvedTypeParameterDeclaration.onType(parameterType, type + \".\" + parameterType,\n                Arrays.asList((extendBound(parameterType)))));\n    }",
        "diffSourceCode": "-  955:     private ResolvedTypeVariable parametrizedType(String type, String parameterType) {\n-  956:         return new ResolvedTypeVariable(ResolvedTypeParameterDeclaration.onType(parameterType, type + \".\" + parameterType,\n-  957:                 Arrays.asList((extendBound(parameterType)))));\n-  958:     }\n-  971:     }\n-  972:     \n-  973:     // return an array type from the base type\n-  975:         return new ResolvedArrayType(baseType);\n-  976:     }\n-  977:     \n-  978:     // return a list of types from the declared types (using a static parser) \n+  955: \n+  956:     // return a list of types\n+  957:     private List<ResolvedType> types(String... types) {\n+  958:         return Arrays.stream(types).map(type -> type(type)).collect(Collectors.toList());\n+  971:     private ResolvedTypeVariable parametrizedType(String type, String parameterType) {\n+  972:         return parametrizedTypeUpperBounded(type, parameterType);\n+  973:     }\n+  975:     private ResolvedTypeVariable parametrizedTypeUpperBounded(String type, String parameterType) {\n+  976:         return new ResolvedTypeVariable(ResolvedTypeParameterDeclaration.onType(parameterType, type + \".\" + parameterType,\n+  977:                 Arrays.asList((extendBound(parameterType)))));\n+  978:     }\n",
        "uniqueId": "cc159998ac7c83234e2665cbc479f85dcc27f5d0_955_958_975_978_971_973",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "testMethod": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 17
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprivate isSpaceOrTabElement(nodeText NodeText, i int) : boolean extracted from private defineEnforcingIndentationContext(nodeText NodeText, startIndex int) : EnforcingIndentationContext in class com.github.javaparser.printer.lexicalpreservation.Difference",
        "diffLocations": [
            {
                "filePath": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Difference.java",
                "startLine": 282,
                "endLine": 321,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Difference.java",
                "startLine": 293,
                "endLine": 333,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Difference.java",
                "startLine": 338,
                "endLine": 340,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "/**\n     * Starting at {@code nodeTextIndex} this method tries to determine how many contiguous spaces there are between \n     * the previous end of line and the next non whitespace (or tab) character\n     * @param nodeText List of elements to analyze\n     * @param nodeTextIndex Starting position in the input list\n     * @return EnforcingIndentationContext Data structure that hold the starting position of the first whitespace char and\n     * The number of consecutive whitespace (or tab) characters\n     */\n    private EnforcingIndentationContext defineEnforcingIndentationContext(NodeText nodeText, int startIndex) {\n    \tEnforcingIndentationContext ctx = new EnforcingIndentationContext(startIndex);\n    \t// compute space before startIndex value\n\t\tif (startIndex < nodeText.numberOfElements() && startIndex > 0) {\n\t\t\t// at this stage startIndex points to the first element before the deleted one\n\t\t\tfor (int i = startIndex - 1; i >= 0 && i < nodeText.numberOfElements(); i--) {\n\t\t\t\tif (nodeText.getTextElement(i).isNewline()) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (!nodeText.getTextElement(i).isSpaceOrTab()) {\n\t\t\t\t\tctx = new EnforcingIndentationContext(startIndex);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tctx.start = i;\n\t\t\t\tctx.extraCharacters++;\n\t\t\t}\n\t\t}\n\t\t// compute space after the deleted element\n\t\tif (nodeText.getTextElement(startIndex).isSpaceOrTab()) {\n\t\t\tfor (int i = startIndex; i >= 0 && i < nodeText.numberOfElements(); i++) {\n\t\t\t\tif (nodeText.getTextElement(i).isNewline()) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (!nodeText.getTextElement(i).isSpaceOrTab()) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tctx.extraCharacters++;\n\t\t\t}\n\t\t}\n        \n        return ctx;\n    }",
        "filePathBefore": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Difference.java",
        "isPureRefactoring": true,
        "commitId": "c9adc2fe0111fdb3f926d2df2264a8dcf6335f11",
        "packageNameBefore": "com.github.javaparser.printer.lexicalpreservation",
        "classNameBefore": "com.github.javaparser.printer.lexicalpreservation.Difference",
        "methodNameBefore": "com.github.javaparser.printer.lexicalpreservation.Difference#defineEnforcingIndentationContext",
        "classSignatureBefore": "public class Difference ",
        "methodNameBeforeSet": [
            "com.github.javaparser.printer.lexicalpreservation.Difference#defineEnforcingIndentationContext"
        ],
        "classNameBeforeSet": [
            "com.github.javaparser.printer.lexicalpreservation.Difference"
        ],
        "classSignatureBeforeSet": [
            "public class Difference "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Changes are within the Extract Method refactoring mechanics",
                "description": "All replacements have been justified - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Copyright (C) 2007-2010 J\u00falio Vilmar Gesser.\n * Copyright (C) 2011, 2013-2023 The JavaParser Team.\n *\n * This file is part of JavaParser.\n *\n * JavaParser can be used either under the terms of\n * a) the GNU Lesser General Public License as published by\n *     the Free Software Foundation, either version 3 of the License, or\n *     (at your option) any later version.\n * b) the terms of the Apache License\n *\n * You should have received a copy of both licenses in LICENCE.LGPL and\n * LICENCE.APACHE. Please refer to those files for details.\n *\n * JavaParser is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n */\npackage com.github.javaparser.printer.lexicalpreservation;\n\nimport com.github.javaparser.GeneratedJavaParserConstants;\nimport com.github.javaparser.JavaToken;\nimport com.github.javaparser.JavaToken.Kind;\nimport com.github.javaparser.TokenTypes;\nimport com.github.javaparser.ast.Node;\nimport com.github.javaparser.ast.NodeList;\nimport com.github.javaparser.ast.comments.Comment;\nimport com.github.javaparser.ast.nodeTypes.NodeWithTypeArguments;\nimport com.github.javaparser.ast.type.ArrayType;\nimport com.github.javaparser.ast.type.ClassOrInterfaceType;\nimport com.github.javaparser.ast.type.Type;\nimport com.github.javaparser.printer.concretesyntaxmodel.*;\nimport com.github.javaparser.printer.lexicalpreservation.LexicalDifferenceCalculator.CsmChild;\n\nimport java.util.*;\nimport java.util.function.Predicate;\nimport java.util.stream.IntStream;\n\nimport static com.github.javaparser.GeneratedJavaParserConstants.*;\n\n/**\n * A Difference should give me a sequence of elements I should find (to indicate the context) followed by a list of elements\n * to remove or to add and follow by another sequence of elements.\n *\n * I should later be able to apply such difference to a nodeText.\n */\npublic class Difference {\n\n    public static final int STANDARD_INDENTATION_SIZE = 4;\n\n    private final NodeText nodeText;\n\n    private final Node node;\n\n    private final List<DifferenceElement> diffElements;\n\n    private final List<TextElement> originalElements;\n\n    private int originalIndex = 0;\n\n    private int diffIndex = 0;\n\n    private final List<TextElement> indentation;\n\n    private boolean addedIndentation = false;\n\n    Difference(List<DifferenceElement> diffElements, NodeText nodeText, Node node) {\n        if (nodeText == null) {\n            throw new NullPointerException(\"nodeText can not be null\");\n        }\n        this.nodeText = nodeText;\n        this.node = node;\n        this.diffElements = diffElements;\n        this.originalElements = nodeText.getElements();\n        this.indentation = LexicalPreservingPrinter.findIndentation(node);\n    }\n\n    /*\n     * Returns the indentation used after the last line break\n     */\n    private List<TextElement> processIndentation(List<TextElement> indentation, List<TextElement> prevElements) {\n        int eolIndex = lastIndexOfEol(prevElements);\n        // Return \"indentation\" as is if no EOL element was found\n        if (eolIndex < 0)\n            return indentation;\n        // Find consecutive space characters after the EOL element\n        indentation = takeWhile(prevElements.subList(eolIndex + 1, prevElements.size()), element -> element.isWhiteSpace());\n        return indentation;\n    }\n    \n    /*\n     * returns only the elements that match the given predicate.\n     * takeWhile takes elements from the initial stream while the predicate holds true.\n     * Meaning that when an element is encountered that does not match the predicate, the rest of the list is discarded. \n     */\n    List<TextElement> takeWhile(List<TextElement> prevElements, Predicate<TextElement> predicate) {\n    \tList<TextElement> spaces = new ArrayList<>();\n    \tfor (TextElement element : prevElements) {\n    \t\tif (predicate.test(element)) {\n    \t\t\tspaces.add(element);\n                continue;\n            }\n            break;\n    \t}\n    \treturn spaces;\n    }\n    \n    \n    int lastIndexOfEol(List<TextElement> source) {\n        return IntStream.range(0, source.size())\n                       .map(i -> source.size() - i - 1)\n                       .filter(i -> source.get(i).isNewline())\n                       .findFirst()\n                       .orElse(-1);\n    }\n\n    /*\n     * Returns the position of the next element in the list starting from @{code fromIndex} which is a comment (Ignoring spaces)\n     * or -1 if it's not a comment.\n     */\n    private int posOfNextComment(int fromIndex, List<TextElement> elements) {\n        if (!isValidIndex(fromIndex, elements))\n            return -1;\n        ReadOnlyListIterator<TextElement> iterator = new ReadOnlyListIterator(elements, fromIndex);\n        // search for the next consecutive space characters\n        while (iterator.hasNext()) {\n            TextElement element = iterator.next();\n            if (element.isSpaceOrTab()) {\n                continue;\n            }\n            if (element.isComment()) {\n            \treturn iterator.index();\n            }\n            break;\n        }\n        return -1;\n    }\n    \n    /*\n     * Returns true if the next element in the list (starting from @{code fromIndex}) is a comment\n     */\n    private boolean isFollowedByComment(int fromIndex, List<TextElement> elements) {\n    \treturn posOfNextComment(fromIndex, elements) != -1;\n    }\n    \n    /*\n     * Removes all elements in the list starting from @{code fromIndex}) ending to @{code toIndex})\n     */\n    private void removeElements(int fromIndex, int toIndex, List<TextElement> elements) {\n    \tif (!(isValidIndex(fromIndex, elements) && isValidIndex(toIndex, elements) && fromIndex <= toIndex))\n            return;\n        ListIterator<TextElement> iterator = elements.listIterator(fromIndex);\n        // removing elements\n        int count = fromIndex;\n        while (iterator.hasNext() && count <= toIndex) {\n        \tTextElement element = iterator.next();\n            iterator.remove();\n            count++;\n        }\n    }\n    \n    private boolean isValidIndex(int index, List<?> elements) {\n    \treturn index >= 0 && index <= elements.size();\n    }\n\n    /*\n     * Returns the position of the last new line character or -1 if there is no eol in the specified list of TextElement \n     */\n    int lastIndexOfEolWithoutGPT(List<TextElement> source) {\n        ListIterator listIterator = source.listIterator(source.size());\n        int lastIndex = source.size() - 1;\n        while (listIterator.hasPrevious()) {\n            TextElement elem = (TextElement) listIterator.previous();\n            if (elem.isNewline()) {\n                return lastIndex;\n            }\n            lastIndex--;\n        }\n        return -1;\n    }\n\n    private List<TextElement> indentationBlock() {\n        List<TextElement> res = new LinkedList<>();\n        res.add(new TokenTextElement(SPACE));\n        res.add(new TokenTextElement(SPACE));\n        res.add(new TokenTextElement(SPACE));\n        res.add(new TokenTextElement(SPACE));\n        return res;\n    }\n\n    private boolean isAfterLBrace(NodeText nodeText, int nodeTextIndex) {\n        if (nodeTextIndex > 0 && nodeText.getTextElement(nodeTextIndex - 1).isToken(LBRACE)) {\n            return true;\n        }\n        if (nodeTextIndex > 0 && nodeText.getTextElement(nodeTextIndex - 1).isSpaceOrTab()) {\n            return isAfterLBrace(nodeText, nodeTextIndex - 1);\n        }\n        return false;\n    }\n\n    /**\n     * If we are at the beginning of a line, with just spaces or tabs before/after the position of the deleted element\n     * we should force the space to be the same as the current indentation.\n     * This method handles the following case if we remove the modifier {@code public} ([ ] is an indent character)\n     * {@code \n     * [ ][ ]public[ ][ ][ ]void[ ]m{}\n     * <-1-->      <---2--->\n     * 1/ current indentation\n     * 2/ these whitespaces must be removed\n     * }\n     * should produce\n     * {@code \n     * [ ][ ]void[ ]m{} \n     * }\n     */\n    private int considerEnforcingIndentation(NodeText nodeText, int nodeTextIndex) {\n        return considerIndentation(nodeText, nodeTextIndex, indentation.size());\n    }\n    \n    private int considerRemovingIndentation(NodeText nodeText, int nodeTextIndex) {\n        return considerIndentation(nodeText, nodeTextIndex, 0);\n    }\n    \n    private int considerIndentation(NodeText nodeText, int nodeTextIndex, int numberOfCharactersToPreserve) {\n        EnforcingIndentationContext enforcingIndentationContext = defineEnforcingIndentationContext(nodeText, nodeTextIndex);\n        // the next position in the list (by default the current position)\n        int res = nodeTextIndex;\n        if (enforcingIndentationContext.extraCharacters > 0) {\n        \tint extraCharacters = enforcingIndentationContext.extraCharacters > numberOfCharactersToPreserve ? enforcingIndentationContext.extraCharacters - numberOfCharactersToPreserve : 0;\n            res = removeExtraCharacters(nodeText, enforcingIndentationContext.start, extraCharacters);\n            // The next position must take into account the indentation\n            res = extraCharacters > 0 ? res + numberOfCharactersToPreserve : res;\n        }\n        if (res < 0) {\n            throw new IllegalStateException();\n        }\n        return res;\n    }\n    \n    private boolean isEnforcingIndentationActivable(RemovedGroup removedGroup) {\n\t\treturn (diffIndex + 1 >= diffElements.size() || !(diffElements.get(diffIndex + 1).isAdded()))\n\t\t\t\t&& originalIndex < originalElements.size()\n\t\t\t\t&& !removedGroup.isACompleteLine();\n\t}\n\n    private boolean isRemovingIndentationActivable(RemovedGroup removedGroup) {\n\t\treturn (diffIndex + 1 >= diffElements.size() || !(diffElements.get(diffIndex + 1).isAdded())) \n\t\t\t\t&& originalIndex < originalElements.size()\n\t\t\t\t&& removedGroup.isACompleteLine();\n\t}\n    \n    /*\n     * This data structure class hold the starting position of the first whitespace char \n     * and the number of consecutive whitespace (or tab) characters\n     */\n    private class EnforcingIndentationContext {\n    \tint start;\n    \tint extraCharacters;\n    \tpublic EnforcingIndentationContext(int start) {\n    \t\tthis.start=start;\n    \t\tthis.extraCharacters=0;\n    \t}\n    }\n\n    /**\n     * Remove excess white space after deleting element.\n     * @param nodeText Contains a list of elements to analyze\n     * @param nodeTextIndex Starting position in the input list\n     * @return The current position in the list of the elements\n     */\n    private int removeExtraCharacters(NodeText nodeText, int nodeTextIndex, int extraCharacters) {\n        int count = 0;\n        while (nodeTextIndex >= 0 && nodeTextIndex < nodeText.numberOfElements() && count < extraCharacters) {\n            nodeText.removeElement(nodeTextIndex);\n            count++;\n        }\n        return nodeTextIndex;\n    }\n\n    /**\n     * Starting at {@code nodeTextIndex} this method tries to determine how many contiguous spaces there are between \n     * the previous end of line and the next non whitespace (or tab) character\n     * @param nodeText List of elements to analyze\n     * @param nodeTextIndex Starting position in the input list\n     * @return EnforcingIndentationContext Data structure that hold the starting position of the first whitespace char and\n     * The number of consecutive whitespace (or tab) characters\n     */\n    private EnforcingIndentationContext defineEnforcingIndentationContext(NodeText nodeText, int startIndex) {\n    \tEnforcingIndentationContext ctx = new EnforcingIndentationContext(startIndex);\n    \t// compute space before startIndex value\n\t\tif (startIndex < nodeText.numberOfElements() && startIndex > 0) {\n\t\t\t// at this stage startIndex points to the first element before the deleted one\n\t\t\tfor (int i = startIndex - 1; i >= 0 && i < nodeText.numberOfElements(); i--) {\n\t\t\t\tif (nodeText.getTextElement(i).isNewline()) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (!nodeText.getTextElement(i).isSpaceOrTab()) {\n\t\t\t\t\tctx = new EnforcingIndentationContext(startIndex);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tctx.start = i;\n\t\t\t\tctx.extraCharacters++;\n\t\t\t}\n\t\t}\n\t\t// compute space after the deleted element\n\t\tif (nodeText.getTextElement(startIndex).isSpaceOrTab()) {\n\t\t\tfor (int i = startIndex; i >= 0 && i < nodeText.numberOfElements(); i++) {\n\t\t\t\tif (nodeText.getTextElement(i).isNewline()) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (!nodeText.getTextElement(i).isSpaceOrTab()) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tctx.extraCharacters++;\n\t\t\t}\n\t\t}\n        \n        return ctx;\n    }\n\n    /**\n     * Node that we have calculate the Difference we can apply to a concrete NodeText, modifying it according\n     * to the difference (adding and removing the elements provided).\n     */\n    void apply() {\n        extractReshuffledDiffElements(diffElements);\n        Map<Removed, RemovedGroup> removedGroups = combineRemovedElementsToRemovedGroups();\n        do {\n            boolean isLeftOverDiffElement = applyLeftOverDiffElements();\n            boolean isLeftOverOriginalElement = applyLeftOverOriginalElements();\n            if (!isLeftOverDiffElement && !isLeftOverOriginalElement) {\n                DifferenceElement diffElement = diffElements.get(diffIndex);\n                if (diffElement.isAdded()) {\n                    applyAddedDiffElement((Added) diffElement);\n                } else {\n                    TextElement originalElement = originalElements.get(originalIndex);\n                    boolean originalElementIsChild = originalElement instanceof ChildTextElement;\n                    boolean originalElementIsToken = originalElement instanceof TokenTextElement;\n                    if (diffElement.isKept()) {\n                        applyKeptDiffElement((Kept) diffElement, originalElement, originalElementIsChild, originalElementIsToken);\n                    } else if (diffElement.isRemoved()) {\n                        Removed removed = (Removed) diffElement;\n                        applyRemovedDiffElement(removedGroups.get(removed), removed, originalElement, originalElementIsChild, originalElementIsToken);\n                    } else {\n                        throw new UnsupportedOperationException(\"\" + diffElement + \" vs \" + originalElement);\n                    }\n                }\n            }\n        } while (diffIndex < diffElements.size() || originalIndex < originalElements.size());\n    }\n\n    private boolean applyLeftOverOriginalElements() {\n        boolean isLeftOverElement = false;\n        if (diffIndex >= diffElements.size() && originalIndex < originalElements.size()) {\n            TextElement originalElement = originalElements.get(originalIndex);\n            if (originalElement.isWhiteSpaceOrComment()) {\n                originalIndex++;\n            } else {\n                throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \" + this + \" \" + originalElement);\n            }\n            isLeftOverElement = true;\n        }\n        return isLeftOverElement;\n    }\n\n    private boolean applyLeftOverDiffElements() {\n        boolean isLeftOverElement = false;\n        if (diffIndex < diffElements.size() && originalIndex >= originalElements.size()) {\n            DifferenceElement diffElement = diffElements.get(diffIndex);\n            if (diffElement.isKept()) {\n                diffIndex++;\n            } else if (diffElement.isAdded()) {\n                Added addedElement = (Added) diffElement;\n                nodeText.addElement(originalIndex, addedElement.toTextElement());\n                originalIndex++;\n                diffIndex++;\n            } else {\n                // let's forget this element\n                diffIndex++;\n            }\n            isLeftOverElement = true;\n        }\n        return isLeftOverElement;\n    }\n\n    private void extractReshuffledDiffElements(List<DifferenceElement> diffElements) {\n        for (int index = 0; index < diffElements.size(); index++) {\n            DifferenceElement diffElement = diffElements.get(index);\n            if (diffElement instanceof Reshuffled) {\n                Reshuffled reshuffled = (Reshuffled) diffElement;\n                // First, let's see how many tokens we need to attribute to the previous version of the of the CsmMix\n                CsmMix elementsFromPreviousOrder = reshuffled.getPreviousOrder();\n                CsmMix elementsFromNextOrder = reshuffled.getNextOrder();\n                // This contains indexes from elementsFromNextOrder to indexes from elementsFromPreviousOrder\n                Map<Integer, Integer> correspondanceBetweenNextOrderAndPreviousOrder = getCorrespondanceBetweenNextOrderAndPreviousOrder(elementsFromPreviousOrder, elementsFromNextOrder);\n                // We now find out which Node Text elements corresponds to the elements in the original CSM\n                List<Integer> nodeTextIndexOfPreviousElements = findIndexOfCorrespondingNodeTextElement(elementsFromPreviousOrder.getElements(), nodeText, originalIndex, node);\n                Map<Integer, Integer> nodeTextIndexToPreviousCSMIndex = new HashMap<>();\n                for (int i = 0; i < nodeTextIndexOfPreviousElements.size(); i++) {\n                    int value = nodeTextIndexOfPreviousElements.get(i);\n                    if (value != -1) {\n                        nodeTextIndexToPreviousCSMIndex.put(value, i);\n                    }\n                }\n                int lastNodeTextIndex = nodeTextIndexOfPreviousElements.stream().max(Integer::compareTo).orElse(-1);\n                // Elements to be added at the end\n                List<CsmElement> elementsToBeAddedAtTheEnd = new LinkedList<>();\n                List<CsmElement> nextOrderElements = elementsFromNextOrder.getElements();\n                Map<Integer, List<CsmElement>> elementsToAddBeforeGivenOriginalCSMElement = new HashMap<>();\n                for (int ni = 0; ni < nextOrderElements.size(); ni++) {\n                    // If it has a mapping, then it is kept\n                    if (!correspondanceBetweenNextOrderAndPreviousOrder.containsKey(ni)) {\n                        // Ok, it is something new. Where to put it? Let's see what is the first following\n                        // element that has a mapping\n                        int originalCsmIndex = -1;\n                        for (int nj = ni + 1; nj < nextOrderElements.size() && originalCsmIndex == -1; nj++) {\n                            if (correspondanceBetweenNextOrderAndPreviousOrder.containsKey(nj)) {\n                                originalCsmIndex = correspondanceBetweenNextOrderAndPreviousOrder.get(nj);\n                                if (!elementsToAddBeforeGivenOriginalCSMElement.containsKey(originalCsmIndex)) {\n                                    elementsToAddBeforeGivenOriginalCSMElement.put(originalCsmIndex, new LinkedList<>());\n                                }\n                                elementsToAddBeforeGivenOriginalCSMElement.get(originalCsmIndex).add(nextOrderElements.get(ni));\n                            }\n                        }\n                        // it does not preceed anything, so it goes at the end\n                        if (originalCsmIndex == -1) {\n                            elementsToBeAddedAtTheEnd.add(nextOrderElements.get(ni));\n                        }\n                    }\n                }\n                // We go over the original node text elements, in the order they appear in the NodeText.\n                // Considering an original node text element (ONE)\n                // * we verify if it corresponds to a CSM element. If it does not we just move on, otherwise\n                // we find the correspond OCE (Original CSM Element)\n                // * we first add new elements that are marked to be added before OCE\n                // * if OCE is marked to be present also in the \"after\" CSM we add a kept element,\n                // otherwise we add a removed element\n                // Remove the whole Reshuffled element\n                diffElements.remove(index);\n                int diffElIterator = index;\n                if (lastNodeTextIndex != -1) {\n                    for (int ntIndex = originalIndex; ntIndex <= lastNodeTextIndex; ntIndex++) {\n                        if (nodeTextIndexToPreviousCSMIndex.containsKey(ntIndex)) {\n                            int indexOfOriginalCSMElement = nodeTextIndexToPreviousCSMIndex.get(ntIndex);\n                            if (elementsToAddBeforeGivenOriginalCSMElement.containsKey(indexOfOriginalCSMElement)) {\n                                for (CsmElement elementToAdd : elementsToAddBeforeGivenOriginalCSMElement.get(indexOfOriginalCSMElement)) {\n                                    diffElements.add(diffElIterator++, new Added(elementToAdd));\n                                }\n                            }\n                            CsmElement originalCSMElement = elementsFromPreviousOrder.getElements().get(indexOfOriginalCSMElement);\n                            boolean toBeKept = correspondanceBetweenNextOrderAndPreviousOrder.containsValue(indexOfOriginalCSMElement);\n                            if (toBeKept) {\n                                diffElements.add(diffElIterator++, new Kept(originalCSMElement));\n                            } else {\n                                diffElements.add(diffElIterator++, new Removed(originalCSMElement));\n                            }\n                        }\n                        // else we have a simple node text element, without associated csm element, just keep ignore it\n                    }\n                }\n                // Finally we look for the remaining new elements that were not yet added and\n                // add all of them\n                for (CsmElement elementToAdd : elementsToBeAddedAtTheEnd) {\n                    diffElements.add(diffElIterator++, new Added(elementToAdd));\n                }\n            }\n        }\n    }\n\n    /**\n     * Maps all Removed elements as keys to their corresponding RemovedGroup.\n     * A RemovedGroup contains all consecutive Removed elements.\n     * <br>\n     * Example:\n     * <pre>\n     * Elements: Kept|Removed1|Removed2|Kept|Removed3|Added|Removed4\n     * Groups:        <----Group1---->       Group2         Group3\n     * Keys:          Removed1+Removed2      Removed3       Removed4\n     * </pre>\n     *\n     * @return Map with all Removed elements as keys to their corresponding RemovedGroup\n     */\n    private Map<Removed, RemovedGroup> combineRemovedElementsToRemovedGroups() {\n        Map<Integer, List<Removed>> removedElementsMap = groupConsecutiveRemovedElements();\n        List<RemovedGroup> removedGroups = new ArrayList<>();\n        for (Map.Entry<Integer, List<Removed>> entry : removedElementsMap.entrySet()) {\n            removedGroups.add(RemovedGroup.of(entry.getKey(), entry.getValue()));\n        }\n        Map<Removed, RemovedGroup> map = new HashMap<>();\n        for (RemovedGroup removedGroup : removedGroups) {\n            for (Removed index : removedGroup) {\n                map.put(index, removedGroup);\n            }\n        }\n        return map;\n    }\n\n    private Map<Integer, List<Removed>> groupConsecutiveRemovedElements() {\n        Map<Integer, List<Removed>> removedElementsMap = new HashMap<>();\n        Integer firstElement = null;\n        for (int i = 0; i < diffElements.size(); i++) {\n            DifferenceElement diffElement = diffElements.get(i);\n            if (diffElement.isRemoved()) {\n                if (firstElement == null) {\n                    firstElement = i;\n                }\n                removedElementsMap.computeIfAbsent(firstElement, key -> new ArrayList<>()).add((Removed) diffElement);\n            } else {\n                firstElement = null;\n            }\n        }\n        return removedElementsMap;\n    }\n\n    private void applyRemovedDiffElement(RemovedGroup removedGroup, Removed removed, TextElement originalElement, boolean originalElementIsChild, boolean originalElementIsToken) {\n        if (removed.isChild() && originalElementIsChild) {\n            ChildTextElement originalElementChild = (ChildTextElement) originalElement;\n            if (originalElementChild.isComment()) {\n                // We expected to remove a proper node but we found a comment in between.\n                // If the comment is associated to the node we want to remove we remove it as well, otherwise we keep it\n                Comment comment = (Comment) originalElementChild.getChild();\n                if (!comment.isOrphan() && comment.getCommentedNode().isPresent() && comment.getCommentedNode().get().equals(removed.getChild())) {\n                    nodeText.removeElement(originalIndex);\n                } else {\n                    originalIndex++;\n                }\n            } else {\n                nodeText.removeElement(originalIndex);\n                // When we don't try to remove a complete line \n                // and removing the element is not the first action of a replacement (removal followed by addition)\n                // (in the latter case we keep the indentation)\n                // then we want to enforce the indentation.\n                if (isEnforcingIndentationActivable(removedGroup)) {\n                \t// Since the element has been deleted we try to start the analysis from the element following the one that was deleted\n                    originalIndex = considerEnforcingIndentation(nodeText, originalIndex);\n                }\n                // If in front we have one space and before also we had space let's drop one space\n                if (originalElements.size() > originalIndex && originalIndex > 0) {\n                    if (originalElements.get(originalIndex).isWhiteSpace() && originalElements.get(originalIndex - 1).isWhiteSpace()) {\n                        // However we do not want to do that when we are about to adding or removing elements\n                        // The intention is not very clear maybe it should clarify this with examples!\n                        // Are we to understand that we can only do this if there is a single modification to process\n                        // OR or if the next change is to keep the element\n                        if ((diffIndex + 1) == diffElements.size() || (diffElements.get(diffIndex + 1).isKept())) {\n                            originalElements.remove(originalIndex--);\n                        }\n                    }\n                }\n                // We need to know if, in the original list of elements, the deleted child node is immediately followed by the same comment.\n                // If so, it should also be deleted.\n                if (isFollowedByComment(originalIndex, originalElements) ) {\n                \tint indexOfNextComment = posOfNextComment(originalIndex, originalElements);\n                \tremoveElements(originalIndex, indexOfNextComment, originalElements);\n                }\n                if (isRemovingIndentationActivable(removedGroup)) {\n                \t// Since the element has been deleted we try to start the analysis from the previous element\n                    originalIndex = considerRemovingIndentation(nodeText, originalIndex);\n                }\n                diffIndex++;\n            }\n        } else if (removed.isChild() && originalElement.isComment()) {\n        \t// removing the comment first\n        \tnodeText.removeElement(originalIndex);\n        \tif (isRemovingIndentationActivable(removedGroup)) {\n                originalIndex = considerRemovingIndentation(nodeText, originalIndex);\n            }\n        } else if (removed.isToken() && originalElementIsToken && (removed.getTokenType() == ((TokenTextElement) originalElement).getTokenKind() || // handle EOLs separately as their token kind might not be equal. This is because the 'removed'\n        // element always has the current operating system's EOL as type\n        (((TokenTextElement) originalElement).getToken().getCategory().isEndOfLine() && removed.isNewLine()))) {\n            nodeText.removeElement(originalIndex);\n            diffIndex++;\n        } else if ((removed.isWhiteSpaceNotEol() || removed.getElement() instanceof CsmIndent || removed.getElement() instanceof CsmUnindent)\n        \t\t&& originalElement.isSpaceOrTab()){\n        \t// remove the current space\n        \tnodeText.removeElement(originalIndex);\n        }else if (originalElementIsToken && originalElement.isWhiteSpaceOrComment()) {\n            originalIndex++;\n            // skip the newline token which may be generated unnecessarily by the concrete syntax pattern\n            if (removed.isNewLine()) { \n            \tdiffIndex++;\n            }\n        } else if (originalElement.isLiteral()) {\n            nodeText.removeElement(originalIndex);\n            diffIndex++;\n        } else if (removed.isPrimitiveType()) {\n            if (originalElement.isPrimitive()) {\n                nodeText.removeElement(originalIndex);\n                diffIndex++;\n            } else {\n                throw new UnsupportedOperationException(\"removed \" + removed.getElement() + \" vs \" + originalElement);\n            }\n        } else if (removed.isWhiteSpace() || removed.getElement() instanceof CsmIndent || removed.getElement() instanceof CsmUnindent) {\n            diffIndex++;\n        } else if (originalElement.isWhiteSpace()) {\n            originalIndex++;\n        } else if (removed.isChild()) {\n            // see issue #3721 this case is linked for example to a change of type of variable declarator\n            nodeText.removeElement(originalIndex);\n            diffIndex++;\n        } else {\n            throw new UnsupportedOperationException(\"removed \" + removed.getElement() + \" vs \" + originalElement);\n        }\n        cleanTheLineOfLeftOverSpace(removedGroup, removed);\n    }\n\n    /**\n     * Cleans the line of left over space if there is unnecessary indentation and the element will not be replaced\n     */\n    private void cleanTheLineOfLeftOverSpace(RemovedGroup removedGroup, Removed removed) {\n        if (originalIndex >= originalElements.size()) {\n            // if all elements were already processed there is nothing to do\n            return;\n        }\n        // we dont want to remove the indentation if the last removed element is a newline\n        // because in this case we are trying to remove the indentation of the next child element\n        if (!removedGroup.isProcessed() \n        \t\t&& removedGroup.isLastElement(removed) \n        \t\t&& removedGroup.isACompleteLine()\n        \t\t&& !removed.isNewLine()) {\n            Integer lastElementIndex = removedGroup.getLastElementIndex();\n            Optional<Integer> indentation = removedGroup.getIndentation();\n            if (indentation.isPresent() && !isReplaced(lastElementIndex)) {\n                for (int i = 0; i < indentation.get(); i++) {\n                    if (originalElements.get(originalIndex).isSpaceOrTab()) {\n                        // If the current element is a space, remove it\n                        nodeText.removeElement(originalIndex);\n                    } else if (originalIndex >= 1 && originalElements.get(originalIndex - 1).isSpaceOrTab()) {\n                        // If the current element is not a space itself we remove the space in front of (before) it\n                        nodeText.removeElement(originalIndex - 1);\n                        originalIndex--;\n                    }\n                    // Remove remaining newline character if needed\n                    if (nodeText.getTextElement(originalIndex).isNewline()) {\n                    \tnodeText.removeElement(originalIndex);\n                    \toriginalIndex = originalIndex > 0 ? originalIndex-- : 0;\n                    }\n                }\n            }\n            // Mark RemovedGroup as processed\n            removedGroup.processed();\n        }\n    }\n\n    // note:\n    // increment originalIndex if we want to keep the original element\n    // increment diffIndex if we want to skip the diff element\n    private void applyKeptDiffElement(Kept kept, TextElement originalElement, boolean originalElementIsChild, boolean originalElementIsToken) {\n\t\tif (originalElement.isComment()) {\n\t\t\toriginalIndex++;\n        } else if (kept.isChild() && ((CsmChild) kept.getElement()).getChild() instanceof Comment) {\n            diffIndex++;\n        } else if (kept.isChild() && originalElementIsChild) {\n            diffIndex++;\n            originalIndex++;\n        } else if (kept.isChild() && originalElementIsToken) {\n            if (originalElement.isWhiteSpaceOrComment()) {\n                originalIndex++;\n            } else if (originalElement.isIdentifier() && isNodeWithTypeArguments(kept)) {\n                diffIndex++;\n                // skip all token related to node with type argument declaration\n                // for example:\n                // List i : in this case originalElement is \"List\" and the next token is space. There is nothing to skip. in the originalElements list.\n                // List<String> i : in this case originalElement is \"List\" and the next token is\n                // \"<\" so we have to skip all the tokens which are used in the typed argument declaration [<][String][>](3 tokens) in the originalElements list.\n                // List<List<String>> i : in this case originalElement is \"List\" and the next\n                // token is \"<\" so we have to skip all the tokens which are used in the typed arguments declaration [<][List][<][String][>][>](6 tokens) in the originalElements list.\n                int step = getIndexToNextTokenElement((TokenTextElement) originalElement, 0);\n                originalIndex += step;\n                originalIndex++;\n            } else if (originalElement.isIdentifier() && isTypeWithFullyQualifiedName(kept)) {\n                diffIndex++;\n                // skip all token related to node with the fully qualified name\n                // for example:\n                // java.lang.Object is represented in originalElement as a list of tokens \"java\", \".\", \"lang\", \".\", \"Object\".\n                // So we have to skip 5 tokens.\n                int step = getIndexToNextTokenElement((TokenTextElement) originalElement, kept);\n                originalIndex += step;\n                // positioning on the next token\n                originalIndex++;\n            } else if ((originalElement.isIdentifier() || originalElement.isKeyword()) && isArrayType(kept)) {\n                int tokenToSkip = getIndexToNextTokenElementInArrayType((TokenTextElement) originalElement, getArrayLevel(kept));\n                diffIndex++;\n                originalIndex += tokenToSkip;\n                originalIndex++;\n            } else if (originalElement.isIdentifier()) {\n                originalIndex++;\n                diffIndex++;\n            } else {\n                if (kept.isPrimitiveType()) {\n                    originalIndex++;\n                    diffIndex++;\n                } else {\n                    throw new UnsupportedOperationException(\"kept \" + kept.getElement() + \" vs \" + originalElement);\n                }\n            }\n        } else if (kept.isToken() && originalElementIsToken) {\n            TokenTextElement originalTextToken = (TokenTextElement) originalElement;\n            if (kept.getTokenType() == originalTextToken.getTokenKind()) {\n                originalIndex++;\n                diffIndex++;\n            } else if (kept.isNewLine() && originalTextToken.isNewline()) {\n                originalIndex++;\n                diffIndex++;\n            } else if (kept.isNewLine() && originalTextToken.isSpaceOrTab()) {\n                originalIndex++;\n            } else if (kept.isWhiteSpaceOrComment()) {\n                diffIndex++;\n            } else if (originalTextToken.isWhiteSpaceOrComment()) {\n                originalIndex++;\n            } else if (!kept.isNewLine() && originalTextToken.isSeparator()) {\n                // case where originalTextToken is a separator like \";\" and\n                // kept is not a new line or whitespace for example \"}\"\n                // see issue 2351\n                originalIndex++;\n            } else {\n                throw new UnsupportedOperationException(\"Csm token \" + kept.getElement() + \" NodeText TOKEN \" + originalTextToken);\n            }\n        } else if (kept.isToken() && originalElementIsChild) {\n            diffIndex++;\n        } else if (kept.isWhiteSpace()) {\n            diffIndex++;\n        } else if (kept.isIndent()) {\n            diffIndex++;\n        } else if (kept.isUnindent()) {\n            // Nothing to do\n            diffIndex++;\n        } else {\n            throw new UnsupportedOperationException(\"kept \" + kept.getElement() + \" vs \" + originalElement);\n        }\n    }\n\n    /*\n     * Returns the array level if the DifferenceElement is a CsmChild representing an ArrayType else 0\n     */\n    private int getArrayLevel(DifferenceElement element) {\n        CsmElement csmElem = element.getElement();\n        if (isArrayType(element)) {\n            Node child = ((LexicalDifferenceCalculator.CsmChild) csmElem).getChild();\n            return ((ArrayType) child).getArrayLevel();\n        }\n        return 0;\n    }\n\n    /*\n     * Returns true if the DifferenceElement is a CsmChild representing an ArrayType\n     */\n    private boolean isArrayType(DifferenceElement element) {\n        CsmElement csmElem = element.getElement();\n        return csmElem instanceof LexicalDifferenceCalculator.CsmChild && ((LexicalDifferenceCalculator.CsmChild) csmElem).getChild() instanceof ArrayType;\n    }\n\n    /*\n     * Returns true if the DifferenceElement is a CsmChild which represents a type with fully qualified name\n     */\n    private boolean isTypeWithFullyQualifiedName(DifferenceElement element) {\n        if (!element.isChild())\n            return false;\n        CsmChild child = (CsmChild) element.getElement();\n        if (!ClassOrInterfaceType.class.isAssignableFrom(child.getChild().getClass()))\n            return false;\n        return ((ClassOrInterfaceType) child.getChild()).getScope().isPresent();\n    }\n\n    /*\n     * Returns true if the DifferenceElement is a CsmChild with type arguments\n     */\n    private boolean isNodeWithTypeArguments(DifferenceElement element) {\n        if (!element.isChild())\n            return false;\n        CsmChild child = (CsmChild) element.getElement();\n        if (!NodeWithTypeArguments.class.isAssignableFrom(child.getChild().getClass()))\n            return false;\n        Optional<NodeList<Type>> typeArgs = ((NodeWithTypeArguments) child.getChild()).getTypeArguments();\n        return typeArgs.isPresent() && typeArgs.get().size() > 0;\n    }\n\n    /*\n     * Try to resolve the number of token to skip in the original list to match \n     * a ClassOrInterfaceType with a list of tokens like \"java\", \".\", \"lang\", \".\", \"Object\"\n     */\n    private int getIndexToNextTokenElement(TokenTextElement element, DifferenceElement kept) {\n        // number of token to skip\n        int step = 0;\n        // verify if the DifferenceElement is a ClassOrInterfaceType with a fully qualified name\n        if (!isTypeWithFullyQualifiedName(kept))\n            return 0;\n        CsmChild child = (CsmChild) kept.getElement();\n        // split the type fully qualified node name to an array of tokens\n        String[] parts = ((ClassOrInterfaceType) child.getChild()).getNameWithScope().split(\"\\\\.\");\n        JavaToken token = element.getToken();\n        for (String part : parts) {\n            if (part.equals(token.asString())) {\n                // get 'dot' token\n                token = token.getNextToken().get();\n                if (!token.asString().equals(\".\"))\n                    break;\n                // get the next part\n                token = token.getNextToken().get();\n                step += 2;\n                continue;\n            }\n            // there is no match so we don't have token to skip\n            step = 0;\n            break;\n        }\n        return step;\n    }\n\n    /*\n     * Returns the number of tokens to skip in originalElements list to synchronize it with the DiffElements list\n     * This is due to the fact that types are considered as token in the originalElements list.\n     * For example,\n     * List<String> is represented by 4 tokens ([List][<][String][>]) while it's a CsmChild element in the DiffElements list\n     * So in this case, getIndexToNextTokenElement(..) on the [List] token returns 3 because we have to skip 3 tokens ([<][String][>]) to synchronize\n     * DiffElements list and originalElements list\n     * The end of recursivity is reached when there is no next token or if the nested diamond operators are totally managed, to take into account this type of declaration\n     * List <List<String>> l\n     * Be careful, this method must be call only if diamond operator could be found in the sequence\n     *\n     * @Param TokenTextElement the token currently analyzed\n     * @Param int the number of nested diamond operators\n     * @return the number of token to skip in originalElements list\n     */\n    private int getIndexToNextTokenElement(TokenTextElement element, int nestedDiamondOperator) {\n        // number of token to skip\n        int step = 0;\n        Optional<JavaToken> next = element.getToken().getNextToken();\n        if (!next.isPresent())\n            return step;\n        // because there is a token, first we need to increment the number of token to skip\n        step++;\n        // manage nested diamond operators by incrementing the level on LT token and decrementing on GT\n        JavaToken nextToken = next.get();\n        Kind kind = Kind.valueOf(nextToken.getKind());\n        if (isDiamondOperator(kind)) {\n            if (kind.GT.equals(kind))\n                nestedDiamondOperator--;\n            else\n                nestedDiamondOperator++;\n        }\n        // manage the fact where the first token is not a diamond operator but a whitespace\n        // and the end of the token sequence to skip\n        // for example in this declaration List <String> a;\n        if (nestedDiamondOperator == 0 && !nextToken.getCategory().isWhitespace())\n            return step;\n        // recursively analyze token to skip\n        return step += getIndexToNextTokenElement(new TokenTextElement(nextToken), nestedDiamondOperator);\n    }\n\n    /*\n     * Returns the number of tokens to skip in originalElements list to synchronize it with the DiffElements list\n     */\n    private int getIndexToNextTokenElementInArrayType(TokenTextElement element, int arrayLevel) {\n        // number of token to skip\n        int step = 0;\n        Optional<JavaToken> next = element.getToken().getNextToken();\n        if (!next.isPresent())\n            return step;\n        // because there is a token, first we need to increment the number of token to skip\n        step++;\n        // manage array Level by decrementing the level on right bracket token\n        JavaToken nextToken = next.get();\n        Kind kind = Kind.valueOf(nextToken.getKind());\n        if (isBracket(kind)) {\n            if (kind.RBRACKET.equals(kind))\n                arrayLevel--;\n        }\n        // manage the fact where the first token is not a diamond operator but a whitespace\n        // and the end of the token sequence to skip\n        // for example in this declaration int [] a;\n        if (arrayLevel == 0 && !nextToken.getCategory().isWhitespace())\n            return step;\n        // recursively analyze token to skip\n        return step += getIndexToNextTokenElementInArrayType(new TokenTextElement(nextToken), arrayLevel);\n    }\n\n    /*\n     * Returns true if the token is possibly a diamond operator\n     */\n    private boolean isDiamondOperator(Kind kind) {\n        return kind.GT.equals(kind) || kind.LT.equals(kind);\n    }\n\n    /*\n     * Returns true if the token is a bracket\n     */\n    private boolean isBracket(Kind kind) {\n        return kind.LBRACKET.equals(kind) || kind.RBRACKET.equals(kind);\n    }\n\n    private boolean openBraceWasOnSameLine() {\n        int index = originalIndex;\n        while (index >= 0 && !nodeText.getTextElement(index).isNewline()) {\n            if (nodeText.getTextElement(index).isToken(LBRACE)) {\n                return true;\n            }\n            index--;\n        }\n        return false;\n    }\n\n    private boolean wasSpaceBetweenBraces() {\n        return nodeText.getTextElement(originalIndex).isToken(RBRACE) && doWeHaveLeftBraceFollowedBySpace(originalIndex - 1) && (diffIndex < 2 || !diffElements.get(diffIndex - 2).isRemoved());\n    }\n\n    private boolean doWeHaveLeftBraceFollowedBySpace(int index) {\n        index = rewindSpace(index);\n        return nodeText.getTextElement(index).isToken(LBRACE);\n    }\n\n    private int rewindSpace(int index) {\n        if (index <= 0) {\n            return index;\n        }\n        if (nodeText.getTextElement(index).isWhiteSpace()) {\n            return rewindSpace(index - 1);\n        } else {\n            return index;\n        }\n    }\n\n    private boolean nextIsRightBrace(int index) {\n        List<TextElement> elements = originalElements.subList(index, originalElements.size());\n        for (TextElement element : elements) {\n            if (!element.isSpaceOrTab()) {\n                return element.isToken(RBRACE);\n            }\n        }\n        return false;\n    }\n\n    private void applyAddedDiffElement(Added added) {\n        if (added.isIndent()) {\n            for (int i = 0; i < STANDARD_INDENTATION_SIZE; i++) {\n                indentation.add(new TokenTextElement(GeneratedJavaParserConstants.SPACE));\n            }\n            addedIndentation = true;\n            diffIndex++;\n            return;\n        }\n        if (added.isUnindent()) {\n            for (int i = 0; i < STANDARD_INDENTATION_SIZE && !indentation.isEmpty(); i++) {\n                indentation.remove(indentation.size() - 1);\n            }\n            addedIndentation = false;\n            diffIndex++;\n            return;\n        }\n        TextElement addedTextElement = added.toTextElement();\n        boolean used = false;\n        boolean isPreviousElementNewline = (originalIndex > 0) && originalElements.get(originalIndex - 1).isNewline();\n        if (isPreviousElementNewline) {\n            List<TextElement> elements = processIndentation(indentation, originalElements.subList(0, originalIndex - 1));\n            boolean nextIsRightBrace = nextIsRightBrace(originalIndex);\n            for (TextElement e : elements) {\n                if (!nextIsRightBrace && e instanceof TokenTextElement && originalElements.get(originalIndex).isToken(((TokenTextElement) e).getTokenKind())) {\n                    originalIndex++;\n                } else {\n                    nodeText.addElement(originalIndex++, e);\n                }\n            }\n        } else if (isAfterLBrace(nodeText, originalIndex) && !isAReplacement(diffIndex)) {\n            if (addedTextElement.isNewline()) {\n                used = true;\n            }\n            nodeText.addElement(originalIndex++, new TokenTextElement(TokenTypes.eolTokenKind()));\n            // This remove the space in \"{ }\" when adding a new line\n            while (originalIndex >= 2 && originalElements.get(originalIndex - 2).isSpaceOrTab()) {\n                originalElements.remove(originalIndex - 2);\n                originalIndex--;\n            }\n            for (TextElement e : processIndentation(indentation, originalElements.subList(0, originalIndex - 1))) {\n                nodeText.addElement(originalIndex++, e);\n            }\n            // Indentation is painful...\n            // Sometimes we want to force indentation: this is the case when indentation was expected but\n            // was actually not there. For example if we have \"{ }\" we would expect indentation but it is\n            // not there, so when adding new elements we force it. However if the indentation has been\n            // inserted by us in this transformation we do not want to insert it again\n            if (!addedIndentation) {\n                for (TextElement e : indentationBlock()) {\n                    nodeText.addElement(originalIndex++, e);\n                }\n            }\n        }\n        if (!used) {\n            // Handling trailing comments\n            boolean sufficientTokensRemainToSkip = nodeText.numberOfElements() > originalIndex + 2;\n            boolean currentIsAComment = nodeText.getTextElement(originalIndex).isComment();\n            boolean previousIsAComment = originalIndex > 0 && nodeText.getTextElement(originalIndex - 1).isComment();\n            boolean currentIsNewline = nodeText.getTextElement(originalIndex).isNewline();\n            boolean isFirstElement = originalIndex == 0;\n            boolean previousIsWhiteSpace = originalIndex > 0 && nodeText.getTextElement(originalIndex - 1).isWhiteSpace();\n\t\t\tboolean commentIsBeforeAddedElement = currentIsAComment && addedTextElement.getRange().isPresent()\n\t\t\t\t\t&& nodeText.getTextElement(originalIndex).getRange()\n\t\t\t\t\t\t\t.map(range -> range.isBefore(addedTextElement.getRange().get())).orElse(false);\n            if (sufficientTokensRemainToSkip && currentIsAComment && commentIsBeforeAddedElement) {\n                // Need to get behind the comment:\n                // FIXME: Why 2? This comment and the next newline?\n                originalIndex += 2;\n                // Defer originalIndex increment\n                nodeText.addElement(originalIndex, addedTextElement);\n                // We want to adjust the indentation while considering the new element that we added\n                originalIndex = adjustIndentation(indentation, nodeText, originalIndex, false);\n                // Now we can increment\n                originalIndex++;\n            } else if (currentIsNewline && previousIsAComment) {\n                /*\n                 * Manage the case where we want to add an element, after an expression which is followed by a comment on the same line.\n                 * This is not the same case as the one who handles the trailing comments, because in this case the node text element is a new line (not a comment)\n                 * For example : {@code private String a; // this is a }\n                 */\n                // Insert after the new line which follows this comment.\n                originalIndex++;\n                // We want to adjust the indentation while considering the new element that we added\n                originalIndex = adjustIndentation(indentation, nodeText, originalIndex, false);\n                // Defer originalIndex increment\n                nodeText.addElement(originalIndex, addedTextElement);\n                // Now we can increment.\n                originalIndex++;\n            } else if (currentIsNewline && addedTextElement.isChild()) {\n                // here we want to place the new child element after the current new line character.\n                // Except if indentation has been inserted just before this step (in the case where isPreviousElementNewline is true)\n                // or if the previous character is a space (it could be the case if we want to replace a statement)\n                // Example 1 : if we insert a statement (a duplicated method call expression ) after this one <code>  value();\\n\\n</code>\n                // we want to have this result <code>  value();\\n  value();\\n</code> not <code>  value();\\n  \\nvalue();</code>\n                // Example 2 : if we want to insert a statement after this one <code>  \\n</code> we want to have <code>  value();\\n</code>\n                // not <code>  \\nvalue();</code> --> this case appears on member replacement for example\n                if (!isPreviousElementNewline && !isFirstElement && !previousIsWhiteSpace) {\n                    // Insert after the new line\n                    originalIndex++;\n                }\n                nodeText.addElement(originalIndex, addedTextElement);\n                originalIndex++;\n            } else {\n                nodeText.addElement(originalIndex, addedTextElement);\n                originalIndex++;\n            }\n        }\n        if (addedTextElement.isNewline()) {\n            boolean followedByUnindent = isFollowedByUnindent(diffElements, diffIndex);\n            boolean nextIsRightBrace = nextIsRightBrace(originalIndex);\n            boolean nextIsNewLine = originalElements.get(originalIndex).isNewline();\n            if ((!nextIsNewLine && !nextIsRightBrace) || followedByUnindent) {\n                originalIndex = adjustIndentation(indentation, nodeText, originalIndex, followedByUnindent);\n            }\n        }\n        diffIndex++;\n    }\n\n    private String tokenDescription(int kind) {\n        return GeneratedJavaParserConstants.tokenImage[kind];\n    }\n\n\t/*\n\t * Considering that the lists of elements are ordered, We can find the common\n\t * elements by starting with the list before the modifications and, for each\n\t * element, by going through the list of elements containing the modifications.\n\t * \n\t * We can find the common elements by starting with the list before the\n\t * modifications (L1) and, for each element, by going through the list of elements\n\t * containing the modifications (L2).\n\t * \n\t * If element A in list L1 is not found in list L2, it is a deleted element. \n\t * If element A of list L1 is found in list L2, it is a kept element. In this\n\t * case the search for the next element of the list L1 must start from the\n\t * position of the last element kept {@code syncNextIndex}.\n\t */\n\tprivate Map<Integer, Integer> getCorrespondanceBetweenNextOrderAndPreviousOrder(CsmMix elementsFromPreviousOrder,\n\t\t\tCsmMix elementsFromNextOrder) {\n\t\tMap<Integer, Integer> correspondanceBetweenNextOrderAndPreviousOrder = new HashMap<>();\n\t\tReadOnlyListIterator<CsmElement> previousOrderElementsIterator = new ReadOnlyListIterator(\n\t\t\t\telementsFromPreviousOrder.getElements());\n\t\tint syncNextIndex = 0;\n\t\twhile (previousOrderElementsIterator.hasNext()) {\n\t\t\tCsmElement pe = previousOrderElementsIterator.next();\n\t\t\tReadOnlyListIterator<CsmElement> nextOrderElementsIterator = new ReadOnlyListIterator(\n\t\t\t\t\telementsFromNextOrder.getElements(), syncNextIndex);\n\t\t\twhile (nextOrderElementsIterator.hasNext()) {\n\t\t\t\tCsmElement ne = nextOrderElementsIterator.next();\n\t\t\t\tif (!correspondanceBetweenNextOrderAndPreviousOrder.values().contains(previousOrderElementsIterator.index())\n\t\t\t\t\t\t&& DifferenceElementCalculator.matching(ne, pe)) {\n\t\t\t\t\tcorrespondanceBetweenNextOrderAndPreviousOrder.put(nextOrderElementsIterator.index(),\n\t\t\t\t\t\t\tpreviousOrderElementsIterator.index());\n\t\t\t\t\t// set the position to start on the next {@code nextOrderElementsIterator} iteration\n\t\t\t\t\tsyncNextIndex = nextOrderElementsIterator.index(); \n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn correspondanceBetweenNextOrderAndPreviousOrder;\n\t}\n    \n    /*\n     * A list iterator which does not allow to modify the list \n     * and which provides a method to know the current positioning \n     */\n    private class ReadOnlyListIterator<T> implements ListIterator<T> {\n    \tListIterator<T> elements;\n    \tpublic ReadOnlyListIterator(List<T> elements) {\n    \t\tthis(elements, 0);\n    \t}\n    \t\n    \tpublic ReadOnlyListIterator(List<T> elements, int index) {\n    \t\tthis.elements = elements.listIterator(index);\n    \t}\n\n\t\t@Override\n\t\tpublic boolean hasNext() {\n\t\t\treturn elements.hasNext();\n\t\t}\n\n\t\t@Override\n\t\tpublic T next() {\n\t\t\treturn elements.next();\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean hasPrevious() {\n\t\t\treturn elements.hasPrevious();\n\t\t}\n\n\t\t@Override\n\t\tpublic T previous() {\n\t\t\treturn elements.previous();\n\t\t}\n\n\t\t@Override\n\t\tpublic int nextIndex() {\n\t\t\treturn elements.nextIndex();\n\t\t}\n\n\t\t@Override\n\t\tpublic int previousIndex() {\n\t\t\treturn elements.previousIndex();\n\t\t}\n\t\t\n\t\t/*\n\t\t * Returns the current index in the underlying list\n\t\t */\n\t\tpublic int index() {\n\t\t\treturn elements.nextIndex() - 1;\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic void remove() {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\n\t\t@Override\n\t\tpublic void set(T e) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\n\t\t@Override\n\t\tpublic void add(T e) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n    \t\n    }\n\n    /*\n     * Returns true if the next element in the list is an added element of type CsmUnindent\n     */\n    private boolean isFollowedByUnindent(List<DifferenceElement> diffElements, int diffIndex) {\n        int nextIndexValue = diffIndex + 1;\n        return (nextIndexValue) < diffElements.size() && diffElements.get(nextIndexValue).isAdded() && diffElements.get(nextIndexValue).getElement() instanceof CsmUnindent;\n    }\n\n    private List<Integer> findIndexOfCorrespondingNodeTextElement(List<CsmElement> elements, NodeText nodeText, int startIndex, Node node) {\n        List<Integer> correspondingIndices = new ArrayList<>();\n        for (ListIterator<CsmElement> csmElementListIterator = elements.listIterator(); csmElementListIterator.hasNext(); ) {\n            int previousCsmElementIndex = csmElementListIterator.previousIndex();\n            CsmElement csmElement = csmElementListIterator.next();\n            int nextCsmElementIndex = csmElementListIterator.nextIndex();\n            Map<MatchClassification, Integer> potentialMatches = new EnumMap<>(MatchClassification.class);\n            for (int i = startIndex; i < nodeText.numberOfElements(); i++) {\n                if (!correspondingIndices.contains(i)) {\n                    TextElement textElement = nodeText.getTextElement(i);\n                    boolean isCorresponding = isCorrespondingElement(textElement, csmElement, node);\n                    if (isCorresponding) {\n                        boolean hasSamePreviousElement = false;\n                        if (i > 0 && previousCsmElementIndex > -1) {\n                            TextElement previousTextElement = nodeText.getTextElement(i - 1);\n                            hasSamePreviousElement = isCorrespondingElement(previousTextElement, elements.get(previousCsmElementIndex), node);\n                        }\n                        boolean hasSameNextElement = false;\n                        if (i < nodeText.numberOfElements() - 1 && nextCsmElementIndex < elements.size()) {\n                            TextElement nextTextElement = nodeText.getTextElement(i + 1);\n                            hasSameNextElement = isCorrespondingElement(nextTextElement, elements.get(nextCsmElementIndex), node);\n                        }\n                        if (hasSamePreviousElement && hasSameNextElement) {\n                            potentialMatches.putIfAbsent(MatchClassification.ALL, i);\n                        } else if (hasSamePreviousElement) {\n                            potentialMatches.putIfAbsent(MatchClassification.PREVIOUS_AND_SAME, i);\n                        } else if (hasSameNextElement) {\n                            potentialMatches.putIfAbsent(MatchClassification.NEXT_AND_SAME, i);\n                        } else {\n                            potentialMatches.putIfAbsent(MatchClassification.SAME_ONLY, i);\n                        }\n                    } else if (isAlmostCorrespondingElement(textElement, csmElement, node)) {\n                        potentialMatches.putIfAbsent(MatchClassification.ALMOST, i);\n                    }\n                }\n            }\n            // Prioritize the matches from best to worst\n            Optional<MatchClassification> bestMatchKey = potentialMatches.keySet().stream().min(Comparator.comparing(MatchClassification::getPriority));\n            if (bestMatchKey.isPresent()) {\n                correspondingIndices.add(potentialMatches.get(bestMatchKey.get()));\n            } else {\n                correspondingIndices.add(-1);\n            }\n        }\n        return correspondingIndices;\n    }\n\n    private enum MatchClassification {\n\n        ALL(1), PREVIOUS_AND_SAME(2), NEXT_AND_SAME(3), SAME_ONLY(4), ALMOST(5);\n\n        private final int priority;\n\n        MatchClassification(int priority) {\n            this.priority = priority;\n        }\n\n        int getPriority() {\n            return priority;\n        }\n    }\n\n    private boolean isCorrespondingElement(TextElement textElement, CsmElement csmElement, Node node) {\n        if (csmElement instanceof CsmToken) {\n            CsmToken csmToken = (CsmToken) csmElement;\n            if (textElement instanceof TokenTextElement) {\n                TokenTextElement tokenTextElement = (TokenTextElement) textElement;\n                return tokenTextElement.getTokenKind() == csmToken.getTokenType() && tokenTextElement.getText().equals(csmToken.getContent(node));\n            }\n        } else if (csmElement instanceof CsmChild) {\n            CsmChild csmChild = (CsmChild) csmElement;\n            if (textElement instanceof ChildTextElement) {\n                ChildTextElement childTextElement = (ChildTextElement) textElement;\n                return childTextElement.getChild() == csmChild.getChild();\n            }\n        } else if (csmElement instanceof CsmIndent) {\n        \tCsmIndent csmIndent = (CsmIndent) csmElement;\n            if (textElement instanceof TokenTextElement) {\n            \tTokenTextElement tokenTextElement = (TokenTextElement) textElement;\n                return tokenTextElement.isSpaceOrTab();\n            }\n        } else {\n            throw new UnsupportedOperationException();\n        }\n        return false;\n    }\n\n    private boolean isAlmostCorrespondingElement(TextElement textElement, CsmElement csmElement, Node node) {\n        if (isCorrespondingElement(textElement, csmElement, node)) {\n            return false;\n        }\n        return textElement.isWhiteSpace() && csmElement instanceof CsmToken && ((CsmToken) csmElement).isWhiteSpace();\n    }\n\n    private int adjustIndentation(List<TextElement> indentation, NodeText nodeText, int nodeTextIndex, boolean followedByUnindent) {\n        List<TextElement> indentationAdj = processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1));\n        if (nodeTextIndex < nodeText.numberOfElements() && nodeText.getTextElement(nodeTextIndex).isToken(RBRACE)) {\n            indentationAdj = indentationAdj.subList(0, indentationAdj.size() - Math.min(STANDARD_INDENTATION_SIZE, indentationAdj.size()));\n        } else if (followedByUnindent) {\n            indentationAdj = indentationAdj.subList(0, Math.max(0, indentationAdj.size() - STANDARD_INDENTATION_SIZE));\n        }\n        for (TextElement e : indentationAdj) {\n            if ((nodeTextIndex < nodeText.numberOfElements()) && nodeText.getTextElement(nodeTextIndex).isSpaceOrTab()) {\n                nodeTextIndex++;\n            } else {\n                nodeText.getElements().add(nodeTextIndex++, e);\n            }\n        }\n        if (nodeTextIndex < 0) {\n            throw new IllegalStateException();\n        }\n        return nodeTextIndex;\n    }\n\n    /*\n     * Returns true if the current <code>Added</code> element is preceded by a <code>Removed</code> element.\n     */\n    private boolean isAReplacement(int diffIndex) {\n        return (diffIndex > 0) && diffElements.get(diffIndex).isAdded() && diffElements.get(diffIndex - 1).isRemoved();\n    }\n\n    /*\n     * Returns true if the current <code>Removed</code> element is followed by a <code>Added</code> element.\n     */\n    private boolean isReplaced(int diffIndex) {\n        return (diffIndex < diffElements.size() - 1) && diffElements.get(diffIndex + 1).isAdded() && diffElements.get(diffIndex).isRemoved();\n    }\n\n    @Override\n    public String toString() {\n        return \"Difference{\" + diffElements + '}';\n    }\n}\n",
        "filePathAfter": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Difference.java",
        "sourceCodeAfterForWhole": "/*\n * Copyright (C) 2007-2010 J\u00falio Vilmar Gesser.\n * Copyright (C) 2011, 2013-2023 The JavaParser Team.\n *\n * This file is part of JavaParser.\n *\n * JavaParser can be used either under the terms of\n * a) the GNU Lesser General Public License as published by\n *     the Free Software Foundation, either version 3 of the License, or\n *     (at your option) any later version.\n * b) the terms of the Apache License\n *\n * You should have received a copy of both licenses in LICENCE.LGPL and\n * LICENCE.APACHE. Please refer to those files for details.\n *\n * JavaParser is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n */\npackage com.github.javaparser.printer.lexicalpreservation;\n\nimport static com.github.javaparser.GeneratedJavaParserConstants.*;\n\nimport java.util.*;\nimport java.util.function.Predicate;\nimport java.util.stream.IntStream;\n\nimport com.github.javaparser.GeneratedJavaParserConstants;\nimport com.github.javaparser.JavaToken;\nimport com.github.javaparser.JavaToken.Kind;\nimport com.github.javaparser.TokenTypes;\nimport com.github.javaparser.ast.Node;\nimport com.github.javaparser.ast.NodeList;\nimport com.github.javaparser.ast.comments.Comment;\nimport com.github.javaparser.ast.nodeTypes.NodeWithTypeArguments;\nimport com.github.javaparser.ast.type.ArrayType;\nimport com.github.javaparser.ast.type.ClassOrInterfaceType;\nimport com.github.javaparser.ast.type.Type;\nimport com.github.javaparser.printer.concretesyntaxmodel.*;\nimport com.github.javaparser.printer.lexicalpreservation.LexicalDifferenceCalculator.CsmChild;\n\n/**\n * A Difference should give me a sequence of elements I should find (to indicate the context) followed by a list of elements\n * to remove or to add and follow by another sequence of elements.\n *\n * I should later be able to apply such difference to a nodeText.\n */\npublic class Difference {\n\n    public static final int STANDARD_INDENTATION_SIZE = 4;\n\n    private final NodeText nodeText;\n\n    private final Node node;\n\n    private final List<DifferenceElement> diffElements;\n\n    private final List<TextElement> originalElements;\n\n    private int originalIndex = 0;\n\n    private int diffIndex = 0;\n\n    private final List<TextElement> indentation;\n\n    private boolean addedIndentation = false;\n\n    Difference(List<DifferenceElement> diffElements, NodeText nodeText, Node node) {\n        if (nodeText == null) {\n            throw new NullPointerException(\"nodeText can not be null\");\n        }\n        this.nodeText = nodeText;\n        this.node = node;\n        this.diffElements = diffElements;\n        this.originalElements = nodeText.getElements();\n        this.indentation = LexicalPreservingPrinter.findIndentation(node);\n    }\n\n    /*\n     * Returns the indentation used after the last line break\n     */\n    private List<TextElement> processIndentation(List<TextElement> indentation, List<TextElement> prevElements) {\n        int eolIndex = lastIndexOfEol(prevElements);\n        // Return \"indentation\" as is if no EOL element was found\n        if (eolIndex < 0)\n            return indentation;\n        // Find consecutive space characters after the EOL element\n        indentation = takeWhile(prevElements.subList(eolIndex + 1, prevElements.size()), element -> element.isWhiteSpace());\n        return indentation;\n    }\n\n    /*\n     * returns only the elements that match the given predicate.\n     * takeWhile takes elements from the initial stream while the predicate holds true.\n     * Meaning that when an element is encountered that does not match the predicate, the rest of the list is discarded.\n     */\n    List<TextElement> takeWhile(List<TextElement> prevElements, Predicate<TextElement> predicate) {\n    \tList<TextElement> spaces = new ArrayList<>();\n    \tfor (TextElement element : prevElements) {\n    \t\tif (predicate.test(element)) {\n    \t\t\tspaces.add(element);\n                continue;\n            }\n            break;\n    \t}\n    \treturn spaces;\n    }\n\n\n    int lastIndexOfEol(List<TextElement> source) {\n        return IntStream.range(0, source.size())\n                       .map(i -> source.size() - i - 1)\n                       .filter(i -> source.get(i).isNewline())\n                       .findFirst()\n                       .orElse(-1);\n    }\n\n    /*\n     * Returns the position of the next element in the list starting from @{code fromIndex} which is a comment (Ignoring spaces)\n     * or -1 if it's not a comment.\n     */\n    private int posOfNextComment(int fromIndex, List<TextElement> elements) {\n        if (!isValidIndex(fromIndex, elements))\n            return -1;\n        ReadOnlyListIterator<TextElement> iterator = new ReadOnlyListIterator(elements, fromIndex);\n        // search for the next consecutive space characters\n        while (iterator.hasNext()) {\n            TextElement element = iterator.next();\n            if (element.isSpaceOrTab()) {\n                continue;\n            }\n            if (element.isComment()) {\n            \treturn iterator.index();\n            }\n            break;\n        }\n        return -1;\n    }\n\n    /*\n     * Returns true if the next element in the list (starting from @{code fromIndex}) is a comment\n     */\n    private boolean isFollowedByComment(int fromIndex, List<TextElement> elements) {\n    \treturn posOfNextComment(fromIndex, elements) != -1;\n    }\n\n    /*\n     * Removes all elements in the list starting from @{code fromIndex}) ending to @{code toIndex})\n     */\n    private void removeElements(int fromIndex, int toIndex, List<TextElement> elements) {\n    \tif (!(isValidIndex(fromIndex, elements) && isValidIndex(toIndex, elements) && fromIndex <= toIndex))\n            return;\n        ListIterator<TextElement> iterator = elements.listIterator(fromIndex);\n        // removing elements\n        int count = fromIndex;\n        while (iterator.hasNext() && count <= toIndex) {\n        \tTextElement element = iterator.next();\n            iterator.remove();\n            count++;\n        }\n    }\n\n    private boolean isValidIndex(int index, List<?> elements) {\n    \treturn index >= 0 && index <= elements.size();\n    }\n\n    /*\n     * Returns the position of the last new line character or -1 if there is no eol in the specified list of TextElement\n     */\n    int lastIndexOfEolWithoutGPT(List<TextElement> source) {\n        ListIterator listIterator = source.listIterator(source.size());\n        int lastIndex = source.size() - 1;\n        while (listIterator.hasPrevious()) {\n            TextElement elem = (TextElement) listIterator.previous();\n            if (elem.isNewline()) {\n                return lastIndex;\n            }\n            lastIndex--;\n        }\n        return -1;\n    }\n\n    private List<TextElement> indentationBlock() {\n        List<TextElement> res = new LinkedList<>();\n        res.add(new TokenTextElement(SPACE));\n        res.add(new TokenTextElement(SPACE));\n        res.add(new TokenTextElement(SPACE));\n        res.add(new TokenTextElement(SPACE));\n        return res;\n    }\n\n    private boolean isAfterLBrace(NodeText nodeText, int nodeTextIndex) {\n        if (nodeTextIndex > 0 && nodeText.getTextElement(nodeTextIndex - 1).isToken(LBRACE)) {\n            return true;\n        }\n        if (nodeTextIndex > 0 && nodeText.getTextElement(nodeTextIndex - 1).isSpaceOrTab()) {\n            return isAfterLBrace(nodeText, nodeTextIndex - 1);\n        }\n        return false;\n    }\n\n    /**\n     * If we are at the beginning of a line, with just spaces or tabs before/after the position of the deleted element\n     * we should force the space to be the same as the current indentation.\n     * This method handles the following case if we remove the modifier {@code public} ([ ] is an indent character)\n     * {@code\n     * [ ][ ]public[ ][ ][ ]void[ ]m{}\n     * <-1-->      <---2--->\n     * 1/ current indentation\n     * 2/ these whitespaces must be removed\n     * }\n     * should produce\n     * {@code\n     * [ ][ ]void[ ]m{}\n     * }\n     */\n    private int considerEnforcingIndentation(NodeText nodeText, int nodeTextIndex) {\n        return considerIndentation(nodeText, nodeTextIndex, indentation.size());\n    }\n\n    private int considerRemovingIndentation(NodeText nodeText, int nodeTextIndex) {\n        return considerIndentation(nodeText, nodeTextIndex, 0);\n    }\n\n    private int considerIndentation(NodeText nodeText, int nodeTextIndex, int numberOfCharactersToPreserve) {\n        EnforcingIndentationContext enforcingIndentationContext = defineEnforcingIndentationContext(nodeText, nodeTextIndex);\n        // the next position in the list (by default the current position)\n        int res = nodeTextIndex;\n        if (enforcingIndentationContext.extraCharacters > 0) {\n        \tint extraCharacters = enforcingIndentationContext.extraCharacters > numberOfCharactersToPreserve ? enforcingIndentationContext.extraCharacters - numberOfCharactersToPreserve : 0;\n            res = removeExtraCharacters(nodeText, enforcingIndentationContext.start, extraCharacters);\n            // The next position must take into account the indentation\n            res = extraCharacters > 0 ? res + numberOfCharactersToPreserve : res;\n        }\n        if (res < 0) {\n            throw new IllegalStateException();\n        }\n        return res;\n    }\n\n    private boolean isEnforcingIndentationActivable(RemovedGroup removedGroup) {\n\t\treturn (isLastElement(diffElements, diffIndex) || !(nextDiffElement(diffElements,diffIndex).isAdded()))\n\t\t\t\t&& originalIndex < originalElements.size()\n\t\t\t\t&& !removedGroup.isACompleteLine();\n\t}\n\n    private boolean isRemovingIndentationActivable(RemovedGroup removedGroup) {\n\t\treturn (isLastElement(diffElements, diffIndex) || !(nextDiffElement(diffElements,diffIndex).isAdded()))\n\t\t\t\t&& originalIndex < originalElements.size()\n\t\t\t\t&& removedGroup.isACompleteLine();\n\t}\n\n    private boolean isLastElement(List<?> list, int index) {\n\t\treturn index + 1 >= list.size();\n\t}\n\n    private DifferenceElement nextDiffElement(List<DifferenceElement> list, int index) {\n    \treturn list.get(index + 1);\n    }\n\n    /*\n     * This data structure class hold the starting position of the first whitespace char\n     * and the number of consecutive whitespace (or tab) characters\n     */\n    private class EnforcingIndentationContext {\n    \tint start;\n    \tint extraCharacters;\n    \tpublic EnforcingIndentationContext(int start) {\n    \t\tthis(start,0);\n    \t}\n    \tpublic EnforcingIndentationContext(int start, int extraCharacters) {\n    \t\tthis.start=start;\n    \t\tthis.extraCharacters=extraCharacters;\n    \t}\n    }\n\n    /**\n     * Remove excess white space after deleting element.\n     * @param nodeText Contains a list of elements to analyze\n     * @param nodeTextIndex Starting position in the input list\n     * @return The current position in the list of the elements\n     */\n    private int removeExtraCharacters(NodeText nodeText, int nodeTextIndex, int extraCharacters) {\n        int count = 0;\n        while (nodeTextIndex >= 0 && nodeTextIndex < nodeText.numberOfElements() && count < extraCharacters) {\n            nodeText.removeElement(nodeTextIndex);\n            count++;\n        }\n        return nodeTextIndex;\n    }\n\n    /**\n     * Starting at {@code nodeTextIndex} this method tries to determine how many contiguous spaces there are between\n     * the previous end of line and the next non whitespace (or tab) character\n     * @param nodeText List of elements to analyze\n     * @param nodeTextIndex Starting position in the input list\n     * @return EnforcingIndentationContext Data structure that hold the starting position of the first whitespace char and\n     * The number of consecutive whitespace (or tab) characters\n     */\n    private EnforcingIndentationContext defineEnforcingIndentationContext(NodeText nodeText, int startIndex) {\n    \tEnforcingIndentationContext ctx = new EnforcingIndentationContext(startIndex);\n    \t// compute space before startIndex value\n\t\tif (startIndex < nodeText.numberOfElements() && startIndex > 0) {\n\t\t\t// at this stage startIndex points to the first element before the deleted one\n\t\t\tfor (int i = startIndex - 1; i >= 0 && i < nodeText.numberOfElements(); i--) {\n\t\t\t\tif (nodeText.getTextElement(i).isNewline()) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (!isSpaceOrTabElement(nodeText, i)) {\n\t\t\t\t\tctx = new EnforcingIndentationContext(startIndex);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tctx.start = i;\n\t\t\t\tctx.extraCharacters++;\n\t\t\t}\n\t\t}\n\t\t// compute space after the deleted element\n\t\tif (isSpaceOrTabElement(nodeText, startIndex)) {\n//\t\t\tint startingFromIndex = startIndex == 0 ? startIndex : startIndex + 1;\n\t\t\tfor (int i = startIndex; i >= 0 && i < nodeText.numberOfElements(); i++) {\n\t\t\t\tif (nodeText.getTextElement(i).isNewline()) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (!isSpaceOrTabElement(nodeText, i)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tctx.extraCharacters++;\n\t\t\t}\n\t\t}\n\n        return ctx;\n    }\n\n    /*\n     * Returns true if the indexed element is a space or a tab\n     */\n\tprivate boolean isSpaceOrTabElement(NodeText nodeText, int i) {\n\t\treturn nodeText.getTextElement(i).isSpaceOrTab();\n\t}\n\n    /**\n     * Node that we have calculate the Difference we can apply to a concrete NodeText, modifying it according\n     * to the difference (adding and removing the elements provided).\n     */\n    void apply() {\n        extractReshuffledDiffElements(diffElements);\n        Map<Removed, RemovedGroup> removedGroups = combineRemovedElementsToRemovedGroups();\n        do {\n            boolean isLeftOverDiffElement = applyLeftOverDiffElements();\n            boolean isLeftOverOriginalElement = applyLeftOverOriginalElements();\n            if (!isLeftOverDiffElement && !isLeftOverOriginalElement) {\n                DifferenceElement diffElement = diffElements.get(diffIndex);\n                if (diffElement.isAdded()) {\n                    applyAddedDiffElement((Added) diffElement);\n                } else {\n                    TextElement originalElement = originalElements.get(originalIndex);\n                    boolean originalElementIsChild = originalElement instanceof ChildTextElement;\n                    boolean originalElementIsToken = originalElement instanceof TokenTextElement;\n                    if (diffElement.isKept()) {\n                        applyKeptDiffElement((Kept) diffElement, originalElement, originalElementIsChild, originalElementIsToken);\n                    } else if (diffElement.isRemoved()) {\n                        Removed removed = (Removed) diffElement;\n                        applyRemovedDiffElement(removedGroups.get(removed), removed, originalElement, originalElementIsChild, originalElementIsToken);\n                    } else {\n                        throw new UnsupportedOperationException(\"\" + diffElement + \" vs \" + originalElement);\n                    }\n                }\n            }\n        } while (diffIndex < diffElements.size() || originalIndex < originalElements.size());\n    }\n\n    private boolean applyLeftOverOriginalElements() {\n        boolean isLeftOverElement = false;\n        if (diffIndex >= diffElements.size() && originalIndex < originalElements.size()) {\n            TextElement originalElement = originalElements.get(originalIndex);\n            if (originalElement.isWhiteSpaceOrComment()) {\n                originalIndex++;\n            } else {\n                throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \" + this + \" \" + originalElement);\n            }\n            isLeftOverElement = true;\n        }\n        return isLeftOverElement;\n    }\n\n    private boolean applyLeftOverDiffElements() {\n        boolean isLeftOverElement = false;\n        if (diffIndex < diffElements.size() && originalIndex >= originalElements.size()) {\n            DifferenceElement diffElement = diffElements.get(diffIndex);\n            if (diffElement.isKept()) {\n                diffIndex++;\n            } else if (diffElement.isAdded()) {\n                Added addedElement = (Added) diffElement;\n                nodeText.addElement(originalIndex, addedElement.toTextElement());\n                originalIndex++;\n                diffIndex++;\n            } else {\n                // let's forget this element\n                diffIndex++;\n            }\n            isLeftOverElement = true;\n        }\n        return isLeftOverElement;\n    }\n\n    private void extractReshuffledDiffElements(List<DifferenceElement> diffElements) {\n        for (int index = 0; index < diffElements.size(); index++) {\n            DifferenceElement diffElement = diffElements.get(index);\n            if (diffElement instanceof Reshuffled) {\n                Reshuffled reshuffled = (Reshuffled) diffElement;\n                // First, let's see how many tokens we need to attribute to the previous version of the of the CsmMix\n                CsmMix elementsFromPreviousOrder = reshuffled.getPreviousOrder();\n                CsmMix elementsFromNextOrder = reshuffled.getNextOrder();\n                // This contains indexes from elementsFromNextOrder to indexes from elementsFromPreviousOrder\n                Map<Integer, Integer> correspondanceBetweenNextOrderAndPreviousOrder = getCorrespondanceBetweenNextOrderAndPreviousOrder(elementsFromPreviousOrder, elementsFromNextOrder);\n                // We now find out which Node Text elements corresponds to the elements in the original CSM\n                List<Integer> nodeTextIndexOfPreviousElements = findIndexOfCorrespondingNodeTextElement(elementsFromPreviousOrder.getElements(), nodeText, originalIndex, node);\n                Map<Integer, Integer> nodeTextIndexToPreviousCSMIndex = new HashMap<>();\n                for (int i = 0; i < nodeTextIndexOfPreviousElements.size(); i++) {\n                    int value = nodeTextIndexOfPreviousElements.get(i);\n                    if (value != -1) {\n                        nodeTextIndexToPreviousCSMIndex.put(value, i);\n                    }\n                }\n                int lastNodeTextIndex = nodeTextIndexOfPreviousElements.stream().max(Integer::compareTo).orElse(-1);\n                // Elements to be added at the end\n                List<CsmElement> elementsToBeAddedAtTheEnd = new LinkedList<>();\n                List<CsmElement> nextOrderElements = elementsFromNextOrder.getElements();\n                Map<Integer, List<CsmElement>> elementsToAddBeforeGivenOriginalCSMElement = new HashMap<>();\n                for (int ni = 0; ni < nextOrderElements.size(); ni++) {\n                    // If it has a mapping, then it is kept\n                    if (!correspondanceBetweenNextOrderAndPreviousOrder.containsKey(ni)) {\n                        // Ok, it is something new. Where to put it? Let's see what is the first following\n                        // element that has a mapping\n                        int originalCsmIndex = -1;\n                        for (int nj = ni + 1; nj < nextOrderElements.size() && originalCsmIndex == -1; nj++) {\n                            if (correspondanceBetweenNextOrderAndPreviousOrder.containsKey(nj)) {\n                                originalCsmIndex = correspondanceBetweenNextOrderAndPreviousOrder.get(nj);\n                                if (!elementsToAddBeforeGivenOriginalCSMElement.containsKey(originalCsmIndex)) {\n                                    elementsToAddBeforeGivenOriginalCSMElement.put(originalCsmIndex, new LinkedList<>());\n                                }\n                                elementsToAddBeforeGivenOriginalCSMElement.get(originalCsmIndex).add(nextOrderElements.get(ni));\n                            }\n                        }\n                        // it does not preceed anything, so it goes at the end\n                        if (originalCsmIndex == -1) {\n                            elementsToBeAddedAtTheEnd.add(nextOrderElements.get(ni));\n                        }\n                    }\n                }\n                // We go over the original node text elements, in the order they appear in the NodeText.\n                // Considering an original node text element (ONE)\n                // * we verify if it corresponds to a CSM element. If it does not we just move on, otherwise\n                // we find the correspond OCE (Original CSM Element)\n                // * we first add new elements that are marked to be added before OCE\n                // * if OCE is marked to be present also in the \"after\" CSM we add a kept element,\n                // otherwise we add a removed element\n                // Remove the whole Reshuffled element\n                diffElements.remove(index);\n                int diffElIterator = index;\n                if (lastNodeTextIndex != -1) {\n                    for (int ntIndex = originalIndex; ntIndex <= lastNodeTextIndex; ntIndex++) {\n                        if (nodeTextIndexToPreviousCSMIndex.containsKey(ntIndex)) {\n                            int indexOfOriginalCSMElement = nodeTextIndexToPreviousCSMIndex.get(ntIndex);\n                            if (elementsToAddBeforeGivenOriginalCSMElement.containsKey(indexOfOriginalCSMElement)) {\n                                for (CsmElement elementToAdd : elementsToAddBeforeGivenOriginalCSMElement.get(indexOfOriginalCSMElement)) {\n                                    diffElements.add(diffElIterator++, new Added(elementToAdd));\n                                }\n                            }\n                            CsmElement originalCSMElement = elementsFromPreviousOrder.getElements().get(indexOfOriginalCSMElement);\n                            boolean toBeKept = correspondanceBetweenNextOrderAndPreviousOrder.containsValue(indexOfOriginalCSMElement);\n                            if (toBeKept) {\n                                diffElements.add(diffElIterator++, new Kept(originalCSMElement));\n                            } else {\n                                diffElements.add(diffElIterator++, new Removed(originalCSMElement));\n                            }\n                        }\n                        // else we have a simple node text element, without associated csm element, just keep ignore it\n                    }\n                }\n                // Finally we look for the remaining new elements that were not yet added and\n                // add all of them\n                for (CsmElement elementToAdd : elementsToBeAddedAtTheEnd) {\n                    diffElements.add(diffElIterator++, new Added(elementToAdd));\n                }\n            }\n        }\n    }\n\n    /**\n     * Maps all Removed elements as keys to their corresponding RemovedGroup.\n     * A RemovedGroup contains all consecutive Removed elements.\n     * <br>\n     * Example:\n     * <pre>\n     * Elements: Kept|Removed1|Removed2|Kept|Removed3|Added|Removed4\n     * Groups:        <----Group1---->       Group2         Group3\n     * Keys:          Removed1+Removed2      Removed3       Removed4\n     * </pre>\n     *\n     * @return Map with all Removed elements as keys to their corresponding RemovedGroup\n     */\n    private Map<Removed, RemovedGroup> combineRemovedElementsToRemovedGroups() {\n        Map<Integer, List<Removed>> removedElementsMap = groupConsecutiveRemovedElements();\n        List<RemovedGroup> removedGroups = new ArrayList<>();\n        for (Map.Entry<Integer, List<Removed>> entry : removedElementsMap.entrySet()) {\n            removedGroups.add(RemovedGroup.of(entry.getKey(), entry.getValue()));\n        }\n        Map<Removed, RemovedGroup> map = new HashMap<>();\n        for (RemovedGroup removedGroup : removedGroups) {\n            for (Removed index : removedGroup) {\n                map.put(index, removedGroup);\n            }\n        }\n        return map;\n    }\n\n    private Map<Integer, List<Removed>> groupConsecutiveRemovedElements() {\n        Map<Integer, List<Removed>> removedElementsMap = new HashMap<>();\n        Integer firstElement = null;\n        for (int i = 0; i < diffElements.size(); i++) {\n            DifferenceElement diffElement = diffElements.get(i);\n            if (diffElement.isRemoved()) {\n                if (firstElement == null) {\n                    firstElement = i;\n                }\n                removedElementsMap.computeIfAbsent(firstElement, key -> new ArrayList<>()).add((Removed) diffElement);\n            } else {\n                firstElement = null;\n            }\n        }\n        return removedElementsMap;\n    }\n\n    private void applyRemovedDiffElement(RemovedGroup removedGroup, Removed removed, TextElement originalElement, boolean originalElementIsChild, boolean originalElementIsToken) {\n        if (removed.isChild() && originalElementIsChild) {\n            ChildTextElement originalElementChild = (ChildTextElement) originalElement;\n            if (originalElementChild.isComment()) {\n                // We expected to remove a proper node but we found a comment in between.\n                // If the comment is associated to the node we want to remove we remove it as well, otherwise we keep it\n                Comment comment = (Comment) originalElementChild.getChild();\n                if (!comment.isOrphan() && comment.getCommentedNode().isPresent() && comment.getCommentedNode().get().equals(removed.getChild())) {\n                    nodeText.removeElement(originalIndex);\n                } else {\n                    originalIndex++;\n                }\n            } else {\n                nodeText.removeElement(originalIndex);\n                // When we don't try to remove a complete line\n                // and removing the element is not the first action of a replacement (removal followed by addition)\n                // (in the latter case we keep the indentation)\n                // then we want to enforce the indentation.\n                if (isEnforcingIndentationActivable(removedGroup)) {\n                \t// Since the element has been deleted we try to start the analysis from the element following the one that was deleted\n                    originalIndex = considerEnforcingIndentation(nodeText, originalIndex);\n                }\n                // If in front we have one space and before also we had space let's drop one space\n                if (originalElements.size() > originalIndex && originalIndex > 0) {\n                    if (originalElements.get(originalIndex).isWhiteSpace() && originalElements.get(originalIndex - 1).isWhiteSpace()) {\n                        // However we do not want to do that when we are about to adding or removing elements\n                        // The intention is not very clear maybe it should clarify this with examples!\n                        // Are we to understand that we can only do this if there is a single modification to process\n                        // OR or if the next change is to keep the element\n                        if ((diffIndex + 1) == diffElements.size() || (diffElements.get(diffIndex + 1).isKept())) {\n                            originalElements.remove(originalIndex--);\n                        }\n                    }\n                }\n                // We need to know if, in the original list of elements, the deleted child node is immediately followed by the same comment.\n                // If so, it should also be deleted.\n                if (isFollowedByComment(originalIndex, originalElements) ) {\n                \tint indexOfNextComment = posOfNextComment(originalIndex, originalElements);\n                \tremoveElements(originalIndex, indexOfNextComment, originalElements);\n                }\n                if (isRemovingIndentationActivable(removedGroup)) {\n                \t// Since the element has been deleted we try to start the analysis from the previous element\n                    originalIndex = considerRemovingIndentation(nodeText, originalIndex);\n                }\n                diffIndex++;\n            }\n        } else if (removed.isChild() && originalElement.isComment()) {\n        \t// removing the comment first\n        \tnodeText.removeElement(originalIndex);\n        \tif (isRemovingIndentationActivable(removedGroup)) {\n                originalIndex = considerRemovingIndentation(nodeText, originalIndex);\n            }\n        } else if (removed.isToken() && originalElementIsToken && (removed.getTokenType() == ((TokenTextElement) originalElement).getTokenKind() || // handle EOLs separately as their token kind might not be equal. This is because the 'removed'\n        // element always has the current operating system's EOL as type\n        (((TokenTextElement) originalElement).getToken().getCategory().isEndOfLine() && removed.isNewLine()))) {\n            nodeText.removeElement(originalIndex);\n            diffIndex++;\n        } else if ((removed.isWhiteSpaceNotEol() || removed.getElement() instanceof CsmIndent || removed.getElement() instanceof CsmUnindent)\n        \t\t&& originalElement.isSpaceOrTab()){\n        \t// remove the current space\n        \tnodeText.removeElement(originalIndex);\n        }else if (originalElementIsToken && originalElement.isWhiteSpaceOrComment()) {\n            originalIndex++;\n            // skip the newline token which may be generated unnecessarily by the concrete syntax pattern\n            if (removed.isNewLine()) {\n            \tdiffIndex++;\n            }\n        } else if (originalElement.isLiteral()) {\n            nodeText.removeElement(originalIndex);\n            diffIndex++;\n        } else if (removed.isPrimitiveType()) {\n            if (originalElement.isPrimitive()) {\n                nodeText.removeElement(originalIndex);\n                diffIndex++;\n            } else {\n                throw new UnsupportedOperationException(\"removed \" + removed.getElement() + \" vs \" + originalElement);\n            }\n        } else if (removed.isWhiteSpace() || removed.getElement() instanceof CsmIndent || removed.getElement() instanceof CsmUnindent) {\n            diffIndex++;\n        } else if (originalElement.isWhiteSpace()) {\n            originalIndex++;\n        } else if (removed.isChild()) {\n            // see issue #3721 this case is linked for example to a change of type of variable declarator\n            nodeText.removeElement(originalIndex);\n            diffIndex++;\n        } else {\n            throw new UnsupportedOperationException(\"removed \" + removed.getElement() + \" vs \" + originalElement);\n        }\n        cleanTheLineOfLeftOverSpace(removedGroup, removed);\n    }\n\n    /**\n     * Cleans the line of left over space if there is unnecessary indentation and the element will not be replaced\n     */\n    private void cleanTheLineOfLeftOverSpace(RemovedGroup removedGroup, Removed removed) {\n        if (originalIndex >= originalElements.size()) {\n            // if all elements were already processed there is nothing to do\n            return;\n        }\n        // we dont want to remove the indentation if the last removed element is a newline\n        // because in this case we are trying to remove the indentation of the next child element\n        if (!removedGroup.isProcessed()\n        \t\t&& removedGroup.isLastElement(removed)\n        \t\t&& removedGroup.isACompleteLine()\n        \t\t&& !removed.isNewLine()) {\n            Integer lastElementIndex = removedGroup.getLastElementIndex();\n            Optional<Integer> indentation = removedGroup.getIndentation();\n            if (indentation.isPresent() && !isReplaced(lastElementIndex)) {\n                for (int i = 0; i < indentation.get(); i++) {\n                    if (originalElements.get(originalIndex).isSpaceOrTab()) {\n                        // If the current element is a space, remove it\n                        nodeText.removeElement(originalIndex);\n                    } else if (originalIndex >= 1 && originalElements.get(originalIndex - 1).isSpaceOrTab()) {\n                        // If the current element is not a space itself we remove the space in front of (before) it\n                        nodeText.removeElement(originalIndex - 1);\n                        originalIndex--;\n                    }\n                    // Remove remaining newline character if needed\n                    if (nodeText.getTextElement(originalIndex).isNewline()) {\n                    \tnodeText.removeElement(originalIndex);\n                    \toriginalIndex = originalIndex > 0 ? originalIndex-- : 0;\n                    }\n                }\n            }\n            // Mark RemovedGroup as processed\n            removedGroup.processed();\n        }\n    }\n\n    // note:\n    // increment originalIndex if we want to keep the original element\n    // increment diffIndex if we want to skip the diff element\n    private void applyKeptDiffElement(Kept kept, TextElement originalElement, boolean originalElementIsChild, boolean originalElementIsToken) {\n\t\tif (originalElement.isComment()) {\n\t\t\toriginalIndex++;\n        } else if (kept.isChild() && ((CsmChild) kept.getElement()).getChild() instanceof Comment) {\n            diffIndex++;\n        } else if (kept.isChild() && originalElementIsChild) {\n            diffIndex++;\n            originalIndex++;\n        } else if (kept.isChild() && originalElementIsToken) {\n            if (originalElement.isWhiteSpaceOrComment()) {\n                originalIndex++;\n            } else if (originalElement.isIdentifier() && isNodeWithTypeArguments(kept)) {\n                diffIndex++;\n                // skip all token related to node with type argument declaration\n                // for example:\n                // List i : in this case originalElement is \"List\" and the next token is space. There is nothing to skip. in the originalElements list.\n                // List<String> i : in this case originalElement is \"List\" and the next token is\n                // \"<\" so we have to skip all the tokens which are used in the typed argument declaration [<][String][>](3 tokens) in the originalElements list.\n                // List<List<String>> i : in this case originalElement is \"List\" and the next\n                // token is \"<\" so we have to skip all the tokens which are used in the typed arguments declaration [<][List][<][String][>][>](6 tokens) in the originalElements list.\n                int step = getIndexToNextTokenElement((TokenTextElement) originalElement, 0);\n                originalIndex += step;\n                originalIndex++;\n            } else if (originalElement.isIdentifier() && isTypeWithFullyQualifiedName(kept)) {\n                diffIndex++;\n                // skip all token related to node with the fully qualified name\n                // for example:\n                // java.lang.Object is represented in originalElement as a list of tokens \"java\", \".\", \"lang\", \".\", \"Object\".\n                // So we have to skip 5 tokens.\n                int step = getIndexToNextTokenElement((TokenTextElement) originalElement, kept);\n                originalIndex += step;\n                // positioning on the next token\n                originalIndex++;\n            } else if ((originalElement.isIdentifier() || originalElement.isKeyword()) && isArrayType(kept)) {\n                int tokenToSkip = getIndexToNextTokenElementInArrayType((TokenTextElement) originalElement, getArrayLevel(kept));\n                diffIndex++;\n                originalIndex += tokenToSkip;\n                originalIndex++;\n            } else if (originalElement.isIdentifier()) {\n                originalIndex++;\n                diffIndex++;\n            } else {\n                if (kept.isPrimitiveType()) {\n                    originalIndex++;\n                    diffIndex++;\n                } else {\n                    throw new UnsupportedOperationException(\"kept \" + kept.getElement() + \" vs \" + originalElement);\n                }\n            }\n        } else if (kept.isToken() && originalElementIsToken) {\n            TokenTextElement originalTextToken = (TokenTextElement) originalElement;\n            if (kept.getTokenType() == originalTextToken.getTokenKind()) {\n                originalIndex++;\n                diffIndex++;\n            } else if (kept.isNewLine() && originalTextToken.isNewline()) {\n                originalIndex++;\n                diffIndex++;\n            } else if (kept.isNewLine() && originalTextToken.isSpaceOrTab()) {\n                originalIndex++;\n            } else if (kept.isWhiteSpaceOrComment()) {\n                diffIndex++;\n            } else if (originalTextToken.isWhiteSpaceOrComment()) {\n                originalIndex++;\n            } else if (!kept.isNewLine() && originalTextToken.isSeparator()) {\n                // case where originalTextToken is a separator like \";\" and\n                // kept is not a new line or whitespace for example \"}\"\n                // see issue 2351\n                originalIndex++;\n            } else {\n                throw new UnsupportedOperationException(\"Csm token \" + kept.getElement() + \" NodeText TOKEN \" + originalTextToken);\n            }\n        } else if (kept.isToken() && originalElementIsChild) {\n            diffIndex++;\n        } else if (kept.isWhiteSpace()) {\n            diffIndex++;\n        } else if (kept.isIndent()) {\n            diffIndex++;\n        } else if (kept.isUnindent()) {\n            // Nothing to do\n            diffIndex++;\n        } else {\n            throw new UnsupportedOperationException(\"kept \" + kept.getElement() + \" vs \" + originalElement);\n        }\n    }\n\n    /*\n     * Returns the array level if the DifferenceElement is a CsmChild representing an ArrayType else 0\n     */\n    private int getArrayLevel(DifferenceElement element) {\n        CsmElement csmElem = element.getElement();\n        if (isArrayType(element)) {\n            Node child = ((LexicalDifferenceCalculator.CsmChild) csmElem).getChild();\n            return ((ArrayType) child).getArrayLevel();\n        }\n        return 0;\n    }\n\n    /*\n     * Returns true if the DifferenceElement is a CsmChild representing an ArrayType\n     */\n    private boolean isArrayType(DifferenceElement element) {\n        CsmElement csmElem = element.getElement();\n        return csmElem instanceof LexicalDifferenceCalculator.CsmChild && ((LexicalDifferenceCalculator.CsmChild) csmElem).getChild() instanceof ArrayType;\n    }\n\n    /*\n     * Returns true if the DifferenceElement is a CsmChild which represents a type with fully qualified name\n     */\n    private boolean isTypeWithFullyQualifiedName(DifferenceElement element) {\n        if (!element.isChild())\n            return false;\n        CsmChild child = (CsmChild) element.getElement();\n        if (!ClassOrInterfaceType.class.isAssignableFrom(child.getChild().getClass()))\n            return false;\n        return ((ClassOrInterfaceType) child.getChild()).getScope().isPresent();\n    }\n\n    /*\n     * Returns true if the DifferenceElement is a CsmChild with type arguments\n     */\n    private boolean isNodeWithTypeArguments(DifferenceElement element) {\n        if (!element.isChild())\n            return false;\n        CsmChild child = (CsmChild) element.getElement();\n        if (!NodeWithTypeArguments.class.isAssignableFrom(child.getChild().getClass()))\n            return false;\n        Optional<NodeList<Type>> typeArgs = ((NodeWithTypeArguments) child.getChild()).getTypeArguments();\n        return typeArgs.isPresent() && typeArgs.get().size() > 0;\n    }\n\n    /*\n     * Try to resolve the number of token to skip in the original list to match\n     * a ClassOrInterfaceType with a list of tokens like \"java\", \".\", \"lang\", \".\", \"Object\"\n     */\n    private int getIndexToNextTokenElement(TokenTextElement element, DifferenceElement kept) {\n        // number of token to skip\n        int step = 0;\n        // verify if the DifferenceElement is a ClassOrInterfaceType with a fully qualified name\n        if (!isTypeWithFullyQualifiedName(kept))\n            return 0;\n        CsmChild child = (CsmChild) kept.getElement();\n        // split the type fully qualified node name to an array of tokens\n        String[] parts = ((ClassOrInterfaceType) child.getChild()).getNameWithScope().split(\"\\\\.\");\n        JavaToken token = element.getToken();\n        for (String part : parts) {\n            if (part.equals(token.asString())) {\n                // get 'dot' token\n                token = token.getNextToken().get();\n                if (!token.asString().equals(\".\"))\n                    break;\n                // get the next part\n                token = token.getNextToken().get();\n                step += 2;\n                continue;\n            }\n            // there is no match so we don't have token to skip\n            step = 0;\n            break;\n        }\n        return step;\n    }\n\n    /*\n     * Returns the number of tokens to skip in originalElements list to synchronize it with the DiffElements list\n     * This is due to the fact that types are considered as token in the originalElements list.\n     * For example,\n     * List<String> is represented by 4 tokens ([List][<][String][>]) while it's a CsmChild element in the DiffElements list\n     * So in this case, getIndexToNextTokenElement(..) on the [List] token returns 3 because we have to skip 3 tokens ([<][String][>]) to synchronize\n     * DiffElements list and originalElements list\n     * The end of recursivity is reached when there is no next token or if the nested diamond operators are totally managed, to take into account this type of declaration\n     * List <List<String>> l\n     * Be careful, this method must be call only if diamond operator could be found in the sequence\n     *\n     * @Param TokenTextElement the token currently analyzed\n     * @Param int the number of nested diamond operators\n     * @return the number of token to skip in originalElements list\n     */\n    private int getIndexToNextTokenElement(TokenTextElement element, int nestedDiamondOperator) {\n        // number of token to skip\n        int step = 0;\n        Optional<JavaToken> next = element.getToken().getNextToken();\n        if (!next.isPresent())\n            return step;\n        // because there is a token, first we need to increment the number of token to skip\n        step++;\n        // manage nested diamond operators by incrementing the level on LT token and decrementing on GT\n        JavaToken nextToken = next.get();\n        Kind kind = Kind.valueOf(nextToken.getKind());\n        if (isDiamondOperator(kind)) {\n            if (kind.GT.equals(kind))\n                nestedDiamondOperator--;\n            else\n                nestedDiamondOperator++;\n        }\n        // manage the fact where the first token is not a diamond operator but a whitespace\n        // and the end of the token sequence to skip\n        // for example in this declaration List <String> a;\n        if (nestedDiamondOperator == 0 && !nextToken.getCategory().isWhitespace())\n            return step;\n        // recursively analyze token to skip\n        return step += getIndexToNextTokenElement(new TokenTextElement(nextToken), nestedDiamondOperator);\n    }\n\n    /*\n     * Returns the number of tokens to skip in originalElements list to synchronize it with the DiffElements list\n     */\n    private int getIndexToNextTokenElementInArrayType(TokenTextElement element, int arrayLevel) {\n        // number of token to skip\n        int step = 0;\n        Optional<JavaToken> next = element.getToken().getNextToken();\n        if (!next.isPresent())\n            return step;\n        // because there is a token, first we need to increment the number of token to skip\n        step++;\n        // manage array Level by decrementing the level on right bracket token\n        JavaToken nextToken = next.get();\n        Kind kind = Kind.valueOf(nextToken.getKind());\n        if (isBracket(kind)) {\n            if (kind.RBRACKET.equals(kind))\n                arrayLevel--;\n        }\n        // manage the fact where the first token is not a diamond operator but a whitespace\n        // and the end of the token sequence to skip\n        // for example in this declaration int [] a;\n        if (arrayLevel == 0 && !nextToken.getCategory().isWhitespace())\n            return step;\n        // recursively analyze token to skip\n        return step += getIndexToNextTokenElementInArrayType(new TokenTextElement(nextToken), arrayLevel);\n    }\n\n    /*\n     * Returns true if the token is possibly a diamond operator\n     */\n    private boolean isDiamondOperator(Kind kind) {\n        return kind.GT.equals(kind) || kind.LT.equals(kind);\n    }\n\n    /*\n     * Returns true if the token is a bracket\n     */\n    private boolean isBracket(Kind kind) {\n        return kind.LBRACKET.equals(kind) || kind.RBRACKET.equals(kind);\n    }\n\n    private boolean openBraceWasOnSameLine() {\n        int index = originalIndex;\n        while (index >= 0 && !nodeText.getTextElement(index).isNewline()) {\n            if (nodeText.getTextElement(index).isToken(LBRACE)) {\n                return true;\n            }\n            index--;\n        }\n        return false;\n    }\n\n    private boolean wasSpaceBetweenBraces() {\n        return nodeText.getTextElement(originalIndex).isToken(RBRACE) && doWeHaveLeftBraceFollowedBySpace(originalIndex - 1) && (diffIndex < 2 || !diffElements.get(diffIndex - 2).isRemoved());\n    }\n\n    private boolean doWeHaveLeftBraceFollowedBySpace(int index) {\n        index = rewindSpace(index);\n        return nodeText.getTextElement(index).isToken(LBRACE);\n    }\n\n    private int rewindSpace(int index) {\n        if (index <= 0) {\n            return index;\n        }\n        if (nodeText.getTextElement(index).isWhiteSpace()) {\n            return rewindSpace(index - 1);\n        } else {\n            return index;\n        }\n    }\n\n    private boolean nextIsRightBrace(int index) {\n        List<TextElement> elements = originalElements.subList(index, originalElements.size());\n        for (TextElement element : elements) {\n            if (!element.isSpaceOrTab()) {\n                return element.isToken(RBRACE);\n            }\n        }\n        return false;\n    }\n\n    private void applyAddedDiffElement(Added added) {\n        if (added.isIndent()) {\n            for (int i = 0; i < STANDARD_INDENTATION_SIZE; i++) {\n                indentation.add(new TokenTextElement(GeneratedJavaParserConstants.SPACE));\n            }\n            addedIndentation = true;\n            diffIndex++;\n            return;\n        }\n        if (added.isUnindent()) {\n            for (int i = 0; i < STANDARD_INDENTATION_SIZE && !indentation.isEmpty(); i++) {\n                indentation.remove(indentation.size() - 1);\n            }\n            addedIndentation = false;\n            diffIndex++;\n            return;\n        }\n        TextElement addedTextElement = added.toTextElement();\n        boolean used = false;\n        boolean isPreviousElementNewline = (originalIndex > 0) && originalElements.get(originalIndex - 1).isNewline();\n        if (isPreviousElementNewline) {\n            List<TextElement> elements = processIndentation(indentation, originalElements.subList(0, originalIndex - 1));\n            boolean nextIsRightBrace = nextIsRightBrace(originalIndex);\n            for (TextElement e : elements) {\n                if (!nextIsRightBrace && e instanceof TokenTextElement && originalElements.get(originalIndex).isToken(((TokenTextElement) e).getTokenKind())) {\n                    originalIndex++;\n                } else {\n                    nodeText.addElement(originalIndex++, e);\n                }\n            }\n        } else if (isAfterLBrace(nodeText, originalIndex) && !isAReplacement(diffIndex)) {\n            if (addedTextElement.isNewline()) {\n                used = true;\n            }\n            nodeText.addElement(originalIndex++, new TokenTextElement(TokenTypes.eolTokenKind()));\n            // This remove the space in \"{ }\" when adding a new line\n            while (originalIndex >= 2 && originalElements.get(originalIndex - 2).isSpaceOrTab()) {\n                originalElements.remove(originalIndex - 2);\n                originalIndex--;\n            }\n            for (TextElement e : processIndentation(indentation, originalElements.subList(0, originalIndex - 1))) {\n                nodeText.addElement(originalIndex++, e);\n            }\n            // Indentation is painful...\n            // Sometimes we want to force indentation: this is the case when indentation was expected but\n            // was actually not there. For example if we have \"{ }\" we would expect indentation but it is\n            // not there, so when adding new elements we force it. However if the indentation has been\n            // inserted by us in this transformation we do not want to insert it again\n            if (!addedIndentation) {\n                for (TextElement e : indentationBlock()) {\n                    nodeText.addElement(originalIndex++, e);\n                }\n            }\n        }\n        if (!used) {\n            // Handling trailing comments\n            boolean sufficientTokensRemainToSkip = nodeText.numberOfElements() > originalIndex + 2;\n            boolean currentIsAComment = nodeText.getTextElement(originalIndex).isComment();\n            boolean previousIsAComment = originalIndex > 0 && nodeText.getTextElement(originalIndex - 1).isComment();\n            boolean currentIsNewline = nodeText.getTextElement(originalIndex).isNewline();\n            boolean isFirstElement = originalIndex == 0;\n            boolean previousIsWhiteSpace = originalIndex > 0 && nodeText.getTextElement(originalIndex - 1).isWhiteSpace();\n\t\t\tboolean commentIsBeforeAddedElement = currentIsAComment && addedTextElement.getRange().isPresent()\n\t\t\t\t\t&& nodeText.getTextElement(originalIndex).getRange()\n\t\t\t\t\t\t\t.map(range -> range.isBefore(addedTextElement.getRange().get())).orElse(false);\n            if (sufficientTokensRemainToSkip && currentIsAComment && commentIsBeforeAddedElement) {\n                // Need to get behind the comment:\n                // FIXME: Why 2? This comment and the next newline?\n                originalIndex += 2;\n                // Defer originalIndex increment\n                nodeText.addElement(originalIndex, addedTextElement);\n                // We want to adjust the indentation while considering the new element that we added\n                originalIndex = adjustIndentation(indentation, nodeText, originalIndex, false);\n                // Now we can increment\n                originalIndex++;\n            } else if (currentIsNewline && previousIsAComment) {\n                /*\n                 * Manage the case where we want to add an element, after an expression which is followed by a comment on the same line.\n                 * This is not the same case as the one who handles the trailing comments, because in this case the node text element is a new line (not a comment)\n                 * For example : {@code private String a; // this is a }\n                 */\n                // Insert after the new line which follows this comment.\n                originalIndex++;\n                // We want to adjust the indentation while considering the new element that we added\n                originalIndex = adjustIndentation(indentation, nodeText, originalIndex, false);\n                // Defer originalIndex increment\n                nodeText.addElement(originalIndex, addedTextElement);\n                // Now we can increment.\n                originalIndex++;\n            } else if (currentIsNewline && addedTextElement.isChild()) {\n                // here we want to place the new child element after the current new line character.\n                // Except if indentation has been inserted just before this step (in the case where isPreviousElementNewline is true)\n                // or if the previous character is a space (it could be the case if we want to replace a statement)\n                // Example 1 : if we insert a statement (a duplicated method call expression ) after this one <code>  value();\\n\\n</code>\n                // we want to have this result <code>  value();\\n  value();\\n</code> not <code>  value();\\n  \\nvalue();</code>\n                // Example 2 : if we want to insert a statement after this one <code>  \\n</code> we want to have <code>  value();\\n</code>\n                // not <code>  \\nvalue();</code> --> this case appears on member replacement for example\n                if (!isPreviousElementNewline && !isFirstElement && !previousIsWhiteSpace) {\n                    // Insert after the new line\n                    originalIndex++;\n                }\n                nodeText.addElement(originalIndex, addedTextElement);\n                originalIndex++;\n            } else {\n                nodeText.addElement(originalIndex, addedTextElement);\n                originalIndex++;\n            }\n        }\n        if (addedTextElement.isNewline()) {\n            boolean followedByUnindent = isFollowedByUnindent(diffElements, diffIndex);\n            boolean nextIsRightBrace = nextIsRightBrace(originalIndex);\n            boolean nextIsNewLine = originalElements.get(originalIndex).isNewline();\n            if ((!nextIsNewLine && !nextIsRightBrace) || followedByUnindent) {\n                originalIndex = adjustIndentation(indentation, nodeText, originalIndex, followedByUnindent);\n            }\n        }\n        diffIndex++;\n    }\n\n    private String tokenDescription(int kind) {\n        return GeneratedJavaParserConstants.tokenImage[kind];\n    }\n\n\t/*\n\t * Considering that the lists of elements are ordered, We can find the common\n\t * elements by starting with the list before the modifications and, for each\n\t * element, by going through the list of elements containing the modifications.\n\t *\n\t * We can find the common elements by starting with the list before the\n\t * modifications (L1) and, for each element, by going through the list of elements\n\t * containing the modifications (L2).\n\t *\n\t * If element A in list L1 is not found in list L2, it is a deleted element.\n\t * If element A of list L1 is found in list L2, it is a kept element. In this\n\t * case the search for the next element of the list L1 must start from the\n\t * position of the last element kept {@code syncNextIndex}.\n\t */\n\tprivate Map<Integer, Integer> getCorrespondanceBetweenNextOrderAndPreviousOrder(CsmMix elementsFromPreviousOrder,\n\t\t\tCsmMix elementsFromNextOrder) {\n\t\tMap<Integer, Integer> correspondanceBetweenNextOrderAndPreviousOrder = new HashMap<>();\n\t\tReadOnlyListIterator<CsmElement> previousOrderElementsIterator = new ReadOnlyListIterator(\n\t\t\t\telementsFromPreviousOrder.getElements());\n\t\tint syncNextIndex = 0;\n\t\twhile (previousOrderElementsIterator.hasNext()) {\n\t\t\tCsmElement pe = previousOrderElementsIterator.next();\n\t\t\tReadOnlyListIterator<CsmElement> nextOrderElementsIterator = new ReadOnlyListIterator(\n\t\t\t\t\telementsFromNextOrder.getElements(), syncNextIndex);\n\t\t\twhile (nextOrderElementsIterator.hasNext()) {\n\t\t\t\tCsmElement ne = nextOrderElementsIterator.next();\n\t\t\t\tif (!correspondanceBetweenNextOrderAndPreviousOrder.values().contains(previousOrderElementsIterator.index())\n\t\t\t\t\t\t&& DifferenceElementCalculator.matching(ne, pe)) {\n\t\t\t\t\tcorrespondanceBetweenNextOrderAndPreviousOrder.put(nextOrderElementsIterator.index(),\n\t\t\t\t\t\t\tpreviousOrderElementsIterator.index());\n\t\t\t\t\t// set the position to start on the next {@code nextOrderElementsIterator} iteration\n\t\t\t\t\tsyncNextIndex = nextOrderElementsIterator.index();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn correspondanceBetweenNextOrderAndPreviousOrder;\n\t}\n\n    /*\n     * A list iterator which does not allow to modify the list\n     * and which provides a method to know the current positioning\n     */\n    private class ReadOnlyListIterator<T> implements ListIterator<T> {\n    \tListIterator<T> elements;\n    \tpublic ReadOnlyListIterator(List<T> elements) {\n    \t\tthis(elements, 0);\n    \t}\n\n    \tpublic ReadOnlyListIterator(List<T> elements, int index) {\n    \t\tthis.elements = elements.listIterator(index);\n    \t}\n\n\t\t@Override\n\t\tpublic boolean hasNext() {\n\t\t\treturn elements.hasNext();\n\t\t}\n\n\t\t@Override\n\t\tpublic T next() {\n\t\t\treturn elements.next();\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean hasPrevious() {\n\t\t\treturn elements.hasPrevious();\n\t\t}\n\n\t\t@Override\n\t\tpublic T previous() {\n\t\t\treturn elements.previous();\n\t\t}\n\n\t\t@Override\n\t\tpublic int nextIndex() {\n\t\t\treturn elements.nextIndex();\n\t\t}\n\n\t\t@Override\n\t\tpublic int previousIndex() {\n\t\t\treturn elements.previousIndex();\n\t\t}\n\n\t\t/*\n\t\t * Returns the current index in the underlying list\n\t\t */\n\t\tpublic int index() {\n\t\t\treturn elements.nextIndex() - 1;\n\t\t}\n\n\t\t@Override\n\t\tpublic void remove() {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\n\t\t@Override\n\t\tpublic void set(T e) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\n\t\t@Override\n\t\tpublic void add(T e) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\n    }\n\n    /*\n     * Returns true if the next element in the list is an added element of type CsmUnindent\n     */\n    private boolean isFollowedByUnindent(List<DifferenceElement> diffElements, int diffIndex) {\n        int nextIndexValue = diffIndex + 1;\n        return (nextIndexValue) < diffElements.size() && diffElements.get(nextIndexValue).isAdded() && diffElements.get(nextIndexValue).getElement() instanceof CsmUnindent;\n    }\n\n    private List<Integer> findIndexOfCorrespondingNodeTextElement(List<CsmElement> elements, NodeText nodeText, int startIndex, Node node) {\n        List<Integer> correspondingIndices = new ArrayList<>();\n        for (ListIterator<CsmElement> csmElementListIterator = elements.listIterator(); csmElementListIterator.hasNext(); ) {\n            int previousCsmElementIndex = csmElementListIterator.previousIndex();\n            CsmElement csmElement = csmElementListIterator.next();\n            int nextCsmElementIndex = csmElementListIterator.nextIndex();\n            Map<MatchClassification, Integer> potentialMatches = new EnumMap<>(MatchClassification.class);\n            for (int i = startIndex; i < nodeText.numberOfElements(); i++) {\n                if (!correspondingIndices.contains(i)) {\n                    TextElement textElement = nodeText.getTextElement(i);\n                    boolean isCorresponding = isCorrespondingElement(textElement, csmElement, node);\n                    if (isCorresponding) {\n                        boolean hasSamePreviousElement = false;\n                        if (i > 0 && previousCsmElementIndex > -1) {\n                            TextElement previousTextElement = nodeText.getTextElement(i - 1);\n                            hasSamePreviousElement = isCorrespondingElement(previousTextElement, elements.get(previousCsmElementIndex), node);\n                        }\n                        boolean hasSameNextElement = false;\n                        if (i < nodeText.numberOfElements() - 1 && nextCsmElementIndex < elements.size()) {\n                            TextElement nextTextElement = nodeText.getTextElement(i + 1);\n                            hasSameNextElement = isCorrespondingElement(nextTextElement, elements.get(nextCsmElementIndex), node);\n                        }\n                        if (hasSamePreviousElement && hasSameNextElement) {\n                            potentialMatches.putIfAbsent(MatchClassification.ALL, i);\n                        } else if (hasSamePreviousElement) {\n                            potentialMatches.putIfAbsent(MatchClassification.PREVIOUS_AND_SAME, i);\n                        } else if (hasSameNextElement) {\n                            potentialMatches.putIfAbsent(MatchClassification.NEXT_AND_SAME, i);\n                        } else {\n                            potentialMatches.putIfAbsent(MatchClassification.SAME_ONLY, i);\n                        }\n                    } else if (isAlmostCorrespondingElement(textElement, csmElement, node)) {\n                        potentialMatches.putIfAbsent(MatchClassification.ALMOST, i);\n                    }\n                }\n            }\n            // Prioritize the matches from best to worst\n            Optional<MatchClassification> bestMatchKey = potentialMatches.keySet().stream().min(Comparator.comparing(MatchClassification::getPriority));\n            if (bestMatchKey.isPresent()) {\n                correspondingIndices.add(potentialMatches.get(bestMatchKey.get()));\n            } else {\n                correspondingIndices.add(-1);\n            }\n        }\n        return correspondingIndices;\n    }\n\n    private enum MatchClassification {\n\n        ALL(1), PREVIOUS_AND_SAME(2), NEXT_AND_SAME(3), SAME_ONLY(4), ALMOST(5);\n\n        private final int priority;\n\n        MatchClassification(int priority) {\n            this.priority = priority;\n        }\n\n        int getPriority() {\n            return priority;\n        }\n    }\n\n    private boolean isCorrespondingElement(TextElement textElement, CsmElement csmElement, Node node) {\n        if (csmElement instanceof CsmToken) {\n            CsmToken csmToken = (CsmToken) csmElement;\n            if (textElement instanceof TokenTextElement) {\n                TokenTextElement tokenTextElement = (TokenTextElement) textElement;\n                return tokenTextElement.getTokenKind() == csmToken.getTokenType() && tokenTextElement.getText().equals(csmToken.getContent(node));\n            }\n        } else if (csmElement instanceof CsmChild) {\n            CsmChild csmChild = (CsmChild) csmElement;\n            if (textElement instanceof ChildTextElement) {\n                ChildTextElement childTextElement = (ChildTextElement) textElement;\n                return childTextElement.getChild() == csmChild.getChild();\n            }\n        } else if (csmElement instanceof CsmIndent) {\n        \tCsmIndent csmIndent = (CsmIndent) csmElement;\n            if (textElement instanceof TokenTextElement) {\n            \tTokenTextElement tokenTextElement = (TokenTextElement) textElement;\n                return tokenTextElement.isSpaceOrTab();\n            }\n        } else {\n            throw new UnsupportedOperationException();\n        }\n        return false;\n    }\n\n    private boolean isAlmostCorrespondingElement(TextElement textElement, CsmElement csmElement, Node node) {\n        if (isCorrespondingElement(textElement, csmElement, node)) {\n            return false;\n        }\n        return textElement.isWhiteSpace() && csmElement instanceof CsmToken && ((CsmToken) csmElement).isWhiteSpace();\n    }\n\n    private int adjustIndentation(List<TextElement> indentation, NodeText nodeText, int nodeTextIndex, boolean followedByUnindent) {\n        List<TextElement> indentationAdj = processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1));\n        if (nodeTextIndex < nodeText.numberOfElements() && nodeText.getTextElement(nodeTextIndex).isToken(RBRACE)) {\n            indentationAdj = indentationAdj.subList(0, indentationAdj.size() - Math.min(STANDARD_INDENTATION_SIZE, indentationAdj.size()));\n        } else if (followedByUnindent) {\n            indentationAdj = indentationAdj.subList(0, Math.max(0, indentationAdj.size() - STANDARD_INDENTATION_SIZE));\n        }\n        for (TextElement e : indentationAdj) {\n            if ((nodeTextIndex < nodeText.numberOfElements()) && nodeText.getTextElement(nodeTextIndex).isSpaceOrTab()) {\n                nodeTextIndex++;\n            } else {\n                nodeText.getElements().add(nodeTextIndex++, e);\n            }\n        }\n        if (nodeTextIndex < 0) {\n            throw new IllegalStateException();\n        }\n        return nodeTextIndex;\n    }\n\n    /*\n     * Returns true if the current <code>Added</code> element is preceded by a <code>Removed</code> element.\n     */\n    private boolean isAReplacement(int diffIndex) {\n        return (diffIndex > 0) && diffElements.get(diffIndex).isAdded() && diffElements.get(diffIndex - 1).isRemoved();\n    }\n\n    /*\n     * Returns true if the current <code>Removed</code> element is followed by a <code>Added</code> element.\n     */\n    private boolean isReplaced(int diffIndex) {\n        return (diffIndex < diffElements.size() - 1) && diffElements.get(diffIndex + 1).isAdded() && diffElements.get(diffIndex).isRemoved();\n    }\n\n    @Override\n    public String toString() {\n        return \"Difference{\" + diffElements + '}';\n    }\n}\n",
        "diffSourceCodeSet": [
            "private boolean isSpaceOrTabElement(NodeText nodeText, int i) {\n\t\treturn nodeText.getTextElement(i).isSpaceOrTab();\n\t}"
        ],
        "invokedMethodSet": [],
        "sourceCodeAfterRefactoring": "/**\n     * Starting at {@code nodeTextIndex} this method tries to determine how many contiguous spaces there are between\n     * the previous end of line and the next non whitespace (or tab) character\n     * @param nodeText List of elements to analyze\n     * @param nodeTextIndex Starting position in the input list\n     * @return EnforcingIndentationContext Data structure that hold the starting position of the first whitespace char and\n     * The number of consecutive whitespace (or tab) characters\n     */\n    private EnforcingIndentationContext defineEnforcingIndentationContext(NodeText nodeText, int startIndex) {\n    \tEnforcingIndentationContext ctx = new EnforcingIndentationContext(startIndex);\n    \t// compute space before startIndex value\n\t\tif (startIndex < nodeText.numberOfElements() && startIndex > 0) {\n\t\t\t// at this stage startIndex points to the first element before the deleted one\n\t\t\tfor (int i = startIndex - 1; i >= 0 && i < nodeText.numberOfElements(); i--) {\n\t\t\t\tif (nodeText.getTextElement(i).isNewline()) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (!isSpaceOrTabElement(nodeText, i)) {\n\t\t\t\t\tctx = new EnforcingIndentationContext(startIndex);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tctx.start = i;\n\t\t\t\tctx.extraCharacters++;\n\t\t\t}\n\t\t}\n\t\t// compute space after the deleted element\n\t\tif (isSpaceOrTabElement(nodeText, startIndex)) {\n//\t\t\tint startingFromIndex = startIndex == 0 ? startIndex : startIndex + 1;\n\t\t\tfor (int i = startIndex; i >= 0 && i < nodeText.numberOfElements(); i++) {\n\t\t\t\tif (nodeText.getTextElement(i).isNewline()) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (!isSpaceOrTabElement(nodeText, i)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tctx.extraCharacters++;\n\t\t\t}\n\t\t}\n\n        return ctx;\n    }\nprivate boolean isSpaceOrTabElement(NodeText nodeText, int i) {\n\t\treturn nodeText.getTextElement(i).isSpaceOrTab();\n\t}",
        "diffSourceCode": "-  282:     /**\n-  283:      * Starting at {@code nodeTextIndex} this method tries to determine how many contiguous spaces there are between \n-  284:      * the previous end of line and the next non whitespace (or tab) character\n-  285:      * @param nodeText List of elements to analyze\n-  286:      * @param nodeTextIndex Starting position in the input list\n-  287:      * @return EnforcingIndentationContext Data structure that hold the starting position of the first whitespace char and\n-  288:      * The number of consecutive whitespace (or tab) characters\n-  289:      */\n-  290:     private EnforcingIndentationContext defineEnforcingIndentationContext(NodeText nodeText, int startIndex) {\n-  291:     \tEnforcingIndentationContext ctx = new EnforcingIndentationContext(startIndex);\n-  292:     \t// compute space before startIndex value\n-  293: \t\tif (startIndex < nodeText.numberOfElements() && startIndex > 0) {\n-  294: \t\t\t// at this stage startIndex points to the first element before the deleted one\n-  295: \t\t\tfor (int i = startIndex - 1; i >= 0 && i < nodeText.numberOfElements(); i--) {\n-  296: \t\t\t\tif (nodeText.getTextElement(i).isNewline()) {\n-  297: \t\t\t\t\tbreak;\n-  298: \t\t\t\t}\n-  299: \t\t\t\tif (!nodeText.getTextElement(i).isSpaceOrTab()) {\n-  300: \t\t\t\t\tctx = new EnforcingIndentationContext(startIndex);\n-  301: \t\t\t\t\tbreak;\n-  302: \t\t\t\t}\n-  303: \t\t\t\tctx.start = i;\n-  304: \t\t\t\tctx.extraCharacters++;\n-  305: \t\t\t}\n-  306: \t\t}\n-  307: \t\t// compute space after the deleted element\n-  308: \t\tif (nodeText.getTextElement(startIndex).isSpaceOrTab()) {\n-  309: \t\t\tfor (int i = startIndex; i >= 0 && i < nodeText.numberOfElements(); i++) {\n-  310: \t\t\t\tif (nodeText.getTextElement(i).isNewline()) {\n-  311: \t\t\t\t\tbreak;\n-  312: \t\t\t\t}\n-  313: \t\t\t\tif (!nodeText.getTextElement(i).isSpaceOrTab()) {\n-  314: \t\t\t\t\tbreak;\n-  315: \t\t\t\t}\n-  316: \t\t\t\tctx.extraCharacters++;\n-  317: \t\t\t}\n-  318: \t\t}\n-  319:         \n-  320:         return ctx;\n-  321:     }\n-  322: \n-  323:     /**\n-  324:      * Node that we have calculate the Difference we can apply to a concrete NodeText, modifying it according\n-  325:      * to the difference (adding and removing the elements provided).\n-  326:      */\n-  327:     void apply() {\n-  328:         extractReshuffledDiffElements(diffElements);\n-  329:         Map<Removed, RemovedGroup> removedGroups = combineRemovedElementsToRemovedGroups();\n-  330:         do {\n-  331:             boolean isLeftOverDiffElement = applyLeftOverDiffElements();\n-  332:             boolean isLeftOverOriginalElement = applyLeftOverOriginalElements();\n-  333:             if (!isLeftOverDiffElement && !isLeftOverOriginalElement) {\n-  338:                     TextElement originalElement = originalElements.get(originalIndex);\n-  339:                     boolean originalElementIsChild = originalElement instanceof ChildTextElement;\n-  340:                     boolean originalElementIsToken = originalElement instanceof TokenTextElement;\n+  282:      * @return The current position in the list of the elements\n+  283:      */\n+  284:     private int removeExtraCharacters(NodeText nodeText, int nodeTextIndex, int extraCharacters) {\n+  285:         int count = 0;\n+  286:         while (nodeTextIndex >= 0 && nodeTextIndex < nodeText.numberOfElements() && count < extraCharacters) {\n+  287:             nodeText.removeElement(nodeTextIndex);\n+  288:             count++;\n+  289:         }\n+  290:         return nodeTextIndex;\n+  291:     }\n+  292: \n+  293:     /**\n+  294:      * Starting at {@code nodeTextIndex} this method tries to determine how many contiguous spaces there are between\n+  295:      * the previous end of line and the next non whitespace (or tab) character\n+  296:      * @param nodeText List of elements to analyze\n+  297:      * @param nodeTextIndex Starting position in the input list\n+  298:      * @return EnforcingIndentationContext Data structure that hold the starting position of the first whitespace char and\n+  299:      * The number of consecutive whitespace (or tab) characters\n+  300:      */\n+  301:     private EnforcingIndentationContext defineEnforcingIndentationContext(NodeText nodeText, int startIndex) {\n+  302:     \tEnforcingIndentationContext ctx = new EnforcingIndentationContext(startIndex);\n+  303:     \t// compute space before startIndex value\n+  304: \t\tif (startIndex < nodeText.numberOfElements() && startIndex > 0) {\n+  305: \t\t\t// at this stage startIndex points to the first element before the deleted one\n+  306: \t\t\tfor (int i = startIndex - 1; i >= 0 && i < nodeText.numberOfElements(); i--) {\n+  307: \t\t\t\tif (nodeText.getTextElement(i).isNewline()) {\n+  308: \t\t\t\t\tbreak;\n+  309: \t\t\t\t}\n+  310: \t\t\t\tif (!isSpaceOrTabElement(nodeText, i)) {\n+  311: \t\t\t\t\tctx = new EnforcingIndentationContext(startIndex);\n+  312: \t\t\t\t\tbreak;\n+  313: \t\t\t\t}\n+  314: \t\t\t\tctx.start = i;\n+  315: \t\t\t\tctx.extraCharacters++;\n+  316: \t\t\t}\n+  317: \t\t}\n+  318: \t\t// compute space after the deleted element\n+  319: \t\tif (isSpaceOrTabElement(nodeText, startIndex)) {\n+  320: //\t\t\tint startingFromIndex = startIndex == 0 ? startIndex : startIndex + 1;\n+  321: \t\t\tfor (int i = startIndex; i >= 0 && i < nodeText.numberOfElements(); i++) {\n+  322: \t\t\t\tif (nodeText.getTextElement(i).isNewline()) {\n+  323: \t\t\t\t\tbreak;\n+  324: \t\t\t\t}\n+  325: \t\t\t\tif (!isSpaceOrTabElement(nodeText, i)) {\n+  326: \t\t\t\t\tbreak;\n+  327: \t\t\t\t}\n+  328: \t\t\t\tctx.extraCharacters++;\n+  329: \t\t\t}\n+  330: \t\t}\n+  331: \n+  332:         return ctx;\n+  333:     }\n+  338: \tprivate boolean isSpaceOrTabElement(NodeText nodeText, int i) {\n+  339: \t\treturn nodeText.getTextElement(i).isSpaceOrTab();\n+  340: \t}\n",
        "uniqueId": "c9adc2fe0111fdb3f926d2df2264a8dcf6335f11_282_321_338_340_293_333",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 0,
                "covered": 86
            },
            "BRANCH": {
                "missed": 5,
                "covered": 17
            },
            "LINE": {
                "missed": 0,
                "covered": 18
            },
            "COMPLEXITY": {
                "missed": 5,
                "covered": 7
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 1.8
    },
    {
        "type": "Extract And Move Method",
        "description": "Extract And Move Method\tpublic of() : LeastUpperBoundLogic extracted from public leastUpperBound(types Set<ResolvedType>) : ResolvedType in class com.github.javaparser.symbolsolver.resolution.typeinference.TypeHelper & moved to class com.github.javaparser.symbolsolver.resolution.typeinference.LeastUpperBoundLogic",
        "diffLocations": [
            {
                "filePath": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/TypeHelper.java",
                "startLine": 203,
                "endLine": 211,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/TypeHelper.java",
                "startLine": 203,
                "endLine": 211,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/TypeHelper.java",
                "startLine": 25,
                "endLine": 27,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "/**\n     * See JLS 4.10.4. Least Upper Bound.\n     * The least upper bound, or \"lub\", of a set of reference types is a shared supertype that is more specific than\n     * any other shared supertype (that is, no other shared supertype is a subtype of the least upper bound).\n     */\n    public static ResolvedType leastUpperBound(Set<ResolvedType> types) {\n    \tLeastUpperBoundLogic logic = new LeastUpperBoundLogic();\n    \treturn logic.lub(types);\n    }",
        "filePathBefore": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/TypeHelper.java",
        "isPureRefactoring": true,
        "commitId": "2b503c32229deae7d432f59dab710839ecf76c4c",
        "packageNameBefore": "com.github.javaparser.symbolsolver.resolution.typeinference",
        "classNameBefore": "com.github.javaparser.symbolsolver.resolution.typeinference.TypeHelper",
        "methodNameBefore": "com.github.javaparser.symbolsolver.resolution.typeinference.TypeHelper#leastUpperBound",
        "invokedMethod": "methodSignature: com.github.javaparser.symbolsolver.resolution.typeinference.LeastUpperBoundLogic#lub\n methodBody: public ResolvedType lub(Set<ResolvedType> types) {\nif(types.isEmpty()){throw new IllegalArgumentException();\n}Set<ResolvedType> resolvedTypes=types.stream().filter(type -> !(type instanceof NullType)).collect(Collectors.toSet());\nif(resolvedTypes.size() == 1){return resolvedTypes.stream().findFirst().get();\n}List<Set<ResolvedType>> supertypes=supertypes(resolvedTypes);\nList<Set<ResolvedType>> erasedSupertypes=erased(supertypes);\nList<ResolvedType> erasedCandidates=intersection(erasedSupertypes);\nList<ResolvedType> minimalErasedCandidates=minimalCandidates(erasedCandidates);\nif(minimalErasedCandidates.isEmpty()){return null;\n}Multimap<ResolvedType,ResolvedType> relevantParameterizations=relevantParameterizations(minimalErasedCandidates,supertypes);\nResolvedType erasedBest=best(minimalErasedCandidates);\nCollection<ResolvedType> erasedTypeParameterizations=relevantParameterizations.get(erasedBest);\nif(erasedTypeParameterizations != null && !erasedTypeParameterizations.contains(erasedBest)){Set<ResolvedType> searchedTypes=new HashSet<>(resolvedTypes);\nif(!lubCache.contains(searchedTypes)){lubCache.add(searchedTypes);\nreturn leastContainingParameterization(new ArrayList<>(erasedTypeParameterizations));\n}}return erasedBest;\n}",
        "classSignatureBefore": "public class TypeHelper ",
        "methodNameBeforeSet": [
            "com.github.javaparser.symbolsolver.resolution.typeinference.TypeHelper#leastUpperBound"
        ],
        "classNameBeforeSet": [
            "com.github.javaparser.symbolsolver.resolution.typeinference.TypeHelper"
        ],
        "classSignatureBeforeSet": [
            "public class TypeHelper "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Copyright (C) 2015-2016 Federico Tomassetti\n * Copyright (C) 2017-2023 The JavaParser Team.\n *\n * This file is part of JavaParser.\n *\n * JavaParser can be used either under the terms of\n * a) the GNU Lesser General Public License as published by\n *     the Free Software Foundation, either version 3 of the License, or\n *     (at your option) any later version.\n * b) the terms of the Apache License\n *\n * You should have received a copy of both licenses in LICENCE.LGPL and\n * LICENCE.APACHE. Please refer to those files for details.\n *\n * JavaParser is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n */\n\npackage com.github.javaparser.symbolsolver.resolution.typeinference;\n\nimport java.util.*;\n\nimport com.github.javaparser.ast.expr.Expression;\nimport com.github.javaparser.ast.expr.LambdaExpr;\nimport com.github.javaparser.resolution.MethodUsage;\nimport com.github.javaparser.resolution.TypeSolver;\nimport com.github.javaparser.resolution.declarations.ResolvedReferenceTypeDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedTypeParameterDeclaration;\nimport com.github.javaparser.resolution.logic.FunctionalInterfaceLogic;\nimport com.github.javaparser.resolution.model.SymbolReference;\nimport com.github.javaparser.resolution.model.typesystem.LazyType;\nimport com.github.javaparser.resolution.model.typesystem.ReferenceTypeImpl;\nimport com.github.javaparser.resolution.types.*;\nimport com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade;\nimport com.github.javaparser.utils.Pair;\n\n/**\n * The term \"type\" is used loosely in this chapter to include type-like syntax that contains inference variables.\n *\n * Assertions that involve inference\n * variables are assertions about every proper type that can be produced by replacing each inference variable with\n * a proper type.\n *\n * @author Federico Tomassetti\n */\npublic class TypeHelper {\n\n    /**\n     * The term proper type excludes such \"types\" that mention inference variables.\n     */\n    public static boolean isProperType(ResolvedType type) {\n        if (type instanceof InferenceVariable) {\n            return false;\n        }\n        if (type instanceof ResolvedReferenceType) {\n            ResolvedReferenceType referenceType = (ResolvedReferenceType) type;\n            return referenceType.typeParametersValues().stream().allMatch(it -> isProperType(it));\n        }\n        if (type instanceof LazyType) {\n            return type.asReferenceType().typeParametersValues().stream().allMatch(it -> isProperType(it));\n        }\n        if (type instanceof ResolvedWildcard) {\n            ResolvedWildcard wildcard = (ResolvedWildcard)type;\n            if (wildcard.isBounded()) {\n                return isProperType(wildcard.getBoundedType());\n            } else {\n                return true;\n            }\n        }\n        if (type.isPrimitive()) {\n            return true;\n        }\n        if (type.isTypeVariable()) {\n            // FIXME I am not sure...\n            return false;\n        }\n        if (type.isArray()) {\n            return isProperType(type.asArrayType().getComponentType());\n        }\n        throw new UnsupportedOperationException(type.toString());\n    }\n\n    /**\n     * see https://docs.oracle.com/javase/specs/jls/se8/html/jls-5.html#jls-5.3\n     * @param expression\n     * @param t\n     * @return\n     */\n    public static boolean isCompatibleInAStrictInvocationContext(Expression expression, ResolvedType t) {\n        throw new UnsupportedOperationException();\n    }\n\n    /**\n     * see https://docs.oracle.com/javase/specs/jls/se8/html/jls-5.html#jls-5.3\n     * @param expression\n     * @param t\n     * @return\n     */\n    public static boolean isCompatibleInALooseInvocationContext(TypeSolver typeSolver, Expression expression, ResolvedType t) {\n        //throw new UnsupportedOperationException(\"Unable to determine if \" + expression + \" is compatible in a loose invocation context with type \" + t);\n        return isCompatibleInALooseInvocationContext(JavaParserFacade.get(typeSolver).getType(expression), t);\n    }\n\n    /**\n     * see https://docs.oracle.com/javase/specs/jls/se8/html/jls-5.html#jls-5.3\n     * @param s\n     * @param t\n     * @return\n     */\n    public static boolean isCompatibleInALooseInvocationContext(ResolvedType s, ResolvedType t) {\n        // Loose invocation contexts allow a more permissive set of conversions, because they are only used for a\n        // particular invocation if no applicable declaration can be found using strict invocation contexts. Loose\n        // invocation contexts allow the use of one of the following:\n        //\n        // - an identity conversion (\u00a75.1.1)\n\n        if (s.equals(t)) {\n            return true;\n        }\n\n        // - a widening primitive conversion (\u00a75.1.2)\n\n        if (s.isPrimitive() && t.isPrimitive() && areCompatibleThroughWideningPrimitiveConversion(s, t)) {\n            return true;\n        }\n\n        // - a widening reference conversion (\u00a75.1.5)\n\n        if (s.isReferenceType() && t.isReferenceType() && areCompatibleThroughWideningReferenceConversion(s, t)) {\n            return true;\n        }\n\n        // - a boxing conversion (\u00a75.1.7) optionally followed by widening reference conversion\n\n        if (s.isPrimitive() && t.isReferenceType() &&\n                areCompatibleThroughWideningReferenceConversion(toBoxedType(s.asPrimitive()), t)) {\n            return true;\n        }\n\n        // - an unboxing conversion (\u00a75.1.8) optionally followed by a widening primitive conversion\n\n        if (s.isReferenceType() && s.asReferenceType().isUnboxable() && t.isPrimitive() &&\n                areCompatibleThroughWideningPrimitiveConversion(s.asReferenceType().toUnboxedType().get(), t)) {\n            return true;\n        }\n\n        // If, after the conversions listed for an invocation context have been applied, the resulting type is a raw\n        // type (\u00a74.8), an unchecked conversion (\u00a75.1.9) may then be applied.\n        //\n        // A value of the null type (the null reference is the only such value) may be assigned to any reference type\n        if (s.isNull() && t.isReferenceType()) {\n            return true;\n        }\n\n        //throw new UnsupportedOperationException(\"isCompatibleInALooseInvocationContext unable to decide on s=\" + s + \", t=\" + t);\n        // TODO FIXME\n        return t.isAssignableBy(s);\n    }\n\n    public static ResolvedType toBoxedType(ResolvedPrimitiveType primitiveType) {\n        throw new UnsupportedOperationException();\n    }\n\n    // get the resolved boxed type of the specified primitive type\n    public static ResolvedType toBoxedType(ResolvedPrimitiveType primitiveType, TypeSolver typeSolver ) {\n        SymbolReference<ResolvedReferenceTypeDeclaration> typeDeclaration =  typeSolver.tryToSolveType(primitiveType.getBoxTypeQName());\n        return new ReferenceTypeImpl(typeDeclaration.getCorrespondingDeclaration());\n    }\n\n    public static boolean areCompatibleThroughWideningReferenceConversion(ResolvedType s, ResolvedType t) {\n        Optional<ResolvedPrimitiveType> correspondingPrimitiveTypeForS = Arrays.stream(ResolvedPrimitiveType.values()).filter(pt -> pt.getBoxTypeQName().equals(s.asReferenceType().getQualifiedName())).findFirst();\n        if (!correspondingPrimitiveTypeForS.isPresent()) {\n            return false;\n        }\n        throw new UnsupportedOperationException(\"areCompatibleThroughWideningReferenceConversion s=\"+s+\", t=\" + t);\n    }\n\n    public static boolean areCompatibleThroughWideningPrimitiveConversion(ResolvedType s, ResolvedType t) {\n        if (s.isPrimitive() && t.isPrimitive()) {\n            return s.isAssignableBy(t);\n        } else {\n            return false;\n        }\n    }\n\n    public static Set<InferenceVariable> usedInferenceVariables(ResolvedType type) {\n        if (type.isInferenceVariable()) {\n            return new HashSet<>(Arrays.asList((InferenceVariable) type));\n        }\n        if (type.isReferenceType()) {\n            Set<InferenceVariable> res = new HashSet<>();\n            for (ResolvedType tp : type.asReferenceType().typeParametersValues()) {\n                res.addAll(usedInferenceVariables(tp));\n            }\n            return res;\n        }\n        throw new UnsupportedOperationException(type.toString());\n    }\n\n    /**\n     * See JLS 4.10.4. Least Upper Bound.\n     * The least upper bound, or \"lub\", of a set of reference types is a shared supertype that is more specific than\n     * any other shared supertype (that is, no other shared supertype is a subtype of the least upper bound).\n     */\n    public static ResolvedType leastUpperBound(Set<ResolvedType> types) {\n    \tLeastUpperBoundLogic logic = new LeastUpperBoundLogic();\n    \treturn logic.lub(types);\n    }\n\n    /**\n     * See JLS 15.27.3. Type of a Lambda Expression\n     * @return\n     */\n    public static Pair<ResolvedType, Boolean> groundTargetTypeOfLambda(LambdaExpr lambdaExpr, ResolvedType T, TypeSolver typeSolver) {\n        // The ground target type is derived from T as follows:\n        //\n        boolean used18_5_3 = false;\n\n        boolean wildcardParameterized = T.asReferenceType().typeParametersValues().stream()\n                .anyMatch(tp -> tp.isWildcard());\n        if (wildcardParameterized) {\n            // - If T is a wildcard-parameterized functional interface type and the lambda expression is explicitly typed,\n            //   then the ground target type is inferred as described in \u00a718.5.3.\n\n            if (ExpressionHelper.isExplicitlyTyped(lambdaExpr)) {\n                used18_5_3 = true;\n                throw new UnsupportedOperationException();\n            }\n\n            // - If T is a wildcard-parameterized functional interface type and the lambda expression is implicitly typed,\n            //   then the ground target type is the non-wildcard parameterization (\u00a79.9) of T.\n\n            else {\n                return new Pair<>(nonWildcardParameterizationOf(T.asReferenceType(), typeSolver), used18_5_3);\n            }\n        }\n\n        // - Otherwise, the ground target type is T.\n        return new Pair<>(T, used18_5_3);\n    }\n\n    /**\n     * See JLS 9.9\n     */\n    private static ResolvedReferenceType nonWildcardParameterizationOf(ResolvedReferenceType originalType, TypeSolver typeSolver) {\n        ResolvedReferenceTypeDeclaration originalTypeDeclaration = originalType.getTypeDeclaration().orElseThrow(() -> new RuntimeException(\"TypeDeclaration unexpectedly empty.\"));\n\n        List<ResolvedType> TIs = new LinkedList<>();\n        List<ResolvedType> AIs = originalType.typeParametersValues();\n        List<ResolvedTypeParameterDeclaration> TPs = originalTypeDeclaration.getTypeParameters();\n\n        // Let P1...Pn be the type parameters of I with corresponding bounds B1...Bn. For all i (1 \u2264 i \u2264 n),\n        // Ti is derived according to the form of Ai:\n\n        ResolvedReferenceType object = new ReferenceTypeImpl(typeSolver.getSolvedJavaLangObject());\n\n        for (int i=0;i<AIs.size();i++) {\n            ResolvedType Ai = AIs.get(i);\n            ResolvedType Ti = null;\n\n            // - If Ai is a type, then Ti = Ai.\n\n            if (!Ai.isWildcard()) {\n                Ti = Ai;\n            }\n\n            // - If Ai is a wildcard, and the corresponding type parameter's bound, Bi, mentions one of P1...Pn, then\n            //   Ti is undefined and there is no function type.\n\n            if (Ti == null && Ai.isWildcard() && Ai.asWildcard().mention(originalTypeDeclaration.getTypeParameters())) {\n                throw new IllegalArgumentException();\n            }\n\n            // - Otherwise:\n\n            if (Ti == null) {\n\n                ResolvedType Bi = TPs.get(i).hasLowerBound() ? TPs.get(i).getLowerBound() : object;\n\n                //   - If Ai is an unbound wildcard ?, then Ti = Bi.\n\n                if (Ai.isWildcard() && !Ai.asWildcard().isBounded()) {\n                    Ti = Bi;\n                }\n\n                //   - If Ai is a upper-bounded wildcard ? extends Ui, then Ti = glb(Ui, Bi) (\u00a75.1.10).\n\n                else if (Ai.isWildcard() && Ai.asWildcard().isUpperBounded()) {\n                    ResolvedType Ui = Ai.asWildcard().getBoundedType();\n                    Ti = glb(new HashSet<>(Arrays.asList(Ui, Bi)));\n                }\n\n                //   - If Ai is a lower-bounded wildcard ? super Li, then Ti = Li.\n\n                else if (Ai.isWildcard() && Ai.asWildcard().isLowerBounded()) {\n                    Ti = Ai.asWildcard().getBoundedType();\n                }\n\n                else {\n                    throw new RuntimeException(\"This should not happen\");\n                }\n            }\n\n            TIs.add(Ti);\n        }\n\n        return new ReferenceTypeImpl(originalTypeDeclaration, TIs);\n    }\n\n    public static MethodType getFunctionType(ResolvedType type) {\n        Optional<MethodUsage> mu = FunctionalInterfaceLogic.getFunctionalMethod(type);\n        if (mu.isPresent()) {\n            return MethodType.fromMethodUsage(mu.get());\n        } else {\n            throw new IllegalArgumentException();\n        }\n    }\n\n    /**\n     * See JLS 5.1.10. Capture Conversion.\n     */\n    public static ResolvedType glb(Set<ResolvedType> types) {\n        if (types.isEmpty()) {\n            throw new IllegalArgumentException();\n        }\n        if (types.size() == 1) {\n            return types.iterator().next();\n        }\n        return new ResolvedIntersectionType(types);\n    }\n}\n",
        "filePathAfter": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/TypeHelper.java",
        "sourceCodeAfterForWhole": "/*\n * Copyright (C) 2015-2016 Federico Tomassetti\n * Copyright (C) 2017-2023 The JavaParser Team.\n *\n * This file is part of JavaParser.\n *\n * JavaParser can be used either under the terms of\n * a) the GNU Lesser General Public License as published by\n *     the Free Software Foundation, either version 3 of the License, or\n *     (at your option) any later version.\n * b) the terms of the Apache License\n *\n * You should have received a copy of both licenses in LICENCE.LGPL and\n * LICENCE.APACHE. Please refer to those files for details.\n *\n * JavaParser is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n */\n\npackage com.github.javaparser.symbolsolver.resolution.typeinference;\n\nimport java.util.*;\n\nimport com.github.javaparser.ast.expr.Expression;\nimport com.github.javaparser.ast.expr.LambdaExpr;\nimport com.github.javaparser.resolution.MethodUsage;\nimport com.github.javaparser.resolution.TypeSolver;\nimport com.github.javaparser.resolution.declarations.ResolvedReferenceTypeDeclaration;\nimport com.github.javaparser.resolution.declarations.ResolvedTypeParameterDeclaration;\nimport com.github.javaparser.resolution.logic.FunctionalInterfaceLogic;\nimport com.github.javaparser.resolution.model.SymbolReference;\nimport com.github.javaparser.resolution.model.typesystem.LazyType;\nimport com.github.javaparser.resolution.model.typesystem.ReferenceTypeImpl;\nimport com.github.javaparser.resolution.types.*;\nimport com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade;\nimport com.github.javaparser.utils.Pair;\n\n/**\n * The term \"type\" is used loosely in this chapter to include type-like syntax that contains inference variables.\n *\n * Assertions that involve inference\n * variables are assertions about every proper type that can be produced by replacing each inference variable with\n * a proper type.\n *\n * @author Federico Tomassetti\n */\npublic class TypeHelper {\n\n    /**\n     * The term proper type excludes such \"types\" that mention inference variables.\n     */\n    public static boolean isProperType(ResolvedType type) {\n        if (type instanceof InferenceVariable) {\n            return false;\n        }\n        if (type instanceof ResolvedReferenceType) {\n            ResolvedReferenceType referenceType = (ResolvedReferenceType) type;\n            return referenceType.typeParametersValues().stream().allMatch(it -> isProperType(it));\n        }\n        if (type instanceof LazyType) {\n            return type.asReferenceType().typeParametersValues().stream().allMatch(it -> isProperType(it));\n        }\n        if (type instanceof ResolvedWildcard) {\n            ResolvedWildcard wildcard = (ResolvedWildcard)type;\n            if (wildcard.isBounded()) {\n                return isProperType(wildcard.getBoundedType());\n            } else {\n                return true;\n            }\n        }\n        if (type.isPrimitive()) {\n            return true;\n        }\n        if (type.isTypeVariable()) {\n            // FIXME I am not sure...\n            return false;\n        }\n        if (type.isArray()) {\n            return isProperType(type.asArrayType().getComponentType());\n        }\n        throw new UnsupportedOperationException(type.toString());\n    }\n\n    /**\n     * see https://docs.oracle.com/javase/specs/jls/se8/html/jls-5.html#jls-5.3\n     * @param expression\n     * @param t\n     * @return\n     */\n    public static boolean isCompatibleInAStrictInvocationContext(Expression expression, ResolvedType t) {\n        throw new UnsupportedOperationException();\n    }\n\n    /**\n     * see https://docs.oracle.com/javase/specs/jls/se8/html/jls-5.html#jls-5.3\n     * @param expression\n     * @param t\n     * @return\n     */\n    public static boolean isCompatibleInALooseInvocationContext(TypeSolver typeSolver, Expression expression, ResolvedType t) {\n        //throw new UnsupportedOperationException(\"Unable to determine if \" + expression + \" is compatible in a loose invocation context with type \" + t);\n        return isCompatibleInALooseInvocationContext(JavaParserFacade.get(typeSolver).getType(expression), t);\n    }\n\n    /**\n     * see https://docs.oracle.com/javase/specs/jls/se8/html/jls-5.html#jls-5.3\n     * @param s\n     * @param t\n     * @return\n     */\n    public static boolean isCompatibleInALooseInvocationContext(ResolvedType s, ResolvedType t) {\n        // Loose invocation contexts allow a more permissive set of conversions, because they are only used for a\n        // particular invocation if no applicable declaration can be found using strict invocation contexts. Loose\n        // invocation contexts allow the use of one of the following:\n        //\n        // - an identity conversion (\u00a75.1.1)\n\n        if (s.equals(t)) {\n            return true;\n        }\n\n        // - a widening primitive conversion (\u00a75.1.2)\n\n        if (s.isPrimitive() && t.isPrimitive() && areCompatibleThroughWideningPrimitiveConversion(s, t)) {\n            return true;\n        }\n\n        // - a widening reference conversion (\u00a75.1.5)\n\n        if (s.isReferenceType() && t.isReferenceType() && areCompatibleThroughWideningReferenceConversion(s, t)) {\n            return true;\n        }\n\n        // - a boxing conversion (\u00a75.1.7) optionally followed by widening reference conversion\n\n        if (s.isPrimitive() && t.isReferenceType() &&\n                areCompatibleThroughWideningReferenceConversion(toBoxedType(s.asPrimitive()), t)) {\n            return true;\n        }\n\n        // - an unboxing conversion (\u00a75.1.8) optionally followed by a widening primitive conversion\n\n        if (s.isReferenceType() && s.asReferenceType().isUnboxable() && t.isPrimitive() &&\n                areCompatibleThroughWideningPrimitiveConversion(s.asReferenceType().toUnboxedType().get(), t)) {\n            return true;\n        }\n\n        // If, after the conversions listed for an invocation context have been applied, the resulting type is a raw\n        // type (\u00a74.8), an unchecked conversion (\u00a75.1.9) may then be applied.\n        //\n        // A value of the null type (the null reference is the only such value) may be assigned to any reference type\n        if (s.isNull() && t.isReferenceType()) {\n            return true;\n        }\n\n        //throw new UnsupportedOperationException(\"isCompatibleInALooseInvocationContext unable to decide on s=\" + s + \", t=\" + t);\n        // TODO FIXME\n        return t.isAssignableBy(s);\n    }\n\n    public static ResolvedType toBoxedType(ResolvedPrimitiveType primitiveType) {\n        throw new UnsupportedOperationException();\n    }\n\n    // get the resolved boxed type of the specified primitive type\n    public static ResolvedType toBoxedType(ResolvedPrimitiveType primitiveType, TypeSolver typeSolver ) {\n        SymbolReference<ResolvedReferenceTypeDeclaration> typeDeclaration =  typeSolver.tryToSolveType(primitiveType.getBoxTypeQName());\n        return new ReferenceTypeImpl(typeDeclaration.getCorrespondingDeclaration());\n    }\n\n    public static boolean areCompatibleThroughWideningReferenceConversion(ResolvedType s, ResolvedType t) {\n        Optional<ResolvedPrimitiveType> correspondingPrimitiveTypeForS = Arrays.stream(ResolvedPrimitiveType.values()).filter(pt -> pt.getBoxTypeQName().equals(s.asReferenceType().getQualifiedName())).findFirst();\n        if (!correspondingPrimitiveTypeForS.isPresent()) {\n            return false;\n        }\n        throw new UnsupportedOperationException(\"areCompatibleThroughWideningReferenceConversion s=\"+s+\", t=\" + t);\n    }\n\n    public static boolean areCompatibleThroughWideningPrimitiveConversion(ResolvedType s, ResolvedType t) {\n        if (s.isPrimitive() && t.isPrimitive()) {\n            return s.isAssignableBy(t);\n        } else {\n            return false;\n        }\n    }\n\n    public static Set<InferenceVariable> usedInferenceVariables(ResolvedType type) {\n        if (type.isInferenceVariable()) {\n            return new HashSet<>(Arrays.asList((InferenceVariable) type));\n        }\n        if (type.isReferenceType()) {\n            Set<InferenceVariable> res = new HashSet<>();\n            for (ResolvedType tp : type.asReferenceType().typeParametersValues()) {\n                res.addAll(usedInferenceVariables(tp));\n            }\n            return res;\n        }\n        throw new UnsupportedOperationException(type.toString());\n    }\n\n    /**\n     * See JLS 4.10.4. Least Upper Bound.\n     * The least upper bound, or \"lub\", of a set of reference types is a shared supertype that is more specific than\n     * any other shared supertype (that is, no other shared supertype is a subtype of the least upper bound).\n     */\n    public static ResolvedType leastUpperBound(Set<ResolvedType> types) {\n    \tLeastUpperBoundLogic logic = LeastUpperBoundLogic.of();\n    \treturn logic.lub(types);\n    }\n\n    /**\n     * See JLS 15.27.3. Type of a Lambda Expression\n     * @return\n     */\n    public static Pair<ResolvedType, Boolean> groundTargetTypeOfLambda(LambdaExpr lambdaExpr, ResolvedType T, TypeSolver typeSolver) {\n        // The ground target type is derived from T as follows:\n        //\n        boolean used18_5_3 = false;\n\n        boolean wildcardParameterized = T.asReferenceType().typeParametersValues().stream()\n                .anyMatch(tp -> tp.isWildcard());\n        if (wildcardParameterized) {\n            // - If T is a wildcard-parameterized functional interface type and the lambda expression is explicitly typed,\n            //   then the ground target type is inferred as described in \u00a718.5.3.\n\n            if (ExpressionHelper.isExplicitlyTyped(lambdaExpr)) {\n                used18_5_3 = true;\n                throw new UnsupportedOperationException();\n            }\n\n            // - If T is a wildcard-parameterized functional interface type and the lambda expression is implicitly typed,\n            //   then the ground target type is the non-wildcard parameterization (\u00a79.9) of T.\n\n            else {\n                return new Pair<>(nonWildcardParameterizationOf(T.asReferenceType(), typeSolver), used18_5_3);\n            }\n        }\n\n        // - Otherwise, the ground target type is T.\n        return new Pair<>(T, used18_5_3);\n    }\n\n    /**\n     * See JLS 9.9\n     */\n    private static ResolvedReferenceType nonWildcardParameterizationOf(ResolvedReferenceType originalType, TypeSolver typeSolver) {\n        ResolvedReferenceTypeDeclaration originalTypeDeclaration = originalType.getTypeDeclaration().orElseThrow(() -> new RuntimeException(\"TypeDeclaration unexpectedly empty.\"));\n\n        List<ResolvedType> TIs = new LinkedList<>();\n        List<ResolvedType> AIs = originalType.typeParametersValues();\n        List<ResolvedTypeParameterDeclaration> TPs = originalTypeDeclaration.getTypeParameters();\n\n        // Let P1...Pn be the type parameters of I with corresponding bounds B1...Bn. For all i (1 \u2264 i \u2264 n),\n        // Ti is derived according to the form of Ai:\n\n        ResolvedReferenceType object = new ReferenceTypeImpl(typeSolver.getSolvedJavaLangObject());\n\n        for (int i=0;i<AIs.size();i++) {\n            ResolvedType Ai = AIs.get(i);\n            ResolvedType Ti = null;\n\n            // - If Ai is a type, then Ti = Ai.\n\n            if (!Ai.isWildcard()) {\n                Ti = Ai;\n            }\n\n            // - If Ai is a wildcard, and the corresponding type parameter's bound, Bi, mentions one of P1...Pn, then\n            //   Ti is undefined and there is no function type.\n\n            if (Ti == null && Ai.isWildcard() && Ai.asWildcard().mention(originalTypeDeclaration.getTypeParameters())) {\n                throw new IllegalArgumentException();\n            }\n\n            // - Otherwise:\n\n            if (Ti == null) {\n\n                ResolvedType Bi = TPs.get(i).hasLowerBound() ? TPs.get(i).getLowerBound() : object;\n\n                //   - If Ai is an unbound wildcard ?, then Ti = Bi.\n\n                if (Ai.isWildcard() && !Ai.asWildcard().isBounded()) {\n                    Ti = Bi;\n                }\n\n                //   - If Ai is a upper-bounded wildcard ? extends Ui, then Ti = glb(Ui, Bi) (\u00a75.1.10).\n\n                else if (Ai.isWildcard() && Ai.asWildcard().isUpperBounded()) {\n                    ResolvedType Ui = Ai.asWildcard().getBoundedType();\n                    Ti = glb(new HashSet<>(Arrays.asList(Ui, Bi)));\n                }\n\n                //   - If Ai is a lower-bounded wildcard ? super Li, then Ti = Li.\n\n                else if (Ai.isWildcard() && Ai.asWildcard().isLowerBounded()) {\n                    Ti = Ai.asWildcard().getBoundedType();\n                }\n\n                else {\n                    throw new RuntimeException(\"This should not happen\");\n                }\n            }\n\n            TIs.add(Ti);\n        }\n\n        return new ReferenceTypeImpl(originalTypeDeclaration, TIs);\n    }\n\n    public static MethodType getFunctionType(ResolvedType type) {\n        Optional<MethodUsage> mu = FunctionalInterfaceLogic.getFunctionalMethod(type);\n        if (mu.isPresent()) {\n            return MethodType.fromMethodUsage(mu.get());\n        } else {\n            throw new IllegalArgumentException();\n        }\n    }\n\n    /**\n     * See JLS 5.1.10. Capture Conversion.\n     */\n    public static ResolvedType glb(Set<ResolvedType> types) {\n        if (types.isEmpty()) {\n            throw new IllegalArgumentException();\n        }\n        if (types.size() == 1) {\n            return types.iterator().next();\n        }\n        return new ResolvedIntersectionType(types);\n    }\n}\n",
        "diffSourceCodeSet": [
            "import com.github.javaparser.ast.expr.Expression;\nimport com.github.javaparser.ast.expr.LambdaExpr;"
        ],
        "invokedMethodSet": [
            "methodSignature: com.github.javaparser.symbolsolver.resolution.typeinference.LeastUpperBoundLogic#lub\n methodBody: public ResolvedType lub(Set<ResolvedType> types) {\nif(types.isEmpty()){throw new IllegalArgumentException();\n}Set<ResolvedType> resolvedTypes=types.stream().filter(type -> !(type instanceof NullType)).collect(Collectors.toSet());\nif(resolvedTypes.size() == 1){return resolvedTypes.stream().findFirst().get();\n}List<Set<ResolvedType>> supertypes=supertypes(resolvedTypes);\nList<Set<ResolvedType>> erasedSupertypes=erased(supertypes);\nList<ResolvedType> erasedCandidates=intersection(erasedSupertypes);\nList<ResolvedType> minimalErasedCandidates=minimalCandidates(erasedCandidates);\nif(minimalErasedCandidates.isEmpty()){return null;\n}Multimap<ResolvedType,ResolvedType> relevantParameterizations=relevantParameterizations(minimalErasedCandidates,supertypes);\nResolvedType erasedBest=best(minimalErasedCandidates);\nCollection<ResolvedType> erasedTypeParameterizations=relevantParameterizations.get(erasedBest);\nif(erasedTypeParameterizations != null && !erasedTypeParameterizations.contains(erasedBest)){Set<ResolvedType> searchedTypes=new HashSet<>(resolvedTypes);\nif(!lubCache.contains(searchedTypes)){lubCache.add(searchedTypes);\nreturn leastContainingParameterization(new ArrayList<>(erasedTypeParameterizations));\n}}return erasedBest;\n}"
        ],
        "sourceCodeAfterRefactoring": "/**\n     * See JLS 4.10.4. Least Upper Bound.\n     * The least upper bound, or \"lub\", of a set of reference types is a shared supertype that is more specific than\n     * any other shared supertype (that is, no other shared supertype is a subtype of the least upper bound).\n     */\n    public static ResolvedType leastUpperBound(Set<ResolvedType> types) {\n    \tLeastUpperBoundLogic logic = LeastUpperBoundLogic.of();\n    \treturn logic.lub(types);\n    }\nimport com.github.javaparser.ast.expr.Expression;\nimport com.github.javaparser.ast.expr.LambdaExpr;",
        "diffSourceCode": "    25: \n    26: import com.github.javaparser.ast.expr.Expression;\n    27: import com.github.javaparser.ast.expr.LambdaExpr;\n   203:     /**\n   204:      * See JLS 4.10.4. Least Upper Bound.\n   205:      * The least upper bound, or \"lub\", of a set of reference types is a shared supertype that is more specific than\n   206:      * any other shared supertype (that is, no other shared supertype is a subtype of the least upper bound).\n   207:      */\n   208:     public static ResolvedType leastUpperBound(Set<ResolvedType> types) {\n-  209:     \tLeastUpperBoundLogic logic = new LeastUpperBoundLogic();\n+  209:     \tLeastUpperBoundLogic logic = LeastUpperBoundLogic.of();\n   210:     \treturn logic.lub(types);\n   211:     }\n",
        "uniqueId": "2b503c32229deae7d432f59dab710839ecf76c4c_203_211_25_27_203_211",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 0,
                "covered": 8
            },
            "LINE": {
                "missed": 0,
                "covered": 2
            },
            "COMPLEXITY": {
                "missed": 0,
                "covered": 1
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 1.8
    },
    {
        "type": "Extract And Move Method",
        "description": "Extract And Move Method\tpublic getFooter() : String extracted from package process(comment Comment, printer SourcePrinter) : void in class com.github.javaparser.printer.concretesyntaxmodel.CsmComment & moved to class com.github.javaparser.ast.comments.JavadocComment",
        "diffLocations": [
            {
                "filePath": "javaparser-core/src/main/java/com/github/javaparser/printer/concretesyntaxmodel/CsmComment.java",
                "startLine": 32,
                "endLine": 49,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "javaparser-core/src/main/java/com/github/javaparser/printer/concretesyntaxmodel/CsmComment.java",
                "startLine": 29,
                "endLine": 34,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "javaparser-core/src/main/java/com/github/javaparser/printer/concretesyntaxmodel/CsmComment.java",
                "startLine": 120,
                "endLine": 123,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "static void process(Comment comment, SourcePrinter printer) {\n        String content = printer.normalizeEolInTextBlock(comment.getContent());\n        if (comment instanceof BlockComment) {\n            printer.print(\"/*\");\n            printer.print(content);\n            printer.println(\"*/\");\n        } else if (comment instanceof JavadocComment) {\n            printer.print(\"/**\");\n            printer.print(content);\n            printer.println(\"*/\");\n        } else if (comment instanceof LineComment) {\n            printer.print(\"//\");\n            printer.print(content);\n            printer.println();\n        } else {\n            throw new UnsupportedOperationException(comment.getClass().getSimpleName());\n        }\n    }",
        "filePathBefore": "javaparser-core/src/main/java/com/github/javaparser/printer/concretesyntaxmodel/CsmComment.java",
        "isPureRefactoring": true,
        "commitId": "78d0ea5d493f0ab2e83bb70d7023b670bfa2f7b6",
        "packageNameBefore": "com.github.javaparser.printer.concretesyntaxmodel",
        "classNameBefore": "com.github.javaparser.printer.concretesyntaxmodel.CsmComment",
        "methodNameBefore": "com.github.javaparser.printer.concretesyntaxmodel.CsmComment#process",
        "invokedMethod": "methodSignature: com.github.javaparser.ast.comments.Comment#getContent\n methodBody: public String getContent() {\nreturn content;\n}\nmethodSignature: com.github.javaparser.printer.lexicalpreservation.LexicalPreservingPrinter#print\n methodBody: public static String print(Node node) {\nLexicalPreservingVisitor visitor=new LexicalPreservingVisitor();\nfinal NodeText nodeText=getOrCreateNodeText(node);\nnodeText.getElements().forEach(element -> element.accept(visitor));\nreturn visitor.toString();\n}",
        "classSignatureBefore": "public class CsmComment implements CsmElement ",
        "methodNameBeforeSet": [
            "com.github.javaparser.printer.concretesyntaxmodel.CsmComment#process"
        ],
        "classNameBeforeSet": [
            "com.github.javaparser.printer.concretesyntaxmodel.CsmComment"
        ],
        "classSignatureBeforeSet": [
            "public class CsmComment implements CsmElement "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "",
                "description": "Argument replaced with return expression - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Copyright (C) 2007-2010 J\u00falio Vilmar Gesser.\n * Copyright (C) 2011, 2013-2023 The JavaParser Team.\n *\n * This file is part of JavaParser.\n *\n * JavaParser can be used either under the terms of\n * a) the GNU Lesser General Public License as published by\n *     the Free Software Foundation, either version 3 of the License, or\n *     (at your option) any later version.\n * b) the terms of the Apache License\n *\n * You should have received a copy of both licenses in LICENCE.LGPL and\n * LICENCE.APACHE. Please refer to those files for details.\n *\n * JavaParser is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n */\npackage com.github.javaparser.printer.concretesyntaxmodel;\n\nimport com.github.javaparser.ast.Node;\nimport com.github.javaparser.ast.comments.BlockComment;\nimport com.github.javaparser.ast.comments.Comment;\nimport com.github.javaparser.ast.comments.JavadocComment;\nimport com.github.javaparser.ast.comments.LineComment;\nimport com.github.javaparser.printer.SourcePrinter;\n\npublic class CsmComment implements CsmElement {\n\n    static void process(Comment comment, SourcePrinter printer) {\n        String content = printer.normalizeEolInTextBlock(comment.getContent());\n        if (comment instanceof BlockComment) {\n            printer.print(\"/*\");\n            printer.print(content);\n            printer.println(\"*/\");\n        } else if (comment instanceof JavadocComment) {\n            printer.print(\"/**\");\n            printer.print(content);\n            printer.println(\"*/\");\n        } else if (comment instanceof LineComment) {\n            printer.print(\"//\");\n            printer.print(content);\n            printer.println();\n        } else {\n            throw new UnsupportedOperationException(comment.getClass().getSimpleName());\n        }\n    }\n\n    @Override\n    public void prettyPrint(Node node, SourcePrinter printer) {\n        node.getComment().ifPresent(c -> process(c, printer));\n    }\n}\n",
        "filePathAfter": "javaparser-core/src/main/java/com/github/javaparser/printer/concretesyntaxmodel/CsmComment.java",
        "sourceCodeAfterForWhole": "/*\n * Copyright (C) 2007-2010 J\u00falio Vilmar Gesser.\n * Copyright (C) 2011, 2013-2023 The JavaParser Team.\n *\n * This file is part of JavaParser.\n *\n * JavaParser can be used either under the terms of\n * a) the GNU Lesser General Public License as published by\n *     the Free Software Foundation, either version 3 of the License, or\n *     (at your option) any later version.\n * b) the terms of the Apache License\n *\n * You should have received a copy of both licenses in LICENCE.LGPL and\n * LICENCE.APACHE. Please refer to those files for details.\n *\n * JavaParser is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n */\npackage com.github.javaparser.printer.concretesyntaxmodel;\n\nimport com.github.javaparser.ast.Node;\nimport com.github.javaparser.ast.comments.Comment;\nimport com.github.javaparser.printer.SourcePrinter;\n\npublic class CsmComment implements CsmElement {\n\n    static void process(Comment comment, SourcePrinter printer) {\n        String content = printer.normalizeEolInTextBlock(comment.getContent());\n\t\tprinter.print(comment.getHeader());\n\t\tprinter.print(content);\n\t\tprinter.println(comment.getFooter());\n    }\n\n    @Override\n    public void prettyPrint(Node node, SourcePrinter printer) {\n        node.getComment().ifPresent(c -> process(c, printer));\n    }\n}\n",
        "diffSourceCodeSet": [
            ""
        ],
        "invokedMethodSet": [
            "methodSignature: com.github.javaparser.ast.comments.Comment#getContent\n methodBody: public String getContent() {\nreturn content;\n}",
            "methodSignature: com.github.javaparser.printer.lexicalpreservation.LexicalPreservingPrinter#print\n methodBody: public static String print(Node node) {\nLexicalPreservingVisitor visitor=new LexicalPreservingVisitor();\nfinal NodeText nodeText=getOrCreateNodeText(node);\nnodeText.getElements().forEach(element -> element.accept(visitor));\nreturn visitor.toString();\n}"
        ],
        "sourceCodeAfterRefactoring": "static void process(Comment comment, SourcePrinter printer) {\n        String content = printer.normalizeEolInTextBlock(comment.getContent());\n\t\tprinter.print(comment.getHeader());\n\t\tprinter.print(content);\n\t\tprinter.println(comment.getFooter());\n    }\n",
        "diffSourceCode": "-   29: \n-   30: public class CsmComment implements CsmElement {\n-   31: \n-   32:     static void process(Comment comment, SourcePrinter printer) {\n-   33:         String content = printer.normalizeEolInTextBlock(comment.getContent());\n-   34:         if (comment instanceof BlockComment) {\n-   35:             printer.print(\"/*\");\n-   36:             printer.print(content);\n-   37:             printer.println(\"*/\");\n-   38:         } else if (comment instanceof JavadocComment) {\n-   39:             printer.print(\"/**\");\n-   40:             printer.print(content);\n-   41:             printer.println(\"*/\");\n-   42:         } else if (comment instanceof LineComment) {\n-   43:             printer.print(\"//\");\n-   44:             printer.print(content);\n-   45:             printer.println();\n-   46:         } else {\n-   47:             throw new UnsupportedOperationException(comment.getClass().getSimpleName());\n-   48:         }\n-   49:     }\n+   29:     static void process(Comment comment, SourcePrinter printer) {\n+   30:         String content = printer.normalizeEolInTextBlock(comment.getContent());\n+   31: \t\tprinter.print(comment.getHeader());\n+   32: \t\tprinter.print(content);\n+   33: \t\tprinter.println(comment.getFooter());\n+   34:     }\n+   35: \n+   36:     @Override\n+   37:     public void prettyPrint(Node node, SourcePrinter printer) {\n+   38:         node.getComment().ifPresent(c -> process(c, printer));\n+   39:     }\n+   40: }\n",
        "uniqueId": "78d0ea5d493f0ab2e83bb70d7023b670bfa2f7b6_32_49_120_123_29_34",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 7,
                "covered": 53
            },
            "BRANCH": {
                "missed": 1,
                "covered": 5
            },
            "LINE": {
                "missed": 1,
                "covered": 14
            },
            "COMPLEXITY": {
                "missed": 1,
                "covered": 3
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 17
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprivate considerIndentation(nodeText NodeText, nodeTextIndex int, numberOfCharactersToPreserve int) : int extracted from private considerEnforcingIndentation(nodeText NodeText, nodeTextIndex int) : int in class com.github.javaparser.printer.lexicalpreservation.Difference",
        "diffLocations": [
            {
                "filePath": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Difference.java",
                "startLine": 185,
                "endLine": 214,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Difference.java",
                "startLine": 185,
                "endLine": 202,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Difference.java",
                "startLine": 208,
                "endLine": 222,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "/**\n     * If we are at the beginning of a line, with just spaces or tabs before/after the position of the deleted element\n     * we should force the space to be the same as the current indentation.\n     * This method handles the following case if we remove the modifier {@code public} ([ ] is an indent character)\n     * {@code \n     * [ ][ ]public[ ][ ][ ]void[ ]m{}\n     * <-1-->      <---2--->\n     * 1/ current indentation\n     * 2/ these whitespaces must be removed\n     * }\n     * should produce\n     * {@code \n     * [ ][ ]void[ ]m{} \n     * }\n     */\n    private int considerEnforcingIndentation(NodeText nodeText, int nodeTextIndex) {\n        EnforcingIndentationContext enforcingIndentationContext = defineEnforcingIndentationContext(nodeText, nodeTextIndex);\n        // the next position in the list (by default the current position)\n        int res = nodeTextIndex;\n        if (enforcingIndentationContext.extraCharacters > 0) {\n        \tint extraCharacters = enforcingIndentationContext.extraCharacters > indentation.size() ? enforcingIndentationContext.extraCharacters - indentation.size() : 0;\n            res = removeExtraCharacters(nodeText, enforcingIndentationContext.start, extraCharacters);\n            // The next position must take into account the indentation\n            res = extraCharacters > 0 ? res + indentation.size() : res;\n        }\n        if (res < 0) {\n            throw new IllegalStateException();\n        }\n        return res;\n    }",
        "filePathBefore": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Difference.java",
        "isPureRefactoring": true,
        "commitId": "ca3ca0cbd889d07977095289d24591f282157bd8",
        "packageNameBefore": "com.github.javaparser.printer.lexicalpreservation",
        "classNameBefore": "com.github.javaparser.printer.lexicalpreservation.Difference",
        "methodNameBefore": "com.github.javaparser.printer.lexicalpreservation.Difference#considerEnforcingIndentation",
        "invokedMethod": "methodSignature: com.github.javaparser.printer.lexicalpreservation.Difference#defineEnforcingIndentationContext\n methodBody: private EnforcingIndentationContext defineEnforcingIndentationContext(NodeText nodeText, int nodeTextIndex) {\nEnforcingIndentationContext ctx=new EnforcingIndentationContext(nodeTextIndex);\nif(nodeTextIndex < nodeText.numberOfElements()){for(int i=nodeTextIndex; i >= 0 && i < nodeText.numberOfElements(); i--){if(nodeText.getTextElement(i).isNewline()){break;\n}if(!nodeText.getTextElement(i).isSpaceOrTab()){ctx=new EnforcingIndentationContext(nodeTextIndex);\nbreak;\n}ctx.start=i;\nctx.extraCharacters++;\n}if(nodeText.getTextElement(nodeTextIndex).isSpaceOrTab()){for(int i=nodeTextIndex + 1; i >= 0 && i < nodeText.numberOfElements(); i++){if(!nodeText.getTextElement(i).isSpaceOrTab()){break;\n}ctx.extraCharacters++;\n}}}return ctx;\n}\nmethodSignature: com.github.javaparser.printer.lexicalpreservation.Difference#removeExtraCharacters\n methodBody: private int removeExtraCharacters(NodeText nodeText, int nodeTextIndex, int extraCharacters) {\nint pos=nodeTextIndex;\nint count=0;\nfor(int i=nodeTextIndex; i >= 0 && i < nodeText.numberOfElements() && count < extraCharacters; i++){if(nodeText.getTextElement(i).isNewline()){break;\n}nodeText.removeElement(pos);\ncount++;\n}return pos;\n}",
        "classSignatureBefore": "public class Difference ",
        "methodNameBeforeSet": [
            "com.github.javaparser.printer.lexicalpreservation.Difference#considerEnforcingIndentation"
        ],
        "classNameBeforeSet": [
            "com.github.javaparser.printer.lexicalpreservation.Difference"
        ],
        "classSignatureBeforeSet": [
            "public class Difference "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Changes are within the Extract Method refactoring mechanics",
                "description": "All the mappings are matched! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Copyright (C) 2007-2010 J\u00falio Vilmar Gesser.\n * Copyright (C) 2011, 2013-2021 The JavaParser Team.\n *\n * This file is part of JavaParser.\n *\n * JavaParser can be used either under the terms of\n * a) the GNU Lesser General Public License as published by\n *     the Free Software Foundation, either version 3 of the License, or\n *     (at your option) any later version.\n * b) the terms of the Apache License\n *\n * You should have received a copy of both licenses in LICENCE.LGPL and\n * LICENCE.APACHE. Please refer to those files for details.\n *\n * JavaParser is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n */\npackage com.github.javaparser.printer.lexicalpreservation;\n\nimport com.github.javaparser.GeneratedJavaParserConstants;\nimport com.github.javaparser.JavaToken;\nimport com.github.javaparser.JavaToken.Kind;\nimport com.github.javaparser.TokenTypes;\nimport com.github.javaparser.ast.Node;\nimport com.github.javaparser.ast.NodeList;\nimport com.github.javaparser.ast.comments.Comment;\nimport com.github.javaparser.ast.nodeTypes.NodeWithTypeArguments;\nimport com.github.javaparser.ast.type.ArrayType;\nimport com.github.javaparser.ast.type.ClassOrInterfaceType;\nimport com.github.javaparser.ast.type.Type;\nimport com.github.javaparser.printer.concretesyntaxmodel.*;\nimport com.github.javaparser.printer.lexicalpreservation.LexicalDifferenceCalculator.CsmChild;\n\nimport java.util.*;\n\nimport static com.github.javaparser.GeneratedJavaParserConstants.*;\n\n/**\n * A Difference should give me a sequence of elements I should find (to indicate the context) followed by a list of elements\n * to remove or to add and follow by another sequence of elements.\n *\n * I should later be able to apply such difference to a nodeText.\n */\npublic class Difference {\n\n    public static final int STANDARD_INDENTATION_SIZE = 4;\n\n    private final NodeText nodeText;\n\n    private final Node node;\n\n    private final List<DifferenceElement> diffElements;\n\n    private final List<TextElement> originalElements;\n\n    private int originalIndex = 0;\n\n    private int diffIndex = 0;\n\n    private final List<TokenTextElement> indentation;\n\n    private boolean addedIndentation = false;\n\n    Difference(List<DifferenceElement> diffElements, NodeText nodeText, Node node) {\n        if (nodeText == null) {\n            throw new NullPointerException(\"nodeText can not be null\");\n        }\n        this.nodeText = nodeText;\n        this.node = node;\n        this.diffElements = diffElements;\n        this.originalElements = nodeText.getElements();\n        this.indentation = LexicalPreservingPrinter.findIndentation(node);\n    }\n\n    /*\n     * Returns the indentation used after the last line break\n     */\n    private List<TextElement> processIndentation(List<TokenTextElement> indentation, List<TextElement> prevElements) {\n        List<TextElement> res = new LinkedList<>(indentation);\n        int index = lastIndexOfEol(prevElements);\n        // no EOL found\n        if (index < 0)\n            return res;\n        // initialize previous indentation\n        res.clear();\n        // search for consecutive space characters\n        for (int i = (index + 1); i < prevElements.size(); i++) {\n            TextElement elem = prevElements.get(i);\n            if (elem.isWhiteSpace()) {\n                res.add(elem);\n                continue;\n            }\n            break;\n        }\n        return res;\n    }\n    \n    /*\n     * Returns the position of the next element in the list starting from @{code fromIndex} which is a comment (Ignoring spaces)\n     * or -1 if it's not a comment.\n     */\n    private int posOfNextComment(int fromIndex, List<TextElement> elements) {\n        if (!isValidIndex(fromIndex, elements))\n            return -1;\n        ReadOnlyListIterator<TextElement> iterator = new ReadOnlyListIterator(elements, fromIndex);\n        // search for the next consecutive space characters\n        while (iterator.hasNext()) {\n            TextElement element = iterator.next();\n            if (element.isSpaceOrTab()) {\n                continue;\n            }\n            if (element.isComment()) {\n            \treturn iterator.index();\n            }\n            break;\n        }\n        return -1;\n    }\n    \n    /*\n     * Returns true if the next element in the list (starting from @{code fromIndex}) is a comment\n     */\n    private boolean isFollowedByComment(int fromIndex, List<TextElement> elements) {\n    \treturn posOfNextComment(fromIndex, elements) != -1;\n    }\n    \n    /*\n     * Removes all elements in the list starting from @{code fromIndex}) ending to @{code toIndex})\n     */\n    private void removeElements(int fromIndex, int toIndex, List<TextElement> elements) {\n    \tif (!(isValidIndex(fromIndex, elements) && isValidIndex(toIndex, elements) && fromIndex <= toIndex))\n            return;\n        ListIterator<TextElement> iterator = elements.listIterator(fromIndex);\n        // removing elements\n        int count = fromIndex;\n        while (iterator.hasNext() && count <= toIndex) {\n        \tTextElement element = iterator.next();\n            iterator.remove();\n            count++;\n        }\n    }\n    \n    private boolean isValidIndex(int index, List<?> elements) {\n    \treturn index >= 0 && index <= elements.size();\n    }\n\n    /*\n     * Returns the position of the last new line character or -1 if there is no eol in the specified list of TextElement \n     */\n    int lastIndexOfEol(List<TextElement> source) {\n        ListIterator listIterator = source.listIterator(source.size());\n        int lastIndex = source.size() - 1;\n        while (listIterator.hasPrevious()) {\n            TextElement elem = (TextElement) listIterator.previous();\n            if (elem.isNewline()) {\n                return lastIndex;\n            }\n            lastIndex--;\n        }\n        return -1;\n    }\n\n    private List<TextElement> indentationBlock() {\n        List<TextElement> res = new LinkedList<>();\n        res.add(new TokenTextElement(SPACE));\n        res.add(new TokenTextElement(SPACE));\n        res.add(new TokenTextElement(SPACE));\n        res.add(new TokenTextElement(SPACE));\n        return res;\n    }\n\n    private boolean isAfterLBrace(NodeText nodeText, int nodeTextIndex) {\n        if (nodeTextIndex > 0 && nodeText.getTextElement(nodeTextIndex - 1).isToken(LBRACE)) {\n            return true;\n        }\n        if (nodeTextIndex > 0 && nodeText.getTextElement(nodeTextIndex - 1).isSpaceOrTab()) {\n            return isAfterLBrace(nodeText, nodeTextIndex - 1);\n        }\n        return false;\n    }\n\n    /**\n     * If we are at the beginning of a line, with just spaces or tabs before/after the position of the deleted element\n     * we should force the space to be the same as the current indentation.\n     * This method handles the following case if we remove the modifier {@code public} ([ ] is an indent character)\n     * {@code \n     * [ ][ ]public[ ][ ][ ]void[ ]m{}\n     * <-1-->      <---2--->\n     * 1/ current indentation\n     * 2/ these whitespaces must be removed\n     * }\n     * should produce\n     * {@code \n     * [ ][ ]void[ ]m{} \n     * }\n     */\n    private int considerEnforcingIndentation(NodeText nodeText, int nodeTextIndex) {\n        EnforcingIndentationContext enforcingIndentationContext = defineEnforcingIndentationContext(nodeText, nodeTextIndex);\n        // the next position in the list (by default the current position)\n        int res = nodeTextIndex;\n        if (enforcingIndentationContext.extraCharacters > 0) {\n        \tint extraCharacters = enforcingIndentationContext.extraCharacters > indentation.size() ? enforcingIndentationContext.extraCharacters - indentation.size() : 0;\n            res = removeExtraCharacters(nodeText, enforcingIndentationContext.start, extraCharacters);\n            // The next position must take into account the indentation\n            res = extraCharacters > 0 ? res + indentation.size() : res;\n        }\n        if (res < 0) {\n            throw new IllegalStateException();\n        }\n        return res;\n    }\n    \n    /*\n     * This data structure class hold the starting position of the first whitespace char \n     * and the number of consecutive whitespace (or tab) characters\n     */\n    private class EnforcingIndentationContext {\n    \tint start;\n    \tint extraCharacters;\n    \tpublic EnforcingIndentationContext(int start) {\n    \t\tthis.start=start;\n    \t\tthis.extraCharacters=0;\n    \t}\n    }\n\n    /**\n     * Remove excess white space after deleting element.\n     * @param nodeText Contains a list of elements to analyze\n     * @param nodeTextIndex Starting position in the input list\n     * @return The current position in the list of the elements\n     */\n    private int removeExtraCharacters(NodeText nodeText, int nodeTextIndex, int extraCharacters) {\n        int pos = nodeTextIndex;\n        int count = 0;\n        for (int i = nodeTextIndex; i >= 0 && i < nodeText.numberOfElements() && count < extraCharacters; i++) {\n            if (nodeText.getTextElement(i).isNewline()) {\n                break;\n            }\n            nodeText.removeElement(pos);\n            count++;\n        }\n        return pos;\n    }\n\n    /**\n     * Starting at {@code nodeTextIndex} this method tries to determine how many contiguous spaces there are between \n     * the previous end of line and the next non whitespace (or tab) character\n     * @param nodeText List of elements to analyze\n     * @param nodeTextIndex Starting position in the input list\n     * @return EnforcingIndentationContext Data structure that hold the starting position of the first whitespace char and\n     * The number of consecutive whitespace (or tab) characters\n     */\n    private EnforcingIndentationContext defineEnforcingIndentationContext(NodeText nodeText, int nodeTextIndex) {\n    \tEnforcingIndentationContext ctx = new EnforcingIndentationContext(nodeTextIndex);\n    \t// compute space before nodeTextIndex value\n\t\tif (nodeTextIndex < nodeText.numberOfElements()) {\n\t\t\tfor (int i = nodeTextIndex; i >= 0 && i < nodeText.numberOfElements(); i--) {\n\t\t\t\tif (nodeText.getTextElement(i).isNewline()) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (!nodeText.getTextElement(i).isSpaceOrTab()) {\n\t\t\t\t\tctx = new EnforcingIndentationContext(nodeTextIndex);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tctx.start = i;\n\t\t\t\tctx.extraCharacters++;\n\t\t\t}\n\t\t\t// compute space after nodeTextIndex value\n\t\t\tif (nodeText.getTextElement(nodeTextIndex).isSpaceOrTab()) {\n\t\t\t\tfor (int i = nodeTextIndex + 1; i >= 0 && i < nodeText.numberOfElements(); i++) {\n\t\t\t\t\tif (!nodeText.getTextElement(i).isSpaceOrTab()) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tctx.extraCharacters++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n        \n        return ctx;\n    }\n\n    /**\n     * Node that we have calculate the Difference we can apply to a concrete NodeText, modifying it according\n     * to the difference (adding and removing the elements provided).\n     */\n    void apply() {\n        extractReshuffledDiffElements(diffElements);\n        Map<Removed, RemovedGroup> removedGroups = combineRemovedElementsToRemovedGroups();\n        do {\n            boolean isLeftOverDiffElement = applyLeftOverDiffElements();\n            boolean isLeftOverOriginalElement = applyLeftOverOriginalElements();\n            if (!isLeftOverDiffElement && !isLeftOverOriginalElement) {\n                DifferenceElement diffElement = diffElements.get(diffIndex);\n                if (diffElement.isAdded()) {\n                    applyAddedDiffElement((Added) diffElement);\n                } else {\n                    TextElement originalElement = originalElements.get(originalIndex);\n                    boolean originalElementIsChild = originalElement instanceof ChildTextElement;\n                    boolean originalElementIsToken = originalElement instanceof TokenTextElement;\n                    if (diffElement.isKept()) {\n                        applyKeptDiffElement((Kept) diffElement, originalElement, originalElementIsChild, originalElementIsToken);\n                    } else if (diffElement.isRemoved()) {\n                        Removed removed = (Removed) diffElement;\n                        applyRemovedDiffElement(removedGroups.get(removed), removed, originalElement, originalElementIsChild, originalElementIsToken);\n                    } else {\n                        throw new UnsupportedOperationException(\"\" + diffElement + \" vs \" + originalElement);\n                    }\n                }\n            }\n        } while (diffIndex < diffElements.size() || originalIndex < originalElements.size());\n    }\n\n    private boolean applyLeftOverOriginalElements() {\n        boolean isLeftOverElement = false;\n        if (diffIndex >= diffElements.size() && originalIndex < originalElements.size()) {\n            TextElement originalElement = originalElements.get(originalIndex);\n            if (originalElement.isWhiteSpaceOrComment()) {\n                originalIndex++;\n            } else {\n                throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \" + this + \" \" + originalElement);\n            }\n            isLeftOverElement = true;\n        }\n        return isLeftOverElement;\n    }\n\n    private boolean applyLeftOverDiffElements() {\n        boolean isLeftOverElement = false;\n        if (diffIndex < diffElements.size() && originalIndex >= originalElements.size()) {\n            DifferenceElement diffElement = diffElements.get(diffIndex);\n            if (diffElement.isKept()) {\n                diffIndex++;\n            } else if (diffElement.isAdded()) {\n                Added addedElement = (Added) diffElement;\n                nodeText.addElement(originalIndex, addedElement.toTextElement());\n                originalIndex++;\n                diffIndex++;\n            } else {\n                // let's forget this element\n                diffIndex++;\n            }\n            isLeftOverElement = true;\n        }\n        return isLeftOverElement;\n    }\n\n    private void extractReshuffledDiffElements(List<DifferenceElement> diffElements) {\n        for (int index = 0; index < diffElements.size(); index++) {\n            DifferenceElement diffElement = diffElements.get(index);\n            if (diffElement instanceof Reshuffled) {\n                Reshuffled reshuffled = (Reshuffled) diffElement;\n                // First, let's see how many tokens we need to attribute to the previous version of the of the CsmMix\n                CsmMix elementsFromPreviousOrder = reshuffled.getPreviousOrder();\n                CsmMix elementsFromNextOrder = reshuffled.getNextOrder();\n                // This contains indexes from elementsFromNextOrder to indexes from elementsFromPreviousOrder\n                Map<Integer, Integer> correspondanceBetweenNextOrderAndPreviousOrder = getCorrespondanceBetweenNextOrderAndPreviousOrder(elementsFromPreviousOrder, elementsFromNextOrder);\n                // We now find out which Node Text elements corresponds to the elements in the original CSM\n                List<Integer> nodeTextIndexOfPreviousElements = findIndexOfCorrespondingNodeTextElement(elementsFromPreviousOrder.getElements(), nodeText, originalIndex, node);\n                Map<Integer, Integer> nodeTextIndexToPreviousCSMIndex = new HashMap<>();\n                for (int i = 0; i < nodeTextIndexOfPreviousElements.size(); i++) {\n                    int value = nodeTextIndexOfPreviousElements.get(i);\n                    if (value != -1) {\n                        nodeTextIndexToPreviousCSMIndex.put(value, i);\n                    }\n                }\n                int lastNodeTextIndex = nodeTextIndexOfPreviousElements.stream().max(Integer::compareTo).orElse(-1);\n                // Elements to be added at the end\n                List<CsmElement> elementsToBeAddedAtTheEnd = new LinkedList<>();\n                List<CsmElement> nextOrderElements = elementsFromNextOrder.getElements();\n                Map<Integer, List<CsmElement>> elementsToAddBeforeGivenOriginalCSMElement = new HashMap<>();\n                for (int ni = 0; ni < nextOrderElements.size(); ni++) {\n                    // If it has a mapping, then it is kept\n                    if (!correspondanceBetweenNextOrderAndPreviousOrder.containsKey(ni)) {\n                        // Ok, it is something new. Where to put it? Let's see what is the first following\n                        // element that has a mapping\n                        int originalCsmIndex = -1;\n                        for (int nj = ni + 1; nj < nextOrderElements.size() && originalCsmIndex == -1; nj++) {\n                            if (correspondanceBetweenNextOrderAndPreviousOrder.containsKey(nj)) {\n                                originalCsmIndex = correspondanceBetweenNextOrderAndPreviousOrder.get(nj);\n                                if (!elementsToAddBeforeGivenOriginalCSMElement.containsKey(originalCsmIndex)) {\n                                    elementsToAddBeforeGivenOriginalCSMElement.put(originalCsmIndex, new LinkedList<>());\n                                }\n                                elementsToAddBeforeGivenOriginalCSMElement.get(originalCsmIndex).add(nextOrderElements.get(ni));\n                            }\n                        }\n                        // it does not preceed anything, so it goes at the end\n                        if (originalCsmIndex == -1) {\n                            elementsToBeAddedAtTheEnd.add(nextOrderElements.get(ni));\n                        }\n                    }\n                }\n                // We go over the original node text elements, in the order they appear in the NodeText.\n                // Considering an original node text element (ONE)\n                // * we verify if it corresponds to a CSM element. If it does not we just move on, otherwise\n                // we find the correspond OCE (Original CSM Element)\n                // * we first add new elements that are marked to be added before OCE\n                // * if OCE is marked to be present also in the \"after\" CSM we add a kept element,\n                // otherwise we add a removed element\n                // Remove the whole Reshuffled element\n                diffElements.remove(index);\n                int diffElIterator = index;\n                if (lastNodeTextIndex != -1) {\n                    for (int ntIndex = originalIndex; ntIndex <= lastNodeTextIndex; ntIndex++) {\n                        if (nodeTextIndexToPreviousCSMIndex.containsKey(ntIndex)) {\n                            int indexOfOriginalCSMElement = nodeTextIndexToPreviousCSMIndex.get(ntIndex);\n                            if (elementsToAddBeforeGivenOriginalCSMElement.containsKey(indexOfOriginalCSMElement)) {\n                                for (CsmElement elementToAdd : elementsToAddBeforeGivenOriginalCSMElement.get(indexOfOriginalCSMElement)) {\n                                    diffElements.add(diffElIterator++, new Added(elementToAdd));\n                                }\n                            }\n                            CsmElement originalCSMElement = elementsFromPreviousOrder.getElements().get(indexOfOriginalCSMElement);\n                            boolean toBeKept = correspondanceBetweenNextOrderAndPreviousOrder.containsValue(indexOfOriginalCSMElement);\n                            if (toBeKept) {\n                                diffElements.add(diffElIterator++, new Kept(originalCSMElement));\n                            } else {\n                                diffElements.add(diffElIterator++, new Removed(originalCSMElement));\n                            }\n                        }\n                        // else we have a simple node text element, without associated csm element, just keep ignore it\n                    }\n                }\n                // Finally we look for the remaining new elements that were not yet added and\n                // add all of them\n                for (CsmElement elementToAdd : elementsToBeAddedAtTheEnd) {\n                    diffElements.add(diffElIterator++, new Added(elementToAdd));\n                }\n            }\n        }\n    }\n\n    /**\n     * Maps all Removed elements as keys to their corresponding RemovedGroup.\n     * A RemovedGroup contains all consecutive Removed elements.\n     * <br>\n     * Example:\n     * <pre>\n     * Elements: Kept|Removed1|Removed2|Kept|Removed3|Added|Removed4\n     * Groups:        <----Group1---->       Group2         Group3\n     * Keys:          Removed1+Removed2      Removed3       Removed4\n     * </pre>\n     *\n     * @return Map with all Removed elements as keys to their corresponding RemovedGroup\n     */\n    private Map<Removed, RemovedGroup> combineRemovedElementsToRemovedGroups() {\n        Map<Integer, List<Removed>> removedElementsMap = groupConsecutiveRemovedElements();\n        List<RemovedGroup> removedGroups = new ArrayList<>();\n        for (Map.Entry<Integer, List<Removed>> entry : removedElementsMap.entrySet()) {\n            removedGroups.add(RemovedGroup.of(entry.getKey(), entry.getValue()));\n        }\n        Map<Removed, RemovedGroup> map = new HashMap<>();\n        for (RemovedGroup removedGroup : removedGroups) {\n            for (Removed index : removedGroup) {\n                map.put(index, removedGroup);\n            }\n        }\n        return map;\n    }\n\n    private Map<Integer, List<Removed>> groupConsecutiveRemovedElements() {\n        Map<Integer, List<Removed>> removedElementsMap = new HashMap<>();\n        Integer firstElement = null;\n        for (int i = 0; i < diffElements.size(); i++) {\n            DifferenceElement diffElement = diffElements.get(i);\n            if (diffElement.isRemoved()) {\n                if (firstElement == null) {\n                    firstElement = i;\n                }\n                removedElementsMap.computeIfAbsent(firstElement, key -> new ArrayList<>()).add((Removed) diffElement);\n            } else {\n                firstElement = null;\n            }\n        }\n        return removedElementsMap;\n    }\n\n    private void applyRemovedDiffElement(RemovedGroup removedGroup, Removed removed, TextElement originalElement, boolean originalElementIsChild, boolean originalElementIsToken) {\n        if (removed.isChild() && originalElementIsChild) {\n            ChildTextElement originalElementChild = (ChildTextElement) originalElement;\n            if (originalElementChild.isComment()) {\n                // We expected to remove a proper node but we found a comment in between.\n                // If the comment is associated to the node we want to remove we remove it as well, otherwise we keep it\n                Comment comment = (Comment) originalElementChild.getChild();\n                if (!comment.isOrphan() && comment.getCommentedNode().isPresent() && comment.getCommentedNode().get().equals(removed.getChild())) {\n                    nodeText.removeElement(originalIndex);\n                } else {\n                    originalIndex++;\n                }\n            } else {\n                nodeText.removeElement(originalIndex);\n                // When we don't try to remove a complete line \n                // and removing the element is not the first action of a replacement (removal followed by addition)\n                // (in the latter case we keep the indentation)\n                // then we want to enforce the indentation.\n                if ((diffIndex + 1 >= diffElements.size() || !(diffElements.get(diffIndex + 1).isAdded())) \n                \t\t&& !removedGroup.isACompleteLine()) {\n                    originalIndex = considerEnforcingIndentation(nodeText, originalIndex);\n                }\n                // If in front we have one space and before also we had space let's drop one space\n                if (originalElements.size() > originalIndex && originalIndex > 0) {\n                    if (originalElements.get(originalIndex).isWhiteSpace() && originalElements.get(originalIndex - 1).isWhiteSpace()) {\n                        // However we do not want to do that when we are about to adding or removing elements\n                        // The intention is not very clear maybe it should clarify this with examples!\n                        // Are we to understand that we can only do this if there is a single modification to process\n                        // OR or if the next change is to keep the element\n                        if ((diffIndex + 1) == diffElements.size() || (diffElements.get(diffIndex + 1).isKept())) {\n                            originalElements.remove(originalIndex--);\n                        }\n                    }\n                }\n                // We need to know if, in the original list of elements, the deleted child node is immediately followed by a comment.\n                // If so, it should also be deleted.\n                if (isFollowedByComment(originalIndex, originalElements)) {\n                \tint indexOfNextComment = posOfNextComment(originalIndex, originalElements);\n                \tremoveElements(originalIndex, indexOfNextComment, originalElements);\n                }\n                diffIndex++;\n            }\n        } else if (removed.isToken() && originalElementIsToken && (removed.getTokenType() == ((TokenTextElement) originalElement).getTokenKind() || // handle EOLs separately as their token kind might not be equal. This is because the 'removed'\n        // element always has the current operating system's EOL as type\n        (((TokenTextElement) originalElement).getToken().getCategory().isEndOfLine() && removed.isNewLine()))) {\n            nodeText.removeElement(originalIndex);\n            diffIndex++;\n        } else if (originalElementIsToken && originalElement.isWhiteSpaceOrComment()) {\n            originalIndex++;\n            // skip the newline token which may be generated unnecessarily by the concrete syntax pattern\n            if (removed.isNewLine()) { \n            \tdiffIndex++;\n            }\n        } else if (originalElement.isLiteral()) {\n            nodeText.removeElement(originalIndex);\n            diffIndex++;\n        } else if (removed.isPrimitiveType()) {\n            if (originalElement.isPrimitive()) {\n                nodeText.removeElement(originalIndex);\n                diffIndex++;\n            } else {\n                throw new UnsupportedOperationException(\"removed \" + removed.getElement() + \" vs \" + originalElement);\n            }\n        } else if (removed.isWhiteSpace() || removed.getElement() instanceof CsmIndent || removed.getElement() instanceof CsmUnindent) {\n            diffIndex++;\n        } else if (originalElement.isWhiteSpace()) {\n            originalIndex++;\n        } else if (removed.isChild()) {\n            // see issue #3721 this case is linked for example to a change of type of variable declarator\n            nodeText.removeElement(originalIndex);\n            diffIndex++;\n        } else {\n            throw new UnsupportedOperationException(\"removed \" + removed.getElement() + \" vs \" + originalElement);\n        }\n        cleanTheLineOfLeftOverSpace(removedGroup, removed);\n    }\n\n    /**\n     * Cleans the line of left over space if there is unnecessary indentation and the element will not be replaced\n     */\n    private void cleanTheLineOfLeftOverSpace(RemovedGroup removedGroup, Removed removed) {\n        if (originalIndex >= originalElements.size()) {\n            // if all elements were already processed there is nothing to do\n            return;\n        }\n        if (!removedGroup.isProcessed() && removedGroup.getLastElement() == removed && removedGroup.isACompleteLine()) {\n            Integer lastElementIndex = removedGroup.getLastElementIndex();\n            Optional<Integer> indentation = removedGroup.getIndentation();\n            if (indentation.isPresent() && !isReplaced(lastElementIndex)) {\n                for (int i = 0; i < indentation.get(); i++) {\n                    if (originalElements.get(originalIndex).isSpaceOrTab()) {\n                        // If the current element is a space, remove it\n                        nodeText.removeElement(originalIndex);\n                    } else if (originalIndex >= 1 && originalElements.get(originalIndex - 1).isSpaceOrTab()) {\n                        // If the current element is not a space itself we remove the space in front of (before) it\n                        nodeText.removeElement(originalIndex - 1);\n                        originalIndex--;\n                    }\n                    // Remove remaining newline character if needed\n                    if (nodeText.getTextElement(originalIndex).isNewline()) {\n                    \tnodeText.removeElement(originalIndex);\n                    \toriginalIndex = originalIndex > 0 ? originalIndex-- : 0;\n                    }\n                }\n            }\n            // Mark RemovedGroup as processed\n            removedGroup.processed();\n        }\n    }\n\n    // note:\n    // increment originalIndex if we want to keep the original element\n    // increment diffIndex if we want to skip the diff element\n    private void applyKeptDiffElement(Kept kept, TextElement originalElement, boolean originalElementIsChild, boolean originalElementIsToken) {\n\t\tif (originalElement.isComment()) {\n\t\t\toriginalIndex++;\n        } else if (kept.isChild() && ((CsmChild) kept.getElement()).getChild() instanceof Comment) {\n            diffIndex++;\n        } else if (kept.isChild() && originalElementIsChild) {\n            diffIndex++;\n            originalIndex++;\n        } else if (kept.isChild() && originalElementIsToken) {\n            if (originalElement.isWhiteSpaceOrComment()) {\n                originalIndex++;\n            } else if (originalElement.isIdentifier() && isNodeWithTypeArguments(kept)) {\n                diffIndex++;\n                // skip all token related to node with type argument declaration\n                // for example:\n                // List i : in this case originalElement is \"List\" and the next token is space. There is nothing to skip. in the originalElements list.\n                // List<String> i : in this case originalElement is \"List\" and the next token is\n                // \"<\" so we have to skip all the tokens which are used in the typed argument declaration [<][String][>](3 tokens) in the originalElements list.\n                // List<List<String>> i : in this case originalElement is \"List\" and the next\n                // token is \"<\" so we have to skip all the tokens which are used in the typed arguments declaration [<][List][<][String][>][>](6 tokens) in the originalElements list.\n                int step = getIndexToNextTokenElement((TokenTextElement) originalElement, 0);\n                originalIndex += step;\n                originalIndex++;\n            } else if (originalElement.isIdentifier() && isTypeWithFullyQualifiedName(kept)) {\n                diffIndex++;\n                // skip all token related to node with the fully qualified name\n                // for example:\n                // java.lang.Object is represented in originalElement as a list of tokens \"java\", \".\", \"lang\", \".\", \"Object\".\n                // So we have to skip 5 tokens.\n                int step = getIndexToNextTokenElement((TokenTextElement) originalElement, kept);\n                originalIndex += step;\n                // positioning on the next token\n                originalIndex++;\n            } else if ((originalElement.isIdentifier() || originalElement.isKeyword()) && isArrayType(kept)) {\n                int tokenToSkip = getIndexToNextTokenElementInArrayType((TokenTextElement) originalElement, getArrayLevel(kept));\n                diffIndex++;\n                originalIndex += tokenToSkip;\n                originalIndex++;\n            } else if (originalElement.isIdentifier()) {\n                originalIndex++;\n                diffIndex++;\n            } else {\n                if (kept.isPrimitiveType()) {\n                    originalIndex++;\n                    diffIndex++;\n                } else {\n                    throw new UnsupportedOperationException(\"kept \" + kept.getElement() + \" vs \" + originalElement);\n                }\n            }\n        } else if (kept.isToken() && originalElementIsToken) {\n            TokenTextElement originalTextToken = (TokenTextElement) originalElement;\n            if (kept.getTokenType() == originalTextToken.getTokenKind()) {\n                originalIndex++;\n                diffIndex++;\n            } else if (kept.isNewLine() && originalTextToken.isNewline()) {\n                originalIndex++;\n                diffIndex++;\n            } else if (kept.isNewLine() && originalTextToken.isSpaceOrTab()) {\n                originalIndex++;\n            } else if (kept.isWhiteSpaceOrComment()) {\n                diffIndex++;\n            } else if (originalTextToken.isWhiteSpaceOrComment()) {\n                originalIndex++;\n            } else if (!kept.isNewLine() && originalTextToken.isSeparator()) {\n                // case where originalTextToken is a separator like \";\" and\n                // kept is not a new line or whitespace for example \"}\"\n                // see issue 2351\n                originalIndex++;\n            } else {\n                throw new UnsupportedOperationException(\"Csm token \" + kept.getElement() + \" NodeText TOKEN \" + originalTextToken);\n            }\n        } else if (kept.isToken() && originalElementIsChild) {\n            diffIndex++;\n        } else if (kept.isWhiteSpace()) {\n            diffIndex++;\n        } else if (kept.isIndent()) {\n            diffIndex++;\n        } else if (kept.isUnindent()) {\n            // Nothing to do\n            diffIndex++;\n        } else {\n            throw new UnsupportedOperationException(\"kept \" + kept.getElement() + \" vs \" + originalElement);\n        }\n    }\n\n    /*\n     * Returns the array level if the DifferenceElement is a CsmChild representing an ArrayType else 0\n     */\n    private int getArrayLevel(DifferenceElement element) {\n        CsmElement csmElem = element.getElement();\n        if (isArrayType(element)) {\n            Node child = ((LexicalDifferenceCalculator.CsmChild) csmElem).getChild();\n            return ((ArrayType) child).getArrayLevel();\n        }\n        return 0;\n    }\n\n    /*\n     * Returns true if the DifferenceElement is a CsmChild representing an ArrayType\n     */\n    private boolean isArrayType(DifferenceElement element) {\n        CsmElement csmElem = element.getElement();\n        return csmElem instanceof LexicalDifferenceCalculator.CsmChild && ((LexicalDifferenceCalculator.CsmChild) csmElem).getChild() instanceof ArrayType;\n    }\n\n    /*\n     * Returns true if the DifferenceElement is a CsmChild which represents a type with fully qualified name\n     */\n    private boolean isTypeWithFullyQualifiedName(DifferenceElement element) {\n        if (!element.isChild())\n            return false;\n        CsmChild child = (CsmChild) element.getElement();\n        if (!ClassOrInterfaceType.class.isAssignableFrom(child.getChild().getClass()))\n            return false;\n        return ((ClassOrInterfaceType) child.getChild()).getScope().isPresent();\n    }\n\n    /*\n     * Returns true if the DifferenceElement is a CsmChild with type arguments\n     */\n    private boolean isNodeWithTypeArguments(DifferenceElement element) {\n        if (!element.isChild())\n            return false;\n        CsmChild child = (CsmChild) element.getElement();\n        if (!NodeWithTypeArguments.class.isAssignableFrom(child.getChild().getClass()))\n            return false;\n        Optional<NodeList<Type>> typeArgs = ((NodeWithTypeArguments) child.getChild()).getTypeArguments();\n        return typeArgs.isPresent() && typeArgs.get().size() > 0;\n    }\n\n    /*\n     * Try to resolve the number of token to skip in the original list to match \n     * a ClassOrInterfaceType with a list of tokens like \"java\", \".\", \"lang\", \".\", \"Object\"\n     */\n    private int getIndexToNextTokenElement(TokenTextElement element, DifferenceElement kept) {\n        // number of token to skip\n        int step = 0;\n        // verify if the DifferenceElement is a ClassOrInterfaceType with a fully qualified name\n        if (!isTypeWithFullyQualifiedName(kept))\n            return 0;\n        CsmChild child = (CsmChild) kept.getElement();\n        // split the type fully qualified node name to an array of tokens\n        String[] parts = ((ClassOrInterfaceType) child.getChild()).getNameWithScope().split(\"\\\\.\");\n        JavaToken token = element.getToken();\n        for (String part : parts) {\n            if (part.equals(token.asString())) {\n                // get 'dot' token\n                token = token.getNextToken().get();\n                if (!token.asString().equals(\".\"))\n                    break;\n                // get the next part\n                token = token.getNextToken().get();\n                step += 2;\n                continue;\n            }\n            // there is no match so we don't have token to skip\n            step = 0;\n            break;\n        }\n        return step;\n    }\n\n    /*\n     * Returns the number of tokens to skip in originalElements list to synchronize it with the DiffElements list\n     * This is due to the fact that types are considered as token in the originalElements list.\n     * For example,\n     * List<String> is represented by 4 tokens ([List][<][String][>]) while it's a CsmChild element in the DiffElements list\n     * So in this case, getIndexToNextTokenElement(..) on the [List] token returns 3 because we have to skip 3 tokens ([<][String][>]) to synchronize\n     * DiffElements list and originalElements list\n     * The end of recursivity is reached when there is no next token or if the nested diamond operators are totally managed, to take into account this type of declaration\n     * List <List<String>> l\n     * Be careful, this method must be call only if diamond operator could be found in the sequence\n     *\n     * @Param TokenTextElement the token currently analyzed\n     * @Param int the number of nested diamond operators\n     * @return the number of token to skip in originalElements list\n     */\n    private int getIndexToNextTokenElement(TokenTextElement element, int nestedDiamondOperator) {\n        // number of token to skip\n        int step = 0;\n        Optional<JavaToken> next = element.getToken().getNextToken();\n        if (!next.isPresent())\n            return step;\n        // because there is a token, first we need to increment the number of token to skip\n        step++;\n        // manage nested diamond operators by incrementing the level on LT token and decrementing on GT\n        JavaToken nextToken = next.get();\n        Kind kind = Kind.valueOf(nextToken.getKind());\n        if (isDiamondOperator(kind)) {\n            if (kind.GT.equals(kind))\n                nestedDiamondOperator--;\n            else\n                nestedDiamondOperator++;\n        }\n        // manage the fact where the first token is not a diamond operator but a whitespace\n        // and the end of the token sequence to skip\n        // for example in this declaration List <String> a;\n        if (nestedDiamondOperator == 0 && !nextToken.getCategory().isWhitespace())\n            return step;\n        // recursively analyze token to skip\n        return step += getIndexToNextTokenElement(new TokenTextElement(nextToken), nestedDiamondOperator);\n    }\n\n    /*\n     * Returns the number of tokens to skip in originalElements list to synchronize it with the DiffElements list\n     */\n    private int getIndexToNextTokenElementInArrayType(TokenTextElement element, int arrayLevel) {\n        // number of token to skip\n        int step = 0;\n        Optional<JavaToken> next = element.getToken().getNextToken();\n        if (!next.isPresent())\n            return step;\n        // because there is a token, first we need to increment the number of token to skip\n        step++;\n        // manage array Level by decrementing the level on right bracket token\n        JavaToken nextToken = next.get();\n        Kind kind = Kind.valueOf(nextToken.getKind());\n        if (isBracket(kind)) {\n            if (kind.RBRACKET.equals(kind))\n                arrayLevel--;\n        }\n        // manage the fact where the first token is not a diamond operator but a whitespace\n        // and the end of the token sequence to skip\n        // for example in this declaration int [] a;\n        if (arrayLevel == 0 && !nextToken.getCategory().isWhitespace())\n            return step;\n        // recursively analyze token to skip\n        return step += getIndexToNextTokenElementInArrayType(new TokenTextElement(nextToken), arrayLevel);\n    }\n\n    /*\n     * Returns true if the token is possibly a diamond operator\n     */\n    private boolean isDiamondOperator(Kind kind) {\n        return kind.GT.equals(kind) || kind.LT.equals(kind);\n    }\n\n    /*\n     * Returns true if the token is a bracket\n     */\n    private boolean isBracket(Kind kind) {\n        return kind.LBRACKET.equals(kind) || kind.RBRACKET.equals(kind);\n    }\n\n    private boolean openBraceWasOnSameLine() {\n        int index = originalIndex;\n        while (index >= 0 && !nodeText.getTextElement(index).isNewline()) {\n            if (nodeText.getTextElement(index).isToken(LBRACE)) {\n                return true;\n            }\n            index--;\n        }\n        return false;\n    }\n\n    private boolean wasSpaceBetweenBraces() {\n        return nodeText.getTextElement(originalIndex).isToken(RBRACE) && doWeHaveLeftBraceFollowedBySpace(originalIndex - 1) && (diffIndex < 2 || !diffElements.get(diffIndex - 2).isRemoved());\n    }\n\n    private boolean doWeHaveLeftBraceFollowedBySpace(int index) {\n        index = rewindSpace(index);\n        return nodeText.getTextElement(index).isToken(LBRACE);\n    }\n\n    private int rewindSpace(int index) {\n        if (index <= 0) {\n            return index;\n        }\n        if (nodeText.getTextElement(index).isWhiteSpace()) {\n            return rewindSpace(index - 1);\n        } else {\n            return index;\n        }\n    }\n\n    private boolean nextIsRightBrace(int index) {\n        List<TextElement> elements = originalElements.subList(index, originalElements.size());\n        for (TextElement element : elements) {\n            if (!element.isSpaceOrTab()) {\n                return element.isToken(RBRACE);\n            }\n        }\n        return false;\n    }\n\n    private void applyAddedDiffElement(Added added) {\n        if (added.isIndent()) {\n            for (int i = 0; i < STANDARD_INDENTATION_SIZE; i++) {\n                indentation.add(new TokenTextElement(GeneratedJavaParserConstants.SPACE));\n            }\n            addedIndentation = true;\n            diffIndex++;\n            return;\n        }\n        if (added.isUnindent()) {\n            for (int i = 0; i < STANDARD_INDENTATION_SIZE && !indentation.isEmpty(); i++) {\n                indentation.remove(indentation.size() - 1);\n            }\n            addedIndentation = false;\n            diffIndex++;\n            return;\n        }\n        TextElement addedTextElement = added.toTextElement();\n        boolean used = false;\n        boolean isPreviousElementNewline = (originalIndex > 0) && originalElements.get(originalIndex - 1).isNewline();\n        if (isPreviousElementNewline) {\n            List<TextElement> elements = processIndentation(indentation, originalElements.subList(0, originalIndex - 1));\n            boolean nextIsRightBrace = nextIsRightBrace(originalIndex);\n            for (TextElement e : elements) {\n                if (!nextIsRightBrace && e instanceof TokenTextElement && originalElements.get(originalIndex).isToken(((TokenTextElement) e).getTokenKind())) {\n                    originalIndex++;\n                } else {\n                    nodeText.addElement(originalIndex++, e);\n                }\n            }\n        } else if (isAfterLBrace(nodeText, originalIndex) && !isAReplacement(diffIndex)) {\n            if (addedTextElement.isNewline()) {\n                used = true;\n            }\n            nodeText.addElement(originalIndex++, new TokenTextElement(TokenTypes.eolTokenKind()));\n            // This remove the space in \"{ }\" when adding a new line\n            while (originalIndex >= 2 && originalElements.get(originalIndex - 2).isSpaceOrTab()) {\n                originalElements.remove(originalIndex - 2);\n                originalIndex--;\n            }\n            for (TextElement e : processIndentation(indentation, originalElements.subList(0, originalIndex - 1))) {\n                nodeText.addElement(originalIndex++, e);\n            }\n            // Indentation is painful...\n            // Sometimes we want to force indentation: this is the case when indentation was expected but\n            // was actually not there. For example if we have \"{ }\" we would expect indentation but it is\n            // not there, so when adding new elements we force it. However if the indentation has been\n            // inserted by us in this transformation we do not want to insert it again\n            if (!addedIndentation) {\n                for (TextElement e : indentationBlock()) {\n                    nodeText.addElement(originalIndex++, e);\n                }\n            }\n        }\n        if (!used) {\n            // Handling trailing comments\n            boolean sufficientTokensRemainToSkip = nodeText.numberOfElements() > originalIndex + 2;\n            boolean currentIsAComment = nodeText.getTextElement(originalIndex).isComment();\n            boolean previousIsAComment = originalIndex > 0 && nodeText.getTextElement(originalIndex - 1).isComment();\n            boolean currentIsNewline = nodeText.getTextElement(originalIndex).isNewline();\n            boolean isFirstElement = originalIndex == 0;\n            boolean previousIsWhiteSpace = originalIndex > 0 && nodeText.getTextElement(originalIndex - 1).isWhiteSpace();\n\t\t\tboolean commentIsBeforeAddedElement = currentIsAComment && addedTextElement.getRange().isPresent()\n\t\t\t\t\t&& nodeText.getTextElement(originalIndex).getRange()\n\t\t\t\t\t\t\t.map(range -> range.isBefore(addedTextElement.getRange().get())).orElse(false);\n            if (sufficientTokensRemainToSkip && currentIsAComment && commentIsBeforeAddedElement) {\n                // Need to get behind the comment:\n                // FIXME: Why 2? This comment and the next newline?\n                originalIndex += 2;\n                // Defer originalIndex increment\n                nodeText.addElement(originalIndex, addedTextElement);\n                // We want to adjust the indentation while considering the new element that we added\n                originalIndex = adjustIndentation(indentation, nodeText, originalIndex, false);\n                // Now we can increment\n                originalIndex++;\n            } else if (currentIsNewline && previousIsAComment) {\n                /*\n                 * Manage the case where we want to add an element, after an expression which is followed by a comment on the same line.\n                 * This is not the same case as the one who handles the trailing comments, because in this case the node text element is a new line (not a comment)\n                 * For example : {@code private String a; // this is a }\n                 */\n                // Insert after the new line which follows this comment.\n                originalIndex++;\n                // We want to adjust the indentation while considering the new element that we added\n                originalIndex = adjustIndentation(indentation, nodeText, originalIndex, false);\n                // Defer originalIndex increment\n                nodeText.addElement(originalIndex, addedTextElement);\n                // Now we can increment.\n                originalIndex++;\n            } else if (currentIsNewline && addedTextElement.isChild()) {\n                // here we want to place the new child element after the current new line character.\n                // Except if indentation has been inserted just before this step (in the case where isPreviousElementNewline is true)\n                // or if the previous character is a space (it could be the case if we want to replace a statement)\n                // Example 1 : if we insert a statement (a duplicated method call expression ) after this one <code>  value();\\n\\n</code>\n                // we want to have this result <code>  value();\\n  value();\\n</code> not <code>  value();\\n  \\nvalue();</code>\n                // Example 2 : if we want to insert a statement after this one <code>  \\n</code> we want to have <code>  value();\\n</code>\n                // not <code>  \\nvalue();</code> --> this case appears on member replacement for example\n                if (!isPreviousElementNewline && !isFirstElement && !previousIsWhiteSpace) {\n                    // Insert after the new line\n                    originalIndex++;\n                }\n                nodeText.addElement(originalIndex, addedTextElement);\n                originalIndex++;\n            } else {\n                nodeText.addElement(originalIndex, addedTextElement);\n                originalIndex++;\n            }\n        }\n        if (addedTextElement.isNewline()) {\n            boolean followedByUnindent = isFollowedByUnindent(diffElements, diffIndex);\n            boolean nextIsRightBrace = nextIsRightBrace(originalIndex);\n            boolean nextIsNewLine = originalElements.get(originalIndex).isNewline();\n            if ((!nextIsNewLine && !nextIsRightBrace) || followedByUnindent) {\n                originalIndex = adjustIndentation(indentation, nodeText, originalIndex, followedByUnindent);\n            }\n        }\n        diffIndex++;\n    }\n\n    private String tokenDescription(int kind) {\n        return GeneratedJavaParserConstants.tokenImage[kind];\n    }\n\n\t/*\n\t * Considering that the lists of elements are ordered, We can find the common\n\t * elements by starting with the list before the modifications and, for each\n\t * element, by going through the list of elements containing the modifications.\n\t * \n\t * We can find the common elements by starting with the list before the\n\t * modifications (L1) and, for each element, by going through the list of elements\n\t * containing the modifications (L2).\n\t * \n\t * If element A in list L1 is not found in list L2, it is a deleted element. \n\t * If element A of list L1 is found in list L2, it is a kept element. In this\n\t * case the search for the next element of the list L1 must start from the\n\t * position of the last element kept {@code syncNextIndex}.\n\t */\n\tprivate Map<Integer, Integer> getCorrespondanceBetweenNextOrderAndPreviousOrder(CsmMix elementsFromPreviousOrder,\n\t\t\tCsmMix elementsFromNextOrder) {\n\t\tMap<Integer, Integer> correspondanceBetweenNextOrderAndPreviousOrder = new HashMap<>();\n\t\tReadOnlyListIterator<CsmElement> previousOrderElementsIterator = new ReadOnlyListIterator(\n\t\t\t\telementsFromPreviousOrder.getElements());\n\t\tint syncNextIndex = 0;\n\t\twhile (previousOrderElementsIterator.hasNext()) {\n\t\t\tCsmElement pe = previousOrderElementsIterator.next();\n\t\t\tReadOnlyListIterator<CsmElement> nextOrderElementsIterator = new ReadOnlyListIterator(\n\t\t\t\t\telementsFromNextOrder.getElements(), syncNextIndex);\n\t\t\twhile (nextOrderElementsIterator.hasNext()) {\n\t\t\t\tCsmElement ne = nextOrderElementsIterator.next();\n\t\t\t\tif (!correspondanceBetweenNextOrderAndPreviousOrder.values().contains(previousOrderElementsIterator.index())\n\t\t\t\t\t\t&& DifferenceElementCalculator.matching(ne, pe)) {\n\t\t\t\t\tcorrespondanceBetweenNextOrderAndPreviousOrder.put(nextOrderElementsIterator.index(),\n\t\t\t\t\t\t\tpreviousOrderElementsIterator.index());\n\t\t\t\t\t// set the position to start on the next {@code nextOrderElementsIterator} iteration\n\t\t\t\t\tsyncNextIndex = nextOrderElementsIterator.index(); \n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn correspondanceBetweenNextOrderAndPreviousOrder;\n\t}\n    \n    /*\n     * A list iterator which does not allow to modify the list \n     * and which provides a method to know the current positioning \n     */\n    private class ReadOnlyListIterator<T> implements ListIterator<T> {\n    \tListIterator<T> elements;\n    \tpublic ReadOnlyListIterator(List<T> elements) {\n    \t\tthis(elements, 0);\n    \t}\n    \t\n    \tpublic ReadOnlyListIterator(List<T> elements, int index) {\n    \t\tthis.elements = elements.listIterator(index);\n    \t}\n\n\t\t@Override\n\t\tpublic boolean hasNext() {\n\t\t\treturn elements.hasNext();\n\t\t}\n\n\t\t@Override\n\t\tpublic T next() {\n\t\t\treturn elements.next();\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean hasPrevious() {\n\t\t\treturn elements.hasPrevious();\n\t\t}\n\n\t\t@Override\n\t\tpublic T previous() {\n\t\t\treturn elements.previous();\n\t\t}\n\n\t\t@Override\n\t\tpublic int nextIndex() {\n\t\t\treturn elements.nextIndex();\n\t\t}\n\n\t\t@Override\n\t\tpublic int previousIndex() {\n\t\t\treturn elements.previousIndex();\n\t\t}\n\t\t\n\t\t/*\n\t\t * Returns the current index in the underlying list\n\t\t */\n\t\tpublic int index() {\n\t\t\treturn elements.nextIndex() - 1;\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic void remove() {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\n\t\t@Override\n\t\tpublic void set(T e) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\n\t\t@Override\n\t\tpublic void add(T e) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n    \t\n    }\n\n    /*\n     * Returns true if the next element in the list is an added element of type CsmUnindent\n     */\n    private boolean isFollowedByUnindent(List<DifferenceElement> diffElements, int diffIndex) {\n        int nextIndexValue = diffIndex + 1;\n        return (nextIndexValue) < diffElements.size() && diffElements.get(nextIndexValue).isAdded() && diffElements.get(nextIndexValue).getElement() instanceof CsmUnindent;\n    }\n\n    private List<Integer> findIndexOfCorrespondingNodeTextElement(List<CsmElement> elements, NodeText nodeText, int startIndex, Node node) {\n        List<Integer> correspondingIndices = new ArrayList<>();\n        for (ListIterator<CsmElement> csmElementListIterator = elements.listIterator(); csmElementListIterator.hasNext(); ) {\n            int previousCsmElementIndex = csmElementListIterator.previousIndex();\n            CsmElement csmElement = csmElementListIterator.next();\n            int nextCsmElementIndex = csmElementListIterator.nextIndex();\n            Map<MatchClassification, Integer> potentialMatches = new EnumMap<>(MatchClassification.class);\n            for (int i = startIndex; i < nodeText.numberOfElements(); i++) {\n                if (!correspondingIndices.contains(i)) {\n                    TextElement textElement = nodeText.getTextElement(i);\n                    boolean isCorresponding = isCorrespondingElement(textElement, csmElement, node);\n                    if (isCorresponding) {\n                        boolean hasSamePreviousElement = false;\n                        if (i > 0 && previousCsmElementIndex > -1) {\n                            TextElement previousTextElement = nodeText.getTextElement(i - 1);\n                            hasSamePreviousElement = isCorrespondingElement(previousTextElement, elements.get(previousCsmElementIndex), node);\n                        }\n                        boolean hasSameNextElement = false;\n                        if (i < nodeText.numberOfElements() - 1 && nextCsmElementIndex < elements.size()) {\n                            TextElement nextTextElement = nodeText.getTextElement(i + 1);\n                            hasSameNextElement = isCorrespondingElement(nextTextElement, elements.get(nextCsmElementIndex), node);\n                        }\n                        if (hasSamePreviousElement && hasSameNextElement) {\n                            potentialMatches.putIfAbsent(MatchClassification.ALL, i);\n                        } else if (hasSamePreviousElement) {\n                            potentialMatches.putIfAbsent(MatchClassification.PREVIOUS_AND_SAME, i);\n                        } else if (hasSameNextElement) {\n                            potentialMatches.putIfAbsent(MatchClassification.NEXT_AND_SAME, i);\n                        } else {\n                            potentialMatches.putIfAbsent(MatchClassification.SAME_ONLY, i);\n                        }\n                    } else if (isAlmostCorrespondingElement(textElement, csmElement, node)) {\n                        potentialMatches.putIfAbsent(MatchClassification.ALMOST, i);\n                    }\n                }\n            }\n            // Prioritize the matches from best to worst\n            Optional<MatchClassification> bestMatchKey = potentialMatches.keySet().stream().min(Comparator.comparing(MatchClassification::getPriority));\n            if (bestMatchKey.isPresent()) {\n                correspondingIndices.add(potentialMatches.get(bestMatchKey.get()));\n            } else {\n                correspondingIndices.add(-1);\n            }\n        }\n        return correspondingIndices;\n    }\n\n    private enum MatchClassification {\n\n        ALL(1), PREVIOUS_AND_SAME(2), NEXT_AND_SAME(3), SAME_ONLY(4), ALMOST(5);\n\n        private final int priority;\n\n        MatchClassification(int priority) {\n            this.priority = priority;\n        }\n\n        int getPriority() {\n            return priority;\n        }\n    }\n\n    private boolean isCorrespondingElement(TextElement textElement, CsmElement csmElement, Node node) {\n        if (csmElement instanceof CsmToken) {\n            CsmToken csmToken = (CsmToken) csmElement;\n            if (textElement instanceof TokenTextElement) {\n                TokenTextElement tokenTextElement = (TokenTextElement) textElement;\n                return tokenTextElement.getTokenKind() == csmToken.getTokenType() && tokenTextElement.getText().equals(csmToken.getContent(node));\n            }\n        } else if (csmElement instanceof CsmChild) {\n            CsmChild csmChild = (CsmChild) csmElement;\n            if (textElement instanceof ChildTextElement) {\n                ChildTextElement childTextElement = (ChildTextElement) textElement;\n                return childTextElement.getChild() == csmChild.getChild();\n            }\n        } else {\n            throw new UnsupportedOperationException();\n        }\n        return false;\n    }\n\n    private boolean isAlmostCorrespondingElement(TextElement textElement, CsmElement csmElement, Node node) {\n        if (isCorrespondingElement(textElement, csmElement, node)) {\n            return false;\n        }\n        return textElement.isWhiteSpace() && csmElement instanceof CsmToken && ((CsmToken) csmElement).isWhiteSpace();\n    }\n\n    private int adjustIndentation(List<TokenTextElement> indentation, NodeText nodeText, int nodeTextIndex, boolean followedByUnindent) {\n        List<TextElement> indentationAdj = processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1));\n        if (nodeTextIndex < nodeText.numberOfElements() && nodeText.getTextElement(nodeTextIndex).isToken(RBRACE)) {\n            indentationAdj = indentationAdj.subList(0, indentationAdj.size() - Math.min(STANDARD_INDENTATION_SIZE, indentationAdj.size()));\n        } else if (followedByUnindent) {\n            indentationAdj = indentationAdj.subList(0, Math.max(0, indentationAdj.size() - STANDARD_INDENTATION_SIZE));\n        }\n        for (TextElement e : indentationAdj) {\n            if ((nodeTextIndex < nodeText.numberOfElements()) && nodeText.getTextElement(nodeTextIndex).isSpaceOrTab()) {\n                nodeTextIndex++;\n            } else {\n                nodeText.getElements().add(nodeTextIndex++, e);\n            }\n        }\n        if (nodeTextIndex < 0) {\n            throw new IllegalStateException();\n        }\n        return nodeTextIndex;\n    }\n\n    /*\n     * Returns true if the current <code>Added</code> element is preceded by a <code>Removed</code> element.\n     */\n    private boolean isAReplacement(int diffIndex) {\n        return (diffIndex > 0) && diffElements.get(diffIndex).isAdded() && diffElements.get(diffIndex - 1).isRemoved();\n    }\n\n    /*\n     * Returns true if the current <code>Removed</code> element is followed by a <code>Added</code> element.\n     */\n    private boolean isReplaced(int diffIndex) {\n        return (diffIndex < diffElements.size() - 1) && diffElements.get(diffIndex + 1).isAdded() && diffElements.get(diffIndex).isRemoved();\n    }\n\n    @Override\n    public String toString() {\n        return \"Difference{\" + diffElements + '}';\n    }\n}\n",
        "filePathAfter": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Difference.java",
        "sourceCodeAfterForWhole": "/*\n * Copyright (C) 2007-2010 J\u00falio Vilmar Gesser.\n * Copyright (C) 2011, 2013-2021 The JavaParser Team.\n *\n * This file is part of JavaParser.\n *\n * JavaParser can be used either under the terms of\n * a) the GNU Lesser General Public License as published by\n *     the Free Software Foundation, either version 3 of the License, or\n *     (at your option) any later version.\n * b) the terms of the Apache License\n *\n * You should have received a copy of both licenses in LICENCE.LGPL and\n * LICENCE.APACHE. Please refer to those files for details.\n *\n * JavaParser is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n */\npackage com.github.javaparser.printer.lexicalpreservation;\n\nimport com.github.javaparser.GeneratedJavaParserConstants;\nimport com.github.javaparser.JavaToken;\nimport com.github.javaparser.JavaToken.Kind;\nimport com.github.javaparser.TokenTypes;\nimport com.github.javaparser.ast.Node;\nimport com.github.javaparser.ast.NodeList;\nimport com.github.javaparser.ast.comments.Comment;\nimport com.github.javaparser.ast.nodeTypes.NodeWithTypeArguments;\nimport com.github.javaparser.ast.type.ArrayType;\nimport com.github.javaparser.ast.type.ClassOrInterfaceType;\nimport com.github.javaparser.ast.type.Type;\nimport com.github.javaparser.printer.concretesyntaxmodel.*;\nimport com.github.javaparser.printer.lexicalpreservation.LexicalDifferenceCalculator.CsmChild;\n\nimport java.util.*;\n\nimport static com.github.javaparser.GeneratedJavaParserConstants.*;\n\n/**\n * A Difference should give me a sequence of elements I should find (to indicate the context) followed by a list of elements\n * to remove or to add and follow by another sequence of elements.\n *\n * I should later be able to apply such difference to a nodeText.\n */\npublic class Difference {\n\n    public static final int STANDARD_INDENTATION_SIZE = 4;\n\n    private final NodeText nodeText;\n\n    private final Node node;\n\n    private final List<DifferenceElement> diffElements;\n\n    private final List<TextElement> originalElements;\n\n    private int originalIndex = 0;\n\n    private int diffIndex = 0;\n\n    private final List<TokenTextElement> indentation;\n\n    private boolean addedIndentation = false;\n\n    Difference(List<DifferenceElement> diffElements, NodeText nodeText, Node node) {\n        if (nodeText == null) {\n            throw new NullPointerException(\"nodeText can not be null\");\n        }\n        this.nodeText = nodeText;\n        this.node = node;\n        this.diffElements = diffElements;\n        this.originalElements = nodeText.getElements();\n        this.indentation = LexicalPreservingPrinter.findIndentation(node);\n    }\n\n    /*\n     * Returns the indentation used after the last line break\n     */\n    private List<TextElement> processIndentation(List<TokenTextElement> indentation, List<TextElement> prevElements) {\n        List<TextElement> res = new LinkedList<>(indentation);\n        int index = lastIndexOfEol(prevElements);\n        // no EOL found\n        if (index < 0)\n            return res;\n        // initialize previous indentation\n        res.clear();\n        // search for consecutive space characters\n        for (int i = (index + 1); i < prevElements.size(); i++) {\n            TextElement elem = prevElements.get(i);\n            if (elem.isWhiteSpace()) {\n                res.add(elem);\n                continue;\n            }\n            break;\n        }\n        return res;\n    }\n    \n    /*\n     * Returns the position of the next element in the list starting from @{code fromIndex} which is a comment (Ignoring spaces)\n     * or -1 if it's not a comment.\n     */\n    private int posOfNextComment(int fromIndex, List<TextElement> elements) {\n        if (!isValidIndex(fromIndex, elements))\n            return -1;\n        ReadOnlyListIterator<TextElement> iterator = new ReadOnlyListIterator(elements, fromIndex);\n        // search for the next consecutive space characters\n        while (iterator.hasNext()) {\n            TextElement element = iterator.next();\n            if (element.isSpaceOrTab()) {\n                continue;\n            }\n            if (element.isComment()) {\n            \treturn iterator.index();\n            }\n            break;\n        }\n        return -1;\n    }\n    \n    /*\n     * Returns true if the next element in the list (starting from @{code fromIndex}) is a comment\n     */\n    private boolean isFollowedByComment(int fromIndex, List<TextElement> elements) {\n    \treturn posOfNextComment(fromIndex, elements) != -1;\n    }\n    \n    /*\n     * Removes all elements in the list starting from @{code fromIndex}) ending to @{code toIndex})\n     */\n    private void removeElements(int fromIndex, int toIndex, List<TextElement> elements) {\n    \tif (!(isValidIndex(fromIndex, elements) && isValidIndex(toIndex, elements) && fromIndex <= toIndex))\n            return;\n        ListIterator<TextElement> iterator = elements.listIterator(fromIndex);\n        // removing elements\n        int count = fromIndex;\n        while (iterator.hasNext() && count <= toIndex) {\n        \tTextElement element = iterator.next();\n            iterator.remove();\n            count++;\n        }\n    }\n    \n    private boolean isValidIndex(int index, List<?> elements) {\n    \treturn index >= 0 && index <= elements.size();\n    }\n\n    /*\n     * Returns the position of the last new line character or -1 if there is no eol in the specified list of TextElement \n     */\n    int lastIndexOfEol(List<TextElement> source) {\n        ListIterator listIterator = source.listIterator(source.size());\n        int lastIndex = source.size() - 1;\n        while (listIterator.hasPrevious()) {\n            TextElement elem = (TextElement) listIterator.previous();\n            if (elem.isNewline()) {\n                return lastIndex;\n            }\n            lastIndex--;\n        }\n        return -1;\n    }\n\n    private List<TextElement> indentationBlock() {\n        List<TextElement> res = new LinkedList<>();\n        res.add(new TokenTextElement(SPACE));\n        res.add(new TokenTextElement(SPACE));\n        res.add(new TokenTextElement(SPACE));\n        res.add(new TokenTextElement(SPACE));\n        return res;\n    }\n\n    private boolean isAfterLBrace(NodeText nodeText, int nodeTextIndex) {\n        if (nodeTextIndex > 0 && nodeText.getTextElement(nodeTextIndex - 1).isToken(LBRACE)) {\n            return true;\n        }\n        if (nodeTextIndex > 0 && nodeText.getTextElement(nodeTextIndex - 1).isSpaceOrTab()) {\n            return isAfterLBrace(nodeText, nodeTextIndex - 1);\n        }\n        return false;\n    }\n\n    /**\n     * If we are at the beginning of a line, with just spaces or tabs before/after the position of the deleted element\n     * we should force the space to be the same as the current indentation.\n     * This method handles the following case if we remove the modifier {@code public} ([ ] is an indent character)\n     * {@code \n     * [ ][ ]public[ ][ ][ ]void[ ]m{}\n     * <-1-->      <---2--->\n     * 1/ current indentation\n     * 2/ these whitespaces must be removed\n     * }\n     * should produce\n     * {@code \n     * [ ][ ]void[ ]m{} \n     * }\n     */\n    private int considerEnforcingIndentation(NodeText nodeText, int nodeTextIndex) {\n        return considerIndentation(nodeText, nodeTextIndex, indentation.size());\n    }\n    \n    private int considerRemovingIndentation(NodeText nodeText, int nodeTextIndex) {\n        return considerIndentation(nodeText, nodeTextIndex, 0);\n    }\n    \n    private int considerIndentation(NodeText nodeText, int nodeTextIndex, int numberOfCharactersToPreserve) {\n        EnforcingIndentationContext enforcingIndentationContext = defineEnforcingIndentationContext(nodeText, nodeTextIndex);\n        // the next position in the list (by default the current position)\n        int res = nodeTextIndex;\n        if (enforcingIndentationContext.extraCharacters > 0) {\n        \tint extraCharacters = enforcingIndentationContext.extraCharacters > numberOfCharactersToPreserve ? enforcingIndentationContext.extraCharacters - numberOfCharactersToPreserve : 0;\n            res = removeExtraCharacters(nodeText, enforcingIndentationContext.start, extraCharacters);\n            // The next position must take into account the indentation\n            res = extraCharacters > 0 ? res + numberOfCharactersToPreserve : res;\n        }\n        if (res < 0) {\n            throw new IllegalStateException();\n        }\n        return res;\n    }\n    \n    private boolean isEnforcingIndentationActivable(RemovedGroup removedGroup) {\n\t\treturn (diffIndex + 1 >= diffElements.size() || !(diffElements.get(diffIndex + 1).isAdded()))\n\t\t\t\t&& originalIndex < originalElements.size()\n\t\t\t\t&& !removedGroup.isACompleteLine();\n\t}\n\n    private boolean isRemovingIndentationActivable(RemovedGroup removedGroup) {\n\t\treturn (diffIndex + 1 >= diffElements.size() || !(diffElements.get(diffIndex + 1).isAdded())) \n\t\t\t\t&& originalIndex < originalElements.size()\n\t\t\t\t&& removedGroup.isACompleteLine();\n\t}\n    \n    /*\n     * This data structure class hold the starting position of the first whitespace char \n     * and the number of consecutive whitespace (or tab) characters\n     */\n    private class EnforcingIndentationContext {\n    \tint start;\n    \tint extraCharacters;\n    \tpublic EnforcingIndentationContext(int start) {\n    \t\tthis.start=start;\n    \t\tthis.extraCharacters=0;\n    \t}\n    }\n\n    /**\n     * Remove excess white space after deleting element.\n     * @param nodeText Contains a list of elements to analyze\n     * @param nodeTextIndex Starting position in the input list\n     * @return The current position in the list of the elements\n     */\n    private int removeExtraCharacters(NodeText nodeText, int nodeTextIndex, int extraCharacters) {\n        int count = 0;\n        while (nodeTextIndex >= 0 && nodeTextIndex < nodeText.numberOfElements() && count < extraCharacters) {\n            nodeText.removeElement(nodeTextIndex);\n            count++;\n        }\n        return nodeTextIndex;\n    }\n\n    /**\n     * Starting at {@code nodeTextIndex} this method tries to determine how many contiguous spaces there are between \n     * the previous end of line and the next non whitespace (or tab) character\n     * @param nodeText List of elements to analyze\n     * @param nodeTextIndex Starting position in the input list\n     * @return EnforcingIndentationContext Data structure that hold the starting position of the first whitespace char and\n     * The number of consecutive whitespace (or tab) characters\n     */\n    private EnforcingIndentationContext defineEnforcingIndentationContext(NodeText nodeText, int startIndex) {\n    \tEnforcingIndentationContext ctx = new EnforcingIndentationContext(startIndex);\n    \t// compute space before startIndex value\n\t\tif (startIndex < nodeText.numberOfElements() && startIndex > 0) {\n\t\t\t// at this stage startIndex points to the first element before the deleted one\n\t\t\tfor (int i = startIndex - 1; i >= 0 && i < nodeText.numberOfElements(); i--) {\n\t\t\t\tif (nodeText.getTextElement(i).isNewline()) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (!nodeText.getTextElement(i).isSpaceOrTab()) {\n\t\t\t\t\tctx = new EnforcingIndentationContext(startIndex);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tctx.start = i;\n\t\t\t\tctx.extraCharacters++;\n\t\t\t}\n\t\t}\n\t\t// compute space after the deleted element\n\t\tif (nodeText.getTextElement(startIndex).isSpaceOrTab()) {\n\t\t\tfor (int i = startIndex; i >= 0 && i < nodeText.numberOfElements(); i++) {\n\t\t\t\tif (nodeText.getTextElement(i).isNewline()) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (!nodeText.getTextElement(i).isSpaceOrTab()) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tctx.extraCharacters++;\n\t\t\t}\n\t\t}\n        \n        return ctx;\n    }\n\n    /**\n     * Node that we have calculate the Difference we can apply to a concrete NodeText, modifying it according\n     * to the difference (adding and removing the elements provided).\n     */\n    void apply() {\n        extractReshuffledDiffElements(diffElements);\n        Map<Removed, RemovedGroup> removedGroups = combineRemovedElementsToRemovedGroups();\n        do {\n            boolean isLeftOverDiffElement = applyLeftOverDiffElements();\n            boolean isLeftOverOriginalElement = applyLeftOverOriginalElements();\n            if (!isLeftOverDiffElement && !isLeftOverOriginalElement) {\n                DifferenceElement diffElement = diffElements.get(diffIndex);\n                if (diffElement.isAdded()) {\n                    applyAddedDiffElement((Added) diffElement);\n                } else {\n                    TextElement originalElement = originalElements.get(originalIndex);\n                    boolean originalElementIsChild = originalElement instanceof ChildTextElement;\n                    boolean originalElementIsToken = originalElement instanceof TokenTextElement;\n                    if (diffElement.isKept()) {\n                        applyKeptDiffElement((Kept) diffElement, originalElement, originalElementIsChild, originalElementIsToken);\n                    } else if (diffElement.isRemoved()) {\n                        Removed removed = (Removed) diffElement;\n                        applyRemovedDiffElement(removedGroups.get(removed), removed, originalElement, originalElementIsChild, originalElementIsToken);\n                    } else {\n                        throw new UnsupportedOperationException(\"\" + diffElement + \" vs \" + originalElement);\n                    }\n                }\n            }\n        } while (diffIndex < diffElements.size() || originalIndex < originalElements.size());\n    }\n\n    private boolean applyLeftOverOriginalElements() {\n        boolean isLeftOverElement = false;\n        if (diffIndex >= diffElements.size() && originalIndex < originalElements.size()) {\n            TextElement originalElement = originalElements.get(originalIndex);\n            if (originalElement.isWhiteSpaceOrComment()) {\n                originalIndex++;\n            } else {\n                throw new UnsupportedOperationException(\"NodeText: \" + nodeText + \". Difference: \" + this + \" \" + originalElement);\n            }\n            isLeftOverElement = true;\n        }\n        return isLeftOverElement;\n    }\n\n    private boolean applyLeftOverDiffElements() {\n        boolean isLeftOverElement = false;\n        if (diffIndex < diffElements.size() && originalIndex >= originalElements.size()) {\n            DifferenceElement diffElement = diffElements.get(diffIndex);\n            if (diffElement.isKept()) {\n                diffIndex++;\n            } else if (diffElement.isAdded()) {\n                Added addedElement = (Added) diffElement;\n                nodeText.addElement(originalIndex, addedElement.toTextElement());\n                originalIndex++;\n                diffIndex++;\n            } else {\n                // let's forget this element\n                diffIndex++;\n            }\n            isLeftOverElement = true;\n        }\n        return isLeftOverElement;\n    }\n\n    private void extractReshuffledDiffElements(List<DifferenceElement> diffElements) {\n        for (int index = 0; index < diffElements.size(); index++) {\n            DifferenceElement diffElement = diffElements.get(index);\n            if (diffElement instanceof Reshuffled) {\n                Reshuffled reshuffled = (Reshuffled) diffElement;\n                // First, let's see how many tokens we need to attribute to the previous version of the of the CsmMix\n                CsmMix elementsFromPreviousOrder = reshuffled.getPreviousOrder();\n                CsmMix elementsFromNextOrder = reshuffled.getNextOrder();\n                // This contains indexes from elementsFromNextOrder to indexes from elementsFromPreviousOrder\n                Map<Integer, Integer> correspondanceBetweenNextOrderAndPreviousOrder = getCorrespondanceBetweenNextOrderAndPreviousOrder(elementsFromPreviousOrder, elementsFromNextOrder);\n                // We now find out which Node Text elements corresponds to the elements in the original CSM\n                List<Integer> nodeTextIndexOfPreviousElements = findIndexOfCorrespondingNodeTextElement(elementsFromPreviousOrder.getElements(), nodeText, originalIndex, node);\n                Map<Integer, Integer> nodeTextIndexToPreviousCSMIndex = new HashMap<>();\n                for (int i = 0; i < nodeTextIndexOfPreviousElements.size(); i++) {\n                    int value = nodeTextIndexOfPreviousElements.get(i);\n                    if (value != -1) {\n                        nodeTextIndexToPreviousCSMIndex.put(value, i);\n                    }\n                }\n                int lastNodeTextIndex = nodeTextIndexOfPreviousElements.stream().max(Integer::compareTo).orElse(-1);\n                // Elements to be added at the end\n                List<CsmElement> elementsToBeAddedAtTheEnd = new LinkedList<>();\n                List<CsmElement> nextOrderElements = elementsFromNextOrder.getElements();\n                Map<Integer, List<CsmElement>> elementsToAddBeforeGivenOriginalCSMElement = new HashMap<>();\n                for (int ni = 0; ni < nextOrderElements.size(); ni++) {\n                    // If it has a mapping, then it is kept\n                    if (!correspondanceBetweenNextOrderAndPreviousOrder.containsKey(ni)) {\n                        // Ok, it is something new. Where to put it? Let's see what is the first following\n                        // element that has a mapping\n                        int originalCsmIndex = -1;\n                        for (int nj = ni + 1; nj < nextOrderElements.size() && originalCsmIndex == -1; nj++) {\n                            if (correspondanceBetweenNextOrderAndPreviousOrder.containsKey(nj)) {\n                                originalCsmIndex = correspondanceBetweenNextOrderAndPreviousOrder.get(nj);\n                                if (!elementsToAddBeforeGivenOriginalCSMElement.containsKey(originalCsmIndex)) {\n                                    elementsToAddBeforeGivenOriginalCSMElement.put(originalCsmIndex, new LinkedList<>());\n                                }\n                                elementsToAddBeforeGivenOriginalCSMElement.get(originalCsmIndex).add(nextOrderElements.get(ni));\n                            }\n                        }\n                        // it does not preceed anything, so it goes at the end\n                        if (originalCsmIndex == -1) {\n                            elementsToBeAddedAtTheEnd.add(nextOrderElements.get(ni));\n                        }\n                    }\n                }\n                // We go over the original node text elements, in the order they appear in the NodeText.\n                // Considering an original node text element (ONE)\n                // * we verify if it corresponds to a CSM element. If it does not we just move on, otherwise\n                // we find the correspond OCE (Original CSM Element)\n                // * we first add new elements that are marked to be added before OCE\n                // * if OCE is marked to be present also in the \"after\" CSM we add a kept element,\n                // otherwise we add a removed element\n                // Remove the whole Reshuffled element\n                diffElements.remove(index);\n                int diffElIterator = index;\n                if (lastNodeTextIndex != -1) {\n                    for (int ntIndex = originalIndex; ntIndex <= lastNodeTextIndex; ntIndex++) {\n                        if (nodeTextIndexToPreviousCSMIndex.containsKey(ntIndex)) {\n                            int indexOfOriginalCSMElement = nodeTextIndexToPreviousCSMIndex.get(ntIndex);\n                            if (elementsToAddBeforeGivenOriginalCSMElement.containsKey(indexOfOriginalCSMElement)) {\n                                for (CsmElement elementToAdd : elementsToAddBeforeGivenOriginalCSMElement.get(indexOfOriginalCSMElement)) {\n                                    diffElements.add(diffElIterator++, new Added(elementToAdd));\n                                }\n                            }\n                            CsmElement originalCSMElement = elementsFromPreviousOrder.getElements().get(indexOfOriginalCSMElement);\n                            boolean toBeKept = correspondanceBetweenNextOrderAndPreviousOrder.containsValue(indexOfOriginalCSMElement);\n                            if (toBeKept) {\n                                diffElements.add(diffElIterator++, new Kept(originalCSMElement));\n                            } else {\n                                diffElements.add(diffElIterator++, new Removed(originalCSMElement));\n                            }\n                        }\n                        // else we have a simple node text element, without associated csm element, just keep ignore it\n                    }\n                }\n                // Finally we look for the remaining new elements that were not yet added and\n                // add all of them\n                for (CsmElement elementToAdd : elementsToBeAddedAtTheEnd) {\n                    diffElements.add(diffElIterator++, new Added(elementToAdd));\n                }\n            }\n        }\n    }\n\n    /**\n     * Maps all Removed elements as keys to their corresponding RemovedGroup.\n     * A RemovedGroup contains all consecutive Removed elements.\n     * <br>\n     * Example:\n     * <pre>\n     * Elements: Kept|Removed1|Removed2|Kept|Removed3|Added|Removed4\n     * Groups:        <----Group1---->       Group2         Group3\n     * Keys:          Removed1+Removed2      Removed3       Removed4\n     * </pre>\n     *\n     * @return Map with all Removed elements as keys to their corresponding RemovedGroup\n     */\n    private Map<Removed, RemovedGroup> combineRemovedElementsToRemovedGroups() {\n        Map<Integer, List<Removed>> removedElementsMap = groupConsecutiveRemovedElements();\n        List<RemovedGroup> removedGroups = new ArrayList<>();\n        for (Map.Entry<Integer, List<Removed>> entry : removedElementsMap.entrySet()) {\n            removedGroups.add(RemovedGroup.of(entry.getKey(), entry.getValue()));\n        }\n        Map<Removed, RemovedGroup> map = new HashMap<>();\n        for (RemovedGroup removedGroup : removedGroups) {\n            for (Removed index : removedGroup) {\n                map.put(index, removedGroup);\n            }\n        }\n        return map;\n    }\n\n    private Map<Integer, List<Removed>> groupConsecutiveRemovedElements() {\n        Map<Integer, List<Removed>> removedElementsMap = new HashMap<>();\n        Integer firstElement = null;\n        for (int i = 0; i < diffElements.size(); i++) {\n            DifferenceElement diffElement = diffElements.get(i);\n            if (diffElement.isRemoved()) {\n                if (firstElement == null) {\n                    firstElement = i;\n                }\n                removedElementsMap.computeIfAbsent(firstElement, key -> new ArrayList<>()).add((Removed) diffElement);\n            } else {\n                firstElement = null;\n            }\n        }\n        return removedElementsMap;\n    }\n\n    private void applyRemovedDiffElement(RemovedGroup removedGroup, Removed removed, TextElement originalElement, boolean originalElementIsChild, boolean originalElementIsToken) {\n        if (removed.isChild() && originalElementIsChild) {\n            ChildTextElement originalElementChild = (ChildTextElement) originalElement;\n            if (originalElementChild.isComment()) {\n                // We expected to remove a proper node but we found a comment in between.\n                // If the comment is associated to the node we want to remove we remove it as well, otherwise we keep it\n                Comment comment = (Comment) originalElementChild.getChild();\n                if (!comment.isOrphan() && comment.getCommentedNode().isPresent() && comment.getCommentedNode().get().equals(removed.getChild())) {\n                    nodeText.removeElement(originalIndex);\n                } else {\n                    originalIndex++;\n                }\n            } else {\n                nodeText.removeElement(originalIndex);\n                // When we don't try to remove a complete line \n                // and removing the element is not the first action of a replacement (removal followed by addition)\n                // (in the latter case we keep the indentation)\n                // then we want to enforce the indentation.\n                if (isEnforcingIndentationActivable(removedGroup)) {\n                \t// Since the element has been deleted we try to start the analysis from the element following the one that was deleted\n                    originalIndex = considerEnforcingIndentation(nodeText, originalIndex);\n                }\n                // If in front we have one space and before also we had space let's drop one space\n                if (originalElements.size() > originalIndex && originalIndex > 0) {\n                    if (originalElements.get(originalIndex).isWhiteSpace() && originalElements.get(originalIndex - 1).isWhiteSpace()) {\n                        // However we do not want to do that when we are about to adding or removing elements\n                        // The intention is not very clear maybe it should clarify this with examples!\n                        // Are we to understand that we can only do this if there is a single modification to process\n                        // OR or if the next change is to keep the element\n                        if ((diffIndex + 1) == diffElements.size() || (diffElements.get(diffIndex + 1).isKept())) {\n                            originalElements.remove(originalIndex--);\n                        }\n                    }\n                }\n                // We need to know if, in the original list of elements, the deleted child node is immediately followed by the same comment.\n                // If so, it should also be deleted.\n                if (isFollowedByComment(originalIndex, originalElements) ) {\n                \tint indexOfNextComment = posOfNextComment(originalIndex, originalElements);\n                \tremoveElements(originalIndex, indexOfNextComment, originalElements);\n                }\n                if (isRemovingIndentationActivable(removedGroup)) {\n                \t// Since the element has been deleted we try to start the analysis from the previous element\n                    originalIndex = considerRemovingIndentation(nodeText, originalIndex);\n                }\n                diffIndex++;\n            }\n        } else if (removed.isChild() && originalElement.isComment()) {\n        \t// removing the comment first\n        \tnodeText.removeElement(originalIndex);\n        \tif (isRemovingIndentationActivable(removedGroup)) {\n                originalIndex = considerRemovingIndentation(nodeText, originalIndex);\n            }\n        } else if (removed.isToken() && originalElementIsToken && (removed.getTokenType() == ((TokenTextElement) originalElement).getTokenKind() || // handle EOLs separately as their token kind might not be equal. This is because the 'removed'\n        // element always has the current operating system's EOL as type\n        (((TokenTextElement) originalElement).getToken().getCategory().isEndOfLine() && removed.isNewLine()))) {\n            nodeText.removeElement(originalIndex);\n            diffIndex++;\n        } else if ((removed.isWhiteSpaceNotEol() || removed.getElement() instanceof CsmIndent || removed.getElement() instanceof CsmUnindent)\n        \t\t&& originalElement.isSpaceOrTab()){\n        \t// remove the current space\n        \tnodeText.removeElement(originalIndex);\n        }else if (originalElementIsToken && originalElement.isWhiteSpaceOrComment()) {\n            originalIndex++;\n            // skip the newline token which may be generated unnecessarily by the concrete syntax pattern\n            if (removed.isNewLine()) { \n            \tdiffIndex++;\n            }\n        } else if (originalElement.isLiteral()) {\n            nodeText.removeElement(originalIndex);\n            diffIndex++;\n        } else if (removed.isPrimitiveType()) {\n            if (originalElement.isPrimitive()) {\n                nodeText.removeElement(originalIndex);\n                diffIndex++;\n            } else {\n                throw new UnsupportedOperationException(\"removed \" + removed.getElement() + \" vs \" + originalElement);\n            }\n        } else if (removed.isWhiteSpace() || removed.getElement() instanceof CsmIndent || removed.getElement() instanceof CsmUnindent) {\n            diffIndex++;\n        } else if (originalElement.isWhiteSpace()) {\n            originalIndex++;\n        } else if (removed.isChild()) {\n            // see issue #3721 this case is linked for example to a change of type of variable declarator\n            nodeText.removeElement(originalIndex);\n            diffIndex++;\n        } else {\n            throw new UnsupportedOperationException(\"removed \" + removed.getElement() + \" vs \" + originalElement);\n        }\n        cleanTheLineOfLeftOverSpace(removedGroup, removed);\n    }\n\n    /**\n     * Cleans the line of left over space if there is unnecessary indentation and the element will not be replaced\n     */\n    private void cleanTheLineOfLeftOverSpace(RemovedGroup removedGroup, Removed removed) {\n        if (originalIndex >= originalElements.size()) {\n            // if all elements were already processed there is nothing to do\n            return;\n        }\n        // we dont want to remove the indentation if the last removed element is a newline\n        // because in this case we are trying to remove the indentation of the next child element\n        if (!removedGroup.isProcessed() \n        \t\t&& removedGroup.isLastElement(removed) \n        \t\t&& removedGroup.isACompleteLine()\n        \t\t&& !removed.isNewLine()) {\n            Integer lastElementIndex = removedGroup.getLastElementIndex();\n            Optional<Integer> indentation = removedGroup.getIndentation();\n            if (indentation.isPresent() && !isReplaced(lastElementIndex)) {\n                for (int i = 0; i < indentation.get(); i++) {\n                    if (originalElements.get(originalIndex).isSpaceOrTab()) {\n                        // If the current element is a space, remove it\n                        nodeText.removeElement(originalIndex);\n                    } else if (originalIndex >= 1 && originalElements.get(originalIndex - 1).isSpaceOrTab()) {\n                        // If the current element is not a space itself we remove the space in front of (before) it\n                        nodeText.removeElement(originalIndex - 1);\n                        originalIndex--;\n                    }\n                    // Remove remaining newline character if needed\n                    if (nodeText.getTextElement(originalIndex).isNewline()) {\n                    \tnodeText.removeElement(originalIndex);\n                    \toriginalIndex = originalIndex > 0 ? originalIndex-- : 0;\n                    }\n                }\n            }\n            // Mark RemovedGroup as processed\n            removedGroup.processed();\n        }\n    }\n\n    // note:\n    // increment originalIndex if we want to keep the original element\n    // increment diffIndex if we want to skip the diff element\n    private void applyKeptDiffElement(Kept kept, TextElement originalElement, boolean originalElementIsChild, boolean originalElementIsToken) {\n\t\tif (originalElement.isComment()) {\n\t\t\toriginalIndex++;\n        } else if (kept.isChild() && ((CsmChild) kept.getElement()).getChild() instanceof Comment) {\n            diffIndex++;\n        } else if (kept.isChild() && originalElementIsChild) {\n            diffIndex++;\n            originalIndex++;\n        } else if (kept.isChild() && originalElementIsToken) {\n            if (originalElement.isWhiteSpaceOrComment()) {\n                originalIndex++;\n            } else if (originalElement.isIdentifier() && isNodeWithTypeArguments(kept)) {\n                diffIndex++;\n                // skip all token related to node with type argument declaration\n                // for example:\n                // List i : in this case originalElement is \"List\" and the next token is space. There is nothing to skip. in the originalElements list.\n                // List<String> i : in this case originalElement is \"List\" and the next token is\n                // \"<\" so we have to skip all the tokens which are used in the typed argument declaration [<][String][>](3 tokens) in the originalElements list.\n                // List<List<String>> i : in this case originalElement is \"List\" and the next\n                // token is \"<\" so we have to skip all the tokens which are used in the typed arguments declaration [<][List][<][String][>][>](6 tokens) in the originalElements list.\n                int step = getIndexToNextTokenElement((TokenTextElement) originalElement, 0);\n                originalIndex += step;\n                originalIndex++;\n            } else if (originalElement.isIdentifier() && isTypeWithFullyQualifiedName(kept)) {\n                diffIndex++;\n                // skip all token related to node with the fully qualified name\n                // for example:\n                // java.lang.Object is represented in originalElement as a list of tokens \"java\", \".\", \"lang\", \".\", \"Object\".\n                // So we have to skip 5 tokens.\n                int step = getIndexToNextTokenElement((TokenTextElement) originalElement, kept);\n                originalIndex += step;\n                // positioning on the next token\n                originalIndex++;\n            } else if ((originalElement.isIdentifier() || originalElement.isKeyword()) && isArrayType(kept)) {\n                int tokenToSkip = getIndexToNextTokenElementInArrayType((TokenTextElement) originalElement, getArrayLevel(kept));\n                diffIndex++;\n                originalIndex += tokenToSkip;\n                originalIndex++;\n            } else if (originalElement.isIdentifier()) {\n                originalIndex++;\n                diffIndex++;\n            } else {\n                if (kept.isPrimitiveType()) {\n                    originalIndex++;\n                    diffIndex++;\n                } else {\n                    throw new UnsupportedOperationException(\"kept \" + kept.getElement() + \" vs \" + originalElement);\n                }\n            }\n        } else if (kept.isToken() && originalElementIsToken) {\n            TokenTextElement originalTextToken = (TokenTextElement) originalElement;\n            if (kept.getTokenType() == originalTextToken.getTokenKind()) {\n                originalIndex++;\n                diffIndex++;\n            } else if (kept.isNewLine() && originalTextToken.isNewline()) {\n                originalIndex++;\n                diffIndex++;\n            } else if (kept.isNewLine() && originalTextToken.isSpaceOrTab()) {\n                originalIndex++;\n            } else if (kept.isWhiteSpaceOrComment()) {\n                diffIndex++;\n            } else if (originalTextToken.isWhiteSpaceOrComment()) {\n                originalIndex++;\n            } else if (!kept.isNewLine() && originalTextToken.isSeparator()) {\n                // case where originalTextToken is a separator like \";\" and\n                // kept is not a new line or whitespace for example \"}\"\n                // see issue 2351\n                originalIndex++;\n            } else {\n                throw new UnsupportedOperationException(\"Csm token \" + kept.getElement() + \" NodeText TOKEN \" + originalTextToken);\n            }\n        } else if (kept.isToken() && originalElementIsChild) {\n            diffIndex++;\n        } else if (kept.isWhiteSpace()) {\n            diffIndex++;\n        } else if (kept.isIndent()) {\n            diffIndex++;\n        } else if (kept.isUnindent()) {\n            // Nothing to do\n            diffIndex++;\n        } else {\n            throw new UnsupportedOperationException(\"kept \" + kept.getElement() + \" vs \" + originalElement);\n        }\n    }\n\n    /*\n     * Returns the array level if the DifferenceElement is a CsmChild representing an ArrayType else 0\n     */\n    private int getArrayLevel(DifferenceElement element) {\n        CsmElement csmElem = element.getElement();\n        if (isArrayType(element)) {\n            Node child = ((LexicalDifferenceCalculator.CsmChild) csmElem).getChild();\n            return ((ArrayType) child).getArrayLevel();\n        }\n        return 0;\n    }\n\n    /*\n     * Returns true if the DifferenceElement is a CsmChild representing an ArrayType\n     */\n    private boolean isArrayType(DifferenceElement element) {\n        CsmElement csmElem = element.getElement();\n        return csmElem instanceof LexicalDifferenceCalculator.CsmChild && ((LexicalDifferenceCalculator.CsmChild) csmElem).getChild() instanceof ArrayType;\n    }\n\n    /*\n     * Returns true if the DifferenceElement is a CsmChild which represents a type with fully qualified name\n     */\n    private boolean isTypeWithFullyQualifiedName(DifferenceElement element) {\n        if (!element.isChild())\n            return false;\n        CsmChild child = (CsmChild) element.getElement();\n        if (!ClassOrInterfaceType.class.isAssignableFrom(child.getChild().getClass()))\n            return false;\n        return ((ClassOrInterfaceType) child.getChild()).getScope().isPresent();\n    }\n\n    /*\n     * Returns true if the DifferenceElement is a CsmChild with type arguments\n     */\n    private boolean isNodeWithTypeArguments(DifferenceElement element) {\n        if (!element.isChild())\n            return false;\n        CsmChild child = (CsmChild) element.getElement();\n        if (!NodeWithTypeArguments.class.isAssignableFrom(child.getChild().getClass()))\n            return false;\n        Optional<NodeList<Type>> typeArgs = ((NodeWithTypeArguments) child.getChild()).getTypeArguments();\n        return typeArgs.isPresent() && typeArgs.get().size() > 0;\n    }\n\n    /*\n     * Try to resolve the number of token to skip in the original list to match \n     * a ClassOrInterfaceType with a list of tokens like \"java\", \".\", \"lang\", \".\", \"Object\"\n     */\n    private int getIndexToNextTokenElement(TokenTextElement element, DifferenceElement kept) {\n        // number of token to skip\n        int step = 0;\n        // verify if the DifferenceElement is a ClassOrInterfaceType with a fully qualified name\n        if (!isTypeWithFullyQualifiedName(kept))\n            return 0;\n        CsmChild child = (CsmChild) kept.getElement();\n        // split the type fully qualified node name to an array of tokens\n        String[] parts = ((ClassOrInterfaceType) child.getChild()).getNameWithScope().split(\"\\\\.\");\n        JavaToken token = element.getToken();\n        for (String part : parts) {\n            if (part.equals(token.asString())) {\n                // get 'dot' token\n                token = token.getNextToken().get();\n                if (!token.asString().equals(\".\"))\n                    break;\n                // get the next part\n                token = token.getNextToken().get();\n                step += 2;\n                continue;\n            }\n            // there is no match so we don't have token to skip\n            step = 0;\n            break;\n        }\n        return step;\n    }\n\n    /*\n     * Returns the number of tokens to skip in originalElements list to synchronize it with the DiffElements list\n     * This is due to the fact that types are considered as token in the originalElements list.\n     * For example,\n     * List<String> is represented by 4 tokens ([List][<][String][>]) while it's a CsmChild element in the DiffElements list\n     * So in this case, getIndexToNextTokenElement(..) on the [List] token returns 3 because we have to skip 3 tokens ([<][String][>]) to synchronize\n     * DiffElements list and originalElements list\n     * The end of recursivity is reached when there is no next token or if the nested diamond operators are totally managed, to take into account this type of declaration\n     * List <List<String>> l\n     * Be careful, this method must be call only if diamond operator could be found in the sequence\n     *\n     * @Param TokenTextElement the token currently analyzed\n     * @Param int the number of nested diamond operators\n     * @return the number of token to skip in originalElements list\n     */\n    private int getIndexToNextTokenElement(TokenTextElement element, int nestedDiamondOperator) {\n        // number of token to skip\n        int step = 0;\n        Optional<JavaToken> next = element.getToken().getNextToken();\n        if (!next.isPresent())\n            return step;\n        // because there is a token, first we need to increment the number of token to skip\n        step++;\n        // manage nested diamond operators by incrementing the level on LT token and decrementing on GT\n        JavaToken nextToken = next.get();\n        Kind kind = Kind.valueOf(nextToken.getKind());\n        if (isDiamondOperator(kind)) {\n            if (kind.GT.equals(kind))\n                nestedDiamondOperator--;\n            else\n                nestedDiamondOperator++;\n        }\n        // manage the fact where the first token is not a diamond operator but a whitespace\n        // and the end of the token sequence to skip\n        // for example in this declaration List <String> a;\n        if (nestedDiamondOperator == 0 && !nextToken.getCategory().isWhitespace())\n            return step;\n        // recursively analyze token to skip\n        return step += getIndexToNextTokenElement(new TokenTextElement(nextToken), nestedDiamondOperator);\n    }\n\n    /*\n     * Returns the number of tokens to skip in originalElements list to synchronize it with the DiffElements list\n     */\n    private int getIndexToNextTokenElementInArrayType(TokenTextElement element, int arrayLevel) {\n        // number of token to skip\n        int step = 0;\n        Optional<JavaToken> next = element.getToken().getNextToken();\n        if (!next.isPresent())\n            return step;\n        // because there is a token, first we need to increment the number of token to skip\n        step++;\n        // manage array Level by decrementing the level on right bracket token\n        JavaToken nextToken = next.get();\n        Kind kind = Kind.valueOf(nextToken.getKind());\n        if (isBracket(kind)) {\n            if (kind.RBRACKET.equals(kind))\n                arrayLevel--;\n        }\n        // manage the fact where the first token is not a diamond operator but a whitespace\n        // and the end of the token sequence to skip\n        // for example in this declaration int [] a;\n        if (arrayLevel == 0 && !nextToken.getCategory().isWhitespace())\n            return step;\n        // recursively analyze token to skip\n        return step += getIndexToNextTokenElementInArrayType(new TokenTextElement(nextToken), arrayLevel);\n    }\n\n    /*\n     * Returns true if the token is possibly a diamond operator\n     */\n    private boolean isDiamondOperator(Kind kind) {\n        return kind.GT.equals(kind) || kind.LT.equals(kind);\n    }\n\n    /*\n     * Returns true if the token is a bracket\n     */\n    private boolean isBracket(Kind kind) {\n        return kind.LBRACKET.equals(kind) || kind.RBRACKET.equals(kind);\n    }\n\n    private boolean openBraceWasOnSameLine() {\n        int index = originalIndex;\n        while (index >= 0 && !nodeText.getTextElement(index).isNewline()) {\n            if (nodeText.getTextElement(index).isToken(LBRACE)) {\n                return true;\n            }\n            index--;\n        }\n        return false;\n    }\n\n    private boolean wasSpaceBetweenBraces() {\n        return nodeText.getTextElement(originalIndex).isToken(RBRACE) && doWeHaveLeftBraceFollowedBySpace(originalIndex - 1) && (diffIndex < 2 || !diffElements.get(diffIndex - 2).isRemoved());\n    }\n\n    private boolean doWeHaveLeftBraceFollowedBySpace(int index) {\n        index = rewindSpace(index);\n        return nodeText.getTextElement(index).isToken(LBRACE);\n    }\n\n    private int rewindSpace(int index) {\n        if (index <= 0) {\n            return index;\n        }\n        if (nodeText.getTextElement(index).isWhiteSpace()) {\n            return rewindSpace(index - 1);\n        } else {\n            return index;\n        }\n    }\n\n    private boolean nextIsRightBrace(int index) {\n        List<TextElement> elements = originalElements.subList(index, originalElements.size());\n        for (TextElement element : elements) {\n            if (!element.isSpaceOrTab()) {\n                return element.isToken(RBRACE);\n            }\n        }\n        return false;\n    }\n\n    private void applyAddedDiffElement(Added added) {\n        if (added.isIndent()) {\n            for (int i = 0; i < STANDARD_INDENTATION_SIZE; i++) {\n                indentation.add(new TokenTextElement(GeneratedJavaParserConstants.SPACE));\n            }\n            addedIndentation = true;\n            diffIndex++;\n            return;\n        }\n        if (added.isUnindent()) {\n            for (int i = 0; i < STANDARD_INDENTATION_SIZE && !indentation.isEmpty(); i++) {\n                indentation.remove(indentation.size() - 1);\n            }\n            addedIndentation = false;\n            diffIndex++;\n            return;\n        }\n        TextElement addedTextElement = added.toTextElement();\n        boolean used = false;\n        boolean isPreviousElementNewline = (originalIndex > 0) && originalElements.get(originalIndex - 1).isNewline();\n        if (isPreviousElementNewline) {\n            List<TextElement> elements = processIndentation(indentation, originalElements.subList(0, originalIndex - 1));\n            boolean nextIsRightBrace = nextIsRightBrace(originalIndex);\n            for (TextElement e : elements) {\n                if (!nextIsRightBrace && e instanceof TokenTextElement && originalElements.get(originalIndex).isToken(((TokenTextElement) e).getTokenKind())) {\n                    originalIndex++;\n                } else {\n                    nodeText.addElement(originalIndex++, e);\n                }\n            }\n        } else if (isAfterLBrace(nodeText, originalIndex) && !isAReplacement(diffIndex)) {\n            if (addedTextElement.isNewline()) {\n                used = true;\n            }\n            nodeText.addElement(originalIndex++, new TokenTextElement(TokenTypes.eolTokenKind()));\n            // This remove the space in \"{ }\" when adding a new line\n            while (originalIndex >= 2 && originalElements.get(originalIndex - 2).isSpaceOrTab()) {\n                originalElements.remove(originalIndex - 2);\n                originalIndex--;\n            }\n            for (TextElement e : processIndentation(indentation, originalElements.subList(0, originalIndex - 1))) {\n                nodeText.addElement(originalIndex++, e);\n            }\n            // Indentation is painful...\n            // Sometimes we want to force indentation: this is the case when indentation was expected but\n            // was actually not there. For example if we have \"{ }\" we would expect indentation but it is\n            // not there, so when adding new elements we force it. However if the indentation has been\n            // inserted by us in this transformation we do not want to insert it again\n            if (!addedIndentation) {\n                for (TextElement e : indentationBlock()) {\n                    nodeText.addElement(originalIndex++, e);\n                }\n            }\n        }\n        if (!used) {\n            // Handling trailing comments\n            boolean sufficientTokensRemainToSkip = nodeText.numberOfElements() > originalIndex + 2;\n            boolean currentIsAComment = nodeText.getTextElement(originalIndex).isComment();\n            boolean previousIsAComment = originalIndex > 0 && nodeText.getTextElement(originalIndex - 1).isComment();\n            boolean currentIsNewline = nodeText.getTextElement(originalIndex).isNewline();\n            boolean isFirstElement = originalIndex == 0;\n            boolean previousIsWhiteSpace = originalIndex > 0 && nodeText.getTextElement(originalIndex - 1).isWhiteSpace();\n\t\t\tboolean commentIsBeforeAddedElement = currentIsAComment && addedTextElement.getRange().isPresent()\n\t\t\t\t\t&& nodeText.getTextElement(originalIndex).getRange()\n\t\t\t\t\t\t\t.map(range -> range.isBefore(addedTextElement.getRange().get())).orElse(false);\n            if (sufficientTokensRemainToSkip && currentIsAComment && commentIsBeforeAddedElement) {\n                // Need to get behind the comment:\n                // FIXME: Why 2? This comment and the next newline?\n                originalIndex += 2;\n                // Defer originalIndex increment\n                nodeText.addElement(originalIndex, addedTextElement);\n                // We want to adjust the indentation while considering the new element that we added\n                originalIndex = adjustIndentation(indentation, nodeText, originalIndex, false);\n                // Now we can increment\n                originalIndex++;\n            } else if (currentIsNewline && previousIsAComment) {\n                /*\n                 * Manage the case where we want to add an element, after an expression which is followed by a comment on the same line.\n                 * This is not the same case as the one who handles the trailing comments, because in this case the node text element is a new line (not a comment)\n                 * For example : {@code private String a; // this is a }\n                 */\n                // Insert after the new line which follows this comment.\n                originalIndex++;\n                // We want to adjust the indentation while considering the new element that we added\n                originalIndex = adjustIndentation(indentation, nodeText, originalIndex, false);\n                // Defer originalIndex increment\n                nodeText.addElement(originalIndex, addedTextElement);\n                // Now we can increment.\n                originalIndex++;\n            } else if (currentIsNewline && addedTextElement.isChild()) {\n                // here we want to place the new child element after the current new line character.\n                // Except if indentation has been inserted just before this step (in the case where isPreviousElementNewline is true)\n                // or if the previous character is a space (it could be the case if we want to replace a statement)\n                // Example 1 : if we insert a statement (a duplicated method call expression ) after this one <code>  value();\\n\\n</code>\n                // we want to have this result <code>  value();\\n  value();\\n</code> not <code>  value();\\n  \\nvalue();</code>\n                // Example 2 : if we want to insert a statement after this one <code>  \\n</code> we want to have <code>  value();\\n</code>\n                // not <code>  \\nvalue();</code> --> this case appears on member replacement for example\n                if (!isPreviousElementNewline && !isFirstElement && !previousIsWhiteSpace) {\n                    // Insert after the new line\n                    originalIndex++;\n                }\n                nodeText.addElement(originalIndex, addedTextElement);\n                originalIndex++;\n            } else {\n                nodeText.addElement(originalIndex, addedTextElement);\n                originalIndex++;\n            }\n        }\n        if (addedTextElement.isNewline()) {\n            boolean followedByUnindent = isFollowedByUnindent(diffElements, diffIndex);\n            boolean nextIsRightBrace = nextIsRightBrace(originalIndex);\n            boolean nextIsNewLine = originalElements.get(originalIndex).isNewline();\n            if ((!nextIsNewLine && !nextIsRightBrace) || followedByUnindent) {\n                originalIndex = adjustIndentation(indentation, nodeText, originalIndex, followedByUnindent);\n            }\n        }\n        diffIndex++;\n    }\n\n    private String tokenDescription(int kind) {\n        return GeneratedJavaParserConstants.tokenImage[kind];\n    }\n\n\t/*\n\t * Considering that the lists of elements are ordered, We can find the common\n\t * elements by starting with the list before the modifications and, for each\n\t * element, by going through the list of elements containing the modifications.\n\t * \n\t * We can find the common elements by starting with the list before the\n\t * modifications (L1) and, for each element, by going through the list of elements\n\t * containing the modifications (L2).\n\t * \n\t * If element A in list L1 is not found in list L2, it is a deleted element. \n\t * If element A of list L1 is found in list L2, it is a kept element. In this\n\t * case the search for the next element of the list L1 must start from the\n\t * position of the last element kept {@code syncNextIndex}.\n\t */\n\tprivate Map<Integer, Integer> getCorrespondanceBetweenNextOrderAndPreviousOrder(CsmMix elementsFromPreviousOrder,\n\t\t\tCsmMix elementsFromNextOrder) {\n\t\tMap<Integer, Integer> correspondanceBetweenNextOrderAndPreviousOrder = new HashMap<>();\n\t\tReadOnlyListIterator<CsmElement> previousOrderElementsIterator = new ReadOnlyListIterator(\n\t\t\t\telementsFromPreviousOrder.getElements());\n\t\tint syncNextIndex = 0;\n\t\twhile (previousOrderElementsIterator.hasNext()) {\n\t\t\tCsmElement pe = previousOrderElementsIterator.next();\n\t\t\tReadOnlyListIterator<CsmElement> nextOrderElementsIterator = new ReadOnlyListIterator(\n\t\t\t\t\telementsFromNextOrder.getElements(), syncNextIndex);\n\t\t\twhile (nextOrderElementsIterator.hasNext()) {\n\t\t\t\tCsmElement ne = nextOrderElementsIterator.next();\n\t\t\t\tif (!correspondanceBetweenNextOrderAndPreviousOrder.values().contains(previousOrderElementsIterator.index())\n\t\t\t\t\t\t&& DifferenceElementCalculator.matching(ne, pe)) {\n\t\t\t\t\tcorrespondanceBetweenNextOrderAndPreviousOrder.put(nextOrderElementsIterator.index(),\n\t\t\t\t\t\t\tpreviousOrderElementsIterator.index());\n\t\t\t\t\t// set the position to start on the next {@code nextOrderElementsIterator} iteration\n\t\t\t\t\tsyncNextIndex = nextOrderElementsIterator.index(); \n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn correspondanceBetweenNextOrderAndPreviousOrder;\n\t}\n    \n    /*\n     * A list iterator which does not allow to modify the list \n     * and which provides a method to know the current positioning \n     */\n    private class ReadOnlyListIterator<T> implements ListIterator<T> {\n    \tListIterator<T> elements;\n    \tpublic ReadOnlyListIterator(List<T> elements) {\n    \t\tthis(elements, 0);\n    \t}\n    \t\n    \tpublic ReadOnlyListIterator(List<T> elements, int index) {\n    \t\tthis.elements = elements.listIterator(index);\n    \t}\n\n\t\t@Override\n\t\tpublic boolean hasNext() {\n\t\t\treturn elements.hasNext();\n\t\t}\n\n\t\t@Override\n\t\tpublic T next() {\n\t\t\treturn elements.next();\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean hasPrevious() {\n\t\t\treturn elements.hasPrevious();\n\t\t}\n\n\t\t@Override\n\t\tpublic T previous() {\n\t\t\treturn elements.previous();\n\t\t}\n\n\t\t@Override\n\t\tpublic int nextIndex() {\n\t\t\treturn elements.nextIndex();\n\t\t}\n\n\t\t@Override\n\t\tpublic int previousIndex() {\n\t\t\treturn elements.previousIndex();\n\t\t}\n\t\t\n\t\t/*\n\t\t * Returns the current index in the underlying list\n\t\t */\n\t\tpublic int index() {\n\t\t\treturn elements.nextIndex() - 1;\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic void remove() {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\n\t\t@Override\n\t\tpublic void set(T e) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\n\t\t@Override\n\t\tpublic void add(T e) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n    \t\n    }\n\n    /*\n     * Returns true if the next element in the list is an added element of type CsmUnindent\n     */\n    private boolean isFollowedByUnindent(List<DifferenceElement> diffElements, int diffIndex) {\n        int nextIndexValue = diffIndex + 1;\n        return (nextIndexValue) < diffElements.size() && diffElements.get(nextIndexValue).isAdded() && diffElements.get(nextIndexValue).getElement() instanceof CsmUnindent;\n    }\n\n    private List<Integer> findIndexOfCorrespondingNodeTextElement(List<CsmElement> elements, NodeText nodeText, int startIndex, Node node) {\n        List<Integer> correspondingIndices = new ArrayList<>();\n        for (ListIterator<CsmElement> csmElementListIterator = elements.listIterator(); csmElementListIterator.hasNext(); ) {\n            int previousCsmElementIndex = csmElementListIterator.previousIndex();\n            CsmElement csmElement = csmElementListIterator.next();\n            int nextCsmElementIndex = csmElementListIterator.nextIndex();\n            Map<MatchClassification, Integer> potentialMatches = new EnumMap<>(MatchClassification.class);\n            for (int i = startIndex; i < nodeText.numberOfElements(); i++) {\n                if (!correspondingIndices.contains(i)) {\n                    TextElement textElement = nodeText.getTextElement(i);\n                    boolean isCorresponding = isCorrespondingElement(textElement, csmElement, node);\n                    if (isCorresponding) {\n                        boolean hasSamePreviousElement = false;\n                        if (i > 0 && previousCsmElementIndex > -1) {\n                            TextElement previousTextElement = nodeText.getTextElement(i - 1);\n                            hasSamePreviousElement = isCorrespondingElement(previousTextElement, elements.get(previousCsmElementIndex), node);\n                        }\n                        boolean hasSameNextElement = false;\n                        if (i < nodeText.numberOfElements() - 1 && nextCsmElementIndex < elements.size()) {\n                            TextElement nextTextElement = nodeText.getTextElement(i + 1);\n                            hasSameNextElement = isCorrespondingElement(nextTextElement, elements.get(nextCsmElementIndex), node);\n                        }\n                        if (hasSamePreviousElement && hasSameNextElement) {\n                            potentialMatches.putIfAbsent(MatchClassification.ALL, i);\n                        } else if (hasSamePreviousElement) {\n                            potentialMatches.putIfAbsent(MatchClassification.PREVIOUS_AND_SAME, i);\n                        } else if (hasSameNextElement) {\n                            potentialMatches.putIfAbsent(MatchClassification.NEXT_AND_SAME, i);\n                        } else {\n                            potentialMatches.putIfAbsent(MatchClassification.SAME_ONLY, i);\n                        }\n                    } else if (isAlmostCorrespondingElement(textElement, csmElement, node)) {\n                        potentialMatches.putIfAbsent(MatchClassification.ALMOST, i);\n                    }\n                }\n            }\n            // Prioritize the matches from best to worst\n            Optional<MatchClassification> bestMatchKey = potentialMatches.keySet().stream().min(Comparator.comparing(MatchClassification::getPriority));\n            if (bestMatchKey.isPresent()) {\n                correspondingIndices.add(potentialMatches.get(bestMatchKey.get()));\n            } else {\n                correspondingIndices.add(-1);\n            }\n        }\n        return correspondingIndices;\n    }\n\n    private enum MatchClassification {\n\n        ALL(1), PREVIOUS_AND_SAME(2), NEXT_AND_SAME(3), SAME_ONLY(4), ALMOST(5);\n\n        private final int priority;\n\n        MatchClassification(int priority) {\n            this.priority = priority;\n        }\n\n        int getPriority() {\n            return priority;\n        }\n    }\n\n    private boolean isCorrespondingElement(TextElement textElement, CsmElement csmElement, Node node) {\n        if (csmElement instanceof CsmToken) {\n            CsmToken csmToken = (CsmToken) csmElement;\n            if (textElement instanceof TokenTextElement) {\n                TokenTextElement tokenTextElement = (TokenTextElement) textElement;\n                return tokenTextElement.getTokenKind() == csmToken.getTokenType() && tokenTextElement.getText().equals(csmToken.getContent(node));\n            }\n        } else if (csmElement instanceof CsmChild) {\n            CsmChild csmChild = (CsmChild) csmElement;\n            if (textElement instanceof ChildTextElement) {\n                ChildTextElement childTextElement = (ChildTextElement) textElement;\n                return childTextElement.getChild() == csmChild.getChild();\n            }\n        } else if (csmElement instanceof CsmIndent) {\n        \tCsmIndent csmIndent = (CsmIndent) csmElement;\n            if (textElement instanceof TokenTextElement) {\n            \tTokenTextElement tokenTextElement = (TokenTextElement) textElement;\n                return tokenTextElement.isSpaceOrTab();\n            }\n        } else {\n            throw new UnsupportedOperationException();\n        }\n        return false;\n    }\n\n    private boolean isAlmostCorrespondingElement(TextElement textElement, CsmElement csmElement, Node node) {\n        if (isCorrespondingElement(textElement, csmElement, node)) {\n            return false;\n        }\n        return textElement.isWhiteSpace() && csmElement instanceof CsmToken && ((CsmToken) csmElement).isWhiteSpace();\n    }\n\n    private int adjustIndentation(List<TokenTextElement> indentation, NodeText nodeText, int nodeTextIndex, boolean followedByUnindent) {\n        List<TextElement> indentationAdj = processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1));\n        if (nodeTextIndex < nodeText.numberOfElements() && nodeText.getTextElement(nodeTextIndex).isToken(RBRACE)) {\n            indentationAdj = indentationAdj.subList(0, indentationAdj.size() - Math.min(STANDARD_INDENTATION_SIZE, indentationAdj.size()));\n        } else if (followedByUnindent) {\n            indentationAdj = indentationAdj.subList(0, Math.max(0, indentationAdj.size() - STANDARD_INDENTATION_SIZE));\n        }\n        for (TextElement e : indentationAdj) {\n            if ((nodeTextIndex < nodeText.numberOfElements()) && nodeText.getTextElement(nodeTextIndex).isSpaceOrTab()) {\n                nodeTextIndex++;\n            } else {\n                nodeText.getElements().add(nodeTextIndex++, e);\n            }\n        }\n        if (nodeTextIndex < 0) {\n            throw new IllegalStateException();\n        }\n        return nodeTextIndex;\n    }\n\n    /*\n     * Returns true if the current <code>Added</code> element is preceded by a <code>Removed</code> element.\n     */\n    private boolean isAReplacement(int diffIndex) {\n        return (diffIndex > 0) && diffElements.get(diffIndex).isAdded() && diffElements.get(diffIndex - 1).isRemoved();\n    }\n\n    /*\n     * Returns true if the current <code>Removed</code> element is followed by a <code>Added</code> element.\n     */\n    private boolean isReplaced(int diffIndex) {\n        return (diffIndex < diffElements.size() - 1) && diffElements.get(diffIndex + 1).isAdded() && diffElements.get(diffIndex).isRemoved();\n    }\n\n    @Override\n    public String toString() {\n        return \"Difference{\" + diffElements + '}';\n    }\n}\n",
        "diffSourceCodeSet": [
            "private int considerIndentation(NodeText nodeText, int nodeTextIndex, int numberOfCharactersToPreserve) {\n        EnforcingIndentationContext enforcingIndentationContext = defineEnforcingIndentationContext(nodeText, nodeTextIndex);\n        // the next position in the list (by default the current position)\n        int res = nodeTextIndex;\n        if (enforcingIndentationContext.extraCharacters > 0) {\n        \tint extraCharacters = enforcingIndentationContext.extraCharacters > numberOfCharactersToPreserve ? enforcingIndentationContext.extraCharacters - numberOfCharactersToPreserve : 0;\n            res = removeExtraCharacters(nodeText, enforcingIndentationContext.start, extraCharacters);\n            // The next position must take into account the indentation\n            res = extraCharacters > 0 ? res + numberOfCharactersToPreserve : res;\n        }\n        if (res < 0) {\n            throw new IllegalStateException();\n        }\n        return res;\n    }"
        ],
        "invokedMethodSet": [
            "methodSignature: com.github.javaparser.printer.lexicalpreservation.Difference#defineEnforcingIndentationContext\n methodBody: private EnforcingIndentationContext defineEnforcingIndentationContext(NodeText nodeText, int nodeTextIndex) {\nEnforcingIndentationContext ctx=new EnforcingIndentationContext(nodeTextIndex);\nif(nodeTextIndex < nodeText.numberOfElements()){for(int i=nodeTextIndex; i >= 0 && i < nodeText.numberOfElements(); i--){if(nodeText.getTextElement(i).isNewline()){break;\n}if(!nodeText.getTextElement(i).isSpaceOrTab()){ctx=new EnforcingIndentationContext(nodeTextIndex);\nbreak;\n}ctx.start=i;\nctx.extraCharacters++;\n}if(nodeText.getTextElement(nodeTextIndex).isSpaceOrTab()){for(int i=nodeTextIndex + 1; i >= 0 && i < nodeText.numberOfElements(); i++){if(!nodeText.getTextElement(i).isSpaceOrTab()){break;\n}ctx.extraCharacters++;\n}}}return ctx;\n}",
            "methodSignature: com.github.javaparser.printer.lexicalpreservation.Difference#removeExtraCharacters\n methodBody: private int removeExtraCharacters(NodeText nodeText, int nodeTextIndex, int extraCharacters) {\nint pos=nodeTextIndex;\nint count=0;\nfor(int i=nodeTextIndex; i >= 0 && i < nodeText.numberOfElements() && count < extraCharacters; i++){if(nodeText.getTextElement(i).isNewline()){break;\n}nodeText.removeElement(pos);\ncount++;\n}return pos;\n}"
        ],
        "sourceCodeAfterRefactoring": "/**\n     * If we are at the beginning of a line, with just spaces or tabs before/after the position of the deleted element\n     * we should force the space to be the same as the current indentation.\n     * This method handles the following case if we remove the modifier {@code public} ([ ] is an indent character)\n     * {@code \n     * [ ][ ]public[ ][ ][ ]void[ ]m{}\n     * <-1-->      <---2--->\n     * 1/ current indentation\n     * 2/ these whitespaces must be removed\n     * }\n     * should produce\n     * {@code \n     * [ ][ ]void[ ]m{} \n     * }\n     */\n    private int considerEnforcingIndentation(NodeText nodeText, int nodeTextIndex) {\n        return considerIndentation(nodeText, nodeTextIndex, indentation.size());\n    }\nprivate int considerIndentation(NodeText nodeText, int nodeTextIndex, int numberOfCharactersToPreserve) {\n        EnforcingIndentationContext enforcingIndentationContext = defineEnforcingIndentationContext(nodeText, nodeTextIndex);\n        // the next position in the list (by default the current position)\n        int res = nodeTextIndex;\n        if (enforcingIndentationContext.extraCharacters > 0) {\n        \tint extraCharacters = enforcingIndentationContext.extraCharacters > numberOfCharactersToPreserve ? enforcingIndentationContext.extraCharacters - numberOfCharactersToPreserve : 0;\n            res = removeExtraCharacters(nodeText, enforcingIndentationContext.start, extraCharacters);\n            // The next position must take into account the indentation\n            res = extraCharacters > 0 ? res + numberOfCharactersToPreserve : res;\n        }\n        if (res < 0) {\n            throw new IllegalStateException();\n        }\n        return res;\n    }",
        "diffSourceCode": "   185:     /**\n   186:      * If we are at the beginning of a line, with just spaces or tabs before/after the position of the deleted element\n   187:      * we should force the space to be the same as the current indentation.\n   188:      * This method handles the following case if we remove the modifier {@code public} ([ ] is an indent character)\n   189:      * {@code \n   190:      * [ ][ ]public[ ][ ][ ]void[ ]m{}\n   191:      * <-1-->      <---2--->\n   192:      * 1/ current indentation\n   193:      * 2/ these whitespaces must be removed\n   194:      * }\n   195:      * should produce\n   196:      * {@code \n   197:      * [ ][ ]void[ ]m{} \n   198:      * }\n   199:      */\n   200:     private int considerEnforcingIndentation(NodeText nodeText, int nodeTextIndex) {\n-  201:         EnforcingIndentationContext enforcingIndentationContext = defineEnforcingIndentationContext(nodeText, nodeTextIndex);\n-  202:         // the next position in the list (by default the current position)\n-  203:         int res = nodeTextIndex;\n-  204:         if (enforcingIndentationContext.extraCharacters > 0) {\n-  205:         \tint extraCharacters = enforcingIndentationContext.extraCharacters > indentation.size() ? enforcingIndentationContext.extraCharacters - indentation.size() : 0;\n-  206:             res = removeExtraCharacters(nodeText, enforcingIndentationContext.start, extraCharacters);\n-  207:             // The next position must take into account the indentation\n-  208:             res = extraCharacters > 0 ? res + indentation.size() : res;\n-  209:         }\n-  210:         if (res < 0) {\n-  211:             throw new IllegalStateException();\n-  212:         }\n-  213:         return res;\n-  214:     }\n-  215:     \n-  216:     /*\n-  217:      * This data structure class hold the starting position of the first whitespace char \n-  218:      * and the number of consecutive whitespace (or tab) characters\n-  219:      */\n-  220:     private class EnforcingIndentationContext {\n-  221:     \tint start;\n-  222:     \tint extraCharacters;\n+  201:         return considerIndentation(nodeText, nodeTextIndex, indentation.size());\n+  202:     }\n+  203:     \n+  204:     private int considerRemovingIndentation(NodeText nodeText, int nodeTextIndex) {\n+  205:         return considerIndentation(nodeText, nodeTextIndex, 0);\n+  206:     }\n+  207:     \n+  208:     private int considerIndentation(NodeText nodeText, int nodeTextIndex, int numberOfCharactersToPreserve) {\n+  209:         EnforcingIndentationContext enforcingIndentationContext = defineEnforcingIndentationContext(nodeText, nodeTextIndex);\n+  210:         // the next position in the list (by default the current position)\n+  211:         int res = nodeTextIndex;\n+  212:         if (enforcingIndentationContext.extraCharacters > 0) {\n+  213:         \tint extraCharacters = enforcingIndentationContext.extraCharacters > numberOfCharactersToPreserve ? enforcingIndentationContext.extraCharacters - numberOfCharactersToPreserve : 0;\n+  214:             res = removeExtraCharacters(nodeText, enforcingIndentationContext.start, extraCharacters);\n+  215:             // The next position must take into account the indentation\n+  216:             res = extraCharacters > 0 ? res + numberOfCharactersToPreserve : res;\n+  217:         }\n+  218:         if (res < 0) {\n+  219:             throw new IllegalStateException();\n+  220:         }\n+  221:         return res;\n+  222:     }\n",
        "uniqueId": "ca3ca0cbd889d07977095289d24591f282157bd8_185_214_208_222_185_202",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 6,
                "covered": 44
            },
            "BRANCH": {
                "missed": 3,
                "covered": 5
            },
            "LINE": {
                "missed": 1,
                "covered": 8
            },
            "COMPLEXITY": {
                "missed": 3,
                "covered": 2
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 17
    },
    {
        "type": "Move Method",
        "description": "Move Method\tpublic getParamPos(node Node) : int from class com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserSymbolDeclaration to private getParamPos(node Node) : int from class com.github.javaparser.symbolsolver.javaparsermodel.TypeExtractor",
        "diffLocations": [
            {
                "filePath": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/declarations/JavaParserSymbolDeclaration.java",
                "startLine": 70,
                "endLine": 79,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/TypeExtractor.java",
                "startLine": 644,
                "endLine": 653,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "public static int getParamPos(Node node) {\n        if (demandParentNode(node) instanceof MethodCallExpr) {\n            MethodCallExpr call = (MethodCallExpr) demandParentNode(node);\n            for (int i = 0; i < call.getArguments().size(); i++) {\n                if (call.getArguments().get(i) == node) return i;\n            }\n            throw new IllegalStateException();\n        }\n        throw new IllegalArgumentException();\n    }",
        "filePathBefore": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/declarations/JavaParserSymbolDeclaration.java",
        "isPureRefactoring": true,
        "commitId": "fa213729c4da1fe0a4e06fbb5360c92a3b7c1267",
        "packageNameBefore": "com.github.javaparser.symbolsolver.javaparsermodel.declarations",
        "classNameBefore": "com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserSymbolDeclaration",
        "methodNameBefore": "com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserSymbolDeclaration#getParamPos",
        "classSignatureBefore": "public final class JavaParserSymbolDeclaration ",
        "methodNameBeforeSet": [
            "com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserSymbolDeclaration#getParamPos"
        ],
        "classNameBeforeSet": [
            "com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserSymbolDeclaration"
        ],
        "classSignatureBeforeSet": [
            "public final class JavaParserSymbolDeclaration "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Copyright (C) 2015-2016 Federico Tomassetti\n * Copyright (C) 2017-2020 The JavaParser Team.\n *\n * This file is part of JavaParser.\n *\n * JavaParser can be used either under the terms of\n * a) the GNU Lesser General Public License as published by\n *     the Free Software Foundation, either version 3 of the License, or\n *     (at your option) any later version.\n * b) the terms of the Apache License\n *\n * You should have received a copy of both licenses in LICENCE.LGPL and\n * LICENCE.APACHE. Please refer to those files for details.\n *\n * JavaParser is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n */\n\npackage com.github.javaparser.symbolsolver.javaparsermodel.declarations;\n\nimport static com.github.javaparser.resolution.Navigator.demandParentNode;\n\nimport com.github.javaparser.ast.Node;\nimport com.github.javaparser.ast.body.Parameter;\nimport com.github.javaparser.ast.body.VariableDeclarator;\nimport com.github.javaparser.ast.expr.MethodCallExpr;\nimport com.github.javaparser.ast.expr.PatternExpr;\nimport com.github.javaparser.resolution.TypeSolver;\n\n/**\n * This should not be used to represent fields of parameters.\n *\n * Eventually this should be renamed in JavaParserVariableDeclaration.\n *\n * @author Federico Tomassetti\n */\npublic final class JavaParserSymbolDeclaration {\n\n    public static JavaParserFieldDeclaration field(VariableDeclarator wrappedNode, TypeSolver typeSolver) {\n        return new JavaParserFieldDeclaration(wrappedNode, typeSolver);\n    }\n\n    public static JavaParserParameterDeclaration parameter(Parameter parameter, TypeSolver typeSolver) {\n        return new JavaParserParameterDeclaration(parameter, typeSolver);\n    }\n\n    public static JavaParserVariableDeclaration localVar(VariableDeclarator variableDeclarator, TypeSolver typeSolver) {\n        return new JavaParserVariableDeclaration(variableDeclarator, typeSolver);\n    }\n\n    public static JavaParserPatternDeclaration patternVar(PatternExpr patternExpr, TypeSolver typeSolver) {\n        return new JavaParserPatternDeclaration(patternExpr, typeSolver);\n    }\n\n    public static int getParamPos(Parameter parameter) {\n        int pos = 0;\n        for (Node node : demandParentNode(parameter).getChildNodes()) {\n            if (node == parameter) {\n                return pos;\n            } else if (node instanceof Parameter) {\n                pos++;\n            }\n        }\n        return pos;\n    }\n\n    public static int getParamPos(Node node) {\n        if (demandParentNode(node) instanceof MethodCallExpr) {\n            MethodCallExpr call = (MethodCallExpr) demandParentNode(node);\n            for (int i = 0; i < call.getArguments().size(); i++) {\n                if (call.getArguments().get(i) == node) return i;\n            }\n            throw new IllegalStateException();\n        }\n        throw new IllegalArgumentException();\n    }\n\n    private JavaParserSymbolDeclaration() {\n        // This private constructor is used to hide the public one\n    }\n\n}\n",
        "filePathAfter": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/TypeExtractor.java",
        "sourceCodeAfterForWhole": "/*\n * Copyright (C) 2015-2016 Federico Tomassetti\n * Copyright (C) 2017-2020 The JavaParser Team.\n *\n * This file is part of JavaParser.\n *\n * JavaParser can be used either under the terms of\n * a) the GNU Lesser General Public License as published by\n *     the Free Software Foundation, either version 3 of the License, or\n *     (at your option) any later version.\n * b) the terms of the Apache License\n *\n * You should have received a copy of both licenses in LICENCE.LGPL and\n * LICENCE.APACHE. Please refer to those files for details.\n *\n * JavaParser is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n */\n\npackage com.github.javaparser.symbolsolver.javaparsermodel;\n\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.Node;\nimport com.github.javaparser.ast.body.FieldDeclaration;\nimport com.github.javaparser.ast.body.Parameter;\nimport com.github.javaparser.ast.body.VariableDeclarator;\nimport com.github.javaparser.ast.expr.*;\nimport com.github.javaparser.ast.stmt.BlockStmt;\nimport com.github.javaparser.ast.stmt.ExpressionStmt;\nimport com.github.javaparser.ast.stmt.ReturnStmt;\nimport com.github.javaparser.ast.type.ClassOrInterfaceType;\nimport com.github.javaparser.ast.type.UnknownType;\nimport com.github.javaparser.resolution.Context;\nimport com.github.javaparser.resolution.MethodUsage;\nimport com.github.javaparser.resolution.Solver;\nimport com.github.javaparser.resolution.TypeSolver;\nimport com.github.javaparser.resolution.UnsolvedSymbolException;\nimport com.github.javaparser.resolution.declarations.*;\nimport com.github.javaparser.resolution.logic.FunctionalInterfaceLogic;\nimport com.github.javaparser.resolution.logic.InferenceContext;\nimport com.github.javaparser.resolution.model.SymbolReference;\nimport com.github.javaparser.resolution.model.Value;\nimport com.github.javaparser.resolution.model.typesystem.LazyType;\nimport com.github.javaparser.resolution.model.typesystem.NullType;\nimport com.github.javaparser.resolution.model.typesystem.ReferenceTypeImpl;\nimport com.github.javaparser.resolution.promotion.ConditionalExprHandler;\nimport com.github.javaparser.resolution.promotion.ConditionalExprResolver;\nimport com.github.javaparser.resolution.types.ResolvedArrayType;\nimport com.github.javaparser.resolution.types.ResolvedPrimitiveType;\nimport com.github.javaparser.resolution.types.ResolvedType;\nimport com.github.javaparser.resolution.types.ResolvedVoidType;\nimport com.github.javaparser.symbolsolver.resolution.SymbolSolver;\nimport com.github.javaparser.utils.Log;\nimport com.github.javaparser.utils.Pair;\nimport com.google.common.collect.ImmutableList;\n\nimport java.util.List;\nimport java.util.Optional;\n\nimport static com.github.javaparser.resolution.Navigator.demandParentNode;\n\npublic class TypeExtractor extends DefaultVisitorAdapter {\n\n    private static final String JAVA_LANG_STRING = String.class.getCanonicalName();\n    private final ResolvedType stringReferenceType;\n\n    private TypeSolver typeSolver;\n    private JavaParserFacade facade;\n    \n\n    public TypeExtractor(TypeSolver typeSolver, JavaParserFacade facade) {\n        this.typeSolver = typeSolver;\n        this.facade = facade;\n        // pre-calculate the String reference (optimization)\n        // consider a LazyType to avoid having to systematically declare a ReflectionTypeSolver\n        stringReferenceType = new LazyType(v -> new ReferenceTypeImpl(typeSolver.solveType(JAVA_LANG_STRING)));\n    }\n\n    @Override\n    public ResolvedType visit(VariableDeclarator node, Boolean solveLambdas) {\n        if (demandParentNode(node) instanceof FieldDeclaration) {\n            return facade.convertToUsage(node.getType());\n        } else if (demandParentNode(node) instanceof VariableDeclarationExpr) {\n            return facade.convertToUsage(node.getType());\n        }\n        throw new UnsupportedOperationException(demandParentNode(node).getClass().getCanonicalName());\n    }\n\n    @Override\n    public ResolvedType visit(Parameter node, Boolean solveLambdas) {\n        if (node.getType() instanceof UnknownType) {\n            throw new IllegalStateException(\"Parameter has unknown type: \" + node);\n        }\n        return facade.convertToUsage(node.getType());\n    }\n\n\n    @Override\n    public ResolvedType visit(ArrayAccessExpr node, Boolean solveLambdas) {\n        ResolvedType arrayUsageType = node.getName().accept(this, solveLambdas);\n        if (arrayUsageType.isArray()) {\n            return ((ResolvedArrayType) arrayUsageType).getComponentType();\n        }\n        return arrayUsageType;\n    }\n\n    @Override\n    public ResolvedType visit(ArrayCreationExpr node, Boolean solveLambdas) {\n        ResolvedType res = facade.convertToUsage(node.getElementType(), JavaParserFactory.getContext(node, typeSolver));\n        for (int i = 0; i < node.getLevels().size(); i++) {\n            res = new ResolvedArrayType(res);\n        }\n        return res;\n    }\n\n    @Override\n    public ResolvedType visit(ArrayInitializerExpr node, Boolean solveLambdas) {\n        throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n    }\n\n    @Override\n    public ResolvedType visit(AssignExpr node, Boolean solveLambdas) {\n        return node.getTarget().accept(this, solveLambdas);\n    }\n\n    @Override\n    public ResolvedType visit(BinaryExpr node, Boolean solveLambdas) {\n        switch (node.getOperator()) {\n            case PLUS:\n            case MINUS:\n            case DIVIDE:\n            case MULTIPLY:\n            case REMAINDER:\n            case BINARY_AND:\n            case BINARY_OR:\n            case XOR:\n                return facade.getBinaryTypeConcrete(node.getLeft(), node.getRight(), solveLambdas, node.getOperator());\n            case LESS_EQUALS:\n            case LESS:\n            case GREATER:\n            case GREATER_EQUALS:\n            case EQUALS:\n            case NOT_EQUALS:\n            case OR:\n            case AND:\n                return ResolvedPrimitiveType.BOOLEAN;\n            case SIGNED_RIGHT_SHIFT:\n            case UNSIGNED_RIGHT_SHIFT:\n            case LEFT_SHIFT:\n                ResolvedType rt = node.getLeft().accept(this, solveLambdas);\n                // apply unary primitive promotion\n                return ResolvedPrimitiveType.unp(rt);\n            default:\n                throw new UnsupportedOperationException(\"Operator \" + node.getOperator().name());\n        }\n    }\n\n    @Override\n    public ResolvedType visit(CastExpr node, Boolean solveLambdas) {\n        return facade.convertToUsage(node.getType(), JavaParserFactory.getContext(node, typeSolver));\n    }\n\n    @Override\n    public ResolvedType visit(ClassExpr node, Boolean solveLambdas) {\n        // This implementation does not regard the actual type argument of the ClassExpr.\n        ResolvedType jssType = facade.convertToUsage(node.getType());\n        return new ReferenceTypeImpl(typeSolver.solveType(Class.class.getCanonicalName()), ImmutableList.of(jssType));\n    }\n\n    /*\n     * The conditional operator has three operand expressions. ? appears between the first and second expressions, and\n     * : appears between the second and third expressions.\n     * There are three kinds of conditional expressions, classified according to the second and third operand\n     * expressions: boolean conditional expressions, numeric conditional expressions, and reference conditional\n     * expressions.\n     * The classification rules are as follows:\n     * 1/ If both the second and the third operand expressions are boolean expressions, the conditional expression is a\n     * boolean conditional expression.\n     * 2/ If both the second and the third operand expressions are numeric expressions, the conditional expression is a\n     * numeric conditional expression.\n     * 3/ Otherwise, the conditional expression is a reference conditional expression\n     */\n    @Override\n    public ResolvedType visit(ConditionalExpr node, Boolean solveLambdas) {\n        ResolvedType thenExpr = node.getThenExpr().accept(this, solveLambdas);\n        ResolvedType elseExpr = node.getElseExpr().accept(this, solveLambdas);\n\n        ConditionalExprHandler rce = ConditionalExprResolver.getConditionExprHandler(thenExpr, elseExpr);\n        try {\n            return rce.resolveType();\n        } catch (UnsupportedOperationException e) {\n            // There is nothing to do because, for the moment, we want to run actual implementation\n        }\n        return node.getThenExpr().accept(this, solveLambdas);\n    }\n    \n    private boolean isCompatible(ResolvedType resolvedType, ResolvedPrimitiveType primitiveType) {\n        return (resolvedType.isPrimitive() && resolvedType.asPrimitive().equals(primitiveType))\n        || (resolvedType.isReferenceType() && resolvedType.asReferenceType().isUnboxableTo(primitiveType));\n    }\n\n    @Override\n    public ResolvedType visit(EnclosedExpr node, Boolean solveLambdas) {\n        return node.getInner().accept(this, solveLambdas);\n    }\n\n    /**\n     * Java Parser can't differentiate between packages, internal types, and fields.\n     * All three are lumped together into FieldAccessExpr. We need to differentiate them.\n     */\n    private ResolvedType solveDotExpressionType(ResolvedReferenceTypeDeclaration parentType, FieldAccessExpr node) {\n        // Fields and internal type declarations cannot have the same name.\n        // Thus, these checks will always be mutually exclusive.\n        if (parentType.isEnum() && parentType.asEnum().hasEnumConstant(node.getName().getId())) {\n            return parentType.asEnum().getEnumConstant(node.getName().getId()).getType();\n        } else if (parentType.hasField(node.getName().getId())) {\n            return parentType.getField(node.getName().getId()).getType();\n        } else if (parentType.hasInternalType(node.getName().getId())) {\n            return new ReferenceTypeImpl(parentType.getInternalType(node.getName().getId()));\n        } else {\n            throw new UnsolvedSymbolException(node.getName().getId());\n        }\n    }\n\n    @Override\n    public ResolvedType visit(FieldAccessExpr node, Boolean solveLambdas) {\n        // We should understand if this is a static access\n        if (node.getScope() instanceof NameExpr ||\n                node.getScope() instanceof FieldAccessExpr) {\n            Expression staticValue = node.getScope();\n            SymbolReference<ResolvedTypeDeclaration> typeAccessedStatically = JavaParserFactory.getContext(node, typeSolver).solveType(staticValue.toString());\n            if (typeAccessedStatically.isSolved()) {\n                // TODO here maybe we have to substitute type typeParametersValues\n                return solveDotExpressionType(\n                        typeAccessedStatically.getCorrespondingDeclaration().asReferenceType(), node);\n            }\n        } else if (node.getScope() instanceof ThisExpr) {\n            // If we are accessing through a 'this' expression, first resolve the type\n            // corresponding to 'this'\n            SymbolReference<ResolvedTypeDeclaration> solve = facade.solve((ThisExpr) node.getScope());\n            // If found get it's declaration and get the field in there\n            if (solve.isSolved()) {\n                ResolvedTypeDeclaration correspondingDeclaration = solve.getCorrespondingDeclaration();\n                if (correspondingDeclaration instanceof ResolvedReferenceTypeDeclaration) {\n                    return solveDotExpressionType(correspondingDeclaration.asReferenceType(), node);\n                }\n            }\n\n        } else if (node.getScope().toString().indexOf('.') > 0) {\n            // try to find fully qualified name\n            SymbolReference<ResolvedReferenceTypeDeclaration> sr = typeSolver.tryToSolveType(node.getScope().toString());\n            if (sr.isSolved()) {\n                return solveDotExpressionType(sr.getCorrespondingDeclaration(), node);\n            }\n        }\n        Optional<Value> value = Optional.empty();\n        try {\n            value = createSolver().solveSymbolAsValue(node.getName().getId(), node);\n        } catch (UnsolvedSymbolException use) {\n            // This node may have a package name as part of its fully qualified name.\n            // We should solve for the type declaration inside this package.\n            SymbolReference<ResolvedReferenceTypeDeclaration> sref = typeSolver.tryToSolveType(node.toString());\n            if (sref.isSolved()) {\n                return new ReferenceTypeImpl(sref.getCorrespondingDeclaration());\n            }\n        }\n        if (value.isPresent()) {\n            return value.get().getType();\n        }\n        throw new UnsolvedSymbolException(node.getName().getId());\n    }\n\n    @Override\n    public ResolvedType visit(InstanceOfExpr node, Boolean solveLambdas) {\n        return ResolvedPrimitiveType.BOOLEAN;\n    }\n\n    @Override\n    public ResolvedType visit(StringLiteralExpr node, Boolean solveLambdas) {\n        return stringReferenceType;\n    }\n\n    @Override\n    public ResolvedType visit(IntegerLiteralExpr node, Boolean solveLambdas) {\n        return ResolvedPrimitiveType.INT;\n    }\n\n    @Override\n    public ResolvedType visit(LongLiteralExpr node, Boolean solveLambdas) {\n        return ResolvedPrimitiveType.LONG;\n    }\n\n    @Override\n    public ResolvedType visit(CharLiteralExpr node, Boolean solveLambdas) {\n        return ResolvedPrimitiveType.CHAR;\n    }\n\n    @Override\n    public ResolvedType visit(DoubleLiteralExpr node, Boolean solveLambdas) {\n        if (node.getValue().toLowerCase().endsWith(\"f\")) {\n            return ResolvedPrimitiveType.FLOAT;\n        }\n        return ResolvedPrimitiveType.DOUBLE;\n    }\n\n    @Override\n    public ResolvedType visit(BooleanLiteralExpr node, Boolean solveLambdas) {\n        return ResolvedPrimitiveType.BOOLEAN;\n    }\n\n    @Override\n    public ResolvedType visit(NullLiteralExpr node, Boolean solveLambdas) {\n        return NullType.INSTANCE;\n    }\n\n    @Override\n    public ResolvedType visit(MethodCallExpr node, Boolean solveLambdas) {\n        Log.trace(\"getType on method call %s\", ()-> node);\n        // first solve the method\n        MethodUsage ref = facade.solveMethodAsUsage(node);\n        Log.trace(\"getType on method call %s resolved to %s\", ()-> node, ()-> ref);\n        Log.trace(\"getType on method call %s return type is %s\", ()-> node, ref::returnType);\n        return ref.returnType();\n        // the type is the return type of the method\n    }\n\n    @Override\n    public ResolvedType visit(NameExpr node, Boolean solveLambdas) {\n        Log.trace(\"getType on name expr %s\", ()-> node);\n        Optional<Value> value = createSolver().solveSymbolAsValue(node.getName().getId(), node);\n        if (!value.isPresent()) {\n            throw new UnsolvedSymbolException(\"Solving \" + node, node.getName().getId());\n        } else {\n            return value.get().getType();\n        }\n    }\n\n    @Override\n    public ResolvedType visit(TypeExpr node, Boolean solveLambdas) {\n        Log.trace(\"getType on type expr %s\", ()-> node);\n        if (!(node.getType() instanceof ClassOrInterfaceType)) {\n            throw new UnsupportedOperationException(node.getType().getClass().getCanonicalName());\n        }\n\n        ClassOrInterfaceType classOrInterfaceType = (ClassOrInterfaceType) node.getType();\n        String nameWithScope = classOrInterfaceType.getNameWithScope();\n\n        // JLS 15.13 - ReferenceType :: [TypeArguments] Identifier\n        SymbolReference<ResolvedTypeDeclaration> typeDeclarationSymbolReference = JavaParserFactory\n                .getContext(classOrInterfaceType, typeSolver)\n                .solveType(nameWithScope);\n        if (typeDeclarationSymbolReference.isSolved()) {\n            return new ReferenceTypeImpl(typeDeclarationSymbolReference.getCorrespondingDeclaration().asReferenceType());\n        }\n\n        // JLS 15.13 - ExpressionName :: [TypeArguments] Identifier\n        Optional<Value> value = createSolver().solveSymbolAsValue(nameWithScope, node);\n        if (value.isPresent()) {\n            return value.get().getType();\n        }\n\n        throw new UnsolvedSymbolException(\"Solving \" + node, classOrInterfaceType.getName().getId());\n    }\n\n    @Override\n    public ResolvedType visit(ObjectCreationExpr node, Boolean solveLambdas) {\n        return facade.convertToUsage(node.getType());\n    }\n\n    @Override\n    public ResolvedType visit(ThisExpr node, Boolean solveLambdas) {\n        // If 'this' is prefixed by a class eg. MyClass.this\n        if (node.getTypeName().isPresent()) {\n            // Get the class name\n            String className = node.getTypeName().get().asString();\n            // Attempt to resolve locally in Compilation unit\n            // first try a buttom/up approach\n            try {\n                return new ReferenceTypeImpl(\n                        facade.getTypeDeclaration(facade.findContainingTypeDeclOrObjectCreationExpr(node, className)));\n            } catch (IllegalStateException e) {\n                // trying another approach from type solver\n                Optional<CompilationUnit> cu = node.findAncestor(CompilationUnit.class);\n                SymbolReference<ResolvedReferenceTypeDeclaration> clazz = typeSolver.tryToSolveType(className);\n                if (clazz.isSolved()) {\n                    return new ReferenceTypeImpl(clazz.getCorrespondingDeclaration());\n                }\n            }\n        }\n        return new ReferenceTypeImpl(facade.getTypeDeclaration(facade.findContainingTypeDeclOrObjectCreationExpr(node)));\n    }\n\n    @Override\n    public ResolvedType visit(SuperExpr node, Boolean solveLambdas) {\n        // If 'super' is prefixed by a class eg. MyClass.this\n        if (node.getTypeName().isPresent()) {\n            String className = node.getTypeName().get().asString();\n            SymbolReference<ResolvedTypeDeclaration> resolvedTypeNameRef = JavaParserFactory.getContext(node, typeSolver).solveType(className);\n            if (resolvedTypeNameRef.isSolved()) {\n                // Cfr JLS $15.12.1\n                ResolvedTypeDeclaration resolvedTypeName = resolvedTypeNameRef.getCorrespondingDeclaration();\n                if (resolvedTypeName.isInterface()) {\n                    return new ReferenceTypeImpl(resolvedTypeName.asInterface());\n                } else if (resolvedTypeName.isClass()) {\n                    // TODO: Maybe include a presence check? e.g. in the case of `java.lang.Object` there will be no superclass.\n                    return resolvedTypeName.asClass().getSuperClass().orElseThrow(() -> new RuntimeException(\"super class unexpectedly empty\"));\n                } else {\n                    throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n                }\n            } else {\n                throw new UnsolvedSymbolException(className);\n            }\n        }\n\n        ResolvedTypeDeclaration typeOfNode = facade.getTypeDeclaration(facade.findContainingTypeDeclOrObjectCreationExpr(node));\n        if (typeOfNode instanceof ResolvedClassDeclaration) {\n            // TODO: Maybe include a presence check? e.g. in the case of `java.lang.Object` there will be no superclass.\n            return ((ResolvedClassDeclaration) typeOfNode).getSuperClass().orElseThrow(() -> new RuntimeException(\"super class unexpectedly empty\"));\n        } else {\n            throw new UnsupportedOperationException(node.getClass().getCanonicalName());\n        }\n    }\n\n    @Override\n    public ResolvedType visit(UnaryExpr node, Boolean solveLambdas) {\n        switch (node.getOperator()) {\n            case MINUS:\n            case PLUS:\n                return ResolvedPrimitiveType.unp(node.getExpression().accept(this, solveLambdas));\n            case LOGICAL_COMPLEMENT:\n                return ResolvedPrimitiveType.BOOLEAN;\n            case POSTFIX_DECREMENT:\n            case PREFIX_DECREMENT:\n            case POSTFIX_INCREMENT:\n            case PREFIX_INCREMENT:\n            case BITWISE_COMPLEMENT:\n                return node.getExpression().accept(this, solveLambdas);\n            default:\n                throw new UnsupportedOperationException(node.getOperator().name());\n        }\n    }\n\n    @Override\n    public ResolvedType visit(VariableDeclarationExpr node, Boolean solveLambdas) {\n        if (node.getVariables().size() != 1) {\n            throw new UnsupportedOperationException();\n        }\n        return facade.convertToUsage(node.getVariables().get(0).getType());\n    }\n\n\n    @Override\n    public ResolvedType visit(LambdaExpr node, Boolean solveLambdas) {\n        if (demandParentNode(node) instanceof MethodCallExpr) {\n            MethodCallExpr callExpr = (MethodCallExpr) demandParentNode(node);\n            int pos = getParamPos(node);\n            SymbolReference<ResolvedMethodDeclaration> refMethod = facade.solve(callExpr);\n            if (!refMethod.isSolved()) {\n                throw new UnsolvedSymbolException(demandParentNode(node).toString(), callExpr.getName().getId());\n            }\n            Log.trace(\"getType on lambda expr %s\", ()-> refMethod.getCorrespondingDeclaration().getName());\n\n            // The type parameter referred here should be the java.util.stream.Stream.T\n            ResolvedType result = refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n\n            if (solveLambdas) {\n                if (callExpr.hasScope()) {\n                    Expression scope = callExpr.getScope().get();\n\n                    // If it is a static call we should not try to get the type of the scope\n                    boolean staticCall = false;\n                    if (scope instanceof NameExpr) {\n                        NameExpr nameExpr = (NameExpr) scope;\n                        try {\n                            SymbolReference<ResolvedTypeDeclaration> type = JavaParserFactory.getContext(nameExpr, typeSolver).solveType(nameExpr.getName().getId());\n                            if (type.isSolved()) {\n                                staticCall = true;\n                            }\n                        } catch (Exception e) {\n\n                        }\n                    }\n\n                    if (!staticCall) {\n                        ResolvedType scopeType = facade.getType(scope);\n                        if (scopeType.isReferenceType()) {\n                            result = scopeType.asReferenceType().useThisTypeParametersOnTheGivenType(result);\n                        }\n                    }\n                }\n\n                result = resolveLambda(node, result);\n            }\n            return result;\n        } else if (demandParentNode(node) instanceof VariableDeclarator)\n        {\n            VariableDeclarator decExpr = (VariableDeclarator) demandParentNode(node);\n            ResolvedType result = decExpr.getType().resolve();\n\n            if (solveLambdas) {\n                result = resolveLambda(node, result);\n            }\n            return result;\n        } else if (demandParentNode(node) instanceof AssignExpr) {\n            AssignExpr assExpr = (AssignExpr) demandParentNode(node);\n            ResolvedType result = assExpr.calculateResolvedType();\n\n            if (solveLambdas) {\n                result = resolveLambda(node, result);\n            }\n            return result;\n        } else {\n            throw new UnsupportedOperationException(\"The type of a lambda expr depends on the position and its return value\");\n        }\n    }\n\n    private ResolvedType resolveLambda(LambdaExpr node, ResolvedType result) {\n        // We need to replace the type variables\n        Context ctx = JavaParserFactory.getContext(node, typeSolver);\n        result = result.solveGenericTypes(ctx);\n\n        //We should find out which is the functional method (e.g., apply) and replace the params of the\n        //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n        //lambdas\n        Optional<MethodUsage> functionalMethod = FunctionalInterfaceLogic.getFunctionalMethod(result);\n        if (functionalMethod.isPresent()) {\n            LambdaExpr lambdaExpr = node;\n\n            InferenceContext lambdaCtx = new InferenceContext(typeSolver);\n            InferenceContext funcInterfaceCtx = new InferenceContext(typeSolver);\n\n            // At this point parameterType\n            // if Function<T=? super Stream.T, ? extends map.R>\n            // we should replace Stream.T\n            ResolvedType functionalInterfaceType = ReferenceTypeImpl.undeterminedParameters(functionalMethod.get().getDeclaration().declaringType());\n\n            lambdaCtx.addPair(result, functionalInterfaceType);\n\n            ResolvedType actualType;\n\n            if (lambdaExpr.getBody() instanceof ExpressionStmt) {\n                actualType = facade.getType(((ExpressionStmt) lambdaExpr.getBody()).getExpression());\n            } else if (lambdaExpr.getBody() instanceof BlockStmt) {\n                BlockStmt blockStmt = (BlockStmt) lambdaExpr.getBody();\n\n                // Get all the return statements in the lambda block\n                List<ReturnStmt> returnStmts = blockStmt.findAll(ReturnStmt.class);\n\n                if (returnStmts.size() > 0) {\n                    actualType = returnStmts.stream()\n                            .map(returnStmt -> returnStmt.getExpression().map(e -> facade.getType(e)).orElse(ResolvedVoidType.INSTANCE))\n                            .filter(x -> x != null && !x.isVoid() && !x.isNull())\n                            .findFirst()\n                            .orElse(ResolvedVoidType.INSTANCE);\n\n                } else {\n                    actualType = ResolvedVoidType.INSTANCE;\n                }\n\n\n            } else {\n                throw new UnsupportedOperationException();\n            }\n\n            ResolvedType formalType = functionalMethod.get().returnType();\n\n            // Infer the functional interfaces' return vs actual type\n            funcInterfaceCtx.addPair(formalType, actualType);\n            // Substitute to obtain a new type\n            ResolvedType functionalTypeWithReturn = funcInterfaceCtx.resolve(funcInterfaceCtx.addSingle(functionalInterfaceType));\n\n            // if the functional method returns void anyway\n            // we don't need to bother inferring types\n            if (!(formalType instanceof ResolvedVoidType)) {\n                lambdaCtx.addPair(result, functionalTypeWithReturn);\n                result = lambdaCtx.resolve(lambdaCtx.addSingle(result));\n            }\n        }\n        return result;\n    }\n\n    @Override\n    public ResolvedType visit(MethodReferenceExpr node, Boolean solveLambdas) {\n        if (demandParentNode(node) instanceof MethodCallExpr) {\n            MethodCallExpr callExpr = (MethodCallExpr) demandParentNode(node);\n            int pos = getParamPos(node);\n            SymbolReference<ResolvedMethodDeclaration> refMethod = facade.solve(callExpr, false);\n            if (!refMethod.isSolved()) {\n                throw new UnsolvedSymbolException(demandParentNode(node).toString(), callExpr.getName().getId());\n            }\n            Log.trace(\"getType on method reference expr %s\", ()-> refMethod.getCorrespondingDeclaration().getName());\n            if (solveLambdas) {\n                MethodUsage usage = facade.solveMethodAsUsage(callExpr);\n                ResolvedType result = usage.getParamType(pos);\n                // We need to replace the type variables\n                Context ctx = JavaParserFactory.getContext(node, typeSolver);\n                result = result.solveGenericTypes(ctx);\n\n                //We should find out which is the functional method (e.g., apply) and replace the params of the\n                //solveLambdas with it, to derive so the values. We should also consider the value returned by the\n                //lambdas\n                Optional<MethodUsage> functionalMethodOpt = FunctionalInterfaceLogic.getFunctionalMethod(result);\n                if (functionalMethodOpt.isPresent()) {\n                    MethodUsage functionalMethod = functionalMethodOpt.get();\n\n                    for (Pair<ResolvedTypeParameterDeclaration, ResolvedType> typeParamDecl : result.asReferenceType().getTypeParametersMap()) {\n                        functionalMethod = functionalMethod.replaceTypeParameter(typeParamDecl.a, typeParamDecl.b);\n                    }\n\n                    // replace wildcards\n                    for (int i = 0; i < functionalMethod.getNoParams(); i++) {\n                        ResolvedType type = functionalMethod.getParamType(i);\n                        if (type.isWildcard()) {\n                            ResolvedType boundedType = type.asWildcard().getBoundedType();\n                            functionalMethod = functionalMethod.replaceParamType(i, boundedType);\n                        }\n                    }\n\n                    ResolvedType actualType = facade.toMethodUsage(node, functionalMethod.getParamTypes()).returnType();\n                    ResolvedType formalType = functionalMethod.returnType();\n\n                    InferenceContext inferenceContext = new InferenceContext(typeSolver);\n                    inferenceContext.addPair(formalType, actualType);\n                    result = inferenceContext.resolve(inferenceContext.addSingle(result));\n                }\n\n                return result;\n            }\n            return refMethod.getCorrespondingDeclaration().getParam(pos).getType();\n        }\n        throw new UnsupportedOperationException(\"The type of a method reference expr depends on the position and its return value\");\n    }\n\n    @Override\n    public ResolvedType visit(FieldDeclaration node, Boolean solveLambdas) {\n        if (node.getVariables().size() == 1) {\n            return node.getVariables().get(0).accept(this, solveLambdas);\n        }\n        throw new IllegalArgumentException(\"Cannot resolve the type of a field with multiple variable declarations. Pick one\");\n    }\n    \n    private static int getParamPos(Node node) {\n        if (demandParentNode(node) instanceof MethodCallExpr) {\n            MethodCallExpr call = (MethodCallExpr) demandParentNode(node);\n            for (int i = 0; i < call.getArguments().size(); i++) {\n                if (call.getArguments().get(i) == node) return i;\n            }\n            throw new IllegalStateException();\n        }\n        throw new IllegalArgumentException();\n    }\n\n    protected Solver createSolver() {\n        return new SymbolSolver(typeSolver);\n    }\n}\n",
        "diffSourceCodeSet": [],
        "invokedMethodSet": [],
        "sourceCodeAfterRefactoring": "private static int getParamPos(Node node) {\n        if (demandParentNode(node) instanceof MethodCallExpr) {\n            MethodCallExpr call = (MethodCallExpr) demandParentNode(node);\n            for (int i = 0; i < call.getArguments().size(); i++) {\n                if (call.getArguments().get(i) == node) return i;\n            }\n            throw new IllegalStateException();\n        }\n        throw new IllegalArgumentException();\n    }",
        "diffSourceCode": "-   70:     public static int getParamPos(Node node) {\n-   71:         if (demandParentNode(node) instanceof MethodCallExpr) {\n-   72:             MethodCallExpr call = (MethodCallExpr) demandParentNode(node);\n-   73:             for (int i = 0; i < call.getArguments().size(); i++) {\n-   74:                 if (call.getArguments().get(i) == node) return i;\n-   75:             }\n-   76:             throw new IllegalStateException();\n-   77:         }\n-   78:         throw new IllegalArgumentException();\n+   70:     private JavaParserFacade facade;\n+   71:     \n+   72: \n+   73:     public TypeExtractor(TypeSolver typeSolver, JavaParserFacade facade) {\n+   74:         this.typeSolver = typeSolver;\n+   75:         this.facade = facade;\n+   76:         // pre-calculate the String reference (optimization)\n+   77:         // consider a LazyType to avoid having to systematically declare a ReflectionTypeSolver\n+   78:         stringReferenceType = new LazyType(v -> new ReferenceTypeImpl(typeSolver.solveType(JAVA_LANG_STRING)));\n    79:     }\n+  644:     private static int getParamPos(Node node) {\n+  645:         if (demandParentNode(node) instanceof MethodCallExpr) {\n+  646:             MethodCallExpr call = (MethodCallExpr) demandParentNode(node);\n+  647:             for (int i = 0; i < call.getArguments().size(); i++) {\n+  648:                 if (call.getArguments().get(i) == node) return i;\n+  649:             }\n+  650:             throw new IllegalStateException();\n+  651:         }\n+  652:         throw new IllegalArgumentException();\n+  653:     }\n",
        "uniqueId": "fa213729c4da1fe0a4e06fbb5360c92a3b7c1267_70_79__644_653",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 8,
                "covered": 25
            },
            "BRANCH": {
                "missed": 2,
                "covered": 4
            },
            "LINE": {
                "missed": 2,
                "covered": 4
            },
            "COMPLEXITY": {
                "missed": 2,
                "covered": 2
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 17
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprivate replaceTypeParameter(methodUsage MethodUsage, matchedTypeParameters Map<ResolvedTypeParameterDeclaration,ResolvedType>) : MethodUsage extracted from private resolveMethodTypeParameters(methodUsage MethodUsage, actualParamTypes List<ResolvedType>) : MethodUsage in class com.github.javaparser.symbolsolver.javaparsermodel.contexts.MethodCallExprContext",
        "diffLocations": [
            {
                "filePath": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/MethodCallExprContext.java",
                "startLine": 332,
                "endLine": 379,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/MethodCallExprContext.java",
                "startLine": 334,
                "endLine": 397,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/MethodCallExprContext.java",
                "startLine": 399,
                "endLine": 405,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "private MethodUsage resolveMethodTypeParameters(MethodUsage methodUsage, List<ResolvedType> actualParamTypes) {\n        Map<ResolvedTypeParameterDeclaration, ResolvedType> matchedTypeParameters = new HashMap<>();\n\n        if (methodUsage.getDeclaration().hasVariadicParameter()) {\n            if (actualParamTypes.size() == methodUsage.getDeclaration().getNumberOfParams()) {\n                // the varargs parameter is an Array, so extract the inner type\n                ResolvedType expectedType =\n                    methodUsage.getDeclaration().getLastParam().getType().asArrayType().getComponentType();\n                // the varargs corresponding type can be either T or Array<T>\n                ResolvedType actualType =\n                    actualParamTypes.get(actualParamTypes.size() - 1).isArray() ?\n                        actualParamTypes.get(actualParamTypes.size() - 1).asArrayType().getComponentType() :\n                        actualParamTypes.get(actualParamTypes.size() - 1);\n                if (!expectedType.isAssignableBy(actualType)) {\n                    for (ResolvedTypeParameterDeclaration tp : methodUsage.getDeclaration().getTypeParameters()) {\n                        expectedType = MethodResolutionLogic.replaceTypeParam(expectedType, tp, typeSolver);\n                    }\n                }\n                if (!expectedType.isAssignableBy(actualType)) {\n                    // ok, then it needs to be wrapped\n                    throw new UnsupportedOperationException(\n                        String.format(\"Unable to resolve the type typeParametersValues in a MethodUsage. Expected type: %s, Actual type: %s. Method Declaration: %s. MethodUsage: %s\",\n                                      expectedType,\n                                      actualType,\n                                      methodUsage.getDeclaration(),\n                                      methodUsage));\n                }\n                // match only the varargs type\n                matchTypeParameters(expectedType, actualType, matchedTypeParameters);\n            } else {\n                return methodUsage;\n            }\n        }\n\n        int until = methodUsage.getDeclaration().hasVariadicParameter() ?\n            actualParamTypes.size() - 1 :\n            actualParamTypes.size();\n\n        for (int i = 0; i < until; i++) {\n            ResolvedType expectedType = methodUsage.getParamType(i);\n            ResolvedType actualType = actualParamTypes.get(i);\n            matchTypeParameters(expectedType, actualType, matchedTypeParameters);\n        }\n        for (ResolvedTypeParameterDeclaration tp : matchedTypeParameters.keySet()) {\n            methodUsage = methodUsage.replaceTypeParameter(tp, matchedTypeParameters.get(tp));\n        }\n        return methodUsage;\n    }",
        "filePathBefore": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/MethodCallExprContext.java",
        "isPureRefactoring": true,
        "commitId": "3b6ee2e9f72d824eb11cc3e0afca8bed76b37df6",
        "packageNameBefore": "com.github.javaparser.symbolsolver.javaparsermodel.contexts",
        "classNameBefore": "com.github.javaparser.symbolsolver.javaparsermodel.contexts.MethodCallExprContext",
        "methodNameBefore": "com.github.javaparser.symbolsolver.javaparsermodel.contexts.MethodCallExprContext#resolveMethodTypeParameters",
        "invokedMethod": "methodSignature: com.github.javaparser.symbolsolver.javaparsermodel.contexts.MethodCallExprContext#matchTypeParameters\n methodBody: private void matchTypeParameters(ResolvedType expectedType, ResolvedType actualType, Map<ResolvedTypeParameterDeclaration, ResolvedType> matchedTypeParameters) {\nif(expectedType.isTypeVariable()){ResolvedType type=actualType;\nif(type.isPrimitive()){type=MyObjectProvider.INSTANCE.byName(type.asPrimitive().getBoxTypeQName());\n}if(type.isNull()){type=MyObjectProvider.INSTANCE.object();\n}if(!type.isTypeVariable() && !type.isReferenceType()){throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n}matchedTypeParameters.put(expectedType.asTypeParameter(),type);\n}if(expectedType.isArray()){if(!(actualType.isArray() || actualType.isNull())){throw new UnsupportedOperationException(actualType.getClass().getCanonicalName());\n}matchTypeParameters(expectedType.asArrayType().getComponentType(),actualType.isNull() ? actualType : actualType.asArrayType().getComponentType(),matchedTypeParameters);\n}if(expectedType.isReferenceType()){if(actualType.isReferenceType() && actualType.asReferenceType().typeParametersValues().size() > 0){int i=0;\nfor(ResolvedType tp: expectedType.asReferenceType().typeParametersValues()){matchTypeParameters(tp,actualType.asReferenceType().typeParametersValues().get(i),matchedTypeParameters);\ni++;\n}}}if(expectedType.isPrimitive()){}if(expectedType.isWildcard()){}{throw new UnsupportedOperationException(expectedType.getClass().getCanonicalName());\n}}",
        "classSignatureBefore": "public class MethodCallExprContext extends AbstractJavaParserContext<MethodCallExpr> ",
        "methodNameBeforeSet": [
            "com.github.javaparser.symbolsolver.javaparsermodel.contexts.MethodCallExprContext#resolveMethodTypeParameters"
        ],
        "classNameBeforeSet": [
            "com.github.javaparser.symbolsolver.javaparsermodel.contexts.MethodCallExprContext"
        ],
        "classSignatureBeforeSet": [
            "public class MethodCallExprContext extends AbstractJavaParserContext<MethodCallExpr> "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Copyright (C) 2015-2016 Federico Tomassetti\n * Copyright (C) 2017-2020 The JavaParser Team.\n *\n * This file is part of JavaParser.\n *\n * JavaParser can be used either under the terms of\n * a) the GNU Lesser General Public License as published by\n *     the Free Software Foundation, either version 3 of the License, or\n *     (at your option) any later version.\n * b) the terms of the Apache License\n *\n * You should have received a copy of both licenses in LICENCE.LGPL and\n * LICENCE.APACHE. Please refer to those files for details.\n *\n * JavaParser is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n */\n\npackage com.github.javaparser.symbolsolver.javaparsermodel.contexts;\n\nimport com.github.javaparser.ast.expr.Expression;\nimport com.github.javaparser.ast.expr.MethodCallExpr;\nimport com.github.javaparser.ast.expr.NameExpr;\nimport com.github.javaparser.resolution.Context;\nimport com.github.javaparser.resolution.MethodUsage;\nimport com.github.javaparser.resolution.TypeSolver;\nimport com.github.javaparser.resolution.UnsolvedSymbolException;\nimport com.github.javaparser.resolution.declarations.*;\nimport com.github.javaparser.resolution.model.SymbolReference;\nimport com.github.javaparser.resolution.model.Value;\nimport com.github.javaparser.resolution.model.typesystem.ReferenceTypeImpl;\nimport com.github.javaparser.resolution.types.*;\nimport com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade;\nimport com.github.javaparser.symbolsolver.reflectionmodel.MyObjectProvider;\nimport com.github.javaparser.symbolsolver.reflectionmodel.ReflectionClassDeclaration;\nimport com.github.javaparser.symbolsolver.resolution.MethodResolutionLogic;\nimport com.github.javaparser.utils.Pair;\n\nimport java.util.*;\n\npublic class MethodCallExprContext extends AbstractJavaParserContext<MethodCallExpr> {\n\n    ///\n    /// Constructors\n    ///\n\n    public MethodCallExprContext(MethodCallExpr wrappedNode, TypeSolver typeSolver) {\n        super(wrappedNode, typeSolver);\n    }\n\n    ///\n    /// Public methods\n    ///\n\n    @Override\n    public Optional<ResolvedType> solveGenericType(String name) {\n        Optional<Expression> nodeScope = wrappedNode.getScope();\n        if (!nodeScope.isPresent()) {\n            return Optional.empty();\n        }\n\n        // Method calls can have generic types defined, for example: {@code expr.<T1, T2>method(x, y, z);} or {@code super.<T, E>check2(val1, val2).}\n        ResolvedType typeOfScope = JavaParserFacade.get(typeSolver).getType(nodeScope.get());\n        Optional<ResolvedType> resolvedType = typeOfScope.asReferenceType().getGenericParameterByName(name);\n\n        // TODO/FIXME: Consider if we should check if the result is present, else delegate \"up\" the context chain (e.g. {@code solveGenericTypeInParent()})\n        return resolvedType;\n    }\n\n    @Override\n    public String toString() {\n        return \"MethodCallExprContext{wrapped=\" + wrappedNode + \"}\";\n    }\n\n    @Override\n    public Optional<MethodUsage> solveMethodAsUsage(String name, List<ResolvedType> argumentsTypes) {\n        ResolvedType typeOfScope;\n        if (wrappedNode.hasScope()) {\n            Expression scope = wrappedNode.getScope().get();\n            // Consider static method calls\n            if (scope instanceof NameExpr) {\n                String className = ((NameExpr) scope).getName().getId();\n                SymbolReference<ResolvedTypeDeclaration> ref = solveType(className);\n                if (ref.isSolved()) {\n                    SymbolReference<ResolvedMethodDeclaration> m = MethodResolutionLogic.solveMethodInType(ref.getCorrespondingDeclaration(), name, argumentsTypes);\n                    if (m.isSolved()) {\n                        MethodUsage methodUsage = new MethodUsage(m.getCorrespondingDeclaration());\n                        methodUsage = resolveMethodTypeParametersFromExplicitList(typeSolver, methodUsage);\n                        methodUsage = resolveMethodTypeParameters(methodUsage, argumentsTypes);\n                        return Optional.of(methodUsage);\n                    } else {\n                        throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(),\n                                \"Method '\" + name + \"' with parameterTypes \" + argumentsTypes);\n                    }\n                }\n            }\n\n            // Scope is present -- search/solve within that type\n            typeOfScope = JavaParserFacade.get(typeSolver).getType(scope);\n        } else {\n            // Scope not present -- search/solve within itself.\n            typeOfScope = JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n        }\n\n        // we can replace the parameter types from the scope into the typeParametersValues\n        Map<ResolvedTypeParameterDeclaration, ResolvedType> inferredTypes = new HashMap<>();\n        for (int i = 0; i < argumentsTypes.size(); i++) {\n            // by replacing types I can also find new equivalences\n            // for example if I replace T=U with String because I know that T=String I can derive that also U equal String\n            ResolvedType originalArgumentType = argumentsTypes.get(i);\n            ResolvedType updatedArgumentType = usingParameterTypesFromScope(typeOfScope, originalArgumentType, inferredTypes);\n            argumentsTypes.set(i, updatedArgumentType);\n        }\n        for (int i = 0; i < argumentsTypes.size(); i++) {\n            ResolvedType updatedArgumentType = applyInferredTypes(argumentsTypes.get(i), inferredTypes);\n            argumentsTypes.set(i, updatedArgumentType);\n        }\n\n        return solveMethodAsUsage(typeOfScope, name, argumentsTypes, this);\n    }\n\n    private MethodUsage resolveMethodTypeParametersFromExplicitList(TypeSolver typeSolver, MethodUsage methodUsage) {\n        if (wrappedNode.getTypeArguments().isPresent()) {\n            final List<ResolvedType> typeArguments = new ArrayList<>();\n            for (com.github.javaparser.ast.type.Type ty : wrappedNode.getTypeArguments().get()) {\n                typeArguments.add(JavaParserFacade.get(typeSolver).convertToUsage(ty));\n            }\n\n            List<ResolvedTypeParameterDeclaration> tyParamDecls = methodUsage.getDeclaration().getTypeParameters();\n            if (tyParamDecls.size() == typeArguments.size()) {\n                for (int i = 0; i < tyParamDecls.size(); i++) {\n                    methodUsage = methodUsage.replaceTypeParameter(tyParamDecls.get(i), typeArguments.get(i));\n                }\n            }\n        }\n\n        return methodUsage;\n    }\n\n    @Override\n    public Optional<Value> solveSymbolAsValue(String name) {\n        return solveSymbolAsValueInParentContext(name);\n    }\n\n    @Override\n    public SymbolReference<ResolvedMethodDeclaration> solveMethod(String name, List<ResolvedType> argumentsTypes, boolean staticOnly) {\n        Collection<ResolvedReferenceTypeDeclaration> rrtds = findTypeDeclarations(wrappedNode.getScope());\n\n        if (rrtds.isEmpty()) {\n            // if the bounds of a type parameter are empty, then the bound is implicitly \"extends Object\"\n            // we don't make this _ex_plicit in the data representation because that would affect codegen\n            // and make everything generate like <T extends Object> instead of <T>\n            // https://github.com/javaparser/javaparser/issues/2044\n            rrtds = Collections.singleton(typeSolver.getSolvedJavaLangObject());\n        }\n\n        for (ResolvedReferenceTypeDeclaration rrtd : rrtds) {\n            SymbolReference<ResolvedMethodDeclaration> res = MethodResolutionLogic.solveMethodInType(rrtd, name, argumentsTypes, false);\n            if (res.isSolved()) {\n                return res;\n            }\n        }\n\n        return SymbolReference.unsolved();\n    }\n\n    ///\n    /// Private methods\n    ///\n\n    private Optional<MethodUsage> solveMethodAsUsage(ResolvedReferenceType refType, String name,\n                                                     List<ResolvedType> argumentsTypes,\n                                                     Context invokationContext) {\n        if(!refType.getTypeDeclaration().isPresent()) {\n            return Optional.empty();\n        }\n\n        Optional<MethodUsage> ref = ContextHelper.solveMethodAsUsage(refType.getTypeDeclaration().get(), name, argumentsTypes, invokationContext, refType.typeParametersValues());\n        if (ref.isPresent()) {\n            MethodUsage methodUsage = ref.get();\n\n            methodUsage = resolveMethodTypeParametersFromExplicitList(typeSolver, methodUsage);\n\n            // At this stage I should derive from the context and the value some information on the type parameters\n            // for example, when calling:\n            // myStream.collect(Collectors.toList())\n            // I should be able to figure out that considering the type of the stream (e.g., Stream<String>)\n            // and considering that Stream has this method:\n            //\n            // <R,A> R collect(Collector<? super T,A,R> collector)\n            //\n            // and collector has this method:\n            //\n            // static <T> Collector<T,?,List<T>>   toList()\n            //\n            // In this case collect.R has to be equal to List<toList.T>\n            // And toList.T has to be equal to ? super Stream.T\n            // Therefore R has to be equal to List<? super Stream.T>.\n            // In our example Stream.T equal to String, so the R (and the result of the call to collect) is\n            // List<? super String>\n\n            Map<ResolvedTypeParameterDeclaration, ResolvedType> derivedValues = new HashMap<>();\n            for (int i = 0; i < methodUsage.getParamTypes().size(); i++) {\n                ResolvedParameterDeclaration parameter = methodUsage.getDeclaration().getParam(i);\n                ResolvedType parameterType = parameter.getType();\n                // Don't continue if a vararg parameter is reached and there are no arguments left\n                if (parameter.isVariadic() && argumentsTypes.size() < methodUsage.getNoParams()) {\n                    break;\n                }\n                if (!argumentsTypes.get(i).isArray() && parameter.isVariadic()) {\n                    parameterType = parameterType.asArrayType().getComponentType();\n                }\n                inferTypes(argumentsTypes.get(i), parameterType, derivedValues);\n            }\n\n            for (Map.Entry<ResolvedTypeParameterDeclaration, ResolvedType> entry : derivedValues.entrySet()){\n                methodUsage = methodUsage.replaceTypeParameter(entry.getKey(), entry.getValue());\n            }\n\n            ResolvedType returnType = refType.useThisTypeParametersOnTheGivenType(methodUsage.returnType());\n            // we don't want to replace the return type in case of UNBOUNDED type (<?>)\n            if (returnType != methodUsage.returnType() && !(returnType == ResolvedWildcard.UNBOUNDED)) {\n                methodUsage = methodUsage.replaceReturnType(returnType);\n            }\n            for (int i = 0; i < methodUsage.getParamTypes().size(); i++) {\n                ResolvedType replaced = refType.useThisTypeParametersOnTheGivenType(methodUsage.getParamTypes().get(i));\n                methodUsage = methodUsage.replaceParamType(i, replaced);\n            }\n            return Optional.of(methodUsage);\n        } else {\n            return ref;\n        }\n    }\n\n    private void inferTypes(ResolvedType source, ResolvedType target, Map<ResolvedTypeParameterDeclaration, ResolvedType> mappings) {\n        if (source.equals(target)) {\n            return;\n        }\n        if (source.isReferenceType() && target.isReferenceType()) {\n            ResolvedReferenceType sourceRefType = source.asReferenceType();\n            ResolvedReferenceType targetRefType = target.asReferenceType();\n            if (sourceRefType.getQualifiedName().equals(targetRefType.getQualifiedName())) {\n            \tif (!sourceRefType.isRawType() && !targetRefType.isRawType()) {\n\t                for (int i = 0; i < sourceRefType.typeParametersValues().size(); i++) {\n\t                    inferTypes(sourceRefType.typeParametersValues().get(i), targetRefType.typeParametersValues().get(i), mappings);\n\t                }\n            \t}\n            }\n            return;\n        }\n        if (source.isReferenceType() && target.isWildcard()) {\n            if (target.asWildcard().isBounded()) {\n                inferTypes(source, target.asWildcard().getBoundedType(), mappings);\n                return;\n            }\n            return;\n        }\n        if (source.isWildcard() && target.isWildcard()) {\n            if (source.asWildcard().isBounded() && target.asWildcard().isBounded()){\n                inferTypes(source.asWildcard().getBoundedType(), target.asWildcard().getBoundedType(), mappings);\n            }\n            return;\n        }\n        if (source.isReferenceType() && target.isTypeVariable()) {\n            mappings.put(target.asTypeParameter(), source);\n            return;\n        }\n        if (source.isWildcard() && target.isTypeVariable()) {\n            mappings.put(target.asTypeParameter(), source);\n            return;\n        }\n        if (source.isArray() && target.isArray()) {\n            ResolvedType sourceComponentType = source.asArrayType().getComponentType();\n            ResolvedType targetComponentType = target.asArrayType().getComponentType();\n            inferTypes(sourceComponentType, targetComponentType, mappings);\n            return;\n        }\n        if (source.isArray() && target.isWildcard()){\n            if(target.asWildcard().isBounded()){\n                inferTypes(source, target.asWildcard().getBoundedType(), mappings);\n                return;\n            }\n            return;\n        }\n        if (source.isArray() && target.isTypeVariable()) {\n            mappings.put(target.asTypeParameter(), source);\n            return;\n        }\n\n        if (source.isWildcard() && target.isReferenceType()){\n            if (source.asWildcard().isBounded()){\n                inferTypes(source.asWildcard().getBoundedType(), target, mappings);\n            }\n            return;\n        }\n        if (source.isConstraint() && target.isReferenceType()){\n            inferTypes(source.asConstraintType().getBound(), target, mappings);\n            return;\n        }\n\n        if (source.isConstraint() && target.isTypeVariable()){\n            inferTypes(source.asConstraintType().getBound(), target, mappings);\n            return;\n        }\n        if (source.isTypeVariable() && target.isTypeVariable()) {\n            mappings.put(target.asTypeParameter(), source);\n            return;\n        }\n        if (source.isTypeVariable()) {\n            inferTypes(target, source, mappings);\n            return;\n        }\n        if (source.isPrimitive() || target.isPrimitive()) {\n            return;\n        }\n        if (source.isNull()) {\n            return;\n        }\n        \n        if (target.isReferenceType()) {\n            ResolvedReferenceType formalTypeAsReference = target.asReferenceType();\n            if (formalTypeAsReference.isJavaLangObject()) {\n                return;\n            }\n        }\n        throw new RuntimeException(source.describe() + \" \" + target.describe());\n    }\n\n    private MethodUsage resolveMethodTypeParameters(MethodUsage methodUsage, List<ResolvedType> actualParamTypes) {\n        Map<ResolvedTypeParameterDeclaration, ResolvedType> matchedTypeParameters = new HashMap<>();\n\n        if (methodUsage.getDeclaration().hasVariadicParameter()) {\n            if (actualParamTypes.size() == methodUsage.getDeclaration().getNumberOfParams()) {\n                // the varargs parameter is an Array, so extract the inner type\n                ResolvedType expectedType =\n                    methodUsage.getDeclaration().getLastParam().getType().asArrayType().getComponentType();\n                // the varargs corresponding type can be either T or Array<T>\n                ResolvedType actualType =\n                    actualParamTypes.get(actualParamTypes.size() - 1).isArray() ?\n                        actualParamTypes.get(actualParamTypes.size() - 1).asArrayType().getComponentType() :\n                        actualParamTypes.get(actualParamTypes.size() - 1);\n                if (!expectedType.isAssignableBy(actualType)) {\n                    for (ResolvedTypeParameterDeclaration tp : methodUsage.getDeclaration().getTypeParameters()) {\n                        expectedType = MethodResolutionLogic.replaceTypeParam(expectedType, tp, typeSolver);\n                    }\n                }\n                if (!expectedType.isAssignableBy(actualType)) {\n                    // ok, then it needs to be wrapped\n                    throw new UnsupportedOperationException(\n                        String.format(\"Unable to resolve the type typeParametersValues in a MethodUsage. Expected type: %s, Actual type: %s. Method Declaration: %s. MethodUsage: %s\",\n                                      expectedType,\n                                      actualType,\n                                      methodUsage.getDeclaration(),\n                                      methodUsage));\n                }\n                // match only the varargs type\n                matchTypeParameters(expectedType, actualType, matchedTypeParameters);\n            } else {\n                return methodUsage;\n            }\n        }\n\n        int until = methodUsage.getDeclaration().hasVariadicParameter() ?\n            actualParamTypes.size() - 1 :\n            actualParamTypes.size();\n\n        for (int i = 0; i < until; i++) {\n            ResolvedType expectedType = methodUsage.getParamType(i);\n            ResolvedType actualType = actualParamTypes.get(i);\n            matchTypeParameters(expectedType, actualType, matchedTypeParameters);\n        }\n        for (ResolvedTypeParameterDeclaration tp : matchedTypeParameters.keySet()) {\n            methodUsage = methodUsage.replaceTypeParameter(tp, matchedTypeParameters.get(tp));\n        }\n        return methodUsage;\n    }\n\n    private void matchTypeParameters(ResolvedType expectedType, ResolvedType actualType, Map<ResolvedTypeParameterDeclaration, ResolvedType> matchedTypeParameters) {\n        if (expectedType.isTypeVariable()) {\n            ResolvedType type = actualType;\n            // in case of primitive type, the expected type must be compared with the boxed type of the actual type\n            if (type.isPrimitive()) {\n                type = MyObjectProvider.INSTANCE.byName(type.asPrimitive().getBoxTypeQName());\n            }\n            /*\n             * \"a value of the null type (the null reference is the only such value) may be assigned to any reference type, resulting in a null reference of that type\"\n             * https://docs.oracle.com/javase/specs/jls/se15/html/jls-5.html#jls-5.2\n             */\n            if (type.isNull()) {\n                type = MyObjectProvider.INSTANCE.object();\n            }\n            if (!type.isTypeVariable() && !type.isReferenceType()) {\n                throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n            }\n            matchedTypeParameters.put(expectedType.asTypeParameter(), type);\n        } else if (expectedType.isArray()) {\n        \t// Issue 2258 : NullType must not fail this search\n            if (!(actualType.isArray() || actualType.isNull())) {\n                throw new UnsupportedOperationException(actualType.getClass().getCanonicalName());\n            }\n            matchTypeParameters(\n                    expectedType.asArrayType().getComponentType(),\n                    actualType.isNull() ? actualType : actualType.asArrayType().getComponentType(),\n                    matchedTypeParameters);\n        } else if (expectedType.isReferenceType()) {\n            // avoid cases where the actual type has no type parameters but the expected one has. Such as: \"classX extends classY<Integer>\"\n            if (actualType.isReferenceType() && actualType.asReferenceType().typeParametersValues().size() > 0) {\n                int i = 0;\n                for (ResolvedType tp : expectedType.asReferenceType().typeParametersValues()) {\n                    matchTypeParameters(tp, actualType.asReferenceType().typeParametersValues().get(i), matchedTypeParameters);\n                    i++;\n                }\n            }\n        } else if (expectedType.isPrimitive()) {\n            // nothing to do\n        } else if (expectedType.isWildcard()) {\n            // nothing to do\n        } else {\n            throw new UnsupportedOperationException(expectedType.getClass().getCanonicalName());\n        }\n    }\n\n    private Optional<MethodUsage> solveMethodAsUsage(ResolvedTypeVariable tp, String name, List<ResolvedType> argumentsTypes, Context invokationContext) {\n        List<ResolvedTypeParameterDeclaration.Bound> bounds = tp.asTypeParameter().getBounds();\n\n        if (bounds.isEmpty()) {\n            // if the bounds of a type parameter are empty, then the bound is implicitly \"extends Object\"\n            // we don't make this _ex_plicit in the data representation because that would affect codegen\n            // and make everything generate like <T extends Object> instead of <T>\n            // https://github.com/javaparser/javaparser/issues/2044\n            bounds = Collections.singletonList(\n                    ResolvedTypeParameterDeclaration.Bound.extendsBound(\n                            JavaParserFacade.get(typeSolver).classToResolvedType(Object.class)));\n        }\n\n        for (ResolvedTypeParameterDeclaration.Bound bound : bounds) {\n            Optional<MethodUsage> methodUsage = solveMethodAsUsage(bound.getType(), name, argumentsTypes, invokationContext);\n            if (methodUsage.isPresent()) {\n                return methodUsage;\n            }\n        }\n\n        return Optional.empty();\n    }\n\n    private Optional<MethodUsage> solveMethodAsUsage(ResolvedType type, String name, List<ResolvedType> argumentsTypes, Context invokationContext) {\n        if (type instanceof ResolvedReferenceType) {\n            return solveMethodAsUsage((ResolvedReferenceType) type, name, argumentsTypes, invokationContext);\n        } else if (type instanceof ResolvedTypeVariable) {\n            return solveMethodAsUsage((ResolvedTypeVariable) type, name, argumentsTypes, invokationContext);\n        } else if (type instanceof ResolvedWildcard) {\n            ResolvedWildcard wildcardUsage = (ResolvedWildcard) type;\n            if (wildcardUsage.isSuper()) {\n                return solveMethodAsUsage(wildcardUsage.getBoundedType(), name, argumentsTypes, invokationContext);\n            } else if (wildcardUsage.isExtends()) {\n                return solveMethodAsUsage(wildcardUsage.getBoundedType(), name, argumentsTypes, invokationContext);\n            } else {\n                return solveMethodAsUsage(new ReferenceTypeImpl(new ReflectionClassDeclaration(Object.class, typeSolver)), name, argumentsTypes, invokationContext);\n            }\n        } else if (type instanceof ResolvedLambdaConstraintType){\n            ResolvedLambdaConstraintType constraintType = (ResolvedLambdaConstraintType) type;\n            return solveMethodAsUsage(constraintType.getBound(), name, argumentsTypes, invokationContext);\n        } else if (type instanceof ResolvedArrayType) {\n            // An array inherits methods from Object not from it's component type\n            return solveMethodAsUsage(new ReferenceTypeImpl(new ReflectionClassDeclaration(Object.class, typeSolver)), name, argumentsTypes, invokationContext);\n        } else if (type instanceof ResolvedUnionType) {\n            Optional<ResolvedReferenceType> commonAncestor = type.asUnionType().getCommonAncestor();\n            if (commonAncestor.isPresent()) {\n                return solveMethodAsUsage(commonAncestor.get(), name, argumentsTypes, invokationContext);\n            } else {\n                throw new UnsupportedOperationException(\"no common ancestor available for \" + type.describe());\n            }\n        } else {\n            throw new UnsupportedOperationException(\"type usage: \" + type.getClass().getCanonicalName());\n        }\n    }\n\n    private ResolvedType usingParameterTypesFromScope(ResolvedType scope, ResolvedType type, Map<ResolvedTypeParameterDeclaration, ResolvedType> inferredTypes) {\n        if (type.isReferenceType()) {\n            for (Pair<ResolvedTypeParameterDeclaration, ResolvedType> entry : type.asReferenceType().getTypeParametersMap()) {\n                if (entry.a.declaredOnType() && scope.isReferenceType() && scope.asReferenceType().getGenericParameterByName(entry.a.getName()).isPresent()) {\n                    type = type.replaceTypeVariables(entry.a, scope.asReferenceType().getGenericParameterByName(entry.a.getName()).get(), inferredTypes);\n                }\n            }\n            return type;\n        } else {\n            return type;\n        }\n    }\n\n    private ResolvedType applyInferredTypes(ResolvedType type, Map<ResolvedTypeParameterDeclaration, ResolvedType> inferredTypes) {\n        for (ResolvedTypeParameterDeclaration tp : inferredTypes.keySet()) {\n            type = type.replaceTypeVariables(tp, inferredTypes.get(tp), inferredTypes);\n        }\n        return type;\n    }\n}\n",
        "filePathAfter": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/MethodCallExprContext.java",
        "sourceCodeAfterForWhole": "/*\n * Copyright (C) 2015-2016 Federico Tomassetti\n * Copyright (C) 2017-2020 The JavaParser Team.\n *\n * This file is part of JavaParser.\n *\n * JavaParser can be used either under the terms of\n * a) the GNU Lesser General Public License as published by\n *     the Free Software Foundation, either version 3 of the License, or\n *     (at your option) any later version.\n * b) the terms of the Apache License\n *\n * You should have received a copy of both licenses in LICENCE.LGPL and\n * LICENCE.APACHE. Please refer to those files for details.\n *\n * JavaParser is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n */\n\npackage com.github.javaparser.symbolsolver.javaparsermodel.contexts;\n\nimport com.github.javaparser.ast.NodeList;\nimport com.github.javaparser.ast.expr.Expression;\nimport com.github.javaparser.ast.expr.MethodCallExpr;\nimport com.github.javaparser.ast.expr.NameExpr;\nimport com.github.javaparser.ast.type.ArrayType;\nimport com.github.javaparser.resolution.Context;\nimport com.github.javaparser.resolution.MethodUsage;\nimport com.github.javaparser.resolution.TypeSolver;\nimport com.github.javaparser.resolution.UnsolvedSymbolException;\nimport com.github.javaparser.resolution.declarations.*;\nimport com.github.javaparser.resolution.model.SymbolReference;\nimport com.github.javaparser.resolution.model.Value;\nimport com.github.javaparser.resolution.model.typesystem.ReferenceTypeImpl;\nimport com.github.javaparser.resolution.types.*;\nimport com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade;\nimport com.github.javaparser.symbolsolver.reflectionmodel.MyObjectProvider;\nimport com.github.javaparser.symbolsolver.reflectionmodel.ReflectionClassDeclaration;\nimport com.github.javaparser.symbolsolver.resolution.MethodResolutionLogic;\nimport com.github.javaparser.utils.Pair;\n\nimport java.util.*;\n\npublic class MethodCallExprContext extends AbstractJavaParserContext<MethodCallExpr> {\n\n    ///\n    /// Constructors\n    ///\n\n    public MethodCallExprContext(MethodCallExpr wrappedNode, TypeSolver typeSolver) {\n        super(wrappedNode, typeSolver);\n    }\n\n    ///\n    /// Public methods\n    ///\n\n    @Override\n    public Optional<ResolvedType> solveGenericType(String name) {\n        Optional<Expression> nodeScope = wrappedNode.getScope();\n        if (!nodeScope.isPresent()) {\n            return Optional.empty();\n        }\n\n        // Method calls can have generic types defined, for example: {@code expr.<T1, T2>method(x, y, z);} or {@code super.<T, E>check2(val1, val2).}\n        ResolvedType typeOfScope = JavaParserFacade.get(typeSolver).getType(nodeScope.get());\n        Optional<ResolvedType> resolvedType = typeOfScope.asReferenceType().getGenericParameterByName(name);\n\n        // TODO/FIXME: Consider if we should check if the result is present, else delegate \"up\" the context chain (e.g. {@code solveGenericTypeInParent()})\n        return resolvedType;\n    }\n\n    @Override\n    public String toString() {\n        return \"MethodCallExprContext{wrapped=\" + wrappedNode + \"}\";\n    }\n\n    @Override\n    public Optional<MethodUsage> solveMethodAsUsage(String name, List<ResolvedType> argumentsTypes) {\n        ResolvedType typeOfScope;\n        if (wrappedNode.hasScope()) {\n            Expression scope = wrappedNode.getScope().get();\n            // Consider static method calls\n            if (scope instanceof NameExpr) {\n                String className = ((NameExpr) scope).getName().getId();\n                SymbolReference<ResolvedTypeDeclaration> ref = solveType(className);\n                if (ref.isSolved()) {\n                    SymbolReference<ResolvedMethodDeclaration> m = MethodResolutionLogic.solveMethodInType(ref.getCorrespondingDeclaration(), name, argumentsTypes);\n                    if (m.isSolved()) {\n                        MethodUsage methodUsage = new MethodUsage(m.getCorrespondingDeclaration());\n                        methodUsage = resolveMethodTypeParametersFromExplicitList(typeSolver, methodUsage);\n                        methodUsage = resolveMethodTypeParameters(methodUsage, argumentsTypes);\n                        return Optional.of(methodUsage);\n                    } else {\n                        throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(),\n                                \"Method '\" + name + \"' with parameterTypes \" + argumentsTypes);\n                    }\n                }\n            }\n\n            // Scope is present -- search/solve within that type\n            typeOfScope = JavaParserFacade.get(typeSolver).getType(scope);\n        } else {\n            // Scope not present -- search/solve within itself.\n            typeOfScope = JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n        }\n\n        // we can replace the parameter types from the scope into the typeParametersValues\n        Map<ResolvedTypeParameterDeclaration, ResolvedType> inferredTypes = new HashMap<>();\n        for (int i = 0; i < argumentsTypes.size(); i++) {\n            // by replacing types I can also find new equivalences\n            // for example if I replace T=U with String because I know that T=String I can derive that also U equal String\n            ResolvedType originalArgumentType = argumentsTypes.get(i);\n            ResolvedType updatedArgumentType = usingParameterTypesFromScope(typeOfScope, originalArgumentType, inferredTypes);\n            argumentsTypes.set(i, updatedArgumentType);\n        }\n        for (int i = 0; i < argumentsTypes.size(); i++) {\n            ResolvedType updatedArgumentType = applyInferredTypes(argumentsTypes.get(i), inferredTypes);\n            argumentsTypes.set(i, updatedArgumentType);\n        }\n\n        return solveMethodAsUsage(typeOfScope, name, argumentsTypes, this);\n    }\n\n    private MethodUsage resolveMethodTypeParametersFromExplicitList(TypeSolver typeSolver, MethodUsage methodUsage) {\n        if (wrappedNode.getTypeArguments().isPresent()) {\n            final List<ResolvedType> typeArguments = new ArrayList<>();\n            for (com.github.javaparser.ast.type.Type ty : wrappedNode.getTypeArguments().get()) {\n                typeArguments.add(JavaParserFacade.get(typeSolver).convertToUsage(ty));\n            }\n\n            List<ResolvedTypeParameterDeclaration> tyParamDecls = methodUsage.getDeclaration().getTypeParameters();\n            if (tyParamDecls.size() == typeArguments.size()) {\n                for (int i = 0; i < tyParamDecls.size(); i++) {\n                    methodUsage = methodUsage.replaceTypeParameter(tyParamDecls.get(i), typeArguments.get(i));\n                }\n            }\n        }\n\n        return methodUsage;\n    }\n\n    @Override\n    public Optional<Value> solveSymbolAsValue(String name) {\n        return solveSymbolAsValueInParentContext(name);\n    }\n\n    @Override\n    public SymbolReference<ResolvedMethodDeclaration> solveMethod(String name, List<ResolvedType> argumentsTypes, boolean staticOnly) {\n        Collection<ResolvedReferenceTypeDeclaration> rrtds = findTypeDeclarations(wrappedNode.getScope());\n\n        if (rrtds.isEmpty()) {\n            // if the bounds of a type parameter are empty, then the bound is implicitly \"extends Object\"\n            // we don't make this _ex_plicit in the data representation because that would affect codegen\n            // and make everything generate like <T extends Object> instead of <T>\n            // https://github.com/javaparser/javaparser/issues/2044\n            rrtds = Collections.singleton(typeSolver.getSolvedJavaLangObject());\n        }\n\n        for (ResolvedReferenceTypeDeclaration rrtd : rrtds) {\n            SymbolReference<ResolvedMethodDeclaration> res = MethodResolutionLogic.solveMethodInType(rrtd, name, argumentsTypes, false);\n            if (res.isSolved()) {\n                return res;\n            }\n        }\n\n        return SymbolReference.unsolved();\n    }\n\n    ///\n    /// Private methods\n    ///\n\n    private Optional<MethodUsage> solveMethodAsUsage(ResolvedReferenceType refType, String name,\n                                                     List<ResolvedType> argumentsTypes,\n                                                     Context invokationContext) {\n        if(!refType.getTypeDeclaration().isPresent()) {\n            return Optional.empty();\n        }\n\n        Optional<MethodUsage> ref = ContextHelper.solveMethodAsUsage(refType.getTypeDeclaration().get(), name, argumentsTypes, invokationContext, refType.typeParametersValues());\n        if (ref.isPresent()) {\n            MethodUsage methodUsage = ref.get();\n\n            methodUsage = resolveMethodTypeParametersFromExplicitList(typeSolver, methodUsage);\n\n            // At this stage I should derive from the context and the value some information on the type parameters\n            // for example, when calling:\n            // myStream.collect(Collectors.toList())\n            // I should be able to figure out that considering the type of the stream (e.g., Stream<String>)\n            // and considering that Stream has this method:\n            //\n            // <R,A> R collect(Collector<? super T,A,R> collector)\n            //\n            // and collector has this method:\n            //\n            // static <T> Collector<T,?,List<T>>   toList()\n            //\n            // In this case collect.R has to be equal to List<toList.T>\n            // And toList.T has to be equal to ? super Stream.T\n            // Therefore R has to be equal to List<? super Stream.T>.\n            // In our example Stream.T equal to String, so the R (and the result of the call to collect) is\n            // List<? super String>\n\n            Map<ResolvedTypeParameterDeclaration, ResolvedType> derivedValues = new HashMap<>();\n            for (int i = 0; i < methodUsage.getParamTypes().size(); i++) {\n                ResolvedParameterDeclaration parameter = methodUsage.getDeclaration().getParam(i);\n                ResolvedType parameterType = parameter.getType();\n                // Don't continue if a vararg parameter is reached and there are no arguments left\n                if (parameter.isVariadic() && argumentsTypes.size() < methodUsage.getNoParams()) {\n                    break;\n                }\n                if (!argumentsTypes.get(i).isArray() && parameter.isVariadic()) {\n                    parameterType = parameterType.asArrayType().getComponentType();\n                }\n                inferTypes(argumentsTypes.get(i), parameterType, derivedValues);\n            }\n\n            for (Map.Entry<ResolvedTypeParameterDeclaration, ResolvedType> entry : derivedValues.entrySet()){\n                methodUsage = methodUsage.replaceTypeParameter(entry.getKey(), entry.getValue());\n            }\n\n            ResolvedType returnType = refType.useThisTypeParametersOnTheGivenType(methodUsage.returnType());\n            // we don't want to replace the return type in case of UNBOUNDED type (<?>)\n            if (returnType != methodUsage.returnType() && !(returnType == ResolvedWildcard.UNBOUNDED)) {\n                methodUsage = methodUsage.replaceReturnType(returnType);\n            }\n            for (int i = 0; i < methodUsage.getParamTypes().size(); i++) {\n                ResolvedType replaced = refType.useThisTypeParametersOnTheGivenType(methodUsage.getParamTypes().get(i));\n                methodUsage = methodUsage.replaceParamType(i, replaced);\n            }\n            return Optional.of(methodUsage);\n        } else {\n            return ref;\n        }\n    }\n\n    private void inferTypes(ResolvedType source, ResolvedType target, Map<ResolvedTypeParameterDeclaration, ResolvedType> mappings) {\n        if (source.equals(target)) {\n            return;\n        }\n        if (source.isReferenceType() && target.isReferenceType()) {\n            ResolvedReferenceType sourceRefType = source.asReferenceType();\n            ResolvedReferenceType targetRefType = target.asReferenceType();\n            if (sourceRefType.getQualifiedName().equals(targetRefType.getQualifiedName())) {\n            \tif (!sourceRefType.isRawType() && !targetRefType.isRawType()) {\n\t                for (int i = 0; i < sourceRefType.typeParametersValues().size(); i++) {\n\t                    inferTypes(sourceRefType.typeParametersValues().get(i), targetRefType.typeParametersValues().get(i), mappings);\n\t                }\n            \t}\n            }\n            return;\n        }\n        if (source.isReferenceType() && target.isWildcard()) {\n            if (target.asWildcard().isBounded()) {\n                inferTypes(source, target.asWildcard().getBoundedType(), mappings);\n                return;\n            }\n            return;\n        }\n        if (source.isWildcard() && target.isWildcard()) {\n            if (source.asWildcard().isBounded() && target.asWildcard().isBounded()){\n                inferTypes(source.asWildcard().getBoundedType(), target.asWildcard().getBoundedType(), mappings);\n            }\n            return;\n        }\n        if (source.isReferenceType() && target.isTypeVariable()) {\n            mappings.put(target.asTypeParameter(), source);\n            return;\n        }\n        if (source.isWildcard() && target.isTypeVariable()) {\n            mappings.put(target.asTypeParameter(), source);\n            return;\n        }\n        if (source.isArray() && target.isArray()) {\n            ResolvedType sourceComponentType = source.asArrayType().getComponentType();\n            ResolvedType targetComponentType = target.asArrayType().getComponentType();\n            inferTypes(sourceComponentType, targetComponentType, mappings);\n            return;\n        }\n        if (source.isArray() && target.isWildcard()){\n            if(target.asWildcard().isBounded()){\n                inferTypes(source, target.asWildcard().getBoundedType(), mappings);\n                return;\n            }\n            return;\n        }\n        if (source.isArray() && target.isTypeVariable()) {\n            mappings.put(target.asTypeParameter(), source);\n            return;\n        }\n\n        if (source.isWildcard() && target.isReferenceType()){\n            if (source.asWildcard().isBounded()){\n                inferTypes(source.asWildcard().getBoundedType(), target, mappings);\n            }\n            return;\n        }\n        if (source.isConstraint() && target.isReferenceType()){\n            inferTypes(source.asConstraintType().getBound(), target, mappings);\n            return;\n        }\n\n        if (source.isConstraint() && target.isTypeVariable()){\n            inferTypes(source.asConstraintType().getBound(), target, mappings);\n            return;\n        }\n        if (source.isTypeVariable() && target.isTypeVariable()) {\n            mappings.put(target.asTypeParameter(), source);\n            return;\n        }\n        if (source.isTypeVariable()) {\n            inferTypes(target, source, mappings);\n            return;\n        }\n        if (source.isPrimitive() || target.isPrimitive()) {\n            return;\n        }\n        if (source.isNull()) {\n            return;\n        }\n        \n        if (target.isReferenceType()) {\n            ResolvedReferenceType formalTypeAsReference = target.asReferenceType();\n            if (formalTypeAsReference.isJavaLangObject()) {\n                return;\n            }\n        }\n        throw new RuntimeException(source.describe() + \" \" + target.describe());\n    }\n\n    private MethodUsage resolveMethodTypeParameters(MethodUsage methodUsage, List<ResolvedType> actualParamTypes) {\n        Map<ResolvedTypeParameterDeclaration, ResolvedType> matchedTypeParameters = new HashMap<>();\n\n        if (methodUsage.getDeclaration().hasVariadicParameter()) {\n            if (actualParamTypes.size() == methodUsage.getDeclaration().getNumberOfParams()) {\n                // the varargs parameter is an Array, so extract the inner type\n                ResolvedType expectedType =\n                    methodUsage.getDeclaration().getLastParam().getType().asArrayType().getComponentType();\n                // the varargs corresponding type can be either T or Array<T>\n                ResolvedType actualType =\n                    actualParamTypes.get(actualParamTypes.size() - 1).isArray() ?\n                        actualParamTypes.get(actualParamTypes.size() - 1).asArrayType().getComponentType() :\n                        actualParamTypes.get(actualParamTypes.size() - 1);\n                if (!expectedType.isAssignableBy(actualType)) {\n                    for (ResolvedTypeParameterDeclaration tp : methodUsage.getDeclaration().getTypeParameters()) {\n                        expectedType = MethodResolutionLogic.replaceTypeParam(expectedType, tp, typeSolver);\n                    }\n                }\n                if (!expectedType.isAssignableBy(actualType)) {\n                    // ok, then it needs to be wrapped\n                    throw new UnsupportedOperationException(\n                        String.format(\"Unable to resolve the type typeParametersValues in a MethodUsage. Expected type: %s, Actual type: %s. Method Declaration: %s. MethodUsage: %s\",\n                                      expectedType,\n                                      actualType,\n                                      methodUsage.getDeclaration(),\n                                      methodUsage));\n                }\n                // match only the varargs type\n                matchTypeParameters(expectedType, actualType, matchedTypeParameters);\n            } else if (methodUsage.getDeclaration().getNumberOfParams() == 1) {\n            \t// In this case the method declares only one parameter which is a variadic parameter.\n            \t// At this stage we can consider that the actual parameters all have the same type.\n                ResolvedType expectedType =\n                    methodUsage.getDeclaration().getLastParam().getType().asArrayType().getComponentType();\n                // the varargs corresponding type can not be an Array<T> because of the assumption\n//                ResolvedType actualType = new ResolvedArrayType(actualParamTypes.get(actualParamTypes.size() - 1));\n                ResolvedType actualType = actualParamTypes.get(actualParamTypes.size() - 1);\n                if (!expectedType.isAssignableBy(actualType)) {\n                    throw new UnsupportedOperationException(\n                    \t\tString.format(\"Unable to resolve the type typeParametersValues in a MethodUsage. Expected type: %s, Actual type: %s. Method Declaration: %s. MethodUsage: %s\",\n                            expectedType,\n                            actualType,\n                            methodUsage.getDeclaration(),\n                            methodUsage));\n                }\n                matchTypeParameters(expectedType, actualType, matchedTypeParameters);\n                return replaceTypeParameter(methodUsage, matchedTypeParameters);\n            } else {\n                return methodUsage;\n            }\n        }\n\n        int until = methodUsage.getDeclaration().hasVariadicParameter() ?\n            actualParamTypes.size() - 1 :\n            actualParamTypes.size();\n\n        for (int i = 0; i < until; i++) {\n            ResolvedType expectedType = methodUsage.getParamType(i);\n            ResolvedType actualType = actualParamTypes.get(i);\n            matchTypeParameters(expectedType, actualType, matchedTypeParameters);\n        }\n        methodUsage = replaceTypeParameter(methodUsage, matchedTypeParameters);\n        return methodUsage;\n    }\n\n\tprivate MethodUsage replaceTypeParameter(MethodUsage methodUsage,\n\t\t\tMap<ResolvedTypeParameterDeclaration, ResolvedType> matchedTypeParameters) {\n\t\tfor (ResolvedTypeParameterDeclaration tp : matchedTypeParameters.keySet()) {\n            methodUsage = methodUsage.replaceTypeParameter(tp, matchedTypeParameters.get(tp));\n        }\n\t\treturn methodUsage;\n\t}\n\n    private void matchTypeParameters(ResolvedType expectedType, ResolvedType actualType, Map<ResolvedTypeParameterDeclaration, ResolvedType> matchedTypeParameters) {\n        if (expectedType.isTypeVariable()) {\n            ResolvedType type = actualType;\n            // in case of primitive type, the expected type must be compared with the boxed type of the actual type\n            if (type.isPrimitive()) {\n                type = MyObjectProvider.INSTANCE.byName(type.asPrimitive().getBoxTypeQName());\n            }\n            /*\n             * \"a value of the null type (the null reference is the only such value) may be assigned to any reference type, resulting in a null reference of that type\"\n             * https://docs.oracle.com/javase/specs/jls/se15/html/jls-5.html#jls-5.2\n             */\n            if (type.isNull()) {\n                type = MyObjectProvider.INSTANCE.object();\n            }\n            if (!type.isTypeVariable() && !type.isReferenceType()) {\n                throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n            }\n            matchedTypeParameters.put(expectedType.asTypeParameter(), type);\n        } else if (expectedType.isArray()) {\n        \t// Issue 2258 : NullType must not fail this search\n            if (!(actualType.isArray() || actualType.isNull())) {\n                throw new UnsupportedOperationException(actualType.getClass().getCanonicalName());\n            }\n            matchTypeParameters(\n                    expectedType.asArrayType().getComponentType(),\n                    actualType.isNull() ? actualType : actualType.asArrayType().getComponentType(),\n                    matchedTypeParameters);\n        } else if (expectedType.isReferenceType()) {\n            // avoid cases where the actual type has no type parameters but the expected one has. Such as: \"classX extends classY<Integer>\"\n            if (actualType.isReferenceType() && actualType.asReferenceType().typeParametersValues().size() > 0) {\n                int i = 0;\n                for (ResolvedType tp : expectedType.asReferenceType().typeParametersValues()) {\n                    matchTypeParameters(tp, actualType.asReferenceType().typeParametersValues().get(i), matchedTypeParameters);\n                    i++;\n                }\n            }\n        } else if (expectedType.isPrimitive()) {\n            // nothing to do\n        } else if (expectedType.isWildcard()) {\n            // nothing to do\n        } else {\n            throw new UnsupportedOperationException(expectedType.getClass().getCanonicalName());\n        }\n    }\n\n    private Optional<MethodUsage> solveMethodAsUsage(ResolvedTypeVariable tp, String name, List<ResolvedType> argumentsTypes, Context invokationContext) {\n        List<ResolvedTypeParameterDeclaration.Bound> bounds = tp.asTypeParameter().getBounds();\n\n        if (bounds.isEmpty()) {\n            // if the bounds of a type parameter are empty, then the bound is implicitly \"extends Object\"\n            // we don't make this _ex_plicit in the data representation because that would affect codegen\n            // and make everything generate like <T extends Object> instead of <T>\n            // https://github.com/javaparser/javaparser/issues/2044\n            bounds = Collections.singletonList(\n                    ResolvedTypeParameterDeclaration.Bound.extendsBound(\n                            JavaParserFacade.get(typeSolver).classToResolvedType(Object.class)));\n        }\n\n        for (ResolvedTypeParameterDeclaration.Bound bound : bounds) {\n            Optional<MethodUsage> methodUsage = solveMethodAsUsage(bound.getType(), name, argumentsTypes, invokationContext);\n            if (methodUsage.isPresent()) {\n                return methodUsage;\n            }\n        }\n\n        return Optional.empty();\n    }\n\n    private Optional<MethodUsage> solveMethodAsUsage(ResolvedType type, String name, List<ResolvedType> argumentsTypes, Context invokationContext) {\n        if (type instanceof ResolvedReferenceType) {\n            return solveMethodAsUsage((ResolvedReferenceType) type, name, argumentsTypes, invokationContext);\n        } else if (type instanceof ResolvedTypeVariable) {\n            return solveMethodAsUsage((ResolvedTypeVariable) type, name, argumentsTypes, invokationContext);\n        } else if (type instanceof ResolvedWildcard) {\n            ResolvedWildcard wildcardUsage = (ResolvedWildcard) type;\n            if (wildcardUsage.isSuper()) {\n                return solveMethodAsUsage(wildcardUsage.getBoundedType(), name, argumentsTypes, invokationContext);\n            } else if (wildcardUsage.isExtends()) {\n                return solveMethodAsUsage(wildcardUsage.getBoundedType(), name, argumentsTypes, invokationContext);\n            } else {\n                return solveMethodAsUsage(new ReferenceTypeImpl(new ReflectionClassDeclaration(Object.class, typeSolver)), name, argumentsTypes, invokationContext);\n            }\n        } else if (type instanceof ResolvedLambdaConstraintType){\n            ResolvedLambdaConstraintType constraintType = (ResolvedLambdaConstraintType) type;\n            return solveMethodAsUsage(constraintType.getBound(), name, argumentsTypes, invokationContext);\n        } else if (type instanceof ResolvedArrayType) {\n            // An array inherits methods from Object not from it's component type\n            return solveMethodAsUsage(new ReferenceTypeImpl(new ReflectionClassDeclaration(Object.class, typeSolver)), name, argumentsTypes, invokationContext);\n        } else if (type instanceof ResolvedUnionType) {\n            Optional<ResolvedReferenceType> commonAncestor = type.asUnionType().getCommonAncestor();\n            if (commonAncestor.isPresent()) {\n                return solveMethodAsUsage(commonAncestor.get(), name, argumentsTypes, invokationContext);\n            } else {\n                throw new UnsupportedOperationException(\"no common ancestor available for \" + type.describe());\n            }\n        } else {\n            throw new UnsupportedOperationException(\"type usage: \" + type.getClass().getCanonicalName());\n        }\n    }\n\n    private ResolvedType usingParameterTypesFromScope(ResolvedType scope, ResolvedType type, Map<ResolvedTypeParameterDeclaration, ResolvedType> inferredTypes) {\n        if (type.isReferenceType()) {\n            for (Pair<ResolvedTypeParameterDeclaration, ResolvedType> entry : type.asReferenceType().getTypeParametersMap()) {\n                if (entry.a.declaredOnType() && scope.isReferenceType() && scope.asReferenceType().getGenericParameterByName(entry.a.getName()).isPresent()) {\n                    type = type.replaceTypeVariables(entry.a, scope.asReferenceType().getGenericParameterByName(entry.a.getName()).get(), inferredTypes);\n                }\n            }\n            return type;\n        } else {\n            return type;\n        }\n    }\n\n    private ResolvedType applyInferredTypes(ResolvedType type, Map<ResolvedTypeParameterDeclaration, ResolvedType> inferredTypes) {\n        for (ResolvedTypeParameterDeclaration tp : inferredTypes.keySet()) {\n            type = type.replaceTypeVariables(tp, inferredTypes.get(tp), inferredTypes);\n        }\n        return type;\n    }\n}\n",
        "diffSourceCodeSet": [
            "private MethodUsage replaceTypeParameter(MethodUsage methodUsage,\n\t\t\tMap<ResolvedTypeParameterDeclaration, ResolvedType> matchedTypeParameters) {\n\t\tfor (ResolvedTypeParameterDeclaration tp : matchedTypeParameters.keySet()) {\n            methodUsage = methodUsage.replaceTypeParameter(tp, matchedTypeParameters.get(tp));\n        }\n\t\treturn methodUsage;\n\t}"
        ],
        "invokedMethodSet": [
            "methodSignature: com.github.javaparser.symbolsolver.javaparsermodel.contexts.MethodCallExprContext#matchTypeParameters\n methodBody: private void matchTypeParameters(ResolvedType expectedType, ResolvedType actualType, Map<ResolvedTypeParameterDeclaration, ResolvedType> matchedTypeParameters) {\nif(expectedType.isTypeVariable()){ResolvedType type=actualType;\nif(type.isPrimitive()){type=MyObjectProvider.INSTANCE.byName(type.asPrimitive().getBoxTypeQName());\n}if(type.isNull()){type=MyObjectProvider.INSTANCE.object();\n}if(!type.isTypeVariable() && !type.isReferenceType()){throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n}matchedTypeParameters.put(expectedType.asTypeParameter(),type);\n}if(expectedType.isArray()){if(!(actualType.isArray() || actualType.isNull())){throw new UnsupportedOperationException(actualType.getClass().getCanonicalName());\n}matchTypeParameters(expectedType.asArrayType().getComponentType(),actualType.isNull() ? actualType : actualType.asArrayType().getComponentType(),matchedTypeParameters);\n}if(expectedType.isReferenceType()){if(actualType.isReferenceType() && actualType.asReferenceType().typeParametersValues().size() > 0){int i=0;\nfor(ResolvedType tp: expectedType.asReferenceType().typeParametersValues()){matchTypeParameters(tp,actualType.asReferenceType().typeParametersValues().get(i),matchedTypeParameters);\ni++;\n}}}if(expectedType.isPrimitive()){}if(expectedType.isWildcard()){}{throw new UnsupportedOperationException(expectedType.getClass().getCanonicalName());\n}}"
        ],
        "sourceCodeAfterRefactoring": "private MethodUsage resolveMethodTypeParameters(MethodUsage methodUsage, List<ResolvedType> actualParamTypes) {\n        Map<ResolvedTypeParameterDeclaration, ResolvedType> matchedTypeParameters = new HashMap<>();\n\n        if (methodUsage.getDeclaration().hasVariadicParameter()) {\n            if (actualParamTypes.size() == methodUsage.getDeclaration().getNumberOfParams()) {\n                // the varargs parameter is an Array, so extract the inner type\n                ResolvedType expectedType =\n                    methodUsage.getDeclaration().getLastParam().getType().asArrayType().getComponentType();\n                // the varargs corresponding type can be either T or Array<T>\n                ResolvedType actualType =\n                    actualParamTypes.get(actualParamTypes.size() - 1).isArray() ?\n                        actualParamTypes.get(actualParamTypes.size() - 1).asArrayType().getComponentType() :\n                        actualParamTypes.get(actualParamTypes.size() - 1);\n                if (!expectedType.isAssignableBy(actualType)) {\n                    for (ResolvedTypeParameterDeclaration tp : methodUsage.getDeclaration().getTypeParameters()) {\n                        expectedType = MethodResolutionLogic.replaceTypeParam(expectedType, tp, typeSolver);\n                    }\n                }\n                if (!expectedType.isAssignableBy(actualType)) {\n                    // ok, then it needs to be wrapped\n                    throw new UnsupportedOperationException(\n                        String.format(\"Unable to resolve the type typeParametersValues in a MethodUsage. Expected type: %s, Actual type: %s. Method Declaration: %s. MethodUsage: %s\",\n                                      expectedType,\n                                      actualType,\n                                      methodUsage.getDeclaration(),\n                                      methodUsage));\n                }\n                // match only the varargs type\n                matchTypeParameters(expectedType, actualType, matchedTypeParameters);\n            } else if (methodUsage.getDeclaration().getNumberOfParams() == 1) {\n            \t// In this case the method declares only one parameter which is a variadic parameter.\n            \t// At this stage we can consider that the actual parameters all have the same type.\n                ResolvedType expectedType =\n                    methodUsage.getDeclaration().getLastParam().getType().asArrayType().getComponentType();\n                // the varargs corresponding type can not be an Array<T> because of the assumption\n//                ResolvedType actualType = new ResolvedArrayType(actualParamTypes.get(actualParamTypes.size() - 1));\n                ResolvedType actualType = actualParamTypes.get(actualParamTypes.size() - 1);\n                if (!expectedType.isAssignableBy(actualType)) {\n                    throw new UnsupportedOperationException(\n                    \t\tString.format(\"Unable to resolve the type typeParametersValues in a MethodUsage. Expected type: %s, Actual type: %s. Method Declaration: %s. MethodUsage: %s\",\n                            expectedType,\n                            actualType,\n                            methodUsage.getDeclaration(),\n                            methodUsage));\n                }\n                matchTypeParameters(expectedType, actualType, matchedTypeParameters);\n                return replaceTypeParameter(methodUsage, matchedTypeParameters);\n            } else {\n                return methodUsage;\n            }\n        }\n\n        int until = methodUsage.getDeclaration().hasVariadicParameter() ?\n            actualParamTypes.size() - 1 :\n            actualParamTypes.size();\n\n        for (int i = 0; i < until; i++) {\n            ResolvedType expectedType = methodUsage.getParamType(i);\n            ResolvedType actualType = actualParamTypes.get(i);\n            matchTypeParameters(expectedType, actualType, matchedTypeParameters);\n        }\n        methodUsage = replaceTypeParameter(methodUsage, matchedTypeParameters);\n        return methodUsage;\n    }\nprivate MethodUsage replaceTypeParameter(MethodUsage methodUsage,\n\t\t\tMap<ResolvedTypeParameterDeclaration, ResolvedType> matchedTypeParameters) {\n\t\tfor (ResolvedTypeParameterDeclaration tp : matchedTypeParameters.keySet()) {\n            methodUsage = methodUsage.replaceTypeParameter(tp, matchedTypeParameters.get(tp));\n        }\n\t\treturn methodUsage;\n\t}",
        "diffSourceCode": "-  332:     private MethodUsage resolveMethodTypeParameters(MethodUsage methodUsage, List<ResolvedType> actualParamTypes) {\n-  333:         Map<ResolvedTypeParameterDeclaration, ResolvedType> matchedTypeParameters = new HashMap<>();\n-  334: \n-  335:         if (methodUsage.getDeclaration().hasVariadicParameter()) {\n-  336:             if (actualParamTypes.size() == methodUsage.getDeclaration().getNumberOfParams()) {\n-  337:                 // the varargs parameter is an Array, so extract the inner type\n-  338:                 ResolvedType expectedType =\n-  339:                     methodUsage.getDeclaration().getLastParam().getType().asArrayType().getComponentType();\n-  340:                 // the varargs corresponding type can be either T or Array<T>\n-  341:                 ResolvedType actualType =\n-  342:                     actualParamTypes.get(actualParamTypes.size() - 1).isArray() ?\n-  343:                         actualParamTypes.get(actualParamTypes.size() - 1).asArrayType().getComponentType() :\n-  344:                         actualParamTypes.get(actualParamTypes.size() - 1);\n-  345:                 if (!expectedType.isAssignableBy(actualType)) {\n-  346:                     for (ResolvedTypeParameterDeclaration tp : methodUsage.getDeclaration().getTypeParameters()) {\n-  347:                         expectedType = MethodResolutionLogic.replaceTypeParam(expectedType, tp, typeSolver);\n-  348:                     }\n-  349:                 }\n-  350:                 if (!expectedType.isAssignableBy(actualType)) {\n-  351:                     // ok, then it needs to be wrapped\n-  352:                     throw new UnsupportedOperationException(\n-  353:                         String.format(\"Unable to resolve the type typeParametersValues in a MethodUsage. Expected type: %s, Actual type: %s. Method Declaration: %s. MethodUsage: %s\",\n-  354:                                       expectedType,\n-  355:                                       actualType,\n-  356:                                       methodUsage.getDeclaration(),\n-  357:                                       methodUsage));\n-  358:                 }\n-  359:                 // match only the varargs type\n-  360:                 matchTypeParameters(expectedType, actualType, matchedTypeParameters);\n-  361:             } else {\n-  362:                 return methodUsage;\n-  363:             }\n-  364:         }\n-  365: \n-  366:         int until = methodUsage.getDeclaration().hasVariadicParameter() ?\n-  367:             actualParamTypes.size() - 1 :\n-  368:             actualParamTypes.size();\n-  369: \n-  370:         for (int i = 0; i < until; i++) {\n-  371:             ResolvedType expectedType = methodUsage.getParamType(i);\n-  372:             ResolvedType actualType = actualParamTypes.get(i);\n-  373:             matchTypeParameters(expectedType, actualType, matchedTypeParameters);\n-  374:         }\n-  375:         for (ResolvedTypeParameterDeclaration tp : matchedTypeParameters.keySet()) {\n-  376:             methodUsage = methodUsage.replaceTypeParameter(tp, matchedTypeParameters.get(tp));\n-  377:         }\n-  378:         return methodUsage;\n-  379:     }\n-  380: \n-  381:     private void matchTypeParameters(ResolvedType expectedType, ResolvedType actualType, Map<ResolvedTypeParameterDeclaration, ResolvedType> matchedTypeParameters) {\n-  382:         if (expectedType.isTypeVariable()) {\n-  383:             ResolvedType type = actualType;\n-  384:             // in case of primitive type, the expected type must be compared with the boxed type of the actual type\n-  385:             if (type.isPrimitive()) {\n-  386:                 type = MyObjectProvider.INSTANCE.byName(type.asPrimitive().getBoxTypeQName());\n-  387:             }\n-  388:             /*\n-  389:              * \"a value of the null type (the null reference is the only such value) may be assigned to any reference type, resulting in a null reference of that type\"\n-  390:              * https://docs.oracle.com/javase/specs/jls/se15/html/jls-5.html#jls-5.2\n-  391:              */\n-  392:             if (type.isNull()) {\n-  393:                 type = MyObjectProvider.INSTANCE.object();\n-  394:             }\n-  395:             if (!type.isTypeVariable() && !type.isReferenceType()) {\n-  396:                 throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n-  397:             }\n-  399:         } else if (expectedType.isArray()) {\n-  400:         \t// Issue 2258 : NullType must not fail this search\n-  401:             if (!(actualType.isArray() || actualType.isNull())) {\n-  402:                 throw new UnsupportedOperationException(actualType.getClass().getCanonicalName());\n-  403:             }\n-  404:             matchTypeParameters(\n-  405:                     expectedType.asArrayType().getComponentType(),\n+  332:     }\n+  333: \n+  334:     private MethodUsage resolveMethodTypeParameters(MethodUsage methodUsage, List<ResolvedType> actualParamTypes) {\n+  335:         Map<ResolvedTypeParameterDeclaration, ResolvedType> matchedTypeParameters = new HashMap<>();\n+  336: \n+  337:         if (methodUsage.getDeclaration().hasVariadicParameter()) {\n+  338:             if (actualParamTypes.size() == methodUsage.getDeclaration().getNumberOfParams()) {\n+  339:                 // the varargs parameter is an Array, so extract the inner type\n+  340:                 ResolvedType expectedType =\n+  341:                     methodUsage.getDeclaration().getLastParam().getType().asArrayType().getComponentType();\n+  342:                 // the varargs corresponding type can be either T or Array<T>\n+  343:                 ResolvedType actualType =\n+  344:                     actualParamTypes.get(actualParamTypes.size() - 1).isArray() ?\n+  345:                         actualParamTypes.get(actualParamTypes.size() - 1).asArrayType().getComponentType() :\n+  346:                         actualParamTypes.get(actualParamTypes.size() - 1);\n+  347:                 if (!expectedType.isAssignableBy(actualType)) {\n+  348:                     for (ResolvedTypeParameterDeclaration tp : methodUsage.getDeclaration().getTypeParameters()) {\n+  349:                         expectedType = MethodResolutionLogic.replaceTypeParam(expectedType, tp, typeSolver);\n+  350:                     }\n+  351:                 }\n+  352:                 if (!expectedType.isAssignableBy(actualType)) {\n+  353:                     // ok, then it needs to be wrapped\n+  354:                     throw new UnsupportedOperationException(\n+  355:                         String.format(\"Unable to resolve the type typeParametersValues in a MethodUsage. Expected type: %s, Actual type: %s. Method Declaration: %s. MethodUsage: %s\",\n+  356:                                       expectedType,\n+  357:                                       actualType,\n+  358:                                       methodUsage.getDeclaration(),\n+  359:                                       methodUsage));\n+  360:                 }\n+  361:                 // match only the varargs type\n+  362:                 matchTypeParameters(expectedType, actualType, matchedTypeParameters);\n+  363:             } else if (methodUsage.getDeclaration().getNumberOfParams() == 1) {\n+  364:             \t// In this case the method declares only one parameter which is a variadic parameter.\n+  365:             \t// At this stage we can consider that the actual parameters all have the same type.\n+  366:                 ResolvedType expectedType =\n+  367:                     methodUsage.getDeclaration().getLastParam().getType().asArrayType().getComponentType();\n+  368:                 // the varargs corresponding type can not be an Array<T> because of the assumption\n+  369: //                ResolvedType actualType = new ResolvedArrayType(actualParamTypes.get(actualParamTypes.size() - 1));\n+  370:                 ResolvedType actualType = actualParamTypes.get(actualParamTypes.size() - 1);\n+  371:                 if (!expectedType.isAssignableBy(actualType)) {\n+  372:                     throw new UnsupportedOperationException(\n+  373:                     \t\tString.format(\"Unable to resolve the type typeParametersValues in a MethodUsage. Expected type: %s, Actual type: %s. Method Declaration: %s. MethodUsage: %s\",\n+  374:                             expectedType,\n+  375:                             actualType,\n+  376:                             methodUsage.getDeclaration(),\n+  377:                             methodUsage));\n+  378:                 }\n+  379:                 matchTypeParameters(expectedType, actualType, matchedTypeParameters);\n+  380:                 return replaceTypeParameter(methodUsage, matchedTypeParameters);\n+  381:             } else {\n+  382:                 return methodUsage;\n+  383:             }\n+  384:         }\n+  385: \n+  386:         int until = methodUsage.getDeclaration().hasVariadicParameter() ?\n+  387:             actualParamTypes.size() - 1 :\n+  388:             actualParamTypes.size();\n+  389: \n+  390:         for (int i = 0; i < until; i++) {\n+  391:             ResolvedType expectedType = methodUsage.getParamType(i);\n+  392:             ResolvedType actualType = actualParamTypes.get(i);\n+  393:             matchTypeParameters(expectedType, actualType, matchedTypeParameters);\n+  394:         }\n+  395:         methodUsage = replaceTypeParameter(methodUsage, matchedTypeParameters);\n+  396:         return methodUsage;\n+  397:     }\n+  399: \tprivate MethodUsage replaceTypeParameter(MethodUsage methodUsage,\n+  400: \t\t\tMap<ResolvedTypeParameterDeclaration, ResolvedType> matchedTypeParameters) {\n+  401: \t\tfor (ResolvedTypeParameterDeclaration tp : matchedTypeParameters.keySet()) {\n+  402:             methodUsage = methodUsage.replaceTypeParameter(tp, matchedTypeParameters.get(tp));\n+  403:         }\n+  404: \t\treturn methodUsage;\n+  405: \t}\n",
        "uniqueId": "3b6ee2e9f72d824eb11cc3e0afca8bed76b37df6_332_379_399_405_334_397",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 44,
                "covered": 119
            },
            "BRANCH": {
                "missed": 4,
                "covered": 14
            },
            "LINE": {
                "missed": 6,
                "covered": 24
            },
            "COMPLEXITY": {
                "missed": 3,
                "covered": 7
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 17
    },
    {
        "type": "Extract And Move Method",
        "description": "Extract And Move Method\tpublic convertToUsage(context Context) : ResolvedType extracted from protected convertToUsage(type Type, context Context) : ResolvedType in class com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade & moved to class com.github.javaparser.ast.type.VoidType",
        "diffLocations": [
            {
                "filePath": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java",
                "startLine": 622,
                "endLine": 653,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java",
                "startLine": 616,
                "endLine": 629,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java",
                "startLine": 132,
                "endLine": 135,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "/**\n     * Convert a {@link Type} into the corresponding {@link ResolvedType}.\n     *\n     * @param type      The type to be converted.\n     * @param context   The current context.\n     *\n     * @return The type resolved.\n     */\n    protected ResolvedType convertToUsage(Type type, Context context) {\n        if (context == null) {\n            throw new NullPointerException(\"Context should not be null\");\n        }\n        if (type.isUnknownType()) {\n            throw new IllegalArgumentException(\"Inferred lambda parameter type\");\n        } else if (type.isClassOrInterfaceType()) {\n            return convertClassOrInterfaceTypeToUsage(type.asClassOrInterfaceType(), context);\n        } else if (type.isPrimitiveType()) {\n            return ResolvedPrimitiveType.byName(type.asPrimitiveType().getType().name());\n        } else if (type.isWildcardType()) {\n            return convertWildcardTypeToUsage(type.asWildcardType(), context);\n        } else if (type.isVoidType()) {\n            return ResolvedVoidType.INSTANCE;\n        } else if (type.isArrayType()) {\n            return convertArrayTypeToUsage(type.asArrayType(), context);\n        } else if (type.isUnionType()) {\n            return convertUnionTypeToUsage(type.asUnionType(), context);\n        } else if (type.isVarType()) {\n            return convertVarTypeToUsage(type.asVarType(), context);\n        } else {\n            throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n        }\n    }",
        "filePathBefore": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java",
        "isPureRefactoring": true,
        "commitId": "86f41353d40bfd3ef0669b863926626b6c4949bf",
        "packageNameBefore": "com.github.javaparser.symbolsolver.javaparsermodel",
        "classNameBefore": "com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade",
        "methodNameBefore": "com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade#convertToUsage",
        "invokedMethod": "methodSignature: com.github.javaparser.ast.type.Type#isVoidType\n methodBody: public boolean isVoidType() {\nreturn false;\n}\nmethodSignature: com.github.javaparser.ast.type.Type#isPrimitiveType\n methodBody: public boolean isPrimitiveType() {\nreturn false;\n}\nmethodSignature: com.github.javaparser.ast.type.PrimitiveType#asPrimitiveType\n methodBody: public PrimitiveType asPrimitiveType() {\nreturn this;\n}\nmethodSignature: com.github.javaparser.ast.type.ArrayType#asArrayType\n methodBody: public ArrayType asArrayType() {\nreturn this;\n}\nmethodSignature: com.github.javaparser.ast.type.Type#isUnionType\n methodBody: public boolean isUnionType() {\nreturn false;\n}\nmethodSignature: com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade#convertArrayTypeToUsage\n methodBody: protected ResolvedType convertArrayTypeToUsage(ArrayType arrayType, Context context) {\nreturn new ResolvedArrayType(convertToUsage(arrayType.getComponentType(),context));\n}\nmethodSignature: com.github.javaparser.ast.type.Type#asClassOrInterfaceType\n methodBody: public ClassOrInterfaceType asClassOrInterfaceType() {\nthrow new IllegalStateException(f(\"%s is not ClassOrInterfaceType, it is %s\",this,this.getClass().getSimpleName()));\n}\nmethodSignature: com.github.javaparser.ast.type.UnionType#isUnionType\n methodBody: public boolean isUnionType() {\nreturn true;\n}\nmethodSignature: com.github.javaparser.ast.type.ClassOrInterfaceType#asClassOrInterfaceType\n methodBody: public ClassOrInterfaceType asClassOrInterfaceType() {\nreturn this;\n}\nmethodSignature: com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade#convertVarTypeToUsage\n methodBody: protected ResolvedType convertVarTypeToUsage(VarType varType, Context context) {\nNode parent=varType.getParentNode().get();\nif(!(parent instanceof VariableDeclarator)){throw new IllegalStateException(\"Trying to resolve a `var` which is not in a variable declaration.\");\n}final VariableDeclarator variableDeclarator=(VariableDeclarator)parent;\nOptional<Expression> initializer=variableDeclarator.getInitializer();\nif(!initializer.isPresent()){Optional<ForEachStmt> forEachStmt=forEachStmtWithVariableDeclarator(variableDeclarator);\nif(forEachStmt.isPresent()){Expression iterable=forEachStmt.get().getIterable();\nResolvedType iterType=iterable.calculateResolvedType();\nif(iterType instanceof ResolvedArrayType){return ((ResolvedArrayType)iterType).getComponentType();\n}if(iterType.isReferenceType()){List<ResolvedType> parametersType=iterType.asReferenceType().typeParametersMap().getTypes();\nif(parametersType.isEmpty()){Optional<ResolvedTypeDeclaration> oObjectDeclaration=context.solveType(JAVA_LANG_OBJECT).getDeclaration();\nreturn oObjectDeclaration.map(decl -> ReferenceTypeImpl.undeterminedParameters(decl.asReferenceType())).orElseThrow(() -> new UnsupportedOperationException());\n}return parametersType.get(0);\n}}}return initializer.map(Expression::calculateResolvedType).orElseThrow(() -> new IllegalStateException(\"Cannot resolve `var` which has no initializer.\"));\n}\nmethodSignature: com.github.javaparser.ast.type.ArrayType#isArrayType\n methodBody: public boolean isArrayType() {\nreturn true;\n}\nmethodSignature: com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade#convertWildcardTypeToUsage\n methodBody: protected ResolvedType convertWildcardTypeToUsage(WildcardType wildcardType, Context context) {\nif(wildcardType.getExtendedType().isPresent() && !wildcardType.getSuperType().isPresent()){return ResolvedWildcard.extendsBound(convertToUsage(wildcardType.getExtendedType().get(),context));\n}if(!wildcardType.getExtendedType().isPresent() && wildcardType.getSuperType().isPresent()){return ResolvedWildcard.superBound(convertToUsage(wildcardType.getSuperType().get(),context));\n}if(!wildcardType.getExtendedType().isPresent() && !wildcardType.getSuperType().isPresent()){return ResolvedWildcard.UNBOUNDED;\n}{throw new UnsupportedOperationException(wildcardType.toString());\n}}\nmethodSignature: com.github.javaparser.ast.type.Type#asWildcardType\n methodBody: public WildcardType asWildcardType() {\nthrow new IllegalStateException(f(\"%s is not WildcardType, it is %s\",this,this.getClass().getSimpleName()));\n}\nmethodSignature: com.github.javaparser.ast.type.Type#asVarType\n methodBody: public VarType asVarType() {\nthrow new IllegalStateException(f(\"%s is not VarType, it is %s\",this,this.getClass().getSimpleName()));\n}\nmethodSignature: com.github.javaparser.ast.type.Type#asUnionType\n methodBody: public UnionType asUnionType() {\nthrow new IllegalStateException(f(\"%s is not UnionType, it is %s\",this,this.getClass().getSimpleName()));\n}\nmethodSignature: com.github.javaparser.ast.type.Type#isVarType\n methodBody: public boolean isVarType() {\nreturn false;\n}\nmethodSignature: com.github.javaparser.ast.type.UnknownType#isUnknownType\n methodBody: public boolean isUnknownType() {\nreturn true;\n}\nmethodSignature: com.github.javaparser.ast.type.Type#asArrayType\n methodBody: public ArrayType asArrayType() {\nthrow new IllegalStateException(f(\"%s is not ArrayType, it is %s\",this,this.getClass().getSimpleName()));\n}\nmethodSignature: com.github.javaparser.ast.type.VarType#asVarType\n methodBody: public VarType asVarType() {\nreturn this;\n}\nmethodSignature: com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade#getType\n methodBody: public ResolvedType getType(Node node, boolean solveLambdas) {\nif(solveLambdas){if(!node.containsData(TYPE_WITH_LAMBDAS_RESOLVED)){ResolvedType res=getTypeConcrete(node,solveLambdas);\nnode.setData(TYPE_WITH_LAMBDAS_RESOLVED,res);\nboolean secondPassNecessary=false;\nif(node instanceof MethodCallExpr){MethodCallExpr methodCallExpr=(MethodCallExpr)node;\nfor(Node arg: methodCallExpr.getArguments()){if(!arg.containsData(TYPE_WITH_LAMBDAS_RESOLVED)){getType(arg,true);\nsecondPassNecessary=true;\n}}}if(secondPassNecessary){node.removeData(TYPE_WITH_LAMBDAS_RESOLVED);\nResolvedType type=getType(node,true);\nnode.setData(TYPE_WITH_LAMBDAS_RESOLVED,type);\n}Log.trace(\"getType on %s  -> %s\",() -> node,() -> res);\n}return node.getData(TYPE_WITH_LAMBDAS_RESOLVED);\n}{Optional<ResolvedType> res=find(TYPE_WITH_LAMBDAS_RESOLVED,node);\nif(res.isPresent()){return res.get();\n}res=find(TYPE_WITHOUT_LAMBDAS_RESOLVED,node);\nif(!res.isPresent()){ResolvedType resType=getTypeConcrete(node,solveLambdas);\nnode.setData(TYPE_WITHOUT_LAMBDAS_RESOLVED,resType);\nOptional<ResolvedType> finalRes=res;\nLog.trace(\"getType on %s (no solveLambdas) -> %s\",() -> node,() -> finalRes);\nreturn resType;\n}return res.get();\n}}\nmethodSignature: com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade#convertClassOrInterfaceTypeToUsage\n methodBody: protected ResolvedType convertClassOrInterfaceTypeToUsage(ClassOrInterfaceType classOrInterfaceType, Context context) {\nString name=classOrInterfaceType.getNameWithScope();\nSymbolReference<ResolvedTypeDeclaration> ref=context.solveType(name);\nif(!ref.isSolved()){throw new UnsolvedSymbolException(name);\n}ResolvedTypeDeclaration typeDeclaration=ref.getCorrespondingDeclaration();\nList<ResolvedType> typeParameters=Collections.emptyList();\nif(classOrInterfaceType.getTypeArguments().isPresent()){typeParameters=classOrInterfaceType.getTypeArguments().get().stream().map((pt) -> convertToUsage(pt,context)).collect(Collectors.toList());\n}if(typeDeclaration.isTypeParameter()){return new ResolvedTypeVariable(typeDeclaration.asTypeParameter());\n}{return new ReferenceTypeImpl((ResolvedReferenceTypeDeclaration)typeDeclaration,typeParameters);\n}}\nmethodSignature: com.github.javaparser.ast.type.Type#asPrimitiveType\n methodBody: public PrimitiveType asPrimitiveType() {\nthrow new IllegalStateException(f(\"%s is not PrimitiveType, it is %s\",this,this.getClass().getSimpleName()));\n}\nmethodSignature: com.github.javaparser.ast.type.VarType#isVarType\n methodBody: public boolean isVarType() {\nreturn true;\n}\nmethodSignature: com.github.javaparser.ast.type.VoidType#isVoidType\n methodBody: public boolean isVoidType() {\nreturn true;\n}\nmethodSignature: com.github.javaparser.ast.type.Type#isWildcardType\n methodBody: public boolean isWildcardType() {\nreturn false;\n}\nmethodSignature: com.github.javaparser.ast.type.Type#isUnknownType\n methodBody: public boolean isUnknownType() {\nreturn false;\n}\nmethodSignature: com.github.javaparser.ast.type.Type#isClassOrInterfaceType\n methodBody: public boolean isClassOrInterfaceType() {\nreturn false;\n}\nmethodSignature: com.github.javaparser.ast.type.PrimitiveType#getType\n methodBody: public Primitive getType() {\nreturn type;\n}\nmethodSignature: com.github.javaparser.ast.type.WildcardType#isWildcardType\n methodBody: public boolean isWildcardType() {\nreturn true;\n}\nmethodSignature: com.github.javaparser.ast.type.WildcardType#asWildcardType\n methodBody: public WildcardType asWildcardType() {\nreturn this;\n}\nmethodSignature: com.github.javaparser.ast.type.Type#isArrayType\n methodBody: public boolean isArrayType() {\nreturn false;\n}\nmethodSignature: com.github.javaparser.ast.type.ClassOrInterfaceType#isClassOrInterfaceType\n methodBody: public boolean isClassOrInterfaceType() {\nreturn true;\n}\nmethodSignature: com.github.javaparser.ast.type.PrimitiveType#isPrimitiveType\n methodBody: public boolean isPrimitiveType() {\nreturn true;\n}\nmethodSignature: com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade#convertUnionTypeToUsage\n methodBody: protected ResolvedType convertUnionTypeToUsage(UnionType unionType, Context context) {\nList<ResolvedType> resolvedElements=unionType.getElements().stream().map(el -> convertToUsage(el,context)).collect(Collectors.toList());\nreturn new ResolvedUnionType(resolvedElements);\n}\nmethodSignature: com.github.javaparser.ast.type.UnionType#asUnionType\n methodBody: public UnionType asUnionType() {\nreturn this;\n}",
        "classSignatureBefore": "public class JavaParserFacade ",
        "methodNameBeforeSet": [
            "com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade#convertToUsage"
        ],
        "classNameBeforeSet": [
            "com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade"
        ],
        "classSignatureBeforeSet": [
            "public class JavaParserFacade "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Copyright (C) 2015-2016 Federico Tomassetti\n * Copyright (C) 2017-2020 The JavaParser Team.\n *\n * This file is part of JavaParser.\n *\n * JavaParser can be used either under the terms of\n * a) the GNU Lesser General Public License as published by\n *     the Free Software Foundation, either version 3 of the License, or\n *     (at your option) any later version.\n * b) the terms of the Apache License\n *\n * You should have received a copy of both licenses in LICENCE.LGPL and\n * LICENCE.APACHE. Please refer to those files for details.\n *\n * JavaParser is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n */\n\npackage com.github.javaparser.symbolsolver.javaparsermodel;\n\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.DataKey;\nimport com.github.javaparser.ast.Node;\nimport com.github.javaparser.ast.NodeList;\nimport com.github.javaparser.ast.body.*;\nimport com.github.javaparser.ast.expr.*;\nimport com.github.javaparser.ast.stmt.ExplicitConstructorInvocationStmt;\nimport com.github.javaparser.ast.stmt.ForEachStmt;\nimport com.github.javaparser.ast.type.*;\nimport com.github.javaparser.resolution.MethodAmbiguityException;\nimport com.github.javaparser.resolution.MethodUsage;\nimport com.github.javaparser.resolution.TypeSolver;\nimport com.github.javaparser.resolution.UnsolvedSymbolException;\nimport com.github.javaparser.resolution.declarations.*;\nimport com.github.javaparser.resolution.model.LambdaArgumentTypePlaceholder;\nimport com.github.javaparser.resolution.model.SymbolReference;\nimport com.github.javaparser.resolution.model.typesystem.ReferenceTypeImpl;\nimport com.github.javaparser.resolution.types.*;\nimport com.github.javaparser.resolution.types.parametrization.ResolvedTypeParametersMap;\nimport com.github.javaparser.symbolsolver.core.resolution.Context;\nimport com.github.javaparser.symbolsolver.javaparsermodel.contexts.FieldAccessContext;\nimport com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserAnonymousClassDeclaration;\nimport com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserEnumDeclaration;\nimport com.github.javaparser.symbolsolver.reflectionmodel.ReflectionAnnotationDeclaration;\nimport com.github.javaparser.symbolsolver.reflectionmodel.ReflectionClassDeclaration;\nimport com.github.javaparser.symbolsolver.reflectionmodel.ReflectionEnumDeclaration;\nimport com.github.javaparser.symbolsolver.reflectionmodel.ReflectionInterfaceDeclaration;\nimport com.github.javaparser.symbolsolver.resolution.ConstructorResolutionLogic;\nimport com.github.javaparser.symbolsolver.resolution.MethodResolutionLogic;\nimport com.github.javaparser.symbolsolver.resolution.SymbolSolver;\nimport com.github.javaparser.utils.Log;\n\nimport java.util.*;\nimport java.util.stream.Collectors;\n\nimport static com.github.javaparser.resolution.model.SymbolReference.solved;\nimport static com.github.javaparser.resolution.model.SymbolReference.unsolved;\nimport static com.github.javaparser.symbolsolver.javaparser.Navigator.demandParentNode;\n\n/**\n * Class to be used by final users to solve symbols for JavaParser ASTs.\n *\n * @author Federico Tomassetti\n */\npublic class JavaParserFacade {\n\n    // Start of static class\n\n    private static final DataKey<ResolvedType> TYPE_WITH_LAMBDAS_RESOLVED = new DataKey<ResolvedType>() {\n    };\n    private static final DataKey<ResolvedType> TYPE_WITHOUT_LAMBDAS_RESOLVED = new DataKey<ResolvedType>() {\n    };\n\n    private static final Map<TypeSolver, JavaParserFacade> instances = new WeakHashMap<>();\n\n    private static final String JAVA_LANG_STRING = String.class.getCanonicalName();\n    \n    private static final String JAVA_LANG_OBJECT = Object.class.getCanonicalName();\n\n    /**\n     * Note that the addition of the modifier {@code synchronized} is specific and directly in response to issue #2668.\n     * <br>This <strong>MUST NOT</strong> be misinterpreted as a signal that JavaParser is safe to use within a multi-threaded environment.\n     * <br>\n     * <br>Additional discussion and context from a user attempting multithreading can be found within issue #2671 .\n     * <br>\n     *\n     * @see <a href=\"https://github.com/javaparser/javaparser/issues/2668\">https://github.com/javaparser/javaparser/issues/2668</a>\n     * @see <a href=\"https://github.com/javaparser/javaparser/issues/2671\">https://github.com/javaparser/javaparser/issues/2671</a>\n     */\n    public static synchronized JavaParserFacade get(TypeSolver typeSolver) {\n        return instances.computeIfAbsent(typeSolver, JavaParserFacade::new);\n    }\n\n    /**\n     * This method is used to clear internal caches for the sake of releasing memory.\n     */\n    public static void clearInstances() {\n        instances.clear();\n    }\n\n    protected static ResolvedType solveGenericTypes(ResolvedType type, Context context) {\n        if (type.isTypeVariable()) {\n            return context.solveGenericType(type.describe()).orElse(type);\n        }\n        if (type.isWildcard()) {\n            if (type.asWildcard().isExtends() || type.asWildcard().isSuper()) {\n                ResolvedWildcard wildcardUsage = type.asWildcard();\n                ResolvedType boundResolved = solveGenericTypes(wildcardUsage.getBoundedType(), context);\n                if (wildcardUsage.isExtends()) {\n                    return ResolvedWildcard.extendsBound(boundResolved);\n                } else {\n                    return ResolvedWildcard.superBound(boundResolved);\n                }\n            }\n        }\n        return type;\n    }\n\n    // End of static class\n\n    private final TypeSolver typeSolver;\n    private final TypeExtractor typeExtractor;\n    private final SymbolSolver symbolSolver;\n\n    private FailureHandler failureHandler;\n\n    private JavaParserFacade(TypeSolver typeSolver) {\n        this.typeSolver = typeSolver.getRoot();\n        this.symbolSolver = new SymbolSolver(typeSolver);\n        this.typeExtractor = new TypeExtractor(typeSolver, this);\n        this.failureHandler = new FailureHandler();\n    }\n\n    public TypeSolver getTypeSolver() {\n        return typeSolver;\n    }\n\n    public SymbolSolver getSymbolSolver() {\n        return symbolSolver;\n    }\n\n    public SymbolReference<? extends ResolvedValueDeclaration> solve(NameExpr nameExpr) {\n        return symbolSolver.solveSymbol(nameExpr.getName().getId(), nameExpr);\n    }\n\n    public SymbolReference<? extends ResolvedValueDeclaration> solve(SimpleName nameExpr) {\n        return symbolSolver.solveSymbol(nameExpr.getId(), nameExpr);\n    }\n\n    public SymbolReference<? extends ResolvedValueDeclaration> solve(Expression expr) {\n        return expr.toNameExpr().map(this::solve).orElseThrow(() -> new IllegalArgumentException(expr.getClass().getCanonicalName()));\n    }\n\n    public SymbolReference<ResolvedMethodDeclaration> solve(MethodCallExpr methodCallExpr) {\n        return solve(methodCallExpr, true);\n    }\n\n    public SymbolReference<ResolvedMethodDeclaration> solve(MethodReferenceExpr methodReferenceExpr) {\n        return solve(methodReferenceExpr, true);\n    }\n\n    public SymbolReference<ResolvedConstructorDeclaration> solve(ObjectCreationExpr objectCreationExpr) {\n        return solve(objectCreationExpr, true);\n    }\n\n    public SymbolReference<ResolvedConstructorDeclaration> solve(ExplicitConstructorInvocationStmt explicitConstructorInvocationStmt) {\n        return solve(explicitConstructorInvocationStmt, true);\n    }\n\n    public SymbolReference<ResolvedConstructorDeclaration> solve(ExplicitConstructorInvocationStmt explicitConstructorInvocationStmt, boolean solveLambdas) {\n        // Constructor invocation must exist within a class (not interface).\n        Optional<ClassOrInterfaceDeclaration> optAncestorClassOrInterfaceNode = explicitConstructorInvocationStmt.findAncestor(ClassOrInterfaceDeclaration.class);\n        if (!optAncestorClassOrInterfaceNode.isPresent()) {\n            return unsolved();\n        }\n\n        ClassOrInterfaceDeclaration classOrInterfaceNode = optAncestorClassOrInterfaceNode.get();\n        ResolvedReferenceTypeDeclaration resolvedClassNode = classOrInterfaceNode.resolve();\n        if (!resolvedClassNode.isClass()) {\n            throw new IllegalStateException(\"Expected to be a class -- cannot call this() or super() within an interface.\");\n        }\n\n        ResolvedTypeDeclaration typeDecl = null;\n        if (explicitConstructorInvocationStmt.isThis()) {\n            // this()\n            typeDecl = resolvedClassNode.asReferenceType();\n        } else {\n            // super()\n            Optional<ResolvedReferenceType> superClass = resolvedClassNode.asClass().getSuperClass();\n            if (superClass.isPresent() && superClass.get().getTypeDeclaration().isPresent()) {\n                typeDecl = superClass.get().getTypeDeclaration().get();\n            }\n        }\n        if (typeDecl == null) {\n            return unsolved();\n        }\n\n        // Solve each of the arguments being passed into this constructor invocation.\n        List<ResolvedType> argumentTypes = new LinkedList<>();\n        List<LambdaArgumentTypePlaceholder> placeholders = new LinkedList<>();\n        solveArguments(explicitConstructorInvocationStmt, explicitConstructorInvocationStmt.getArguments(), solveLambdas, argumentTypes, placeholders);\n\n        // Determine which constructor is referred to, and return it.\n        SymbolReference<ResolvedConstructorDeclaration> res = ConstructorResolutionLogic.findMostApplicable(((ResolvedClassDeclaration) typeDecl).getConstructors(), argumentTypes, typeSolver);\n        for (LambdaArgumentTypePlaceholder placeholder : placeholders) {\n            placeholder.setMethod(res);\n        }\n\n        return res;\n    }\n\n    public SymbolReference<ResolvedTypeDeclaration> solve(ThisExpr node) {\n        // If 'this' is prefixed by a class eg. MyClass.this\n        if (node.getTypeName().isPresent()) {\n            // Get the class name\n            String className = node.getTypeName().get().asString();\n            // Attempt to resolve using a typeSolver\n            SymbolReference<ResolvedReferenceTypeDeclaration> clazz = typeSolver.tryToSolveType(className);\n            if (clazz.isSolved()) {\n                return solved(clazz.getCorrespondingDeclaration());\n            }\n            // Attempt to resolve locally in Compilation unit\n            Optional<CompilationUnit> cu = node.findAncestor(CompilationUnit.class);\n            if (cu.isPresent()) {\n                Optional<ClassOrInterfaceDeclaration> classByName = cu.get().getClassByName(className);\n                if (classByName.isPresent()) {\n                    return solved(getTypeDeclaration(classByName.get()));\n                }\n            }\n        }\n        return solved(getTypeDeclaration(findContainingTypeDeclOrObjectCreationExpr(node)));\n    }\n\n    /**\n     * Given a constructor call find out to which constructor declaration it corresponds.\n     */\n    public SymbolReference<ResolvedConstructorDeclaration> solve(ObjectCreationExpr objectCreationExpr, boolean solveLambdas) {\n        List<ResolvedType> argumentTypes = new LinkedList<>();\n        List<LambdaArgumentTypePlaceholder> placeholders = new LinkedList<>();\n\n        solveArguments(objectCreationExpr, objectCreationExpr.getArguments(), solveLambdas, argumentTypes, placeholders);\n\n        ResolvedReferenceTypeDeclaration typeDecl = null;\n        if (objectCreationExpr.getAnonymousClassBody().isPresent()) {\n            typeDecl = new JavaParserAnonymousClassDeclaration(objectCreationExpr, typeSolver);\n        } else {\n            ResolvedType classDecl = JavaParserFacade.get(typeSolver).convert(objectCreationExpr.getType(), objectCreationExpr);\n            if (classDecl.isReferenceType() && classDecl.asReferenceType().getTypeDeclaration().isPresent()) {\n                typeDecl = classDecl.asReferenceType().getTypeDeclaration().get();\n            }\n        }\n        if (typeDecl == null) {\n            return unsolved();\n        }\n        SymbolReference<ResolvedConstructorDeclaration> res = ConstructorResolutionLogic.findMostApplicable(typeDecl.getConstructors(), argumentTypes, typeSolver);\n        for (LambdaArgumentTypePlaceholder placeholder : placeholders) {\n            placeholder.setMethod(res);\n        }\n        return res;\n    }\n\n    private void solveArguments(Node node, NodeList<Expression> args, boolean solveLambdas, List<ResolvedType> argumentTypes,\n                                List<LambdaArgumentTypePlaceholder> placeholders) {\n        int i = 0;\n        for (Expression parameterValue : args) {\n            if (parameterValue.isLambdaExpr() || parameterValue.isMethodReferenceExpr()) {\n                LambdaArgumentTypePlaceholder placeholder = new LambdaArgumentTypePlaceholder(i);\n                argumentTypes.add(placeholder);\n                placeholders.add(placeholder);\n            } else {\n                try {\n                    argumentTypes.add(JavaParserFacade.get(typeSolver).getType(parameterValue, solveLambdas));\n                } catch (Exception e) {\n                    throw failureHandler.handle(e, String.format(\"Unable to calculate the type of a parameter of a method call. Method call: %s, Parameter: %s\",\n                            node, parameterValue));\n                }\n            }\n            i++;\n        }\n    }\n\n    /**\n     * Given a method call find out to which method declaration it corresponds.\n     */\n    public SymbolReference<ResolvedMethodDeclaration> solve(MethodCallExpr methodCallExpr, boolean solveLambdas) {\n        List<ResolvedType> argumentTypes = new LinkedList<>();\n        List<LambdaArgumentTypePlaceholder> placeholders = new LinkedList<>();\n\n        solveArguments(methodCallExpr, methodCallExpr.getArguments(), solveLambdas, argumentTypes, placeholders);\n\n        SymbolReference<ResolvedMethodDeclaration> res = JavaParserFactory.getContext(methodCallExpr, typeSolver).solveMethod(methodCallExpr.getName().getId(), argumentTypes, false);\n        for (LambdaArgumentTypePlaceholder placeholder : placeholders) {\n            placeholder.setMethod(res);\n        }\n        return res;\n    }\n\n    /**\n     * Given a method reference find out to which method declaration it corresponds.\n     */\n    public SymbolReference<ResolvedMethodDeclaration> solve(MethodReferenceExpr methodReferenceExpr, boolean solveLambdas) {\n        // pass empty argument list to be populated\n        List<ResolvedType> argumentTypes = new LinkedList<>();\n        return JavaParserFactory.getContext(methodReferenceExpr, typeSolver).solveMethod(methodReferenceExpr.getIdentifier(), argumentTypes, false);\n    }\n\n    public SymbolReference<ResolvedAnnotationDeclaration> solve(AnnotationExpr annotationExpr) {\n        Context context = JavaParserFactory.getContext(annotationExpr, typeSolver);\n        SymbolReference<ResolvedTypeDeclaration> typeDeclarationSymbolReference = context.solveType(annotationExpr.getNameAsString());\n        if (typeDeclarationSymbolReference.isSolved()) {\n            ResolvedAnnotationDeclaration annotationDeclaration = (ResolvedAnnotationDeclaration) typeDeclarationSymbolReference.getCorrespondingDeclaration();\n            return solved(annotationDeclaration);\n        } else {\n            return unsolved();\n        }\n    }\n\n    public SymbolReference<ResolvedValueDeclaration> solve(FieldAccessExpr fieldAccessExpr) {\n        return ((FieldAccessContext) JavaParserFactory.getContext(fieldAccessExpr, typeSolver)).solveField(fieldAccessExpr.getName().getId());\n    }\n\n    /**\n     * Get the type associated with the node.\n     * <p>\n     * This method was originally intended to get the type of a value: any value has a type.\n     * <p>\n     * For example:\n     * <pre>\n     * int foo(int a) {\n     *     return a; // when getType is invoked on \"a\" it returns the type \"int\"\n     * }\n     * </pre>\n     * <p>\n     * Now, users started using also of names of types itself, which do not have a type.\n     * <p>\n     * For example:\n     * <pre>\n     * class A {\n     *     int foo(int a) {\n     *         return A.someStaticField; // when getType is invoked on \"A\", which represents a class, it returns\n     *             // the type \"A\" itself while it used to throw UnsolvedSymbolException\n     * }\n     * </pre>\n     * <p>\n     * To accommodate this usage and avoid confusion this method return\n     * the type itself when used on the name of type.\n     */\n    public ResolvedType getType(Node node) {\n        try {\n            return getType(node, true);\n        } catch (UnsolvedSymbolException e) {\n            if (node instanceof NameExpr) {\n                NameExpr nameExpr = (NameExpr) node;\n                SymbolReference<ResolvedTypeDeclaration> typeDeclaration = JavaParserFactory.getContext(node, typeSolver)\n                        .solveType(nameExpr.getNameAsString());\n                if (typeDeclaration.isSolved() && typeDeclaration.getCorrespondingDeclaration() instanceof ResolvedReferenceTypeDeclaration) {\n                    ResolvedReferenceTypeDeclaration resolvedReferenceTypeDeclaration = (ResolvedReferenceTypeDeclaration) typeDeclaration.getCorrespondingDeclaration();\n                    return ReferenceTypeImpl.undeterminedParameters(resolvedReferenceTypeDeclaration);\n                }\n            }\n            throw failureHandler.handle(e);\n        }\n    }\n\n    public ResolvedType getType(Node node, boolean solveLambdas) {\n        if (solveLambdas) {\n            if (!node.containsData(TYPE_WITH_LAMBDAS_RESOLVED)) {\n                ResolvedType res = getTypeConcrete(node, solveLambdas);\n\n                node.setData(TYPE_WITH_LAMBDAS_RESOLVED, res);\n\n                boolean secondPassNecessary = false;\n                if (node instanceof MethodCallExpr) {\n                    MethodCallExpr methodCallExpr = (MethodCallExpr) node;\n                    for (Node arg : methodCallExpr.getArguments()) {\n                        if (!arg.containsData(TYPE_WITH_LAMBDAS_RESOLVED)) {\n                            getType(arg, true);\n                            secondPassNecessary = true;\n                        }\n                    }\n                }\n                if (secondPassNecessary) {\n                    node.removeData(TYPE_WITH_LAMBDAS_RESOLVED);\n                    ResolvedType type = getType(node, true);\n                    node.setData(TYPE_WITH_LAMBDAS_RESOLVED, type);\n\n                }\n                Log.trace(\"getType on %s  -> %s\", () -> node, () -> res);\n            }\n            return node.getData(TYPE_WITH_LAMBDAS_RESOLVED);\n        } else {\n            Optional<ResolvedType> res = find(TYPE_WITH_LAMBDAS_RESOLVED, node);\n            if (res.isPresent()) {\n                return res.get();\n            }\n            res = find(TYPE_WITHOUT_LAMBDAS_RESOLVED, node);\n            if (!res.isPresent()) {\n                ResolvedType resType = getTypeConcrete(node, solveLambdas);\n                node.setData(TYPE_WITHOUT_LAMBDAS_RESOLVED, resType);\n                Optional<ResolvedType> finalRes = res;\n                Log.trace(\"getType on %s (no solveLambdas) -> %s\", () -> node, () -> finalRes);\n                return resType;\n            }\n            return res.get();\n        }\n    }\n\n    private Optional<ResolvedType> find(DataKey<ResolvedType> dataKey, Node node) {\n        if (node.containsData(dataKey)) {\n            return Optional.of(node.getData(dataKey));\n        }\n        return Optional.empty();\n    }\n\n    protected MethodUsage toMethodUsage(MethodReferenceExpr methodReferenceExpr, List<ResolvedType> paramTypes) {\n        Expression scope = methodReferenceExpr.getScope();\n        ResolvedType typeOfScope = getType(methodReferenceExpr.getScope());\n        if (!typeOfScope.isReferenceType()) {\n            throw new UnsupportedOperationException(typeOfScope.getClass().getCanonicalName());\n        }\n\n        Optional<MethodUsage> result;\n        Set<MethodUsage> allMethods = typeOfScope.asReferenceType().getTypeDeclaration()\n                .orElseThrow(() -> new RuntimeException(\"TypeDeclaration unexpectedly empty.\"))\n                .getAllMethods();\n\n        if (scope.isTypeExpr()) {\n            // static methods should match all params\n            List<MethodUsage> staticMethodUsages = allMethods.stream()\n                    .filter(it -> it.getDeclaration().isStatic())\n                    .collect(Collectors.toList());\n\n            result = MethodResolutionLogic.findMostApplicableUsage(staticMethodUsages, methodReferenceExpr.getIdentifier(), paramTypes, typeSolver);\n\n            if (!paramTypes.isEmpty()) {\n                // instance methods are called on the first param and should match all other params\n                List<MethodUsage> instanceMethodUsages = allMethods.stream()\n                        .filter(it -> !it.getDeclaration().isStatic())\n                        .collect(Collectors.toList());\n\n                List<ResolvedType> instanceMethodParamTypes = new ArrayList<>(paramTypes);\n                instanceMethodParamTypes.remove(0); // remove the first one\n\n                Optional<MethodUsage> instanceResult = MethodResolutionLogic.findMostApplicableUsage(\n                        instanceMethodUsages, methodReferenceExpr.getIdentifier(), instanceMethodParamTypes, typeSolver);\n                if (result.isPresent() && instanceResult.isPresent()) {\n                    throw new MethodAmbiguityException(\"Ambiguous method call: cannot find a most applicable method for \" + methodReferenceExpr.getIdentifier());\n                }\n\n                if (instanceResult.isPresent()) {\n                    result = instanceResult;\n                }\n            }\n        } else {\n            result = MethodResolutionLogic.findMostApplicableUsage(new ArrayList<>(allMethods), methodReferenceExpr.getIdentifier(), paramTypes, typeSolver);\n\n            if (result.isPresent() && result.get().getDeclaration().isStatic()) {\n                throw new RuntimeException(\"Invalid static method reference \" + methodReferenceExpr.getIdentifier());\n            }\n        }\n\n        if (!result.isPresent()) {\n            throw new UnsupportedOperationException();\n        }\n\n        return result.get();\n    }\n\n    protected ResolvedType getBinaryTypeConcrete(Node left, Node right, boolean solveLambdas, BinaryExpr.Operator operator) {\n        ResolvedType leftType = getTypeConcrete(left, solveLambdas);\n        ResolvedType rightType = getTypeConcrete(right, solveLambdas);\n\n        // JLS 15.18.1. String Concatenation Operator +\n        // If only one operand expression is of type String, then string conversion (\u00a75.1.11) is performed on the other\n        // operand to produce a string at run time.\n        //\n        // The result of string concatenation is a reference to a String object that is the concatenation of the two\n        // operand strings. The characters of the left-hand operand precede the characters of the right-hand operand in\n        // the newly created string.\n\n        if (operator == BinaryExpr.Operator.PLUS) {\n            boolean isLeftString = leftType.isReferenceType() && leftType.asReferenceType()\n                    .getQualifiedName().equals(JAVA_LANG_STRING);\n            boolean isRightString = rightType.isReferenceType() && rightType.asReferenceType()\n                    .getQualifiedName().equals(JAVA_LANG_STRING);\n            if (isLeftString || isRightString) {\n                return isLeftString ? leftType : rightType;\n            }\n        }\n\n        // JLS 5.6.2. Binary Numeric Promotion\n        //\n        // Widening primitive conversion (\u00a75.1.2) is applied to convert either or both operands as specified by the\n        // following rules:\n        //\n        // * If either operand is of type double, the other is converted to double.\n        // * Otherwise, if either operand is of type float, the other is converted to float.\n        // * Otherwise, if either operand is of type long, the other is converted to long.\n        // * Otherwise, both operands are converted to type int.\n\n        boolean isLeftNumeric = leftType.isPrimitive() && leftType.asPrimitive().isNumeric();\n        boolean isRightNumeric = rightType.isPrimitive() && rightType.asPrimitive().isNumeric();\n\n        if (isLeftNumeric && isRightNumeric) {\n            return leftType.asPrimitive().bnp(rightType.asPrimitive());\n        }\n\n        if (rightType.isAssignableBy(leftType)) {\n            return rightType;\n        }\n        return leftType;\n    }\n\n\n    /**\n     * Should return more like a TypeApplication: a TypeDeclaration and possible typeParametersValues or array\n     * modifiers.\n     */\n    private ResolvedType getTypeConcrete(Node node, boolean solveLambdas) {\n        if (node == null) throw new IllegalArgumentException();\n        return node.accept(typeExtractor, solveLambdas);\n    }\n\n    /**\n     * Where a node has an interface/class/enum declaration as its ancestor, return the nearest one.\n     * <p>\n     * NOTE: See {@link #findContainingTypeDeclOrObjectCreationExpr} if wanting to include anonymous inner classes.\n     * <p>\n     * For example, these all return X:\n     * {@code public interface X { ... node here ... }}\n     * {@code public class X { ... node here ... }}\n     * {@code public enum X { ... node here ... }}\n     *\n     * @param node The Node whose ancestors will be traversed,\n     * @return The first class/interface/enum declaration in the Node's ancestry.\n     */\n    protected TypeDeclaration<?> findContainingTypeDecl(Node node) {\n        Node parent = node;\n        while (true) {\n            parent = demandParentNode(parent);\n            if (parent instanceof TypeDeclaration) {\n                return (TypeDeclaration<?>) parent;\n            }\n        }\n    }\n\n    /**\n     * Where a node has an interface/class/enum declaration -- or an object creation expression (anonymous inner class)\n     * -- as its ancestor, return the nearest one.\n     * <p>\n     * NOTE: See {@link #findContainingTypeDecl} if wanting to not include anonymous inner classes.\n     * <p>\n     * For example, these all return X:\n     * <ul>\n     *     <li>{@code public interface X { ... node here ... }}</li>\n     *     <li>{@code public class X { ... node here ... }}</li>\n     *     <li>{@code public enum X { ... node here ... }}</li>\n     *     <li><pre>{@code\n     *     new ActionListener() {\n     *          ... node here ...\n     *          public void actionPerformed(ActionEvent e) {\n     *               ... or node here ...\n     *          }\n     *     }\n     *     }</pre></li>\n     * </ul>\n     * <p>\n     *\n     * @param node The Node whose ancestors will be traversed,\n     * @return The first class/interface/enum declaration -- or object creation expression (anonymous inner class) -- in\n     * the Node's ancestry.\n     */\n    protected Node findContainingTypeDeclOrObjectCreationExpr(Node node) {\n        Node parent = node;\n        boolean detachFlag = false;\n        while (true) {\n            parent = demandParentNode(parent);\n            if (parent instanceof BodyDeclaration) {\n                if (parent instanceof TypeDeclaration) {\n                    return parent;\n                } else {\n                    detachFlag = true;\n                }\n            } else if (parent instanceof ObjectCreationExpr) {\n                if (detachFlag) {\n                    return parent;\n                }\n            }\n        }\n    }\n\n    /**\n     * Where a node has an interface/class/enum declaration -- or an object creation expression in an inner class\n     * references an outer class -- as its ancestor, return the declaration corresponding to the class name specified.\n     */\n    protected Node findContainingTypeDeclOrObjectCreationExpr(Node node, String className) {\n        Node parent = node;\n        boolean detachFlag = false;\n        while (true) {\n            parent = demandParentNode(parent);\n            if (parent instanceof BodyDeclaration) {\n                if (parent instanceof TypeDeclaration && ((TypeDeclaration<?>) parent).getFullyQualifiedName().get().endsWith(className)) {\n                    return parent;\n                } else {\n                    detachFlag = true;\n                }\n            } else if (parent instanceof ObjectCreationExpr && ((ObjectCreationExpr) parent).getType().getName().asString().equals(className)) {\n                if (detachFlag) {\n                    return parent;\n                }\n            }\n        }\n    }\n\n    public ResolvedType convertToUsageVariableType(VariableDeclarator var) {\n        return get(typeSolver).convertToUsage(var.getType(), var);\n    }\n\n    /**\n     * Convert a {@link Type} into the corresponding {@link ResolvedType}.\n     *\n     * @param type      The type to be converted.\n     * @param context   The current context.\n     *\n     * @return The type resolved.\n     */\n    protected ResolvedType convertToUsage(Type type, Context context) {\n        if (context == null) {\n            throw new NullPointerException(\"Context should not be null\");\n        }\n        if (type.isUnknownType()) {\n            throw new IllegalArgumentException(\"Inferred lambda parameter type\");\n        } else if (type.isClassOrInterfaceType()) {\n            return convertClassOrInterfaceTypeToUsage(type.asClassOrInterfaceType(), context);\n        } else if (type.isPrimitiveType()) {\n            return ResolvedPrimitiveType.byName(type.asPrimitiveType().getType().name());\n        } else if (type.isWildcardType()) {\n            return convertWildcardTypeToUsage(type.asWildcardType(), context);\n        } else if (type.isVoidType()) {\n            return ResolvedVoidType.INSTANCE;\n        } else if (type.isArrayType()) {\n            return convertArrayTypeToUsage(type.asArrayType(), context);\n        } else if (type.isUnionType()) {\n            return convertUnionTypeToUsage(type.asUnionType(), context);\n        } else if (type.isVarType()) {\n            return convertVarTypeToUsage(type.asVarType(), context);\n        } else {\n            throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n        }\n    }\n\n    /**\n     * Convert a {@link Type} into the corresponding {@link ResolvedType}.\n     *\n     * @param type      The type to be converted.\n     * @param context   The current context.\n     *\n     * @return The type resolved.\n     */\n    public ResolvedType convertToUsage(Type type, Node context) {\n        return convertToUsage(type, JavaParserFactory.getContext(context, typeSolver));\n    }\n\n    /**\n     * Convert a {@link Type} into the corresponding {@link ResolvedType}.\n     *\n     * @param type The type to be converted.\n     *\n     * @return The type resolved.\n     */\n    public ResolvedType convertToUsage(Type type) {\n        return convertToUsage(type, type);\n    }\n\n    /**\n     * Convert a {@link ClassOrInterfaceType} into a {@link ResolvedType}.\n     *\n     * @param classOrInterfaceType  The class of interface type to be converted.\n     * @param context               The current context.\n     *\n     * @return The type resolved.\n     */\n    protected ResolvedType convertClassOrInterfaceTypeToUsage(ClassOrInterfaceType classOrInterfaceType, Context context) {\n        String name = classOrInterfaceType.getNameWithScope();\n        SymbolReference<ResolvedTypeDeclaration> ref = context.solveType(name);\n        if (!ref.isSolved()) {\n            throw new UnsolvedSymbolException(name);\n        }\n        ResolvedTypeDeclaration typeDeclaration = ref.getCorrespondingDeclaration();\n        List<ResolvedType> typeParameters = Collections.emptyList();\n        if (classOrInterfaceType.getTypeArguments().isPresent()) {\n            typeParameters = classOrInterfaceType.getTypeArguments().get().stream().map((pt) -> convertToUsage(pt, context)).collect(Collectors.toList());\n        }\n        if (typeDeclaration.isTypeParameter()) {\n            return new ResolvedTypeVariable(typeDeclaration.asTypeParameter());\n        } else {\n            return new ReferenceTypeImpl((ResolvedReferenceTypeDeclaration) typeDeclaration, typeParameters);\n        }\n    }\n\n    /**\n     * Convert a {@link WildcardType} into a {@link ResolvedType}.\n     *\n     * @param wildcardType  The wildcard type to be converted.\n     * @param context       The current context.\n     *\n     * @return The type resolved.\n     */\n    protected ResolvedType convertWildcardTypeToUsage(WildcardType wildcardType, Context context) {\n        if (wildcardType.getExtendedType().isPresent() && !wildcardType.getSuperType().isPresent()) {\n            return ResolvedWildcard.extendsBound(convertToUsage(wildcardType.getExtendedType().get(), context)); // removed (ReferenceTypeImpl)\n        } else if (!wildcardType.getExtendedType().isPresent() && wildcardType.getSuperType().isPresent()) {\n            return ResolvedWildcard.superBound(convertToUsage(wildcardType.getSuperType().get(), context)); // removed (ReferenceTypeImpl)\n        } else if (!wildcardType.getExtendedType().isPresent() && !wildcardType.getSuperType().isPresent()) {\n            return ResolvedWildcard.UNBOUNDED;\n        } else {\n            throw new UnsupportedOperationException(wildcardType.toString());\n        }\n    }\n\n    /**\n     * Convert a {@link ArrayType} into a {@link ResolvedType}.\n     *\n     * @param arrayType The array type to be converted.\n     * @param context   The current context.\n     *\n     * @return The type resolved.\n     */\n    protected ResolvedType convertArrayTypeToUsage(ArrayType arrayType, Context context) {\n        return new ResolvedArrayType(convertToUsage(arrayType.getComponentType(), context));\n    }\n\n    /**\n     * Convert a {@link UnionType} into a {@link ResolvedType}.\n     *\n     * @param unionType The union type to be converted.\n     * @param context   The current context.\n     *\n     * @return The type resolved.\n     */\n    protected ResolvedType convertUnionTypeToUsage(UnionType unionType, Context context) {\n        List<ResolvedType> resolvedElements = unionType.getElements().stream()\n                .map(el -> convertToUsage(el, context))\n                .collect(Collectors.toList());\n        return new ResolvedUnionType(resolvedElements);\n    }\n\n    /**\n     * Convert a {@link VarType} into a {@link ResolvedType}.\n     *\n     * @param varType The var type to be converted.\n     * @param context The current context.\n     *\n     * @return The type resolved.\n     */\n    protected ResolvedType convertVarTypeToUsage(VarType varType, Context context) {\n        Node parent = varType.getParentNode().get();\n        if (!(parent instanceof VariableDeclarator)) {\n            throw new IllegalStateException(\"Trying to resolve a `var` which is not in a variable declaration.\");\n        }\n        final VariableDeclarator variableDeclarator = (VariableDeclarator) parent;\n        Optional<Expression> initializer = variableDeclarator.getInitializer();\n        if (!initializer.isPresent()) {\n            // When a `var` type decl has no initializer it may be part of a\n            // for-each statement (e.g. `for(var i : expr)`).\n            Optional<ForEachStmt> forEachStmt = forEachStmtWithVariableDeclarator(variableDeclarator);\n            if (forEachStmt.isPresent()) {\n                Expression iterable = forEachStmt.get().getIterable();\n                ResolvedType iterType = iterable.calculateResolvedType();\n                if (iterType instanceof ResolvedArrayType) {\n                    // The type of a variable in a for-each loop with an array\n                    // is the component type of the array.\n                    return ((ResolvedArrayType)iterType).getComponentType();\n                }\n                if (iterType.isReferenceType()) {\n                    // The type of a variable in a for-each loop with an\n                    // Iterable with parameter type\n                \tList<ResolvedType> parametersType = iterType.asReferenceType().typeParametersMap().getTypes();\n\t\t\t\t\tif (parametersType.isEmpty()) {\n\t\t\t\t\t\tOptional<ResolvedTypeDeclaration> oObjectDeclaration = context.solveType(JAVA_LANG_OBJECT)\n\t\t\t\t\t\t\t\t.getDeclaration();\n\t\t\t\t\t\treturn oObjectDeclaration\n\t\t\t\t\t\t\t\t.map(decl -> ReferenceTypeImpl.undeterminedParameters(decl.asReferenceType()))\n\t\t\t\t\t\t\t\t.orElseThrow(() -> new UnsupportedOperationException());\n\t\t\t\t\t}\n                    return parametersType.get(0);\n                }\n            }\n        }\n        return initializer\n                .map(Expression::calculateResolvedType)\n                .orElseThrow(() -> new IllegalStateException(\"Cannot resolve `var` which has no initializer.\"));\n    }\n\n    private Optional<ForEachStmt> forEachStmtWithVariableDeclarator(\n            VariableDeclarator variableDeclarator) {\n        Optional<Node> node = variableDeclarator.getParentNode();\n        if (!node.isPresent() || !(node.get() instanceof VariableDeclarationExpr)) {\n            return Optional.empty();\n        }\n        node = node.get().getParentNode();\n        if (!node.isPresent() || !(node.get() instanceof ForEachStmt)) {\n            return Optional.empty();\n        } else {\n            return Optional.of((ForEachStmt)node.get());\n        }\n    }\n\n    public ResolvedType convert(Type type, Node node) {\n        return convert(type, JavaParserFactory.getContext(node, typeSolver));\n    }\n\n    public ResolvedType convert(Type type, Context context) {\n        return convertToUsage(type, context);\n    }\n\n    public MethodUsage solveMethodAsUsage(MethodCallExpr call) {\n        List<ResolvedType> params = new ArrayList<>();\n        if (call.getArguments() != null) {\n            for (Expression param : call.getArguments()) {\n                //getTypeConcrete(Node node, boolean solveLambdas)\n                try {\n                    params.add(getType(param, false));\n                } catch (Exception e) {\n                    throw failureHandler.handle(e, String.format(\"Error calculating the type of parameter %s of method call %s\", param, call));\n                }\n                //params.add(getTypeConcrete(param, false));\n            }\n        }\n        Context context = JavaParserFactory.getContext(call, typeSolver);\n        Optional<MethodUsage> methodUsage = context.solveMethodAsUsage(call.getName().getId(), params);\n        if (!methodUsage.isPresent()) {\n            throw new RuntimeException(\"Method '\" + call.getName() + \"' cannot be resolved in context \"\n                    + call + \" (line: \" + call.getRange().map(r -> \"\" + r.begin.line).orElse(\"??\") + \") \" + context + \". Parameter types: \" + params);\n        }\n        return methodUsage.get();\n    }\n\n    public ResolvedReferenceTypeDeclaration getTypeDeclaration(Node node) {\n        if (node instanceof TypeDeclaration) {\n            return getTypeDeclaration((TypeDeclaration) node);\n        }\n        if (node instanceof ObjectCreationExpr) {\n            return new JavaParserAnonymousClassDeclaration((ObjectCreationExpr) node, typeSolver);\n        }\n        throw new IllegalArgumentException();\n    }\n\n    public ResolvedReferenceTypeDeclaration getTypeDeclaration(ClassOrInterfaceDeclaration classOrInterfaceDeclaration) {\n        return JavaParserFactory.toTypeDeclaration(classOrInterfaceDeclaration, typeSolver);\n    }\n\n    /**\n     * \"this\" inserted in the given point, which type would have?\n     */\n    public ResolvedType getTypeOfThisIn(Node node) {\n        // TODO consider static methods\n        if (node instanceof ClassOrInterfaceDeclaration) {\n            return new ReferenceTypeImpl(getTypeDeclaration((ClassOrInterfaceDeclaration) node));\n        }\n        if (node instanceof EnumDeclaration) {\n            JavaParserEnumDeclaration enumDeclaration = new JavaParserEnumDeclaration((EnumDeclaration) node, typeSolver);\n            return new ReferenceTypeImpl(enumDeclaration);\n        }\n        if (node instanceof ObjectCreationExpr && ((ObjectCreationExpr) node).getAnonymousClassBody().isPresent()) {\n            JavaParserAnonymousClassDeclaration anonymousDeclaration = new JavaParserAnonymousClassDeclaration((ObjectCreationExpr) node, typeSolver);\n            return new ReferenceTypeImpl(anonymousDeclaration);\n        }\n        return getTypeOfThisIn(demandParentNode(node));\n    }\n\n    public ResolvedReferenceTypeDeclaration getTypeDeclaration(TypeDeclaration<?> typeDeclaration) {\n        return JavaParserFactory.toTypeDeclaration(typeDeclaration, typeSolver);\n    }\n\n    /**\n     * Convert a {@link Class} into the corresponding {@link ResolvedType}.\n     *\n     * @param clazz The class to be converted.\n     *\n     * @return The class resolved.\n     */\n    public ResolvedType classToResolvedType(Class<?> clazz) {\n        if (clazz.isPrimitive()) {\n            return ResolvedPrimitiveType.byName(clazz.getName());\n        }\n\n        ResolvedReferenceTypeDeclaration declaration;\n        if (clazz.isAnnotation()) {\n            declaration = new ReflectionAnnotationDeclaration(clazz, typeSolver);\n        } else if (clazz.isEnum()) {\n            declaration = new ReflectionEnumDeclaration(clazz, typeSolver);\n        } else if (clazz.isInterface()) {\n            declaration = new ReflectionInterfaceDeclaration(clazz, typeSolver);\n        } else {\n            declaration = new ReflectionClassDeclaration(clazz, typeSolver);\n        }\n        return new ReferenceTypeImpl(declaration);\n    }\n\n}\n",
        "filePathAfter": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java",
        "sourceCodeAfterForWhole": "/*\n * Copyright (C) 2015-2016 Federico Tomassetti\n * Copyright (C) 2017-2020 The JavaParser Team.\n *\n * This file is part of JavaParser.\n *\n * JavaParser can be used either under the terms of\n * a) the GNU Lesser General Public License as published by\n *     the Free Software Foundation, either version 3 of the License, or\n *     (at your option) any later version.\n * b) the terms of the Apache License\n *\n * You should have received a copy of both licenses in LICENCE.LGPL and\n * LICENCE.APACHE. Please refer to those files for details.\n *\n * JavaParser is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n */\n\npackage com.github.javaparser.symbolsolver.javaparsermodel;\n\nimport com.github.javaparser.ast.CompilationUnit;\nimport com.github.javaparser.ast.DataKey;\nimport com.github.javaparser.ast.Node;\nimport com.github.javaparser.ast.NodeList;\nimport com.github.javaparser.ast.body.*;\nimport com.github.javaparser.ast.expr.*;\nimport com.github.javaparser.ast.stmt.ExplicitConstructorInvocationStmt;\nimport com.github.javaparser.ast.stmt.ForEachStmt;\nimport com.github.javaparser.ast.type.*;\nimport com.github.javaparser.resolution.Context;\nimport com.github.javaparser.resolution.MethodAmbiguityException;\nimport com.github.javaparser.resolution.MethodUsage;\nimport com.github.javaparser.resolution.TypeSolver;\nimport com.github.javaparser.resolution.UnsolvedSymbolException;\nimport com.github.javaparser.resolution.declarations.*;\nimport com.github.javaparser.resolution.model.LambdaArgumentTypePlaceholder;\nimport com.github.javaparser.resolution.model.SymbolReference;\nimport com.github.javaparser.resolution.model.typesystem.ReferenceTypeImpl;\nimport com.github.javaparser.resolution.types.*;\nimport com.github.javaparser.resolution.types.parametrization.ResolvedTypeParametersMap;\nimport com.github.javaparser.symbolsolver.javaparsermodel.contexts.FieldAccessContext;\nimport com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserAnonymousClassDeclaration;\nimport com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserEnumDeclaration;\nimport com.github.javaparser.symbolsolver.reflectionmodel.ReflectionAnnotationDeclaration;\nimport com.github.javaparser.symbolsolver.reflectionmodel.ReflectionClassDeclaration;\nimport com.github.javaparser.symbolsolver.reflectionmodel.ReflectionEnumDeclaration;\nimport com.github.javaparser.symbolsolver.reflectionmodel.ReflectionInterfaceDeclaration;\nimport com.github.javaparser.symbolsolver.resolution.ConstructorResolutionLogic;\nimport com.github.javaparser.symbolsolver.resolution.MethodResolutionLogic;\nimport com.github.javaparser.symbolsolver.resolution.SymbolSolver;\nimport com.github.javaparser.utils.Log;\n\nimport java.util.*;\nimport java.util.stream.Collectors;\n\nimport static com.github.javaparser.resolution.model.SymbolReference.solved;\nimport static com.github.javaparser.resolution.model.SymbolReference.unsolved;\nimport static com.github.javaparser.symbolsolver.javaparser.Navigator.demandParentNode;\n\n/**\n * Class to be used by final users to solve symbols for JavaParser ASTs.\n *\n * @author Federico Tomassetti\n */\npublic class JavaParserFacade {\n\n    // Start of static class\n\n    private static final DataKey<ResolvedType> TYPE_WITH_LAMBDAS_RESOLVED = new DataKey<ResolvedType>() {\n    };\n    private static final DataKey<ResolvedType> TYPE_WITHOUT_LAMBDAS_RESOLVED = new DataKey<ResolvedType>() {\n    };\n\n    private static final Map<TypeSolver, JavaParserFacade> instances = new WeakHashMap<>();\n\n    private static final String JAVA_LANG_STRING = String.class.getCanonicalName();\n    \n    /**\n     * Note that the addition of the modifier {@code synchronized} is specific and directly in response to issue #2668.\n     * <br>This <strong>MUST NOT</strong> be misinterpreted as a signal that JavaParser is safe to use within a multi-threaded environment.\n     * <br>\n     * <br>Additional discussion and context from a user attempting multithreading can be found within issue #2671 .\n     * <br>\n     *\n     * @see <a href=\"https://github.com/javaparser/javaparser/issues/2668\">https://github.com/javaparser/javaparser/issues/2668</a>\n     * @see <a href=\"https://github.com/javaparser/javaparser/issues/2671\">https://github.com/javaparser/javaparser/issues/2671</a>\n     */\n    public static synchronized JavaParserFacade get(TypeSolver typeSolver) {\n        return instances.computeIfAbsent(typeSolver, JavaParserFacade::new);\n    }\n\n    /**\n     * This method is used to clear internal caches for the sake of releasing memory.\n     */\n    public static void clearInstances() {\n        instances.clear();\n    }\n\n    protected static ResolvedType solveGenericTypes(ResolvedType type, Context context) {\n        if (type.isTypeVariable()) {\n            return context.solveGenericType(type.describe()).orElse(type);\n        }\n        if (type.isWildcard()) {\n            if (type.asWildcard().isExtends() || type.asWildcard().isSuper()) {\n                ResolvedWildcard wildcardUsage = type.asWildcard();\n                ResolvedType boundResolved = solveGenericTypes(wildcardUsage.getBoundedType(), context);\n                if (wildcardUsage.isExtends()) {\n                    return ResolvedWildcard.extendsBound(boundResolved);\n                } else {\n                    return ResolvedWildcard.superBound(boundResolved);\n                }\n            }\n        }\n        return type;\n    }\n\n    // End of static class\n\n    private final TypeSolver typeSolver;\n    private final TypeExtractor typeExtractor;\n    private final SymbolSolver symbolSolver;\n\n    private FailureHandler failureHandler;\n\n    private JavaParserFacade(TypeSolver typeSolver) {\n        this.typeSolver = typeSolver.getRoot();\n        this.symbolSolver = new SymbolSolver(typeSolver);\n        this.typeExtractor = new TypeExtractor(typeSolver, this);\n        this.failureHandler = new FailureHandler();\n    }\n\n    public TypeSolver getTypeSolver() {\n        return typeSolver;\n    }\n\n    public SymbolSolver getSymbolSolver() {\n        return symbolSolver;\n    }\n\n    public SymbolReference<? extends ResolvedValueDeclaration> solve(NameExpr nameExpr) {\n        return symbolSolver.solveSymbol(nameExpr.getName().getId(), nameExpr);\n    }\n\n    public SymbolReference<? extends ResolvedValueDeclaration> solve(SimpleName nameExpr) {\n        return symbolSolver.solveSymbol(nameExpr.getId(), nameExpr);\n    }\n\n    public SymbolReference<? extends ResolvedValueDeclaration> solve(Expression expr) {\n        return expr.toNameExpr().map(this::solve).orElseThrow(() -> new IllegalArgumentException(expr.getClass().getCanonicalName()));\n    }\n\n    public SymbolReference<ResolvedMethodDeclaration> solve(MethodCallExpr methodCallExpr) {\n        return solve(methodCallExpr, true);\n    }\n\n    public SymbolReference<ResolvedMethodDeclaration> solve(MethodReferenceExpr methodReferenceExpr) {\n        return solve(methodReferenceExpr, true);\n    }\n\n    public SymbolReference<ResolvedConstructorDeclaration> solve(ObjectCreationExpr objectCreationExpr) {\n        return solve(objectCreationExpr, true);\n    }\n\n    public SymbolReference<ResolvedConstructorDeclaration> solve(ExplicitConstructorInvocationStmt explicitConstructorInvocationStmt) {\n        return solve(explicitConstructorInvocationStmt, true);\n    }\n\n    public SymbolReference<ResolvedConstructorDeclaration> solve(ExplicitConstructorInvocationStmt explicitConstructorInvocationStmt, boolean solveLambdas) {\n        // Constructor invocation must exist within a class (not interface).\n        Optional<ClassOrInterfaceDeclaration> optAncestorClassOrInterfaceNode = explicitConstructorInvocationStmt.findAncestor(ClassOrInterfaceDeclaration.class);\n        if (!optAncestorClassOrInterfaceNode.isPresent()) {\n            return unsolved();\n        }\n\n        ClassOrInterfaceDeclaration classOrInterfaceNode = optAncestorClassOrInterfaceNode.get();\n        ResolvedReferenceTypeDeclaration resolvedClassNode = classOrInterfaceNode.resolve();\n        if (!resolvedClassNode.isClass()) {\n            throw new IllegalStateException(\"Expected to be a class -- cannot call this() or super() within an interface.\");\n        }\n\n        ResolvedTypeDeclaration typeDecl = null;\n        if (explicitConstructorInvocationStmt.isThis()) {\n            // this()\n            typeDecl = resolvedClassNode.asReferenceType();\n        } else {\n            // super()\n            Optional<ResolvedReferenceType> superClass = resolvedClassNode.asClass().getSuperClass();\n            if (superClass.isPresent() && superClass.get().getTypeDeclaration().isPresent()) {\n                typeDecl = superClass.get().getTypeDeclaration().get();\n            }\n        }\n        if (typeDecl == null) {\n            return unsolved();\n        }\n\n        // Solve each of the arguments being passed into this constructor invocation.\n        List<ResolvedType> argumentTypes = new LinkedList<>();\n        List<LambdaArgumentTypePlaceholder> placeholders = new LinkedList<>();\n        solveArguments(explicitConstructorInvocationStmt, explicitConstructorInvocationStmt.getArguments(), solveLambdas, argumentTypes, placeholders);\n\n        // Determine which constructor is referred to, and return it.\n        SymbolReference<ResolvedConstructorDeclaration> res = ConstructorResolutionLogic.findMostApplicable(((ResolvedClassDeclaration) typeDecl).getConstructors(), argumentTypes, typeSolver);\n        for (LambdaArgumentTypePlaceholder placeholder : placeholders) {\n            placeholder.setMethod(res);\n        }\n\n        return res;\n    }\n\n    public SymbolReference<ResolvedTypeDeclaration> solve(ThisExpr node) {\n        // If 'this' is prefixed by a class eg. MyClass.this\n        if (node.getTypeName().isPresent()) {\n            // Get the class name\n            String className = node.getTypeName().get().asString();\n            // Attempt to resolve using a typeSolver\n            SymbolReference<ResolvedReferenceTypeDeclaration> clazz = typeSolver.tryToSolveType(className);\n            if (clazz.isSolved()) {\n                return solved(clazz.getCorrespondingDeclaration());\n            }\n            // Attempt to resolve locally in Compilation unit\n            Optional<CompilationUnit> cu = node.findAncestor(CompilationUnit.class);\n            if (cu.isPresent()) {\n                Optional<ClassOrInterfaceDeclaration> classByName = cu.get().getClassByName(className);\n                if (classByName.isPresent()) {\n                    return solved(getTypeDeclaration(classByName.get()));\n                }\n            }\n        }\n        return solved(getTypeDeclaration(findContainingTypeDeclOrObjectCreationExpr(node)));\n    }\n\n    /**\n     * Given a constructor call find out to which constructor declaration it corresponds.\n     */\n    public SymbolReference<ResolvedConstructorDeclaration> solve(ObjectCreationExpr objectCreationExpr, boolean solveLambdas) {\n        List<ResolvedType> argumentTypes = new LinkedList<>();\n        List<LambdaArgumentTypePlaceholder> placeholders = new LinkedList<>();\n\n        solveArguments(objectCreationExpr, objectCreationExpr.getArguments(), solveLambdas, argumentTypes, placeholders);\n\n        ResolvedReferenceTypeDeclaration typeDecl = null;\n        if (objectCreationExpr.getAnonymousClassBody().isPresent()) {\n            typeDecl = new JavaParserAnonymousClassDeclaration(objectCreationExpr, typeSolver);\n        } else {\n            ResolvedType classDecl = JavaParserFacade.get(typeSolver).convert(objectCreationExpr.getType(), objectCreationExpr);\n            if (classDecl.isReferenceType() && classDecl.asReferenceType().getTypeDeclaration().isPresent()) {\n                typeDecl = classDecl.asReferenceType().getTypeDeclaration().get();\n            }\n        }\n        if (typeDecl == null) {\n            return unsolved();\n        }\n        SymbolReference<ResolvedConstructorDeclaration> res = ConstructorResolutionLogic.findMostApplicable(typeDecl.getConstructors(), argumentTypes, typeSolver);\n        for (LambdaArgumentTypePlaceholder placeholder : placeholders) {\n            placeholder.setMethod(res);\n        }\n        return res;\n    }\n\n    private void solveArguments(Node node, NodeList<Expression> args, boolean solveLambdas, List<ResolvedType> argumentTypes,\n                                List<LambdaArgumentTypePlaceholder> placeholders) {\n        int i = 0;\n        for (Expression parameterValue : args) {\n            if (parameterValue.isLambdaExpr() || parameterValue.isMethodReferenceExpr()) {\n                LambdaArgumentTypePlaceholder placeholder = new LambdaArgumentTypePlaceholder(i);\n                argumentTypes.add(placeholder);\n                placeholders.add(placeholder);\n            } else {\n                try {\n                    argumentTypes.add(JavaParserFacade.get(typeSolver).getType(parameterValue, solveLambdas));\n                } catch (Exception e) {\n                    throw failureHandler.handle(e, String.format(\"Unable to calculate the type of a parameter of a method call. Method call: %s, Parameter: %s\",\n                            node, parameterValue));\n                }\n            }\n            i++;\n        }\n    }\n\n    /**\n     * Given a method call find out to which method declaration it corresponds.\n     */\n    public SymbolReference<ResolvedMethodDeclaration> solve(MethodCallExpr methodCallExpr, boolean solveLambdas) {\n        List<ResolvedType> argumentTypes = new LinkedList<>();\n        List<LambdaArgumentTypePlaceholder> placeholders = new LinkedList<>();\n\n        solveArguments(methodCallExpr, methodCallExpr.getArguments(), solveLambdas, argumentTypes, placeholders);\n\n        SymbolReference<ResolvedMethodDeclaration> res = JavaParserFactory.getContext(methodCallExpr, typeSolver).solveMethod(methodCallExpr.getName().getId(), argumentTypes, false);\n        for (LambdaArgumentTypePlaceholder placeholder : placeholders) {\n            placeholder.setMethod(res);\n        }\n        return res;\n    }\n\n    /**\n     * Given a method reference find out to which method declaration it corresponds.\n     */\n    public SymbolReference<ResolvedMethodDeclaration> solve(MethodReferenceExpr methodReferenceExpr, boolean solveLambdas) {\n        // pass empty argument list to be populated\n        List<ResolvedType> argumentTypes = new LinkedList<>();\n        return JavaParserFactory.getContext(methodReferenceExpr, typeSolver).solveMethod(methodReferenceExpr.getIdentifier(), argumentTypes, false);\n    }\n\n    public SymbolReference<ResolvedAnnotationDeclaration> solve(AnnotationExpr annotationExpr) {\n        Context context = JavaParserFactory.getContext(annotationExpr, typeSolver);\n        SymbolReference<ResolvedTypeDeclaration> typeDeclarationSymbolReference = context.solveType(annotationExpr.getNameAsString());\n        if (typeDeclarationSymbolReference.isSolved()) {\n            ResolvedAnnotationDeclaration annotationDeclaration = (ResolvedAnnotationDeclaration) typeDeclarationSymbolReference.getCorrespondingDeclaration();\n            return solved(annotationDeclaration);\n        } else {\n            return unsolved();\n        }\n    }\n\n    public SymbolReference<ResolvedValueDeclaration> solve(FieldAccessExpr fieldAccessExpr) {\n        return ((FieldAccessContext) JavaParserFactory.getContext(fieldAccessExpr, typeSolver)).solveField(fieldAccessExpr.getName().getId());\n    }\n\n    /**\n     * Get the type associated with the node.\n     * <p>\n     * This method was originally intended to get the type of a value: any value has a type.\n     * <p>\n     * For example:\n     * <pre>\n     * int foo(int a) {\n     *     return a; // when getType is invoked on \"a\" it returns the type \"int\"\n     * }\n     * </pre>\n     * <p>\n     * Now, users started using also of names of types itself, which do not have a type.\n     * <p>\n     * For example:\n     * <pre>\n     * class A {\n     *     int foo(int a) {\n     *         return A.someStaticField; // when getType is invoked on \"A\", which represents a class, it returns\n     *             // the type \"A\" itself while it used to throw UnsolvedSymbolException\n     * }\n     * </pre>\n     * <p>\n     * To accommodate this usage and avoid confusion this method return\n     * the type itself when used on the name of type.\n     */\n    public ResolvedType getType(Node node) {\n        try {\n            return getType(node, true);\n        } catch (UnsolvedSymbolException e) {\n            if (node instanceof NameExpr) {\n                NameExpr nameExpr = (NameExpr) node;\n                SymbolReference<ResolvedTypeDeclaration> typeDeclaration = JavaParserFactory.getContext(node, typeSolver)\n                        .solveType(nameExpr.getNameAsString());\n                if (typeDeclaration.isSolved() && typeDeclaration.getCorrespondingDeclaration() instanceof ResolvedReferenceTypeDeclaration) {\n                    ResolvedReferenceTypeDeclaration resolvedReferenceTypeDeclaration = (ResolvedReferenceTypeDeclaration) typeDeclaration.getCorrespondingDeclaration();\n                    return ReferenceTypeImpl.undeterminedParameters(resolvedReferenceTypeDeclaration);\n                }\n            }\n            throw failureHandler.handle(e);\n        }\n    }\n\n    public ResolvedType getType(Node node, boolean solveLambdas) {\n        if (solveLambdas) {\n            if (!node.containsData(TYPE_WITH_LAMBDAS_RESOLVED)) {\n                ResolvedType res = getTypeConcrete(node, solveLambdas);\n\n                node.setData(TYPE_WITH_LAMBDAS_RESOLVED, res);\n\n                boolean secondPassNecessary = false;\n                if (node instanceof MethodCallExpr) {\n                    MethodCallExpr methodCallExpr = (MethodCallExpr) node;\n                    for (Node arg : methodCallExpr.getArguments()) {\n                        if (!arg.containsData(TYPE_WITH_LAMBDAS_RESOLVED)) {\n                            getType(arg, true);\n                            secondPassNecessary = true;\n                        }\n                    }\n                }\n                if (secondPassNecessary) {\n                    node.removeData(TYPE_WITH_LAMBDAS_RESOLVED);\n                    ResolvedType type = getType(node, true);\n                    node.setData(TYPE_WITH_LAMBDAS_RESOLVED, type);\n\n                }\n                Log.trace(\"getType on %s  -> %s\", () -> node, () -> res);\n            }\n            return node.getData(TYPE_WITH_LAMBDAS_RESOLVED);\n        } else {\n            Optional<ResolvedType> res = find(TYPE_WITH_LAMBDAS_RESOLVED, node);\n            if (res.isPresent()) {\n                return res.get();\n            }\n            res = find(TYPE_WITHOUT_LAMBDAS_RESOLVED, node);\n            if (!res.isPresent()) {\n                ResolvedType resType = getTypeConcrete(node, solveLambdas);\n                node.setData(TYPE_WITHOUT_LAMBDAS_RESOLVED, resType);\n                Optional<ResolvedType> finalRes = res;\n                Log.trace(\"getType on %s (no solveLambdas) -> %s\", () -> node, () -> finalRes);\n                return resType;\n            }\n            return res.get();\n        }\n    }\n\n    private Optional<ResolvedType> find(DataKey<ResolvedType> dataKey, Node node) {\n        if (node.containsData(dataKey)) {\n            return Optional.of(node.getData(dataKey));\n        }\n        return Optional.empty();\n    }\n\n    protected MethodUsage toMethodUsage(MethodReferenceExpr methodReferenceExpr, List<ResolvedType> paramTypes) {\n        Expression scope = methodReferenceExpr.getScope();\n        ResolvedType typeOfScope = getType(methodReferenceExpr.getScope());\n        if (!typeOfScope.isReferenceType()) {\n            throw new UnsupportedOperationException(typeOfScope.getClass().getCanonicalName());\n        }\n\n        Optional<MethodUsage> result;\n        Set<MethodUsage> allMethods = typeOfScope.asReferenceType().getTypeDeclaration()\n                .orElseThrow(() -> new RuntimeException(\"TypeDeclaration unexpectedly empty.\"))\n                .getAllMethods();\n\n        if (scope.isTypeExpr()) {\n            // static methods should match all params\n            List<MethodUsage> staticMethodUsages = allMethods.stream()\n                    .filter(it -> it.getDeclaration().isStatic())\n                    .collect(Collectors.toList());\n\n            result = MethodResolutionLogic.findMostApplicableUsage(staticMethodUsages, methodReferenceExpr.getIdentifier(), paramTypes, typeSolver);\n\n            if (!paramTypes.isEmpty()) {\n                // instance methods are called on the first param and should match all other params\n                List<MethodUsage> instanceMethodUsages = allMethods.stream()\n                        .filter(it -> !it.getDeclaration().isStatic())\n                        .collect(Collectors.toList());\n\n                List<ResolvedType> instanceMethodParamTypes = new ArrayList<>(paramTypes);\n                instanceMethodParamTypes.remove(0); // remove the first one\n\n                Optional<MethodUsage> instanceResult = MethodResolutionLogic.findMostApplicableUsage(\n                        instanceMethodUsages, methodReferenceExpr.getIdentifier(), instanceMethodParamTypes, typeSolver);\n                if (result.isPresent() && instanceResult.isPresent()) {\n                    throw new MethodAmbiguityException(\"Ambiguous method call: cannot find a most applicable method for \" + methodReferenceExpr.getIdentifier());\n                }\n\n                if (instanceResult.isPresent()) {\n                    result = instanceResult;\n                }\n            }\n        } else {\n            result = MethodResolutionLogic.findMostApplicableUsage(new ArrayList<>(allMethods), methodReferenceExpr.getIdentifier(), paramTypes, typeSolver);\n\n            if (result.isPresent() && result.get().getDeclaration().isStatic()) {\n                throw new RuntimeException(\"Invalid static method reference \" + methodReferenceExpr.getIdentifier());\n            }\n        }\n\n        if (!result.isPresent()) {\n            throw new UnsupportedOperationException();\n        }\n\n        return result.get();\n    }\n\n    protected ResolvedType getBinaryTypeConcrete(Node left, Node right, boolean solveLambdas, BinaryExpr.Operator operator) {\n        ResolvedType leftType = getTypeConcrete(left, solveLambdas);\n        ResolvedType rightType = getTypeConcrete(right, solveLambdas);\n\n        // JLS 15.18.1. String Concatenation Operator +\n        // If only one operand expression is of type String, then string conversion (\u00a75.1.11) is performed on the other\n        // operand to produce a string at run time.\n        //\n        // The result of string concatenation is a reference to a String object that is the concatenation of the two\n        // operand strings. The characters of the left-hand operand precede the characters of the right-hand operand in\n        // the newly created string.\n\n        if (operator == BinaryExpr.Operator.PLUS) {\n            boolean isLeftString = leftType.isReferenceType() && leftType.asReferenceType()\n                    .getQualifiedName().equals(JAVA_LANG_STRING);\n            boolean isRightString = rightType.isReferenceType() && rightType.asReferenceType()\n                    .getQualifiedName().equals(JAVA_LANG_STRING);\n            if (isLeftString || isRightString) {\n                return isLeftString ? leftType : rightType;\n            }\n        }\n\n        // JLS 5.6.2. Binary Numeric Promotion\n        //\n        // Widening primitive conversion (\u00a75.1.2) is applied to convert either or both operands as specified by the\n        // following rules:\n        //\n        // * If either operand is of type double, the other is converted to double.\n        // * Otherwise, if either operand is of type float, the other is converted to float.\n        // * Otherwise, if either operand is of type long, the other is converted to long.\n        // * Otherwise, both operands are converted to type int.\n\n        boolean isLeftNumeric = leftType.isPrimitive() && leftType.asPrimitive().isNumeric();\n        boolean isRightNumeric = rightType.isPrimitive() && rightType.asPrimitive().isNumeric();\n\n        if (isLeftNumeric && isRightNumeric) {\n            return leftType.asPrimitive().bnp(rightType.asPrimitive());\n        }\n\n        if (rightType.isAssignableBy(leftType)) {\n            return rightType;\n        }\n        return leftType;\n    }\n\n\n    /**\n     * Should return more like a TypeApplication: a TypeDeclaration and possible typeParametersValues or array\n     * modifiers.\n     */\n    private ResolvedType getTypeConcrete(Node node, boolean solveLambdas) {\n        if (node == null) throw new IllegalArgumentException();\n        return node.accept(typeExtractor, solveLambdas);\n    }\n\n    /**\n     * Where a node has an interface/class/enum declaration as its ancestor, return the nearest one.\n     * <p>\n     * NOTE: See {@link #findContainingTypeDeclOrObjectCreationExpr} if wanting to include anonymous inner classes.\n     * <p>\n     * For example, these all return X:\n     * {@code public interface X { ... node here ... }}\n     * {@code public class X { ... node here ... }}\n     * {@code public enum X { ... node here ... }}\n     *\n     * @param node The Node whose ancestors will be traversed,\n     * @return The first class/interface/enum declaration in the Node's ancestry.\n     */\n    protected TypeDeclaration<?> findContainingTypeDecl(Node node) {\n        Node parent = node;\n        while (true) {\n            parent = demandParentNode(parent);\n            if (parent instanceof TypeDeclaration) {\n                return (TypeDeclaration<?>) parent;\n            }\n        }\n    }\n\n    /**\n     * Where a node has an interface/class/enum declaration -- or an object creation expression (anonymous inner class)\n     * -- as its ancestor, return the nearest one.\n     * <p>\n     * NOTE: See {@link #findContainingTypeDecl} if wanting to not include anonymous inner classes.\n     * <p>\n     * For example, these all return X:\n     * <ul>\n     *     <li>{@code public interface X { ... node here ... }}</li>\n     *     <li>{@code public class X { ... node here ... }}</li>\n     *     <li>{@code public enum X { ... node here ... }}</li>\n     *     <li><pre>{@code\n     *     new ActionListener() {\n     *          ... node here ...\n     *          public void actionPerformed(ActionEvent e) {\n     *               ... or node here ...\n     *          }\n     *     }\n     *     }</pre></li>\n     * </ul>\n     * <p>\n     *\n     * @param node The Node whose ancestors will be traversed,\n     * @return The first class/interface/enum declaration -- or object creation expression (anonymous inner class) -- in\n     * the Node's ancestry.\n     */\n    protected Node findContainingTypeDeclOrObjectCreationExpr(Node node) {\n        Node parent = node;\n        boolean detachFlag = false;\n        while (true) {\n            parent = demandParentNode(parent);\n            if (parent instanceof BodyDeclaration) {\n                if (parent instanceof TypeDeclaration) {\n                    return parent;\n                } else {\n                    detachFlag = true;\n                }\n            } else if (parent instanceof ObjectCreationExpr) {\n                if (detachFlag) {\n                    return parent;\n                }\n            }\n        }\n    }\n\n    /**\n     * Where a node has an interface/class/enum declaration -- or an object creation expression in an inner class\n     * references an outer class -- as its ancestor, return the declaration corresponding to the class name specified.\n     */\n    protected Node findContainingTypeDeclOrObjectCreationExpr(Node node, String className) {\n        Node parent = node;\n        boolean detachFlag = false;\n        while (true) {\n            parent = demandParentNode(parent);\n            if (parent instanceof BodyDeclaration) {\n                if (parent instanceof TypeDeclaration && ((TypeDeclaration<?>) parent).getFullyQualifiedName().get().endsWith(className)) {\n                    return parent;\n                } else {\n                    detachFlag = true;\n                }\n            } else if (parent instanceof ObjectCreationExpr && ((ObjectCreationExpr) parent).getType().getName().asString().equals(className)) {\n                if (detachFlag) {\n                    return parent;\n                }\n            }\n        }\n    }\n\n    /**\n     * Convert a {@link Type} into the corresponding {@link ResolvedType}.\n     *\n     * @param type      The type to be converted.\n     * @param context   The current context.\n     *\n     * @return The type resolved.\n     */\n    protected ResolvedType convertToUsage(Type type, Context context) {\n        if (context == null) {\n            throw new NullPointerException(\"Context should not be null\");\n        }\n        return type.convertToUsage(context);\n    }\n\n    /**\n     * Convert a {@link Type} into the corresponding {@link ResolvedType}.\n     *\n     * @param type      The type to be converted.\n     * @param context   The current context.\n     *\n     * @return The type resolved.\n     */\n    public ResolvedType convertToUsage(Type type, Node context) {\n        return convertToUsage(type, JavaParserFactory.getContext(context, typeSolver));\n    }\n\n    /**\n     * Convert a {@link Type} into the corresponding {@link ResolvedType}.\n     *\n     * @param type The type to be converted.\n     *\n     * @return The type resolved.\n     */\n    public ResolvedType convertToUsage(Type type) {\n        return convertToUsage(type, type);\n    }\n\n    private Optional<ForEachStmt> forEachStmtWithVariableDeclarator(\n            VariableDeclarator variableDeclarator) {\n        Optional<Node> node = variableDeclarator.getParentNode();\n        if (!node.isPresent() || !(node.get() instanceof VariableDeclarationExpr)) {\n            return Optional.empty();\n        }\n        node = node.get().getParentNode();\n        if (!node.isPresent() || !(node.get() instanceof ForEachStmt)) {\n            return Optional.empty();\n        } else {\n            return Optional.of((ForEachStmt)node.get());\n        }\n    }\n\n    public ResolvedType convert(Type type, Node node) {\n        return convert(type, JavaParserFactory.getContext(node, typeSolver));\n    }\n\n    public ResolvedType convert(Type type, Context context) {\n        return convertToUsage(type, context);\n    }\n\n    public MethodUsage solveMethodAsUsage(MethodCallExpr call) {\n        List<ResolvedType> params = new ArrayList<>();\n        if (call.getArguments() != null) {\n            for (Expression param : call.getArguments()) {\n                //getTypeConcrete(Node node, boolean solveLambdas)\n                try {\n                    params.add(getType(param, false));\n                } catch (Exception e) {\n                    throw failureHandler.handle(e, String.format(\"Error calculating the type of parameter %s of method call %s\", param, call));\n                }\n                //params.add(getTypeConcrete(param, false));\n            }\n        }\n        Context context = JavaParserFactory.getContext(call, typeSolver);\n        Optional<MethodUsage> methodUsage = context.solveMethodAsUsage(call.getName().getId(), params);\n        if (!methodUsage.isPresent()) {\n            throw new RuntimeException(\"Method '\" + call.getName() + \"' cannot be resolved in context \"\n                    + call + \" (line: \" + call.getRange().map(r -> \"\" + r.begin.line).orElse(\"??\") + \") \" + context + \". Parameter types: \" + params);\n        }\n        return methodUsage.get();\n    }\n\n    public ResolvedReferenceTypeDeclaration getTypeDeclaration(Node node) {\n        if (node instanceof TypeDeclaration) {\n            return getTypeDeclaration((TypeDeclaration) node);\n        }\n        if (node instanceof ObjectCreationExpr) {\n            return new JavaParserAnonymousClassDeclaration((ObjectCreationExpr) node, typeSolver);\n        }\n        throw new IllegalArgumentException();\n    }\n\n    public ResolvedReferenceTypeDeclaration getTypeDeclaration(ClassOrInterfaceDeclaration classOrInterfaceDeclaration) {\n        return JavaParserFactory.toTypeDeclaration(classOrInterfaceDeclaration, typeSolver);\n    }\n\n    /**\n     * \"this\" inserted in the given point, which type would have?\n     */\n    public ResolvedType getTypeOfThisIn(Node node) {\n        // TODO consider static methods\n        if (node instanceof ClassOrInterfaceDeclaration) {\n            return new ReferenceTypeImpl(getTypeDeclaration((ClassOrInterfaceDeclaration) node));\n        }\n        if (node instanceof EnumDeclaration) {\n            JavaParserEnumDeclaration enumDeclaration = new JavaParserEnumDeclaration((EnumDeclaration) node, typeSolver);\n            return new ReferenceTypeImpl(enumDeclaration);\n        }\n        if (node instanceof ObjectCreationExpr && ((ObjectCreationExpr) node).getAnonymousClassBody().isPresent()) {\n            JavaParserAnonymousClassDeclaration anonymousDeclaration = new JavaParserAnonymousClassDeclaration((ObjectCreationExpr) node, typeSolver);\n            return new ReferenceTypeImpl(anonymousDeclaration);\n        }\n        return getTypeOfThisIn(demandParentNode(node));\n    }\n\n    public ResolvedReferenceTypeDeclaration getTypeDeclaration(TypeDeclaration<?> typeDeclaration) {\n        return JavaParserFactory.toTypeDeclaration(typeDeclaration, typeSolver);\n    }\n\n    /**\n     * Convert a {@link Class} into the corresponding {@link ResolvedType}.\n     *\n     * @param clazz The class to be converted.\n     *\n     * @return The class resolved.\n     */\n    public ResolvedType classToResolvedType(Class<?> clazz) {\n        if (clazz.isPrimitive()) {\n            return ResolvedPrimitiveType.byName(clazz.getName());\n        }\n\n        ResolvedReferenceTypeDeclaration declaration;\n        if (clazz.isAnnotation()) {\n            declaration = new ReflectionAnnotationDeclaration(clazz, typeSolver);\n        } else if (clazz.isEnum()) {\n            declaration = new ReflectionEnumDeclaration(clazz, typeSolver);\n        } else if (clazz.isInterface()) {\n            declaration = new ReflectionInterfaceDeclaration(clazz, typeSolver);\n        } else {\n            declaration = new ReflectionClassDeclaration(clazz, typeSolver);\n        }\n        return new ReferenceTypeImpl(declaration);\n    }\n\n}\n",
        "diffSourceCodeSet": [
            "this.failureHandler = new FailureHandler();\n    }\n\n    public TypeSolver getTypeSolver() {"
        ],
        "invokedMethodSet": [
            "methodSignature: com.github.javaparser.ast.type.Type#isVoidType\n methodBody: public boolean isVoidType() {\nreturn false;\n}",
            "methodSignature: com.github.javaparser.ast.type.Type#isPrimitiveType\n methodBody: public boolean isPrimitiveType() {\nreturn false;\n}",
            "methodSignature: com.github.javaparser.ast.type.PrimitiveType#asPrimitiveType\n methodBody: public PrimitiveType asPrimitiveType() {\nreturn this;\n}",
            "methodSignature: com.github.javaparser.ast.type.ArrayType#asArrayType\n methodBody: public ArrayType asArrayType() {\nreturn this;\n}",
            "methodSignature: com.github.javaparser.ast.type.Type#isUnionType\n methodBody: public boolean isUnionType() {\nreturn false;\n}",
            "methodSignature: com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade#convertArrayTypeToUsage\n methodBody: protected ResolvedType convertArrayTypeToUsage(ArrayType arrayType, Context context) {\nreturn new ResolvedArrayType(convertToUsage(arrayType.getComponentType(),context));\n}",
            "methodSignature: com.github.javaparser.ast.type.Type#asClassOrInterfaceType\n methodBody: public ClassOrInterfaceType asClassOrInterfaceType() {\nthrow new IllegalStateException(f(\"%s is not ClassOrInterfaceType, it is %s\",this,this.getClass().getSimpleName()));\n}",
            "methodSignature: com.github.javaparser.ast.type.UnionType#isUnionType\n methodBody: public boolean isUnionType() {\nreturn true;\n}",
            "methodSignature: com.github.javaparser.ast.type.ClassOrInterfaceType#asClassOrInterfaceType\n methodBody: public ClassOrInterfaceType asClassOrInterfaceType() {\nreturn this;\n}",
            "methodSignature: com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade#convertVarTypeToUsage\n methodBody: protected ResolvedType convertVarTypeToUsage(VarType varType, Context context) {\nNode parent=varType.getParentNode().get();\nif(!(parent instanceof VariableDeclarator)){throw new IllegalStateException(\"Trying to resolve a `var` which is not in a variable declaration.\");\n}final VariableDeclarator variableDeclarator=(VariableDeclarator)parent;\nOptional<Expression> initializer=variableDeclarator.getInitializer();\nif(!initializer.isPresent()){Optional<ForEachStmt> forEachStmt=forEachStmtWithVariableDeclarator(variableDeclarator);\nif(forEachStmt.isPresent()){Expression iterable=forEachStmt.get().getIterable();\nResolvedType iterType=iterable.calculateResolvedType();\nif(iterType instanceof ResolvedArrayType){return ((ResolvedArrayType)iterType).getComponentType();\n}if(iterType.isReferenceType()){List<ResolvedType> parametersType=iterType.asReferenceType().typeParametersMap().getTypes();\nif(parametersType.isEmpty()){Optional<ResolvedTypeDeclaration> oObjectDeclaration=context.solveType(JAVA_LANG_OBJECT).getDeclaration();\nreturn oObjectDeclaration.map(decl -> ReferenceTypeImpl.undeterminedParameters(decl.asReferenceType())).orElseThrow(() -> new UnsupportedOperationException());\n}return parametersType.get(0);\n}}}return initializer.map(Expression::calculateResolvedType).orElseThrow(() -> new IllegalStateException(\"Cannot resolve `var` which has no initializer.\"));\n}",
            "methodSignature: com.github.javaparser.ast.type.ArrayType#isArrayType\n methodBody: public boolean isArrayType() {\nreturn true;\n}",
            "methodSignature: com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade#convertWildcardTypeToUsage\n methodBody: protected ResolvedType convertWildcardTypeToUsage(WildcardType wildcardType, Context context) {\nif(wildcardType.getExtendedType().isPresent() && !wildcardType.getSuperType().isPresent()){return ResolvedWildcard.extendsBound(convertToUsage(wildcardType.getExtendedType().get(),context));\n}if(!wildcardType.getExtendedType().isPresent() && wildcardType.getSuperType().isPresent()){return ResolvedWildcard.superBound(convertToUsage(wildcardType.getSuperType().get(),context));\n}if(!wildcardType.getExtendedType().isPresent() && !wildcardType.getSuperType().isPresent()){return ResolvedWildcard.UNBOUNDED;\n}{throw new UnsupportedOperationException(wildcardType.toString());\n}}",
            "methodSignature: com.github.javaparser.ast.type.Type#asWildcardType\n methodBody: public WildcardType asWildcardType() {\nthrow new IllegalStateException(f(\"%s is not WildcardType, it is %s\",this,this.getClass().getSimpleName()));\n}",
            "methodSignature: com.github.javaparser.ast.type.Type#asVarType\n methodBody: public VarType asVarType() {\nthrow new IllegalStateException(f(\"%s is not VarType, it is %s\",this,this.getClass().getSimpleName()));\n}",
            "methodSignature: com.github.javaparser.ast.type.Type#asUnionType\n methodBody: public UnionType asUnionType() {\nthrow new IllegalStateException(f(\"%s is not UnionType, it is %s\",this,this.getClass().getSimpleName()));\n}",
            "methodSignature: com.github.javaparser.ast.type.Type#isVarType\n methodBody: public boolean isVarType() {\nreturn false;\n}",
            "methodSignature: com.github.javaparser.ast.type.UnknownType#isUnknownType\n methodBody: public boolean isUnknownType() {\nreturn true;\n}",
            "methodSignature: com.github.javaparser.ast.type.Type#asArrayType\n methodBody: public ArrayType asArrayType() {\nthrow new IllegalStateException(f(\"%s is not ArrayType, it is %s\",this,this.getClass().getSimpleName()));\n}",
            "methodSignature: com.github.javaparser.ast.type.VarType#asVarType\n methodBody: public VarType asVarType() {\nreturn this;\n}",
            "methodSignature: com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade#getType\n methodBody: public ResolvedType getType(Node node, boolean solveLambdas) {\nif(solveLambdas){if(!node.containsData(TYPE_WITH_LAMBDAS_RESOLVED)){ResolvedType res=getTypeConcrete(node,solveLambdas);\nnode.setData(TYPE_WITH_LAMBDAS_RESOLVED,res);\nboolean secondPassNecessary=false;\nif(node instanceof MethodCallExpr){MethodCallExpr methodCallExpr=(MethodCallExpr)node;\nfor(Node arg: methodCallExpr.getArguments()){if(!arg.containsData(TYPE_WITH_LAMBDAS_RESOLVED)){getType(arg,true);\nsecondPassNecessary=true;\n}}}if(secondPassNecessary){node.removeData(TYPE_WITH_LAMBDAS_RESOLVED);\nResolvedType type=getType(node,true);\nnode.setData(TYPE_WITH_LAMBDAS_RESOLVED,type);\n}Log.trace(\"getType on %s  -> %s\",() -> node,() -> res);\n}return node.getData(TYPE_WITH_LAMBDAS_RESOLVED);\n}{Optional<ResolvedType> res=find(TYPE_WITH_LAMBDAS_RESOLVED,node);\nif(res.isPresent()){return res.get();\n}res=find(TYPE_WITHOUT_LAMBDAS_RESOLVED,node);\nif(!res.isPresent()){ResolvedType resType=getTypeConcrete(node,solveLambdas);\nnode.setData(TYPE_WITHOUT_LAMBDAS_RESOLVED,resType);\nOptional<ResolvedType> finalRes=res;\nLog.trace(\"getType on %s (no solveLambdas) -> %s\",() -> node,() -> finalRes);\nreturn resType;\n}return res.get();\n}}",
            "methodSignature: com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade#convertClassOrInterfaceTypeToUsage\n methodBody: protected ResolvedType convertClassOrInterfaceTypeToUsage(ClassOrInterfaceType classOrInterfaceType, Context context) {\nString name=classOrInterfaceType.getNameWithScope();\nSymbolReference<ResolvedTypeDeclaration> ref=context.solveType(name);\nif(!ref.isSolved()){throw new UnsolvedSymbolException(name);\n}ResolvedTypeDeclaration typeDeclaration=ref.getCorrespondingDeclaration();\nList<ResolvedType> typeParameters=Collections.emptyList();\nif(classOrInterfaceType.getTypeArguments().isPresent()){typeParameters=classOrInterfaceType.getTypeArguments().get().stream().map((pt) -> convertToUsage(pt,context)).collect(Collectors.toList());\n}if(typeDeclaration.isTypeParameter()){return new ResolvedTypeVariable(typeDeclaration.asTypeParameter());\n}{return new ReferenceTypeImpl((ResolvedReferenceTypeDeclaration)typeDeclaration,typeParameters);\n}}",
            "methodSignature: com.github.javaparser.ast.type.Type#asPrimitiveType\n methodBody: public PrimitiveType asPrimitiveType() {\nthrow new IllegalStateException(f(\"%s is not PrimitiveType, it is %s\",this,this.getClass().getSimpleName()));\n}",
            "methodSignature: com.github.javaparser.ast.type.VarType#isVarType\n methodBody: public boolean isVarType() {\nreturn true;\n}",
            "methodSignature: com.github.javaparser.ast.type.VoidType#isVoidType\n methodBody: public boolean isVoidType() {\nreturn true;\n}",
            "methodSignature: com.github.javaparser.ast.type.Type#isWildcardType\n methodBody: public boolean isWildcardType() {\nreturn false;\n}",
            "methodSignature: com.github.javaparser.ast.type.Type#isUnknownType\n methodBody: public boolean isUnknownType() {\nreturn false;\n}",
            "methodSignature: com.github.javaparser.ast.type.Type#isClassOrInterfaceType\n methodBody: public boolean isClassOrInterfaceType() {\nreturn false;\n}",
            "methodSignature: com.github.javaparser.ast.type.PrimitiveType#getType\n methodBody: public Primitive getType() {\nreturn type;\n}",
            "methodSignature: com.github.javaparser.ast.type.WildcardType#isWildcardType\n methodBody: public boolean isWildcardType() {\nreturn true;\n}",
            "methodSignature: com.github.javaparser.ast.type.WildcardType#asWildcardType\n methodBody: public WildcardType asWildcardType() {\nreturn this;\n}",
            "methodSignature: com.github.javaparser.ast.type.Type#isArrayType\n methodBody: public boolean isArrayType() {\nreturn false;\n}",
            "methodSignature: com.github.javaparser.ast.type.ClassOrInterfaceType#isClassOrInterfaceType\n methodBody: public boolean isClassOrInterfaceType() {\nreturn true;\n}",
            "methodSignature: com.github.javaparser.ast.type.PrimitiveType#isPrimitiveType\n methodBody: public boolean isPrimitiveType() {\nreturn true;\n}",
            "methodSignature: com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade#convertUnionTypeToUsage\n methodBody: protected ResolvedType convertUnionTypeToUsage(UnionType unionType, Context context) {\nList<ResolvedType> resolvedElements=unionType.getElements().stream().map(el -> convertToUsage(el,context)).collect(Collectors.toList());\nreturn new ResolvedUnionType(resolvedElements);\n}",
            "methodSignature: com.github.javaparser.ast.type.UnionType#asUnionType\n methodBody: public UnionType asUnionType() {\nreturn this;\n}"
        ],
        "sourceCodeAfterRefactoring": "/**\n     * Convert a {@link Type} into the corresponding {@link ResolvedType}.\n     *\n     * @param type      The type to be converted.\n     * @param context   The current context.\n     *\n     * @return The type resolved.\n     */\n    protected ResolvedType convertToUsage(Type type, Context context) {\n        if (context == null) {\n            throw new NullPointerException(\"Context should not be null\");\n        }\n        return type.convertToUsage(context);\n    }\nthis.failureHandler = new FailureHandler();\n    }\n\n    public TypeSolver getTypeSolver() {",
        "diffSourceCode": "-  132:         this.symbolSolver = new SymbolSolver(typeSolver);\n-  133:         this.typeExtractor = new TypeExtractor(typeSolver, this);\n-  134:         this.failureHandler = new FailureHandler();\n-  135:     }\n-  616:     }\n-  617: \n-  618:     public ResolvedType convertToUsageVariableType(VariableDeclarator var) {\n-  619:         return get(typeSolver).convertToUsage(var.getType(), var);\n-  620:     }\n-  621: \n-  622:     /**\n-  623:      * Convert a {@link Type} into the corresponding {@link ResolvedType}.\n-  624:      *\n-  625:      * @param type      The type to be converted.\n-  626:      * @param context   The current context.\n-  627:      *\n-  628:      * @return The type resolved.\n-  629:      */\n-  630:     protected ResolvedType convertToUsage(Type type, Context context) {\n-  631:         if (context == null) {\n-  632:             throw new NullPointerException(\"Context should not be null\");\n-  633:         }\n-  634:         if (type.isUnknownType()) {\n-  635:             throw new IllegalArgumentException(\"Inferred lambda parameter type\");\n-  636:         } else if (type.isClassOrInterfaceType()) {\n-  637:             return convertClassOrInterfaceTypeToUsage(type.asClassOrInterfaceType(), context);\n-  638:         } else if (type.isPrimitiveType()) {\n-  639:             return ResolvedPrimitiveType.byName(type.asPrimitiveType().getType().name());\n-  640:         } else if (type.isWildcardType()) {\n-  641:             return convertWildcardTypeToUsage(type.asWildcardType(), context);\n-  642:         } else if (type.isVoidType()) {\n-  643:             return ResolvedVoidType.INSTANCE;\n-  644:         } else if (type.isArrayType()) {\n-  645:             return convertArrayTypeToUsage(type.asArrayType(), context);\n-  646:         } else if (type.isUnionType()) {\n-  647:             return convertUnionTypeToUsage(type.asUnionType(), context);\n-  648:         } else if (type.isVarType()) {\n-  649:             return convertVarTypeToUsage(type.asVarType(), context);\n-  650:         } else {\n-  651:             throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n-  652:         }\n-  653:     }\n+  132:         this.failureHandler = new FailureHandler();\n+  133:     }\n+  134: \n+  135:     public TypeSolver getTypeSolver() {\n+  616:     /**\n+  617:      * Convert a {@link Type} into the corresponding {@link ResolvedType}.\n+  618:      *\n+  619:      * @param type      The type to be converted.\n+  620:      * @param context   The current context.\n+  621:      *\n+  622:      * @return The type resolved.\n+  623:      */\n+  624:     protected ResolvedType convertToUsage(Type type, Context context) {\n+  625:         if (context == null) {\n+  626:             throw new NullPointerException(\"Context should not be null\");\n+  627:         }\n+  628:         return type.convertToUsage(context);\n+  629:     }\n+  630: \n+  631:     /**\n+  632:      * Convert a {@link Type} into the corresponding {@link ResolvedType}.\n+  633:      *\n+  634:      * @param type      The type to be converted.\n+  635:      * @param context   The current context.\n+  636:      *\n+  637:      * @return The type resolved.\n+  638:      */\n+  639:     public ResolvedType convertToUsage(Type type, Node context) {\n+  640:         return convertToUsage(type, JavaParserFactory.getContext(context, typeSolver));\n+  641:     }\n+  642: \n+  643:     /**\n+  644:      * Convert a {@link Type} into the corresponding {@link ResolvedType}.\n+  645:      *\n+  646:      * @param type The type to be converted.\n+  647:      *\n+  648:      * @return The type resolved.\n+  649:      */\n+  650:     public ResolvedType convertToUsage(Type type) {\n+  651:         return convertToUsage(type, type);\n+  652:     }\n+  653: \n",
        "uniqueId": "86f41353d40bfd3ef0669b863926626b6c4949bf_622_653_132_135_616_629",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 0,
                "covered": 5
            },
            "LINE": {
                "missed": 0,
                "covered": 1
            },
            "COMPLEXITY": {
                "missed": 0,
                "covered": 1
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 17
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tpublic solveTypeInParentContext(name String, typeArguments List<ResolvedType>) : SymbolReference<ResolvedTypeDeclaration> extracted from public solveTypeInParentContext(name String) : SymbolReference<ResolvedTypeDeclaration> in class com.github.javaparser.symbolsolver.core.resolution.Context",
        "diffLocations": [
            {
                "filePath": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/core/resolution/Context.java",
                "startLine": 91,
                "endLine": 99,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/core/resolution/Context.java",
                "startLine": 119,
                "endLine": 133,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/core/resolution/Context.java",
                "startLine": 135,
                "endLine": 151,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "default SymbolReference<ResolvedTypeDeclaration> solveTypeInParentContext(String name) {\n        Optional<Context> optionalParentContext = getParent();\n        if (!optionalParentContext.isPresent()) {\n            return SymbolReference.unsolved();\n        }\n\n        // Delegate solving to the parent context.\n        return optionalParentContext.get().solveType(name);\n    }",
        "filePathBefore": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/core/resolution/Context.java",
        "isPureRefactoring": true,
        "commitId": "4549a58efd47cbbd2ea36df1886546895943781e",
        "packageNameBefore": "com.github.javaparser.symbolsolver.core.resolution",
        "classNameBefore": "com.github.javaparser.symbolsolver.core.resolution.Context",
        "methodNameBefore": "com.github.javaparser.symbolsolver.core.resolution.Context#solveTypeInParentContext",
        "invokedMethod": "methodSignature: com.github.javaparser.symbolsolver.core.resolution.Context#getParent\n methodBody: Optional<Context> getParent();\nmethodSignature: com.github.javaparser.symbolsolver.core.resolution.Context#solveType\n methodBody: default SymbolReference<ResolvedTypeDeclaration> solveType(String name) {\nreturn solveTypeInParentContext(name);\n}",
        "classSignatureBefore": "public interface Context ",
        "methodNameBeforeSet": [
            "com.github.javaparser.symbolsolver.core.resolution.Context#solveTypeInParentContext"
        ],
        "classNameBeforeSet": [
            "com.github.javaparser.symbolsolver.core.resolution.Context"
        ],
        "classSignatureBeforeSet": [
            "public interface Context "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Overlapped refactoring - can be identical by undoing the overlapped refactoring\n- Extract Method-",
                "description": "Extract Method on top of the extracted method - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Copyright (C) 2015-2016 Federico Tomassetti\n * Copyright (C) 2017-2020 The JavaParser Team.\n *\n * This file is part of JavaParser.\n *\n * JavaParser can be used either under the terms of\n * a) the GNU Lesser General Public License as published by\n *     the Free Software Foundation, either version 3 of the License, or\n *     (at your option) any later version.\n * b) the terms of the Apache License\n *\n * You should have received a copy of both licenses in LICENCE.LGPL and\n * LICENCE.APACHE. Please refer to those files for details.\n *\n * JavaParser is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n */\n\npackage com.github.javaparser.symbolsolver.core.resolution;\n\nimport com.github.javaparser.ast.Node;\nimport com.github.javaparser.ast.body.Parameter;\nimport com.github.javaparser.ast.body.VariableDeclarator;\nimport com.github.javaparser.ast.expr.PatternExpr;\nimport com.github.javaparser.resolution.MethodUsage;\nimport com.github.javaparser.resolution.declarations.*;\nimport com.github.javaparser.resolution.types.ResolvedType;\nimport com.github.javaparser.symbolsolver.javaparsermodel.contexts.AbstractJavaParserContext;\nimport com.github.javaparser.symbolsolver.model.resolution.SymbolReference;\nimport com.github.javaparser.symbolsolver.model.resolution.Value;\n\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Optional;\n\n/**\n * Context is very similar to scope.\n * In the context we look for solving symbols.\n *\n * @author Federico Tomassetti\n */\npublic interface Context {\n\n    /**\n     * @return The parent context, if there is one. For example, a method exists within a compilation unit.\n     */\n    Optional<Context> getParent();\n\n\n    /* Type resolution */\n\n    /**\n     * Default to no generics available in this context, delegating solving to the parent context.\n     * Contexts which have generics available to it will override this method.\n     * For example class and method declarations, and method calls.\n     *\n     * @param name For example, solving {@code T} within {@code class Foo<T> {}} or\n     * @return The resolved generic type, if found.\n     */\n    default Optional<ResolvedType> solveGenericType(String name) {\n        // Default to solving within the parent context.\n        return solveGenericTypeInParentContext(name);\n    }\n\n    default Optional<ResolvedType> solveGenericTypeInParentContext(String name) {\n        Optional<Context> optionalParentContext = getParent();\n        if (!optionalParentContext.isPresent()) {\n            return Optional.empty();\n        }\n\n        // Delegate solving to the parent context.\n        return optionalParentContext.get().solveGenericType(name);\n    }\n\n    /**\n     * Default to being unable to solve any reference in this context, delegating solving to the parent context.\n     * Contexts which exist as the \"parent\" of a resolvable type will override this method.\n     * For example, a compilation unit can contain classes. A class declaration can also contain types (e.g. a subclass).\n     *\n     * @param name For example, solving {@code List} or {@code java.util.List}.\n     * @return The declaration associated with the given type name.\n     */\n    default SymbolReference<ResolvedTypeDeclaration> solveType(String name) {\n        // Default to solving within the parent context.\n        return solveTypeInParentContext(name);\n    }\n\n    default SymbolReference<ResolvedTypeDeclaration> solveTypeInParentContext(String name) {\n        Optional<Context> optionalParentContext = getParent();\n        if (!optionalParentContext.isPresent()) {\n            return SymbolReference.unsolved();\n        }\n\n        // Delegate solving to the parent context.\n        return optionalParentContext.get().solveType(name);\n    }\n\n    /* Symbol resolution */\n\n    /**\n     * Used where a symbol is being used (e.g. solving {@code x} when used as an argument {@code doubleThis(x)}, or calculation {@code return x * 2;}).\n     * @param name the variable / reference / identifier used.\n     * @return // FIXME: Better documentation on how this is different to solveSymbolAsValue()\n     */\n    default SymbolReference<? extends ResolvedValueDeclaration> solveSymbol(String name) {\n        // Default to solving within the parent context.\n        return solveSymbolInParentContext(name);\n    }\n\n    default SymbolReference<? extends ResolvedValueDeclaration> solveSymbolInParentContext(String name) {\n        Optional<Context> optionalParentContext = getParent();\n        if (!optionalParentContext.isPresent()) {\n            return SymbolReference.unsolved();\n        }\n\n        // Delegate solving to the parent context.\n        return optionalParentContext.get().solveSymbol(name);\n    }\n\n    /**\n     * Used where a symbol is being used (e.g. solving {@code x} when used as an argument {@code doubleThis(x)}, or calculation {@code return x * 2;}).\n     * @param name the variable / reference / identifier used.\n     * @return // FIXME: Better documentation on how this is different to solveSymbol()\n     */\n    default Optional<Value> solveSymbolAsValue(String name) {\n        SymbolReference<? extends ResolvedValueDeclaration> ref = solveSymbol(name);\n        if (!ref.isSolved()) {\n            return Optional.empty();\n        }\n\n        return Optional.of(Value.from(ref.getCorrespondingDeclaration()));\n    }\n\n    default Optional<Value> solveSymbolAsValueInParentContext(String name) {\n        SymbolReference<? extends ResolvedValueDeclaration> ref = solveSymbolInParentContext(name);\n        if (!ref.isSolved()) {\n            return Optional.empty();\n        }\n\n        return Optional.of(Value.from(ref.getCorrespondingDeclaration()));\n    }\n\n\n    /**\n     * The fields that are declared and in this immediate context made visible to a given child.\n     * This list could include values which are shadowed.\n     */\n    default List<ResolvedFieldDeclaration> fieldsExposedToChild(Node child) {\n        return Collections.emptyList();\n    }\n\n    /**\n     * The local variables that are declared in this immediate context and made visible to a given child.\n     * This list could include values which are shadowed.\n     */\n    default List<VariableDeclarator> localVariablesExposedToChild(Node child) {\n        return Collections.emptyList();\n    }\n\n    /**\n     * The parameters that are declared in this immediate context and made visible to a given child.\n     * This list could include values which are shadowed.\n     */\n    default List<Parameter> parametersExposedToChild(Node child) {\n        return Collections.emptyList();\n    }\n\n    /**\n     * The pattern expressions that are declared in this immediate context and made visible to a given child.\n     * This list could include values which are shadowed.\n     */\n    default List<PatternExpr> patternExprsExposedToChild(Node child) {\n        return Collections.emptyList();\n    }\n\n    /**\n     */\n    default List<PatternExpr> patternExprsExposedFromChildren() {\n        return Collections.emptyList();\n    }\n\n    /**\n     */\n    default List<PatternExpr> negatedPatternExprsExposedFromChildren() {\n        return Collections.emptyList();\n    }\n\n    /**\n     * Aim to resolve the given name by looking for a variable matching it.\n     * <p>\n     * To do it consider local variables that are visible in a certain scope as defined in JLS 6.3. Scope of a\n     * Declaration.\n     * <p>\n     * 1. The scope of a local variable declaration in a block (\u00a714.4) is the rest of the block in which the\n     * declaration\n     * appears, starting with its own initializer and including any further declarators to the right in the local\n     * variable declaration statement.\n     * <p>\n     * 2. The scope of a local variable declared in the ForInit part of a basic for statement (\u00a714.14.1) includes all\n     * of the following:\n     * 2.1 Its own initializer\n     * 2.2 Any further declarators to the right in the ForInit part of the for statement\n     * 2.3 The Expression and ForUpdate parts of the for statement\n     * 2.4 The contained Statement\n     * <p>\n     * 3. The scope of a local variable declared in the FormalParameter part of an enhanced for statement (\u00a714.14.2) is\n     * the contained Statement.\n     * 4. The scope of a parameter of an exception handler that is declared in a catch clause of a try statement\n     * (\u00a714.20) is the entire block associated with the catch.\n     * <p>\n     * 5. The scope of a variable declared in the ResourceSpecification of a try-with-resources statement (\u00a714.20.3) is\n     * from the declaration rightward over the remainder of the ResourceSpecification and the entire try block\n     * associated with the try-with-resources statement.\n     */\n    default Optional<VariableDeclarator> localVariableDeclarationInScope(String name) {\n        if (!getParent().isPresent()) {\n            return Optional.empty();\n        }\n\n        // First check if the variable is directly declared within this context.\n        Node wrappedNode = ((AbstractJavaParserContext) this).getWrappedNode();\n        Context parentContext = getParent().get();\n        Optional<VariableDeclarator> localResolutionResults = parentContext\n                .localVariablesExposedToChild(wrappedNode)\n                .stream()\n                .filter(vd -> vd.getNameAsString().equals(name))\n                .findFirst();\n\n        if (localResolutionResults.isPresent()) {\n            return localResolutionResults;\n        }\n\n\n        // If we don't find the variable locally, escalate up the scope hierarchy to see if it is declared there.\n        return parentContext.localVariableDeclarationInScope(name);\n    }\n\n    default Optional<Parameter> parameterDeclarationInScope(String name) {\n        if (!getParent().isPresent()) {\n            return Optional.empty();\n        }\n\n        // First check if the parameter is directly declared within this context.\n        Node wrappedNode = ((AbstractJavaParserContext) this).getWrappedNode();\n        Context parentContext = getParent().get();\n        Optional<Parameter> localResolutionResults = parentContext\n                .parametersExposedToChild(wrappedNode)\n                .stream()\n                .filter(vd -> vd.getNameAsString().equals(name))\n                .findFirst();\n\n        if (localResolutionResults.isPresent()) {\n            return localResolutionResults;\n        }\n\n        // If we don't find the parameter locally, escalate up the scope hierarchy to see if it is declared there.\n        return parentContext.parameterDeclarationInScope(name);\n    }\n\n\n    /**\n     * With respect to solving, the AST \"parent\" of a block statement is not necessarily the same as the scope parent.\n     * <br>Example:\n     * <br>\n     * <pre>{@code\n     *  public String x() {\n     *      if(x) {\n     *          // Parent node: the block attached to the method declaration\n     *          // Scope-parent: the block attached to the method declaration\n     *      } else if {\n     *          // Parent node: the if\n     *          // Scope-parent: the block attached to the method declaration\n     *      } else {\n     *          // Parent node: the elseif\n     *          // Scope-parent: the block attached to the method declaration\n     *      }\n     *  }\n     * }</pre>\n     */\n    default Optional<PatternExpr> patternExprInScope(String name) {\n        if (!getParent().isPresent()) {\n            return Optional.empty();\n        }\n        Context parentContext = getParent().get();\n\n        // FIXME: \"scroll backwards\" from the wrapped node\n        // FIXME: If there are multiple patterns, throw an error?\n\n        // First check if the pattern is directly declared within this context.\n        Node wrappedNode = ((AbstractJavaParserContext) this).getWrappedNode();\n        Optional<PatternExpr> localResolutionResults = parentContext\n                .patternExprsExposedToChild(wrappedNode)\n                .stream()\n                .filter(vd -> vd.getNameAsString().equals(name))\n                .findFirst();\n\n        if (localResolutionResults.isPresent()) {\n            return localResolutionResults;\n        }\n\n        // If we don't find the parameter locally, escalate up the scope hierarchy to see if it is declared there.\n        return parentContext.patternExprInScope(name);\n    }\n\n    default Optional<ResolvedFieldDeclaration> fieldDeclarationInScope(String name) {\n        if (!getParent().isPresent()) {\n            return Optional.empty();\n        }\n        Context parentContext = getParent().get();\n        // First check if the parameter is directly declared within this context.\n        Node wrappedNode = ((AbstractJavaParserContext) this).getWrappedNode();\n        Optional<ResolvedFieldDeclaration> localResolutionResults = parentContext\n                .fieldsExposedToChild(wrappedNode)\n                .stream()\n                .filter(vd -> vd.getName().equals(name))\n                .findFirst();\n\n        if (localResolutionResults.isPresent()) {\n            return localResolutionResults;\n        }\n\n        // If we don't find the field locally, escalate up the scope hierarchy to see if it is declared there.\n        return parentContext.fieldDeclarationInScope(name);\n    }\n\n\n    /* Constructor resolution */\n\n    /**\n     * We find the method declaration which is the best match for the given name and list of typeParametersValues.\n     */\n    default SymbolReference<ResolvedConstructorDeclaration> solveConstructor(List<ResolvedType> argumentsTypes) {\n        throw new IllegalArgumentException(\"Constructor resolution is available only on Class Context\");\n    }\n\n    /* Methods resolution */\n\n    /**\n     * We find the method declaration which is the best match for the given name and list of typeParametersValues.\n     */\n    default SymbolReference<ResolvedMethodDeclaration> solveMethod(String name, List<ResolvedType> argumentsTypes, boolean staticOnly) {\n        // Default to solving within the parent context.\n        return solveMethodInParentContext(name, argumentsTypes, staticOnly);\n    }\n\n    default SymbolReference<ResolvedMethodDeclaration> solveMethodInParentContext(String name, List<ResolvedType> argumentsTypes, boolean staticOnly) {\n        Optional<Context> optionalParentContext = getParent();\n        if (!optionalParentContext.isPresent()) {\n            return SymbolReference.unsolved();\n        }\n\n        // Delegate solving to the parent context.\n        return optionalParentContext.get().solveMethod(name, argumentsTypes, staticOnly);\n    }\n\n    /**\n     * Similar to solveMethod but we return a MethodUsage.\n     * A MethodUsage corresponds to a MethodDeclaration plus the resolved type variables.\n     */\n    default Optional<MethodUsage> solveMethodAsUsage(String name, List<ResolvedType> argumentsTypes) {\n        SymbolReference<ResolvedMethodDeclaration> methodSolved = solveMethod(name, argumentsTypes, false);\n        if (methodSolved.isSolved()) {\n            ResolvedMethodDeclaration methodDeclaration = methodSolved.getCorrespondingDeclaration();\n            if (!(methodDeclaration instanceof TypeVariableResolutionCapability)) {\n                throw new UnsupportedOperationException(String.format(\n                        \"Resolved method declarations must implement %s.\",\n                        TypeVariableResolutionCapability.class.getName()\n                ));\n            }\n\n            MethodUsage methodUsage = ((TypeVariableResolutionCapability) methodDeclaration).resolveTypeVariables(this, argumentsTypes);\n            return Optional.of(methodUsage);\n        } else {\n            return Optional.empty();\n        }\n    }\n\n}\n",
        "filePathAfter": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/core/resolution/Context.java",
        "sourceCodeAfterForWhole": "/*\n * Copyright (C) 2015-2016 Federico Tomassetti\n * Copyright (C) 2017-2020 The JavaParser Team.\n *\n * This file is part of JavaParser.\n *\n * JavaParser can be used either under the terms of\n * a) the GNU Lesser General Public License as published by\n *     the Free Software Foundation, either version 3 of the License, or\n *     (at your option) any later version.\n * b) the terms of the Apache License\n *\n * You should have received a copy of both licenses in LICENCE.LGPL and\n * LICENCE.APACHE. Please refer to those files for details.\n *\n * JavaParser is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n */\n\npackage com.github.javaparser.symbolsolver.core.resolution;\n\nimport com.github.javaparser.ast.Node;\nimport com.github.javaparser.ast.body.Parameter;\nimport com.github.javaparser.ast.body.VariableDeclarator;\nimport com.github.javaparser.ast.expr.PatternExpr;\nimport com.github.javaparser.quality.Nullable;\nimport com.github.javaparser.resolution.MethodUsage;\nimport com.github.javaparser.resolution.declarations.*;\nimport com.github.javaparser.resolution.types.ResolvedType;\nimport com.github.javaparser.symbolsolver.javaparsermodel.contexts.AbstractJavaParserContext;\nimport com.github.javaparser.symbolsolver.model.resolution.SymbolReference;\nimport com.github.javaparser.symbolsolver.model.resolution.Value;\n\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Optional;\n\n/**\n * Context is very similar to scope.\n * In the context we look for solving symbols.\n *\n * @author Federico Tomassetti\n */\npublic interface Context {\n\n    /**\n     * @return The parent context, if there is one. For example, a method exists within a compilation unit.\n     */\n    Optional<Context> getParent();\n\n\n    /* Type resolution */\n\n    /**\n     * Default to no generics available in this context, delegating solving to the parent context.\n     * Contexts which have generics available to it will override this method.\n     * For example class and method declarations, and method calls.\n     *\n     * @param name For example, solving {@code T} within {@code class Foo<T> {}} or\n     * @return The resolved generic type, if found.\n     */\n    default Optional<ResolvedType> solveGenericType(String name) {\n        // Default to solving within the parent context.\n        return solveGenericTypeInParentContext(name);\n    }\n\n    default Optional<ResolvedType> solveGenericTypeInParentContext(String name) {\n        Optional<Context> optionalParentContext = getParent();\n        if (!optionalParentContext.isPresent()) {\n            return Optional.empty();\n        }\n\n        // Delegate solving to the parent context.\n        return optionalParentContext.get().solveGenericType(name);\n    }\n\n    /**\n     * Default to being unable to solve any reference in this context, delegating solving to the parent context.\n     * Contexts which exist as the \"parent\" of a resolvable type will override this method.\n     * For example, a compilation unit can contain classes. A class declaration can also contain types (e.g. a subclass).\n     *\n     * @param name For example, solving {@code List} or {@code java.util.List}.\n     * @return The declaration associated with the given type name.\n     *\n     * @deprecated Consider using method {@link #solveType(String, List)} that also consider the type arguments.\n     *             If you want to keep to use the new function, but keep the same behavior consider passing type\n     *             arguments as {@code null}.\n     */\n    @Deprecated\n    default SymbolReference<ResolvedTypeDeclaration> solveType(String name) {\n        return solveType(name, null);\n    }\n\n    /**\n     * Method used to solve a name with an expected list of type arguments.\n     * <br>\n     * This method differs from {@link Context#solveType(String)} by taking the type arguments in consideration.\n     * For example, lets imagine that we have a project containing the following classes:\n     * <ul>\n     *     <li>com/example/Alpha.java</li>\n     *     <li>com/example/Beta.java</li>\n     * </ul>\n     * Where Alpha creates a inner interface called CustomInterface and Beta implements Alpha.CustomInterface and\n     * also declares a inner interface called CustomInterface with type arguments. Using this method we can\n     * specify which type arguments we are expecting and will be resolved with the type matching that declaration.\n     *\n     * @param name          The name to be solved.\n     * @param typeArguments The list of expected type arguments.\n     *\n     * @return The declaration associated with the given type name.\n     */\n    default SymbolReference<ResolvedTypeDeclaration> solveType(String name, @Nullable List<ResolvedType> typeArguments) {\n        // Default to solving within the parent context.\n        return solveTypeInParentContext(name, typeArguments);\n    }\n\n    /**\n     * Solve a name in the parent context.\n     *\n     * @param name The name to be solved.\n     *\n     * @return The declaration associated with the given type name.\n     *\n     * @deprecated Consider using method {@link #solveTypeInParentContext(String, List)} that also consider the type arguments.\n     *             If you want to keep to use the new function, but keep the same behavior consider passing type\n     *             arguments as {@code null}.\n     */\n    @Deprecated\n    default SymbolReference<ResolvedTypeDeclaration> solveTypeInParentContext(String name) {\n        return solveTypeInParentContext(name, null);\n    }\n\n    /**\n     * Solve a name with type arguments in the parent context.\n     *\n     * @param name          The name to be solved.\n     * @param typeArguments The list of expected type arguments.\n     *\n     * @return The declaration associated with the given type name.\n     */\n    default SymbolReference<ResolvedTypeDeclaration> solveTypeInParentContext(String name, @Nullable List<ResolvedType> typeArguments) {\n        Optional<Context> optionalParentContext = getParent();\n        if (!optionalParentContext.isPresent()) {\n            return SymbolReference.unsolved();\n        }\n\n        // Delegate solving to the parent context.\n        return optionalParentContext.get().solveType(name, typeArguments);\n    }\n\n    /* Symbol resolution */\n\n    /**\n     * Used where a symbol is being used (e.g. solving {@code x} when used as an argument {@code doubleThis(x)}, or calculation {@code return x * 2;}).\n     * @param name the variable / reference / identifier used.\n     * @return // FIXME: Better documentation on how this is different to solveSymbolAsValue()\n     */\n    default SymbolReference<? extends ResolvedValueDeclaration> solveSymbol(String name) {\n        // Default to solving within the parent context.\n        return solveSymbolInParentContext(name);\n    }\n\n    default SymbolReference<? extends ResolvedValueDeclaration> solveSymbolInParentContext(String name) {\n        Optional<Context> optionalParentContext = getParent();\n        if (!optionalParentContext.isPresent()) {\n            return SymbolReference.unsolved();\n        }\n\n        // Delegate solving to the parent context.\n        return optionalParentContext.get().solveSymbol(name);\n    }\n\n    /**\n     * Used where a symbol is being used (e.g. solving {@code x} when used as an argument {@code doubleThis(x)}, or calculation {@code return x * 2;}).\n     * @param name the variable / reference / identifier used.\n     * @return // FIXME: Better documentation on how this is different to solveSymbol()\n     */\n    default Optional<Value> solveSymbolAsValue(String name) {\n        SymbolReference<? extends ResolvedValueDeclaration> ref = solveSymbol(name);\n        if (!ref.isSolved()) {\n            return Optional.empty();\n        }\n\n        return Optional.of(Value.from(ref.getCorrespondingDeclaration()));\n    }\n\n    default Optional<Value> solveSymbolAsValueInParentContext(String name) {\n        SymbolReference<? extends ResolvedValueDeclaration> ref = solveSymbolInParentContext(name);\n        if (!ref.isSolved()) {\n            return Optional.empty();\n        }\n\n        return Optional.of(Value.from(ref.getCorrespondingDeclaration()));\n    }\n\n\n    /**\n     * The fields that are declared and in this immediate context made visible to a given child.\n     * This list could include values which are shadowed.\n     */\n    default List<ResolvedFieldDeclaration> fieldsExposedToChild(Node child) {\n        return Collections.emptyList();\n    }\n\n    /**\n     * The local variables that are declared in this immediate context and made visible to a given child.\n     * This list could include values which are shadowed.\n     */\n    default List<VariableDeclarator> localVariablesExposedToChild(Node child) {\n        return Collections.emptyList();\n    }\n\n    /**\n     * The parameters that are declared in this immediate context and made visible to a given child.\n     * This list could include values which are shadowed.\n     */\n    default List<Parameter> parametersExposedToChild(Node child) {\n        return Collections.emptyList();\n    }\n\n    /**\n     * The pattern expressions that are declared in this immediate context and made visible to a given child.\n     * This list could include values which are shadowed.\n     */\n    default List<PatternExpr> patternExprsExposedToChild(Node child) {\n        return Collections.emptyList();\n    }\n\n    /**\n     */\n    default List<PatternExpr> patternExprsExposedFromChildren() {\n        return Collections.emptyList();\n    }\n\n    /**\n     */\n    default List<PatternExpr> negatedPatternExprsExposedFromChildren() {\n        return Collections.emptyList();\n    }\n\n    /**\n     * Aim to resolve the given name by looking for a variable matching it.\n     * <p>\n     * To do it consider local variables that are visible in a certain scope as defined in JLS 6.3. Scope of a\n     * Declaration.\n     * <p>\n     * 1. The scope of a local variable declaration in a block (\u00a714.4) is the rest of the block in which the\n     * declaration\n     * appears, starting with its own initializer and including any further declarators to the right in the local\n     * variable declaration statement.\n     * <p>\n     * 2. The scope of a local variable declared in the ForInit part of a basic for statement (\u00a714.14.1) includes all\n     * of the following:\n     * 2.1 Its own initializer\n     * 2.2 Any further declarators to the right in the ForInit part of the for statement\n     * 2.3 The Expression and ForUpdate parts of the for statement\n     * 2.4 The contained Statement\n     * <p>\n     * 3. The scope of a local variable declared in the FormalParameter part of an enhanced for statement (\u00a714.14.2) is\n     * the contained Statement.\n     * 4. The scope of a parameter of an exception handler that is declared in a catch clause of a try statement\n     * (\u00a714.20) is the entire block associated with the catch.\n     * <p>\n     * 5. The scope of a variable declared in the ResourceSpecification of a try-with-resources statement (\u00a714.20.3) is\n     * from the declaration rightward over the remainder of the ResourceSpecification and the entire try block\n     * associated with the try-with-resources statement.\n     */\n    default Optional<VariableDeclarator> localVariableDeclarationInScope(String name) {\n        if (!getParent().isPresent()) {\n            return Optional.empty();\n        }\n\n        // First check if the variable is directly declared within this context.\n        Node wrappedNode = ((AbstractJavaParserContext) this).getWrappedNode();\n        Context parentContext = getParent().get();\n        Optional<VariableDeclarator> localResolutionResults = parentContext\n                .localVariablesExposedToChild(wrappedNode)\n                .stream()\n                .filter(vd -> vd.getNameAsString().equals(name))\n                .findFirst();\n\n        if (localResolutionResults.isPresent()) {\n            return localResolutionResults;\n        }\n\n\n        // If we don't find the variable locally, escalate up the scope hierarchy to see if it is declared there.\n        return parentContext.localVariableDeclarationInScope(name);\n    }\n\n    default Optional<Parameter> parameterDeclarationInScope(String name) {\n        if (!getParent().isPresent()) {\n            return Optional.empty();\n        }\n\n        // First check if the parameter is directly declared within this context.\n        Node wrappedNode = ((AbstractJavaParserContext) this).getWrappedNode();\n        Context parentContext = getParent().get();\n        Optional<Parameter> localResolutionResults = parentContext\n                .parametersExposedToChild(wrappedNode)\n                .stream()\n                .filter(vd -> vd.getNameAsString().equals(name))\n                .findFirst();\n\n        if (localResolutionResults.isPresent()) {\n            return localResolutionResults;\n        }\n\n        // If we don't find the parameter locally, escalate up the scope hierarchy to see if it is declared there.\n        return parentContext.parameterDeclarationInScope(name);\n    }\n\n\n    /**\n     * With respect to solving, the AST \"parent\" of a block statement is not necessarily the same as the scope parent.\n     * <br>Example:\n     * <br>\n     * <pre>{@code\n     *  public String x() {\n     *      if(x) {\n     *          // Parent node: the block attached to the method declaration\n     *          // Scope-parent: the block attached to the method declaration\n     *      } else if {\n     *          // Parent node: the if\n     *          // Scope-parent: the block attached to the method declaration\n     *      } else {\n     *          // Parent node: the elseif\n     *          // Scope-parent: the block attached to the method declaration\n     *      }\n     *  }\n     * }</pre>\n     */\n    default Optional<PatternExpr> patternExprInScope(String name) {\n        if (!getParent().isPresent()) {\n            return Optional.empty();\n        }\n        Context parentContext = getParent().get();\n\n        // FIXME: \"scroll backwards\" from the wrapped node\n        // FIXME: If there are multiple patterns, throw an error?\n\n        // First check if the pattern is directly declared within this context.\n        Node wrappedNode = ((AbstractJavaParserContext) this).getWrappedNode();\n        Optional<PatternExpr> localResolutionResults = parentContext\n                .patternExprsExposedToChild(wrappedNode)\n                .stream()\n                .filter(vd -> vd.getNameAsString().equals(name))\n                .findFirst();\n\n        if (localResolutionResults.isPresent()) {\n            return localResolutionResults;\n        }\n\n        // If we don't find the parameter locally, escalate up the scope hierarchy to see if it is declared there.\n        return parentContext.patternExprInScope(name);\n    }\n\n    default Optional<ResolvedFieldDeclaration> fieldDeclarationInScope(String name) {\n        if (!getParent().isPresent()) {\n            return Optional.empty();\n        }\n        Context parentContext = getParent().get();\n        // First check if the parameter is directly declared within this context.\n        Node wrappedNode = ((AbstractJavaParserContext) this).getWrappedNode();\n        Optional<ResolvedFieldDeclaration> localResolutionResults = parentContext\n                .fieldsExposedToChild(wrappedNode)\n                .stream()\n                .filter(vd -> vd.getName().equals(name))\n                .findFirst();\n\n        if (localResolutionResults.isPresent()) {\n            return localResolutionResults;\n        }\n\n        // If we don't find the field locally, escalate up the scope hierarchy to see if it is declared there.\n        return parentContext.fieldDeclarationInScope(name);\n    }\n\n\n    /* Constructor resolution */\n\n    /**\n     * We find the method declaration which is the best match for the given name and list of typeParametersValues.\n     */\n    default SymbolReference<ResolvedConstructorDeclaration> solveConstructor(List<ResolvedType> argumentsTypes) {\n        throw new IllegalArgumentException(\"Constructor resolution is available only on Class Context\");\n    }\n\n    /* Methods resolution */\n\n    /**\n     * We find the method declaration which is the best match for the given name and list of typeParametersValues.\n     */\n    default SymbolReference<ResolvedMethodDeclaration> solveMethod(String name, List<ResolvedType> argumentsTypes, boolean staticOnly) {\n        // Default to solving within the parent context.\n        return solveMethodInParentContext(name, argumentsTypes, staticOnly);\n    }\n\n    default SymbolReference<ResolvedMethodDeclaration> solveMethodInParentContext(String name, List<ResolvedType> argumentsTypes, boolean staticOnly) {\n        Optional<Context> optionalParentContext = getParent();\n        if (!optionalParentContext.isPresent()) {\n            return SymbolReference.unsolved();\n        }\n\n        // Delegate solving to the parent context.\n        return optionalParentContext.get().solveMethod(name, argumentsTypes, staticOnly);\n    }\n\n    /**\n     * Similar to solveMethod but we return a MethodUsage.\n     * A MethodUsage corresponds to a MethodDeclaration plus the resolved type variables.\n     */\n    default Optional<MethodUsage> solveMethodAsUsage(String name, List<ResolvedType> argumentsTypes) {\n        SymbolReference<ResolvedMethodDeclaration> methodSolved = solveMethod(name, argumentsTypes, false);\n        if (methodSolved.isSolved()) {\n            ResolvedMethodDeclaration methodDeclaration = methodSolved.getCorrespondingDeclaration();\n            if (!(methodDeclaration instanceof TypeVariableResolutionCapability)) {\n                throw new UnsupportedOperationException(String.format(\n                        \"Resolved method declarations must implement %s.\",\n                        TypeVariableResolutionCapability.class.getName()\n                ));\n            }\n\n            MethodUsage methodUsage = ((TypeVariableResolutionCapability) methodDeclaration).resolveTypeVariables(this, argumentsTypes);\n            return Optional.of(methodUsage);\n        } else {\n            return Optional.empty();\n        }\n    }\n\n}\n",
        "diffSourceCodeSet": [
            "/**\n     * Solve a name with type arguments in the parent context.\n     *\n     * @param name          The name to be solved.\n     * @param typeArguments The list of expected type arguments.\n     *\n     * @return The declaration associated with the given type name.\n     */\n    default SymbolReference<ResolvedTypeDeclaration> solveTypeInParentContext(String name, @Nullable List<ResolvedType> typeArguments) {\n        Optional<Context> optionalParentContext = getParent();\n        if (!optionalParentContext.isPresent()) {\n            return SymbolReference.unsolved();\n        }\n\n        // Delegate solving to the parent context.\n        return optionalParentContext.get().solveType(name, typeArguments);\n    }"
        ],
        "invokedMethodSet": [
            "methodSignature: com.github.javaparser.symbolsolver.core.resolution.Context#getParent\n methodBody: Optional<Context> getParent();",
            "methodSignature: com.github.javaparser.symbolsolver.core.resolution.Context#solveType\n methodBody: default SymbolReference<ResolvedTypeDeclaration> solveType(String name) {\nreturn solveTypeInParentContext(name);\n}"
        ],
        "sourceCodeAfterRefactoring": "/**\n     * Solve a name in the parent context.\n     *\n     * @param name The name to be solved.\n     *\n     * @return The declaration associated with the given type name.\n     *\n     * @deprecated Consider using method {@link #solveTypeInParentContext(String, List)} that also consider the type arguments.\n     *             If you want to keep to use the new function, but keep the same behavior consider passing type\n     *             arguments as {@code null}.\n     */\n    @Deprecated\n    default SymbolReference<ResolvedTypeDeclaration> solveTypeInParentContext(String name) {\n        return solveTypeInParentContext(name, null);\n    }\n/**\n     * Solve a name with type arguments in the parent context.\n     *\n     * @param name          The name to be solved.\n     * @param typeArguments The list of expected type arguments.\n     *\n     * @return The declaration associated with the given type name.\n     */\n    default SymbolReference<ResolvedTypeDeclaration> solveTypeInParentContext(String name, @Nullable List<ResolvedType> typeArguments) {\n        Optional<Context> optionalParentContext = getParent();\n        if (!optionalParentContext.isPresent()) {\n            return SymbolReference.unsolved();\n        }\n\n        // Delegate solving to the parent context.\n        return optionalParentContext.get().solveType(name, typeArguments);\n    }",
        "diffSourceCode": "-   91:     default SymbolReference<ResolvedTypeDeclaration> solveTypeInParentContext(String name) {\n-   92:         Optional<Context> optionalParentContext = getParent();\n-   93:         if (!optionalParentContext.isPresent()) {\n-   94:             return SymbolReference.unsolved();\n-   95:         }\n-   96: \n-   97:         // Delegate solving to the parent context.\n-   98:         return optionalParentContext.get().solveType(name);\n-   99:     }\n-  119:         // Delegate solving to the parent context.\n-  120:         return optionalParentContext.get().solveSymbol(name);\n-  121:     }\n-  122: \n-  123:     /**\n-  124:      * Used where a symbol is being used (e.g. solving {@code x} when used as an argument {@code doubleThis(x)}, or calculation {@code return x * 2;}).\n-  125:      * @param name the variable / reference / identifier used.\n-  126:      * @return // FIXME: Better documentation on how this is different to solveSymbol()\n-  127:      */\n-  128:     default Optional<Value> solveSymbolAsValue(String name) {\n-  129:         SymbolReference<? extends ResolvedValueDeclaration> ref = solveSymbol(name);\n-  130:         if (!ref.isSolved()) {\n-  131:             return Optional.empty();\n-  132:         }\n-  133: \n-  135:     }\n-  136: \n-  137:     default Optional<Value> solveSymbolAsValueInParentContext(String name) {\n-  138:         SymbolReference<? extends ResolvedValueDeclaration> ref = solveSymbolInParentContext(name);\n-  139:         if (!ref.isSolved()) {\n-  140:             return Optional.empty();\n-  141:         }\n-  142: \n-  143:         return Optional.of(Value.from(ref.getCorrespondingDeclaration()));\n-  144:     }\n-  145: \n-  146: \n-  147:     /**\n-  148:      * The fields that are declared and in this immediate context made visible to a given child.\n-  149:      * This list could include values which are shadowed.\n-  150:      */\n-  151:     default List<ResolvedFieldDeclaration> fieldsExposedToChild(Node child) {\n+   91:     @Deprecated\n+   92:     default SymbolReference<ResolvedTypeDeclaration> solveType(String name) {\n+   93:         return solveType(name, null);\n+   94:     }\n+   95: \n+   96:     /**\n+   97:      * Method used to solve a name with an expected list of type arguments.\n+   98:      * <br>\n+   99:      * This method differs from {@link Context#solveType(String)} by taking the type arguments in consideration.\n+  119:     /**\n+  120:      * Solve a name in the parent context.\n+  121:      *\n+  122:      * @param name The name to be solved.\n+  123:      *\n+  124:      * @return The declaration associated with the given type name.\n+  125:      *\n+  126:      * @deprecated Consider using method {@link #solveTypeInParentContext(String, List)} that also consider the type arguments.\n+  127:      *             If you want to keep to use the new function, but keep the same behavior consider passing type\n+  128:      *             arguments as {@code null}.\n+  129:      */\n+  130:     @Deprecated\n+  131:     default SymbolReference<ResolvedTypeDeclaration> solveTypeInParentContext(String name) {\n+  132:         return solveTypeInParentContext(name, null);\n+  133:     }\n+  135:     /**\n+  136:      * Solve a name with type arguments in the parent context.\n+  137:      *\n+  138:      * @param name          The name to be solved.\n+  139:      * @param typeArguments The list of expected type arguments.\n+  140:      *\n+  141:      * @return The declaration associated with the given type name.\n+  142:      */\n+  143:     default SymbolReference<ResolvedTypeDeclaration> solveTypeInParentContext(String name, @Nullable List<ResolvedType> typeArguments) {\n+  144:         Optional<Context> optionalParentContext = getParent();\n+  145:         if (!optionalParentContext.isPresent()) {\n+  146:             return SymbolReference.unsolved();\n+  147:         }\n+  148: \n+  149:         // Delegate solving to the parent context.\n+  150:         return optionalParentContext.get().solveType(name, typeArguments);\n+  151:     }\n",
        "uniqueId": "4549a58efd47cbbd2ea36df1886546895943781e_91_99_135_151_119_133",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 0,
                "covered": 14
            },
            "BRANCH": {
                "missed": 0,
                "covered": 2
            },
            "LINE": {
                "missed": 0,
                "covered": 4
            },
            "COMPLEXITY": {
                "missed": 0,
                "covered": 2
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 17
    }
]