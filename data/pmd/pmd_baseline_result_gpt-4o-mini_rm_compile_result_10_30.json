[{"type": "Extract Method", "description": "Extract Method\tprotected getCachedMethodResults(simpleName String) : List<JMethodSymbol> extracted from public resolveMethodName(simpleName String) : Stream<JMethodSymbol> in class net.sourceforge.pmd.lang.java.symbols.table.internal.AbstractSymbolTable", "diffLocations": [{"filePath": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/table/internal/AbstractSymbolTable.java", "startLine": 65, "endLine": 75, "startColumn": 0, "endColumn": 0}, {"filePath": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/table/internal/AbstractSymbolTable.java", "startLine": 65, "endLine": 85, "startColumn": 0, "endColumn": 0}, {"filePath": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/table/internal/AbstractSymbolTable.java", "startLine": 100, "endLine": 103, "startColumn": 0, "endColumn": 0}], "sourceCodeBeforeRefactoring": "@Override\n    public final Stream<JMethodSymbol> resolveMethodName(String simpleName) {\n        // This allows the stream contributed by the parent to be resolved lazily,\n        // ie not evaluated unless the stream contributed by this table runs out of values,\n        // a behaviour that Stream.concat can't provide\n\n        return Stream.<Supplier<Stream<JMethodSymbol>>>of(\n            () -> resolveMethodNameImpl(simpleName),\n            () -> parent.resolveMethodName(simpleName)\n        ).flatMap(Supplier::get);\n    }", "filePathBefore": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/table/internal/AbstractSymbolTable.java", "isPureRefactoring": true, "commitId": "946df6fc07c39b98599a4e0548ccc9aec3c7c5da", "packageNameBefore": "net.sourceforge.pmd.lang.java.symbols.table.internal", "classNameBefore": "net.sourceforge.pmd.lang.java.symbols.table.internal.AbstractSymbolTable", "methodNameBefore": "net.sourceforge.pmd.lang.java.symbols.table.internal.AbstractSymbolTable#resolveMethodName", "invokedMethod": "methodSignature: net.sourceforge.pmd.lang.java.symbols.table.internal.AbstractSymbolTable#resolveMethodName\n methodBody: public final Stream<JMethodSymbol> resolveMethodName(String simpleName) {\nreturn Stream.<Supplier<Stream<JMethodSymbol>>>of(() -> resolveMethodNameImpl(simpleName),() -> parent.resolveMethodName(simpleName)).flatMap(Supplier::get);\n}\nmethodSignature: net.sourceforge.pmd.lang.java.symbols.table.JSymbolTable#resolveMethodName\n methodBody: Stream<JMethodSymbol> resolveMethodName(String simpleName);\nmethodSignature: net.sourceforge.pmd.lang.java.symbols.table.internal.TypeMemberSymTable#resolveMethodNameImpl\n methodBody: protected Stream<JMethodSymbol> resolveMethodNameImpl(String simpleName) {\nif(simpleName.equals(JConstructorSymbol.CTOR_NAME)){return Stream.empty();\n}return typeSym.getDeclaredMethods(simpleName).stream();\n}\nmethodSignature: net.sourceforge.pmd.lang.java.symbols.table.internal.AbstractSymbolTable#resolveMethodNameImpl\n methodBody: protected Stream<JMethodSymbol> resolveMethodNameImpl(String simpleName) {\nreturn Stream.empty();\n}\nmethodSignature: net.sourceforge.pmd.lang.java.symbols.table.internal.AbstractImportSymbolTable#resolveMethodNameImpl\n methodBody: protected Stream<JMethodSymbol> resolveMethodNameImpl(String simpleName) {\nreturn importedStaticMethods.getOrDefault(simpleName,Collections.emptyList()).stream();\n}\nmethodSignature: net.sourceforge.pmd.lang.java.symbols.table.internal.EmptySymbolTable#resolveMethodName\n methodBody: public Stream<JMethodSymbol> resolveMethodName(String simpleName) {\nreturn Stream.empty();\n}", "classSignatureBefore": "abstract class AbstractSymbolTable implements JSymbolTable ", "methodNameBeforeSet": ["net.sourceforge.pmd.lang.java.symbols.table.internal.AbstractSymbolTable#resolveMethodName"], "classNameBeforeSet": ["net.sourceforge.pmd.lang.java.symbols.table.internal.AbstractSymbolTable"], "classSignatureBeforeSet": ["abstract class AbstractSymbolTable implements JSymbolTable "], "purityCheckResultList": [{"isPure": true, "purityComment": "Identical statements", "description": "There is no replacement! - all mapped", "mappingState": 1}], "sourceCodeBeforeForWhole": "/*\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.lang.java.symbols.table.internal;\n\nimport java.util.function.Supplier;\nimport java.util.stream.Stream;\n\nimport org.checkerframework.checker.nullness.qual.NonNull;\nimport org.checkerframework.checker.nullness.qual.Nullable;\n\nimport net.sourceforge.pmd.lang.java.ast.ASTImportDeclaration;\nimport net.sourceforge.pmd.lang.java.symbols.JClassSymbol;\nimport net.sourceforge.pmd.lang.java.symbols.JMethodSymbol;\nimport net.sourceforge.pmd.lang.java.symbols.JTypeDeclSymbol;\nimport net.sourceforge.pmd.lang.java.symbols.JVariableSymbol;\nimport net.sourceforge.pmd.lang.java.symbols.table.JSymbolTable;\nimport net.sourceforge.pmd.lang.java.symbols.table.ResolveResult;\n\n\n/**\n * Base implementation.\n *\n * @since 7.0.0\n */\nabstract class AbstractSymbolTable implements JSymbolTable {\n\n    /** Additional info about the context. */\n    protected final SymbolTableHelper helper;\n    private final JSymbolTable parent;\n\n    AbstractSymbolTable(JSymbolTable parent, SymbolTableHelper helper) {\n        assert parent != null : \"Null parent!\";\n        assert helper != null : \"Null helper!\";\n\n        this.parent = parent;\n        this.helper = helper;\n    }\n\n\n    @Override\n    @NonNull\n    public final JSymbolTable getParent() {\n        return parent;\n    }\n\n\n    @Nullable\n    @Override\n    public final ResolveResult<JTypeDeclSymbol> resolveTypeName(String simpleName) {\n        @Nullable ResolveResult<JTypeDeclSymbol> result = resolveTypeNameImpl(simpleName);\n        return result != null ? result : parent.resolveTypeName(simpleName);\n    }\n\n\n    @Nullable\n    @Override\n    public final ResolveResult<JVariableSymbol> resolveValueName(String simpleName) {\n        @Nullable ResolveResult<JVariableSymbol> result = resolveValueNameImpl(simpleName);\n        return result != null ? result : parent.resolveValueName(simpleName);\n    }\n\n\n    @Override\n    public final Stream<JMethodSymbol> resolveMethodName(String simpleName) {\n        // This allows the stream contributed by the parent to be resolved lazily,\n        // ie not evaluated unless the stream contributed by this table runs out of values,\n        // a behaviour that Stream.concat can't provide\n\n        return Stream.<Supplier<Stream<JMethodSymbol>>>of(\n            () -> resolveMethodNameImpl(simpleName),\n            () -> parent.resolveMethodName(simpleName)\n        ).flatMap(Supplier::get);\n    }\n\n\n    /** Finds the matching methods among the declarations tracked by this table without asking the parent. */\n    protected Stream<JMethodSymbol> resolveMethodNameImpl(String simpleName) {\n        return Stream.empty();\n    }\n\n    // We could internally avoid using Optional to reduce the number of created optionals as an optimisation\n\n\n    /**\n     * Finds a type name among the declarations tracked by this table without asking the parent.\n     */\n    protected @Nullable ResolveResult<JTypeDeclSymbol> resolveTypeNameImpl(String simpleName) {\n        return ResolveResultImpl.failed();\n    }\n\n\n    /** Finds a value among the declarations tracked by this table without asking the parent. */\n    protected @Nullable ResolveResult<JVariableSymbol> resolveValueNameImpl(String simpleName) {\n        return ResolveResultImpl.failed();\n    }\n\n\n    /**\n     * Tries to load a class and logs it if it is not found.\n     *\n     * @param anImport Node owning the warning\n     * @param fqcn     Binary name of the class to load\n     *\n     * @return The class, or null if it couldn't be resolved\n     */\n    @Nullable\n    final JClassSymbol loadClassReportFailure(ASTImportDeclaration anImport, String fqcn) {\n        JClassSymbol loaded = helper.loadClassOrFail(fqcn);\n        if (loaded == null) {\n            helper.getLogger().warning(anImport, SemanticChecksLogger.CANNOT_FIND_CLASSPATH_SYMBOL, fqcn);\n        }\n\n        return loaded;\n    }\n\n\n    /**\n     * Tries to load a class, not logging failure.\n     *\n     * @param canonicalName Canonical name of the class to load\n     *\n     * @return The class, or null if it couldn't be resolved\n     */\n    @Nullable\n    final JClassSymbol loadClassIgnoreFailure(String canonicalName) {\n        return helper.loadClassOrFail(canonicalName);\n    }\n\n    /**\n     * Returns true if this table doesn't contain any information, and\n     * can be eliminated from the stack entirely.\n     */\n    boolean isPrunable() {\n        // TODO would be better to conside the three channels separate.\n        //  That way local scopes with no class declaration skip directly to type declaration scope\n        return false;\n    }\n}\n", "filePathAfter": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/table/internal/AbstractSymbolTable.java", "sourceCodeAfterForWhole": "/*\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.lang.java.symbols.table.internal;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\nimport org.checkerframework.checker.nullness.qual.NonNull;\nimport org.checkerframework.checker.nullness.qual.Nullable;\n\nimport net.sourceforge.pmd.lang.java.ast.ASTImportDeclaration;\nimport net.sourceforge.pmd.lang.java.symbols.JClassSymbol;\nimport net.sourceforge.pmd.lang.java.symbols.JMethodSymbol;\nimport net.sourceforge.pmd.lang.java.symbols.JTypeDeclSymbol;\nimport net.sourceforge.pmd.lang.java.symbols.JVariableSymbol;\nimport net.sourceforge.pmd.lang.java.symbols.table.JSymbolTable;\nimport net.sourceforge.pmd.lang.java.symbols.table.ResolveResult;\n\n\n/**\n * Base implementation.\n *\n * @since 7.0.0\n */\nabstract class AbstractSymbolTable implements JSymbolTable {\n\n    /** Additional info about the context. */\n    protected final SymbolTableHelper helper;\n    private final JSymbolTable parent;\n\n    AbstractSymbolTable(JSymbolTable parent, SymbolTableHelper helper) {\n        assert parent != null : \"Null parent!\";\n        assert helper != null : \"Null helper!\";\n\n        this.parent = parent;\n        this.helper = helper;\n    }\n\n\n    @Override\n    @NonNull\n    public final JSymbolTable getParent() {\n        return parent;\n    }\n\n\n    @Nullable\n    @Override\n    public final ResolveResult<JTypeDeclSymbol> resolveTypeName(String simpleName) {\n        @Nullable ResolveResult<JTypeDeclSymbol> result = resolveTypeNameImpl(simpleName);\n        return result != null ? result : parent.resolveTypeName(simpleName);\n    }\n\n\n    @Override\n    public final @Nullable ResolveResult<JVariableSymbol> resolveValueName(String simpleName) {\n        @Nullable ResolveResult<JVariableSymbol> result = resolveValueNameImpl(simpleName);\n        return result != null ? result : parent.resolveValueName(simpleName);\n    }\n\n\n    @Override\n    public final List<JMethodSymbol> resolveMethodName(String simpleName) {\n        // the default implementation always returns the parent results\n        // if the table has methods itself, it needs to override this\n        List<JMethodSymbol> result = getCachedMethodResults(simpleName);\n        if (result != null) {\n            return result;\n        }\n        // Otherwise, create the list from the union\n        List<JMethodSymbol> localResult = resolveMethodNamesHere(simpleName);\n        List<JMethodSymbol> parentResult = parent.resolveMethodName(simpleName); // recurse on parent\n        if (localResult.isEmpty()) {\n            result = parentResult; // parent result is already unmodifiable\n        } else {\n            result = localResult;\n            result.addAll(parentResult);\n            result = Collections.unmodifiableList(result);\n        }\n        cacheMethodResult(simpleName, result);\n        return result;\n    }\n\n    /**\n     * Finds the matching methods among the declarations tracked by this\n     * table *without asking the parent*. Returns a mutable list.\n     *\n     * <p>This method is only called if {@link #getCachedMethodResults(String)}\n     * returns a null result. For that reason, that method must be overridden\n     * if this one is to be used.\n     */\n    protected /*Mutable*/List<JMethodSymbol> resolveMethodNamesHere(String simpleName) {\n        // dead code if getCachedMethodResults is not overridden\n        return new ArrayList<>();\n    }\n\n    @Nullable\n    protected List<JMethodSymbol> getCachedMethodResults(String simpleName) {\n        return parent.resolveMethodName(simpleName); // this table is empty\n    }\n\n    protected void cacheMethodResult(String simpleName, List<JMethodSymbol> sigs) {\n        // do nothing, dead code if getCachedMethodResults is not overridden\n    }\n\n    /**\n     * Finds a type name among the declarations tracked by this table without asking the parent.\n     */\n    protected @Nullable ResolveResult<JTypeDeclSymbol> resolveTypeNameImpl(String simpleName) {\n        return null;\n    }\n\n\n    /** Finds a value among the declarations tracked by this table without asking the parent. */\n    protected @Nullable ResolveResult<JVariableSymbol> resolveValueNameImpl(String simpleName) {\n        return null;\n    }\n\n\n    /**\n     * Tries to load a class and logs it if it is not found.\n     *\n     * @param anImport Node owning the warning\n     * @param fqcn     Binary name of the class to load\n     *\n     * @return The class, or null if it couldn't be resolved\n     */\n    @Nullable\n    final JClassSymbol loadClassReportFailure(ASTImportDeclaration anImport, String fqcn) {\n        JClassSymbol loaded = helper.loadClassOrFail(fqcn);\n        if (loaded == null) {\n            helper.getLogger().warning(anImport, SemanticChecksLogger.CANNOT_FIND_CLASSPATH_SYMBOL, fqcn);\n        }\n\n        return loaded;\n    }\n\n\n    /**\n     * Tries to load a class, not logging failure.\n     *\n     * @param canonicalName Canonical name of the class to load\n     *\n     * @return The class, or null if it couldn't be resolved\n     */\n    @Nullable\n    final JClassSymbol loadClassIgnoreFailure(String canonicalName) {\n        return helper.loadClassOrFail(canonicalName);\n    }\n\n    /**\n     * Returns true if this table doesn't contain any information, and\n     * can be eliminated from the stack entirely.\n     */\n    boolean isPrunable() {\n        // TODO would be better to conside the three channels separate.\n        //  That way local scopes with no class declaration skip directly to type declaration scope\n        return false;\n    }\n}\n", "diffSourceCodeSet": ["@Nullable\n    protected List<JMethodSymbol> getCachedMethodResults(String simpleName) {\n        return parent.resolveMethodName(simpleName); // this table is empty\n    }"], "invokedMethodSet": ["methodSignature: net.sourceforge.pmd.lang.java.symbols.table.internal.AbstractSymbolTable#resolveMethodName\n methodBody: public final Stream<JMethodSymbol> resolveMethodName(String simpleName) {\nreturn Stream.<Supplier<Stream<JMethodSymbol>>>of(() -> resolveMethodNameImpl(simpleName),() -> parent.resolveMethodName(simpleName)).flatMap(Supplier::get);\n}", "methodSignature: net.sourceforge.pmd.lang.java.symbols.table.JSymbolTable#resolveMethodName\n methodBody: Stream<JMethodSymbol> resolveMethodName(String simpleName);", "methodSignature: net.sourceforge.pmd.lang.java.symbols.table.internal.TypeMemberSymTable#resolveMethodNameImpl\n methodBody: protected Stream<JMethodSymbol> resolveMethodNameImpl(String simpleName) {\nif(simpleName.equals(JConstructorSymbol.CTOR_NAME)){return Stream.empty();\n}return typeSym.getDeclaredMethods(simpleName).stream();\n}", "methodSignature: net.sourceforge.pmd.lang.java.symbols.table.internal.AbstractSymbolTable#resolveMethodNameImpl\n methodBody: protected Stream<JMethodSymbol> resolveMethodNameImpl(String simpleName) {\nreturn Stream.empty();\n}", "methodSignature: net.sourceforge.pmd.lang.java.symbols.table.internal.AbstractImportSymbolTable#resolveMethodNameImpl\n methodBody: protected Stream<JMethodSymbol> resolveMethodNameImpl(String simpleName) {\nreturn importedStaticMethods.getOrDefault(simpleName,Collections.emptyList()).stream();\n}", "methodSignature: net.sourceforge.pmd.lang.java.symbols.table.internal.EmptySymbolTable#resolveMethodName\n methodBody: public Stream<JMethodSymbol> resolveMethodName(String simpleName) {\nreturn Stream.empty();\n}"], "sourceCodeAfterRefactoring": "@Override\n    public final List<JMethodSymbol> resolveMethodName(String simpleName) {\n        // the default implementation always returns the parent results\n        // if the table has methods itself, it needs to override this\n        List<JMethodSymbol> result = getCachedMethodResults(simpleName);\n        if (result != null) {\n            return result;\n        }\n        // Otherwise, create the list from the union\n        List<JMethodSymbol> localResult = resolveMethodNamesHere(simpleName);\n        List<JMethodSymbol> parentResult = parent.resolveMethodName(simpleName); // recurse on parent\n        if (localResult.isEmpty()) {\n            result = parentResult; // parent result is already unmodifiable\n        } else {\n            result = localResult;\n            result.addAll(parentResult);\n            result = Collections.unmodifiableList(result);\n        }\n        cacheMethodResult(simpleName, result);\n        return result;\n    }\n@Nullable\n    protected List<JMethodSymbol> getCachedMethodResults(String simpleName) {\n        return parent.resolveMethodName(simpleName); // this table is empty\n    }", "diffSourceCode": "    65:     @Override\n-   66:     public final Stream<JMethodSymbol> resolveMethodName(String simpleName) {\n-   67:         // This allows the stream contributed by the parent to be resolved lazily,\n-   68:         // ie not evaluated unless the stream contributed by this table runs out of values,\n-   69:         // a behaviour that Stream.concat can't provide\n-   70: \n-   71:         return Stream.<Supplier<Stream<JMethodSymbol>>>of(\n-   72:             () -> resolveMethodNameImpl(simpleName),\n-   73:             () -> parent.resolveMethodName(simpleName)\n-   74:         ).flatMap(Supplier::get);\n-   75:     }\n-   76: \n-   77: \n-   78:     /** Finds the matching methods among the declarations tracked by this table without asking the parent. */\n-   79:     protected Stream<JMethodSymbol> resolveMethodNameImpl(String simpleName) {\n-   80:         return Stream.empty();\n-   81:     }\n-   82: \n-   83:     // We could internally avoid using Optional to reduce the number of created optionals as an optimisation\n-   84: \n-   85: \n-  100:     /**\n-  101:      * Tries to load a class and logs it if it is not found.\n-  102:      *\n-  103:      * @param anImport Node owning the warning\n+   66:     public final List<JMethodSymbol> resolveMethodName(String simpleName) {\n+   67:         // the default implementation always returns the parent results\n+   68:         // if the table has methods itself, it needs to override this\n+   69:         List<JMethodSymbol> result = getCachedMethodResults(simpleName);\n+   70:         if (result != null) {\n+   71:             return result;\n+   72:         }\n+   73:         // Otherwise, create the list from the union\n+   74:         List<JMethodSymbol> localResult = resolveMethodNamesHere(simpleName);\n+   75:         List<JMethodSymbol> parentResult = parent.resolveMethodName(simpleName); // recurse on parent\n+   76:         if (localResult.isEmpty()) {\n+   77:             result = parentResult; // parent result is already unmodifiable\n+   78:         } else {\n+   79:             result = localResult;\n+   80:             result.addAll(parentResult);\n+   81:             result = Collections.unmodifiableList(result);\n+   82:         }\n+   83:         cacheMethodResult(simpleName, result);\n+   84:         return result;\n+   85:     }\n+  100:     @Nullable\n+  101:     protected List<JMethodSymbol> getCachedMethodResults(String simpleName) {\n+  102:         return parent.resolveMethodName(simpleName); // this table is empty\n+  103:     }\n", "uniqueId": "946df6fc07c39b98599a4e0548ccc9aec3c7c5da_65_75_100_103_65_85", "moveFileExist": true, "testResult": true, "coverageInfo": {"INSTRUCTION": {"missed": 0, "covered": 18}, "LINE": {"missed": 0, "covered": 2}, "COMPLEXITY": {"missed": 0, "covered": 1}, "METHOD": {"missed": 0, "covered": 1}}, "compileResultBefore": true, "compileResultCurrent": true, "compileJDK": 11, "refactoringMinerResult": false, "compileAndTestResult": false, "refactoredCode": "To improve the readability and maintainability of the `resolveMethodName` method, we can extract the logic that creates the stream of suppliers into a separate method. This will make the main method cleaner and more focused on its purpose.\n\nHere\u2019s the refactored code:\n\n```java\n@Override\npublic final Stream<JMethodSymbol> resolveMethodName(String simpleName) {\n    return createMethodNameStream(simpleName);\n}\n\nprivate Stream<JMethodSymbol> createMethodNameStream(String simpleName) {\n    // This allows the stream contributed by the parent to be resolved lazily,\n    // ie not evaluated unless the stream contributed by this table runs out of values,\n    // a behaviour that Stream.concat can't provide\n\n    return Stream.<Supplier<Stream<JMethodSymbol>>>of(\n        () -> resolveMethodNameImpl(simpleName),\n        () -> parent.resolveMethodName(simpleName)\n    ).flatMap(Supplier::get);\n}\n```\n\nThe `createMethodNameStream` method encapsulates the logic for creating the stream of method symbols, making the `resolveMethodName` method cleaner and easier to understand.\n\nHere\u2019s the output in the requested format:\n\n##########################\n```java\nprivate Stream<JMethodSymbol> createMethodNameStream(String simpleName) {\n    // This allows the stream contributed by the parent to be resolved lazily,\n    // ie not evaluated unless the stream contributed by this table runs out of values,\n    // a behaviour that Stream.concat can't provide\n\n    return Stream.<Supplier<Stream<JMethodSymbol>>>of(\n        () -> resolveMethodNameImpl(simpleName),\n        () -> parent.resolveMethodName(simpleName)\n    ).flatMap(Supplier::get);\n}\n```\n##########################", "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to Refactor:\n@Override\n    public final Stream<JMethodSymbol> resolveMethodName(String simpleName) {\n        // This allows the stream contributed by the parent to be resolved lazily,\n        // ie not evaluated unless the stream contributed by this table runs out of values,\n        // a behaviour that Stream.concat can't provide\n\n        return Stream.<Supplier<Stream<JMethodSymbol>>>of(\n            () -> resolveMethodNameImpl(simpleName),\n            () -> parent.resolveMethodName(simpleName)\n        ).flatMap(Supplier::get);\n    }\n\nClass content:\n/*\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.lang.java.symbols.table.internal;\n\nimport java.util.function.Supplier;\nimport java.util.stream.Stream;\n\nimport org.checkerframework.checker.nullness.qual.NonNull;\nimport org.checkerframework.checker.nullness.qual.Nullable;\n\nimport net.sourceforge.pmd.lang.java.ast.ASTImportDeclaration;\nimport net.sourceforge.pmd.lang.java.symbols.JClassSymbol;\nimport net.sourceforge.pmd.lang.java.symbols.JMethodSymbol;\nimport net.sourceforge.pmd.lang.java.symbols.JTypeDeclSymbol;\nimport net.sourceforge.pmd.lang.java.symbols.JVariableSymbol;\nimport net.sourceforge.pmd.lang.java.symbols.table.JSymbolTable;\nimport net.sourceforge.pmd.lang.java.symbols.table.ResolveResult;\n\n\n/**\n * Base implementation.\n *\n * @since 7.0.0\n */\nabstract class AbstractSymbolTable implements JSymbolTable {\n\n    /** Additional info about the context. */\n    protected final SymbolTableHelper helper;\n    private final JSymbolTable parent;\n\n    AbstractSymbolTable(JSymbolTable parent, SymbolTableHelper helper) {\n        assert parent != null : \"Null parent!\";\n        assert helper != null : \"Null helper!\";\n\n        this.parent = parent;\n        this.helper = helper;\n    }\n\n\n    @Override\n    @NonNull\n    public final JSymbolTable getParent() {\n        return parent;\n    }\n\n\n    @Nullable\n    @Override\n    public final ResolveResult<JTypeDeclSymbol> resolveTypeName(String simpleName) {\n        @Nullable ResolveResult<JTypeDeclSymbol> result = resolveTypeNameImpl(simpleName);\n        return result != null ? result : parent.resolveTypeName(simpleName);\n    }\n\n\n    @Nullable\n    @Override\n    public final ResolveResult<JVariableSymbol> resolveValueName(String simpleName) {\n        @Nullable ResolveResult<JVariableSymbol> result = resolveValueNameImpl(simpleName);\n        return result != null ? result : parent.resolveValueName(simpleName);\n    }\n\n\n    @Override\n    public final Stream<JMethodSymbol> resolveMethodName(String simpleName) {\n        // This allows the stream contributed by the parent to be resolved lazily,\n        // ie not evaluated unless the stream contributed by this table runs out of values,\n        // a behaviour that Stream.concat can't provide\n\n        return Stream.<Supplier<Stream<JMethodSymbol>>>of(\n            () -> resolveMethodNameImpl(simpleName),\n            () -> parent.resolveMethodName(simpleName)\n        ).flatMap(Supplier::get);\n    }\n\n\n    /** Finds the matching methods among the declarations tracked by this table without asking the parent. */\n    protected Stream<JMethodSymbol> resolveMethodNameImpl(String simpleName) {\n        return Stream.empty();\n    }\n\n    // We could internally avoid using Optional to reduce the number of created optionals as an optimisation\n\n\n    /**\n     * Finds a type name among the declarations tracked by this table without asking the parent.\n     */\n    protected @Nullable ResolveResult<JTypeDeclSymbol> resolveTypeNameImpl(String simpleName) {\n        return ResolveResultImpl.failed();\n    }\n\n\n    /** Finds a value among the declarations tracked by this table without asking the parent. */\n    protected @Nullable ResolveResult<JVariableSymbol> resolveValueNameImpl(String simpleName) {\n        return ResolveResultImpl.failed();\n    }\n\n\n    /**\n     * Tries to load a class and logs it if it is not found.\n     *\n     * @param anImport Node owning the warning\n     * @param fqcn     Binary name of the class to load\n     *\n     * @return The class, or null if it couldn't be resolved\n     */\n    @Nullable\n    final JClassSymbol loadClassReportFailure(ASTImportDeclaration anImport, String fqcn) {\n        JClassSymbol loaded = helper.loadClassOrFail(fqcn);\n        if (loaded == null) {\n            helper.getLogger().warning(anImport, SemanticChecksLogger.CANNOT_FIND_CLASSPATH_SYMBOL, fqcn);\n        }\n\n        return loaded;\n    }\n\n\n    /**\n     * Tries to load a class, not logging failure.\n     *\n     * @param canonicalName Canonical name of the class to load\n     *\n     * @return The class, or null if it couldn't be resolved\n     */\n    @Nullable\n    final JClassSymbol loadClassIgnoreFailure(String canonicalName) {\n        return helper.loadClassOrFail(canonicalName);\n    }\n\n    /**\n     * Returns true if this table doesn't contain any information, and\n     * can be eliminated from the stack entirely.\n     */\n    boolean isPrunable() {\n        // TODO would be better to conside the three channels separate.\n        //  That way local scopes with no class declaration skip directly to type declaration scope\n        return false;\n    }\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n"}, {"type": "Extract Method", "description": "Extract Method\tpublic size() : int extracted from public getParameterCount() : int in class net.sourceforge.pmd.lang.java.ast.ASTFormalParameters", "diffLocations": [{"filePath": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTFormalParameters.java", "startLine": 27, "endLine": 31, "startColumn": 0, "endColumn": 0}, {"filePath": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTFormalParameters.java", "startLine": 33, "endLine": 39, "startColumn": 0, "endColumn": 0}, {"filePath": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTFormalParameters.java", "startLine": 27, "endLine": 31, "startColumn": 0, "endColumn": 0}], "sourceCodeBeforeRefactoring": "public int getParameterCount() {\n        final List<ASTFormalParameter> parameters = findChildrenOfType(ASTFormalParameter.class);\n        return !parameters.isEmpty() && parameters.get(0).isExplicitReceiverParameter()\n               ? parameters.size() - 1 : parameters.size();\n    }", "filePathBefore": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTFormalParameters.java", "isPureRefactoring": true, "commitId": "80cba026c2ecda9fc7c770cd78df134ca0803e79", "packageNameBefore": "net.sourceforge.pmd.lang.java.ast", "classNameBefore": "net.sourceforge.pmd.lang.java.ast.ASTFormalParameters", "methodNameBefore": "net.sourceforge.pmd.lang.java.ast.ASTFormalParameters#getParameterCount", "invokedMethod": "methodSignature: net.sourceforge.pmd.lang.java.multifile.signature.JavaOperationSignature.Role#get\n methodBody: private static Role get(ASTMethodDeclaration node) {\nif(node.isStatic()){return STATIC;\n}if(isGetterOrSetter(node)){return GETTER_OR_SETTER;\n}{return METHOD;\n}}", "classSignatureBefore": "public class ASTFormalParameters extends AbstractJavaNode implements Iterable<ASTFormalParameter> ", "methodNameBeforeSet": ["net.sourceforge.pmd.lang.java.ast.ASTFormalParameters#getParameterCount"], "classNameBeforeSet": ["net.sourceforge.pmd.lang.java.ast.ASTFormalParameters"], "classSignatureBeforeSet": ["public class ASTFormalParameters extends AbstractJavaNode implements Iterable<ASTFormalParameter> "], "purityCheckResultList": [{"isPure": true, "purityComment": "Identical statements", "description": "There is no replacement! - all mapped", "mappingState": 1}], "sourceCodeBeforeForWhole": "/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.lang.java.ast;\n\nimport java.util.Iterator;\nimport java.util.List;\n\nimport net.sourceforge.pmd.annotation.InternalApi;\n\n\npublic class ASTFormalParameters extends AbstractJavaNode implements Iterable<ASTFormalParameter> {\n\n    @InternalApi\n    @Deprecated\n    public ASTFormalParameters(int id) {\n        super(id);\n    }\n\n    @InternalApi\n    @Deprecated\n    public ASTFormalParameters(JavaParser p, int id) {\n        super(p, id);\n    }\n\n    public int getParameterCount() {\n        final List<ASTFormalParameter> parameters = findChildrenOfType(ASTFormalParameter.class);\n        return !parameters.isEmpty() && parameters.get(0).isExplicitReceiverParameter()\n               ? parameters.size() - 1 : parameters.size();\n    }\n\n    @Override\n    public Object jjtAccept(JavaParserVisitor visitor, Object data) {\n        return visitor.visit(this, data);\n    }\n\n\n    @Override\n    public Iterator<ASTFormalParameter> iterator() {\n        return new NodeChildrenIterator<>(this, ASTFormalParameter.class);\n    }\n}\n", "filePathAfter": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTFormalParameters.java", "sourceCodeAfterForWhole": "/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.lang.java.ast;\n\nimport java.util.Iterator;\nimport java.util.List;\n\nimport net.sourceforge.pmd.annotation.InternalApi;\n\n\npublic class ASTFormalParameters extends AbstractJavaNode implements Iterable<ASTFormalParameter> {\n\n    @InternalApi\n    @Deprecated\n    public ASTFormalParameters(int id) {\n        super(id);\n    }\n\n    @InternalApi\n    @Deprecated\n    public ASTFormalParameters(JavaParser p, int id) {\n        super(p, id);\n    }\n\n    public int size() {\n        final List<ASTFormalParameter> parameters = findChildrenOfType(ASTFormalParameter.class);\n        return !parameters.isEmpty() && parameters.get(0).isExplicitReceiverParameter()\n               ? parameters.size() - 1 : parameters.size();\n    }\n\n    /**\n     * @deprecated for removal. Use {@link #size()} instead.\n     */\n    @Deprecated\n    public int getParameterCount() {\n        return size();\n    }\n\n    @Override\n    public Object jjtAccept(JavaParserVisitor visitor, Object data) {\n        return visitor.visit(this, data);\n    }\n\n\n    @Override\n    public Iterator<ASTFormalParameter> iterator() {\n        return new NodeChildrenIterator<>(this, ASTFormalParameter.class);\n    }\n}\n", "diffSourceCodeSet": ["public int size() {\n        final List<ASTFormalParameter> parameters = findChildrenOfType(ASTFormalParameter.class);\n        return !parameters.isEmpty() && parameters.get(0).isExplicitReceiverParameter()\n               ? parameters.size() - 1 : parameters.size();\n    }"], "invokedMethodSet": ["methodSignature: net.sourceforge.pmd.lang.java.multifile.signature.JavaOperationSignature.Role#get\n methodBody: private static Role get(ASTMethodDeclaration node) {\nif(node.isStatic()){return STATIC;\n}if(isGetterOrSetter(node)){return GETTER_OR_SETTER;\n}{return METHOD;\n}}"], "sourceCodeAfterRefactoring": "/**\n     * @deprecated for removal. Use {@link #size()} instead.\n     */\n    @Deprecated\n    public int getParameterCount() {\n        return size();\n    }\npublic int size() {\n        final List<ASTFormalParameter> parameters = findChildrenOfType(ASTFormalParameter.class);\n        return !parameters.isEmpty() && parameters.get(0).isExplicitReceiverParameter()\n               ? parameters.size() - 1 : parameters.size();\n    }", "diffSourceCode": "-   27:     public int getParameterCount() {\n+   27:     public int size() {\n    28:         final List<ASTFormalParameter> parameters = findChildrenOfType(ASTFormalParameter.class);\n    29:         return !parameters.isEmpty() && parameters.get(0).isExplicitReceiverParameter()\n    30:                ? parameters.size() - 1 : parameters.size();\n    31:     }\n-   33:     @Override\n-   34:     public Object jjtAccept(JavaParserVisitor visitor, Object data) {\n-   35:         return visitor.visit(this, data);\n-   36:     }\n-   37: \n-   38: \n-   39:     @Override\n+   33:     /**\n+   34:      * @deprecated for removal. Use {@link #size()} instead.\n+   35:      */\n+   36:     @Deprecated\n+   37:     public int getParameterCount() {\n+   38:         return size();\n+   39:     }\n", "uniqueId": "80cba026c2ecda9fc7c770cd78df134ca0803e79_27_31_27_31_33_39", "moveFileExist": true, "testResult": true, "coverageInfo": {"INSTRUCTION": {"missed": 0, "covered": 21}, "BRANCH": {"missed": 0, "covered": 4}, "LINE": {"missed": 0, "covered": 3}, "COMPLEXITY": {"missed": 0, "covered": 3}, "METHOD": {"missed": 0, "covered": 1}}, "compileResultBefore": true, "compileResultCurrent": true, "compileJDK": 11, "refactoringMinerResult": false, "compileAndTestResult": false, "refactoredCode": "To improve the readability and maintainability of the `getParameterCount` method, we can extract the logic that determines whether the first parameter is an explicit receiver parameter into a separate method. This will make the `getParameterCount` method clearer and more focused on its primary responsibility.\n\nHere\u2019s the refactored code:\n\n```java\npublic int getParameterCount() {\n    final List<ASTFormalParameter> parameters = findChildrenOfType(ASTFormalParameter.class);\n    return calculateEffectiveParameterCount(parameters);\n}\n\nprivate int calculateEffectiveParameterCount(List<ASTFormalParameter> parameters) {\n    if (parameters.isEmpty()) {\n        return 0;\n    }\n    return parameters.get(0).isExplicitReceiverParameter() ? parameters.size() - 1 : parameters.size();\n}\n```\n\nThe `calculateEffectiveParameterCount` method encapsulates the logic for determining the effective parameter count based on whether the first parameter is an explicit receiver parameter. This makes the `getParameterCount` method cleaner and easier to understand.\n\nHere\u2019s the output in the required format:\n\n##########################\n```java\nprivate int calculateEffectiveParameterCount(List<ASTFormalParameter> parameters) {\n    if (parameters.isEmpty()) {\n        return 0;\n    }\n    return parameters.get(0).isExplicitReceiverParameter() ? parameters.size() - 1 : parameters.size();\n}\n```\n##########################", "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to Refactor:\npublic int getParameterCount() {\n        final List<ASTFormalParameter> parameters = findChildrenOfType(ASTFormalParameter.class);\n        return !parameters.isEmpty() && parameters.get(0).isExplicitReceiverParameter()\n               ? parameters.size() - 1 : parameters.size();\n    }\n\nClass content:\n/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.lang.java.ast;\n\nimport java.util.Iterator;\nimport java.util.List;\n\nimport net.sourceforge.pmd.annotation.InternalApi;\n\n\npublic class ASTFormalParameters extends AbstractJavaNode implements Iterable<ASTFormalParameter> {\n\n    @InternalApi\n    @Deprecated\n    public ASTFormalParameters(int id) {\n        super(id);\n    }\n\n    @InternalApi\n    @Deprecated\n    public ASTFormalParameters(JavaParser p, int id) {\n        super(p, id);\n    }\n\n    public int getParameterCount() {\n        final List<ASTFormalParameter> parameters = findChildrenOfType(ASTFormalParameter.class);\n        return !parameters.isEmpty() && parameters.get(0).isExplicitReceiverParameter()\n               ? parameters.size() - 1 : parameters.size();\n    }\n\n    @Override\n    public Object jjtAccept(JavaParserVisitor visitor, Object data) {\n        return visitor.visit(this, data);\n    }\n\n\n    @Override\n    public Iterator<ASTFormalParameter> iterator() {\n        return new NodeChildrenIterator<>(this, ASTFormalParameter.class);\n    }\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n"}, {"type": "Extract Method", "description": "Extract Method\tprivate getNumericLiteralValue(literal ASTLiteral) : double extracted from public visit(fieldDeclaration ASTFieldDeclaration, data Object) : Object in class net.sourceforge.pmd.lang.java.rule.performance.RedundantFieldInitializerRule", "diffLocations": [{"filePath": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/performance/RedundantFieldInitializerRule.java", "startLine": 33, "endLine": 107, "startColumn": 0, "endColumn": 0}, {"filePath": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/performance/RedundantFieldInitializerRule.java", "startLine": 48, "endLine": 52, "startColumn": 0, "endColumn": 0}, {"filePath": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/performance/RedundantFieldInitializerRule.java", "startLine": 77, "endLine": 88, "startColumn": 0, "endColumn": 0}], "sourceCodeBeforeRefactoring": "@Override\n    public Object visit(ASTFieldDeclaration fieldDeclaration, Object data) {\n        // Finals can only be initialized once.\n        if (fieldDeclaration.isFinal()) {\n            return data;\n        }\n\n        // Look for a match to the following XPath:\n        // VariableDeclarator/VariableInitializer/Expression/PrimaryExpression/PrimaryPrefix/Literal\n        for (ASTVariableDeclarator variableDeclarator : fieldDeclaration\n                .findChildrenOfType(ASTVariableDeclarator.class)) {\n            if (variableDeclarator.getNumChildren() > 1) {\n                final Node variableInitializer = variableDeclarator.getChild(1);\n                if (variableInitializer.getChild(0) instanceof ASTExpression) {\n                    final Node expression = variableInitializer.getChild(0);\n                    final Node primaryExpression;\n                    if (expression.getNumChildren() == 1) {\n                        if (expression.getChild(0) instanceof ASTPrimaryExpression) {\n                            primaryExpression = expression.getChild(0);\n                        } else if (expression.getChild(0) instanceof ASTCastExpression\n                                && expression.getChild(0).getChild(1) instanceof ASTPrimaryExpression) {\n                            primaryExpression = expression.getChild(0).getChild(1);\n                        } else {\n                            continue;\n                        }\n                    } else {\n                        continue;\n                    }\n                    final Node primaryPrefix = primaryExpression.getChild(0);\n                    if (primaryPrefix.getNumChildren() == 1 && primaryPrefix.getChild(0) instanceof ASTLiteral) {\n                        final ASTLiteral literal = (ASTLiteral) primaryPrefix.getChild(0);\n                        if (isRef(fieldDeclaration, variableDeclarator)) {\n                            // Reference type\n                            if (literal.getNumChildren() == 1 && literal.getChild(0) instanceof ASTNullLiteral) {\n                                addViolation(data, variableDeclarator);\n                            }\n                        } else {\n                            // Primitive type\n                            if (literal.getNumChildren() == 1\n                                    && literal.getChild(0) instanceof ASTBooleanLiteral) {\n                                // boolean type\n                                ASTBooleanLiteral booleanLiteral = (ASTBooleanLiteral) literal.getChild(0);\n                                if (!booleanLiteral.isTrue()) {\n                                    addViolation(data, variableDeclarator);\n                                }\n                            } else if (literal.getNumChildren() == 0) {\n                                // numeric type\n                                // Note: Not catching NumberFormatException, as\n                                // it shouldn't be happening on valid source\n                                // code.\n                                Number value = -1;\n                                if (literal.isIntLiteral()) {\n                                    value = literal.getValueAsInt();\n                                } else if (literal.isLongLiteral()) {\n                                    value = literal.getValueAsLong();\n                                } else if (literal.isFloatLiteral()) {\n                                    value = literal.getValueAsFloat();\n                                } else if (literal.isDoubleLiteral()) {\n                                    value = literal.getValueAsDouble();\n                                } else if (literal.isCharLiteral()) {\n                                    value = (int) literal.getImage().charAt(1);\n                                }\n\n                                if (value.doubleValue() == 0) {\n                                    addViolation(data, variableDeclarator);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        return data;\n    }", "filePathBefore": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/performance/RedundantFieldInitializerRule.java", "isPureRefactoring": true, "commitId": "a707d9451325811748061cbd0eeda5207f920cf4", "packageNameBefore": "net.sourceforge.pmd.lang.java.rule.performance", "classNameBefore": "net.sourceforge.pmd.lang.java.rule.performance.RedundantFieldInitializerRule", "methodNameBefore": "net.sourceforge.pmd.lang.java.rule.performance.RedundantFieldInitializerRule#visit", "invokedMethod": "methodSignature: net.sourceforge.pmd.lang.java.rule.performance.RedundantFieldInitializerRule#addViolation\n methodBody: private void addViolation(Object data, ASTVariableDeclarator variableDeclarator) {\nsuper.addViolation(data,variableDeclarator,variableDeclarator.getChild(0).getImage());\n}\nmethodSignature: net.sourceforge.pmd.lang.java.rule.performance.RedundantFieldInitializerRule#isRef\n methodBody: private boolean isRef(ASTFieldDeclaration fieldDeclaration, ASTVariableDeclarator variableDeclarator) {\nNode type=fieldDeclaration.getChild(0).getChild(0);\nif(type instanceof ASTReferenceType){return true;\n}{return ((ASTVariableDeclaratorId)variableDeclarator.getChild(0)).isArray();\n}}", "classSignatureBefore": "public class RedundantFieldInitializerRule extends AbstractJavaRule ", "methodNameBeforeSet": ["net.sourceforge.pmd.lang.java.rule.performance.RedundantFieldInitializerRule#visit"], "classNameBeforeSet": ["net.sourceforge.pmd.lang.java.rule.performance.RedundantFieldInitializerRule"], "classSignatureBeforeSet": ["public class RedundantFieldInitializerRule extends AbstractJavaRule "], "purityCheckResultList": [{"isPure": true, "purityComment": "Identical statements", "description": "There is no replacement! - all mapped", "mappingState": 1}], "sourceCodeBeforeForWhole": "/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.lang.java.rule.performance;\n\nimport net.sourceforge.pmd.lang.ast.Node;\nimport net.sourceforge.pmd.lang.java.ast.ASTBooleanLiteral;\nimport net.sourceforge.pmd.lang.java.ast.ASTCastExpression;\nimport net.sourceforge.pmd.lang.java.ast.ASTExpression;\nimport net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration;\nimport net.sourceforge.pmd.lang.java.ast.ASTLiteral;\nimport net.sourceforge.pmd.lang.java.ast.ASTNullLiteral;\nimport net.sourceforge.pmd.lang.java.ast.ASTPrimaryExpression;\nimport net.sourceforge.pmd.lang.java.ast.ASTReferenceType;\nimport net.sourceforge.pmd.lang.java.ast.ASTVariableDeclarator;\nimport net.sourceforge.pmd.lang.java.ast.ASTVariableDeclaratorId;\nimport net.sourceforge.pmd.lang.java.rule.AbstractJavaRule;\n\n/**\n * Detects redundant field initializers, i.e. the field initializer expressions\n * the JVM would assign by default.\n *\n * @author lucian.ciufudean@gmail.com\n * @since Apr 10, 2009\n */\npublic class RedundantFieldInitializerRule extends AbstractJavaRule {\n\n    public RedundantFieldInitializerRule() {\n        addRuleChainVisit(ASTFieldDeclaration.class);\n    }\n\n    @Override\n    public Object visit(ASTFieldDeclaration fieldDeclaration, Object data) {\n        // Finals can only be initialized once.\n        if (fieldDeclaration.isFinal()) {\n            return data;\n        }\n\n        // Look for a match to the following XPath:\n        // VariableDeclarator/VariableInitializer/Expression/PrimaryExpression/PrimaryPrefix/Literal\n        for (ASTVariableDeclarator variableDeclarator : fieldDeclaration\n                .findChildrenOfType(ASTVariableDeclarator.class)) {\n            if (variableDeclarator.getNumChildren() > 1) {\n                final Node variableInitializer = variableDeclarator.getChild(1);\n                if (variableInitializer.getChild(0) instanceof ASTExpression) {\n                    final Node expression = variableInitializer.getChild(0);\n                    final Node primaryExpression;\n                    if (expression.getNumChildren() == 1) {\n                        if (expression.getChild(0) instanceof ASTPrimaryExpression) {\n                            primaryExpression = expression.getChild(0);\n                        } else if (expression.getChild(0) instanceof ASTCastExpression\n                                && expression.getChild(0).getChild(1) instanceof ASTPrimaryExpression) {\n                            primaryExpression = expression.getChild(0).getChild(1);\n                        } else {\n                            continue;\n                        }\n                    } else {\n                        continue;\n                    }\n                    final Node primaryPrefix = primaryExpression.getChild(0);\n                    if (primaryPrefix.getNumChildren() == 1 && primaryPrefix.getChild(0) instanceof ASTLiteral) {\n                        final ASTLiteral literal = (ASTLiteral) primaryPrefix.getChild(0);\n                        if (isRef(fieldDeclaration, variableDeclarator)) {\n                            // Reference type\n                            if (literal.getNumChildren() == 1 && literal.getChild(0) instanceof ASTNullLiteral) {\n                                addViolation(data, variableDeclarator);\n                            }\n                        } else {\n                            // Primitive type\n                            if (literal.getNumChildren() == 1\n                                    && literal.getChild(0) instanceof ASTBooleanLiteral) {\n                                // boolean type\n                                ASTBooleanLiteral booleanLiteral = (ASTBooleanLiteral) literal.getChild(0);\n                                if (!booleanLiteral.isTrue()) {\n                                    addViolation(data, variableDeclarator);\n                                }\n                            } else if (literal.getNumChildren() == 0) {\n                                // numeric type\n                                // Note: Not catching NumberFormatException, as\n                                // it shouldn't be happening on valid source\n                                // code.\n                                Number value = -1;\n                                if (literal.isIntLiteral()) {\n                                    value = literal.getValueAsInt();\n                                } else if (literal.isLongLiteral()) {\n                                    value = literal.getValueAsLong();\n                                } else if (literal.isFloatLiteral()) {\n                                    value = literal.getValueAsFloat();\n                                } else if (literal.isDoubleLiteral()) {\n                                    value = literal.getValueAsDouble();\n                                } else if (literal.isCharLiteral()) {\n                                    value = (int) literal.getImage().charAt(1);\n                                }\n\n                                if (value.doubleValue() == 0) {\n                                    addViolation(data, variableDeclarator);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        return data;\n    }\n\n    /**\n     * Checks if a FieldDeclaration is a reference type (includes arrays). The\n     * reference information is in the FieldDeclaration for this example:\n     *\n     * <pre>\n     * int[] ia1\n     * </pre>\n     *\n     * and in the VariableDeclarator for this example:\n     *\n     * <pre>\n     * int ia2[];\n     * </pre>\n     *\n     * .\n     *\n     * @param fieldDeclaration\n     *            the field to check.\n     * @param variableDeclarator\n     *            the variable declarator to check.\n     * @return <code>true</code> if the field is a reference. <code>false</code>\n     *         otherwise.\n     */\n    private boolean isRef(ASTFieldDeclaration fieldDeclaration, ASTVariableDeclarator variableDeclarator) {\n        Node type = fieldDeclaration.getChild(0).getChild(0);\n        if (type instanceof ASTReferenceType) {\n            // Reference type, array or otherwise\n            return true;\n        } else {\n            // Primitive array?\n            return ((ASTVariableDeclaratorId) variableDeclarator.getChild(0)).isArray();\n        }\n    }\n\n    private void addViolation(Object data, ASTVariableDeclarator variableDeclarator) {\n        super.addViolation(data, variableDeclarator, variableDeclarator.getChild(0).getImage());\n    }\n}\n", "filePathAfter": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/performance/RedundantFieldInitializerRule.java", "sourceCodeAfterForWhole": "/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.lang.java.rule.performance;\n\nimport java.util.List;\n\nimport net.sourceforge.pmd.lang.java.ast.ASTBooleanLiteral;\nimport net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration;\nimport net.sourceforge.pmd.lang.java.ast.ASTLiteral;\nimport net.sourceforge.pmd.lang.java.ast.ASTNullLiteral;\nimport net.sourceforge.pmd.lang.java.ast.ASTPrimaryPrefix;\nimport net.sourceforge.pmd.lang.java.ast.ASTPrimitiveType;\nimport net.sourceforge.pmd.lang.java.ast.ASTVariableDeclarator;\nimport net.sourceforge.pmd.lang.java.rule.AbstractJavaRule;\n\n/**\n * Detects redundant field initializers, i.e. the field initializer expressions\n * the JVM would assign by default.\n *\n * @author lucian.ciufudean@gmail.com\n * @since Apr 10, 2009\n */\npublic class RedundantFieldInitializerRule extends AbstractJavaRule {\n\n    public RedundantFieldInitializerRule() {\n        addRuleChainVisit(ASTFieldDeclaration.class);\n    }\n\n    @Override\n    public Object visit(ASTFieldDeclaration fieldDeclaration, Object data) {\n        if (declaresNotFinalField(fieldDeclaration)) {\n            List<ASTVariableDeclarator> varDecls = fieldDeclaration.findDescendantsOfType(ASTVariableDeclarator.class);\n            for (ASTVariableDeclarator varDecl : varDecls) {\n                if (hasRedundantInitializer(fieldDeclaration, varDecl)) {\n                    addViolation(data, varDecl);\n                }\n            }\n        }\n        return data;\n    }\n\n    private boolean declaresNotFinalField(ASTFieldDeclaration fieldDeclaration) {\n        return !fieldDeclaration.isFinal();\n    }\n\n    private boolean hasRedundantInitializer(ASTFieldDeclaration fieldDeclaration, ASTVariableDeclarator varDecl) {\n        return declaresFieldOfPrimitiveType(fieldDeclaration)\n                && hasRedundantInitializerOfPrimitive(varDecl)\n                || hasRedundantInitializerOfReference(varDecl);\n    }\n\n    private boolean declaresFieldOfPrimitiveType(ASTFieldDeclaration fieldDeclaration) {\n        return fieldDeclaration.getChild(0).getChild(0) instanceof ASTPrimitiveType;\n    }\n\n    private boolean hasRedundantInitializerOfPrimitive(ASTVariableDeclarator varDecl) {\n        ASTLiteral literal = getLiteralValue(varDecl);\n        if (literal != null) {\n            if (isNumericLiteral(literal)) {\n                return getNumericLiteralValue(literal) == 0;\n            }\n            if (literal.isCharLiteral()) {\n                return hasDefaultCharLiteralValue(literal);\n            }\n            return isDefaultBooleanLiteral(literal);\n        }\n        return false;\n    }\n\n    private boolean isNumericLiteral(ASTLiteral literal) {\n        return literal.isIntLiteral() || literal.isLongLiteral()\n                || literal.isFloatLiteral() || literal.isDoubleLiteral();\n    }\n\n    private double getNumericLiteralValue(ASTLiteral literal) {\n        if (literal.isIntLiteral()) {\n            return literal.getValueAsInt();\n        }\n        if (literal.isLongLiteral()) {\n            return literal.getValueAsLong();\n        }\n        if (literal.isFloatLiteral()) {\n            return literal.getValueAsFloat();\n        }\n        return literal.getValueAsDouble();\n    }\n\n    private boolean hasDefaultCharLiteralValue(ASTLiteral literal) {\n        String img = literal.getImage();\n        return img.contains(\"\\u0000\") || img.contains(\"\\\\0\");\n    }\n\n    private boolean isDefaultBooleanLiteral(ASTLiteral literal) {\n        ASTBooleanLiteral booleanLiteral = literal.getFirstDescendantOfType(ASTBooleanLiteral.class);\n        return booleanLiteral != null && !booleanLiteral.isTrue();\n    }\n\n    private boolean hasRedundantInitializerOfReference(ASTVariableDeclarator varDecl) {\n        ASTLiteral literal = getLiteralValue(varDecl);\n        return literal != null && isNullLiteral(literal);\n    }\n\n    private ASTLiteral getLiteralValue(ASTVariableDeclarator varDecl) {\n        ASTPrimaryPrefix prefix = varDecl.getFirstDescendantOfType(ASTPrimaryPrefix.class);\n        return prefix != null && prefix.getNumChildren() == 1\n                ? prefix.getFirstChildOfType(ASTLiteral.class)\n                : null;\n    }\n\n    private boolean isNullLiteral(ASTLiteral literal) {\n        return literal.getFirstDescendantOfType(ASTNullLiteral.class) != null;\n    }\n}\n", "diffSourceCodeSet": ["private double getNumericLiteralValue(ASTLiteral literal) {\n        if (literal.isIntLiteral()) {\n            return literal.getValueAsInt();\n        }\n        if (literal.isLongLiteral()) {\n            return literal.getValueAsLong();\n        }\n        if (literal.isFloatLiteral()) {\n            return literal.getValueAsFloat();\n        }\n        return literal.getValueAsDouble();\n    }"], "invokedMethodSet": ["methodSignature: net.sourceforge.pmd.lang.java.rule.performance.RedundantFieldInitializerRule#addViolation\n methodBody: private void addViolation(Object data, ASTVariableDeclarator variableDeclarator) {\nsuper.addViolation(data,variableDeclarator,variableDeclarator.getChild(0).getImage());\n}", "methodSignature: net.sourceforge.pmd.lang.java.rule.performance.RedundantFieldInitializerRule#isRef\n methodBody: private boolean isRef(ASTFieldDeclaration fieldDeclaration, ASTVariableDeclarator variableDeclarator) {\nNode type=fieldDeclaration.getChild(0).getChild(0);\nif(type instanceof ASTReferenceType){return true;\n}{return ((ASTVariableDeclaratorId)variableDeclarator.getChild(0)).isArray();\n}}"], "sourceCodeAfterRefactoring": "private boolean hasRedundantInitializer(ASTFieldDeclaration fieldDeclaration, ASTVariableDeclarator varDecl) {\n        return declaresFieldOfPrimitiveType(fieldDeclaration)\n                && hasRedundantInitializerOfPrimitive(varDecl)\n                || hasRedundantInitializerOfReference(varDecl);\n    }\nprivate double getNumericLiteralValue(ASTLiteral literal) {\n        if (literal.isIntLiteral()) {\n            return literal.getValueAsInt();\n        }\n        if (literal.isLongLiteral()) {\n            return literal.getValueAsLong();\n        }\n        if (literal.isFloatLiteral()) {\n            return literal.getValueAsFloat();\n        }\n        return literal.getValueAsDouble();\n    }", "diffSourceCode": "-   33:     @Override\n-   34:     public Object visit(ASTFieldDeclaration fieldDeclaration, Object data) {\n-   35:         // Finals can only be initialized once.\n-   36:         if (fieldDeclaration.isFinal()) {\n-   37:             return data;\n-   38:         }\n-   39: \n-   40:         // Look for a match to the following XPath:\n-   41:         // VariableDeclarator/VariableInitializer/Expression/PrimaryExpression/PrimaryPrefix/Literal\n-   42:         for (ASTVariableDeclarator variableDeclarator : fieldDeclaration\n-   43:                 .findChildrenOfType(ASTVariableDeclarator.class)) {\n-   44:             if (variableDeclarator.getNumChildren() > 1) {\n-   45:                 final Node variableInitializer = variableDeclarator.getChild(1);\n-   46:                 if (variableInitializer.getChild(0) instanceof ASTExpression) {\n-   47:                     final Node expression = variableInitializer.getChild(0);\n-   48:                     final Node primaryExpression;\n-   49:                     if (expression.getNumChildren() == 1) {\n-   50:                         if (expression.getChild(0) instanceof ASTPrimaryExpression) {\n-   51:                             primaryExpression = expression.getChild(0);\n-   52:                         } else if (expression.getChild(0) instanceof ASTCastExpression\n-   53:                                 && expression.getChild(0).getChild(1) instanceof ASTPrimaryExpression) {\n-   54:                             primaryExpression = expression.getChild(0).getChild(1);\n-   55:                         } else {\n-   56:                             continue;\n-   57:                         }\n-   58:                     } else {\n-   59:                         continue;\n-   60:                     }\n-   61:                     final Node primaryPrefix = primaryExpression.getChild(0);\n-   62:                     if (primaryPrefix.getNumChildren() == 1 && primaryPrefix.getChild(0) instanceof ASTLiteral) {\n-   63:                         final ASTLiteral literal = (ASTLiteral) primaryPrefix.getChild(0);\n-   64:                         if (isRef(fieldDeclaration, variableDeclarator)) {\n-   65:                             // Reference type\n-   66:                             if (literal.getNumChildren() == 1 && literal.getChild(0) instanceof ASTNullLiteral) {\n-   67:                                 addViolation(data, variableDeclarator);\n-   68:                             }\n-   69:                         } else {\n-   70:                             // Primitive type\n-   71:                             if (literal.getNumChildren() == 1\n-   72:                                     && literal.getChild(0) instanceof ASTBooleanLiteral) {\n-   73:                                 // boolean type\n-   74:                                 ASTBooleanLiteral booleanLiteral = (ASTBooleanLiteral) literal.getChild(0);\n-   75:                                 if (!booleanLiteral.isTrue()) {\n-   76:                                     addViolation(data, variableDeclarator);\n-   77:                                 }\n-   78:                             } else if (literal.getNumChildren() == 0) {\n-   79:                                 // numeric type\n-   80:                                 // Note: Not catching NumberFormatException, as\n-   81:                                 // it shouldn't be happening on valid source\n-   82:                                 // code.\n-   83:                                 Number value = -1;\n-   84:                                 if (literal.isIntLiteral()) {\n-   85:                                     value = literal.getValueAsInt();\n-   86:                                 } else if (literal.isLongLiteral()) {\n-   87:                                     value = literal.getValueAsLong();\n-   88:                                 } else if (literal.isFloatLiteral()) {\n-   89:                                     value = literal.getValueAsFloat();\n-   90:                                 } else if (literal.isDoubleLiteral()) {\n-   91:                                     value = literal.getValueAsDouble();\n-   92:                                 } else if (literal.isCharLiteral()) {\n-   93:                                     value = (int) literal.getImage().charAt(1);\n-   94:                                 }\n-   95: \n-   96:                                 if (value.doubleValue() == 0) {\n-   97:                                     addViolation(data, variableDeclarator);\n-   98:                                 }\n-   99:                             }\n-  100:                         }\n-  101:                     }\n-  102:                 }\n-  103:             }\n-  104:         }\n-  105: \n-  106:         return data;\n-  107:     }\n+   33:         if (declaresNotFinalField(fieldDeclaration)) {\n+   34:             List<ASTVariableDeclarator> varDecls = fieldDeclaration.findDescendantsOfType(ASTVariableDeclarator.class);\n+   35:             for (ASTVariableDeclarator varDecl : varDecls) {\n+   36:                 if (hasRedundantInitializer(fieldDeclaration, varDecl)) {\n+   37:                     addViolation(data, varDecl);\n+   38:                 }\n+   39:             }\n+   40:         }\n+   41:         return data;\n+   42:     }\n+   43: \n+   44:     private boolean declaresNotFinalField(ASTFieldDeclaration fieldDeclaration) {\n+   45:         return !fieldDeclaration.isFinal();\n+   46:     }\n+   47: \n+   48:     private boolean hasRedundantInitializer(ASTFieldDeclaration fieldDeclaration, ASTVariableDeclarator varDecl) {\n+   49:         return declaresFieldOfPrimitiveType(fieldDeclaration)\n+   50:                 && hasRedundantInitializerOfPrimitive(varDecl)\n+   51:                 || hasRedundantInitializerOfReference(varDecl);\n+   52:     }\n+   53: \n+   54:     private boolean declaresFieldOfPrimitiveType(ASTFieldDeclaration fieldDeclaration) {\n+   55:         return fieldDeclaration.getChild(0).getChild(0) instanceof ASTPrimitiveType;\n+   56:     }\n+   57: \n+   58:     private boolean hasRedundantInitializerOfPrimitive(ASTVariableDeclarator varDecl) {\n+   59:         ASTLiteral literal = getLiteralValue(varDecl);\n+   60:         if (literal != null) {\n+   61:             if (isNumericLiteral(literal)) {\n+   62:                 return getNumericLiteralValue(literal) == 0;\n+   63:             }\n+   64:             if (literal.isCharLiteral()) {\n+   65:                 return hasDefaultCharLiteralValue(literal);\n+   66:             }\n+   67:             return isDefaultBooleanLiteral(literal);\n+   68:         }\n+   69:         return false;\n+   70:     }\n+   71: \n+   72:     private boolean isNumericLiteral(ASTLiteral literal) {\n+   73:         return literal.isIntLiteral() || literal.isLongLiteral()\n+   74:                 || literal.isFloatLiteral() || literal.isDoubleLiteral();\n+   75:     }\n+   76: \n+   77:     private double getNumericLiteralValue(ASTLiteral literal) {\n+   78:         if (literal.isIntLiteral()) {\n+   79:             return literal.getValueAsInt();\n+   80:         }\n+   81:         if (literal.isLongLiteral()) {\n+   82:             return literal.getValueAsLong();\n+   83:         }\n+   84:         if (literal.isFloatLiteral()) {\n+   85:             return literal.getValueAsFloat();\n+   86:         }\n+   87:         return literal.getValueAsDouble();\n+   88:     }\n+   89: \n+   90:     private boolean hasDefaultCharLiteralValue(ASTLiteral literal) {\n+   91:         String img = literal.getImage();\n+   92:         return img.contains(\"\\u0000\") || img.contains(\"\\\\0\");\n+   93:     }\n+   94: \n+   95:     private boolean isDefaultBooleanLiteral(ASTLiteral literal) {\n+   96:         ASTBooleanLiteral booleanLiteral = literal.getFirstDescendantOfType(ASTBooleanLiteral.class);\n+   97:         return booleanLiteral != null && !booleanLiteral.isTrue();\n+   98:     }\n+   99: \n+  100:     private boolean hasRedundantInitializerOfReference(ASTVariableDeclarator varDecl) {\n+  101:         ASTLiteral literal = getLiteralValue(varDecl);\n+  102:         return literal != null && isNullLiteral(literal);\n+  103:     }\n+  104: \n+  105:     private ASTLiteral getLiteralValue(ASTVariableDeclarator varDecl) {\n+  106:         ASTPrimaryPrefix prefix = varDecl.getFirstDescendantOfType(ASTPrimaryPrefix.class);\n+  107:         return prefix != null && prefix.getNumChildren() == 1\n", "uniqueId": "a707d9451325811748061cbd0eeda5207f920cf4_33_107_77_88_48_52", "moveFileExist": true, "testResult": true, "coverageInfo": {"INSTRUCTION": {"missed": 0, "covered": 184}, "BRANCH": {"missed": 8, "covered": 38}, "LINE": {"missed": 0, "covered": 41}, "COMPLEXITY": {"missed": 8, "covered": 16}, "METHOD": {"missed": 0, "covered": 1}}, "compileResultBefore": true, "compileResultCurrent": true, "compileJDK": 11, "refactoringMinerResult": true, "compileAndTestResult": false, "refactoredCode": "To improve the readability, maintainability, and modularity of the provided code, we can extract several parts of the logic into separate methods. This will help to clarify the purpose of each section of the code and make it easier to understand and modify in the future.\n\nHere\u2019s the refactored code with the extracted methods:\n\n```java\n@Override\npublic Object visit(ASTFieldDeclaration fieldDeclaration, Object data) {\n    // Finals can only be initialized once.\n    if (fieldDeclaration.isFinal()) {\n        return data;\n    }\n\n    // Look for a match to the following XPath:\n    // VariableDeclarator/VariableInitializer/Expression/PrimaryExpression/PrimaryPrefix/Literal\n    for (ASTVariableDeclarator variableDeclarator : fieldDeclaration\n            .findChildrenOfType(ASTVariableDeclarator.class)) {\n        if (variableDeclarator.getNumChildren() > 1) {\n            final Node variableInitializer = variableDeclarator.getChild(1);\n            if (variableInitializer.getChild(0) instanceof ASTExpression) {\n                processVariableInitializer(fieldDeclaration, variableDeclarator, variableInitializer, data);\n            }\n        }\n    }\n\n    return data;\n}\n\nprivate void processVariableInitializer(ASTFieldDeclaration fieldDeclaration, ASTVariableDeclarator variableDeclarator, Node variableInitializer, Object data) {\n    final Node expression = variableInitializer.getChild(0);\n    final Node primaryExpression = getPrimaryExpression(expression);\n    if (primaryExpression != null) {\n        final Node primaryPrefix = primaryExpression.getChild(0);\n        if (isLiteralNode(primaryPrefix)) {\n            final ASTLiteral literal = (ASTLiteral) primaryPrefix.getChild(0);\n            checkForViolations(fieldDeclaration, variableDeclarator, literal, data);\n        }\n    }\n}\n\nprivate Node getPrimaryExpression(Node expression) {\n    if (expression.getNumChildren() == 1) {\n        Node child = expression.getChild(0);\n        if (child instanceof ASTPrimaryExpression) {\n            return child;\n        } else if (child instanceof ASTCastExpression && child.getChild(1) instanceof ASTPrimaryExpression) {\n            return child.getChild(1);\n        }\n    }\n    return null;\n}\n\nprivate boolean isLiteralNode(Node primaryPrefix) {\n    return primaryPrefix.getNumChildren() == 1 && primaryPrefix.getChild(0) instanceof ASTLiteral;\n}\n\nprivate void checkForViolations(ASTFieldDeclaration fieldDeclaration, ASTVariableDeclarator variableDeclarator, ASTLiteral literal, Object data) {\n    if (isRef(fieldDeclaration, variableDeclarator)) {\n        checkReferenceTypeViolation(literal, variableDeclarator, data);\n    } else {\n        checkPrimitiveTypeViolation(literal, variableDeclarator, data);\n    }\n}\n\nprivate void checkReferenceTypeViolation(ASTLiteral literal, ASTVariableDeclarator variableDeclarator, Object data) {\n    if (literal.getNumChildren() == 1 && literal.getChild(0) instanceof ASTNullLiteral) {\n        addViolation(data, variableDeclarator);\n    }\n}\n\nprivate void checkPrimitiveTypeViolation(ASTLiteral literal, ASTVariableDeclarator variableDeclarator, Object data) {\n    if (literal.getNumChildren() == 1 && literal.getChild(0) instanceof ASTBooleanLiteral) {\n        ASTBooleanLiteral booleanLiteral = (ASTBooleanLiteral) literal.getChild(0);\n        if (!booleanLiteral.isTrue()) {\n            addViolation(data, variableDeclarator);\n        }\n    } else if (literal.getNumChildren() == 0) {\n        checkNumericTypeViolation(literal, variableDeclarator, data);\n    }\n}\n\nprivate void checkNumericTypeViolation(ASTLiteral literal, ASTVariableDeclarator variableDeclarator, Object data) {\n    Number value = getNumericValue(literal);\n    if (value.doubleValue() == 0) {\n        addViolation(data, variableDeclarator);\n    }\n}\n\nprivate Number getNumericValue(ASTLiteral literal) {\n    if (literal.isIntLiteral()) {\n        return literal.getValueAsInt();\n    } else if (literal.isLongLiteral()) {\n        return literal.getValueAsLong();\n    } else if (literal.isFloatLiteral()) {\n        return literal.getValueAsFloat();\n    } else if (literal.isDoubleLiteral()) {\n        return literal.getValueAsDouble();\n    } else if (literal.isCharLiteral()) {\n        return (int) literal.getImage().charAt(1);\n    }\n    return -1; // Default value if no match\n}\n```\n\n### Explanation of Changes:\n1. **Extracted Methods**: The logic for processing variable initializers, checking for violations, and handling different types of literals has been extracted into separate methods. This makes the main `visit` method cleaner and easier to follow.\n2. **Modularity**: Each method has a single responsibility, which enhances the modularity of the code. This makes it easier to test and maintain.\n3. **Readability**: The code is now more readable, as each method name describes its purpose, allowing future developers to understand the flow of logic without delving into the details of each operation.\n\nThis refactoring improves the overall structure of the code while maintaining its original functionality.", "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to Refactor:\n@Override\n    public Object visit(ASTFieldDeclaration fieldDeclaration, Object data) {\n        // Finals can only be initialized once.\n        if (fieldDeclaration.isFinal()) {\n            return data;\n        }\n\n        // Look for a match to the following XPath:\n        // VariableDeclarator/VariableInitializer/Expression/PrimaryExpression/PrimaryPrefix/Literal\n        for (ASTVariableDeclarator variableDeclarator : fieldDeclaration\n                .findChildrenOfType(ASTVariableDeclarator.class)) {\n            if (variableDeclarator.getNumChildren() > 1) {\n                final Node variableInitializer = variableDeclarator.getChild(1);\n                if (variableInitializer.getChild(0) instanceof ASTExpression) {\n                    final Node expression = variableInitializer.getChild(0);\n                    final Node primaryExpression;\n                    if (expression.getNumChildren() == 1) {\n                        if (expression.getChild(0) instanceof ASTPrimaryExpression) {\n                            primaryExpression = expression.getChild(0);\n                        } else if (expression.getChild(0) instanceof ASTCastExpression\n                                && expression.getChild(0).getChild(1) instanceof ASTPrimaryExpression) {\n                            primaryExpression = expression.getChild(0).getChild(1);\n                        } else {\n                            continue;\n                        }\n                    } else {\n                        continue;\n                    }\n                    final Node primaryPrefix = primaryExpression.getChild(0);\n                    if (primaryPrefix.getNumChildren() == 1 && primaryPrefix.getChild(0) instanceof ASTLiteral) {\n                        final ASTLiteral literal = (ASTLiteral) primaryPrefix.getChild(0);\n                        if (isRef(fieldDeclaration, variableDeclarator)) {\n                            // Reference type\n                            if (literal.getNumChildren() == 1 && literal.getChild(0) instanceof ASTNullLiteral) {\n                                addViolation(data, variableDeclarator);\n                            }\n                        } else {\n                            // Primitive type\n                            if (literal.getNumChildren() == 1\n                                    && literal.getChild(0) instanceof ASTBooleanLiteral) {\n                                // boolean type\n                                ASTBooleanLiteral booleanLiteral = (ASTBooleanLiteral) literal.getChild(0);\n                                if (!booleanLiteral.isTrue()) {\n                                    addViolation(data, variableDeclarator);\n                                }\n                            } else if (literal.getNumChildren() == 0) {\n                                // numeric type\n                                // Note: Not catching NumberFormatException, as\n                                // it shouldn't be happening on valid source\n                                // code.\n                                Number value = -1;\n                                if (literal.isIntLiteral()) {\n                                    value = literal.getValueAsInt();\n                                } else if (literal.isLongLiteral()) {\n                                    value = literal.getValueAsLong();\n                                } else if (literal.isFloatLiteral()) {\n                                    value = literal.getValueAsFloat();\n                                } else if (literal.isDoubleLiteral()) {\n                                    value = literal.getValueAsDouble();\n                                } else if (literal.isCharLiteral()) {\n                                    value = (int) literal.getImage().charAt(1);\n                                }\n\n                                if (value.doubleValue() == 0) {\n                                    addViolation(data, variableDeclarator);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        return data;\n    }\n\nClass content:\n/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.lang.java.rule.performance;\n\nimport net.sourceforge.pmd.lang.ast.Node;\nimport net.sourceforge.pmd.lang.java.ast.ASTBooleanLiteral;\nimport net.sourceforge.pmd.lang.java.ast.ASTCastExpression;\nimport net.sourceforge.pmd.lang.java.ast.ASTExpression;\nimport net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration;\nimport net.sourceforge.pmd.lang.java.ast.ASTLiteral;\nimport net.sourceforge.pmd.lang.java.ast.ASTNullLiteral;\nimport net.sourceforge.pmd.lang.java.ast.ASTPrimaryExpression;\nimport net.sourceforge.pmd.lang.java.ast.ASTReferenceType;\nimport net.sourceforge.pmd.lang.java.ast.ASTVariableDeclarator;\nimport net.sourceforge.pmd.lang.java.ast.ASTVariableDeclaratorId;\nimport net.sourceforge.pmd.lang.java.rule.AbstractJavaRule;\n\n/**\n * Detects redundant field initializers, i.e. the field initializer expressions\n * the JVM would assign by default.\n *\n * @author lucian.ciufudean@gmail.com\n * @since Apr 10, 2009\n */\npublic class RedundantFieldInitializerRule extends AbstractJavaRule {\n\n    public RedundantFieldInitializerRule() {\n        addRuleChainVisit(ASTFieldDeclaration.class);\n    }\n\n    @Override\n    public Object visit(ASTFieldDeclaration fieldDeclaration, Object data) {\n        // Finals can only be initialized once.\n        if (fieldDeclaration.isFinal()) {\n            return data;\n        }\n\n        // Look for a match to the following XPath:\n        // VariableDeclarator/VariableInitializer/Expression/PrimaryExpression/PrimaryPrefix/Literal\n        for (ASTVariableDeclarator variableDeclarator : fieldDeclaration\n                .findChildrenOfType(ASTVariableDeclarator.class)) {\n            if (variableDeclarator.getNumChildren() > 1) {\n                final Node variableInitializer = variableDeclarator.getChild(1);\n                if (variableInitializer.getChild(0) instanceof ASTExpression) {\n                    final Node expression = variableInitializer.getChild(0);\n                    final Node primaryExpression;\n                    if (expression.getNumChildren() == 1) {\n                        if (expression.getChild(0) instanceof ASTPrimaryExpression) {\n                            primaryExpression = expression.getChild(0);\n                        } else if (expression.getChild(0) instanceof ASTCastExpression\n                                && expression.getChild(0).getChild(1) instanceof ASTPrimaryExpression) {\n                            primaryExpression = expression.getChild(0).getChild(1);\n                        } else {\n                            continue;\n                        }\n                    } else {\n                        continue;\n                    }\n                    final Node primaryPrefix = primaryExpression.getChild(0);\n                    if (primaryPrefix.getNumChildren() == 1 && primaryPrefix.getChild(0) instanceof ASTLiteral) {\n                        final ASTLiteral literal = (ASTLiteral) primaryPrefix.getChild(0);\n                        if (isRef(fieldDeclaration, variableDeclarator)) {\n                            // Reference type\n                            if (literal.getNumChildren() == 1 && literal.getChild(0) instanceof ASTNullLiteral) {\n                                addViolation(data, variableDeclarator);\n                            }\n                        } else {\n                            // Primitive type\n                            if (literal.getNumChildren() == 1\n                                    && literal.getChild(0) instanceof ASTBooleanLiteral) {\n                                // boolean type\n                                ASTBooleanLiteral booleanLiteral = (ASTBooleanLiteral) literal.getChild(0);\n                                if (!booleanLiteral.isTrue()) {\n                                    addViolation(data, variableDeclarator);\n                                }\n                            } else if (literal.getNumChildren() == 0) {\n                                // numeric type\n                                // Note: Not catching NumberFormatException, as\n                                // it shouldn't be happening on valid source\n                                // code.\n                                Number value = -1;\n                                if (literal.isIntLiteral()) {\n                                    value = literal.getValueAsInt();\n                                } else if (literal.isLongLiteral()) {\n                                    value = literal.getValueAsLong();\n                                } else if (literal.isFloatLiteral()) {\n                                    value = literal.getValueAsFloat();\n                                } else if (literal.isDoubleLiteral()) {\n                                    value = literal.getValueAsDouble();\n                                } else if (literal.isCharLiteral()) {\n                                    value = (int) literal.getImage().charAt(1);\n                                }\n\n                                if (value.doubleValue() == 0) {\n                                    addViolation(data, variableDeclarator);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        return data;\n    }\n\n    /**\n     * Checks if a FieldDeclaration is a reference type (includes arrays). The\n     * reference information is in the FieldDeclaration for this example:\n     *\n     * <pre>\n     * int[] ia1\n     * </pre>\n     *\n     * and in the VariableDeclarator for this example:\n     *\n     * <pre>\n     * int ia2[];\n     * </pre>\n     *\n     * .\n     *\n     * @param fieldDeclaration\n     *            the field to check.\n     * @param variableDeclarator\n     *            the variable declarator to check.\n     * @return <code>true</code> if the field is a reference. <code>false</code>\n     *         otherwise.\n     */\n    private boolean isRef(ASTFieldDeclaration fieldDeclaration, ASTVariableDeclarator variableDeclarator) {\n        Node type = fieldDeclaration.getChild(0).getChild(0);\n        if (type instanceof ASTReferenceType) {\n            // Reference type, array or otherwise\n            return true;\n        } else {\n            // Primitive array?\n            return ((ASTVariableDeclaratorId) variableDeclarator.getChild(0)).isArray();\n        }\n    }\n\n    private void addViolation(Object data, ASTVariableDeclarator variableDeclarator) {\n        super.addViolation(data, variableDeclarator, variableDeclarator.getChild(0).getImage());\n    }\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n"}, {"type": "Move Method", "description": "Move Method\tprivate keyFor(rv RuleViolation) : String from class net.sourceforge.pmd.Report to private keyFor(rv RuleViolation) : String from class net.sourceforge.pmd.renderers.TextColorRenderer", "diffLocations": [{"filePath": "pmd-core/src/main/java/net/sourceforge/pmd/Report.java", "startLine": 180, "endLine": 183, "startColumn": 0, "endColumn": 0}, {"filePath": "pmd-core/src/main/java/net/sourceforge/pmd/renderers/TextColorRenderer.java", "startLine": 212, "endLine": 214, "startColumn": 0, "endColumn": 0}], "sourceCodeBeforeRefactoring": "private static String keyFor(RuleViolation rv) {\n\n        return StringUtils.isNotBlank(rv.getPackageName()) ? rv.getPackageName() + '.' + rv.getClassName() : \"\";\n    }", "filePathBefore": "pmd-core/src/main/java/net/sourceforge/pmd/Report.java", "isPureRefactoring": true, "commitId": "7db6f3809c07c93729a8183cf80c19a9643d0837", "packageNameBefore": "net.sourceforge.pmd", "classNameBefore": "net.sourceforge.pmd.Report", "methodNameBefore": "net.sourceforge.pmd.Report#keyFor", "invokedMethod": "methodSignature: net.sourceforge.pmd.lang.dfa.report.ClassNode#getClassName\n methodBody: public String getClassName() {\nreturn className;\n}\nmethodSignature: net.sourceforge.pmd.lang.dfa.report.PackageNode#getPackageName\n methodBody: public String getPackageName() {\nreturn this.packageName;\n}", "classSignatureBefore": "public class Report implements Iterable<RuleViolation> ", "methodNameBeforeSet": ["net.sourceforge.pmd.Report#keyFor"], "classNameBeforeSet": ["net.sourceforge.pmd.Report"], "classSignatureBeforeSet": ["public class Report implements Iterable<RuleViolation> "], "purityCheckResultList": [{"isPure": true, "purityComment": "Identical statements", "description": "There is no replacement! - all mapped", "mappingState": 1}], "sourceCodeBeforeForWhole": "/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.io.StringWriter;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\n\nimport org.apache.commons.lang3.StringUtils;\n\nimport net.sourceforge.pmd.lang.dfa.report.ReportTree;\nimport net.sourceforge.pmd.renderers.AbstractAccumulatingRenderer;\nimport net.sourceforge.pmd.util.DateTimeUtil;\nimport net.sourceforge.pmd.util.NumericConstants;\n\n/**\n * A {@link Report} collects all informations during a PMD execution. This\n * includes violations, suppressed violations, metrics, error during processing\n * and configuration errors.\n */\npublic class Report implements Iterable<RuleViolation> {\n\n    /*\n     * The idea is to store the violations in a tree instead of a list, to do\n     * better and faster sort and filter mechanism and to visualize the result\n     * as tree. (ide plugins).\n     */\n    private final ReportTree violationTree = new ReportTree();\n\n    // Note that this and the above data structure are both being maintained for\n    // a bit\n    private final List<RuleViolation> violations = new ArrayList<>();\n    private final List<ThreadSafeReportListener> listeners = new ArrayList<>();\n    private List<ProcessingError> errors;\n    private List<ConfigurationError> configErrors;\n    private long start;\n    private long end;\n    private List<SuppressedViolation> suppressedRuleViolations = new ArrayList<>();\n\n    /**\n     * Creates a new, initialized, empty report for the given file name.\n     *\n     * @param ctx\n     *            The context to use to connect to the report\n     * @param fileName\n     *            the filename used to report any violations\n     * @return the new report\n     */\n    public static Report createReport(RuleContext ctx, String fileName) {\n        Report report = new Report();\n\n        // overtake the listener\n        report.addListeners(ctx.getReport().getListeners());\n\n        ctx.setReport(report);\n        ctx.setSourceCodeFile(new File(fileName));\n        return report;\n    }\n\n    /**\n     * Represents a duration. Useful for reporting processing time.\n     */\n    public static class ReadableDuration {\n        private final long duration;\n\n        /**\n         * Creates a new duration.\n         *\n         * @param duration\n         *            the duration in milliseconds.\n         */\n        public ReadableDuration(long duration) {\n            this.duration = duration;\n        }\n\n        /**\n         * Gets a human readable representation of the duration, such as \"1h 3m\n         * 5s\".\n         *\n         * @return human readable representation of the duration\n         */\n        public String getTime() {\n            return DateTimeUtil.asHoursMinutesSeconds(duration);\n        }\n    }\n\n    /**\n     * Represents a configuration error.\n     */\n    public static class ConfigurationError {\n        private final Rule rule;\n        private final String issue;\n\n        /**\n         * Creates a new configuration error for a specific rule.\n         *\n         * @param theRule\n         *            the rule which is configured wrongly\n         * @param theIssue\n         *            the reason, why the configuration is wrong\n         */\n        public ConfigurationError(Rule theRule, String theIssue) {\n            rule = theRule;\n            issue = theIssue;\n        }\n\n        /**\n         * Gets the wrongly configured rule\n         *\n         * @return the wrongly configured rule\n         */\n        public Rule rule() {\n            return rule;\n        }\n\n        /**\n         * Gets the reason for the configuration error.\n         *\n         * @return the issue\n         */\n        public String issue() {\n            return issue;\n        }\n    }\n\n    /**\n     * Represents a processing error, such as a parse error.\n     */\n    public static class ProcessingError {\n        private final Throwable error;\n        private final String file;\n\n        /**\n         * Creates a new processing error\n         *\n         * @param error\n         *            the error\n         * @param file\n         *            the file during which the error occurred\n         */\n        public ProcessingError(Throwable error, String file) {\n            this.error = error;\n            this.file = file;\n        }\n\n        public String getMsg() {\n            return error.getClass().getSimpleName() + \": \" + error.getMessage();\n        }\n\n        public String getDetail() {\n            try (StringWriter stringWriter = new StringWriter();\n                    PrintWriter writer = new PrintWriter(stringWriter)) {\n                error.printStackTrace(writer);\n                return stringWriter.toString();\n            } catch (IOException e) {\n                // IOException on close - should never happen when using StringWriter\n                throw new RuntimeException(e);\n            }\n        }\n\n        public String getFile() {\n            return file;\n        }\n\n        public Throwable getError() {\n            return error;\n        }\n    }\n\n\n    private static String keyFor(RuleViolation rv) {\n\n        return StringUtils.isNotBlank(rv.getPackageName()) ? rv.getPackageName() + '.' + rv.getClassName() : \"\";\n    }\n\n    /**\n     * Calculate a summary of violation counts per fully classified class name.\n     *\n     * @return violations per class name\n     */\n    public Map<String, Integer> getCountSummary() {\n        Map<String, Integer> summary = new HashMap<>();\n        for (RuleViolation rv : violationTree) {\n            String key = keyFor(rv);\n            Integer o = summary.get(key);\n            summary.put(key, o == null ? NumericConstants.ONE : o + 1);\n        }\n        return summary;\n    }\n\n    public ReportTree getViolationTree() {\n        return this.violationTree;\n    }\n\n    /**\n     * Calculate a summary of violations per rule.\n     *\n     * @return a Map summarizing the Report: String (rule name) -&gt; Integer (count\n     *         of violations)\n     */\n    public Map<String, Integer> getSummary() {\n        Map<String, Integer> summary = new HashMap<>();\n        for (RuleViolation rv : violations) {\n            String name = rv.getRule().getName();\n            if (!summary.containsKey(name)) {\n                summary.put(name, NumericConstants.ZERO);\n            }\n            Integer count = summary.get(name);\n            summary.put(name, count + 1);\n        }\n        return summary;\n    }\n\n    /**\n     * Registers a report listener\n     *\n     * @param listener\n     *            the listener\n     */\n    public void addListener(ThreadSafeReportListener listener) {\n        listeners.add(listener);\n    }\n\n    public List<SuppressedViolation> getSuppressedRuleViolations() {\n        return suppressedRuleViolations;\n    }\n\n    /**\n     * Represents a violation, that has been suppressed.\n     * TODO this should implement RuleViolation\n     */\n    public static class SuppressedViolation {\n        private final RuleViolation rv;\n        private final String userMessage;\n        private final ViolationSuppressor suppressor;\n\n        /**\n         * Creates a suppressed violation.\n         *\n         * @param rv          The violation, that has been suppressed\n         * @param suppressor  The suppressor which suppressed the violation\n         * @param userMessage Any relevant info given by the suppressor\n         */\n        public SuppressedViolation(RuleViolation rv, ViolationSuppressor suppressor, String userMessage) {\n            this.suppressor = suppressor;\n            this.rv = rv;\n            this.userMessage = userMessage;\n        }\n\n        public ViolationSuppressor getSuppressor() {\n            return suppressor;\n        }\n\n        public RuleViolation getRuleViolation() {\n            return this.rv;\n        }\n\n        public String getUserMessage() {\n            return userMessage;\n        }\n    }\n\n\n    public void addSuppressedViolation(SuppressedViolation sv) {\n        suppressedRuleViolations.add(sv);\n    }\n\n    /**\n     * Adds a new rule violation to the report and notify the listeners.\n     *\n     * @param violation\n     *            the violation to add\n     */\n    public void addRuleViolation(RuleViolation violation) {\n        int index = Collections.binarySearch(violations, violation, RuleViolationComparator.INSTANCE);\n        violations.add(index < 0 ? -index - 1 : index, violation);\n        violationTree.addRuleViolation(violation);\n        for (ThreadSafeReportListener listener : listeners) {\n            listener.ruleViolationAdded(violation);\n        }\n    }\n\n    /**\n     * Adds a new configuration error to the report.\n     *\n     * @param error\n     *            the error to add\n     */\n    public void addConfigError(ConfigurationError error) {\n        if (configErrors == null) {\n            configErrors = new ArrayList<>();\n        }\n        configErrors.add(error);\n    }\n\n    /**\n     * Adds a new processing error to the report.\n     *\n     * @param error\n     *            the error to add\n     */\n    public void addError(ProcessingError error) {\n        if (errors == null) {\n            errors = new ArrayList<>();\n        }\n        errors.add(error);\n    }\n\n    /**\n     * Merges the given report into this report. This might be necessary, if a\n     * summary over all violations is needed as PMD creates one report per file\n     * by default.\n     *\n     * @param r\n     *            the report to be merged into this.\n     * @see AbstractAccumulatingRenderer\n     */\n    public void merge(Report r) {\n        Iterator<ProcessingError> i = r.errors();\n        while (i.hasNext()) {\n            addError(i.next());\n        }\n        Iterator<ConfigurationError> ce = r.configErrors();\n        while (ce.hasNext()) {\n            addConfigError(ce.next());\n        }\n        Iterator<RuleViolation> v = r.iterator();\n        while (v.hasNext()) {\n            RuleViolation violation = v.next();\n            int index = Collections.binarySearch(violations, violation, RuleViolationComparator.INSTANCE);\n            violations.add(index < 0 ? -index - 1 : index, violation);\n            violationTree.addRuleViolation(violation);\n        }\n        Iterator<SuppressedViolation> s = r.getSuppressedRuleViolations().iterator();\n        while (s.hasNext()) {\n            suppressedRuleViolations.add(s.next());\n        }\n    }\n\n    public boolean isEmpty() {\n        return !violations.iterator().hasNext() && !hasErrors();\n    }\n\n    /**\n     * Checks whether any processing errors have been reported.\n     *\n     * @return <code>true</code> if there were any processing errors,\n     *         <code>false</code> otherwise\n     */\n    public boolean hasErrors() {\n        return errors != null && !errors.isEmpty();\n    }\n\n    /**\n     * Checks whether any configuration errors have been reported.\n     *\n     * @return <code>true</code> if there were any configuration errors,\n     *         <code>false</code> otherwise\n     */\n    public boolean hasConfigErrors() {\n        return configErrors != null && !configErrors.isEmpty();\n    }\n\n    /**\n     * Checks whether no violations have been reported.\n     *\n     * @return <code>true</code> if no violations have been reported,\n     *         <code>false</code> otherwise\n     */\n    public boolean treeIsEmpty() {\n        return !violationTree.iterator().hasNext();\n    }\n\n    /**\n     * Returns an iteration over the reported violations.\n     *\n     * @return an iterator\n     */\n    public Iterator<RuleViolation> treeIterator() {\n        return violationTree.iterator();\n    }\n\n    @Override\n    public Iterator<RuleViolation> iterator() {\n        return violations.iterator();\n    }\n\n    /**\n     * Returns an iterator of the reported processing errors.\n     *\n     * @return the iterator\n     */\n    public Iterator<ProcessingError> errors() {\n        return errors == null ? Collections.<ProcessingError>emptyIterator() : errors.iterator();\n    }\n\n    /**\n     * Returns an iterator of the reported configuration errors.\n     *\n     * @return the iterator\n     */\n    public Iterator<ConfigurationError> configErrors() {\n        return configErrors == null ? Collections.<ConfigurationError>emptyIterator() : configErrors.iterator();\n    }\n\n    /**\n     * The number of violations.\n     *\n     * @return number of violations.\n     */\n    public int treeSize() {\n        return violationTree.size();\n    }\n\n    /**\n     * The number of violations.\n     *\n     * @return number of violations.\n     */\n    public int size() {\n        return violations.size();\n    }\n\n    /**\n     * Mark the start time of the report. This is used to get the elapsed time\n     * in the end.\n     *\n     * @see #getElapsedTimeInMillis()\n     */\n    public void start() {\n        start = System.currentTimeMillis();\n    }\n\n    /**\n     * Mark the end time of the report. This is ued to get the elapsed time.\n     *\n     * @see #getElapsedTimeInMillis()\n     */\n    public void end() {\n        end = System.currentTimeMillis();\n    }\n\n    public long getElapsedTimeInMillis() {\n        return end - start;\n    }\n\n    public List<ThreadSafeReportListener> getListeners() {\n        return listeners;\n    }\n\n    /**\n     * Adds all given listeners to this report\n     *\n     * @param allListeners\n     *            the report listeners\n     */\n    public void addListeners(List<ThreadSafeReportListener> allListeners) {\n        listeners.addAll(allListeners);\n    }\n}\n", "filePathAfter": "pmd-core/src/main/java/net/sourceforge/pmd/renderers/TextColorRenderer.java", "sourceCodeAfterForWhole": "/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.renderers;\n\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.Reader;\nimport java.nio.charset.Charset;\nimport java.nio.file.Files;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.Map;\n\nimport org.apache.commons.lang3.StringUtils;\n\nimport net.sourceforge.pmd.PMD;\nimport net.sourceforge.pmd.Report;\nimport net.sourceforge.pmd.RuleViolation;\nimport net.sourceforge.pmd.properties.PropertyDescriptor;\nimport net.sourceforge.pmd.properties.PropertyFactory;\nimport net.sourceforge.pmd.util.NumericConstants;\n\n/**\n * <p>\n * A console renderer with optional color support under *nix systems.\n * </p>\n *\n * <pre>\n * * file: ./src/gilot/Test.java\n *     src:  Test.java:12\n *     rule: AtLeastOneConstructor\n *     msg:  Each class should declare at least one constructor\n *     code: public class Test\n *\n * * file: ./src/gilot/log/format/LogInterpreter.java\n *     src:  LogInterpreter.java:317\n *     rule: AvoidDuplicateLiterals\n *     msg:  The same String literal appears 4 times in this file; the first occurrence is on line 317\n *     code: logger.error( \"missing attribute 'app_arg' in rule '\" + ((Element)element.getParent()).getAttributeValue( \"name\" ) + \"'\" );\n *\n *     src:  LogInterpreter.java:317\n *     rule: AvoidDuplicateLiterals\n *     msg:  The same String literal appears 5 times in this file; the first occurrence is on line 317\n *     code: logger.error( \"missing attribute 'app_arg' in rule '\" + ((Element)element.getParent()).getAttributeValue( \"name\" ) + \"'\" );\n * * warnings: 3\n * </pre>\n * <p>\n * Colorization is turned on by supplying -D<b>pmd.color</b> - any value other\n * than '0' or 'false', enables color - including an empty value (''). <b>Nota\n * Bene:</b> colorization is atm only supported under *nix terminals accepting\n * ansi escape sequences, such as xterm, rxvt et cetera.\n * </p>\n */\npublic class TextColorRenderer extends AbstractAccumulatingRenderer {\n\n    public static final String NAME = \"textcolor\";\n\n    // What? TODO 7.0.0 Use a boolean property\n    // TODO should the \"textcolor\" renderer really support \"optional\" colors?\n    //   either use text or textcolor...\n    //   This property is really weird, the standard boolean properties\n    //   are false unless value is exactly \"true\", this one is true unless\n    //   \"false\" or \"0\"...\n    public static final PropertyDescriptor<String> COLOR = PropertyFactory.stringProperty(\"color\").desc(\"Enables colors with anything other than 'false' or '0'.\").defaultValue(\"yes\").build();\n    private static final String SYSTEM_PROPERTY_PMD_COLOR = \"pmd.color\";\n\n    /**\n     * Directory from where java was invoked.\n     */\n    private String pwd;\n\n    private String yellowBold = \"\";\n    private String whiteBold = \"\";\n    private String redBold = \"\";\n    private String red = \"\";\n    private String cyan = \"\";\n    private String green = \"\";\n\n    private String colorReset = \"\";\n\n    public TextColorRenderer() {\n        // This Renderer was originally submitted by Adrian Papari and was\n        // called the \"PapariTextRenderer\" pre-PMD 5.0.\n        super(NAME, \"Text format, with color support (requires ANSI console support, e.g. xterm, rxvt, etc.).\");\n        definePropertyDescriptor(COLOR);\n    }\n\n    @Override\n    public String defaultFileExtension() {\n        return \"txt\";\n    }\n\n    /**\n     * Enables colors on *nix systems - not windows. Color support depends on\n     * the pmd.color property, which should be set with the -D option during\n     * execution - a set value other than 'false' or '0' enables color.\n     * <p/>\n     * btw, is it possible to do this on windows (ie; console colors)?\n     */\n    private void initializeColorsIfSupported() {\n        if (isPropertyEnabled(getProperty(COLOR)) || isPropertyEnabled(System.getProperty(SYSTEM_PROPERTY_PMD_COLOR))) {\n            this.yellowBold = \"\\u001B[1;33m\";\n            this.whiteBold = \"\\u001B[1;37m\";\n            this.redBold = \"\\u001B[1;31m\";\n            this.red = \"\\u001B[0;31m\";\n            this.green = \"\\u001B[0;32m\";\n            this.cyan = \"\\u001B[0;36m\";\n\n            this.colorReset = \"\\u001B[0m\";\n        }\n    }\n\n    private boolean isPropertyEnabled(String property) {\n        return property != null && !(\"0\".equals(property) || \"false\".equalsIgnoreCase(property));\n    }\n\n    @Override\n    public void end() throws IOException {\n        StringBuilder buf = new StringBuilder(500);\n        buf.append(PMD.EOL);\n        initializeColorsIfSupported();\n        String lastFile = null;\n        int numberOfErrors = 0;\n        int numberOfWarnings = 0;\n\n        for (Iterator<RuleViolation> i = report.iterator(); i.hasNext();) {\n            buf.setLength(0);\n            numberOfWarnings++;\n            RuleViolation rv = i.next();\n            String nextFile = determineFileName(rv.getFilename());\n            if (!nextFile.equals(lastFile)) {\n                lastFile = nextFile;\n                buf.append(this.yellowBold + \"*\" + this.colorReset + \" file: \" + this.whiteBold\n                        + this.getRelativePath(lastFile) + this.colorReset + PMD.EOL);\n            }\n            buf.append(\n                    this.green + \"    src:  \" + this.cyan + lastFile.substring(lastFile.lastIndexOf(File.separator) + 1)\n                            + this.colorReset + \":\" + this.cyan + rv.getBeginLine()\n                            + (rv.getEndLine() == -1 ? \"\" : \":\" + rv.getEndLine()) + this.colorReset + PMD.EOL);\n            buf.append(this.green + \"    rule: \" + this.colorReset + rv.getRule().getName() + PMD.EOL);\n            buf.append(this.green + \"    msg:  \" + this.colorReset + rv.getDescription() + PMD.EOL);\n            buf.append(this.green + \"    code: \" + this.colorReset + this.getLine(lastFile, rv.getBeginLine()) + PMD.EOL\n                    + PMD.EOL);\n            writer.write(buf.toString());\n        }\n        writer.write(PMD.EOL + PMD.EOL);\n        writer.write(\"Summary:\" + PMD.EOL + PMD.EOL);\n        for (Map.Entry<String, Integer> entry : getCountSummary(report).entrySet()) {\n            buf.setLength(0);\n            String key = entry.getKey();\n            buf.append(key).append(\" : \").append(entry.getValue()).append(PMD.EOL);\n            writer.write(buf.toString());\n        }\n\n        for (Iterator<Report.ProcessingError> i = report.errors(); i.hasNext();) {\n            buf.setLength(0);\n            numberOfErrors++;\n            Report.ProcessingError error = i.next();\n            String nextFile = determineFileName(error.getFile());\n            if (!nextFile.equals(lastFile)) {\n                lastFile = nextFile;\n                buf.append(this.redBold + \"*\" + this.colorReset + \" file: \" + this.whiteBold\n                        + this.getRelativePath(lastFile) + this.colorReset + PMD.EOL);\n            }\n            buf.append(this.green + \"    err:  \" + this.cyan + error.getMsg() + this.colorReset + PMD.EOL)\n                .append(this.red).append(error.getDetail()).append(colorReset).append(PMD.EOL).append(PMD.EOL);\n            writer.write(buf.toString());\n        }\n\n        for (Iterator<Report.ConfigurationError> i = report.configErrors(); i.hasNext();) {\n            buf.setLength(0);\n            numberOfErrors++;\n            Report.ConfigurationError error = i.next();\n            buf.append(this.redBold + \"*\" + this.colorReset + \" rule: \" + this.whiteBold\n                    + error.rule().getName() + this.colorReset + PMD.EOL);\n            buf.append(this.green + \"    err:  \" + this.cyan + error.issue() + this.colorReset + PMD.EOL + PMD.EOL);\n            writer.write(buf.toString());\n        }\n\n        // adding error message count, if any\n        if (numberOfErrors > 0) {\n            writer.write(this.redBold + \"*\" + this.colorReset + \" errors:   \" + this.whiteBold + numberOfErrors\n                             + this.colorReset + PMD.EOL);\n        }\n        writer.write(this.yellowBold + \"*\" + this.colorReset + \" warnings: \" + this.whiteBold + numberOfWarnings\n                         + this.colorReset + PMD.EOL);\n    }\n\n\n    /**\n     * Calculate a summary of violation counts per fully classified class name.\n     *\n     * @return violations per class name\n     */\n    private static Map<String, Integer> getCountSummary(Report report) {\n        Map<String, Integer> summary = new HashMap<>();\n        for (RuleViolation rv : report) {\n            String key = keyFor(rv);\n            if (key.isEmpty()) {\n                continue;\n            }\n            Integer o = summary.get(key);\n            summary.put(key, o == null ? NumericConstants.ONE : o + 1);\n        }\n        return summary;\n    }\n\n    private static String keyFor(RuleViolation rv) {\n        return StringUtils.isNotBlank(rv.getPackageName()) ? rv.getPackageName() + '.' + rv.getClassName() : \"\";\n    }\n\n\n    /**\n     * Retrieves the requested line from the specified file.\n     *\n     * @param sourceFile the java or cpp source file\n     * @param line       line number to extract\n     *\n     * @return a trimmed line of source code\n     */\n    private String getLine(String sourceFile, int line) {\n        String code = null;\n        try (BufferedReader br = new BufferedReader(getReader(sourceFile))) {\n            for (int i = 0; line > i; i++) {\n                String txt = br.readLine();\n                code = txt == null ? \"\" : txt.trim();\n            }\n        } catch (IOException ioErr) {\n            ioErr.printStackTrace();\n        }\n        return code;\n    }\n\n    protected Reader getReader(String sourceFile) throws FileNotFoundException {\n        try {\n            return Files.newBufferedReader(new File(sourceFile).toPath(), Charset.defaultCharset());\n        } catch (IOException e) {\n            FileNotFoundException ex = new FileNotFoundException(sourceFile);\n            ex.initCause(e);\n            throw ex;\n        }\n    }\n\n    /**\n     * Attempts to determine the relative path to the file. If relative path\n     * cannot be found, the original path is returnedi, ie - the current path\n     * for the supplied file.\n     *\n     * @param fileName\n     *            well, the file with its original path.\n     * @return the relative path to the file\n     */\n    private String getRelativePath(String fileName) {\n        String relativePath;\n\n        // check if working directory need to be assigned\n        if (pwd == null) {\n            try {\n                this.pwd = new File(\".\").getCanonicalPath();\n            } catch (IOException ioErr) {\n                // to avoid further error\n                this.pwd = \"\";\n            }\n        }\n\n        // make sure that strings match before doing any substring-ing\n        if (fileName.indexOf(this.pwd) == 0) {\n            relativePath = \".\" + fileName.substring(this.pwd.length());\n\n            // remove current dir occuring twice - occurs if . was supplied as\n            // path\n            if (relativePath.startsWith(\".\" + File.separator + \".\" + File.separator)) {\n                relativePath = relativePath.substring(2);\n            }\n        } else {\n            // this happens when pmd's supplied argument deviates from the pwd\n            // 'branch' (god knows this terminolgy - i hope i make some sense).\n            // for instance, if supplied=/usr/lots/of/src and\n            // pwd=/usr/lots/of/shared/source\n            // TODO: a fix to get relative path?\n            relativePath = fileName;\n        }\n\n        return relativePath;\n    }\n}\n", "diffSourceCodeSet": [], "invokedMethodSet": ["methodSignature: net.sourceforge.pmd.lang.dfa.report.ClassNode#getClassName\n methodBody: public String getClassName() {\nreturn className;\n}", "methodSignature: net.sourceforge.pmd.lang.dfa.report.PackageNode#getPackageName\n methodBody: public String getPackageName() {\nreturn this.packageName;\n}"], "sourceCodeAfterRefactoring": "private static String keyFor(RuleViolation rv) {\n        return StringUtils.isNotBlank(rv.getPackageName()) ? rv.getPackageName() + '.' + rv.getClassName() : \"\";\n    }", "diffSourceCode": "-  180:     private static String keyFor(RuleViolation rv) {\n-  181: \n-  182:         return StringUtils.isNotBlank(rv.getPackageName()) ? rv.getPackageName() + '.' + rv.getClassName() : \"\";\n-  183:     }\n-  212:         for (RuleViolation rv : violations) {\n-  213:             String name = rv.getRule().getName();\n-  214:             if (!summary.containsKey(name)) {\n+  180:             buf.append(this.green + \"    err:  \" + this.cyan + error.issue() + this.colorReset + PMD.EOL + PMD.EOL);\n+  181:             writer.write(buf.toString());\n+  182:         }\n+  183: \n+  212:     private static String keyFor(RuleViolation rv) {\n+  213:         return StringUtils.isNotBlank(rv.getPackageName()) ? rv.getPackageName() + '.' + rv.getClassName() : \"\";\n+  214:     }\n", "uniqueId": "7db6f3809c07c93729a8183cf80c19a9643d0837_180_183__212_214", "moveFileExist": true, "testResult": true, "coverageInfo": {"INSTRUCTION": {"missed": 13, "covered": 6}, "BRANCH": {"missed": 1, "covered": 1}, "LINE": {"missed": 0, "covered": 1}, "COMPLEXITY": {"missed": 1, "covered": 1}, "METHOD": {"missed": 0, "covered": 1}}, "compileResultBefore": true, "compileResultCurrent": true, "compileJDK": 11, "refactoringMinerResult": true, "compileAndTestResult": false, "refactoredCode": "To refactor the provided code by moving the `keyFor` method to an appropriate existing class, we will analyze the project structure and identify a suitable target file. \n\n### Analysis\nThe `keyFor` method is a utility function that constructs a key based on the package name and class name of a `RuleViolation`. This type of utility function is often best placed in a utility class that deals with `RuleViolation` or similar entities.\n\n### Target Class\nGiven the project structure, the `RuleViolation` class seems to be a logical place to move the `keyFor` method, as it directly relates to the data being processed. \n\n### Moved Method Code\nWe will move the `keyFor` method to the `RuleViolation` class and make it a public static method.\n\n### Refactored Method Code\nAfter moving the method, we will update the `Report` class to call the new method from the `RuleViolation` class.\n\n### Implementation\n\n1. **Target File Path**: `pmd-core/src/main/java/net/sourceforge/pmd/RuleViolation.java`\n2. **Moved Class Code**:\n```java\npackage net.sourceforge.pmd;\n\nimport org.apache.commons.lang3.StringUtils;\n\npublic class RuleViolation {\n    // Existing fields and methods...\n\n    public static String keyFor(RuleViolation rv) {\n        return StringUtils.isNotBlank(rv.getPackageName()) ? rv.getPackageName() + '.' + rv.getClassName() : \"\";\n    }\n}\n```\n\n3. **Refactored Method Code** in `Report` class:\n```java\nprivate static String keyFor(RuleViolation rv) {\n    return RuleViolation.keyFor(rv);\n}\n```\n\n### Output\nHere is the output in the specified format:\n\n##########################\npmd-core/src/main/java/net/sourceforge/pmd/RuleViolation.java\n##########################\npublic class RuleViolation {\n    // Existing fields and methods...\n\n    public static String keyFor(RuleViolation rv) {\n        return StringUtils.isNotBlank(rv.getPackageName()) ? rv.getPackageName() + '.' + rv.getClassName() : \"\";\n    }\n}\n##########################\nprivate static String keyFor(RuleViolation rv) {\n    return RuleViolation.keyFor(rv);\n}\n##########################", "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to Refactor:\nprivate static String keyFor(RuleViolation rv) {\n\n        return StringUtils.isNotBlank(rv.getPackageName()) ? rv.getPackageName() + '.' + rv.getClassName() : \"\";\n    }\n\nClass content:\n/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.io.StringWriter;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\n\nimport org.apache.commons.lang3.StringUtils;\n\nimport net.sourceforge.pmd.lang.dfa.report.ReportTree;\nimport net.sourceforge.pmd.renderers.AbstractAccumulatingRenderer;\nimport net.sourceforge.pmd.util.DateTimeUtil;\nimport net.sourceforge.pmd.util.NumericConstants;\n\n/**\n * A {@link Report} collects all informations during a PMD execution. This\n * includes violations, suppressed violations, metrics, error during processing\n * and configuration errors.\n */\npublic class Report implements Iterable<RuleViolation> {\n\n    /*\n     * The idea is to store the violations in a tree instead of a list, to do\n     * better and faster sort and filter mechanism and to visualize the result\n     * as tree. (ide plugins).\n     */\n    private final ReportTree violationTree = new ReportTree();\n\n    // Note that this and the above data structure are both being maintained for\n    // a bit\n    private final List<RuleViolation> violations = new ArrayList<>();\n    private final List<ThreadSafeReportListener> listeners = new ArrayList<>();\n    private List<ProcessingError> errors;\n    private List<ConfigurationError> configErrors;\n    private long start;\n    private long end;\n    private List<SuppressedViolation> suppressedRuleViolations = new ArrayList<>();\n\n    /**\n     * Creates a new, initialized, empty report for the given file name.\n     *\n     * @param ctx\n     *            The context to use to connect to the report\n     * @param fileName\n     *            the filename used to report any violations\n     * @return the new report\n     */\n    public static Report createReport(RuleContext ctx, String fileName) {\n        Report report = new Report();\n\n        // overtake the listener\n        report.addListeners(ctx.getReport().getListeners());\n\n        ctx.setReport(report);\n        ctx.setSourceCodeFile(new File(fileName));\n        return report;\n    }\n\n    /**\n     * Represents a duration. Useful for reporting processing time.\n     */\n    public static class ReadableDuration {\n        private final long duration;\n\n        /**\n         * Creates a new duration.\n         *\n         * @param duration\n         *            the duration in milliseconds.\n         */\n        public ReadableDuration(long duration) {\n            this.duration = duration;\n        }\n\n        /**\n         * Gets a human readable representation of the duration, such as \"1h 3m\n         * 5s\".\n         *\n         * @return human readable representation of the duration\n         */\n        public String getTime() {\n            return DateTimeUtil.asHoursMinutesSeconds(duration);\n        }\n    }\n\n    /**\n     * Represents a configuration error.\n     */\n    public static class ConfigurationError {\n        private final Rule rule;\n        private final String issue;\n\n        /**\n         * Creates a new configuration error for a specific rule.\n         *\n         * @param theRule\n         *            the rule which is configured wrongly\n         * @param theIssue\n         *            the reason, why the configuration is wrong\n         */\n        public ConfigurationError(Rule theRule, String theIssue) {\n            rule = theRule;\n            issue = theIssue;\n        }\n\n        /**\n         * Gets the wrongly configured rule\n         *\n         * @return the wrongly configured rule\n         */\n        public Rule rule() {\n            return rule;\n        }\n\n        /**\n         * Gets the reason for the configuration error.\n         *\n         * @return the issue\n         */\n        public String issue() {\n            return issue;\n        }\n    }\n\n    /**\n     * Represents a processing error, such as a parse error.\n     */\n    public static class ProcessingError {\n        private final Throwable error;\n        private final String file;\n\n        /**\n         * Creates a new processing error\n         *\n         * @param error\n         *            the error\n         * @param file\n         *            the file during which the error occurred\n         */\n        public ProcessingError(Throwable error, String file) {\n            this.error = error;\n            this.file = file;\n        }\n\n        public String getMsg() {\n            return error.getClass().getSimpleName() + \": \" + error.getMessage();\n        }\n\n        public String getDetail() {\n            try (StringWriter stringWriter = new StringWriter();\n                    PrintWriter writer = new PrintWriter(stringWriter)) {\n                error.printStackTrace(writer);\n                return stringWriter.toString();\n            } catch (IOException e) {\n                // IOException on close - should never happen when using StringWriter\n                throw new RuntimeException(e);\n            }\n        }\n\n        public String getFile() {\n            return file;\n        }\n\n        public Throwable getError() {\n            return error;\n        }\n    }\n\n\n    private static String keyFor(RuleViolation rv) {\n\n        return StringUtils.isNotBlank(rv.getPackageName()) ? rv.getPackageName() + '.' + rv.getClassName() : \"\";\n    }\n\n    /**\n     * Calculate a summary of violation counts per fully classified class name.\n     *\n     * @return violations per class name\n     */\n    public Map<String, Integer> getCountSummary() {\n        Map<String, Integer> summary = new HashMap<>();\n        for (RuleViolation rv : violationTree) {\n            String key = keyFor(rv);\n            Integer o = summary.get(key);\n            summary.put(key, o == null ? NumericConstants.ONE : o + 1);\n        }\n        return summary;\n    }\n\n    public ReportTree getViolationTree() {\n        return this.violationTree;\n    }\n\n    /**\n     * Calculate a summary of violations per rule.\n     *\n     * @return a Map summarizing the Report: String (rule name) -&gt; Integer (count\n     *         of violations)\n     */\n    public Map<String, Integer> getSummary() {\n        Map<String, Integer> summary = new HashMap<>();\n        for (RuleViolation rv : violations) {\n            String name = rv.getRule().getName();\n            if (!summary.containsKey(name)) {\n                summary.put(name, NumericConstants.ZERO);\n            }\n            Integer count = summary.get(name);\n            summary.put(name, count + 1);\n        }\n        return summary;\n    }\n\n    /**\n     * Registers a report listener\n     *\n     * @param listener\n     *            the listener\n     */\n    public void addListener(ThreadSafeReportListener listener) {\n        listeners.add(listener);\n    }\n\n    public List<SuppressedViolation> getSuppressedRuleViolations() {\n        return suppressedRuleViolations;\n    }\n\n    /**\n     * Represents a violation, that has been suppressed.\n     * TODO this should implement RuleViolation\n     */\n    public static class SuppressedViolation {\n        private final RuleViolation rv;\n        private final String userMessage;\n        private final ViolationSuppressor suppressor;\n\n        /**\n         * Creates a suppressed violation.\n         *\n         * @param rv          The violation, that has been suppressed\n         * @param suppressor  The suppressor which suppressed the violation\n         * @param userMessage Any relevant info given by the suppressor\n         */\n        public SuppressedViolation(RuleViolation rv, ViolationSuppressor suppressor, String userMessage) {\n            this.suppressor = suppressor;\n            this.rv = rv;\n            this.userMessage = userMessage;\n        }\n\n        public ViolationSuppressor getSuppressor() {\n            return suppressor;\n        }\n\n        public RuleViolation getRuleViolation() {\n            return this.rv;\n        }\n\n        public String getUserMessage() {\n            return userMessage;\n        }\n    }\n\n\n    public void addSuppressedViolation(SuppressedViolation sv) {\n        suppressedRuleViolations.add(sv);\n    }\n\n    /**\n     * Adds a new rule violation to the report and notify the listeners.\n     *\n     * @param violation\n     *            the violation to add\n     */\n    public void addRuleViolation(RuleViolation violation) {\n        int index = Collections.binarySearch(violations, violation, RuleViolationComparator.INSTANCE);\n        violations.add(index < 0 ? -index - 1 : index, violation);\n        violationTree.addRuleViolation(violation);\n        for (ThreadSafeReportListener listener : listeners) {\n            listener.ruleViolationAdded(violation);\n        }\n    }\n\n    /**\n     * Adds a new configuration error to the report.\n     *\n     * @param error\n     *            the error to add\n     */\n    public void addConfigError(ConfigurationError error) {\n        if (configErrors == null) {\n            configErrors = new ArrayList<>();\n        }\n        configErrors.add(error);\n    }\n\n    /**\n     * Adds a new processing error to the report.\n     *\n     * @param error\n     *            the error to add\n     */\n    public void addError(ProcessingError error) {\n        if (errors == null) {\n            errors = new ArrayList<>();\n        }\n        errors.add(error);\n    }\n\n    /**\n     * Merges the given report into this report. This might be necessary, if a\n     * summary over all violations is needed as PMD creates one report per file\n     * by default.\n     *\n     * @param r\n     *            the report to be merged into this.\n     * @see AbstractAccumulatingRenderer\n     */\n    public void merge(Report r) {\n        Iterator<ProcessingError> i = r.errors();\n        while (i.hasNext()) {\n            addError(i.next());\n        }\n        Iterator<ConfigurationError> ce = r.configErrors();\n        while (ce.hasNext()) {\n            addConfigError(ce.next());\n        }\n        Iterator<RuleViolation> v = r.iterator();\n        while (v.hasNext()) {\n            RuleViolation violation = v.next();\n            int index = Collections.binarySearch(violations, violation, RuleViolationComparator.INSTANCE);\n            violations.add(index < 0 ? -index - 1 : index, violation);\n            violationTree.addRuleViolation(violation);\n        }\n        Iterator<SuppressedViolation> s = r.getSuppressedRuleViolations().iterator();\n        while (s.hasNext()) {\n            suppressedRuleViolations.add(s.next());\n        }\n    }\n\n    public boolean isEmpty() {\n        return !violations.iterator().hasNext() && !hasErrors();\n    }\n\n    /**\n     * Checks whether any processing errors have been reported.\n     *\n     * @return <code>true</code> if there were any processing errors,\n     *         <code>false</code> otherwise\n     */\n    public boolean hasErrors() {\n        return errors != null && !errors.isEmpty();\n    }\n\n    /**\n     * Checks whether any configuration errors have been reported.\n     *\n     * @return <code>true</code> if there were any configuration errors,\n     *         <code>false</code> otherwise\n     */\n    public boolean hasConfigErrors() {\n        return configErrors != null && !configErrors.isEmpty();\n    }\n\n    /**\n     * Checks whether no violations have been reported.\n     *\n     * @return <code>true</code> if no violations have been reported,\n     *         <code>false</code> otherwise\n     */\n    public boolean treeIsEmpty() {\n        return !violationTree.iterator().hasNext();\n    }\n\n    /**\n     * Returns an iteration over the reported violations.\n     *\n     * @return an iterator\n     */\n    public Iterator<RuleViolation> treeIterator() {\n        return violationTree.iterator();\n    }\n\n    @Override\n    public Iterator<RuleViolation> iterator() {\n        return violations.iterator();\n    }\n\n    /**\n     * Returns an iterator of the reported processing errors.\n     *\n     * @return the iterator\n     */\n    public Iterator<ProcessingError> errors() {\n        return errors == null ? Collections.<ProcessingError>emptyIterator() : errors.iterator();\n    }\n\n    /**\n     * Returns an iterator of the reported configuration errors.\n     *\n     * @return the iterator\n     */\n    public Iterator<ConfigurationError> configErrors() {\n        return configErrors == null ? Collections.<ConfigurationError>emptyIterator() : configErrors.iterator();\n    }\n\n    /**\n     * The number of violations.\n     *\n     * @return number of violations.\n     */\n    public int treeSize() {\n        return violationTree.size();\n    }\n\n    /**\n     * The number of violations.\n     *\n     * @return number of violations.\n     */\n    public int size() {\n        return violations.size();\n    }\n\n    /**\n     * Mark the start time of the report. This is used to get the elapsed time\n     * in the end.\n     *\n     * @see #getElapsedTimeInMillis()\n     */\n    public void start() {\n        start = System.currentTimeMillis();\n    }\n\n    /**\n     * Mark the end time of the report. This is ued to get the elapsed time.\n     *\n     * @see #getElapsedTimeInMillis()\n     */\n    public void end() {\n        end = System.currentTimeMillis();\n    }\n\n    public long getElapsedTimeInMillis() {\n        return end - start;\n    }\n\n    public List<ThreadSafeReportListener> getListeners() {\n        return listeners;\n    }\n\n    /**\n     * Adds all given listeners to this report\n     *\n     * @param allListeners\n     *            the report listeners\n     */\n    public void addListeners(List<ThreadSafeReportListener> allListeners) {\n        listeners.addAll(allListeners);\n    }\n}\n\nRefactoring Operation:\nMove Method\n\nProject Structure:\n['pmd-core/src/main/java/net/sourceforge/pmd/AbstractConfiguration.java', 'pmd-core/src/main/java/net/sourceforge/pmd/PMD.java', 'pmd-core/src/main/java/net/sourceforge/pmd/PMDConfiguration.java', 'pmd-core/src/main/java/net/sourceforge/pmd/PMDException.java', 'pmd-core/src/main/java/net/sourceforge/pmd/PMDVersion.java', 'pmd-core/src/main/java/net/sourceforge/pmd/Report.java', 'pmd-core/src/main/java/net/sourceforge/pmd/Rule.java', 'pmd-core/src/main/java/net/sourceforge/pmd/RuleContext.java', 'pmd-core/src/main/java/net/sourceforge/pmd/RulePriority.java', 'pmd-core/src/main/java/net/sourceforge/pmd/RuleSet.java', 'pmd-core/src/main/java/net/sourceforge/pmd/RuleSetFactory.java', 'pmd-core/src/main/java/net/sourceforge/pmd/RuleSetFactoryCompatibility.java', 'pmd-core/src/main/java/net/sourceforge/pmd/RuleSetNotFoundException.java', 'pmd-core/src/main/java/net/sourceforge/pmd/RuleSetReference.java', 'pmd-core/src/main/java/net/sourceforge/pmd/RuleSetReferenceId.java', 'pmd-core/src/main/java/net/sourceforge/pmd/RuleSetWriter.java', 'pmd-core/src/main/java/net/sourceforge/pmd/RuleSets.java', 'pmd-core/src/main/java/net/sourceforge/pmd/RuleViolation.java', 'pmd-core/src/main/java/net/sourceforge/pmd/RuleViolationComparator.java', 'pmd-core/src/main/java/net/sourceforge/pmd/RulesetsFactoryUtils.java', 'pmd-core/src/main/java/net/sourceforge/pmd/SourceCodeProcessor.java', 'pmd-core/src/main/java/net/sourceforge/pmd/ThreadSafeReportListener.java', 'pmd-core/src/main/java/net/sourceforge/pmd/ViolationSuppressor.java', 'pmd-core/src/main/java/net/sourceforge/pmd/annotation/DeprecatedUntil700.java', 'pmd-core/src/main/java/net/sourceforge/pmd/annotation/Experimental.java', 'pmd-core/src/main/java/net/sourceforge/pmd/annotation/InternalApi.java', 'pmd-core/src/main/java/net/sourceforge/pmd/annotation/ReservedSubclassing.java', 'pmd-core/src/main/java/net/sourceforge/pmd/ant/Formatter.java', 'pmd-core/src/main/java/net/sourceforge/pmd/ant/PMDTask.java', 'pmd-core/src/main/java/net/sourceforge/pmd/ant/RuleSetWrapper.java', 'pmd-core/src/main/java/net/sourceforge/pmd/ant/SourceLanguage.java', 'pmd-core/src/main/java/net/sourceforge/pmd/ant/internal/PMDTaskImpl.java', 'pmd-core/src/main/java/net/sourceforge/pmd/benchmark/TextTimingReportRenderer.java', 'pmd-core/src/main/java/net/sourceforge/pmd/benchmark/TimeTracker.java', 'pmd-core/src/main/java/net/sourceforge/pmd/benchmark/TimedOperation.java', 'pmd-core/src/main/java/net/sourceforge/pmd/benchmark/TimedOperationCategory.java', 'pmd-core/src/main/java/net/sourceforge/pmd/benchmark/TimingReport.java', 'pmd-core/src/main/java/net/sourceforge/pmd/benchmark/TimingReportRenderer.java', 'pmd-core/src/main/java/net/sourceforge/pmd/cache/AbstractAnalysisCache.java', 'pmd-core/src/main/java/net/sourceforge/pmd/cache/AnalysisCache.java', 'pmd-core/src/main/java/net/sourceforge/pmd/cache/AnalysisResult.java', 'pmd-core/src/main/java/net/sourceforge/pmd/cache/CachedRuleMapper.java', 'pmd-core/src/main/java/net/sourceforge/pmd/cache/CachedRuleViolation.java', 'pmd-core/src/main/java/net/sourceforge/pmd/cache/ChecksumAware.java', 'pmd-core/src/main/java/net/sourceforge/pmd/cache/FileAnalysisCache.java', 'pmd-core/src/main/java/net/sourceforge/pmd/cache/NoopAnalysisCache.java', 'pmd-core/src/main/java/net/sourceforge/pmd/cache/package-info.java', 'pmd-core/src/main/java/net/sourceforge/pmd/cli/PMDCommandLineInterface.java', 'pmd-core/src/main/java/net/sourceforge/pmd/cli/PMDParameters.java', 'pmd-core/src/main/java/net/sourceforge/pmd/cpd/AbstractLanguage.java', 'pmd-core/src/main/java/net/sourceforge/pmd/cpd/AbstractTokenizer.java', 'pmd-core/src/main/java/net/sourceforge/pmd/cpd/AnyLanguage.java', 'pmd-core/src/main/java/net/sourceforge/pmd/cpd/AnyTokenizer.java', 'pmd-core/src/main/java/net/sourceforge/pmd/cpd/CPD.java', 'pmd-core/src/main/java/net/sourceforge/pmd/cpd/CPDCommandLineInterface.java', 'pmd-core/src/main/java/net/sourceforge/pmd/cpd/CPDConfiguration.java', 'pmd-core/src/main/java/net/sourceforge/pmd/cpd/CPDListener.java', 'pmd-core/src/main/java/net/sourceforge/pmd/cpd/CPDNullListener.java', 'pmd-core/src/main/java/net/sourceforge/pmd/cpd/CPDTask.java', 'pmd-core/src/main/java/net/sourceforge/pmd/cpd/CSVRenderer.java', 'pmd-core/src/main/java/net/sourceforge/pmd/cpd/CSVWithLinecountPerFileRenderer.java', 'pmd-core/src/main/java/net/sourceforge/pmd/cpd/FileReporter.java', 'pmd-core/src/main/java/net/sourceforge/pmd/cpd/GUI.java', 'pmd-core/src/main/java/net/sourceforge/pmd/cpd/GridBagHelper.java', 'pmd-core/src/main/java/net/sourceforge/pmd/cpd/Language.java', 'pmd-core/src/main/java/net/sourceforge/pmd/cpd/LanguageFactory.java', 'pmd-core/src/main/java/net/sourceforge/pmd/cpd/Mark.java', 'pmd-core/src/main/java/net/sourceforge/pmd/cpd/Match.java', 'pmd-core/src/main/java/net/sourceforge/pmd/cpd/MatchAlgorithm.java', 'pmd-core/src/main/java/net/sourceforge/pmd/cpd/MatchCollector.java', 'pmd-core/src/main/java/net/sourceforge/pmd/cpd/Renderer.java', 'pmd-core/src/main/java/net/sourceforge/pmd/cpd/ReportException.java', 'pmd-core/src/main/java/net/sourceforge/pmd/cpd/SimpleRenderer.java', 'pmd-core/src/main/java/net/sourceforge/pmd/cpd/SourceCode.java', 'pmd-core/src/main/java/net/sourceforge/pmd/cpd/TokenEntry.java', 'pmd-core/src/main/java/net/sourceforge/pmd/cpd/Tokenizer.java', 'pmd-core/src/main/java/net/sourceforge/pmd/cpd/Tokens.java', 'pmd-core/src/main/java/net/sourceforge/pmd/cpd/VSRenderer.java', 'pmd-core/src/main/java/net/sourceforge/pmd/cpd/XMLRenderer.java', 'pmd-core/src/main/java/net/sourceforge/pmd/cpd/internal/AntlrTokenizer.java', 'pmd-core/src/main/java/net/sourceforge/pmd/cpd/internal/JavaCCTokenizer.java', 'pmd-core/src/main/java/net/sourceforge/pmd/cpd/renderer/CPDRenderer.java', 'pmd-core/src/main/java/net/sourceforge/pmd/cpd/token/AntlrTokenFilter.java', 'pmd-core/src/main/java/net/sourceforge/pmd/cpd/token/JavaCCTokenFilter.java', 'pmd-core/src/main/java/net/sourceforge/pmd/cpd/token/TokenFilter.java', 'pmd-core/src/main/java/net/sourceforge/pmd/cpd/token/internal/BaseTokenFilter.java', 'pmd-core/src/main/java/net/sourceforge/pmd/document/DeleteDocumentOperation.java', 'pmd-core/src/main/java/net/sourceforge/pmd/document/Document.java', 'pmd-core/src/main/java/net/sourceforge/pmd/document/DocumentFile.java', 'pmd-core/src/main/java/net/sourceforge/pmd/document/DocumentOperation.java', 'pmd-core/src/main/java/net/sourceforge/pmd/document/DocumentOperationsApplierForNonOverlappingRegions.java', 'pmd-core/src/main/java/net/sourceforge/pmd/document/InsertDocumentOperation.java', 'pmd-core/src/main/java/net/sourceforge/pmd/document/RegionByLine.java', 'pmd-core/src/main/java/net/sourceforge/pmd/document/RegionByLineImp.java', 'pmd-core/src/main/java/net/sourceforge/pmd/document/RegionByOffset.java', 'pmd-core/src/main/java/net/sourceforge/pmd/document/RegionByOffsetImp.java', 'pmd-core/src/main/java/net/sourceforge/pmd/document/ReplaceDocumentOperation.java', 'pmd-core/src/main/java/net/sourceforge/pmd/internal/RulesetStageDependencyHelper.java', 'pmd-core/src/main/java/net/sourceforge/pmd/internal/util/AssertionUtil.java', 'pmd-core/src/main/java/net/sourceforge/pmd/internal/util/FileExtensionFilter.java', 'pmd-core/src/main/java/net/sourceforge/pmd/internal/util/IteratorUtil.java', 'pmd-core/src/main/java/net/sourceforge/pmd/internal/util/PredicateUtil.java', 'pmd-core/src/main/java/net/sourceforge/pmd/internal/util/ShortFilenameUtil.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/AbstractLanguageVersionHandler.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/AbstractParser.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/AbstractPmdLanguageVersionHandler.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/BaseLanguageModule.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/DataFlowHandler.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/Language.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/LanguageFilenameFilter.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/LanguageRegistry.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/LanguageVersion.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/LanguageVersionDiscoverer.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/LanguageVersionHandler.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/Parser.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/ParserOptions.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/TokenManager.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/XPathHandler.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/AbstractTokenManager.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/AstAnalysisContext.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/AstProcessingStage.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/AstVisitor.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/AstVisitorBase.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/CharStream.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/GenericToken.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/Node.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/NodeStream.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/ParseException.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/RootNode.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/SignedNode.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/SourceCodePositioner.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/TextAvailableNode.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/TokenMgrError.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/impl/AbstractNode.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/impl/AbstractNodeWithTextCoordinates.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/impl/GenericNode.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/impl/TokenDocument.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/impl/antlr4/AntlrBaseParser.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/impl/antlr4/AntlrBaseRule.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/impl/antlr4/AntlrGeneratedParserBase.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/impl/antlr4/AntlrNameDictionary.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/impl/antlr4/AntlrNode.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/impl/antlr4/AntlrToken.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/impl/antlr4/AntlrTokenManager.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/impl/antlr4/BaseAntlrErrorNode.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/impl/antlr4/BaseAntlrInnerNode.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/impl/antlr4/BaseAntlrNode.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/impl/antlr4/BaseAntlrTerminalNode.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/impl/javacc/AbstractJjtreeNode.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/impl/javacc/CharStreamFactory.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/impl/javacc/JavaCharStream.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/impl/javacc/JavaccToken.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/impl/javacc/JavaccTokenDocument.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/impl/javacc/JjtreeBuilder.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/impl/javacc/JjtreeNode.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/impl/javacc/JjtreeParserAdapter.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/impl/javacc/SimpleCharStream.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/impl/javacc/package-info.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/internal/AncestorOrSelfIterator.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/internal/AxisStream.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/internal/Filtermap.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/internal/GreedyNStream.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/internal/IteratorBasedNStream.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/internal/SingletonNodeStream.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/internal/StreamImpl.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/internal/TraversalUtils.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/internal/TreeWalker.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/xpath/AbstractASTXPathHandler.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/xpath/Attribute.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/xpath/AttributeAxisIterator.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/xpath/DefaultASTXPathHandler.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/xpath/DocumentNavigator.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/xpath/NoAttribute.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/xpath/NodeIterator.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/xpath/internal/ContextualizedNavigator.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/xpath/internal/DeprecatedAttrLogger.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/xpath/internal/DeprecatedAttribute.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/xpath/saxon/AbstractNodeInfo.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/xpath/saxon/AttributeAxisIterator.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/xpath/saxon/AttributeNode.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/xpath/saxon/BaseNodeInfo.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/xpath/saxon/DocumentNode.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/xpath/saxon/ElementNode.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/xpath/saxon/IdGenerator.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/dfa/AbstractDataFlowNode.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/dfa/DataFlowNode.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/dfa/Linker.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/dfa/LinkerException.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/dfa/NodeType.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/dfa/SequenceChecker.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/dfa/SequenceException.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/dfa/StackObject.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/dfa/StartOrEndDataFlowNode.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/dfa/Structure.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/dfa/VariableAccess.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/dfa/VariableAccessException.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/dfa/pathfinder/CurrentPath.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/dfa/pathfinder/DAAPathFinder.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/dfa/pathfinder/Executable.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/dfa/pathfinder/PathElement.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/dfa/report/AbstractReportNode.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/dfa/report/ClassNode.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/dfa/report/PackageNode.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/dfa/report/ReportHTMLPrintVisitor.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/dfa/report/ReportTree.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/dfa/report/ReportVisitor.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/dfa/report/ViolationNode.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/metrics/AbstractMetric.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/metrics/LanguageMetricsProvider.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/metrics/Metric.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/metrics/MetricKey.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/metrics/MetricOption.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/metrics/MetricOptions.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/metrics/MetricsUtil.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/metrics/ParameterizedMetricKey.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/metrics/SigMask.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/metrics/Signature.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/metrics/internal/AbstractLanguageMetricsProvider.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/metrics/package-info.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/rule/AbstractDelegateRule.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/rule/AbstractRule.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/rule/AbstractRuleViolationFactory.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/rule/ImmutableLanguage.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/rule/MockRule.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/rule/ParametricRuleViolation.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/rule/RuleReference.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/rule/RuleTargetSelector.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/rule/RuleViolationFactory.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/rule/XPathRule.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/rule/impl/DefaultRuleViolationFactory.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/rule/internal/CommonPropertyDescriptors.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/rule/internal/GraphUtils.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/rule/internal/LatticeRelation.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/rule/internal/RuleApplicator.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/rule/internal/TargetSelectorInternal.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/rule/internal/TopoOrder.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/rule/internal/TreeIndex.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/rule/xpath/AbstractXPathRuleQuery.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/rule/xpath/JaxenXPathRuleQuery.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/rule/xpath/SaxonXPathRuleQuery.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/rule/xpath/XPathRuleQuery.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/rule/xpath/XPathVersion.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/rule/xpath/internal/DocumentSorter.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/rule/xpath/internal/ExpressionPrinter.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/rule/xpath/internal/RuleChainAnalyzer.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/rule/xpath/internal/SaxonExprVisitor.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/rule/xpath/internal/SplitUnions.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/symboltable/AbstractNameDeclaration.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/symboltable/AbstractScope.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/symboltable/Applier.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/symboltable/ImageFinderFunction.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/symboltable/NameDeclaration.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/symboltable/NameOccurrence.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/symboltable/Scope.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/symboltable/ScopedNode.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/xpath/Initializer.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/xpath/MatchesFunction.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/xpath/PMDFunctions.java', 'pmd-core/src/main/java/net/sourceforge/pmd/processor/AbstractPMDProcessor.java', 'pmd-core/src/main/java/net/sourceforge/pmd/processor/MonoThreadProcessor.java', 'pmd-core/src/main/java/net/sourceforge/pmd/processor/MultiThreadProcessor.java', 'pmd-core/src/main/java/net/sourceforge/pmd/processor/PmdRunnable.java', 'pmd-core/src/main/java/net/sourceforge/pmd/processor/PmdThreadFactory.java', 'pmd-core/src/main/java/net/sourceforge/pmd/properties/AbstractMultiNumericProperty.java', 'pmd-core/src/main/java/net/sourceforge/pmd/properties/AbstractMultiPackagedProperty.java', 'pmd-core/src/main/java/net/sourceforge/pmd/properties/AbstractMultiValueProperty.java', 'pmd-core/src/main/java/net/sourceforge/pmd/properties/AbstractNumericProperty.java', 'pmd-core/src/main/java/net/sourceforge/pmd/properties/AbstractPackagedProperty.java', 'pmd-core/src/main/java/net/sourceforge/pmd/properties/AbstractProperty.java', 'pmd-core/src/main/java/net/sourceforge/pmd/properties/AbstractPropertySource.java', 'pmd-core/src/main/java/net/sourceforge/pmd/properties/AbstractSingleValueProperty.java', 'pmd-core/src/main/java/net/sourceforge/pmd/properties/BooleanMultiProperty.java', 'pmd-core/src/main/java/net/sourceforge/pmd/properties/BooleanProperty.java', 'pmd-core/src/main/java/net/sourceforge/pmd/properties/CharacterMultiProperty.java', 'pmd-core/src/main/java/net/sourceforge/pmd/properties/CharacterProperty.java', 'pmd-core/src/main/java/net/sourceforge/pmd/properties/DoubleMultiProperty.java', 'pmd-core/src/main/java/net/sourceforge/pmd/properties/DoubleProperty.java', 'pmd-core/src/main/java/net/sourceforge/pmd/properties/EnumeratedMultiProperty.java', 'pmd-core/src/main/java/net/sourceforge/pmd/properties/EnumeratedProperty.java', 'pmd-core/src/main/java/net/sourceforge/pmd/properties/EnumeratedPropertyDescriptor.java', 'pmd-core/src/main/java/net/sourceforge/pmd/properties/FileProperty.java', 'pmd-core/src/main/java/net/sourceforge/pmd/properties/FloatMultiProperty.java', 'pmd-core/src/main/java/net/sourceforge/pmd/properties/FloatProperty.java', 'pmd-core/src/main/java/net/sourceforge/pmd/properties/GenericMultiValuePropertyDescriptor.java', 'pmd-core/src/main/java/net/sourceforge/pmd/properties/GenericPropertyDescriptor.java', 'pmd-core/src/main/java/net/sourceforge/pmd/properties/IntegerMultiProperty.java', 'pmd-core/src/main/java/net/sourceforge/pmd/properties/IntegerProperty.java', 'pmd-core/src/main/java/net/sourceforge/pmd/properties/LongMultiProperty.java', 'pmd-core/src/main/java/net/sourceforge/pmd/properties/LongProperty.java', 'pmd-core/src/main/java/net/sourceforge/pmd/properties/MethodMultiProperty.java', 'pmd-core/src/main/java/net/sourceforge/pmd/properties/MethodProperty.java', 'pmd-core/src/main/java/net/sourceforge/pmd/properties/MultiValuePropertyDescriptor.java', 'pmd-core/src/main/java/net/sourceforge/pmd/properties/NumericPropertyDescriptor.java', 'pmd-core/src/main/java/net/sourceforge/pmd/properties/PackagedPropertyDescriptor.java', 'pmd-core/src/main/java/net/sourceforge/pmd/properties/PropertyBuilder.java', 'pmd-core/src/main/java/net/sourceforge/pmd/properties/PropertyDescriptor.java', 'pmd-core/src/main/java/net/sourceforge/pmd/properties/PropertyDescriptorField.java', 'pmd-core/src/main/java/net/sourceforge/pmd/properties/PropertyFactory.java', 'pmd-core/src/main/java/net/sourceforge/pmd/properties/PropertySource.java', 'pmd-core/src/main/java/net/sourceforge/pmd/properties/PropertyTypeId.java', 'pmd-core/src/main/java/net/sourceforge/pmd/properties/RegexProperty.java', 'pmd-core/src/main/java/net/sourceforge/pmd/properties/SingleValuePropertyDescriptor.java', 'pmd-core/src/main/java/net/sourceforge/pmd/properties/StringMultiProperty.java', 'pmd-core/src/main/java/net/sourceforge/pmd/properties/StringProperty.java', 'pmd-core/src/main/java/net/sourceforge/pmd/properties/TypeMultiProperty.java', 'pmd-core/src/main/java/net/sourceforge/pmd/properties/TypeProperty.java', 'pmd-core/src/main/java/net/sourceforge/pmd/properties/ValueParser.java', 'pmd-core/src/main/java/net/sourceforge/pmd/properties/ValueParserConstants.java', 'pmd-core/src/main/java/net/sourceforge/pmd/properties/builders/MultiNumericPropertyBuilder.java', 'pmd-core/src/main/java/net/sourceforge/pmd/properties/builders/MultiPackagedPropertyBuilder.java', 'pmd-core/src/main/java/net/sourceforge/pmd/properties/builders/MultiValuePropertyBuilder.java', 'pmd-core/src/main/java/net/sourceforge/pmd/properties/builders/PropertyDescriptorBuilder.java', 'pmd-core/src/main/java/net/sourceforge/pmd/properties/builders/PropertyDescriptorBuilderConversionWrapper.java', 'pmd-core/src/main/java/net/sourceforge/pmd/properties/builders/PropertyDescriptorExternalBuilder.java', 'pmd-core/src/main/java/net/sourceforge/pmd/properties/builders/SingleNumericPropertyBuilder.java', 'pmd-core/src/main/java/net/sourceforge/pmd/properties/builders/SinglePackagedPropertyBuilder.java', 'pmd-core/src/main/java/net/sourceforge/pmd/properties/builders/SingleValuePropertyBuilder.java', 'pmd-core/src/main/java/net/sourceforge/pmd/properties/constraints/NumericConstraints.java', 'pmd-core/src/main/java/net/sourceforge/pmd/properties/constraints/PropertyConstraint.java', 'pmd-core/src/main/java/net/sourceforge/pmd/properties/modules/EnumeratedPropertyModule.java', 'pmd-core/src/main/java/net/sourceforge/pmd/properties/modules/MethodPropertyModule.java', 'pmd-core/src/main/java/net/sourceforge/pmd/properties/modules/NumericPropertyModule.java', 'pmd-core/src/main/java/net/sourceforge/pmd/properties/modules/PackagedPropertyModule.java', 'pmd-core/src/main/java/net/sourceforge/pmd/properties/modules/TypePropertyModule.java', 'pmd-core/src/main/java/net/sourceforge/pmd/renderers/AbstractAccumulatingRenderer.java', 'pmd-core/src/main/java/net/sourceforge/pmd/renderers/AbstractIncrementingRenderer.java', 'pmd-core/src/main/java/net/sourceforge/pmd/renderers/AbstractRenderer.java', 'pmd-core/src/main/java/net/sourceforge/pmd/renderers/CSVRenderer.java', 'pmd-core/src/main/java/net/sourceforge/pmd/renderers/CSVWriter.java', 'pmd-core/src/main/java/net/sourceforge/pmd/renderers/CodeClimateIssue.java', 'pmd-core/src/main/java/net/sourceforge/pmd/renderers/CodeClimateRenderer.java', 'pmd-core/src/main/java/net/sourceforge/pmd/renderers/ColumnDescriptor.java', 'pmd-core/src/main/java/net/sourceforge/pmd/renderers/EmacsRenderer.java', 'pmd-core/src/main/java/net/sourceforge/pmd/renderers/EmptyRenderer.java', 'pmd-core/src/main/java/net/sourceforge/pmd/renderers/HTMLRenderer.java', 'pmd-core/src/main/java/net/sourceforge/pmd/renderers/IDEAJRenderer.java', 'pmd-core/src/main/java/net/sourceforge/pmd/renderers/JsonRenderer.java', 'pmd-core/src/main/java/net/sourceforge/pmd/renderers/Renderer.java', 'pmd-core/src/main/java/net/sourceforge/pmd/renderers/RendererFactory.java', 'pmd-core/src/main/java/net/sourceforge/pmd/renderers/SummaryHTMLRenderer.java', 'pmd-core/src/main/java/net/sourceforge/pmd/renderers/TextColorRenderer.java', 'pmd-core/src/main/java/net/sourceforge/pmd/renderers/TextPadRenderer.java', 'pmd-core/src/main/java/net/sourceforge/pmd/renderers/TextRenderer.java', 'pmd-core/src/main/java/net/sourceforge/pmd/renderers/VBHTMLRenderer.java', 'pmd-core/src/main/java/net/sourceforge/pmd/renderers/XMLRenderer.java', 'pmd-core/src/main/java/net/sourceforge/pmd/renderers/XSLTRenderer.java', 'pmd-core/src/main/java/net/sourceforge/pmd/renderers/YAHTMLRenderer.java', 'pmd-core/src/main/java/net/sourceforge/pmd/rules/RuleBuilder.java', 'pmd-core/src/main/java/net/sourceforge/pmd/rules/RuleFactory.java', 'pmd-core/src/main/java/net/sourceforge/pmd/util/ClassUtil.java', 'pmd-core/src/main/java/net/sourceforge/pmd/util/ClasspathClassLoader.java', 'pmd-core/src/main/java/net/sourceforge/pmd/util/CollectionUtil.java', 'pmd-core/src/main/java/net/sourceforge/pmd/util/CompoundIterator.java', 'pmd-core/src/main/java/net/sourceforge/pmd/util/DataMap.java', 'pmd-core/src/main/java/net/sourceforge/pmd/util/DateTimeUtil.java', 'pmd-core/src/main/java/net/sourceforge/pmd/util/FileFinder.java', 'pmd-core/src/main/java/net/sourceforge/pmd/util/FileIterable.java', 'pmd-core/src/main/java/net/sourceforge/pmd/util/FileUtil.java', 'pmd-core/src/main/java/net/sourceforge/pmd/util/IOUtil.java', 'pmd-core/src/main/java/net/sourceforge/pmd/util/NumericConstants.java', 'pmd-core/src/main/java/net/sourceforge/pmd/util/ResourceLoader.java', 'pmd-core/src/main/java/net/sourceforge/pmd/util/SearchFunction.java', 'pmd-core/src/main/java/net/sourceforge/pmd/util/StringUtil.java', 'pmd-core/src/main/java/net/sourceforge/pmd/util/TypeMap.java', 'pmd-core/src/main/java/net/sourceforge/pmd/util/database/DBMSMetadata.java', 'pmd-core/src/main/java/net/sourceforge/pmd/util/database/DBType.java', 'pmd-core/src/main/java/net/sourceforge/pmd/util/database/DBURI.java', 'pmd-core/src/main/java/net/sourceforge/pmd/util/database/ResourceLoader.java', 'pmd-core/src/main/java/net/sourceforge/pmd/util/database/ResourceResolver.java', 'pmd-core/src/main/java/net/sourceforge/pmd/util/database/SourceObject.java', 'pmd-core/src/main/java/net/sourceforge/pmd/util/datasource/DataSource.java', 'pmd-core/src/main/java/net/sourceforge/pmd/util/datasource/FileDataSource.java', 'pmd-core/src/main/java/net/sourceforge/pmd/util/datasource/ReaderDataSource.java', 'pmd-core/src/main/java/net/sourceforge/pmd/util/datasource/ZipDataSource.java', 'pmd-core/src/main/java/net/sourceforge/pmd/util/datasource/internal/AbstractDataSource.java', 'pmd-core/src/main/java/net/sourceforge/pmd/util/designerbindings/DesignerBindings.java', 'pmd-core/src/main/java/net/sourceforge/pmd/util/designerbindings/RelatedNodesSelector.java', 'pmd-core/src/main/java/net/sourceforge/pmd/util/log/AntLogHandler.java', 'pmd-core/src/main/java/net/sourceforge/pmd/util/log/ConsoleLogHandler.java', 'pmd-core/src/main/java/net/sourceforge/pmd/util/log/PmdLogFormatter.java', 'pmd-core/src/main/java/net/sourceforge/pmd/util/log/ScopedLogHandlersManager.java', 'pmd-core/src/main/java/net/sourceforge/pmd/util/treeexport/TextTreeRenderer.java', 'pmd-core/src/main/java/net/sourceforge/pmd/util/treeexport/TreeExportCli.java', 'pmd-core/src/main/java/net/sourceforge/pmd/util/treeexport/TreeRenderer.java', 'pmd-core/src/main/java/net/sourceforge/pmd/util/treeexport/TreeRendererDescriptor.java', 'pmd-core/src/main/java/net/sourceforge/pmd/util/treeexport/TreeRendererDescriptorImpl.java', 'pmd-core/src/main/java/net/sourceforge/pmd/util/treeexport/TreeRenderers.java', 'pmd-core/src/main/java/net/sourceforge/pmd/util/treeexport/XmlTreeRenderer.java']\n\nInstructions:\n1. Analyze the provided code, class content, and project structure, apply move method refactoring to the code to be refactored, output the target file path, moved class code, and refactored method code.\nNeed to move to an existing java file\nThe moved method code should be updated to the public static method.\nThe refactored method code should use the moved class to call the moved method.\nThe target file path should be the path of the existing class where the method is moved to.\n\n2. If refactoring is performed, output the target file path, moved class code, and refactored method code in the following format:\n##########################\ntarget_file_path\n##########################\nmoved_class_code\n##########################\nrefactored_method_code\n##########################\n\n\n\n"}, {"type": "Extract Method", "description": "Extract Method\tpublic getPrimitive(kind PrimitiveTypeKind) : JPrimitiveType extracted from public getClassSymbol(klass Class<?>) : JClassSymbol in class net.sourceforge.pmd.lang.java.types.TypeSystem", "diffLocations": [{"filePath": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/internal/impl/reflect/ReflectionSymFactory.java", "startLine": 58, "endLine": 82, "startColumn": 0, "endColumn": 0}, {"filePath": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/TypeSystem.java", "startLine": 337, "endLine": 359, "startColumn": 0, "endColumn": 0}, {"filePath": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/TypeSystem.java", "startLine": 586, "endLine": 596, "startColumn": 0, "endColumn": 0}], "sourceCodeBeforeRefactoring": "@Override\n    @Nullable\n    public JClassSymbol getClassSymbol(@Nullable Class<?> klass) {\n        if (klass == null) {\n            return null;\n        }\n\n        Map<Class<?>, JClassSymbol> shared = getCommonSyms();\n        if (shared.containsKey(klass)) {\n            return shared.get(klass);\n        }\n\n        if (klass.getEnclosingClass() != null) {\n            JClassSymbol enclosing = getClassSymbol(klass.getEnclosingClass());\n            assert enclosing != null;\n            return createWithEnclosing(this, enclosing, klass);\n        }\n\n        if (klass.isArray()) {\n            JClassSymbol component = getClassSymbol(klass.getComponentType());\n            return makeArraySymbol(component);\n        }\n\n        return createOuterClass(this, klass);\n    }", "filePathBefore": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/internal/impl/reflect/ReflectionSymFactory.java", "isPureRefactoring": true, "commitId": "2449f6404ec001dde8fe782febb993f262a5ddc1", "packageNameBefore": "net.sourceforge.pmd.lang.java.symbols.internal.impl.reflect", "classNameBefore": "net.sourceforge.pmd.lang.java.symbols.internal.impl.reflect.ReflectionSymFactory", "methodNameBefore": "net.sourceforge.pmd.lang.java.symbols.internal.impl.reflect.ReflectionSymFactory#getClassSymbol", "invokedMethod": "methodSignature: net.sourceforge.pmd.lang.java.symbols.internal.impl.reflect.ReflectedClassImpl#getEnclosingClass\n methodBody: public JClassSymbol getEnclosingClass() {\nreturn enclosing;\n}\nmethodSignature: net.sourceforge.pmd.lang.java.symbols.internal.impl.SymbolFactory#getClassSymbol\n methodBody: JClassSymbol getClassSymbol(@Nullable T klass);\nmethodSignature: net.sourceforge.pmd.lang.java.symbols.internal.impl.UnresolvedClassImpl#getEnclosingClass\n methodBody: public JClassSymbol getEnclosingClass() {\nreturn enclosing;\n}\nmethodSignature: net.sourceforge.pmd.lang.java.symbols.internal.impl.reflect.ReflectionSymFactory#getClassSymbol\n methodBody: public JClassSymbol getClassSymbol(@Nullable Class<?> klass) {\nif(klass == null){return null;\n}Map<Class<?>,JClassSymbol> shared=getCommonSyms();\nif(shared.containsKey(klass)){return shared.get(klass);\n}if(klass.getEnclosingClass() != null){JClassSymbol enclosing=getClassSymbol(klass.getEnclosingClass());\nassert enclosing != null;\nreturn createWithEnclosing(this,enclosing,klass);\n}if(klass.isArray()){JClassSymbol component=getClassSymbol(klass.getComponentType());\nreturn makeArraySymbol(component);\n}return createOuterClass(this,klass);\n}\nmethodSignature: net.sourceforge.pmd.lang.java.symbols.internal.impl.reflect.ReflectedClassImpl#createWithEnclosing\n methodBody: static ReflectedClassImpl createWithEnclosing(ReflectionSymFactory symbolFactory,\n                                                  @Nullable JClassSymbol enclosing,\n                                                  Class<?> myClass) {\nreturn new ReflectedClassImpl(symbolFactory,enclosing,myClass);\n}\nmethodSignature: net.sourceforge.pmd.lang.java.symbols.internal.impl.UnresolvedClassImpl#isArray\n methodBody: public boolean isArray() {\nreturn false;\n}\nmethodSignature: net.sourceforge.pmd.lang.java.symbols.internal.impl.reflect.AbstractReflectedExecutableSymbol#getEnclosingClass\n methodBody: public final JClassSymbol getEnclosingClass() {\nreturn owner;\n}\nmethodSignature: net.sourceforge.pmd.lang.java.symbols.internal.impl.reflect.ReflectedClassImpl#createOuterClass\n methodBody: static ReflectedClassImpl createOuterClass(ReflectionSymFactory symbolFactory, Class<?> myClass) {\nreturn new ReflectedClassImpl(symbolFactory,myClass);\n}\nmethodSignature: net.sourceforge.pmd.lang.java.symbols.internal.impl.ImplicitMemberSymbols.FakeExecutableSymBase#getEnclosingClass\n methodBody: public @NonNull JClassSymbol getEnclosingClass() {\nreturn owner;\n}\nmethodSignature: net.sourceforge.pmd.lang.java.symbols.internal.impl.ArraySymbolImpl#isArray\n methodBody: public boolean isArray() {\nreturn true;\n}\nmethodSignature: net.sourceforge.pmd.lang.java.symbols.internal.impl.reflect.ReflectedClassImpl#isArray\n methodBody: public boolean isArray() {\nreturn false;\n}\nmethodSignature: net.sourceforge.pmd.lang.java.symbols.internal.impl.ast.AstClassSym#getEnclosingClass\n methodBody: public @Nullable JClassSymbol getEnclosingClass() {\nif(enclosing instanceof JClassSymbol){return (JClassSymbol)enclosing;\n}if(enclosing instanceof JExecutableSymbol){return enclosing.getEnclosingClass();\n}assert enclosing == null;\nreturn null;\n}\nmethodSignature: net.sourceforge.pmd.lang.java.symbols.internal.impl.ast.AstFieldSym#getEnclosingClass\n methodBody: public @NonNull JClassSymbol getEnclosingClass() {\nreturn owner;\n}\nmethodSignature: net.sourceforge.pmd.lang.java.symbols.internal.impl.ArraySymbolImpl#getEnclosingClass\n methodBody: public JClassSymbol getEnclosingClass() {\nreturn null;\n}\nmethodSignature: net.sourceforge.pmd.lang.java.symbols.internal.impl.ImplicitMemberSymbols.FakeFieldSym#getEnclosingClass\n methodBody: public @NonNull JClassSymbol getEnclosingClass() {\nreturn owner;\n}\nmethodSignature: net.sourceforge.pmd.lang.java.symbols.JTypeParameterSymbol#getEnclosingClass\n methodBody: default JClassSymbol getEnclosingClass() {\nJTypeParameterOwnerSymbol ownerSymbol=getDeclaringSymbol();\nreturn ownerSymbol instanceof JClassSymbol ? (JClassSymbol)ownerSymbol : ownerSymbol.getEnclosingClass();\n}\nmethodSignature: net.sourceforge.pmd.typeresolution.testdata.LocalGenericClass.localClassInGeneric.MyLocalClass#get\n methodBody: public Optional<T> get() {\nreturn Optional.empty();\n}\nmethodSignature: net.sourceforge.pmd.lang.java.symbols.JAccessibleElementSymbol#getEnclosingClass\n methodBody: JClassSymbol getEnclosingClass();\nmethodSignature: net.sourceforge.pmd.lang.java.symbols.internal.impl.SymbolFactory#makeArraySymbol\n methodBody: default JClassSymbol makeArraySymbol(JTypeDeclSymbol component) {\nreturn new ArraySymbolImpl(this,component);\n}\nmethodSignature: net.sourceforge.pmd.lang.java.symbols.JClassSymbol#isArray\n methodBody: boolean isArray();\nmethodSignature: net.sourceforge.pmd.lang.java.symbols.internal.impl.ast.AbstractAstExecSymbol#getEnclosingClass\n methodBody: public @NonNull JClassSymbol getEnclosingClass() {\nreturn owner;\n}\nmethodSignature: net.sourceforge.pmd.lang.java.symbols.internal.impl.reflect.ReflectionSymFactory#getCommonSyms\n methodBody: private static Map<Class<?>, JClassSymbol> getCommonSyms() {\nMap<Class<?>,JClassSymbol> shared=commonSymbols;\nif(shared == null){synchronized(ReflectionSymFactory.class){shared=commonSymbols;\nif(shared == null){shared=initCommonSyms();\ncommonSymbols=shared;\n}}}return shared;\n}\nmethodSignature: net.sourceforge.pmd.lang.java.symbols.internal.impl.reflect.ReflectedFieldImpl#getEnclosingClass\n methodBody: public JClassSymbol getEnclosingClass() {\nreturn owner;\n}\nmethodSignature: net.sourceforge.pmd.typeresolution.testdata.LocalGenericClass.MySupplier#get\n methodBody: S get();\nmethodSignature: net.sourceforge.pmd.lang.java.symbols.internal.impl.ast.AstClassSym#isArray\n methodBody: public boolean isArray() {\nreturn false;\n}\nmethodSignature: net.sourceforge.pmd.lang.java.symbols.JExecutableSymbol#getEnclosingClass\n methodBody: JClassSymbol getEnclosingClass();", "classSignatureBefore": "public final class ReflectionSymFactory implements SymbolFactory<Class<?>> ", "methodNameBeforeSet": ["net.sourceforge.pmd.lang.java.symbols.internal.impl.reflect.ReflectionSymFactory#getClassSymbol"], "classNameBeforeSet": ["net.sourceforge.pmd.lang.java.symbols.internal.impl.reflect.ReflectionSymFactory"], "classSignatureBeforeSet": ["public final class ReflectionSymFactory implements SymbolFactory<Class<?>> "], "purityCheckResultList": [{"isPure": true, "purityComment": "Tolerable changes in the body\n", "description": "All replacements have been justified - all mapped", "mappingState": 1}], "sourceCodeBeforeForWhole": "/*\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.lang.java.symbols.internal.impl.reflect;\n\n\nimport static net.sourceforge.pmd.lang.java.symbols.internal.impl.reflect.ReflectSymInternals.BOOLEAN_SYM;\nimport static net.sourceforge.pmd.lang.java.symbols.internal.impl.reflect.ReflectSymInternals.BOXED_BOOLEAN_SYM;\nimport static net.sourceforge.pmd.lang.java.symbols.internal.impl.reflect.ReflectSymInternals.BOXED_BYTE_SYM;\nimport static net.sourceforge.pmd.lang.java.symbols.internal.impl.reflect.ReflectSymInternals.BOXED_CHAR_SYM;\nimport static net.sourceforge.pmd.lang.java.symbols.internal.impl.reflect.ReflectSymInternals.BOXED_DOUBLE_SYM;\nimport static net.sourceforge.pmd.lang.java.symbols.internal.impl.reflect.ReflectSymInternals.BOXED_FLOAT_SYM;\nimport static net.sourceforge.pmd.lang.java.symbols.internal.impl.reflect.ReflectSymInternals.BOXED_INT_SYM;\nimport static net.sourceforge.pmd.lang.java.symbols.internal.impl.reflect.ReflectSymInternals.BOXED_LONG_SYM;\nimport static net.sourceforge.pmd.lang.java.symbols.internal.impl.reflect.ReflectSymInternals.BOXED_SHORT_SYM;\nimport static net.sourceforge.pmd.lang.java.symbols.internal.impl.reflect.ReflectSymInternals.BOXED_VOID_SYM;\nimport static net.sourceforge.pmd.lang.java.symbols.internal.impl.reflect.ReflectSymInternals.BYTE_SYM;\nimport static net.sourceforge.pmd.lang.java.symbols.internal.impl.reflect.ReflectSymInternals.CHAR_SYM;\nimport static net.sourceforge.pmd.lang.java.symbols.internal.impl.reflect.ReflectSymInternals.CLONEABLE_SYM;\nimport static net.sourceforge.pmd.lang.java.symbols.internal.impl.reflect.ReflectSymInternals.DOUBLE_SYM;\nimport static net.sourceforge.pmd.lang.java.symbols.internal.impl.reflect.ReflectSymInternals.ENUM_SYM;\nimport static net.sourceforge.pmd.lang.java.symbols.internal.impl.reflect.ReflectSymInternals.FLOAT_SYM;\nimport static net.sourceforge.pmd.lang.java.symbols.internal.impl.reflect.ReflectSymInternals.INT_SYM;\nimport static net.sourceforge.pmd.lang.java.symbols.internal.impl.reflect.ReflectSymInternals.ITERABLE_SYM;\nimport static net.sourceforge.pmd.lang.java.symbols.internal.impl.reflect.ReflectSymInternals.LONG_SYM;\nimport static net.sourceforge.pmd.lang.java.symbols.internal.impl.reflect.ReflectSymInternals.OBJECT_SYM;\nimport static net.sourceforge.pmd.lang.java.symbols.internal.impl.reflect.ReflectSymInternals.SERIALIZABLE_SYM;\nimport static net.sourceforge.pmd.lang.java.symbols.internal.impl.reflect.ReflectSymInternals.SHORT_SYM;\nimport static net.sourceforge.pmd.lang.java.symbols.internal.impl.reflect.ReflectSymInternals.STRING_SYM;\nimport static net.sourceforge.pmd.lang.java.symbols.internal.impl.reflect.ReflectSymInternals.VOID_SYM;\nimport static net.sourceforge.pmd.lang.java.symbols.internal.impl.reflect.ReflectedClassImpl.createOuterClass;\nimport static net.sourceforge.pmd.lang.java.symbols.internal.impl.reflect.ReflectedClassImpl.createWithEnclosing;\n\nimport java.io.Serializable;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport org.checkerframework.checker.nullness.qual.Nullable;\n\nimport net.sourceforge.pmd.lang.java.symbols.JClassSymbol;\nimport net.sourceforge.pmd.lang.java.symbols.internal.impl.SymbolFactory;\n\n/**\n * Symbol factory building type symbols from {@link Class} instances.\n * Reflected symbol implementations carry an instance of this around,\n * so as to allow caching recently accessed symbols later on.\n */\npublic final class ReflectionSymFactory implements SymbolFactory<Class<?>> {\n\n    /**\n     * Lazy initialized to avoid class init cycle, because\n     * {@link SymbolFactory} creates reflected symbols.\n     */\n    private static Map<Class<?>, JClassSymbol> commonSymbols;\n\n    @Override\n    @Nullable\n    public JClassSymbol getClassSymbol(@Nullable Class<?> klass) {\n        if (klass == null) {\n            return null;\n        }\n\n        Map<Class<?>, JClassSymbol> shared = getCommonSyms();\n        if (shared.containsKey(klass)) {\n            return shared.get(klass);\n        }\n\n        if (klass.getEnclosingClass() != null) {\n            JClassSymbol enclosing = getClassSymbol(klass.getEnclosingClass());\n            assert enclosing != null;\n            return createWithEnclosing(this, enclosing, klass);\n        }\n\n        if (klass.isArray()) {\n            JClassSymbol component = getClassSymbol(klass.getComponentType());\n            return makeArraySymbol(component);\n        }\n\n        return createOuterClass(this, klass);\n    }\n\n    private static Map<Class<?>, JClassSymbol> getCommonSyms() {\n        Map<Class<?>, JClassSymbol> shared = commonSymbols;\n        if (shared == null) {\n            synchronized (ReflectionSymFactory.class) {\n                shared = commonSymbols;\n                if (shared == null) {\n                    shared = initCommonSyms();\n                    commonSymbols = shared;\n                }\n            }\n        }\n        return shared;\n    }\n\n    private static void putStr(Map<Class<?>, JClassSymbol> byClass,\n                               Class<?> booleanClass,\n                               JClassSymbol booleanSym) {\n        byClass.put(booleanClass, booleanSym);\n    }\n\n\n    private static Map<Class<?>, JClassSymbol> initCommonSyms() {\n        // consider putting whole java.lang + java.util in there ?\n\n        Map<Class<?>, JClassSymbol> specials = new HashMap<>();\n\n        putStr(specials, Object.class, OBJECT_SYM);\n\n        putStr(specials, boolean.class, BOOLEAN_SYM);\n        putStr(specials, byte.class, BYTE_SYM);\n        putStr(specials, char.class, CHAR_SYM);\n        putStr(specials, double.class, DOUBLE_SYM);\n        putStr(specials, float.class, FLOAT_SYM);\n        putStr(specials, int.class, INT_SYM);\n        putStr(specials, long.class, LONG_SYM);\n        putStr(specials, short.class, SHORT_SYM);\n        putStr(specials, void.class, VOID_SYM);\n\n        putStr(specials, Cloneable.class, CLONEABLE_SYM);\n        putStr(specials, Serializable.class, SERIALIZABLE_SYM);\n\n        putStr(specials, Boolean.class, BOXED_BOOLEAN_SYM);\n        putStr(specials, Byte.class, BOXED_BYTE_SYM);\n        putStr(specials, Character.class, BOXED_CHAR_SYM);\n        putStr(specials, Double.class, BOXED_DOUBLE_SYM);\n        putStr(specials, Float.class, BOXED_FLOAT_SYM);\n        putStr(specials, Integer.class, BOXED_INT_SYM);\n        putStr(specials, Long.class, BOXED_LONG_SYM);\n        putStr(specials, Short.class, BOXED_SHORT_SYM);\n        putStr(specials, Void.class, BOXED_VOID_SYM);\n\n        putStr(specials, Iterable.class, ITERABLE_SYM);\n        putStr(specials, Enum.class, ENUM_SYM);\n        putStr(specials, String.class, STRING_SYM);\n\n        return Collections.unmodifiableMap(specials);\n    }\n\n}\n", "filePathAfter": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/TypeSystem.java", "sourceCodeAfterForWhole": "/*\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.lang.java.types;\n\nimport static java.util.Collections.emptyList;\nimport static net.sourceforge.pmd.util.CollectionUtil.immutableSetOf;\n\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.EnumMap;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.ListIterator;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Set;\nimport java.util.function.Function;\n\nimport org.checkerframework.checker.nullness.qual.NonNull;\nimport org.checkerframework.checker.nullness.qual.Nullable;\n\nimport net.sourceforge.pmd.annotation.InternalApi;\nimport net.sourceforge.pmd.internal.util.AssertionUtil;\nimport net.sourceforge.pmd.lang.java.symbols.JClassSymbol;\nimport net.sourceforge.pmd.lang.java.symbols.JExecutableSymbol;\nimport net.sourceforge.pmd.lang.java.symbols.JTypeDeclSymbol;\nimport net.sourceforge.pmd.lang.java.symbols.JTypeParameterSymbol;\nimport net.sourceforge.pmd.lang.java.symbols.SymbolResolver;\nimport net.sourceforge.pmd.lang.java.symbols.internal.impl.SymbolFactory;\nimport net.sourceforge.pmd.lang.java.symbols.internal.impl.asm.AsmSymbolResolver;\nimport net.sourceforge.pmd.lang.java.symbols.internal.impl.reflect.ReflectedSymbols;\nimport net.sourceforge.pmd.lang.java.types.JPrimitiveType.PrimitiveTypeKind;\nimport net.sourceforge.pmd.lang.java.types.internal.infer.JInferenceVar;\n\n/**\n * Root context object for type analysis. Type systems own a {@link SymbolFactory},\n * which creates and caches symbols. Methods of this class promote symbols\n * to types, and compose types together. {@link TypeOps} and {@link TypeConversion}\n * have some more operations on types.\n *\n * <p>Some special types are presented as constant fields, eg {@link #OBJECT}\n * or {@link #NULL_TYPE}. These are always comparable by reference.\n */\npublic final class TypeSystem {\n\n    /** Top type of the reference type system. */\n    public final JClassType OBJECT;\n\n    /**\n     * The bottom type of the reference type system. This is named\n     * the <i>null type</i> in the JLS and is not denotable in Java\n     * programs.\n     *\n     * <p>This implementation uses this as the type of the 'null' literal.\n     */\n    public final JTypeMirror NULL_TYPE = new JTypeMirror() {\n\n        @Override\n        public JTypeMirror subst(Function<? super SubstVar, ? extends @NonNull JTypeMirror> subst) {\n            return this;\n        }\n\n        @Override\n        public TypeSystem getTypeSystem() {\n            return TypeSystem.this;\n        }\n\n        @Override\n        public @Nullable JClassSymbol getSymbol() {\n            return null;\n        }\n\n        @Override\n        public <T, P> T acceptVisitor(JTypeVisitor<T, P> visitor, P p) {\n            return visitor.visitNullType(this, p);\n        }\n\n        @Override\n        public String toString() {\n            return \"null\";\n        }\n    };\n\n\n    // primitives\n    public final JPrimitiveType BOOLEAN;\n    public final JPrimitiveType CHAR;\n    public final JPrimitiveType BYTE;\n    public final JPrimitiveType SHORT;\n    public final JPrimitiveType INT;\n    public final JPrimitiveType LONG;\n    public final JPrimitiveType FLOAT;\n    public final JPrimitiveType DOUBLE;\n\n    /**\n     * The set of all primitive types. See {@link #getPrimitive(PrimitiveTypeKind)}.\n     */\n    public final Set<JPrimitiveType> allPrimitives;\n    private final EnumMap<PrimitiveTypeKind, JPrimitiveType> primitivesByKind;\n\n    /**\n     * A constant to represent the normal absence of a type. The\n     * primitive {@code void.class} represents that type, and this\n     * is the return type of a void method.\n     *\n     * <p>Note that the type of the class literal {@code void.class}\n     * is {@code Class<java.lang.Void>}, not NO_TYPE.\n     */\n    public final JTypeMirror NO_TYPE;\n\n    /**\n     * A constant to represent an unresolved type. This means, that resolution\n     * was attempted but failed and shouldn't be tried again.\n     */\n    public final JTypeMirror UNRESOLVED_TYPE;\n\n    /**\n     * Sentinel value for an unresolved method. This type corresponds to\n     * a method declaration in the type {@link #UNRESOLVED_TYPE},\n     * returning {@link #UNRESOLVED_TYPE}.\n     */\n    // TODO it doesn't need to be declared in UNRESOLVED_TYPE\n    public final JMethodSig UNRESOLVED_METHOD = new UnresolvedMethodSig(this);\n\n    /**\n     * A constant to represent a typing error. This would have been\n     * reported by a compiler.\n     */\n    public final JTypeMirror ERROR_TYPE = new SentinelType(this, \"/*error*/\");\n\n    /*\n     * Common, non-special types.\n     */\n\n    /** The unbounded wildcard, \"?\". */\n    public final JWildcardType UNBOUNDED_WILD;\n\n    // array supertypes\n    public final JClassType CLONEABLE;\n    public final JClassType SERIALIZABLE;\n\n    /**\n     * This is the boxed type of {@code Void.class}, not to be confused with\n     * {@code void.class}, which in this framework is represented by\n     * {@link #NO_TYPE}.\n     */\n    public final JClassType BOXED_VOID;\n\n\n    private final SymbolFactory symbolFactory;\n\n    /** Contains special types, that must be shared to be comparable by reference. */\n    private final Map<JTypeDeclSymbol, JTypeMirror> sharedTypes;\n    // test only\n    final AsmSymbolResolver resolver;\n\n    /**\n     * Builds a new type system. Its public fields will be initialized\n     * with fresh types, unrelated to other types.\n     *\n     * @param bootstrapResourceLoader Classloader used to resolve class files\n     *                                to populate the fields of the new type\n     *                                system\n     */\n    public TypeSystem(ClassLoader bootstrapResourceLoader) {\n        this.resolver = new AsmSymbolResolver(this, bootstrapResourceLoader);\n        this.symbolFactory = new SymbolFactory(this);\n\n        // initialize primitives. their constructor also initializes their box + box erasure\n\n        BOOLEAN = createPrimitive(PrimitiveTypeKind.BOOLEAN, Boolean.class);\n        CHAR = createPrimitive(PrimitiveTypeKind.CHAR, Character.class);\n        BYTE = createPrimitive(PrimitiveTypeKind.BYTE, Byte.class);\n        SHORT = createPrimitive(PrimitiveTypeKind.SHORT, Short.class);\n        INT = createPrimitive(PrimitiveTypeKind.INT, Integer.class);\n        LONG = createPrimitive(PrimitiveTypeKind.LONG, Long.class);\n        FLOAT = createPrimitive(PrimitiveTypeKind.FLOAT, Float.class);\n        DOUBLE = createPrimitive(PrimitiveTypeKind.DOUBLE, Double.class);\n\n        // this relies on the fact that setOf always returns immutable sets\n        BOOLEAN.superTypes = immutableSetOf(BOOLEAN);\n        CHAR.superTypes = immutableSetOf(CHAR, INT, LONG, FLOAT, DOUBLE);\n        BYTE.superTypes = immutableSetOf(BYTE, SHORT, INT, LONG, FLOAT, DOUBLE);\n        SHORT.superTypes = immutableSetOf(SHORT, INT, LONG, FLOAT, DOUBLE);\n        INT.superTypes = immutableSetOf(INT, LONG, FLOAT, DOUBLE);\n        LONG.superTypes = immutableSetOf(LONG, FLOAT, DOUBLE);\n        FLOAT.superTypes = immutableSetOf(FLOAT, DOUBLE);\n        DOUBLE.superTypes = immutableSetOf(DOUBLE);\n\n        this.allPrimitives = immutableSetOf(BOOLEAN, CHAR, BYTE, SHORT, INT, LONG, FLOAT, DOUBLE);\n        this.primitivesByKind = new EnumMap<>(PrimitiveTypeKind.class);\n        primitivesByKind.put(PrimitiveTypeKind.BOOLEAN, BOOLEAN);\n        primitivesByKind.put(PrimitiveTypeKind.CHAR, CHAR);\n        primitivesByKind.put(PrimitiveTypeKind.BYTE, BYTE);\n        primitivesByKind.put(PrimitiveTypeKind.SHORT, SHORT);\n        primitivesByKind.put(PrimitiveTypeKind.INT, INT);\n        primitivesByKind.put(PrimitiveTypeKind.LONG, LONG);\n        primitivesByKind.put(PrimitiveTypeKind.FLOAT, FLOAT);\n        primitivesByKind.put(PrimitiveTypeKind.DOUBLE, DOUBLE);\n\n        JClassSymbol unresolvedTypeSym = symbolFactory.makeUnresolvedReference(\"/*unresolved*/\", 0);\n        UNRESOLVED_TYPE = new SentinelType(this, \"/*unresolved*/\") {\n            @Override\n            public JTypeDeclSymbol getSymbol() {\n                return unresolvedTypeSym;\n            }\n        };\n\n        JClassSymbol primitiveVoidSym = ReflectedSymbols.getClassSymbol(symbolFactory, void.class);\n        assert primitiveVoidSym != null : \"void\";\n        NO_TYPE = new SentinelType(this, \"void\") {\n            @Override\n            public JTypeDeclSymbol getSymbol() {\n                return primitiveVoidSym;\n            }\n        };\n\n        // reuse instances for common types\n\n        // this map is vital to preserve some of the invariants of\n        // the framework, e.g., that primitive types are never represented\n        // by a ClassType, or that OBJECT is unique\n\n        // this is only appropriate for non-generic types\n\n        Map<JClassSymbol, JTypeMirror> shared = new HashMap<>();\n\n        OBJECT = addSpecial(Object.class, shared);\n        SERIALIZABLE = addSpecial(Serializable.class, shared);\n        CLONEABLE = addSpecial(Cloneable.class, shared);\n        BOXED_VOID = addSpecial(Void.class, shared);\n\n        shared.put(primitiveVoidSym, NO_TYPE);\n        shared.put(unresolvedTypeSym, UNRESOLVED_TYPE);\n\n        for (JPrimitiveType prim : allPrimitives) {\n            // primitives have a special implementation for their box\n            shared.put(prim.getSymbol(), prim);\n            shared.put(prim.box().getSymbol(), prim.box());\n        }\n\n        // make it really untouchable\n        this.sharedTypes = Collections.unmodifiableMap(new HashMap<>(shared));\n\n        UNBOUNDED_WILD = new WildcardTypeImpl(this, true, OBJECT);\n    }\n\n    @SuppressWarnings(\"IncompleteCopyConstructor\")\n    private TypeSystem(TypeSystem other) {\n        // create a new symbol factory, with an independent cache.\n        this.symbolFactory = new SymbolFactory(this);\n\n        this.resolver = other.resolver;\n        this.sharedTypes = other.sharedTypes;\n\n        this.OBJECT = other.OBJECT;\n        this.BOOLEAN = other.BOOLEAN;\n        this.CHAR = other.CHAR;\n        this.BYTE = other.BYTE;\n        this.SHORT = other.SHORT;\n        this.INT = other.INT;\n        this.LONG = other.LONG;\n        this.FLOAT = other.FLOAT;\n        this.DOUBLE = other.DOUBLE;\n        this.NO_TYPE = other.NO_TYPE;\n        this.allPrimitives = other.allPrimitives;\n        this.primitivesByKind = other.primitivesByKind;\n\n        this.UNRESOLVED_TYPE = other.UNRESOLVED_TYPE;\n        this.UNBOUNDED_WILD = other.UNBOUNDED_WILD;\n        this.CLONEABLE = other.CLONEABLE;\n        this.SERIALIZABLE = other.SERIALIZABLE;\n        this.BOXED_VOID = other.BOXED_VOID;\n    }\n\n    /**\n     * Returns a new, distinct type system, which caches symbols independently\n     * of this one. Constants such as {@link #INT} or {@link #OBJECT} are\n     * shared between this type system and all the sub-systems it spawns.\n     *\n     * <p>This provides a simple mechanism to localize cached symbols.\n     * Each file gets its own \"scope\", which, when garbage-collected,\n     * reclaims all symbols cached for the file. This also avoids concurrency\n     * issues.\n     *\n     * @return A new type system, based on this one.\n     */\n    public TypeSystem newScope() {\n        return new TypeSystem(this);\n    }\n\n    /**\n     * Returns the symbol factory associated with this type system.\n     * This is internal API, symbols are low-level abstractions that\n     * should not be created manually.\n     */\n    @InternalApi\n    public SymbolFactory symbols() {\n        return symbolFactory;\n    }\n\n    /**\n     * Returns the bootstrap symbol resolver. Concrete analysis passes\n     * may decorate this with different resolvers.\n     */\n    public SymbolResolver bootstrapResolver() {\n        return resolver;\n    }\n\n    // helpers for the constructor, cannot use typeOf, only for trusted types\n\n    private JClassType addSpecial(Class<?> klass, Map<JClassSymbol, JTypeMirror> shared) {\n        JClassSymbol sym = getBootStrapSymbol(klass);\n        JClassType nonErased = new ClassTypeImpl(this, sym, emptyList(), false);\n        shared.put(sym, nonErased);\n        return nonErased;\n    }\n\n    private JClassSymbol getBootStrapSymbol(Class<?> clazz) {\n        AssertionUtil.requireParamNotNull(\"clazz\", clazz);\n        JClassSymbol sym = resolver.resolveClassFromBinaryName(clazz.getName());\n        return Objects.requireNonNull(sym, \"sym\");\n    }\n\n    @NonNull\n    private JPrimitiveType createPrimitive(PrimitiveTypeKind kind, Class<?> box) {\n        return new JPrimitiveType(this, kind, new PrimitiveSymbol(this, kind), getBootStrapSymbol(box));\n    }\n\n\n    // type creation routines\n\n    /**\n     * Returns the class symbol for the given reflected class. This asks\n     * the classloader of this type system, but never returns null. Returns\n     * null if the parameter is null.\n     *\n     * @param clazz Class\n     */\n    @Nullable\n    public JClassSymbol getClassSymbol(@Nullable Class<?> clazz) {\n        if (clazz == null) {\n            return null;\n        } else if (clazz.isPrimitive()) {\n            return getPrimitive(PrimitiveTypeKind.fromName(clazz.getName())).getSymbol();\n        } else if (clazz.isArray()) {\n            return symbols().makeArraySymbol(getClassSymbol(clazz.getComponentType()));\n        }\n\n        JClassSymbol classLoaderPreferred = resolver.resolveClassFromBinaryName(clazz.getName());\n        if (classLoaderPreferred != null) {\n            return classLoaderPreferred;\n        }\n        return ReflectedSymbols.getClassSymbol(symbols(), clazz);\n    }\n\n    /**\n     * Returns a type mirror for the given symbol. If the symbol declares\n     * type parameters, then the resulting type is raw (differs from the\n     * behaviour of {@link #declaration(JClassSymbol)}), meaning all its\n     * supertypes are erased.\n     *\n     * <p>If the symbol is a {@link JTypeParameterSymbol type parameter},\n     * returns a {@link JTypeVar}.\n     *\n     * <p>If the symbol is a {@link JClassSymbol}, then:\n     * <ul>\n     * <li>If it represents a primitive type, the corresponding {@link JPrimitiveType}\n     * is returned (one of {@link #INT}, {@link #CHAR}, etc.).\n     * <li>If it represents an array type, a new {@link JArrayType} is\n     * returned. Note that the component type will always be erased;\n     * creating a generic array type should instead be done with\n     * {@link #arrayType(JTypeMirror, int)}.\n     * <li>If it represents a class or interface type, a {@link JClassType}\n     * is returned.\n     * <ul>\n     *     <li>If the parameter {@code isErased} is true, then the type\n     *     will be {@linkplain JClassType#hasErasedSuperTypes() erased},\n     *     which means all its generic supertypes are erased. In particular,\n     *     if the symbol declares type parameters itself, then it will be a\n     *     {@linkplain JClassType#isRaw() raw type}.\n     *     <li>Otherwise, the generic supertypes are preserved. In particular,\n     *     if the symbol declares type parameters itself, then it will\n     *     be a {@linkplain JClassType#isGenericTypeDeclaration() generic type declaration}.\n     * </ul>\n     * If the symbol is a non-static member of another class, then the given\n     * type's {@linkplain JClassType#getEnclosingType() enclosing type} is\n     * created, applying the above rules about erasure recursively. A type\n     * is either completely erased, or completely parameterized.\n     * </li>\n     * </ul>\n     *\n     * @param symbol   Symbol for the type declaration\n     * @param isErased Whether the type should be consider erased, if it\n     *                 represents a class or interface type. This does not\n     *                 erase type variables, or array types for that matter.\n     *\n     * @throws NullPointerException if the symbol is null\n     */\n    public JTypeMirror typeOf(JTypeDeclSymbol symbol, boolean isErased) {\n        Objects.requireNonNull(symbol, \"Argument shouldn't be null\");\n\n        // takes care of primitives, and constants like OBJECT or UNRESOLVED_TYPE\n        JTypeMirror common = specialCache(symbol);\n        if (common != null) {\n            return common;\n        }\n\n        if (symbol instanceof JClassSymbol) {\n            JClassSymbol classSym = (JClassSymbol) symbol;\n            if (classSym.isArray()) {\n                // generic array types are represented by a special\n                // type in the j.l.reflect API, so the component is\n                // also raw\n                JTypeMirror component = rawType(classSym.getArrayComponent());\n                return arrayType(component, 1);\n            } else {\n                return new ClassTypeImpl(this, classSym, emptyList(), !isErased);\n            }\n        } else if (symbol instanceof JTypeParameterSymbol) {\n            return ((JTypeParameterSymbol) symbol).getTypeMirror();\n        }\n        throw new AssertionError(\"Uncategorized type symbol \" + symbol.getClass() + \": \" + symbol);\n    }\n\n    /**\n     * Like {@link #typeOf(JTypeDeclSymbol, boolean)}, defaulting the\n     * erased parameter to\n     * @param klass\n     * @return\n     */\n    public JTypeMirror rawType(JTypeDeclSymbol klass) {\n        return typeOf(klass, true);\n    }\n\n    public JTypeMirror declaration(JClassSymbol klass) {\n        return typeOf(klass, false);\n    }\n\n\n    @NonNull\n    public JTypeMirror parameterise(JClassSymbol klass, List<? extends JTypeMirror> typeArgs) {\n        Objects.requireNonNull(klass, \"Null class symbol\");\n        Objects.requireNonNull(typeArgs, \"Null type arguments, use an empty list!\");\n\n        if (!klass.isUnresolved() && !typeArgs.isEmpty() && klass.getTypeParameterCount() != typeArgs.size()) {\n            throw new IllegalArgumentException(\"Cannot parameterize \" + klass + \" with \" + typeArgs);\n        } else if (typeArgs.isEmpty()) {\n            return rawType(klass);\n        }\n\n        // if the type arguments are mismatched, the constructor will throw\n        return new ClassTypeImpl(this, klass, new ArrayList<>(typeArgs), false);\n    }\n\n\n    /**\n     * Returns a new type variable for\n     */\n    public JTypeVar.FreshTypeVar newTypeVar(JTypeParameterSymbol symbol) {\n        return new TypeVarImpl(this, symbol);\n    }\n\n\n    /**\n     * Creates a new array type from an arbitrary element type.\n     *\n     * <pre>{@code\n     * arrayType(T, 0)          = T\n     * arrayType(T, 1)          = T[]\n     * arrayType(T, 3)          = T[][][]\n     * arrayType(T[], 2)        = T[][][]\n     * arrayType(ERROR_TYPE, _) = ERROR_TYPE\n     * }</pre>\n     *\n     * @param element       Element type\n     * @param numDimensions Number of dimensions\n     *\n     * @return A new array type\n     *\n     * @throws IllegalArgumentException If numDimensions is negative\n     * @throws IllegalArgumentException If the element type is a {@link JWildcardType},\n     *                                  the null type, or {@link #NO_TYPE void}.\n     * @throws NullPointerException     If the element type is null\n     */\n    public JTypeMirror arrayType(@NonNull JTypeMirror element, int numDimensions) {\n        AssertionUtil.requireNonNegative(\"numDimensions\", numDimensions);\n        AssertionUtil.requireParamNotNull(\"elementType\", element);\n\n        if (element instanceof JWildcardType\n            || element == NULL_TYPE\n            || element == NO_TYPE) {\n            throw new IllegalArgumentException(\"The type < \" + element + \" > is not a valid array element type \");\n        }\n\n        if (numDimensions == 0 || element == ERROR_TYPE) {\n            return element;\n        }\n\n        JArrayType res = new ArrayTypeImpl(this, element);\n        while (--numDimensions > 0) {\n            res = new ArrayTypeImpl(this, res);\n        }\n        return res;\n    }\n\n    public JMethodSig sigOf(JExecutableSymbol methodSym) {\n        return sigOf(methodSym, Substitution.EMPTY);\n    }\n\n    public JMethodSig sigOf(JExecutableSymbol methodSym, Substitution subst) {\n        JClassType klass = (JClassType) declaration(methodSym.getEnclosingClass());\n        return new ClassMethodSigImpl(klass.subst(subst), methodSym);\n    }\n\n    /**\n     * Builds an intersection type for the specified component types.\n     * This does not necessarily return a {@link JIntersectionType}.\n     *\n     * @param types Types to intersect\n     *\n     * @return An intersection type\n     *\n     * @throws NullPointerException     If the collection is null\n     * @throws IllegalArgumentException If the collection is empty\n     */\n    public JTypeMirror intersect(Collection<? extends JTypeMirror> types) {\n        if (types.isEmpty()) {\n            throw new IllegalArgumentException(\"Cannot intersect zero types\");\n        } else if (types.size() == 1) {\n            return types.iterator().next();\n        }\n        return new IntersectionTypeImpl(this, new ArrayList<>(types));\n    }\n\n\n    /**\n     * Builds a wildcard type with a single bound.\n     *\n     * <pre>{@code\n     *\n     * wildcard(true, T)      = ? extends T\n     * wildcard(false, T)     = ? super T\n     * wildcard(true, OBJECT) = ?\n     * wildcard(_, ERROR_TYPE) = ERROR_TYPE\n     *\n     * }</pre>\n     *\n     * @param isUpperBound If true, this is an \"extends\" wildcard, otherwise a \"super\"\n     * @param bound        Bound of the wildcard\n     *\n     * @return A wildcard\n     *\n     * @throws NullPointerException     If the bound is null\n     * @throws IllegalArgumentException If the bound is a primitive type,\n     *                                  or a wildcard type\n     * @throws IllegalArgumentException If the bound is OBJECT and this\n     *                                  is a lower-bounded wildcard (? super Object)\n     */\n    public JTypeMirror wildcard(boolean isUpperBound, @NonNull JTypeMirror bound) {\n        Objects.requireNonNull(bound, \"Argument shouldn't be null\");\n        if (bound == ERROR_TYPE) {\n            return bound;\n        }\n        if (bound.isPrimitive() || bound instanceof JWildcardType) {\n            throw new IllegalArgumentException(\"<\" + bound + \"> cannot be a wildcard bound\");\n        }\n        return isUpperBound && bound == OBJECT ? UNBOUNDED_WILD\n                                               : new WildcardTypeImpl(this, isUpperBound, bound);\n    }\n\n    /**\n     * Maps a type decl symbol to its shared representation. Eg this\n     * maps the symbol for {@code int.class} to {@link #INT}. Only\n     * non-generic types are cached.\n     */\n    private @Nullable JTypeMirror specialCache(JTypeDeclSymbol raw) {\n        return sharedTypes.get(raw);\n    }\n\n\n    /**\n     * Gets the primitive type identified by the given kind.\n     *\n     * @param kind Kind of primitive type\n     *\n     * @return A primitive type, or null if the argument is null\n     */\n    @Nullable\n    public JPrimitiveType getPrimitive(PrimitiveTypeKind kind) {\n        return primitivesByKind.get(kind);\n    }\n\n    /**\n     * The least upper bound, or \"lub\", of a set of reference types is\n     * a shared supertype that is more specific than any other shared\n     * supertype (that is, no other shared supertype is a subtype of the\n     * least upper bound).\n     *\n     * @throws IllegalArgumentException If types is empty\n     * @throws NullPointerException     If types is null\n     */\n    public JTypeMirror lub(Collection<? extends JTypeMirror> types) {\n        return Lub.lub(this, types);\n    }\n\n    /**\n     * Returns the greatest lower bound of the given set of types.\n     * This is defined in JLS\u00a75.1.10 (Capture Conversion):\n     *\n     * <blockquote>\n     * glb(V1,...,Vm) = V1 & ... & Vm\n     * glb(V) = V\n     * </blockquote>\n     *\n     * @throws IllegalArgumentException If some component is not a class, array, or wildcard type\n     * @throws IllegalArgumentException If there is more than one minimal class or array type\n     * @throws IllegalArgumentException If types is empty\n     * @throws NullPointerException     If types is null\n     */\n    public JTypeMirror glb(Collection<? extends JTypeMirror> types) {\n        if (types.isEmpty()) {\n            throw new IllegalArgumentException(\"Cannot compute GLB of empty set\");\n        }\n\n\n        ArrayList<JTypeMirror> list = new ArrayList<>(types.size());\n\n        for (JTypeMirror type : types) {\n            // flatten intersections: (A & (B & C)) => (A & B & C)\n            if (type instanceof JIntersectionType) {\n                list.addAll(((JIntersectionType) type).getComponents());\n            } else {\n                list.add(type);\n            }\n        }\n\n\n        JTypeMirror ck = OBJECT; // Ck is a class type\n\n        for (ListIterator<JTypeMirror> iterator = list.listIterator(); iterator.hasNext(); ) {\n            JTypeMirror ci = iterator.next();\n\n            if (ci.isPrimitive() || ci instanceof JWildcardType || ci instanceof JIntersectionType) {\n                throw new IllegalArgumentException(\"Bad intersection type component: \" + ci + \" in \" + types);\n            }\n\n            if (!isPossiblyAnInterface(ci)) {\n                // either Ci is an array, or Ci is a class\n                // Ci is not unresolved\n\n                if (ci.isSubtypeOf(ck)) {\n                    ck = ci; // Ci is more specific than Ck\n                    iterator.remove(); // remove bound\n                } else if (ck.isSubtypeOf(ci)) {\n                    // then our Ck is already more specific than Ci\n                    iterator.remove();\n                } else {\n                    throw new IllegalArgumentException(\n                        \"Bad intersection, unrelated class types \" + ci + \" and \" + ck + \" in \" + types);\n                }\n            } else if (!(ci instanceof JInferenceVar) && ck.isSubtypeOf(ci)) {\n                // then our Ck is already more specific than Ci\n                iterator.remove();\n            }\n        }\n\n        if (list.isEmpty()) {\n            return ck;\n        }\n\n        if (ck != OBJECT) {\n            // readd ck as first component\n            list.add(0, ck);\n        }\n\n        if (list.size() == 1) {\n            return list.get(0);\n        }\n\n        if (ck instanceof JTypeVar) {\n            return new IntersectionTypeImpl(this, list);\n        }\n\n        // We assume there cannot be an array type here. Why?\n        // In well-formed java programs an array type in a GLB can only occur in the following situation\n        //\n        // class C<T extends B1 & .. & Bn>      // nota: the Bi cannot be array types\n        //\n        // Somewhere: C<? extends Arr[]>\n\n        // And capture would merge the bounds of the wildcard and of the tvar\n        // into Arr[] & B1 & .. & Bn\n        // Now the C<? ...> would only typecheck if Arr[] <: Bi forall i\n        // (Note that this means, that Bi in { Serializable, Cloneable, Object })\n\n        // This means, that the loop above would find Ck = Arr[], and delete all Bi, since Ck <: Bi\n        // So in the end, we would return Arr[] alone, not create an intersection\n        // TODO this is order dependent: Arr[] & Serializable is ok, but Serializable & Arr[] is not\n        //   Possibly use TypeOps::mostSpecific to merge them\n        assert ck instanceof JClassType : \"Weird intersection involving multiple array types? \" + list;\n\n        return new IntersectionTypeImpl.MinimalIntersection(this, (JClassType) ck, list);\n    }\n\n\n    private boolean isPossiblyAnInterface(JTypeMirror ci) {\n        return ci.isInterface()\n            || ci instanceof JInferenceVar\n            || (ci.getSymbol() != null && ci.getSymbol().isUnresolved());\n    }\n\n    // package-private\n    JClassType erasedType(JClassSymbol symbol) {\n        JTypeMirror t = specialCache(symbol);\n        if (t != null) {\n            return (JClassType) t.getErasure();\n        } else {\n            return new ErasedClassType(this, symbol);\n        }\n    }\n}\n", "diffSourceCodeSet": ["/**\n     * Gets the primitive type identified by the given kind.\n     *\n     * @param kind Kind of primitive type\n     *\n     * @return A primitive type, or null if the argument is null\n     */\n    @Nullable\n    public JPrimitiveType getPrimitive(PrimitiveTypeKind kind) {\n        return primitivesByKind.get(kind);\n    }"], "invokedMethodSet": ["methodSignature: net.sourceforge.pmd.lang.java.symbols.internal.impl.reflect.ReflectedClassImpl#getEnclosingClass\n methodBody: public JClassSymbol getEnclosingClass() {\nreturn enclosing;\n}", "methodSignature: net.sourceforge.pmd.lang.java.symbols.internal.impl.SymbolFactory#getClassSymbol\n methodBody: JClassSymbol getClassSymbol(@Nullable T klass);", "methodSignature: net.sourceforge.pmd.lang.java.symbols.internal.impl.UnresolvedClassImpl#getEnclosingClass\n methodBody: public JClassSymbol getEnclosingClass() {\nreturn enclosing;\n}", "methodSignature: net.sourceforge.pmd.lang.java.symbols.internal.impl.reflect.ReflectionSymFactory#getClassSymbol\n methodBody: public JClassSymbol getClassSymbol(@Nullable Class<?> klass) {\nif(klass == null){return null;\n}Map<Class<?>,JClassSymbol> shared=getCommonSyms();\nif(shared.containsKey(klass)){return shared.get(klass);\n}if(klass.getEnclosingClass() != null){JClassSymbol enclosing=getClassSymbol(klass.getEnclosingClass());\nassert enclosing != null;\nreturn createWithEnclosing(this,enclosing,klass);\n}if(klass.isArray()){JClassSymbol component=getClassSymbol(klass.getComponentType());\nreturn makeArraySymbol(component);\n}return createOuterClass(this,klass);\n}", "methodSignature: net.sourceforge.pmd.lang.java.symbols.internal.impl.reflect.ReflectedClassImpl#createWithEnclosing\n methodBody: static ReflectedClassImpl createWithEnclosing(ReflectionSymFactory symbolFactory,\n                                                  @Nullable JClassSymbol enclosing,\n                                                  Class<?> myClass) {\nreturn new ReflectedClassImpl(symbolFactory,enclosing,myClass);\n}", "methodSignature: net.sourceforge.pmd.lang.java.symbols.internal.impl.UnresolvedClassImpl#isArray\n methodBody: public boolean isArray() {\nreturn false;\n}", "methodSignature: net.sourceforge.pmd.lang.java.symbols.internal.impl.reflect.AbstractReflectedExecutableSymbol#getEnclosingClass\n methodBody: public final JClassSymbol getEnclosingClass() {\nreturn owner;\n}", "methodSignature: net.sourceforge.pmd.lang.java.symbols.internal.impl.reflect.ReflectedClassImpl#createOuterClass\n methodBody: static ReflectedClassImpl createOuterClass(ReflectionSymFactory symbolFactory, Class<?> myClass) {\nreturn new ReflectedClassImpl(symbolFactory,myClass);\n}", "methodSignature: net.sourceforge.pmd.lang.java.symbols.internal.impl.ImplicitMemberSymbols.FakeExecutableSymBase#getEnclosingClass\n methodBody: public @NonNull JClassSymbol getEnclosingClass() {\nreturn owner;\n}", "methodSignature: net.sourceforge.pmd.lang.java.symbols.internal.impl.ArraySymbolImpl#isArray\n methodBody: public boolean isArray() {\nreturn true;\n}", "methodSignature: net.sourceforge.pmd.lang.java.symbols.internal.impl.reflect.ReflectedClassImpl#isArray\n methodBody: public boolean isArray() {\nreturn false;\n}", "methodSignature: net.sourceforge.pmd.lang.java.symbols.internal.impl.ast.AstClassSym#getEnclosingClass\n methodBody: public @Nullable JClassSymbol getEnclosingClass() {\nif(enclosing instanceof JClassSymbol){return (JClassSymbol)enclosing;\n}if(enclosing instanceof JExecutableSymbol){return enclosing.getEnclosingClass();\n}assert enclosing == null;\nreturn null;\n}", "methodSignature: net.sourceforge.pmd.lang.java.symbols.internal.impl.ast.AstFieldSym#getEnclosingClass\n methodBody: public @NonNull JClassSymbol getEnclosingClass() {\nreturn owner;\n}", "methodSignature: net.sourceforge.pmd.lang.java.symbols.internal.impl.ArraySymbolImpl#getEnclosingClass\n methodBody: public JClassSymbol getEnclosingClass() {\nreturn null;\n}", "methodSignature: net.sourceforge.pmd.lang.java.symbols.internal.impl.ImplicitMemberSymbols.FakeFieldSym#getEnclosingClass\n methodBody: public @NonNull JClassSymbol getEnclosingClass() {\nreturn owner;\n}", "methodSignature: net.sourceforge.pmd.lang.java.symbols.JTypeParameterSymbol#getEnclosingClass\n methodBody: default JClassSymbol getEnclosingClass() {\nJTypeParameterOwnerSymbol ownerSymbol=getDeclaringSymbol();\nreturn ownerSymbol instanceof JClassSymbol ? (JClassSymbol)ownerSymbol : ownerSymbol.getEnclosingClass();\n}", "methodSignature: net.sourceforge.pmd.typeresolution.testdata.LocalGenericClass.localClassInGeneric.MyLocalClass#get\n methodBody: public Optional<T> get() {\nreturn Optional.empty();\n}", "methodSignature: net.sourceforge.pmd.lang.java.symbols.JAccessibleElementSymbol#getEnclosingClass\n methodBody: JClassSymbol getEnclosingClass();", "methodSignature: net.sourceforge.pmd.lang.java.symbols.internal.impl.SymbolFactory#makeArraySymbol\n methodBody: default JClassSymbol makeArraySymbol(JTypeDeclSymbol component) {\nreturn new ArraySymbolImpl(this,component);\n}", "methodSignature: net.sourceforge.pmd.lang.java.symbols.JClassSymbol#isArray\n methodBody: boolean isArray();", "methodSignature: net.sourceforge.pmd.lang.java.symbols.internal.impl.ast.AbstractAstExecSymbol#getEnclosingClass\n methodBody: public @NonNull JClassSymbol getEnclosingClass() {\nreturn owner;\n}", "methodSignature: net.sourceforge.pmd.lang.java.symbols.internal.impl.reflect.ReflectionSymFactory#getCommonSyms\n methodBody: private static Map<Class<?>, JClassSymbol> getCommonSyms() {\nMap<Class<?>,JClassSymbol> shared=commonSymbols;\nif(shared == null){synchronized(ReflectionSymFactory.class){shared=commonSymbols;\nif(shared == null){shared=initCommonSyms();\ncommonSymbols=shared;\n}}}return shared;\n}", "methodSignature: net.sourceforge.pmd.lang.java.symbols.internal.impl.reflect.ReflectedFieldImpl#getEnclosingClass\n methodBody: public JClassSymbol getEnclosingClass() {\nreturn owner;\n}", "methodSignature: net.sourceforge.pmd.typeresolution.testdata.LocalGenericClass.MySupplier#get\n methodBody: S get();", "methodSignature: net.sourceforge.pmd.lang.java.symbols.internal.impl.ast.AstClassSym#isArray\n methodBody: public boolean isArray() {\nreturn false;\n}", "methodSignature: net.sourceforge.pmd.lang.java.symbols.JExecutableSymbol#getEnclosingClass\n methodBody: JClassSymbol getEnclosingClass();"], "sourceCodeAfterRefactoring": "/**\n     * Returns the class symbol for the given reflected class. This asks\n     * the classloader of this type system, but never returns null. Returns\n     * null if the parameter is null.\n     *\n     * @param clazz Class\n     */\n    @Nullable\n    public JClassSymbol getClassSymbol(@Nullable Class<?> clazz) {\n        if (clazz == null) {\n            return null;\n        } else if (clazz.isPrimitive()) {\n            return getPrimitive(PrimitiveTypeKind.fromName(clazz.getName())).getSymbol();\n        } else if (clazz.isArray()) {\n            return symbols().makeArraySymbol(getClassSymbol(clazz.getComponentType()));\n        }\n\n        JClassSymbol classLoaderPreferred = resolver.resolveClassFromBinaryName(clazz.getName());\n        if (classLoaderPreferred != null) {\n            return classLoaderPreferred;\n        }\n        return ReflectedSymbols.getClassSymbol(symbols(), clazz);\n    }\n/**\n     * Gets the primitive type identified by the given kind.\n     *\n     * @param kind Kind of primitive type\n     *\n     * @return A primitive type, or null if the argument is null\n     */\n    @Nullable\n    public JPrimitiveType getPrimitive(PrimitiveTypeKind kind) {\n        return primitivesByKind.get(kind);\n    }", "diffSourceCode": "-   58:     @Override\n-   59:     @Nullable\n-   60:     public JClassSymbol getClassSymbol(@Nullable Class<?> klass) {\n-   61:         if (klass == null) {\n-   62:             return null;\n-   63:         }\n-   64: \n-   65:         Map<Class<?>, JClassSymbol> shared = getCommonSyms();\n-   66:         if (shared.containsKey(klass)) {\n-   67:             return shared.get(klass);\n-   68:         }\n-   69: \n-   70:         if (klass.getEnclosingClass() != null) {\n-   71:             JClassSymbol enclosing = getClassSymbol(klass.getEnclosingClass());\n-   72:             assert enclosing != null;\n-   73:             return createWithEnclosing(this, enclosing, klass);\n-   74:         }\n-   75: \n-   76:         if (klass.isArray()) {\n-   77:             JClassSymbol component = getClassSymbol(klass.getComponentType());\n-   78:             return makeArraySymbol(component);\n-   79:         }\n-   80: \n-   81:         return createOuterClass(this, klass);\n-   82:     }\n+   58:      * <p>This implementation uses this as the type of the 'null' literal.\n+   59:      */\n+   60:     public final JTypeMirror NULL_TYPE = new JTypeMirror() {\n+   61: \n+   62:         @Override\n+   63:         public JTypeMirror subst(Function<? super SubstVar, ? extends @NonNull JTypeMirror> subst) {\n+   64:             return this;\n+   65:         }\n+   66: \n+   67:         @Override\n+   68:         public TypeSystem getTypeSystem() {\n+   69:             return TypeSystem.this;\n+   70:         }\n+   71: \n+   72:         @Override\n+   73:         public @Nullable JClassSymbol getSymbol() {\n+   74:             return null;\n+   75:         }\n+   76: \n+   77:         @Override\n+   78:         public <T, P> T acceptVisitor(JTypeVisitor<T, P> visitor, P p) {\n+   79:             return visitor.visitNullType(this, p);\n+   80:         }\n+   81: \n+   82:         @Override\n+  337:     /**\n+  338:      * Returns the class symbol for the given reflected class. This asks\n+  339:      * the classloader of this type system, but never returns null. Returns\n+  340:      * null if the parameter is null.\n+  341:      *\n+  342:      * @param clazz Class\n+  343:      */\n+  344:     @Nullable\n+  345:     public JClassSymbol getClassSymbol(@Nullable Class<?> clazz) {\n+  346:         if (clazz == null) {\n+  347:             return null;\n+  348:         } else if (clazz.isPrimitive()) {\n+  349:             return getPrimitive(PrimitiveTypeKind.fromName(clazz.getName())).getSymbol();\n+  350:         } else if (clazz.isArray()) {\n+  351:             return symbols().makeArraySymbol(getClassSymbol(clazz.getComponentType()));\n+  352:         }\n+  353: \n+  354:         JClassSymbol classLoaderPreferred = resolver.resolveClassFromBinaryName(clazz.getName());\n+  355:         if (classLoaderPreferred != null) {\n+  356:             return classLoaderPreferred;\n+  357:         }\n+  358:         return ReflectedSymbols.getClassSymbol(symbols(), clazz);\n+  359:     }\n+  586:     /**\n+  587:      * Gets the primitive type identified by the given kind.\n+  588:      *\n+  589:      * @param kind Kind of primitive type\n+  590:      *\n+  591:      * @return A primitive type, or null if the argument is null\n+  592:      */\n+  593:     @Nullable\n+  594:     public JPrimitiveType getPrimitive(PrimitiveTypeKind kind) {\n+  595:         return primitivesByKind.get(kind);\n+  596:     }\n", "uniqueId": "2449f6404ec001dde8fe782febb993f262a5ddc1_58_82_586_596_337_359", "moveFileExist": true, "testResult": true, "coverageInfo": {"INSTRUCTION": {"missed": 4, "covered": 48}, "BRANCH": {"missed": 2, "covered": 10}, "LINE": {"missed": 0, "covered": 13}, "COMPLEXITY": {"missed": 2, "covered": 5}, "METHOD": {"missed": 0, "covered": 1}}, "compileResultBefore": true, "compileResultCurrent": true, "compileJDK": 11, "refactoringMinerResult": true, "compileAndTestResult": true, "refactoredCode": "To improve the readability and maintainability of the `getClassSymbol` method, we can extract the logic for handling different types of classes (enclosing classes, array classes, and outer classes) into separate methods. This will make the main method cleaner and easier to understand.\n\nHere\u2019s the refactored code with the extracted methods:\n\n```java\n@Override\n@Nullable\npublic JClassSymbol getClassSymbol(@Nullable Class<?> klass) {\n    if (klass == null) {\n        return null;\n    }\n\n    Map<Class<?>, JClassSymbol> shared = getCommonSyms();\n    if (shared.containsKey(klass)) {\n        return shared.get(klass);\n    }\n\n    if (klass.getEnclosingClass() != null) {\n        return handleEnclosingClass(klass);\n    }\n\n    if (klass.isArray()) {\n        return handleArrayClass(klass);\n    }\n\n    return createOuterClass(this, klass);\n}\n\nprivate JClassSymbol handleEnclosingClass(Class<?> klass) {\n    JClassSymbol enclosing = getClassSymbol(klass.getEnclosingClass());\n    assert enclosing != null;\n    return createWithEnclosing(this, enclosing, klass);\n}\n\nprivate JClassSymbol handleArrayClass(Class<?> klass) {\n    JClassSymbol component = getClassSymbol(klass.getComponentType());\n    return makeArraySymbol(component);\n}\n```\n\nThis refactoring separates the logic for handling enclosing classes and array classes into their own methods, `handleEnclosingClass` and `handleArrayClass`, respectively. This makes the `getClassSymbol` method more concise and focused on its primary purpose, which is to retrieve the class symbol for a given class.\n\nHere\u2019s the output in the requested format:\n\n##########################\n```java\n@Override\n@Nullable\npublic JClassSymbol getClassSymbol(@Nullable Class<?> klass) {\n    if (klass == null) {\n        return null;\n    }\n\n    Map<Class<?>, JClassSymbol> shared = getCommonSyms();\n    if (shared.containsKey(klass)) {\n        return shared.get(klass);\n    }\n\n    if (klass.getEnclosingClass() != null) {\n        return handleEnclosingClass(klass);\n    }\n\n    if (klass.isArray()) {\n        return handleArrayClass(klass);\n    }\n\n    return createOuterClass(this, klass);\n}\n\nprivate JClassSymbol handleEnclosingClass(Class<?> klass) {\n    JClassSymbol enclosing = getClassSymbol(klass.getEnclosingClass());\n    assert enclosing != null;\n    return createWithEnclosing(this, enclosing, klass);\n}\n\nprivate JClassSymbol handleArrayClass(Class<?> klass) {\n    JClassSymbol component = getClassSymbol(klass.getComponentType());\n    return makeArraySymbol(component);\n}\n```\n##########################", "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to Refactor:\n@Override\n    @Nullable\n    public JClassSymbol getClassSymbol(@Nullable Class<?> klass) {\n        if (klass == null) {\n            return null;\n        }\n\n        Map<Class<?>, JClassSymbol> shared = getCommonSyms();\n        if (shared.containsKey(klass)) {\n            return shared.get(klass);\n        }\n\n        if (klass.getEnclosingClass() != null) {\n            JClassSymbol enclosing = getClassSymbol(klass.getEnclosingClass());\n            assert enclosing != null;\n            return createWithEnclosing(this, enclosing, klass);\n        }\n\n        if (klass.isArray()) {\n            JClassSymbol component = getClassSymbol(klass.getComponentType());\n            return makeArraySymbol(component);\n        }\n\n        return createOuterClass(this, klass);\n    }\n\nClass content:\n/*\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.lang.java.symbols.internal.impl.reflect;\n\n\nimport static net.sourceforge.pmd.lang.java.symbols.internal.impl.reflect.ReflectSymInternals.BOOLEAN_SYM;\nimport static net.sourceforge.pmd.lang.java.symbols.internal.impl.reflect.ReflectSymInternals.BOXED_BOOLEAN_SYM;\nimport static net.sourceforge.pmd.lang.java.symbols.internal.impl.reflect.ReflectSymInternals.BOXED_BYTE_SYM;\nimport static net.sourceforge.pmd.lang.java.symbols.internal.impl.reflect.ReflectSymInternals.BOXED_CHAR_SYM;\nimport static net.sourceforge.pmd.lang.java.symbols.internal.impl.reflect.ReflectSymInternals.BOXED_DOUBLE_SYM;\nimport static net.sourceforge.pmd.lang.java.symbols.internal.impl.reflect.ReflectSymInternals.BOXED_FLOAT_SYM;\nimport static net.sourceforge.pmd.lang.java.symbols.internal.impl.reflect.ReflectSymInternals.BOXED_INT_SYM;\nimport static net.sourceforge.pmd.lang.java.symbols.internal.impl.reflect.ReflectSymInternals.BOXED_LONG_SYM;\nimport static net.sourceforge.pmd.lang.java.symbols.internal.impl.reflect.ReflectSymInternals.BOXED_SHORT_SYM;\nimport static net.sourceforge.pmd.lang.java.symbols.internal.impl.reflect.ReflectSymInternals.BOXED_VOID_SYM;\nimport static net.sourceforge.pmd.lang.java.symbols.internal.impl.reflect.ReflectSymInternals.BYTE_SYM;\nimport static net.sourceforge.pmd.lang.java.symbols.internal.impl.reflect.ReflectSymInternals.CHAR_SYM;\nimport static net.sourceforge.pmd.lang.java.symbols.internal.impl.reflect.ReflectSymInternals.CLONEABLE_SYM;\nimport static net.sourceforge.pmd.lang.java.symbols.internal.impl.reflect.ReflectSymInternals.DOUBLE_SYM;\nimport static net.sourceforge.pmd.lang.java.symbols.internal.impl.reflect.ReflectSymInternals.ENUM_SYM;\nimport static net.sourceforge.pmd.lang.java.symbols.internal.impl.reflect.ReflectSymInternals.FLOAT_SYM;\nimport static net.sourceforge.pmd.lang.java.symbols.internal.impl.reflect.ReflectSymInternals.INT_SYM;\nimport static net.sourceforge.pmd.lang.java.symbols.internal.impl.reflect.ReflectSymInternals.ITERABLE_SYM;\nimport static net.sourceforge.pmd.lang.java.symbols.internal.impl.reflect.ReflectSymInternals.LONG_SYM;\nimport static net.sourceforge.pmd.lang.java.symbols.internal.impl.reflect.ReflectSymInternals.OBJECT_SYM;\nimport static net.sourceforge.pmd.lang.java.symbols.internal.impl.reflect.ReflectSymInternals.SERIALIZABLE_SYM;\nimport static net.sourceforge.pmd.lang.java.symbols.internal.impl.reflect.ReflectSymInternals.SHORT_SYM;\nimport static net.sourceforge.pmd.lang.java.symbols.internal.impl.reflect.ReflectSymInternals.STRING_SYM;\nimport static net.sourceforge.pmd.lang.java.symbols.internal.impl.reflect.ReflectSymInternals.VOID_SYM;\nimport static net.sourceforge.pmd.lang.java.symbols.internal.impl.reflect.ReflectedClassImpl.createOuterClass;\nimport static net.sourceforge.pmd.lang.java.symbols.internal.impl.reflect.ReflectedClassImpl.createWithEnclosing;\n\nimport java.io.Serializable;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport org.checkerframework.checker.nullness.qual.Nullable;\n\nimport net.sourceforge.pmd.lang.java.symbols.JClassSymbol;\nimport net.sourceforge.pmd.lang.java.symbols.internal.impl.SymbolFactory;\n\n/**\n * Symbol factory building type symbols from {@link Class} instances.\n * Reflected symbol implementations carry an instance of this around,\n * so as to allow caching recently accessed symbols later on.\n */\npublic final class ReflectionSymFactory implements SymbolFactory<Class<?>> {\n\n    /**\n     * Lazy initialized to avoid class init cycle, because\n     * {@link SymbolFactory} creates reflected symbols.\n     */\n    private static Map<Class<?>, JClassSymbol> commonSymbols;\n\n    @Override\n    @Nullable\n    public JClassSymbol getClassSymbol(@Nullable Class<?> klass) {\n        if (klass == null) {\n            return null;\n        }\n\n        Map<Class<?>, JClassSymbol> shared = getCommonSyms();\n        if (shared.containsKey(klass)) {\n            return shared.get(klass);\n        }\n\n        if (klass.getEnclosingClass() != null) {\n            JClassSymbol enclosing = getClassSymbol(klass.getEnclosingClass());\n            assert enclosing != null;\n            return createWithEnclosing(this, enclosing, klass);\n        }\n\n        if (klass.isArray()) {\n            JClassSymbol component = getClassSymbol(klass.getComponentType());\n            return makeArraySymbol(component);\n        }\n\n        return createOuterClass(this, klass);\n    }\n\n    private static Map<Class<?>, JClassSymbol> getCommonSyms() {\n        Map<Class<?>, JClassSymbol> shared = commonSymbols;\n        if (shared == null) {\n            synchronized (ReflectionSymFactory.class) {\n                shared = commonSymbols;\n                if (shared == null) {\n                    shared = initCommonSyms();\n                    commonSymbols = shared;\n                }\n            }\n        }\n        return shared;\n    }\n\n    private static void putStr(Map<Class<?>, JClassSymbol> byClass,\n                               Class<?> booleanClass,\n                               JClassSymbol booleanSym) {\n        byClass.put(booleanClass, booleanSym);\n    }\n\n\n    private static Map<Class<?>, JClassSymbol> initCommonSyms() {\n        // consider putting whole java.lang + java.util in there ?\n\n        Map<Class<?>, JClassSymbol> specials = new HashMap<>();\n\n        putStr(specials, Object.class, OBJECT_SYM);\n\n        putStr(specials, boolean.class, BOOLEAN_SYM);\n        putStr(specials, byte.class, BYTE_SYM);\n        putStr(specials, char.class, CHAR_SYM);\n        putStr(specials, double.class, DOUBLE_SYM);\n        putStr(specials, float.class, FLOAT_SYM);\n        putStr(specials, int.class, INT_SYM);\n        putStr(specials, long.class, LONG_SYM);\n        putStr(specials, short.class, SHORT_SYM);\n        putStr(specials, void.class, VOID_SYM);\n\n        putStr(specials, Cloneable.class, CLONEABLE_SYM);\n        putStr(specials, Serializable.class, SERIALIZABLE_SYM);\n\n        putStr(specials, Boolean.class, BOXED_BOOLEAN_SYM);\n        putStr(specials, Byte.class, BOXED_BYTE_SYM);\n        putStr(specials, Character.class, BOXED_CHAR_SYM);\n        putStr(specials, Double.class, BOXED_DOUBLE_SYM);\n        putStr(specials, Float.class, BOXED_FLOAT_SYM);\n        putStr(specials, Integer.class, BOXED_INT_SYM);\n        putStr(specials, Long.class, BOXED_LONG_SYM);\n        putStr(specials, Short.class, BOXED_SHORT_SYM);\n        putStr(specials, Void.class, BOXED_VOID_SYM);\n\n        putStr(specials, Iterable.class, ITERABLE_SYM);\n        putStr(specials, Enum.class, ENUM_SYM);\n        putStr(specials, String.class, STRING_SYM);\n\n        return Collections.unmodifiableMap(specials);\n    }\n\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n"}, {"type": "Extract Method", "description": "Extract Method\tprivate getParentMethodCallArgsSuffix(expr ASTPrimaryExpression) : ASTPrimarySuffix extracted from private isArgumentOfEqualsMethodCall(expr ASTPrimaryExpression) : boolean in class net.sourceforge.pmd.lang.java.rule.errorprone.UnnecessaryCaseChangeRule", "diffLocations": [{"filePath": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/errorprone/UnnecessaryCaseChangeRule.java", "startLine": 85, "endLine": 95, "startColumn": 0, "endColumn": 0}, {"filePath": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/errorprone/UnnecessaryCaseChangeRule.java", "startLine": 85, "endLine": 94, "startColumn": 0, "endColumn": 0}, {"filePath": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/errorprone/UnnecessaryCaseChangeRule.java", "startLine": 96, "endLine": 101, "startColumn": 0, "endColumn": 0}], "sourceCodeBeforeRefactoring": "private boolean isArgumentOfEqualsMethodCall(ASTPrimaryExpression expr) {\n        JavaNode parent = expr.getParent().getParent();\n        if (parent instanceof ASTArgumentList) {\n            ASTPrimarySuffix parentMethodCallArgs = parent.getFirstParentOfType(ASTPrimarySuffix.class);\n            List<JavaNode> parentNodes = parentMethodCallArgs.getParent().findChildrenOfType(JavaNode.class);\n            int parentMethodCallIndex = parentNodes.indexOf(parentMethodCallArgs) - 1;\n            JavaNode parentMethodCall = parentNodes.get(parentMethodCallIndex);\n            return isEqualsMethodCall(parentMethodCall, parentMethodCallArgs);\n        }\n        return false;\n    }", "filePathBefore": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/errorprone/UnnecessaryCaseChangeRule.java", "isPureRefactoring": true, "commitId": "d69520f68fc68e40dc541604aa301246c8612ca7", "packageNameBefore": "net.sourceforge.pmd.lang.java.rule.errorprone", "classNameBefore": "net.sourceforge.pmd.lang.java.rule.errorprone.UnnecessaryCaseChangeRule", "methodNameBefore": "net.sourceforge.pmd.lang.java.rule.errorprone.UnnecessaryCaseChangeRule#isArgumentOfEqualsMethodCall", "invokedMethod": "methodSignature: net.sourceforge.pmd.lang.java.rule.errorprone.UnnecessaryCaseChangeRule#isEqualsMethodCall\n methodBody: private boolean isEqualsMethodCall(JavaNode methodCall, JavaNode methodCallArgs) {\nString methodName=methodCall.getImage();\nint methodArgsCount=getCalledMethodArgsCount(methodCallArgs);\nreturn methodName != null && EQUALITY_METHODS.contains(methodName) && methodArgsCount == 1;\n}", "classSignatureBefore": "public class UnnecessaryCaseChangeRule extends AbstractJavaRule ", "methodNameBeforeSet": ["net.sourceforge.pmd.lang.java.rule.errorprone.UnnecessaryCaseChangeRule#isArgumentOfEqualsMethodCall"], "classNameBeforeSet": ["net.sourceforge.pmd.lang.java.rule.errorprone.UnnecessaryCaseChangeRule"], "classSignatureBeforeSet": ["public class UnnecessaryCaseChangeRule extends AbstractJavaRule "], "purityCheckResultList": [{"isPure": true, "purityComment": "Tolerable changes in the body\n", "description": "All replacements have been justified - all mapped", "mappingState": 1}], "sourceCodeBeforeForWhole": "/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.lang.java.rule.errorprone;\n\nimport static java.util.Arrays.asList;\n\nimport java.util.List;\n\nimport net.sourceforge.pmd.lang.java.ast.ASTArgumentList;\nimport net.sourceforge.pmd.lang.java.ast.ASTArguments;\nimport net.sourceforge.pmd.lang.java.ast.ASTName;\nimport net.sourceforge.pmd.lang.java.ast.ASTPrimaryExpression;\nimport net.sourceforge.pmd.lang.java.ast.ASTPrimaryPrefix;\nimport net.sourceforge.pmd.lang.java.ast.ASTPrimarySuffix;\nimport net.sourceforge.pmd.lang.java.ast.JavaNode;\nimport net.sourceforge.pmd.lang.java.rule.AbstractJavaRule;\n\npublic class UnnecessaryCaseChangeRule extends AbstractJavaRule {\n\n    private static final List<String> CASE_CHANGING_METHODS = asList(\"toLowerCase\", \"toUpperCase\");\n    private static final List<String> EQUALITY_METHODS = asList(\"equals\", \"equalsIgnoreCase\");\n\n    @Override\n    public Object visit(ASTPrimaryExpression expr, Object data) {\n        int caseChangingCallIndex = getCaseChangingMethodCallIndex(expr);\n        if (caseChangingCallIndex != -1) {\n            int chainedMethodCallIndex = caseChangingCallIndex + 2;\n            if (hasEqualsMethodCallChainedAtPosition(expr, chainedMethodCallIndex)\n                    || isArgumentOfEqualsMethodCall(expr)) {\n                addViolation(data, expr);\n            }\n        }\n        return super.visit(expr, data);\n    }\n\n    private int getCaseChangingMethodCallIndex(ASTPrimaryExpression expr) {\n        List<JavaNode> exprNodes = expr.findChildrenOfType(JavaNode.class);\n        for (int callArgsIndex = 1; callArgsIndex < exprNodes.size(); callArgsIndex++) {\n            int callIndex = callArgsIndex - 1;\n            if (isCaseChangingMethodCall(exprNodes.get(callIndex), exprNodes.get(callArgsIndex))) {\n                return callIndex;\n            }\n        }\n        return -1;\n    }\n\n    private boolean isCaseChangingMethodCall(JavaNode methodCall, JavaNode methodCallArgs) {\n        String methodName = getCalledMethodName(methodCall);\n        int methodArgsCount = getCalledMethodArgsCount(methodCallArgs);\n        return methodName != null\n                && isNameOfCaseChangingMethod(methodName) && methodArgsCount == 0;\n    }\n\n    private String getCalledMethodName(JavaNode methodCall) {\n        if (methodCall instanceof ASTPrimaryPrefix) {\n            ASTName methodName = methodCall.getFirstDescendantOfType(ASTName.class);\n            return methodName != null ? methodName.getImage() : null;\n        }\n        return methodCall.getImage();\n    }\n\n    private boolean isNameOfCaseChangingMethod(String methodName) {\n        for (String caseChangingMethod : CASE_CHANGING_METHODS) {\n            if (methodName.endsWith(caseChangingMethod)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private boolean hasEqualsMethodCallChainedAtPosition(ASTPrimaryExpression expr, int pos) {\n        int argsPos = pos + 1;\n        if (hasNodeAtPosition(expr, argsPos)) {\n            return isEqualsMethodCall(expr.getChild(pos), expr.getChild(argsPos));\n        }\n        return false;\n    }\n\n    private boolean hasNodeAtPosition(ASTPrimaryExpression expr, int pos) {\n        return pos < expr.getNumChildren();\n    }\n\n    private boolean isArgumentOfEqualsMethodCall(ASTPrimaryExpression expr) {\n        JavaNode parent = expr.getParent().getParent();\n        if (parent instanceof ASTArgumentList) {\n            ASTPrimarySuffix parentMethodCallArgs = parent.getFirstParentOfType(ASTPrimarySuffix.class);\n            List<JavaNode> parentNodes = parentMethodCallArgs.getParent().findChildrenOfType(JavaNode.class);\n            int parentMethodCallIndex = parentNodes.indexOf(parentMethodCallArgs) - 1;\n            JavaNode parentMethodCall = parentNodes.get(parentMethodCallIndex);\n            return isEqualsMethodCall(parentMethodCall, parentMethodCallArgs);\n        }\n        return false;\n    }\n\n    private boolean isEqualsMethodCall(JavaNode methodCall, JavaNode methodCallArgs) {\n        String methodName = methodCall.getImage();\n        int methodArgsCount = getCalledMethodArgsCount(methodCallArgs);\n        return methodName != null\n                && EQUALITY_METHODS.contains(methodName) && methodArgsCount == 1;\n    }\n\n    private int getCalledMethodArgsCount(JavaNode methodCall) {\n        ASTArguments args = methodCall.getFirstDescendantOfType(ASTArguments.class);\n        return args != null ? args.size() : -1;\n    }\n}\n", "filePathAfter": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/errorprone/UnnecessaryCaseChangeRule.java", "sourceCodeAfterForWhole": "/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.lang.java.rule.errorprone;\n\nimport static java.util.Arrays.asList;\n\nimport java.util.List;\n\nimport net.sourceforge.pmd.lang.java.ast.ASTArgumentList;\nimport net.sourceforge.pmd.lang.java.ast.ASTArguments;\nimport net.sourceforge.pmd.lang.java.ast.ASTName;\nimport net.sourceforge.pmd.lang.java.ast.ASTPrimaryExpression;\nimport net.sourceforge.pmd.lang.java.ast.ASTPrimaryPrefix;\nimport net.sourceforge.pmd.lang.java.ast.ASTPrimarySuffix;\nimport net.sourceforge.pmd.lang.java.ast.JavaNode;\nimport net.sourceforge.pmd.lang.java.rule.AbstractJavaRule;\n\npublic class UnnecessaryCaseChangeRule extends AbstractJavaRule {\n\n    private static final List<String> CASE_CHANGING_METHODS = asList(\"toLowerCase\", \"toUpperCase\");\n    private static final List<String> EQUALITY_METHODS = asList(\"equals\", \"equalsIgnoreCase\");\n\n    @Override\n    public Object visit(ASTPrimaryExpression expr, Object data) {\n        int caseChangingCallIndex = getCaseChangingMethodCallIndex(expr);\n        if (caseChangingCallIndex != -1) {\n            int chainedMethodCallIndex = caseChangingCallIndex + 2;\n            if (hasEqualsMethodCallChainedAtPosition(expr, chainedMethodCallIndex)\n                    || isArgumentOfEqualsMethodCall(expr)) {\n                addViolation(data, expr);\n            }\n        }\n        return super.visit(expr, data);\n    }\n\n    private int getCaseChangingMethodCallIndex(ASTPrimaryExpression expr) {\n        List<JavaNode> exprNodes = expr.findChildrenOfType(JavaNode.class);\n        for (int callArgsIndex = 1; callArgsIndex < exprNodes.size(); callArgsIndex++) {\n            int callIndex = callArgsIndex - 1;\n            if (isCaseChangingMethodCall(exprNodes.get(callIndex), exprNodes.get(callArgsIndex))) {\n                return callIndex;\n            }\n        }\n        return -1;\n    }\n\n    private boolean isCaseChangingMethodCall(JavaNode methodCall, JavaNode methodCallArgs) {\n        String methodName = getCalledMethodName(methodCall);\n        int methodArgsCount = getCalledMethodArgsCount(methodCallArgs);\n        return methodName != null\n                && isNameOfCaseChangingMethod(methodName) && methodArgsCount == 0;\n    }\n\n    private String getCalledMethodName(JavaNode methodCall) {\n        if (methodCall instanceof ASTPrimaryPrefix) {\n            ASTName methodName = methodCall.getFirstDescendantOfType(ASTName.class);\n            return methodName != null ? methodName.getImage() : null;\n        }\n        return methodCall.getImage();\n    }\n\n    private boolean isNameOfCaseChangingMethod(String methodName) {\n        for (String caseChangingMethod : CASE_CHANGING_METHODS) {\n            if (methodName.endsWith(caseChangingMethod)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private boolean hasEqualsMethodCallChainedAtPosition(ASTPrimaryExpression expr, int pos) {\n        int argsPos = pos + 1;\n        if (hasNodeAtPosition(expr, argsPos)) {\n            return isEqualsMethodCall(expr.getChild(pos), expr.getChild(argsPos));\n        }\n        return false;\n    }\n\n    private boolean hasNodeAtPosition(ASTPrimaryExpression expr, int pos) {\n        return pos < expr.getNumChildren();\n    }\n\n    private boolean isArgumentOfEqualsMethodCall(ASTPrimaryExpression expr) {\n        ASTPrimarySuffix parentMethodCallArgs = getParentMethodCallArgsSuffix(expr);\n        if (parentMethodCallArgs != null) {\n            List<JavaNode> parentNodes = parentMethodCallArgs.getParent().findChildrenOfType(JavaNode.class);\n            int parentMethodCallIndex = parentNodes.indexOf(parentMethodCallArgs) - 1;\n            JavaNode parentMethodCall = parentNodes.get(parentMethodCallIndex);\n            return isEqualsMethodCall(parentMethodCall, parentMethodCallArgs);\n        }\n        return false;\n    }\n\n    private ASTPrimarySuffix getParentMethodCallArgsSuffix(ASTPrimaryExpression expr) {\n        JavaNode parent = expr.getParent().getParent(); // ASTArgumentList/ASTExpression/ASTPrimaryExpression\n        return parent instanceof ASTArgumentList\n                ? parent.getFirstParentOfType(ASTPrimarySuffix.class)\n                : null;\n    }\n\n    private boolean isEqualsMethodCall(JavaNode methodCall, JavaNode methodCallArgs) {\n        String methodName = methodCall.getImage();\n        int methodArgsCount = getCalledMethodArgsCount(methodCallArgs);\n        return methodName != null\n                && EQUALITY_METHODS.contains(methodName) && methodArgsCount == 1;\n    }\n\n    private int getCalledMethodArgsCount(JavaNode methodCall) {\n        ASTArguments args = methodCall.getFirstDescendantOfType(ASTArguments.class);\n        return args != null ? args.size() : -1;\n    }\n}\n", "diffSourceCodeSet": ["private ASTPrimarySuffix getParentMethodCallArgsSuffix(ASTPrimaryExpression expr) {\n        JavaNode parent = expr.getParent().getParent(); // ASTArgumentList/ASTExpression/ASTPrimaryExpression\n        return parent instanceof ASTArgumentList\n                ? parent.getFirstParentOfType(ASTPrimarySuffix.class)\n                : null;\n    }"], "invokedMethodSet": ["methodSignature: net.sourceforge.pmd.lang.java.rule.errorprone.UnnecessaryCaseChangeRule#isEqualsMethodCall\n methodBody: private boolean isEqualsMethodCall(JavaNode methodCall, JavaNode methodCallArgs) {\nString methodName=methodCall.getImage();\nint methodArgsCount=getCalledMethodArgsCount(methodCallArgs);\nreturn methodName != null && EQUALITY_METHODS.contains(methodName) && methodArgsCount == 1;\n}"], "sourceCodeAfterRefactoring": "private boolean isArgumentOfEqualsMethodCall(ASTPrimaryExpression expr) {\n        ASTPrimarySuffix parentMethodCallArgs = getParentMethodCallArgsSuffix(expr);\n        if (parentMethodCallArgs != null) {\n            List<JavaNode> parentNodes = parentMethodCallArgs.getParent().findChildrenOfType(JavaNode.class);\n            int parentMethodCallIndex = parentNodes.indexOf(parentMethodCallArgs) - 1;\n            JavaNode parentMethodCall = parentNodes.get(parentMethodCallIndex);\n            return isEqualsMethodCall(parentMethodCall, parentMethodCallArgs);\n        }\n        return false;\n    }\nprivate ASTPrimarySuffix getParentMethodCallArgsSuffix(ASTPrimaryExpression expr) {\n        JavaNode parent = expr.getParent().getParent(); // ASTArgumentList/ASTExpression/ASTPrimaryExpression\n        return parent instanceof ASTArgumentList\n                ? parent.getFirstParentOfType(ASTPrimarySuffix.class)\n                : null;\n    }", "diffSourceCode": "    85:     private boolean isArgumentOfEqualsMethodCall(ASTPrimaryExpression expr) {\n-   86:         JavaNode parent = expr.getParent().getParent();\n-   87:         if (parent instanceof ASTArgumentList) {\n-   88:             ASTPrimarySuffix parentMethodCallArgs = parent.getFirstParentOfType(ASTPrimarySuffix.class);\n-   89:             List<JavaNode> parentNodes = parentMethodCallArgs.getParent().findChildrenOfType(JavaNode.class);\n-   90:             int parentMethodCallIndex = parentNodes.indexOf(parentMethodCallArgs) - 1;\n-   91:             JavaNode parentMethodCall = parentNodes.get(parentMethodCallIndex);\n-   92:             return isEqualsMethodCall(parentMethodCall, parentMethodCallArgs);\n-   93:         }\n-   94:         return false;\n-   95:     }\n-   96: \n-   97:     private boolean isEqualsMethodCall(JavaNode methodCall, JavaNode methodCallArgs) {\n-   98:         String methodName = methodCall.getImage();\n-   99:         int methodArgsCount = getCalledMethodArgsCount(methodCallArgs);\n-  100:         return methodName != null\n-  101:                 && EQUALITY_METHODS.contains(methodName) && methodArgsCount == 1;\n+   86:         ASTPrimarySuffix parentMethodCallArgs = getParentMethodCallArgsSuffix(expr);\n+   87:         if (parentMethodCallArgs != null) {\n+   88:             List<JavaNode> parentNodes = parentMethodCallArgs.getParent().findChildrenOfType(JavaNode.class);\n+   89:             int parentMethodCallIndex = parentNodes.indexOf(parentMethodCallArgs) - 1;\n+   90:             JavaNode parentMethodCall = parentNodes.get(parentMethodCallIndex);\n+   91:             return isEqualsMethodCall(parentMethodCall, parentMethodCallArgs);\n+   92:         }\n+   93:         return false;\n+   94:     }\n+   95: \n+   96:     private ASTPrimarySuffix getParentMethodCallArgsSuffix(ASTPrimaryExpression expr) {\n+   97:         JavaNode parent = expr.getParent().getParent(); // ASTArgumentList/ASTExpression/ASTPrimaryExpression\n+   98:         return parent instanceof ASTArgumentList\n+   99:                 ? parent.getFirstParentOfType(ASTPrimarySuffix.class)\n+  100:                 : null;\n+  101:     }\n", "uniqueId": "d69520f68fc68e40dc541604aa301246c8612ca7_85_95_96_101_85_94", "moveFileExist": true, "testResult": true, "coverageInfo": {"INSTRUCTION": {"missed": 2, "covered": 35}, "BRANCH": {"missed": 1, "covered": 1}, "LINE": {"missed": 1, "covered": 7}, "COMPLEXITY": {"missed": 1, "covered": 1}, "METHOD": {"missed": 0, "covered": 1}}, "compileResultBefore": true, "compileResultCurrent": true, "compileJDK": 11, "refactoringMinerResult": true, "compileAndTestResult": true, "refactoredCode": "To improve the readability and maintainability of the `isArgumentOfEqualsMethodCall` method, we can extract the logic that retrieves the parent method call and checks if it is an equals method call into a separate method. This will make the code cleaner and easier to understand.\n\nHere\u2019s the refactored method:\n\n```java\nprivate boolean isArgumentOfEqualsMethodCall(ASTPrimaryExpression expr) {\n    JavaNode parentMethodCall = getParentMethodCall(expr);\n    return parentMethodCall != null && isEqualsMethodCall(parentMethodCall, getParentMethodCallArgs(expr));\n}\n\nprivate JavaNode getParentMethodCall(ASTPrimaryExpression expr) {\n    JavaNode parent = expr.getParent().getParent();\n    if (parent instanceof ASTArgumentList) {\n        ASTPrimarySuffix parentMethodCallArgs = parent.getFirstParentOfType(ASTPrimarySuffix.class);\n        List<JavaNode> parentNodes = parentMethodCallArgs.getParent().findChildrenOfType(JavaNode.class);\n        int parentMethodCallIndex = parentNodes.indexOf(parentMethodCallArgs) - 1;\n        return parentNodes.get(parentMethodCallIndex);\n    }\n    return null;\n}\n\nprivate JavaNode getParentMethodCallArgs(ASTPrimaryExpression expr) {\n    JavaNode parent = expr.getParent().getParent();\n    if (parent instanceof ASTArgumentList) {\n        return parent.getFirstParentOfType(ASTPrimarySuffix.class);\n    }\n    return null;\n}\n```\n\nThis refactoring extracts the logic for retrieving the parent method call and the parent method call arguments into their own methods, `getParentMethodCall` and `getParentMethodCallArgs`, respectively. This enhances the clarity of the `isArgumentOfEqualsMethodCall` method by reducing its complexity and making it easier to follow. \n\nHere\u2019s the output in the required format:\n\n##########################\n```java\nprivate boolean isArgumentOfEqualsMethodCall(ASTPrimaryExpression expr) {\n    JavaNode parentMethodCall = getParentMethodCall(expr);\n    return parentMethodCall != null && isEqualsMethodCall(parentMethodCall, getParentMethodCallArgs(expr));\n}\n\nprivate JavaNode getParentMethodCall(ASTPrimaryExpression expr) {\n    JavaNode parent = expr.getParent().getParent();\n    if (parent instanceof ASTArgumentList) {\n        ASTPrimarySuffix parentMethodCallArgs = parent.getFirstParentOfType(ASTPrimarySuffix.class);\n        List<JavaNode> parentNodes = parentMethodCallArgs.getParent().findChildrenOfType(JavaNode.class);\n        int parentMethodCallIndex = parentNodes.indexOf(parentMethodCallArgs) - 1;\n        return parentNodes.get(parentMethodCallIndex);\n    }\n    return null;\n}\n\nprivate JavaNode getParentMethodCallArgs(ASTPrimaryExpression expr) {\n    JavaNode parent = expr.getParent().getParent();\n    if (parent instanceof ASTArgumentList) {\n        return parent.getFirstParentOfType(ASTPrimarySuffix.class);\n    }\n    return null;\n}\n```\n##########################", "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to Refactor:\nprivate boolean isArgumentOfEqualsMethodCall(ASTPrimaryExpression expr) {\n        JavaNode parent = expr.getParent().getParent();\n        if (parent instanceof ASTArgumentList) {\n            ASTPrimarySuffix parentMethodCallArgs = parent.getFirstParentOfType(ASTPrimarySuffix.class);\n            List<JavaNode> parentNodes = parentMethodCallArgs.getParent().findChildrenOfType(JavaNode.class);\n            int parentMethodCallIndex = parentNodes.indexOf(parentMethodCallArgs) - 1;\n            JavaNode parentMethodCall = parentNodes.get(parentMethodCallIndex);\n            return isEqualsMethodCall(parentMethodCall, parentMethodCallArgs);\n        }\n        return false;\n    }\n\nClass content:\n/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.lang.java.rule.errorprone;\n\nimport static java.util.Arrays.asList;\n\nimport java.util.List;\n\nimport net.sourceforge.pmd.lang.java.ast.ASTArgumentList;\nimport net.sourceforge.pmd.lang.java.ast.ASTArguments;\nimport net.sourceforge.pmd.lang.java.ast.ASTName;\nimport net.sourceforge.pmd.lang.java.ast.ASTPrimaryExpression;\nimport net.sourceforge.pmd.lang.java.ast.ASTPrimaryPrefix;\nimport net.sourceforge.pmd.lang.java.ast.ASTPrimarySuffix;\nimport net.sourceforge.pmd.lang.java.ast.JavaNode;\nimport net.sourceforge.pmd.lang.java.rule.AbstractJavaRule;\n\npublic class UnnecessaryCaseChangeRule extends AbstractJavaRule {\n\n    private static final List<String> CASE_CHANGING_METHODS = asList(\"toLowerCase\", \"toUpperCase\");\n    private static final List<String> EQUALITY_METHODS = asList(\"equals\", \"equalsIgnoreCase\");\n\n    @Override\n    public Object visit(ASTPrimaryExpression expr, Object data) {\n        int caseChangingCallIndex = getCaseChangingMethodCallIndex(expr);\n        if (caseChangingCallIndex != -1) {\n            int chainedMethodCallIndex = caseChangingCallIndex + 2;\n            if (hasEqualsMethodCallChainedAtPosition(expr, chainedMethodCallIndex)\n                    || isArgumentOfEqualsMethodCall(expr)) {\n                addViolation(data, expr);\n            }\n        }\n        return super.visit(expr, data);\n    }\n\n    private int getCaseChangingMethodCallIndex(ASTPrimaryExpression expr) {\n        List<JavaNode> exprNodes = expr.findChildrenOfType(JavaNode.class);\n        for (int callArgsIndex = 1; callArgsIndex < exprNodes.size(); callArgsIndex++) {\n            int callIndex = callArgsIndex - 1;\n            if (isCaseChangingMethodCall(exprNodes.get(callIndex), exprNodes.get(callArgsIndex))) {\n                return callIndex;\n            }\n        }\n        return -1;\n    }\n\n    private boolean isCaseChangingMethodCall(JavaNode methodCall, JavaNode methodCallArgs) {\n        String methodName = getCalledMethodName(methodCall);\n        int methodArgsCount = getCalledMethodArgsCount(methodCallArgs);\n        return methodName != null\n                && isNameOfCaseChangingMethod(methodName) && methodArgsCount == 0;\n    }\n\n    private String getCalledMethodName(JavaNode methodCall) {\n        if (methodCall instanceof ASTPrimaryPrefix) {\n            ASTName methodName = methodCall.getFirstDescendantOfType(ASTName.class);\n            return methodName != null ? methodName.getImage() : null;\n        }\n        return methodCall.getImage();\n    }\n\n    private boolean isNameOfCaseChangingMethod(String methodName) {\n        for (String caseChangingMethod : CASE_CHANGING_METHODS) {\n            if (methodName.endsWith(caseChangingMethod)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private boolean hasEqualsMethodCallChainedAtPosition(ASTPrimaryExpression expr, int pos) {\n        int argsPos = pos + 1;\n        if (hasNodeAtPosition(expr, argsPos)) {\n            return isEqualsMethodCall(expr.getChild(pos), expr.getChild(argsPos));\n        }\n        return false;\n    }\n\n    private boolean hasNodeAtPosition(ASTPrimaryExpression expr, int pos) {\n        return pos < expr.getNumChildren();\n    }\n\n    private boolean isArgumentOfEqualsMethodCall(ASTPrimaryExpression expr) {\n        JavaNode parent = expr.getParent().getParent();\n        if (parent instanceof ASTArgumentList) {\n            ASTPrimarySuffix parentMethodCallArgs = parent.getFirstParentOfType(ASTPrimarySuffix.class);\n            List<JavaNode> parentNodes = parentMethodCallArgs.getParent().findChildrenOfType(JavaNode.class);\n            int parentMethodCallIndex = parentNodes.indexOf(parentMethodCallArgs) - 1;\n            JavaNode parentMethodCall = parentNodes.get(parentMethodCallIndex);\n            return isEqualsMethodCall(parentMethodCall, parentMethodCallArgs);\n        }\n        return false;\n    }\n\n    private boolean isEqualsMethodCall(JavaNode methodCall, JavaNode methodCallArgs) {\n        String methodName = methodCall.getImage();\n        int methodArgsCount = getCalledMethodArgsCount(methodCallArgs);\n        return methodName != null\n                && EQUALITY_METHODS.contains(methodName) && methodArgsCount == 1;\n    }\n\n    private int getCalledMethodArgsCount(JavaNode methodCall) {\n        ASTArguments args = methodCall.getFirstDescendantOfType(ASTArguments.class);\n        return args != null ? args.size() : -1;\n    }\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n"}, {"type": "Extract Method", "description": "Extract Method\tpublic getName() : String extracted from public getImage() : String in class net.sourceforge.pmd.lang.apex.ast.ASTFieldDeclaration", "diffLocations": [{"filePath": "pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/ast/ASTFieldDeclaration.java", "startLine": 20, "endLine": 30, "startColumn": 0, "endColumn": 0}, {"filePath": "pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/ast/ASTFieldDeclaration.java", "startLine": 20, "endLine": 23, "startColumn": 0, "endColumn": 0}, {"filePath": "pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/ast/ASTFieldDeclaration.java", "startLine": 25, "endLine": 34, "startColumn": 0, "endColumn": 0}], "sourceCodeBeforeRefactoring": "@Override\n    public String getImage() {\n        if (node.getFieldInfo() != null) {\n            return node.getFieldInfo().getName();\n        }\n        ASTVariableExpression variable = getFirstChildOfType(ASTVariableExpression.class);\n        if (variable != null) {\n            return variable.getImage();\n        }\n        return null;\n    }", "filePathBefore": "pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/ast/ASTFieldDeclaration.java", "isPureRefactoring": true, "commitId": "e8f8e1ac7a9f4f21bb7a0f9242a81fe7ab7e599c", "packageNameBefore": "net.sourceforge.pmd.lang.apex.ast", "classNameBefore": "net.sourceforge.pmd.lang.apex.ast.ASTFieldDeclaration", "methodNameBefore": "net.sourceforge.pmd.lang.apex.ast.ASTFieldDeclaration#getImage", "invokedMethod": "methodSignature: net.sourceforge.pmd.lang.apex.ast.ASTField#getImage\n methodBody: public String getImage() {\nreturn node.getFieldInfo().getName();\n}\nmethodSignature: net.sourceforge.pmd.lang.apex.ast.ASTFieldDeclaration#getImage\n methodBody: public String getImage() {\nif(node.getFieldInfo() != null){return node.getFieldInfo().getName();\n}ASTVariableExpression variable=getFirstChildOfType(ASTVariableExpression.class);\nif(variable != null){return variable.getImage();\n}return null;\n}", "classSignatureBefore": "public class ASTFieldDeclaration extends AbstractApexNode<FieldDeclaration> ", "methodNameBeforeSet": ["net.sourceforge.pmd.lang.apex.ast.ASTFieldDeclaration#getImage"], "classNameBeforeSet": ["net.sourceforge.pmd.lang.apex.ast.ASTFieldDeclaration"], "classSignatureBeforeSet": ["public class ASTFieldDeclaration extends AbstractApexNode<FieldDeclaration> "], "purityCheckResultList": [{"isPure": true, "purityComment": "Identical statements", "description": "There is no replacement! - all mapped", "mappingState": 1}], "sourceCodeBeforeForWhole": "/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.lang.apex.ast;\n\nimport apex.jorje.semantic.ast.statement.FieldDeclaration;\n\npublic class ASTFieldDeclaration extends AbstractApexNode<FieldDeclaration> {\n\n    public ASTFieldDeclaration(FieldDeclaration fieldDeclaration) {\n        super(fieldDeclaration);\n    }\n\n    @Override\n    public Object jjtAccept(ApexParserVisitor visitor, Object data) {\n        return visitor.visit(this, data);\n    }\n\n    @Override\n    public String getImage() {\n        if (node.getFieldInfo() != null) {\n            return node.getFieldInfo().getName();\n        }\n        ASTVariableExpression variable = getFirstChildOfType(ASTVariableExpression.class);\n        if (variable != null) {\n            return variable.getImage();\n        }\n        return null;\n    }\n}\n", "filePathAfter": "pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/ast/ASTFieldDeclaration.java", "sourceCodeAfterForWhole": "/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.lang.apex.ast;\n\nimport apex.jorje.semantic.ast.statement.FieldDeclaration;\n\npublic class ASTFieldDeclaration extends AbstractApexNode<FieldDeclaration> {\n\n    public ASTFieldDeclaration(FieldDeclaration fieldDeclaration) {\n        super(fieldDeclaration);\n    }\n\n    @Override\n    public Object jjtAccept(ApexParserVisitor visitor, Object data) {\n        return visitor.visit(this, data);\n    }\n\n    @Override\n    public String getImage() {\n        return getName();\n    }\n\n    public String getName() {\n        if (node.getFieldInfo() != null) {\n            return node.getFieldInfo().getName();\n        }\n        ASTVariableExpression variable = getFirstChildOfType(ASTVariableExpression.class);\n        if (variable != null) {\n            return variable.getImage();\n        }\n        return null;\n    }\n}\n", "diffSourceCodeSet": ["public String getName() {\n        if (node.getFieldInfo() != null) {\n            return node.getFieldInfo().getName();\n        }\n        ASTVariableExpression variable = getFirstChildOfType(ASTVariableExpression.class);\n        if (variable != null) {\n            return variable.getImage();\n        }\n        return null;\n    }"], "invokedMethodSet": ["methodSignature: net.sourceforge.pmd.lang.apex.ast.ASTField#getImage\n methodBody: public String getImage() {\nreturn node.getFieldInfo().getName();\n}", "methodSignature: net.sourceforge.pmd.lang.apex.ast.ASTFieldDeclaration#getImage\n methodBody: public String getImage() {\nif(node.getFieldInfo() != null){return node.getFieldInfo().getName();\n}ASTVariableExpression variable=getFirstChildOfType(ASTVariableExpression.class);\nif(variable != null){return variable.getImage();\n}return null;\n}"], "sourceCodeAfterRefactoring": "@Override\n    public String getImage() {\n        return getName();\n    }\npublic String getName() {\n        if (node.getFieldInfo() != null) {\n            return node.getFieldInfo().getName();\n        }\n        ASTVariableExpression variable = getFirstChildOfType(ASTVariableExpression.class);\n        if (variable != null) {\n            return variable.getImage();\n        }\n        return null;\n    }", "diffSourceCode": "    20:     @Override\n    21:     public String getImage() {\n-   22:         if (node.getFieldInfo() != null) {\n-   23:             return node.getFieldInfo().getName();\n-   24:         }\n-   25:         ASTVariableExpression variable = getFirstChildOfType(ASTVariableExpression.class);\n-   26:         if (variable != null) {\n-   27:             return variable.getImage();\n+   22:         return getName();\n+   23:     }\n+   24: \n+   25:     public String getName() {\n+   26:         if (node.getFieldInfo() != null) {\n+   27:             return node.getFieldInfo().getName();\n    28:         }\n-   29:         return null;\n-   30:     }\n-   31: }\n+   29:         ASTVariableExpression variable = getFirstChildOfType(ASTVariableExpression.class);\n+   30:         if (variable != null) {\n+   31:             return variable.getImage();\n+   32:         }\n+   33:         return null;\n+   34:     }\n", "uniqueId": "e8f8e1ac7a9f4f21bb7a0f9242a81fe7ab7e599c_20_30_25_34_20_23", "moveFileExist": true, "testResult": true, "coverageInfo": {"INSTRUCTION": {"missed": 8, "covered": 15}, "BRANCH": {"missed": 2, "covered": 2}, "LINE": {"missed": 2, "covered": 4}, "COMPLEXITY": {"missed": 2, "covered": 1}, "METHOD": {"missed": 0, "covered": 1}}, "compileResultBefore": true, "compileResultCurrent": true, "compileJDK": 11, "refactoringMinerResult": true, "compileAndTestResult": true, "refactoredCode": "To improve the readability and maintainability of the `getImage` method, we can extract the logic for retrieving the image from the `node` and the `ASTVariableExpression` into separate methods. This will make the `getImage` method cleaner and easier to understand.\n\nHere\u2019s the refactored code:\n\n```java\n@Override\npublic String getImage() {\n    String fieldInfoImage = getFieldInfoImage();\n    if (fieldInfoImage != null) {\n        return fieldInfoImage;\n    }\n    return getVariableImage();\n}\n\nprivate String getFieldInfoImage() {\n    if (node.getFieldInfo() != null) {\n        return node.getFieldInfo().getName();\n    }\n    return null;\n}\n\nprivate String getVariableImage() {\n    ASTVariableExpression variable = getFirstChildOfType(ASTVariableExpression.class);\n    if (variable != null) {\n        return variable.getImage();\n    }\n    return null;\n}\n```\n\nThis refactoring separates the concerns of retrieving the field info image and the variable image into their own methods, making the `getImage` method more concise and easier to read.\n\nHere\u2019s the output in the required format:\n\n##########################\n```java\n@Override\npublic String getImage() {\n    String fieldInfoImage = getFieldInfoImage();\n    if (fieldInfoImage != null) {\n        return fieldInfoImage;\n    }\n    return getVariableImage();\n}\n\nprivate String getFieldInfoImage() {\n    if (node.getFieldInfo() != null) {\n        return node.getFieldInfo().getName();\n    }\n    return null;\n}\n\nprivate String getVariableImage() {\n    ASTVariableExpression variable = getFirstChildOfType(ASTVariableExpression.class);\n    if (variable != null) {\n        return variable.getImage();\n    }\n    return null;\n}\n```\n##########################", "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to Refactor:\n@Override\n    public String getImage() {\n        if (node.getFieldInfo() != null) {\n            return node.getFieldInfo().getName();\n        }\n        ASTVariableExpression variable = getFirstChildOfType(ASTVariableExpression.class);\n        if (variable != null) {\n            return variable.getImage();\n        }\n        return null;\n    }\n\nClass content:\n/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.lang.apex.ast;\n\nimport apex.jorje.semantic.ast.statement.FieldDeclaration;\n\npublic class ASTFieldDeclaration extends AbstractApexNode<FieldDeclaration> {\n\n    public ASTFieldDeclaration(FieldDeclaration fieldDeclaration) {\n        super(fieldDeclaration);\n    }\n\n    @Override\n    public Object jjtAccept(ApexParserVisitor visitor, Object data) {\n        return visitor.visit(this, data);\n    }\n\n    @Override\n    public String getImage() {\n        if (node.getFieldInfo() != null) {\n            return node.getFieldInfo().getName();\n        }\n        ASTVariableExpression variable = getFirstChildOfType(ASTVariableExpression.class);\n        if (variable != null) {\n            return variable.getImage();\n        }\n        return null;\n    }\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n"}, {"type": "Extract Method", "description": "Extract Method\tpublic getName() : String extracted from public getImage() : String in class net.sourceforge.pmd.lang.apex.ast.ASTField", "diffLocations": [{"filePath": "pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/ast/ASTField.java", "startLine": 22, "endLine": 25, "startColumn": 0, "endColumn": 0}, {"filePath": "pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/ast/ASTField.java", "startLine": 22, "endLine": 25, "startColumn": 0, "endColumn": 0}, {"filePath": "pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/ast/ASTField.java", "startLine": 47, "endLine": 49, "startColumn": 0, "endColumn": 0}], "sourceCodeBeforeRefactoring": "@Override\n    public String getImage() {\n        return node.getFieldInfo().getName();\n    }", "filePathBefore": "pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/ast/ASTField.java", "isPureRefactoring": true, "commitId": "e8f8e1ac7a9f4f21bb7a0f9242a81fe7ab7e599c", "packageNameBefore": "net.sourceforge.pmd.lang.apex.ast", "classNameBefore": "net.sourceforge.pmd.lang.apex.ast.ASTField", "methodNameBefore": "net.sourceforge.pmd.lang.apex.ast.ASTField#getImage", "classSignatureBefore": "public class ASTField extends AbstractApexNode<Field> implements CanSuppressWarnings ", "methodNameBeforeSet": ["net.sourceforge.pmd.lang.apex.ast.ASTField#getImage"], "classNameBeforeSet": ["net.sourceforge.pmd.lang.apex.ast.ASTField"], "classSignatureBeforeSet": ["public class ASTField extends AbstractApexNode<Field> implements CanSuppressWarnings "], "purityCheckResultList": [{"isPure": true, "purityComment": "Identical statements", "description": "There is no replacement! - all mapped", "mappingState": 1}], "sourceCodeBeforeForWhole": "/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.lang.apex.ast;\n\nimport net.sourceforge.pmd.Rule;\n\nimport apex.jorje.semantic.ast.member.Field;\n\npublic class ASTField extends AbstractApexNode<Field> implements CanSuppressWarnings {\n\n    public ASTField(Field field) {\n        super(field);\n    }\n\n    @Override\n    public Object jjtAccept(ApexParserVisitor visitor, Object data) {\n        return visitor.visit(this, data);\n    }\n\n    @Override\n    public String getImage() {\n        return node.getFieldInfo().getName();\n    }\n\n    @Override\n    public boolean hasSuppressWarningsAnnotationFor(Rule rule) {\n        for (ASTModifierNode modifier : findChildrenOfType(ASTModifierNode.class)) {\n            for (ASTAnnotation a : modifier.findChildrenOfType(ASTAnnotation.class)) {\n                if (a.suppresses(rule)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    public String getType() {\n        return node.getFieldInfo().getType().getApexName();\n    }\n\n    public ASTModifierNode getModifiers() {\n        return getFirstChildOfType(ASTModifierNode.class);\n    }\n\n    public String getValue() {\n        if (node.getFieldInfo().getValue() != null) {\n            return String.valueOf(node.getFieldInfo().getValue());\n        }\n        return null;\n    }\n}\n", "filePathAfter": "pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/ast/ASTField.java", "sourceCodeAfterForWhole": "/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.lang.apex.ast;\n\nimport net.sourceforge.pmd.Rule;\n\nimport apex.jorje.semantic.ast.member.Field;\n\npublic class ASTField extends AbstractApexNode<Field> implements CanSuppressWarnings {\n\n    public ASTField(Field field) {\n        super(field);\n    }\n\n    @Override\n    public Object jjtAccept(ApexParserVisitor visitor, Object data) {\n        return visitor.visit(this, data);\n    }\n\n    @Override\n    public String getImage() {\n        return getName();\n    }\n\n    @Override\n    public boolean hasSuppressWarningsAnnotationFor(Rule rule) {\n        for (ASTModifierNode modifier : findChildrenOfType(ASTModifierNode.class)) {\n            for (ASTAnnotation a : modifier.findChildrenOfType(ASTAnnotation.class)) {\n                if (a.suppresses(rule)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    public String getType() {\n        return node.getFieldInfo().getType().getApexName();\n    }\n\n    public ASTModifierNode getModifiers() {\n        return getFirstChildOfType(ASTModifierNode.class);\n    }\n\n    public String getName() {\n        return node.getFieldInfo().getName();\n    }\n\n    public String getValue() {\n        if (node.getFieldInfo().getValue() != null) {\n            return String.valueOf(node.getFieldInfo().getValue());\n        }\n        return null;\n    }\n}\n", "diffSourceCodeSet": ["public String getName() {\n        return node.getFieldInfo().getName();\n    }"], "invokedMethodSet": [], "sourceCodeAfterRefactoring": "@Override\n    public String getImage() {\n        return getName();\n    }\npublic String getName() {\n        return node.getFieldInfo().getName();\n    }", "diffSourceCode": "    22:     @Override\n    23:     public String getImage() {\n-   24:         return node.getFieldInfo().getName();\n+   24:         return getName();\n    25:     }\n-   47:     public String getValue() {\n-   48:         if (node.getFieldInfo().getValue() != null) {\n-   49:             return String.valueOf(node.getFieldInfo().getValue());\n+   47:     public String getName() {\n+   48:         return node.getFieldInfo().getName();\n+   49:     }\n", "uniqueId": "e8f8e1ac7a9f4f21bb7a0f9242a81fe7ab7e599c_22_25_47_49_22_25", "moveFileExist": true, "compileResultBefore": true, "compileResultCurrent": true, "compileJDK": 11, "testResult": true, "coverageInfo": {"INSTRUCTION": {"missed": 0, "covered": 3}, "LINE": {"missed": 0, "covered": 1}, "COMPLEXITY": {"missed": 0, "covered": 1}, "METHOD": {"missed": 0, "covered": 1}}, "refactoringMinerResult": true, "compileAndTestResult": true, "refactoredCode": "To improve the readability and maintainability of the `getImage` method, we can extract the logic that retrieves the field name into a separate method. This will make the `getImage` method cleaner and more focused on its primary responsibility.\n\nHere\u2019s the refactored code:\n\n```java\n@Override\npublic String getImage() {\n    return retrieveFieldName();\n}\n\nprivate String retrieveFieldName() {\n    return node.getFieldInfo().getName();\n}\n```\n\nNow, the `getImage` method simply calls the new `retrieveFieldName` method, which encapsulates the logic for obtaining the field name.\n\nHere\u2019s the output in the required format:\n\n##########################\n```java\n@Override\npublic String getImage() {\n    return retrieveFieldName();\n}\n\nprivate String retrieveFieldName() {\n    return node.getFieldInfo().getName();\n}\n```\n##########################", "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to Refactor:\n@Override\n    public String getImage() {\n        return node.getFieldInfo().getName();\n    }\n\nClass content:\n/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.lang.apex.ast;\n\nimport net.sourceforge.pmd.Rule;\n\nimport apex.jorje.semantic.ast.member.Field;\n\npublic class ASTField extends AbstractApexNode<Field> implements CanSuppressWarnings {\n\n    public ASTField(Field field) {\n        super(field);\n    }\n\n    @Override\n    public Object jjtAccept(ApexParserVisitor visitor, Object data) {\n        return visitor.visit(this, data);\n    }\n\n    @Override\n    public String getImage() {\n        return node.getFieldInfo().getName();\n    }\n\n    @Override\n    public boolean hasSuppressWarningsAnnotationFor(Rule rule) {\n        for (ASTModifierNode modifier : findChildrenOfType(ASTModifierNode.class)) {\n            for (ASTAnnotation a : modifier.findChildrenOfType(ASTAnnotation.class)) {\n                if (a.suppresses(rule)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    public String getType() {\n        return node.getFieldInfo().getType().getApexName();\n    }\n\n    public ASTModifierNode getModifiers() {\n        return getFirstChildOfType(ASTModifierNode.class);\n    }\n\n    public String getValue() {\n        if (node.getFieldInfo().getValue() != null) {\n            return String.valueOf(node.getFieldInfo().getValue());\n        }\n        return null;\n    }\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n"}, {"type": "Extract And Move Method", "description": "Extract And Move Method\tpublic getType() : String extracted from package getFQVariableName(variable ASTNewKeyValueObjectExpression) : String in class net.sourceforge.pmd.lang.apex.rule.security.Helper & moved to class net.sourceforge.pmd.lang.apex.ast.ASTNewKeyValueObjectExpression", "diffLocations": [{"filePath": "pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/rule/security/Helper.java", "startLine": 187, "endLine": 194, "startColumn": 0, "endColumn": 0}, {"filePath": "pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/rule/security/Helper.java", "startLine": 175, "endLine": 180, "startColumn": 0, "endColumn": 0}, {"filePath": "pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/rule/security/Helper.java", "startLine": 20, "endLine": 22, "startColumn": 0, "endColumn": 0}], "sourceCodeBeforeRefactoring": "static String getFQVariableName(final ASTNewKeyValueObjectExpression variable) {\n        NewKeyValueObjectExpression n = variable.getNode();\n        TypeRef typeRef = n.getTypeRef();\n        String objType = typeRef.getNames().get(0).getValue();\n\n        StringBuilder sb = new StringBuilder().append(n.getDefiningType().getApexName()).append(\":\").append(objType);\n        return sb.toString();\n    }", "filePathBefore": "pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/rule/security/Helper.java", "isPureRefactoring": true, "commitId": "91d0ebf4620b9cda44ce6f02232fe8a003d82efd", "packageNameBefore": "net.sourceforge.pmd.lang.apex.rule.security", "classNameBefore": "net.sourceforge.pmd.lang.apex.rule.security.Helper", "methodNameBefore": "net.sourceforge.pmd.lang.apex.rule.security.Helper#getFQVariableName", "classSignatureBefore": "public final class Helper ", "methodNameBeforeSet": ["net.sourceforge.pmd.lang.apex.rule.security.Helper#getFQVariableName"], "classNameBeforeSet": ["net.sourceforge.pmd.lang.apex.rule.security.Helper"], "classSignatureBeforeSet": ["public final class Helper "], "purityCheckResultList": [{"isPure": true, "purityComment": "Overlapped refactoring - can be identical by undoing the overlapped refactoring\n- Inline Variable-", "description": "Inline Variable on top of the extracted method - all mapped", "mappingState": 1}], "sourceCodeBeforeForWhole": "/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.lang.apex.rule.security;\n\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Locale;\n\nimport net.sourceforge.pmd.lang.apex.ast.ASTDmlDeleteStatement;\nimport net.sourceforge.pmd.lang.apex.ast.ASTDmlInsertStatement;\nimport net.sourceforge.pmd.lang.apex.ast.ASTDmlMergeStatement;\nimport net.sourceforge.pmd.lang.apex.ast.ASTDmlUndeleteStatement;\nimport net.sourceforge.pmd.lang.apex.ast.ASTDmlUpdateStatement;\nimport net.sourceforge.pmd.lang.apex.ast.ASTDmlUpsertStatement;\nimport net.sourceforge.pmd.lang.apex.ast.ASTField;\nimport net.sourceforge.pmd.lang.apex.ast.ASTFieldDeclaration;\nimport net.sourceforge.pmd.lang.apex.ast.ASTMethodCallExpression;\nimport net.sourceforge.pmd.lang.apex.ast.ASTModifierNode;\nimport net.sourceforge.pmd.lang.apex.ast.ASTNewKeyValueObjectExpression;\nimport net.sourceforge.pmd.lang.apex.ast.ASTParameter;\nimport net.sourceforge.pmd.lang.apex.ast.ASTReferenceExpression;\nimport net.sourceforge.pmd.lang.apex.ast.ASTSoqlExpression;\nimport net.sourceforge.pmd.lang.apex.ast.ASTSoslExpression;\nimport net.sourceforge.pmd.lang.apex.ast.ASTUserClass;\nimport net.sourceforge.pmd.lang.apex.ast.ASTVariableDeclaration;\nimport net.sourceforge.pmd.lang.apex.ast.ASTVariableExpression;\nimport net.sourceforge.pmd.lang.apex.ast.ApexNode;\n\nimport apex.jorje.data.Identifier;\nimport apex.jorje.data.ast.TypeRef;\nimport apex.jorje.semantic.ast.expression.MethodCallExpression;\nimport apex.jorje.semantic.ast.expression.NewKeyValueObjectExpression;\nimport apex.jorje.semantic.ast.expression.VariableExpression;\nimport apex.jorje.semantic.ast.member.Field;\nimport apex.jorje.semantic.ast.member.Parameter;\nimport apex.jorje.semantic.ast.statement.FieldDeclaration;\nimport apex.jorje.semantic.ast.statement.VariableDeclaration;\n\n/**\n * Helper methods\n * \n * @author sergey.gorbaty\n *\n */\npublic final class Helper {\n    static final String ANY_METHOD = \"*\";\n\n    private Helper() {\n        throw new AssertionError(\"Can't instantiate helper classes\");\n    }\n\n    static boolean isTestMethodOrClass(final ApexNode<?> node) {\n        final List<ASTModifierNode> modifierNode = node.findChildrenOfType(ASTModifierNode.class);\n        for (final ASTModifierNode m : modifierNode) {\n            if (m.isTest()) {\n                return true;\n            }\n        }\n\n        final String className = node.getNode().getDefiningType().getApexName();\n        return className.endsWith(\"Test\");\n    }\n\n    static boolean foundAnySOQLorSOSL(final ApexNode<?> node) {\n        final List<ASTSoqlExpression> dmlSoqlExpression = node.findDescendantsOfType(ASTSoqlExpression.class);\n        final List<ASTSoslExpression> dmlSoslExpression = node.findDescendantsOfType(ASTSoslExpression.class);\n\n        return !dmlSoqlExpression.isEmpty() || !dmlSoslExpression.isEmpty();\n    }\n\n    /**\n     * Finds DML operations in a given node descendants' path\n     * \n     * @param node\n     * \n     * @return true if found DML operations in node descendants\n     */\n    static boolean foundAnyDML(final ApexNode<?> node) {\n\n        final List<ASTDmlUpsertStatement> dmlUpsertStatement = node.findDescendantsOfType(ASTDmlUpsertStatement.class);\n        final List<ASTDmlUpdateStatement> dmlUpdateStatement = node.findDescendantsOfType(ASTDmlUpdateStatement.class);\n        final List<ASTDmlUndeleteStatement> dmlUndeleteStatement = node\n                .findDescendantsOfType(ASTDmlUndeleteStatement.class);\n        final List<ASTDmlMergeStatement> dmlMergeStatement = node.findDescendantsOfType(ASTDmlMergeStatement.class);\n        final List<ASTDmlInsertStatement> dmlInsertStatement = node.findDescendantsOfType(ASTDmlInsertStatement.class);\n        final List<ASTDmlDeleteStatement> dmlDeleteStatement = node.findDescendantsOfType(ASTDmlDeleteStatement.class);\n\n        return !dmlUpsertStatement.isEmpty() || !dmlUpdateStatement.isEmpty() || !dmlUndeleteStatement.isEmpty()\n                || !dmlMergeStatement.isEmpty() || !dmlInsertStatement.isEmpty() || !dmlDeleteStatement.isEmpty();\n    }\n\n    static boolean isMethodName(final ASTMethodCallExpression methodNode, final String className,\n            final String methodName) {\n        final ASTReferenceExpression reference = methodNode.getFirstChildOfType(ASTReferenceExpression.class);\n\n        return reference != null && reference.getNode().getNames().size() == 1\n                && reference.getNode().getNames().get(0).getValue().equalsIgnoreCase(className)\n                && (methodName.equals(ANY_METHOD) || isMethodName(methodNode, methodName));\n    }\n\n    static boolean isMethodName(final ASTMethodCallExpression m, final String methodName) {\n        return isMethodName(m.getNode(), methodName);\n    }\n\n    static boolean isMethodName(final MethodCallExpression m, final String methodName) {\n        return m.getMethodName().equalsIgnoreCase(methodName);\n    }\n\n    static boolean isMethodCallChain(final ASTMethodCallExpression methodNode, final String... methodNames) {\n        String methodName = methodNames[methodNames.length - 1];\n        if (Helper.isMethodName(methodNode, methodName)) {\n            final ASTReferenceExpression reference = methodNode.getFirstChildOfType(ASTReferenceExpression.class);\n            if (reference != null) {\n                final ASTMethodCallExpression nestedMethod = reference\n                        .getFirstChildOfType(ASTMethodCallExpression.class);\n                if (nestedMethod != null) {\n                    String[] newMethodNames = Arrays.copyOf(methodNames, methodNames.length - 1);\n                    return isMethodCallChain(nestedMethod, newMethodNames);\n                } else {\n                    String[] newClassName = Arrays.copyOf(methodNames, methodNames.length - 1);\n                    if (newClassName.length == 1) {\n                        return Helper.isMethodName(methodNode, newClassName[0], methodName);\n                    }\n                }\n            }\n        }\n\n        return false;\n    }\n\n    static String getFQVariableName(final ASTVariableExpression variable) {\n        final ASTReferenceExpression ref = variable.getFirstChildOfType(ASTReferenceExpression.class);\n        String objectName = \"\";\n        if (ref != null) {\n            if (ref.getNode().getNames().size() == 1) {\n                objectName = ref.getNode().getNames().get(0).getValue() + \".\";\n            }\n        }\n\n        VariableExpression n = variable.getNode();\n        StringBuilder sb = new StringBuilder().append(n.getDefiningType().getApexName()).append(\":\").append(objectName)\n                .append(n.getIdentifier().getValue());\n        return sb.toString();\n    }\n\n    static String getFQVariableName(final ASTVariableDeclaration variable) {\n        VariableDeclaration n = variable.getNode();\n        StringBuilder sb = new StringBuilder().append(n.getDefiningType().getApexName()).append(\":\")\n                .append(n.getLocalInfo().getName());\n        return sb.toString();\n    }\n\n    static String getFQVariableName(final ASTField variable) {\n        Field n = variable.getNode();\n        StringBuilder sb = new StringBuilder().append(n.getDefiningType().getApexName()).append(\":\")\n                .append(n.getFieldInfo().getName());\n        return sb.toString();\n    }\n\n    static String getVariableType(final ASTField variable) {\n        Field n = variable.getNode();\n        StringBuilder sb = new StringBuilder().append(n.getDefiningType().getApexName()).append(\":\")\n                .append(n.getFieldInfo().getName());\n        return sb.toString();\n    }\n    \n    static String getFQVariableName(final ASTFieldDeclaration variable) {\n        FieldDeclaration n = variable.getNode();\n        String name = \"\";\n\n        try {\n            java.lang.reflect.Field f = n.getClass().getDeclaredField(\"name\");\n            f.setAccessible(true);\n            Identifier nameField = (Identifier) f.get(n);\n            name = nameField.getValue();\n\n        } catch (NoSuchFieldException | SecurityException | IllegalArgumentException | IllegalAccessException e) {\n            throw new RuntimeException(e);\n        }\n\n        StringBuilder sb = new StringBuilder().append(n.getDefiningType().getApexName()).append(\":\").append(name);\n        return sb.toString();\n    }\n\n    static String getFQVariableName(final ASTNewKeyValueObjectExpression variable) {\n        NewKeyValueObjectExpression n = variable.getNode();\n        TypeRef typeRef = n.getTypeRef();\n        String objType = typeRef.getNames().get(0).getValue();\n\n        StringBuilder sb = new StringBuilder().append(n.getDefiningType().getApexName()).append(\":\").append(objType);\n        return sb.toString();\n    }\n\n    static boolean isSystemLevelClass(ASTUserClass node) {\n        List<TypeRef> interfaces = node.getNode().getDefiningType().getCodeUnitDetails().getInterfaceTypeRefs();\n\n        for (TypeRef intObject : interfaces) {\n            if (isWhitelisted(intObject.getNames())) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    private static boolean isWhitelisted(List<Identifier> ids) {\n        StringBuffer sb = new StringBuffer();\n\n        for (int i = 0; i < ids.size(); i++) {\n            sb.append(ids.get(i).getValue());\n\n            if (i != ids.size() - 1) {\n                sb.append(\".\");\n            }\n        }\n\n        switch (sb.toString().toLowerCase(Locale.ROOT)) {\n        case \"queueable\":\n        case \"database.batchable\":\n        case \"installhandler\":\n            return true;\n        default:\n            break;\n        }\n        return false;\n    }\n\n    public static String getFQVariableName(Parameter p) {\n        StringBuffer sb = new StringBuffer();\n        sb.append(p.getDefiningType()).append(\":\").append(p.getName().getValue());\n        return sb.toString();\n    }\n\n    static String getFQVariableName(ASTParameter p) {\n        StringBuffer sb = new StringBuffer();\n        sb.append(p.getNode().getDefiningType()).append(\":\").append(p.getImage());\n        return sb.toString();\n    }\n\n}\n", "filePathAfter": "pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/rule/security/Helper.java", "sourceCodeAfterForWhole": "/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.lang.apex.rule.security;\n\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Locale;\n\nimport net.sourceforge.pmd.lang.apex.ast.ASTDmlDeleteStatement;\nimport net.sourceforge.pmd.lang.apex.ast.ASTDmlInsertStatement;\nimport net.sourceforge.pmd.lang.apex.ast.ASTDmlMergeStatement;\nimport net.sourceforge.pmd.lang.apex.ast.ASTDmlUndeleteStatement;\nimport net.sourceforge.pmd.lang.apex.ast.ASTDmlUpdateStatement;\nimport net.sourceforge.pmd.lang.apex.ast.ASTDmlUpsertStatement;\nimport net.sourceforge.pmd.lang.apex.ast.ASTField;\nimport net.sourceforge.pmd.lang.apex.ast.ASTFieldDeclaration;\nimport net.sourceforge.pmd.lang.apex.ast.ASTMethodCallExpression;\nimport net.sourceforge.pmd.lang.apex.ast.ASTModifierNode;\nimport net.sourceforge.pmd.lang.apex.ast.ASTNewKeyValueObjectExpression;\nimport net.sourceforge.pmd.lang.apex.ast.ASTParameter;\nimport net.sourceforge.pmd.lang.apex.ast.ASTReferenceExpression;\nimport net.sourceforge.pmd.lang.apex.ast.ASTSoqlExpression;\nimport net.sourceforge.pmd.lang.apex.ast.ASTSoslExpression;\nimport net.sourceforge.pmd.lang.apex.ast.ASTUserClass;\nimport net.sourceforge.pmd.lang.apex.ast.ASTVariableDeclaration;\nimport net.sourceforge.pmd.lang.apex.ast.ASTVariableExpression;\nimport net.sourceforge.pmd.lang.apex.ast.ApexNode;\n\nimport apex.jorje.data.Identifier;\nimport apex.jorje.data.ast.TypeRef;\nimport apex.jorje.semantic.ast.expression.MethodCallExpression;\nimport apex.jorje.semantic.ast.expression.VariableExpression;\nimport apex.jorje.semantic.ast.member.Field;\nimport apex.jorje.semantic.ast.member.Parameter;\nimport apex.jorje.semantic.ast.statement.VariableDeclaration;\n\n/**\n * Helper methods\n * \n * @author sergey.gorbaty\n *\n */\npublic final class Helper {\n    static final String ANY_METHOD = \"*\";\n\n    private Helper() {\n        throw new AssertionError(\"Can't instantiate helper classes\");\n    }\n\n    static boolean isTestMethodOrClass(final ApexNode<?> node) {\n        final List<ASTModifierNode> modifierNode = node.findChildrenOfType(ASTModifierNode.class);\n        for (final ASTModifierNode m : modifierNode) {\n            if (m.isTest()) {\n                return true;\n            }\n        }\n\n        final String className = node.getNode().getDefiningType().getApexName();\n        return className.endsWith(\"Test\");\n    }\n\n    static boolean foundAnySOQLorSOSL(final ApexNode<?> node) {\n        final List<ASTSoqlExpression> dmlSoqlExpression = node.findDescendantsOfType(ASTSoqlExpression.class);\n        final List<ASTSoslExpression> dmlSoslExpression = node.findDescendantsOfType(ASTSoslExpression.class);\n\n        return !dmlSoqlExpression.isEmpty() || !dmlSoslExpression.isEmpty();\n    }\n\n    /**\n     * Finds DML operations in a given node descendants' path\n     * \n     * @param node\n     * \n     * @return true if found DML operations in node descendants\n     */\n    static boolean foundAnyDML(final ApexNode<?> node) {\n\n        final List<ASTDmlUpsertStatement> dmlUpsertStatement = node.findDescendantsOfType(ASTDmlUpsertStatement.class);\n        final List<ASTDmlUpdateStatement> dmlUpdateStatement = node.findDescendantsOfType(ASTDmlUpdateStatement.class);\n        final List<ASTDmlUndeleteStatement> dmlUndeleteStatement = node\n                .findDescendantsOfType(ASTDmlUndeleteStatement.class);\n        final List<ASTDmlMergeStatement> dmlMergeStatement = node.findDescendantsOfType(ASTDmlMergeStatement.class);\n        final List<ASTDmlInsertStatement> dmlInsertStatement = node.findDescendantsOfType(ASTDmlInsertStatement.class);\n        final List<ASTDmlDeleteStatement> dmlDeleteStatement = node.findDescendantsOfType(ASTDmlDeleteStatement.class);\n\n        return !dmlUpsertStatement.isEmpty() || !dmlUpdateStatement.isEmpty() || !dmlUndeleteStatement.isEmpty()\n                || !dmlMergeStatement.isEmpty() || !dmlInsertStatement.isEmpty() || !dmlDeleteStatement.isEmpty();\n    }\n\n    static boolean isMethodName(final ASTMethodCallExpression methodNode, final String className,\n            final String methodName) {\n        final ASTReferenceExpression reference = methodNode.getFirstChildOfType(ASTReferenceExpression.class);\n\n        return reference != null && reference.getNode().getNames().size() == 1\n                && reference.getNode().getNames().get(0).getValue().equalsIgnoreCase(className)\n                && (methodName.equals(ANY_METHOD) || isMethodName(methodNode, methodName));\n    }\n\n    static boolean isMethodName(final ASTMethodCallExpression m, final String methodName) {\n        return isMethodName(m.getNode(), methodName);\n    }\n\n    static boolean isMethodName(final MethodCallExpression m, final String methodName) {\n        return m.getMethodName().equalsIgnoreCase(methodName);\n    }\n\n    static boolean isMethodCallChain(final ASTMethodCallExpression methodNode, final String... methodNames) {\n        String methodName = methodNames[methodNames.length - 1];\n        if (Helper.isMethodName(methodNode, methodName)) {\n            final ASTReferenceExpression reference = methodNode.getFirstChildOfType(ASTReferenceExpression.class);\n            if (reference != null) {\n                final ASTMethodCallExpression nestedMethod = reference\n                        .getFirstChildOfType(ASTMethodCallExpression.class);\n                if (nestedMethod != null) {\n                    String[] newMethodNames = Arrays.copyOf(methodNames, methodNames.length - 1);\n                    return isMethodCallChain(nestedMethod, newMethodNames);\n                } else {\n                    String[] newClassName = Arrays.copyOf(methodNames, methodNames.length - 1);\n                    if (newClassName.length == 1) {\n                        return Helper.isMethodName(methodNode, newClassName[0], methodName);\n                    }\n                }\n            }\n        }\n\n        return false;\n    }\n\n    static String getFQVariableName(final ASTVariableExpression variable) {\n        final ASTReferenceExpression ref = variable.getFirstChildOfType(ASTReferenceExpression.class);\n        String objectName = \"\";\n        if (ref != null) {\n            if (ref.getNode().getNames().size() == 1) {\n                objectName = ref.getNode().getNames().get(0).getValue() + \".\";\n            }\n        }\n\n        VariableExpression n = variable.getNode();\n        StringBuilder sb = new StringBuilder().append(n.getDefiningType().getApexName()).append(\":\").append(objectName)\n                .append(n.getIdentifier().getValue());\n        return sb.toString();\n    }\n\n    static String getFQVariableName(final ASTVariableDeclaration variable) {\n        VariableDeclaration n = variable.getNode();\n        StringBuilder sb = new StringBuilder().append(n.getDefiningType().getApexName()).append(\":\")\n                .append(n.getLocalInfo().getName());\n        return sb.toString();\n    }\n\n    static String getFQVariableName(final ASTField variable) {\n        Field n = variable.getNode();\n        StringBuilder sb = new StringBuilder()\n                .append(n.getDefiningType().getApexName()).append(\":\")\n                .append(n.getFieldInfo().getName());\n        return sb.toString();\n    }\n\n    static String getVariableType(final ASTField variable) {\n        Field n = variable.getNode();\n        StringBuilder sb = new StringBuilder().append(n.getDefiningType().getApexName()).append(\":\")\n                .append(n.getFieldInfo().getName());\n        return sb.toString();\n    }\n    \n    static String getFQVariableName(final ASTFieldDeclaration variable) {\n        StringBuilder sb = new StringBuilder()\n                .append(variable.getNode().getDefiningType().getApexName()).append(\":\")\n                .append(variable.getImage());\n        return sb.toString();\n    }\n\n    static String getFQVariableName(final ASTNewKeyValueObjectExpression variable) {\n        StringBuilder sb = new StringBuilder()\n                .append(variable.getNode().getDefiningType().getApexName()).append(\":\")\n                .append(variable.getType());\n        return sb.toString();\n    }\n\n    static boolean isSystemLevelClass(ASTUserClass node) {\n        List<TypeRef> interfaces = node.getNode().getDefiningType().getCodeUnitDetails().getInterfaceTypeRefs();\n\n        for (TypeRef intObject : interfaces) {\n            if (isWhitelisted(intObject.getNames())) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    private static boolean isWhitelisted(List<Identifier> ids) {\n        StringBuffer sb = new StringBuffer();\n\n        for (int i = 0; i < ids.size(); i++) {\n            sb.append(ids.get(i).getValue());\n\n            if (i != ids.size() - 1) {\n                sb.append(\".\");\n            }\n        }\n\n        switch (sb.toString().toLowerCase(Locale.ROOT)) {\n        case \"queueable\":\n        case \"database.batchable\":\n        case \"installhandler\":\n            return true;\n        default:\n            break;\n        }\n        return false;\n    }\n\n    public static String getFQVariableName(Parameter p) {\n        StringBuffer sb = new StringBuffer();\n        sb.append(p.getDefiningType()).append(\":\").append(p.getName().getValue());\n        return sb.toString();\n    }\n\n    static String getFQVariableName(ASTParameter p) {\n        StringBuffer sb = new StringBuffer();\n        sb.append(p.getNode().getDefiningType()).append(\":\").append(p.getImage());\n        return sb.toString();\n    }\n\n}\n", "diffSourceCodeSet": ["import net.sourceforge.pmd.lang.apex.ast.ASTModifierNode;\nimport net.sourceforge.pmd.lang.apex.ast.ASTNewKeyValueObjectExpression;\nimport net.sourceforge.pmd.lang.apex.ast.ASTParameter;"], "invokedMethodSet": [], "sourceCodeAfterRefactoring": "static String getFQVariableName(final ASTNewKeyValueObjectExpression variable) {\n        StringBuilder sb = new StringBuilder()\n                .append(variable.getNode().getDefiningType().getApexName()).append(\":\")\n                .append(variable.getType());\n        return sb.toString();\n    }\nimport net.sourceforge.pmd.lang.apex.ast.ASTModifierNode;\nimport net.sourceforge.pmd.lang.apex.ast.ASTNewKeyValueObjectExpression;\nimport net.sourceforge.pmd.lang.apex.ast.ASTParameter;", "diffSourceCode": "    20: import net.sourceforge.pmd.lang.apex.ast.ASTModifierNode;\n    21: import net.sourceforge.pmd.lang.apex.ast.ASTNewKeyValueObjectExpression;\n    22: import net.sourceforge.pmd.lang.apex.ast.ASTParameter;\n-  175:             f.setAccessible(true);\n-  176:             Identifier nameField = (Identifier) f.get(n);\n-  177:             name = nameField.getValue();\n-  178: \n-  179:         } catch (NoSuchFieldException | SecurityException | IllegalArgumentException | IllegalAccessException e) {\n-  180:             throw new RuntimeException(e);\n-  187:     static String getFQVariableName(final ASTNewKeyValueObjectExpression variable) {\n-  188:         NewKeyValueObjectExpression n = variable.getNode();\n-  189:         TypeRef typeRef = n.getTypeRef();\n-  190:         String objType = typeRef.getNames().get(0).getValue();\n-  191: \n-  192:         StringBuilder sb = new StringBuilder().append(n.getDefiningType().getApexName()).append(\":\").append(objType);\n-  193:         return sb.toString();\n-  194:     }\n+  175:     static String getFQVariableName(final ASTNewKeyValueObjectExpression variable) {\n+  176:         StringBuilder sb = new StringBuilder()\n+  177:                 .append(variable.getNode().getDefiningType().getApexName()).append(\":\")\n+  178:                 .append(variable.getType());\n+  179:         return sb.toString();\n+  180:     }\n+  187:                 return true;\n+  188:             }\n+  189:         }\n+  190: \n+  191:         return false;\n+  192:     }\n+  193: \n+  194:     private static boolean isWhitelisted(List<Identifier> ids) {\n", "uniqueId": "91d0ebf4620b9cda44ce6f02232fe8a003d82efd_187_194_20_22_175_180", "moveFileExist": true, "testResult": true, "coverageInfo": {"INSTRUCTION": {"missed": 0, "covered": 19}, "LINE": {"missed": 0, "covered": 3}, "COMPLEXITY": {"missed": 0, "covered": 1}, "METHOD": {"missed": 0, "covered": 1}}, "compileResultBefore": true, "compileResultCurrent": true, "compileJDK": 11, "refactoringMinerResult": true, "compileAndTestResult": true, "refactoredCode": "To refactor the provided code, we will extract the method `getFQVariableName` that takes an `ASTNewKeyValueObjectExpression` as a parameter and move it to the `ApexLanguage` class, which is a suitable location based on the project structure. This will improve modularity and maintainability.\n\n### Step 1: Extracted Method Code\nThe extracted method will be a public static method in the `ApexLanguage` class.\n\n```java\npublic static String getFQVariableName(final ASTNewKeyValueObjectExpression variable) {\n    NewKeyValueObjectExpression n = variable.getNode();\n    TypeRef typeRef = n.getTypeRef();\n    String objType = typeRef.getNames().get(0).getValue();\n\n    StringBuilder sb = new StringBuilder().append(n.getDefiningType().getApexName()).append(\":\").append(objType);\n    return sb.toString();\n}\n```\n\n### Step 2: Refactored Method Code\nThe refactored method in the `Helper` class will call the newly extracted method from the `ApexLanguage` class.\n\n```java\nstatic String getFQVariableName(final ASTNewKeyValueObjectExpression variable) {\n    return ApexLanguage.getFQVariableName(variable);\n}\n```\n\n### Step 3: Target File Path\nThe target file path where the method is moved to is:\n```\npmd-apex/src/main/java/net/sourceforge/pmd/cpd/ApexLanguage.java\n```\n\n### Final Output\nHere is the complete output in the specified format:\n\n##########################\npmd-apex/src/main/java/net/sourceforge/pmd/cpd/ApexLanguage.java\n##########################\npublic static String getFQVariableName(final ASTNewKeyValueObjectExpression variable) {\n    NewKeyValueObjectExpression n = variable.getNode();\n    TypeRef typeRef = n.getTypeRef();\n    String objType = typeRef.getNames().get(0).getValue();\n\n    StringBuilder sb = new StringBuilder().append(n.getDefiningType().getApexName()).append(\":\").append(objType);\n    return sb.toString();\n}\n##########################\nstatic String getFQVariableName(final ASTNewKeyValueObjectExpression variable) {\n    return ApexLanguage.getFQVariableName(variable);\n}\n##########################", "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to Refactor:\nstatic String getFQVariableName(final ASTNewKeyValueObjectExpression variable) {\n        NewKeyValueObjectExpression n = variable.getNode();\n        TypeRef typeRef = n.getTypeRef();\n        String objType = typeRef.getNames().get(0).getValue();\n\n        StringBuilder sb = new StringBuilder().append(n.getDefiningType().getApexName()).append(\":\").append(objType);\n        return sb.toString();\n    }\n\nClass content:\n/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.lang.apex.rule.security;\n\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Locale;\n\nimport net.sourceforge.pmd.lang.apex.ast.ASTDmlDeleteStatement;\nimport net.sourceforge.pmd.lang.apex.ast.ASTDmlInsertStatement;\nimport net.sourceforge.pmd.lang.apex.ast.ASTDmlMergeStatement;\nimport net.sourceforge.pmd.lang.apex.ast.ASTDmlUndeleteStatement;\nimport net.sourceforge.pmd.lang.apex.ast.ASTDmlUpdateStatement;\nimport net.sourceforge.pmd.lang.apex.ast.ASTDmlUpsertStatement;\nimport net.sourceforge.pmd.lang.apex.ast.ASTField;\nimport net.sourceforge.pmd.lang.apex.ast.ASTFieldDeclaration;\nimport net.sourceforge.pmd.lang.apex.ast.ASTMethodCallExpression;\nimport net.sourceforge.pmd.lang.apex.ast.ASTModifierNode;\nimport net.sourceforge.pmd.lang.apex.ast.ASTNewKeyValueObjectExpression;\nimport net.sourceforge.pmd.lang.apex.ast.ASTParameter;\nimport net.sourceforge.pmd.lang.apex.ast.ASTReferenceExpression;\nimport net.sourceforge.pmd.lang.apex.ast.ASTSoqlExpression;\nimport net.sourceforge.pmd.lang.apex.ast.ASTSoslExpression;\nimport net.sourceforge.pmd.lang.apex.ast.ASTUserClass;\nimport net.sourceforge.pmd.lang.apex.ast.ASTVariableDeclaration;\nimport net.sourceforge.pmd.lang.apex.ast.ASTVariableExpression;\nimport net.sourceforge.pmd.lang.apex.ast.ApexNode;\n\nimport apex.jorje.data.Identifier;\nimport apex.jorje.data.ast.TypeRef;\nimport apex.jorje.semantic.ast.expression.MethodCallExpression;\nimport apex.jorje.semantic.ast.expression.NewKeyValueObjectExpression;\nimport apex.jorje.semantic.ast.expression.VariableExpression;\nimport apex.jorje.semantic.ast.member.Field;\nimport apex.jorje.semantic.ast.member.Parameter;\nimport apex.jorje.semantic.ast.statement.FieldDeclaration;\nimport apex.jorje.semantic.ast.statement.VariableDeclaration;\n\n/**\n * Helper methods\n * \n * @author sergey.gorbaty\n *\n */\npublic final class Helper {\n    static final String ANY_METHOD = \"*\";\n\n    private Helper() {\n        throw new AssertionError(\"Can't instantiate helper classes\");\n    }\n\n    static boolean isTestMethodOrClass(final ApexNode<?> node) {\n        final List<ASTModifierNode> modifierNode = node.findChildrenOfType(ASTModifierNode.class);\n        for (final ASTModifierNode m : modifierNode) {\n            if (m.isTest()) {\n                return true;\n            }\n        }\n\n        final String className = node.getNode().getDefiningType().getApexName();\n        return className.endsWith(\"Test\");\n    }\n\n    static boolean foundAnySOQLorSOSL(final ApexNode<?> node) {\n        final List<ASTSoqlExpression> dmlSoqlExpression = node.findDescendantsOfType(ASTSoqlExpression.class);\n        final List<ASTSoslExpression> dmlSoslExpression = node.findDescendantsOfType(ASTSoslExpression.class);\n\n        return !dmlSoqlExpression.isEmpty() || !dmlSoslExpression.isEmpty();\n    }\n\n    /**\n     * Finds DML operations in a given node descendants' path\n     * \n     * @param node\n     * \n     * @return true if found DML operations in node descendants\n     */\n    static boolean foundAnyDML(final ApexNode<?> node) {\n\n        final List<ASTDmlUpsertStatement> dmlUpsertStatement = node.findDescendantsOfType(ASTDmlUpsertStatement.class);\n        final List<ASTDmlUpdateStatement> dmlUpdateStatement = node.findDescendantsOfType(ASTDmlUpdateStatement.class);\n        final List<ASTDmlUndeleteStatement> dmlUndeleteStatement = node\n                .findDescendantsOfType(ASTDmlUndeleteStatement.class);\n        final List<ASTDmlMergeStatement> dmlMergeStatement = node.findDescendantsOfType(ASTDmlMergeStatement.class);\n        final List<ASTDmlInsertStatement> dmlInsertStatement = node.findDescendantsOfType(ASTDmlInsertStatement.class);\n        final List<ASTDmlDeleteStatement> dmlDeleteStatement = node.findDescendantsOfType(ASTDmlDeleteStatement.class);\n\n        return !dmlUpsertStatement.isEmpty() || !dmlUpdateStatement.isEmpty() || !dmlUndeleteStatement.isEmpty()\n                || !dmlMergeStatement.isEmpty() || !dmlInsertStatement.isEmpty() || !dmlDeleteStatement.isEmpty();\n    }\n\n    static boolean isMethodName(final ASTMethodCallExpression methodNode, final String className,\n            final String methodName) {\n        final ASTReferenceExpression reference = methodNode.getFirstChildOfType(ASTReferenceExpression.class);\n\n        return reference != null && reference.getNode().getNames().size() == 1\n                && reference.getNode().getNames().get(0).getValue().equalsIgnoreCase(className)\n                && (methodName.equals(ANY_METHOD) || isMethodName(methodNode, methodName));\n    }\n\n    static boolean isMethodName(final ASTMethodCallExpression m, final String methodName) {\n        return isMethodName(m.getNode(), methodName);\n    }\n\n    static boolean isMethodName(final MethodCallExpression m, final String methodName) {\n        return m.getMethodName().equalsIgnoreCase(methodName);\n    }\n\n    static boolean isMethodCallChain(final ASTMethodCallExpression methodNode, final String... methodNames) {\n        String methodName = methodNames[methodNames.length - 1];\n        if (Helper.isMethodName(methodNode, methodName)) {\n            final ASTReferenceExpression reference = methodNode.getFirstChildOfType(ASTReferenceExpression.class);\n            if (reference != null) {\n                final ASTMethodCallExpression nestedMethod = reference\n                        .getFirstChildOfType(ASTMethodCallExpression.class);\n                if (nestedMethod != null) {\n                    String[] newMethodNames = Arrays.copyOf(methodNames, methodNames.length - 1);\n                    return isMethodCallChain(nestedMethod, newMethodNames);\n                } else {\n                    String[] newClassName = Arrays.copyOf(methodNames, methodNames.length - 1);\n                    if (newClassName.length == 1) {\n                        return Helper.isMethodName(methodNode, newClassName[0], methodName);\n                    }\n                }\n            }\n        }\n\n        return false;\n    }\n\n    static String getFQVariableName(final ASTVariableExpression variable) {\n        final ASTReferenceExpression ref = variable.getFirstChildOfType(ASTReferenceExpression.class);\n        String objectName = \"\";\n        if (ref != null) {\n            if (ref.getNode().getNames().size() == 1) {\n                objectName = ref.getNode().getNames().get(0).getValue() + \".\";\n            }\n        }\n\n        VariableExpression n = variable.getNode();\n        StringBuilder sb = new StringBuilder().append(n.getDefiningType().getApexName()).append(\":\").append(objectName)\n                .append(n.getIdentifier().getValue());\n        return sb.toString();\n    }\n\n    static String getFQVariableName(final ASTVariableDeclaration variable) {\n        VariableDeclaration n = variable.getNode();\n        StringBuilder sb = new StringBuilder().append(n.getDefiningType().getApexName()).append(\":\")\n                .append(n.getLocalInfo().getName());\n        return sb.toString();\n    }\n\n    static String getFQVariableName(final ASTField variable) {\n        Field n = variable.getNode();\n        StringBuilder sb = new StringBuilder().append(n.getDefiningType().getApexName()).append(\":\")\n                .append(n.getFieldInfo().getName());\n        return sb.toString();\n    }\n\n    static String getVariableType(final ASTField variable) {\n        Field n = variable.getNode();\n        StringBuilder sb = new StringBuilder().append(n.getDefiningType().getApexName()).append(\":\")\n                .append(n.getFieldInfo().getName());\n        return sb.toString();\n    }\n    \n    static String getFQVariableName(final ASTFieldDeclaration variable) {\n        FieldDeclaration n = variable.getNode();\n        String name = \"\";\n\n        try {\n            java.lang.reflect.Field f = n.getClass().getDeclaredField(\"name\");\n            f.setAccessible(true);\n            Identifier nameField = (Identifier) f.get(n);\n            name = nameField.getValue();\n\n        } catch (NoSuchFieldException | SecurityException | IllegalArgumentException | IllegalAccessException e) {\n            throw new RuntimeException(e);\n        }\n\n        StringBuilder sb = new StringBuilder().append(n.getDefiningType().getApexName()).append(\":\").append(name);\n        return sb.toString();\n    }\n\n    static String getFQVariableName(final ASTNewKeyValueObjectExpression variable) {\n        NewKeyValueObjectExpression n = variable.getNode();\n        TypeRef typeRef = n.getTypeRef();\n        String objType = typeRef.getNames().get(0).getValue();\n\n        StringBuilder sb = new StringBuilder().append(n.getDefiningType().getApexName()).append(\":\").append(objType);\n        return sb.toString();\n    }\n\n    static boolean isSystemLevelClass(ASTUserClass node) {\n        List<TypeRef> interfaces = node.getNode().getDefiningType().getCodeUnitDetails().getInterfaceTypeRefs();\n\n        for (TypeRef intObject : interfaces) {\n            if (isWhitelisted(intObject.getNames())) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    private static boolean isWhitelisted(List<Identifier> ids) {\n        StringBuffer sb = new StringBuffer();\n\n        for (int i = 0; i < ids.size(); i++) {\n            sb.append(ids.get(i).getValue());\n\n            if (i != ids.size() - 1) {\n                sb.append(\".\");\n            }\n        }\n\n        switch (sb.toString().toLowerCase(Locale.ROOT)) {\n        case \"queueable\":\n        case \"database.batchable\":\n        case \"installhandler\":\n            return true;\n        default:\n            break;\n        }\n        return false;\n    }\n\n    public static String getFQVariableName(Parameter p) {\n        StringBuffer sb = new StringBuffer();\n        sb.append(p.getDefiningType()).append(\":\").append(p.getName().getValue());\n        return sb.toString();\n    }\n\n    static String getFQVariableName(ASTParameter p) {\n        StringBuffer sb = new StringBuffer();\n        sb.append(p.getNode().getDefiningType()).append(\":\").append(p.getImage());\n        return sb.toString();\n    }\n\n}\n\nRefactoring Operation:\nExtract And Move Method\n\nProject Structure:\n['pmd-apex/src/main/java/net/sourceforge/pmd/cpd/ApexLanguage.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/cpd/ApexTokenizer.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/ApexHandler.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/ApexJorjeLogging.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/ApexLanguageModule.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/ApexParser.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/ApexParserOptions.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/ast/ASTAnnotation.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/ast/ASTAnnotationParameter.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/ast/ASTAnonymousClass.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/ast/ASTArrayLoadExpression.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/ast/ASTArrayStoreExpression.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/ast/ASTAssignmentExpression.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/ast/ASTBinaryExpression.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/ast/ASTBindExpressions.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/ast/ASTBlockStatement.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/ast/ASTBooleanExpression.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/ast/ASTBreakStatement.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/ast/ASTBridgeMethodCreator.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/ast/ASTCastExpression.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/ast/ASTCatchBlockStatement.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/ast/ASTClassRefExpression.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/ast/ASTConstructorPreamble.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/ast/ASTConstructorPreambleStatement.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/ast/ASTContinueStatement.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/ast/ASTDmlDeleteStatement.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/ast/ASTDmlInsertStatement.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/ast/ASTDmlMergeStatement.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/ast/ASTDmlUndeleteStatement.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/ast/ASTDmlUpdateStatement.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/ast/ASTDmlUpsertStatement.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/ast/ASTDoLoopStatement.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/ast/ASTExpression.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/ast/ASTExpressionStatement.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/ast/ASTField.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/ast/ASTFieldDeclaration.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/ast/ASTFieldDeclarationStatements.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/ast/ASTForEachStatement.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/ast/ASTForLoopStatement.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/ast/ASTFormalComment.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/ast/ASTIfBlockStatement.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/ast/ASTIfElseBlockStatement.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/ast/ASTIllegalStoreExpression.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/ast/ASTInstanceOfExpression.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/ast/ASTJavaMethodCallExpression.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/ast/ASTJavaVariableExpression.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/ast/ASTLiteralExpression.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/ast/ASTMapEntryNode.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/ast/ASTMethod.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/ast/ASTMethodBlockStatement.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/ast/ASTMethodCallExpression.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/ast/ASTModifier.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/ast/ASTModifierNode.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/ast/ASTModifierOrAnnotation.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/ast/ASTMultiStatement.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/ast/ASTNestedExpression.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/ast/ASTNestedStoreExpression.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/ast/ASTNewKeyValueObjectExpression.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/ast/ASTNewListInitExpression.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/ast/ASTNewListLiteralExpression.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/ast/ASTNewMapInitExpression.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/ast/ASTNewMapLiteralExpression.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/ast/ASTNewObjectExpression.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/ast/ASTNewSetInitExpression.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/ast/ASTNewSetLiteralExpression.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/ast/ASTPackageVersionExpression.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/ast/ASTParameter.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/ast/ASTPostfixExpression.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/ast/ASTPrefixExpression.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/ast/ASTProperty.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/ast/ASTReferenceExpression.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/ast/ASTReturnStatement.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/ast/ASTRunAsBlockStatement.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/ast/ASTSoqlExpression.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/ast/ASTSoslExpression.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/ast/ASTStandardCondition.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/ast/ASTStatement.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/ast/ASTStatementExecuted.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/ast/ASTSuperMethodCallExpression.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/ast/ASTSuperVariableExpression.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/ast/ASTTernaryExpression.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/ast/ASTThisMethodCallExpression.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/ast/ASTThisVariableExpression.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/ast/ASTThrowStatement.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/ast/ASTTriggerVariableExpression.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/ast/ASTTryCatchFinallyBlockStatement.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/ast/ASTUserClass.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/ast/ASTUserClassMethods.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/ast/ASTUserClassOrInterface.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/ast/ASTUserEnum.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/ast/ASTUserExceptionMethods.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/ast/ASTUserInterface.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/ast/ASTUserTrigger.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/ast/ASTVariableDeclaration.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/ast/ASTVariableDeclarationStatements.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/ast/ASTVariableExpression.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/ast/ASTWhileLoopStatement.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/ast/AbstractApexNode.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/ast/AbstractApexNodeBase.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/ast/AccessNode.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/ast/ApexNode.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/ast/ApexParser.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/ast/ApexParserVisitor.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/ast/ApexParserVisitorAdapter.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/ast/ApexParserVisitorReducedAdapter.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/ast/ApexQualifiableNode.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/ast/ApexQualifiedName.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/ast/ApexRootNode.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/ast/ApexTreeBuilder.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/ast/CanSuppressWarnings.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/ast/CompilerService.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/ast/DumpFacade.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/ast/EmptySymbolProvider.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/ast/TestAccessEvaluator.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/ast/TestQueryValidators.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/metrics/AbstractApexMetric.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/metrics/ApexMetrics.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/metrics/ApexMetricsComputer.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/metrics/ApexMetricsFacade.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/metrics/ApexProjectMemoizer.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/metrics/ApexSignatureMatcher.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/metrics/api/ApexClassMetric.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/metrics/api/ApexClassMetricKey.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/metrics/api/ApexOperationMetric.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/metrics/api/ApexOperationMetricKey.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/metrics/impl/AbstractApexClassMetric.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/metrics/impl/AbstractApexOperationMetric.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/metrics/impl/CycloMetric.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/metrics/impl/WmcMetric.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/metrics/impl/visitors/StandardCycloVisitor.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/metrics/signature/ApexOperationSigMask.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/metrics/signature/ApexOperationSignature.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/metrics/signature/ApexSignature.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/multifile/ApexClassStats.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/multifile/ApexMultifileVisitor.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/multifile/ApexMultifileVisitorFacade.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/multifile/ApexProjectMirror.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/rule/AbstractApexRule.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/rule/AbstractApexUnitTestRule.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/rule/AbstractStatisticalApexRule.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/rule/ApexRuleChainVisitor.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/rule/ApexRuleViolation.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/rule/ApexRuleViolationFactory.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/rule/ApexXPathRule.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/rule/bestpractices/ApexUnitTestClassShouldHaveAssertsRule.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/rule/bestpractices/ApexUnitTestShouldNotUseSeeAllDataTrueRule.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/rule/bestpractices/AvoidGlobalModifierRule.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/rule/bestpractices/AvoidLogicInTriggerRule.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/rule/codestyle/ClassNamingConventionsRule.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/rule/codestyle/MethodNamingConventionsRule.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/rule/codestyle/VariableNamingConventionsRule.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/rule/design/AbstractNcssCountRule.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/rule/design/AvoidDeeplyNestedIfStmtsRule.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/rule/design/CyclomaticComplexityRule.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/rule/design/ExcessiveClassLengthRule.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/rule/design/ExcessiveLengthRule.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/rule/design/ExcessiveNodeCountRule.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/rule/design/ExcessiveParameterListRule.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/rule/design/ExcessivePublicCountRule.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/rule/design/NcssConstructorCountRule.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/rule/design/NcssMethodCountRule.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/rule/design/NcssTypeCountRule.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/rule/design/StdCyclomaticComplexityRule.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/rule/design/TooManyFieldsRule.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/rule/documentation/ApexDocRule.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/rule/errorprone/AvoidHardcodingIdRule.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/rule/errorprone/AvoidNonExistentAnnotationsRule.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/rule/errorprone/MethodWithSameNameAsEnclosingClassRule.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/rule/performance/AvoidDmlStatementsInLoopsRule.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/rule/performance/AvoidSoqlInLoopsRule.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/rule/performance/AvoidSoslInLoopsRule.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/rule/security/ApexBadCryptoRule.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/rule/security/ApexCRUDViolationRule.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/rule/security/ApexCSRFRule.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/rule/security/ApexDangerousMethodsRule.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/rule/security/ApexInsecureEndpointRule.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/rule/security/ApexOpenRedirectRule.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/rule/security/ApexSOQLInjectionRule.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/rule/security/ApexSharingViolationsRule.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/rule/security/ApexSuggestUsingNamedCredRule.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/rule/security/ApexXSSFromEscapeFalseRule.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/rule/security/ApexXSSFromURLParamRule.java', 'pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/rule/security/Helper.java']\n\nFile Path Before Refactoring:\npmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/rule/security/Helper.java\n\nInstructions:\n1. Analyze the provided code, class content, and project structure, apply relevant refactoring operation to the code to be refactored, and you need move the extracted method to another existing java file, output the target file path, extracted method code, refactored method code after refactoring.\nThe extracted method code should be the public static method.\nThe refactored method code should use the moved class to call the extracted method.\nThe target file path should be the path of the existing class where the method is moved to.\n\n2. If refactoring is performed, output the refactored class code in the following format:\n##########################\ntarget_file_path\n##########################\nextracted_method_code\n##########################\nrefactored_method_code\n##########################\n\n\n\n\n\n"}, {"type": "Extract Method", "description": "Extract Method\tpublic getValue() : String extracted from public getImage() : String in class net.sourceforge.pmd.lang.apex.ast.ASTAnnotationParameter", "diffLocations": [{"filePath": "pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/ast/ASTAnnotationParameter.java", "startLine": 20, "endLine": 26, "startColumn": 0, "endColumn": 0}, {"filePath": "pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/ast/ASTAnnotationParameter.java", "startLine": 39, "endLine": 42, "startColumn": 0, "endColumn": 0}, {"filePath": "pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/ast/ASTAnnotationParameter.java", "startLine": 28, "endLine": 33, "startColumn": 0, "endColumn": 0}], "sourceCodeBeforeRefactoring": "@Override\n    public String getImage() {\n        if (node.getValue() != null) {\n            return node.getValueAsString();\n        }\n        return null;\n    }", "filePathBefore": "pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/ast/ASTAnnotationParameter.java", "isPureRefactoring": true, "commitId": "acb30271668581c270c352d85bda4c171b404ce2", "packageNameBefore": "net.sourceforge.pmd.lang.apex.ast", "classNameBefore": "net.sourceforge.pmd.lang.apex.ast.ASTAnnotationParameter", "methodNameBefore": "net.sourceforge.pmd.lang.apex.ast.ASTAnnotationParameter#getImage", "classSignatureBefore": "public class ASTAnnotationParameter extends AbstractApexNode<AnnotationParameter> ", "methodNameBeforeSet": ["net.sourceforge.pmd.lang.apex.ast.ASTAnnotationParameter#getImage"], "classNameBeforeSet": ["net.sourceforge.pmd.lang.apex.ast.ASTAnnotationParameter"], "classSignatureBeforeSet": ["public class ASTAnnotationParameter extends AbstractApexNode<AnnotationParameter> "], "purityCheckResultList": [{"isPure": true, "purityComment": "Identical statements", "description": "There is no replacement! - all mapped", "mappingState": 1}], "sourceCodeBeforeForWhole": "/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.lang.apex.ast;\n\nimport apex.jorje.semantic.ast.modifier.AnnotationParameter;\n\npublic class ASTAnnotationParameter extends AbstractApexNode<AnnotationParameter> {\n\n    public ASTAnnotationParameter(AnnotationParameter annotationParameter) {\n        super(annotationParameter);\n    }\n\n    @Override\n    public Object jjtAccept(ApexParserVisitor visitor, Object data) {\n        return visitor.visit(this, data);\n    }\n\n    @Override\n    public String getImage() {\n        if (node.getValue() != null) {\n            return node.getValueAsString();\n        }\n        return null;\n    }\n}\n", "filePathAfter": "pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/ast/ASTAnnotationParameter.java", "sourceCodeAfterForWhole": "/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.lang.apex.ast;\n\nimport apex.jorje.semantic.ast.modifier.AnnotationParameter;\n\npublic class ASTAnnotationParameter extends AbstractApexNode<AnnotationParameter> {\n    public static final String SEE_ALL_DATA = \"seeAllData\";\n\n    public ASTAnnotationParameter(AnnotationParameter annotationParameter) {\n        super(annotationParameter);\n    }\n\n    @Override\n    public Object jjtAccept(ApexParserVisitor visitor, Object data) {\n        return visitor.visit(this, data);\n    }\n\n    public String getName() {\n        if (node.getProperty() != null) {\n            return node.getProperty().getName();\n        }\n        return null;\n    }\n\n    public String getValue() {\n        if (node.getValue() != null) {\n            return node.getValueAsString();\n        }\n        return null;\n    }\n\n    public Boolean getBooleanValue() {\n        return node.getBooleanValue();\n    }\n\n    @Override\n    public String getImage() {\n        return getValue();\n    }\n}\n", "diffSourceCodeSet": ["public String getValue() {\n        if (node.getValue() != null) {\n            return node.getValueAsString();\n        }\n        return null;\n    }"], "invokedMethodSet": [], "sourceCodeAfterRefactoring": "@Override\n    public String getImage() {\n        return getValue();\n    }\npublic String getValue() {\n        if (node.getValue() != null) {\n            return node.getValueAsString();\n        }\n        return null;\n    }", "diffSourceCode": "-   20:     @Override\n-   21:     public String getImage() {\n-   22:         if (node.getValue() != null) {\n-   23:             return node.getValueAsString();\n+   20: \n+   21:     public String getName() {\n+   22:         if (node.getProperty() != null) {\n+   23:             return node.getProperty().getName();\n    24:         }\n    25:         return null;\n    26:     }\n+   28:     public String getValue() {\n+   29:         if (node.getValue() != null) {\n+   30:             return node.getValueAsString();\n+   31:         }\n+   32:         return null;\n+   33:     }\n+   39:     @Override\n+   40:     public String getImage() {\n+   41:         return getValue();\n+   42:     }\n", "uniqueId": "acb30271668581c270c352d85bda4c171b404ce2_20_26_28_33_39_42", "moveFileExist": true, "testResult": true, "coverageInfo": {"INSTRUCTION": {"missed": 2, "covered": 10}, "BRANCH": {"missed": 1, "covered": 1}, "LINE": {"missed": 1, "covered": 2}, "COMPLEXITY": {"missed": 1, "covered": 1}, "METHOD": {"missed": 0, "covered": 1}}, "compileResultBefore": true, "compileResultCurrent": true, "compileJDK": 11, "refactoringMinerResult": true, "compileAndTestResult": true, "refactoredCode": "To improve the readability and maintainability of the `getImage` method, we can extract the logic that checks for the value and retrieves it into a separate method. This will make the `getImage` method cleaner and more focused on its primary responsibility.\n\nHere\u2019s the refactored code:\n\n```java\n@Override\npublic String getImage() {\n    return getValueAsStringIfPresent();\n}\n\nprivate String getValueAsStringIfPresent() {\n    if (node.getValue() != null) {\n        return node.getValueAsString();\n    }\n    return null;\n}\n```\n\nNow, let's present the refactored method code in the required format:\n\n##########################\n```java\n@Override\npublic String getImage() {\n    return getValueAsStringIfPresent();\n}\n\nprivate String getValueAsStringIfPresent() {\n    if (node.getValue() != null) {\n        return node.getValueAsString();\n    }\n    return null;\n}\n```\n##########################", "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to Refactor:\n@Override\n    public String getImage() {\n        if (node.getValue() != null) {\n            return node.getValueAsString();\n        }\n        return null;\n    }\n\nClass content:\n/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.lang.apex.ast;\n\nimport apex.jorje.semantic.ast.modifier.AnnotationParameter;\n\npublic class ASTAnnotationParameter extends AbstractApexNode<AnnotationParameter> {\n\n    public ASTAnnotationParameter(AnnotationParameter annotationParameter) {\n        super(annotationParameter);\n    }\n\n    @Override\n    public Object jjtAccept(ApexParserVisitor visitor, Object data) {\n        return visitor.visit(this, data);\n    }\n\n    @Override\n    public String getImage() {\n        if (node.getValue() != null) {\n            return node.getValueAsString();\n        }\n        return null;\n    }\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n"}, {"type": "Extract And Move Method", "description": "Extract And Move Method\tpackage getComment(commentOwner JavadocCommentOwner) : FormalComment extracted from public getJavadocComment() : FormalComment in class net.sourceforge.pmd.lang.java.ast.JavadocCommentOwner & moved to class net.sourceforge.pmd.lang.java.ast.CommentAssignmentPass", "diffLocations": [{"filePath": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/JavadocCommentOwner.java", "startLine": 14, "endLine": 20, "startColumn": 0, "endColumn": 0}, {"filePath": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/JavadocCommentOwner.java", "startLine": 14, "endLine": 20, "startColumn": 0, "endColumn": 0}, {"filePath": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/JavadocCommentOwner.java", "startLine": 26, "endLine": 28, "startColumn": 0, "endColumn": 0}], "sourceCodeBeforeRefactoring": "/**\n     * Returns the javadoc comment that applies to this declaration. If\n     * there is none, returns null.\n     */\n    default @Nullable FormalComment getJavadocComment() {\n        return getUserMap().get(CommentAssignmentPass.FORMAL_COMMENT_KEY);\n    }", "filePathBefore": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/JavadocCommentOwner.java", "isPureRefactoring": true, "commitId": "97c08a37ab6e5f0dc0bc2c38d865207b69b7eb2d", "packageNameBefore": "net.sourceforge.pmd.lang.java.ast", "classNameBefore": "net.sourceforge.pmd.lang.java.ast.JavadocCommentOwner", "methodNameBefore": "net.sourceforge.pmd.lang.java.ast.JavadocCommentOwner#getJavadocComment", "classSignatureBefore": "public interface JavadocCommentOwner extends JavaNode ", "methodNameBeforeSet": ["net.sourceforge.pmd.lang.java.ast.JavadocCommentOwner#getJavadocComment"], "classNameBeforeSet": ["net.sourceforge.pmd.lang.java.ast.JavadocCommentOwner"], "classSignatureBeforeSet": ["public interface JavadocCommentOwner extends JavaNode "], "purityCheckResultList": [{"isPure": true, "purityComment": "Changes are within the Extract Method refactoring mechanics", "description": "All the mappings are matched! - all mapped", "mappingState": 1}], "sourceCodeBeforeForWhole": "/*\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.lang.java.ast;\n\nimport org.checkerframework.checker.nullness.qual.Nullable;\n\n/**\n * A node that may own a javadoc comment.\n */\npublic interface JavadocCommentOwner extends JavaNode {\n\n    /**\n     * Returns the javadoc comment that applies to this declaration. If\n     * there is none, returns null.\n     */\n    default @Nullable FormalComment getJavadocComment() {\n        return getUserMap().get(CommentAssignmentPass.FORMAL_COMMENT_KEY);\n    }\n\n}\n", "filePathAfter": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/JavadocCommentOwner.java", "sourceCodeAfterForWhole": "/*\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.lang.java.ast;\n\nimport org.checkerframework.checker.nullness.qual.Nullable;\n\n/**\n * A node that may own a javadoc comment.\n */\npublic interface JavadocCommentOwner extends JavaNode {\n\n    /**\n     * Returns the javadoc comment that applies to this declaration. If\n     * there is none, returns null.\n     */\n    default @Nullable FormalComment getJavadocComment() {\n        return CommentAssignmentPass.getComment(this);\n    }\n\n}\n", "diffSourceCodeSet": [""], "invokedMethodSet": [], "sourceCodeAfterRefactoring": "/**\n     * Returns the javadoc comment that applies to this declaration. If\n     * there is none, returns null.\n     */\n    default @Nullable FormalComment getJavadocComment() {\n        return CommentAssignmentPass.getComment(this);\n    }\n", "diffSourceCode": "    14:     /**\n    15:      * Returns the javadoc comment that applies to this declaration. If\n    16:      * there is none, returns null.\n    17:      */\n    18:     default @Nullable FormalComment getJavadocComment() {\n-   19:         return getUserMap().get(CommentAssignmentPass.FORMAL_COMMENT_KEY);\n+   19:         return CommentAssignmentPass.getComment(this);\n    20:     }\n", "uniqueId": "97c08a37ab6e5f0dc0bc2c38d865207b69b7eb2d_14_20_26_28_14_20", "moveFileExist": true, "testResult": true, "coverageInfo": {"INSTRUCTION": {"missed": 0, "covered": 6}, "LINE": {"missed": 0, "covered": 1}, "COMPLEXITY": {"missed": 0, "covered": 1}, "METHOD": {"missed": 0, "covered": 1}}, "compileResultBefore": true, "compileResultCurrent": true, "compileJDK": 11, "refactoringMinerResult": false, "compileAndTestResult": false, "refactoredCode": "To refactor the provided code, we will extract the logic for retrieving the Javadoc comment into a new static method in an existing utility class. This will improve modularity and readability. \n\n### Step 1: Identify the Target Class for Extraction\nGiven the project structure, a suitable class to hold utility methods is `AstImplUtil`, which is located at:\n```\npmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/AstImplUtil.java\n```\n\n### Step 2: Extract the Method\nWe will extract the logic from the `getJavadocComment` method and create a new static method in `AstImplUtil`.\n\n### Step 3: Refactor the Original Method\nWe will modify the `getJavadocComment` method in `JavadocCommentOwner` to call the new static method from `AstImplUtil`.\n\n### Refactored Code\n\nHere\u2019s how the refactored code will look:\n\n##########################\npmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/AstImplUtil.java\n##########################\n```java\npublic class AstImplUtil {\n    public static @Nullable FormalComment getJavadocCommentFromUserMap(UserMap userMap) {\n        return userMap.get(CommentAssignmentPass.FORMAL_COMMENT_KEY);\n    }\n}\n```\n##########################\npmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/JavadocCommentOwner.java\n##########################\n```java\n/**\n * A node that may own a javadoc comment.\n */\npublic interface JavadocCommentOwner extends JavaNode {\n\n    /**\n     * Returns the javadoc comment that applies to this declaration. If\n     * there is none, returns null.\n     */\n    default @Nullable FormalComment getJavadocComment() {\n        return AstImplUtil.getJavadocCommentFromUserMap(getUserMap());\n    }\n}\n```\n##########################\n\n### Summary of Changes\n1. **Extracted Method**: `getJavadocCommentFromUserMap` is a static method in `AstImplUtil` that takes a `UserMap` and retrieves the Javadoc comment.\n2. **Refactored Method**: The `getJavadocComment` method in `JavadocCommentOwner` now calls the static method from `AstImplUtil`, improving modularity and separation of concerns. \n\nThis refactoring enhances the maintainability and readability of the code by centralizing the logic for retrieving the Javadoc comment in a utility class.", "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to Refactor:\n/**\n     * Returns the javadoc comment that applies to this declaration. If\n     * there is none, returns null.\n     */\n    default @Nullable FormalComment getJavadocComment() {\n        return getUserMap().get(CommentAssignmentPass.FORMAL_COMMENT_KEY);\n    }\n\nClass content:\n/*\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.lang.java.ast;\n\nimport org.checkerframework.checker.nullness.qual.Nullable;\n\n/**\n * A node that may own a javadoc comment.\n */\npublic interface JavadocCommentOwner extends JavaNode {\n\n    /**\n     * Returns the javadoc comment that applies to this declaration. If\n     * there is none, returns null.\n     */\n    default @Nullable FormalComment getJavadocComment() {\n        return getUserMap().get(CommentAssignmentPass.FORMAL_COMMENT_KEY);\n    }\n\n}\n\nRefactoring Operation:\nExtract And Move Method\n\nProject Structure:\n['pmd-java/src/main/java/net/sourceforge/pmd/cpd/JavaLanguage.java', 'pmd-java/src/main/java/net/sourceforge/pmd/cpd/JavaTokenizer.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/JavaLanguageModule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTAdditiveExpression.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTAllocationExpression.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTAmbiguousName.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTAndExpression.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTAnnotation.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTAnnotationMemberList.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTAnnotationMethodDeclaration.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTAnnotationTypeBody.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTAnnotationTypeDeclaration.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTAnonymousClassDeclaration.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTAnyTypeDeclaration.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTArgumentList.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTArguments.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTArrayAccess.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTArrayAllocation.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTArrayDimExpr.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTArrayDimensions.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTArrayDimsAndInits.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTArrayInitializer.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTArrayType.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTArrayTypeDim.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTAssertStatement.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTAssignableExpr.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTAssignmentExpression.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTAssignmentOperator.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTBlock.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTBlockStatement.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTBodyDeclaration.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTBooleanLiteral.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTBreakStatement.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTCastExpression.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTCatchClause.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTCatchParameter.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTCharLiteral.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTClassLiteral.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTClassOrInterfaceBody.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTClassOrInterfaceBodyDeclaration.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTClassOrInterfaceDeclaration.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTClassOrInterfaceType.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTCompilationUnit.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTConditionalAndExpression.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTConditionalExpression.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTConditionalOrExpression.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTConstructorCall.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTConstructorDeclaration.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTContinueStatement.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTDefaultValue.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTDoStatement.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTEmptyDeclaration.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTEmptyStatement.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTEnumBody.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTEnumConstant.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTEnumDeclaration.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTEqualityExpression.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTExclusiveOrExpression.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTExplicitConstructorInvocation.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTExpression.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTExpressionStatement.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTExtendsList.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTFieldAccess.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTFieldDeclaration.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTFinallyClause.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTForInit.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTForStatement.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTForUpdate.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTForeachStatement.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTFormalParameter.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTFormalParameters.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTIfStatement.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTImplementsList.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTImportDeclaration.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTInclusiveOrExpression.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTInfixExpression.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTInitializer.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTInstanceOfExpression.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTIntersectionType.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTLabeledStatement.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTLambdaExpression.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTLambdaParameter.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTLambdaParameterList.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTList.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTLiteral.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTLocalClassStatement.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTLocalVariableDeclaration.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTLoopStatement.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTMemberSelector.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTMemberValue.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTMemberValueArrayInitializer.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTMemberValuePair.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTMethodCall.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTMethodDeclaration.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTMethodDeclarator.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTMethodOrConstructorDeclaration.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTMethodReference.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTModifierList.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTModuleDeclaration.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTModuleDirective.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTModuleName.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTMultiplicativeExpression.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTName.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTNameList.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTNullLiteral.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTNumericLiteral.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTPackageDeclaration.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTPattern.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTPatternExpression.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTPermitsList.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTPrimaryExpression.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTPrimaryPrefix.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTPrimarySuffix.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTPrimitiveType.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTRSIGNEDSHIFT.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTRUNSIGNEDSHIFT.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTReceiverParameter.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTRecordBody.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTRecordComponent.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTRecordComponentList.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTRecordConstructorDeclaration.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTRecordDeclaration.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTReferenceType.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTRelationalExpression.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTResource.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTResourceList.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTResources.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTResultType.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTReturnStatement.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTShiftExpression.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTStatement.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTStatementExpression.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTStatementExpressionList.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTStringLiteral.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTSuperExpression.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTSwitchArrowBranch.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTSwitchArrowRHS.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTSwitchBranch.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTSwitchExpression.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTSwitchFallthroughBranch.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTSwitchLabel.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTSwitchLike.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTSwitchStatement.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTSynchronizedStatement.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTThisExpression.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTThrowStatement.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTThrowsList.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTTopLevelDeclaration.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTTryStatement.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTType.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTTypeArgument.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTTypeArguments.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTTypeBody.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTTypeBound.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTTypeExpression.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTTypeParameter.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTTypeParameters.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTTypeTestPattern.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTUnaryExpression.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTUnaryExpressionNotPlusMinus.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTUnionType.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTVariableAccess.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTVariableDeclarator.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTVariableDeclaratorId.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTVariableInitializer.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTVoidType.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTWhileStatement.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTWildcardBounds.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTWildcardType.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTYieldStatement.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/AbstractAnyTypeDeclaration.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/AbstractInvocationExpr.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/AbstractJavaExpr.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/AbstractJavaNode.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/AbstractJavaTypeNode.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/AbstractLiteral.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/AbstractMethodOrConstructorDeclaration.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/AbstractStatement.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/AbstractTypeBodyDeclaration.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/AbstractTypedSymbolDeclarator.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/AccessNode.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/Annotatable.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/AssignmentOp.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/AstDisambiguationPass.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/AstImplUtil.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/BinaryOp.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/Comment.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/CommentAssignmentPass.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ConstantFolder.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/FinalizableNode.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/FormalComment.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/InternalApiBridge.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/InternalInterfaces.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/InvocationNode.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/JModifier.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/JavaNode.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/JavaParser.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/JavaParserVisitor.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/JavaParserVisitorAdapter.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/JavaTokenDocument.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/JavaVisitorBase.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/JavadocCommentOwner.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/JavadocElement.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/LazyTypeResolver.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/LeftRecursiveNode.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/MethodLikeNode.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/MultiLineComment.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/PolyResolution.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/QualifiableExpression.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/SingleLineComment.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/SymbolDeclaratorNode.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/TokenUtils.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/TypeNode.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/TypeParamOwnerNode.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/TypesFromAst.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/UnaryOp.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/internal/ImportWrapper.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/internal/LanguageLevelChecker.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/internal/PrettyPrintingUtil.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/internal/ReportingStrategy.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/package-info.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/internal/JavaAstProcessor.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/internal/JavaDesignerBindings.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/internal/JavaLanguageHandler.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/internal/JavaProcessingStage.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/javadoc/JavadocTag.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/metrics/AbstractJavaClassMetric.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/metrics/AbstractJavaMetric.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/metrics/AbstractJavaOperationMetric.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/metrics/api/JavaClassMetric.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/metrics/api/JavaClassMetricKey.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/metrics/api/JavaOperationMetric.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/metrics/api/JavaOperationMetricKey.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/metrics/internal/AtfdMetric.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/metrics/internal/ClassFanOutMetric.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/metrics/internal/CycloMetric.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/metrics/internal/LocMetric.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/metrics/internal/NcssMetric.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/metrics/internal/NoamMetric.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/metrics/internal/NopaMetric.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/metrics/internal/NpathMetric.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/metrics/internal/TccMetric.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/metrics/internal/WmcMetric.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/metrics/internal/WocMetric.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/metrics/internal/visitors/AtfdBaseVisitor.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/metrics/internal/visitors/ClassFanOutVisitor.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/metrics/internal/visitors/CycloVisitor.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/metrics/internal/visitors/NcssVisitor.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/metrics/internal/visitors/NpathBaseVisitor.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/metrics/internal/visitors/TccAttributeAccessCollector.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/multifile/signature/JavaFieldSigMask.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/multifile/signature/JavaFieldSignature.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/multifile/signature/JavaOperationSigMask.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/multifile/signature/JavaOperationSignature.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/multifile/signature/JavaSigMask.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/multifile/signature/JavaSignature.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/AbstractIgnoredAnnotationRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/AbstractInefficientZeroCheck.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/AbstractJUnitRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/AbstractJavaMetricsRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/AbstractJavaRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/AbstractJavaRulechainRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/AbstractLombokAwareRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/AbstractPoorMethodCall.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/JavaRuleViolation.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/bestpractices/AbstractClassWithoutAbstractMethodRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/bestpractices/AbstractPositionLiteralsFirstInComparisons.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/bestpractices/AbstractSunSecureRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/bestpractices/AccessorClassGenerationRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/bestpractices/AccessorMethodGenerationRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/bestpractices/ArrayIsStoredDirectlyRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/bestpractices/AvoidReassigningCatchVariablesRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/bestpractices/AvoidReassigningLoopVariablesRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/bestpractices/AvoidReassigningParametersRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/bestpractices/AvoidUsingHardCodedIPRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/bestpractices/CheckResultSetRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/bestpractices/ForLoopCanBeForeachRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/bestpractices/GuardLogStatementRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/bestpractices/JUnitAssertionsShouldIncludeMessageRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/bestpractices/JUnitTestsShouldIncludeAssertRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/bestpractices/JUnitUseExpectedRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/bestpractices/LiteralsFirstInComparisonsRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/bestpractices/LooseCouplingRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/bestpractices/MethodReturnsInternalArrayRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/bestpractices/MissingOverrideRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/bestpractices/PositionLiteralsFirstInCaseInsensitiveComparisonsRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/bestpractices/PositionLiteralsFirstInComparisonsRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/bestpractices/PreserveStackTraceRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/bestpractices/UnusedAssignmentRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/bestpractices/UnusedFormalParameterRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/bestpractices/UnusedImportsRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/bestpractices/UnusedLocalVariableRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/bestpractices/UnusedPrivateFieldRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/bestpractices/UnusedPrivateMethodRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/bestpractices/UseCollectionIsEmptyRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/codestyle/AbstractNamingConventionRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/codestyle/AtLeastOneConstructorRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/codestyle/AvoidDollarSignsRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/codestyle/ClassNamingConventionsRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/codestyle/CommentDefaultAccessModifierRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/codestyle/ConfusingTernaryRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/codestyle/DontImportJavaLangRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/codestyle/DuplicateImportsRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/codestyle/FieldDeclarationsShouldBeAtStartOfClassRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/codestyle/FieldNamingConventionsRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/codestyle/FormalParameterNamingConventionsRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/codestyle/IdenticalCatchBranchesRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/codestyle/LinguisticNamingRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/codestyle/LocalVariableCouldBeFinalRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/codestyle/LocalVariableNamingConventionsRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/codestyle/MethodArgumentCouldBeFinalRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/codestyle/MethodNamingConventionsRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/codestyle/OnlyOneReturnRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/codestyle/PrematureDeclarationRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/codestyle/UnnecessaryAnnotationValueElementRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/codestyle/UnnecessaryCastRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/codestyle/UnnecessaryConstructorRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/codestyle/UnnecessaryFullyQualifiedNameRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/codestyle/UnnecessaryLocalBeforeReturnRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/codestyle/UnnecessaryModifierRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/codestyle/UnnecessaryReturnRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/design/AvoidDeeplyNestedIfStmtsRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/design/AvoidThrowingNullPointerExceptionRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/design/CouplingBetweenObjectsRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/design/CyclomaticComplexityRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/design/DataClassRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/design/ExceptionAsFlowControlRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/design/ExcessiveClassLengthRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/design/ExcessiveImportsRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/design/ExcessiveMethodLengthRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/design/ExcessiveParameterListRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/design/ExcessivePublicCountRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/design/GodClassRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/design/ImmutableFieldRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/design/LawOfDemeterRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/design/LoosePackageCouplingRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/design/NPathComplexityRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/design/NcssCountRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/design/SignatureDeclareThrowsExceptionRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/design/SimplifyBooleanReturnsRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/design/SingularFieldRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/design/SwitchDensityRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/design/TooManyFieldsRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/design/UseUtilityClassRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/design/UselessOverridingMethodRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/documentation/CommentContentRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/documentation/CommentRequiredRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/documentation/CommentSizeRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/errorprone/AssignmentInOperandRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/errorprone/AssignmentToNonFinalStaticRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/errorprone/AvoidBranchingStatementAsLastInLoopRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/errorprone/AvoidCallingFinalizeRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/errorprone/AvoidCatchingThrowableRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/errorprone/AvoidDuplicateLiteralsRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/errorprone/AvoidFieldNameMatchingMethodNameRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/errorprone/AvoidFieldNameMatchingTypeNameRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/errorprone/AvoidMultipleUnaryOperatorsRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/errorprone/AvoidUsingOctalValuesRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/errorprone/BeanMembersShouldSerializeRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/errorprone/BrokenNullCheckRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/errorprone/CheckSkipResultRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/errorprone/CloneMethodMustImplementCloneableRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/errorprone/CloseResourceRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/errorprone/CompareObjectsWithEqualsRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/errorprone/ConstructorCallsOverridableMethodRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/errorprone/DontImportSunRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/errorprone/IdempotentOperationsRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/errorprone/ImportFromSamePackageRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/errorprone/InvalidLogMessageFormatRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/errorprone/JUnitSpellingRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/errorprone/JUnitStaticSuiteRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/errorprone/MethodWithSameNameAsEnclosingClassRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/errorprone/MoreThanOneLoggerRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/errorprone/NullAssignmentRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/errorprone/OverrideBothEqualsAndHashcodeRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/errorprone/ProperCloneImplementationRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/errorprone/SingleMethodSingletonRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/errorprone/SingletonClassReturningNewInstanceRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/errorprone/SuspiciousHashcodeMethodNameRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/errorprone/SuspiciousOctalEscapeRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/errorprone/TestClassWithoutTestCasesRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/errorprone/UnnecessaryCaseChangeRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/errorprone/UnnecessaryConversionTemporaryRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/errorprone/UselessOperationOnImmutableRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/internal/AbstractJavaCounterCheckRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/internal/AnnotationSuppressionUtil.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/internal/JavaRuleViolationFactory.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/multithreading/DoubleCheckedLockingRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/multithreading/NonThreadSafeSingletonRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/multithreading/UnsynchronizedStaticFormatterRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/package-info.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/performance/AbstractOptimizationRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/performance/AppendCharacterWithCharRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/performance/AvoidInstantiatingObjectsInLoopsRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/performance/BigIntegerInstantiationRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/performance/BooleanInstantiationRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/performance/ConsecutiveAppendsShouldReuseRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/performance/ConsecutiveLiteralAppendsRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/performance/InefficientEmptyStringCheckRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/performance/InefficientStringBufferingRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/performance/InsufficientStringBufferDeclarationRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/performance/RedundantFieldInitializerRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/performance/StringInstantiationRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/performance/StringToStringRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/performance/UnnecessaryWrapperObjectCreationRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/performance/UseIndexOfCharRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/performance/UseStringBufferForStringAppendsRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/performance/UseStringBufferLengthRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/performance/UselessStringValueOfRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/regex/RegexHelper.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/security/HardCodedCryptoKeyRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/security/InsecureCryptoIvRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/security/TypeResTestRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/xpath/internal/BaseJavaXPathFunction.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/xpath/internal/GetCommentOnFunction.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/xpath/internal/MetricFunction.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/xpath/internal/TypeIsFunction.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/BoundToNode.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/JAccessibleElementSymbol.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/JClassSymbol.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/JConstructorSymbol.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/JElementSymbol.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/JExecutableSymbol.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/JFieldSymbol.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/JFormalParamSymbol.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/JLocalVariableSymbol.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/JMethodSymbol.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/JTypeDeclSymbol.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/JTypeParameterOwnerSymbol.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/JTypeParameterSymbol.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/JVariableSymbol.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/SymbolResolver.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/SymbolVisitor.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/internal/FlexibleUnresolvedClassImpl.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/internal/ImplicitMemberSymbols.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/internal/SymbolEquality.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/internal/SymbolToStrings.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/internal/UnresolvedClassImpl.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/internal/UnresolvedClassStore.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/internal/asm/AsmStub.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/internal/asm/AsmSymbolResolver.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/internal/asm/ClassStub.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/internal/asm/ClassStubBuilder.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/internal/asm/ExecutableStub.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/internal/asm/FieldStub.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/internal/asm/GenericSigBase.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/internal/asm/LazyTypeSig.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/internal/asm/Loader.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/internal/asm/MemberStubBase.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/internal/asm/ParseLock.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/internal/asm/SigVisitor.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/internal/asm/SignatureParser.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/internal/asm/SignatureScanner.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/internal/asm/SoftClassReference.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/internal/asm/TParamStub.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/internal/asm/TypeParamsParser.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/internal/asm/TypeSigParser.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/internal/ast/AbstractAstBackedSymbol.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/internal/ast/AbstractAstExecSymbol.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/internal/ast/AbstractAstTParamOwner.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/internal/ast/AbstractAstVariableSym.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/internal/ast/AstClassSym.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/internal/ast/AstCtorSym.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/internal/ast/AstFieldSym.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/internal/ast/AstFormalParamSym.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/internal/ast/AstLocalVarSym.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/internal/ast/AstMethodSym.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/internal/ast/AstSymFactory.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/internal/ast/AstSymbolMakerVisitor.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/internal/ast/AstTypeParamSym.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/internal/ast/MapSymResolver.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/internal/ast/SymbolResolutionPass.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/package-info.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/table/JSymbolTable.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/table/ScopeInfo.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/table/coreimpl/CachingShadowChainNode.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/table/coreimpl/CoreResolvers.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/table/coreimpl/MostlySingularMultimap.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/table/coreimpl/NameResolver.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/table/coreimpl/ShadowChain.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/table/coreimpl/ShadowChainBuilder.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/table/coreimpl/ShadowChainIterator.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/table/coreimpl/ShadowChainIteratorImpl.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/table/coreimpl/ShadowChainNode.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/table/coreimpl/ShadowChainNodeBase.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/table/coreimpl/ShadowChainRoot.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/table/internal/JavaResolvers.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/table/internal/ReferenceCtx.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/table/internal/ScopeInfo.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/table/internal/SemanticChecksLogger.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/table/internal/SuperTypesEnumerator.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/table/internal/SymTableFactory.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/table/internal/SymbolChainBuilder.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/table/internal/SymbolTableImpl.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/table/internal/SymbolTableResolver.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symboltable/AbstractJavaScope.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symboltable/ClassNameDeclaration.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symboltable/ClassScope.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symboltable/DeclarationFinderFunction.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symboltable/JavaNameOccurrence.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symboltable/LocalScope.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symboltable/MethodNameDeclaration.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symboltable/MethodScope.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symboltable/NameFinder.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symboltable/OccurrenceFinder.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symboltable/ScopeAndDeclarationFinder.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symboltable/Search.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symboltable/SimpleTypedNameDeclaration.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symboltable/SourceFileScope.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symboltable/SymbolFacade.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symboltable/TypeSet.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symboltable/TypedNameDeclaration.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symboltable/VariableNameDeclaration.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symboltable/package-info.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/typeresolution/ClassTypeResolver.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/typeresolution/PMDASMClassLoader.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/typeresolution/internal/NullableClassLoader.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/typeresolution/visitors/PMDASMVisitor.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/ArrayMethodSigImpl.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/ArraySymbolImpl.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/BasePrimitiveSymbol.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/BoxedPrimitive.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/CaptureMatcher.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/ClassMethodSigImpl.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/ClassTypeImpl.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/ErasedClassType.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/FakeIntersectionSymbol.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/JArrayType.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/JClassType.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/JIntersectionType.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/JMethodSig.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/JPrimitiveType.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/JTypeMirror.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/JTypeVar.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/JTypeVisitable.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/JTypeVisitor.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/JVariableSig.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/JWildcardType.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/LexicalScope.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/Lub.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/MapFunction.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/OverloadSelectionResult.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/SentinelType.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/SubstVar.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/Substitution.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/TypeConversion.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/TypeOps.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/TypePrettyPrint.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/TypeSystem.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/TypeTestUtil.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/TypeVarImpl.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/TypesFromReflection.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/UnresolvedMethodSig.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/WildcardTypeImpl.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/internal/InternalMethodTypeItf.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/internal/infer/ExprCheckHelper.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/internal/infer/ExprMirror.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/internal/infer/ExprOps.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/internal/infer/Graph.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/internal/infer/IncorporationAction.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/internal/infer/Infer.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/internal/infer/InferenceContext.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/internal/infer/InferenceVar.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/internal/infer/InferenceVarSym.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/internal/infer/MethodCallSite.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/internal/infer/MethodResolutionPhase.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/internal/infer/OverloadSet.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/internal/infer/PhaseOverloadSet.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/internal/infer/PolySite.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/internal/infer/ReductionStep.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/internal/infer/ResolutionFailedException.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/internal/infer/ResolutionFailure.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/internal/infer/TypeInferenceLogger.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/internal/infer/VarWalkStrategy.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/internal/infer/ast/BaseExprMirror.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/internal/infer/ast/BaseInvocMirror.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/internal/infer/ast/BasePolyMirror.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/internal/infer/ast/ConditionalMirrorImpl.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/internal/infer/ast/CtorInvocMirror.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/internal/infer/ast/JavaExprMirrors.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/internal/infer/ast/LambdaMirrorImpl.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/internal/infer/ast/MethodInvocMirror.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/internal/infer/ast/MethodRefMirrorImpl.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/internal/infer/ast/StandaloneExprMirror.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/internal/infer/ast/SwitchMirror.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/package-info.java']\n\nFile Path Before Refactoring:\npmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/JavadocCommentOwner.java\n\nInstructions:\n1. Analyze the provided code, class content, and project structure, apply relevant refactoring operation to the code to be refactored, and you need move the extracted method to another existing java file, output the target file path, extracted method code, refactored method code after refactoring.\nThe extracted method code should be the public static method.\nThe refactored method code should use the moved class to call the extracted method.\nThe target file path should be the path of the existing class where the method is moved to.\n\n2. If refactoring is performed, output the refactored class code in the following format:\n##########################\ntarget_file_path\n##########################\nextracted_method_code\n##########################\nrefactored_method_code\n##########################\n\n\n\n\n\n"}, {"type": "Extract And Move Method", "description": "Extract And Move Method\tpublic reportToLogger(logger Logger) : SemanticErrorReporter extracted from public defaultLogger() : SemanticChecksLogger in class net.sourceforge.pmd.lang.java.internal.JavaAstProcessor & moved to class net.sourceforge.pmd.lang.ast.SemanticErrorReporter", "diffLocations": [{"filePath": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/internal/JavaAstProcessor.java", "startLine": 144, "endLine": 160, "startColumn": 0, "endColumn": 0}, {"filePath": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/internal/JavaAstProcessor.java", "startLine": 142, "endLine": 144, "startColumn": 0, "endColumn": 0}, {"filePath": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/internal/JavaAstProcessor.java", "startLine": 71, "endLine": 106, "startColumn": 0, "endColumn": 0}], "sourceCodeBeforeRefactoring": "public static SemanticChecksLogger defaultLogger() {\n        return new SemanticChecksLogger() {\n            private String locPrefix(JavaNode loc) {\n                return \"[\" + loc.getBeginLine() + \",\" + loc.getBeginColumn() + \"] \";\n            }\n\n            @Override\n            public void warning(JavaNode location, String message, Object... args) {\n                DEFAULT_LOG.fine(() -> locPrefix(location) + MessageFormat.format(message, args));\n            }\n\n            @Override\n            public void error(JavaNode location, String message, Object... args) {\n                DEFAULT_LOG.severe(() -> locPrefix(location) + MessageFormat.format(message, args));\n            }\n        };\n    }", "filePathBefore": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/internal/JavaAstProcessor.java", "isPureRefactoring": true, "commitId": "da03fafabb2146ca3b2cd3f61484754490dfc9fb", "packageNameBefore": "net.sourceforge.pmd.lang.java.internal", "classNameBefore": "net.sourceforge.pmd.lang.java.internal.JavaAstProcessor", "methodNameBefore": "net.sourceforge.pmd.lang.java.internal.JavaAstProcessor#defaultLogger", "classSignatureBefore": "public final class JavaAstProcessor ", "methodNameBeforeSet": ["net.sourceforge.pmd.lang.java.internal.JavaAstProcessor#defaultLogger"], "classNameBeforeSet": ["net.sourceforge.pmd.lang.java.internal.JavaAstProcessor"], "classSignatureBeforeSet": ["public final class JavaAstProcessor "], "purityCheckResultList": [{"isPure": true, "purityComment": "Changes are within the Extract Method refactoring mechanics\nTolerable changes in the body\n", "description": "All replacements have been justified - all mapped", "mappingState": 1}], "sourceCodeBeforeForWhole": "/*\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.lang.java.internal;\n\nimport java.text.MessageFormat;\nimport java.util.IdentityHashMap;\nimport java.util.Map;\nimport java.util.function.Supplier;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\nimport net.sourceforge.pmd.benchmark.TimeTracker;\nimport net.sourceforge.pmd.benchmark.TimedOperation;\nimport net.sourceforge.pmd.benchmark.TimedOperationCategory;\nimport net.sourceforge.pmd.lang.LanguageVersion;\nimport net.sourceforge.pmd.lang.ast.NodeStream;\nimport net.sourceforge.pmd.lang.java.ast.ASTCompilationUnit;\nimport net.sourceforge.pmd.lang.java.ast.InternalApiBridge;\nimport net.sourceforge.pmd.lang.java.ast.JavaNode;\nimport net.sourceforge.pmd.lang.java.symbols.JClassSymbol;\nimport net.sourceforge.pmd.lang.java.symbols.JTypeDeclSymbol;\nimport net.sourceforge.pmd.lang.java.symbols.SymbolResolver;\nimport net.sourceforge.pmd.lang.java.symbols.internal.UnresolvedClassStore;\nimport net.sourceforge.pmd.lang.java.symbols.internal.ast.SymbolResolutionPass;\nimport net.sourceforge.pmd.lang.java.symbols.table.internal.ReferenceCtx;\nimport net.sourceforge.pmd.lang.java.symbols.table.internal.SemanticChecksLogger;\nimport net.sourceforge.pmd.lang.java.symbols.table.internal.SymbolTableResolver;\nimport net.sourceforge.pmd.lang.java.types.TypeSystem;\nimport net.sourceforge.pmd.lang.java.types.internal.infer.TypeInferenceLogger;\nimport net.sourceforge.pmd.lang.java.types.internal.infer.TypeInferenceLogger.SimpleLogger;\nimport net.sourceforge.pmd.lang.java.types.internal.infer.TypeInferenceLogger.VerboseLogger;\n\n/**\n * Processes the output of the parser before rules get access to the AST.\n * This performs all semantic analyses in layered passes.\n *\n * <p>This is the root context object for file-specific context. Instances\n * do not need to be thread-safe. Global information about eg the classpath\n * is held in a {@link TypeSystem} instance.\n */\npublic final class JavaAstProcessor {\n\n    private static final Logger DEFAULT_LOG = Logger.getLogger(JavaAstProcessor.class.getName());\n\n    private static final Map<ClassLoader, TypeSystem> TYPE_SYSTEMS = new IdentityHashMap<>();\n    private static final Level INFERENCE_LOG_LEVEL;\n\n\n    static {\n        Level level;\n        try {\n            level = Level.parse(System.getenv(\"PMD_DEBUG_LEVEL\"));\n        } catch (IllegalArgumentException | NullPointerException ignored) {\n            level = Level.OFF;\n        }\n        INFERENCE_LOG_LEVEL = level;\n    }\n\n\n    private final TypeInferenceLogger typeInferenceLogger;\n    private final SemanticChecksLogger logger;\n    private final LanguageVersion languageVersion;\n    private final TypeSystem typeSystem;\n\n    private SymbolResolver symResolver;\n\n    private final UnresolvedClassStore unresolvedTypes;\n\n\n    private JavaAstProcessor(TypeSystem typeSystem,\n                             SymbolResolver symResolver,\n                             SemanticChecksLogger logger,\n                             TypeInferenceLogger typeInfLogger,\n                             LanguageVersion languageVersion) {\n\n        this.symResolver = symResolver;\n        this.logger = logger;\n        this.typeInferenceLogger = typeInfLogger;\n        this.languageVersion = languageVersion;\n\n        this.typeSystem = typeSystem;\n        unresolvedTypes = new UnresolvedClassStore(typeSystem);\n    }\n\n    static TypeInferenceLogger defaultTypeInfLogger() {\n        if (INFERENCE_LOG_LEVEL == Level.FINEST) {\n            return new VerboseLogger(System.err);\n        } else if (INFERENCE_LOG_LEVEL == Level.FINE) {\n            return new SimpleLogger(System.err);\n        } else {\n            return TypeInferenceLogger.noop();\n        }\n    }\n\n    public JClassSymbol makeUnresolvedReference(String canonicalName, int typeArity) {\n        return unresolvedTypes.makeUnresolvedReference(canonicalName, typeArity);\n    }\n\n    public JClassSymbol makeUnresolvedReference(JTypeDeclSymbol outer, String simpleName, int typeArity) {\n        if (outer instanceof JClassSymbol) {\n            return unresolvedTypes.makeUnresolvedReference((JClassSymbol) outer, simpleName, typeArity);\n        }\n        return makeUnresolvedReference(\"error.\" + simpleName, typeArity);\n    }\n\n    public SymbolResolver getSymResolver() {\n        return symResolver;\n    }\n\n    public SemanticChecksLogger getLogger() {\n        return logger;\n    }\n\n    public LanguageVersion getLanguageVersion() {\n        return languageVersion;\n    }\n\n    public int getJdkVersion() {\n        return ((JavaLanguageHandler) languageVersion.getLanguageVersionHandler()).getJdkVersion();\n    }\n\n    /**\n     * Performs semantic analysis on the given source file.\n     */\n    public void process(ASTCompilationUnit acu) {\n\n        SymbolResolver knownSyms = bench(\"Symbol resolution\", () -> SymbolResolutionPass.traverse(this, acu));\n\n        // Now symbols are on the relevant nodes\n        this.symResolver = SymbolResolver.layer(knownSyms, this.symResolver);\n\n        InternalApiBridge.initTypeResolver(acu, this, typeInferenceLogger);\n\n        bench(\"2. Symbol table resolution\", () -> SymbolTableResolver.traverse(this, acu));\n        bench(\"3. AST disambiguation\", () -> InternalApiBridge.disambigWithCtx(NodeStream.of(acu), ReferenceCtx.root(this, acu)));\n    }\n\n    public TypeSystem getTypeSystem() {\n        return typeSystem;\n    }\n\n    public static SemanticChecksLogger defaultLogger() {\n        return new SemanticChecksLogger() {\n            private String locPrefix(JavaNode loc) {\n                return \"[\" + loc.getBeginLine() + \",\" + loc.getBeginColumn() + \"] \";\n            }\n\n            @Override\n            public void warning(JavaNode location, String message, Object... args) {\n                DEFAULT_LOG.fine(() -> locPrefix(location) + MessageFormat.format(message, args));\n            }\n\n            @Override\n            public void error(JavaNode location, String message, Object... args) {\n                DEFAULT_LOG.severe(() -> locPrefix(location) + MessageFormat.format(message, args));\n            }\n        };\n    }\n\n    public static JavaAstProcessor create(SymbolResolver symResolver,\n                                          TypeSystem typeSystem,\n                                          LanguageVersion languageVersion,\n                                          SemanticChecksLogger logger) {\n\n        return new JavaAstProcessor(\n            typeSystem,\n            symResolver,\n            logger,\n            defaultTypeInfLogger(),\n            languageVersion\n        );\n    }\n\n    public static JavaAstProcessor create(ClassLoader classLoader,\n                                          LanguageVersion languageVersion,\n                                          SemanticChecksLogger logger,\n                                          TypeInferenceLogger typeInfLogger) {\n\n        TypeSystem typeSystem = TYPE_SYSTEMS.computeIfAbsent(classLoader, TypeSystem::new);\n        return new JavaAstProcessor(\n            typeSystem,\n            typeSystem.bootstrapResolver(),\n            logger,\n            typeInfLogger,\n            languageVersion\n        );\n    }\n\n    public static JavaAstProcessor create(TypeSystem typeSystem,\n                                          LanguageVersion languageVersion,\n                                          SemanticChecksLogger semanticLogger,\n                                          TypeInferenceLogger typeInfLogger) {\n        return new JavaAstProcessor(\n            typeSystem,\n            typeSystem.bootstrapResolver(),\n            semanticLogger,\n            typeInfLogger,\n            languageVersion\n        );\n    }\n\n    public static void bench(String label, Runnable runnable) {\n        try (TimedOperation to = TimeTracker.startOperation(TimedOperationCategory.LANGUAGE_SPECIFIC_PROCESSING, label)) {\n            runnable.run();\n        }\n    }\n\n    public static <T> T bench(String label, Supplier<T> runnable) {\n        try (TimedOperation to = TimeTracker.startOperation(TimedOperationCategory.LANGUAGE_SPECIFIC_PROCESSING, label)) {\n            return runnable.get();\n        }\n    }\n}\n", "filePathAfter": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/internal/JavaAstProcessor.java", "sourceCodeAfterForWhole": "/*\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.lang.java.internal;\n\nimport java.util.IdentityHashMap;\nimport java.util.Map;\nimport java.util.function.Supplier;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\nimport net.sourceforge.pmd.benchmark.TimeTracker;\nimport net.sourceforge.pmd.benchmark.TimedOperation;\nimport net.sourceforge.pmd.benchmark.TimedOperationCategory;\nimport net.sourceforge.pmd.lang.LanguageVersion;\nimport net.sourceforge.pmd.lang.ast.NodeStream;\nimport net.sourceforge.pmd.lang.ast.SemanticErrorReporter;\nimport net.sourceforge.pmd.lang.java.ast.ASTCompilationUnit;\nimport net.sourceforge.pmd.lang.java.ast.InternalApiBridge;\nimport net.sourceforge.pmd.lang.java.symbols.JClassSymbol;\nimport net.sourceforge.pmd.lang.java.symbols.JTypeDeclSymbol;\nimport net.sourceforge.pmd.lang.java.symbols.SymbolResolver;\nimport net.sourceforge.pmd.lang.java.symbols.internal.UnresolvedClassStore;\nimport net.sourceforge.pmd.lang.java.symbols.internal.ast.SymbolResolutionPass;\nimport net.sourceforge.pmd.lang.java.symbols.table.internal.ReferenceCtx;\nimport net.sourceforge.pmd.lang.java.symbols.table.internal.SymbolTableResolver;\nimport net.sourceforge.pmd.lang.java.types.TypeSystem;\nimport net.sourceforge.pmd.lang.java.types.internal.infer.TypeInferenceLogger;\nimport net.sourceforge.pmd.lang.java.types.internal.infer.TypeInferenceLogger.SimpleLogger;\nimport net.sourceforge.pmd.lang.java.types.internal.infer.TypeInferenceLogger.VerboseLogger;\n\n/**\n * Processes the output of the parser before rules get access to the AST.\n * This performs all semantic analyses in layered passes.\n *\n * <p>This is the root context object for file-specific context. Instances\n * do not need to be thread-safe. Global information about eg the classpath\n * is held in a {@link TypeSystem} instance.\n */\npublic final class JavaAstProcessor {\n\n    private static final Logger DEFAULT_LOG = Logger.getLogger(JavaAstProcessor.class.getName());\n\n    private static final Map<ClassLoader, TypeSystem> TYPE_SYSTEMS = new IdentityHashMap<>();\n    private static final Level INFERENCE_LOG_LEVEL;\n\n\n    static {\n        Level level;\n        try {\n            level = Level.parse(System.getenv(\"PMD_DEBUG_LEVEL\"));\n        } catch (IllegalArgumentException | NullPointerException ignored) {\n            level = Level.OFF;\n        }\n        INFERENCE_LOG_LEVEL = level;\n    }\n\n\n    private final TypeInferenceLogger typeInferenceLogger;\n    private final SemanticErrorReporter logger;\n    private final LanguageVersion languageVersion;\n    private final TypeSystem typeSystem;\n\n    private SymbolResolver symResolver;\n\n    private final UnresolvedClassStore unresolvedTypes;\n\n\n    private JavaAstProcessor(TypeSystem typeSystem,\n                             SymbolResolver symResolver,\n                             SemanticErrorReporter logger,\n                             TypeInferenceLogger typeInfLogger,\n                             LanguageVersion languageVersion) {\n\n        this.symResolver = symResolver;\n        this.logger = logger;\n        this.typeInferenceLogger = typeInfLogger;\n        this.languageVersion = languageVersion;\n\n        this.typeSystem = typeSystem;\n        unresolvedTypes = new UnresolvedClassStore(typeSystem);\n    }\n\n    static TypeInferenceLogger defaultTypeInfLogger() {\n        if (INFERENCE_LOG_LEVEL == Level.FINEST) {\n            return new VerboseLogger(System.err);\n        } else if (INFERENCE_LOG_LEVEL == Level.FINE) {\n            return new SimpleLogger(System.err);\n        } else {\n            return TypeInferenceLogger.noop();\n        }\n    }\n\n    public JClassSymbol makeUnresolvedReference(String canonicalName, int typeArity) {\n        return unresolvedTypes.makeUnresolvedReference(canonicalName, typeArity);\n    }\n\n    public JClassSymbol makeUnresolvedReference(JTypeDeclSymbol outer, String simpleName, int typeArity) {\n        if (outer instanceof JClassSymbol) {\n            return unresolvedTypes.makeUnresolvedReference((JClassSymbol) outer, simpleName, typeArity);\n        }\n        return makeUnresolvedReference(\"error.\" + simpleName, typeArity);\n    }\n\n    public SymbolResolver getSymResolver() {\n        return symResolver;\n    }\n\n    public SemanticErrorReporter getLogger() {\n        return logger;\n    }\n\n    public LanguageVersion getLanguageVersion() {\n        return languageVersion;\n    }\n\n    public int getJdkVersion() {\n        return ((JavaLanguageHandler) languageVersion.getLanguageVersionHandler()).getJdkVersion();\n    }\n\n    /**\n     * Performs semantic analysis on the given source file.\n     */\n    public void process(ASTCompilationUnit acu) {\n\n        SymbolResolver knownSyms = bench(\"Symbol resolution\", () -> SymbolResolutionPass.traverse(this, acu));\n\n        // Now symbols are on the relevant nodes\n        this.symResolver = SymbolResolver.layer(knownSyms, this.symResolver);\n\n        InternalApiBridge.initTypeResolver(acu, this, typeInferenceLogger);\n\n        bench(\"2. Symbol table resolution\", () -> SymbolTableResolver.traverse(this, acu));\n        bench(\"3. AST disambiguation\", () -> InternalApiBridge.disambigWithCtx(NodeStream.of(acu), ReferenceCtx.root(this, acu)));\n    }\n\n    public TypeSystem getTypeSystem() {\n        return typeSystem;\n    }\n\n    public static SemanticErrorReporter defaultLogger() {\n        return SemanticErrorReporter.reportToLogger(DEFAULT_LOG);\n    }\n\n    public static JavaAstProcessor create(SymbolResolver symResolver,\n                                          TypeSystem typeSystem,\n                                          LanguageVersion languageVersion,\n                                          SemanticErrorReporter logger) {\n\n        return new JavaAstProcessor(\n            typeSystem,\n            symResolver,\n            logger,\n            defaultTypeInfLogger(),\n            languageVersion\n        );\n    }\n\n    public static JavaAstProcessor create(ClassLoader classLoader,\n                                          LanguageVersion languageVersion,\n                                          SemanticErrorReporter logger,\n                                          TypeInferenceLogger typeInfLogger) {\n\n        TypeSystem typeSystem = TYPE_SYSTEMS.computeIfAbsent(classLoader, TypeSystem::new);\n        return new JavaAstProcessor(\n            typeSystem,\n            typeSystem.bootstrapResolver(),\n            logger,\n            typeInfLogger,\n            languageVersion\n        );\n    }\n\n    public static JavaAstProcessor create(TypeSystem typeSystem,\n                                          LanguageVersion languageVersion,\n                                          SemanticErrorReporter semanticLogger,\n                                          TypeInferenceLogger typeInfLogger) {\n        return new JavaAstProcessor(\n            typeSystem,\n            typeSystem.bootstrapResolver(),\n            semanticLogger,\n            typeInfLogger,\n            languageVersion\n        );\n    }\n\n    public static void bench(String label, Runnable runnable) {\n        try (TimedOperation to = TimeTracker.startOperation(TimedOperationCategory.LANGUAGE_SPECIFIC_PROCESSING, label)) {\n            runnable.run();\n        }\n    }\n\n    public static <T> T bench(String label, Supplier<T> runnable) {\n        try (TimedOperation to = TimeTracker.startOperation(TimedOperationCategory.LANGUAGE_SPECIFIC_PROCESSING, label)) {\n            return runnable.get();\n        }\n    }\n}\n", "diffSourceCodeSet": ["SymbolResolver symResolver,\n                             SemanticErrorReporter logger,\n                             TypeInferenceLogger typeInfLogger,\n                             LanguageVersion languageVersion) {\n\n        this.symResolver = symResolver;\n        this.logger = logger;\n        this.typeInferenceLogger = typeInfLogger;\n        this.languageVersion = languageVersion;\n\n        this.typeSystem = typeSystem;\n        unresolvedTypes = new UnresolvedClassStore(typeSystem);\n    }\n\n    static TypeInferenceLogger defaultTypeInfLogger() {\n        if (INFERENCE_LOG_LEVEL == Level.FINEST) {\n            return new VerboseLogger(System.err);\n        } else if (INFERENCE_LOG_LEVEL == Level.FINE) {\n            return new SimpleLogger(System.err);\n        } else {\n            return TypeInferenceLogger.noop();\n        }\n    }\n\n    public JClassSymbol makeUnresolvedReference(String canonicalName, int typeArity) {\n        return unresolvedTypes.makeUnresolvedReference(canonicalName, typeArity);\n    }\n\n    public JClassSymbol makeUnresolvedReference(JTypeDeclSymbol outer, String simpleName, int typeArity) {\n        if (outer instanceof JClassSymbol) {\n            return unresolvedTypes.makeUnresolvedReference((JClassSymbol) outer, simpleName, typeArity);\n        }\n        return makeUnresolvedReference(\"error.\" + simpleName, typeArity);\n    }\n\n    public SymbolResolver getSymResolver() {"], "invokedMethodSet": [], "sourceCodeAfterRefactoring": "public static SemanticErrorReporter defaultLogger() {\n        return SemanticErrorReporter.reportToLogger(DEFAULT_LOG);\n    }\nSymbolResolver symResolver,\n                             SemanticErrorReporter logger,\n                             TypeInferenceLogger typeInfLogger,\n                             LanguageVersion languageVersion) {\n\n        this.symResolver = symResolver;\n        this.logger = logger;\n        this.typeInferenceLogger = typeInfLogger;\n        this.languageVersion = languageVersion;\n\n        this.typeSystem = typeSystem;\n        unresolvedTypes = new UnresolvedClassStore(typeSystem);\n    }\n\n    static TypeInferenceLogger defaultTypeInfLogger() {\n        if (INFERENCE_LOG_LEVEL == Level.FINEST) {\n            return new VerboseLogger(System.err);\n        } else if (INFERENCE_LOG_LEVEL == Level.FINE) {\n            return new SimpleLogger(System.err);\n        } else {\n            return TypeInferenceLogger.noop();\n        }\n    }\n\n    public JClassSymbol makeUnresolvedReference(String canonicalName, int typeArity) {\n        return unresolvedTypes.makeUnresolvedReference(canonicalName, typeArity);\n    }\n\n    public JClassSymbol makeUnresolvedReference(JTypeDeclSymbol outer, String simpleName, int typeArity) {\n        if (outer instanceof JClassSymbol) {\n            return unresolvedTypes.makeUnresolvedReference((JClassSymbol) outer, simpleName, typeArity);\n        }\n        return makeUnresolvedReference(\"error.\" + simpleName, typeArity);\n    }\n\n    public SymbolResolver getSymResolver() {", "diffSourceCode": "-   71: \n-   72:     private JavaAstProcessor(TypeSystem typeSystem,\n-   73:                              SymbolResolver symResolver,\n-   74:                              SemanticChecksLogger logger,\n-   75:                              TypeInferenceLogger typeInfLogger,\n-   76:                              LanguageVersion languageVersion) {\n-   77: \n-   78:         this.symResolver = symResolver;\n-   79:         this.logger = logger;\n-   80:         this.typeInferenceLogger = typeInfLogger;\n-   81:         this.languageVersion = languageVersion;\n-   82: \n-   83:         this.typeSystem = typeSystem;\n-   84:         unresolvedTypes = new UnresolvedClassStore(typeSystem);\n-   85:     }\n-   86: \n-   87:     static TypeInferenceLogger defaultTypeInfLogger() {\n-   88:         if (INFERENCE_LOG_LEVEL == Level.FINEST) {\n-   89:             return new VerboseLogger(System.err);\n-   90:         } else if (INFERENCE_LOG_LEVEL == Level.FINE) {\n-   91:             return new SimpleLogger(System.err);\n-   92:         } else {\n-   93:             return TypeInferenceLogger.noop();\n-   94:         }\n-   95:     }\n-   96: \n-   97:     public JClassSymbol makeUnresolvedReference(String canonicalName, int typeArity) {\n-   98:         return unresolvedTypes.makeUnresolvedReference(canonicalName, typeArity);\n-   99:     }\n-  100: \n-  101:     public JClassSymbol makeUnresolvedReference(JTypeDeclSymbol outer, String simpleName, int typeArity) {\n-  102:         if (outer instanceof JClassSymbol) {\n-  103:             return unresolvedTypes.makeUnresolvedReference((JClassSymbol) outer, simpleName, typeArity);\n-  104:         }\n-  105:         return makeUnresolvedReference(\"error.\" + simpleName, typeArity);\n-  106:     }\n-  142:     }\n-  143: \n-  144:     public static SemanticChecksLogger defaultLogger() {\n-  145:         return new SemanticChecksLogger() {\n-  146:             private String locPrefix(JavaNode loc) {\n-  147:                 return \"[\" + loc.getBeginLine() + \",\" + loc.getBeginColumn() + \"] \";\n-  148:             }\n-  149: \n-  150:             @Override\n-  151:             public void warning(JavaNode location, String message, Object... args) {\n-  152:                 DEFAULT_LOG.fine(() -> locPrefix(location) + MessageFormat.format(message, args));\n-  153:             }\n-  154: \n-  155:             @Override\n-  156:             public void error(JavaNode location, String message, Object... args) {\n-  157:                 DEFAULT_LOG.severe(() -> locPrefix(location) + MessageFormat.format(message, args));\n-  158:             }\n-  159:         };\n-  160:     }\n+   71:                              SymbolResolver symResolver,\n+   72:                              SemanticErrorReporter logger,\n+   73:                              TypeInferenceLogger typeInfLogger,\n+   74:                              LanguageVersion languageVersion) {\n+   75: \n+   76:         this.symResolver = symResolver;\n+   77:         this.logger = logger;\n+   78:         this.typeInferenceLogger = typeInfLogger;\n+   79:         this.languageVersion = languageVersion;\n+   80: \n+   81:         this.typeSystem = typeSystem;\n+   82:         unresolvedTypes = new UnresolvedClassStore(typeSystem);\n+   83:     }\n+   84: \n+   85:     static TypeInferenceLogger defaultTypeInfLogger() {\n+   86:         if (INFERENCE_LOG_LEVEL == Level.FINEST) {\n+   87:             return new VerboseLogger(System.err);\n+   88:         } else if (INFERENCE_LOG_LEVEL == Level.FINE) {\n+   89:             return new SimpleLogger(System.err);\n+   90:         } else {\n+   91:             return TypeInferenceLogger.noop();\n+   92:         }\n+   93:     }\n+   94: \n+   95:     public JClassSymbol makeUnresolvedReference(String canonicalName, int typeArity) {\n+   96:         return unresolvedTypes.makeUnresolvedReference(canonicalName, typeArity);\n+   97:     }\n+   98: \n+   99:     public JClassSymbol makeUnresolvedReference(JTypeDeclSymbol outer, String simpleName, int typeArity) {\n+  100:         if (outer instanceof JClassSymbol) {\n+  101:             return unresolvedTypes.makeUnresolvedReference((JClassSymbol) outer, simpleName, typeArity);\n+  102:         }\n+  103:         return makeUnresolvedReference(\"error.\" + simpleName, typeArity);\n+  104:     }\n+  105: \n+  106:     public SymbolResolver getSymResolver() {\n+  142:     public static SemanticErrorReporter defaultLogger() {\n+  143:         return SemanticErrorReporter.reportToLogger(DEFAULT_LOG);\n+  144:     }\n+  145: \n+  146:     public static JavaAstProcessor create(SymbolResolver symResolver,\n+  147:                                           TypeSystem typeSystem,\n+  148:                                           LanguageVersion languageVersion,\n+  149:                                           SemanticErrorReporter logger) {\n+  150: \n+  151:         return new JavaAstProcessor(\n+  152:             typeSystem,\n+  153:             symResolver,\n+  154:             logger,\n+  155:             defaultTypeInfLogger(),\n+  156:             languageVersion\n+  157:         );\n+  158:     }\n+  159: \n+  160:     public static JavaAstProcessor create(ClassLoader classLoader,\n", "uniqueId": "da03fafabb2146ca3b2cd3f61484754490dfc9fb_144_160_71_106_142_144", "moveFileExist": true, "testResult": true, "coverageInfo": {"INSTRUCTION": {"missed": 0, "covered": 4}, "LINE": {"missed": 0, "covered": 1}, "COMPLEXITY": {"missed": 0, "covered": 1}, "METHOD": {"missed": 0, "covered": 1}}, "compileResultBefore": true, "compileResultCurrent": true, "compileJDK": 11, "refactoringMinerResult": true, "compileAndTestResult": false, "refactoredCode": "To refactor the provided code, we will extract the `defaultLogger` method from the `JavaAstProcessor` class and move it to the `SemanticChecksLogger` class, which is already defined in the project structure. This will improve modularity and maintainability by keeping the logging functionality encapsulated within the logger class.\n\n### Step 1: Analyze the Code\nThe `defaultLogger` method creates an instance of `SemanticChecksLogger` with overridden methods for logging warnings and errors. This functionality is closely related to the `SemanticChecksLogger` class, making it a suitable candidate for extraction.\n\n### Step 2: Extract and Move Method\nWe will move the `defaultLogger` method to the `SemanticChecksLogger` class. The method will be made static and will return a new instance of `SemanticChecksLogger`.\n\n### Step 3: Update the Refactored Method\nAfter moving the method, we will update the `JavaAstProcessor` class to call the new static method from `SemanticChecksLogger`.\n\n### Target File Path\nThe target file path for the extracted method will be:\n```\npmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/table/internal/SemanticChecksLogger.java\n```\n\n### Extracted Method Code\nHere is the extracted method code that will be moved to `SemanticChecksLogger`:\n```java\npublic static SemanticChecksLogger defaultLogger() {\n    return new SemanticChecksLogger() {\n        private String locPrefix(JavaNode loc) {\n            return \"[\" + loc.getBeginLine() + \",\" + loc.getBeginColumn() + \"] \";\n        }\n\n        @Override\n        public void warning(JavaNode location, String message, Object... args) {\n            Logger.getLogger(SemanticChecksLogger.class.getName()).fine(() -> locPrefix(location) + MessageFormat.format(message, args));\n        }\n\n        @Override\n        public void error(JavaNode location, String message, Object... args) {\n            Logger.getLogger(SemanticChecksLogger.class.getName()).severe(() -> locPrefix(location) + MessageFormat.format(message, args));\n        }\n    };\n}\n```\n\n### Refactored Method Code\nHere is the refactored method code in the `JavaAstProcessor` class:\n```java\npublic static SemanticChecksLogger defaultLogger() {\n    return SemanticChecksLogger.defaultLogger();\n}\n```\n\n### Final Output\nHere is the complete output in the specified format:\n\n##########################\npmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/table/internal/SemanticChecksLogger.java\n##########################\npublic static SemanticChecksLogger defaultLogger() {\n    return new SemanticChecksLogger() {\n        private String locPrefix(JavaNode loc) {\n            return \"[\" + loc.getBeginLine() + \",\" + loc.getBeginColumn() + \"] \";\n        }\n\n        @Override\n        public void warning(JavaNode location, String message, Object... args) {\n            Logger.getLogger(SemanticChecksLogger.class.getName()).fine(() -> locPrefix(location) + MessageFormat.format(message, args));\n        }\n\n        @Override\n        public void error(JavaNode location, String message, Object... args) {\n            Logger.getLogger(SemanticChecksLogger.class.getName()).severe(() -> locPrefix(location) + MessageFormat.format(message, args));\n        }\n    };\n}\n##########################\npublic static SemanticChecksLogger defaultLogger() {\n    return SemanticChecksLogger.defaultLogger();\n}\n##########################", "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to Refactor:\npublic static SemanticChecksLogger defaultLogger() {\n        return new SemanticChecksLogger() {\n            private String locPrefix(JavaNode loc) {\n                return \"[\" + loc.getBeginLine() + \",\" + loc.getBeginColumn() + \"] \";\n            }\n\n            @Override\n            public void warning(JavaNode location, String message, Object... args) {\n                DEFAULT_LOG.fine(() -> locPrefix(location) + MessageFormat.format(message, args));\n            }\n\n            @Override\n            public void error(JavaNode location, String message, Object... args) {\n                DEFAULT_LOG.severe(() -> locPrefix(location) + MessageFormat.format(message, args));\n            }\n        };\n    }\n\nClass content:\n/*\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.lang.java.internal;\n\nimport java.text.MessageFormat;\nimport java.util.IdentityHashMap;\nimport java.util.Map;\nimport java.util.function.Supplier;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\nimport net.sourceforge.pmd.benchmark.TimeTracker;\nimport net.sourceforge.pmd.benchmark.TimedOperation;\nimport net.sourceforge.pmd.benchmark.TimedOperationCategory;\nimport net.sourceforge.pmd.lang.LanguageVersion;\nimport net.sourceforge.pmd.lang.ast.NodeStream;\nimport net.sourceforge.pmd.lang.java.ast.ASTCompilationUnit;\nimport net.sourceforge.pmd.lang.java.ast.InternalApiBridge;\nimport net.sourceforge.pmd.lang.java.ast.JavaNode;\nimport net.sourceforge.pmd.lang.java.symbols.JClassSymbol;\nimport net.sourceforge.pmd.lang.java.symbols.JTypeDeclSymbol;\nimport net.sourceforge.pmd.lang.java.symbols.SymbolResolver;\nimport net.sourceforge.pmd.lang.java.symbols.internal.UnresolvedClassStore;\nimport net.sourceforge.pmd.lang.java.symbols.internal.ast.SymbolResolutionPass;\nimport net.sourceforge.pmd.lang.java.symbols.table.internal.ReferenceCtx;\nimport net.sourceforge.pmd.lang.java.symbols.table.internal.SemanticChecksLogger;\nimport net.sourceforge.pmd.lang.java.symbols.table.internal.SymbolTableResolver;\nimport net.sourceforge.pmd.lang.java.types.TypeSystem;\nimport net.sourceforge.pmd.lang.java.types.internal.infer.TypeInferenceLogger;\nimport net.sourceforge.pmd.lang.java.types.internal.infer.TypeInferenceLogger.SimpleLogger;\nimport net.sourceforge.pmd.lang.java.types.internal.infer.TypeInferenceLogger.VerboseLogger;\n\n/**\n * Processes the output of the parser before rules get access to the AST.\n * This performs all semantic analyses in layered passes.\n *\n * <p>This is the root context object for file-specific context. Instances\n * do not need to be thread-safe. Global information about eg the classpath\n * is held in a {@link TypeSystem} instance.\n */\npublic final class JavaAstProcessor {\n\n    private static final Logger DEFAULT_LOG = Logger.getLogger(JavaAstProcessor.class.getName());\n\n    private static final Map<ClassLoader, TypeSystem> TYPE_SYSTEMS = new IdentityHashMap<>();\n    private static final Level INFERENCE_LOG_LEVEL;\n\n\n    static {\n        Level level;\n        try {\n            level = Level.parse(System.getenv(\"PMD_DEBUG_LEVEL\"));\n        } catch (IllegalArgumentException | NullPointerException ignored) {\n            level = Level.OFF;\n        }\n        INFERENCE_LOG_LEVEL = level;\n    }\n\n\n    private final TypeInferenceLogger typeInferenceLogger;\n    private final SemanticChecksLogger logger;\n    private final LanguageVersion languageVersion;\n    private final TypeSystem typeSystem;\n\n    private SymbolResolver symResolver;\n\n    private final UnresolvedClassStore unresolvedTypes;\n\n\n    private JavaAstProcessor(TypeSystem typeSystem,\n                             SymbolResolver symResolver,\n                             SemanticChecksLogger logger,\n                             TypeInferenceLogger typeInfLogger,\n                             LanguageVersion languageVersion) {\n\n        this.symResolver = symResolver;\n        this.logger = logger;\n        this.typeInferenceLogger = typeInfLogger;\n        this.languageVersion = languageVersion;\n\n        this.typeSystem = typeSystem;\n        unresolvedTypes = new UnresolvedClassStore(typeSystem);\n    }\n\n    static TypeInferenceLogger defaultTypeInfLogger() {\n        if (INFERENCE_LOG_LEVEL == Level.FINEST) {\n            return new VerboseLogger(System.err);\n        } else if (INFERENCE_LOG_LEVEL == Level.FINE) {\n            return new SimpleLogger(System.err);\n        } else {\n            return TypeInferenceLogger.noop();\n        }\n    }\n\n    public JClassSymbol makeUnresolvedReference(String canonicalName, int typeArity) {\n        return unresolvedTypes.makeUnresolvedReference(canonicalName, typeArity);\n    }\n\n    public JClassSymbol makeUnresolvedReference(JTypeDeclSymbol outer, String simpleName, int typeArity) {\n        if (outer instanceof JClassSymbol) {\n            return unresolvedTypes.makeUnresolvedReference((JClassSymbol) outer, simpleName, typeArity);\n        }\n        return makeUnresolvedReference(\"error.\" + simpleName, typeArity);\n    }\n\n    public SymbolResolver getSymResolver() {\n        return symResolver;\n    }\n\n    public SemanticChecksLogger getLogger() {\n        return logger;\n    }\n\n    public LanguageVersion getLanguageVersion() {\n        return languageVersion;\n    }\n\n    public int getJdkVersion() {\n        return ((JavaLanguageHandler) languageVersion.getLanguageVersionHandler()).getJdkVersion();\n    }\n\n    /**\n     * Performs semantic analysis on the given source file.\n     */\n    public void process(ASTCompilationUnit acu) {\n\n        SymbolResolver knownSyms = bench(\"Symbol resolution\", () -> SymbolResolutionPass.traverse(this, acu));\n\n        // Now symbols are on the relevant nodes\n        this.symResolver = SymbolResolver.layer(knownSyms, this.symResolver);\n\n        InternalApiBridge.initTypeResolver(acu, this, typeInferenceLogger);\n\n        bench(\"2. Symbol table resolution\", () -> SymbolTableResolver.traverse(this, acu));\n        bench(\"3. AST disambiguation\", () -> InternalApiBridge.disambigWithCtx(NodeStream.of(acu), ReferenceCtx.root(this, acu)));\n    }\n\n    public TypeSystem getTypeSystem() {\n        return typeSystem;\n    }\n\n    public static SemanticChecksLogger defaultLogger() {\n        return new SemanticChecksLogger() {\n            private String locPrefix(JavaNode loc) {\n                return \"[\" + loc.getBeginLine() + \",\" + loc.getBeginColumn() + \"] \";\n            }\n\n            @Override\n            public void warning(JavaNode location, String message, Object... args) {\n                DEFAULT_LOG.fine(() -> locPrefix(location) + MessageFormat.format(message, args));\n            }\n\n            @Override\n            public void error(JavaNode location, String message, Object... args) {\n                DEFAULT_LOG.severe(() -> locPrefix(location) + MessageFormat.format(message, args));\n            }\n        };\n    }\n\n    public static JavaAstProcessor create(SymbolResolver symResolver,\n                                          TypeSystem typeSystem,\n                                          LanguageVersion languageVersion,\n                                          SemanticChecksLogger logger) {\n\n        return new JavaAstProcessor(\n            typeSystem,\n            symResolver,\n            logger,\n            defaultTypeInfLogger(),\n            languageVersion\n        );\n    }\n\n    public static JavaAstProcessor create(ClassLoader classLoader,\n                                          LanguageVersion languageVersion,\n                                          SemanticChecksLogger logger,\n                                          TypeInferenceLogger typeInfLogger) {\n\n        TypeSystem typeSystem = TYPE_SYSTEMS.computeIfAbsent(classLoader, TypeSystem::new);\n        return new JavaAstProcessor(\n            typeSystem,\n            typeSystem.bootstrapResolver(),\n            logger,\n            typeInfLogger,\n            languageVersion\n        );\n    }\n\n    public static JavaAstProcessor create(TypeSystem typeSystem,\n                                          LanguageVersion languageVersion,\n                                          SemanticChecksLogger semanticLogger,\n                                          TypeInferenceLogger typeInfLogger) {\n        return new JavaAstProcessor(\n            typeSystem,\n            typeSystem.bootstrapResolver(),\n            semanticLogger,\n            typeInfLogger,\n            languageVersion\n        );\n    }\n\n    public static void bench(String label, Runnable runnable) {\n        try (TimedOperation to = TimeTracker.startOperation(TimedOperationCategory.LANGUAGE_SPECIFIC_PROCESSING, label)) {\n            runnable.run();\n        }\n    }\n\n    public static <T> T bench(String label, Supplier<T> runnable) {\n        try (TimedOperation to = TimeTracker.startOperation(TimedOperationCategory.LANGUAGE_SPECIFIC_PROCESSING, label)) {\n            return runnable.get();\n        }\n    }\n}\n\nRefactoring Operation:\nExtract And Move Method\n\nProject Structure:\n['pmd-java/src/main/java/net/sourceforge/pmd/cpd/JavaLanguage.java', 'pmd-java/src/main/java/net/sourceforge/pmd/cpd/JavaTokenizer.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/JavaLanguageModule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTAdditiveExpression.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTAllocationExpression.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTAmbiguousName.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTAndExpression.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTAnnotation.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTAnnotationMemberList.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTAnnotationMethodDeclaration.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTAnnotationTypeBody.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTAnnotationTypeDeclaration.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTAnonymousClassDeclaration.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTAnyTypeDeclaration.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTArgumentList.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTArguments.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTArrayAccess.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTArrayAllocation.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTArrayDimExpr.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTArrayDimensions.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTArrayDimsAndInits.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTArrayInitializer.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTArrayType.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTArrayTypeDim.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTAssertStatement.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTAssignableExpr.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTAssignmentExpression.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTAssignmentOperator.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTBlock.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTBlockStatement.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTBodyDeclaration.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTBooleanLiteral.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTBreakStatement.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTCastExpression.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTCatchClause.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTCatchParameter.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTCharLiteral.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTClassLiteral.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTClassOrInterfaceBody.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTClassOrInterfaceBodyDeclaration.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTClassOrInterfaceDeclaration.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTClassOrInterfaceType.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTCompilationUnit.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTConditionalAndExpression.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTConditionalExpression.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTConditionalOrExpression.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTConstructorCall.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTConstructorDeclaration.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTContinueStatement.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTDefaultValue.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTDoStatement.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTEmptyDeclaration.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTEmptyStatement.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTEnumBody.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTEnumConstant.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTEnumDeclaration.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTEqualityExpression.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTExclusiveOrExpression.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTExplicitConstructorInvocation.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTExpression.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTExpressionStatement.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTExtendsList.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTFieldAccess.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTFieldDeclaration.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTFinallyClause.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTForInit.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTForStatement.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTForUpdate.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTForeachStatement.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTFormalParameter.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTFormalParameters.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTIfStatement.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTImplementsList.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTImportDeclaration.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTInclusiveOrExpression.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTInfixExpression.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTInitializer.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTInstanceOfExpression.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTIntersectionType.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTLabeledStatement.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTLambdaExpression.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTLambdaParameter.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTLambdaParameterList.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTList.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTLiteral.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTLocalClassStatement.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTLocalVariableDeclaration.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTLoopStatement.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTMemberSelector.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTMemberValue.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTMemberValueArrayInitializer.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTMemberValuePair.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTMethodCall.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTMethodDeclaration.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTMethodDeclarator.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTMethodOrConstructorDeclaration.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTMethodReference.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTModifierList.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTModuleDeclaration.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTModuleDirective.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTModuleName.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTMultiplicativeExpression.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTName.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTNameList.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTNullLiteral.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTNumericLiteral.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTPackageDeclaration.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTPattern.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTPatternExpression.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTPermitsList.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTPrimaryExpression.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTPrimaryPrefix.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTPrimarySuffix.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTPrimitiveType.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTRSIGNEDSHIFT.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTRUNSIGNEDSHIFT.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTReceiverParameter.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTRecordBody.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTRecordComponent.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTRecordComponentList.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTRecordConstructorDeclaration.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTRecordDeclaration.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTReferenceType.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTRelationalExpression.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTResource.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTResourceList.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTResources.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTResultType.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTReturnStatement.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTShiftExpression.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTStatement.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTStatementExpression.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTStatementExpressionList.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTStringLiteral.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTSuperExpression.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTSwitchArrowBranch.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTSwitchArrowRHS.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTSwitchBranch.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTSwitchExpression.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTSwitchFallthroughBranch.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTSwitchLabel.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTSwitchLike.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTSwitchStatement.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTSynchronizedStatement.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTThisExpression.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTThrowStatement.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTThrowsList.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTTopLevelDeclaration.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTTryStatement.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTType.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTTypeArgument.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTTypeArguments.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTTypeBody.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTTypeBound.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTTypeExpression.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTTypeParameter.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTTypeParameters.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTTypeTestPattern.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTUnaryExpression.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTUnaryExpressionNotPlusMinus.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTUnionType.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTVariableAccess.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTVariableDeclarator.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTVariableDeclaratorId.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTVariableInitializer.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTVoidType.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTWhileStatement.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTWildcardBounds.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTWildcardType.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTYieldStatement.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/AbstractAnyTypeDeclaration.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/AbstractInvocationExpr.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/AbstractJavaExpr.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/AbstractJavaNode.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/AbstractJavaTypeNode.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/AbstractLiteral.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/AbstractMethodOrConstructorDeclaration.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/AbstractStatement.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/AbstractTypeBodyDeclaration.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/AbstractTypedSymbolDeclarator.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/AccessNode.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/Annotatable.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/AssignmentOp.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/AstDisambiguationPass.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/AstImplUtil.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/BinaryOp.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/Comment.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/CommentUtil.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ConstantFolder.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/FinalizableNode.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/FormalComment.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/InternalApiBridge.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/InternalInterfaces.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/InvocationNode.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/JModifier.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/JavaNode.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/JavaParser.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/JavaParserVisitor.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/JavaParserVisitorAdapter.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/JavaTokenDocument.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/JavaVisitorBase.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/JavadocElement.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/LazyTypeResolver.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/LeftRecursiveNode.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/MethodLikeNode.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/MultiLineComment.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/PolyResolution.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/QualifiableExpression.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/SingleLineComment.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/SymbolDeclaratorNode.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/TokenUtils.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/TypeNode.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/TypeParamOwnerNode.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/TypesFromAst.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/UnaryOp.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/internal/ImportWrapper.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/internal/LanguageLevelChecker.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/internal/PrettyPrintingUtil.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/internal/ReportingStrategy.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/package-info.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/internal/JavaAstProcessor.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/internal/JavaDesignerBindings.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/internal/JavaLanguageHandler.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/internal/JavaProcessingStage.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/javadoc/JavadocTag.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/metrics/AbstractJavaClassMetric.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/metrics/AbstractJavaMetric.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/metrics/AbstractJavaOperationMetric.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/metrics/api/JavaClassMetric.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/metrics/api/JavaClassMetricKey.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/metrics/api/JavaOperationMetric.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/metrics/api/JavaOperationMetricKey.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/metrics/internal/AtfdMetric.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/metrics/internal/ClassFanOutMetric.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/metrics/internal/CycloMetric.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/metrics/internal/LocMetric.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/metrics/internal/NcssMetric.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/metrics/internal/NoamMetric.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/metrics/internal/NopaMetric.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/metrics/internal/NpathMetric.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/metrics/internal/TccMetric.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/metrics/internal/WmcMetric.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/metrics/internal/WocMetric.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/metrics/internal/visitors/AtfdBaseVisitor.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/metrics/internal/visitors/ClassFanOutVisitor.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/metrics/internal/visitors/CycloVisitor.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/metrics/internal/visitors/NcssVisitor.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/metrics/internal/visitors/NpathBaseVisitor.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/metrics/internal/visitors/TccAttributeAccessCollector.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/multifile/signature/JavaFieldSigMask.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/multifile/signature/JavaFieldSignature.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/multifile/signature/JavaOperationSigMask.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/multifile/signature/JavaOperationSignature.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/multifile/signature/JavaSigMask.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/multifile/signature/JavaSignature.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/AbstractIgnoredAnnotationRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/AbstractInefficientZeroCheck.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/AbstractJUnitRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/AbstractJavaMetricsRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/AbstractJavaRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/AbstractJavaRulechainRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/AbstractLombokAwareRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/AbstractPoorMethodCall.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/JavaRuleViolation.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/bestpractices/AbstractClassWithoutAbstractMethodRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/bestpractices/AbstractPositionLiteralsFirstInComparisons.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/bestpractices/AbstractSunSecureRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/bestpractices/AccessorClassGenerationRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/bestpractices/AccessorMethodGenerationRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/bestpractices/ArrayIsStoredDirectlyRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/bestpractices/AvoidReassigningCatchVariablesRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/bestpractices/AvoidReassigningLoopVariablesRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/bestpractices/AvoidReassigningParametersRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/bestpractices/AvoidUsingHardCodedIPRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/bestpractices/CheckResultSetRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/bestpractices/ForLoopCanBeForeachRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/bestpractices/GuardLogStatementRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/bestpractices/JUnitAssertionsShouldIncludeMessageRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/bestpractices/JUnitTestsShouldIncludeAssertRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/bestpractices/JUnitUseExpectedRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/bestpractices/LiteralsFirstInComparisonsRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/bestpractices/LooseCouplingRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/bestpractices/MethodReturnsInternalArrayRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/bestpractices/MissingOverrideRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/bestpractices/PositionLiteralsFirstInCaseInsensitiveComparisonsRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/bestpractices/PositionLiteralsFirstInComparisonsRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/bestpractices/PreserveStackTraceRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/bestpractices/UnusedAssignmentRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/bestpractices/UnusedFormalParameterRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/bestpractices/UnusedImportsRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/bestpractices/UnusedLocalVariableRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/bestpractices/UnusedPrivateFieldRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/bestpractices/UnusedPrivateMethodRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/bestpractices/UseCollectionIsEmptyRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/codestyle/AbstractNamingConventionRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/codestyle/AtLeastOneConstructorRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/codestyle/AvoidDollarSignsRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/codestyle/ClassNamingConventionsRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/codestyle/CommentDefaultAccessModifierRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/codestyle/ConfusingTernaryRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/codestyle/DontImportJavaLangRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/codestyle/DuplicateImportsRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/codestyle/FieldDeclarationsShouldBeAtStartOfClassRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/codestyle/FieldNamingConventionsRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/codestyle/FormalParameterNamingConventionsRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/codestyle/IdenticalCatchBranchesRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/codestyle/LinguisticNamingRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/codestyle/LocalVariableCouldBeFinalRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/codestyle/LocalVariableNamingConventionsRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/codestyle/MethodArgumentCouldBeFinalRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/codestyle/MethodNamingConventionsRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/codestyle/OnlyOneReturnRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/codestyle/PrematureDeclarationRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/codestyle/UnnecessaryAnnotationValueElementRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/codestyle/UnnecessaryCastRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/codestyle/UnnecessaryConstructorRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/codestyle/UnnecessaryFullyQualifiedNameRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/codestyle/UnnecessaryLocalBeforeReturnRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/codestyle/UnnecessaryModifierRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/codestyle/UnnecessaryReturnRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/design/AvoidDeeplyNestedIfStmtsRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/design/AvoidThrowingNullPointerExceptionRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/design/CouplingBetweenObjectsRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/design/CyclomaticComplexityRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/design/DataClassRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/design/ExceptionAsFlowControlRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/design/ExcessiveClassLengthRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/design/ExcessiveImportsRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/design/ExcessiveMethodLengthRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/design/ExcessiveParameterListRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/design/ExcessivePublicCountRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/design/GodClassRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/design/ImmutableFieldRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/design/LawOfDemeterRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/design/LoosePackageCouplingRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/design/NPathComplexityRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/design/NcssCountRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/design/SignatureDeclareThrowsExceptionRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/design/SimplifyBooleanReturnsRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/design/SingularFieldRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/design/SwitchDensityRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/design/TooManyFieldsRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/design/UseUtilityClassRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/design/UselessOverridingMethodRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/documentation/AbstractCommentRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/documentation/CommentContentRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/documentation/CommentRequiredRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/documentation/CommentSizeRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/errorprone/AssignmentInOperandRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/errorprone/AssignmentToNonFinalStaticRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/errorprone/AvoidBranchingStatementAsLastInLoopRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/errorprone/AvoidCallingFinalizeRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/errorprone/AvoidCatchingThrowableRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/errorprone/AvoidDuplicateLiteralsRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/errorprone/AvoidFieldNameMatchingMethodNameRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/errorprone/AvoidFieldNameMatchingTypeNameRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/errorprone/AvoidMultipleUnaryOperatorsRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/errorprone/AvoidUsingOctalValuesRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/errorprone/BeanMembersShouldSerializeRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/errorprone/BrokenNullCheckRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/errorprone/CheckSkipResultRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/errorprone/CloneMethodMustImplementCloneableRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/errorprone/CloseResourceRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/errorprone/CompareObjectsWithEqualsRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/errorprone/ConstructorCallsOverridableMethodRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/errorprone/DontImportSunRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/errorprone/IdempotentOperationsRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/errorprone/ImportFromSamePackageRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/errorprone/InvalidLogMessageFormatRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/errorprone/JUnitSpellingRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/errorprone/JUnitStaticSuiteRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/errorprone/MethodWithSameNameAsEnclosingClassRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/errorprone/MoreThanOneLoggerRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/errorprone/NullAssignmentRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/errorprone/OverrideBothEqualsAndHashcodeRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/errorprone/ProperCloneImplementationRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/errorprone/SingleMethodSingletonRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/errorprone/SingletonClassReturningNewInstanceRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/errorprone/SuspiciousHashcodeMethodNameRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/errorprone/SuspiciousOctalEscapeRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/errorprone/TestClassWithoutTestCasesRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/errorprone/UnnecessaryCaseChangeRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/errorprone/UnnecessaryConversionTemporaryRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/errorprone/UselessOperationOnImmutableRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/internal/AbstractJavaCounterCheckRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/internal/AnnotationSuppressionUtil.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/internal/JavaRuleViolationFactory.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/multithreading/DoubleCheckedLockingRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/multithreading/NonThreadSafeSingletonRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/multithreading/UnsynchronizedStaticFormatterRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/package-info.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/performance/AbstractOptimizationRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/performance/AppendCharacterWithCharRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/performance/AvoidInstantiatingObjectsInLoopsRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/performance/BigIntegerInstantiationRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/performance/BooleanInstantiationRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/performance/ConsecutiveAppendsShouldReuseRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/performance/ConsecutiveLiteralAppendsRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/performance/InefficientEmptyStringCheckRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/performance/InefficientStringBufferingRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/performance/InsufficientStringBufferDeclarationRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/performance/RedundantFieldInitializerRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/performance/StringInstantiationRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/performance/StringToStringRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/performance/UnnecessaryWrapperObjectCreationRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/performance/UseIndexOfCharRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/performance/UseStringBufferForStringAppendsRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/performance/UseStringBufferLengthRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/performance/UselessStringValueOfRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/regex/RegexHelper.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/security/HardCodedCryptoKeyRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/security/InsecureCryptoIvRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/security/TypeResTestRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/xpath/internal/BaseJavaXPathFunction.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/xpath/internal/GetCommentOnFunction.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/xpath/internal/MetricFunction.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/xpath/internal/TypeIsFunction.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/BoundToNode.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/JAccessibleElementSymbol.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/JClassSymbol.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/JConstructorSymbol.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/JElementSymbol.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/JExecutableSymbol.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/JFieldSymbol.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/JFormalParamSymbol.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/JLocalVariableSymbol.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/JMethodSymbol.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/JTypeDeclSymbol.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/JTypeParameterOwnerSymbol.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/JTypeParameterSymbol.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/JVariableSymbol.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/SymbolResolver.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/SymbolVisitor.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/internal/FlexibleUnresolvedClassImpl.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/internal/ImplicitMemberSymbols.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/internal/SymbolEquality.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/internal/SymbolToStrings.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/internal/UnresolvedClassImpl.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/internal/UnresolvedClassStore.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/internal/asm/AsmStub.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/internal/asm/AsmSymbolResolver.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/internal/asm/ClassStub.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/internal/asm/ClassStubBuilder.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/internal/asm/ExecutableStub.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/internal/asm/FieldStub.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/internal/asm/GenericSigBase.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/internal/asm/LazyTypeSig.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/internal/asm/Loader.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/internal/asm/MemberStubBase.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/internal/asm/ParseLock.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/internal/asm/SigVisitor.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/internal/asm/SignatureParser.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/internal/asm/SignatureScanner.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/internal/asm/SoftClassReference.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/internal/asm/TParamStub.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/internal/asm/TypeParamsParser.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/internal/asm/TypeSigParser.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/internal/ast/AbstractAstBackedSymbol.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/internal/ast/AbstractAstExecSymbol.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/internal/ast/AbstractAstTParamOwner.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/internal/ast/AbstractAstVariableSym.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/internal/ast/AstClassSym.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/internal/ast/AstCtorSym.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/internal/ast/AstFieldSym.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/internal/ast/AstFormalParamSym.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/internal/ast/AstLocalVarSym.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/internal/ast/AstMethodSym.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/internal/ast/AstSymFactory.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/internal/ast/AstSymbolMakerVisitor.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/internal/ast/AstTypeParamSym.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/internal/ast/MapSymResolver.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/internal/ast/SymbolResolutionPass.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/package-info.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/table/JSymbolTable.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/table/ScopeInfo.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/table/coreimpl/CachingShadowChainNode.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/table/coreimpl/CoreResolvers.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/table/coreimpl/MostlySingularMultimap.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/table/coreimpl/NameResolver.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/table/coreimpl/ShadowChain.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/table/coreimpl/ShadowChainBuilder.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/table/coreimpl/ShadowChainIterator.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/table/coreimpl/ShadowChainIteratorImpl.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/table/coreimpl/ShadowChainNode.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/table/coreimpl/ShadowChainNodeBase.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/table/coreimpl/ShadowChainRoot.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/table/internal/JavaResolvers.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/table/internal/ReferenceCtx.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/table/internal/ScopeInfo.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/table/internal/SemanticChecksLogger.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/table/internal/SuperTypesEnumerator.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/table/internal/SymTableFactory.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/table/internal/SymbolChainBuilder.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/table/internal/SymbolTableImpl.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/table/internal/SymbolTableResolver.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symboltable/AbstractJavaScope.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symboltable/ClassNameDeclaration.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symboltable/ClassScope.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symboltable/DeclarationFinderFunction.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symboltable/JavaNameOccurrence.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symboltable/LocalScope.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symboltable/MethodNameDeclaration.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symboltable/MethodScope.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symboltable/NameFinder.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symboltable/OccurrenceFinder.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symboltable/ScopeAndDeclarationFinder.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symboltable/Search.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symboltable/SimpleTypedNameDeclaration.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symboltable/SourceFileScope.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symboltable/SymbolFacade.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symboltable/TypeSet.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symboltable/TypedNameDeclaration.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symboltable/VariableNameDeclaration.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symboltable/package-info.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/typeresolution/ClassTypeResolver.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/typeresolution/PMDASMClassLoader.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/typeresolution/internal/NullableClassLoader.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/typeresolution/visitors/PMDASMVisitor.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/ArrayMethodSigImpl.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/ArraySymbolImpl.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/BasePrimitiveSymbol.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/BoxedPrimitive.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/CaptureMatcher.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/ClassMethodSigImpl.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/ClassTypeImpl.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/ErasedClassType.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/FakeIntersectionSymbol.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/JArrayType.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/JClassType.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/JIntersectionType.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/JMethodSig.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/JPrimitiveType.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/JTypeMirror.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/JTypeVar.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/JTypeVisitable.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/JTypeVisitor.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/JVariableSig.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/JWildcardType.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/LexicalScope.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/Lub.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/MapFunction.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/OverloadSelectionResult.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/SentinelType.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/SubstVar.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/Substitution.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/TypeConversion.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/TypeOps.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/TypePrettyPrint.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/TypeSystem.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/TypeTestUtil.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/TypeVarImpl.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/TypesFromReflection.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/UnresolvedMethodSig.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/WildcardTypeImpl.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/internal/InternalMethodTypeItf.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/internal/infer/ExprCheckHelper.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/internal/infer/ExprMirror.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/internal/infer/ExprOps.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/internal/infer/Graph.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/internal/infer/IncorporationAction.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/internal/infer/Infer.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/internal/infer/InferenceContext.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/internal/infer/InferenceVar.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/internal/infer/InferenceVarSym.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/internal/infer/MethodCallSite.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/internal/infer/MethodResolutionPhase.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/internal/infer/OverloadSet.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/internal/infer/PhaseOverloadSet.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/internal/infer/PolySite.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/internal/infer/ReductionStep.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/internal/infer/ResolutionFailedException.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/internal/infer/ResolutionFailure.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/internal/infer/TypeInferenceLogger.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/internal/infer/VarWalkStrategy.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/internal/infer/ast/BaseExprMirror.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/internal/infer/ast/BaseInvocMirror.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/internal/infer/ast/BasePolyMirror.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/internal/infer/ast/ConditionalMirrorImpl.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/internal/infer/ast/CtorInvocMirror.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/internal/infer/ast/JavaExprMirrors.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/internal/infer/ast/LambdaMirrorImpl.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/internal/infer/ast/MethodInvocMirror.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/internal/infer/ast/MethodRefMirrorImpl.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/internal/infer/ast/StandaloneExprMirror.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/internal/infer/ast/SwitchMirror.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/package-info.java']\n\nFile Path Before Refactoring:\npmd-java/src/main/java/net/sourceforge/pmd/lang/java/internal/JavaAstProcessor.java\n\nInstructions:\n1. Analyze the provided code, class content, and project structure, apply relevant refactoring operation to the code to be refactored, and you need move the extracted method to another existing java file, output the target file path, extracted method code, refactored method code after refactoring.\nThe extracted method code should be the public static method.\nThe refactored method code should use the moved class to call the extracted method.\nThe target file path should be the path of the existing class where the method is moved to.\n\n2. If refactoring is performed, output the refactored class code in the following format:\n##########################\ntarget_file_path\n##########################\nextracted_method_code\n##########################\nrefactored_method_code\n##########################\n\n\n\n\n\n"}, {"type": "Extract Method", "description": "Extract Method\tprivate assertIsA(node TypeNode, type Class<?>, exactly boolean, expectTrue boolean) : void extracted from private assertIsA(node TypeNode, type Class<?>) : void in class net.sourceforge.pmd.lang.java.types.TypeTestUtilTest", "diffLocations": [{"filePath": "pmd-java/src/test/java/net/sourceforge/pmd/lang/java/types/TypeTestUtilTest.java", "startLine": 163, "endLine": 168, "startColumn": 0, "endColumn": 0}, {"filePath": "pmd-java/src/test/java/net/sourceforge/pmd/lang/java/types/TypeTestUtilTest.java", "startLine": 213, "endLine": 215, "startColumn": 0, "endColumn": 0}, {"filePath": "pmd-java/src/test/java/net/sourceforge/pmd/lang/java/types/TypeTestUtilTest.java", "startLine": 236, "endLine": 245, "startColumn": 0, "endColumn": 0}], "sourceCodeBeforeRefactoring": "private void assertIsA(TypeNode node, Class<?> type) {\n        Assert.assertTrue(\"TypeTestUtil::isA with class arg: \" + type.getCanonicalName(),\n                          TypeTestUtil.isA(type, node));\n        Assert.assertTrue(\"TypeTestUtil::isA with string arg: \" + type.getCanonicalName(),\n                          TypeTestUtil.isA(type.getCanonicalName(), node));\n    }", "filePathBefore": "pmd-java/src/test/java/net/sourceforge/pmd/lang/java/types/TypeTestUtilTest.java", "isPureRefactoring": true, "commitId": "20930119137620c622b742dda74f24c55f7ab70d", "packageNameBefore": "net.sourceforge.pmd.lang.java.types", "classNameBefore": "net.sourceforge.pmd.lang.java.types.TypeTestUtilTest", "methodNameBefore": "net.sourceforge.pmd.lang.java.types.TypeTestUtilTest#assertIsA", "invokedMethod": "methodSignature: net.sourceforge.pmd.lang.java.types.TypeTestUtil#isA\n methodBody: public static boolean isA(/*@NonNull*/ String canonicalName, /*@Nullable*/ TypeNode node) {\nrequireParamNotNull(\"canonicalName\",canonicalName);\nif(node == null){return false;\n}Class<?> nodeType=node.getType();\nif(nodeType == null){return fallbackIsA(node,canonicalName,true);\n}if(nodeType.isAnnotation()){return isAnnotationSubtype(nodeType,canonicalName);\n}final Class<?> clazz=loadClassWithNodeClassloader(node,canonicalName);\nif(clazz != null){if(clazz.getCanonicalName() == null){return false;\n}return clazz.isAssignableFrom(nodeType);\n}{return fallbackIsA(node,canonicalName,true);\n}}", "classSignatureBefore": "public class TypeTestUtilTest extends BaseNonParserTest ", "methodNameBeforeSet": ["net.sourceforge.pmd.lang.java.types.TypeTestUtilTest#assertIsA"], "classNameBeforeSet": ["net.sourceforge.pmd.lang.java.types.TypeTestUtilTest"], "classSignatureBeforeSet": ["public class TypeTestUtilTest extends BaseNonParserTest "], "purityCheckResultList": [{"isPure": true, "purityComment": "Tolerable changes in the body\n", "description": "All replacements have been justified - all mapped", "mappingState": 1}], "sourceCodeBeforeForWhole": "/*\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.lang.java.types;\n\nimport java.io.Serializable;\nimport java.lang.annotation.Annotation;\nimport java.util.concurrent.Callable;\n\nimport org.junit.Assert;\nimport org.junit.Rule;\nimport org.junit.Test;\nimport org.junit.function.ThrowingRunnable;\nimport org.junit.rules.ExpectedException;\n\nimport net.sourceforge.pmd.lang.java.ast.ASTAllocationExpression;\nimport net.sourceforge.pmd.lang.java.ast.ASTAnnotationTypeDeclaration;\nimport net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration;\nimport net.sourceforge.pmd.lang.java.ast.ASTEnumDeclaration;\nimport net.sourceforge.pmd.lang.java.ast.ASTMarkerAnnotation;\nimport net.sourceforge.pmd.lang.java.ast.ASTName;\nimport net.sourceforge.pmd.lang.java.ast.TypeNode;\nimport net.sourceforge.pmd.lang.java.symboltable.BaseNonParserTest;\nimport net.sourceforge.pmd.lang.java.types.testdata.SomeClassWithAnon;\n\npublic class TypeTestUtilTest extends BaseNonParserTest {\n\n    @Rule\n    public final ExpectedException expect = ExpectedException.none();\n\n    @Test\n    public void testIsAFallback() {\n\n        ASTClassOrInterfaceDeclaration klass =\n            java.parse(\"package org; import java.io.Serializable; \"\n                           + \"class FooBar implements Serializable {}\")\n                .getFirstDescendantOfType(ASTClassOrInterfaceDeclaration.class);\n\n\n        Assert.assertNull(klass.getType());\n        Assert.assertTrue(TypeTestUtil.isA(\"org.FooBar\", klass));\n        Assert.assertTrue(TypeTestUtil.isA(\"java.io.Serializable\", klass));\n        Assert.assertTrue(TypeTestUtil.isA(Serializable.class, klass));\n    }\n\n\n    @Test\n    public void testIsAFallbackEnum() {\n\n        ASTEnumDeclaration klass =\n            java.parse(\"package org; \"\n                           + \"enum FooBar implements Iterable {}\")\n                .getFirstDescendantOfType(ASTEnumDeclaration.class);\n\n\n        Assert.assertNull(klass.getType());\n        Assert.assertTrue(TypeTestUtil.isA(\"org.FooBar\", klass));\n        assertIsA(klass, Iterable.class);\n        assertIsA(klass, Enum.class);\n        assertIsA(klass, Serializable.class);\n        assertIsA(klass, Object.class);\n    }\n\n    @Test\n    public void testIsAFallbackAnnotation() {\n\n        ASTAnnotationTypeDeclaration klass =\n            java.parse(\"package org; import foo.Stuff;\"\n                           + \"public @interface FooBar {}\")\n                .getFirstDescendantOfType(ASTAnnotationTypeDeclaration.class);\n\n\n        Assert.assertNull(klass.getType());\n        Assert.assertTrue(TypeTestUtil.isA(\"org.FooBar\", klass));\n        assertIsA(klass, Annotation.class);\n        assertIsA(klass, Object.class);\n    }\n\n    @Test\n    public void testAnonClassTypeNPE() {\n        // #2756\n\n        ASTAllocationExpression anon =\n            java.parseClass(SomeClassWithAnon.class)\n                .getFirstDescendantOfType(ASTAllocationExpression.class);\n\n\n        Assert.assertNotNull(\"Type should be resolved\", anon.getType());\n        Assert.assertTrue(\"Anon class\", anon.isAnonymousClass());\n        Assert.assertTrue(\"Anon class\", anon.getType().isAnonymousClass());\n        Assert.assertTrue(\"Should be a Runnable\", TypeTestUtil.isA(Runnable.class, anon));\n\n        // This is not a canonical name, so we give up early\n        Assert.assertFalse(TypeTestUtil.isA(SomeClassWithAnon.class.getName() + \"$1\", anon));\n        Assert.assertFalse(TypeTestUtil.isExactlyA(SomeClassWithAnon.class.getName() + \"$1\", anon));\n\n        // this is the failure case: if the binary name doesn't match, we test the canoname, which was null\n        Assert.assertFalse(TypeTestUtil.isA(Callable.class, anon));\n        Assert.assertFalse(TypeTestUtil.isA(Callable.class.getCanonicalName(), anon));\n        Assert.assertFalse(TypeTestUtil.isExactlyA(Callable.class, anon));\n        Assert.assertFalse(TypeTestUtil.isExactlyA(Callable.class.getCanonicalName(), anon));\n    }\n\n    /**\n     * If we don't have the annotation on the classpath,\n     * we should resolve the full name via the import, if possible\n     * and compare then. Only after that, we should compare the\n     * simple names.\n     */\n    @Test\n    public void testIsAFallbackAnnotationSimpleNameImport() {\n        ASTName annotation = java.parse(\"package org; import foo.Stuff; @Stuff public class FooBar {}\")\n                                 .getFirstDescendantOfType(ASTMarkerAnnotation.class).getFirstChildOfType(ASTName.class);\n\n        Assert.assertNull(annotation.getType());\n        Assert.assertTrue(TypeTestUtil.isA(\"foo.Stuff\", annotation));\n        Assert.assertFalse(TypeTestUtil.isA(\"other.Stuff\", annotation));\n        // if the searched class name is not fully qualified, then the search should still be successful\n        Assert.assertTrue(TypeTestUtil.isA(\"Stuff\", annotation));\n    }\n\n    @Test\n    public void testNullNode() {\n        Assert.assertFalse(TypeTestUtil.isA(String.class, null));\n        Assert.assertFalse(TypeTestUtil.isA(\"java.lang.String\", null));\n        Assert.assertFalse(TypeTestUtil.isExactlyA(String.class, null));\n        Assert.assertFalse(TypeTestUtil.isExactlyA(\"java.lang.String\", null));\n    }\n\n    @Test\n    public void testNullClass() {\n        final ASTName node = java.parse(\"package org; import foo.Stuff; @Stuff public class FooBar {}\")\n                                 .getFirstDescendantOfType(ASTMarkerAnnotation.class).getFirstChildOfType(ASTName.class);\n        Assert.assertNotNull(node);\n\n        Assert.assertThrows(NullPointerException.class, new ThrowingRunnable() {\n            @Override\n            public void run() {\n                TypeTestUtil.isA((String) null, node);\n            }\n        });\n        Assert.assertThrows(NullPointerException.class, new ThrowingRunnable() {\n            @Override\n            public void run() {\n                TypeTestUtil.isA((Class<?>) null, node);\n            }\n        });\n        Assert.assertThrows(NullPointerException.class, new ThrowingRunnable() {\n            @Override\n            public void run() {\n                TypeTestUtil.isExactlyA((Class<?>) null, node);\n            }\n        });\n        Assert.assertThrows(NullPointerException.class, new ThrowingRunnable() {\n            @Override\n            public void run() {\n                TypeTestUtil.isExactlyA((String) null, node);\n            }\n        });\n    }\n\n    private void assertIsA(TypeNode node, Class<?> type) {\n        Assert.assertTrue(\"TypeTestUtil::isA with class arg: \" + type.getCanonicalName(),\n                          TypeTestUtil.isA(type, node));\n        Assert.assertTrue(\"TypeTestUtil::isA with string arg: \" + type.getCanonicalName(),\n                          TypeTestUtil.isA(type.getCanonicalName(), node));\n    }\n\n}\n", "filePathAfter": "pmd-java/src/test/java/net/sourceforge/pmd/lang/java/types/TypeTestUtilTest.java", "sourceCodeAfterForWhole": "/*\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.lang.java.types;\n\nimport java.io.ObjectStreamField;\nimport java.io.Serializable;\nimport java.lang.annotation.Annotation;\nimport java.util.concurrent.Callable;\n\nimport org.junit.Assert;\nimport org.junit.Rule;\nimport org.junit.Test;\nimport org.junit.function.ThrowingRunnable;\nimport org.junit.rules.ExpectedException;\n\nimport net.sourceforge.pmd.lang.java.ast.ASTAllocationExpression;\nimport net.sourceforge.pmd.lang.java.ast.ASTAnnotationTypeDeclaration;\nimport net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration;\nimport net.sourceforge.pmd.lang.java.ast.ASTEnumDeclaration;\nimport net.sourceforge.pmd.lang.java.ast.ASTMarkerAnnotation;\nimport net.sourceforge.pmd.lang.java.ast.ASTName;\nimport net.sourceforge.pmd.lang.java.ast.ASTType;\nimport net.sourceforge.pmd.lang.java.ast.TypeNode;\nimport net.sourceforge.pmd.lang.java.symboltable.BaseNonParserTest;\nimport net.sourceforge.pmd.lang.java.types.testdata.SomeClassWithAnon;\n\npublic class TypeTestUtilTest extends BaseNonParserTest {\n\n    @Rule\n    public final ExpectedException expect = ExpectedException.none();\n\n    @Test\n    public void testIsAFallback() {\n\n        ASTClassOrInterfaceDeclaration klass =\n            java.parse(\"package org; import java.io.Serializable; \"\n                           + \"class FooBar implements Serializable {}\")\n                .getFirstDescendantOfType(ASTClassOrInterfaceDeclaration.class);\n\n\n        Assert.assertNull(klass.getType());\n        Assert.assertTrue(TypeTestUtil.isA(\"org.FooBar\", klass));\n        Assert.assertTrue(TypeTestUtil.isA(\"java.io.Serializable\", klass));\n        Assert.assertTrue(TypeTestUtil.isA(Serializable.class, klass));\n    }\n\n\n    @Test\n    public void testIsAFallbackEnum() {\n\n        ASTEnumDeclaration klass =\n            java.parse(\"package org; \"\n                           + \"enum FooBar implements Iterable {}\")\n                .getFirstDescendantOfType(ASTEnumDeclaration.class);\n\n\n        Assert.assertNull(klass.getType());\n        Assert.assertTrue(TypeTestUtil.isA(\"org.FooBar\", klass));\n        assertIsStrictSubtype(klass, Iterable.class);\n        assertIsStrictSubtype(klass, Enum.class);\n        assertIsStrictSubtype(klass, Serializable.class);\n        assertIsStrictSubtype(klass, Object.class);\n    }\n\n\n    @Test\n    public void testIsAnArrayClass() {\n\n        ASTType arrayT =\n            java.parse(\"import java.io.ObjectStreamField; \"\n                           + \"class Foo { private static final ObjectStreamField[] serialPersistentFields; }\")\n                .getFirstDescendantOfType(ASTType.class);\n\n\n        assertIsExactlyA(arrayT, ObjectStreamField[].class);\n        assertIsStrictSubtype(arrayT, Object[].class);\n        assertIsStrictSubtype(arrayT, Serializable.class);\n        assertIsNot(arrayT, Serializable[].class);\n        assertIsStrictSubtype(arrayT, Object.class);\n    }\n\n    @Test\n    public void testIsAnAnnotationClass() {\n\n        ASTType arrayT =\n            java.parse(\"class Foo { org.junit.Test field; }\")\n                .getFirstDescendantOfType(ASTType.class);\n\n\n        assertIsExactlyA(arrayT, Test.class);\n        assertIsStrictSubtype(arrayT, Annotation.class);\n        assertIsStrictSubtype(arrayT, Object.class);\n    }\n\n    @Test\n    public void testIsAPrimitiveArrayClass() {\n\n        ASTType arrayT =\n            java.parse(\"import java.io.ObjectStreamField; \"\n                           + \"class Foo { private static final int[] serialPersistentFields; }\")\n                .getFirstDescendantOfType(ASTType.class);\n\n\n        assertIsExactlyA(arrayT, int[].class);\n        assertIsNot(arrayT, long[].class);\n        assertIsNot(arrayT, Object[].class);\n\n        assertIsStrictSubtype(arrayT, Serializable.class);\n        assertIsStrictSubtype(arrayT, Object.class);\n    }\n\n\n    @Test\n    public void testIsAFallbackAnnotation() {\n\n        ASTAnnotationTypeDeclaration klass =\n            java.parse(\"package org; import foo.Stuff;\"\n                           + \"public @interface FooBar {}\")\n                .getFirstDescendantOfType(ASTAnnotationTypeDeclaration.class);\n\n\n        Assert.assertNull(klass.getType());\n        Assert.assertTrue(TypeTestUtil.isA(\"org.FooBar\", klass));\n        assertIsA(klass, Annotation.class);\n        assertIsA(klass, Object.class);\n    }\n\n    @Test\n    public void testAnonClassTypeNPE() {\n        // #2756\n\n        ASTAllocationExpression anon =\n            java.parseClass(SomeClassWithAnon.class)\n                .getFirstDescendantOfType(ASTAllocationExpression.class);\n\n\n        Assert.assertNotNull(\"Type should be resolved\", anon.getType());\n        Assert.assertTrue(\"Anon class\", anon.isAnonymousClass());\n        Assert.assertTrue(\"Anon class\", anon.getType().isAnonymousClass());\n        Assert.assertTrue(\"Should be a Runnable\", TypeTestUtil.isA(Runnable.class, anon));\n\n        // This is not a canonical name, so we give up early\n        Assert.assertFalse(TypeTestUtil.isA(SomeClassWithAnon.class.getName() + \"$1\", anon));\n        Assert.assertFalse(TypeTestUtil.isExactlyA(SomeClassWithAnon.class.getName() + \"$1\", anon));\n\n        // this is the failure case: if the binary name doesn't match, we test the canoname, which was null\n        Assert.assertFalse(TypeTestUtil.isA(Callable.class, anon));\n        Assert.assertFalse(TypeTestUtil.isA(Callable.class.getCanonicalName(), anon));\n        Assert.assertFalse(TypeTestUtil.isExactlyA(Callable.class, anon));\n        Assert.assertFalse(TypeTestUtil.isExactlyA(Callable.class.getCanonicalName(), anon));\n    }\n\n    /**\n     * If we don't have the annotation on the classpath,\n     * we should resolve the full name via the import, if possible\n     * and compare then. Only after that, we should compare the\n     * simple names.\n     */\n    @Test\n    public void testIsAFallbackAnnotationSimpleNameImport() {\n        ASTName annotation = java.parse(\"package org; import foo.Stuff; @Stuff public class FooBar {}\")\n                                 .getFirstDescendantOfType(ASTMarkerAnnotation.class).getFirstChildOfType(ASTName.class);\n\n        Assert.assertNull(annotation.getType());\n        Assert.assertTrue(TypeTestUtil.isA(\"foo.Stuff\", annotation));\n        Assert.assertFalse(TypeTestUtil.isA(\"other.Stuff\", annotation));\n        // if the searched class name is not fully qualified, then the search should still be successful\n        Assert.assertTrue(TypeTestUtil.isA(\"Stuff\", annotation));\n    }\n\n    @Test\n    public void testNullNode() {\n        Assert.assertFalse(TypeTestUtil.isA(String.class, null));\n        Assert.assertFalse(TypeTestUtil.isA(\"java.lang.String\", null));\n        Assert.assertFalse(TypeTestUtil.isExactlyA(String.class, null));\n        Assert.assertFalse(TypeTestUtil.isExactlyA(\"java.lang.String\", null));\n    }\n\n    @Test\n    public void testNullClass() {\n        final ASTName node = java.parse(\"package org; import foo.Stuff; @Stuff public class FooBar {}\")\n                                 .getFirstDescendantOfType(ASTMarkerAnnotation.class).getFirstChildOfType(ASTName.class);\n        Assert.assertNotNull(node);\n\n        Assert.assertThrows(NullPointerException.class, new ThrowingRunnable() {\n            @Override\n            public void run() {\n                TypeTestUtil.isA((String) null, node);\n            }\n        });\n        Assert.assertThrows(NullPointerException.class, new ThrowingRunnable() {\n            @Override\n            public void run() {\n                TypeTestUtil.isA((Class<?>) null, node);\n            }\n        });\n        Assert.assertThrows(NullPointerException.class, new ThrowingRunnable() {\n            @Override\n            public void run() {\n                TypeTestUtil.isExactlyA((Class<?>) null, node);\n            }\n        });\n        Assert.assertThrows(NullPointerException.class, new ThrowingRunnable() {\n            @Override\n            public void run() {\n                TypeTestUtil.isExactlyA((String) null, node);\n            }\n        });\n    }\n\n    private void assertIsA(TypeNode node, Class<?> type) {\n        assertIsA(node, type, false, true);\n    }\n\n    private void assertIsExactlyA(TypeNode node, Class<?> type) {\n        assertIsA(node, type, true, true);\n        assertIsA(node, type, false, true);\n    }\n\n    private void assertIsNot(TypeNode node, Class<?> type) {\n        assertIsA(node, type, true, false);\n        assertIsA(node, type, false, false);\n    }\n\n    private void assertIsNotExactly(TypeNode node, Class<?> type) {\n        assertIsA(node, type, true, false);\n    }\n\n    private void assertIsStrictSubtype(TypeNode node, Class<?> type) {\n        assertIsNotExactly(node, type);\n        assertIsA(node, type);\n    }\n\n    private void assertIsA(TypeNode node, Class<?> type, boolean exactly, boolean expectTrue) {\n        Assert.assertEquals(\"TypeTestUtil::isA with class arg: \" + type.getCanonicalName(),\n                            expectTrue,\n                            exactly ? TypeTestUtil.isExactlyA(type, node)\n                                    : TypeTestUtil.isA(type, node));\n        Assert.assertEquals(\"TypeTestUtil::isA with string arg: \" + type.getCanonicalName(),\n                            expectTrue,\n                            exactly ? TypeTestUtil.isExactlyA(type.getCanonicalName(), node)\n                                    : TypeTestUtil.isA(type.getCanonicalName(), node));\n    }\n\n\n}\n", "diffSourceCodeSet": ["private void assertIsA(TypeNode node, Class<?> type, boolean exactly, boolean expectTrue) {\n        Assert.assertEquals(\"TypeTestUtil::isA with class arg: \" + type.getCanonicalName(),\n                            expectTrue,\n                            exactly ? TypeTestUtil.isExactlyA(type, node)\n                                    : TypeTestUtil.isA(type, node));\n        Assert.assertEquals(\"TypeTestUtil::isA with string arg: \" + type.getCanonicalName(),\n                            expectTrue,\n                            exactly ? TypeTestUtil.isExactlyA(type.getCanonicalName(), node)\n                                    : TypeTestUtil.isA(type.getCanonicalName(), node));\n    }"], "invokedMethodSet": ["methodSignature: net.sourceforge.pmd.lang.java.types.TypeTestUtil#isA\n methodBody: public static boolean isA(/*@NonNull*/ String canonicalName, /*@Nullable*/ TypeNode node) {\nrequireParamNotNull(\"canonicalName\",canonicalName);\nif(node == null){return false;\n}Class<?> nodeType=node.getType();\nif(nodeType == null){return fallbackIsA(node,canonicalName,true);\n}if(nodeType.isAnnotation()){return isAnnotationSubtype(nodeType,canonicalName);\n}final Class<?> clazz=loadClassWithNodeClassloader(node,canonicalName);\nif(clazz != null){if(clazz.getCanonicalName() == null){return false;\n}return clazz.isAssignableFrom(nodeType);\n}{return fallbackIsA(node,canonicalName,true);\n}}"], "sourceCodeAfterRefactoring": "private void assertIsA(TypeNode node, Class<?> type) {\n        assertIsA(node, type, false, true);\n    }\nprivate void assertIsA(TypeNode node, Class<?> type, boolean exactly, boolean expectTrue) {\n        Assert.assertEquals(\"TypeTestUtil::isA with class arg: \" + type.getCanonicalName(),\n                            expectTrue,\n                            exactly ? TypeTestUtil.isExactlyA(type, node)\n                                    : TypeTestUtil.isA(type, node));\n        Assert.assertEquals(\"TypeTestUtil::isA with string arg: \" + type.getCanonicalName(),\n                            expectTrue,\n                            exactly ? TypeTestUtil.isExactlyA(type.getCanonicalName(), node)\n                                    : TypeTestUtil.isA(type.getCanonicalName(), node));\n    }", "diffSourceCode": "-  163:     private void assertIsA(TypeNode node, Class<?> type) {\n-  164:         Assert.assertTrue(\"TypeTestUtil::isA with class arg: \" + type.getCanonicalName(),\n-  165:                           TypeTestUtil.isA(type, node));\n-  166:         Assert.assertTrue(\"TypeTestUtil::isA with string arg: \" + type.getCanonicalName(),\n-  167:                           TypeTestUtil.isA(type.getCanonicalName(), node));\n-  168:     }\n+  163:         ASTName annotation = java.parse(\"package org; import foo.Stuff; @Stuff public class FooBar {}\")\n+  164:                                  .getFirstDescendantOfType(ASTMarkerAnnotation.class).getFirstChildOfType(ASTName.class);\n+  165: \n+  166:         Assert.assertNull(annotation.getType());\n+  167:         Assert.assertTrue(TypeTestUtil.isA(\"foo.Stuff\", annotation));\n+  168:         Assert.assertFalse(TypeTestUtil.isA(\"other.Stuff\", annotation));\n+  213:     private void assertIsA(TypeNode node, Class<?> type) {\n+  214:         assertIsA(node, type, false, true);\n+  215:     }\n+  236:     private void assertIsA(TypeNode node, Class<?> type, boolean exactly, boolean expectTrue) {\n+  237:         Assert.assertEquals(\"TypeTestUtil::isA with class arg: \" + type.getCanonicalName(),\n+  238:                             expectTrue,\n+  239:                             exactly ? TypeTestUtil.isExactlyA(type, node)\n+  240:                                     : TypeTestUtil.isA(type, node));\n+  241:         Assert.assertEquals(\"TypeTestUtil::isA with string arg: \" + type.getCanonicalName(),\n+  242:                             expectTrue,\n+  243:                             exactly ? TypeTestUtil.isExactlyA(type.getCanonicalName(), node)\n+  244:                                     : TypeTestUtil.isA(type.getCanonicalName(), node));\n+  245:     }\n", "uniqueId": "20930119137620c622b742dda74f24c55f7ab70d_163_168_236_245_213_215", "moveFileExist": true, "testResult": true, "coverageInfo": {"testMethod": {"missed": 0, "covered": 1}}, "compileResultBefore": true, "compileResultCurrent": true, "compileJDK": 11, "refactoringMinerResult": true, "compileAndTestResult": true, "refactoredCode": "To improve the readability and maintainability of the `assertIsA` method, we can extract the repeated logic of asserting the type checks into a separate method. This will reduce duplication and make the code cleaner.\n\nHere\u2019s the refactored method code:\n\n##########################\nprivate void assertIsA(TypeNode node, Class<?> type) {\n    assertTypeIsA(node, type);\n}\n\nprivate void assertTypeIsA(TypeNode node, Class<?> type) {\n    Assert.assertTrue(\"TypeTestUtil::isA with class arg: \" + type.getCanonicalName(),\n                      TypeTestUtil.isA(type, node));\n    Assert.assertTrue(\"TypeTestUtil::isA with string arg: \" + type.getCanonicalName(),\n                      TypeTestUtil.isA(type.getCanonicalName(), node));\n}\n##########################", "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to Refactor:\nprivate void assertIsA(TypeNode node, Class<?> type) {\n        Assert.assertTrue(\"TypeTestUtil::isA with class arg: \" + type.getCanonicalName(),\n                          TypeTestUtil.isA(type, node));\n        Assert.assertTrue(\"TypeTestUtil::isA with string arg: \" + type.getCanonicalName(),\n                          TypeTestUtil.isA(type.getCanonicalName(), node));\n    }\n\nClass content:\n/*\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.lang.java.types;\n\nimport java.io.Serializable;\nimport java.lang.annotation.Annotation;\nimport java.util.concurrent.Callable;\n\nimport org.junit.Assert;\nimport org.junit.Rule;\nimport org.junit.Test;\nimport org.junit.function.ThrowingRunnable;\nimport org.junit.rules.ExpectedException;\n\nimport net.sourceforge.pmd.lang.java.ast.ASTAllocationExpression;\nimport net.sourceforge.pmd.lang.java.ast.ASTAnnotationTypeDeclaration;\nimport net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration;\nimport net.sourceforge.pmd.lang.java.ast.ASTEnumDeclaration;\nimport net.sourceforge.pmd.lang.java.ast.ASTMarkerAnnotation;\nimport net.sourceforge.pmd.lang.java.ast.ASTName;\nimport net.sourceforge.pmd.lang.java.ast.TypeNode;\nimport net.sourceforge.pmd.lang.java.symboltable.BaseNonParserTest;\nimport net.sourceforge.pmd.lang.java.types.testdata.SomeClassWithAnon;\n\npublic class TypeTestUtilTest extends BaseNonParserTest {\n\n    @Rule\n    public final ExpectedException expect = ExpectedException.none();\n\n    @Test\n    public void testIsAFallback() {\n\n        ASTClassOrInterfaceDeclaration klass =\n            java.parse(\"package org; import java.io.Serializable; \"\n                           + \"class FooBar implements Serializable {}\")\n                .getFirstDescendantOfType(ASTClassOrInterfaceDeclaration.class);\n\n\n        Assert.assertNull(klass.getType());\n        Assert.assertTrue(TypeTestUtil.isA(\"org.FooBar\", klass));\n        Assert.assertTrue(TypeTestUtil.isA(\"java.io.Serializable\", klass));\n        Assert.assertTrue(TypeTestUtil.isA(Serializable.class, klass));\n    }\n\n\n    @Test\n    public void testIsAFallbackEnum() {\n\n        ASTEnumDeclaration klass =\n            java.parse(\"package org; \"\n                           + \"enum FooBar implements Iterable {}\")\n                .getFirstDescendantOfType(ASTEnumDeclaration.class);\n\n\n        Assert.assertNull(klass.getType());\n        Assert.assertTrue(TypeTestUtil.isA(\"org.FooBar\", klass));\n        assertIsA(klass, Iterable.class);\n        assertIsA(klass, Enum.class);\n        assertIsA(klass, Serializable.class);\n        assertIsA(klass, Object.class);\n    }\n\n    @Test\n    public void testIsAFallbackAnnotation() {\n\n        ASTAnnotationTypeDeclaration klass =\n            java.parse(\"package org; import foo.Stuff;\"\n                           + \"public @interface FooBar {}\")\n                .getFirstDescendantOfType(ASTAnnotationTypeDeclaration.class);\n\n\n        Assert.assertNull(klass.getType());\n        Assert.assertTrue(TypeTestUtil.isA(\"org.FooBar\", klass));\n        assertIsA(klass, Annotation.class);\n        assertIsA(klass, Object.class);\n    }\n\n    @Test\n    public void testAnonClassTypeNPE() {\n        // #2756\n\n        ASTAllocationExpression anon =\n            java.parseClass(SomeClassWithAnon.class)\n                .getFirstDescendantOfType(ASTAllocationExpression.class);\n\n\n        Assert.assertNotNull(\"Type should be resolved\", anon.getType());\n        Assert.assertTrue(\"Anon class\", anon.isAnonymousClass());\n        Assert.assertTrue(\"Anon class\", anon.getType().isAnonymousClass());\n        Assert.assertTrue(\"Should be a Runnable\", TypeTestUtil.isA(Runnable.class, anon));\n\n        // This is not a canonical name, so we give up early\n        Assert.assertFalse(TypeTestUtil.isA(SomeClassWithAnon.class.getName() + \"$1\", anon));\n        Assert.assertFalse(TypeTestUtil.isExactlyA(SomeClassWithAnon.class.getName() + \"$1\", anon));\n\n        // this is the failure case: if the binary name doesn't match, we test the canoname, which was null\n        Assert.assertFalse(TypeTestUtil.isA(Callable.class, anon));\n        Assert.assertFalse(TypeTestUtil.isA(Callable.class.getCanonicalName(), anon));\n        Assert.assertFalse(TypeTestUtil.isExactlyA(Callable.class, anon));\n        Assert.assertFalse(TypeTestUtil.isExactlyA(Callable.class.getCanonicalName(), anon));\n    }\n\n    /**\n     * If we don't have the annotation on the classpath,\n     * we should resolve the full name via the import, if possible\n     * and compare then. Only after that, we should compare the\n     * simple names.\n     */\n    @Test\n    public void testIsAFallbackAnnotationSimpleNameImport() {\n        ASTName annotation = java.parse(\"package org; import foo.Stuff; @Stuff public class FooBar {}\")\n                                 .getFirstDescendantOfType(ASTMarkerAnnotation.class).getFirstChildOfType(ASTName.class);\n\n        Assert.assertNull(annotation.getType());\n        Assert.assertTrue(TypeTestUtil.isA(\"foo.Stuff\", annotation));\n        Assert.assertFalse(TypeTestUtil.isA(\"other.Stuff\", annotation));\n        // if the searched class name is not fully qualified, then the search should still be successful\n        Assert.assertTrue(TypeTestUtil.isA(\"Stuff\", annotation));\n    }\n\n    @Test\n    public void testNullNode() {\n        Assert.assertFalse(TypeTestUtil.isA(String.class, null));\n        Assert.assertFalse(TypeTestUtil.isA(\"java.lang.String\", null));\n        Assert.assertFalse(TypeTestUtil.isExactlyA(String.class, null));\n        Assert.assertFalse(TypeTestUtil.isExactlyA(\"java.lang.String\", null));\n    }\n\n    @Test\n    public void testNullClass() {\n        final ASTName node = java.parse(\"package org; import foo.Stuff; @Stuff public class FooBar {}\")\n                                 .getFirstDescendantOfType(ASTMarkerAnnotation.class).getFirstChildOfType(ASTName.class);\n        Assert.assertNotNull(node);\n\n        Assert.assertThrows(NullPointerException.class, new ThrowingRunnable() {\n            @Override\n            public void run() {\n                TypeTestUtil.isA((String) null, node);\n            }\n        });\n        Assert.assertThrows(NullPointerException.class, new ThrowingRunnable() {\n            @Override\n            public void run() {\n                TypeTestUtil.isA((Class<?>) null, node);\n            }\n        });\n        Assert.assertThrows(NullPointerException.class, new ThrowingRunnable() {\n            @Override\n            public void run() {\n                TypeTestUtil.isExactlyA((Class<?>) null, node);\n            }\n        });\n        Assert.assertThrows(NullPointerException.class, new ThrowingRunnable() {\n            @Override\n            public void run() {\n                TypeTestUtil.isExactlyA((String) null, node);\n            }\n        });\n    }\n\n    private void assertIsA(TypeNode node, Class<?> type) {\n        Assert.assertTrue(\"TypeTestUtil::isA with class arg: \" + type.getCanonicalName(),\n                          TypeTestUtil.isA(type, node));\n        Assert.assertTrue(\"TypeTestUtil::isA with string arg: \" + type.getCanonicalName(),\n                          TypeTestUtil.isA(type.getCanonicalName(), node));\n    }\n\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n"}, {"type": "Move And Inline Method", "description": "Move And Inline Method\tpublic newRegionByLine(beginLine int, beginColumn int, endLine int, endColumn int) : RegionByLine moved from class net.sourceforge.pmd.document.TextRegion to class net.sourceforge.pmd.document.DocumentImpl & inlined to public createRegion(beginLine int, beginColumn int, endLine int, endColumn int) : RegionByLine", "diffLocations": [{"filePath": "pmd-core/src/main/java/net/sourceforge/pmd/document/DocumentImpl.java", "startLine": 103, "endLine": 107, "startColumn": 0, "endColumn": 0}, {"filePath": "pmd-core/src/main/java/net/sourceforge/pmd/document/DocumentImpl.java", "startLine": 114, "endLine": 118, "startColumn": 0, "endColumn": 0}, {"filePath": "pmd-core/src/main/java/net/sourceforge/pmd/document/DocumentImpl.java", "startLine": 28, "endLine": 30, "startColumn": 0, "endColumn": 0}], "sourceCodeBeforeRefactoring": "positioner = new SourceCodePositioner(source);\n    }", "filePathBefore": "pmd-core/src/main/java/net/sourceforge/pmd/document/DocumentImpl.java", "isPureRefactoring": true, "commitId": "a733da4dcfa19b80f21480040aaf701e72e51bb5", "packageNameBefore": "net.sourceforge.pmd.document", "classNameBefore": "net.sourceforge.pmd.document.TextRegion", "methodNameBefore": "net.sourceforge.pmd.document.TextRegion#newRegionByLine", "classSignatureBefore": "public interface TextRegion ", "methodNameBeforeSet": ["net.sourceforge.pmd.document.TextRegion#newRegionByLine"], "classNameBeforeSet": ["net.sourceforge.pmd.document.TextRegion"], "classSignatureBeforeSet": ["public interface TextRegion "], "purityCheckResultList": [{"isPure": true, "purityComment": "Tolerable changes in the body\n", "description": "All replacements have been justified - all mapped", "mappingState": 1}], "sourceCodeBeforeForWhole": "/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.document;\n\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.SortedMap;\nimport java.util.TreeMap;\n\nimport net.sourceforge.pmd.document.TextRegion.RegionByLine;\nimport net.sourceforge.pmd.document.TextRegion.RegionByOffset;\nimport net.sourceforge.pmd.lang.ast.SourceCodePositioner;\n\n\nclass DocumentImpl implements MutableDocument {\n\n    private ReplaceFunction out;\n    /** The positioner has the original source file. */\n    private SourceCodePositioner positioner;\n    private SortedMap<Integer, Integer> accumulatedOffsets = new TreeMap<>();\n\n\n    public DocumentImpl(final String source, final ReplaceFunction writer) {\n        this.out = writer;\n        positioner = new SourceCodePositioner(source);\n    }\n\n    @Override\n    public void insert(int beginLine, int beginColumn, final String textToInsert) {\n        insert(positioner.offsetFromLineColumn(beginLine, beginColumn), textToInsert);\n    }\n\n    @Override\n    public void insert(int offset, String textToInsert) {\n        replace(createRegion(offset, 0), textToInsert);\n    }\n\n\n    @Override\n    public void delete(final TextRegion region) {\n        replace(region, \"\");\n    }\n\n    @Override\n    public void replace(final TextRegion region, final String textToReplace) {\n        RegionByOffset off = region.toOffset(this);\n\n        RegionByOffset realPos = shiftOffset(off, textToReplace.length() - off.getLength());\n\n        out.replace(realPos, textToReplace);\n    }\n\n    private RegionByOffset shiftOffset(RegionByOffset origCoords, int lenDiff) {\n        ArrayList<Integer> keys = new ArrayList<>(accumulatedOffsets.keySet());\n        int idx = Collections.binarySearch(keys, origCoords.getOffset());\n\n        if (idx < 0) {\n            idx = -(idx + 1);\n        } else {\n            idx++;\n        }\n\n        int shift = 0;\n        for (int i = 0; i < idx; i++) {\n            shift += accumulatedOffsets.get(keys.get(i));\n        }\n\n        RegionByOffset realPos = shift == 0\n                                 ? origCoords\n                                 // don't check it\n                                 : new RegionByOffsetImp(origCoords.getOffset() + shift, origCoords.getLength());\n\n        accumulatedOffsets.compute(origCoords.getOffset(), (k, v) -> {\n            int s = v == null ? lenDiff : v + lenDiff;\n            return s == 0 ? null : s; // delete mapping if shift is 0\n        });\n\n        return realPos;\n    }\n\n    @Override\n    public RegionByLine mapToLine(RegionByOffset region) {\n        int bline = positioner.lineNumberFromOffset(region.getOffset());\n        int bcol = positioner.columnFromOffset(bline, region.getOffset());\n        int eline = positioner.lineNumberFromOffset(region.getOffsetAfterEnding());\n        int ecol = positioner.columnFromOffset(eline, region.getOffsetAfterEnding());\n\n        return createRegion(bline, bcol, eline, ecol);\n    }\n\n    @Override\n    public RegionByOffset mapToOffset(RegionByLine region) {\n        int offset = positioner.offsetFromLineColumn(region.getBeginLine(), region.getBeginColumn());\n        int len = positioner.offsetFromLineColumn(region.getEndLine(), region.getEndColumn())\n            - offset;\n\n        return createRegion(offset, len);\n    }\n\n    @Override\n    public RegionByLine createRegion(int beginLine, int beginColumn, int endLine, int endColumn) {\n        // TODO checks, positioner should return -1\n        return TextRegion.newRegionByLine(beginLine, beginColumn, endLine, endColumn);\n    }\n\n    @Override\n    public RegionByOffset createRegion(int offset, int length) {\n        if (offset < 0 || offset + length > positioner.getSourceCode().length()) {\n            throw new IndexOutOfBoundsException(\n                \"Region (\" + offset + \",+\" + length + \") is not in range of this document\");\n        }\n\n\n        return new RegionByOffsetImp(offset, length);\n    }\n\n    @Override\n    public CharSequence getText() {\n        return positioner.getSourceCode();\n    }\n\n    @Override\n    public CharSequence subSequence(TextRegion region) {\n        RegionByOffset byOffset = region.toOffset(this);\n        return getText().subSequence(byOffset.getOffset(), byOffset.getOffsetAfterEnding());\n    }\n\n    @Override\n    public CharSequence getUncommittedText() {\n        return out.getCurrentText(this);\n    }\n\n    @Override\n    public void close() throws IOException {\n        out = out.commit();\n        positioner = new SourceCodePositioner(out.getCurrentText(this).toString());\n        accumulatedOffsets = new TreeMap<>();\n    }\n\n}\n", "filePathAfter": "pmd-core/src/main/java/net/sourceforge/pmd/document/DocumentImpl.java", "sourceCodeAfterForWhole": "/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.document;\n\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.SortedMap;\nimport java.util.TreeMap;\n\nimport net.sourceforge.pmd.document.TextRegion.RegionByLine;\nimport net.sourceforge.pmd.document.TextRegion.RegionByOffset;\nimport net.sourceforge.pmd.lang.ast.SourceCodePositioner;\n\n\nclass DocumentImpl implements MutableDocument {\n\n    private ReplaceHandler out;\n    /** The positioner has the original source file. */\n    private SourceCodePositioner positioner;\n    private SortedMap<Integer, Integer> accumulatedOffsets = new TreeMap<>();\n\n\n    DocumentImpl(final String source, final ReplaceHandler writer) {\n        this.out = writer;\n        positioner = new SourceCodePositioner(source);\n    }\n\n    @Override\n    public MutableDocument newMutableDoc(ReplaceHandler out) {\n        return new DocumentImpl(getText().toString(), out);\n    }\n\n    @Override\n    public void insert(int beginLine, int beginColumn, final String textToInsert) {\n        insert(positioner.offsetFromLineColumn(beginLine, beginColumn), textToInsert);\n    }\n\n    @Override\n    public void insert(int offset, String textToInsert) {\n        replace(createRegion(offset, 0), textToInsert);\n    }\n\n\n    @Override\n    public void delete(final TextRegion region) {\n        replace(region, \"\");\n    }\n\n    @Override\n    public void replace(final TextRegion region, final String textToReplace) {\n        RegionByOffset off = region.toOffset(this);\n\n        RegionByOffset realPos = shiftOffset(off, textToReplace.length() - off.getLength());\n\n        out.replace(realPos, textToReplace);\n    }\n\n    private RegionByOffset shiftOffset(RegionByOffset origCoords, int lenDiff) {\n        ArrayList<Integer> keys = new ArrayList<>(accumulatedOffsets.keySet());\n        int idx = Collections.binarySearch(keys, origCoords.getStartOffset());\n\n        if (idx < 0) {\n            // there is no entry exactly for this offset, so that binarySearch\n            // returns the correct insertion index (but inverted)\n            idx = -(idx + 1);\n        } else {\n            // there is an exact entry\n            // since the loop below stops at idx, increment it to take that last entry into account\n            idx++;\n        }\n\n        // compute the shift accumulated by the mutations that have occurred\n        // left of the start index\n        int shift = 0;\n        for (int i = 0; i < idx; i++) {\n            shift += accumulatedOffsets.get(keys.get(i));\n        }\n\n        RegionByOffset realPos = shift == 0\n                                 ? origCoords\n                                 // don't check the bounds\n                                 : new RegionByOffsetImpl(origCoords.getStartOffset() + shift, origCoords.getLength());\n\n        accumulatedOffsets.compute(origCoords.getStartOffset(), (k, v) -> {\n            int s = v == null ? lenDiff : v + lenDiff;\n            return s == 0 ? null : s; // delete mapping if shift is 0\n        });\n\n        return realPos;\n    }\n\n    @Override\n    public RegionByLine mapToLine(RegionByOffset region) {\n        int bline = positioner.lineNumberFromOffset(region.getStartOffset());\n        int bcol = positioner.columnFromOffset(bline, region.getStartOffset());\n        int eline = positioner.lineNumberFromOffset(region.getOffsetAfterEnding());\n        int ecol = positioner.columnFromOffset(eline, region.getOffsetAfterEnding());\n\n        return createRegion(bline, bcol, eline, ecol);\n    }\n\n    @Override\n    public RegionByOffset mapToOffset(RegionByLine region) {\n        int offset = positioner.offsetFromLineColumn(region.getBeginLine(), region.getBeginColumn());\n        int len = positioner.offsetFromLineColumn(region.getEndLine(), region.getEndColumn())\n            - offset;\n\n        return createRegion(offset, len);\n    }\n\n    @Override\n    public RegionByLine createRegion(int beginLine, int beginColumn, int endLine, int endColumn) {\n        // TODO checks, positioner should return -1\n        return new RegionByLineImpl(beginLine, beginColumn, endLine, endColumn);\n    }\n\n    @Override\n    public RegionByOffset createRegion(int offset, int length) {\n        if (offset < 0 || offset + length > positioner.getSourceCode().length()) {\n            throw new IndexOutOfBoundsException(\n                \"Region (\" + offset + \",+\" + length + \") is not in range of this document\");\n        }\n\n\n        return new RegionByOffsetImpl(offset, length);\n    }\n\n    @Override\n    public CharSequence getText() {\n        return positioner.getSourceCode();\n    }\n\n    @Override\n    public CharSequence subSequence(TextRegion region) {\n        RegionByOffset byOffset = region.toOffset(this);\n        return getText().subSequence(byOffset.getStartOffset(), byOffset.getOffsetAfterEnding());\n    }\n\n\n    @Override\n    public CharSequence getUncommittedText() {\n        return out.getCurrentText(this);\n    }\n\n    @Override\n    public void close() throws IOException {\n        out = out.commit();\n        positioner = new SourceCodePositioner(out.getCurrentText(this).toString());\n        accumulatedOffsets = new TreeMap<>();\n    }\n\n}\n", "diffSourceCodeSet": [], "invokedMethodSet": [], "sourceCodeAfterRefactoring": "@Override\n    public RegionByLine createRegion(int beginLine, int beginColumn, int endLine, int endColumn) {\n        // TODO checks, positioner should return -1\n        return new RegionByLineImpl(beginLine, beginColumn, endLine, endColumn);\n    }", "diffSourceCode": "    28:         positioner = new SourceCodePositioner(source);\n    29:     }\n    30: \n-  103:     @Override\n-  104:     public RegionByLine createRegion(int beginLine, int beginColumn, int endLine, int endColumn) {\n-  105:         // TODO checks, positioner should return -1\n-  106:         return TextRegion.newRegionByLine(beginLine, beginColumn, endLine, endColumn);\n-  107:     }\n-  114:         }\n-  115: \n-  116: \n-  117:         return new RegionByOffsetImp(offset, length);\n+  103:     }\n+  104: \n+  105:     @Override\n+  106:     public RegionByOffset mapToOffset(RegionByLine region) {\n+  107:         int offset = positioner.offsetFromLineColumn(region.getBeginLine(), region.getBeginColumn());\n+  114:     @Override\n+  115:     public RegionByLine createRegion(int beginLine, int beginColumn, int endLine, int endColumn) {\n+  116:         // TODO checks, positioner should return -1\n+  117:         return new RegionByLineImpl(beginLine, beginColumn, endLine, endColumn);\n   118:     }\n", "uniqueId": "a733da4dcfa19b80f21480040aaf701e72e51bb5_103_107__114_118_28_30", "moveFileExist": true, "testResult": true, "coverageInfo": {"INSTRUCTION": {"missed": 0, "covered": 8}, "LINE": {"missed": 0, "covered": 1}, "COMPLEXITY": {"missed": 0, "covered": 1}, "METHOD": {"missed": 0, "covered": 1}}, "compileResultBefore": true, "compileResultCurrent": true, "compileJDK": 11, "refactoringMinerResult": false, "compileAndTestResult": false, "refactoredCode": "To perform the refactoring operation of \"Move And Inline Method\" on the provided code, we will analyze the `DocumentImpl` class and identify a method that can be inlined into the constructor. The constructor currently initializes the `positioner` variable with a new instance of `SourceCodePositioner`. \n\nSince the `SourceCodePositioner` is only used in the constructor and does not have any complex logic, we can inline its initialization directly into the constructor. \n\nHere\u2019s the refactored code:\n\n### Refactored Code\n\n```java\npackage net.sourceforge.pmd.document;\n\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.SortedMap;\nimport java.util.TreeMap;\n\nimport net.sourceforge.pmd.document.TextRegion.RegionByLine;\nimport net.sourceforge.pmd.document.TextRegion.RegionByOffset;\nimport net.sourceforge.pmd.lang.ast.SourceCodePositioner;\n\nclass DocumentImpl implements MutableDocument {\n\n    private ReplaceFunction out;\n    /** The positioner has the original source file. */\n    private SourceCodePositioner positioner;\n    private SortedMap<Integer, Integer> accumulatedOffsets = new TreeMap<>();\n\n    public DocumentImpl(final String source, final ReplaceFunction writer) {\n        this.out = writer;\n        this.positioner = new SourceCodePositioner(source); // Inlined initialization\n    }\n\n    @Override\n    public void insert(int beginLine, int beginColumn, final String textToInsert) {\n        insert(positioner.offsetFromLineColumn(beginLine, beginColumn), textToInsert);\n    }\n\n    @Override\n    public void insert(int offset, String textToInsert) {\n        replace(createRegion(offset, 0), textToInsert);\n    }\n\n    @Override\n    public void delete(final TextRegion region) {\n        replace(region, \"\");\n    }\n\n    @Override\n    public void replace(final TextRegion region, final String textToReplace) {\n        RegionByOffset off = region.toOffset(this);\n        RegionByOffset realPos = shiftOffset(off, textToReplace.length() - off.getLength());\n        out.replace(realPos, textToReplace);\n    }\n\n    private RegionByOffset shiftOffset(RegionByOffset origCoords, int lenDiff) {\n        ArrayList<Integer> keys = new ArrayList<>(accumulatedOffsets.keySet());\n        int idx = Collections.binarySearch(keys, origCoords.getOffset());\n\n        if (idx < 0) {\n            idx = -(idx + 1);\n        } else {\n            idx++;\n        }\n\n        int shift = 0;\n        for (int i = 0; i < idx; i++) {\n            shift += accumulatedOffsets.get(keys.get(i));\n        }\n\n        RegionByOffset realPos = shift == 0\n                                 ? origCoords\n                                 : new RegionByOffsetImp(origCoords.getOffset() + shift, origCoords.getLength());\n\n        accumulatedOffsets.compute(origCoords.getOffset(), (k, v) -> {\n            int s = v == null ? lenDiff : v + lenDiff;\n            return s == 0 ? null : s; // delete mapping if shift is 0\n        });\n\n        return realPos;\n    }\n\n    @Override\n    public RegionByLine mapToLine(RegionByOffset region) {\n        int bline = positioner.lineNumberFromOffset(region.getOffset());\n        int bcol = positioner.columnFromOffset(bline, region.getOffset());\n        int eline = positioner.lineNumberFromOffset(region.getOffsetAfterEnding());\n        int ecol = positioner.columnFromOffset(eline, region.getOffsetAfterEnding());\n\n        return createRegion(bline, bcol, eline, ecol);\n    }\n\n    @Override\n    public RegionByOffset mapToOffset(RegionByLine region) {\n        int offset = positioner.offsetFromLineColumn(region.getBeginLine(), region.getBeginColumn());\n        int len = positioner.offsetFromLineColumn(region.getEndLine(), region.getEndColumn())\n            - offset;\n\n        return createRegion(offset, len);\n    }\n\n    @Override\n    public RegionByLine createRegion(int beginLine, int beginColumn, int endLine, int endColumn) {\n        return TextRegion.newRegionByLine(beginLine, beginColumn, endLine, endColumn);\n    }\n\n    @Override\n    public RegionByOffset createRegion(int offset, int length) {\n        if (offset < 0 || offset + length > positioner.getSourceCode().length()) {\n            throw new IndexOutOfBoundsException(\n                \"Region (\" + offset + \",+\" + length + \") is not in range of this document\");\n        }\n\n        return new RegionByOffsetImp(offset, length);\n    }\n\n    @Override\n    public CharSequence getText() {\n        return positioner.getSourceCode();\n    }\n\n    @Override\n    public CharSequence subSequence(TextRegion region) {\n        RegionByOffset byOffset = region.toOffset(this);\n        return getText().subSequence(byOffset.getOffset(), byOffset.getOffsetAfterEnding());\n    }\n\n    @Override\n    public CharSequence getUncommittedText() {\n        return out.getCurrentText(this);\n    }\n\n    @Override\n    public void close() throws IOException {\n        out = out.commit();\n        positioner = new SourceCodePositioner(out.getCurrentText(this).toString());\n        accumulatedOffsets = new TreeMap<>();\n    }\n}\n```\n\n### Target File Path\n`pmd-core/src/main/java/net/sourceforge/pmd/document/DocumentImpl.java`", "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to Refactor:\npositioner = new SourceCodePositioner(source);\n    }\n\nClass content:\n/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.document;\n\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.SortedMap;\nimport java.util.TreeMap;\n\nimport net.sourceforge.pmd.document.TextRegion.RegionByLine;\nimport net.sourceforge.pmd.document.TextRegion.RegionByOffset;\nimport net.sourceforge.pmd.lang.ast.SourceCodePositioner;\n\n\nclass DocumentImpl implements MutableDocument {\n\n    private ReplaceFunction out;\n    /** The positioner has the original source file. */\n    private SourceCodePositioner positioner;\n    private SortedMap<Integer, Integer> accumulatedOffsets = new TreeMap<>();\n\n\n    public DocumentImpl(final String source, final ReplaceFunction writer) {\n        this.out = writer;\n        positioner = new SourceCodePositioner(source);\n    }\n\n    @Override\n    public void insert(int beginLine, int beginColumn, final String textToInsert) {\n        insert(positioner.offsetFromLineColumn(beginLine, beginColumn), textToInsert);\n    }\n\n    @Override\n    public void insert(int offset, String textToInsert) {\n        replace(createRegion(offset, 0), textToInsert);\n    }\n\n\n    @Override\n    public void delete(final TextRegion region) {\n        replace(region, \"\");\n    }\n\n    @Override\n    public void replace(final TextRegion region, final String textToReplace) {\n        RegionByOffset off = region.toOffset(this);\n\n        RegionByOffset realPos = shiftOffset(off, textToReplace.length() - off.getLength());\n\n        out.replace(realPos, textToReplace);\n    }\n\n    private RegionByOffset shiftOffset(RegionByOffset origCoords, int lenDiff) {\n        ArrayList<Integer> keys = new ArrayList<>(accumulatedOffsets.keySet());\n        int idx = Collections.binarySearch(keys, origCoords.getOffset());\n\n        if (idx < 0) {\n            idx = -(idx + 1);\n        } else {\n            idx++;\n        }\n\n        int shift = 0;\n        for (int i = 0; i < idx; i++) {\n            shift += accumulatedOffsets.get(keys.get(i));\n        }\n\n        RegionByOffset realPos = shift == 0\n                                 ? origCoords\n                                 // don't check it\n                                 : new RegionByOffsetImp(origCoords.getOffset() + shift, origCoords.getLength());\n\n        accumulatedOffsets.compute(origCoords.getOffset(), (k, v) -> {\n            int s = v == null ? lenDiff : v + lenDiff;\n            return s == 0 ? null : s; // delete mapping if shift is 0\n        });\n\n        return realPos;\n    }\n\n    @Override\n    public RegionByLine mapToLine(RegionByOffset region) {\n        int bline = positioner.lineNumberFromOffset(region.getOffset());\n        int bcol = positioner.columnFromOffset(bline, region.getOffset());\n        int eline = positioner.lineNumberFromOffset(region.getOffsetAfterEnding());\n        int ecol = positioner.columnFromOffset(eline, region.getOffsetAfterEnding());\n\n        return createRegion(bline, bcol, eline, ecol);\n    }\n\n    @Override\n    public RegionByOffset mapToOffset(RegionByLine region) {\n        int offset = positioner.offsetFromLineColumn(region.getBeginLine(), region.getBeginColumn());\n        int len = positioner.offsetFromLineColumn(region.getEndLine(), region.getEndColumn())\n            - offset;\n\n        return createRegion(offset, len);\n    }\n\n    @Override\n    public RegionByLine createRegion(int beginLine, int beginColumn, int endLine, int endColumn) {\n        // TODO checks, positioner should return -1\n        return TextRegion.newRegionByLine(beginLine, beginColumn, endLine, endColumn);\n    }\n\n    @Override\n    public RegionByOffset createRegion(int offset, int length) {\n        if (offset < 0 || offset + length > positioner.getSourceCode().length()) {\n            throw new IndexOutOfBoundsException(\n                \"Region (\" + offset + \",+\" + length + \") is not in range of this document\");\n        }\n\n\n        return new RegionByOffsetImp(offset, length);\n    }\n\n    @Override\n    public CharSequence getText() {\n        return positioner.getSourceCode();\n    }\n\n    @Override\n    public CharSequence subSequence(TextRegion region) {\n        RegionByOffset byOffset = region.toOffset(this);\n        return getText().subSequence(byOffset.getOffset(), byOffset.getOffsetAfterEnding());\n    }\n\n    @Override\n    public CharSequence getUncommittedText() {\n        return out.getCurrentText(this);\n    }\n\n    @Override\n    public void close() throws IOException {\n        out = out.commit();\n        positioner = new SourceCodePositioner(out.getCurrentText(this).toString());\n        accumulatedOffsets = new TreeMap<>();\n    }\n\n}\n\nRefactoring Operation:\nMove And Inline Method\n\nProject Structure:\n['pmd-core/src/main/java/net/sourceforge/pmd/AbstractConfiguration.java', 'pmd-core/src/main/java/net/sourceforge/pmd/PMD.java', 'pmd-core/src/main/java/net/sourceforge/pmd/PMDConfiguration.java', 'pmd-core/src/main/java/net/sourceforge/pmd/PMDVersion.java', 'pmd-core/src/main/java/net/sourceforge/pmd/Report.java', 'pmd-core/src/main/java/net/sourceforge/pmd/Rule.java', 'pmd-core/src/main/java/net/sourceforge/pmd/RuleContext.java', 'pmd-core/src/main/java/net/sourceforge/pmd/RulePriority.java', 'pmd-core/src/main/java/net/sourceforge/pmd/RuleSet.java', 'pmd-core/src/main/java/net/sourceforge/pmd/RuleSetFactory.java', 'pmd-core/src/main/java/net/sourceforge/pmd/RuleSetFactoryCompatibility.java', 'pmd-core/src/main/java/net/sourceforge/pmd/RuleSetNotFoundException.java', 'pmd-core/src/main/java/net/sourceforge/pmd/RuleSetReference.java', 'pmd-core/src/main/java/net/sourceforge/pmd/RuleSetReferenceId.java', 'pmd-core/src/main/java/net/sourceforge/pmd/RuleSetWriter.java', 'pmd-core/src/main/java/net/sourceforge/pmd/RuleSets.java', 'pmd-core/src/main/java/net/sourceforge/pmd/RuleViolation.java', 'pmd-core/src/main/java/net/sourceforge/pmd/RulesetsFactoryUtils.java', 'pmd-core/src/main/java/net/sourceforge/pmd/ViolationSuppressor.java', 'pmd-core/src/main/java/net/sourceforge/pmd/annotation/DeprecatedUntil700.java', 'pmd-core/src/main/java/net/sourceforge/pmd/annotation/Experimental.java', 'pmd-core/src/main/java/net/sourceforge/pmd/annotation/InternalApi.java', 'pmd-core/src/main/java/net/sourceforge/pmd/annotation/ReservedSubclassing.java', 'pmd-core/src/main/java/net/sourceforge/pmd/ant/Formatter.java', 'pmd-core/src/main/java/net/sourceforge/pmd/ant/PMDTask.java', 'pmd-core/src/main/java/net/sourceforge/pmd/ant/RuleSetWrapper.java', 'pmd-core/src/main/java/net/sourceforge/pmd/ant/SourceLanguage.java', 'pmd-core/src/main/java/net/sourceforge/pmd/ant/internal/PMDTaskImpl.java', 'pmd-core/src/main/java/net/sourceforge/pmd/benchmark/TextTimingReportRenderer.java', 'pmd-core/src/main/java/net/sourceforge/pmd/benchmark/TimeTracker.java', 'pmd-core/src/main/java/net/sourceforge/pmd/benchmark/TimedOperation.java', 'pmd-core/src/main/java/net/sourceforge/pmd/benchmark/TimedOperationCategory.java', 'pmd-core/src/main/java/net/sourceforge/pmd/benchmark/TimingReport.java', 'pmd-core/src/main/java/net/sourceforge/pmd/benchmark/TimingReportRenderer.java', 'pmd-core/src/main/java/net/sourceforge/pmd/cache/AbstractAnalysisCache.java', 'pmd-core/src/main/java/net/sourceforge/pmd/cache/AnalysisCache.java', 'pmd-core/src/main/java/net/sourceforge/pmd/cache/AnalysisResult.java', 'pmd-core/src/main/java/net/sourceforge/pmd/cache/CachedRuleMapper.java', 'pmd-core/src/main/java/net/sourceforge/pmd/cache/CachedRuleViolation.java', 'pmd-core/src/main/java/net/sourceforge/pmd/cache/ChecksumAware.java', 'pmd-core/src/main/java/net/sourceforge/pmd/cache/FileAnalysisCache.java', 'pmd-core/src/main/java/net/sourceforge/pmd/cache/NoopAnalysisCache.java', 'pmd-core/src/main/java/net/sourceforge/pmd/cache/package-info.java', 'pmd-core/src/main/java/net/sourceforge/pmd/cli/PMDCommandLineInterface.java', 'pmd-core/src/main/java/net/sourceforge/pmd/cli/PMDParameters.java', 'pmd-core/src/main/java/net/sourceforge/pmd/cpd/AbstractLanguage.java', 'pmd-core/src/main/java/net/sourceforge/pmd/cpd/AbstractTokenizer.java', 'pmd-core/src/main/java/net/sourceforge/pmd/cpd/AnyLanguage.java', 'pmd-core/src/main/java/net/sourceforge/pmd/cpd/AnyTokenizer.java', 'pmd-core/src/main/java/net/sourceforge/pmd/cpd/CPD.java', 'pmd-core/src/main/java/net/sourceforge/pmd/cpd/CPDCommandLineInterface.java', 'pmd-core/src/main/java/net/sourceforge/pmd/cpd/CPDConfiguration.java', 'pmd-core/src/main/java/net/sourceforge/pmd/cpd/CPDListener.java', 'pmd-core/src/main/java/net/sourceforge/pmd/cpd/CPDNullListener.java', 'pmd-core/src/main/java/net/sourceforge/pmd/cpd/CPDTask.java', 'pmd-core/src/main/java/net/sourceforge/pmd/cpd/CSVRenderer.java', 'pmd-core/src/main/java/net/sourceforge/pmd/cpd/CSVWithLinecountPerFileRenderer.java', 'pmd-core/src/main/java/net/sourceforge/pmd/cpd/FileReporter.java', 'pmd-core/src/main/java/net/sourceforge/pmd/cpd/GUI.java', 'pmd-core/src/main/java/net/sourceforge/pmd/cpd/GridBagHelper.java', 'pmd-core/src/main/java/net/sourceforge/pmd/cpd/Language.java', 'pmd-core/src/main/java/net/sourceforge/pmd/cpd/LanguageFactory.java', 'pmd-core/src/main/java/net/sourceforge/pmd/cpd/Mark.java', 'pmd-core/src/main/java/net/sourceforge/pmd/cpd/Match.java', 'pmd-core/src/main/java/net/sourceforge/pmd/cpd/MatchAlgorithm.java', 'pmd-core/src/main/java/net/sourceforge/pmd/cpd/MatchCollector.java', 'pmd-core/src/main/java/net/sourceforge/pmd/cpd/Renderer.java', 'pmd-core/src/main/java/net/sourceforge/pmd/cpd/ReportException.java', 'pmd-core/src/main/java/net/sourceforge/pmd/cpd/SimpleRenderer.java', 'pmd-core/src/main/java/net/sourceforge/pmd/cpd/SourceCode.java', 'pmd-core/src/main/java/net/sourceforge/pmd/cpd/TokenEntry.java', 'pmd-core/src/main/java/net/sourceforge/pmd/cpd/Tokenizer.java', 'pmd-core/src/main/java/net/sourceforge/pmd/cpd/Tokens.java', 'pmd-core/src/main/java/net/sourceforge/pmd/cpd/VSRenderer.java', 'pmd-core/src/main/java/net/sourceforge/pmd/cpd/XMLRenderer.java', 'pmd-core/src/main/java/net/sourceforge/pmd/cpd/internal/AntlrTokenizer.java', 'pmd-core/src/main/java/net/sourceforge/pmd/cpd/internal/JavaCCTokenizer.java', 'pmd-core/src/main/java/net/sourceforge/pmd/cpd/renderer/CPDRenderer.java', 'pmd-core/src/main/java/net/sourceforge/pmd/cpd/token/AntlrTokenFilter.java', 'pmd-core/src/main/java/net/sourceforge/pmd/cpd/token/JavaCCTokenFilter.java', 'pmd-core/src/main/java/net/sourceforge/pmd/cpd/token/TokenFilter.java', 'pmd-core/src/main/java/net/sourceforge/pmd/cpd/token/internal/BaseTokenFilter.java', 'pmd-core/src/main/java/net/sourceforge/pmd/document/Document.java', 'pmd-core/src/main/java/net/sourceforge/pmd/document/DocumentImpl.java', 'pmd-core/src/main/java/net/sourceforge/pmd/document/MutableDocument.java', 'pmd-core/src/main/java/net/sourceforge/pmd/document/RegionByLineImp.java', 'pmd-core/src/main/java/net/sourceforge/pmd/document/RegionByOffsetImp.java', 'pmd-core/src/main/java/net/sourceforge/pmd/document/ReplaceFunction.java', 'pmd-core/src/main/java/net/sourceforge/pmd/document/TextRegion.java', 'pmd-core/src/main/java/net/sourceforge/pmd/internal/GraphUtils.java', 'pmd-core/src/main/java/net/sourceforge/pmd/internal/RulesetStageDependencyHelper.java', 'pmd-core/src/main/java/net/sourceforge/pmd/internal/util/AssertionUtil.java', 'pmd-core/src/main/java/net/sourceforge/pmd/internal/util/FileExtensionFilter.java', 'pmd-core/src/main/java/net/sourceforge/pmd/internal/util/IteratorUtil.java', 'pmd-core/src/main/java/net/sourceforge/pmd/internal/util/PredicateUtil.java', 'pmd-core/src/main/java/net/sourceforge/pmd/internal/util/ShortFilenameUtil.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/AbstractLanguageVersionHandler.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/AbstractPmdLanguageVersionHandler.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/BaseLanguageModule.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/Language.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/LanguageFilenameFilter.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/LanguageRegistry.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/LanguageVersion.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/LanguageVersionDiscoverer.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/LanguageVersionHandler.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/Parser.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/ParserOptions.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/TokenManager.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/AbstractTokenManager.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/AstAnalysisContext.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/AstProcessingStage.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/AstVisitor.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/AstVisitorBase.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/CharStream.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/FileAnalysisException.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/GenericToken.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/Node.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/NodeStream.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/ParseException.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/RootNode.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/SemanticErrorReporter.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/SemanticException.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/SignedNode.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/SourceCodePositioner.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/TextAvailableNode.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/TokenMgrError.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/impl/AbstractNode.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/impl/AbstractNodeWithTextCoordinates.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/impl/GenericNode.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/impl/TokenDocument.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/impl/antlr4/AntlrBaseParser.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/impl/antlr4/AntlrBaseRule.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/impl/antlr4/AntlrGeneratedParserBase.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/impl/antlr4/AntlrNameDictionary.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/impl/antlr4/AntlrNode.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/impl/antlr4/AntlrToken.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/impl/antlr4/AntlrTokenManager.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/impl/antlr4/BaseAntlrErrorNode.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/impl/antlr4/BaseAntlrInnerNode.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/impl/antlr4/BaseAntlrNode.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/impl/antlr4/BaseAntlrTerminalNode.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/impl/javacc/AbstractJjtreeNode.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/impl/javacc/CharStreamFactory.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/impl/javacc/JavaCharStream.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/impl/javacc/JavaccToken.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/impl/javacc/JavaccTokenDocument.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/impl/javacc/JjtreeBuilder.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/impl/javacc/JjtreeNode.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/impl/javacc/JjtreeParserAdapter.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/impl/javacc/SimpleCharStream.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/impl/javacc/package-info.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/internal/AncestorOrSelfIterator.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/internal/AxisStream.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/internal/Filtermap.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/internal/GreedyNStream.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/internal/IteratorBasedNStream.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/internal/SingletonNodeStream.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/internal/StreamImpl.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/internal/TraversalUtils.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/internal/TreeWalker.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/metrics/AbstractMetric.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/metrics/LanguageMetricsProvider.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/metrics/Metric.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/metrics/MetricKey.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/metrics/MetricOption.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/metrics/MetricOptions.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/metrics/MetricsUtil.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/metrics/ParameterizedMetricKey.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/metrics/SigMask.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/metrics/Signature.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/metrics/internal/AbstractLanguageMetricsProvider.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/metrics/package-info.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/rule/AbstractDelegateRule.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/rule/AbstractRule.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/rule/ParametricRuleViolation.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/rule/RuleReference.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/rule/RuleTargetSelector.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/rule/RuleViolationFactory.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/rule/XPathRule.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/rule/impl/DefaultRuleViolationFactory.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/rule/internal/CommonPropertyDescriptors.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/rule/internal/LatticeRelation.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/rule/internal/RuleApplicator.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/rule/internal/TargetSelectorInternal.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/rule/internal/TopoOrder.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/rule/internal/TreeIndex.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/rule/xpath/Attribute.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/rule/xpath/DeprecatedAttribute.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/rule/xpath/NoAttribute.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/rule/xpath/XPathVersion.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/rule/xpath/impl/AbstractXPathFunctionDef.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/rule/xpath/impl/AttributeAxisIterator.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/rule/xpath/impl/XPathHandler.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/rule/xpath/internal/AstAttributeNode.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/rule/xpath/internal/AstDocumentNode.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/rule/xpath/internal/AstElementNode.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/rule/xpath/internal/AstTreeInfo.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/rule/xpath/internal/BaseNodeInfo.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/rule/xpath/internal/DeprecatedAttrLogger.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/rule/xpath/internal/DomainConversion.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/rule/xpath/internal/ExpressionPrinter.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/rule/xpath/internal/PmdDocumentSorter.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/rule/xpath/internal/RuleChainAnalyzer.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/rule/xpath/internal/SaxonExprVisitor.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/rule/xpath/internal/SaxonXPathRuleQuery.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/rule/xpath/internal/SplitUnions.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/symboltable/AbstractNameDeclaration.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/symboltable/AbstractScope.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/symboltable/Applier.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/symboltable/ImageFinderFunction.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/symboltable/NameDeclaration.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/symboltable/NameOccurrence.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/symboltable/Scope.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/symboltable/ScopedNode.java', 'pmd-core/src/main/java/net/sourceforge/pmd/processor/AbstractPMDProcessor.java', 'pmd-core/src/main/java/net/sourceforge/pmd/processor/MonoThreadProcessor.java', 'pmd-core/src/main/java/net/sourceforge/pmd/processor/MultiThreadProcessor.java', 'pmd-core/src/main/java/net/sourceforge/pmd/processor/PmdRunnable.java', 'pmd-core/src/main/java/net/sourceforge/pmd/processor/PmdThreadFactory.java', 'pmd-core/src/main/java/net/sourceforge/pmd/properties/AbstractMultiNumericProperty.java', 'pmd-core/src/main/java/net/sourceforge/pmd/properties/AbstractMultiValueProperty.java', 'pmd-core/src/main/java/net/sourceforge/pmd/properties/AbstractNumericProperty.java', 'pmd-core/src/main/java/net/sourceforge/pmd/properties/AbstractProperty.java', 'pmd-core/src/main/java/net/sourceforge/pmd/properties/AbstractPropertySource.java', 'pmd-core/src/main/java/net/sourceforge/pmd/properties/AbstractSingleValueProperty.java', 'pmd-core/src/main/java/net/sourceforge/pmd/properties/BooleanMultiProperty.java', 'pmd-core/src/main/java/net/sourceforge/pmd/properties/BooleanProperty.java', 'pmd-core/src/main/java/net/sourceforge/pmd/properties/CharacterMultiProperty.java', 'pmd-core/src/main/java/net/sourceforge/pmd/properties/CharacterProperty.java', 'pmd-core/src/main/java/net/sourceforge/pmd/properties/DoubleMultiProperty.java', 'pmd-core/src/main/java/net/sourceforge/pmd/properties/DoubleProperty.java', 'pmd-core/src/main/java/net/sourceforge/pmd/properties/EnumeratedMultiProperty.java', 'pmd-core/src/main/java/net/sourceforge/pmd/properties/EnumeratedProperty.java', 'pmd-core/src/main/java/net/sourceforge/pmd/properties/EnumeratedPropertyDescriptor.java', 'pmd-core/src/main/java/net/sourceforge/pmd/properties/FileProperty.java', 'pmd-core/src/main/java/net/sourceforge/pmd/properties/FloatMultiProperty.java', 'pmd-core/src/main/java/net/sourceforge/pmd/properties/FloatProperty.java', 'pmd-core/src/main/java/net/sourceforge/pmd/properties/GenericMultiValuePropertyDescriptor.java', 'pmd-core/src/main/java/net/sourceforge/pmd/properties/GenericPropertyDescriptor.java', 'pmd-core/src/main/java/net/sourceforge/pmd/properties/IntegerMultiProperty.java', 'pmd-core/src/main/java/net/sourceforge/pmd/properties/IntegerProperty.java', 'pmd-core/src/main/java/net/sourceforge/pmd/properties/LongMultiProperty.java', 'pmd-core/src/main/java/net/sourceforge/pmd/properties/LongProperty.java', 'pmd-core/src/main/java/net/sourceforge/pmd/properties/MultiValuePropertyDescriptor.java', 'pmd-core/src/main/java/net/sourceforge/pmd/properties/NumericPropertyDescriptor.java', 'pmd-core/src/main/java/net/sourceforge/pmd/properties/PropertyBuilder.java', 'pmd-core/src/main/java/net/sourceforge/pmd/properties/PropertyDescriptor.java', 'pmd-core/src/main/java/net/sourceforge/pmd/properties/PropertyDescriptorField.java', 'pmd-core/src/main/java/net/sourceforge/pmd/properties/PropertyFactory.java', 'pmd-core/src/main/java/net/sourceforge/pmd/properties/PropertySource.java', 'pmd-core/src/main/java/net/sourceforge/pmd/properties/PropertyTypeId.java', 'pmd-core/src/main/java/net/sourceforge/pmd/properties/RegexProperty.java', 'pmd-core/src/main/java/net/sourceforge/pmd/properties/SingleValuePropertyDescriptor.java', 'pmd-core/src/main/java/net/sourceforge/pmd/properties/StringMultiProperty.java', 'pmd-core/src/main/java/net/sourceforge/pmd/properties/StringProperty.java', 'pmd-core/src/main/java/net/sourceforge/pmd/properties/ValueParser.java', 'pmd-core/src/main/java/net/sourceforge/pmd/properties/ValueParserConstants.java', 'pmd-core/src/main/java/net/sourceforge/pmd/properties/builders/MultiNumericPropertyBuilder.java', 'pmd-core/src/main/java/net/sourceforge/pmd/properties/builders/MultiPackagedPropertyBuilder.java', 'pmd-core/src/main/java/net/sourceforge/pmd/properties/builders/MultiValuePropertyBuilder.java', 'pmd-core/src/main/java/net/sourceforge/pmd/properties/builders/PropertyDescriptorBuilder.java', 'pmd-core/src/main/java/net/sourceforge/pmd/properties/builders/PropertyDescriptorBuilderConversionWrapper.java', 'pmd-core/src/main/java/net/sourceforge/pmd/properties/builders/PropertyDescriptorExternalBuilder.java', 'pmd-core/src/main/java/net/sourceforge/pmd/properties/builders/SingleNumericPropertyBuilder.java', 'pmd-core/src/main/java/net/sourceforge/pmd/properties/builders/SinglePackagedPropertyBuilder.java', 'pmd-core/src/main/java/net/sourceforge/pmd/properties/builders/SingleValuePropertyBuilder.java', 'pmd-core/src/main/java/net/sourceforge/pmd/properties/constraints/NumericConstraints.java', 'pmd-core/src/main/java/net/sourceforge/pmd/properties/constraints/PropertyConstraint.java', 'pmd-core/src/main/java/net/sourceforge/pmd/properties/modules/EnumeratedPropertyModule.java', 'pmd-core/src/main/java/net/sourceforge/pmd/properties/modules/NumericPropertyModule.java', 'pmd-core/src/main/java/net/sourceforge/pmd/renderers/AbstractAccumulatingRenderer.java', 'pmd-core/src/main/java/net/sourceforge/pmd/renderers/AbstractIncrementingRenderer.java', 'pmd-core/src/main/java/net/sourceforge/pmd/renderers/AbstractRenderer.java', 'pmd-core/src/main/java/net/sourceforge/pmd/renderers/CSVRenderer.java', 'pmd-core/src/main/java/net/sourceforge/pmd/renderers/CSVWriter.java', 'pmd-core/src/main/java/net/sourceforge/pmd/renderers/CodeClimateIssue.java', 'pmd-core/src/main/java/net/sourceforge/pmd/renderers/CodeClimateRenderer.java', 'pmd-core/src/main/java/net/sourceforge/pmd/renderers/ColumnDescriptor.java', 'pmd-core/src/main/java/net/sourceforge/pmd/renderers/EmacsRenderer.java', 'pmd-core/src/main/java/net/sourceforge/pmd/renderers/EmptyRenderer.java', 'pmd-core/src/main/java/net/sourceforge/pmd/renderers/HTMLRenderer.java', 'pmd-core/src/main/java/net/sourceforge/pmd/renderers/IDEAJRenderer.java', 'pmd-core/src/main/java/net/sourceforge/pmd/renderers/JsonRenderer.java', 'pmd-core/src/main/java/net/sourceforge/pmd/renderers/Renderer.java', 'pmd-core/src/main/java/net/sourceforge/pmd/renderers/RendererFactory.java', 'pmd-core/src/main/java/net/sourceforge/pmd/renderers/SummaryHTMLRenderer.java', 'pmd-core/src/main/java/net/sourceforge/pmd/renderers/TextColorRenderer.java', 'pmd-core/src/main/java/net/sourceforge/pmd/renderers/TextPadRenderer.java', 'pmd-core/src/main/java/net/sourceforge/pmd/renderers/TextRenderer.java', 'pmd-core/src/main/java/net/sourceforge/pmd/renderers/VBHTMLRenderer.java', 'pmd-core/src/main/java/net/sourceforge/pmd/renderers/XMLRenderer.java', 'pmd-core/src/main/java/net/sourceforge/pmd/renderers/XSLTRenderer.java', 'pmd-core/src/main/java/net/sourceforge/pmd/renderers/YAHTMLRenderer.java', 'pmd-core/src/main/java/net/sourceforge/pmd/reporting/FileAnalysisListener.java', 'pmd-core/src/main/java/net/sourceforge/pmd/reporting/GlobalAnalysisListener.java', 'pmd-core/src/main/java/net/sourceforge/pmd/reporting/NoopFileListener.java', 'pmd-core/src/main/java/net/sourceforge/pmd/rules/RuleBuilder.java', 'pmd-core/src/main/java/net/sourceforge/pmd/rules/RuleFactory.java', 'pmd-core/src/main/java/net/sourceforge/pmd/util/BaseResultProducingCloseable.java', 'pmd-core/src/main/java/net/sourceforge/pmd/util/ClasspathClassLoader.java', 'pmd-core/src/main/java/net/sourceforge/pmd/util/CollectionUtil.java', 'pmd-core/src/main/java/net/sourceforge/pmd/util/CompoundIterator.java', 'pmd-core/src/main/java/net/sourceforge/pmd/util/ConsList.java', 'pmd-core/src/main/java/net/sourceforge/pmd/util/DataMap.java', 'pmd-core/src/main/java/net/sourceforge/pmd/util/FileFinder.java', 'pmd-core/src/main/java/net/sourceforge/pmd/util/FileUtil.java', 'pmd-core/src/main/java/net/sourceforge/pmd/util/IOUtil.java', 'pmd-core/src/main/java/net/sourceforge/pmd/util/OptionalBool.java', 'pmd-core/src/main/java/net/sourceforge/pmd/util/ResourceLoader.java', 'pmd-core/src/main/java/net/sourceforge/pmd/util/StringUtil.java', 'pmd-core/src/main/java/net/sourceforge/pmd/util/database/DBMSMetadata.java', 'pmd-core/src/main/java/net/sourceforge/pmd/util/database/DBType.java', 'pmd-core/src/main/java/net/sourceforge/pmd/util/database/DBURI.java', 'pmd-core/src/main/java/net/sourceforge/pmd/util/database/ResourceLoader.java', 'pmd-core/src/main/java/net/sourceforge/pmd/util/database/ResourceResolver.java', 'pmd-core/src/main/java/net/sourceforge/pmd/util/database/SourceObject.java', 'pmd-core/src/main/java/net/sourceforge/pmd/util/datasource/DataSource.java', 'pmd-core/src/main/java/net/sourceforge/pmd/util/datasource/FileDataSource.java', 'pmd-core/src/main/java/net/sourceforge/pmd/util/datasource/ReaderDataSource.java', 'pmd-core/src/main/java/net/sourceforge/pmd/util/datasource/ZipDataSource.java', 'pmd-core/src/main/java/net/sourceforge/pmd/util/datasource/internal/AbstractDataSource.java', 'pmd-core/src/main/java/net/sourceforge/pmd/util/designerbindings/DesignerBindings.java', 'pmd-core/src/main/java/net/sourceforge/pmd/util/designerbindings/RelatedNodesSelector.java', 'pmd-core/src/main/java/net/sourceforge/pmd/util/log/AntLogHandler.java', 'pmd-core/src/main/java/net/sourceforge/pmd/util/log/ConsoleLogHandler.java', 'pmd-core/src/main/java/net/sourceforge/pmd/util/log/PmdLogFormatter.java', 'pmd-core/src/main/java/net/sourceforge/pmd/util/log/ScopedLogHandlersManager.java', 'pmd-core/src/main/java/net/sourceforge/pmd/util/treeexport/TextTreeRenderer.java', 'pmd-core/src/main/java/net/sourceforge/pmd/util/treeexport/TreeExportCli.java', 'pmd-core/src/main/java/net/sourceforge/pmd/util/treeexport/TreeRenderer.java', 'pmd-core/src/main/java/net/sourceforge/pmd/util/treeexport/TreeRendererDescriptor.java', 'pmd-core/src/main/java/net/sourceforge/pmd/util/treeexport/TreeRendererDescriptorImpl.java', 'pmd-core/src/main/java/net/sourceforge/pmd/util/treeexport/TreeRenderers.java', 'pmd-core/src/main/java/net/sourceforge/pmd/util/treeexport/XmlTreeRenderer.java']\n\nInstructions:\n1. Analyze the provided code, class content, and project structure, apply relevant refactoring operation to the code to be refactored, output the target file path.\n2. If refactoring is performed, output the refactored class code in the following format:\n$target_file_path$:\n$refactored_class_code$:\n\n\n"}, {"type": "Move And Inline Method", "description": "Move And Inline Method\tpublic reportError(error ProcessingError) : void moved from class net.sourceforge.pmd.RuleContext to class net.sourceforge.pmd.processor.PmdRunnable & inlined to public run() : void", "diffLocations": [{"filePath": "pmd-core/src/main/java/net/sourceforge/pmd/processor/PmdRunnable.java", "startLine": 63, "endLine": 98, "startColumn": 0, "endColumn": 0}, {"filePath": "pmd-core/src/main/java/net/sourceforge/pmd/processor/PmdRunnable.java", "startLine": 61, "endLine": 95, "startColumn": 0, "endColumn": 0}, {"filePath": "pmd-core/src/main/java/net/sourceforge/pmd/processor/PmdRunnable.java", "startLine": 45, "endLine": 47, "startColumn": 0, "endColumn": 0}], "sourceCodeBeforeRefactoring": "PMDConfiguration configuration) {\n        this.dataSource = dataSource;\n        // this is the real, canonical and absolute filename (not shortened)", "filePathBefore": "pmd-core/src/main/java/net/sourceforge/pmd/processor/PmdRunnable.java", "isPureRefactoring": true, "commitId": "0276320abf2c66cae14d2ad24e2b2fb0386943b3", "packageNameBefore": "net.sourceforge.pmd", "classNameBefore": "net.sourceforge.pmd.RuleContext", "methodNameBefore": "net.sourceforge.pmd.RuleContext#reportError", "classSignatureBefore": "public final class RuleContext ", "methodNameBeforeSet": ["net.sourceforge.pmd.RuleContext#reportError"], "classNameBeforeSet": ["net.sourceforge.pmd.RuleContext"], "classSignatureBeforeSet": ["public final class RuleContext "], "purityCheckResultList": [{"isPure": true, "purityComment": "Identical statements", "description": "There is no replacement! - all mapped", "mappingState": 1}], "sourceCodeBeforeForWhole": "/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.processor;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.Collections;\n\nimport net.sourceforge.pmd.PMDConfiguration;\nimport net.sourceforge.pmd.Report;\nimport net.sourceforge.pmd.RuleContext;\nimport net.sourceforge.pmd.RuleSets;\nimport net.sourceforge.pmd.RuleViolation;\nimport net.sourceforge.pmd.benchmark.TimeTracker;\nimport net.sourceforge.pmd.benchmark.TimedOperation;\nimport net.sourceforge.pmd.benchmark.TimedOperationCategory;\nimport net.sourceforge.pmd.internal.RulesetStageDependencyHelper;\nimport net.sourceforge.pmd.lang.LanguageVersion;\nimport net.sourceforge.pmd.lang.Parser;\nimport net.sourceforge.pmd.lang.Parser.ParserTask;\nimport net.sourceforge.pmd.lang.ast.FileAnalysisException;\nimport net.sourceforge.pmd.lang.ast.RootNode;\nimport net.sourceforge.pmd.lang.ast.SemanticErrorReporter;\nimport net.sourceforge.pmd.reporting.FileAnalysisListener;\nimport net.sourceforge.pmd.reporting.GlobalAnalysisListener;\nimport net.sourceforge.pmd.util.datasource.DataSource;\n\n/**\n * A processing task for a single file.\n */\nabstract class PmdRunnable implements Runnable {\n\n    private final DataSource dataSource;\n    private final File file;\n    private final GlobalAnalysisListener ruleContext;\n\n    private final PMDConfiguration configuration;\n\n    private final RulesetStageDependencyHelper dependencyHelper;\n\n    PmdRunnable(DataSource dataSource,\n                GlobalAnalysisListener ruleContext,\n                PMDConfiguration configuration) {\n        this.dataSource = dataSource;\n        // this is the real, canonical and absolute filename (not shortened)\n        String realFileName = dataSource.getNiceFileName(false, null);\n\n        this.file = new File(realFileName);\n        this.ruleContext = ruleContext;\n        this.configuration = configuration;\n        this.dependencyHelper = new RulesetStageDependencyHelper(configuration);\n    }\n\n    /**\n     * This is only called within the run method (when we are on the actual carrier thread).\n     * That way an implementation that uses a ThreadLocal will see the\n     * correct thread.\n     */\n    protected abstract RuleSets getRulesets();\n\n    @Override\n    public void run() throws FileAnalysisException {\n        TimeTracker.initThread();\n\n        RuleSets ruleSets = getRulesets();\n\n        try (FileAnalysisListener listener = ruleContext.startFileAnalysis(dataSource)) {\n            final RuleContext ruleCtx = RuleContext.create(listener);\n\n            LanguageVersion langVersion = configuration.getLanguageVersionOfFile(file.getPath());\n\n\n            // Coarse check to see if any RuleSet applies to file, will need to do a finer RuleSet specific check later\n            if (ruleSets.applies(file)) {\n                if (configuration.getAnalysisCache().isUpToDate(file)) {\n                    reportCachedRuleViolations(ruleCtx, file);\n                } else {\n                    try {\n                        processSource(ruleCtx, langVersion, ruleSets);\n                    } catch (Exception e) {\n                        configuration.getAnalysisCache().analysisFailed(file);\n\n                        // The listener handles logging if needed,\n                        // it may also rethrow the error, as a FileAnalysisException (which we let through below)\n                        ruleCtx.reportError(new Report.ProcessingError(e, file.getPath()));\n                    }\n                }\n            }\n        } catch (FileAnalysisException e) {\n            throw e; // bubble managed exceptions, they were already reported\n        } catch (Exception e) {\n            throw FileAnalysisException.wrap(file.getPath(), \"Exception while closing listener\", e);\n        }\n\n        TimeTracker.finishThread();\n    }\n\n    private void processSource(RuleContext ruleCtx, LanguageVersion languageVersion, RuleSets ruleSets) throws IOException, FileAnalysisException {\n        String fullSource = DataSource.readToString(dataSource, configuration.getSourceEncoding());\n        String filename = dataSource.getNiceFileName(false, null);\n\n        try {\n            ruleSets.start(ruleCtx);\n            processSource(fullSource, ruleSets, ruleCtx, languageVersion, filename);\n        } finally {\n            ruleSets.end(ruleCtx);\n        }\n\n    }\n\n\n    private void reportCachedRuleViolations(final RuleContext ctx, File file) {\n        for (final RuleViolation rv : configuration.getAnalysisCache().getCachedViolations(file)) {\n            ctx.addViolationNoSuppress(rv);\n        }\n    }\n\n    private RootNode parse(Parser parser, ParserTask task) {\n        try (TimedOperation to = TimeTracker.startOperation(TimedOperationCategory.PARSER)) {\n            return parser.parse(task);\n        }\n    }\n\n\n    private void processSource(String sourceCode,\n                               RuleSets ruleSets,\n                               RuleContext ctx,\n                               LanguageVersion languageVersion,\n                               String filename) throws FileAnalysisException {\n\n        ParserTask task = new ParserTask(\n            languageVersion,\n            filename,\n            sourceCode,\n            SemanticErrorReporter.noop(), // TODO\n            configuration.getSuppressMarker()\n        );\n\n        Parser parser = languageVersion.getLanguageVersionHandler().getParser();\n\n        RootNode rootNode = parse(parser, task);\n\n        dependencyHelper.runLanguageSpecificStages(ruleSets, languageVersion, rootNode);\n\n        ruleSets.apply(Collections.singletonList(rootNode), ctx);\n    }\n\n}\n", "filePathAfter": "pmd-core/src/main/java/net/sourceforge/pmd/processor/PmdRunnable.java", "sourceCodeAfterForWhole": "/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.processor;\n\nimport java.io.File;\nimport java.io.IOException;\n\nimport net.sourceforge.pmd.PMDConfiguration;\nimport net.sourceforge.pmd.Report;\nimport net.sourceforge.pmd.RuleSets;\nimport net.sourceforge.pmd.RuleViolation;\nimport net.sourceforge.pmd.benchmark.TimeTracker;\nimport net.sourceforge.pmd.benchmark.TimedOperation;\nimport net.sourceforge.pmd.benchmark.TimedOperationCategory;\nimport net.sourceforge.pmd.internal.RulesetStageDependencyHelper;\nimport net.sourceforge.pmd.lang.LanguageVersion;\nimport net.sourceforge.pmd.lang.Parser;\nimport net.sourceforge.pmd.lang.Parser.ParserTask;\nimport net.sourceforge.pmd.lang.ast.FileAnalysisException;\nimport net.sourceforge.pmd.lang.ast.RootNode;\nimport net.sourceforge.pmd.lang.ast.SemanticErrorReporter;\nimport net.sourceforge.pmd.reporting.FileAnalysisListener;\nimport net.sourceforge.pmd.reporting.GlobalAnalysisListener;\nimport net.sourceforge.pmd.util.datasource.DataSource;\n\n/**\n * A processing task for a single file.\n */\nabstract class PmdRunnable implements Runnable {\n\n    private final DataSource dataSource;\n    private final File file;\n    private final GlobalAnalysisListener ruleContext;\n\n    private final PMDConfiguration configuration;\n\n    private final RulesetStageDependencyHelper dependencyHelper;\n\n    PmdRunnable(DataSource dataSource,\n                GlobalAnalysisListener ruleContext,\n                PMDConfiguration configuration) {\n        this.dataSource = dataSource;\n        // this is the real, canonical and absolute filename (not shortened)\n        String realFileName = dataSource.getNiceFileName(false, null);\n\n        this.file = new File(realFileName);\n        this.ruleContext = ruleContext;\n        this.configuration = configuration;\n        this.dependencyHelper = new RulesetStageDependencyHelper(configuration);\n    }\n\n    /**\n     * This is only called within the run method (when we are on the actual carrier thread).\n     * That way an implementation that uses a ThreadLocal will see the\n     * correct thread.\n     */\n    protected abstract RuleSets getRulesets();\n\n    @Override\n    public void run() throws FileAnalysisException {\n        TimeTracker.initThread();\n\n        RuleSets ruleSets = getRulesets();\n\n        try (FileAnalysisListener listener = ruleContext.startFileAnalysis(dataSource)) {\n\n            LanguageVersion langVersion = configuration.getLanguageVersionOfFile(file.getPath());\n\n\n            // Coarse check to see if any RuleSet applies to file, will need to do a finer RuleSet specific check later\n            if (ruleSets.applies(file)) {\n                if (configuration.getAnalysisCache().isUpToDate(file)) {\n                    reportCachedRuleViolations(listener, file);\n                } else {\n                    try {\n                        processSource(listener, langVersion, ruleSets);\n                    } catch (Exception e) {\n                        configuration.getAnalysisCache().analysisFailed(file);\n\n                        // The listener handles logging if needed,\n                        // it may also rethrow the error, as a FileAnalysisException (which we let through below)\n                        listener.onError(new Report.ProcessingError(e, file.getPath()));\n                    }\n                }\n            }\n        } catch (FileAnalysisException e) {\n            throw e; // bubble managed exceptions, they were already reported\n        } catch (Exception e) {\n            throw FileAnalysisException.wrap(file.getPath(), \"Exception while closing listener\", e);\n        }\n\n        TimeTracker.finishThread();\n    }\n\n    private void processSource(FileAnalysisListener listener, LanguageVersion languageVersion, RuleSets ruleSets) throws IOException, FileAnalysisException {\n        String fullSource = DataSource.readToString(dataSource, configuration.getSourceEncoding());\n        String filename = dataSource.getNiceFileName(false, null);\n\n        processSource(fullSource, ruleSets, listener, languageVersion, filename);\n    }\n\n\n    private void reportCachedRuleViolations(final FileAnalysisListener ctx, File file) {\n        for (final RuleViolation rv : configuration.getAnalysisCache().getCachedViolations(file)) {\n            ctx.onRuleViolation(rv);\n        }\n    }\n\n    private RootNode parse(Parser parser, ParserTask task) {\n        try (TimedOperation to = TimeTracker.startOperation(TimedOperationCategory.PARSER)) {\n            return parser.parse(task);\n        }\n    }\n\n\n    private void processSource(String sourceCode,\n                               RuleSets ruleSets,\n                               FileAnalysisListener listener,\n                               LanguageVersion languageVersion,\n                               String filename) throws FileAnalysisException {\n\n        ParserTask task = new ParserTask(\n            languageVersion,\n            filename,\n            sourceCode,\n            SemanticErrorReporter.noop(), // TODO\n            configuration.getSuppressMarker()\n        );\n\n        Parser parser = languageVersion.getLanguageVersionHandler().getParser();\n\n        RootNode rootNode = parse(parser, task);\n\n        dependencyHelper.runLanguageSpecificStages(ruleSets, languageVersion, rootNode);\n\n        ruleSets.apply(rootNode, listener);\n    }\n\n}\n", "diffSourceCodeSet": [], "invokedMethodSet": [], "sourceCodeAfterRefactoring": "@Override\n    public void run() throws FileAnalysisException {\n        TimeTracker.initThread();\n\n        RuleSets ruleSets = getRulesets();\n\n        try (FileAnalysisListener listener = ruleContext.startFileAnalysis(dataSource)) {\n\n            LanguageVersion langVersion = configuration.getLanguageVersionOfFile(file.getPath());\n\n\n            // Coarse check to see if any RuleSet applies to file, will need to do a finer RuleSet specific check later\n            if (ruleSets.applies(file)) {\n                if (configuration.getAnalysisCache().isUpToDate(file)) {\n                    reportCachedRuleViolations(listener, file);\n                } else {\n                    try {\n                        processSource(listener, langVersion, ruleSets);\n                    } catch (Exception e) {\n                        configuration.getAnalysisCache().analysisFailed(file);\n\n                        // The listener handles logging if needed,\n                        // it may also rethrow the error, as a FileAnalysisException (which we let through below)\n                        listener.onError(new Report.ProcessingError(e, file.getPath()));\n                    }\n                }\n            }\n        } catch (FileAnalysisException e) {\n            throw e; // bubble managed exceptions, they were already reported\n        } catch (Exception e) {\n            throw FileAnalysisException.wrap(file.getPath(), \"Exception while closing listener\", e);\n        }\n\n        TimeTracker.finishThread();\n    }", "diffSourceCode": "-   45:                 PMDConfiguration configuration) {\n-   46:         this.dataSource = dataSource;\n-   47:         // this is the real, canonical and absolute filename (not shortened)\n-   61:     protected abstract RuleSets getRulesets();\n-   62: \n-   63:     @Override\n-   64:     public void run() throws FileAnalysisException {\n-   65:         TimeTracker.initThread();\n+   45:         // this is the real, canonical and absolute filename (not shortened)\n+   46:         String realFileName = dataSource.getNiceFileName(false, null);\n+   47: \n+   61:     @Override\n+   62:     public void run() throws FileAnalysisException {\n+   63:         TimeTracker.initThread();\n+   64: \n+   65:         RuleSets ruleSets = getRulesets();\n    66: \n-   67:         RuleSets ruleSets = getRulesets();\n+   67:         try (FileAnalysisListener listener = ruleContext.startFileAnalysis(dataSource)) {\n    68: \n-   69:         try (FileAnalysisListener listener = ruleContext.startFileAnalysis(dataSource)) {\n-   70:             final RuleContext ruleCtx = RuleContext.create(listener);\n+   69:             LanguageVersion langVersion = configuration.getLanguageVersionOfFile(file.getPath());\n+   70: \n    71: \n-   72:             LanguageVersion langVersion = configuration.getLanguageVersionOfFile(file.getPath());\n-   73: \n-   74: \n-   75:             // Coarse check to see if any RuleSet applies to file, will need to do a finer RuleSet specific check later\n-   76:             if (ruleSets.applies(file)) {\n-   77:                 if (configuration.getAnalysisCache().isUpToDate(file)) {\n-   78:                     reportCachedRuleViolations(ruleCtx, file);\n-   79:                 } else {\n-   80:                     try {\n-   81:                         processSource(ruleCtx, langVersion, ruleSets);\n-   82:                     } catch (Exception e) {\n-   83:                         configuration.getAnalysisCache().analysisFailed(file);\n-   84: \n-   85:                         // The listener handles logging if needed,\n-   86:                         // it may also rethrow the error, as a FileAnalysisException (which we let through below)\n-   87:                         ruleCtx.reportError(new Report.ProcessingError(e, file.getPath()));\n-   88:                     }\n-   89:                 }\n-   90:             }\n-   91:         } catch (FileAnalysisException e) {\n-   92:             throw e; // bubble managed exceptions, they were already reported\n-   93:         } catch (Exception e) {\n-   94:             throw FileAnalysisException.wrap(file.getPath(), \"Exception while closing listener\", e);\n-   95:         }\n+   72:             // Coarse check to see if any RuleSet applies to file, will need to do a finer RuleSet specific check later\n+   73:             if (ruleSets.applies(file)) {\n+   74:                 if (configuration.getAnalysisCache().isUpToDate(file)) {\n+   75:                     reportCachedRuleViolations(listener, file);\n+   76:                 } else {\n+   77:                     try {\n+   78:                         processSource(listener, langVersion, ruleSets);\n+   79:                     } catch (Exception e) {\n+   80:                         configuration.getAnalysisCache().analysisFailed(file);\n+   81: \n+   82:                         // The listener handles logging if needed,\n+   83:                         // it may also rethrow the error, as a FileAnalysisException (which we let through below)\n+   84:                         listener.onError(new Report.ProcessingError(e, file.getPath()));\n+   85:                     }\n+   86:                 }\n+   87:             }\n+   88:         } catch (FileAnalysisException e) {\n+   89:             throw e; // bubble managed exceptions, they were already reported\n+   90:         } catch (Exception e) {\n+   91:             throw FileAnalysisException.wrap(file.getPath(), \"Exception while closing listener\", e);\n+   92:         }\n+   93: \n+   94:         TimeTracker.finishThread();\n+   95:     }\n    96: \n-   97:         TimeTracker.finishThread();\n-   98:     }\n+   97:     private void processSource(FileAnalysisListener listener, LanguageVersion languageVersion, RuleSets ruleSets) throws IOException, FileAnalysisException {\n+   98:         String fullSource = DataSource.readToString(dataSource, configuration.getSourceEncoding());\n", "uniqueId": "0276320abf2c66cae14d2ad24e2b2fb0386943b3_63_98__61_95_45_47", "moveFileExist": true, "testResult": true, "coverageInfo": {"INSTRUCTION": {"missed": 0, "covered": 5}, "LINE": {"missed": 0, "covered": 2}, "COMPLEXITY": {"missed": 0, "covered": 1}, "METHOD": {"missed": 0, "covered": 1}}, "compileResultBefore": true, "compileResultCurrent": true, "compileJDK": 11, "refactoringMinerResult": false, "compileAndTestResult": false, "refactoredCode": "To perform the refactoring operation of \"Move And Inline Method\" on the provided code, we will focus on the `processSource` method, which is a private method that can be inlined into the `run` method where it is called. This will improve readability by reducing the number of method calls and making the logic more straightforward.\n\n### Target File Path\nThe target file path for the refactored class is:\n```\npmd-core/src/main/java/net/sourceforge/pmd/processor/PmdRunnable.java\n```\n\n### Refactored Class Code\nHere is the refactored class code with the `processSource` method inlined into the `run` method:\n\n```java\n/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.processor;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.Collections;\n\nimport net.sourceforge.pmd.PMDConfiguration;\nimport net.sourceforge.pmd.Report;\nimport net.sourceforge.pmd.RuleContext;\nimport net.sourceforge.pmd.RuleSets;\nimport net.sourceforge.pmd.RuleViolation;\nimport net.sourceforge.pmd.benchmark.TimeTracker;\nimport net.sourceforge.pmd.benchmark.TimedOperation;\nimport net.sourceforge.pmd.benchmark.TimedOperationCategory;\nimport net.sourceforge.pmd.internal.RulesetStageDependencyHelper;\nimport net.sourceforge.pmd.lang.LanguageVersion;\nimport net.sourceforge.pmd.lang.Parser;\nimport net.sourceforge.pmd.lang.Parser.ParserTask;\nimport net.sourceforge.pmd.lang.ast.FileAnalysisException;\nimport net.sourceforge.pmd.lang.ast.RootNode;\nimport net.sourceforge.pmd.lang.ast.SemanticErrorReporter;\nimport net.sourceforge.pmd.reporting.FileAnalysisListener;\nimport net.sourceforge.pmd.reporting.GlobalAnalysisListener;\nimport net.sourceforge.pmd.util.datasource.DataSource;\n\n/**\n * A processing task for a single file.\n */\nabstract class PmdRunnable implements Runnable {\n\n    private final DataSource dataSource;\n    private final File file;\n    private final GlobalAnalysisListener ruleContext;\n\n    private final PMDConfiguration configuration;\n\n    private final RulesetStageDependencyHelper dependencyHelper;\n\n    PmdRunnable(DataSource dataSource,\n                GlobalAnalysisListener ruleContext,\n                PMDConfiguration configuration) {\n        this.dataSource = dataSource;\n        // this is the real, canonical and absolute filename (not shortened)\n        String realFileName = dataSource.getNiceFileName(false, null);\n\n        this.file = new File(realFileName);\n        this.ruleContext = ruleContext;\n        this.configuration = configuration;\n        this.dependencyHelper = new RulesetStageDependencyHelper(configuration);\n    }\n\n    /**\n     * This is only called within the run method (when we are on the actual carrier thread).\n     * That way an implementation that uses a ThreadLocal will see the\n     * correct thread.\n     */\n    protected abstract RuleSets getRulesets();\n\n    @Override\n    public void run() throws FileAnalysisException {\n        TimeTracker.initThread();\n\n        RuleSets ruleSets = getRulesets();\n\n        try (FileAnalysisListener listener = ruleContext.startFileAnalysis(dataSource)) {\n            final RuleContext ruleCtx = RuleContext.create(listener);\n\n            LanguageVersion langVersion = configuration.getLanguageVersionOfFile(file.getPath());\n\n            // Coarse check to see if any RuleSet applies to file, will need to do a finer RuleSet specific check later\n            if (ruleSets.applies(file)) {\n                if (configuration.getAnalysisCache().isUpToDate(file)) {\n                    reportCachedRuleViolations(ruleCtx, file);\n                } else {\n                    String fullSource = DataSource.readToString(dataSource, configuration.getSourceEncoding());\n                    String filename = dataSource.getNiceFileName(false, null);\n\n                    try {\n                        ruleSets.start(ruleCtx);\n                        ParserTask task = new ParserTask(\n                            langVersion,\n                            filename,\n                            fullSource,\n                            SemanticErrorReporter.noop(), // TODO\n                            configuration.getSuppressMarker()\n                        );\n\n                        Parser parser = langVersion.getLanguageVersionHandler().getParser();\n                        RootNode rootNode = parse(parser, task);\n\n                        dependencyHelper.runLanguageSpecificStages(ruleSets, langVersion, rootNode);\n                        ruleSets.apply(Collections.singletonList(rootNode), ruleCtx);\n                    } catch (Exception e) {\n                        configuration.getAnalysisCache().analysisFailed(file);\n\n                        // The listener handles logging if needed,\n                        // it may also rethrow the error, as a FileAnalysisException (which we let through below)\n                        ruleCtx.reportError(new Report.ProcessingError(e, file.getPath()));\n                    } finally {\n                        ruleSets.end(ruleCtx);\n                    }\n                }\n            }\n        } catch (FileAnalysisException e) {\n            throw e; // bubble managed exceptions, they were already reported\n        } catch (Exception e) {\n            throw FileAnalysisException.wrap(file.getPath(), \"Exception while closing listener\", e);\n        }\n\n        TimeTracker.finishThread();\n    }\n\n    private void reportCachedRuleViolations(final RuleContext ctx, File file) {\n        for (final RuleViolation rv : configuration.getAnalysisCache().getCachedViolations(file)) {\n            ctx.addViolationNoSuppress(rv);\n        }\n    }\n\n    private RootNode parse(Parser parser, ParserTask task) {\n        try (TimedOperation to = TimeTracker.startOperation(TimedOperationCategory.PARSER)) {\n            return parser.parse(task);\n        }\n    }\n}\n```\n\n### Summary of Changes\n- The `processSource` method has been inlined into the `run` method, which simplifies the flow of the code and reduces the number of method calls.\n- The logic for processing the source code, including reading the source, creating the parser task, parsing, and applying the rules, is now directly within the `run` method, making it easier to follow the execution path.", "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to Refactor:\nPMDConfiguration configuration) {\n        this.dataSource = dataSource;\n        // this is the real, canonical and absolute filename (not shortened)\n\nClass content:\n/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.processor;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.Collections;\n\nimport net.sourceforge.pmd.PMDConfiguration;\nimport net.sourceforge.pmd.Report;\nimport net.sourceforge.pmd.RuleContext;\nimport net.sourceforge.pmd.RuleSets;\nimport net.sourceforge.pmd.RuleViolation;\nimport net.sourceforge.pmd.benchmark.TimeTracker;\nimport net.sourceforge.pmd.benchmark.TimedOperation;\nimport net.sourceforge.pmd.benchmark.TimedOperationCategory;\nimport net.sourceforge.pmd.internal.RulesetStageDependencyHelper;\nimport net.sourceforge.pmd.lang.LanguageVersion;\nimport net.sourceforge.pmd.lang.Parser;\nimport net.sourceforge.pmd.lang.Parser.ParserTask;\nimport net.sourceforge.pmd.lang.ast.FileAnalysisException;\nimport net.sourceforge.pmd.lang.ast.RootNode;\nimport net.sourceforge.pmd.lang.ast.SemanticErrorReporter;\nimport net.sourceforge.pmd.reporting.FileAnalysisListener;\nimport net.sourceforge.pmd.reporting.GlobalAnalysisListener;\nimport net.sourceforge.pmd.util.datasource.DataSource;\n\n/**\n * A processing task for a single file.\n */\nabstract class PmdRunnable implements Runnable {\n\n    private final DataSource dataSource;\n    private final File file;\n    private final GlobalAnalysisListener ruleContext;\n\n    private final PMDConfiguration configuration;\n\n    private final RulesetStageDependencyHelper dependencyHelper;\n\n    PmdRunnable(DataSource dataSource,\n                GlobalAnalysisListener ruleContext,\n                PMDConfiguration configuration) {\n        this.dataSource = dataSource;\n        // this is the real, canonical and absolute filename (not shortened)\n        String realFileName = dataSource.getNiceFileName(false, null);\n\n        this.file = new File(realFileName);\n        this.ruleContext = ruleContext;\n        this.configuration = configuration;\n        this.dependencyHelper = new RulesetStageDependencyHelper(configuration);\n    }\n\n    /**\n     * This is only called within the run method (when we are on the actual carrier thread).\n     * That way an implementation that uses a ThreadLocal will see the\n     * correct thread.\n     */\n    protected abstract RuleSets getRulesets();\n\n    @Override\n    public void run() throws FileAnalysisException {\n        TimeTracker.initThread();\n\n        RuleSets ruleSets = getRulesets();\n\n        try (FileAnalysisListener listener = ruleContext.startFileAnalysis(dataSource)) {\n            final RuleContext ruleCtx = RuleContext.create(listener);\n\n            LanguageVersion langVersion = configuration.getLanguageVersionOfFile(file.getPath());\n\n\n            // Coarse check to see if any RuleSet applies to file, will need to do a finer RuleSet specific check later\n            if (ruleSets.applies(file)) {\n                if (configuration.getAnalysisCache().isUpToDate(file)) {\n                    reportCachedRuleViolations(ruleCtx, file);\n                } else {\n                    try {\n                        processSource(ruleCtx, langVersion, ruleSets);\n                    } catch (Exception e) {\n                        configuration.getAnalysisCache().analysisFailed(file);\n\n                        // The listener handles logging if needed,\n                        // it may also rethrow the error, as a FileAnalysisException (which we let through below)\n                        ruleCtx.reportError(new Report.ProcessingError(e, file.getPath()));\n                    }\n                }\n            }\n        } catch (FileAnalysisException e) {\n            throw e; // bubble managed exceptions, they were already reported\n        } catch (Exception e) {\n            throw FileAnalysisException.wrap(file.getPath(), \"Exception while closing listener\", e);\n        }\n\n        TimeTracker.finishThread();\n    }\n\n    private void processSource(RuleContext ruleCtx, LanguageVersion languageVersion, RuleSets ruleSets) throws IOException, FileAnalysisException {\n        String fullSource = DataSource.readToString(dataSource, configuration.getSourceEncoding());\n        String filename = dataSource.getNiceFileName(false, null);\n\n        try {\n            ruleSets.start(ruleCtx);\n            processSource(fullSource, ruleSets, ruleCtx, languageVersion, filename);\n        } finally {\n            ruleSets.end(ruleCtx);\n        }\n\n    }\n\n\n    private void reportCachedRuleViolations(final RuleContext ctx, File file) {\n        for (final RuleViolation rv : configuration.getAnalysisCache().getCachedViolations(file)) {\n            ctx.addViolationNoSuppress(rv);\n        }\n    }\n\n    private RootNode parse(Parser parser, ParserTask task) {\n        try (TimedOperation to = TimeTracker.startOperation(TimedOperationCategory.PARSER)) {\n            return parser.parse(task);\n        }\n    }\n\n\n    private void processSource(String sourceCode,\n                               RuleSets ruleSets,\n                               RuleContext ctx,\n                               LanguageVersion languageVersion,\n                               String filename) throws FileAnalysisException {\n\n        ParserTask task = new ParserTask(\n            languageVersion,\n            filename,\n            sourceCode,\n            SemanticErrorReporter.noop(), // TODO\n            configuration.getSuppressMarker()\n        );\n\n        Parser parser = languageVersion.getLanguageVersionHandler().getParser();\n\n        RootNode rootNode = parse(parser, task);\n\n        dependencyHelper.runLanguageSpecificStages(ruleSets, languageVersion, rootNode);\n\n        ruleSets.apply(Collections.singletonList(rootNode), ctx);\n    }\n\n}\n\nRefactoring Operation:\nMove And Inline Method\n\nProject Structure:\n['pmd-core/src/main/java/net/sourceforge/pmd/AbstractConfiguration.java', 'pmd-core/src/main/java/net/sourceforge/pmd/PMD.java', 'pmd-core/src/main/java/net/sourceforge/pmd/PMDConfiguration.java', 'pmd-core/src/main/java/net/sourceforge/pmd/PMDVersion.java', 'pmd-core/src/main/java/net/sourceforge/pmd/Report.java', 'pmd-core/src/main/java/net/sourceforge/pmd/Rule.java', 'pmd-core/src/main/java/net/sourceforge/pmd/RuleContext.java', 'pmd-core/src/main/java/net/sourceforge/pmd/RulePriority.java', 'pmd-core/src/main/java/net/sourceforge/pmd/RuleSet.java', 'pmd-core/src/main/java/net/sourceforge/pmd/RuleSetFactory.java', 'pmd-core/src/main/java/net/sourceforge/pmd/RuleSetFactoryCompatibility.java', 'pmd-core/src/main/java/net/sourceforge/pmd/RuleSetNotFoundException.java', 'pmd-core/src/main/java/net/sourceforge/pmd/RuleSetReference.java', 'pmd-core/src/main/java/net/sourceforge/pmd/RuleSetReferenceId.java', 'pmd-core/src/main/java/net/sourceforge/pmd/RuleSetWriter.java', 'pmd-core/src/main/java/net/sourceforge/pmd/RuleSets.java', 'pmd-core/src/main/java/net/sourceforge/pmd/RuleViolation.java', 'pmd-core/src/main/java/net/sourceforge/pmd/RuleViolationComparator.java', 'pmd-core/src/main/java/net/sourceforge/pmd/RulesetsFactoryUtils.java', 'pmd-core/src/main/java/net/sourceforge/pmd/ViolationSuppressor.java', 'pmd-core/src/main/java/net/sourceforge/pmd/annotation/DeprecatedUntil700.java', 'pmd-core/src/main/java/net/sourceforge/pmd/annotation/Experimental.java', 'pmd-core/src/main/java/net/sourceforge/pmd/annotation/InternalApi.java', 'pmd-core/src/main/java/net/sourceforge/pmd/annotation/ReservedSubclassing.java', 'pmd-core/src/main/java/net/sourceforge/pmd/ant/Formatter.java', 'pmd-core/src/main/java/net/sourceforge/pmd/ant/PMDTask.java', 'pmd-core/src/main/java/net/sourceforge/pmd/ant/RuleSetWrapper.java', 'pmd-core/src/main/java/net/sourceforge/pmd/ant/SourceLanguage.java', 'pmd-core/src/main/java/net/sourceforge/pmd/ant/internal/PMDTaskImpl.java', 'pmd-core/src/main/java/net/sourceforge/pmd/benchmark/TextTimingReportRenderer.java', 'pmd-core/src/main/java/net/sourceforge/pmd/benchmark/TimeTracker.java', 'pmd-core/src/main/java/net/sourceforge/pmd/benchmark/TimedOperation.java', 'pmd-core/src/main/java/net/sourceforge/pmd/benchmark/TimedOperationCategory.java', 'pmd-core/src/main/java/net/sourceforge/pmd/benchmark/TimingReport.java', 'pmd-core/src/main/java/net/sourceforge/pmd/benchmark/TimingReportRenderer.java', 'pmd-core/src/main/java/net/sourceforge/pmd/cache/AbstractAnalysisCache.java', 'pmd-core/src/main/java/net/sourceforge/pmd/cache/AnalysisCache.java', 'pmd-core/src/main/java/net/sourceforge/pmd/cache/AnalysisResult.java', 'pmd-core/src/main/java/net/sourceforge/pmd/cache/CachedRuleMapper.java', 'pmd-core/src/main/java/net/sourceforge/pmd/cache/CachedRuleViolation.java', 'pmd-core/src/main/java/net/sourceforge/pmd/cache/ChecksumAware.java', 'pmd-core/src/main/java/net/sourceforge/pmd/cache/FileAnalysisCache.java', 'pmd-core/src/main/java/net/sourceforge/pmd/cache/NoopAnalysisCache.java', 'pmd-core/src/main/java/net/sourceforge/pmd/cache/package-info.java', 'pmd-core/src/main/java/net/sourceforge/pmd/cli/PMDCommandLineInterface.java', 'pmd-core/src/main/java/net/sourceforge/pmd/cli/PMDParameters.java', 'pmd-core/src/main/java/net/sourceforge/pmd/cpd/AbstractLanguage.java', 'pmd-core/src/main/java/net/sourceforge/pmd/cpd/AbstractTokenizer.java', 'pmd-core/src/main/java/net/sourceforge/pmd/cpd/AnyLanguage.java', 'pmd-core/src/main/java/net/sourceforge/pmd/cpd/AnyTokenizer.java', 'pmd-core/src/main/java/net/sourceforge/pmd/cpd/CPD.java', 'pmd-core/src/main/java/net/sourceforge/pmd/cpd/CPDCommandLineInterface.java', 'pmd-core/src/main/java/net/sourceforge/pmd/cpd/CPDConfiguration.java', 'pmd-core/src/main/java/net/sourceforge/pmd/cpd/CPDListener.java', 'pmd-core/src/main/java/net/sourceforge/pmd/cpd/CPDNullListener.java', 'pmd-core/src/main/java/net/sourceforge/pmd/cpd/CPDTask.java', 'pmd-core/src/main/java/net/sourceforge/pmd/cpd/CSVRenderer.java', 'pmd-core/src/main/java/net/sourceforge/pmd/cpd/CSVWithLinecountPerFileRenderer.java', 'pmd-core/src/main/java/net/sourceforge/pmd/cpd/FileReporter.java', 'pmd-core/src/main/java/net/sourceforge/pmd/cpd/GUI.java', 'pmd-core/src/main/java/net/sourceforge/pmd/cpd/GridBagHelper.java', 'pmd-core/src/main/java/net/sourceforge/pmd/cpd/Language.java', 'pmd-core/src/main/java/net/sourceforge/pmd/cpd/LanguageFactory.java', 'pmd-core/src/main/java/net/sourceforge/pmd/cpd/Mark.java', 'pmd-core/src/main/java/net/sourceforge/pmd/cpd/Match.java', 'pmd-core/src/main/java/net/sourceforge/pmd/cpd/MatchAlgorithm.java', 'pmd-core/src/main/java/net/sourceforge/pmd/cpd/MatchCollector.java', 'pmd-core/src/main/java/net/sourceforge/pmd/cpd/Renderer.java', 'pmd-core/src/main/java/net/sourceforge/pmd/cpd/ReportException.java', 'pmd-core/src/main/java/net/sourceforge/pmd/cpd/SimpleRenderer.java', 'pmd-core/src/main/java/net/sourceforge/pmd/cpd/SourceCode.java', 'pmd-core/src/main/java/net/sourceforge/pmd/cpd/TokenEntry.java', 'pmd-core/src/main/java/net/sourceforge/pmd/cpd/Tokenizer.java', 'pmd-core/src/main/java/net/sourceforge/pmd/cpd/Tokens.java', 'pmd-core/src/main/java/net/sourceforge/pmd/cpd/VSRenderer.java', 'pmd-core/src/main/java/net/sourceforge/pmd/cpd/XMLRenderer.java', 'pmd-core/src/main/java/net/sourceforge/pmd/cpd/internal/AntlrTokenizer.java', 'pmd-core/src/main/java/net/sourceforge/pmd/cpd/internal/JavaCCTokenizer.java', 'pmd-core/src/main/java/net/sourceforge/pmd/cpd/renderer/CPDRenderer.java', 'pmd-core/src/main/java/net/sourceforge/pmd/cpd/token/AntlrTokenFilter.java', 'pmd-core/src/main/java/net/sourceforge/pmd/cpd/token/JavaCCTokenFilter.java', 'pmd-core/src/main/java/net/sourceforge/pmd/cpd/token/TokenFilter.java', 'pmd-core/src/main/java/net/sourceforge/pmd/cpd/token/internal/BaseTokenFilter.java', 'pmd-core/src/main/java/net/sourceforge/pmd/document/DeleteDocumentOperation.java', 'pmd-core/src/main/java/net/sourceforge/pmd/document/Document.java', 'pmd-core/src/main/java/net/sourceforge/pmd/document/DocumentFile.java', 'pmd-core/src/main/java/net/sourceforge/pmd/document/DocumentOperation.java', 'pmd-core/src/main/java/net/sourceforge/pmd/document/DocumentOperationsApplierForNonOverlappingRegions.java', 'pmd-core/src/main/java/net/sourceforge/pmd/document/InsertDocumentOperation.java', 'pmd-core/src/main/java/net/sourceforge/pmd/document/RegionByLine.java', 'pmd-core/src/main/java/net/sourceforge/pmd/document/RegionByLineImp.java', 'pmd-core/src/main/java/net/sourceforge/pmd/document/RegionByOffset.java', 'pmd-core/src/main/java/net/sourceforge/pmd/document/RegionByOffsetImp.java', 'pmd-core/src/main/java/net/sourceforge/pmd/document/ReplaceDocumentOperation.java', 'pmd-core/src/main/java/net/sourceforge/pmd/internal/RulesetStageDependencyHelper.java', 'pmd-core/src/main/java/net/sourceforge/pmd/internal/util/AssertionUtil.java', 'pmd-core/src/main/java/net/sourceforge/pmd/internal/util/FileExtensionFilter.java', 'pmd-core/src/main/java/net/sourceforge/pmd/internal/util/IteratorUtil.java', 'pmd-core/src/main/java/net/sourceforge/pmd/internal/util/PredicateUtil.java', 'pmd-core/src/main/java/net/sourceforge/pmd/internal/util/ShortFilenameUtil.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/AbstractLanguageVersionHandler.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/AbstractPmdLanguageVersionHandler.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/BaseLanguageModule.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/Language.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/LanguageFilenameFilter.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/LanguageRegistry.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/LanguageVersion.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/LanguageVersionDiscoverer.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/LanguageVersionHandler.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/Parser.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/ParserOptions.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/TokenManager.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/AbstractTokenManager.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/AstAnalysisContext.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/AstProcessingStage.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/AstVisitor.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/AstVisitorBase.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/CharStream.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/FileAnalysisException.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/GenericToken.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/Node.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/NodeStream.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/ParseException.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/RootNode.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/SemanticErrorReporter.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/SemanticException.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/SignedNode.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/SourceCodePositioner.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/TextAvailableNode.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/TokenMgrError.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/impl/AbstractNode.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/impl/AbstractNodeWithTextCoordinates.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/impl/GenericNode.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/impl/TokenDocument.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/impl/antlr4/AntlrBaseParser.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/impl/antlr4/AntlrBaseRule.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/impl/antlr4/AntlrGeneratedParserBase.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/impl/antlr4/AntlrNameDictionary.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/impl/antlr4/AntlrNode.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/impl/antlr4/AntlrToken.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/impl/antlr4/AntlrTokenManager.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/impl/antlr4/BaseAntlrErrorNode.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/impl/antlr4/BaseAntlrInnerNode.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/impl/antlr4/BaseAntlrNode.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/impl/antlr4/BaseAntlrTerminalNode.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/impl/javacc/AbstractJjtreeNode.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/impl/javacc/CharStreamFactory.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/impl/javacc/JavaCharStream.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/impl/javacc/JavaccToken.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/impl/javacc/JavaccTokenDocument.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/impl/javacc/JjtreeBuilder.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/impl/javacc/JjtreeNode.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/impl/javacc/JjtreeParserAdapter.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/impl/javacc/SimpleCharStream.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/impl/javacc/package-info.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/internal/AncestorOrSelfIterator.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/internal/AxisStream.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/internal/Filtermap.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/internal/GreedyNStream.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/internal/IteratorBasedNStream.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/internal/SingletonNodeStream.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/internal/StreamImpl.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/internal/TraversalUtils.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/internal/TreeWalker.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/metrics/AbstractMetric.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/metrics/LanguageMetricsProvider.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/metrics/Metric.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/metrics/MetricKey.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/metrics/MetricOption.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/metrics/MetricOptions.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/metrics/MetricsUtil.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/metrics/ParameterizedMetricKey.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/metrics/SigMask.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/metrics/Signature.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/metrics/internal/AbstractLanguageMetricsProvider.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/metrics/package-info.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/rule/AbstractDelegateRule.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/rule/AbstractRule.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/rule/ParametricRuleViolation.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/rule/RuleReference.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/rule/RuleTargetSelector.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/rule/RuleViolationFactory.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/rule/XPathRule.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/rule/impl/DefaultRuleViolationFactory.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/rule/internal/CommonPropertyDescriptors.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/rule/internal/GraphUtils.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/rule/internal/LatticeRelation.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/rule/internal/RuleApplicator.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/rule/internal/TargetSelectorInternal.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/rule/internal/TopoOrder.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/rule/internal/TreeIndex.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/rule/xpath/Attribute.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/rule/xpath/DeprecatedAttribute.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/rule/xpath/NoAttribute.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/rule/xpath/XPathVersion.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/rule/xpath/impl/AbstractXPathFunctionDef.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/rule/xpath/impl/AttributeAxisIterator.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/rule/xpath/impl/XPathHandler.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/rule/xpath/internal/AstAttributeNode.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/rule/xpath/internal/AstDocumentNode.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/rule/xpath/internal/AstElementNode.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/rule/xpath/internal/AstTreeInfo.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/rule/xpath/internal/BaseNodeInfo.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/rule/xpath/internal/DeprecatedAttrLogger.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/rule/xpath/internal/DomainConversion.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/rule/xpath/internal/ExpressionPrinter.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/rule/xpath/internal/PmdDocumentSorter.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/rule/xpath/internal/RuleChainAnalyzer.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/rule/xpath/internal/SaxonExprVisitor.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/rule/xpath/internal/SaxonXPathRuleQuery.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/rule/xpath/internal/SplitUnions.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/symboltable/AbstractNameDeclaration.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/symboltable/AbstractScope.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/symboltable/Applier.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/symboltable/ImageFinderFunction.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/symboltable/NameDeclaration.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/symboltable/NameOccurrence.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/symboltable/Scope.java', 'pmd-core/src/main/java/net/sourceforge/pmd/lang/symboltable/ScopedNode.java', 'pmd-core/src/main/java/net/sourceforge/pmd/processor/AbstractPMDProcessor.java', 'pmd-core/src/main/java/net/sourceforge/pmd/processor/MonoThreadProcessor.java', 'pmd-core/src/main/java/net/sourceforge/pmd/processor/MultiThreadProcessor.java', 'pmd-core/src/main/java/net/sourceforge/pmd/processor/PmdRunnable.java', 'pmd-core/src/main/java/net/sourceforge/pmd/processor/PmdThreadFactory.java', 'pmd-core/src/main/java/net/sourceforge/pmd/properties/AbstractMultiNumericProperty.java', 'pmd-core/src/main/java/net/sourceforge/pmd/properties/AbstractMultiValueProperty.java', 'pmd-core/src/main/java/net/sourceforge/pmd/properties/AbstractNumericProperty.java', 'pmd-core/src/main/java/net/sourceforge/pmd/properties/AbstractProperty.java', 'pmd-core/src/main/java/net/sourceforge/pmd/properties/AbstractPropertySource.java', 'pmd-core/src/main/java/net/sourceforge/pmd/properties/AbstractSingleValueProperty.java', 'pmd-core/src/main/java/net/sourceforge/pmd/properties/BooleanMultiProperty.java', 'pmd-core/src/main/java/net/sourceforge/pmd/properties/BooleanProperty.java', 'pmd-core/src/main/java/net/sourceforge/pmd/properties/CharacterMultiProperty.java', 'pmd-core/src/main/java/net/sourceforge/pmd/properties/CharacterProperty.java', 'pmd-core/src/main/java/net/sourceforge/pmd/properties/DoubleMultiProperty.java', 'pmd-core/src/main/java/net/sourceforge/pmd/properties/DoubleProperty.java', 'pmd-core/src/main/java/net/sourceforge/pmd/properties/EnumeratedMultiProperty.java', 'pmd-core/src/main/java/net/sourceforge/pmd/properties/EnumeratedProperty.java', 'pmd-core/src/main/java/net/sourceforge/pmd/properties/EnumeratedPropertyDescriptor.java', 'pmd-core/src/main/java/net/sourceforge/pmd/properties/FileProperty.java', 'pmd-core/src/main/java/net/sourceforge/pmd/properties/FloatMultiProperty.java', 'pmd-core/src/main/java/net/sourceforge/pmd/properties/FloatProperty.java', 'pmd-core/src/main/java/net/sourceforge/pmd/properties/GenericMultiValuePropertyDescriptor.java', 'pmd-core/src/main/java/net/sourceforge/pmd/properties/GenericPropertyDescriptor.java', 'pmd-core/src/main/java/net/sourceforge/pmd/properties/IntegerMultiProperty.java', 'pmd-core/src/main/java/net/sourceforge/pmd/properties/IntegerProperty.java', 'pmd-core/src/main/java/net/sourceforge/pmd/properties/LongMultiProperty.java', 'pmd-core/src/main/java/net/sourceforge/pmd/properties/LongProperty.java', 'pmd-core/src/main/java/net/sourceforge/pmd/properties/MultiValuePropertyDescriptor.java', 'pmd-core/src/main/java/net/sourceforge/pmd/properties/NumericPropertyDescriptor.java', 'pmd-core/src/main/java/net/sourceforge/pmd/properties/PropertyBuilder.java', 'pmd-core/src/main/java/net/sourceforge/pmd/properties/PropertyDescriptor.java', 'pmd-core/src/main/java/net/sourceforge/pmd/properties/PropertyDescriptorField.java', 'pmd-core/src/main/java/net/sourceforge/pmd/properties/PropertyFactory.java', 'pmd-core/src/main/java/net/sourceforge/pmd/properties/PropertySource.java', 'pmd-core/src/main/java/net/sourceforge/pmd/properties/PropertyTypeId.java', 'pmd-core/src/main/java/net/sourceforge/pmd/properties/RegexProperty.java', 'pmd-core/src/main/java/net/sourceforge/pmd/properties/SingleValuePropertyDescriptor.java', 'pmd-core/src/main/java/net/sourceforge/pmd/properties/StringMultiProperty.java', 'pmd-core/src/main/java/net/sourceforge/pmd/properties/StringProperty.java', 'pmd-core/src/main/java/net/sourceforge/pmd/properties/ValueParser.java', 'pmd-core/src/main/java/net/sourceforge/pmd/properties/ValueParserConstants.java', 'pmd-core/src/main/java/net/sourceforge/pmd/properties/builders/MultiNumericPropertyBuilder.java', 'pmd-core/src/main/java/net/sourceforge/pmd/properties/builders/MultiPackagedPropertyBuilder.java', 'pmd-core/src/main/java/net/sourceforge/pmd/properties/builders/MultiValuePropertyBuilder.java', 'pmd-core/src/main/java/net/sourceforge/pmd/properties/builders/PropertyDescriptorBuilder.java', 'pmd-core/src/main/java/net/sourceforge/pmd/properties/builders/PropertyDescriptorBuilderConversionWrapper.java', 'pmd-core/src/main/java/net/sourceforge/pmd/properties/builders/PropertyDescriptorExternalBuilder.java', 'pmd-core/src/main/java/net/sourceforge/pmd/properties/builders/SingleNumericPropertyBuilder.java', 'pmd-core/src/main/java/net/sourceforge/pmd/properties/builders/SinglePackagedPropertyBuilder.java', 'pmd-core/src/main/java/net/sourceforge/pmd/properties/builders/SingleValuePropertyBuilder.java', 'pmd-core/src/main/java/net/sourceforge/pmd/properties/constraints/NumericConstraints.java', 'pmd-core/src/main/java/net/sourceforge/pmd/properties/constraints/PropertyConstraint.java', 'pmd-core/src/main/java/net/sourceforge/pmd/properties/modules/EnumeratedPropertyModule.java', 'pmd-core/src/main/java/net/sourceforge/pmd/properties/modules/NumericPropertyModule.java', 'pmd-core/src/main/java/net/sourceforge/pmd/renderers/AbstractAccumulatingRenderer.java', 'pmd-core/src/main/java/net/sourceforge/pmd/renderers/AbstractIncrementingRenderer.java', 'pmd-core/src/main/java/net/sourceforge/pmd/renderers/AbstractRenderer.java', 'pmd-core/src/main/java/net/sourceforge/pmd/renderers/CSVRenderer.java', 'pmd-core/src/main/java/net/sourceforge/pmd/renderers/CSVWriter.java', 'pmd-core/src/main/java/net/sourceforge/pmd/renderers/CodeClimateIssue.java', 'pmd-core/src/main/java/net/sourceforge/pmd/renderers/CodeClimateRenderer.java', 'pmd-core/src/main/java/net/sourceforge/pmd/renderers/ColumnDescriptor.java', 'pmd-core/src/main/java/net/sourceforge/pmd/renderers/EmacsRenderer.java', 'pmd-core/src/main/java/net/sourceforge/pmd/renderers/EmptyRenderer.java', 'pmd-core/src/main/java/net/sourceforge/pmd/renderers/HTMLRenderer.java', 'pmd-core/src/main/java/net/sourceforge/pmd/renderers/IDEAJRenderer.java', 'pmd-core/src/main/java/net/sourceforge/pmd/renderers/JsonRenderer.java', 'pmd-core/src/main/java/net/sourceforge/pmd/renderers/Renderer.java', 'pmd-core/src/main/java/net/sourceforge/pmd/renderers/RendererFactory.java', 'pmd-core/src/main/java/net/sourceforge/pmd/renderers/SummaryHTMLRenderer.java', 'pmd-core/src/main/java/net/sourceforge/pmd/renderers/TextColorRenderer.java', 'pmd-core/src/main/java/net/sourceforge/pmd/renderers/TextPadRenderer.java', 'pmd-core/src/main/java/net/sourceforge/pmd/renderers/TextRenderer.java', 'pmd-core/src/main/java/net/sourceforge/pmd/renderers/VBHTMLRenderer.java', 'pmd-core/src/main/java/net/sourceforge/pmd/renderers/XMLRenderer.java', 'pmd-core/src/main/java/net/sourceforge/pmd/renderers/XSLTRenderer.java', 'pmd-core/src/main/java/net/sourceforge/pmd/renderers/YAHTMLRenderer.java', 'pmd-core/src/main/java/net/sourceforge/pmd/reporting/FileAnalysisListener.java', 'pmd-core/src/main/java/net/sourceforge/pmd/reporting/GlobalAnalysisListener.java', 'pmd-core/src/main/java/net/sourceforge/pmd/reporting/NoopFileListener.java', 'pmd-core/src/main/java/net/sourceforge/pmd/rules/RuleBuilder.java', 'pmd-core/src/main/java/net/sourceforge/pmd/rules/RuleFactory.java', 'pmd-core/src/main/java/net/sourceforge/pmd/util/BaseResultProducingCloseable.java', 'pmd-core/src/main/java/net/sourceforge/pmd/util/ClasspathClassLoader.java', 'pmd-core/src/main/java/net/sourceforge/pmd/util/CollectionUtil.java', 'pmd-core/src/main/java/net/sourceforge/pmd/util/CompoundIterator.java', 'pmd-core/src/main/java/net/sourceforge/pmd/util/ConsList.java', 'pmd-core/src/main/java/net/sourceforge/pmd/util/DataMap.java', 'pmd-core/src/main/java/net/sourceforge/pmd/util/FileFinder.java', 'pmd-core/src/main/java/net/sourceforge/pmd/util/FileUtil.java', 'pmd-core/src/main/java/net/sourceforge/pmd/util/IOUtil.java', 'pmd-core/src/main/java/net/sourceforge/pmd/util/OptionalBool.java', 'pmd-core/src/main/java/net/sourceforge/pmd/util/ResourceLoader.java', 'pmd-core/src/main/java/net/sourceforge/pmd/util/StringUtil.java', 'pmd-core/src/main/java/net/sourceforge/pmd/util/database/DBMSMetadata.java', 'pmd-core/src/main/java/net/sourceforge/pmd/util/database/DBType.java', 'pmd-core/src/main/java/net/sourceforge/pmd/util/database/DBURI.java', 'pmd-core/src/main/java/net/sourceforge/pmd/util/database/ResourceLoader.java', 'pmd-core/src/main/java/net/sourceforge/pmd/util/database/ResourceResolver.java', 'pmd-core/src/main/java/net/sourceforge/pmd/util/database/SourceObject.java', 'pmd-core/src/main/java/net/sourceforge/pmd/util/datasource/DataSource.java', 'pmd-core/src/main/java/net/sourceforge/pmd/util/datasource/FileDataSource.java', 'pmd-core/src/main/java/net/sourceforge/pmd/util/datasource/ReaderDataSource.java', 'pmd-core/src/main/java/net/sourceforge/pmd/util/datasource/ZipDataSource.java', 'pmd-core/src/main/java/net/sourceforge/pmd/util/datasource/internal/AbstractDataSource.java', 'pmd-core/src/main/java/net/sourceforge/pmd/util/designerbindings/DesignerBindings.java', 'pmd-core/src/main/java/net/sourceforge/pmd/util/designerbindings/RelatedNodesSelector.java', 'pmd-core/src/main/java/net/sourceforge/pmd/util/log/AntLogHandler.java', 'pmd-core/src/main/java/net/sourceforge/pmd/util/log/ConsoleLogHandler.java', 'pmd-core/src/main/java/net/sourceforge/pmd/util/log/PmdLogFormatter.java', 'pmd-core/src/main/java/net/sourceforge/pmd/util/log/ScopedLogHandlersManager.java', 'pmd-core/src/main/java/net/sourceforge/pmd/util/treeexport/TextTreeRenderer.java', 'pmd-core/src/main/java/net/sourceforge/pmd/util/treeexport/TreeExportCli.java', 'pmd-core/src/main/java/net/sourceforge/pmd/util/treeexport/TreeRenderer.java', 'pmd-core/src/main/java/net/sourceforge/pmd/util/treeexport/TreeRendererDescriptor.java', 'pmd-core/src/main/java/net/sourceforge/pmd/util/treeexport/TreeRendererDescriptorImpl.java', 'pmd-core/src/main/java/net/sourceforge/pmd/util/treeexport/TreeRenderers.java', 'pmd-core/src/main/java/net/sourceforge/pmd/util/treeexport/XmlTreeRenderer.java']\n\nInstructions:\n1. Analyze the provided code, class content, and project structure, apply relevant refactoring operation to the code to be refactored, output the target file path.\n2. If refactoring is performed, output the refactored class code in the following format:\n$target_file_path$:\n$refactored_class_code$:\n\n\n"}, {"type": "Move Method", "description": "Move Method\tpublic collectMostSpecific(commonSubtype JTypeMirror) : Collector<JMethodSig,?,List<JMethodSig>> from class net.sourceforge.pmd.lang.java.types.internal.infer.OverloadComparator to public collectMostSpecific(commonSubtype JTypeMirror) : Collector<JMethodSig,?,List<JMethodSig>> from class net.sourceforge.pmd.lang.java.types.TypeOps", "diffLocations": [{"filePath": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/internal/infer/OverloadComparator.java", "startLine": 267, "endLine": 287, "startColumn": 0, "endColumn": 0}, {"filePath": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/TypeOps.java", "startLine": 1724, "endLine": 1744, "startColumn": 0, "endColumn": 0}], "sourceCodeBeforeRefactoring": "/**\n     * Returns a collector that can apply to a stream of method signatures,\n     * and that collects them into a set of method, where none override one another.\n     * Do not use this in a parallel stream. Do not use this to collect constructors.\n     * Do not use this if your stream contains methods that have different names.\n     *\n     * @param commonSubtype Site where the signatures are observed. The owner of every method\n     *                      in the stream must be a supertype of this type\n     *\n     * @return A collector\n     */\n    public static Collector<JMethodSig, ?, List<JMethodSig>> collectMostSpecific(JTypeMirror commonSubtype) {\n        return Collector.of(\n            OverloadSet::new,\n            (set, sig) -> set.add(sig, commonSubtype),\n            (left, right) -> {\n                throw new NotImplementedException(\"Cannot use this in a parallel stream\");\n            },\n            OverloadSet::getOverloads\n        );\n    }", "filePathBefore": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/internal/infer/OverloadComparator.java", "isPureRefactoring": true, "commitId": "12d40eb6dcc965cc0523c4f2df71cf52a6a290e8", "packageNameBefore": "net.sourceforge.pmd.lang.java.types.internal.infer", "classNameBefore": "net.sourceforge.pmd.lang.java.types.internal.infer.OverloadComparator", "methodNameBefore": "net.sourceforge.pmd.lang.java.types.internal.infer.OverloadComparator#collectMostSpecific", "invokedMethod": "methodSignature: net.sourceforge.pmd.lang.java.types.internal.infer.OverloadSet#add\n methodBody: void add(JMethodSig sig, JTypeMirror commonSubtype) {\nif(name == null){name=sig.getName();\n}assert sig.getName().equals(name) : \"Not the right name!\";\nassert !sig.isConstructor() : \"Constructors they cannot override each other\";\nListIterator<JMethodSig> iterator=overloads.listIterator();\nwhile(iterator.hasNext()){JMethodSig existing=iterator.next();\nif(areOverrideEquivalent(existing,sig)){switch(shouldTakePrecedence(existing,sig,commonSubtype))case YES:return;\ncase NO:iterator.remove();\nbreak;\ncase UNKNOWN:break;\ndefault:throw new AssertionError();\n}}overloads.add(sig);\n}\nmethodSignature: net.sourceforge.pmd.lang.java.types.internal.infer.OverloadSet#getOverloads\n methodBody: public List<JMethodSig> getOverloads() {\nreturn Collections.unmodifiableList(overloads);\n}", "classSignatureBefore": "public final class OverloadComparator ", "methodNameBeforeSet": ["net.sourceforge.pmd.lang.java.types.internal.infer.OverloadComparator#collectMostSpecific"], "classNameBeforeSet": ["net.sourceforge.pmd.lang.java.types.internal.infer.OverloadComparator"], "classSignatureBeforeSet": ["public final class OverloadComparator "], "purityCheckResultList": [{"isPure": true, "purityComment": "Identical statements", "description": "There is no replacement! - all mapped", "mappingState": 1}], "sourceCodeBeforeForWhole": "/*\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.lang.java.types.internal.infer;\n\nimport static net.sourceforge.pmd.lang.java.types.TypeOps.areOverrideEquivalent;\nimport static net.sourceforge.pmd.lang.java.types.TypeOps.overrides;\nimport static net.sourceforge.pmd.util.OptionalBool.NO;\nimport static net.sourceforge.pmd.util.OptionalBool.UNKNOWN;\nimport static net.sourceforge.pmd.util.OptionalBool.YES;\nimport static net.sourceforge.pmd.util.OptionalBool.definitely;\n\nimport java.lang.reflect.Modifier;\nimport java.util.List;\nimport java.util.stream.Collector;\n\nimport org.apache.commons.lang3.NotImplementedException;\nimport org.checkerframework.checker.nullness.qual.NonNull;\n\nimport net.sourceforge.pmd.lang.java.symbols.JClassSymbol;\nimport net.sourceforge.pmd.lang.java.types.JClassType;\nimport net.sourceforge.pmd.lang.java.types.JMethodSig;\nimport net.sourceforge.pmd.lang.java.types.JTypeMirror;\nimport net.sourceforge.pmd.lang.java.types.TypeOps;\nimport net.sourceforge.pmd.lang.java.types.internal.infer.ExprMirror.InvocationMirror.MethodCtDecl;\nimport net.sourceforge.pmd.util.OptionalBool;\n\npublic final class OverloadComparator {\n\n    private final Infer infer;\n    private final TypeInferenceLogger log;\n\n\n    OverloadComparator(Infer infer) {\n        this.infer = infer;\n        this.log = infer.getLogger();\n    }\n\n\n    /**\n     * Returns the most specific method of the two methods for the\n     * given invocation expression, given both are applicable to the\n     * site AND given that the currentBest may be shadowing/overriding/hiding\n     * the candidate if they are override-equivalent.\n     *\n     * <p>https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.12.2.5\n     */\n    @NonNull MethodCtDecl selectMoreSpecific(MethodCtDecl currentBest, MethodCtDecl candidate, MethodCallSite site, MethodResolutionPhase phase) {\n        if (currentBest.isFailed()) {\n            return candidate;\n        } else if (candidate.isFailed()) {\n            return currentBest;\n        }\n\n        JMethodSig m1 = currentBest.getMethodType().internalApi().adaptedMethod();\n        JMethodSig m2 = candidate.getMethodType().internalApi().adaptedMethod();\n\n        return isMoreSpecific(m1, m2, site, phase)\n               ? currentBest\n               : candidate;\n    }\n\n    private boolean isMoreSpecific(@NonNull JMethodSig m1, @NonNull JMethodSig m2, MethodCallSite site, MethodResolutionPhase phase) {\n\n        boolean m1OverM2 = isMoreSpecificImpl(m1, m2, site, phase);\n        boolean m2OverM1 = isMoreSpecificImpl(m2, m1, site, phase);\n\n        if (m1OverM2 != m2OverM1) {\n            // then one of them is strictly more specific than the other\n            return m1OverM2;\n        } else if (areOverrideEquivalent(m1, m2)) {\n\n            OptionalBool result = shouldTakePrecedence(m1, m2, site.getExpr().getReceiverType());\n            if (result == UNKNOWN) {\n                log.ambiguityError(site, m1, m2);\n                // todo if a third method comes in that is more specific\n                //  than all ambiguous methods, then the ambiguity is lifted\n                return true;\n            } else {\n                return result == YES;\n            }\n        }\n\n        return false;\n    }\n\n    // test only\n\n    /**\n     * Given that m1 and m2 are override-equivalent, should m1 be chosen\n     * over m2 (YES/NO), or should an ambiguity error arise (UNKNOWN). This\n     * handles a few cases about shadowing/overriding/hiding that are not\n     * covered strictly by the definition of \"specificity\".\n     *\n     * <p>If m1 and m2 are equal, returns the first one by convention.\n     */\n    static OptionalBool shouldTakePrecedence(JMethodSig m1, JMethodSig m2, JTypeMirror commonSubtype) {\n        // select\n        // 1. the non-bridge\n        // 2. the one that overrides the other\n        // 3. the non-abstract method\n\n        // Symbols don't reflect bridge methods anymore\n        // if (m1.isBridge() != m2.isBridge()) {\n        //      return definitely(!m1.isBridge());\n        // } else\n        if (overrides(m1, m2, commonSubtype)) {\n            return YES;\n        } else if (overrides(m2, m1, commonSubtype)) {\n            return NO;\n        } else if (m1.isAbstract() ^ m2.isAbstract()) {\n            return definitely(!m1.isAbstract());\n        } else if (m1.isAbstract() && m2.isAbstract()) { // last ditch effort\n            // both are unrelated abstract, inherited into 'site'\n            // their signature would be merged into the site\n            // if exactly one is declared in a class, prefer it\n            // if both are declared in a class, ambiguity error (recall, neither overrides the other)\n            // if both are declared in an interface, select any of them\n            boolean m1InClass = m1.getSymbol().getEnclosingClass().isClass();\n            boolean m2Class = m2.getSymbol().getEnclosingClass().isClass();\n\n            return m1InClass && m2Class ? UNKNOWN : definitely(m1InClass);\n        }\n\n        if (Modifier.isPrivate(m1.getModifiers() | m2.getModifiers())\n            && commonSubtype instanceof JClassType) {\n            // One of them is private, which means, they can't be overridden,\n            // so they failed the above test\n            // Maybe it's shadowing then\n            return shadows(m1, m2, (JClassType) commonSubtype);\n        }\n\n        return UNKNOWN;\n    }\n\n\n    /**\n     * Returns whether m1 shadows m2 in the body of the given site, ie\n     * m1 is declared in a class C1 that encloses the site, and m2 is declared\n     * in a type that strictly encloses C1.\n     *\n     * <p>Assumes m1 and m2 are override-equivalent, and declared in different\n     * classes.\n     */\n    static OptionalBool shadows(JMethodSig m1, JMethodSig m2, JClassType site) {\n        final JClassSymbol c1 = m1.getSymbol().getEnclosingClass();\n        final JClassSymbol c2 = m2.getSymbol().getEnclosingClass();\n\n        // We go outward from the `site`. The height measure is the distance\n        // from the site (ie, the reverted depth of each class)\n\n        int height = 0;\n        int c1Height = -1;\n        int c2Height = -1;\n        JClassSymbol c = site.getSymbol();\n\n        while (c != null) {\n            if (c.equals(c1)) {\n                c1Height = height;\n            }\n            if (c.equals(c2)) {\n                c2Height = height;\n            }\n            c = c.getEnclosingClass();\n            height++;\n        }\n\n        if (c1Height < 0 || c2Height < 0 || c1Height == c2Height) {\n            return UNKNOWN;\n        }\n        return definitely(c1Height < c2Height);\n    }\n\n    private boolean isMoreSpecificImpl(JMethodSig m1, JMethodSig m2, MethodCallSite site, MethodResolutionPhase phase) {\n        return m2.isGeneric() ? isInferredMoreSpecific(m1, m2, site, phase)\n                              : isMoreSpecificNonGeneric(m1, m2, site, phase);\n    }\n\n\n    private boolean isInferredMoreSpecific(JMethodSig m1, JMethodSig m2, MethodCallSite site, MethodResolutionPhase phase) {\n        /* TODO\n             https://docs.oracle.com/javase/specs/jls/se8/html/jls-18.html#jls-18.5.4\n     \n             Test case:\n         */\n        try {\n            return doInfer(m1, m2, site, phase);\n        } catch (ResolutionFailedException e) {\n            return false;\n        }\n    }\n\n    private boolean doInfer(JMethodSig m1, JMethodSig m2, MethodCallSite site, MethodResolutionPhase phase) {\n        InferenceContext ctx = infer.newContextFor(m2);\n\n        // even if m1 is generic, the type parameters of m1 are treated as type variables, not inference variables.\n\n        JMethodSig m2p = ctx.mapToIVars(m2);\n\n        List<ExprMirror> es = site.getExpr().getArgumentExpressions();\n        List<JTypeMirror> m1Formals = m1.getFormalParameters();\n        List<JTypeMirror> m2Formals = m2p.getFormalParameters();\n\n        int k = es.size();\n\n        for (int i = 0; i < k; i++) {\n            JTypeMirror ti = phase.ithFormal(m2Formals, i);\n            JTypeMirror si = phase.ithFormal(m1Formals, i);\n            ExprMirror ei = es.get(i);\n\n            if (ctx.isGround(ti) && !isTypeMoreSpecificForArg(si, ti, ei)) {\n                return true;\n            }\n\n            // Otherwise, if Ti is not a functional interface type, the\n            // constraint formula \u2039Si <: Ti\u203a is generated.\n            JMethodSig fun = TypeOps.findFunctionalInterfaceMethod(ti);\n            if (fun == null) {\n                // not a functional interface\n                infer.checkConvertibleOrDefer(ctx, si, ti, ei, phase, null);\n            }\n\n            // todo special conditions for lambdas/ mrefs\n\n        }\n\n        if (phase.requiresVarargs() && m2Formals.size() == k + 1) {\n            // that is, the invocation has no arguments for the varargs, eg Stream.of()\n            infer.checkConvertibleOrDefer(ctx, phase.ithFormal(m1Formals, k), m2Formals.get(k), site.getExpr(), phase, null);\n        }\n\n        ctx.solve();         // throws ResolutionFailedException\n        ctx.callListeners(); // may throw ResolutionFailedException\n\n        return true;\n    }\n\n    private boolean isMoreSpecificNonGeneric(JMethodSig m1, JMethodSig m2, MethodCallSite site, MethodResolutionPhase phase) {\n        List<JTypeMirror> m1Formals = m1.getFormalParameters();\n        List<JTypeMirror> m2Formals = m2.getFormalParameters();\n        List<ExprMirror> args = site.getExpr().getArgumentExpressions();\n        int k = args.size();\n        for (int i = 0; i < k; i++) {\n            JTypeMirror si = phase.ithFormal(m1Formals, i);\n            JTypeMirror ti = phase.ithFormal(m2Formals, i);\n            if (!isTypeMoreSpecificForArg(si, ti, args.get(i))) {\n                return false;\n            }\n        }\n\n        if (phase.requiresVarargs() && m2Formals.size() == k + 1) {\n            // if the varargs argument has length 0, then the last\n            // formal of m1 must be more specific than the last formal of m2\n            return phase.ithFormal(m1Formals, k).isSubtypeOf(m2Formals.get(k));\n        }\n\n        return true;\n    }\n\n    @SuppressWarnings(\"PMD.UnusedFormalParameter\")\n    private boolean isTypeMoreSpecificForArg(JTypeMirror si, JTypeMirror ti, ExprMirror argExpr) {\n        // A type S is more specific than a type T for any expression if S <: T (\u00a74.10).\n        return si.isSubtypeOf(ti, true); // TODO checks for lambdas/method refs are much more complicated\n    }\n\n    /**\n     * Returns a collector that can apply to a stream of method signatures,\n     * and that collects them into a set of method, where none override one another.\n     * Do not use this in a parallel stream. Do not use this to collect constructors.\n     * Do not use this if your stream contains methods that have different names.\n     *\n     * @param commonSubtype Site where the signatures are observed. The owner of every method\n     *                      in the stream must be a supertype of this type\n     *\n     * @return A collector\n     */\n    public static Collector<JMethodSig, ?, List<JMethodSig>> collectMostSpecific(JTypeMirror commonSubtype) {\n        return Collector.of(\n            OverloadSet::new,\n            (set, sig) -> set.add(sig, commonSubtype),\n            (left, right) -> {\n                throw new NotImplementedException(\"Cannot use this in a parallel stream\");\n            },\n            OverloadSet::getOverloads\n        );\n    }\n}\n", "filePathAfter": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/TypeOps.java", "sourceCodeAfterForWhole": "/*\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.lang.java.types;\n\nimport static net.sourceforge.pmd.lang.java.types.Substitution.EMPTY;\nimport static net.sourceforge.pmd.lang.java.types.Substitution.mapping;\nimport static net.sourceforge.pmd.lang.java.types.TypeConversion.capture;\nimport static net.sourceforge.pmd.util.OptionalBool.NO;\nimport static net.sourceforge.pmd.util.OptionalBool.UNKNOWN;\nimport static net.sourceforge.pmd.util.OptionalBool.YES;\nimport static net.sourceforge.pmd.util.OptionalBool.definitely;\n\nimport java.lang.reflect.Modifier;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Objects;\nimport java.util.Set;\nimport java.util.function.Function;\nimport java.util.function.Predicate;\nimport java.util.stream.Collector;\nimport java.util.stream.Collectors;\n\nimport org.apache.commons.lang3.NotImplementedException;\nimport org.checkerframework.checker.nullness.qual.NonNull;\nimport org.checkerframework.checker.nullness.qual.Nullable;\n\nimport net.sourceforge.pmd.internal.util.IteratorUtil;\nimport net.sourceforge.pmd.lang.java.symbols.JClassSymbol;\nimport net.sourceforge.pmd.lang.java.symbols.JExecutableSymbol;\nimport net.sourceforge.pmd.lang.java.symbols.JMethodSymbol;\nimport net.sourceforge.pmd.lang.java.symbols.table.coreimpl.CoreResolvers;\nimport net.sourceforge.pmd.lang.java.symbols.table.coreimpl.NameResolver;\nimport net.sourceforge.pmd.lang.java.symbols.table.internal.JavaResolvers;\nimport net.sourceforge.pmd.lang.java.types.JVariableSig.FieldSig;\nimport net.sourceforge.pmd.lang.java.types.internal.infer.JInferenceVar;\nimport net.sourceforge.pmd.lang.java.types.internal.infer.JInferenceVar.BoundKind;\nimport net.sourceforge.pmd.util.CollectionUtil;\nimport net.sourceforge.pmd.util.OptionalBool;\n\n/**\n * Common operations on types.\n */\n@SuppressWarnings(\"PMD.CompareObjectsWithEquals\")\npublic final class TypeOps {\n\n    private TypeOps() {\n        // utility class\n    }\n\n\n    // <editor-fold  defaultstate=\"collapsed\" desc=\"Type equality\">\n\n    public static boolean isSameType(JMethodSig t, JMethodSig s) {\n        return t.getDeclaringType().equals(s.getDeclaringType()) && haveSameSignature(t, s);\n    }\n\n    /*\n     * Note that type mirror implementations use this method as their\n     * Object#equals, which means it can't be used here unless it's on\n     * the smaller parts of a type.\n     */\n\n    public static boolean isSameType(JTypeMirror t, JTypeMirror s) {\n        return isSameType(t, s, false);\n    }\n\n    /**\n     * Returns true if t and s are the same type. If 'inInference' is\n     * true, then encountering inference variables produces side effects\n     * on them, adding bounds.\n     */\n    public static boolean isSameType(JTypeMirror t, JTypeMirror s, boolean inInference) {\n        if (t == s) {\n            // also returns true if both t and s are null\n            return true;\n        }\n\n        if (t == null || s == null) {\n            return false;\n        }\n\n        if (!inInference) {\n            return t.acceptVisitor(SameTypeVisitor.PURE, s);\n        }\n\n        // reorder\n        if (t instanceof JInferenceVar) {\n            return t.acceptVisitor(SameTypeVisitor.INFERENCE, s);\n        } else {\n            return s.acceptVisitor(SameTypeVisitor.INFERENCE, t);\n        }\n    }\n\n    public static boolean areSameTypes(List<JTypeMirror> ts, List<JTypeMirror> ss, boolean inInference) {\n        return areSameTypes(ts, ss, EMPTY, inInference);\n    }\n\n    public static boolean areSameTypes(List<JTypeMirror> ts, List<JTypeMirror> ss, Substitution subst) {\n        return areSameTypes(ts, ss, subst, false);\n    }\n\n    public static boolean areSameTypes(List<JTypeMirror> ts, List<JTypeMirror> ss, Substitution subst, boolean inInference) {\n        if (ts.size() != ss.size()) {\n            return false;\n        }\n        for (int i = 0; i < ts.size(); i++) {\n            if (!isSameType(ts.get(i), ss.get(i).subst(subst), inInference)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static boolean allArgsAreUnboundedWildcards(List<JTypeMirror> sargs) {\n        for (JTypeMirror sarg : sargs) {\n            if (!(sarg instanceof JWildcardType) || !((JWildcardType) sarg).isUnbounded()) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private static class SameTypeVisitor implements JTypeVisitor<Boolean, JTypeMirror> {\n\n        static final SameTypeVisitor INFERENCE = new SameTypeVisitor(true);\n        static final SameTypeVisitor PURE = new SameTypeVisitor(false);\n\n        private final boolean inInference;\n\n        private SameTypeVisitor(boolean inInference) {\n            this.inInference = inInference;\n        }\n\n        @Override\n        public Boolean visit(JTypeMirror t, JTypeMirror s) {\n            // for primitive & sentinel types\n            return t == s;\n        }\n\n        @Override\n        public Boolean visitClass(JClassType t, JTypeMirror s) {\n            if (s instanceof JClassType) {\n                JClassType s2 = (JClassType) s;\n                return t.getSymbol().getBinaryName().equals(s2.getSymbol().getBinaryName())\n                    && t.hasErasedSuperTypes() == s2.hasErasedSuperTypes()\n                    && isSameType(t.getEnclosingType(), s2.getEnclosingType(), inInference)\n                    && areSameTypes(t.getTypeArgs(), s2.getTypeArgs(), inInference);\n            }\n            return false;\n        }\n\n        @Override\n        public Boolean visitTypeVar(JTypeVar t, JTypeMirror s) {\n            return t.equals(s);\n        }\n\n        @Override\n        public Boolean visitWildcard(JWildcardType t, JTypeMirror s) {\n            if (!(s instanceof JWildcardType)) {\n                return false;\n            }\n            JWildcardType s2 = (JWildcardType) s;\n            return s2.isUpperBound() == t.isUpperBound() && isSameType(t.getBound(), s2.getBound(), inInference);\n        }\n\n        @Override\n        public Boolean visitInferenceVar(JInferenceVar t, JTypeMirror s) {\n            if (!inInference) {\n                return t == s;\n            }\n\n            if (s instanceof JPrimitiveType) {\n                return false;\n            }\n\n            if (s instanceof JWildcardType) {\n                JWildcardType s2 = (JWildcardType) s;\n                if (s2.isUpperBound()) {\n                    t.addBound(BoundKind.UPPER, s2.asUpperBound());\n                } else {\n                    t.addBound(BoundKind.LOWER, s2.asLowerBound());\n                }\n                return true;\n            }\n\n            // add an equality bound\n            t.addBound(BoundKind.EQ, s);\n            return true;\n        }\n\n        @Override\n        public Boolean visitIntersection(JIntersectionType t, JTypeMirror s) {\n            if (!(s instanceof JIntersectionType)) {\n                return false;\n            }\n\n            JIntersectionType s2 = (JIntersectionType) s;\n\n            // order is irrelevant\n\n            if (s2.getComponents().size() != t.getComponents().size()) {\n                return false;\n            }\n\n            if (!isSameType(t.getPrimaryBound(), s2.getPrimaryBound(), inInference)) {\n                return false;\n            }\n\n            Map<JTypeMirror, JTypeMirror> tMap = new HashMap<>();\n            for (JTypeMirror ti : t.getInterfaces()) {\n                tMap.put(ti.getErasure(), ti);\n            }\n            for (JTypeMirror si : s2.getInterfaces()) {\n                JTypeMirror siErased = si.getErasure();\n                if (!tMap.containsKey(siErased)) {\n                    return false;\n                }\n                JTypeMirror ti = tMap.remove(siErased);\n                if (!isSameType(ti, si, inInference)) {\n                    return false;\n                }\n            }\n            return tMap.isEmpty();\n        }\n\n        @Override\n        public Boolean visitArray(JArrayType t, JTypeMirror s) {\n            if (s instanceof JArrayType) {\n                return isSameType(t.getComponentType(), ((JArrayType) s).getComponentType(), inInference);\n            }\n            return false;\n        }\n    }\n\n    // </editor-fold>\n\n    // <editor-fold  defaultstate=\"collapsed\" desc=\"Supertype enumeration\">\n\n\n    /**\n     * Returns the set of all supertypes of the given type.\n     *\n     * @see JTypeMirror#getSuperTypeSet()\n     */\n    public static Set<JTypeMirror> getSuperTypeSet(@NonNull JTypeMirror t) {\n        Set<JTypeMirror> result = new LinkedHashSet<>();\n        t.acceptVisitor(SuperTypesVisitor.INSTANCE, result);\n        assert !result.isEmpty() : \"Empty supertype set for \" + t;\n        return result;\n    }\n\n    private static final class SuperTypesVisitor implements JTypeVisitor<Void, Set<JTypeMirror>> {\n\n        static final SuperTypesVisitor INSTANCE = new SuperTypesVisitor();\n\n        @Override\n        public Void visit(JTypeMirror t, Set<JTypeMirror> result) {\n            throw new IllegalStateException(\"Should not be called\");\n        }\n\n        @Override\n        public Void visitTypeVar(JTypeVar t, Set<JTypeMirror> result) {\n            if (result.add(t)) {\n                // prevent infinite loop\n                t.getUpperBound().acceptVisitor(this, result);\n            }\n            return null;\n        }\n\n        @Override\n        public Void visitNullType(JTypeMirror t, Set<JTypeMirror> result) {\n            // too many types\n            throw new IllegalArgumentException(\"The null type has all reference types as supertype\");\n        }\n\n        @Override\n        public Void visitSentinel(JTypeMirror t, Set<JTypeMirror> result) {\n            result.add(t);\n            return null;\n        }\n\n        @Override\n        public Void visitInferenceVar(JInferenceVar t, Set<JTypeMirror> result) {\n            result.add(t);\n            return null;\n        }\n\n        @Override\n        public Void visitWildcard(JWildcardType t, Set<JTypeMirror> result) {\n            t.asUpperBound().acceptVisitor(this, result);\n            // wildcards should be captured and so we should not end up here\n            return null;\n        }\n\n        @Override\n        public Void visitClass(JClassType t, Set<JTypeMirror> result) {\n            result.add(t);\n\n\n            // prefer digging up the superclass first\n            JClassType sup = t.getSuperClass();\n            if (sup != null) {\n                sup.acceptVisitor(this, result);\n            }\n            for (JClassType i : t.getSuperInterfaces()) {\n                visitClass(i, result);\n            }\n            if (t.isInterface() && t.getSuperInterfaces().isEmpty()) {\n                result.add(t.getTypeSystem().OBJECT);\n            }\n            return null;\n        }\n\n        @Override\n        public Void visitIntersection(JIntersectionType t, Set<JTypeMirror> result) {\n            for (JTypeMirror it : t.getComponents()) {\n                it.acceptVisitor(this, result);\n            }\n            return null;\n        }\n\n        @Override\n        public Void visitArray(JArrayType t, Set<JTypeMirror> result) {\n            result.add(t);\n\n            TypeSystem ts = t.getTypeSystem();\n\n            for (JTypeMirror componentSuper : t.getComponentType().getSuperTypeSet()) {\n                result.add(ts.arrayType(componentSuper));\n            }\n            result.add(ts.CLONEABLE);\n            result.add(ts.SERIALIZABLE);\n            result.add(ts.OBJECT);\n\n            return null;\n        }\n\n        @Override\n        public Void visitPrimitive(JPrimitiveType t, Set<JTypeMirror> result) {\n            result.addAll(t.getSuperTypeSet()); // special implementation in JPrimitiveType\n            return null;\n        }\n    }\n\n    // </editor-fold>\n\n    // <editor-fold  defaultstate=\"collapsed\" desc=\"Subtyping\">\n\n    /**\n     * Returns whether if {@code T <: S}, ie T is a subtype of S.\n     *\n     * <p>Note that {@link TypeSystem#ERROR_TYPE} and {@link TypeSystem#UNRESOLVED_TYPE}\n     * are considered subtypes of anything.\n     *\n     * @param t A type T\n     * @param s A type S\n     */\n    public static Subtyping isSubtype(@NonNull JTypeMirror t, @NonNull JTypeMirror s) {\n        if (t == s) {\n            Objects.requireNonNull(t);\n            return Subtyping.YES;\n        } else if (s == t.getTypeSystem().OBJECT) {\n            return Subtyping.definitely(!t.isPrimitive());\n        }\n\n        if (s instanceof JInferenceVar) {\n            // it's possible to add a bound to UNRESOLVED\n            ((JInferenceVar) s).addBound(BoundKind.LOWER, t);\n            return Subtyping.YES;\n        } else if (t == t.getTypeSystem().ERROR_TYPE) {\n            // don't check both, because subtyping must be asymmetric\n            return Subtyping.YES;\n        }\n\n        return capture(t).acceptVisitor(SubtypeVisitor.INSTANCE, s);\n    }\n\n    /**\n     * A result for a subtyping check. The subtyping routines here are\n     * more general than the strict definition of the JLS. For example,\n     * they handle unchecked conversion, and widening conversions between\n     * primitive types.\n     */\n    public enum Subtyping {\n        /** T is not a subtype of S. */\n        NO,\n\n        /**\n         * T is not a subtype of S, but every time T is used in a context\n         * where an S is expected, unchecked conversion converts the T to\n         * an S with a mandated warning. For example the raw type {@code Class}\n         * is convertible to {@code Class<String>} with an unchecked warning.\n         */\n        UNCHECKED_WARNING,\n\n        /**\n         * T is a subtype of S ({@code T <: S}), or one of the following:\n         * <ul>\n         * <li>T and S are primitive types, and T is convertible to S by widening conversion.\n         * For example, {@code int} can be widened to {@code long}.\n         * <li>T is a raw type, which is a subtype of |S|, but S is\n         * parameterized with only unbounded wildcards. This is a special\n         * case of unchecked conversion that produces no warning. For example,\n         * {@code Class<String>} is convertible to {@code Class<?>}.\n         * </ul>\n         *\n         * <p>Note that this ignores any other kind of conversion.\n         */\n        YES;\n\n        public boolean toBoolean(boolean allowUnchecked) {\n            return allowUnchecked ? this != NO\n                                  : this == YES;\n        }\n\n        public boolean evenUnchecked() {\n            return this != NO;\n        }\n\n        /** Preserves the unchecked warning. */\n        Subtyping and(Subtyping b) {\n            if (this == b) {\n                return this;\n            } else if (this == NO || b == NO) {\n                return NO;\n            }\n            return UNCHECKED_WARNING;\n        }\n\n        static Subtyping definitely(boolean b) {\n            return b ? YES : NO;\n        }\n\n        static Subtyping subtypesAll(JTypeMirror t, Iterable<? extends JTypeMirror> supers) {\n            Subtyping result = YES;\n            for (JTypeMirror ui : supers) {\n                Subtyping sub = isSubtype(t, ui);\n                if (sub == NO) {\n                    return NO;\n                }\n                result = result.and(sub);\n            }\n            return result;\n        }\n\n        static Subtyping anySubTypesAny(Iterable<? extends JTypeMirror> us, Iterable<? extends JTypeMirror> vs) {\n            for (JTypeMirror ui : us) {\n                for (JTypeMirror vi : vs) {\n                    Subtyping sub = isSubtype(ui, vi);\n                    if (sub != NO) {\n                        return sub;\n                    }\n                }\n            }\n            return NO;\n        }\n    }\n\n    private static JTypeMirror upperBound(JTypeMirror type) {\n        if (type instanceof JWildcardType) {\n            return upperBound(((JWildcardType) type).asUpperBound());\n        }\n        return type;\n    }\n\n    private static JTypeMirror lowerBound(JTypeMirror type) {\n        if (type instanceof JWildcardType) {\n            return lowerBound(((JWildcardType) type).asLowerBound());\n        }\n        return type;\n    }\n\n    private static JTypeMirror lowerBoundRec(JTypeMirror type) {\n        if (type instanceof JWildcardType) {\n            return lowerBoundRec(((JWildcardType) type).asLowerBound());\n        } else if (type instanceof JTypeVar && ((JTypeVar) type).isCaptured()) {\n            return lowerBoundRec(((JTypeVar) type).getLowerBound());\n        }\n        return type;\n    }\n\n    private static boolean isTypeRange(JTypeMirror s) {\n        return s instanceof JWildcardType\n            || s instanceof JTypeVar && ((JTypeVar) s).isCaptured();\n    }\n\n\n    /**\n     * Returns true if {@code S <= T}, ie \"T contains S\".\n     *\n     * <p>T contains S if:\n     *\n     * <p>{@code L(T) <: L(S) && U(S) <: U(T)}\n     *\n     * <p>This only makes sense for type arguments, it's a component of\n     * subtype checks for parameterized types:\n     *\n     * <p>{@code C<T> <: C<S> if T <= S}\n     *\n     * <p>Defined in JLS\u00a74.5.1 (Type Arguments of Parameterized Types)\n     */\n    public static Subtyping typeArgContains(JTypeMirror t, JTypeMirror s) {\n        // the contains relation can be understood intuitively if we\n        // represent types as ranges on a line:\n\n        // \u22a5 ---------L(T)---L(S)------U(S)-----U(T)---> Object\n        // range of T   [-------------------------]\n        // range of S          [---------]\n\n        // here T contains S because its range is greater\n\n        // since a wildcard is either \"super\" or \"extends\", in reality\n        // either L(T) = \u22a5, or U(T) = Object.\n\n        // meaning when T != S, we only have two scenarios where S <= T:\n\n        //      \u22a5 -------U(S)-----U(T)------> Object   (L(S) = L(T) = \u22a5)\n        //      \u22a5 -------L(T)-----L(S)------> Object   (U(S) = U(T) = Object)\n\n        if (isSameType(t, s, true)) {\n            // T <= T\n            return Subtyping.YES;\n        }\n\n        //        if (t instanceof JWildcardType && s instanceof JTypeVar) {\n        //            if (((JTypeVar) s).isCaptureOf((JWildcardType) t)) {\n        //                return true;\n        //            }\n        //        }\n\n        if (t instanceof JWildcardType) {\n            JWildcardType tw = (JWildcardType) t;\n            if (tw.isUpperBound()) {\n                //  U(S) <: U(T) if T is \"super\" bound (U(T) is top)\n                return isSubtype(upperBound(s), tw.asUpperBound());\n            } else {\n                // L(T) <: L(S) if T is \"extends\" bound (L(T) is bottom)\n                return isSubtype(tw.asLowerBound(), lowerBound(s));\n            }\n        }\n\n        return Subtyping.NO;\n    }\n\n\n    private static final class SubtypeVisitor implements JTypeVisitor<Subtyping, JTypeMirror> {\n\n        static final SubtypeVisitor INSTANCE = new SubtypeVisitor();\n\n        @Override\n        public Subtyping visit(JTypeMirror t, JTypeMirror s) {\n            throw new IllegalStateException(\"Should not be called\");\n        }\n\n        @Override\n        public Subtyping visitTypeVar(JTypeVar t, JTypeMirror s) {\n            if (isTypeRange(s)) {\n                return isSubtype(t, lowerBoundRec(s));\n            }\n            return isSubtype(t.getUpperBound(), s);\n        }\n\n        @Override\n        public Subtyping visitNullType(JTypeMirror t, JTypeMirror s) {\n            return Subtyping.definitely(!s.isPrimitive());\n        }\n\n        @Override\n        public Subtyping visitSentinel(JTypeMirror t, JTypeMirror s) {\n            return Subtyping.YES;\n        }\n\n        @Override\n        public Subtyping visitInferenceVar(JInferenceVar t, JTypeMirror s) {\n            if (s == t.getTypeSystem().NULL_TYPE || s instanceof JPrimitiveType) {\n                return Subtyping.NO;\n            }\n            // here we add a constraint on the variable\n            t.addBound(BoundKind.UPPER, s);\n            return Subtyping.YES;\n        }\n\n        @Override\n        public Subtyping visitWildcard(JWildcardType t, JTypeMirror s) {\n            // wildcards should be captured and so we should not end up here\n            return Subtyping.NO;\n        }\n\n        @Override\n        public Subtyping visitClass(JClassType t, JTypeMirror s) {\n            if (s == t.getTypeSystem().OBJECT) {\n                return Subtyping.YES;\n            }\n\n            if (s instanceof JIntersectionType) {\n                // If S is an intersection, then T must conform to *all* bounds of S\n                // Symmetrically, if T is an intersection, T <: S requires only that\n                // at least one bound of T is a subtype of S.\n                return Subtyping.subtypesAll(t, asList(s));\n            }\n\n            if (isTypeRange(s)) {\n                return isSubtype(t, lowerBoundRec(s));\n            }\n\n            if (!(s instanceof JClassType)) {\n                // note, that this ignores wildcard types,\n                // because they're only compared through\n                // type argument containment.\n                return Subtyping.NO;\n            }\n\n            JClassType cs = (JClassType) s;\n\n            // most specific\n            // if null then not a subtype\n            JClassType superDecl = t.getAsSuper(cs.getSymbol());\n\n            if (superDecl == null) {\n                return Subtyping.NO;\n            } else if (cs.isRaw()) {\n                // a raw type C is a supertype for all the family of parameterized type generated by C<F1, .., Fn>\n                return Subtyping.YES;\n            } else {\n                return typeArgsAreContained(superDecl.getTypeArgs(), cs.getTypeArgs());\n            }\n        }\n\n        /**\n         * Generalises equality to check if for each i, {@code Ti <= Si}.\n         */\n        private Subtyping typeArgsAreContained(List<JTypeMirror> targs, List<JTypeMirror> sargs) {\n            if (targs.isEmpty()) {\n                if (sargs.isEmpty()) {\n                    return Subtyping.YES;\n                }\n                // for some C, S = C<...> and T = C, ie T is raw\n                // T is convertible to S, by unchecked conversion.\n                // If S = D<?, .., ?>, then the conversion produces\n                // no unchecked warning.\n                return allArgsAreUnboundedWildcards(sargs) ? Subtyping.YES\n                                                           : Subtyping.UNCHECKED_WARNING;\n            }\n\n            Subtyping result = Subtyping.YES;\n            for (int i = 0; i < targs.size(); i++) {\n                Subtyping sub = typeArgContains(sargs.get(i), targs.get(i));\n                if (sub == Subtyping.NO) {\n                    return Subtyping.NO;\n                }\n                result = result.and(sub);\n            }\n\n            return result;\n        }\n\n        @Override\n        public Subtyping visitIntersection(JIntersectionType t, JTypeMirror s) {\n            // A & B <: A\n            // A & B <: B\n\n            // But for a class C, `C <: A & B` if `C <: A` and `C <: B`\n\n            // So we can't just say, \"any component of t must subtype s\",\n            // because if s is itself an intersection we have a problem:\n            // Eg let T = S = A & B\n            // T <: S -> A & B <: S\n            //        -> A <: S OR B <: S\n            //        -> A <: A & B OR B <: A & B\n            //        -> false\n\n            // what we mean is, if S is an intersection, then\n            // \"any component of T subtypes any component of S\"\n\n            return Subtyping.anySubTypesAny(t.getComponents(), asList(s));\n        }\n\n        @Override\n        public Subtyping visitArray(JArrayType t, JTypeMirror s) {\n            TypeSystem ts = t.getTypeSystem();\n            if (s == ts.OBJECT || s.equals(ts.CLONEABLE) || s.equals(ts.SERIALIZABLE)) {\n                return Subtyping.YES;\n            }\n\n            if (!(s instanceof JArrayType)) {\n                // not comparable to any other type\n                return Subtyping.NO;\n            }\n\n            JArrayType cs = (JArrayType) s;\n\n            if (t.getComponentType().isPrimitive() || cs.getComponentType().isPrimitive()) {\n                // arrays of primitive types have no sub-/ supertype\n                return Subtyping.definitely(cs.getComponentType() == t.getComponentType());\n            } else {\n                return isSubtype(t.getComponentType(), cs.getComponentType());\n            }\n        }\n\n        @Override\n        public Subtyping visitPrimitive(JPrimitiveType t, JTypeMirror s) {\n            return Subtyping.definitely(t.isSubtypeOf(s, false)); // JPrimitiveType already overrides this\n        }\n    }\n\n    // </editor-fold>\n\n    // <editor-fold  defaultstate=\"collapsed\" desc=\"Substitution\">\n\n    /**\n     * Replace the type variables occurring in the given type to their\n     * image by the given function. Substitutions are not applied\n     * recursively.\n     *\n     * @param type  Type to substitute\n     * @param subst Substitution function, eg a {@link Substitution}\n     */\n    public static JTypeMirror subst(@Nullable JTypeMirror type, Function<? super SubstVar, ? extends @NonNull JTypeMirror> subst) {\n        if (type == null || Substitution.isEmptySubst(subst)) {\n            return type;\n        }\n        return type.subst(subst);\n    }\n\n\n    /** Substitute on a list of types. */\n    public static List<JTypeMirror> subst(List<? extends JTypeMirror> ts, Function<? super SubstVar, ? extends @NonNull JTypeMirror> subst) {\n        return mapPreservingSelf(ts, t -> t.subst(subst));\n    }\n\n    public static List<JClassType> substClasses(List<JClassType> ts, Function<? super SubstVar, ? extends @NonNull JTypeMirror> subst) {\n        return mapPreservingSelf(ts, t -> t.subst(subst));\n    }\n\n    public static List<JTypeVar> substInBoundsOnly(List<JTypeVar> ts, Function<? super SubstVar, ? extends @NonNull JTypeMirror> subst) {\n        return mapPreservingSelf(ts, t -> t.substInBounds(subst));\n    }\n\n    // relies on the fact the original list is unmodifiable or won't be\n    // modified\n    @SuppressWarnings(\"unchecked\")\n    private static @NonNull <T> List<T> mapPreservingSelf(List<? extends T> ts, Function<? super T, ? extends @NonNull T> subst) {\n        // Profiling shows, only 10% of calls to this method need to\n        // create a new list. Substitution in general is a hot spot\n        // of the framework, so optimizing this out is nice\n        List<T> list = null;\n        for (int i = 0, size = ts.size(); i < size; i++) {\n            T it = ts.get(i);\n            T substed = subst.apply(it);\n            if (substed != it) {\n                if (list == null) {\n                    list = Arrays.asList((T[]) ts.toArray()); // NOPMD ClassCastExceptionWithToArray\n                }\n                list.set(i, substed);\n            }\n        }\n\n        // subst relies on the fact that the original list is returned\n        // to avoid new type creation. Thus one cannot use\n        // Collections::unmodifiableList here\n        return list != null ? list : (List<T>) ts;\n    }\n\n    // </editor-fold>\n\n    // <editor-fold  defaultstate=\"collapsed\" desc=\"Projection\">\n\n\n    /**\n     * Returns the upwards projection of the given type, with respect\n     * to the set of capture variables that are found in it. This is\n     * some supertype of T which does not mention those capture variables.\n     * This is used for local variable type inference.\n     *\n     * https://docs.oracle.com/javase/specs/jls/se11/html/jls-4.html#jls-4.10.5\n     */\n    public static JTypeMirror projectUpwards(JTypeMirror t) {\n        return t.acceptVisitor(UPWARDS_PROJECTOR, null);\n    }\n\n    private static final JTypeMirror NO_DOWN_PROJECTION = null;\n    private static final ProjectionVisitor UPWARDS_PROJECTOR = new ProjectionVisitor(true) {\n\n        @Override\n        public JTypeMirror visitTypeVar(JTypeVar t, Void v) {\n            if (t.isCaptured()) {\n                return t.getUpperBound().acceptVisitor(UPWARDS_PROJECTOR, null);\n            }\n            return t;\n        }\n\n\n        @Override\n        public JTypeMirror visitWildcard(JWildcardType t, Void v) {\n            JTypeMirror u = t.getBound().acceptVisitor(UPWARDS_PROJECTOR, null);\n            if (u == t.getBound()) {\n                return t;\n            }\n            TypeSystem ts = t.getTypeSystem();\n\n            if (t.isUpperBound()) {\n                return ts.wildcard(true, u);\n            } else {\n                JTypeMirror down = t.getBound().acceptVisitor(DOWNWARDS_PROJECTOR, null);\n                return down == NO_DOWN_PROJECTION ? ts.UNBOUNDED_WILD : ts.wildcard(false, down);\n            }\n        }\n\n\n        @Override\n        public JTypeMirror visitNullType(JTypeMirror t, Void v) {\n            return t;\n        }\n\n    };\n\n\n    private static final ProjectionVisitor DOWNWARDS_PROJECTOR = new ProjectionVisitor(false) {\n\n        @Override\n        public JTypeMirror visitWildcard(JWildcardType t, Void v) {\n            JTypeMirror u = t.getBound().acceptVisitor(UPWARDS_PROJECTOR, null);\n            if (u == t.getBound()) {\n                return t;\n            }\n            TypeSystem ts = t.getTypeSystem();\n\n            if (t.isUpperBound()) {\n                JTypeMirror down = t.getBound().acceptVisitor(DOWNWARDS_PROJECTOR, null);\n                return down == NO_DOWN_PROJECTION ? NO_DOWN_PROJECTION\n                                                  : ts.wildcard(true, down);\n            } else {\n                return ts.wildcard(false, u);\n            }\n        }\n\n\n        @Override\n        public JTypeMirror visitTypeVar(JTypeVar t, Void v) {\n            if (t.isCaptured()) {\n                return t.getLowerBound().acceptVisitor(DOWNWARDS_PROJECTOR, null);\n            }\n            return t;\n        }\n\n        @Override\n        public JTypeMirror visitNullType(JTypeMirror t, Void v) {\n            return NO_DOWN_PROJECTION;\n        }\n    };\n\n    /**\n     * Restricted type variables are:\n     * - Inference vars\n     * - Capture vars\n     *\n     * See\n     *\n     * https://docs.oracle.com/javase/specs/jls/se11/html/jls-4.html#jls-4.10.5\n     *\n     *\n     * <p>Here we use {@link #NO_DOWN_PROJECTION} as a sentinel\n     * (downwards projection is a partial function). If a type does not mention\n     * restricted type variables, then the visitor should return the original\n     * type (same reference). This allows testing predicates like\n     * <blockquote>\n     * \"If Ai does not mention any restricted type variable, then Ai' = Ai.\"\n     * </blockquote>\n     */\n    private abstract static class ProjectionVisitor implements JTypeVisitor<JTypeMirror, Void> {\n\n        private final boolean upwards;\n\n        private ProjectionVisitor(boolean upwards) {\n            this.upwards = upwards;\n        }\n\n\n        @Override\n        public abstract JTypeMirror visitNullType(JTypeMirror t, Void v);\n\n\n        @Override\n        public abstract JTypeMirror visitWildcard(JWildcardType t, Void v);\n\n\n        @Override\n        public abstract JTypeMirror visitTypeVar(JTypeVar t, Void v);\n\n\n        @Override\n        public JTypeMirror visit(JTypeMirror t, Void v) {\n            return t;\n        }\n\n        @Override\n        public JTypeMirror visitClass(JClassType t, Void v) {\n            if (t.isParameterizedType()) {\n                List<JTypeMirror> targs = t.getTypeArgs();\n                List<JTypeMirror> newTargs = new ArrayList<>(targs.size());\n                List<JTypeVar> formals = t.getFormalTypeParams();\n                boolean change = false;\n\n                for (int i = 0; i < targs.size(); i++) {\n                    JTypeMirror ai = targs.get(i);\n                    JTypeMirror u = ai.acceptVisitor(this, null);\n                    if (u == ai || ai instanceof JWildcardType) {\n                        // no change, or handled by the visitWildcard\n                        newTargs.add(u);\n                        continue;\n                    } else if (!upwards) {\n                        // If Ai is a type that mentions a restricted type variable, then Ai' is undefined.\n                        return NO_DOWN_PROJECTION;\n                    }\n\n                    change = true;\n\n                    /*\n                        If Ai is a type that mentions a restricted type variable...\n                     */\n                    JTypeMirror bi = formals.get(i).getUpperBound();\n\n                    TypeSystem ts = t.getTypeSystem();\n                    if (u != ts.OBJECT\n                        && (mentionsAny(bi, formals) || !bi.isSubtypeOf(u))) {\n                        newTargs.add(ts.wildcard(true, u));\n                    } else {\n                        JTypeMirror down = ai.acceptVisitor(DOWNWARDS_PROJECTOR, null);\n                        if (down == NO_DOWN_PROJECTION) {\n                            newTargs.add(ts.UNBOUNDED_WILD);\n                        } else {\n                            newTargs.add(ts.wildcard(false, down));\n                        }\n                    }\n                }\n\n                return change ? t.withTypeArguments(newTargs) : t;\n            } else {\n                return t;\n            }\n        }\n\n        @Override\n        public JTypeMirror visitIntersection(JIntersectionType t, Void v) {\n            List<JTypeMirror> comps = new ArrayList<>(t.getComponents());\n            boolean change = false;\n            for (int i = 0; i < comps.size(); i++) {\n                JTypeMirror ci = comps.get(i);\n                JTypeMirror proj = ci.acceptVisitor(this, null);\n                if (proj == NO_DOWN_PROJECTION) {\n                    return proj;\n                } else {\n                    comps.set(i, proj);\n                    if (ci != proj) {\n                        change = true;\n                    }\n                }\n            }\n            return change ? t.getTypeSystem().glb(comps) : t;\n        }\n\n        @Override\n        public JTypeMirror visitArray(JArrayType t, Void v) {\n            JTypeMirror comp2 = t.getComponentType().acceptVisitor(this, null);\n            return comp2 == NO_DOWN_PROJECTION\n                   ? NO_DOWN_PROJECTION\n                   : comp2 == t.getComponentType()\n                     ? t : t.getTypeSystem().arrayType(comp2);\n        }\n\n        @Override\n        public JTypeMirror visitSentinel(JTypeMirror t, Void v) {\n            return t;\n        }\n    }\n\n    // </editor-fold>\n\n    // <editor-fold  defaultstate=\"collapsed\" desc=\"Overriding\">\n\n    /**\n     * Returns true if m1 is return-type substitutable with m2. . The notion of return-type-substitutability\n     * supports covariant returns, that is, the specialization of the return type to a subtype.\n     *\n     * https://docs.oracle.com/javase/specs/jls/se9/html/jls-8.html#jls-8.4.5\n     */\n    public static boolean isReturnTypeSubstitutable(JMethodSig m1, JMethodSig m2) {\n\n        JTypeMirror r1 = m1.getReturnType();\n        JTypeMirror r2 = m2.getReturnType();\n\n        if (r1 == r1.getTypeSystem().NO_TYPE) {\n            return r1 == r2;\n        }\n\n        if (r1.isPrimitive()) {\n            return r1 == r2;\n        }\n\n        JMethodSig m1Prime = adaptForTypeParameters(m1, m2);\n        if (m1Prime != null && isSubtype(m1Prime.getReturnType(), r2) != Subtyping.NO) {\n            return true;\n        }\n\n        if (!haveSameSignature(m1, m2)) {\n            return isSameType(r1, r2.getErasure());\n        }\n\n        return false;\n    }\n\n    /**\n     * Adapt m1 to the type parameters of m2. Returns null if that's not possible.\n     *\n     * https://docs.oracle.com/javase/specs/jls/se9/html/jls-8.html#jls-8.4.4\n     */\n    private static @Nullable JMethodSig adaptForTypeParameters(JMethodSig m1, JMethodSig m2) {\n        if (haveSameTypeParams(m1, m2)) {\n            return m1.subst(mapping(m1.getTypeParameters(), m2.getTypeParameters()));\n        }\n\n        return null;\n    }\n\n    private static boolean haveSameTypeParams(JMethodSig m1, JMethodSig m2) {\n        List<JTypeVar> tp1 = m1.getTypeParameters();\n        List<JTypeVar> tp2 = m2.getTypeParameters();\n        if (tp1.size() != tp2.size()) {\n            return false;\n        }\n\n        if (tp1.isEmpty()) {\n            return true;\n        }\n\n        for (int i = 0; i < tp1.size(); i++) {\n            JTypeVar p1 = tp1.get(i);\n            JTypeVar p2 = tp2.get(i);\n\n            if (!isSameType(p1, subst(p2, mapping(tp2, tp1)))) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * Two method signatures m1 and m2 are override-equivalent iff either\n     * m1 is a subsignature of m2 or m2 is a subsignature of m1. This does\n     * not look at the origin of the methods (their declaring class).\n     *\n     * https://docs.oracle.com/javase/specs/jls/se9/html/jls-8.html#jls-8.4.2\n     */\n    public static boolean areOverrideEquivalent(JMethodSig m1, JMethodSig m2) {\n        // This method is a very hot spot as it is used to prune shadowed/overridden/hidden\n        // methods from overload candidates before overload resolution.\n        // Any optimization makes a big impact.\n        if (m1.getArity() != m2.getArity()) {\n            return false; // easy case\n        } else if (m1 == m2) {\n            return true;\n        }\n        // Two methods can only have the same signature if they have the same type parameters\n        // But a generic method is allowed to override a non-generic one, and vice versa\n        // So we first project both methods into a form that has the same number of type parameters\n        boolean m1Gen = m1.isGeneric();\n        boolean m2Gen = m2.isGeneric();\n        if (m1Gen ^ m2Gen) {\n            if (m1Gen) {\n                m1 = m1.getErasure();\n            } else {\n                m2 = m2.getErasure();\n            }\n        }\n        return haveSameSignature(m1, m2);\n    }\n\n    /**\n     * The signature of a method m1 is a subsignature of the signature of a method m2 if either:\n     * - m2 has the same signature as m1, or\n     * - the signature of m1 is the same as the erasure (\u00a74.6) of the signature of m2.\n     */\n    private static boolean isSubSignature(JMethodSig m1, JMethodSig m2) {\n        // prune easy cases\n        if (m1.getArity() != m2.getArity() || !m1.getName().equals(m2.getName())) {\n            return false;\n        }\n        boolean m1Gen = m1.isGeneric();\n        boolean m2Gen = m2.isGeneric();\n        if (m1Gen ^ m2Gen) {\n            if (m1Gen) {\n                return false; // this test is assymetric\n            } else {\n                m2 = m2.getErasure();\n            }\n        }\n        return haveSameSignature(m1, m2);\n    }\n\n    /**\n     * Two methods or constructors, M and N, have the same signature if\n     * they have the same name, the same type parameters (if any) (\u00a78.4.4),\n     * and, after adapting the formal parameter types of N to the the type\n     * parameters of M, the same formal parameter types.\n     *\n     * Thrown exceptions are not part of the signature of a method.\n     */\n    private static boolean haveSameSignature(JMethodSig m1, JMethodSig m2) {\n        if (!m1.getName().equals(m2.getName()) || m1.getArity() != m2.getArity()) {\n            return false;\n        }\n\n        if (!haveSameTypeParams(m1, m2)) {\n            return false;\n        }\n\n        return areSameTypes(m1.getFormalParameters(),\n                            m2.getFormalParameters(),\n                            Substitution.mapping(m2.getTypeParameters(), m1.getTypeParameters()));\n    }\n\n    /**\n     * Returns true if m1 overrides m2, when both are view as members of\n     * class origin. m1 and m2 may be declared in supertypes of origin,\n     * possibly unrelated (default methods), which is why we need that\n     * third parameter. By convention a method overrides itself.\n     *\n     * <p>This method ignores the static modifier. If both methods are\n     * static, then this method tests for <i>hiding</i>. Otherwise, this\n     * method properly tests for overriding. Note that it is an error for\n     * a static method to override an instance method, or the reverse.\n     */\n    public static boolean overrides(JMethodSig m1, JMethodSig m2, JTypeMirror origin) {\n\n        if (m1.isConstructor() || m2.isConstructor()) {\n            return m1.equals(m2); // \"by convention a method overrides itself\"\n        }\n\n        JTypeMirror m1Owner = m1.getDeclaringType();\n        JClassType m2Owner = (JClassType) m2.getDeclaringType();\n\n        if (isOverridableIn(m2, m2Owner.getSymbol(), (JClassSymbol) m1Owner.getSymbol())) {\n            JClassType m2AsM1Supertype = (JClassType) m1Owner.getAsSuper(m2Owner.getSymbol());\n            if (m2AsM1Supertype != null) {\n                JMethodSig m2Prime = m2AsM1Supertype.getDeclaredMethod(m2.getSymbol());\n                assert m2Prime != null;\n                if (isSubSignature(m1, m2Prime)) {\n                    return true;\n                }\n            }\n        }\n\n        // todo that is very weird\n        if (m1.isAbstract()\n            || !m2.isAbstract() && !m2.getSymbol().isDefaultMethod()\n            || !isOverridableIn(m2, m2Owner.getSymbol(), (JClassSymbol) origin.getSymbol())\n            || !(m1Owner instanceof JClassType)) {\n            return false;\n        }\n\n        JTypeMirror m1AsSuper = origin.getAsSuper(((JClassType) m1Owner).getSymbol());\n        JTypeMirror m2AsSuper = origin.getAsSuper(m2Owner.getSymbol());\n        if (m1AsSuper instanceof JClassType && m2AsSuper instanceof JClassType) {\n            m1 = ((JClassType) m1AsSuper).getDeclaredMethod(m1.getSymbol());\n            m2 = ((JClassType) m2AsSuper).getDeclaredMethod(m2.getSymbol());\n            assert m1 != null && m2 != null;\n            return isSubSignature(m1, m2);\n        }\n        return false;\n    }\n\n    /**\n     * Returns true if the given method can be overridden in the origin\n     * class. This only checks access modifiers and not eg whether the\n     * method is final or static. Regardless of whether the method is\n     * final it is overridden - whether this is a compile error or not\n     * is another matter.\n     *\n     * <p>Like {@link #overrides(JMethodSig, JMethodSig, JTypeMirror)},\n     * this does not check the static modifier, and tests for hiding\n     * if the method is static.\n     *\n     * @param m         Method to test\n     * @param declaring Symbol of the declaring type of m\n     * @param origin    Site of the potential override\n     */\n    private static boolean isOverridableIn(JMethodSig m, JClassSymbol declaring, JClassSymbol origin) {\n        final int accessFlags = Modifier.PUBLIC | Modifier.PROTECTED | Modifier.PRIVATE;\n\n        // JLS 8.4.6.1\n        switch (m.getModifiers() & accessFlags) {\n        case Modifier.PUBLIC:\n            return true;\n        case Modifier.PROTECTED:\n            return !origin.isInterface();\n        case 0:\n            // package private\n            return\n                declaring.getPackageName().equals(origin.getPackageName())\n                    && !origin.isInterface();\n        default:\n            // private\n            return false;\n        }\n    }\n\n    // </editor-fold>\n\n    // <editor-fold  defaultstate=\"collapsed\" desc=\"SAM types\">\n\n    /*\n     * Function types of SAM (single-abstract-method) types.\n     *\n     * See https://docs.oracle.com/javase/specs/jls/se11/html/jls-9.html#jls-9.9\n     */\n\n\n    /**\n     * Returns the non-wildcard parameterization of the given functional\n     * interface type. Returns null if such a parameterization does not\n     * exist.\n     *\n     * <p>This is used to remove wildcards from the type of a functional\n     * interface.\n     *\n     * https://docs.oracle.com/javase/specs/jls/se9/html/jls-9.html#jls-9.9\n     *\n     * @param type A parameterized functional interface type\n     */\n    public static @Nullable JClassType nonWildcardParameterization(@NonNull JClassType type) {\n        TypeSystem ts = type.getTypeSystem();\n\n        List<JTypeMirror> targs = type.getTypeArgs();\n        if (targs.stream().noneMatch(it -> it instanceof JWildcardType)) {\n            return type;\n        }\n\n        List<JTypeVar> tparams = type.getFormalTypeParams();\n        List<JTypeMirror> newArgs = new ArrayList<>();\n\n        for (int i = 0; i < tparams.size(); i++) {\n            JTypeMirror ai = targs.get(i);\n            if (ai instanceof JWildcardType) {\n                JTypeVar pi = tparams.get(i);\n                JTypeMirror bi = pi.getUpperBound();\n                if (mentionsAny(bi, new HashSet<JTypeVar>(tparams))) {\n                    return null;\n                }\n\n                JWildcardType ai2 = (JWildcardType) ai;\n\n                if (ai2.isUnbounded()) {\n                    newArgs.add(bi);\n                } else if (ai2.isUpperBound()) {\n                    newArgs.add(ts.glb(Arrays.asList(ai2.asUpperBound(), bi)));\n                } else { // lower bound\n                    newArgs.add(ai2.asLowerBound());\n                }\n\n            } else {\n                newArgs.add(ai);\n            }\n\n        }\n\n        return type.withTypeArguments(newArgs);\n    }\n\n    /**\n     * Finds the method of the given type that can be overridden as a lambda\n     * expression. That is more complicated than \"the unique abstract method\",\n     * it's actually a function type which can override all abstract methods\n     * of the SAM at once.\n     *\n     * https://docs.oracle.com/javase/specs/jls/se9/html/jls-9.html#jls-9.9\n     *\n     * <p>If the parameter is not mappable to a class type with {@link #asClassType(JTypeMirror)},\n     * or if the functional method does not exist, returns null.\n     */\n    public static @Nullable JMethodSig findFunctionalInterfaceMethod(@Nullable JTypeMirror type) {\n        JClassType candidateSam = asClassType(type);\n        if (candidateSam == null) {\n            return null;\n        }\n\n        if (candidateSam.isParameterizedType()) {\n            return findFunctionTypeImpl(nonWildcardParameterization(candidateSam));\n        } else if (candidateSam.isRaw()) {\n            //  The function type of the raw type of a generic functional\n            //  interface I<...> is the erasure of the function type of the generic functional interface I<...>.\n            JMethodSig fun = findFunctionTypeImpl(candidateSam.getGenericTypeDeclaration());\n            return fun == null ? null : fun.getErasure();\n        } else {\n            return findFunctionTypeImpl(candidateSam);\n        }\n    }\n\n    /**\n     * Returns t if it is a class or interface type. If it is an intersection type,\n     * returns the induced class or interface type. Returns null otherwise, including\n     * if the parameter is null.\n     */\n    public static @Nullable JClassType asClassType(@Nullable JTypeMirror t) {\n        if (t instanceof JClassType) {\n            return (JClassType) t;\n        } else if (t instanceof JIntersectionType) {\n            return ((JIntersectionType) t).getInducedClassType();\n        }\n        return null;\n    }\n\n    private static @Nullable JMethodSig findFunctionTypeImpl(@Nullable JClassType candidateSam) {\n\n        if (candidateSam == null || !candidateSam.isInterface() || candidateSam.getSymbol().isAnnotation()) {\n            return null;\n        }\n\n        Map<String, List<JMethodSig>> relevantMethods = candidateSam.streamMethods(it -> !Modifier.isStatic(it.getModifiers()))\n                                                                    .filter(TypeOps::isNotDeclaredInClassObject)\n                                                                    .collect(Collectors.groupingBy(JMethodSig::getName, collectMostSpecific(candidateSam)));\n\n\n        List<JMethodSig> candidates = new ArrayList<>();\n        for (Entry<String, List<JMethodSig>> entry : relevantMethods.entrySet()) {\n            for (JMethodSig sig : entry.getValue()) {\n                if (sig.isAbstract()) {\n                    candidates.add(sig);\n                }\n            }\n        }\n\n        if (candidates.isEmpty()) {\n            return null;\n        } else if (candidates.size() == 1) {\n            return candidates.get(0);\n        }\n\n        JMethodSig currentBest = null;\n\n        nextCandidate:\n        for (int i = 0; i < candidates.size(); i++) {\n            JMethodSig cand = candidates.get(i);\n\n            for (JMethodSig other : candidates) {\n                if (!isSubSignature(cand, other)\n                    || !isReturnTypeSubstitutable(cand, other)) {\n                    continue nextCandidate;\n                }\n            }\n\n            if (currentBest == null) {\n                currentBest = cand;\n            } else if (cand.getReturnType().isSubtypeOf(currentBest.getReturnType())) {\n                // select the most specific return type\n                currentBest = cand;\n            }\n        }\n\n        return currentBest;\n    }\n\n    private static boolean isNotDeclaredInClassObject(JMethodSig it) {\n        TypeSystem ts = it.getDeclaringType().getTypeSystem();\n        return ts.OBJECT.streamMethods(om -> Modifier.isPublic(om.getModifiers()) && om.getSimpleName().equals(it.getName()))\n                        .noneMatch(om -> haveSameSignature(it, om));\n    }\n\n    // </editor-fold>\n\n    // <editor-fold  defaultstate=\"collapsed\" desc=\"As super\">\n\n    /**\n     * @see JTypeMirror#getAsSuper(JClassSymbol)\n     */\n    public static @Nullable JTypeMirror asSuper(JTypeMirror t, JClassSymbol s) {\n\n        if (!t.isPrimitive() && s.equals(t.getTypeSystem().OBJECT.getSymbol())) {\n            // interface types need to have OBJECT somewhere up their hierarchy\n            return t.getTypeSystem().OBJECT;\n        }\n\n        return t.acceptVisitor(AsSuperVisitor.INSTANCE, s);\n    }\n\n    /**\n     * Return the base type of t or any of its outer types that starts\n     * with the given type.  If none exists, return null.\n     */\n    public static JClassType asOuterSuper(JTypeMirror t, JClassSymbol sym) {\n        if (t instanceof JClassType) {\n            JClassType ct = (JClassType) t;\n            do {\n                JClassType sup = ct.getAsSuper(sym);\n                if (sup != null) {\n                    return sup;\n                }\n                ct = ct.getEnclosingType();\n            } while (ct != null);\n        } else if (t instanceof JTypeVar || t instanceof JArrayType) {\n            return (JClassType) t.getAsSuper(sym);\n        }\n        return null;\n    }\n\n    private static final class AsSuperVisitor implements JTypeVisitor<@Nullable JTypeMirror, JClassSymbol> {\n\n        static final AsSuperVisitor INSTANCE = new AsSuperVisitor();\n\n        /** Parameter is the erasure of the target. */\n\n        @Override\n        public JTypeMirror visit(JTypeMirror t, JClassSymbol target) {\n            return null;\n        }\n\n        @Override\n        public JTypeMirror visitClass(JClassType t, JClassSymbol target) {\n            if (target.equals(t.getSymbol())) {\n                return t;\n            }\n\n            // prefer digging up the superclass first\n            JClassType sup = t.getSuperClass();\n            JClassType res = sup == null ? null : (JClassType) sup.acceptVisitor(this, target);\n            if (res != null) {\n                return res;\n            } else {\n                // then look in interfaces if possible\n                if (target.isInterface()) {\n                    return firstResult(target, t.getSuperInterfaces());\n                }\n            }\n\n            return null;\n        }\n\n        @Override\n        public JTypeMirror visitIntersection(JIntersectionType t, JClassSymbol target) {\n            return firstResult(target, t.getComponents());\n        }\n\n        public @Nullable JTypeMirror firstResult(JClassSymbol target, Iterable<? extends JTypeMirror> components) {\n            for (JTypeMirror ci : components) {\n                @Nullable JTypeMirror sup = ci.acceptVisitor(this, target);\n                if (sup != null) {\n                    return sup;\n                }\n            }\n            return null;\n        }\n\n        @Override\n        public JTypeMirror visitTypeVar(JTypeVar t, JClassSymbol target) {\n            // caution, infinite recursion\n            return t.getUpperBound().acceptVisitor(this, target);\n        }\n\n        @Override\n        public JTypeMirror visitArray(JArrayType t, JClassSymbol target) {\n            // Cloneable, Serializable, Object\n            JTypeMirror decl = t.getTypeSystem().declaration(target);\n            return t.isSubtypeOf(decl) ? decl : null;\n        }\n    }\n\n    // </editor-fold>\n\n    // <editor-fold  defaultstate=\"collapsed\" desc=\"LUB/GLB\">\n\n    /**\n     * Returns a subset S of the parameter, whose components have no\n     * strict supertype in S.\n     *\n     * <pre>{@code\n     * S = { V | V in set, and for all W \u2260 V in set, it is not the case that W <: V }\n     * }</pre>\n     */\n    public static Set<JTypeMirror> mostSpecific(Set<? extends JTypeMirror> set) {\n        LinkedHashSet<JTypeMirror> result = new LinkedHashSet<>(set.size());\n        vLoop:\n        for (JTypeMirror v : set) {\n            for (JTypeMirror w : set) {\n                if (!w.equals(v) && w.isSubtypeOf(v, true)) {\n                    continue vLoop;\n                }\n            }\n            result.add(v);\n        }\n        return result;\n    }\n\n    // </editor-fold>\n\n    /**\n     * Returns the components of t if it is an intersection type,\n     * otherwise returns t.\n     */\n    public static List<JTypeMirror> asList(JTypeMirror t) {\n        if (t instanceof JIntersectionType) {\n            return ((JIntersectionType) t).getComponents();\n        } else {\n            return Collections.singletonList(t);\n        }\n    }\n\n    /** Returns a list with the erasures of the given types, may be unmodifiable. */\n    public static List<JTypeMirror> erase(Collection<? extends JTypeMirror> ts) {\n        return CollectionUtil.map(ts, JTypeMirror::getErasure);\n    }\n\n    // <editor-fold  defaultstate=\"collapsed\" desc=\"Mentions\">\n\n\n    public static boolean mentions(@NonNull JTypeVisitable type, @NonNull JInferenceVar parent) {\n        return type.acceptVisitor(MentionsVisitor.INSTANCE, Collections.singleton(parent));\n    }\n\n    public static boolean mentionsAny(JTypeVisitable t, Collection<? extends SubstVar> vars) {\n        return !vars.isEmpty() && t.acceptVisitor(MentionsVisitor.INSTANCE, vars);\n    }\n\n\n    private static final class MentionsVisitor implements JTypeVisitor<Boolean, Collection<? extends JTypeMirror>> {\n\n        static final MentionsVisitor INSTANCE = new MentionsVisitor();\n\n        @Override\n        public Boolean visit(JTypeMirror t, Collection<? extends JTypeMirror> targets) {\n            return false;\n        }\n\n        @Override\n        public Boolean visitTypeVar(JTypeVar t, Collection<? extends JTypeMirror> targets) {\n            return targets.contains(t);\n        }\n\n        @Override\n        public Boolean visitInferenceVar(JInferenceVar t, Collection<? extends JTypeMirror> targets) {\n            return targets.contains(t);\n        }\n\n        @Override\n        public Boolean visitWildcard(JWildcardType t, Collection<? extends JTypeMirror> targets) {\n            return t.getBound().acceptVisitor(this, targets);\n        }\n\n        @Override\n        public Boolean visitMethodType(JMethodSig t, Collection<? extends JTypeMirror> targets) {\n            if (t.getReturnType().acceptVisitor(this, targets)) {\n                return true;\n            }\n            for (JTypeMirror fi : t.getFormalParameters()) {\n                if (fi.acceptVisitor(this, targets)) {\n                    return true;\n                }\n            }\n            for (JTypeMirror ti : t.getThrownExceptions()) {\n                if (ti.acceptVisitor(this, targets)) {\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        @Override\n        public Boolean visitClass(JClassType t, Collection<? extends JTypeMirror> targets) {\n            JClassType encl = t.getEnclosingType();\n            if (encl != null && encl.acceptVisitor(this, targets)) {\n                return true;\n            }\n\n            for (JTypeMirror typeArg : t.getTypeArgs()) {\n                if (typeArg.acceptVisitor(this, targets)) {\n                    return true;\n                }\n            }\n\n            return false;\n        }\n\n        @Override\n        public Boolean visitIntersection(JIntersectionType t, Collection<? extends JTypeMirror> targets) {\n            for (JTypeMirror comp : t.getComponents()) {\n                if (comp.acceptVisitor(this, targets)) {\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        @Override\n        public Boolean visitArray(JArrayType t, Collection<? extends JTypeMirror> targets) {\n            return t.getComponentType().acceptVisitor(this, targets);\n        }\n    }\n\n    // </editor-fold>\n\n    // <editor-fold  defaultstate=\"collapsed\" desc=\"Accessibility utils\">\n\n\n    public static Predicate<JMethodSymbol> accessibleMethodFilter(String name, @NonNull JClassSymbol symbol) {\n        return it -> it.getSimpleName().equals(name) && isAccessible(it, symbol);\n    }\n\n    public static Iterable<JMethodSig> lazyFilterAccessible(List<JMethodSig> visible, @NonNull JClassSymbol accessSite) {\n        return () -> IteratorUtil.filter(visible.iterator(), it -> isAccessible(it.getSymbol(), accessSite));\n    }\n\n    public static List<JMethodSig> filterAccessible(List<JMethodSig> visible, @NonNull JClassSymbol accessSite) {\n        return CollectionUtil.mapNotNull(visible, m -> isAccessible(m.getSymbol(), accessSite) ? m : null);\n    }\n\n\n    public static List<JMethodSig> getMethodsOf(JTypeMirror type, String name, boolean staticOnly, @NonNull JClassSymbol enclosing) {\n        return type.streamMethods(\n            it -> (!staticOnly || Modifier.isStatic(it.getModifiers()))\n                && it.getSimpleName().equals(name)\n                && isAccessible(it, enclosing)\n        ).collect(collectMostSpecific(type));\n    }\n\n    private static boolean isAccessible(JExecutableSymbol method, JClassSymbol ctx) {\n        Objects.requireNonNull(ctx, \"Cannot check a null symbol\");\n\n        int mods = method.getModifiers();\n        if (Modifier.isPublic(mods)) {\n            return true;\n        }\n\n        JClassSymbol owner = method.getEnclosingClass();\n\n        if (Modifier.isPrivate(mods)) {\n            return ctx.getNestRoot().equals(owner.getNestRoot());\n        }\n\n        return ctx.getPackageName().equals(owner.getPackageName())\n            // we can exclude interfaces because their members are all public\n            || Modifier.isProtected(mods) && isSubClassOfNoInterface(ctx, owner);\n    }\n\n    private static boolean isSubClassOfNoInterface(JClassSymbol sub, JClassSymbol symbol) {\n        if (symbol.equals(sub)) {\n            return true;\n        }\n\n        JClassSymbol superclass = sub.getSuperclass();\n        return superclass != null && isSubClassOfNoInterface(superclass, symbol);\n    }\n\n    public static NameResolver<FieldSig> getMemberFieldResolver(JTypeMirror c, @NonNull String accessPackageName, @Nullable JClassSymbol access, String name) {\n        if (c instanceof JClassType) {\n            // fast path\n            return JavaResolvers.getMemberFieldResolver((JClassType) c, accessPackageName, access, name);\n        }\n\n        return c.acceptVisitor(GetFieldVisitor.INSTANCE, new FieldSearchParams(accessPackageName, access, name));\n    }\n\n    private static final class FieldSearchParams {\n\n        private final @NonNull String accessPackageName;\n        private final @Nullable JClassSymbol access;\n        private final String name;\n\n        FieldSearchParams(@NonNull String accessPackageName, @Nullable JClassSymbol access, String name) {\n            this.accessPackageName = accessPackageName;\n            this.access = access;\n            this.name = name;\n        }\n    }\n\n    private static final class GetFieldVisitor implements JTypeVisitor<NameResolver<FieldSig>, FieldSearchParams> {\n\n        static final GetFieldVisitor INSTANCE = new GetFieldVisitor();\n\n        @Override\n        public NameResolver<FieldSig> visit(JTypeMirror t, FieldSearchParams fieldSearchParams) {\n            return CoreResolvers.emptyResolver();\n        }\n\n        @Override\n        public NameResolver<FieldSig> visitClass(JClassType t, FieldSearchParams fieldSearchParams) {\n            return JavaResolvers.getMemberFieldResolver(t, fieldSearchParams.accessPackageName, fieldSearchParams.access, fieldSearchParams.name);\n        }\n\n        @Override\n        public NameResolver<FieldSig> visitTypeVar(JTypeVar t, FieldSearchParams fieldSearchParams) {\n            return t.getUpperBound().acceptVisitor(this, fieldSearchParams);\n        }\n\n        @Override\n        public NameResolver<FieldSig> visitIntersection(JIntersectionType t, FieldSearchParams fieldSearchParams) {\n            return NameResolver.composite(\n                CollectionUtil.map(t.getComponents(), c -> c.acceptVisitor(this, fieldSearchParams))\n            );\n        }\n\n        @Override\n        public NameResolver<FieldSig> visitArray(JArrayType t, FieldSearchParams fieldSearchParams) {\n            if (\"length\".equals(fieldSearchParams.name)) {\n                return CoreResolvers.singleton(\"length\", t.getTypeSystem().sigOf(t, t.getSymbol().getDeclaredField(\"length\")));\n            }\n            return CoreResolvers.emptyResolver();\n        }\n    }\n\n    // </editor-fold>\n\n    // <editor-fold  defaultstate=\"collapsed\" desc=\"Specificity utils\">\n\n\n    /**\n     * Returns a collector that can apply to a stream of method signatures,\n     * and that collects them into a set of method, where none override one another.\n     * Do not use this in a parallel stream. Do not use this to collect constructors.\n     * Do not use this if your stream contains methods that have different names.\n     *\n     * @param commonSubtype Site where the signatures are observed. The owner of every method\n     *                      in the stream must be a supertype of this type\n     *\n     * @return A collector\n     */\n    public static Collector<JMethodSig, ?, List<JMethodSig>> collectMostSpecific(JTypeMirror commonSubtype) {\n        return Collector.of(\n            OverloadSet::new,\n            (set, sig) -> set.add(sig, commonSubtype),\n            (left, right) -> {\n                throw new NotImplementedException(\"Cannot use this in a parallel stream\");\n            },\n            OverloadSet::getOverloads\n        );\n    }\n\n\n    /**\n     * Given that m1 and m2 are override-equivalent, should m1 be chosen\n     * over m2 (YES/NO), or should an ambiguity error arise (UNKNOWN). This\n     * handles a few cases about shadowing/overriding/hiding that are not\n     * covered strictly by the definition of \"specificity\".\n     *\n     * <p>If m1 and m2 are equal, returns the first one by convention.\n     */\n    public static OptionalBool shouldTakePrecedence(JMethodSig m1, JMethodSig m2, JTypeMirror commonSubtype) {\n        // select\n        // 1. the non-bridge\n        // 2. the one that overrides the other\n        // 3. the non-abstract method\n\n        // Symbols don't reflect bridge methods anymore\n        // if (m1.isBridge() != m2.isBridge()) {\n        //      return definitely(!m1.isBridge());\n        // } else\n        if (overrides(m1, m2, commonSubtype)) {\n            return YES;\n        } else if (overrides(m2, m1, commonSubtype)) {\n            return NO;\n        } else if (m1.isAbstract() ^ m2.isAbstract()) {\n            return definitely(!m1.isAbstract());\n        } else if (m1.isAbstract() && m2.isAbstract()) { // last ditch effort\n            // both are unrelated abstract, inherited into 'site'\n            // their signature would be merged into the site\n            // if exactly one is declared in a class, prefer it\n            // if both are declared in a class, ambiguity error (recall, neither overrides the other)\n            // if both are declared in an interface, select any of them\n            boolean m1InClass = m1.getSymbol().getEnclosingClass().isClass();\n            boolean m2Class = m2.getSymbol().getEnclosingClass().isClass();\n\n            return m1InClass && m2Class ? UNKNOWN : definitely(m1InClass);\n        }\n\n        if (Modifier.isPrivate(m1.getModifiers() | m2.getModifiers())\n            && commonSubtype instanceof JClassType) {\n            // One of them is private, which means, they can't be overridden,\n            // so they failed the above test\n            // Maybe it's shadowing then\n            return shadows(m1, m2, (JClassType) commonSubtype);\n        }\n\n        return UNKNOWN;\n    }\n\n\n    /**\n     * Returns whether m1 shadows m2 in the body of the given site, ie\n     * m1 is declared in a class C1 that encloses the site, and m2 is declared\n     * in a type that strictly encloses C1.\n     *\n     * <p>Assumes m1 and m2 are override-equivalent, and declared in different\n     * classes.\n     */\n    static OptionalBool shadows(JMethodSig m1, JMethodSig m2, JClassType site) {\n        final JClassSymbol c1 = m1.getSymbol().getEnclosingClass();\n        final JClassSymbol c2 = m2.getSymbol().getEnclosingClass();\n\n        // We go outward from the `site`. The height measure is the distance\n        // from the site (ie, the reverted depth of each class)\n\n        int height = 0;\n        int c1Height = -1;\n        int c2Height = -1;\n        JClassSymbol c = site.getSymbol();\n\n        while (c != null) {\n            if (c.equals(c1)) {\n                c1Height = height;\n            }\n            if (c.equals(c2)) {\n                c2Height = height;\n            }\n            c = c.getEnclosingClass();\n            height++;\n        }\n\n        if (c1Height < 0 || c2Height < 0 || c1Height == c2Height) {\n            return UNKNOWN;\n        }\n        return definitely(c1Height < c2Height);\n    }\n\n\n    // </editor-fold>\n\n    // <editor-fold  defaultstate=\"collapsed\" desc=\"Miscellaneous\">\n\n\n    /**\n     * Returns true if the type is {@link TypeSystem#UNRESOLVED_TYPE},\n     * {@link TypeSystem#ERROR_TYPE}, or its symbol is unresolved.\n     *\n     * @param t Non-null type\n     *\n     * @throws NullPointerException if the parameter is null\n     */\n    public static boolean isUnresolved(@NonNull JTypeMirror t) {\n        TypeSystem ts = t.getTypeSystem();\n        return t == ts.UNRESOLVED_TYPE || t == ts.ERROR_TYPE || t.getSymbol() != null && t.getSymbol().isUnresolved();\n    }\n\n    public static boolean isUnresolvedOrNull(@Nullable JTypeMirror t) {\n        return t == null || isUnresolved(t);\n    }\n\n    // </editor-fold>\n}\n", "diffSourceCodeSet": [], "invokedMethodSet": ["methodSignature: net.sourceforge.pmd.lang.java.types.internal.infer.OverloadSet#add\n methodBody: void add(JMethodSig sig, JTypeMirror commonSubtype) {\nif(name == null){name=sig.getName();\n}assert sig.getName().equals(name) : \"Not the right name!\";\nassert !sig.isConstructor() : \"Constructors they cannot override each other\";\nListIterator<JMethodSig> iterator=overloads.listIterator();\nwhile(iterator.hasNext()){JMethodSig existing=iterator.next();\nif(areOverrideEquivalent(existing,sig)){switch(shouldTakePrecedence(existing,sig,commonSubtype))case YES:return;\ncase NO:iterator.remove();\nbreak;\ncase UNKNOWN:break;\ndefault:throw new AssertionError();\n}}overloads.add(sig);\n}", "methodSignature: net.sourceforge.pmd.lang.java.types.internal.infer.OverloadSet#getOverloads\n methodBody: public List<JMethodSig> getOverloads() {\nreturn Collections.unmodifiableList(overloads);\n}"], "sourceCodeAfterRefactoring": "/**\n     * Returns a collector that can apply to a stream of method signatures,\n     * and that collects them into a set of method, where none override one another.\n     * Do not use this in a parallel stream. Do not use this to collect constructors.\n     * Do not use this if your stream contains methods that have different names.\n     *\n     * @param commonSubtype Site where the signatures are observed. The owner of every method\n     *                      in the stream must be a supertype of this type\n     *\n     * @return A collector\n     */\n    public static Collector<JMethodSig, ?, List<JMethodSig>> collectMostSpecific(JTypeMirror commonSubtype) {\n        return Collector.of(\n            OverloadSet::new,\n            (set, sig) -> set.add(sig, commonSubtype),\n            (left, right) -> {\n                throw new NotImplementedException(\"Cannot use this in a parallel stream\");\n            },\n            OverloadSet::getOverloads\n        );\n    }", "diffSourceCode": "-  267:     /**\n-  268:      * Returns a collector that can apply to a stream of method signatures,\n-  269:      * and that collects them into a set of method, where none override one another.\n-  270:      * Do not use this in a parallel stream. Do not use this to collect constructors.\n-  271:      * Do not use this if your stream contains methods that have different names.\n-  272:      *\n-  273:      * @param commonSubtype Site where the signatures are observed. The owner of every method\n-  274:      *                      in the stream must be a supertype of this type\n-  275:      *\n-  276:      * @return A collector\n-  277:      */\n-  278:     public static Collector<JMethodSig, ?, List<JMethodSig>> collectMostSpecific(JTypeMirror commonSubtype) {\n-  279:         return Collector.of(\n-  280:             OverloadSet::new,\n-  281:             (set, sig) -> set.add(sig, commonSubtype),\n-  282:             (left, right) -> {\n-  283:                 throw new NotImplementedException(\"Cannot use this in a parallel stream\");\n-  284:             },\n-  285:             OverloadSet::getOverloads\n-  286:         );\n-  287:     }\n+  267:         public Void visit(JTypeMirror t, Set<JTypeMirror> result) {\n+  268:             throw new IllegalStateException(\"Should not be called\");\n+  269:         }\n+  270: \n+  271:         @Override\n+  272:         public Void visitTypeVar(JTypeVar t, Set<JTypeMirror> result) {\n+  273:             if (result.add(t)) {\n+  274:                 // prevent infinite loop\n+  275:                 t.getUpperBound().acceptVisitor(this, result);\n+  276:             }\n+  277:             return null;\n+  278:         }\n+  279: \n+  280:         @Override\n+  281:         public Void visitNullType(JTypeMirror t, Set<JTypeMirror> result) {\n+  282:             // too many types\n+  283:             throw new IllegalArgumentException(\"The null type has all reference types as supertype\");\n+  284:         }\n+  285: \n+  286:         @Override\n+  287:         public Void visitSentinel(JTypeMirror t, Set<JTypeMirror> result) {\n+ 1724:     /**\n+ 1725:      * Returns a collector that can apply to a stream of method signatures,\n+ 1726:      * and that collects them into a set of method, where none override one another.\n+ 1727:      * Do not use this in a parallel stream. Do not use this to collect constructors.\n+ 1728:      * Do not use this if your stream contains methods that have different names.\n+ 1729:      *\n+ 1730:      * @param commonSubtype Site where the signatures are observed. The owner of every method\n+ 1731:      *                      in the stream must be a supertype of this type\n+ 1732:      *\n+ 1733:      * @return A collector\n+ 1734:      */\n+ 1735:     public static Collector<JMethodSig, ?, List<JMethodSig>> collectMostSpecific(JTypeMirror commonSubtype) {\n+ 1736:         return Collector.of(\n+ 1737:             OverloadSet::new,\n+ 1738:             (set, sig) -> set.add(sig, commonSubtype),\n+ 1739:             (left, right) -> {\n+ 1740:                 throw new NotImplementedException(\"Cannot use this in a parallel stream\");\n+ 1741:             },\n+ 1742:             OverloadSet::getOverloads\n+ 1743:         );\n+ 1744:     }\n", "uniqueId": "12d40eb6dcc965cc0523c4f2df71cf52a6a290e8_267_287__1724_1744", "moveFileExist": true, "testResult": true, "coverageInfo": {"INSTRUCTION": {"missed": 0, "covered": 9}, "LINE": {"missed": 0, "covered": 1}, "COMPLEXITY": {"missed": 0, "covered": 1}, "METHOD": {"missed": 0, "covered": 1}}, "compileResultBefore": true, "compileResultCurrent": true, "compileJDK": 11, "refactoringMinerResult": false, "compileAndTestResult": false, "refactoredCode": "To perform the requested refactoring, we will move the `collectMostSpecific` method from the `OverloadComparator` class to an existing class that is appropriate for this method. Given the context of the method, it seems to be related to method signatures and overload resolution, which could fit well in a utility class that deals with method operations.\n\nAfter analyzing the project structure, a suitable candidate for the target file is `TypeOps.java`, as it contains various operations related to types, including method signatures.\n\n### Target File Path\nThe target file path for the moved method will be:\n```\npmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/TypeOps.java\n```\n\n### Moved Class Code\nHere is the code for the `collectMostSpecific` method that will be moved to `TypeOps.java`:\n\n```java\n/**\n * Returns a collector that can apply to a stream of method signatures,\n * and that collects them into a set of method, where none override one another.\n * Do not use this in a parallel stream. Do not use this to collect constructors.\n * Do not use this if your stream contains methods that have different names.\n *\n * @param commonSubtype Site where the signatures are observed. The owner of every method\n *                      in the stream must be a supertype of this type\n *\n * @return A collector\n */\npublic static Collector<JMethodSig, ?, List<JMethodSig>> collectMostSpecific(JTypeMirror commonSubtype) {\n    return Collector.of(\n        OverloadSet::new,\n        (set, sig) -> set.add(sig, commonSubtype),\n        (left, right) -> {\n            throw new NotImplementedException(\"Cannot use this in a parallel stream\");\n        },\n        OverloadSet::getOverloads\n    );\n}\n```\n\n### Refactored Method Code\nThe `OverloadComparator` class will be updated to call the moved method from `TypeOps`. Here is the refactored method code:\n\n```java\npublic static Collector<JMethodSig, ?, List<JMethodSig>> collectMostSpecific(JTypeMirror commonSubtype) {\n    return TypeOps.collectMostSpecific(commonSubtype);\n}\n```\n\n### Final Output\nHere is the complete output in the requested format:\n\n##########################\npmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/TypeOps.java\n##########################\n/**\n * Returns a collector that can apply to a stream of method signatures,\n * and that collects them into a set of method, where none override one another.\n * Do not use this in a parallel stream. Do not use this to collect constructors.\n * Do not use this if your stream contains methods that have different names.\n *\n * @param commonSubtype Site where the signatures are observed. The owner of every method\n *                      in the stream must be a supertype of this type\n *\n * @return A collector\n */\npublic static Collector<JMethodSig, ?, List<JMethodSig>> collectMostSpecific(JTypeMirror commonSubtype) {\n    return Collector.of(\n        OverloadSet::new,\n        (set, sig) -> set.add(sig, commonSubtype),\n        (left, right) -> {\n            throw new NotImplementedException(\"Cannot use this in a parallel stream\");\n        },\n        OverloadSet::getOverloads\n    );\n}\n##########################\npublic static Collector<JMethodSig, ?, List<JMethodSig>> collectMostSpecific(JTypeMirror commonSubtype) {\n    return TypeOps.collectMostSpecific(commonSubtype);\n}\n##########################", "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to Refactor:\n/**\n     * Returns a collector that can apply to a stream of method signatures,\n     * and that collects them into a set of method, where none override one another.\n     * Do not use this in a parallel stream. Do not use this to collect constructors.\n     * Do not use this if your stream contains methods that have different names.\n     *\n     * @param commonSubtype Site where the signatures are observed. The owner of every method\n     *                      in the stream must be a supertype of this type\n     *\n     * @return A collector\n     */\n    public static Collector<JMethodSig, ?, List<JMethodSig>> collectMostSpecific(JTypeMirror commonSubtype) {\n        return Collector.of(\n            OverloadSet::new,\n            (set, sig) -> set.add(sig, commonSubtype),\n            (left, right) -> {\n                throw new NotImplementedException(\"Cannot use this in a parallel stream\");\n            },\n            OverloadSet::getOverloads\n        );\n    }\n\nClass content:\n/*\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.lang.java.types.internal.infer;\n\nimport static net.sourceforge.pmd.lang.java.types.TypeOps.areOverrideEquivalent;\nimport static net.sourceforge.pmd.lang.java.types.TypeOps.overrides;\nimport static net.sourceforge.pmd.util.OptionalBool.NO;\nimport static net.sourceforge.pmd.util.OptionalBool.UNKNOWN;\nimport static net.sourceforge.pmd.util.OptionalBool.YES;\nimport static net.sourceforge.pmd.util.OptionalBool.definitely;\n\nimport java.lang.reflect.Modifier;\nimport java.util.List;\nimport java.util.stream.Collector;\n\nimport org.apache.commons.lang3.NotImplementedException;\nimport org.checkerframework.checker.nullness.qual.NonNull;\n\nimport net.sourceforge.pmd.lang.java.symbols.JClassSymbol;\nimport net.sourceforge.pmd.lang.java.types.JClassType;\nimport net.sourceforge.pmd.lang.java.types.JMethodSig;\nimport net.sourceforge.pmd.lang.java.types.JTypeMirror;\nimport net.sourceforge.pmd.lang.java.types.TypeOps;\nimport net.sourceforge.pmd.lang.java.types.internal.infer.ExprMirror.InvocationMirror.MethodCtDecl;\nimport net.sourceforge.pmd.util.OptionalBool;\n\npublic final class OverloadComparator {\n\n    private final Infer infer;\n    private final TypeInferenceLogger log;\n\n\n    OverloadComparator(Infer infer) {\n        this.infer = infer;\n        this.log = infer.getLogger();\n    }\n\n\n    /**\n     * Returns the most specific method of the two methods for the\n     * given invocation expression, given both are applicable to the\n     * site AND given that the currentBest may be shadowing/overriding/hiding\n     * the candidate if they are override-equivalent.\n     *\n     * <p>https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.12.2.5\n     */\n    @NonNull MethodCtDecl selectMoreSpecific(MethodCtDecl currentBest, MethodCtDecl candidate, MethodCallSite site, MethodResolutionPhase phase) {\n        if (currentBest.isFailed()) {\n            return candidate;\n        } else if (candidate.isFailed()) {\n            return currentBest;\n        }\n\n        JMethodSig m1 = currentBest.getMethodType().internalApi().adaptedMethod();\n        JMethodSig m2 = candidate.getMethodType().internalApi().adaptedMethod();\n\n        return isMoreSpecific(m1, m2, site, phase)\n               ? currentBest\n               : candidate;\n    }\n\n    private boolean isMoreSpecific(@NonNull JMethodSig m1, @NonNull JMethodSig m2, MethodCallSite site, MethodResolutionPhase phase) {\n\n        boolean m1OverM2 = isMoreSpecificImpl(m1, m2, site, phase);\n        boolean m2OverM1 = isMoreSpecificImpl(m2, m1, site, phase);\n\n        if (m1OverM2 != m2OverM1) {\n            // then one of them is strictly more specific than the other\n            return m1OverM2;\n        } else if (areOverrideEquivalent(m1, m2)) {\n\n            OptionalBool result = shouldTakePrecedence(m1, m2, site.getExpr().getReceiverType());\n            if (result == UNKNOWN) {\n                log.ambiguityError(site, m1, m2);\n                // todo if a third method comes in that is more specific\n                //  than all ambiguous methods, then the ambiguity is lifted\n                return true;\n            } else {\n                return result == YES;\n            }\n        }\n\n        return false;\n    }\n\n    // test only\n\n    /**\n     * Given that m1 and m2 are override-equivalent, should m1 be chosen\n     * over m2 (YES/NO), or should an ambiguity error arise (UNKNOWN). This\n     * handles a few cases about shadowing/overriding/hiding that are not\n     * covered strictly by the definition of \"specificity\".\n     *\n     * <p>If m1 and m2 are equal, returns the first one by convention.\n     */\n    static OptionalBool shouldTakePrecedence(JMethodSig m1, JMethodSig m2, JTypeMirror commonSubtype) {\n        // select\n        // 1. the non-bridge\n        // 2. the one that overrides the other\n        // 3. the non-abstract method\n\n        // Symbols don't reflect bridge methods anymore\n        // if (m1.isBridge() != m2.isBridge()) {\n        //      return definitely(!m1.isBridge());\n        // } else\n        if (overrides(m1, m2, commonSubtype)) {\n            return YES;\n        } else if (overrides(m2, m1, commonSubtype)) {\n            return NO;\n        } else if (m1.isAbstract() ^ m2.isAbstract()) {\n            return definitely(!m1.isAbstract());\n        } else if (m1.isAbstract() && m2.isAbstract()) { // last ditch effort\n            // both are unrelated abstract, inherited into 'site'\n            // their signature would be merged into the site\n            // if exactly one is declared in a class, prefer it\n            // if both are declared in a class, ambiguity error (recall, neither overrides the other)\n            // if both are declared in an interface, select any of them\n            boolean m1InClass = m1.getSymbol().getEnclosingClass().isClass();\n            boolean m2Class = m2.getSymbol().getEnclosingClass().isClass();\n\n            return m1InClass && m2Class ? UNKNOWN : definitely(m1InClass);\n        }\n\n        if (Modifier.isPrivate(m1.getModifiers() | m2.getModifiers())\n            && commonSubtype instanceof JClassType) {\n            // One of them is private, which means, they can't be overridden,\n            // so they failed the above test\n            // Maybe it's shadowing then\n            return shadows(m1, m2, (JClassType) commonSubtype);\n        }\n\n        return UNKNOWN;\n    }\n\n\n    /**\n     * Returns whether m1 shadows m2 in the body of the given site, ie\n     * m1 is declared in a class C1 that encloses the site, and m2 is declared\n     * in a type that strictly encloses C1.\n     *\n     * <p>Assumes m1 and m2 are override-equivalent, and declared in different\n     * classes.\n     */\n    static OptionalBool shadows(JMethodSig m1, JMethodSig m2, JClassType site) {\n        final JClassSymbol c1 = m1.getSymbol().getEnclosingClass();\n        final JClassSymbol c2 = m2.getSymbol().getEnclosingClass();\n\n        // We go outward from the `site`. The height measure is the distance\n        // from the site (ie, the reverted depth of each class)\n\n        int height = 0;\n        int c1Height = -1;\n        int c2Height = -1;\n        JClassSymbol c = site.getSymbol();\n\n        while (c != null) {\n            if (c.equals(c1)) {\n                c1Height = height;\n            }\n            if (c.equals(c2)) {\n                c2Height = height;\n            }\n            c = c.getEnclosingClass();\n            height++;\n        }\n\n        if (c1Height < 0 || c2Height < 0 || c1Height == c2Height) {\n            return UNKNOWN;\n        }\n        return definitely(c1Height < c2Height);\n    }\n\n    private boolean isMoreSpecificImpl(JMethodSig m1, JMethodSig m2, MethodCallSite site, MethodResolutionPhase phase) {\n        return m2.isGeneric() ? isInferredMoreSpecific(m1, m2, site, phase)\n                              : isMoreSpecificNonGeneric(m1, m2, site, phase);\n    }\n\n\n    private boolean isInferredMoreSpecific(JMethodSig m1, JMethodSig m2, MethodCallSite site, MethodResolutionPhase phase) {\n        /* TODO\n             https://docs.oracle.com/javase/specs/jls/se8/html/jls-18.html#jls-18.5.4\n     \n             Test case:\n         */\n        try {\n            return doInfer(m1, m2, site, phase);\n        } catch (ResolutionFailedException e) {\n            return false;\n        }\n    }\n\n    private boolean doInfer(JMethodSig m1, JMethodSig m2, MethodCallSite site, MethodResolutionPhase phase) {\n        InferenceContext ctx = infer.newContextFor(m2);\n\n        // even if m1 is generic, the type parameters of m1 are treated as type variables, not inference variables.\n\n        JMethodSig m2p = ctx.mapToIVars(m2);\n\n        List<ExprMirror> es = site.getExpr().getArgumentExpressions();\n        List<JTypeMirror> m1Formals = m1.getFormalParameters();\n        List<JTypeMirror> m2Formals = m2p.getFormalParameters();\n\n        int k = es.size();\n\n        for (int i = 0; i < k; i++) {\n            JTypeMirror ti = phase.ithFormal(m2Formals, i);\n            JTypeMirror si = phase.ithFormal(m1Formals, i);\n            ExprMirror ei = es.get(i);\n\n            if (ctx.isGround(ti) && !isTypeMoreSpecificForArg(si, ti, ei)) {\n                return true;\n            }\n\n            // Otherwise, if Ti is not a functional interface type, the\n            // constraint formula \u2039Si <: Ti\u203a is generated.\n            JMethodSig fun = TypeOps.findFunctionalInterfaceMethod(ti);\n            if (fun == null) {\n                // not a functional interface\n                infer.checkConvertibleOrDefer(ctx, si, ti, ei, phase, null);\n            }\n\n            // todo special conditions for lambdas/ mrefs\n\n        }\n\n        if (phase.requiresVarargs() && m2Formals.size() == k + 1) {\n            // that is, the invocation has no arguments for the varargs, eg Stream.of()\n            infer.checkConvertibleOrDefer(ctx, phase.ithFormal(m1Formals, k), m2Formals.get(k), site.getExpr(), phase, null);\n        }\n\n        ctx.solve();         // throws ResolutionFailedException\n        ctx.callListeners(); // may throw ResolutionFailedException\n\n        return true;\n    }\n\n    private boolean isMoreSpecificNonGeneric(JMethodSig m1, JMethodSig m2, MethodCallSite site, MethodResolutionPhase phase) {\n        List<JTypeMirror> m1Formals = m1.getFormalParameters();\n        List<JTypeMirror> m2Formals = m2.getFormalParameters();\n        List<ExprMirror> args = site.getExpr().getArgumentExpressions();\n        int k = args.size();\n        for (int i = 0; i < k; i++) {\n            JTypeMirror si = phase.ithFormal(m1Formals, i);\n            JTypeMirror ti = phase.ithFormal(m2Formals, i);\n            if (!isTypeMoreSpecificForArg(si, ti, args.get(i))) {\n                return false;\n            }\n        }\n\n        if (phase.requiresVarargs() && m2Formals.size() == k + 1) {\n            // if the varargs argument has length 0, then the last\n            // formal of m1 must be more specific than the last formal of m2\n            return phase.ithFormal(m1Formals, k).isSubtypeOf(m2Formals.get(k));\n        }\n\n        return true;\n    }\n\n    @SuppressWarnings(\"PMD.UnusedFormalParameter\")\n    private boolean isTypeMoreSpecificForArg(JTypeMirror si, JTypeMirror ti, ExprMirror argExpr) {\n        // A type S is more specific than a type T for any expression if S <: T (\u00a74.10).\n        return si.isSubtypeOf(ti, true); // TODO checks for lambdas/method refs are much more complicated\n    }\n\n    /**\n     * Returns a collector that can apply to a stream of method signatures,\n     * and that collects them into a set of method, where none override one another.\n     * Do not use this in a parallel stream. Do not use this to collect constructors.\n     * Do not use this if your stream contains methods that have different names.\n     *\n     * @param commonSubtype Site where the signatures are observed. The owner of every method\n     *                      in the stream must be a supertype of this type\n     *\n     * @return A collector\n     */\n    public static Collector<JMethodSig, ?, List<JMethodSig>> collectMostSpecific(JTypeMirror commonSubtype) {\n        return Collector.of(\n            OverloadSet::new,\n            (set, sig) -> set.add(sig, commonSubtype),\n            (left, right) -> {\n                throw new NotImplementedException(\"Cannot use this in a parallel stream\");\n            },\n            OverloadSet::getOverloads\n        );\n    }\n}\n\nRefactoring Operation:\nMove Method\n\nProject Structure:\n['pmd-java/src/main/java/net/sourceforge/pmd/cpd/JavaLanguage.java', 'pmd-java/src/main/java/net/sourceforge/pmd/cpd/JavaTokenizer.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/JavaLanguageModule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTAdditiveExpression.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTAllocationExpression.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTAmbiguousName.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTAndExpression.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTAnnotation.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTAnnotationMemberList.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTAnnotationMethodDeclaration.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTAnnotationTypeBody.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTAnnotationTypeDeclaration.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTAnonymousClassDeclaration.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTAnyTypeDeclaration.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTArgumentList.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTArguments.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTArrayAccess.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTArrayAllocation.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTArrayDimExpr.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTArrayDimensions.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTArrayDimsAndInits.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTArrayInitializer.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTArrayType.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTArrayTypeDim.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTAssertStatement.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTAssignableExpr.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTAssignmentExpression.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTAssignmentOperator.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTBlock.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTBlockStatement.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTBodyDeclaration.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTBooleanLiteral.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTBreakStatement.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTCastExpression.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTCatchClause.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTCatchParameter.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTCharLiteral.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTClassLiteral.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTClassOrInterfaceBody.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTClassOrInterfaceBodyDeclaration.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTClassOrInterfaceDeclaration.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTClassOrInterfaceType.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTCompilationUnit.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTConditionalAndExpression.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTConditionalExpression.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTConditionalOrExpression.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTConstructorCall.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTConstructorDeclaration.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTContinueStatement.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTDefaultValue.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTDoStatement.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTEmptyDeclaration.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTEmptyStatement.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTEnumBody.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTEnumConstant.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTEnumDeclaration.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTEqualityExpression.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTExclusiveOrExpression.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTExplicitConstructorInvocation.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTExpression.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTExpressionStatement.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTExtendsList.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTFieldAccess.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTFieldDeclaration.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTFinallyClause.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTForInit.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTForStatement.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTForUpdate.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTForeachStatement.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTFormalParameter.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTFormalParameters.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTIfStatement.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTImplementsList.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTImportDeclaration.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTInclusiveOrExpression.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTInfixExpression.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTInitializer.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTInstanceOfExpression.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTIntersectionType.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTLabeledStatement.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTLambdaExpression.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTLambdaParameter.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTLambdaParameterList.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTList.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTLiteral.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTLocalClassStatement.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTLocalVariableDeclaration.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTLoopStatement.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTMemberSelector.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTMemberValue.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTMemberValueArrayInitializer.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTMemberValuePair.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTMethodCall.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTMethodDeclaration.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTMethodDeclarator.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTMethodOrConstructorDeclaration.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTMethodReference.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTModifierList.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTModuleDeclaration.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTModuleDirective.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTModuleName.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTMultiplicativeExpression.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTName.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTNameList.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTNullLiteral.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTNumericLiteral.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTPackageDeclaration.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTPattern.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTPatternExpression.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTPrimaryExpression.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTPrimaryPrefix.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTPrimarySuffix.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTPrimitiveType.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTRSIGNEDSHIFT.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTRUNSIGNEDSHIFT.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTReceiverParameter.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTRecordBody.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTRecordComponent.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTRecordComponentList.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTRecordConstructorDeclaration.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTRecordDeclaration.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTReferenceType.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTRelationalExpression.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTResource.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTResourceList.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTResources.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTResultType.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTReturnStatement.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTShiftExpression.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTStatement.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTStatementExpression.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTStatementExpressionList.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTStringLiteral.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTSuperExpression.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTSwitchArrowBranch.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTSwitchArrowRHS.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTSwitchBranch.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTSwitchExpression.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTSwitchFallthroughBranch.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTSwitchLabel.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTSwitchLike.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTSwitchStatement.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTSynchronizedStatement.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTThisExpression.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTThrowStatement.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTThrowsList.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTTopLevelDeclaration.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTTryStatement.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTType.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTTypeArgument.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTTypeArguments.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTTypeBody.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTTypeBound.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTTypeExpression.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTTypeParameter.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTTypeParameters.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTTypeTestPattern.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTUnaryExpression.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTUnaryExpressionNotPlusMinus.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTUnionType.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTVariableAccess.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTVariableDeclarator.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTVariableDeclaratorId.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTVariableInitializer.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTWhileStatement.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTWildcardBounds.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTWildcardType.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTYieldStatement.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/AbstractAnyTypeDeclaration.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/AbstractJavaExpr.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/AbstractJavaNode.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/AbstractJavaTypeNode.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/AbstractLiteral.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/AbstractMethodOrConstructorDeclaration.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/AbstractStatement.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/AbstractTypeBodyDeclaration.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/AbstractTypedSymbolDeclarator.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/AccessNode.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/Annotatable.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/AssignmentOp.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/AstDisambiguationPass.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/AstImplUtil.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/BinaryOp.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/Comment.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/CommentUtil.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/FinalizableNode.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/FormalComment.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/InternalApiBridge.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/InternalInterfaces.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/InvocationNode.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/JModifier.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/JavaNode.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/JavaParser.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/JavaParserVisitor.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/JavaParserVisitorAdapter.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/JavaTokenDocument.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/JavaVisitorBase.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/JavadocElement.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/LazyTypeResolver.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/LeftRecursiveNode.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/MethodLikeNode.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/MultiLineComment.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/PolyResolution.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/QualifiableExpression.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/SingleLineComment.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/SymbolDeclaratorNode.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/TokenUtils.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/TypeNode.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/TypeParamOwnerNode.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/TypesFromAst.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/UnaryOp.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/internal/ImportWrapper.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/internal/LanguageLevelChecker.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/internal/PrettyPrintingUtil.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/internal/ReportingStrategy.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/package-info.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/internal/JavaAstProcessor.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/internal/JavaDesignerBindings.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/internal/JavaLanguageHandler.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/internal/JavaProcessingStage.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/javadoc/JavadocTag.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/metrics/AbstractJavaClassMetric.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/metrics/AbstractJavaMetric.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/metrics/AbstractJavaOperationMetric.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/metrics/api/JavaClassMetric.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/metrics/api/JavaClassMetricKey.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/metrics/api/JavaOperationMetric.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/metrics/api/JavaOperationMetricKey.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/metrics/internal/AtfdMetric.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/metrics/internal/ClassFanOutMetric.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/metrics/internal/CycloMetric.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/metrics/internal/LocMetric.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/metrics/internal/NcssMetric.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/metrics/internal/NoamMetric.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/metrics/internal/NopaMetric.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/metrics/internal/NpathMetric.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/metrics/internal/TccMetric.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/metrics/internal/WmcMetric.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/metrics/internal/WocMetric.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/metrics/internal/visitors/AtfdBaseVisitor.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/metrics/internal/visitors/ClassFanOutVisitor.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/metrics/internal/visitors/CycloVisitor.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/metrics/internal/visitors/NcssVisitor.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/metrics/internal/visitors/NpathBaseVisitor.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/metrics/internal/visitors/TccAttributeAccessCollector.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/multifile/signature/JavaFieldSigMask.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/multifile/signature/JavaFieldSignature.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/multifile/signature/JavaOperationSigMask.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/multifile/signature/JavaOperationSignature.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/multifile/signature/JavaSigMask.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/multifile/signature/JavaSignature.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/AbstractIgnoredAnnotationRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/AbstractInefficientZeroCheck.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/AbstractJUnitRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/AbstractJavaMetricsRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/AbstractJavaRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/AbstractJavaRulechainRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/AbstractLombokAwareRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/AbstractPoorMethodCall.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/JavaRuleViolation.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/bestpractices/AbstractClassWithoutAbstractMethodRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/bestpractices/AbstractPositionLiteralsFirstInComparisons.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/bestpractices/AbstractSunSecureRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/bestpractices/AccessorClassGenerationRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/bestpractices/AccessorMethodGenerationRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/bestpractices/ArrayIsStoredDirectlyRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/bestpractices/AvoidReassigningCatchVariablesRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/bestpractices/AvoidReassigningLoopVariablesRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/bestpractices/AvoidReassigningParametersRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/bestpractices/AvoidUsingHardCodedIPRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/bestpractices/CheckResultSetRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/bestpractices/ForLoopCanBeForeachRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/bestpractices/GuardLogStatementRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/bestpractices/JUnitAssertionsShouldIncludeMessageRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/bestpractices/JUnitTestsShouldIncludeAssertRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/bestpractices/JUnitUseExpectedRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/bestpractices/LiteralsFirstInComparisonsRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/bestpractices/LooseCouplingRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/bestpractices/MethodReturnsInternalArrayRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/bestpractices/MissingOverrideRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/bestpractices/PositionLiteralsFirstInCaseInsensitiveComparisonsRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/bestpractices/PositionLiteralsFirstInComparisonsRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/bestpractices/PreserveStackTraceRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/bestpractices/UnusedAssignmentRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/bestpractices/UnusedFormalParameterRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/bestpractices/UnusedImportsRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/bestpractices/UnusedLocalVariableRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/bestpractices/UnusedPrivateFieldRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/bestpractices/UnusedPrivateMethodRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/bestpractices/UseCollectionIsEmptyRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/codestyle/AbstractNamingConventionRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/codestyle/AtLeastOneConstructorRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/codestyle/AvoidDollarSignsRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/codestyle/ClassNamingConventionsRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/codestyle/CommentDefaultAccessModifierRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/codestyle/ConfusingTernaryRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/codestyle/DontImportJavaLangRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/codestyle/DuplicateImportsRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/codestyle/FieldDeclarationsShouldBeAtStartOfClassRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/codestyle/FieldNamingConventionsRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/codestyle/FormalParameterNamingConventionsRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/codestyle/IdenticalCatchBranchesRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/codestyle/LinguisticNamingRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/codestyle/LocalVariableCouldBeFinalRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/codestyle/LocalVariableNamingConventionsRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/codestyle/MethodArgumentCouldBeFinalRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/codestyle/MethodNamingConventionsRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/codestyle/OnlyOneReturnRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/codestyle/PrematureDeclarationRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/codestyle/UnnecessaryAnnotationValueElementRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/codestyle/UnnecessaryCastRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/codestyle/UnnecessaryConstructorRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/codestyle/UnnecessaryFullyQualifiedNameRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/codestyle/UnnecessaryLocalBeforeReturnRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/codestyle/UnnecessaryModifierRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/codestyle/UnnecessaryReturnRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/design/AvoidDeeplyNestedIfStmtsRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/design/AvoidThrowingNullPointerExceptionRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/design/CouplingBetweenObjectsRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/design/CyclomaticComplexityRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/design/DataClassRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/design/ExceptionAsFlowControlRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/design/ExcessiveClassLengthRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/design/ExcessiveImportsRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/design/ExcessiveMethodLengthRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/design/ExcessiveParameterListRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/design/ExcessivePublicCountRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/design/GodClassRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/design/ImmutableFieldRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/design/LawOfDemeterRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/design/LoosePackageCouplingRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/design/NPathComplexityRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/design/NcssCountRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/design/SignatureDeclareThrowsExceptionRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/design/SimplifyBooleanReturnsRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/design/SingularFieldRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/design/SwitchDensityRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/design/TooManyFieldsRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/design/UseUtilityClassRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/design/UselessOverridingMethodRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/documentation/AbstractCommentRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/documentation/CommentContentRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/documentation/CommentRequiredRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/documentation/CommentSizeRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/errorprone/AssignmentInOperandRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/errorprone/AssignmentToNonFinalStaticRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/errorprone/AvoidBranchingStatementAsLastInLoopRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/errorprone/AvoidCallingFinalizeRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/errorprone/AvoidCatchingThrowableRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/errorprone/AvoidDuplicateLiteralsRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/errorprone/AvoidFieldNameMatchingMethodNameRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/errorprone/AvoidFieldNameMatchingTypeNameRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/errorprone/AvoidMultipleUnaryOperatorsRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/errorprone/AvoidUsingOctalValuesRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/errorprone/BeanMembersShouldSerializeRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/errorprone/BrokenNullCheckRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/errorprone/CheckSkipResultRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/errorprone/CloneMethodMustImplementCloneableRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/errorprone/CloseResourceRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/errorprone/CompareObjectsWithEqualsRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/errorprone/ConstructorCallsOverridableMethodRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/errorprone/DontImportSunRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/errorprone/IdempotentOperationsRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/errorprone/ImportFromSamePackageRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/errorprone/InvalidLogMessageFormatRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/errorprone/JUnitSpellingRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/errorprone/JUnitStaticSuiteRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/errorprone/MethodWithSameNameAsEnclosingClassRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/errorprone/MoreThanOneLoggerRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/errorprone/NullAssignmentRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/errorprone/OverrideBothEqualsAndHashcodeRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/errorprone/ProperCloneImplementationRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/errorprone/SingleMethodSingletonRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/errorprone/SingletonClassReturningNewInstanceRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/errorprone/SuspiciousHashcodeMethodNameRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/errorprone/SuspiciousOctalEscapeRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/errorprone/TestClassWithoutTestCasesRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/errorprone/UnnecessaryCaseChangeRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/errorprone/UnnecessaryConversionTemporaryRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/errorprone/UselessOperationOnImmutableRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/internal/AbstractJavaCounterCheckRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/internal/AnnotationSuppressionUtil.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/internal/JavaRuleViolationFactory.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/multithreading/DoubleCheckedLockingRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/multithreading/NonThreadSafeSingletonRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/multithreading/UnsynchronizedStaticFormatterRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/package-info.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/performance/AbstractOptimizationRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/performance/AppendCharacterWithCharRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/performance/AvoidInstantiatingObjectsInLoopsRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/performance/BigIntegerInstantiationRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/performance/BooleanInstantiationRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/performance/ConsecutiveAppendsShouldReuseRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/performance/ConsecutiveLiteralAppendsRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/performance/InefficientEmptyStringCheckRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/performance/InefficientStringBufferingRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/performance/InsufficientStringBufferDeclarationRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/performance/RedundantFieldInitializerRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/performance/StringInstantiationRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/performance/StringToStringRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/performance/UnnecessaryWrapperObjectCreationRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/performance/UseIndexOfCharRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/performance/UseStringBufferForStringAppendsRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/performance/UseStringBufferLengthRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/performance/UselessStringValueOfRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/regex/RegexHelper.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/security/HardCodedCryptoKeyRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/security/InsecureCryptoIvRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/security/TypeResTestRule.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/BoundToNode.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/JAccessibleElementSymbol.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/JClassSymbol.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/JConstructorSymbol.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/JElementSymbol.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/JExecutableSymbol.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/JFieldSymbol.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/JFormalParamSymbol.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/JLocalVariableSymbol.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/JMethodSymbol.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/JTypeDeclSymbol.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/JTypeParameterOwnerSymbol.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/JTypeParameterSymbol.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/JVariableSymbol.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/SymbolResolver.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/SymbolVisitor.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/internal/FlexibleUnresolvedClassImpl.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/internal/ImplicitMemberSymbols.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/internal/SymbolEquality.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/internal/SymbolFactory.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/internal/SymbolToStrings.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/internal/UnresolvedClassImpl.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/internal/UnresolvedClassStore.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/internal/asm/AsmStub.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/internal/asm/AsmSymbolResolver.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/internal/asm/ClassStub.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/internal/asm/ClassStubBuilder.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/internal/asm/ExecutableStub.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/internal/asm/FieldStub.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/internal/asm/GenericSigBase.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/internal/asm/LazyTypeSig.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/internal/asm/Loader.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/internal/asm/MemberStubBase.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/internal/asm/ParseLock.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/internal/asm/SignatureParser.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/internal/asm/SignatureScanner.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/internal/asm/SoftClassReference.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/internal/asm/TParamStub.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/internal/asm/TypeParamsParser.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/internal/asm/TypeSigParser.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/internal/ast/AbstractAstBackedSymbol.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/internal/ast/AbstractAstExecSymbol.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/internal/ast/AbstractAstTParamOwner.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/internal/ast/AbstractAstVariableSym.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/internal/ast/AstClassSym.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/internal/ast/AstCtorSym.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/internal/ast/AstFieldSym.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/internal/ast/AstFormalParamSym.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/internal/ast/AstLocalVarSym.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/internal/ast/AstMethodSym.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/internal/ast/AstSymFactory.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/internal/ast/AstSymbolMakerVisitor.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/internal/ast/AstTypeParamSym.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/internal/ast/MapSymResolver.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/internal/ast/SymbolResolutionPass.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/package-info.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/table/JSymbolTable.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/table/ScopeInfo.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/table/coreimpl/CachingShadowChainNode.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/table/coreimpl/CoreResolvers.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/table/coreimpl/MostlySingularMultimap.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/table/coreimpl/NameResolver.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/table/coreimpl/ShadowChain.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/table/coreimpl/ShadowChainBuilder.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/table/coreimpl/ShadowChainIterator.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/table/coreimpl/ShadowChainIteratorImpl.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/table/coreimpl/ShadowChainNode.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/table/coreimpl/ShadowChainNodeBase.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/table/coreimpl/ShadowChainRoot.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/table/internal/JavaResolvers.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/table/internal/ScopeInfo.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/table/internal/SemanticChecksLogger.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/table/internal/SuperTypesEnumerator.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/table/internal/SymTableFactory.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/table/internal/SymbolChainBuilder.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/table/internal/SymbolTableImpl.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/table/internal/SymbolTableResolver.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symboltable/AbstractJavaScope.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symboltable/ClassNameDeclaration.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symboltable/ClassScope.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symboltable/DeclarationFinderFunction.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symboltable/JavaNameOccurrence.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symboltable/LocalScope.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symboltable/MethodNameDeclaration.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symboltable/MethodScope.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symboltable/NameFinder.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symboltable/OccurrenceFinder.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symboltable/ScopeAndDeclarationFinder.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symboltable/Search.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symboltable/SimpleTypedNameDeclaration.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symboltable/SourceFileScope.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symboltable/SymbolFacade.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symboltable/TypeSet.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symboltable/TypedNameDeclaration.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symboltable/VariableNameDeclaration.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symboltable/package-info.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/typeresolution/ClassTypeResolver.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/typeresolution/PMDASMClassLoader.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/typeresolution/TypeHelper.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/typeresolution/internal/NullableClassLoader.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/typeresolution/visitors/PMDASMVisitor.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/ArrayMethodSigImpl.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/ArraySymbolImpl.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/BasePrimitiveSymbol.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/BoxedPrimitive.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/CaptureMatcher.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/ClassMethodSigImpl.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/ClassTypeImpl.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/ErasedClassType.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/FakeIntersectionSymbol.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/JArrayType.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/JClassType.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/JIntersectionType.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/JMethodSig.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/JPrimitiveType.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/JTypeMirror.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/JTypeVar.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/JTypeVisitable.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/JTypeVisitor.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/JVariableSig.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/JWildcardType.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/LexicalScope.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/Lub.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/MapFunction.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/SentinelType.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/SubstVar.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/Substitution.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/TypeConversion.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/TypeOps.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/TypePrettyPrint.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/TypeSystem.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/TypeVarImpl.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/TypesFromReflection.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/UnresolvedMethodSig.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/WildcardTypeImpl.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/internal/InternalMethodTypeItf.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/internal/infer/ExprCheckHelper.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/internal/infer/ExprMirror.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/internal/infer/ExprOps.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/internal/infer/Graph.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/internal/infer/IncorporationAction.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/internal/infer/Infer.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/internal/infer/InferenceContext.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/internal/infer/InferenceVarSym.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/internal/infer/JInferenceVar.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/internal/infer/MethodCallSite.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/internal/infer/MethodResolutionPhase.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/internal/infer/OverloadComparator.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/internal/infer/OverloadSet.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/internal/infer/PolySite.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/internal/infer/ReductionStep.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/internal/infer/ResolutionFailedException.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/internal/infer/ResolutionFailure.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/internal/infer/TypeInferenceLogger.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/internal/infer/VarWalkStrategy.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/internal/infer/ast/BaseExprMirror.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/internal/infer/ast/BaseInvocMirror.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/internal/infer/ast/BasePolyMirror.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/internal/infer/ast/ConditionalMirrorImpl.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/internal/infer/ast/CtorInvocMirror.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/internal/infer/ast/JavaExprMirrors.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/internal/infer/ast/LambdaMirrorImpl.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/internal/infer/ast/MethodInvocMirror.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/internal/infer/ast/MethodRefMirrorImpl.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/internal/infer/ast/StandaloneExprMirror.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/internal/infer/ast/SwitchMirror.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/package-info.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/xpath/GetCommentOnFunction.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/xpath/JavaFunctions.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/xpath/MetricFunction.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/xpath/TypeIsExactlyFunction.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/xpath/TypeIsFunction.java', 'pmd-java/src/main/java/net/sourceforge/pmd/lang/java/xpath/TypeOfFunction.java']\n\nInstructions:\n1. Analyze the provided code, class content, and project structure, apply move method refactoring to the code to be refactored, output the target file path, moved class code, and refactored method code.\nNeed to move to an existing java file\nThe moved method code should be updated to the public static method.\nThe refactored method code should use the moved class to call the moved method.\nThe target file path should be the path of the existing class where the method is moved to.\n\n2. If refactoring is performed, output the target file path, moved class code, and refactored method code in the following format:\n##########################\ntarget_file_path\n##########################\nmoved_class_code\n##########################\nrefactored_method_code\n##########################\n\n\n\n"}, {"type": "Extract Method", "description": "Extract Method\tpublic addBound(kind BoundKind, type JTypeMirror, isSubstitution boolean) : void extracted from public addBound(kind BoundKind, type JTypeMirror) : void in class net.sourceforge.pmd.lang.java.types.internal.infer.JInferenceVar", "diffLocations": [{"filePath": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/internal/infer/JInferenceVar.java", "startLine": 82, "endLine": 130, "startColumn": 0, "endColumn": 0}, {"filePath": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/internal/infer/JInferenceVar.java", "startLine": 82, "endLine": 87, "startColumn": 0, "endColumn": 0}, {"filePath": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/internal/infer/JInferenceVar.java", "startLine": 89, "endLine": 134, "startColumn": 0, "endColumn": 0}], "sourceCodeBeforeRefactoring": "/**\n     * Adds a new bound on this variable.\n     */\n    public void addBound(BoundKind kind, JTypeMirror type) {\n        if (type == this) {\n            // may occur because of transitive propagation\n            // alpha <: alpha is always true and not interesting\n            return;\n        }\n\n        if (type instanceof JInferenceVar && ((JInferenceVar) type).getDelegate() != null) {\n            addBound(kind, ((JInferenceVar) type).getDelegate());\n            return;\n        }\n\n        if (delegate != null) {\n            delegate.addBound(kind, type);\n            return;\n        }\n\n        if (type instanceof JInferenceVar) {\n            JInferenceVar var = (JInferenceVar) type;\n\n            if (kind == BoundKind.EQ\n                // A <: B && B <: A => A = B\n                // this is early propagation\n                || getBounds(kind.complement()).contains(type)) {\n\n                var.merge(this);\n                return;\n            }\n        }\n\n        if (type instanceof JInferenceVar && ((JInferenceVar) type).getDelegate() == this) {\n\n            Set<JTypeMirror> bounds = this.bounds.get(kind);\n            if (bounds == null || bounds.isEmpty()) {\n                return;\n            } else {\n                // maybe it's been added previously\n                bounds.remove(type);\n            }\n            return;\n        }\n\n        if (bounds.computeIfAbsent(kind, k -> new LinkedHashSet<>()).add(type)) {\n            ctx.onBoundAdded(this, kind, type);\n        }\n    }", "filePathBefore": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/internal/infer/JInferenceVar.java", "isPureRefactoring": true, "commitId": "a78560c337ee1dc2462357fcc94408928433e235", "packageNameBefore": "net.sourceforge.pmd.lang.java.types.internal.infer", "classNameBefore": "net.sourceforge.pmd.lang.java.types.internal.infer.JInferenceVar", "methodNameBefore": "net.sourceforge.pmd.lang.java.types.internal.infer.JInferenceVar#addBound", "invokedMethod": "methodSignature: net.sourceforge.pmd.lang.java.types.internal.infer.InferenceContext#onBoundAdded\n methodBody: void onBoundAdded(JInferenceVar ivar, BoundKind kind, JTypeMirror bound) {\nif(ivar.getDelegate() != null){return;\n}if(kind != BoundKind.UPPER || bound != ts.OBJECT){if(parent != null){parent.onBoundAdded(ivar,kind,bound);\nreturn;\n}logger.boundAdded(this,ivar,kind,bound);\nincorporationActions.add(new CheckBound(ivar,kind,bound));\nincorporationActions.add(new PropagateBounds(ivar,kind,bound));\n}}\nmethodSignature: net.sourceforge.pmd.lang.java.types.internal.infer.JInferenceVar#getBounds\n methodBody: Set<JTypeMirror> getBounds(Set<BoundKind> kinds) {\nSet<JTypeMirror> bounds=new LinkedHashSet<>();\nfor(BoundKind k: kinds){bounds.addAll(getBounds(k));\n}return bounds;\n}\nmethodSignature: net.sourceforge.pmd.lang.java.types.internal.infer.JInferenceVar.BoundKind#complement\n methodBody: public abstract BoundKind complement();\nmethodSignature: net.sourceforge.pmd.lang.java.types.internal.infer.JInferenceVar#getDelegate\n methodBody: JInferenceVar getDelegate() {\nreturn delegate;\n}\nmethodSignature: net.sourceforge.pmd.lang.java.types.internal.infer.JInferenceVar#addBound\n methodBody: public void addBound(BoundKind kind, JTypeMirror type) {\nif(type == this){return;\n}if(type instanceof JInferenceVar && ((JInferenceVar)type).getDelegate() != null){addBound(kind,((JInferenceVar)type).getDelegate());\nreturn;\n}if(delegate != null){delegate.addBound(kind,type);\nreturn;\n}if(type instanceof JInferenceVar){JInferenceVar var=(JInferenceVar)type;\nif(kind == BoundKind.EQ || getBounds(kind.complement()).contains(type)){var.merge(this);\nreturn;\n}}if(type instanceof JInferenceVar && ((JInferenceVar)type).getDelegate() == this){Set<JTypeMirror> bounds=this.bounds.get(kind);\nif(bounds == null || bounds.isEmpty()){return;\n}{bounds.remove(type);\n}return;\n}if(bounds.computeIfAbsent(kind,k -> new LinkedHashSet<>()).add(type)){ctx.onBoundAdded(this,kind,type);\n}}\nmethodSignature: net.sourceforge.pmd.lang.java.types.internal.infer.InferenceContext#isEmpty\n methodBody: public boolean isEmpty() {\nreturn inferenceVars.isEmpty();\n}\nmethodSignature: net.sourceforge.pmd.lang.java.types.internal.infer.JInferenceVar#merge\n methodBody: void merge(JInferenceVar candidate) {\nJInferenceVar realDelegate=candidate.getDelegate() != null ? candidate.getDelegate() : candidate;\nif(realDelegate == this){return;\n}this.delegate=realDelegate;\nMap<BoundKind,Set<JTypeMirror>> bounds=this.bounds;\nthis.bounds=Collections.emptyMap();\nfor(BoundKind kind: BoundKind.values()){for(JTypeMirror bound: bounds.getOrDefault(kind,Collections.emptySet())){this.delegate.addBound(kind,bound);\n}}ctx.onIvarMerged(this,this.delegate);\n}", "classSignatureBefore": "public final class JInferenceVar implements JTypeMirror, SubstVar ", "methodNameBeforeSet": ["net.sourceforge.pmd.lang.java.types.internal.infer.JInferenceVar#addBound"], "classNameBeforeSet": ["net.sourceforge.pmd.lang.java.types.internal.infer.JInferenceVar"], "classSignatureBeforeSet": ["public final class JInferenceVar implements JTypeMirror, SubstVar "], "purityCheckResultList": [{"isPure": true, "purityComment": "Overlapped refactoring - can be identical by undoing the overlapped refactoring\n- Add Parameter-", "description": "Parametrization or Add Parameter on top of the extract method - all mapped", "mappingState": 1}], "sourceCodeBeforeForWhole": "/*\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\n\npackage net.sourceforge.pmd.lang.java.types.internal.infer;\n\nimport java.util.Collections;\nimport java.util.EnumMap;\nimport java.util.EnumSet;\nimport java.util.LinkedHashSet;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Set;\nimport java.util.function.Function;\n\nimport org.checkerframework.checker.nullness.qual.NonNull;\nimport org.checkerframework.checker.nullness.qual.Nullable;\n\nimport net.sourceforge.pmd.lang.java.symbols.JTypeDeclSymbol;\nimport net.sourceforge.pmd.lang.java.types.JTypeMirror;\nimport net.sourceforge.pmd.lang.java.types.JTypeVar;\nimport net.sourceforge.pmd.lang.java.types.JTypeVisitor;\nimport net.sourceforge.pmd.lang.java.types.SubstVar;\nimport net.sourceforge.pmd.lang.java.types.TypeSystem;\n\n/**\n * Represents an inference variable. Inference variables are just\n * placeholder for types, used during the inference process.\n * After type inference they should have been erased and hence this\n * type is of no importance outside the implementation of this framework.\n */\npublic final class JInferenceVar implements JTypeMirror, SubstVar {\n\n    private static final String[] NAMES = {\n        \"\u03b1\", \"\u03b2\", \"\u03b3\", \"\u03b4\", \"\u03b5\", \"\u03b6\", \"\u03b7\", \"\u03b8\", \"\u03b9\", \"\u03ba\", \"\u03bb\", \"\u03bc\", \"\u03bd\",\n        \"\u03be\", \"\u03bf\", \"\u03c0\", \"\u03c1\", \"\u03c3\", \"\u03c2\", \"\u03c4\", \"\u03c5\", \"\u03c6\", \"\u03c7\", \"\u03c8\", \"\u03c9\",\n    };\n\n    private final InferenceContext ctx;\n    private final JTypeVar tvar;\n    private int id;\n    private Map<BoundKind, Set<JTypeMirror>> bounds = new EnumMap<>(BoundKind.class);\n    private JTypeMirror inst;\n    private JInferenceVar delegate;\n\n    JInferenceVar(InferenceContext ctx, JTypeVar tvar, int id) {\n        this.ctx = ctx;\n        this.tvar = tvar;\n        this.id = id;\n    }\n\n    @Override\n    public String getName() {\n        return toString();\n    }\n\n    @Override\n    public TypeSystem getTypeSystem() {\n        return ctx.ts;\n    }\n\n\n    /**\n     * Returns the bounds of a certain kind that apply to\n     * this variable.\n     */\n    Set<JTypeMirror> getBounds(BoundKind kind) {\n        return bounds.getOrDefault(kind, Collections.emptySet());\n    }\n\n\n    Set<JTypeMirror> getBounds(Set<BoundKind> kinds) {\n        Set<JTypeMirror> bounds = new LinkedHashSet<>();\n        for (BoundKind k : kinds) {\n            bounds.addAll(getBounds(k));\n        }\n        return bounds;\n    }\n\n\n    /**\n     * Adds a new bound on this variable.\n     */\n    public void addBound(BoundKind kind, JTypeMirror type) {\n        if (type == this) {\n            // may occur because of transitive propagation\n            // alpha <: alpha is always true and not interesting\n            return;\n        }\n\n        if (type instanceof JInferenceVar && ((JInferenceVar) type).getDelegate() != null) {\n            addBound(kind, ((JInferenceVar) type).getDelegate());\n            return;\n        }\n\n        if (delegate != null) {\n            delegate.addBound(kind, type);\n            return;\n        }\n\n        if (type instanceof JInferenceVar) {\n            JInferenceVar var = (JInferenceVar) type;\n\n            if (kind == BoundKind.EQ\n                // A <: B && B <: A => A = B\n                // this is early propagation\n                || getBounds(kind.complement()).contains(type)) {\n\n                var.merge(this);\n                return;\n            }\n        }\n\n        if (type instanceof JInferenceVar && ((JInferenceVar) type).getDelegate() == this) {\n\n            Set<JTypeMirror> bounds = this.bounds.get(kind);\n            if (bounds == null || bounds.isEmpty()) {\n                return;\n            } else {\n                // maybe it's been added previously\n                bounds.remove(type);\n            }\n            return;\n        }\n\n        if (bounds.computeIfAbsent(kind, k -> new LinkedHashSet<>()).add(type)) {\n            ctx.onBoundAdded(this, kind, type);\n        }\n    }\n\n    /**\n     * Returns the instantiation of this inference variable if\n     * it has already been determined. Returns null otherwise.\n     */\n    @Nullable\n    JTypeMirror getInst() {\n        return delegate == null ? inst : delegate.getInst();\n    }\n\n\n    void setInst(JTypeMirror inst) {\n        this.inst = inst;\n    }\n\n    /**\n     * Apply a substitution to the bounds of this variable.\n     *\n     * @param substitution The substitution to apply\n     */\n    void substBounds(Function<JTypeMirror, JTypeMirror> substitution) {\n\n        for (Entry<BoundKind, Set<JTypeMirror>> entry : bounds.entrySet()) {\n            BoundKind kind = entry.getKey();\n            Set<JTypeMirror> prevBounds = entry.getValue();\n\n\n            // put the new bounds before updating\n            bounds.put(kind, new LinkedHashSet<>());\n\n            for (JTypeMirror prev : prevBounds) {\n                // add substituted bound\n                addBound(kind, prev.subst(substitution));\n            }\n        }\n    }\n\n    JTypeVar getBaseVar() {\n        return tvar;\n    }\n\n\n    boolean isCaptured() {\n        return tvar.isCaptured();\n    }\n\n    JInferenceVar getDelegate() {\n        return delegate;\n    }\n\n\n    /**\n     * Set this ivar's delegate to the given ivar. This\n     * - copies all bounds of this ivar onto the delegate\n     * - drops all bounds of this ivar\n     * - makes {@link #getInst()} delegate to delegate.getInst()\n     *\n     * <p>The inference engine subsequently only works on the delegate.\n     * Proofs about the delegate are reflected by this ivar.\n     */\n    void merge(JInferenceVar candidate) {\n        JInferenceVar realDelegate = candidate.getDelegate() != null ? candidate.getDelegate() : candidate;\n        if (realDelegate == this) {\n            return;\n        }\n        this.delegate = realDelegate;\n\n        Map<BoundKind, Set<JTypeMirror>> bounds = this.bounds;\n        this.bounds = Collections.emptyMap();\n        for (BoundKind kind : BoundKind.values()) {\n            for (JTypeMirror bound : bounds.getOrDefault(kind, Collections.emptySet())) {\n                this.delegate.addBound(kind, bound);\n            }\n        }\n\n        // TODO remove bounds mentioning this var in the delegate\n\n        ctx.onIvarMerged(this, this.delegate);\n    }\n\n    /**\n     * Returns the symbol of the {@link JInferenceVar#getInst() instantiation},\n     * or null if there's no instantiation or it has no symbol.\n     */\n    @Override\n    public @Nullable JTypeDeclSymbol getSymbol() {\n        return inst != null ? inst.getSymbol() : null;\n    }\n\n\n    @Override\n    public JTypeMirror subst(Function<? super SubstVar, ? extends @NonNull JTypeMirror> subst) {\n        return subst.apply(this);\n    }\n\n    @Override\n    public <T, P> T acceptVisitor(JTypeVisitor<T, P> visitor, P p) {\n        return visitor.visitInferenceVar(this, p);\n    }\n\n\n    @Override\n    public String toString() {\n        return NAMES[id % NAMES.length] + numOfId();\n    }\n\n    private String numOfId() {\n        int n = id / NAMES.length;\n        return n == 0 ? \"\" : \"\" + n;\n    }\n\n\n    public enum BoundKind {\n        UPPER(\" <: \") {\n            @Override\n            public BoundKind complement() {\n                return LOWER;\n            }\n\n            @Override\n            public Set<BoundKind> complementSet(boolean eqIsAll) {\n                return EQ_LOWER;\n            }\n        },\n        EQ(\" = \") {\n            @Override\n            public BoundKind complement() {\n                return this;\n            }\n\n            @Override\n            public Set<BoundKind> complementSet(boolean eqIsAll) {\n                return eqIsAll ? ALL : JUST_EQ;\n            }\n        },\n        LOWER(\" >: \") {\n            @Override\n            public BoundKind complement() {\n                return UPPER;\n            }\n\n            @Override\n            public Set<BoundKind> complementSet(boolean eqIsAll) {\n                return EQ_UPPER;\n            }\n        };\n\n        // These sets are shared because otherwise *literal millions* of enumsets are created, with the same constants\n        static final Set<BoundKind> ALL = EnumSet.allOf(BoundKind.class);\n        static final Set<BoundKind> EQ_LOWER = EnumSet.of(EQ, LOWER);\n        private static final Set<BoundKind> EQ_UPPER = EnumSet.of(EQ, UPPER);\n        private static final Set<BoundKind> JUST_EQ = Collections.singleton(EQ);\n\n        private final String sym;\n\n        BoundKind(String sym) {\n            this.sym = sym;\n        }\n\n        public String format(JTypeMirror ivar, JTypeMirror bound) {\n            return ivar + sym + bound;\n        }\n\n        /**\n         * Returns the complementary bound kind.\n         * <pre>\n         *     complement(LOWER) = UPPER\n         *     complement(UPPER) = LOWER\n         *     complement(EQ) = EQ\n         * </pre>\n         */\n        public abstract BoundKind complement();\n\n\n        /**\n         * Returns the complement of this kind. There's two ways to complement EQ:\n         * - With eqIsAll, this returns all constants.\n         * - Otherwise this returns just EQ.\n         */\n        public abstract Set<BoundKind> complementSet(boolean eqIsAll);\n\n        @Override\n        public String toString() {\n            return sym;\n        }\n    }\n}\n", "filePathAfter": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/internal/infer/JInferenceVar.java", "sourceCodeAfterForWhole": "/*\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\n\npackage net.sourceforge.pmd.lang.java.types.internal.infer;\n\nimport java.util.Collections;\nimport java.util.EnumMap;\nimport java.util.EnumSet;\nimport java.util.LinkedHashSet;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Set;\nimport java.util.function.Function;\n\nimport org.checkerframework.checker.nullness.qual.NonNull;\nimport org.checkerframework.checker.nullness.qual.Nullable;\n\nimport net.sourceforge.pmd.lang.java.symbols.JTypeDeclSymbol;\nimport net.sourceforge.pmd.lang.java.types.JTypeMirror;\nimport net.sourceforge.pmd.lang.java.types.JTypeVar;\nimport net.sourceforge.pmd.lang.java.types.JTypeVisitor;\nimport net.sourceforge.pmd.lang.java.types.SubstVar;\nimport net.sourceforge.pmd.lang.java.types.TypeSystem;\n\n/**\n * Represents an inference variable. Inference variables are just\n * placeholder for types, used during the inference process.\n * After type inference they should have been erased and hence this\n * type is of no importance outside the implementation of this framework.\n */\npublic final class JInferenceVar implements JTypeMirror, SubstVar {\n\n    private static final String[] NAMES = {\n        \"\u03b1\", \"\u03b2\", \"\u03b3\", \"\u03b4\", \"\u03b5\", \"\u03b6\", \"\u03b7\", \"\u03b8\", \"\u03b9\", \"\u03ba\", \"\u03bb\", \"\u03bc\", \"\u03bd\",\n        \"\u03be\", \"\u03bf\", \"\u03c0\", \"\u03c1\", \"\u03c3\", \"\u03c2\", \"\u03c4\", \"\u03c5\", \"\u03c6\", \"\u03c7\", \"\u03c8\", \"\u03c9\",\n    };\n\n    private final InferenceContext ctx;\n    private final JTypeVar tvar;\n    private int id;\n    private Map<BoundKind, Set<JTypeMirror>> bounds = new EnumMap<>(BoundKind.class);\n    private JTypeMirror inst;\n    private JInferenceVar delegate;\n\n    JInferenceVar(InferenceContext ctx, JTypeVar tvar, int id) {\n        this.ctx = ctx;\n        this.tvar = tvar;\n        this.id = id;\n    }\n\n    @Override\n    public String getName() {\n        return toString();\n    }\n\n    @Override\n    public TypeSystem getTypeSystem() {\n        return ctx.ts;\n    }\n\n\n    /**\n     * Returns the bounds of a certain kind that apply to\n     * this variable.\n     */\n    Set<JTypeMirror> getBounds(BoundKind kind) {\n        return bounds.getOrDefault(kind, Collections.emptySet());\n    }\n\n\n    Set<JTypeMirror> getBounds(Set<BoundKind> kinds) {\n        Set<JTypeMirror> bounds = new LinkedHashSet<>();\n        for (BoundKind k : kinds) {\n            bounds.addAll(getBounds(k));\n        }\n        return bounds;\n    }\n\n\n    /**\n     * Adds a new bound on this variable.\n     */\n    public void addBound(BoundKind kind, JTypeMirror type) {\n        addBound(kind, type, false);\n    }\n\n    public void addBound(BoundKind kind, JTypeMirror type, boolean isSubstitution) {\n        if (type == this) {\n            // may occur because of transitive propagation\n            // alpha <: alpha is always true and not interesting\n            return;\n        }\n\n        if (type instanceof JInferenceVar && ((JInferenceVar) type).getDelegate() != null) {\n            addBound(kind, ((JInferenceVar) type).getDelegate());\n            return;\n        }\n\n        if (delegate != null) {\n            delegate.addBound(kind, type);\n            return;\n        }\n\n        if (type instanceof JInferenceVar) {\n            JInferenceVar var = (JInferenceVar) type;\n\n            if (kind == BoundKind.EQ\n                // A <: B && B <: A => A = B\n                // this is early propagation\n                || getBounds(kind.complement()).contains(type)) {\n\n                var.merge(this);\n                return;\n            }\n        }\n\n        if (type instanceof JInferenceVar && ((JInferenceVar) type).getDelegate() == this) {\n\n            Set<JTypeMirror> bounds = this.bounds.get(kind);\n            if (bounds == null || bounds.isEmpty()) {\n                return;\n            } else {\n                // maybe it's been added previously\n                bounds.remove(type);\n            }\n            return;\n        }\n\n        if (bounds.computeIfAbsent(kind, k -> new LinkedHashSet<>()).add(type)) {\n            ctx.onBoundAdded(this, kind, type, isSubstitution);\n        }\n    }\n\n    /**\n     * Returns the instantiation of this inference variable if\n     * it has already been determined. Returns null otherwise.\n     */\n    @Nullable\n    JTypeMirror getInst() {\n        return delegate == null ? inst : delegate.getInst();\n    }\n\n\n    void setInst(JTypeMirror inst) {\n        this.inst = inst;\n    }\n\n    /**\n     * Apply a substitution to the bounds of this variable.\n     *\n     * @param substitution The substitution to apply\n     */\n    void substBounds(Function<JTypeMirror, JTypeMirror> substitution) {\n\n        for (Entry<BoundKind, Set<JTypeMirror>> entry : bounds.entrySet()) {\n            BoundKind kind = entry.getKey();\n            Set<JTypeMirror> prevBounds = entry.getValue();\n\n\n            // put the new bounds before updating\n            LinkedHashSet<JTypeMirror> newBounds = new LinkedHashSet<>();\n            bounds.put(kind, newBounds);\n\n            for (JTypeMirror prev : prevBounds) {\n                // add substituted bound\n                JTypeMirror newBound = prev.subst(substitution);\n                if (newBound == prev) {\n                    // not actually new, don't call listeners, etc\n                    newBounds.add(prev);\n                } else {\n                    addBound(kind, newBound);\n                }\n            }\n        }\n    }\n\n    JTypeVar getBaseVar() {\n        return tvar;\n    }\n\n\n    boolean isCaptured() {\n        return tvar.isCaptured();\n    }\n\n    JInferenceVar getDelegate() {\n        return delegate;\n    }\n\n\n    /**\n     * Set this ivar's delegate to the given ivar. This\n     * - copies all bounds of this ivar onto the delegate\n     * - drops all bounds of this ivar\n     * - makes {@link #getInst()} delegate to delegate.getInst()\n     *\n     * <p>The inference engine subsequently only works on the delegate.\n     * Proofs about the delegate are reflected by this ivar.\n     */\n    void merge(JInferenceVar candidate) {\n        JInferenceVar realDelegate = candidate.getDelegate() != null ? candidate.getDelegate() : candidate;\n        if (realDelegate == this) {\n            return;\n        }\n        this.delegate = realDelegate;\n\n        Map<BoundKind, Set<JTypeMirror>> bounds = this.bounds;\n        this.bounds = Collections.emptyMap();\n        for (BoundKind kind : BoundKind.values()) {\n            for (JTypeMirror bound : bounds.getOrDefault(kind, Collections.emptySet())) {\n                this.delegate.addBound(kind, bound);\n            }\n        }\n\n        // TODO remove bounds mentioning this var in the delegate\n\n        ctx.onIvarMerged(this, this.delegate);\n    }\n\n    /**\n     * Returns the symbol of the {@link JInferenceVar#getInst() instantiation},\n     * or null if there's no instantiation or it has no symbol.\n     */\n    @Override\n    public @Nullable JTypeDeclSymbol getSymbol() {\n        return inst != null ? inst.getSymbol() : null;\n    }\n\n\n    @Override\n    public JTypeMirror subst(Function<? super SubstVar, ? extends @NonNull JTypeMirror> subst) {\n        return subst.apply(this);\n    }\n\n    @Override\n    public <T, P> T acceptVisitor(JTypeVisitor<T, P> visitor, P p) {\n        return visitor.visitInferenceVar(this, p);\n    }\n\n\n    @Override\n    public String toString() {\n        return NAMES[id % NAMES.length] + numOfId();\n    }\n\n    private String numOfId() {\n        int n = id / NAMES.length;\n        return n == 0 ? \"\" : \"\" + n;\n    }\n\n\n    public enum BoundKind {\n        UPPER(\" <: \") {\n            @Override\n            public BoundKind complement() {\n                return LOWER;\n            }\n\n            @Override\n            public Set<BoundKind> complementSet(boolean eqIsAll) {\n                return EQ_LOWER;\n            }\n        },\n        EQ(\" = \") {\n            @Override\n            public BoundKind complement() {\n                return this;\n            }\n\n            @Override\n            public Set<BoundKind> complementSet(boolean eqIsAll) {\n                return eqIsAll ? ALL : JUST_EQ;\n            }\n        },\n        LOWER(\" >: \") {\n            @Override\n            public BoundKind complement() {\n                return UPPER;\n            }\n\n            @Override\n            public Set<BoundKind> complementSet(boolean eqIsAll) {\n                return EQ_UPPER;\n            }\n        };\n\n        // These sets are shared because otherwise *literal millions* of enumsets are created, with the same constants\n        static final Set<BoundKind> ALL = EnumSet.allOf(BoundKind.class);\n        static final Set<BoundKind> EQ_LOWER = EnumSet.of(EQ, LOWER);\n        private static final Set<BoundKind> EQ_UPPER = EnumSet.of(EQ, UPPER);\n        private static final Set<BoundKind> JUST_EQ = Collections.singleton(EQ);\n\n        private final String sym;\n\n        BoundKind(String sym) {\n            this.sym = sym;\n        }\n\n        public String format(JTypeMirror ivar, JTypeMirror bound) {\n            return ivar + sym + bound;\n        }\n\n        /**\n         * Returns the complementary bound kind.\n         * <pre>\n         *     complement(LOWER) = UPPER\n         *     complement(UPPER) = LOWER\n         *     complement(EQ) = EQ\n         * </pre>\n         */\n        public abstract BoundKind complement();\n\n\n        /**\n         * Returns the complement of this kind. There's two ways to complement EQ:\n         * - With eqIsAll, this returns all constants.\n         * - Otherwise this returns just EQ.\n         */\n        public abstract Set<BoundKind> complementSet(boolean eqIsAll);\n\n        @Override\n        public String toString() {\n            return sym;\n        }\n    }\n}\n", "diffSourceCodeSet": ["public void addBound(BoundKind kind, JTypeMirror type, boolean isSubstitution) {\n        if (type == this) {\n            // may occur because of transitive propagation\n            // alpha <: alpha is always true and not interesting\n            return;\n        }\n\n        if (type instanceof JInferenceVar && ((JInferenceVar) type).getDelegate() != null) {\n            addBound(kind, ((JInferenceVar) type).getDelegate());\n            return;\n        }\n\n        if (delegate != null) {\n            delegate.addBound(kind, type);\n            return;\n        }\n\n        if (type instanceof JInferenceVar) {\n            JInferenceVar var = (JInferenceVar) type;\n\n            if (kind == BoundKind.EQ\n                // A <: B && B <: A => A = B\n                // this is early propagation\n                || getBounds(kind.complement()).contains(type)) {\n\n                var.merge(this);\n                return;\n            }\n        }\n\n        if (type instanceof JInferenceVar && ((JInferenceVar) type).getDelegate() == this) {\n\n            Set<JTypeMirror> bounds = this.bounds.get(kind);\n            if (bounds == null || bounds.isEmpty()) {\n                return;\n            } else {\n                // maybe it's been added previously\n                bounds.remove(type);\n            }\n            return;\n        }\n\n        if (bounds.computeIfAbsent(kind, k -> new LinkedHashSet<>()).add(type)) {\n            ctx.onBoundAdded(this, kind, type, isSubstitution);\n        }\n    }"], "invokedMethodSet": ["methodSignature: net.sourceforge.pmd.lang.java.types.internal.infer.InferenceContext#onBoundAdded\n methodBody: void onBoundAdded(JInferenceVar ivar, BoundKind kind, JTypeMirror bound) {\nif(ivar.getDelegate() != null){return;\n}if(kind != BoundKind.UPPER || bound != ts.OBJECT){if(parent != null){parent.onBoundAdded(ivar,kind,bound);\nreturn;\n}logger.boundAdded(this,ivar,kind,bound);\nincorporationActions.add(new CheckBound(ivar,kind,bound));\nincorporationActions.add(new PropagateBounds(ivar,kind,bound));\n}}", "methodSignature: net.sourceforge.pmd.lang.java.types.internal.infer.JInferenceVar#getBounds\n methodBody: Set<JTypeMirror> getBounds(Set<BoundKind> kinds) {\nSet<JTypeMirror> bounds=new LinkedHashSet<>();\nfor(BoundKind k: kinds){bounds.addAll(getBounds(k));\n}return bounds;\n}", "methodSignature: net.sourceforge.pmd.lang.java.types.internal.infer.JInferenceVar.BoundKind#complement\n methodBody: public abstract BoundKind complement();", "methodSignature: net.sourceforge.pmd.lang.java.types.internal.infer.JInferenceVar#getDelegate\n methodBody: JInferenceVar getDelegate() {\nreturn delegate;\n}", "methodSignature: net.sourceforge.pmd.lang.java.types.internal.infer.JInferenceVar#addBound\n methodBody: public void addBound(BoundKind kind, JTypeMirror type) {\nif(type == this){return;\n}if(type instanceof JInferenceVar && ((JInferenceVar)type).getDelegate() != null){addBound(kind,((JInferenceVar)type).getDelegate());\nreturn;\n}if(delegate != null){delegate.addBound(kind,type);\nreturn;\n}if(type instanceof JInferenceVar){JInferenceVar var=(JInferenceVar)type;\nif(kind == BoundKind.EQ || getBounds(kind.complement()).contains(type)){var.merge(this);\nreturn;\n}}if(type instanceof JInferenceVar && ((JInferenceVar)type).getDelegate() == this){Set<JTypeMirror> bounds=this.bounds.get(kind);\nif(bounds == null || bounds.isEmpty()){return;\n}{bounds.remove(type);\n}return;\n}if(bounds.computeIfAbsent(kind,k -> new LinkedHashSet<>()).add(type)){ctx.onBoundAdded(this,kind,type);\n}}", "methodSignature: net.sourceforge.pmd.lang.java.types.internal.infer.InferenceContext#isEmpty\n methodBody: public boolean isEmpty() {\nreturn inferenceVars.isEmpty();\n}", "methodSignature: net.sourceforge.pmd.lang.java.types.internal.infer.JInferenceVar#merge\n methodBody: void merge(JInferenceVar candidate) {\nJInferenceVar realDelegate=candidate.getDelegate() != null ? candidate.getDelegate() : candidate;\nif(realDelegate == this){return;\n}this.delegate=realDelegate;\nMap<BoundKind,Set<JTypeMirror>> bounds=this.bounds;\nthis.bounds=Collections.emptyMap();\nfor(BoundKind kind: BoundKind.values()){for(JTypeMirror bound: bounds.getOrDefault(kind,Collections.emptySet())){this.delegate.addBound(kind,bound);\n}}ctx.onIvarMerged(this,this.delegate);\n}"], "sourceCodeAfterRefactoring": "/**\n     * Adds a new bound on this variable.\n     */\n    public void addBound(BoundKind kind, JTypeMirror type) {\n        addBound(kind, type, false);\n    }\npublic void addBound(BoundKind kind, JTypeMirror type, boolean isSubstitution) {\n        if (type == this) {\n            // may occur because of transitive propagation\n            // alpha <: alpha is always true and not interesting\n            return;\n        }\n\n        if (type instanceof JInferenceVar && ((JInferenceVar) type).getDelegate() != null) {\n            addBound(kind, ((JInferenceVar) type).getDelegate());\n            return;\n        }\n\n        if (delegate != null) {\n            delegate.addBound(kind, type);\n            return;\n        }\n\n        if (type instanceof JInferenceVar) {\n            JInferenceVar var = (JInferenceVar) type;\n\n            if (kind == BoundKind.EQ\n                // A <: B && B <: A => A = B\n                // this is early propagation\n                || getBounds(kind.complement()).contains(type)) {\n\n                var.merge(this);\n                return;\n            }\n        }\n\n        if (type instanceof JInferenceVar && ((JInferenceVar) type).getDelegate() == this) {\n\n            Set<JTypeMirror> bounds = this.bounds.get(kind);\n            if (bounds == null || bounds.isEmpty()) {\n                return;\n            } else {\n                // maybe it's been added previously\n                bounds.remove(type);\n            }\n            return;\n        }\n\n        if (bounds.computeIfAbsent(kind, k -> new LinkedHashSet<>()).add(type)) {\n            ctx.onBoundAdded(this, kind, type, isSubstitution);\n        }\n    }", "diffSourceCode": "    82:     /**\n    83:      * Adds a new bound on this variable.\n    84:      */\n    85:     public void addBound(BoundKind kind, JTypeMirror type) {\n-   86:         if (type == this) {\n-   87:             // may occur because of transitive propagation\n-   88:             // alpha <: alpha is always true and not interesting\n-   89:             return;\n-   90:         }\n-   91: \n-   92:         if (type instanceof JInferenceVar && ((JInferenceVar) type).getDelegate() != null) {\n-   93:             addBound(kind, ((JInferenceVar) type).getDelegate());\n-   94:             return;\n-   95:         }\n-   96: \n-   97:         if (delegate != null) {\n-   98:             delegate.addBound(kind, type);\n-   99:             return;\n-  100:         }\n-  101: \n-  102:         if (type instanceof JInferenceVar) {\n-  103:             JInferenceVar var = (JInferenceVar) type;\n-  104: \n-  105:             if (kind == BoundKind.EQ\n-  106:                 // A <: B && B <: A => A = B\n-  107:                 // this is early propagation\n-  108:                 || getBounds(kind.complement()).contains(type)) {\n-  109: \n-  110:                 var.merge(this);\n-  111:                 return;\n-  112:             }\n-  113:         }\n-  114: \n-  115:         if (type instanceof JInferenceVar && ((JInferenceVar) type).getDelegate() == this) {\n-  116: \n-  117:             Set<JTypeMirror> bounds = this.bounds.get(kind);\n-  118:             if (bounds == null || bounds.isEmpty()) {\n-  119:                 return;\n-  120:             } else {\n-  121:                 // maybe it's been added previously\n-  122:                 bounds.remove(type);\n-  123:             }\n-  124:             return;\n-  125:         }\n-  126: \n-  127:         if (bounds.computeIfAbsent(kind, k -> new LinkedHashSet<>()).add(type)) {\n-  128:             ctx.onBoundAdded(this, kind, type);\n+   86:         addBound(kind, type, false);\n+   87:     }\n+   88: \n+   89:     public void addBound(BoundKind kind, JTypeMirror type, boolean isSubstitution) {\n+   90:         if (type == this) {\n+   91:             // may occur because of transitive propagation\n+   92:             // alpha <: alpha is always true and not interesting\n+   93:             return;\n+   94:         }\n+   95: \n+   96:         if (type instanceof JInferenceVar && ((JInferenceVar) type).getDelegate() != null) {\n+   97:             addBound(kind, ((JInferenceVar) type).getDelegate());\n+   98:             return;\n+   99:         }\n+  100: \n+  101:         if (delegate != null) {\n+  102:             delegate.addBound(kind, type);\n+  103:             return;\n+  104:         }\n+  105: \n+  106:         if (type instanceof JInferenceVar) {\n+  107:             JInferenceVar var = (JInferenceVar) type;\n+  108: \n+  109:             if (kind == BoundKind.EQ\n+  110:                 // A <: B && B <: A => A = B\n+  111:                 // this is early propagation\n+  112:                 || getBounds(kind.complement()).contains(type)) {\n+  113: \n+  114:                 var.merge(this);\n+  115:                 return;\n+  116:             }\n+  117:         }\n+  118: \n+  119:         if (type instanceof JInferenceVar && ((JInferenceVar) type).getDelegate() == this) {\n+  120: \n+  121:             Set<JTypeMirror> bounds = this.bounds.get(kind);\n+  122:             if (bounds == null || bounds.isEmpty()) {\n+  123:                 return;\n+  124:             } else {\n+  125:                 // maybe it's been added previously\n+  126:                 bounds.remove(type);\n+  127:             }\n+  128:             return;\n   129:         }\n-  130:     }\n-  131: \n-  132:     /**\n-  133:      * Returns the instantiation of this inference variable if\n-  134:      * it has already been determined. Returns null otherwise.\n+  130: \n+  131:         if (bounds.computeIfAbsent(kind, k -> new LinkedHashSet<>()).add(type)) {\n+  132:             ctx.onBoundAdded(this, kind, type, isSubstitution);\n+  133:         }\n+  134:     }\n", "uniqueId": "a78560c337ee1dc2462357fcc94408928433e235_82_130_89_134_82_87", "moveFileExist": true, "testResult": true, "coverageInfo": {"INSTRUCTION": {"missed": 17, "covered": 71}, "BRANCH": {"missed": 5, "covered": 19}, "LINE": {"missed": 5, "covered": 18}, "COMPLEXITY": {"missed": 3, "covered": 10}, "METHOD": {"missed": 0, "covered": 1}}, "compileResultBefore": true, "compileResultCurrent": true, "compileJDK": 11, "refactoringMinerResult": true, "compileAndTestResult": false, "refactoredCode": "To improve the readability and maintainability of the `addBound` method in the `JInferenceVar` class, we can extract several distinct logical blocks into separate methods. This will help clarify the purpose of each block and reduce the complexity of the `addBound` method.\n\nHere\u2019s the refactored code with the extracted methods:\n\n```java\n/**\n * Adds a new bound on this variable.\n */\npublic void addBound(BoundKind kind, JTypeMirror type) {\n    if (isSelfReference(type)) {\n        return;\n    }\n\n    if (handleDelegateBound(kind, type)) {\n        return;\n    }\n\n    if (handleEarlyPropagation(kind, type)) {\n        return;\n    }\n\n    if (handleRedundantBound(kind, type)) {\n        return;\n    }\n\n    addNewBound(kind, type);\n}\n\nprivate boolean isSelfReference(JTypeMirror type) {\n    return type == this; // may occur because of transitive propagation\n}\n\nprivate boolean handleDelegateBound(BoundKind kind, JTypeMirror type) {\n    if (type instanceof JInferenceVar && ((JInferenceVar) type).getDelegate() != null) {\n        addBound(kind, ((JInferenceVar) type).getDelegate());\n        return true;\n    }\n\n    if (delegate != null) {\n        delegate.addBound(kind, type);\n        return true;\n    }\n\n    return false;\n}\n\nprivate boolean handleEarlyPropagation(BoundKind kind, JTypeMirror type) {\n    if (type instanceof JInferenceVar) {\n        JInferenceVar var = (JInferenceVar) type;\n\n        if (kind == BoundKind.EQ || getBounds(kind.complement()).contains(type)) {\n            var.merge(this);\n            return true;\n        }\n    }\n    return false;\n}\n\nprivate boolean handleRedundantBound(BoundKind kind, JTypeMirror type) {\n    if (type instanceof JInferenceVar && ((JInferenceVar) type).getDelegate() == this) {\n        Set<JTypeMirror> bounds = this.bounds.get(kind);\n        if (bounds == null || bounds.isEmpty()) {\n            return true;\n        } else {\n            bounds.remove(type);\n        }\n    }\n    return false;\n}\n\nprivate void addNewBound(BoundKind kind, JTypeMirror type) {\n    if (bounds.computeIfAbsent(kind, k -> new LinkedHashSet<>()).add(type)) {\n        ctx.onBoundAdded(this, kind, type);\n    }\n}\n```\n\n### Explanation of Changes:\n1. **Extracted Methods**: The logic for checking self-reference, handling delegate bounds, early propagation, redundant bounds, and adding new bounds has been extracted into separate methods. This reduces the complexity of the `addBound` method and makes it easier to understand.\n  \n2. **Boolean Return Values**: The extracted methods return boolean values to indicate whether they performed any action, which helps in controlling the flow in the main `addBound` method.\n\n3. **Improved Readability**: Each method now has a clear purpose, making the code more modular and easier to maintain.\n\nThis refactoring enhances the overall structure of the code while preserving its original functionality.", "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to Refactor:\n/**\n     * Adds a new bound on this variable.\n     */\n    public void addBound(BoundKind kind, JTypeMirror type) {\n        if (type == this) {\n            // may occur because of transitive propagation\n            // alpha <: alpha is always true and not interesting\n            return;\n        }\n\n        if (type instanceof JInferenceVar && ((JInferenceVar) type).getDelegate() != null) {\n            addBound(kind, ((JInferenceVar) type).getDelegate());\n            return;\n        }\n\n        if (delegate != null) {\n            delegate.addBound(kind, type);\n            return;\n        }\n\n        if (type instanceof JInferenceVar) {\n            JInferenceVar var = (JInferenceVar) type;\n\n            if (kind == BoundKind.EQ\n                // A <: B && B <: A => A = B\n                // this is early propagation\n                || getBounds(kind.complement()).contains(type)) {\n\n                var.merge(this);\n                return;\n            }\n        }\n\n        if (type instanceof JInferenceVar && ((JInferenceVar) type).getDelegate() == this) {\n\n            Set<JTypeMirror> bounds = this.bounds.get(kind);\n            if (bounds == null || bounds.isEmpty()) {\n                return;\n            } else {\n                // maybe it's been added previously\n                bounds.remove(type);\n            }\n            return;\n        }\n\n        if (bounds.computeIfAbsent(kind, k -> new LinkedHashSet<>()).add(type)) {\n            ctx.onBoundAdded(this, kind, type);\n        }\n    }\n\nClass content:\n/*\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\n\npackage net.sourceforge.pmd.lang.java.types.internal.infer;\n\nimport java.util.Collections;\nimport java.util.EnumMap;\nimport java.util.EnumSet;\nimport java.util.LinkedHashSet;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Set;\nimport java.util.function.Function;\n\nimport org.checkerframework.checker.nullness.qual.NonNull;\nimport org.checkerframework.checker.nullness.qual.Nullable;\n\nimport net.sourceforge.pmd.lang.java.symbols.JTypeDeclSymbol;\nimport net.sourceforge.pmd.lang.java.types.JTypeMirror;\nimport net.sourceforge.pmd.lang.java.types.JTypeVar;\nimport net.sourceforge.pmd.lang.java.types.JTypeVisitor;\nimport net.sourceforge.pmd.lang.java.types.SubstVar;\nimport net.sourceforge.pmd.lang.java.types.TypeSystem;\n\n/**\n * Represents an inference variable. Inference variables are just\n * placeholder for types, used during the inference process.\n * After type inference they should have been erased and hence this\n * type is of no importance outside the implementation of this framework.\n */\npublic final class JInferenceVar implements JTypeMirror, SubstVar {\n\n    private static final String[] NAMES = {\n        \"\u03b1\", \"\u03b2\", \"\u03b3\", \"\u03b4\", \"\u03b5\", \"\u03b6\", \"\u03b7\", \"\u03b8\", \"\u03b9\", \"\u03ba\", \"\u03bb\", \"\u03bc\", \"\u03bd\",\n        \"\u03be\", \"\u03bf\", \"\u03c0\", \"\u03c1\", \"\u03c3\", \"\u03c2\", \"\u03c4\", \"\u03c5\", \"\u03c6\", \"\u03c7\", \"\u03c8\", \"\u03c9\",\n    };\n\n    private final InferenceContext ctx;\n    private final JTypeVar tvar;\n    private int id;\n    private Map<BoundKind, Set<JTypeMirror>> bounds = new EnumMap<>(BoundKind.class);\n    private JTypeMirror inst;\n    private JInferenceVar delegate;\n\n    JInferenceVar(InferenceContext ctx, JTypeVar tvar, int id) {\n        this.ctx = ctx;\n        this.tvar = tvar;\n        this.id = id;\n    }\n\n    @Override\n    public String getName() {\n        return toString();\n    }\n\n    @Override\n    public TypeSystem getTypeSystem() {\n        return ctx.ts;\n    }\n\n\n    /**\n     * Returns the bounds of a certain kind that apply to\n     * this variable.\n     */\n    Set<JTypeMirror> getBounds(BoundKind kind) {\n        return bounds.getOrDefault(kind, Collections.emptySet());\n    }\n\n\n    Set<JTypeMirror> getBounds(Set<BoundKind> kinds) {\n        Set<JTypeMirror> bounds = new LinkedHashSet<>();\n        for (BoundKind k : kinds) {\n            bounds.addAll(getBounds(k));\n        }\n        return bounds;\n    }\n\n\n    /**\n     * Adds a new bound on this variable.\n     */\n    public void addBound(BoundKind kind, JTypeMirror type) {\n        if (type == this) {\n            // may occur because of transitive propagation\n            // alpha <: alpha is always true and not interesting\n            return;\n        }\n\n        if (type instanceof JInferenceVar && ((JInferenceVar) type).getDelegate() != null) {\n            addBound(kind, ((JInferenceVar) type).getDelegate());\n            return;\n        }\n\n        if (delegate != null) {\n            delegate.addBound(kind, type);\n            return;\n        }\n\n        if (type instanceof JInferenceVar) {\n            JInferenceVar var = (JInferenceVar) type;\n\n            if (kind == BoundKind.EQ\n                // A <: B && B <: A => A = B\n                // this is early propagation\n                || getBounds(kind.complement()).contains(type)) {\n\n                var.merge(this);\n                return;\n            }\n        }\n\n        if (type instanceof JInferenceVar && ((JInferenceVar) type).getDelegate() == this) {\n\n            Set<JTypeMirror> bounds = this.bounds.get(kind);\n            if (bounds == null || bounds.isEmpty()) {\n                return;\n            } else {\n                // maybe it's been added previously\n                bounds.remove(type);\n            }\n            return;\n        }\n\n        if (bounds.computeIfAbsent(kind, k -> new LinkedHashSet<>()).add(type)) {\n            ctx.onBoundAdded(this, kind, type);\n        }\n    }\n\n    /**\n     * Returns the instantiation of this inference variable if\n     * it has already been determined. Returns null otherwise.\n     */\n    @Nullable\n    JTypeMirror getInst() {\n        return delegate == null ? inst : delegate.getInst();\n    }\n\n\n    void setInst(JTypeMirror inst) {\n        this.inst = inst;\n    }\n\n    /**\n     * Apply a substitution to the bounds of this variable.\n     *\n     * @param substitution The substitution to apply\n     */\n    void substBounds(Function<JTypeMirror, JTypeMirror> substitution) {\n\n        for (Entry<BoundKind, Set<JTypeMirror>> entry : bounds.entrySet()) {\n            BoundKind kind = entry.getKey();\n            Set<JTypeMirror> prevBounds = entry.getValue();\n\n\n            // put the new bounds before updating\n            bounds.put(kind, new LinkedHashSet<>());\n\n            for (JTypeMirror prev : prevBounds) {\n                // add substituted bound\n                addBound(kind, prev.subst(substitution));\n            }\n        }\n    }\n\n    JTypeVar getBaseVar() {\n        return tvar;\n    }\n\n\n    boolean isCaptured() {\n        return tvar.isCaptured();\n    }\n\n    JInferenceVar getDelegate() {\n        return delegate;\n    }\n\n\n    /**\n     * Set this ivar's delegate to the given ivar. This\n     * - copies all bounds of this ivar onto the delegate\n     * - drops all bounds of this ivar\n     * - makes {@link #getInst()} delegate to delegate.getInst()\n     *\n     * <p>The inference engine subsequently only works on the delegate.\n     * Proofs about the delegate are reflected by this ivar.\n     */\n    void merge(JInferenceVar candidate) {\n        JInferenceVar realDelegate = candidate.getDelegate() != null ? candidate.getDelegate() : candidate;\n        if (realDelegate == this) {\n            return;\n        }\n        this.delegate = realDelegate;\n\n        Map<BoundKind, Set<JTypeMirror>> bounds = this.bounds;\n        this.bounds = Collections.emptyMap();\n        for (BoundKind kind : BoundKind.values()) {\n            for (JTypeMirror bound : bounds.getOrDefault(kind, Collections.emptySet())) {\n                this.delegate.addBound(kind, bound);\n            }\n        }\n\n        // TODO remove bounds mentioning this var in the delegate\n\n        ctx.onIvarMerged(this, this.delegate);\n    }\n\n    /**\n     * Returns the symbol of the {@link JInferenceVar#getInst() instantiation},\n     * or null if there's no instantiation or it has no symbol.\n     */\n    @Override\n    public @Nullable JTypeDeclSymbol getSymbol() {\n        return inst != null ? inst.getSymbol() : null;\n    }\n\n\n    @Override\n    public JTypeMirror subst(Function<? super SubstVar, ? extends @NonNull JTypeMirror> subst) {\n        return subst.apply(this);\n    }\n\n    @Override\n    public <T, P> T acceptVisitor(JTypeVisitor<T, P> visitor, P p) {\n        return visitor.visitInferenceVar(this, p);\n    }\n\n\n    @Override\n    public String toString() {\n        return NAMES[id % NAMES.length] + numOfId();\n    }\n\n    private String numOfId() {\n        int n = id / NAMES.length;\n        return n == 0 ? \"\" : \"\" + n;\n    }\n\n\n    public enum BoundKind {\n        UPPER(\" <: \") {\n            @Override\n            public BoundKind complement() {\n                return LOWER;\n            }\n\n            @Override\n            public Set<BoundKind> complementSet(boolean eqIsAll) {\n                return EQ_LOWER;\n            }\n        },\n        EQ(\" = \") {\n            @Override\n            public BoundKind complement() {\n                return this;\n            }\n\n            @Override\n            public Set<BoundKind> complementSet(boolean eqIsAll) {\n                return eqIsAll ? ALL : JUST_EQ;\n            }\n        },\n        LOWER(\" >: \") {\n            @Override\n            public BoundKind complement() {\n                return UPPER;\n            }\n\n            @Override\n            public Set<BoundKind> complementSet(boolean eqIsAll) {\n                return EQ_UPPER;\n            }\n        };\n\n        // These sets are shared because otherwise *literal millions* of enumsets are created, with the same constants\n        static final Set<BoundKind> ALL = EnumSet.allOf(BoundKind.class);\n        static final Set<BoundKind> EQ_LOWER = EnumSet.of(EQ, LOWER);\n        private static final Set<BoundKind> EQ_UPPER = EnumSet.of(EQ, UPPER);\n        private static final Set<BoundKind> JUST_EQ = Collections.singleton(EQ);\n\n        private final String sym;\n\n        BoundKind(String sym) {\n            this.sym = sym;\n        }\n\n        public String format(JTypeMirror ivar, JTypeMirror bound) {\n            return ivar + sym + bound;\n        }\n\n        /**\n         * Returns the complementary bound kind.\n         * <pre>\n         *     complement(LOWER) = UPPER\n         *     complement(UPPER) = LOWER\n         *     complement(EQ) = EQ\n         * </pre>\n         */\n        public abstract BoundKind complement();\n\n\n        /**\n         * Returns the complement of this kind. There's two ways to complement EQ:\n         * - With eqIsAll, this returns all constants.\n         * - Otherwise this returns just EQ.\n         */\n        public abstract Set<BoundKind> complementSet(boolean eqIsAll);\n\n        @Override\n        public String toString() {\n            return sym;\n        }\n    }\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n"}, {"type": "Extract Method", "description": "Extract Method\tprivate checkArrayElement(element JTypeMirror) : void extracted from public arrayType(element JTypeMirror, numDimensions int) : JTypeMirror in class net.sourceforge.pmd.lang.java.types.TypeSystem", "diffLocations": [{"filePath": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/TypeSystem.java", "startLine": 435, "endLine": 475, "startColumn": 0, "endColumn": 0}, {"filePath": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/TypeSystem.java", "startLine": 439, "endLine": 472, "startColumn": 0, "endColumn": 0}, {"filePath": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/TypeSystem.java", "startLine": 491, "endLine": 499, "startColumn": 0, "endColumn": 0}], "sourceCodeBeforeRefactoring": "/**\n     * Creates a new array type from an arbitrary element type.\n     *\n     * <pre>{@code\n     * arrayType(T, 0)          = T\n     * arrayType(T, 1)          = T[]\n     * arrayType(T, 3)          = T[][][]\n     * arrayType(T[], 2)        = T[][][]\n     * arrayType(ERROR_TYPE, _) = ERROR_TYPE\n     * }</pre>\n     *\n     * @param element       Element type\n     * @param numDimensions Number of dimensions\n     *\n     * @return A new array type\n     *\n     * @throws IllegalArgumentException If numDimensions is negative\n     * @throws IllegalArgumentException If the element type is a {@link JWildcardType},\n     *                                  the null type, or {@link #NO_TYPE void}.\n     * @throws NullPointerException     If the element type is null\n     */\n    public JTypeMirror arrayType(@NonNull JTypeMirror element, int numDimensions) {\n        AssertionUtil.requireNonNegative(\"numDimensions\", numDimensions);\n        AssertionUtil.requireParamNotNull(\"elementType\", element);\n\n        if (element instanceof JWildcardType\n            || element == NULL_TYPE\n            || element == NO_TYPE) {\n            throw new IllegalArgumentException(\"The type < \" + element + \" > is not a valid array element type \");\n        }\n\n        if (numDimensions == 0 || element == ERROR_TYPE) {\n            return element;\n        }\n\n        JArrayType res = new ArrayTypeImpl(this, element);\n        while (--numDimensions > 0) {\n            res = new ArrayTypeImpl(this, res);\n        }\n        return res;\n    }", "filePathBefore": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/TypeSystem.java", "isPureRefactoring": true, "commitId": "a229887f034561d0280131588bad1ad6845e3631", "packageNameBefore": "net.sourceforge.pmd.lang.java.types", "classNameBefore": "net.sourceforge.pmd.lang.java.types.TypeSystem", "methodNameBefore": "net.sourceforge.pmd.lang.java.types.TypeSystem#arrayType", "classSignatureBefore": "public final class TypeSystem ", "methodNameBeforeSet": ["net.sourceforge.pmd.lang.java.types.TypeSystem#arrayType"], "classNameBeforeSet": ["net.sourceforge.pmd.lang.java.types.TypeSystem"], "classSignatureBeforeSet": ["public final class TypeSystem "], "purityCheckResultList": [{"isPure": true, "purityComment": "Tolerable changes in the body\n", "description": "All replacements have been justified - all mapped", "mappingState": 1}], "sourceCodeBeforeForWhole": "/*\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.lang.java.types;\n\nimport static java.util.Collections.emptyList;\nimport static net.sourceforge.pmd.util.CollectionUtil.immutableSetOf;\n\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.EnumMap;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.ListIterator;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Set;\nimport java.util.function.Function;\n\nimport org.checkerframework.checker.nullness.qual.NonNull;\nimport org.checkerframework.checker.nullness.qual.Nullable;\n\nimport net.sourceforge.pmd.annotation.InternalApi;\nimport net.sourceforge.pmd.internal.util.AssertionUtil;\nimport net.sourceforge.pmd.lang.java.symbols.JClassSymbol;\nimport net.sourceforge.pmd.lang.java.symbols.JExecutableSymbol;\nimport net.sourceforge.pmd.lang.java.symbols.JFieldSymbol;\nimport net.sourceforge.pmd.lang.java.symbols.JFormalParamSymbol;\nimport net.sourceforge.pmd.lang.java.symbols.JLocalVariableSymbol;\nimport net.sourceforge.pmd.lang.java.symbols.JTypeDeclSymbol;\nimport net.sourceforge.pmd.lang.java.symbols.JTypeParameterSymbol;\nimport net.sourceforge.pmd.lang.java.symbols.SymbolResolver;\nimport net.sourceforge.pmd.lang.java.symbols.internal.SymbolFactory;\nimport net.sourceforge.pmd.lang.java.symbols.internal.asm.AsmSymbolResolver;\nimport net.sourceforge.pmd.lang.java.types.BasePrimitiveSymbol.RealPrimitiveSymbol;\nimport net.sourceforge.pmd.lang.java.types.BasePrimitiveSymbol.VoidSymbol;\nimport net.sourceforge.pmd.lang.java.types.JPrimitiveType.PrimitiveTypeKind;\nimport net.sourceforge.pmd.lang.java.types.internal.infer.JInferenceVar;\n\n/**\n * Root context object for type analysis. Type systems own a {@link SymbolFactory},\n * which creates and caches symbols. Methods of this class promote symbols\n * to types, and compose types together. {@link TypeOps} and {@link TypeConversion}\n * have some more operations on types.\n *\n * <p>Some special types are presented as constant fields, eg {@link #OBJECT}\n * or {@link #NULL_TYPE}. These are always comparable by reference.\n *\n * <p>The lifetime of a type system is the analysis: it is shared by\n * all compilation units.\n * TODO this is hacked together by comparing the ClassLoader, but this\n *  should be in the language instance\n *\n */\n@SuppressWarnings(\"PMD.CompareObjectsWithEquals\")\npublic final class TypeSystem {\n\n    /** Top type of the reference type system. */\n    public final JClassType OBJECT;\n\n    /**\n     * The bottom type of the reference type system. This is named\n     * the <i>null type</i> in the JLS and is not denotable in Java\n     * programs.\n     *\n     * <p>This implementation uses this as the type of the 'null' literal.\n     */\n    public final JTypeMirror NULL_TYPE = new NullType(this);\n\n\n    // primitives\n    public final JPrimitiveType BOOLEAN;\n    public final JPrimitiveType CHAR;\n    public final JPrimitiveType BYTE;\n    public final JPrimitiveType SHORT;\n    public final JPrimitiveType INT;\n    public final JPrimitiveType LONG;\n    public final JPrimitiveType FLOAT;\n    public final JPrimitiveType DOUBLE;\n\n    /**\n     * The set of all primitive types. See {@link #getPrimitive(PrimitiveTypeKind)}.\n     */\n    public final Set<JPrimitiveType> allPrimitives;\n    private final EnumMap<PrimitiveTypeKind, JPrimitiveType> primitivesByKind;\n\n    /**\n     * A constant to represent the normal absence of a type. The\n     * primitive {@code void.class} represents that type, and this\n     * is the return type of a void method.\n     *\n     * <p>Note that the type of the class literal {@code void.class}\n     * is {@code Class<java.lang.Void>}, not NO_TYPE.\n     */\n    public final JTypeMirror NO_TYPE;\n\n    /**\n     * A constant to represent an unresolved type. This means, that resolution\n     * was attempted but failed and shouldn't be tried again.\n     */\n    public final JTypeMirror UNRESOLVED_TYPE;\n\n    /**\n     * Sentinel value for an unresolved method. This type corresponds to\n     * a method declaration in the type {@link #UNRESOLVED_TYPE},\n     * returning {@link #UNRESOLVED_TYPE}.\n     */\n    // TODO it doesn't need to be declared in UNRESOLVED_TYPE\n    public final JMethodSig UNRESOLVED_METHOD = new UnresolvedMethodSig(this);\n\n    /**\n     * A constant to represent a typing error. This would have been\n     * reported by a compiler.\n     */\n    public final JTypeMirror ERROR_TYPE = new SentinelType(this, \"/*error*/\");\n\n    /*\n     * Common, non-special types.\n     */\n\n    /** The unbounded wildcard, \"?\". */\n    public final JWildcardType UNBOUNDED_WILD;\n\n    // array supertypes\n    public final JClassType CLONEABLE;\n    public final JClassType SERIALIZABLE;\n\n    /**\n     * This is the boxed type of {@code Void.class}, not to be confused with\n     * {@code void.class}, which in this framework is represented by\n     * {@link #NO_TYPE}.\n     */\n    public final JClassType BOXED_VOID;\n\n\n    private final SymbolFactory symbolFactory;\n\n    /** Contains special types, that must be shared to be comparable by reference. */\n    private final Map<JTypeDeclSymbol, JTypeMirror> sharedTypes;\n    // test only\n    final AsmSymbolResolver resolver;\n\n    /**\n     * Builds a new type system. Its public fields will be initialized\n     * with fresh types, unrelated to other types.\n     *\n     * @param bootstrapResourceLoader Classloader used to resolve class files\n     *                                to populate the fields of the new type\n     *                                system\n     */\n    public TypeSystem(ClassLoader bootstrapResourceLoader) {\n        this.resolver = new AsmSymbolResolver(this, bootstrapResourceLoader);\n        this.symbolFactory = new SymbolFactory(this);\n\n        // initialize primitives. their constructor also initializes their box + box erasure\n\n        BOOLEAN = createPrimitive(PrimitiveTypeKind.BOOLEAN, Boolean.class);\n        CHAR = createPrimitive(PrimitiveTypeKind.CHAR, Character.class);\n        BYTE = createPrimitive(PrimitiveTypeKind.BYTE, Byte.class);\n        SHORT = createPrimitive(PrimitiveTypeKind.SHORT, Short.class);\n        INT = createPrimitive(PrimitiveTypeKind.INT, Integer.class);\n        LONG = createPrimitive(PrimitiveTypeKind.LONG, Long.class);\n        FLOAT = createPrimitive(PrimitiveTypeKind.FLOAT, Float.class);\n        DOUBLE = createPrimitive(PrimitiveTypeKind.DOUBLE, Double.class);\n\n        // this relies on the fact that setOf always returns immutable sets\n        BOOLEAN.superTypes = immutableSetOf(BOOLEAN);\n        CHAR.superTypes = immutableSetOf(CHAR, INT, LONG, FLOAT, DOUBLE);\n        BYTE.superTypes = immutableSetOf(BYTE, SHORT, INT, LONG, FLOAT, DOUBLE);\n        SHORT.superTypes = immutableSetOf(SHORT, INT, LONG, FLOAT, DOUBLE);\n        INT.superTypes = immutableSetOf(INT, LONG, FLOAT, DOUBLE);\n        LONG.superTypes = immutableSetOf(LONG, FLOAT, DOUBLE);\n        FLOAT.superTypes = immutableSetOf(FLOAT, DOUBLE);\n        DOUBLE.superTypes = immutableSetOf(DOUBLE);\n\n        this.allPrimitives = immutableSetOf(BOOLEAN, CHAR, BYTE, SHORT, INT, LONG, FLOAT, DOUBLE);\n        this.primitivesByKind = new EnumMap<>(PrimitiveTypeKind.class);\n        primitivesByKind.put(PrimitiveTypeKind.BOOLEAN, BOOLEAN);\n        primitivesByKind.put(PrimitiveTypeKind.CHAR, CHAR);\n        primitivesByKind.put(PrimitiveTypeKind.BYTE, BYTE);\n        primitivesByKind.put(PrimitiveTypeKind.SHORT, SHORT);\n        primitivesByKind.put(PrimitiveTypeKind.INT, INT);\n        primitivesByKind.put(PrimitiveTypeKind.LONG, LONG);\n        primitivesByKind.put(PrimitiveTypeKind.FLOAT, FLOAT);\n        primitivesByKind.put(PrimitiveTypeKind.DOUBLE, DOUBLE);\n\n        JClassSymbol unresolvedTypeSym = symbolFactory.makeUnresolvedReference(\"/*unresolved*/\", 0);\n        UNRESOLVED_TYPE = new SentinelType(this, \"/*unresolved*/\", unresolvedTypeSym);\n\n        JClassSymbol primitiveVoidSym = new VoidSymbol(this);\n        NO_TYPE = new SentinelType(this, \"void\", primitiveVoidSym);\n\n        // reuse instances for common types\n\n        // this map is vital to preserve some of the invariants of\n        // the framework, e.g., that primitive types are never represented\n        // by a ClassType, or that OBJECT is unique\n\n        // this is only appropriate for non-generic types\n\n        Map<JClassSymbol, JTypeMirror> shared = new HashMap<>();\n\n        OBJECT = addSpecial(Object.class, shared);\n        SERIALIZABLE = addSpecial(Serializable.class, shared);\n        CLONEABLE = addSpecial(Cloneable.class, shared);\n        BOXED_VOID = addSpecial(Void.class, shared);\n\n        shared.put(primitiveVoidSym, NO_TYPE);\n        shared.put(unresolvedTypeSym, UNRESOLVED_TYPE);\n\n        for (JPrimitiveType prim : allPrimitives) {\n            // primitives have a special implementation for their box\n            shared.put(prim.getSymbol(), prim);\n            shared.put(prim.box().getSymbol(), prim.box());\n        }\n\n        // make it really untouchable\n        this.sharedTypes = Collections.unmodifiableMap(new HashMap<>(shared));\n\n        UNBOUNDED_WILD = new WildcardTypeImpl(this, true, OBJECT);\n    }\n\n    /**\n     * Returns the symbol factory associated with this type system.\n     * This is internal API, symbols are low-level abstractions that\n     * should not be created manually.\n     */\n    @InternalApi\n    public SymbolFactory symbols() {\n        return symbolFactory;\n    }\n\n    /**\n     * Returns the bootstrap symbol resolver. Concrete analysis passes\n     * may decorate this with different resolvers.\n     */\n    public SymbolResolver bootstrapResolver() {\n        return resolver;\n    }\n\n    // helpers for the constructor, cannot use typeOf, only for trusted types\n\n    private JClassType addSpecial(Class<?> klass, Map<JClassSymbol, JTypeMirror> shared) {\n        JClassSymbol sym = getBootStrapSymbol(klass);\n        JClassType nonErased = new ClassTypeImpl(this, sym, emptyList(), false);\n        shared.put(sym, nonErased);\n        return nonErased;\n    }\n\n    private JClassSymbol getBootStrapSymbol(Class<?> clazz) {\n        AssertionUtil.requireParamNotNull(\"clazz\", clazz);\n        JClassSymbol sym = resolver.resolveClassFromBinaryName(clazz.getName());\n        return Objects.requireNonNull(sym, \"sym\");\n    }\n\n    @NonNull\n    private JPrimitiveType createPrimitive(PrimitiveTypeKind kind, Class<?> box) {\n        return new JPrimitiveType(this, kind, new RealPrimitiveSymbol(this, kind), getBootStrapSymbol(box));\n    }\n\n\n    // type creation routines\n\n    /**\n     * Returns the class symbol for the given reflected class. This asks\n     * the classloader of this type system. Returns null if the parameter\n     * is null, or the class is not available in the analysis classpath.\n     *\n     * @param clazz Class\n     */\n    @Nullable\n    public JClassSymbol getClassSymbol(@Nullable Class<?> clazz) {\n        if (clazz == null) {\n            return null;\n        } else if (clazz.isPrimitive()) {\n            PrimitiveTypeKind kind = PrimitiveTypeKind.fromName(clazz.getName());\n            if (kind == null) { // void\n                return (JClassSymbol) NO_TYPE.getSymbol();\n            }\n            return getPrimitive(kind).getSymbol();\n        } else if (clazz.isArray()) {\n            return symbols().makeArraySymbol(getClassSymbol(clazz.getComponentType()));\n        }\n\n        return resolver.resolveClassFromBinaryName(clazz.getName());\n    }\n\n    /**\n     * Returns a symbol for the binary name. Returns null if the name is\n     * null or the symbol is not found on the classpath. The class must\n     * not be an array.\n     *\n     * @param binaryName Binary name\n     *\n     * @return A symbol, or null\n     *\n     * @throws IllegalArgumentException If the\n     */\n    public @Nullable JClassSymbol getClassSymbol(String binaryName) {\n        if (binaryName == null) {\n            return null;\n        }\n        if (\"void\".equals(binaryName)) {\n            return (JClassSymbol) NO_TYPE.getSymbol();\n        }\n        PrimitiveTypeKind kind = PrimitiveTypeKind.fromName(binaryName);\n        if (kind != null) { // void\n            return getPrimitive(kind).getSymbol();\n        }\n\n        if (!AssertionUtil.isValidJavaPackageName(binaryName)) {\n            throw new IllegalArgumentException(\"Not a binary name '\" + binaryName + \"'\");\n        }\n\n        return resolver.resolveClassFromBinaryName(binaryName);\n    }\n\n    /**\n     * Returns a type mirror for the given symbol. If the symbol declares\n     * type parameters, then the resulting type is raw (differs from the\n     * behaviour of {@link #declaration(JClassSymbol)}), meaning all its\n     * supertypes are erased.\n     *\n     * <p>If the symbol is a {@link JTypeParameterSymbol type parameter},\n     * returns a {@link JTypeVar}.\n     *\n     * <p>If the symbol is a {@link JClassSymbol}, then:\n     * <ul>\n     * <li>If it represents a primitive type, the corresponding {@link JPrimitiveType}\n     * is returned (one of {@link #INT}, {@link #CHAR}, etc.).\n     * <li>If it represents an array type, a new {@link JArrayType} is\n     * returned. Note that the component type will always be erased;\n     * creating a generic array type should instead be done with\n     * {@link #arrayType(JTypeMirror, int)}.\n     * <li>If it represents a class or interface type, a {@link JClassType}\n     * is returned.\n     * <ul>\n     *     <li>If the parameter {@code isErased} is true, and if the\n     *     symbol declares type parameters, then it will be a\n     *     {@linkplain JClassType#isRaw() raw type}. This means,\n     *     which means all its generic supertypes are {@linkplain JClassType#hasErasedSuperTypes() erased}.\n     *     <li>Otherwise, the generic supertypes are preserved. In particular,\n     *     if the symbol declares type parameters itself, then it will\n     *     be a {@linkplain JClassType#isGenericTypeDeclaration() generic type declaration}.\n     * </ul>\n     * If the symbol is a non-static member of another class, then the given\n     * type's {@linkplain JClassType#getEnclosingType() enclosing type} is\n     * created, applying the above rules about erasure recursively. A type\n     * is either completely erased, or completely parameterized.\n     * </li>\n     * </ul>\n     *\n     * @param symbol   Symbol for the type declaration\n     * @param isErased Whether the type should be consider erased, if it\n     *                 represents a class or interface type. This does not\n     *                 erase type variables, or array types for that matter.\n     *\n     * @throws NullPointerException if the symbol is null\n     */\n    public JTypeMirror typeOf(JTypeDeclSymbol symbol, boolean isErased) {\n        Objects.requireNonNull(symbol, \"Argument shouldn't be null\");\n\n        // takes care of primitives, and constants like OBJECT or UNRESOLVED_TYPE\n        JTypeMirror common = specialCache(symbol);\n        if (common != null) {\n            return common;\n        }\n\n        if (symbol instanceof JClassSymbol) {\n            JClassSymbol classSym = (JClassSymbol) symbol;\n            if (classSym.isArray()) {\n                // generic array types are represented by a special\n                // type in the j.l.reflect API, so the component is\n                // also raw\n                // fixme this is wrong:\n                //  var genArr = ts.array(tvar, 1);\n                //  ts.typeOf(genArr.symbol(), false) != genArr\n                JTypeMirror component = rawType(classSym.getArrayComponent());\n                return arrayType(component, 1);\n            } else {\n                return new ClassTypeImpl(this, classSym, emptyList(), !isErased);\n            }\n        } else if (symbol instanceof JTypeParameterSymbol) {\n            return ((JTypeParameterSymbol) symbol).getTypeMirror();\n        }\n        throw new AssertionError(\"Uncategorized type symbol \" + symbol.getClass() + \": \" + symbol);\n    }\n\n    // test only for now\n    JClassType forceErase(JClassType t) {\n        JClassType erasure = t.getErasure();\n        if (erasure == t) {\n            return new ErasedClassType(this, t.getSymbol());\n        }\n        return erasure;\n    }\n\n    /**\n     * Like {@link #typeOf(JTypeDeclSymbol, boolean)}, defaulting the\n     * erased parameter to true. If the symbol is not generic,\n     * the returned symbol is not actually raw.\n     *\n     * @param klass Symbol\n     *\n     * @return An erased class type\n     */\n    public JTypeMirror rawType(JTypeDeclSymbol klass) {\n        return typeOf(klass, true);\n    }\n\n    public JTypeMirror declaration(JClassSymbol klass) {\n        return typeOf(klass, false);\n    }\n\n\n    @NonNull\n    public JTypeMirror parameterise(JClassSymbol klass, List<? extends JTypeMirror> typeArgs) {\n        Objects.requireNonNull(klass, \"Null class symbol\");\n        Objects.requireNonNull(typeArgs, \"Null type arguments, use an empty list!\");\n\n        if (!klass.isUnresolved() && !typeArgs.isEmpty() && klass.getTypeParameterCount() != typeArgs.size()) {\n            throw new IllegalArgumentException(\"Cannot parameterize \" + klass + \" with \" + typeArgs);\n        } else if (typeArgs.isEmpty()) {\n            return rawType(klass);\n        }\n\n        // if the type arguments are mismatched, the constructor will throw\n        return new ClassTypeImpl(this, klass, new ArrayList<>(typeArgs), false);\n    }\n\n\n    /**\n     * Creates a new array type from an arbitrary element type.\n     *\n     * <pre>{@code\n     * arrayType(T, 0)          = T\n     * arrayType(T, 1)          = T[]\n     * arrayType(T, 3)          = T[][][]\n     * arrayType(T[], 2)        = T[][][]\n     * arrayType(ERROR_TYPE, _) = ERROR_TYPE\n     * }</pre>\n     *\n     * @param element       Element type\n     * @param numDimensions Number of dimensions\n     *\n     * @return A new array type\n     *\n     * @throws IllegalArgumentException If numDimensions is negative\n     * @throws IllegalArgumentException If the element type is a {@link JWildcardType},\n     *                                  the null type, or {@link #NO_TYPE void}.\n     * @throws NullPointerException     If the element type is null\n     */\n    public JTypeMirror arrayType(@NonNull JTypeMirror element, int numDimensions) {\n        AssertionUtil.requireNonNegative(\"numDimensions\", numDimensions);\n        AssertionUtil.requireParamNotNull(\"elementType\", element);\n\n        if (element instanceof JWildcardType\n            || element == NULL_TYPE\n            || element == NO_TYPE) {\n            throw new IllegalArgumentException(\"The type < \" + element + \" > is not a valid array element type \");\n        }\n\n        if (numDimensions == 0 || element == ERROR_TYPE) {\n            return element;\n        }\n\n        JArrayType res = new ArrayTypeImpl(this, element);\n        while (--numDimensions > 0) {\n            res = new ArrayTypeImpl(this, res);\n        }\n        return res;\n    }\n\n    public JMethodSig sigOf(JExecutableSymbol methodSym) {\n        return sigOf(methodSym, Substitution.EMPTY);\n    }\n\n    public JMethodSig sigOf(JExecutableSymbol methodSym, Substitution subst) {\n        JClassType klass = (JClassType) declaration(methodSym.getEnclosingClass());\n        return new ClassMethodSigImpl(klass.subst(subst), methodSym);\n    }\n\n    public JVariableSig sigOf(JTypeMirror decl, JFieldSymbol fieldSym) {\n        return JVariableSig.forField(decl, fieldSym);\n    }\n\n    public JVariableSig sigOf(JClassType decl, JLocalVariableSymbol fieldSym) {\n        return JVariableSig.forLocal(decl, fieldSym);\n    }\n\n    public JVariableSig sigOf(JClassType decl, JFormalParamSymbol fieldSym) {\n        return JVariableSig.forLocal(decl, fieldSym);\n    }\n\n    /**\n     * Builds an intersection type for the specified component types.\n     * This does not necessarily return a {@link JIntersectionType}.\n     *\n     * @param types Types to intersect\n     *\n     * @return An intersection type\n     *\n     * @throws NullPointerException     If the collection is null\n     * @throws IllegalArgumentException If the collection is empty\n     */\n    public JTypeMirror intersect(Collection<? extends JTypeMirror> types) {\n        if (types.isEmpty()) {\n            throw new IllegalArgumentException(\"Cannot intersect zero types\");\n        } else if (types.size() == 1) {\n            return types.iterator().next();\n        }\n        return new IntersectionTypeImpl(this, new ArrayList<>(types));\n    }\n\n\n    /**\n     * Builds a wildcard type with a single bound.\n     *\n     * <pre>{@code\n     *\n     * wildcard(true, T)      = ? extends T\n     * wildcard(false, T)     = ? super T\n     * wildcard(true, OBJECT) = ?\n     * wildcard(_, ERROR_TYPE) = ERROR_TYPE\n     *\n     * }</pre>\n     *\n     * @param isUpperBound If true, this is an \"extends\" wildcard, otherwise a \"super\"\n     * @param bound        Bound of the wildcard\n     *\n     * @return A wildcard\n     *\n     * @throws NullPointerException     If the bound is null\n     * @throws IllegalArgumentException If the bound is a primitive type,\n     *                                  or a wildcard type\n     * @throws IllegalArgumentException If the bound is OBJECT and this\n     *                                  is a lower-bounded wildcard (? super Object)\n     */\n    public JTypeMirror wildcard(boolean isUpperBound, @NonNull JTypeMirror bound) {\n        Objects.requireNonNull(bound, \"Argument shouldn't be null\");\n        if (bound == ERROR_TYPE) {\n            return bound;\n        }\n        if (bound.isPrimitive() || bound instanceof JWildcardType) {\n            throw new IllegalArgumentException(\"<\" + bound + \"> cannot be a wildcard bound\");\n        }\n        return isUpperBound && bound == OBJECT ? UNBOUNDED_WILD\n                                               : new WildcardTypeImpl(this, isUpperBound, bound);\n    }\n\n    /**\n     * Maps a type decl symbol to its shared representation. Eg this\n     * maps the symbol for {@code int.class} to {@link #INT}. Only\n     * non-generic types are cached.\n     */\n    private @Nullable JTypeMirror specialCache(JTypeDeclSymbol raw) {\n        return sharedTypes.get(raw);\n    }\n\n\n    /**\n     * Gets the primitive type identified by the given kind.\n     *\n     * @param kind Kind of primitive type\n     *\n     * @return A primitive type\n     *\n     * @throws NullPointerException if kind is null\n     */\n    public @NonNull JPrimitiveType getPrimitive(@NonNull PrimitiveTypeKind kind) {\n        AssertionUtil.requireParamNotNull(\"kind\", kind);\n        return primitivesByKind.get(kind);\n    }\n\n    /**\n     * The least upper bound, or \"lub\", of a set of reference types is\n     * a shared supertype that is more specific than any other shared\n     * supertype (that is, no other shared supertype is a subtype of the\n     * least upper bound).\n     *\n     * @throws IllegalArgumentException If types is empty\n     * @throws NullPointerException     If types is null\n     */\n    public JTypeMirror lub(Collection<? extends JTypeMirror> types) {\n        return Lub.lub(this, types);\n    }\n\n    /**\n     * Returns the greatest lower bound of the given set of types.\n     * This is defined in JLS\u00a75.1.10 (Capture Conversion):\n     *\n     * <blockquote>\n     * glb(V1,...,Vm) = V1 &amp; ... &amp; Vm\n     * glb(V) = V\n     * </blockquote>\n     *\n     * @throws IllegalArgumentException If some component is not a class, array, or wildcard type\n     * @throws IllegalArgumentException If there is more than one minimal class or array type\n     * @throws IllegalArgumentException If types is empty\n     * @throws NullPointerException     If types is null\n     */\n    public JTypeMirror glb(Collection<? extends JTypeMirror> types) {\n        if (types.isEmpty()) {\n            throw new IllegalArgumentException(\"Cannot compute GLB of empty set\");\n        }\n\n\n        ArrayList<JTypeMirror> list = new ArrayList<>(types.size());\n\n        for (JTypeMirror type : types) {\n            // flatten intersections: (A & (B & C)) => (A & B & C)\n            if (type instanceof JIntersectionType) {\n                list.addAll(((JIntersectionType) type).getComponents());\n            } else {\n                list.add(type);\n            }\n        }\n\n\n        JTypeMirror ck = OBJECT; // Ck is a class type\n\n        for (ListIterator<JTypeMirror> iterator = list.listIterator(); iterator.hasNext();) {\n            JTypeMirror ci = iterator.next();\n\n            if (ci.isPrimitive() || ci instanceof JWildcardType || ci instanceof JIntersectionType) {\n                throw new IllegalArgumentException(\"Bad intersection type component: \" + ci + \" in \" + types);\n            }\n\n            if (!isPossiblyAnInterface(ci)) {\n                // either Ci is an array, or Ci is a class\n                // Ci is not unresolved\n\n                if (ci.isSubtypeOf(ck)) {\n                    ck = ci; // Ci is more specific than Ck\n                    iterator.remove(); // remove bound\n                } else if (ck.isSubtypeOf(ci)) {\n                    // then our Ck is already more specific than Ci\n                    iterator.remove();\n                } else {\n                    throw new IllegalArgumentException(\n                        \"Bad intersection, unrelated class types \" + ci + \" and \" + ck + \" in \" + types);\n                }\n            } else if (!(ci instanceof JInferenceVar) && ck.isSubtypeOf(ci)) {\n                // then our Ck is already more specific than Ci\n                iterator.remove();\n            }\n        }\n\n        if (list.isEmpty()) {\n            return ck;\n        }\n\n        if (ck != OBJECT) {\n            // readd ck as first component\n            list.add(0, ck);\n        }\n\n        if (list.size() == 1) {\n            return list.get(0);\n        }\n\n        if (ck instanceof JTypeVar) {\n            return new IntersectionTypeImpl(this, list);\n        }\n\n        // We assume there cannot be an array type here. Why?\n        // In well-formed java programs an array type in a GLB can only occur in the following situation\n        //\n        // class C<T extends B1 & .. & Bn>      // nota: the Bi cannot be array types\n        //\n        // Somewhere: C<? extends Arr[]>\n\n        // And capture would merge the bounds of the wildcard and of the tvar\n        // into Arr[] & B1 & .. & Bn\n        // Now the C<? ...> would only typecheck if Arr[] <: Bi forall i\n        // (Note that this means, that Bi in { Serializable, Cloneable, Object })\n\n        // This means, that the loop above would find Ck = Arr[], and delete all Bi, since Ck <: Bi\n        // So in the end, we would return Arr[] alone, not create an intersection\n        // TODO this is order dependent: Arr[] & Serializable is ok, but Serializable & Arr[] is not\n        //   Possibly use TypeOps::mostSpecific to merge them\n        assert ck instanceof JClassType : \"Weird intersection involving multiple array types? \" + list;\n\n        return new IntersectionTypeImpl.MinimalIntersection(this, (JClassType) ck, list);\n    }\n\n\n    private boolean isPossiblyAnInterface(JTypeMirror ci) {\n        return ci.isInterface()\n            || ci instanceof JInferenceVar\n            || ci.getSymbol() != null && ci.getSymbol().isUnresolved();\n    }\n\n    // package-private\n    JClassType erasedType(JClassSymbol symbol) {\n        JTypeMirror t = specialCache(symbol);\n        if (t != null) {\n            return (JClassType) t.getErasure();\n        } else {\n            return new ErasedClassType(this, symbol);\n        }\n    }\n\n\n    /**\n     * Returns a new type variable for the given symbol. This is only\n     * intended to be used by the implementor of {@link JTypeParameterSymbol}.\n     */\n    public JTypeVar.FreshTypeVar newTypeVar(JTypeParameterSymbol symbol) {\n        return new TypeVarImpl(this, symbol);\n    }\n\n    private static final class NullType implements JTypeMirror {\n        private final TypeSystem ts;\n\n        NullType(TypeSystem ts) {\n            this.ts = ts;\n        }\n\n        @Override\n        public JTypeMirror subst(Function<? super SubstVar, ? extends @NonNull JTypeMirror> subst) {\n            return this;\n        }\n\n        @Override\n        public TypeSystem getTypeSystem() {\n            return ts;\n        }\n\n        @Override\n        public @Nullable JClassSymbol getSymbol() {\n            return null;\n        }\n\n        @Override\n        public <T, P> T acceptVisitor(JTypeVisitor<T, P> visitor, P p) {\n            return visitor.visitNullType(this, p);\n        }\n\n        @Override\n        public String toString() {\n            return \"null\";\n        }\n    }\n}\n", "filePathAfter": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/TypeSystem.java", "sourceCodeAfterForWhole": "/*\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.lang.java.types;\n\nimport static java.util.Collections.emptyList;\nimport static net.sourceforge.pmd.util.CollectionUtil.immutableSetOf;\n\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.EnumMap;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.ListIterator;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Set;\nimport java.util.function.Function;\n\nimport org.checkerframework.checker.nullness.qual.NonNull;\nimport org.checkerframework.checker.nullness.qual.Nullable;\n\nimport net.sourceforge.pmd.annotation.InternalApi;\nimport net.sourceforge.pmd.internal.util.AssertionUtil;\nimport net.sourceforge.pmd.lang.java.symbols.JClassSymbol;\nimport net.sourceforge.pmd.lang.java.symbols.JExecutableSymbol;\nimport net.sourceforge.pmd.lang.java.symbols.JFieldSymbol;\nimport net.sourceforge.pmd.lang.java.symbols.JFormalParamSymbol;\nimport net.sourceforge.pmd.lang.java.symbols.JLocalVariableSymbol;\nimport net.sourceforge.pmd.lang.java.symbols.JTypeDeclSymbol;\nimport net.sourceforge.pmd.lang.java.symbols.JTypeParameterSymbol;\nimport net.sourceforge.pmd.lang.java.symbols.SymbolResolver;\nimport net.sourceforge.pmd.lang.java.symbols.internal.SymbolFactory;\nimport net.sourceforge.pmd.lang.java.symbols.internal.asm.AsmSymbolResolver;\nimport net.sourceforge.pmd.lang.java.types.BasePrimitiveSymbol.RealPrimitiveSymbol;\nimport net.sourceforge.pmd.lang.java.types.BasePrimitiveSymbol.VoidSymbol;\nimport net.sourceforge.pmd.lang.java.types.JPrimitiveType.PrimitiveTypeKind;\nimport net.sourceforge.pmd.lang.java.types.internal.infer.JInferenceVar;\n\n/**\n * Root context object for type analysis. Type systems own a {@link SymbolFactory},\n * which creates and caches symbols. Methods of this class promote symbols\n * to types, and compose types together. {@link TypeOps} and {@link TypeConversion}\n * have some more operations on types.\n *\n * <p>Some special types are presented as constant fields, eg {@link #OBJECT}\n * or {@link #NULL_TYPE}. These are always comparable by reference.\n *\n * <p>The lifetime of a type system is the analysis: it is shared by\n * all compilation units.\n * TODO this is hacked together by comparing the ClassLoader, but this\n *  should be in the language instance\n *\n */\n@SuppressWarnings(\"PMD.CompareObjectsWithEquals\")\npublic final class TypeSystem {\n\n    /** Top type of the reference type system. */\n    public final JClassType OBJECT;\n\n    /**\n     * The bottom type of the reference type system. This is named\n     * the <i>null type</i> in the JLS and is not denotable in Java\n     * programs.\n     *\n     * <p>This implementation uses this as the type of the 'null' literal.\n     */\n    public final JTypeMirror NULL_TYPE = new NullType(this);\n\n\n    // primitives\n    public final JPrimitiveType BOOLEAN;\n    public final JPrimitiveType CHAR;\n    public final JPrimitiveType BYTE;\n    public final JPrimitiveType SHORT;\n    public final JPrimitiveType INT;\n    public final JPrimitiveType LONG;\n    public final JPrimitiveType FLOAT;\n    public final JPrimitiveType DOUBLE;\n\n    /**\n     * The set of all primitive types. See {@link #getPrimitive(PrimitiveTypeKind)}.\n     */\n    public final Set<JPrimitiveType> allPrimitives;\n    private final EnumMap<PrimitiveTypeKind, JPrimitiveType> primitivesByKind;\n\n    /**\n     * A constant to represent the normal absence of a type. The\n     * primitive {@code void.class} represents that type, and this\n     * is the return type of a void method.\n     *\n     * <p>Note that the type of the class literal {@code void.class}\n     * is {@code Class<java.lang.Void>}, not NO_TYPE.\n     */\n    public final JTypeMirror NO_TYPE;\n\n    /**\n     * A constant to represent an unresolved type. This means, that resolution\n     * was attempted but failed and shouldn't be tried again.\n     */\n    public final JTypeMirror UNRESOLVED_TYPE;\n\n    /**\n     * Sentinel value for an unresolved method. This type corresponds to\n     * a method declaration in the type {@link #UNRESOLVED_TYPE},\n     * returning {@link #UNRESOLVED_TYPE}.\n     */\n    // TODO it doesn't need to be declared in UNRESOLVED_TYPE\n    public final JMethodSig UNRESOLVED_METHOD = new UnresolvedMethodSig(this);\n\n    /**\n     * A constant to represent a typing error. This would have been\n     * reported by a compiler.\n     */\n    public final JTypeMirror ERROR_TYPE;\n\n    /*\n     * Common, non-special types.\n     */\n\n    /** The unbounded wildcard, \"?\". */\n    public final JWildcardType UNBOUNDED_WILD;\n\n    // array supertypes\n    public final JClassType CLONEABLE;\n    public final JClassType SERIALIZABLE;\n\n    /**\n     * This is the boxed type of {@code Void.class}, not to be confused with\n     * {@code void.class}, which in this framework is represented by\n     * {@link #NO_TYPE}.\n     */\n    public final JClassType BOXED_VOID;\n\n\n    private final SymbolFactory symbolFactory;\n\n    /** Contains special types, that must be shared to be comparable by reference. */\n    private final Map<JTypeDeclSymbol, JTypeMirror> sharedTypes;\n    // test only\n    final AsmSymbolResolver resolver;\n\n    /**\n     * Builds a new type system. Its public fields will be initialized\n     * with fresh types, unrelated to other types.\n     *\n     * @param bootstrapResourceLoader Classloader used to resolve class files\n     *                                to populate the fields of the new type\n     *                                system\n     */\n    public TypeSystem(ClassLoader bootstrapResourceLoader) {\n        this.resolver = new AsmSymbolResolver(this, bootstrapResourceLoader);\n        this.symbolFactory = new SymbolFactory(this);\n\n        // initialize primitives. their constructor also initializes their box + box erasure\n\n        BOOLEAN = createPrimitive(PrimitiveTypeKind.BOOLEAN, Boolean.class);\n        CHAR = createPrimitive(PrimitiveTypeKind.CHAR, Character.class);\n        BYTE = createPrimitive(PrimitiveTypeKind.BYTE, Byte.class);\n        SHORT = createPrimitive(PrimitiveTypeKind.SHORT, Short.class);\n        INT = createPrimitive(PrimitiveTypeKind.INT, Integer.class);\n        LONG = createPrimitive(PrimitiveTypeKind.LONG, Long.class);\n        FLOAT = createPrimitive(PrimitiveTypeKind.FLOAT, Float.class);\n        DOUBLE = createPrimitive(PrimitiveTypeKind.DOUBLE, Double.class);\n\n        // this relies on the fact that setOf always returns immutable sets\n        BOOLEAN.superTypes = immutableSetOf(BOOLEAN);\n        CHAR.superTypes = immutableSetOf(CHAR, INT, LONG, FLOAT, DOUBLE);\n        BYTE.superTypes = immutableSetOf(BYTE, SHORT, INT, LONG, FLOAT, DOUBLE);\n        SHORT.superTypes = immutableSetOf(SHORT, INT, LONG, FLOAT, DOUBLE);\n        INT.superTypes = immutableSetOf(INT, LONG, FLOAT, DOUBLE);\n        LONG.superTypes = immutableSetOf(LONG, FLOAT, DOUBLE);\n        FLOAT.superTypes = immutableSetOf(FLOAT, DOUBLE);\n        DOUBLE.superTypes = immutableSetOf(DOUBLE);\n\n        this.allPrimitives = immutableSetOf(BOOLEAN, CHAR, BYTE, SHORT, INT, LONG, FLOAT, DOUBLE);\n        this.primitivesByKind = new EnumMap<>(PrimitiveTypeKind.class);\n        primitivesByKind.put(PrimitiveTypeKind.BOOLEAN, BOOLEAN);\n        primitivesByKind.put(PrimitiveTypeKind.CHAR, CHAR);\n        primitivesByKind.put(PrimitiveTypeKind.BYTE, BYTE);\n        primitivesByKind.put(PrimitiveTypeKind.SHORT, SHORT);\n        primitivesByKind.put(PrimitiveTypeKind.INT, INT);\n        primitivesByKind.put(PrimitiveTypeKind.LONG, LONG);\n        primitivesByKind.put(PrimitiveTypeKind.FLOAT, FLOAT);\n        primitivesByKind.put(PrimitiveTypeKind.DOUBLE, DOUBLE);\n\n        JClassSymbol unresolvedTypeSym = symbolFactory.makeUnresolvedReference(\"/*unresolved*/\", 0);\n        UNRESOLVED_TYPE = new SentinelType(this, \"/*unresolved*/\", unresolvedTypeSym);\n\n        JClassSymbol errorTypeSym = symbolFactory.makeUnresolvedReference(\"/*error*/\", 0);\n        ERROR_TYPE = new SentinelType(this, \"/*error*/\", errorTypeSym);\n\n        JClassSymbol primitiveVoidSym = new VoidSymbol(this);\n        NO_TYPE = new SentinelType(this, \"void\", primitiveVoidSym);\n\n        // reuse instances for common types\n\n        // this map is vital to preserve some of the invariants of\n        // the framework, e.g., that primitive types are never represented\n        // by a ClassType, or that OBJECT is unique\n\n        // this is only appropriate for non-generic types\n\n        Map<JClassSymbol, JTypeMirror> shared = new HashMap<>();\n\n        OBJECT = addSpecial(Object.class, shared);\n        SERIALIZABLE = addSpecial(Serializable.class, shared);\n        CLONEABLE = addSpecial(Cloneable.class, shared);\n        BOXED_VOID = addSpecial(Void.class, shared);\n\n        shared.put(primitiveVoidSym, NO_TYPE);\n        shared.put(unresolvedTypeSym, UNRESOLVED_TYPE);\n        shared.put(errorTypeSym, ERROR_TYPE);\n\n        for (JPrimitiveType prim : allPrimitives) {\n            // primitives have a special implementation for their box\n            shared.put(prim.getSymbol(), prim);\n            shared.put(prim.box().getSymbol(), prim.box());\n        }\n\n        // make it really untouchable\n        this.sharedTypes = Collections.unmodifiableMap(new HashMap<>(shared));\n\n        UNBOUNDED_WILD = new WildcardTypeImpl(this, true, OBJECT);\n    }\n\n    /**\n     * Returns the symbol factory associated with this type system.\n     * This is internal API, symbols are low-level abstractions that\n     * should not be created manually.\n     */\n    @InternalApi\n    public SymbolFactory symbols() {\n        return symbolFactory;\n    }\n\n    /**\n     * Returns the bootstrap symbol resolver. Concrete analysis passes\n     * may decorate this with different resolvers.\n     */\n    public SymbolResolver bootstrapResolver() {\n        return resolver;\n    }\n\n    // helpers for the constructor, cannot use typeOf, only for trusted types\n\n    private JClassType addSpecial(Class<?> klass, Map<JClassSymbol, JTypeMirror> shared) {\n        JClassSymbol sym = getBootStrapSymbol(klass);\n        JClassType nonErased = new ClassTypeImpl(this, sym, emptyList(), false);\n        shared.put(sym, nonErased);\n        return nonErased;\n    }\n\n    private JClassSymbol getBootStrapSymbol(Class<?> clazz) {\n        AssertionUtil.requireParamNotNull(\"clazz\", clazz);\n        JClassSymbol sym = resolver.resolveClassFromBinaryName(clazz.getName());\n        return Objects.requireNonNull(sym, \"sym\");\n    }\n\n    @NonNull\n    private JPrimitiveType createPrimitive(PrimitiveTypeKind kind, Class<?> box) {\n        return new JPrimitiveType(this, kind, new RealPrimitiveSymbol(this, kind), getBootStrapSymbol(box));\n    }\n\n\n    // type creation routines\n\n    /**\n     * Returns the class symbol for the given reflected class. This asks\n     * the classloader of this type system. Returns null if the parameter\n     * is null, or the class is not available in the analysis classpath.\n     *\n     * @param clazz Class\n     */\n    @Nullable\n    public JClassSymbol getClassSymbol(@Nullable Class<?> clazz) {\n        if (clazz == null) {\n            return null;\n        } else if (clazz.isPrimitive()) {\n            PrimitiveTypeKind kind = PrimitiveTypeKind.fromName(clazz.getName());\n            if (kind == null) { // void\n                return (JClassSymbol) NO_TYPE.getSymbol();\n            }\n            return getPrimitive(kind).getSymbol();\n        } else if (clazz.isArray()) {\n            return symbols().makeArraySymbol(getClassSymbol(clazz.getComponentType()));\n        }\n\n        return resolver.resolveClassFromBinaryName(clazz.getName());\n    }\n\n    /**\n     * Returns a symbol for the binary name. Returns null if the name is\n     * null or the symbol is not found on the classpath. The class must\n     * not be an array.\n     *\n     * @param binaryName Binary name\n     *\n     * @return A symbol, or null\n     *\n     * @throws IllegalArgumentException If the\n     */\n    public @Nullable JClassSymbol getClassSymbol(String binaryName) {\n        if (binaryName == null) {\n            return null;\n        }\n        if (\"void\".equals(binaryName)) {\n            return (JClassSymbol) NO_TYPE.getSymbol();\n        }\n        PrimitiveTypeKind kind = PrimitiveTypeKind.fromName(binaryName);\n        if (kind != null) { // void\n            return getPrimitive(kind).getSymbol();\n        }\n\n        if (!AssertionUtil.isValidJavaPackageName(binaryName)) {\n            throw new IllegalArgumentException(\"Not a binary name '\" + binaryName + \"'\");\n        }\n\n        return resolver.resolveClassFromBinaryName(binaryName);\n    }\n\n    /**\n     * Returns a type mirror for the given symbol. If the symbol declares\n     * type parameters, then the resulting type is raw (differs from the\n     * behaviour of {@link #declaration(JClassSymbol)}), meaning all its\n     * supertypes are erased.\n     *\n     * <p>If the symbol is a {@link JTypeParameterSymbol type parameter},\n     * returns a {@link JTypeVar}.\n     *\n     * <p>If the symbol is a {@link JClassSymbol}, then:\n     * <ul>\n     * <li>If it represents a primitive type, the corresponding {@link JPrimitiveType}\n     * is returned (one of {@link #INT}, {@link #CHAR}, etc.).\n     * <li>If it represents an array type, a new {@link JArrayType} is\n     * returned. Note that the component type will always be erased;\n     * creating a generic array type should instead be done with\n     * {@link #arrayType(JTypeMirror, int)}.\n     * <li>If it represents a class or interface type, a {@link JClassType}\n     * is returned.\n     * <ul>\n     *     <li>If the parameter {@code isErased} is true, and if the\n     *     symbol declares type parameters, then it will be a\n     *     {@linkplain JClassType#isRaw() raw type}. This means,\n     *     which means all its generic supertypes are {@linkplain JClassType#hasErasedSuperTypes() erased}.\n     *     <li>Otherwise, the generic supertypes are preserved. In particular,\n     *     if the symbol declares type parameters itself, then it will\n     *     be a {@linkplain JClassType#isGenericTypeDeclaration() generic type declaration}.\n     * </ul>\n     * If the symbol is a non-static member of another class, then the given\n     * type's {@linkplain JClassType#getEnclosingType() enclosing type} is\n     * created, applying the above rules about erasure recursively. A type\n     * is either completely erased, or completely parameterized.\n     * </li>\n     * </ul>\n     *\n     * @param symbol   Symbol for the type declaration\n     * @param isErased Whether the type should be consider erased, if it\n     *                 represents a class or interface type. This does not\n     *                 erase type variables, or array types for that matter.\n     *\n     * @throws NullPointerException if the symbol is null\n     */\n    public JTypeMirror typeOf(JTypeDeclSymbol symbol, boolean isErased) {\n        Objects.requireNonNull(symbol, \"Argument shouldn't be null\");\n\n        // takes care of primitives, and constants like OBJECT or UNRESOLVED_TYPE\n        JTypeMirror common = specialCache(symbol);\n        if (common != null) {\n            return common;\n        }\n\n        if (symbol instanceof JClassSymbol) {\n            JClassSymbol classSym = (JClassSymbol) symbol;\n            if (classSym.isArray()) {\n                // generic array types are represented by a special\n                // type in the j.l.reflect API, so the component is\n                // also raw\n                // fixme this is wrong:\n                //  var genArr = ts.array(tvar, 1);\n                //  ts.typeOf(genArr.symbol(), false) != genArr\n                JTypeMirror component = rawType(classSym.getArrayComponent());\n                return arrayType(component);\n            } else {\n                return new ClassTypeImpl(this, classSym, emptyList(), !isErased);\n            }\n        } else if (symbol instanceof JTypeParameterSymbol) {\n            return ((JTypeParameterSymbol) symbol).getTypeMirror();\n        }\n        throw new AssertionError(\"Uncategorized type symbol \" + symbol.getClass() + \": \" + symbol);\n    }\n\n    // test only for now\n    JClassType forceErase(JClassType t) {\n        JClassType erasure = t.getErasure();\n        if (erasure == t) {\n            return new ErasedClassType(this, t.getSymbol());\n        }\n        return erasure;\n    }\n\n    /**\n     * Like {@link #typeOf(JTypeDeclSymbol, boolean)}, defaulting the\n     * erased parameter to true. If the symbol is not generic,\n     * the returned symbol is not actually raw.\n     *\n     * @param klass Symbol\n     *\n     * @return An erased class type\n     */\n    public JTypeMirror rawType(JTypeDeclSymbol klass) {\n        return typeOf(klass, true);\n    }\n\n    public JTypeMirror declaration(JClassSymbol klass) {\n        return typeOf(klass, false);\n    }\n\n\n    @NonNull\n    public JTypeMirror parameterise(JClassSymbol klass, List<? extends JTypeMirror> typeArgs) {\n        Objects.requireNonNull(klass, \"Null class symbol\");\n        Objects.requireNonNull(typeArgs, \"Null type arguments, use an empty list!\");\n\n        if (!klass.isUnresolved() && !typeArgs.isEmpty() && klass.getTypeParameterCount() != typeArgs.size()) {\n            throw new IllegalArgumentException(\"Cannot parameterize \" + klass + \" with \" + typeArgs);\n        } else if (typeArgs.isEmpty()) {\n            return rawType(klass);\n        }\n\n        // if the type arguments are mismatched, the constructor will throw\n        return new ClassTypeImpl(this, klass, new ArrayList<>(typeArgs), false);\n    }\n\n\n    /**\n     * Creates a new array type from an arbitrary element type.\n     *\n     * <pre>{@code\n     * arrayType(T, 0)          = T\n     * arrayType(T, 1)          = T[]\n     * arrayType(T, 3)          = T[][][]\n     * arrayType(T[], 2)        = T[][][]\n     * }</pre>\n     *\n     * @param element       Element type\n     * @param numDimensions Number of dimensions\n     *\n     * @return A new array type\n     *\n     * @throws IllegalArgumentException If numDimensions is negative\n     * @throws IllegalArgumentException If the element type is a {@link JWildcardType},\n     *                                  the null type, or {@link #NO_TYPE void}.\n     * @throws NullPointerException     If the element type is null\n     */\n    public JTypeMirror arrayType(@NonNull JTypeMirror element, int numDimensions) {\n        AssertionUtil.requireNonNegative(\"numDimensions\", numDimensions);\n        checkArrayElement(element); // note we throw even if numDimensions == 0\n\n        if (numDimensions == 0) {\n            return element;\n        }\n\n        JArrayType res = new ArrayTypeImpl(this, element);\n        while (--numDimensions > 0) {\n            res = new ArrayTypeImpl(this, res);\n        }\n        return res;\n    }\n\n    /**\n     * Like {@link #arrayType(JTypeMirror, int)}, with one dimension.\n     *\n     * @param component Component type\n     *\n     * @return An array type\n     *\n     * @throws IllegalArgumentException If the element type is a {@link JWildcardType},\n     *                                  the null type, or {@link #NO_TYPE void}.\n     * @throws NullPointerException     If the element type is null\n     */\n    public JArrayType arrayType(@NonNull JTypeMirror component) {\n        checkArrayElement(component);\n        return new ArrayTypeImpl(this, component);\n    }\n\n\n    private void checkArrayElement(@NonNull JTypeMirror element) {\n        AssertionUtil.requireParamNotNull(\"elementType\", element);\n\n        if (element instanceof JWildcardType\n            || element == NULL_TYPE\n            || element == NO_TYPE) {\n            throw new IllegalArgumentException(\"The type < \" + element + \" > is not a valid array element type\");\n        }\n    }\n\n    public JMethodSig sigOf(JExecutableSymbol methodSym) {\n        return sigOf(methodSym, Substitution.EMPTY);\n    }\n\n    public JMethodSig sigOf(JExecutableSymbol methodSym, Substitution subst) {\n        JClassType klass = (JClassType) declaration(methodSym.getEnclosingClass());\n        return new ClassMethodSigImpl(klass.subst(subst), methodSym);\n    }\n\n    public JVariableSig sigOf(JTypeMirror decl, JFieldSymbol fieldSym) {\n        return JVariableSig.forField(decl, fieldSym);\n    }\n\n    public JVariableSig sigOf(JClassType decl, JLocalVariableSymbol fieldSym) {\n        return JVariableSig.forLocal(decl, fieldSym);\n    }\n\n    public JVariableSig sigOf(JClassType decl, JFormalParamSymbol fieldSym) {\n        return JVariableSig.forLocal(decl, fieldSym);\n    }\n\n    /**\n     * Builds an intersection type for the specified component types.\n     * This does not necessarily return a {@link JIntersectionType}.\n     *\n     * @param types Types to intersect\n     *\n     * @return An intersection type\n     *\n     * @throws NullPointerException     If the collection is null\n     * @throws IllegalArgumentException If the collection is empty\n     */\n    public JTypeMirror intersect(Collection<? extends JTypeMirror> types) {\n        if (types.isEmpty()) {\n            throw new IllegalArgumentException(\"Cannot intersect zero types\");\n        } else if (types.size() == 1) {\n            return types.iterator().next();\n        }\n        return new IntersectionTypeImpl(this, new ArrayList<>(types));\n    }\n\n\n    /**\n     * Builds a wildcard type with a single bound.\n     *\n     * <pre>{@code\n     *\n     * wildcard(true, T)      = ? extends T\n     * wildcard(false, T)     = ? super T\n     * wildcard(true, OBJECT) = ?\n     *\n     * }</pre>\n     *\n     * @param isUpperBound If true, this is an \"extends\" wildcard, otherwise a \"super\"\n     * @param bound        Bound of the wildcard\n     *\n     * @return A wildcard\n     *\n     * @throws NullPointerException     If the bound is null\n     * @throws IllegalArgumentException If the bound is a primitive type,\n     *                                  or a wildcard type\n     * @throws IllegalArgumentException If the bound is OBJECT and this\n     *                                  is a lower-bounded wildcard (? super Object)\n     */\n    public JTypeMirror wildcard(boolean isUpperBound, @NonNull JTypeMirror bound) {\n        Objects.requireNonNull(bound, \"Argument shouldn't be null\");\n        if (bound.isPrimitive() || bound instanceof JWildcardType) {\n            throw new IllegalArgumentException(\"<\" + bound + \"> cannot be a wildcard bound\");\n        }\n        return isUpperBound && bound == OBJECT ? UNBOUNDED_WILD\n                                               : new WildcardTypeImpl(this, isUpperBound, bound);\n    }\n\n    /**\n     * Maps a type decl symbol to its shared representation. Eg this\n     * maps the symbol for {@code int.class} to {@link #INT}. Only\n     * non-generic types are cached.\n     */\n    private @Nullable JTypeMirror specialCache(JTypeDeclSymbol raw) {\n        return sharedTypes.get(raw);\n    }\n\n\n    /**\n     * Gets the primitive type identified by the given kind.\n     *\n     * @param kind Kind of primitive type\n     *\n     * @return A primitive type\n     *\n     * @throws NullPointerException if kind is null\n     */\n    public @NonNull JPrimitiveType getPrimitive(@NonNull PrimitiveTypeKind kind) {\n        AssertionUtil.requireParamNotNull(\"kind\", kind);\n        return primitivesByKind.get(kind);\n    }\n\n    /**\n     * The least upper bound, or \"lub\", of a set of reference types is\n     * a shared supertype that is more specific than any other shared\n     * supertype (that is, no other shared supertype is a subtype of the\n     * least upper bound).\n     *\n     * @throws IllegalArgumentException If types is empty\n     * @throws NullPointerException     If types is null\n     */\n    public JTypeMirror lub(Collection<? extends JTypeMirror> types) {\n        return Lub.lub(this, types);\n    }\n\n    /**\n     * Returns the greatest lower bound of the given set of types.\n     * This is defined in JLS\u00a75.1.10 (Capture Conversion):\n     *\n     * <blockquote>\n     * glb(V1,...,Vm) = V1 &amp; ... &amp; Vm\n     * glb(V) = V\n     * </blockquote>\n     *\n     * @throws IllegalArgumentException If some component is not a class, array, or wildcard type\n     * @throws IllegalArgumentException If there is more than one minimal class or array type\n     * @throws IllegalArgumentException If types is empty\n     * @throws NullPointerException     If types is null\n     */\n    public JTypeMirror glb(Collection<? extends JTypeMirror> types) {\n        if (types.isEmpty()) {\n            throw new IllegalArgumentException(\"Cannot compute GLB of empty set\");\n        }\n\n\n        ArrayList<JTypeMirror> list = new ArrayList<>(types.size());\n\n        for (JTypeMirror type : types) {\n            // flatten intersections: (A & (B & C)) => (A & B & C)\n            if (type instanceof JIntersectionType) {\n                list.addAll(((JIntersectionType) type).getComponents());\n            } else {\n                list.add(type);\n            }\n        }\n\n\n        JTypeMirror ck = OBJECT; // Ck is a class type\n\n        for (ListIterator<JTypeMirror> iterator = list.listIterator(); iterator.hasNext();) {\n            JTypeMirror ci = iterator.next();\n\n            if (ci.isPrimitive() || ci instanceof JWildcardType || ci instanceof JIntersectionType) {\n                throw new IllegalArgumentException(\"Bad intersection type component: \" + ci + \" in \" + types);\n            }\n\n            if (!isPossiblyAnInterface(ci)) {\n                // either Ci is an array, or Ci is a class\n                // Ci is not unresolved\n\n                if (ci.isSubtypeOf(ck)) {\n                    ck = ci; // Ci is more specific than Ck\n                    iterator.remove(); // remove bound\n                } else if (ck.isSubtypeOf(ci)) {\n                    // then our Ck is already more specific than Ci\n                    iterator.remove();\n                } else {\n                    throw new IllegalArgumentException(\n                        \"Bad intersection, unrelated class types \" + ci + \" and \" + ck + \" in \" + types);\n                }\n            } else if (!(ci instanceof JInferenceVar) && ck.isSubtypeOf(ci)) {\n                // then our Ck is already more specific than Ci\n                iterator.remove();\n            }\n        }\n\n        if (list.isEmpty()) {\n            return ck;\n        }\n\n        if (ck != OBJECT) {\n            // readd ck as first component\n            list.add(0, ck);\n        }\n\n        if (list.size() == 1) {\n            return list.get(0);\n        }\n\n        if (ck instanceof JTypeVar) {\n            return new IntersectionTypeImpl(this, list);\n        }\n\n        // We assume there cannot be an array type here. Why?\n        // In well-formed java programs an array type in a GLB can only occur in the following situation\n        //\n        // class C<T extends B1 & .. & Bn>      // nota: the Bi cannot be array types\n        //\n        // Somewhere: C<? extends Arr[]>\n\n        // And capture would merge the bounds of the wildcard and of the tvar\n        // into Arr[] & B1 & .. & Bn\n        // Now the C<? ...> would only typecheck if Arr[] <: Bi forall i\n        // (Note that this means, that Bi in { Serializable, Cloneable, Object })\n\n        // This means, that the loop above would find Ck = Arr[], and delete all Bi, since Ck <: Bi\n        // So in the end, we would return Arr[] alone, not create an intersection\n        // TODO this is order dependent: Arr[] & Serializable is ok, but Serializable & Arr[] is not\n        //   Possibly use TypeOps::mostSpecific to merge them\n        assert ck instanceof JClassType : \"Weird intersection involving multiple array types? \" + list;\n\n        return new IntersectionTypeImpl.MinimalIntersection(this, (JClassType) ck, list);\n    }\n\n\n    private boolean isPossiblyAnInterface(JTypeMirror ci) {\n        return ci.isInterface()\n            || ci instanceof JInferenceVar\n            || ci.getSymbol() != null && ci.getSymbol().isUnresolved();\n    }\n\n    // package-private\n    JClassType erasedType(JClassSymbol symbol) {\n        JTypeMirror t = specialCache(symbol);\n        if (t != null) {\n            return (JClassType) t.getErasure();\n        } else {\n            return new ErasedClassType(this, symbol);\n        }\n    }\n\n\n    /**\n     * Returns a new type variable for the given symbol. This is only\n     * intended to be used by the implementor of {@link JTypeParameterSymbol}.\n     */\n    public JTypeVar.FreshTypeVar newTypeVar(JTypeParameterSymbol symbol) {\n        return new TypeVarImpl(this, symbol);\n    }\n\n    private static final class NullType implements JTypeMirror {\n        private final TypeSystem ts;\n\n        NullType(TypeSystem ts) {\n            this.ts = ts;\n        }\n\n        @Override\n        public JTypeMirror subst(Function<? super SubstVar, ? extends @NonNull JTypeMirror> subst) {\n            return this;\n        }\n\n        @Override\n        public TypeSystem getTypeSystem() {\n            return ts;\n        }\n\n        @Override\n        public @Nullable JClassSymbol getSymbol() {\n            return null;\n        }\n\n        @Override\n        public <T, P> T acceptVisitor(JTypeVisitor<T, P> visitor, P p) {\n            return visitor.visitNullType(this, p);\n        }\n\n        @Override\n        public String toString() {\n            return \"null\";\n        }\n    }\n}\n", "diffSourceCodeSet": ["private void checkArrayElement(@NonNull JTypeMirror element) {\n        AssertionUtil.requireParamNotNull(\"elementType\", element);\n\n        if (element instanceof JWildcardType\n            || element == NULL_TYPE\n            || element == NO_TYPE) {\n            throw new IllegalArgumentException(\"The type < \" + element + \" > is not a valid array element type\");\n        }\n    }"], "invokedMethodSet": [], "sourceCodeAfterRefactoring": "/**\n     * Creates a new array type from an arbitrary element type.\n     *\n     * <pre>{@code\n     * arrayType(T, 0)          = T\n     * arrayType(T, 1)          = T[]\n     * arrayType(T, 3)          = T[][][]\n     * arrayType(T[], 2)        = T[][][]\n     * }</pre>\n     *\n     * @param element       Element type\n     * @param numDimensions Number of dimensions\n     *\n     * @return A new array type\n     *\n     * @throws IllegalArgumentException If numDimensions is negative\n     * @throws IllegalArgumentException If the element type is a {@link JWildcardType},\n     *                                  the null type, or {@link #NO_TYPE void}.\n     * @throws NullPointerException     If the element type is null\n     */\n    public JTypeMirror arrayType(@NonNull JTypeMirror element, int numDimensions) {\n        AssertionUtil.requireNonNegative(\"numDimensions\", numDimensions);\n        checkArrayElement(element); // note we throw even if numDimensions == 0\n\n        if (numDimensions == 0) {\n            return element;\n        }\n\n        JArrayType res = new ArrayTypeImpl(this, element);\n        while (--numDimensions > 0) {\n            res = new ArrayTypeImpl(this, res);\n        }\n        return res;\n    }\nprivate void checkArrayElement(@NonNull JTypeMirror element) {\n        AssertionUtil.requireParamNotNull(\"elementType\", element);\n\n        if (element instanceof JWildcardType\n            || element == NULL_TYPE\n            || element == NO_TYPE) {\n            throw new IllegalArgumentException(\"The type < \" + element + \" > is not a valid array element type\");\n        }\n    }", "diffSourceCode": "-  435:     /**\n-  436:      * Creates a new array type from an arbitrary element type.\n-  437:      *\n-  438:      * <pre>{@code\n-  439:      * arrayType(T, 0)          = T\n-  440:      * arrayType(T, 1)          = T[]\n-  441:      * arrayType(T, 3)          = T[][][]\n-  442:      * arrayType(T[], 2)        = T[][][]\n-  443:      * arrayType(ERROR_TYPE, _) = ERROR_TYPE\n-  444:      * }</pre>\n-  445:      *\n-  446:      * @param element       Element type\n-  447:      * @param numDimensions Number of dimensions\n+  435:         return new ClassTypeImpl(this, klass, new ArrayList<>(typeArgs), false);\n+  436:     }\n+  437: \n+  438: \n+  439:     /**\n+  440:      * Creates a new array type from an arbitrary element type.\n+  441:      *\n+  442:      * <pre>{@code\n+  443:      * arrayType(T, 0)          = T\n+  444:      * arrayType(T, 1)          = T[]\n+  445:      * arrayType(T, 3)          = T[][][]\n+  446:      * arrayType(T[], 2)        = T[][][]\n+  447:      * }</pre>\n   448:      *\n-  449:      * @return A new array type\n-  450:      *\n-  451:      * @throws IllegalArgumentException If numDimensions is negative\n-  452:      * @throws IllegalArgumentException If the element type is a {@link JWildcardType},\n-  453:      *                                  the null type, or {@link #NO_TYPE void}.\n-  454:      * @throws NullPointerException     If the element type is null\n-  455:      */\n-  456:     public JTypeMirror arrayType(@NonNull JTypeMirror element, int numDimensions) {\n-  457:         AssertionUtil.requireNonNegative(\"numDimensions\", numDimensions);\n-  458:         AssertionUtil.requireParamNotNull(\"elementType\", element);\n-  459: \n-  460:         if (element instanceof JWildcardType\n-  461:             || element == NULL_TYPE\n-  462:             || element == NO_TYPE) {\n-  463:             throw new IllegalArgumentException(\"The type < \" + element + \" > is not a valid array element type \");\n-  464:         }\n-  465: \n-  466:         if (numDimensions == 0 || element == ERROR_TYPE) {\n-  467:             return element;\n-  468:         }\n-  469: \n-  470:         JArrayType res = new ArrayTypeImpl(this, element);\n-  471:         while (--numDimensions > 0) {\n-  472:             res = new ArrayTypeImpl(this, res);\n-  473:         }\n-  474:         return res;\n-  475:     }\n-  491:         return JVariableSig.forLocal(decl, fieldSym);\n-  492:     }\n+  449:      * @param element       Element type\n+  450:      * @param numDimensions Number of dimensions\n+  451:      *\n+  452:      * @return A new array type\n+  453:      *\n+  454:      * @throws IllegalArgumentException If numDimensions is negative\n+  455:      * @throws IllegalArgumentException If the element type is a {@link JWildcardType},\n+  456:      *                                  the null type, or {@link #NO_TYPE void}.\n+  457:      * @throws NullPointerException     If the element type is null\n+  458:      */\n+  459:     public JTypeMirror arrayType(@NonNull JTypeMirror element, int numDimensions) {\n+  460:         AssertionUtil.requireNonNegative(\"numDimensions\", numDimensions);\n+  461:         checkArrayElement(element); // note we throw even if numDimensions == 0\n+  462: \n+  463:         if (numDimensions == 0) {\n+  464:             return element;\n+  465:         }\n+  466: \n+  467:         JArrayType res = new ArrayTypeImpl(this, element);\n+  468:         while (--numDimensions > 0) {\n+  469:             res = new ArrayTypeImpl(this, res);\n+  470:         }\n+  471:         return res;\n+  472:     }\n+  473: \n+  474:     /**\n+  475:      * Like {@link #arrayType(JTypeMirror, int)}, with one dimension.\n+  491:     private void checkArrayElement(@NonNull JTypeMirror element) {\n+  492:         AssertionUtil.requireParamNotNull(\"elementType\", element);\n   493: \n-  494:     public JVariableSig sigOf(JClassType decl, JFormalParamSymbol fieldSym) {\n-  495:         return JVariableSig.forLocal(decl, fieldSym);\n-  496:     }\n-  497: \n-  498:     /**\n-  499:      * Builds an intersection type for the specified component types.\n+  494:         if (element instanceof JWildcardType\n+  495:             || element == NULL_TYPE\n+  496:             || element == NO_TYPE) {\n+  497:             throw new IllegalArgumentException(\"The type < \" + element + \" > is not a valid array element type\");\n+  498:         }\n+  499:     }\n", "uniqueId": "a229887f034561d0280131588bad1ad6845e3631_435_475_491_499_439_472", "moveFileExist": true, "testResult": true, "coverageInfo": {"INSTRUCTION": {"missed": 16, "covered": 43}, "BRANCH": {"missed": 5, "covered": 7}, "LINE": {"missed": 2, "covered": 8}, "COMPLEXITY": {"missed": 5, "covered": 2}, "METHOD": {"missed": 0, "covered": 1}}, "compileResultBefore": true, "compileResultCurrent": true, "compileJDK": 11, "refactoringMinerResult": true, "compileAndTestResult": true, "refactoredCode": "To improve the readability and maintainability of the `arrayType` method, we can extract the validation logic into a separate method. This will help to keep the main logic of the `arrayType` method focused and easier to understand.\n\nHere\u2019s the refactored code with the extracted method for validation:\n\n```java\n##########################\npublic JTypeMirror arrayType(@NonNull JTypeMirror element, int numDimensions) {\n    AssertionUtil.requireNonNegative(\"numDimensions\", numDimensions);\n    AssertionUtil.requireParamNotNull(\"elementType\", element);\n    \n    validateElementType(element);\n\n    if (numDimensions == 0 || element == ERROR_TYPE) {\n        return element;\n    }\n\n    JArrayType res = new ArrayTypeImpl(this, element);\n    while (--numDimensions > 0) {\n        res = new ArrayTypeImpl(this, res);\n    }\n    return res;\n}\n\nprivate void validateElementType(JTypeMirror element) {\n    if (element instanceof JWildcardType\n        || element == NULL_TYPE\n        || element == NO_TYPE) {\n        throw new IllegalArgumentException(\"The type < \" + element + \" > is not a valid array element type \");\n    }\n}\n##########################\n```\n\n### Explanation of Changes:\n1. **Extracted Method**: The validation logic for the element type has been moved to a new method called `validateElementType`. This method checks if the element type is valid for creating an array type.\n2. **Improved Readability**: The main `arrayType` method is now cleaner and focuses on the core logic of creating the array type, while the validation logic is encapsulated in its own method.\n3. **Maintainability**: If the validation logic needs to change in the future, it can be done in one place without affecting the main logic of the `arrayType` method.", "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to Refactor:\n/**\n     * Creates a new array type from an arbitrary element type.\n     *\n     * <pre>{@code\n     * arrayType(T, 0)          = T\n     * arrayType(T, 1)          = T[]\n     * arrayType(T, 3)          = T[][][]\n     * arrayType(T[], 2)        = T[][][]\n     * arrayType(ERROR_TYPE, _) = ERROR_TYPE\n     * }</pre>\n     *\n     * @param element       Element type\n     * @param numDimensions Number of dimensions\n     *\n     * @return A new array type\n     *\n     * @throws IllegalArgumentException If numDimensions is negative\n     * @throws IllegalArgumentException If the element type is a {@link JWildcardType},\n     *                                  the null type, or {@link #NO_TYPE void}.\n     * @throws NullPointerException     If the element type is null\n     */\n    public JTypeMirror arrayType(@NonNull JTypeMirror element, int numDimensions) {\n        AssertionUtil.requireNonNegative(\"numDimensions\", numDimensions);\n        AssertionUtil.requireParamNotNull(\"elementType\", element);\n\n        if (element instanceof JWildcardType\n            || element == NULL_TYPE\n            || element == NO_TYPE) {\n            throw new IllegalArgumentException(\"The type < \" + element + \" > is not a valid array element type \");\n        }\n\n        if (numDimensions == 0 || element == ERROR_TYPE) {\n            return element;\n        }\n\n        JArrayType res = new ArrayTypeImpl(this, element);\n        while (--numDimensions > 0) {\n            res = new ArrayTypeImpl(this, res);\n        }\n        return res;\n    }\n\nClass content:\n/*\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.lang.java.types;\n\nimport static java.util.Collections.emptyList;\nimport static net.sourceforge.pmd.util.CollectionUtil.immutableSetOf;\n\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.EnumMap;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.ListIterator;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Set;\nimport java.util.function.Function;\n\nimport org.checkerframework.checker.nullness.qual.NonNull;\nimport org.checkerframework.checker.nullness.qual.Nullable;\n\nimport net.sourceforge.pmd.annotation.InternalApi;\nimport net.sourceforge.pmd.internal.util.AssertionUtil;\nimport net.sourceforge.pmd.lang.java.symbols.JClassSymbol;\nimport net.sourceforge.pmd.lang.java.symbols.JExecutableSymbol;\nimport net.sourceforge.pmd.lang.java.symbols.JFieldSymbol;\nimport net.sourceforge.pmd.lang.java.symbols.JFormalParamSymbol;\nimport net.sourceforge.pmd.lang.java.symbols.JLocalVariableSymbol;\nimport net.sourceforge.pmd.lang.java.symbols.JTypeDeclSymbol;\nimport net.sourceforge.pmd.lang.java.symbols.JTypeParameterSymbol;\nimport net.sourceforge.pmd.lang.java.symbols.SymbolResolver;\nimport net.sourceforge.pmd.lang.java.symbols.internal.SymbolFactory;\nimport net.sourceforge.pmd.lang.java.symbols.internal.asm.AsmSymbolResolver;\nimport net.sourceforge.pmd.lang.java.types.BasePrimitiveSymbol.RealPrimitiveSymbol;\nimport net.sourceforge.pmd.lang.java.types.BasePrimitiveSymbol.VoidSymbol;\nimport net.sourceforge.pmd.lang.java.types.JPrimitiveType.PrimitiveTypeKind;\nimport net.sourceforge.pmd.lang.java.types.internal.infer.JInferenceVar;\n\n/**\n * Root context object for type analysis. Type systems own a {@link SymbolFactory},\n * which creates and caches symbols. Methods of this class promote symbols\n * to types, and compose types together. {@link TypeOps} and {@link TypeConversion}\n * have some more operations on types.\n *\n * <p>Some special types are presented as constant fields, eg {@link #OBJECT}\n * or {@link #NULL_TYPE}. These are always comparable by reference.\n *\n * <p>The lifetime of a type system is the analysis: it is shared by\n * all compilation units.\n * TODO this is hacked together by comparing the ClassLoader, but this\n *  should be in the language instance\n *\n */\n@SuppressWarnings(\"PMD.CompareObjectsWithEquals\")\npublic final class TypeSystem {\n\n    /** Top type of the reference type system. */\n    public final JClassType OBJECT;\n\n    /**\n     * The bottom type of the reference type system. This is named\n     * the <i>null type</i> in the JLS and is not denotable in Java\n     * programs.\n     *\n     * <p>This implementation uses this as the type of the 'null' literal.\n     */\n    public final JTypeMirror NULL_TYPE = new NullType(this);\n\n\n    // primitives\n    public final JPrimitiveType BOOLEAN;\n    public final JPrimitiveType CHAR;\n    public final JPrimitiveType BYTE;\n    public final JPrimitiveType SHORT;\n    public final JPrimitiveType INT;\n    public final JPrimitiveType LONG;\n    public final JPrimitiveType FLOAT;\n    public final JPrimitiveType DOUBLE;\n\n    /**\n     * The set of all primitive types. See {@link #getPrimitive(PrimitiveTypeKind)}.\n     */\n    public final Set<JPrimitiveType> allPrimitives;\n    private final EnumMap<PrimitiveTypeKind, JPrimitiveType> primitivesByKind;\n\n    /**\n     * A constant to represent the normal absence of a type. The\n     * primitive {@code void.class} represents that type, and this\n     * is the return type of a void method.\n     *\n     * <p>Note that the type of the class literal {@code void.class}\n     * is {@code Class<java.lang.Void>}, not NO_TYPE.\n     */\n    public final JTypeMirror NO_TYPE;\n\n    /**\n     * A constant to represent an unresolved type. This means, that resolution\n     * was attempted but failed and shouldn't be tried again.\n     */\n    public final JTypeMirror UNRESOLVED_TYPE;\n\n    /**\n     * Sentinel value for an unresolved method. This type corresponds to\n     * a method declaration in the type {@link #UNRESOLVED_TYPE},\n     * returning {@link #UNRESOLVED_TYPE}.\n     */\n    // TODO it doesn't need to be declared in UNRESOLVED_TYPE\n    public final JMethodSig UNRESOLVED_METHOD = new UnresolvedMethodSig(this);\n\n    /**\n     * A constant to represent a typing error. This would have been\n     * reported by a compiler.\n     */\n    public final JTypeMirror ERROR_TYPE = new SentinelType(this, \"/*error*/\");\n\n    /*\n     * Common, non-special types.\n     */\n\n    /** The unbounded wildcard, \"?\". */\n    public final JWildcardType UNBOUNDED_WILD;\n\n    // array supertypes\n    public final JClassType CLONEABLE;\n    public final JClassType SERIALIZABLE;\n\n    /**\n     * This is the boxed type of {@code Void.class}, not to be confused with\n     * {@code void.class}, which in this framework is represented by\n     * {@link #NO_TYPE}.\n     */\n    public final JClassType BOXED_VOID;\n\n\n    private final SymbolFactory symbolFactory;\n\n    /** Contains special types, that must be shared to be comparable by reference. */\n    private final Map<JTypeDeclSymbol, JTypeMirror> sharedTypes;\n    // test only\n    final AsmSymbolResolver resolver;\n\n    /**\n     * Builds a new type system. Its public fields will be initialized\n     * with fresh types, unrelated to other types.\n     *\n     * @param bootstrapResourceLoader Classloader used to resolve class files\n     *                                to populate the fields of the new type\n     *                                system\n     */\n    public TypeSystem(ClassLoader bootstrapResourceLoader) {\n        this.resolver = new AsmSymbolResolver(this, bootstrapResourceLoader);\n        this.symbolFactory = new SymbolFactory(this);\n\n        // initialize primitives. their constructor also initializes their box + box erasure\n\n        BOOLEAN = createPrimitive(PrimitiveTypeKind.BOOLEAN, Boolean.class);\n        CHAR = createPrimitive(PrimitiveTypeKind.CHAR, Character.class);\n        BYTE = createPrimitive(PrimitiveTypeKind.BYTE, Byte.class);\n        SHORT = createPrimitive(PrimitiveTypeKind.SHORT, Short.class);\n        INT = createPrimitive(PrimitiveTypeKind.INT, Integer.class);\n        LONG = createPrimitive(PrimitiveTypeKind.LONG, Long.class);\n        FLOAT = createPrimitive(PrimitiveTypeKind.FLOAT, Float.class);\n        DOUBLE = createPrimitive(PrimitiveTypeKind.DOUBLE, Double.class);\n\n        // this relies on the fact that setOf always returns immutable sets\n        BOOLEAN.superTypes = immutableSetOf(BOOLEAN);\n        CHAR.superTypes = immutableSetOf(CHAR, INT, LONG, FLOAT, DOUBLE);\n        BYTE.superTypes = immutableSetOf(BYTE, SHORT, INT, LONG, FLOAT, DOUBLE);\n        SHORT.superTypes = immutableSetOf(SHORT, INT, LONG, FLOAT, DOUBLE);\n        INT.superTypes = immutableSetOf(INT, LONG, FLOAT, DOUBLE);\n        LONG.superTypes = immutableSetOf(LONG, FLOAT, DOUBLE);\n        FLOAT.superTypes = immutableSetOf(FLOAT, DOUBLE);\n        DOUBLE.superTypes = immutableSetOf(DOUBLE);\n\n        this.allPrimitives = immutableSetOf(BOOLEAN, CHAR, BYTE, SHORT, INT, LONG, FLOAT, DOUBLE);\n        this.primitivesByKind = new EnumMap<>(PrimitiveTypeKind.class);\n        primitivesByKind.put(PrimitiveTypeKind.BOOLEAN, BOOLEAN);\n        primitivesByKind.put(PrimitiveTypeKind.CHAR, CHAR);\n        primitivesByKind.put(PrimitiveTypeKind.BYTE, BYTE);\n        primitivesByKind.put(PrimitiveTypeKind.SHORT, SHORT);\n        primitivesByKind.put(PrimitiveTypeKind.INT, INT);\n        primitivesByKind.put(PrimitiveTypeKind.LONG, LONG);\n        primitivesByKind.put(PrimitiveTypeKind.FLOAT, FLOAT);\n        primitivesByKind.put(PrimitiveTypeKind.DOUBLE, DOUBLE);\n\n        JClassSymbol unresolvedTypeSym = symbolFactory.makeUnresolvedReference(\"/*unresolved*/\", 0);\n        UNRESOLVED_TYPE = new SentinelType(this, \"/*unresolved*/\", unresolvedTypeSym);\n\n        JClassSymbol primitiveVoidSym = new VoidSymbol(this);\n        NO_TYPE = new SentinelType(this, \"void\", primitiveVoidSym);\n\n        // reuse instances for common types\n\n        // this map is vital to preserve some of the invariants of\n        // the framework, e.g., that primitive types are never represented\n        // by a ClassType, or that OBJECT is unique\n\n        // this is only appropriate for non-generic types\n\n        Map<JClassSymbol, JTypeMirror> shared = new HashMap<>();\n\n        OBJECT = addSpecial(Object.class, shared);\n        SERIALIZABLE = addSpecial(Serializable.class, shared);\n        CLONEABLE = addSpecial(Cloneable.class, shared);\n        BOXED_VOID = addSpecial(Void.class, shared);\n\n        shared.put(primitiveVoidSym, NO_TYPE);\n        shared.put(unresolvedTypeSym, UNRESOLVED_TYPE);\n\n        for (JPrimitiveType prim : allPrimitives) {\n            // primitives have a special implementation for their box\n            shared.put(prim.getSymbol(), prim);\n            shared.put(prim.box().getSymbol(), prim.box());\n        }\n\n        // make it really untouchable\n        this.sharedTypes = Collections.unmodifiableMap(new HashMap<>(shared));\n\n        UNBOUNDED_WILD = new WildcardTypeImpl(this, true, OBJECT);\n    }\n\n    /**\n     * Returns the symbol factory associated with this type system.\n     * This is internal API, symbols are low-level abstractions that\n     * should not be created manually.\n     */\n    @InternalApi\n    public SymbolFactory symbols() {\n        return symbolFactory;\n    }\n\n    /**\n     * Returns the bootstrap symbol resolver. Concrete analysis passes\n     * may decorate this with different resolvers.\n     */\n    public SymbolResolver bootstrapResolver() {\n        return resolver;\n    }\n\n    // helpers for the constructor, cannot use typeOf, only for trusted types\n\n    private JClassType addSpecial(Class<?> klass, Map<JClassSymbol, JTypeMirror> shared) {\n        JClassSymbol sym = getBootStrapSymbol(klass);\n        JClassType nonErased = new ClassTypeImpl(this, sym, emptyList(), false);\n        shared.put(sym, nonErased);\n        return nonErased;\n    }\n\n    private JClassSymbol getBootStrapSymbol(Class<?> clazz) {\n        AssertionUtil.requireParamNotNull(\"clazz\", clazz);\n        JClassSymbol sym = resolver.resolveClassFromBinaryName(clazz.getName());\n        return Objects.requireNonNull(sym, \"sym\");\n    }\n\n    @NonNull\n    private JPrimitiveType createPrimitive(PrimitiveTypeKind kind, Class<?> box) {\n        return new JPrimitiveType(this, kind, new RealPrimitiveSymbol(this, kind), getBootStrapSymbol(box));\n    }\n\n\n    // type creation routines\n\n    /**\n     * Returns the class symbol for the given reflected class. This asks\n     * the classloader of this type system. Returns null if the parameter\n     * is null, or the class is not available in the analysis classpath.\n     *\n     * @param clazz Class\n     */\n    @Nullable\n    public JClassSymbol getClassSymbol(@Nullable Class<?> clazz) {\n        if (clazz == null) {\n            return null;\n        } else if (clazz.isPrimitive()) {\n            PrimitiveTypeKind kind = PrimitiveTypeKind.fromName(clazz.getName());\n            if (kind == null) { // void\n                return (JClassSymbol) NO_TYPE.getSymbol();\n            }\n            return getPrimitive(kind).getSymbol();\n        } else if (clazz.isArray()) {\n            return symbols().makeArraySymbol(getClassSymbol(clazz.getComponentType()));\n        }\n\n        return resolver.resolveClassFromBinaryName(clazz.getName());\n    }\n\n    /**\n     * Returns a symbol for the binary name. Returns null if the name is\n     * null or the symbol is not found on the classpath. The class must\n     * not be an array.\n     *\n     * @param binaryName Binary name\n     *\n     * @return A symbol, or null\n     *\n     * @throws IllegalArgumentException If the\n     */\n    public @Nullable JClassSymbol getClassSymbol(String binaryName) {\n        if (binaryName == null) {\n            return null;\n        }\n        if (\"void\".equals(binaryName)) {\n            return (JClassSymbol) NO_TYPE.getSymbol();\n        }\n        PrimitiveTypeKind kind = PrimitiveTypeKind.fromName(binaryName);\n        if (kind != null) { // void\n            return getPrimitive(kind).getSymbol();\n        }\n\n        if (!AssertionUtil.isValidJavaPackageName(binaryName)) {\n            throw new IllegalArgumentException(\"Not a binary name '\" + binaryName + \"'\");\n        }\n\n        return resolver.resolveClassFromBinaryName(binaryName);\n    }\n\n    /**\n     * Returns a type mirror for the given symbol. If the symbol declares\n     * type parameters, then the resulting type is raw (differs from the\n     * behaviour of {@link #declaration(JClassSymbol)}), meaning all its\n     * supertypes are erased.\n     *\n     * <p>If the symbol is a {@link JTypeParameterSymbol type parameter},\n     * returns a {@link JTypeVar}.\n     *\n     * <p>If the symbol is a {@link JClassSymbol}, then:\n     * <ul>\n     * <li>If it represents a primitive type, the corresponding {@link JPrimitiveType}\n     * is returned (one of {@link #INT}, {@link #CHAR}, etc.).\n     * <li>If it represents an array type, a new {@link JArrayType} is\n     * returned. Note that the component type will always be erased;\n     * creating a generic array type should instead be done with\n     * {@link #arrayType(JTypeMirror, int)}.\n     * <li>If it represents a class or interface type, a {@link JClassType}\n     * is returned.\n     * <ul>\n     *     <li>If the parameter {@code isErased} is true, and if the\n     *     symbol declares type parameters, then it will be a\n     *     {@linkplain JClassType#isRaw() raw type}. This means,\n     *     which means all its generic supertypes are {@linkplain JClassType#hasErasedSuperTypes() erased}.\n     *     <li>Otherwise, the generic supertypes are preserved. In particular,\n     *     if the symbol declares type parameters itself, then it will\n     *     be a {@linkplain JClassType#isGenericTypeDeclaration() generic type declaration}.\n     * </ul>\n     * If the symbol is a non-static member of another class, then the given\n     * type's {@linkplain JClassType#getEnclosingType() enclosing type} is\n     * created, applying the above rules about erasure recursively. A type\n     * is either completely erased, or completely parameterized.\n     * </li>\n     * </ul>\n     *\n     * @param symbol   Symbol for the type declaration\n     * @param isErased Whether the type should be consider erased, if it\n     *                 represents a class or interface type. This does not\n     *                 erase type variables, or array types for that matter.\n     *\n     * @throws NullPointerException if the symbol is null\n     */\n    public JTypeMirror typeOf(JTypeDeclSymbol symbol, boolean isErased) {\n        Objects.requireNonNull(symbol, \"Argument shouldn't be null\");\n\n        // takes care of primitives, and constants like OBJECT or UNRESOLVED_TYPE\n        JTypeMirror common = specialCache(symbol);\n        if (common != null) {\n            return common;\n        }\n\n        if (symbol instanceof JClassSymbol) {\n            JClassSymbol classSym = (JClassSymbol) symbol;\n            if (classSym.isArray()) {\n                // generic array types are represented by a special\n                // type in the j.l.reflect API, so the component is\n                // also raw\n                // fixme this is wrong:\n                //  var genArr = ts.array(tvar, 1);\n                //  ts.typeOf(genArr.symbol(), false) != genArr\n                JTypeMirror component = rawType(classSym.getArrayComponent());\n                return arrayType(component, 1);\n            } else {\n                return new ClassTypeImpl(this, classSym, emptyList(), !isErased);\n            }\n        } else if (symbol instanceof JTypeParameterSymbol) {\n            return ((JTypeParameterSymbol) symbol).getTypeMirror();\n        }\n        throw new AssertionError(\"Uncategorized type symbol \" + symbol.getClass() + \": \" + symbol);\n    }\n\n    // test only for now\n    JClassType forceErase(JClassType t) {\n        JClassType erasure = t.getErasure();\n        if (erasure == t) {\n            return new ErasedClassType(this, t.getSymbol());\n        }\n        return erasure;\n    }\n\n    /**\n     * Like {@link #typeOf(JTypeDeclSymbol, boolean)}, defaulting the\n     * erased parameter to true. If the symbol is not generic,\n     * the returned symbol is not actually raw.\n     *\n     * @param klass Symbol\n     *\n     * @return An erased class type\n     */\n    public JTypeMirror rawType(JTypeDeclSymbol klass) {\n        return typeOf(klass, true);\n    }\n\n    public JTypeMirror declaration(JClassSymbol klass) {\n        return typeOf(klass, false);\n    }\n\n\n    @NonNull\n    public JTypeMirror parameterise(JClassSymbol klass, List<? extends JTypeMirror> typeArgs) {\n        Objects.requireNonNull(klass, \"Null class symbol\");\n        Objects.requireNonNull(typeArgs, \"Null type arguments, use an empty list!\");\n\n        if (!klass.isUnresolved() && !typeArgs.isEmpty() && klass.getTypeParameterCount() != typeArgs.size()) {\n            throw new IllegalArgumentException(\"Cannot parameterize \" + klass + \" with \" + typeArgs);\n        } else if (typeArgs.isEmpty()) {\n            return rawType(klass);\n        }\n\n        // if the type arguments are mismatched, the constructor will throw\n        return new ClassTypeImpl(this, klass, new ArrayList<>(typeArgs), false);\n    }\n\n\n    /**\n     * Creates a new array type from an arbitrary element type.\n     *\n     * <pre>{@code\n     * arrayType(T, 0)          = T\n     * arrayType(T, 1)          = T[]\n     * arrayType(T, 3)          = T[][][]\n     * arrayType(T[], 2)        = T[][][]\n     * arrayType(ERROR_TYPE, _) = ERROR_TYPE\n     * }</pre>\n     *\n     * @param element       Element type\n     * @param numDimensions Number of dimensions\n     *\n     * @return A new array type\n     *\n     * @throws IllegalArgumentException If numDimensions is negative\n     * @throws IllegalArgumentException If the element type is a {@link JWildcardType},\n     *                                  the null type, or {@link #NO_TYPE void}.\n     * @throws NullPointerException     If the element type is null\n     */\n    public JTypeMirror arrayType(@NonNull JTypeMirror element, int numDimensions) {\n        AssertionUtil.requireNonNegative(\"numDimensions\", numDimensions);\n        AssertionUtil.requireParamNotNull(\"elementType\", element);\n\n        if (element instanceof JWildcardType\n            || element == NULL_TYPE\n            || element == NO_TYPE) {\n            throw new IllegalArgumentException(\"The type < \" + element + \" > is not a valid array element type \");\n        }\n\n        if (numDimensions == 0 || element == ERROR_TYPE) {\n            return element;\n        }\n\n        JArrayType res = new ArrayTypeImpl(this, element);\n        while (--numDimensions > 0) {\n            res = new ArrayTypeImpl(this, res);\n        }\n        return res;\n    }\n\n    public JMethodSig sigOf(JExecutableSymbol methodSym) {\n        return sigOf(methodSym, Substitution.EMPTY);\n    }\n\n    public JMethodSig sigOf(JExecutableSymbol methodSym, Substitution subst) {\n        JClassType klass = (JClassType) declaration(methodSym.getEnclosingClass());\n        return new ClassMethodSigImpl(klass.subst(subst), methodSym);\n    }\n\n    public JVariableSig sigOf(JTypeMirror decl, JFieldSymbol fieldSym) {\n        return JVariableSig.forField(decl, fieldSym);\n    }\n\n    public JVariableSig sigOf(JClassType decl, JLocalVariableSymbol fieldSym) {\n        return JVariableSig.forLocal(decl, fieldSym);\n    }\n\n    public JVariableSig sigOf(JClassType decl, JFormalParamSymbol fieldSym) {\n        return JVariableSig.forLocal(decl, fieldSym);\n    }\n\n    /**\n     * Builds an intersection type for the specified component types.\n     * This does not necessarily return a {@link JIntersectionType}.\n     *\n     * @param types Types to intersect\n     *\n     * @return An intersection type\n     *\n     * @throws NullPointerException     If the collection is null\n     * @throws IllegalArgumentException If the collection is empty\n     */\n    public JTypeMirror intersect(Collection<? extends JTypeMirror> types) {\n        if (types.isEmpty()) {\n            throw new IllegalArgumentException(\"Cannot intersect zero types\");\n        } else if (types.size() == 1) {\n            return types.iterator().next();\n        }\n        return new IntersectionTypeImpl(this, new ArrayList<>(types));\n    }\n\n\n    /**\n     * Builds a wildcard type with a single bound.\n     *\n     * <pre>{@code\n     *\n     * wildcard(true, T)      = ? extends T\n     * wildcard(false, T)     = ? super T\n     * wildcard(true, OBJECT) = ?\n     * wildcard(_, ERROR_TYPE) = ERROR_TYPE\n     *\n     * }</pre>\n     *\n     * @param isUpperBound If true, this is an \"extends\" wildcard, otherwise a \"super\"\n     * @param bound        Bound of the wildcard\n     *\n     * @return A wildcard\n     *\n     * @throws NullPointerException     If the bound is null\n     * @throws IllegalArgumentException If the bound is a primitive type,\n     *                                  or a wildcard type\n     * @throws IllegalArgumentException If the bound is OBJECT and this\n     *                                  is a lower-bounded wildcard (? super Object)\n     */\n    public JTypeMirror wildcard(boolean isUpperBound, @NonNull JTypeMirror bound) {\n        Objects.requireNonNull(bound, \"Argument shouldn't be null\");\n        if (bound == ERROR_TYPE) {\n            return bound;\n        }\n        if (bound.isPrimitive() || bound instanceof JWildcardType) {\n            throw new IllegalArgumentException(\"<\" + bound + \"> cannot be a wildcard bound\");\n        }\n        return isUpperBound && bound == OBJECT ? UNBOUNDED_WILD\n                                               : new WildcardTypeImpl(this, isUpperBound, bound);\n    }\n\n    /**\n     * Maps a type decl symbol to its shared representation. Eg this\n     * maps the symbol for {@code int.class} to {@link #INT}. Only\n     * non-generic types are cached.\n     */\n    private @Nullable JTypeMirror specialCache(JTypeDeclSymbol raw) {\n        return sharedTypes.get(raw);\n    }\n\n\n    /**\n     * Gets the primitive type identified by the given kind.\n     *\n     * @param kind Kind of primitive type\n     *\n     * @return A primitive type\n     *\n     * @throws NullPointerException if kind is null\n     */\n    public @NonNull JPrimitiveType getPrimitive(@NonNull PrimitiveTypeKind kind) {\n        AssertionUtil.requireParamNotNull(\"kind\", kind);\n        return primitivesByKind.get(kind);\n    }\n\n    /**\n     * The least upper bound, or \"lub\", of a set of reference types is\n     * a shared supertype that is more specific than any other shared\n     * supertype (that is, no other shared supertype is a subtype of the\n     * least upper bound).\n     *\n     * @throws IllegalArgumentException If types is empty\n     * @throws NullPointerException     If types is null\n     */\n    public JTypeMirror lub(Collection<? extends JTypeMirror> types) {\n        return Lub.lub(this, types);\n    }\n\n    /**\n     * Returns the greatest lower bound of the given set of types.\n     * This is defined in JLS\u00a75.1.10 (Capture Conversion):\n     *\n     * <blockquote>\n     * glb(V1,...,Vm) = V1 &amp; ... &amp; Vm\n     * glb(V) = V\n     * </blockquote>\n     *\n     * @throws IllegalArgumentException If some component is not a class, array, or wildcard type\n     * @throws IllegalArgumentException If there is more than one minimal class or array type\n     * @throws IllegalArgumentException If types is empty\n     * @throws NullPointerException     If types is null\n     */\n    public JTypeMirror glb(Collection<? extends JTypeMirror> types) {\n        if (types.isEmpty()) {\n            throw new IllegalArgumentException(\"Cannot compute GLB of empty set\");\n        }\n\n\n        ArrayList<JTypeMirror> list = new ArrayList<>(types.size());\n\n        for (JTypeMirror type : types) {\n            // flatten intersections: (A & (B & C)) => (A & B & C)\n            if (type instanceof JIntersectionType) {\n                list.addAll(((JIntersectionType) type).getComponents());\n            } else {\n                list.add(type);\n            }\n        }\n\n\n        JTypeMirror ck = OBJECT; // Ck is a class type\n\n        for (ListIterator<JTypeMirror> iterator = list.listIterator(); iterator.hasNext();) {\n            JTypeMirror ci = iterator.next();\n\n            if (ci.isPrimitive() || ci instanceof JWildcardType || ci instanceof JIntersectionType) {\n                throw new IllegalArgumentException(\"Bad intersection type component: \" + ci + \" in \" + types);\n            }\n\n            if (!isPossiblyAnInterface(ci)) {\n                // either Ci is an array, or Ci is a class\n                // Ci is not unresolved\n\n                if (ci.isSubtypeOf(ck)) {\n                    ck = ci; // Ci is more specific than Ck\n                    iterator.remove(); // remove bound\n                } else if (ck.isSubtypeOf(ci)) {\n                    // then our Ck is already more specific than Ci\n                    iterator.remove();\n                } else {\n                    throw new IllegalArgumentException(\n                        \"Bad intersection, unrelated class types \" + ci + \" and \" + ck + \" in \" + types);\n                }\n            } else if (!(ci instanceof JInferenceVar) && ck.isSubtypeOf(ci)) {\n                // then our Ck is already more specific than Ci\n                iterator.remove();\n            }\n        }\n\n        if (list.isEmpty()) {\n            return ck;\n        }\n\n        if (ck != OBJECT) {\n            // readd ck as first component\n            list.add(0, ck);\n        }\n\n        if (list.size() == 1) {\n            return list.get(0);\n        }\n\n        if (ck instanceof JTypeVar) {\n            return new IntersectionTypeImpl(this, list);\n        }\n\n        // We assume there cannot be an array type here. Why?\n        // In well-formed java programs an array type in a GLB can only occur in the following situation\n        //\n        // class C<T extends B1 & .. & Bn>      // nota: the Bi cannot be array types\n        //\n        // Somewhere: C<? extends Arr[]>\n\n        // And capture would merge the bounds of the wildcard and of the tvar\n        // into Arr[] & B1 & .. & Bn\n        // Now the C<? ...> would only typecheck if Arr[] <: Bi forall i\n        // (Note that this means, that Bi in { Serializable, Cloneable, Object })\n\n        // This means, that the loop above would find Ck = Arr[], and delete all Bi, since Ck <: Bi\n        // So in the end, we would return Arr[] alone, not create an intersection\n        // TODO this is order dependent: Arr[] & Serializable is ok, but Serializable & Arr[] is not\n        //   Possibly use TypeOps::mostSpecific to merge them\n        assert ck instanceof JClassType : \"Weird intersection involving multiple array types? \" + list;\n\n        return new IntersectionTypeImpl.MinimalIntersection(this, (JClassType) ck, list);\n    }\n\n\n    private boolean isPossiblyAnInterface(JTypeMirror ci) {\n        return ci.isInterface()\n            || ci instanceof JInferenceVar\n            || ci.getSymbol() != null && ci.getSymbol().isUnresolved();\n    }\n\n    // package-private\n    JClassType erasedType(JClassSymbol symbol) {\n        JTypeMirror t = specialCache(symbol);\n        if (t != null) {\n            return (JClassType) t.getErasure();\n        } else {\n            return new ErasedClassType(this, symbol);\n        }\n    }\n\n\n    /**\n     * Returns a new type variable for the given symbol. This is only\n     * intended to be used by the implementor of {@link JTypeParameterSymbol}.\n     */\n    public JTypeVar.FreshTypeVar newTypeVar(JTypeParameterSymbol symbol) {\n        return new TypeVarImpl(this, symbol);\n    }\n\n    private static final class NullType implements JTypeMirror {\n        private final TypeSystem ts;\n\n        NullType(TypeSystem ts) {\n            this.ts = ts;\n        }\n\n        @Override\n        public JTypeMirror subst(Function<? super SubstVar, ? extends @NonNull JTypeMirror> subst) {\n            return this;\n        }\n\n        @Override\n        public TypeSystem getTypeSystem() {\n            return ts;\n        }\n\n        @Override\n        public @Nullable JClassSymbol getSymbol() {\n            return null;\n        }\n\n        @Override\n        public <T, P> T acceptVisitor(JTypeVisitor<T, P> visitor, P p) {\n            return visitor.visitNullType(this, p);\n        }\n\n        @Override\n        public String toString() {\n            return \"null\";\n        }\n    }\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n"}, {"type": "Inline Method", "description": "Inline Method\tprivate getCalledMethodArgsCount(methodCallArgs JavaNode) : int inlined to private isCaseChangingMethodCall(methodCall JavaNode, methodCallArgs JavaNode) : boolean in class net.sourceforge.pmd.lang.java.rule.errorprone.UnnecessaryCaseChangeRule", "diffLocations": [{"filePath": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/errorprone/UnnecessaryCaseChangeRule.java", "startLine": 51, "endLine": 55, "startColumn": 0, "endColumn": 0}, {"filePath": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/errorprone/UnnecessaryCaseChangeRule.java", "startLine": 86, "endLine": 92, "startColumn": 0, "endColumn": 0}, {"filePath": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/errorprone/UnnecessaryCaseChangeRule.java", "startLine": 113, "endLine": 116, "startColumn": 0, "endColumn": 0}], "sourceCodeBeforeRefactoring": "private int getCalledMethodArgsCount(JavaNode methodCallArgs) {\n        ASTArguments args = methodCallArgs.getFirstDescendantOfType(ASTArguments.class);\n        return args != null ? args.size() : -1;\n    }", "filePathBefore": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/errorprone/UnnecessaryCaseChangeRule.java", "isPureRefactoring": true, "commitId": "eca547b5054814933f87f0718e0432bc2e27e5da", "packageNameBefore": "net.sourceforge.pmd.lang.java.rule.errorprone", "classNameBefore": "net.sourceforge.pmd.lang.java.rule.errorprone.UnnecessaryCaseChangeRule", "methodNameBefore": "net.sourceforge.pmd.lang.java.rule.errorprone.UnnecessaryCaseChangeRule#getCalledMethodArgsCount", "classSignatureBefore": "public class UnnecessaryCaseChangeRule extends AbstractJavaRule ", "methodNameBeforeSet": ["net.sourceforge.pmd.lang.java.rule.errorprone.UnnecessaryCaseChangeRule#getCalledMethodArgsCount"], "classNameBeforeSet": ["net.sourceforge.pmd.lang.java.rule.errorprone.UnnecessaryCaseChangeRule"], "classSignatureBeforeSet": ["public class UnnecessaryCaseChangeRule extends AbstractJavaRule "], "purityCheckResultList": [{"isPure": true, "purityComment": "Identical statements", "description": "There is no replacement! - all mapped", "mappingState": 1}], "sourceCodeBeforeForWhole": "/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.lang.java.rule.errorprone;\n\nimport static java.util.Arrays.asList;\n\nimport java.util.List;\n\nimport net.sourceforge.pmd.lang.java.ast.ASTArgumentList;\nimport net.sourceforge.pmd.lang.java.ast.ASTArguments;\nimport net.sourceforge.pmd.lang.java.ast.ASTName;\nimport net.sourceforge.pmd.lang.java.ast.ASTPrimaryExpression;\nimport net.sourceforge.pmd.lang.java.ast.ASTPrimaryPrefix;\nimport net.sourceforge.pmd.lang.java.ast.ASTPrimarySuffix;\nimport net.sourceforge.pmd.lang.java.ast.JavaNode;\nimport net.sourceforge.pmd.lang.java.rule.AbstractJavaRule;\n\npublic class UnnecessaryCaseChangeRule extends AbstractJavaRule {\n\n    private static final List<String> CASE_CHANGING_METHODS = asList(\"toLowerCase\", \"toUpperCase\");\n    private static final List<String> EQUALITY_METHODS = asList(\"equals\", \"equalsIgnoreCase\");\n\n    @Override\n    public Object visit(ASTPrimaryExpression expr, Object data) {\n        int caseChangingCallIndex = getCaseChangingMethodCallIndex(expr);\n        if (caseChangingCallIndex != -1) {\n            int chainedMethodCallIndex = caseChangingCallIndex + 2;\n            if (hasEqualsMethodCallChainedAtPosition(expr, chainedMethodCallIndex)\n                    || isArgumentOfEqualsMethodCall(expr)) {\n                addViolation(data, expr);\n                return data;\n            }\n        }\n        return super.visit(expr, data);\n    }\n\n    private int getCaseChangingMethodCallIndex(ASTPrimaryExpression expr) {\n        for (int callArgsIndex = 1; callArgsIndex < expr.getNumChildren(); callArgsIndex++) {\n            JavaNode methodCallArgs = expr.getChild(callArgsIndex);\n            int callIndex = callArgsIndex - 1;\n            JavaNode methodCall = expr.getChild(callIndex);\n            if (isCaseChangingMethodCall(methodCall, methodCallArgs)) {\n                return callIndex;\n            }\n        }\n        return -1;\n    }\n\n    private boolean isCaseChangingMethodCall(JavaNode methodCall, JavaNode methodCallArgs) {\n        String methodName = getCalledMethodName(methodCall);\n        int methodArgsCount = getCalledMethodArgsCount(methodCallArgs);\n        return isNameOfCaseChangingMethod(methodName) && methodArgsCount == 0;\n    }\n\n    private String getCalledMethodName(JavaNode methodCall) {\n        if (methodCall instanceof ASTPrimaryPrefix) {\n            ASTName methodName = methodCall.getFirstDescendantOfType(ASTName.class);\n            return methodName != null ? methodName.getImage() : null;\n        }\n        return methodCall.getImage();\n    }\n\n    private boolean isNameOfCaseChangingMethod(String methodName) {\n        if (methodName != null) {\n            for (String caseChangingMethod : CASE_CHANGING_METHODS) {\n                if (methodName.endsWith(caseChangingMethod)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    private boolean hasEqualsMethodCallChainedAtPosition(ASTPrimaryExpression expr, int pos) {\n        int argsPos = pos + 1;\n        if (hasNodeAtPosition(expr, argsPos)) {\n            JavaNode chainedMethodCall = expr.getChild(pos);\n            JavaNode chainedMethodCallArgs = expr.getChild(argsPos);\n            return isEqualsMethodCall(chainedMethodCall, chainedMethodCallArgs);\n        }\n        return false;\n    }\n\n    private boolean hasNodeAtPosition(ASTPrimaryExpression expr, int pos) {\n        return pos < expr.getNumChildren();\n    }\n\n    private boolean isArgumentOfEqualsMethodCall(ASTPrimaryExpression expr) {\n        ASTPrimarySuffix parentMethodCallArgs = getParentMethodCallArgsSuffix(expr);\n        if (parentMethodCallArgs != null) {\n            List<JavaNode> parentNodes = parentMethodCallArgs.getParent().findChildrenOfType(JavaNode.class);\n            int parentMethodCallIndex = parentNodes.indexOf(parentMethodCallArgs) - 1;\n            JavaNode parentMethodCall = parentNodes.get(parentMethodCallIndex);\n            return isEqualsMethodCall(parentMethodCall, parentMethodCallArgs);\n        }\n        return false;\n    }\n\n    private ASTPrimarySuffix getParentMethodCallArgsSuffix(ASTPrimaryExpression expr) {\n        JavaNode parent = expr.getParent().getParent(); // ASTArgumentList/ASTExpression/ASTPrimaryExpression\n        return parent instanceof ASTArgumentList\n                ? parent.getFirstParentOfType(ASTPrimarySuffix.class)\n                : null;\n    }\n\n    private boolean isEqualsMethodCall(JavaNode methodCall, JavaNode methodCallArgs) {\n        int methodArgsCount = getCalledMethodArgsCount(methodCallArgs);\n        return EQUALITY_METHODS.contains(methodCall.getImage()) && methodArgsCount == 1;\n    }\n\n    private int getCalledMethodArgsCount(JavaNode methodCallArgs) {\n        ASTArguments args = methodCallArgs.getFirstDescendantOfType(ASTArguments.class);\n        return args != null ? args.size() : -1;\n    }\n}\n", "filePathAfter": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/errorprone/UnnecessaryCaseChangeRule.java", "sourceCodeAfterForWhole": "/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.lang.java.rule.errorprone;\n\nimport static java.util.Arrays.asList;\n\nimport java.util.List;\n\nimport net.sourceforge.pmd.lang.java.ast.ASTArguments;\nimport net.sourceforge.pmd.lang.java.ast.ASTName;\nimport net.sourceforge.pmd.lang.java.ast.ASTPrimaryExpression;\nimport net.sourceforge.pmd.lang.java.ast.JavaNode;\nimport net.sourceforge.pmd.lang.java.rule.AbstractJavaRule;\n\npublic class UnnecessaryCaseChangeRule extends AbstractJavaRule {\n\n    private static final List<String> CASE_CHANGING_METHODS = asList(\"toLowerCase\", \"toUpperCase\");\n    private static final List<String> EQUALITY_METHODS = asList(\"equals\", \"equalsIgnoreCase\");\n\n    @Override\n    public Object visit(ASTPrimaryExpression expr, Object data) {\n        if (hasUnnecessaryCaseChange(expr)) {\n            addViolation(data, expr);\n        }\n        return super.visit(expr, data);\n    }\n\n    private boolean hasUnnecessaryCaseChange(ASTPrimaryExpression expr) {\n        int equalsMethodCallIndex = getEqualsMethodCallIndex(expr);\n        if (equalsMethodCallIndex != -1) {\n            int equalsMethodCallArgsIndex = equalsMethodCallIndex + 1;\n            ASTPrimaryExpression equalsCallArgs = getMethodCallArgsAtPosition(expr, equalsMethodCallArgsIndex);\n            return anyHasCaseChangingMethodCall(expr, equalsCallArgs);\n        }\n        return false;\n    }\n\n    private int getEqualsMethodCallIndex(ASTPrimaryExpression expr) {\n        for (int callIndex = 0; callIndex < expr.getNumChildren(); callIndex++) {\n            JavaNode methodCall = expr.getChild(callIndex);\n            if (isEqualsMethodCall(methodCall)) {\n                return callIndex;\n            }\n        }\n        return -1;\n    }\n\n    private boolean isEqualsMethodCall(JavaNode methodCall) {\n        return calledMethodHasNameFromList(methodCall, EQUALITY_METHODS);\n    }\n\n    private ASTPrimaryExpression getMethodCallArgsAtPosition(ASTPrimaryExpression expr, int argsPos) {\n        if (hasChildAtPosition(expr, argsPos)) {\n            JavaNode methodCallArgs = expr.getChild(argsPos);\n            return methodCallArgs.getFirstDescendantOfType(ASTPrimaryExpression.class);\n        }\n        return null;\n    }\n\n    private boolean hasChildAtPosition(ASTPrimaryExpression expr, int pos) {\n        return expr.getNumChildren() > pos;\n    }\n\n    private boolean anyHasCaseChangingMethodCall(ASTPrimaryExpression ... exprs) {\n        for (ASTPrimaryExpression expr : exprs) {\n            if (expr != null && hasCaseChangingMethodCall(expr)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private boolean hasCaseChangingMethodCall(ASTPrimaryExpression expr) {\n        for (int callArgsIndex = 1; callArgsIndex < expr.getNumChildren(); callArgsIndex++) {\n            JavaNode methodCall = expr.getChild(callArgsIndex - 1);\n            JavaNode methodCallArgs = expr.getChild(callArgsIndex);\n            if (isCaseChangingMethodCall(methodCall, methodCallArgs)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private boolean isCaseChangingMethodCall(JavaNode methodCall, JavaNode methodCallArgs) {\n        if (calledMethodHasNameFromList(methodCall, CASE_CHANGING_METHODS)) {\n            ASTArguments args = methodCallArgs.getFirstDescendantOfType(ASTArguments.class);\n            return args != null && args.size() == 0;\n        }\n        return false;\n    }\n\n    private boolean calledMethodHasNameFromList(JavaNode methodCall, List<String> nameList) {\n        String methodName = getCalledMethodName(methodCall);\n        if (methodName != null) {\n            for (String nameFromList : nameList) {\n                if (methodName.endsWith(nameFromList)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    private String getCalledMethodName(JavaNode methodCall) {\n        String methodName = methodCall.getImage();\n        if (methodName == null) {\n            ASTName name = methodCall.getFirstDescendantOfType(ASTName.class);\n            return name != null ? methodNameFromCallImage(name.getImage()) : null;\n        }\n        return methodName;\n    }\n\n    private String methodNameFromCallImage(String methodCallImage) {\n        if (methodCallImage.contains(\".\")) {\n            String[] callParts = methodCallImage.split(\"\\\\.\");\n            return callParts[1];\n        }\n        return methodCallImage;\n    }\n}\n", "diffSourceCodeSet": [], "invokedMethodSet": [], "sourceCodeAfterRefactoring": "private boolean isCaseChangingMethodCall(JavaNode methodCall, JavaNode methodCallArgs) {\n        if (calledMethodHasNameFromList(methodCall, CASE_CHANGING_METHODS)) {\n            ASTArguments args = methodCallArgs.getFirstDescendantOfType(ASTArguments.class);\n            return args != null && args.size() == 0;\n        }\n        return false;\n    }", "diffSourceCode": "-   51:     private boolean isCaseChangingMethodCall(JavaNode methodCall, JavaNode methodCallArgs) {\n-   52:         String methodName = getCalledMethodName(methodCall);\n-   53:         int methodArgsCount = getCalledMethodArgsCount(methodCallArgs);\n-   54:         return isNameOfCaseChangingMethod(methodName) && methodArgsCount == 0;\n-   55:     }\n-   86:     private boolean hasNodeAtPosition(ASTPrimaryExpression expr, int pos) {\n-   87:         return pos < expr.getNumChildren();\n-   88:     }\n-   89: \n-   90:     private boolean isArgumentOfEqualsMethodCall(ASTPrimaryExpression expr) {\n-   91:         ASTPrimarySuffix parentMethodCallArgs = getParentMethodCallArgsSuffix(expr);\n-   92:         if (parentMethodCallArgs != null) {\n-  113:     private int getCalledMethodArgsCount(JavaNode methodCallArgs) {\n-  114:         ASTArguments args = methodCallArgs.getFirstDescendantOfType(ASTArguments.class);\n-  115:         return args != null ? args.size() : -1;\n-  116:     }\n+   51:         return calledMethodHasNameFromList(methodCall, EQUALITY_METHODS);\n+   52:     }\n+   53: \n+   54:     private ASTPrimaryExpression getMethodCallArgsAtPosition(ASTPrimaryExpression expr, int argsPos) {\n+   55:         if (hasChildAtPosition(expr, argsPos)) {\n+   86:     private boolean isCaseChangingMethodCall(JavaNode methodCall, JavaNode methodCallArgs) {\n+   87:         if (calledMethodHasNameFromList(methodCall, CASE_CHANGING_METHODS)) {\n+   88:             ASTArguments args = methodCallArgs.getFirstDescendantOfType(ASTArguments.class);\n+   89:             return args != null && args.size() == 0;\n+   90:         }\n+   91:         return false;\n+   92:     }\n+  113:     }\n+  114: \n+  115:     private String methodNameFromCallImage(String methodCallImage) {\n+  116:         if (methodCallImage.contains(\".\")) {\n", "uniqueId": "eca547b5054814933f87f0718e0432bc2e27e5da_51_55__86_92_113_116", "moveFileExist": true, "testResult": true, "coverageInfo": {"INSTRUCTION": {"missed": 0, "covered": 12}, "BRANCH": {"missed": 0, "covered": 2}, "LINE": {"missed": 0, "covered": 2}, "COMPLEXITY": {"missed": 0, "covered": 2}, "METHOD": {"missed": 0, "covered": 1}}, "compileResultBefore": true, "compileResultCurrent": true, "compileJDK": 11, "refactoringMinerResult": true, "compileAndTestResult": true, "refactoredCode": "To perform the \"Inline Method\" refactoring operation on the provided code, we will inline the `getCalledMethodArgsCount` method. This method is only called in two places, and its logic can be directly integrated into those methods without losing clarity.\n\nHere\u2019s the refactored class code after inlining the `getCalledMethodArgsCount` method:\n\n##########################\n```java\n/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.lang.java.rule.errorprone;\n\nimport static java.util.Arrays.asList;\n\nimport java.util.List;\n\nimport net.sourceforge.pmd.lang.java.ast.ASTArgumentList;\nimport net.sourceforge.pmd.lang.java.ast.ASTArguments;\nimport net.sourceforge.pmd.lang.java.ast.ASTName;\nimport net.sourceforge.pmd.lang.java.ast.ASTPrimaryExpression;\nimport net.sourceforge.pmd.lang.java.ast.ASTPrimaryPrefix;\nimport net.sourceforge.pmd.lang.java.ast.ASTPrimarySuffix;\nimport net.sourceforge.pmd.lang.java.ast.JavaNode;\nimport net.sourceforge.pmd.lang.java.rule.AbstractJavaRule;\n\npublic class UnnecessaryCaseChangeRule extends AbstractJavaRule {\n\n    private static final List<String> CASE_CHANGING_METHODS = asList(\"toLowerCase\", \"toUpperCase\");\n    private static final List<String> EQUALITY_METHODS = asList(\"equals\", \"equalsIgnoreCase\");\n\n    @Override\n    public Object visit(ASTPrimaryExpression expr, Object data) {\n        int caseChangingCallIndex = getCaseChangingMethodCallIndex(expr);\n        if (caseChangingCallIndex != -1) {\n            int chainedMethodCallIndex = caseChangingCallIndex + 2;\n            if (hasEqualsMethodCallChainedAtPosition(expr, chainedMethodCallIndex)\n                    || isArgumentOfEqualsMethodCall(expr)) {\n                addViolation(data, expr);\n                return data;\n            }\n        }\n        return super.visit(expr, data);\n    }\n\n    private int getCaseChangingMethodCallIndex(ASTPrimaryExpression expr) {\n        for (int callArgsIndex = 1; callArgsIndex < expr.getNumChildren(); callArgsIndex++) {\n            JavaNode methodCallArgs = expr.getChild(callArgsIndex);\n            int callIndex = callArgsIndex - 1;\n            JavaNode methodCall = expr.getChild(callIndex);\n            if (isCaseChangingMethodCall(methodCall, methodCallArgs)) {\n                return callIndex;\n            }\n        }\n        return -1;\n    }\n\n    private boolean isCaseChangingMethodCall(JavaNode methodCall, JavaNode methodCallArgs) {\n        String methodName = getCalledMethodName(methodCall);\n        ASTArguments args = methodCallArgs.getFirstDescendantOfType(ASTArguments.class);\n        int methodArgsCount = args != null ? args.size() : -1;\n        return isNameOfCaseChangingMethod(methodName) && methodArgsCount == 0;\n    }\n\n    private String getCalledMethodName(JavaNode methodCall) {\n        if (methodCall instanceof ASTPrimaryPrefix) {\n            ASTName methodName = methodCall.getFirstDescendantOfType(ASTName.class);\n            return methodName != null ? methodName.getImage() : null;\n        }\n        return methodCall.getImage();\n    }\n\n    private boolean isNameOfCaseChangingMethod(String methodName) {\n        if (methodName != null) {\n            for (String caseChangingMethod : CASE_CHANGING_METHODS) {\n                if (methodName.endsWith(caseChangingMethod)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    private boolean hasEqualsMethodCallChainedAtPosition(ASTPrimaryExpression expr, int pos) {\n        int argsPos = pos + 1;\n        if (hasNodeAtPosition(expr, argsPos)) {\n            JavaNode chainedMethodCall = expr.getChild(pos);\n            JavaNode chainedMethodCallArgs = expr.getChild(argsPos);\n            return isEqualsMethodCall(chainedMethodCall, chainedMethodCallArgs);\n        }\n        return false;\n    }\n\n    private boolean hasNodeAtPosition(ASTPrimaryExpression expr, int pos) {\n        return pos < expr.getNumChildren();\n    }\n\n    private boolean isArgumentOfEqualsMethodCall(ASTPrimaryExpression expr) {\n        ASTPrimarySuffix parentMethodCallArgs = getParentMethodCallArgsSuffix(expr);\n        if (parentMethodCallArgs != null) {\n            List<JavaNode> parentNodes = parentMethodCallArgs.getParent().findChildrenOfType(JavaNode.class);\n            int parentMethodCallIndex = parentNodes.indexOf(parentMethodCallArgs) - 1;\n            JavaNode parentMethodCall = parentNodes.get(parentMethodCallIndex);\n            return isEqualsMethodCall(parentMethodCall, parentMethodCallArgs);\n        }\n        return false;\n    }\n\n    private ASTPrimarySuffix getParentMethodCallArgsSuffix(ASTPrimaryExpression expr) {\n        JavaNode parent = expr.getParent().getParent(); // ASTArgumentList/ASTExpression/ASTPrimaryExpression\n        return parent instanceof ASTArgumentList\n                ? parent.getFirstParentOfType(ASTPrimarySuffix.class)\n                : null;\n    }\n\n    private boolean isEqualsMethodCall(JavaNode methodCall, JavaNode methodCallArgs) {\n        ASTArguments args = methodCallArgs.getFirstDescendantOfType(ASTArguments.class);\n        int methodArgsCount = args != null ? args.size() : -1;\n        return EQUALITY_METHODS.contains(methodCall.getImage()) && methodArgsCount == 1;\n    }\n}\n```\n########################## \n\nIn this refactored code, the `getCalledMethodArgsCount` method has been removed, and its logic has been directly integrated into the `isCaseChangingMethodCall` and `isEqualsMethodCall` methods. This improves the readability and maintainability of the code by reducing the number of methods and making the logic more straightforward.", "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to Refactor:\nprivate int getCalledMethodArgsCount(JavaNode methodCallArgs) {\n        ASTArguments args = methodCallArgs.getFirstDescendantOfType(ASTArguments.class);\n        return args != null ? args.size() : -1;\n    }\n\nClass content:\n/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.lang.java.rule.errorprone;\n\nimport static java.util.Arrays.asList;\n\nimport java.util.List;\n\nimport net.sourceforge.pmd.lang.java.ast.ASTArgumentList;\nimport net.sourceforge.pmd.lang.java.ast.ASTArguments;\nimport net.sourceforge.pmd.lang.java.ast.ASTName;\nimport net.sourceforge.pmd.lang.java.ast.ASTPrimaryExpression;\nimport net.sourceforge.pmd.lang.java.ast.ASTPrimaryPrefix;\nimport net.sourceforge.pmd.lang.java.ast.ASTPrimarySuffix;\nimport net.sourceforge.pmd.lang.java.ast.JavaNode;\nimport net.sourceforge.pmd.lang.java.rule.AbstractJavaRule;\n\npublic class UnnecessaryCaseChangeRule extends AbstractJavaRule {\n\n    private static final List<String> CASE_CHANGING_METHODS = asList(\"toLowerCase\", \"toUpperCase\");\n    private static final List<String> EQUALITY_METHODS = asList(\"equals\", \"equalsIgnoreCase\");\n\n    @Override\n    public Object visit(ASTPrimaryExpression expr, Object data) {\n        int caseChangingCallIndex = getCaseChangingMethodCallIndex(expr);\n        if (caseChangingCallIndex != -1) {\n            int chainedMethodCallIndex = caseChangingCallIndex + 2;\n            if (hasEqualsMethodCallChainedAtPosition(expr, chainedMethodCallIndex)\n                    || isArgumentOfEqualsMethodCall(expr)) {\n                addViolation(data, expr);\n                return data;\n            }\n        }\n        return super.visit(expr, data);\n    }\n\n    private int getCaseChangingMethodCallIndex(ASTPrimaryExpression expr) {\n        for (int callArgsIndex = 1; callArgsIndex < expr.getNumChildren(); callArgsIndex++) {\n            JavaNode methodCallArgs = expr.getChild(callArgsIndex);\n            int callIndex = callArgsIndex - 1;\n            JavaNode methodCall = expr.getChild(callIndex);\n            if (isCaseChangingMethodCall(methodCall, methodCallArgs)) {\n                return callIndex;\n            }\n        }\n        return -1;\n    }\n\n    private boolean isCaseChangingMethodCall(JavaNode methodCall, JavaNode methodCallArgs) {\n        String methodName = getCalledMethodName(methodCall);\n        int methodArgsCount = getCalledMethodArgsCount(methodCallArgs);\n        return isNameOfCaseChangingMethod(methodName) && methodArgsCount == 0;\n    }\n\n    private String getCalledMethodName(JavaNode methodCall) {\n        if (methodCall instanceof ASTPrimaryPrefix) {\n            ASTName methodName = methodCall.getFirstDescendantOfType(ASTName.class);\n            return methodName != null ? methodName.getImage() : null;\n        }\n        return methodCall.getImage();\n    }\n\n    private boolean isNameOfCaseChangingMethod(String methodName) {\n        if (methodName != null) {\n            for (String caseChangingMethod : CASE_CHANGING_METHODS) {\n                if (methodName.endsWith(caseChangingMethod)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    private boolean hasEqualsMethodCallChainedAtPosition(ASTPrimaryExpression expr, int pos) {\n        int argsPos = pos + 1;\n        if (hasNodeAtPosition(expr, argsPos)) {\n            JavaNode chainedMethodCall = expr.getChild(pos);\n            JavaNode chainedMethodCallArgs = expr.getChild(argsPos);\n            return isEqualsMethodCall(chainedMethodCall, chainedMethodCallArgs);\n        }\n        return false;\n    }\n\n    private boolean hasNodeAtPosition(ASTPrimaryExpression expr, int pos) {\n        return pos < expr.getNumChildren();\n    }\n\n    private boolean isArgumentOfEqualsMethodCall(ASTPrimaryExpression expr) {\n        ASTPrimarySuffix parentMethodCallArgs = getParentMethodCallArgsSuffix(expr);\n        if (parentMethodCallArgs != null) {\n            List<JavaNode> parentNodes = parentMethodCallArgs.getParent().findChildrenOfType(JavaNode.class);\n            int parentMethodCallIndex = parentNodes.indexOf(parentMethodCallArgs) - 1;\n            JavaNode parentMethodCall = parentNodes.get(parentMethodCallIndex);\n            return isEqualsMethodCall(parentMethodCall, parentMethodCallArgs);\n        }\n        return false;\n    }\n\n    private ASTPrimarySuffix getParentMethodCallArgsSuffix(ASTPrimaryExpression expr) {\n        JavaNode parent = expr.getParent().getParent(); // ASTArgumentList/ASTExpression/ASTPrimaryExpression\n        return parent instanceof ASTArgumentList\n                ? parent.getFirstParentOfType(ASTPrimarySuffix.class)\n                : null;\n    }\n\n    private boolean isEqualsMethodCall(JavaNode methodCall, JavaNode methodCallArgs) {\n        int methodArgsCount = getCalledMethodArgsCount(methodCallArgs);\n        return EQUALITY_METHODS.contains(methodCall.getImage()) && methodArgsCount == 1;\n    }\n\n    private int getCalledMethodArgsCount(JavaNode methodCallArgs) {\n        ASTArguments args = methodCallArgs.getFirstDescendantOfType(ASTArguments.class);\n        return args != null ? args.size() : -1;\n    }\n}\n\nRefactoring Operation:\nInline Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored class code in the following format:\n##########################\nrefactored_class_code\n##########################\n\n\n"}, {"type": "Extract Method", "description": "Extract Method\tpublic runPMDRules(tempDir Path, sourceDirectory String, ruleset String, formatter String) : ExecutionResult extracted from public runPMDRules(tempDir Path, sourceDirectory String, ruleset String) : ExecutionResult in class net.sourceforge.pmd.it.PMDExecutor", "diffLocations": [{"filePath": "pmd-dist/src/test/java/net/sourceforge/pmd/it/PMDExecutor.java", "startLine": 96, "endLine": 116, "startColumn": 0, "endColumn": 0}, {"filePath": "pmd-dist/src/test/java/net/sourceforge/pmd/it/PMDExecutor.java", "startLine": 97, "endLine": 108, "startColumn": 0, "endColumn": 0}, {"filePath": "pmd-dist/src/test/java/net/sourceforge/pmd/it/PMDExecutor.java", "startLine": 110, "endLine": 121, "startColumn": 0, "endColumn": 0}], "sourceCodeBeforeRefactoring": "/**\n     * Executes the PMD found in tempDir against the given sourceDirectory path with the given ruleset.\n     *\n     * @param tempDir the directory, to which the binary distribution has been extracted\n     * @param sourceDirectory the source directory, that PMD should analyze\n     * @param ruleset the ruleset, that PMD should execute\n     * @return collected result of the execution\n     * @throws Exception if the execution fails for any reason (executable not found, ...)\n     */\n    public static ExecutionResult runPMDRules(Path tempDir, String sourceDirectory, String ruleset) throws Exception {\n        Path reportFile = Files.createTempFile(\"pmd-it-report\", \"txt\");\n        reportFile.toFile().deleteOnExit();\n\n        if (SystemUtils.IS_OS_WINDOWS) {\n            return runPMDWindows(tempDir, reportFile, SOURCE_DIRECTORY_FLAG, sourceDirectory, RULESET_FLAG, ruleset,\n                    FORMAT_FLAG, FORMATTER, REPORTFILE_FLAG, reportFile.toAbsolutePath().toString());\n        } else {\n            return runPMDUnix(tempDir, reportFile, SOURCE_DIRECTORY_FLAG, sourceDirectory, RULESET_FLAG, ruleset,\n                    FORMAT_FLAG, FORMATTER, REPORTFILE_FLAG, reportFile.toAbsolutePath().toString());\n        }\n    }", "filePathBefore": "pmd-dist/src/test/java/net/sourceforge/pmd/it/PMDExecutor.java", "isPureRefactoring": true, "commitId": "4cf9f5904ad76f13aecc2210a758168974657eb1", "packageNameBefore": "net.sourceforge.pmd.it", "classNameBefore": "net.sourceforge.pmd.it.PMDExecutor", "methodNameBefore": "net.sourceforge.pmd.it.PMDExecutor#runPMDRules", "invokedMethod": "methodSignature: net.sourceforge.pmd.it.PMDExecutor#runPMDWindows\n methodBody: private static ExecutionResult runPMDWindows(Path tempDir, Path reportFile, String ... arguments) throws Exception {\nString cmd=tempDir.resolve(PMD_BIN_PREFIX + PMDVersion.VERSION + \"/bin/pmd.bat\").toAbsolutePath().toString();\nreturn runPMD(cmd,Arrays.asList(arguments),reportFile);\n}\nmethodSignature: net.sourceforge.pmd.it.ExecutionResult#toString\n methodBody: public String toString() {\nStringBuilder sb=new StringBuilder();\nsb.append(\"ExecutionResult:\").append(PMD.EOL).append(\" exit code: \").append(exitCode).append(PMD.EOL).append(\" output:\").append(PMD.EOL).append(output).append(PMD.EOL).append(\" errorOutput:\").append(PMD.EOL).append(errorOutput).append(PMD.EOL).append(\" report:\").append(PMD.EOL).append(report).append(PMD.EOL);\nreturn sb.toString();\n}\nmethodSignature: net.sourceforge.pmd.it.PMDExecutor#runPMDUnix\n methodBody: private static ExecutionResult runPMDUnix(Path tempDir, Path reportFile, String ... arguments) throws Exception {\nString cmd=tempDir.resolve(PMD_BIN_PREFIX + PMDVersion.VERSION + \"/bin/run.sh\").toAbsolutePath().toString();\nList<String> args=new ArrayList<>();\nargs.add(\"pmd\");\nargs.addAll(Arrays.asList(arguments));\nreturn runPMD(cmd,args,reportFile);\n}", "classSignatureBefore": "public class PMDExecutor ", "methodNameBeforeSet": ["net.sourceforge.pmd.it.PMDExecutor#runPMDRules"], "classNameBeforeSet": ["net.sourceforge.pmd.it.PMDExecutor"], "classSignatureBeforeSet": ["public class PMDExecutor "], "purityCheckResultList": [{"isPure": true, "purityComment": "Changes are within the Extract Method refactoring mechanics", "description": "All the mappings are matched! - all mapped", "mappingState": 1}], "sourceCodeBeforeForWhole": "/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.it;\n\nimport java.io.IOException;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.concurrent.TimeUnit;\n\nimport org.apache.commons.io.IOUtils;\nimport org.apache.commons.lang3.SystemUtils;\n\nimport net.sourceforge.pmd.PMDVersion;\n\n/**\n * Executes PMD from command line. Deals with the differences, when PMD is run on Windows or on Linux.\n *\n * @author Andreas Dangel\n */\npublic class PMDExecutor {\n    private static final String PMD_BIN_PREFIX = \"pmd-bin-\";\n    private static final String SOURCE_DIRECTORY_FLAG = \"-d\";\n    private static final String RULESET_FLAG = \"-R\";\n    private static final String FORMAT_FLAG = \"-f\";\n    private static final String FORMATTER = \"text\";\n    private static final String REPORTFILE_FLAG = \"-r\";\n\n    private PMDExecutor() {\n        // this is a helper class only\n    }\n\n    private static ExecutionResult runPMDUnix(Path tempDir, Path reportFile, String ... arguments) throws Exception {\n        String cmd = tempDir.resolve(PMD_BIN_PREFIX + PMDVersion.VERSION + \"/bin/run.sh\").toAbsolutePath().toString();\n        List<String> args = new ArrayList<>();\n        args.add(\"pmd\");\n        args.addAll(Arrays.asList(arguments));\n        return runPMD(cmd, args, reportFile);\n    }\n\n    private static ExecutionResult runPMDWindows(Path tempDir, Path reportFile, String ... arguments) throws Exception {\n        String cmd = tempDir.resolve(PMD_BIN_PREFIX + PMDVersion.VERSION + \"/bin/pmd.bat\").toAbsolutePath().toString();\n        return runPMD(cmd, Arrays.asList(arguments), reportFile);\n    }\n\n    private static ExecutionResult runPMD(String cmd, List<String> arguments, Path reportFile) throws Exception {\n        ProcessBuilder pb = new ProcessBuilder(cmd);\n        pb.command().addAll(arguments);\n        pb.redirectErrorStream(false);\n        final Process process = pb.start();\n        final ExecutionResult.Builder result = new ExecutionResult.Builder();\n\n        Thread outputReader = new Thread(new Runnable() {\n            @Override\n            public void run() {\n                String output;\n                try {\n                    output = IOUtils.toString(process.getInputStream(), StandardCharsets.UTF_8);\n                    result.withOutput(output);\n                } catch (IOException e) {\n                    result.withOutput(\"Exception occurred: \" + e.toString());\n                }\n            }\n        });\n        outputReader.start();\n        Thread errorReader = new Thread(new Runnable() {\n            @Override\n            public void run() {\n                String error;\n                try {\n                    error = IOUtils.toString(process.getErrorStream(), StandardCharsets.UTF_8);\n                    result.withErrorOutput(error);\n                } catch (IOException e) {\n                    result.withErrorOutput(\"Exception occurred: \" + e.toString());\n                }\n            }\n        });\n        errorReader.start();\n\n        int exitCode = process.waitFor();\n        outputReader.join(TimeUnit.MINUTES.toMillis(5));\n        errorReader.join(TimeUnit.MINUTES.toMillis(5));\n\n        String report = null;\n        if (reportFile != null) {\n            report = IOUtils.toString(reportFile.toUri(), StandardCharsets.UTF_8);\n        }\n        return result.withExitCode(exitCode).withReport(report).build();\n    }\n\n    /**\n     * Executes the PMD found in tempDir against the given sourceDirectory path with the given ruleset.\n     *\n     * @param tempDir the directory, to which the binary distribution has been extracted\n     * @param sourceDirectory the source directory, that PMD should analyze\n     * @param ruleset the ruleset, that PMD should execute\n     * @return collected result of the execution\n     * @throws Exception if the execution fails for any reason (executable not found, ...)\n     */\n    public static ExecutionResult runPMDRules(Path tempDir, String sourceDirectory, String ruleset) throws Exception {\n        Path reportFile = Files.createTempFile(\"pmd-it-report\", \"txt\");\n        reportFile.toFile().deleteOnExit();\n\n        if (SystemUtils.IS_OS_WINDOWS) {\n            return runPMDWindows(tempDir, reportFile, SOURCE_DIRECTORY_FLAG, sourceDirectory, RULESET_FLAG, ruleset,\n                    FORMAT_FLAG, FORMATTER, REPORTFILE_FLAG, reportFile.toAbsolutePath().toString());\n        } else {\n            return runPMDUnix(tempDir, reportFile, SOURCE_DIRECTORY_FLAG, sourceDirectory, RULESET_FLAG, ruleset,\n                    FORMAT_FLAG, FORMATTER, REPORTFILE_FLAG, reportFile.toAbsolutePath().toString());\n        }\n    }\n\n    /**\n     * Executes PMD found in tempDir with the given command line arguments.\n     * @param tempDir the directory, to which the binary distribution has been extracted\n     * @param arguments the arguments to execute PMD with\n     * @return collected result of the execution\n     * @throws Exception if the execution fails for any reason (executable not found, ...)\n     */\n    public static ExecutionResult runPMD(Path tempDir, String ... arguments) throws Exception {\n        if (SystemUtils.IS_OS_WINDOWS) {\n            return runPMDWindows(tempDir, null, arguments);\n        } else {\n            return runPMDUnix(tempDir, null, arguments);\n        }\n    }\n}\n", "filePathAfter": "pmd-dist/src/test/java/net/sourceforge/pmd/it/PMDExecutor.java", "sourceCodeAfterForWhole": "/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.it;\n\nimport java.io.IOException;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.concurrent.TimeUnit;\n\nimport org.apache.commons.io.IOUtils;\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.commons.lang3.SystemUtils;\n\nimport net.sourceforge.pmd.PMDVersion;\n\n/**\n * Executes PMD from command line. Deals with the differences, when PMD is run on Windows or on Linux.\n *\n * @author Andreas Dangel\n */\npublic class PMDExecutor {\n    private static final String PMD_BIN_PREFIX = \"pmd-bin-\";\n    private static final String SOURCE_DIRECTORY_FLAG = \"-d\";\n    private static final String RULESET_FLAG = \"-R\";\n    private static final String FORMAT_FLAG = \"-f\";\n    private static final String FORMATTER = \"text\";\n    private static final String REPORTFILE_FLAG = \"-r\";\n\n    private PMDExecutor() {\n        // this is a helper class only\n    }\n\n    private static ExecutionResult runPMDUnix(Path tempDir, Path reportFile, String ... arguments) throws Exception {\n        String cmd = tempDir.resolve(PMD_BIN_PREFIX + PMDVersion.VERSION + \"/bin/run.sh\").toAbsolutePath().toString();\n        List<String> args = new ArrayList<>();\n        args.add(\"pmd\");\n        args.addAll(Arrays.asList(arguments));\n        return runPMD(cmd, args, reportFile);\n    }\n\n    private static ExecutionResult runPMDWindows(Path tempDir, Path reportFile, String ... arguments) throws Exception {\n        String cmd = tempDir.resolve(PMD_BIN_PREFIX + PMDVersion.VERSION + \"/bin/pmd.bat\").toAbsolutePath().toString();\n        return runPMD(cmd, Arrays.asList(arguments), reportFile);\n    }\n\n    private static ExecutionResult runPMD(String cmd, List<String> arguments, Path reportFile) throws Exception {\n        ProcessBuilder pb = new ProcessBuilder(cmd);\n        pb.command().addAll(arguments);\n        pb.redirectErrorStream(false);\n        final Process process = pb.start();\n        final ExecutionResult.Builder result = new ExecutionResult.Builder();\n\n        Thread outputReader = new Thread(new Runnable() {\n            @Override\n            public void run() {\n                String output;\n                try {\n                    output = IOUtils.toString(process.getInputStream(), StandardCharsets.UTF_8);\n                    result.withOutput(output);\n                } catch (IOException e) {\n                    result.withOutput(\"Exception occurred: \" + e.toString());\n                }\n            }\n        });\n        outputReader.start();\n        Thread errorReader = new Thread(new Runnable() {\n            @Override\n            public void run() {\n                String error;\n                try {\n                    error = IOUtils.toString(process.getErrorStream(), StandardCharsets.UTF_8);\n                    result.withErrorOutput(error);\n                } catch (IOException e) {\n                    result.withErrorOutput(\"Exception occurred: \" + e.toString());\n                }\n            }\n        });\n        errorReader.start();\n\n        int exitCode = process.waitFor();\n        outputReader.join(TimeUnit.MINUTES.toMillis(5));\n        errorReader.join(TimeUnit.MINUTES.toMillis(5));\n\n        String report = null;\n        if (reportFile != null) {\n            report = IOUtils.toString(reportFile.toUri(), StandardCharsets.UTF_8);\n        }\n        return result.withExitCode(exitCode).withReport(report).build();\n    }\n\n    /**\n     * Executes the PMD found in tempDir against the given sourceDirectory path with the given ruleset.\n     *\n     * @param tempDir the directory, to which the binary distribution has been extracted\n     * @param sourceDirectory the source directory, that PMD should analyze\n     * @param ruleset the ruleset, that PMD should execute\n     * @return collected result of the execution\n     * @throws Exception if the execution fails for any reason (executable not found, ...)\n     */\n    public static ExecutionResult runPMDRules(Path tempDir, String sourceDirectory, String ruleset) throws Exception {\n        return runPMDRules(tempDir, sourceDirectory, ruleset, FORMATTER);\n    }\n\n    public static ExecutionResult runPMDRules(Path tempDir, String sourceDirectory, String ruleset, String formatter) throws Exception {\n        Path reportFile = Files.createTempFile(\"pmd-it-report\", \"txt\");\n        reportFile.toFile().deleteOnExit();\n\n        if (SystemUtils.IS_OS_WINDOWS) {\n            return runPMDWindows(tempDir, reportFile, SOURCE_DIRECTORY_FLAG, sourceDirectory, RULESET_FLAG, ruleset,\n                    FORMAT_FLAG, formatter, REPORTFILE_FLAG, reportFile.toAbsolutePath().toString());\n        } else {\n            return runPMDUnix(tempDir, reportFile, SOURCE_DIRECTORY_FLAG, sourceDirectory, RULESET_FLAG, ruleset,\n                    FORMAT_FLAG, formatter, REPORTFILE_FLAG, reportFile.toAbsolutePath().toString());\n        }\n    }\n\n    /**\n     * Executes PMD found in tempDir with the given command line arguments.\n     * @param tempDir the directory, to which the binary distribution has been extracted\n     * @param arguments the arguments to execute PMD with\n     * @return collected result of the execution\n     * @throws Exception if the execution fails for any reason (executable not found, ...)\n     */\n    public static ExecutionResult runPMD(Path tempDir, String ... arguments) throws Exception {\n        if (SystemUtils.IS_OS_WINDOWS) {\n            return runPMDWindows(tempDir, null, arguments);\n        } else {\n            return runPMDUnix(tempDir, null, arguments);\n        }\n    }\n\n    public static boolean isJava7Test() {\n        return StringUtils.equals(System.getenv(\"JAVA_HOME\"), System.getProperty(\"java7.home\"));\n    }\n}\n", "diffSourceCodeSet": ["public static ExecutionResult runPMDRules(Path tempDir, String sourceDirectory, String ruleset, String formatter) throws Exception {\n        Path reportFile = Files.createTempFile(\"pmd-it-report\", \"txt\");\n        reportFile.toFile().deleteOnExit();\n\n        if (SystemUtils.IS_OS_WINDOWS) {\n            return runPMDWindows(tempDir, reportFile, SOURCE_DIRECTORY_FLAG, sourceDirectory, RULESET_FLAG, ruleset,\n                    FORMAT_FLAG, formatter, REPORTFILE_FLAG, reportFile.toAbsolutePath().toString());\n        } else {\n            return runPMDUnix(tempDir, reportFile, SOURCE_DIRECTORY_FLAG, sourceDirectory, RULESET_FLAG, ruleset,\n                    FORMAT_FLAG, formatter, REPORTFILE_FLAG, reportFile.toAbsolutePath().toString());\n        }\n    }"], "invokedMethodSet": ["methodSignature: net.sourceforge.pmd.it.PMDExecutor#runPMDWindows\n methodBody: private static ExecutionResult runPMDWindows(Path tempDir, Path reportFile, String ... arguments) throws Exception {\nString cmd=tempDir.resolve(PMD_BIN_PREFIX + PMDVersion.VERSION + \"/bin/pmd.bat\").toAbsolutePath().toString();\nreturn runPMD(cmd,Arrays.asList(arguments),reportFile);\n}", "methodSignature: net.sourceforge.pmd.it.ExecutionResult#toString\n methodBody: public String toString() {\nStringBuilder sb=new StringBuilder();\nsb.append(\"ExecutionResult:\").append(PMD.EOL).append(\" exit code: \").append(exitCode).append(PMD.EOL).append(\" output:\").append(PMD.EOL).append(output).append(PMD.EOL).append(\" errorOutput:\").append(PMD.EOL).append(errorOutput).append(PMD.EOL).append(\" report:\").append(PMD.EOL).append(report).append(PMD.EOL);\nreturn sb.toString();\n}", "methodSignature: net.sourceforge.pmd.it.PMDExecutor#runPMDUnix\n methodBody: private static ExecutionResult runPMDUnix(Path tempDir, Path reportFile, String ... arguments) throws Exception {\nString cmd=tempDir.resolve(PMD_BIN_PREFIX + PMDVersion.VERSION + \"/bin/run.sh\").toAbsolutePath().toString();\nList<String> args=new ArrayList<>();\nargs.add(\"pmd\");\nargs.addAll(Arrays.asList(arguments));\nreturn runPMD(cmd,args,reportFile);\n}"], "sourceCodeAfterRefactoring": "/**\n     * Executes the PMD found in tempDir against the given sourceDirectory path with the given ruleset.\n     *\n     * @param tempDir the directory, to which the binary distribution has been extracted\n     * @param sourceDirectory the source directory, that PMD should analyze\n     * @param ruleset the ruleset, that PMD should execute\n     * @return collected result of the execution\n     * @throws Exception if the execution fails for any reason (executable not found, ...)\n     */\n    public static ExecutionResult runPMDRules(Path tempDir, String sourceDirectory, String ruleset) throws Exception {\n        return runPMDRules(tempDir, sourceDirectory, ruleset, FORMATTER);\n    }\npublic static ExecutionResult runPMDRules(Path tempDir, String sourceDirectory, String ruleset, String formatter) throws Exception {\n        Path reportFile = Files.createTempFile(\"pmd-it-report\", \"txt\");\n        reportFile.toFile().deleteOnExit();\n\n        if (SystemUtils.IS_OS_WINDOWS) {\n            return runPMDWindows(tempDir, reportFile, SOURCE_DIRECTORY_FLAG, sourceDirectory, RULESET_FLAG, ruleset,\n                    FORMAT_FLAG, formatter, REPORTFILE_FLAG, reportFile.toAbsolutePath().toString());\n        } else {\n            return runPMDUnix(tempDir, reportFile, SOURCE_DIRECTORY_FLAG, sourceDirectory, RULESET_FLAG, ruleset,\n                    FORMAT_FLAG, formatter, REPORTFILE_FLAG, reportFile.toAbsolutePath().toString());\n        }\n    }", "diffSourceCode": "-   96:     /**\n-   97:      * Executes the PMD found in tempDir against the given sourceDirectory path with the given ruleset.\n-   98:      *\n-   99:      * @param tempDir the directory, to which the binary distribution has been extracted\n-  100:      * @param sourceDirectory the source directory, that PMD should analyze\n-  101:      * @param ruleset the ruleset, that PMD should execute\n-  102:      * @return collected result of the execution\n-  103:      * @throws Exception if the execution fails for any reason (executable not found, ...)\n-  104:      */\n-  105:     public static ExecutionResult runPMDRules(Path tempDir, String sourceDirectory, String ruleset) throws Exception {\n-  106:         Path reportFile = Files.createTempFile(\"pmd-it-report\", \"txt\");\n-  107:         reportFile.toFile().deleteOnExit();\n-  108: \n-  109:         if (SystemUtils.IS_OS_WINDOWS) {\n-  110:             return runPMDWindows(tempDir, reportFile, SOURCE_DIRECTORY_FLAG, sourceDirectory, RULESET_FLAG, ruleset,\n-  111:                     FORMAT_FLAG, FORMATTER, REPORTFILE_FLAG, reportFile.toAbsolutePath().toString());\n-  112:         } else {\n-  113:             return runPMDUnix(tempDir, reportFile, SOURCE_DIRECTORY_FLAG, sourceDirectory, RULESET_FLAG, ruleset,\n-  114:                     FORMAT_FLAG, FORMATTER, REPORTFILE_FLAG, reportFile.toAbsolutePath().toString());\n-  115:         }\n-  116:     }\n-  117: \n-  118:     /**\n-  119:      * Executes PMD found in tempDir with the given command line arguments.\n-  120:      * @param tempDir the directory, to which the binary distribution has been extracted\n-  121:      * @param arguments the arguments to execute PMD with\n+   96: \n+   97:     /**\n+   98:      * Executes the PMD found in tempDir against the given sourceDirectory path with the given ruleset.\n+   99:      *\n+  100:      * @param tempDir the directory, to which the binary distribution has been extracted\n+  101:      * @param sourceDirectory the source directory, that PMD should analyze\n+  102:      * @param ruleset the ruleset, that PMD should execute\n+  103:      * @return collected result of the execution\n+  104:      * @throws Exception if the execution fails for any reason (executable not found, ...)\n+  105:      */\n+  106:     public static ExecutionResult runPMDRules(Path tempDir, String sourceDirectory, String ruleset) throws Exception {\n+  107:         return runPMDRules(tempDir, sourceDirectory, ruleset, FORMATTER);\n+  108:     }\n+  109: \n+  110:     public static ExecutionResult runPMDRules(Path tempDir, String sourceDirectory, String ruleset, String formatter) throws Exception {\n+  111:         Path reportFile = Files.createTempFile(\"pmd-it-report\", \"txt\");\n+  112:         reportFile.toFile().deleteOnExit();\n+  113: \n+  114:         if (SystemUtils.IS_OS_WINDOWS) {\n+  115:             return runPMDWindows(tempDir, reportFile, SOURCE_DIRECTORY_FLAG, sourceDirectory, RULESET_FLAG, ruleset,\n+  116:                     FORMAT_FLAG, formatter, REPORTFILE_FLAG, reportFile.toAbsolutePath().toString());\n+  117:         } else {\n+  118:             return runPMDUnix(tempDir, reportFile, SOURCE_DIRECTORY_FLAG, sourceDirectory, RULESET_FLAG, ruleset,\n+  119:                     FORMAT_FLAG, formatter, REPORTFILE_FLAG, reportFile.toAbsolutePath().toString());\n+  120:         }\n+  121:     }\n", "uniqueId": "4cf9f5904ad76f13aecc2210a758168974657eb1_96_116_110_121_97_108", "moveFileExist": true, "testResult": true, "coverageInfo": {"testMethod": {"missed": 0, "covered": 1}}, "compileResultBefore": true, "compileResultCurrent": true, "compileJDK": 11, "refactoringMinerResult": false, "compileAndTestResult": true, "refactoredCode": "To improve the readability and maintainability of the `runPMDRules` method, we can extract the logic that constructs the command arguments into a separate method. This will make the `runPMDRules` method cleaner and more focused on its primary responsibility.\n\nHere\u2019s the refactored code:\n\n```java\n##########################\npublic static ExecutionResult runPMDRules(Path tempDir, String sourceDirectory, String ruleset) throws Exception {\n    Path reportFile = Files.createTempFile(\"pmd-it-report\", \"txt\");\n    reportFile.toFile().deleteOnExit();\n\n    List<String> arguments = buildPMDArguments(sourceDirectory, ruleset, reportFile);\n    \n    if (SystemUtils.IS_OS_WINDOWS) {\n        return runPMDWindows(tempDir, reportFile, arguments.toArray(new String[0]));\n    } else {\n        return runPMDUnix(tempDir, reportFile, arguments.toArray(new String[0]));\n    }\n}\n\nprivate static List<String> buildPMDArguments(String sourceDirectory, String ruleset, Path reportFile) {\n    List<String> arguments = new ArrayList<>();\n    arguments.add(SOURCE_DIRECTORY_FLAG);\n    arguments.add(sourceDirectory);\n    arguments.add(RULESET_FLAG);\n    arguments.add(ruleset);\n    arguments.add(FORMAT_FLAG);\n    arguments.add(FORMATTER);\n    arguments.add(REPORTFILE_FLAG);\n    arguments.add(reportFile.toAbsolutePath().toString());\n    return arguments;\n}\n##########################\n```\n\n### Explanation of Changes:\n1. **Extracted Method**: The logic for building the command line arguments for PMD has been extracted into a new method called `buildPMDArguments`. This method takes the `sourceDirectory`, `ruleset`, and `reportFile` as parameters and returns a list of arguments.\n2. **Simplified `runPMDRules`**: The `runPMDRules` method now focuses on creating the report file and determining the OS-specific execution method, making it easier to read and understand.\n3. **Use of `toArray`**: The arguments are converted to an array when passed to the `runPMDWindows` and `runPMDUnix` methods, maintaining the original functionality.\n\nThis refactoring enhances the modularity of the code and makes it easier to maintain and extend in the future.", "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to Refactor:\n/**\n     * Executes the PMD found in tempDir against the given sourceDirectory path with the given ruleset.\n     *\n     * @param tempDir the directory, to which the binary distribution has been extracted\n     * @param sourceDirectory the source directory, that PMD should analyze\n     * @param ruleset the ruleset, that PMD should execute\n     * @return collected result of the execution\n     * @throws Exception if the execution fails for any reason (executable not found, ...)\n     */\n    public static ExecutionResult runPMDRules(Path tempDir, String sourceDirectory, String ruleset) throws Exception {\n        Path reportFile = Files.createTempFile(\"pmd-it-report\", \"txt\");\n        reportFile.toFile().deleteOnExit();\n\n        if (SystemUtils.IS_OS_WINDOWS) {\n            return runPMDWindows(tempDir, reportFile, SOURCE_DIRECTORY_FLAG, sourceDirectory, RULESET_FLAG, ruleset,\n                    FORMAT_FLAG, FORMATTER, REPORTFILE_FLAG, reportFile.toAbsolutePath().toString());\n        } else {\n            return runPMDUnix(tempDir, reportFile, SOURCE_DIRECTORY_FLAG, sourceDirectory, RULESET_FLAG, ruleset,\n                    FORMAT_FLAG, FORMATTER, REPORTFILE_FLAG, reportFile.toAbsolutePath().toString());\n        }\n    }\n\nClass content:\n/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.it;\n\nimport java.io.IOException;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.concurrent.TimeUnit;\n\nimport org.apache.commons.io.IOUtils;\nimport org.apache.commons.lang3.SystemUtils;\n\nimport net.sourceforge.pmd.PMDVersion;\n\n/**\n * Executes PMD from command line. Deals with the differences, when PMD is run on Windows or on Linux.\n *\n * @author Andreas Dangel\n */\npublic class PMDExecutor {\n    private static final String PMD_BIN_PREFIX = \"pmd-bin-\";\n    private static final String SOURCE_DIRECTORY_FLAG = \"-d\";\n    private static final String RULESET_FLAG = \"-R\";\n    private static final String FORMAT_FLAG = \"-f\";\n    private static final String FORMATTER = \"text\";\n    private static final String REPORTFILE_FLAG = \"-r\";\n\n    private PMDExecutor() {\n        // this is a helper class only\n    }\n\n    private static ExecutionResult runPMDUnix(Path tempDir, Path reportFile, String ... arguments) throws Exception {\n        String cmd = tempDir.resolve(PMD_BIN_PREFIX + PMDVersion.VERSION + \"/bin/run.sh\").toAbsolutePath().toString();\n        List<String> args = new ArrayList<>();\n        args.add(\"pmd\");\n        args.addAll(Arrays.asList(arguments));\n        return runPMD(cmd, args, reportFile);\n    }\n\n    private static ExecutionResult runPMDWindows(Path tempDir, Path reportFile, String ... arguments) throws Exception {\n        String cmd = tempDir.resolve(PMD_BIN_PREFIX + PMDVersion.VERSION + \"/bin/pmd.bat\").toAbsolutePath().toString();\n        return runPMD(cmd, Arrays.asList(arguments), reportFile);\n    }\n\n    private static ExecutionResult runPMD(String cmd, List<String> arguments, Path reportFile) throws Exception {\n        ProcessBuilder pb = new ProcessBuilder(cmd);\n        pb.command().addAll(arguments);\n        pb.redirectErrorStream(false);\n        final Process process = pb.start();\n        final ExecutionResult.Builder result = new ExecutionResult.Builder();\n\n        Thread outputReader = new Thread(new Runnable() {\n            @Override\n            public void run() {\n                String output;\n                try {\n                    output = IOUtils.toString(process.getInputStream(), StandardCharsets.UTF_8);\n                    result.withOutput(output);\n                } catch (IOException e) {\n                    result.withOutput(\"Exception occurred: \" + e.toString());\n                }\n            }\n        });\n        outputReader.start();\n        Thread errorReader = new Thread(new Runnable() {\n            @Override\n            public void run() {\n                String error;\n                try {\n                    error = IOUtils.toString(process.getErrorStream(), StandardCharsets.UTF_8);\n                    result.withErrorOutput(error);\n                } catch (IOException e) {\n                    result.withErrorOutput(\"Exception occurred: \" + e.toString());\n                }\n            }\n        });\n        errorReader.start();\n\n        int exitCode = process.waitFor();\n        outputReader.join(TimeUnit.MINUTES.toMillis(5));\n        errorReader.join(TimeUnit.MINUTES.toMillis(5));\n\n        String report = null;\n        if (reportFile != null) {\n            report = IOUtils.toString(reportFile.toUri(), StandardCharsets.UTF_8);\n        }\n        return result.withExitCode(exitCode).withReport(report).build();\n    }\n\n    /**\n     * Executes the PMD found in tempDir against the given sourceDirectory path with the given ruleset.\n     *\n     * @param tempDir the directory, to which the binary distribution has been extracted\n     * @param sourceDirectory the source directory, that PMD should analyze\n     * @param ruleset the ruleset, that PMD should execute\n     * @return collected result of the execution\n     * @throws Exception if the execution fails for any reason (executable not found, ...)\n     */\n    public static ExecutionResult runPMDRules(Path tempDir, String sourceDirectory, String ruleset) throws Exception {\n        Path reportFile = Files.createTempFile(\"pmd-it-report\", \"txt\");\n        reportFile.toFile().deleteOnExit();\n\n        if (SystemUtils.IS_OS_WINDOWS) {\n            return runPMDWindows(tempDir, reportFile, SOURCE_DIRECTORY_FLAG, sourceDirectory, RULESET_FLAG, ruleset,\n                    FORMAT_FLAG, FORMATTER, REPORTFILE_FLAG, reportFile.toAbsolutePath().toString());\n        } else {\n            return runPMDUnix(tempDir, reportFile, SOURCE_DIRECTORY_FLAG, sourceDirectory, RULESET_FLAG, ruleset,\n                    FORMAT_FLAG, FORMATTER, REPORTFILE_FLAG, reportFile.toAbsolutePath().toString());\n        }\n    }\n\n    /**\n     * Executes PMD found in tempDir with the given command line arguments.\n     * @param tempDir the directory, to which the binary distribution has been extracted\n     * @param arguments the arguments to execute PMD with\n     * @return collected result of the execution\n     * @throws Exception if the execution fails for any reason (executable not found, ...)\n     */\n    public static ExecutionResult runPMD(Path tempDir, String ... arguments) throws Exception {\n        if (SystemUtils.IS_OS_WINDOWS) {\n            return runPMDWindows(tempDir, null, arguments);\n        } else {\n            return runPMDUnix(tempDir, null, arguments);\n        }\n    }\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n"}]